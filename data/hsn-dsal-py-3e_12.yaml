- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Selection Algorithms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择算法
- en: One interesting set of algorithms related to finding elements in an unordered
    list of items is selection algorithms. Given a list of elements, selection algorithms
    are used to find the `k`^(th) smallest or largest element from the list. So given
    a list of data elements and a number (`k`), the aim is to find the `k`^(th) smallest
    or largest element. The simplest case of selection algorithms is to find the minimum
    or maximum data element from the list. However, sometimes, we may need to find
    the `k`^(th) smallest or largest element in the list. The simplest way is to first
    sort the list using any sorting algorithm, and then we can easily obtain the `k`^(th)
    smallest (or largest) element. However, when the list is very large, then it is
    not efficient to sort the list to get the `k`^(th) smallest or largest element.
    In that case, we can use different selection algorithms that can efficiently produce
    the `k`^(th) smallest or largest element.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与在无序列表中查找元素相关的一组有趣的算法是选择算法。给定一个元素列表，选择算法用于从列表中找到第`k`个最小或最大的元素。因此，给定一个数据元素列表和一个数字（`k`），目标是找到第`k`个最小或最大的元素。选择算法的最简单情况是从列表中找到最小或最大的数据元素。然而，有时我们可能需要找到列表中的第`k`个最小或最大的元素。最简单的方法是首先使用任何排序算法对列表进行排序，然后我们可以轻松地获得第`k`个最小（或最大）的元素。然而，当列表非常大时，对列表进行排序以获取第`k`个最小或最大的元素可能不是高效的。在这种情况下，我们可以使用不同的选择算法，这些算法可以有效地产生第`k`个最小或最大的元素。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Selection by sorting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序选择
- en: Randomized selection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机选择
- en: Deterministic selection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定性选择
- en: We will start with the technical requirements, and then we will discuss selection
    by sorting.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从技术要求开始，然后讨论排序选择。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All of the source code that’s used in this chapter is provided in the given
    GitHub link: [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter12).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有源代码都提供在给定的GitHub链接中：[https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter12)。
- en: Selection by sorting
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序选择
- en: Items in a list may undergo statistical inquiries such as finding the mean,
    median, and mode values. Finding the mean and mode values does not require the
    list to be ordered. However, to find the median in a list of numbers, the list
    must first be ordered. Finding the median requires you to find the element in
    the middle position of the ordered list. In addition, this can be used when we
    want to find the `k`^(th) smallest item in the list. To find the `k`^(th) smallest
    number in an unordered list of items, an obvious method is to first sort the list,
    and after sorting, you can rest assured that the element at index 0 will hold
    the smallest element in the list. Likewise, the last element in the list will
    hold the largest element in the list.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的项目可能需要进行统计调查，例如找到均值、中位数和众数。找到均值和众数不需要列表是有序的。然而，要找到数字列表中的中位数，列表必须首先是有序的。找到中位数需要你找到有序列表中间位置的元素。此外，这也可以用于当我们想要找到列表中的第`k`个最小项目时。要找到无序列表中第`k`个最小的数字，一个明显的方法是首先对列表进行排序，排序后，你可以放心，列表中索引为0的元素将包含列表中的最小元素。同样，列表中的最后一个元素将包含列表中的最大元素。
- en: For more information on how to order data items within a list, see *Chapter
    11*, *Sorting*. However, in order to obtain a `k`^(th) smallest element from the
    list, it is not a good solution to apply a sorting algorithm to a long list of
    elements to obtain the minimum or maximum or `k`^(th) smallest or largest value
    from the list since sorting is quite an expensive operation. Thus, if we need
    to find out the `k`^(th) smallest or largest element from a given list, there
    is no need to sort the complete list as we have other methods that we can use
    for this purpose. Let’s discuss better techniques to find the `k`^(th) smallest
    element without having to sort the list in the first place, starting with randomized
    selection.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何在列表中排序数据项的更多信息，请参阅 *第 11 章*，*排序*。然而，为了从列表中获得第 `k` 个最小的元素，将排序算法应用于长列表元素以获得最小值、最大值或第
    `k` 个最小值或最大值并不是一个好的解决方案，因为排序是一个相当昂贵的操作。因此，如果我们需要从给定的列表中找出第 `k` 个最小或最大的元素，就没有必要对整个列表进行排序，因为我们有其他可以用于此目的的方法。让我们讨论更好的技术来找到第
    `k` 个最小的元素，而无需首先对列表进行排序，从随机选择开始。
- en: Randomized selection
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机选择
- en: 'The randomized selection algorithm is used to obtain the `k`^(th) smallest
    number that is based on the quicksort algorithm; the randomized selection algorithm
    is also known as quickselect. In *Chapter 11*, *Sorting*, we discussed the quicksort
    algorithm. The quicksort algorithm is an efficient algorithm to sort an unordered
    list of items. To summarize, the quicksort algorithm works as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随机选择算法是基于快速排序算法来获得第 `k` 个最小数的；随机选择算法也被称为快速选择。在 *第 11 章*，*排序* 中，我们讨论了快速排序算法。快速排序算法是一种高效的算法，用于对未排序的项目列表进行排序。总结来说，快速排序算法的工作原理如下：
- en: It selects a pivot.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它选择一个枢轴。
- en: It partitions the unsorted list around the pivot.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将未排序的列表围绕枢轴进行分区。
- en: It recursively sorts the two halves of the partitioned list using *steps 1*
    and *2.*
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它递归地使用步骤 *1* 和 *2* 对分区后的列表的两半进行排序。
- en: One important fact about quicksort is that after every partitioning step, the
    index of the pivot does not change, even after the list becomes sorted. This means
    that after each iteration, the selected pivot value will be placed in its correct
    position in the list. This property of quicksort enables us to obtain the `k`^(th)
    smallest number without sorting the complete list. Let’s discuss the randomized
    selection method, which is also known as the quickselect algorithm, to obtain
    the `k`^(th) smallest element from a list of n data items.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 关于快速排序的一个重要事实是，在每次分区步骤之后，枢轴的索引不会改变，即使列表已经排序。这意味着在每次迭代之后，选定的枢轴值将放置在列表中的正确位置。快速排序的这个特性使我们能够获得第
    `k` 个最小的数，而无需对整个列表进行排序。让我们讨论随机选择方法，也称为快速选择算法，以从包含 n 个数据项的列表中获得第 `k` 个最小的元素。
- en: Quickselect
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速选择
- en: The quickselect algorithm is used to obtain the `k`^(th) smallest element in
    an unordered list of items. It is based on the quicksort algorithm, in which we
    recursively sort the elements of both the sublists from the pivot point. In each
    iteration, the pivot value reaches the correct position in the list, which divides
    the list into two unordered sublists (left and right sublists), where the left
    sublist has smaller values as compared to the pivot value, and the right sublist
    has greater values compared to the pivot value. Now, in the case of the quickselect
    algorithm, we recursively call the function only for the sublist that has the
    `k`^(th) smallest element.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 快速选择算法用于从未排序的项目列表中获得第 `k` 个最小的元素。它基于快速排序算法，其中我们递归地对枢轴点两侧的子列表的元素进行排序。在每次迭代中，枢轴值达到列表中的正确位置，从而将列表分为两个未排序的子列表（左侧子列表和右侧子列表），其中左侧子列表的值小于枢轴值，而右侧子列表的值大于枢轴值。现在，在快速选择算法的情况下，我们只递归调用具有第
    `k` 个最小元素的子列表中的函数。
- en: 'In the quickselect algorithm, we compare the index of the pivot point with
    the `k` value to obtain the `k`^(th) smallest element from the given unordered
    list. There will be three cases in the quickselect algorithm, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在快速选择算法中，我们比较枢轴点的索引与 `k` 值，以从给定的未排序列表中获得第 `k` 个最小的元素。快速选择算法中将有三种情况，如下所示：
- en: If the index of the pivot point is smaller than `k`, then we are sure that the
    `k`^(th) smallest value will be present on the right-hand sublist of the pivot
    point. So we only recursively call the quickselect function for the right sublist.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果枢轴点的索引小于 `k`，那么我们可以确定第 `k` 个最小的值将出现在枢轴点的右侧子列表中。因此，我们只需递归地调用快速选择函数对右侧子列表进行操作。
- en: If the index of the pivot point is greater than `k`, then it is obvious that
    the `k`^(th) smallest element will be present on the left-hand side of the pivot
    point. So we only recursively look for the `i`^(th) element in the left sublist.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果枢轴点的索引大于`k`，那么很明显，第`k`小的元素将出现在枢轴点的左侧。因此，我们只需在左子列表中递归地查找第`i`个元素。
- en: If the index of the pivot point is equal to `k`, then it means that we have
    found out the `k`^(th) smallest value, and we return it.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果枢轴点的索引等于`k`，那么这意味着我们已经找到了第`k`小的值，并返回它。
- en: Let’s understand the working of the quickselect algorithm with an example. Consider
    a list of elements, `{45, 23, 87, 12, 72, 4, 54, 32, 52}`. We can use the quickselect
    algorithm to find the third smallest element in this list.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解quickselect算法的工作原理。考虑一个元素列表，`{45, 23, 87, 12, 72, 4, 54, 32, 52}`。我们可以使用quickselect算法来找到这个列表中的第3小的元素。
- en: We start the algorithm by selecting a pivot value, that is, `45`. Here we are
    choosing the first element as the pivot element for simplicity; however, any other
    element can be chosen as a pivot element. After the first iteration of the algorithm,
    the pivot value moves to its correct position in the list, which in this example
    is at index 4 (the index is starting from 0). Next, we check the condition `k<pivot`
    point (that is, `2<4`). Case- 2 is applicable, so we only consider the left sublist,
    and recursively call the function. Here, we compare the index of the pivot value
    (that is, `4`) with the value of `k` (that is, the 3^(rd) position or at index
    2).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始算法时选择一个枢轴值，即`45`。在这里，为了简单起见，我们选择第一个元素作为枢轴元素；然而，任何其他元素都可以被选为枢轴元素。在算法的第一轮迭代之后，枢轴值移动到列表中的正确位置，在这个例子中是索引4（索引从0开始）。接下来，我们检查条件`k<pivot`点（即`2<4`）。情况-2适用，所以我们只考虑左子列表，并递归调用函数。在这里，我们比较枢轴值的索引（即`4`）与`k`的值（即第3个位置或索引2）。
- en: Next, we take the left sublist and select the pivot point (that is, `4`). After
    the run, the `4` is placed in its correct position (that is, the 0^(th) index).
    As the index of the pivot is less than the value of `k`, we consider the right
    sublist.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们取左子列表并选择枢轴点（即`4`）。运行后，`4`被放置在其正确的位置（即第0个索引）。由于枢轴点的索引小于`k`的值，我们考虑右子列表。
- en: 'Similarly, we take `23` as the pivot point, which is also placed in its correct
    position. Now, when we compare the index of the pivot point and the value of `k`,
    they are equal, which means we have found the 3^(rd) smallest element, and it
    will be returned. The complete step-by-step process to find the 3^(rd) smallest
    element is shown in *Figure 12.1*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将`23`作为枢轴点，它也被放置在其正确的位置。现在，当我们比较枢轴点的索引和`k`的值时，它们是相等的，这意味着我们已经找到了第3小的元素，并且它将被返回。找到第3小元素的完整步骤过程如图*12.1*所示：
- en: '![](img/B17217_12_01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_12_01.png)'
- en: 'Figure 12.1: Step-by-step demonstration of the quickselect algorithm'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：quickselect算法的逐步演示
- en: 'Let’s discuss the implementation of the `quick_select` method. It is defined
    as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论`quick_select`方法的实现。它被定义为如下：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the above code, the `quick_select` function takes the complete array, the
    index of the first element of the list, the index of the last element, and the
    `k`^(th) element specified by value `k` as parameters. The value of `k` maps with
    the index that the user is searching for, meaning the `k`^(th) smallest number
    in the list.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，`quick_select`函数接受完整的数组、列表第一个元素的索引、最后一个元素的索引以及由值`k`指定的`k`个元素作为参数。`k`的值与用户要搜索的索引相对应，意味着列表中的第`k`小的数字。
- en: 'Initially, we use the `partition()` method (which is defined and discussed
    in detail in *Chapter 11*, *Sorting*) to place the selected pivot point in such
    a way that it divides the given list of elements in the left sublist and the right
    sublist, in which the left sublist has data elements that are smaller than the
    pivot value, and right subtree has data elements that are greater than the pivot
    value. The `partition()` method is called `split = partition(array_list, start,
    end)` and returns the `split` index. Here, the `split` index is the position where
    the pivot element is placed in the array, and (`start`, `end`) is the starting
    and ending indices of the list. Once we get the split point, we compare the `split`
    index with the required value of `k` to find out whether we have reached the position
    of the `k`^(th) smallest data item or whether the required `k`^(th) smallest element
    will be on the left sublist or the right sublist. These three conditions are as
    follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`partition()`方法（该方法在*第11章*，*排序*中定义并详细讨论）将选定的枢轴点放置在适当的位置，以便将给定的元素列表分割成左子列表和右子列表，其中左子列表包含小于枢轴值的元素，而右子列表包含大于枢轴值的元素。`partition()`方法调用为`split
    = partition(array_list, start, end)`，并返回`split`索引。在这里，`split`索引是枢轴元素在数组中的位置，而(`start`,
    `end`)是列表的起始和结束索引。一旦我们得到分割点，我们就比较`split`索引与所需的`k`值，以确定我们是否已经到达了第k小数据项的位置，或者所需的第k小元素是否将在左子列表或右子列表中。这三个条件如下：
- en: If the `split` is equal to the value of `k`, then it means that we have reached
    the `k`^(th) smallest data item in the list.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`split`等于`k`的值，那么这意味着我们已经到达了列表中的第k小数据项。
- en: If the `split` is less than `k`, then it means that the `k`^(th) smallest item
    should exist or be found between `split+1` and `right`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`split`小于`k`，那么这意味着第k小的元素应该存在于`split+1`和`right`之间。
- en: If the `split` is greater than `k`, then it means that the `k`^(th) smallest
    item should exist or be found between `left` and `split-1`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`split`大于`k`，那么这意味着第k小的元素应该存在于`left`和`split-1`之间。
- en: In the preceding example, a split point occurs at index 4 (index starting from
    0). If we are searching for the 3^(rd) smallest number, then since 4 < 2 yields
    `false`, a recursive call to the right sublist is made using `quick_select(array_list,
    left, split-1, k)`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，分割点出现在索引4（索引从0开始）。如果我们正在寻找第3小的数字，那么由于4 < 2的结果为`false`，就会对右子列表进行递归调用，使用`quick_select(array_list,
    left, split-1, k)`。
- en: 'Here, for the completeness of this algorithm, the `partition()` method is given
    as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此算法完整，下面给出了`partition()`方法的实现：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of the above code is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the above code, we get the 2^(nd) and 3^(rd) smallest elements from the given
    list of elements. The worst-case performance of a randomized selection-based `quick-select`
    algorithm is O(n²).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们从给定的元素列表中获取第2小和第3小的元素。基于随机选择的`quick-select`算法的最坏情况性能是O(n²)。
- en: In the above implementation of the `partition()` method, we use the first element
    of the list as the pivot element for simplicity, but any element can be chosen
    from the list as the pivot element. A good pivot element is one that divides the
    list into almost equal halves. Therefore, it is possible to improve the performance
    of the quickselect algorithm by selecting the split point more efficiently in
    linear time with the worst-case complexity of `O(n)`. We discuss how to do this
    in the next section using deterministic selection.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述`partition()`方法的实现中，为了简单起见，我们使用列表的第一个元素作为枢轴元素，但可以从列表中选择任何元素作为枢轴元素。一个好的枢轴元素是能够将列表几乎平分的元素。因此，通过更有效地选择分割点，可以在线性时间内提高快速选择算法的性能，其最坏情况复杂度为`O(n)`。我们将在下一节中讨论如何使用确定性选择来实现这一点。
- en: Deterministic selection
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定性选择
- en: Deterministic selection is an algorithm for finding out the `k`^(th) item in
    an unordered list of elements. As we have seen in the `quickselect` algorithm,
    we select a random “pivot” element that partitions the list into two sublists
    and calls itself recursively for one of the two sublists. In a deterministic selection
    algorithm, we choose a pivot element more efficiently instead of taking any random
    pivot element.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性选择是一种在无序元素列表中查找第k项的算法。正如我们在`quickselect`算法中所见，我们选择一个随机的“枢轴”元素，将列表分割成两个子列表，并对其中一个子列表进行递归调用。在确定性选择算法中，我们更有效地选择枢轴元素，而不是随机选择任何枢轴元素。
- en: The main concept of the deterministic algorithm is to select a pivot element
    that produces a good split of the list, and a good split is one that divides the
    list into two halves. For instance, a good way to select a pivot element would
    be to choose the median of all the values. But we will need to sort the elements
    in order to find out the median element, which is not efficient, so instead, we
    try to find a way to select a pivot element that divides the list roughly in the
    middle.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性算法的主要概念是选择一个能产生良好列表分割的枢轴元素，良好的分割是将列表分成两半。例如，选择枢轴元素的一个好方法就是选择所有值的均值。但是，我们需要对元素进行排序以找到中值元素，这并不高效，因此，我们尝试找到一种方法来选择一个大致将列表分成中间的枢轴元素。
- en: The median of medians is a method that provides us with the approximate median
    value, that is, a value close to the actual median for a given unsorted list of
    elements. It divides the given list of elements in such a way that in the worst
    case, at least 3 out of 10 (3/10) of the list will be below the pivot element,
    and at least 3 out of 10 of the elements will be above the list.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 均值的中位数是一种提供给我们近似中值的方法，即一个接近给定未排序元素列表实际中值的价值。它以这种方式划分给定的元素列表，在最坏的情况下，至少有10个中的3个（3/10）的列表将位于枢轴元素之下，至少有10个中的3个的元素将位于列表之上。
- en: 'Let’s take an example to understand this. Let’s say we have a list of 15 elements:
    `{11, 13, 12, 111, 110, 15, 14, 16, 113, 112, 19, 18, 17, 114, 115}`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解这一点。假设我们有一个包含15个元素的列表：`{11, 13, 12, 111, 110, 15, 14, 16, 113, 112,
    19, 18, 17, 114, 115}`。
- en: 'Next, we divide it into groups of 5 elements and sort them as follows: `{{11,
    12, 13, 110, 111}, {14, 15, 16, 112, 113}, {17, 18, 19, 114, 115}}`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将它分成每组5个元素的组，并按以下方式排序：`{{11, 12, 13, 110, 111}, {14, 15, 16, 112, 113},
    {17, 18, 19, 114, 115}}`。
- en: Next, we compute the median of each of these groups, and they are `13`, `16`,
    and `19`, respectively. Further, the median of these median values `{13, 16, 19}`
    is `16`. This is the median of medians for the given list. Here, we can see that
    5 elements are smaller, and `9` elements are greater than the pivot element. When
    we select this median of the median as a pivot element, the list of `n` elements
    is divided in such a way that at least `3n/10` elements are smaller than the pivot
    element.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算这些组中每一组的均值，分别是`13`、`16`和`19`。进一步，这些均值的中位数是`16`。这是给定列表的中位数的中位数。在这里，我们可以看到有5个元素比枢轴元素小，有`9`个元素比枢轴元素大。当我们选择这个均值的中位数作为枢轴元素时，`n`个元素的列表被分成这样的一种方式，至少有`3n/10`个元素比枢轴元素小。
- en: 'The deterministic algorithm to select the `k`^(th) smallest element works as
    follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 选择第`k`个最小元素的确定性算法工作如下：
- en: Split the list of unordered items into groups of five elements each (the number
    5 is not mandatory; it can be changed to any other number, for example, 8)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将无序项的列表分成每组五个元素（数字5不是强制的；它可以改为任何其他数字，例如8）
- en: Sort these groups (in general, we use insertion sort for this purpose) and find
    the median of all these groups
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对这些组进行排序（通常，我们使用插入排序来完成此目的）并找到所有这些组的均值
- en: Recursively, find the median of the medians obtained from these groups; let’s
    say that is point **p**
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归地，从这些组中找到中位数的中位数；假设这个点是**p**
- en: Using this point **p** as the pivot element, recursively call the partition
    algorithm similar to quickselect to find out the `k`^(th) smallest element
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个点**p**作为枢轴元素，递归调用类似于quickselect的分区算法来找出第`k`个最小的元素
- en: Let’s consider an example list of 15 elements to understand the working of the
    deterministic algorithm to find out the 3^(rd) smallest element from the list,
    as shown in *Figure 12.2*. First, we divide the list into groups of 5 elements
    each, and then we sort these groups/sublists. Once we have sorted the lists, we
    find out the median of the sublists. For this example, items **23**, **52**, and
    **34** are the medians of these three sublists, as shown in *Figure 12.2*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个包含15个元素的例子来理解从列表中找出第3个最小元素的确定性算法的工作原理，如图*12.2*所示。首先，我们将列表分成每组5个元素的组，然后对这些组/子列表进行排序。一旦我们有了排序的列表，我们就找出子列表的均值。对于这个例子，项目**23**、**52**和**34**是这三个子列表的均值，如图*12.2*所示。
- en: Next, we sort the list of medians for all the sublists. Further, we find out
    the median of this list, that is, the median of the median, which is **34**. This
    median of medians is used to select the partition/pivot point for the whole list.
    Further, we divide the given list using this pivot element to partition the list
    into 2 sublists, placing the given pivot element at its correct position in the
    list. For this example, the index of the pivot element is 7 (index starting from
    0; this is shown in *Figure 12.2.*).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们对所有子列表的中位数列表进行排序。进一步地，我们找出这个列表的中位数，即中位数的中位数，它是**34**。这个中位数的中位数被用来选择整个列表的分区/枢轴点。进一步地，我们使用这个枢轴元素来划分给定的列表，将枢轴元素放在列表中的正确位置。对于这个例子，枢轴元素的索引是7（索引从0开始；这显示在*图12.2.*中）。
- en: '![](img/B17217_12_02.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_12_02.png)'
- en: 'Figure 12.2: Step-by-step procedure for the deterministic selection algorithm'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：确定性选择算法的逐步过程
- en: The index of the pivot element is greater than the `k`^(th) value, and hence,
    we recursively call the algorithm on the left sublist to obtain the required `k`^(th)
    smallest element.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 枢轴元素的索引大于`k`^(th)值，因此我们递归地在左子列表上调用算法以获得所需的`k`^(th)最小元素。
- en: Next, we will discuss the implementation of the deterministic selection algorithm.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论确定性选择算法的实现。
- en: Implementation of the deterministic selection algorithm
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定性选择算法的实现
- en: 'To implement the deterministic algorithm for determining the `k`^(th) smallest
    value from the list, we start implementing the updated `partition()` method, which
    divides the list where we select the pivot element using the median of medians
    method. Let’s now understand the code for the `partition` function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现确定算法以从列表中确定`k`^(th)最小值，我们开始实现更新的`partition()`方法，该方法使用中位数的中位数方法选择枢轴元素来划分列表。现在让我们理解`partition`函数的代码：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the above code, we implement the partition method, which is very similar
    to what we did in the quickselect algorithm. In the quickselect algorithm, we
    used a random pivot element (for simplicity, the first element of the list), but
    in the deterministic selection algorithm, we select the pivot element using the
    median of medians. The partition method divides the list into two sublists – the
    left and right sublists, in which the left sublist has elements that are smaller
    than the pivot element, and the right sublist has elements that are greater than
    the pivot element. The main benefit of using the pivot element with the median
    of medians is that it, in general, divides the list into almost two halves.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们实现了分区方法，这与我们在quickselect算法中所做的方法非常相似。在quickselect算法中，我们使用了一个随机枢轴元素（为了简单起见，列表的第一个元素），但在确定性选择算法中，我们使用中位数的中位数来选择枢轴元素。分区方法将列表划分为两个子列表——左子列表和右子列表，其中左子列表包含小于枢轴元素的元素，而右子列表包含大于枢轴元素的元素。使用中位数的中位数作为枢轴元素的主要好处是，它通常将列表几乎平分为两半。
- en: At the start of the code, firstly, in the `if-else` condition, we check the
    length of the given list of elements. If the length of the list is 1, then we
    return the index of that element, so if the `unsorted_array` has only one element,
    `first_index` and `last_index` will be equal. Therefore, `first_index` is returned.
    And, if the length is greater than 1, then we call the `median_of_medians()` method
    to compute the median of medians of the list passed to this method with the starting
    and ending indices as `first_index` and `last_index`. The return median of medians
    value is stored in the `nearest_median` variable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的开始部分，首先，在`if-else`条件中，我们检查给定元素列表的长度。如果列表的长度为1，则返回该元素的索引，因此如果`unsorted_array`只有一个元素，`first_index`和`last_index`将相等。因此，返回`first_index`。如果长度大于1，则调用`median_of_medians()`方法来计算传递给此方法的列表的中位数的中位数，起始和结束索引分别为`first_index`和`last_index`。返回的中位数的中位数值存储在`nearest_median`变量中。
- en: 'Now, let’s understand the code of the `median_of_medians()` method. It is given
    as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们理解`median_of_medians()`方法的代码。它如下所示：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the above code of the `median_of_medians` function, recursion is used to
    compute the median of medians for the given list. The function begins by splitting
    the given list, `elems`, into groups of five elements each. As discussed earlier
    in the deterministic algorithm, we divide the given list into groups of 5 elements.
    Here, we choose 5 elements since it mostly performs well. However, we could have
    used any other number as well. This means that if `elems` contains 100 items,
    there will be 20 groups that are created by the `sublists = [elems[j:j+5] for
    j in range(0, len(elems), 5)]` statement, with each containing a maximum of five
    elements.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述 `median_of_medians` 函数的代码中，使用了递归来计算给定列表的中位数的中位数。函数首先将给定的列表 `elems` 分成每组五个元素的组。如前所述，在确定性算法中，我们将给定的列表分成每组
    5 个元素的组。在这里，我们选择 5 个元素，因为它通常表现良好。然而，我们也可以使用任何其他数字。这意味着如果 `elems` 包含 100 个项目，那么将通过
    `sublists = [elems[j:j+5] for j in range(0, len(elems), 5)]` 语句创建 20 个组，每个组最多包含五个元素。
- en: After creating sublists of five elements each, we create an empty array, `medians`,
    that stores the medians of each of the five-element arrays (i.e., `sublists`).
    Further, the `for` loop iterates over the list of lists inside `sublists`. Each
    sublist is sorted, the median is found, and it is stored in the `medians` list.
    The `medians.append(sorted(sublist)[len(sublist)//2])` statement will sort the
    list and obtain the element stored in its middle index. The `medians` variable
    becomes the median list of all the sublists of which there are five elements in
    each sublist. In this implementation, we use an existing sorting function of Python;
    it will not impact the performance of the algorithm due to the list’s small size.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了每个包含五个元素的子列表之后，我们创建一个空的数组 `medians`，用于存储每个五个元素数组的（即 `sublists`）中位数。此外，`for`
    循环遍历 `sublists` 内部的列表。每个子列表被排序，找到中位数，并将其存储在 `medians` 列表中。`medians.append(sorted(sublist)[len(sublist)//2])`
    语句将排序列表并获取其中间索引处的元素。`medians` 变量成为所有五个元素子列表的中位数列表。在这个实现中，我们使用 Python 的现有排序函数；由于列表的大小很小，它不会影响算法的性能。
- en: Thereafter, the next step is to recursively compute the median of medians, which
    we will use as a pivot element. It is important to note here that the length of
    the median array can itself be a large array because if the original length of
    the array is n, then the length of the median array will be n/5, and sorting this
    may be time-consuming in itself. Hence, we check the length of the `medians` array,
    and if it is less than 5, we sort the `medians` list and return the element located
    in its middle index. If, on the other hand, the size of the list is greater than
    five, we recursively call the `median_of_medians` function again, supplying it
    with the list of the medians stored in `medians`. Finally, the function returns
    the median of medians of the given list of elements.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，下一步是递归地计算中位数的中位数，我们将使用它作为枢轴元素。在此需要注意的是，中位数数组的长度本身也可以是一个大数组，因为如果原始数组的长度是 n，那么中位数数组的长度将是
    n/5，对它的排序可能本身就会消耗时间。因此，我们检查 `medians` 数组的长度，如果它小于 5，我们就对 `medians` 列表进行排序，并返回其中间索引处的元素。另一方面，如果列表的大小大于五，我们再次递归调用
    `median_of_medians` 函数，并给它提供存储在 `medians` 中的中位数列表。最后，该函数返回给定元素列表的中位数的中位数。
- en: 'Let’s take another example to better understand the concept of the median of
    medians with the following list of numbers:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下数字列表的另一个例子来更好地理解中位数的中位数的概念：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can break this list down into groups of five elements, each with the `sublists
    = [elems[j:j+5] for j in range(0, len(elems), 5)]` code statement, in order to
    obtain the following list:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下 `sublists = [elems[j:j+5] for j in range(0, len(elems), 5)]` 代码语句将这个列表分解成五个元素的组，以获得以下列表：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Each of the five-element lists will be sorted as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每个五个元素的列表将按以下方式排序：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we obtain their medians to produce the following list:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们获取它们的平均值，生成以下列表：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We sort the above list:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对上述列表进行排序：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since the list is five elements in size, we only return the median of the sorted
    list, which is `12` in this case. Otherwise, if the length of this array had been
    greater than 5, we would have made another call to the `median_of_median` function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表大小为五个元素，我们只需返回排序后的列表的中位数，在这种情况下是 `12`。否则，如果这个数组的长度大于 5，我们就会再次调用 `median_of_median`
    函数。
- en: 'Once we have the median of the median value, we need to find out its index
    in the given list. We write the `get_index_of_nearest_median` function for this
    purpose. This function takes the starting and ending indices of the list indicated
    by the `first` and `last` parameters:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到了中位数的中位数值，我们需要找出它在给定列表中的索引。我们编写 `get_index_of_nearest_median` 函数来完成这个目的。此函数接受由
    `first` 和 `last` 参数指定的列表的起始和结束索引：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next in the partition method, we swap the median of medians value with the
    first element of the list, that is, we swap `index_of_nearest_median` with `first_index`
    of the `unsorted_array` using the `swap` function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在分区方法中，我们将中位数的中位数值与列表的第一个元素交换，即使用 `swap` 函数将 `index_of_nearest_median` 与 `unsorted_array`
    的 `first_index` 交换：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `utility` function to swap two array elements is shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 交换两个数组元素的 `utility` 函数如下所示：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We swap these two elements. The rest of the implementation is quite similar
    to what we discussed in the `quick_select` algorithm. Now, we have the median
    of the median for the given list, which is stored in `first_index` of the unsorted
    list.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们交换这两个元素。其余的实现与我们在 `quick_select` 算法中讨论的相当相似。现在，我们得到了给定列表的中位数的中位数，它存储在未排序列表的
    `first_index` 中。
- en: Now, the rest of the implementation is similar to the partition method of the
    `quick_select` algorithm and also the quicksort algorithm, which is discussed
    in detail in *Chapter 11*, *Sorting*. For the completeness of the algorithm here,
    we discuss this again.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，其余的实现与 `quick_select` 算法的分区方法以及快速排序算法相似，这在 *第11章*，*排序* 中有详细讨论。为了算法的完整性，我们再次讨论这个问题。
- en: 'We consider the first element as a pivot element, and we take two pointers,
    that is, left and right. The left pointer moves from the left to the right direction
    in the list to keep elements that are smaller than the pivot element on the left
    hand side of the pivot element. It is initialized with the second element of the
    list, that is, `first_index+1`, whereas the right pointer moved from the right
    to the left direction, which maintains the list in a way that elements greater
    than the pivot element are on the right-hand side of the pivot element in the
    list. It is initialized with the last element of the list. So we have two variables
    `less_than_pivot_index` (the right pointer) and `greater_than_pivot_index` (the
    left pointer) in which `less_than_pivot_index` is initialized with `index_of_last_element`
    and `greater_than_pivot_index` with `first_index + 1`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将第一个元素视为枢轴元素，并取两个指针，即左指针和右指针。左指针从列表的左侧向右移动，以保持枢轴元素左侧的所有小于枢轴元素的元素。它初始化为列表的第二个元素，即
    `first_index+1`，而右指针从列表的右侧向左移动，以保持列表的顺序，使得大于枢轴元素的元素位于列表的枢轴元素右侧。它初始化为列表的最后一个元素。因此，我们有两个变量
    `less_than_pivot_index`（右指针）和 `greater_than_pivot_index`（左指针），其中 `less_than_pivot_index`
    初始化为 `index_of_last_element`，`greater_than_pivot_index` 初始化为 `first_index + 1`：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we move the left and right pointers in such a way that after one iteration,
    the pivot element is placed in its correct position in the list. That means it
    divides the list into two sublists such that the left sublist has all the elements
    that are smaller than the pivot element, and the right sublist has elements greater
    than the pivot element. We do this with these three steps given below:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们移动左指针和右指针，以便在经过一次迭代后，枢轴元素被放置在列表中的正确位置。这意味着它将列表分为两个子列表，左子列表包含所有小于枢轴元素的元素，右子列表包含大于枢轴元素的元素。我们通过以下三个步骤来完成这个操作：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first while loop will move `greater_than_pivot_index` to the right side
    of the array until the element pointed out by `greater_than_pivot_index` is less
    than the pivot element and `greater_than_pivot_index` is less than `last_index`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个 `while` 循环将 `greater_than_pivot_index` 移到数组的右侧，直到 `greater_than_pivot_index`
    所指向的元素小于枢轴元素，并且 `greater_than_pivot_index` 小于 `last_index`：
- en: '[PRE16]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the second `while` loop, we’ll be doing the same thing but for the `less_than_pivot_index`
    in the array. We’ll move `less_than_pivot_index` to the left direction until the
    element pointed out by `less_than_pivot_index` is greater than the pivot element
    and `less_than_pivot_index` is greater than or equal to `first_index`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个 `while` 循环中，我们将对数组中的 `less_than_pivot_index` 执行相同操作。我们将 `less_than_pivot_index`
    向左移动，直到 `less_than_pivot_index` 所指向的元素大于枢轴元素，并且 `less_than_pivot_index` 大于或等于
    `first_index`：
- en: '[PRE17]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we check if `greater_than_pivot_index` and `less_than_pivot_index` have
    crossed each other or not. If `greater_than_pivot_index` is still less than `less_than_pivot_index`
    (that is, we have not found the correct position for the pivot element yet), we
    swap the elements indicated by `greater_than_pivot_index` and `less_than_pivot_index`,
    and then we will repeat the same three steps again. If they have crossed each
    other, that means we have found the correct position for the pivot element, and
    we will break from the loop:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们检查`greater_than_pivot_index`和`less_than_pivot_index`是否已经交叉或没有。如果`greater_than_pivot_index`仍然小于`less_than_pivot_index`（即我们还没有找到枢轴元素的正确位置），我们交换由`greater_than_pivot_index`和`less_than_pivot_index`指示的元素，然后我们将再次重复相同的三个步骤。如果它们已经交叉，这意味着我们已经找到了枢轴元素的正确位置，我们将从循环中跳出：
- en: '[PRE18]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After exiting the loop, the variable `less_than_pivot_index` will point to
    the correct index of the pivot, so we will just swap the values that are present
    at `less_than_pivot_index` and `pivot_index`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在退出循环后，变量`less_than_pivot_index`将指向枢轴的正确索引，因此我们只需交换`less_than_pivot_index`和`pivot_index`处的值：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Finally, we will simply return the pivot index, which is stored in the variable
    `less_than_pivot_index`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需简单地返回枢轴索引，它存储在变量`less_than_pivot_index`中。
- en: After the partition method, the pivot element reaches its correct position in
    the list. Thereafter, we recursively call the partition method to one of the sublists
    (the left sublist or the right sublist) depending on the required value of `k`
    and the pivot element position to find out the `k`^(th) smallest element. This
    process is the same as the quickselect algorithm.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在分割方法之后，枢轴元素达到其在列表中的正确位置。此后，我们根据所需的`k`值和枢轴元素的位置递归调用分割方法到子列表之一（左子列表或右子列表），以找到`k`^(th)最小元素。这个过程与快速选择算法相同。
- en: 'The implementation of the deterministic select algorithm is given as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性选择算法的实现如下：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you may have observed, the implementation of the deterministic selection
    algorithm looks exactly the same as the quickselect algorithm. The only difference
    between the two is how we select the pivot element; apart from that, everything
    is the same.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所观察到的，确定性选择算法的实现看起来与快速选择算法完全相同。两者之间的唯一区别是我们如何选择枢轴元素；除此之外，一切相同。
- en: 'After the initial `array_list` has been partitioned by the selected pivot element,
    which is the median of medians of the list, a comparison with the `k`^(th) element
    is made:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始`array_list`被选定的枢轴元素（即列表的中位数的中位数）分割后，与`k`^(th)元素进行比较：
- en: If the index of the split point, that is, `split`, is equal to the required
    value of `k`, it means that we have found the required `k`^(th) smallest element.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果分割点的索引，即`split`，等于`k`所需的值，这意味着我们已经找到了所需的`k`^(th)最小元素。
- en: If the index of the split point, the, `split` is less than the required value
    of `k`, then a recursive call to the right sublist is made as `deterministic_select(array_list,
    split + 1, right, k)`. This will look for the `k`^(th) element on the right-hand
    side of the array.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果分割点的索引`split`小于`k`所需的值，那么对右子数组进行递归调用，调用为`deterministic_select(array_list,
    split + 1, right, k)`。这将寻找数组右侧的`k`^(th)元素。
- en: Otherwise, if the split index is greater than the value of k, then the function
    call to the left sublist is made as `deterministic_select(array_list, left, split-1,
    k)`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果分割索引大于`k`的值，那么对左子数组的函数调用为`deterministic_select(array_list, left, split-1,
    k)`。
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The output of the above code is as follows.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下。
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the output of the above code, we have the 6^(th) smallest element from a
    given list of 25 elements. The deterministic selection algorithm improves the
    quickselect algorithm by using the median of medians element as a pivot point
    for selecting the `k`^(th) smallest element from a list. It improves performance
    because the median of medians method finds out the estimated median in linear
    time, and when this estimated median is used as a pivot point in the quickselect
    algorithm, the worst-case running time’s complexity improves from O(n²) to the
    linear O(n).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码的输出中，我们有从给定25个元素的列表中得到的第6^(th)小元素。确定性选择算法通过使用中位数的中位数元素作为选择列表中`k`^(th)最小元素的枢轴点来改进快速选择算法。它提高了性能，因为中位数的中位数方法在线性时间内找到估计的中位数，当这个估计的中位数被用作快速选择算法中的枢轴点时，最坏情况下的运行时间复杂度从O(n²)提高到线性O(n)。
- en: The median of medians algorithm can also be used to choose a pivot point in
    the quicksort algorithm for sorting a list of elements. This significantly improves
    the worst-case performance of the quicksort algorithm from O(n²) to a complexity
    of O(nlogn).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 中位数的中位数算法也可以用于在快速排序算法中选择枢轴点以排序元素列表。这显著提高了快速排序算法的最坏情况性能，从 O(n²) 提高到 O(nlogn)
    的复杂度。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed two important methods to find the k^(th) smallest
    element in a list, randomized selection and deterministic selection algorithms.
    The simple solution of merely sorting a list to perform the operation of finding
    the k^(th) smallest element is not optimal as we can use better methods to determine
    the k^(th) smallest element. The quickselect algorithm, which is the random selection
    algorithm, divides the list into two sublists. One list has smaller values, and
    the other list has greater values as compared to the selected pivot element. We
    reclusively use one of the sublists to find the location of the k^(th) smallest
    element, which can be further improved by selecting the pivot point using the
    median of medians method in the deterministic selection algorithm.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了两种寻找列表中第 k 小元素的重要方法，即随机选择和确定性选择算法。仅仅对列表进行排序以执行寻找第 k 小元素的运算并不是最佳方案，因为我们可以使用更好的方法来确定第
    k 小元素。快速选择算法，作为随机选择算法，将列表分为两个子列表。一个列表包含比选定的枢轴元素小的值，另一个列表包含比选定的枢轴元素大的值。我们递归地使用其中一个子列表来找到第
    k 小元素的位置，这可以通过在确定性选择算法中使用中位数的中位数方法来选择枢轴点进一步改进。
- en: In the next chapter, we will discuss several important string matching algorithms.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论几个重要的字符串匹配算法。
- en: Exercise
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: What will be the output if the quickselect algorithm is applied to the given
    array
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果将快速选择算法应用于给定的数组，输出将会是什么？
- en: '`arr = [3, 1, 10, 4, 6, 5]` with `k` given as 2?'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`arr = [3, 1, 10, 4, 6, 5]`，给定 `k` 为 2？'
- en: Can quickselect find the smallest element in an array with duplicate values?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速选择能否在具有重复值的数组中找到最小元素？
- en: What is the difference between the quicksort algorithm and the quickselect algorithm?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速排序算法与快速选择算法之间的区别是什么？
- en: What is the main difference between the deterministic selection algorithm and
    the quickselect algorithm?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定性选择算法与快速选择算法的主要区别是什么？
- en: What triggers the worst-case behavior of the selection algorithm?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么触发了选择算法的最坏情况行为？
- en: Join our community on Discord
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/MEvK4](https://packt.link/MEvK4)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间，与作者和其他读者进行讨论：[https://packt.link/MEvK4](https://packt.link/MEvK4)
- en: '![](img/QR_Code1421249772551223062.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1421249772551223062.png)'
