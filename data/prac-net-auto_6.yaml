- en: Continuous Integration for Network Engineers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络工程师的持续集成
- en: As we saw in previous chapters, now armed with knowledge or a fair understanding
    on creating automation using various techniques, working with Ansible, and understanding
    best practices, we continue our journey to understand how to work on the basics
    of planning an automation project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，现在我们已具备使用各种技术创建自动化、使用Ansible以及理解最佳实践的知识或相当的了解，我们继续我们的旅程，了解如何进行自动化项目的基本规划。
- en: In this chapter, we will see some of the tools that help us in working on planning
    our automation projects, and some examples to interact with some increasingly
    complex scenarios related to various devices or network technologies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到一些帮助我们规划自动化项目的工具，以及一些与各种设备或网络技术相关的日益复杂的场景的交互示例。
- en: 'Some of the aspects that we will be working on are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将工作的某些方面包括：
- en: Interaction with Splunk
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Splunk的交互
- en: BGP and routing table
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BGP和路由表
- en: Wireless client to AP to switchport
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无线客户端到AP到交换端口
- en: Phone to switchport
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话到交换端口
- en: WLAN and IPAM
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WLAN和IPAM
- en: Useful best practices and use cases
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用的最佳实践和用例
- en: Interaction with Splunk
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Splunk的交互
- en: '**Splunk** is one of the most widely used data mining tools. With its data
    mining and digging capabilities, engineers can take actions based upon decisions.
    While it is useful in various aspects, here we will see an example of Splunk being
    used as a Syslog server, with our test router sending a message (as syslog) to
    this server, and how from automation we can query results from Splunk for these
    syslogs and take actions.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**Splunk** 是最广泛使用的数据挖掘工具之一。凭借其数据挖掘和挖掘能力，工程师可以根据决策采取行动。虽然它在各个方面都很有用，但在这里我们将看到一个Splunk作为Syslog服务器使用的例子，我们的测试路由器向该服务器发送消息（作为syslog），以及我们如何从自动化中查询Splunk的这些syslogs并采取行动。'
- en: This is an important part of automation, since based upon certain events (alerts
    and syslogs), engineers need to perform automated tasks, like self healing, or
    even triggering emails or using third-party tools to create tickets for various
    teams to work on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是自动化过程中的一个重要部分，因为基于某些事件（警报和syslogs），工程师需要执行自动化任务，如自我修复，甚至触发电子邮件或使用第三方工具为各个团队创建工单。
- en: 'Here we will see the basic implementation and configuration of Splunk as a
    Syslog server:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到Splunk作为Syslog服务器的基本实现和配置：
- en: 'After downloading and installing Splunk , it can be accessed from the URL `http://localhost:8000/en-US/account/login?return_to=%2Fen-US%2F` as
    we can see in the following screenshot:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并安装Splunk后，可以通过以下URL访问它：`http://localhost:8000/en-US/account/login?return_to=%2Fen-US%2F`，如下截图所示：
- en: '![](img/6189c067-0a4c-4106-975c-4c5bd66d2d42.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6189c067-0a4c-4106-975c-4c5bd66d2d42.jpg)'
- en: 'Once we login, we create a listener listed to syslogs (in our case we use the
    `TCP` protocol and keep the default port `514` open):'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，我们创建一个监听syslogs的监听器（在我们的案例中我们使用`TCP`协议并保持默认端口`514`开放）：
- en: '![](img/48cc657b-392a-4a50-b50b-72a47dab1d87.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48cc657b-392a-4a50-b50b-72a47dab1d87.jpg)'
- en: Once the configuration is done for TCP port `514` on Splunk (listening for syslog
    messages), ensure any local firewall on the server is allowing inbound packets
    to TCP port `514`, and our machine is ready to access syslogs from network devices
    on TCP port `514`).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Splunk上完成TCP端口`514`的配置（监听syslog消息）后，确保服务器上的任何本地防火墙都允许TCP端口`514`的入站数据包，并且我们的机器已准备好从网络设备通过TCP端口`514`访问syslogs。
- en: 'Configure the router to send syslogs. We apply the following commands on the
    router to enable logging (In our case the IP for the Syslog server is `192.168.255.250`):'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置路由器发送syslogs。我们在路由器上应用以下命令以启用日志记录（在我们的案例中，Syslog服务器的IP地址为`192.168.255.250`）：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This configures the router to send syslogs to the given IP address on TCP protocol
    over port `514`. Additionally, we are also stating to log only information syslog
    messages on the router.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这配置了路由器将syslogs发送到指定IP地址，通过TCP协议在端口`514`上。此外，我们还在路由器上声明仅记录信息syslog消息。
- en: 'Once done, for confirmation we can try to perform a shutdown and no shutdown
    of any interface (`Loopback0` in our case), and see the log using the `show logging`
    command on the router:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，为了确认，我们可以尝试执行任何接口（在我们的案例中是`Loopback0`）的关闭和非关闭操作，并使用路由器上的`show logging`命令查看日志：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An important aspect to confirm if the router is sending syslogs is the line
    `tcp port 514, audit disabled, link up`, which confirms that the router is sending
    syslog traffic to the Syslog server.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 确认路由器是否发送syslogs的一个重要方面是行`tcp port 514, audit disabled, link up`，这确认了路由器正在向Syslog服务器发送syslog流量。
- en: 'Here is the raw output on Splunk for the syslog that is generated:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是Splunk上生成的syslog的原始输出：
- en: '![](img/f9db7f5d-5a30-444b-a201-d60a95547b3f.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9db7f5d-5a30-444b-a201-d60a95547b3f.jpg)'
- en: 'As we see in the New Search section we can write queries to fetch the exact
    data that we want. In our case we wanted to see only the log from our router with
    the `Interface Loopback0` down messages, hence we wrote the query:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在“新搜索”部分所看到的那样，我们可以编写查询来获取我们想要的确切数据。在我们的例子中，我们只想看到来自我们的路由器且带有`Interface
    Loopback0`下线消息的日志，因此我们编写了以下查询：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now let us see the code from Python that we can write to fetch the same information
    using a script:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看看我们可以用Python编写的代码来使用脚本获取相同的信息：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the first section, we query the API of Splunk to fetch the authentication
    session key (or token) to run our queries and get results. Once we have the session
    key (extracted from the XML output), we create a header and using `requests.post`
    we execute our query. The data variable contains our query in the following format:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们查询Splunk的API以获取运行查询和获取结果的认证会话密钥（或令牌）。一旦我们有了会话密钥（从XML输出中提取），我们创建一个头文件，并使用`requests.post`执行我们的查询。数据变量包含以下格式的我们的查询：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In other words, if we take this in a variable (named `Search`) , and provide
    the result as a value to that variable, it would look like below:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果我们把这个作为一个变量（命名为`Search`），并将结果作为值提供给这个变量，它看起来会像下面这样：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Additionally we also send another option of `output_mode` as JSON , since we
    want the output in JSON (some other values can be CSV or XML).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还提供了另一个`output_mode`选项，因为我们希望输出为JSON格式（其他值可以是CSV或XML）。
- en: 'Executing the same will get the following output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 执行相同的操作将得到以下输出：
- en: '![](img/283d1561-ade0-447d-a192-5d72952d8d63.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/283d1561-ade0-447d-a192-5d72952d8d63.jpg)'
- en: As we see in the preceding output, we are now retrieving and displaying the
    value in JSON format.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的输出中所看到的那样，我们现在正在以JSON格式检索和显示值。
- en: We will stop our example here, but to enhance this script, this result can now
    become a trigger on which we can add additional methods or logic to decide on
    the trigger for further actions. By this logic, we can have self-healing scripts
    that find out the data (as a trigger), evaluate the trigger (identify it actionable),
    and take actions based upon further logic.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里停止我们的例子，但为了增强这个脚本，这个结果现在可以成为一个触发器，我们可以添加额外的方法或逻辑来决定触发进一步的动作。通过这种逻辑，我们可以有自我修复的脚本，这些脚本可以找出数据（作为触发器），评估触发器（识别其可操作性），并根据进一步的逻辑采取行动。
- en: Automation examples on various technology domains
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在各种技术领域上的自动化示例
- en: With the familiarity and understanding of automation with the interaction of
    devices, APIs, controllers, let's see some examples of how to interact with other
    network domain devices and tackle some complex scenarios using automation frameworks.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对自动化与设备、API、控制器交互的熟悉和理解，让我们看看一些如何与其他网络域设备交互以及使用自动化框架处理一些复杂场景的例子。
- en: Some of these examples will be a small project in themselves, but will help
    you understand additional ways of performing automation tasks in depth.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些示例将是一个小项目本身，但将帮助你深入了解执行自动化任务的方式。
- en: BGP and routing table
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BGP和路由表
- en: 'Let''s take an example in which we need to configure BGP, validate if a session
    is up, and report the details for the same. In our example, we would take two
    routers (as a prerequisite, both routers are able to ping each other) as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子，我们需要配置BGP，验证会话是否启动，并报告相同细节。在我们的例子中，我们会选择两个路由器（作为先决条件，两个路由器都能互相ping通）如下：
- en: '![](img/ebb2b169-6f26-4d3d-bbd7-e562af417b5d.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ebb2b169-6f26-4d3d-bbd7-e562af417b5d.jpg)'
- en: As we see `R2` and `testrouter` are able to ping each other using an IP address
    of the `FastEthernet0/0` interface of each other.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`R2`和`testrouter`能够使用彼此的`FastEthernet0/0`接口的IP地址互相ping通。
- en: 'The next step is a very basic configuration of BGP (in our case, we use the
    **Autonomous System** (**AS**) number `200`). The code is as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是一个非常基本的BGP配置（在我们的案例中，我们使用**自治系统**（**AS**）号`200`）。代码如下：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/2b09e0f2-6f5d-40c9-83b2-2cf218026f39.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2b09e0f2-6f5d-40c9-83b2-2cf218026f39.jpg)'
- en: As we see, we push the neighbor config (BGP config) to the router. Once the
    config is pushed, the script waits for 5 seconds and validates the state of BGP
    if it is in the `ESTABLISHED state`. This validation confirms that the config
    that we pushed has all the sessions that are newly configured as established.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们将邻居配置（BGP配置）推送到路由器。一旦配置被推送，脚本等待5秒钟并验证BGP的状态是否处于`ESTABLISHED`状态。这种验证确认了我们推送的配置中所有新配置的会话都已建立。
- en: 'Let''s push an incorrect config as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们推送一个不正确的配置如下：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '![](img/05566bbc-1697-444a-a402-d9d243fe5fb1.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05566bbc-1697-444a-a402-d9d243fe5fb1.jpg)'
- en: As we see in the preceding output, now we are pushing the config with an incorrect
    remote (`400` in this case). Of course, since the config is not correct, we get
    a non-established message, which confirms that the config that we pushed was not
    correct. In a similar way, we can push the bulk of the configs by calling the
    methods as many times as we want for each of the remote neighbors to be configured.
    Additionally, sometimes we need to get specific information under certain config
    sections from a running config.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的输出中看到的，现在我们正在使用一个错误的远程配置（在这种情况下是`400`）。当然，由于配置不正确，我们得到了一个未建立的消息，这证实了我们推送的配置是不正确的。以类似的方式，我们可以通过为每个要配置的远程邻居调用方法多次来推送大量配置。此外，有时我们需要从运行配置的某些配置部分获取特定信息。
- en: 'As an example, the following code will give out a list for each section of
    the running config:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码将为运行配置的每个部分输出一个列表：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/1e49b5a2-ae3e-4771-9e99-8e62aa110650.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e49b5a2-ae3e-4771-9e99-8e62aa110650.jpg)'
- en: As we see in the preceding output, we got all the sections of the running config,
    except the exclamation mark `!` that we see in a running config (executing the
    router command `show running-config` on router). The focus of this output is that
    we have a config that is now parsed for each section in running config grouped
    in a single list, or in other words, a specific set of configs meant for a specific
    section (such as an interface or BGP) is grouped in a single list.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的输出中看到的，我们得到了运行配置的所有部分，除了在运行配置中看到的感叹号`!`（在路由器上执行`show running-config`命令时）。这个输出的重点是，我们现在解析了运行配置中的每个部分，或者换句话说，一个特定的配置集（如接口或BGP）被组合在一个单独的列表中。
- en: 'Lets enhance this code. As an example, we only want to see what BGP remote
    IPs are configured in our router:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们增强这段代码。例如，我们只想看到在路由器中配置了哪些BGP远程IP：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/b1e683e7-edb6-4137-a417-79e60ff63dfb.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1e683e7-edb6-4137-a417-79e60ff63dfb.jpg)'
- en: In this case, first we parse the running config and focus on the section which
    has the `router bgp` config. Once we get to that particular list, we parse the
    list and fetch the remote IP using the regex on the specific command that contains
    the string `neighbor`**. **The result values would be the remote IPs under the
    BGP section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，首先我们解析运行配置，并关注包含`router bgp`配置的部分。一旦到达那个特定的列表，我们就解析列表并使用正则表达式在包含字符串`neighbor`的特定命令中获取远程IP。结果值将是BGP部分下的远程IP。
- en: As we are working with BGP, the AS numbers, being an integral part of BGP, need
    to be parsed or validated. Using the preceding strategies, we can get the AS numbers
    for BGP routes/prefixes, but in addition to that, there is a Python library `pyasn` that
    can easily find out AS number information for a given public IP address.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理BGP，AS号码作为BGP的一个组成部分，需要被解析或验证。使用前面的策略，我们可以获取BGP路由/前缀的AS号码，但除此之外，还有一个名为`pyasn`的Python库，可以轻松地查找给定公网IP地址的AS号码信息。
- en: 'Again, as mentioned earlier, we need to install the following library before
    we can call it in the code, by using:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如前所述，在代码中调用它之前，我们需要安装以下库：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The code is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/b63d2c78-e58e-4b92-8a4b-f26ab91884a4.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b63d2c78-e58e-4b92-8a4b-f26ab91884a4.jpg)'
- en: As we see, the first method `getfromhostname` is used to fetch information for
    a given hostname. The other method `getfromip`is used to fetch the same information
    by using an IP address instead of any hostname.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，第一个方法`getfromhostname`用于获取给定主机名的信息。另一个方法`getfromip`用于通过IP地址而不是任何主机名来获取相同的信息。
- en: Configuring Cisco switchport for access point
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置思科交换机端口为接入点
- en: When working with a multi-device environment, along with routers and switches
    we need to interact with other network gear(s) like wireless devices. This example
    will show how to configure a switch with specific ports to be connected to **Access
    Point** (**AP**) as trunk.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当在多设备环境中工作时，除了路由器和交换机外，我们还需要与其他网络设备（如无线设备）交互。本例将展示如何配置交换机，使其特定端口连接到**接入点**（**AP**）作为trunk。
- en: 'In our test case, assuming the VLANs configured on AP are `vlan 100` and `vlan
    200` for users, and the native VLAN is `vlan 10`, and the code is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试案例中，假设在AP上配置的VLAN为`vlan 100`和`vlan 200`用于用户，而原生VLAN为`vlan 10`，代码如下：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/4cc9a1e3-acd6-4da8-b324-7bab8f33e431.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4cc9a1e3-acd6-4da8-b324-7bab8f33e431.jpg)'
- en: As we see, the AP needs to be connected to our switchport, which needs to be
    a trunk, with certain access VLANs to be allowed; hence we create two methods,
    the first of which passes router/switch name and the interfaces that needs to
    be configured.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，AP需要连接到我们的交换机端口，该端口需要是一个trunk，并允许某些访问VLAN；因此我们创建了两个方法，第一个方法传递路由器/交换机名称和需要配置的接口。
- en: Once the configuration is successfully pushed on the switch, we execute the
    `validateswitchport` method to validate if the same port is now in trunk mode.
    The output of the `validateswitchport`method spills out the output of the command,
    on which we can further introduce the regex and splits to get any specific information
    we want from that output (such as the `Administrative Mode` or `Operational Mode`).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置成功推送到交换机，我们执行`validateswitchport`方法来验证该端口是否现在处于trunk模式。`validateswitchport`方法的输出将输出命令的输出，我们可以进一步介绍正则表达式和分割来从该输出中获取我们想要的任何特定信息（如`Administrative
    Mode`或`Operational Mode`）。
- en: As an enhancement, we can also use the outputs from the validation method to
    call other methods that would perform some additional configs (if required), based
    on the result that we got earlier. (For example, changing the `Trunking Native
    Mode VLAN` to `20`).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种增强，我们还可以使用验证方法的结果来调用其他方法，这些方法将执行一些额外的配置（如果需要），基于我们之前得到的结果。（例如，将`Trunking
    Native Mode VLAN`更改为`20`）。
- en: Let's see the new code with the additional enhancement of changing the native
    VLAN to `20`. The code is as follows**:**
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看带有将原生VLAN更改为`20`的额外增强功能的新代码。代码如下**：**
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is explained in two sections as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: 'Validating and changing the native VLAN to `20`:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证并更改原生VLAN为`20`：
- en: '![](img/d58b4964-2880-4582-bbc9-a508d4beecf7.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d58b4964-2880-4582-bbc9-a508d4beecf7.jpg)'
- en: 'Revalidating with the new native VLAN number:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的原生VLAN号重新验证：
- en: '![](img/6d76c4ee-47da-4b36-8e6e-95e316fd34c0.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d76c4ee-47da-4b36-8e6e-95e316fd34c0.jpg)'
- en: As we see in the final validation, now we have a native VLAN 20, instead of
    the earlier `10`. This is also a good troubleshooting technique as in multiple
    scenarios there are requirements of a **what if analysis** (to take decisions
    based upon the evaluation of a certain condition)in which we need to take some
    actions based on the dynamic results received. Since, here in our code we validated
    that the native VLAN needs to be `20`, hence we performed another action to correct
    that earlier config.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在最终验证中看到的，现在我们有原生VLAN 20，而不是之前的`10`。这也是一种良好的故障排除技术，因为在多种场景中，存在对**假设分析**（基于对某种条件的评估做出决策）的需求，在这种情况下，我们需要根据收到的动态结果采取一些行动。由于，在这里我们的代码验证了原生VLAN需要是`20`，因此我们执行了另一个操作来纠正之前的配置。
- en: Configuring Cisco switchport for IP Phone
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置思科交换机端口以用于IP电话
- en: Similar to the earlier scenario, where we want a switchport as a trunk port
    for AP, we can configure the switchport to work with IP Phones. An additional
    task for configuring a port to be used as IP Phone is that another end machine
    or data machine can be connected to the IP Phone for data transfer. In other words,
    a single switchport of a Cisco router can act as both a voice and data port when
    used with IP Phone.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的场景类似，我们希望交换机端口作为AP的 trunk 端口，我们可以配置交换机端口与IP电话一起工作。配置端口用作IP电话的附加任务之一是，另一端机器或数据机器可以连接到IP电话进行数据传输。换句话说，当与IP电话一起使用时，思科路由器的一个单独的交换机端口可以同时作为语音和数据端口。
- en: 'Let''s see an example of configuring a switchport to act as an IP Phone port:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看配置交换机端口作为IP电话端口的示例：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/1bae28c5-6d1f-49f4-a7f5-a14a71f984c4.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1bae28c5-6d1f-49f4-a7f5-a14a71f984c4.jpg)'
- en: 'As we see now, the port configured (`FastEthernet 2/5`) has been assigned a
    `Voice VLAN` of `200` and a data/access VLAN of `100` (from the preceding output,
    notice the line `Access Mode VLAN: 100 (VLAN0100)`. Any IP Phone connecting to
    this port will have access to both the VLANs for its voice and data usage. Again,
    going by previous examples, we can perform additional validations and checks on
    the ports and trigger some actions in case of any incorrect or missing configs.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们现在所看到的，配置的端口（`FastEthernet 2/5`）已被分配了一个`Voice VLAN`为`200`和一个数据/访问VLAN为`100`（从前面的输出中，注意`Access
    Mode VLAN: 100 (VLAN0100)`这一行。任何连接到此端口的IP电话都将能够访问其语音和数据使用的两个VLAN。再次根据前面的示例，我们可以对端口进行额外的验证和检查，并在配置不正确或缺失的情况下触发一些操作）。'
- en: Wireless LAN (WLAN)
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无线局域网（WLAN）
- en: There are many vendors that have backend APIs that can be controlled or called
    using Python to perform certain wireless tasks. A commonly used vendor in wireless
    is `Netgear`. Python has a library `pynetgear` that helps us achieve some of the
    automation to control our locally connected devices.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多厂商提供了后端API，可以使用Python来控制或调用以执行某些无线任务。在无线领域，`Netgear`是一个常用的厂商。Python有一个名为`pynetgear`的库，可以帮助我们实现一些自动化，以控制我们本地连接的设备。
- en: 'Let''s see an example of fetching the current network devices connected to
    the local wireless Netgear router in our network:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例，如何在我们的网络中获取当前连接到本地无线Netgear路由器的网络设备：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Netgear` method accepts four arguments in the following order (`routerpassword`,
    `routerip`, `routerusername`, and `routerport`). As we see in the current example,
    the router is reachable using `http://192.168.100.1` with the username `admin`
    and password as `myrouterpassword`. Hence, we call the method with these parameters.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Netgear`方法接受以下顺序的四个参数（`routerpassword`、`routerip`、`routerusername`和`routerport`）。正如当前示例所示，路由器可以通过`http://192.168.100.1`使用用户名`admin`和密码`myrouterpassword`访问。因此，我们使用这些参数调用该方法。'
- en: 'The output is shown as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we see, the method `get_attached_devices()` returned a list of all the IPs,
    their MAC addresses (hidden in this example), signal (or wireless band being used),
    and the link rate for the connection in Mbps.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`get_attached_devices()`方法返回了一个包含所有IP地址、它们的MAC地址（在本例中隐藏）、信号（或正在使用的无线频段）以及连接的链路速率（以Mbps为单位）的列表。
- en: We can use similar type of methods to manipulate bandwidth, block any user,
    or perform other tasks that are exposed by the APIs of the specific hardware manufacturer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似的方法来操纵带宽、阻止任何用户或执行特定硬件制造商API公开的其他任务。
- en: Access of IP Address Management (IPAM)
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP地址管理（IPAM）访问
- en: Another requirement in networking is to use the IPAM database for IPAM. It is
    provided by different vendors, and as an example here, we would refer to SolarWind's
    IPAM. SolarWinds is again an industry standard tool for monitoring and performing
    various functionalities on a network, and it has a good set of APIs to interact
    with using its ORION SDK toolkit.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中的另一个要求是使用IPAM数据库进行IPAM。它由不同的厂商提供，在此例中，我们将参考SolarWind的IPAM。SolarWinds再次是网络监控和执行各种功能的行业标准工具，它有一套良好的API，可以使用其ORION
    SDK工具包与之交互。
- en: 'In Python, we can install the library `orionsdk` to achieve interaction with
    SolarWinds. Let''s see an example in which we fetch the next available IP address
    from the IPAM module in SolarWinds:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以安装`orionsdk`库以实现与SolarWinds的交互。让我们看看一个示例，其中我们从SolarWinds的IPAM模块中获取下一个可用的IP地址：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/30c86818-98c1-4e5a-9894-a43b9f844821.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30c86818-98c1-4e5a-9894-a43b9f844821.jpg)'
- en: 'As we see in the preceding code, we use the `orionsdk` library to call the
    API for SolarWinds from the `mysolarwindsserver`server.The username and password
    needed for the SolarWinds are passed in script, and we use a simple SQL query
    (which is understandable by SolarWinds) which is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中所看到的，我们使用`orionsdk`库从`mysolarwindsserver`服务器调用SolarWinds的API。SolarWinds所需的用户名和密码在脚本中传递，我们使用一个简单的SQL查询（SolarWinds可以理解），如下所示：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This query fetches the next available IP address (denoted by `Status=2` in SolarWinds)
    and prints it. The first print is the raw print and the one in `for` loop; it
    prints out the value in a better understandable format as shown in the preceding
    output.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询获取下一个可用的IP地址（在SolarWinds中表示为`Status=2`）并打印出来。第一个打印是原始打印，在`for`循环中的打印；它以更好的可理解格式打印出值，如前面的输出所示。
- en: Example and use case
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例和用例
- en: Here, we will see a detailed example that is common to most network engineers,
    and how to automate it using Python. Also, we will create it as a web based tool,
    enabling it to run from any environment or machine, using only a browser.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到一个对大多数网络工程师都常见的详细示例，以及如何使用Python自动化它。我们还将创建一个基于Web的工具，使其能够从任何环境或机器上运行，仅使用浏览器。
- en: Create a web-based pre and post check tool for validations
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基于Web的预和后检查验证工具
- en: In the following example, we will see how we can perform a pre and post check
    on any network maintenance that we do. This is generally required by every network
    engineer while performing activities on production devices to ensure that once
    the maintenance activity is complete, an engineer has not missed out anything
    that could cause an issue later on. It is also required to validate if our changes
    and maintenance have been completed successfully, or if we need to perform additional
    fixes and rollbacks in case of validations that have failed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将看到我们如何对任何网络维护活动进行预检查和后检查。这通常是每个网络工程师在生产设备上执行活动时所需，以确保一旦维护活动完成，工程师没有遗漏任何可能导致后续问题的内容。这也需要验证我们的更改和维护是否成功完成，或者如果验证失败，我们需要执行额外的修复和回滚。
- en: 'The following are the steps to create and execute the tool:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何创建和执行工具的步骤：
- en: Step 1 – Create the main HTML file
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1步 – 创建主HTML文件
- en: We will design a web-based form to select certain show commands that we will
    call for performing checks. These commands, when executed, will act as a precheck;
    once our maintenance activity is complete, we will act again as a postcheck.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计一个基于Web的表单来选择我们将用于执行检查的某些显示命令。这些命令在执行时将作为预检查；一旦我们的维护活动完成，我们将再次作为后检查执行。
- en: Any difference between the same command outputs in precheck or postcheck scenarios
    will be highlighted and the engineer will be in a good position to make decisions
    on calling the maintenance a success or failure, based on the outputs.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在预检查或后检查场景中，相同命令输出的任何差异都将被突出显示，工程师将能够根据输出决定将维护活动称为成功或失败。
- en: 'The HTML code (`prepostcheck.html`) is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: HTML代码（`prepostcheck.html`）如下：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will create the main page on which we select our initial options (set
    of commands and if we need to perform a precheck or a postcheck). The output is
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个主页面，我们在其中选择初始选项（命令集以及是否需要执行预检查或后检查）。输出如下：
- en: '![](img/863b56f6-127a-4ea6-8b8a-abf74b0c3f57.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/863b56f6-127a-4ea6-8b8a-abf74b0c3f57.jpg)'
- en: Main page
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 主页面
- en: 'An additional JavaScript code in HTML ensures that the `Submit` button will
    not send any data until all the selections are made. There is no point sending
    data which is not completed; for example, if we do not fill out entire fields
    the `Submit` option will not proceed, giving out the message that we see in the
    following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: HTML中的附加JavaScript代码确保在所有选择都完成之前，`提交`按钮不会发送任何数据。发送未完成的数据没有意义；例如，如果我们没有填写完整字段，`提交`选项将不会进行，显示我们在以下截图中所见到的消息：
- en: '![](img/e02900d3-19d7-47d4-9b71-97a111443d7a.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e02900d3-19d7-47d4-9b71-97a111443d7a.jpg)'
- en: Unless all the fields are not filled, hitting the `Submit` button will spill
    out this message and the code will not continue. Additionally, as we see in the
    code, the `Submit` button is tied to the Python script, with `checks.py`as a POST
    method. In other words, the selections we will make will be sent to `checks.py`
    as a POST method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除非所有字段都已填写，否则点击“提交”按钮将显示此消息，代码将不会继续执行。此外，正如我们在代码中所见，`提交`按钮与Python脚本相关联，`checks.py`作为POST方法。换句话说，我们将做出的选择将以POST方法发送到`checks.py`。
- en: Step 2 – Create the backend Python code
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2步 – 创建后端Python代码
- en: 'Now, let''s see the back end Python code (`checks.py`)that will accept these
    inputs from HTML form and perform its task. The code is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看后端Python代码（`checks.py`），它将接受来自HTML表单的输入并执行其任务。代码如下：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code accepts input from a web page using the CGI parameter. Various values
    from the web page are parsed into the variables using the following code snippet:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用CGI参数从网页接收输入。网页的各种值使用以下代码片段解析到变量中：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once we have these values, the additional logic is to log in into the given
    device(s) using the `paramiko`library, fetch the output of the show commands,
    and save it in a file under the `logs` folder with the output. An important aspect
    to note here is the way we are constructing the filename:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这些值，附加的逻辑就是使用`paramiko`库登录到指定的设备，获取`show`命令的输出，并将其保存在`logs`文件夹下的文件中。这里需要注意的一个重要方面是我们构建文件名的方式：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `fname` is the filename into which we would write the output, but the filename
    is built dynamically with the inputs provided by the maintenance ID, device IP,
    pre/post status, and the time the file was created. This is to ensure that we
    know the device for which we are performing a pre or a post check, and at what
    time the file was created, to ensure we have a correct pre and post check combination.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`fname`是我们将要写入输出的文件名，但文件名是根据维护ID、设备IP、预/后状态以及文件创建的时间动态构建的。这是为了确保我们知道我们正在执行预检查或后检查的设备，以及文件是在什么时间创建的，以确保我们有一个正确的预检查和后检查组合。'
- en: The function `getoutput()`is invoked from a thread (in a multi-threaded function
    call) to fetch the output and store it in the newly created file. A multi-threading
    process is called, because if we want to perform pre or post checks in multiple
    devices, we can provide a comma separated IP address list in web, and Python script
    will in parallel invoke the show commands on all devices and create multiple pre
    or post check files, based on hostnames.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`getoutput()`函数从线程（在多线程函数调用中）调用以获取输出并将其存储在新建的文件中。调用多线程过程是因为如果我们想在多个设备上执行预检查或后检查，我们可以在Web中提供一个以逗号分隔的IP地址列表，Python脚本将并行地在所有设备上调用`show`命令，并根据主机名创建多个预检查或后检查文件。'
- en: 'Let''s create a `precheck` file for some commands in our example, where we
    fill in some values and click on the `Submit` button:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在示例中为一些命令创建一个`precheck`文件，其中我们填写一些值并点击`提交`按钮：
- en: '![](img/efa052c4-e7e6-4de3-98a0-3b9f6fe93c91.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/efa052c4-e7e6-4de3-98a0-3b9f6fe93c91.jpg)'
- en: While the gathering of data is in progress, the yellow message will be displayed
    to confirm that the back end work is going on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据收集正在进行时，黄色消息将显示以确认后端工作正在进行。
- en: 'Once the task is completed, this is what we see (as returned from the Python
    code):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成后，我们看到的是（如Python代码返回的）：
- en: '![](img/2af3ce42-fa61-4e0f-8058-70e97e9aaf3e.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2af3ce42-fa61-4e0f-8058-70e97e9aaf3e.jpg)'
- en: As we see, the code returns a success, which means that it was able to fetch
    the output of the commands that we want to validate. The filename is dynamically
    created, based on our selection on the main page.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，代码返回成功，这意味着它能够获取我们想要验证的命令的输出。文件名是根据我们在主页上的选择动态创建的。
- en: 'A click on the `.txt` filename that is generated as a clickable URL (which
    can be used to reconfirm if we got the correct output of commands we selected
    earlier), shows the following output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 点击生成的可点击URL（.txt文件名，可以用来重新确认我们是否得到了之前选择的命令的正确输出），显示以下输出：
- en: '![](img/18397e3a-6a6f-468f-9aef-f3107f155925.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18397e3a-6a6f-468f-9aef-f3107f155925.jpg)'
- en: Now, let's perform the same steps and create a `postcheck` file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行相同的步骤并创建一个`postcheck`文件。
- en: 'We go back to the main page, and keeping the other values the same, we just
    select the radio button to `Postcheck` instead of `Precheck`. Do ensure that we
    select the same set of commands, since a pre and post check only make sense if
    we have the same data to work with:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回到主页，保持其他值不变，只是选择单选按钮从`Precheck`改为`Postcheck`。请确保我们选择相同的命令集，因为只有当我们有相同的数据来工作的时候，预检查和后检查才有意义：
- en: '![](img/f4a73e82-3c55-40ad-97e0-9ab73b353a15.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f4a73e82-3c55-40ad-97e0-9ab73b353a15.jpg)'
- en: 'In a similar way, once the backend execution completes, we have a `postcheck`
    file created as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，一旦后端执行完成，我们将创建一个如下所示的`postcheck`文件：
- en: '![](img/9322e246-d639-4e98-a754-37296920ef84.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9322e246-d639-4e98-a754-37296920ef84.jpg)'
- en: Notice the filename, the timestamp, and the `post`word changes based on our
    selection.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文件名、时间戳以及根据我们的选择`post`字样会发生变化。
- en: Step 3 – Create web server based files for the tool
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3步 – 为工具创建基于Web服务器的文件
- en: Now with the both pre and post check files created, let's create a web framework
    to perform web-based pre/post check for the files. We need to create a web page
    in which our current log files are visible as pre and post files, and we can select
    the `precheck` file and its relevant `postcheck` file for comparison. As we know
    that we cannot use HTML or browser languages to fetch information about any files
    from the server,  we need to use some backed web language to perform this function
    for us. We take advantage of ASP and VB.NET to create the web page to display
    the already created log files for selection and comparison.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经创建了前后检查文件，让我们创建一个用于执行基于网络的文件前后检查的Web框架。我们需要创建一个网页，其中我们的当前日志文件作为前后文件可见，并且我们可以选择`precheck`文件及其相关的`postcheck`文件进行比较。正如我们所知，我们不能使用HTML或浏览器语言从服务器获取任何文件的信息，因此我们需要使用某种后端Web语言来为我们执行此功能。我们利用ASP和VB.NET创建网页，以显示已创建的日志文件以供选择和比较。
- en: 'The backend code for `selectfiles.aspx` is as follows (this is to display the
    files from the log directory on a browser):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectfiles.aspx`的后端代码如下（这是在浏览器上显示日志目录中的文件）：'
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The VB.NET backend code, to fill in the values on the preceding `.aspx` page
    `selectfiles.aspx.vb`, is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在前面提到的`.aspx`页面`selectfiles.aspx.vb`上填写值的VB.NET后端代码如下：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code is used to fetch the files from the log directory, and based on their
    filenames, they are divided into either `precheck` files or `postcheck` files.
    Also, the files are ordered in chronological order for easy selection during the
    comparison process.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码用于从日志目录获取文件，并根据它们的文件名，将它们分为`precheck`文件或`postcheck`文件。此外，文件按时间顺序排列，以便在比较过程中易于选择。
- en: 'Let''s see the output of this page now:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这个页面的输出：
- en: '![](img/1eab88dc-950f-41b1-b457-49a01d201889.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1eab88dc-950f-41b1-b457-49a01d201889.jpg)'
- en: Step 4 – Create server based files for pre and post files comparison
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4步 – 创建用于前后文件比较的服务器端文件
- en: The final step is to create a web page that retrieves the text from these files
    and also provides frontend (or a web-based tool) for easy comparison. For our
    purpose, we use a JScript library called `diffview` **. **To call this dependency,
    we need to download `diffview.js`, `difflib.js`, and `diffview.css` which available
    here: [https://github.com/cemerick/jsdifflib, ](https://github.com/cemerick/jsdifflib)and
    copy the files into our web server folder. Once done, in the similar way as accessing
    the files, we would again create a `.aspx` page to get the content of the selected
    files and display it for comparison.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建一个网页，它检索这些文件中的文本，并提供前端（或基于Web的工具）以便于比较。为了我们的目的，我们使用一个名为`diffview`的JScript库**。**要调用此依赖项，我们需要下载`diffview.js`、`difflib.js`和`diffview.css`，这些文件可在以下位置找到：[https://github.com/cemerick/jsdifflib](https://github.com/cemerick/jsdifflib)，并将文件复制到我们的Web服务器文件夹中。一旦完成，我们就会像访问文件一样再次创建一个`.aspx`页面来获取所选文件的内容，并将其显示以进行比较。
- en: 'The following is the code of the main page `comparefiles.aspx`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是主页面`comparefiles.aspx`的代码：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The backend code for the main page, to get the contents of the file (`comparefiles.aspx.vb`),
    is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 用于获取文件内容（`comparefiles.aspx.vb`）的主页后端代码如下：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With this ready, let''s compare the files and see the results. We select the
    pre and post check files and click on `Submit`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 准备就绪后，让我们比较文件并查看结果。我们选择前后检查文件，然后点击`提交`：
- en: '![](img/6402dbab-3ae6-41f6-b6c9-c1666534b465.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6402dbab-3ae6-41f6-b6c9-c1666534b465.jpg)'
- en: 'The next page takes us to the content and comparison:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下一页带我们到内容和比较：
- en: '![](img/493e101c-9380-4c06-a801-8a1c2788cbbf.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/493e101c-9380-4c06-a801-8a1c2788cbbf.jpg)'
- en: As we see in the preceding screenshot, on the left, we have the `precheck` file,
    and on the right, we have the `postcheck` file. Both can be read on the page itself
    through slides on both windows. The bottom window appears when we select either
    `Side by Side Diff` or `Inline Diff`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述截图所示，在左侧，我们有`precheck`文件，在右侧，我们有`postcheck`文件。两者都可以通过两个窗口上的幻灯片在页面上本身读取。当选择`Side
    by Side Diff`或`Inline Diff`时，底部窗口会出现。
- en: On a `Side by Side Diff`, anything that is different will be highlighted. In
    our case it was uptime that was different. For everything else in common, no color
    highlighting will be in place and an engineer can safely assume the same states
    for non highlighted colors.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Side by Side Diff`中，任何不同之处都会被突出显示。在我们的案例中，是运行时间不同。对于其他所有共同点，没有颜色突出显示，工程师可以安全地假设非突出显示颜色的相同状态。
- en: 'Let''s see the same example with a `Inline Diff` comparison selection:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`Inline Diff`比较选择来查看相同的示例：
- en: '![](img/4cf4ec76-401b-438b-bbda-03bd7796af1b.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4cf4ec76-401b-438b-bbda-03bd7796af1b.jpg)'
- en: It is the same result; different lines are highlighted in different colors to
    confirm the pre and post check differences. With this tool now, an engineer can
    quickly parse through the entire log files, and based on the highlighted differences
    (a mismatch between `precheck` file content and `postcheck` file content), can
    make the decision to call the task a success or a failure.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一样的；不同的行用不同的颜色突出显示，以确认前后检查的差异。有了这个工具，工程师现在可以快速解析整个日志文件，并根据突出显示的差异（`precheck`文件内容和`postcheck`文件内容之间的不匹配），决定将任务标记为成功或失败。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw various concepts related to the usage of automation
    in daily network scenarios. We got familiar with examples of performing various
    tasks related to additional devices such as wireless AP and IP Phones. Additionally,
    we also got introduced to IPAM of SolarWinds and how to work on the API using
    Python.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了与日常网络场景中自动化使用相关的各种概念。我们熟悉了执行与无线AP和IP电话等附加设备相关的各种任务的例子。此外，我们还介绍了SolarWinds的IPAM以及如何使用Python操作API。
- en: We also saw a real-world example of creating a pre and post validation tool
    to help engineers make quick maintenance validation decisions, and also ported
    to the web so that the tool can be used from anywhere, instead of running from
    individual machines with Python installed as a prerequisite.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了一个创建前后验证工具的真实世界例子，以帮助工程师快速做出维护验证决策，并且将该工具移植到网络上，这样工具就可以在任何地方使用，而不是在安装了Python的单独机器上运行。
- en: Finally, in our concluding chapter, we will look at some additional aspects
    of SDN to understand better usage and how and where to automate, with respect
    to SDN scenarios.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的结论章节中，我们将探讨SDN的一些附加方面，以更好地理解使用方法以及如何在SDN场景中自动化。
