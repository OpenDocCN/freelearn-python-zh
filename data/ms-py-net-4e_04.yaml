- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: The Python Automation Framework – Ansible
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 自动化框架 – Ansible
- en: The previous two chapters incrementally introduced different ways to interact
    with network devices. In *Chapter 2*, *Low-Level Network Device Interactions*,
    we discussed the Pexpect and Paramiko libraries, which manage an interactive session
    to control interactions. In *Chapter 3*, *APIs and Intent-Driven Networking*,
    we started to think of our network in terms of API and intent. We looked at various
    APIs that contain a well-defined command structure and provide a structured way
    of getting feedback from the device. As we moved from *Chapter 2*, *Low-Level
    Network Device Interactions*, to *Chapter 3*, *APIs and Intent-Driven Networking*,
    we began to think about our intent for the network. We gradually began to express
    our network as code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前两章逐步介绍了与网络设备交互的不同方式。在 *第二章*，*低级网络设备交互* 中，我们讨论了 Pexpect 和 Paramiko 库，它们管理交互会话以控制交互。在
    *第三章*，*APIs 和意图驱动型网络* 中，我们开始从 API 和意图的角度思考我们的网络。我们研究了包含良好定义的命令结构并提供从设备获取反馈的结构的各种
    API。当我们从 *第二章*，*低级网络设备交互* 转到 *第三章*，*APIs 和意图驱动型网络* 时，我们开始思考我们的网络意图。我们逐渐开始将我们的网络表达为代码。
- en: In this chapter, let’s expand upon the idea of translating our intention into
    network requirements. If you have worked on network designs, chances are the most
    challenging part of the process is not the different pieces of network equipment
    but rather the qualifying and translating of business requirements into the actual
    network design. Your network design needs to solve business problems. For example,
    you might be working within a larger infrastructure team that needs to accommodate
    a thriving online e-commerce site that experiences slow site response times during
    peak hours. How do you determine whether the network is the problem? If the slow
    response on the website was indeed due to network congestion, which part of the
    network should you upgrade? Can the rest of the system take advantage of the greater
    speed and feed?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，让我们进一步探讨将我们的意图转化为网络需求的想法。如果你从事过网络设计工作，那么最具有挑战性的部分可能不是不同的网络设备，而是对业务需求的评估和将它们转化为实际网络设计。你的网络设计需要解决业务问题。例如，你可能在需要适应在高峰时段出现网站响应时间缓慢的繁荣在线电子商务网站的大型基础设施团队中工作。你如何确定网络是否是问题所在？如果网站上的缓慢响应确实是由于网络拥塞造成的，你应该升级网络的哪个部分？系统的其他部分能否利用更高的速度和吞吐量？
- en: 'The following diagram is an illustration of a simple process of the steps that
    we might go through when trying to translate our business requirements into a
    network design:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了将我们的业务需求转化为网络设计时可能经历的一个简单流程步骤：
- en: '![Diagram  Description automatically generated](img/B18403_04_01.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B18403_04_01.png)'
- en: 'Figure 4.1: Business logic to network deployment'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：业务逻辑到网络部署
- en: In my opinion, network automation is not just about faster configuration change.
    It should also solve business problems while accurately and reliably translating
    our intention into device behavior. These are the goals that we should keep in
    mind as we march on our network automation journey. In this chapter, we will look
    at a Python-based framework called **Ansible**, which allows us to declare our
    intention for the network and abstract even more from the API and CLI.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，网络自动化不仅仅是关于更快的配置更改。它还应该在准确和可靠地将我们的意图转化为设备行为的同时解决业务问题。这些是我们进行网络自动化之旅时应该牢记的目标。在本章中，我们将探讨一个基于
    Python 的框架，称为 **Ansible**，它允许我们声明我们的网络意图，并从 API 和 CLI 中进一步抽象化。
- en: 'In this chapter, we will take a look at the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: An introduction to Ansible
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 简介
- en: The advantages of Ansible
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 的优势
- en: The Ansible architecture
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 架构
- en: Ansible advanced topics
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 高级主题
- en: Let’s begin by looking at an overview of the Ansible framework.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Ansible 框架的概述开始。
- en: Ansible – A More Declarative Framework
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible – 一个更声明式的框架
- en: 'Imagine yourselves in a hypothetical situation: you woke up one morning in
    a cold sweat from a nightmare you had about a potential network security breach.
    You realize your network contains valuable digital assets that should be protected.
    You have been doing your job as a network administrator, so it is pretty secure,
    but you want to put more security measures around your network devices just to
    be sure.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下一个假设的情况：你在一个寒冷的早晨从关于潜在网络安全漏洞的恶梦中惊醒。你意识到你的网络中包含应该受到保护的宝贵数字资产。你一直担任网络管理员的工作，所以网络相当安全，但你只是想确保在你的网络设备周围增加更多的安全措施。
- en: 'To start with, you break the objective down into two actionable items:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将目标分解为两个可执行项：
- en: 'Upgrading the devices to the latest version of the software. The steps include
    the following:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将设备升级到软件的最新版本。步骤包括以下内容：
- en: Uploading the image to the device
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图片上传到设备
- en: Instructing the device to boot from the new image
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指示设备从新镜像启动
- en: Proceeding to reboot the device
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续重启设备
- en: Verifying that the device is running with the new software image
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 核实设备正在运行新的软件镜像
- en: 'Configuring the appropriate access control list on the networking devices,
    which includes the following:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络设备上配置适当的访问控制列表，包括以下内容：
- en: Constructing the access list on the device
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上构建访问列表
- en: Configuring the access list on the interface under the interface configuration
    section
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接口配置部分配置访问列表
- en: Being an automation-focused network engineer, you want to write scripts to reliably
    configure the devices and receive feedback from the operations. You begin to research
    the necessary commands and APIs for each step, validate them in the lab, and finally,
    deploy them in production. Having done a fair amount of work for OS upgrade and
    ACL deployment, you hope the scripts are transferable to the next generation of
    devices.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一位专注于自动化的网络工程师，你想编写脚本来可靠地配置设备并从操作中获取反馈。你开始研究每个步骤所需的必要命令和API，然后在实验室中验证它们，最后在生产环境中部署它们。在操作系统升级和ACL部署方面做了大量工作后，你希望这些脚本可以转移到下一代设备上。
- en: Wouldn’t it be nice if there was a tool that could shorten this design-develop-deployment
    cycle? In this chapter, we will work with an open-source automation framework
    called Ansible. It is a framework that can simplify the process of going from
    business logic to completing the job without getting bogged down with specific
    network commands. It can configure systems, deploy software, and orchestrate a
    combination of tasks.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个工具可以缩短这个设计-开发-部署周期，那岂不是很好？在本章中，我们将使用一个名为Ansible的开源自动化框架。这是一个可以将从业务逻辑到完成工作简化过程的框架，而无需陷入特定的网络命令。它可以配置系统、部署软件和编排一系列任务。
- en: 'Ansible is written in Python and has emerged as one of the leading automation
    tools for Python developers. It is also one of the most supported automation frameworks
    by network vendors. In the *‘Python Developers Survey 2020’* by JetBrains, Ansible
    is ranked #1 for configuration management tools:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是用Python编写的，已成为Python开发者领先的自动化工具之一。它也是网络供应商支持最多的自动化框架之一。在JetBrains的*‘Python
    Developers Survey 2020’*调查中，Ansible在配置管理工具中排名#1：
- en: '![](img/B18403_04_02.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18403_04_02.png)'
- en: 'Figure 4.2: Python Developers Survey 2020 Results (source: https://www.jetbrains.com/lp/python-developers-survey-2020/)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：Python Developers Survey 2020 结果（来源：https://www.jetbrains.com/lp/python-developers-survey-2020/）
- en: Ever since version 2.10, Ansible has separated the release schedule for **ansible-core**
    and community packages. It is a bit confusing, so let’s take a look at the differences.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 自从2.10版本以来，Ansible已经将**ansible-core**和社区包的发布计划分开。这有点令人困惑，所以让我们看看它们之间的区别。
- en: Ansible Versions
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible版本
- en: Prior to version 2.9, Ansible has a fairly straightforward versioning system,
    going from 2.5, 2.6, 2.7, and so on ([https://docs.ansible.com/ansible/latest/roadmap/old_roadmap_index.html](https://docs.ansible.com/ansible/latest/roadmap/old_roadmap_index.html)).
    Starting from version 2.10, we see the jump from Ansible project 2.10, 3.0, 4.0,
    and so on ([https://docs.ansible.com/ansible/latest/roadmap/ansible_roadmap_index.html#ansible-roadmap](https://docs.ansible.com/ansible/latest/roadmap/ansible_roadmap_index.html#ansible-roadmap)).
    What gives? The Ansible team wants to separate the core engine, modules, and plugins
    from the wider community-curated modules and plugins. This allows the core team
    to move faster with the core features while allowing time for the community to
    catch up with the maintenance of their code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本2.9之前，Ansible有一个相当直接的版本控制系统，从2.5、2.6、2.7等版本开始（[https://docs.ansible.com/ansible/latest/roadmap/old_roadmap_index.html](https://docs.ansible.com/ansible/latest/roadmap/old_roadmap_index.html)）。从版本2.10开始，我们看到Ansible项目从2.10、3.0、4.0等版本跳跃（[https://docs.ansible.com/ansible/latest/roadmap/ansible_roadmap_index.html#ansible-roadmap](https://docs.ansible.com/ansible/latest/roadmap/ansible_roadmap_index.html#ansible-roadmap)）。这是怎么回事？Ansible团队希望将核心引擎、模块和插件与更广泛的社区维护的模块和插件分开。这允许核心团队在核心功能上更快地移动，同时为社区留出时间来跟上其代码的维护。
- en: When we talk about “Ansible,” we are referring to a collection of community
    packages at that level, say, version 3.0\. In the version, it will specify a version
    of `ansible-core` (initially called `ansible-base`) it requires. For example,
    Ansible 3.0 requires ansible-core 2.10 and above, while Ansible 4.0 requires ansible-core
    2.11+. In this structure, we can upgrade ansible-core to the latest version while
    keeping the community packages in an older release if needed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论“Ansible”时，我们指的是该级别的社区包集合，比如说，版本3.0。在这个版本中，它将指定所需的`ansible-core`（最初称为`ansible-base`）版本。例如，Ansible
    3.0需要ansible-core 2.10及以上版本，而Ansible 4.0需要ansible-core 2.11+版本。在这个结构中，我们可以将ansible-core升级到最新版本，同时如果需要，可以保持社区包在较旧版本中。
- en: If want to learn more about the versioning split, Ansible provides a useful
    Q&A page when they first adopted Ansible 3.0, [https://www.ansible.com/blog/ansible-3.0.0-qa](https://www.ansible.com/blog/ansible-3.0.0-qa).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想了解更多关于版本分割的信息，Ansible在其首次采用Ansible 3.0时提供了一个有用的问答页面，[https://www.ansible.com/blog/ansible-3.0.0-qa](https://www.ansible.com/blog/ansible-3.0.0-qa)。
- en: Let’s move ahead and look at an Ansible example.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，看看一个Ansible示例。
- en: Our First Ansible Network Example
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一篇Ansible网络示例
- en: Ansible is an IT automation tool. Its main attributes are simplicity and ease
    of use with minimum moving parts. It manages machines in an agent-less manner
    (more on this later) and relies on the existing operating system credentials and
    remote Python software to run its code. Ansible is installed on a centralized
    machine called the controlled node and executes on the machine it wishes to control,
    called the managed node.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是一个IT自动化工具。其主要属性是简单易用，组件最少。它以无代理的方式管理机器（关于这一点稍后会有更多介绍），并依赖于现有的操作系统凭证和远程Python软件来运行其代码。Ansible安装在称为控制节点的中央机器上，并在它希望控制的机器上执行，称为受管理节点。
- en: '![](img/B18403_04_03.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18403_04_03.png)'
- en: 'Figure 4.3: Ansible Architecture (Source: https://docs.ansible.com/ansible/latest/getting_started/index.html)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：Ansible架构（来源：https://docs.ansible.com/ansible/latest/getting_started/index.html）
- en: As with most IT infrastructure automation, Ansible started by managing servers.
    Most servers have Python installed or are capable of running Python code; Ansible
    would leverage this feature by pushing the code to the managed node and having
    it run locally on the managed node. However, as we know, most network devices
    are not capable of running native Python code; therefore, when it comes to network
    automation, the Ansible configuration is run locally first before making the changes
    to the remote devices.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数IT基础设施自动化一样，Ansible最初是通过管理服务器开始的。大多数服务器都安装了Python或者能够运行Python代码；Ansible会利用这一特性，通过将代码推送到受管理的节点，并在受管理的节点上本地运行。然而，正如我们所知，大多数网络设备无法运行原生Python代码；因此，当涉及到网络自动化时，Ansible配置首先在本地运行，然后再对远程设备进行更改。
- en: For more information on how network automation is different, check out this
    document from Ansible, [https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于网络自动化差异的信息，请查看Ansible的这篇文档，[https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html)。
- en: Let us install Ansible on the control node.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在控制节点上安装Ansible。
- en: The Control Node Installation
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制节点安装
- en: We will install Ansible on the Ubuntu host in our lab. The only requirements
    for the control node are Python 3.8 or newer as well as Python’s `pip` package
    management system
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在实验室的Ubuntu宿主机上安装Ansible。控制节点仅有的要求是Python 3.8或更高版本以及Python的`pip`包管理系统。
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can check the installed Ansible version as well as other package-level information
    via the ‘—version’ switch:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用‘—version’开关来检查已安装的Ansible版本以及其他包级别信息：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you are interested in installing Ansible on specific operation systems using
    their respective package management systems, please consult the Ansible documentation,
    [https://docs.ansible.com/ansible/latest/installation_guide/installation_distros.html](https://docs.ansible.com/ansible/latest/installation_guide/installation_distros.html).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对在特定的操作系统上使用各自的包管理系统安装Ansible感兴趣，请参阅Ansible文档，[https://docs.ansible.com/ansible/latest/installation_guide/installation_distros.html](https://docs.ansible.com/ansible/latest/installation_guide/installation_distros.html)。
- en: There is some important information displayed in the output. The most important
    is the Ansible core version (2.13.3) and configuration file (none for now). This
    is all we need to get started with Ansible, we can start to construct our first
    automation task.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中显示了一些重要信息。最重要的是Ansible核心版本（2.13.3）和配置文件（目前没有）。这就是我们开始使用Ansible所需的所有信息，我们可以开始构建我们的第一个自动化任务。
- en: Lab Topology
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验室拓扑
- en: Ansible is known to have many different ways to accomplish the same task. For
    example, we can define Ansible configuration files in different locations. We
    can also specify host-specific variables in a variety of places such as an inventory,
    in playbooks, in roles, and the command line. This is too confusing for people
    who are just getting started with Ansible. In this chapter, I will use just one
    way of doing things that makes the most sense to me. Once we learn the basics,
    we can always consult the documentation to find out other ways to accomplish a
    task.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 已知Ansible有多种不同的方式来完成同一任务。例如，我们可以在不同的位置定义Ansible配置文件。我们还可以在inventory、playbooks、roles和命令行等多种地方指定特定宿主机的变量。这对刚开始使用Ansible的人来说可能有些令人困惑。在本章中，我将使用我认为最有意义的一种方式来做事情。一旦我们学会了基础知识，我们总是可以查阅文档来了解其他完成任务的方法。
- en: For the first example, we will use the same lab topology that we have been using
    and run the task against the two IOSv devices, `lax-edg-r1` and `lax-edg-r2`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个示例，我们将使用我们一直在使用的相同实验室拓扑，并对两个IOSv设备`lax-edg-r1`和`lax-edg-r2`运行任务。
- en: '![](img/B18403_04_04.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18403_04_04.png)'
- en: 'Figure 4.4: Lab Topology'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：实验室拓扑
- en: 'The first thing we will need to think about is how to define the hosts we want
    to manage. In Ansible, we use an inventory file to define the host we intend to
    manage. Let us create a file called `hosts` and put the following text in the
    file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要考虑的是如何定义我们想要管理的宿主机。在Ansible中，我们使用一个名为inventory的文件来定义我们打算管理的宿主机。让我们创建一个名为`hosts`的文件，并将以下文本放入该文件中：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This type of file is in an INI format ([https://en.wikipedia.org/wiki/INI_file](https://en.wikipedia.org/wiki/INI_file)),
    which states I have a group of devices called the `ios_devices` with members of
    `iosv-1` and `iosv-2`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的文件是INI格式（[https://en.wikipedia.org/wiki/INI_file](https://en.wikipedia.org/wiki/INI_file)），它声明我有一个名为`ios_devices`的设备组，其成员包括`iosv-1`和`iosv-2`。
- en: We should now specify the particular variables associated with each host.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该指定与每个宿主机相关的特定变量。
- en: The Variable Files
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量文件
- en: 'There are many places we can put the variables associated with a host. Let
    us create a folder called `host_vars` and two files with the names of the files
    identical to the hosts we specified in the inventory file. The directory and filenames
    are important because that is how Ansible matches up the variables with the host.
    Below is an output to show the directory and files within that directory:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在许多地方放置与宿主机相关的变量。让我们创建一个名为`host_vars`的文件夹，并创建两个文件，其名称与inventory文件中指定的宿主机名称相同。目录和文件名很重要，因为Ansible就是通过这种方式将变量与宿主机匹配的。以下是目录和该目录内文件的输出：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The file is where we will put the necessary information belonging to the host.
    For example, we can specify the IP address, username, password, and other information.
    Here is the output of the `iosv-1` file for our lab:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 文件是我们将放置属于宿主机必要信息的地点。例如，我们可以指定IP地址、用户名、密码和其他信息。以下是我们的实验室中`iosv-1`文件的输出：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This file is in YAML format ([https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html](https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html)).
    The ‘---’ symbol indicates the start of the document. Below the start symbol,
    we have many key-value pairs. The keys all start with `ansible` and the value
    is separated from the key with a colon. The `ansible_host`, `ansible_user`, and
    `ansible_ssh_pass` should be changed to values matching your own lab. How do I
    know these names? Ansible documentation is our best friend here. Ansible has a
    standard way of naming these parameters listed in its documentation, [https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html](https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件采用YAML格式（[https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html](https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html)）。符号‘---’表示文档的开始。在开始符号下方，有许多键值对。所有键都以`ansible`开头，键与值之间用冒号分隔。`ansible_host`、`ansible_user`和`ansible_ssh_pass`应更改为与您自己的实验室匹配的值。我如何知道这些名称？Ansible文档在这里是我们的好朋友。Ansible在其文档中列出了命名这些参数的标准方式，[https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html](https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html)。
- en: Prior to Ansible 2.8, network modules did not have a standard way of naming
    the parameters, which is very confusing. Since version 2.8, the network modules
    have become much better at standardizing the parameters with the rest of the Ansible
    modules.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible 2.8版本之前，网络模块没有标准的方式来命名参数，这非常令人困惑。从2.8版本开始，网络模块在标准化参数方面变得更好，与Ansible的其他模块保持一致。
- en: Once we have defined the respective files for the host variables, we are ready
    to construct an Ansible playbook.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了主机变量的相应文件，我们就可以开始构建Ansible剧本了。
- en: Our First Playbook
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的第一份剧本
- en: Playbooks are Ansible’s blueprint to describe what you would like to do to the
    managed nodes, using modules. This is where we will be spending the majority of
    our time as operators when working with Ansible. What are modules? In a simplified
    view, modules are pre-built codes that we can use to accomplish a certain task.
    Similar to Python modules, the code can come with the default Ansible installation
    or it can be installed separately.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 剧本（Playbook）是Ansible描述对受管理节点进行操作蓝图的方式，使用模块来实现。这是我们作为操作员使用Ansible时将花费大部分时间的地方。什么是模块？从简化的角度来看，模块是我们用来完成特定任务的预构建代码。类似于Python模块，代码可以随默认的Ansible安装提供，也可以单独安装。
- en: If we use an analogy of building a tree house with Ansible, the playbook will
    be the instruction manual, the modules will be the tools we use, and the inventory
    will be the components we work on.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用Ansible构建树屋的类比，剧本将是说明书，模块将是使用的工具，而清单（inventory）则是我们工作的组件。
- en: 'The playbook is designed to be human-readable in YAML format ([https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html](https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html)).
    We will write our first playbook, named `ios_config_backup.yml`, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 剧本设计为以YAML格式（[https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html](https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html)）可读。我们将编写第一个剧本，命名为`ios_config_backup.yml`，如下所示：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note the `-` in front of `name`, it specifies a list item in YAML. Everything
    in the same list item should have the same indentation. We set `gather_facts`
    to `false` because most network tasks are executed locally before making the changes
    to the devices. The `gather_facts` were mainly used when the managed nodes were
    servers to gather server information before any of the tasks were executed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`name`前的`-`，它指定了YAML中的一个列表项。同一列表项中的所有内容都应该有相同的缩进。我们将`gather_facts`设置为`false`，因为大多数网络任务在更改设备之前都是在本地执行的。`gather_facts`主要用于在执行任何任务之前收集受管理节点（通常是服务器）的信息。
- en: There are two key-value pairs in the list item, `hosts` and `tasks`. The `hosts`
    variable with the value of `all` specifies that we will work on all the hosts
    in the inventory file. The `tasks` key has another list item in the value, which
    uses the `ios_config` module ([https://docs.ansible.com/ansible/latest/collections/cisco/ios/ios_config_module.html#ansible-collections-cisco-ios-ios-config-module](https://docs.ansible.com/ansible/latest/collections/cisco/ios/ios_config_module.html#ansible-collections-cisco-ios-ios-config-module)).
    The `ios_config` module is one of the collections of modules installed along with
    Ansible. It also has a variety of arguments. We use the `backup` argument and
    set it to `yes` to indicate we will back up the devices’ `running-config`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表项中有两个键值对，`hosts` 和 `tasks`。具有 `all` 值的 `hosts` 变量指定我们将处理清单文件中的所有主机。`tasks`
    键的值中还有一个列表项，它使用 `ios_config` 模块 ([https://docs.ansible.com/ansible/latest/collections/cisco/ios/ios_config_module.html#ansible-collections-cisco-ios-ios_config-module](https://docs.ansible.com/ansible/latest/collections/cisco/ios/ios_config_module.html#ansible-collections-cisco-ios-ios_config-module))。`ios_config`
    模块是随 Ansible 一起安装的模块集合之一。它也有许多参数。我们使用 `backup` 参数并将其设置为 `yes`，以表示我们将备份设备的 `running-config`。
- en: 'The next task we will do is to use the new LibSSH connection plugin for Ansible.
    By default, Ansible network SSH connections use the Paramiko library. However,
    the Paramiko library does not guarantee FIPS readiness and is a bit slow when
    we need to connect to multiple devices. We will install LibSSH as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的任务是使用新的 LibSSH 连接插件来配置 Ansible。默认情况下，Ansible 网络SSH连接使用 Paramiko 库。然而，Paramiko
    库并不能保证符合 FIPS 标准，并且在需要连接多个设备时速度较慢。我们将按照以下步骤安装 LibSSH：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will specify the usage in a new `ansible.cfg` file. We will create the file
    in the same directory as our playbook with the following content. In the same
    configuration file, we will also set `host_key_checking` to be `false`; this is
    to prevent an error if the host is not initially in the `known_hosts` list in
    the `ssh` setup:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在新的 `ansible.cfg` 文件中指定用法。我们将在这个与我们的剧本相同的目录中创建文件，内容如下。在同一个配置文件中，我们还将 `host_key_checking`
    设置为 `false`；这是为了防止在 `ssh` 设置中主机最初不在 `known_hosts` 列表中时出现错误：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we can execute the playbook via the `ansible-playbook` command with
    the `-i` switch to indicate the inventory file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过带有 `-i` 选项的 `ansible-playbook` 命令来执行剧本，以指示清单文件：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Just like magic, if we take a look at our working directory where the playbook
    is executed, we will see a folder named `backup` with the two devices’ running
    configurations with timestamps! This command can now be scheduled to run via `cron`
    to run nightly to back up all of our devices’ configurations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 就像魔法一样，如果我们查看执行剧本的工作目录，我们会看到一个名为 `backup` 的文件夹，其中包含两个设备的运行配置文件，并带有时间戳！现在，这个命令可以通过
    `cron` 计划任务每晚运行，以备份我们所有设备的配置。
- en: Congratulations on executing your first Ansible playbook! Even with a playbook
    as simple as ours, this is a very useful automation task that we were able to
    accomplish in a short amount of time. We will expand on this playbook in just
    a bit, but first, let’s take a look at why Ansible is a good fit for network management.
    Remember that Ansible modules are written in Python; that is one advantage for
    a Pythonic network engineer, right?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你执行了你的第一个 Ansible 剧本！即使像我们这样的剧本很简单，这也是一个非常有用的自动化任务，我们能够在短时间内完成。我们将在稍后扩展这个剧本，但首先，让我们看看为什么
    Ansible 适合网络管理。记住，Ansible 模块是用 Python 编写的；这对于 Python 网络工程师来说是一个优势，对吧？
- en: The Advantages of Ansible
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 的优势
- en: There are many infrastructure automation frameworks besides Ansible—namely Chef,
    Puppet, and SaltStack. Each framework offers its unique features; no one right
    framework fits all organizations. In this section, let’s take a look at some of
    the advantages of Ansible and why I believe it is a good tool for network automation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Ansible 之外，还有许多基础设施自动化框架，如 Chef、Puppet 和 SaltStack。每个框架都提供其独特的功能；没有一个框架适合所有组织。在本节中，让我们看看
    Ansible 的一些优势以及为什么我相信它是网络自动化的好工具。
- en: The advantages will be listed with limited comparison to other frameworks to
    not start a flame war. Other frameworks might adopt some of the same philosophies
    or certain aspects of Ansible, but rarely do they contain all of the features
    that I will be mentioning. It is the combination of all the following features
    and philosophies that makes Ansible ideal for network automation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 优点将与其他框架进行有限的比较，以避免引发争论战。其他框架可能会采用一些相同的理念或Ansible的某些方面，但很少会包含我将要提到的所有功能。正是所有以下功能和理念的组合使得Ansible非常适合网络自动化。
- en: Agentless
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无代理
- en: Unlike some of its peers, Ansible does not require a strict master-client model.
    No software or agent needs to be installed on the client that communicates back
    to the server. Outside of the Python interpreter, which many platforms have by
    default, there is no additional software needed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与其一些同行不同，Ansible不需要严格的master-client模型。不需要在向服务器通信的客户端上安装任何软件或代理。除了许多平台默认拥有的Python解释器之外，不需要额外的软件。
- en: For network automation modules, instead of relying on remote host agents, Ansible
    uses SSH or API calls to push the required changes to the remote host. This further
    reduces the need for a Python interpreter. This is huge for network device management,
    as network vendors are typically reluctant to put third-party software on their
    platforms. SSH, on the other hand, already exists on the network equipment. As
    we saw from *Chapter 3*, *APIs and Intent-Driven Networking*, newer network devices
    also provide an API layer, which can also be leveraged by Ansible.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络自动化模块，Ansible不是依赖于远程主机代理，而是使用SSH或API调用将所需更改推送到远程主机。这进一步减少了Python解释器的需求。这对于网络设备管理来说是个巨大的优势，因为网络供应商通常不愿意在他们的平台上安装第三方软件。另一方面，SSH已经存在于网络设备上。正如我们在*第三章*，*APIs和Intent-Driven
    Networking*中看到的那样，较新的网络设备也提供了API层，这也可以被Ansible利用。
- en: Because there is no agent on the remote host, Ansible uses a `push` model to
    push the changes to the device, as opposed to the `pull` model, where the agent
    pulls the information from the master server. The `push` model is more deterministic
    as everything originates from the control machine. In a `pull` model, the timing
    of the `pull` might vary from client to client and therefore results in timing
    variance.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于远程主机上没有代理，Ansible使用`push`模型将更改推送到设备，而不是`pull`模型，其中代理从主服务器拉取信息。`push`模型更确定，因为所有内容都源自控制机器。在`pull`模型中，`pull`的时间可能会因客户端而异，因此导致时间差异。
- en: Again, the importance of being agentless cannot be stressed enough when working
    with the existing network equipment. This is usually one of the major reasons
    network operators and vendors embrace Ansible.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，当与现有的网络设备一起工作时，无代理的重要性不容忽视。这通常是网络运营商和供应商接受Ansible的主要原因之一。
- en: Idempotence
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 幂等性
- en: According to Wikipedia, idempotence is the property of certain operations in
    mathematics and computer science that can be applied multiple times without changing
    the result beyond the initial application ([https://en.wikipedia.org/wiki/Idempotence](https://en.wikipedia.org/wiki/Idempotence)).
    In more common terms, it means that running the same procedure repeatedly does
    not change a system after the first time. Ansible aims to be idempotent, which
    is good for network operations that require a certain order of operations. In
    our first playbook example, there is a ‘changed’ value when the playbook is run;
    this value will be ‘false’ if there was no change made on the remote device.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科，幂等性是数学和计算机科学中某些操作的性质，可以在不改变初始应用结果的情况下多次应用([https://zh.wikipedia.org/wiki/幂等性](https://zh.wikipedia.org/wiki/幂等性))。用更通俗的话来说，这意味着重复执行相同的程序不会在第一次之后改变系统。Ansible旨在实现幂等性，这对于需要特定操作顺序的网络操作来说是个优点。在我们的第一个playbook示例中，当playbook运行时会有一个‘changed’值；如果远程设备上没有进行任何更改，这个值将是‘false’。
- en: The advantage of idempotence is best compared to the Pexpect and Paramiko scripts
    we have written. Remember that these scripts were written to push out commands
    like an engineer was sitting at the terminal. If you were to execute the script
    10 times, the script would make the same changes 10 times. If we write the same
    task via the Ansible playbook, the existing device configuration will be checked
    first, and the playbook will only execute if the changes do not exist. If we execute
    the playbook 10 times, the change will only be applied during the first run, with
    the next 9 runs suppressing the configuration change.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等性的优势最好与我们所编写的Pexpect和Paramiko脚本进行比较。请记住，这些脚本是为了像工程师坐在终端一样推送命令而编写的。如果你执行脚本10次，脚本会进行10次相同的变化。如果我们通过Ansible剧本编写相同的任务，首先会检查现有设备配置，并且只有在没有变化的情况下剧本才会执行。如果我们执行剧本10次，变化只会在第一次运行时应用，接下来的9次运行将抑制配置更改。
- en: Being idempotent, we can repeatedly execute the playbook without worrying that
    there will be unnecessary changes made. This is important as we need to automatically
    check for state consistency without extra overhead.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于幂等性，我们可以反复执行剧本而不用担心会有不必要的更改。这对于我们需要自动检查状态一致性而不增加额外开销来说非常重要。
- en: Simple and Extensible
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单和可扩展
- en: Ansible is written in Python and uses YAML for the playbook language, both of
    which are relatively easy to learn. Remember the Cisco IOS syntax? This is a domain-specific
    language that is only applicable when you are managing Cisco IOS devices or other
    similarly structured equipment; it is not a general-purpose language beyond its
    limited scope. Luckily, unlike some other automation tools, there is no extra
    **domain-specific language** (**DSL**) to learn for Ansible because YAML and Python
    are both widely used as general-purpose languages.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是用Python编写的，并使用YAML作为剧本语言，这两者都相对容易学习。还记得Cisco IOS语法吗？这是一种仅在管理Cisco IOS设备或其他类似结构的设备时适用的领域特定语言；它不是一种超出其有限范围的通用语言。幸运的是，与一些其他自动化工具不同，Ansible没有额外的**领域特定语言**（**DSL**）需要学习，因为YAML和Python都是广泛使用的通用语言。
- en: Ansible is extensible. As illustrated by the preceding example, Ansible starts
    with automating server (primarily Linux) workloads in mind. It then branches out
    to manage Windows machines with PowerShell. As more and more people in the network
    industry have started to adopt Ansible, network automation is now the main staple
    in Ansible workgroups.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是可扩展的。正如前面的例子所示，Ansible最初是为了自动化服务器（主要是Linux）工作负载而设计的。然后它扩展到使用PowerShell管理Windows机器。随着越来越多的网络行业人士开始采用Ansible，网络自动化现在已成为Ansible工作组的主要支柱。
- en: The simplicity and extensibility speak well for future-proofing. The technology
    world is evolving fast, and we are constantly trying to adapt. Wouldn’t it be
    great to learn a technology once and continue to use it, regardless of the latest
    trend? Ansible’s track record speaks well for future technology adaptation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 简单性和可扩展性为未来的可靠性提供了良好的保障。技术世界正在快速发展，我们一直在努力适应。如果能够学习一种技术并持续使用，而不受最新趋势的影响，那岂不是很好？Ansible的记录很好地证明了未来技术的适应性。
- en: Now that we’ve covered some of the advantages of Ansible, let’s build on what
    we have learned so far with more features.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了一些Ansible的优势，让我们在此基础上，利用更多功能继续学习。
- en: Ansible Content Collections
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible内容集合
- en: 'Let’s start by listing out all the modules we have at hand with the default
    Ansible installation. They are organized into Content Collections ([https://www.ansible.com/products/content-collections](https://www.ansible.com/products/content-collections)),
    sometimes called collections for abbreviation. We can list out the collections
    via the `ansible-galaxy collection list` command. Some of the notable network
    collections are listed out below:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先列出默认Ansible安装中我们手头的所有模块。它们被组织到内容集合中（[https://www.ansible.com/products/content-collections](https://www.ansible.com/products/content-collections)），有时简称为集合。我们可以通过`ansible-galaxy
    collection list`命令列出集合。以下列出了一些值得注意的网络集合：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As shown from the list, even with the default installation, there is a large
    collection of network-related modules we can use. They range from enterprise software
    to open-source projects. Taking a look at the list and reading up on the ones
    that are of interest in your production environment would be a good start. Ansible
    documentation also provides a full list of all the available collections, [https://docs.ansible.com/ansible/latest/collections/index.html](https://docs.ansible.com/ansible/latest/collections/index.html).
    The collections can also be expanded via the `agalaxy` `install` command, [https://docs.ansible.com/ansible/latest/user_guide/collections_using.html](https://docs.ansible.com/ansible/latest/user_guide/collections_using.html).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表所示，即使使用默认安装，我们也有大量的网络相关模块可以使用。它们从企业软件到开源项目都有。查看列表并阅读您生产环境中感兴趣的内容是一个好的开始。Ansible文档还提供了所有可用集合的完整列表，[https://docs.ansible.com/ansible/latest/collections/index.html](https://docs.ansible.com/ansible/latest/collections/index.html)。集合也可以通过`agalaxy`
    `install`命令进行扩展，[https://docs.ansible.com/ansible/latest/user_guide/collections_using.html](https://docs.ansible.com/ansible/latest/user_guide/collections_using.html)。
- en: More Ansible Network Examples
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多Ansible网络示例
- en: Our first Ansible network example took us from being a noob to running our first
    useful network automation task. Let’s try to build from the foundation and learn
    more features.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一个Ansible网络示例让我们从新手变成了运行第一个有用的网络自动化任务。让我们从基础开始，学习更多功能。
- en: 'We will begin by seeing how we can build an inventory file that includes all
    of our network devices. If you recall, we have two data centers, each with core
    and edge devices:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看看我们如何构建一个包含我们所有网络设备的清单文件。如果您还记得，我们有两个数据中心，每个数据中心都有核心和边缘设备：
- en: '![](img/B18403_04_05.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18403_04_05.png)'
- en: 'Figure 4.5: Full Lab Topology'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：完整实验室拓扑
- en: In this example, we will include all of the devices in our inventory file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将包含我们清单文件中的所有设备。
- en: Inventory Nesting
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清单嵌套
- en: 'We can build an inventory file that includes nesting. For example, we can put
    together a host file named `hosts_full` that includes children from one group
    to another:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构建一个包含嵌套的清单文件。例如，我们可以创建一个名为`hosts_full`的主机文件，它包含来自一个组到另一个组的子组：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the file, we group the devices via both roles and features using the `[<name>:children]`
    format. To work with this new inventory file, we will need to update the `host_vars`
    directory to include the respective names of the devices:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中，我们使用`[<name>:children]`格式通过角色和功能对设备进行分组。为了使用这个新的清单文件，我们需要更新`host_vars`目录以包含相应设备的名称：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will also need to change the `ansible_host` and `ansible_network_os` accordingly,
    using `lax-cor-r1` as an example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要相应地更改`ansible_host`和`ansible_network_os`，以`lax-cor-r1`为例：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we can use the parent’s group name to include its children. For example,
    in the `nxos_config_backup.yml` playbook, we only specified the parent group of
    `nxos_devices` instead of `all`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用父组的名称来包含其子组。例如，在`nxos_config_backup.yml`剧本中，我们只指定了`nxos_devices`的父组而不是`all`：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When we execute this playbook, it will automatically include its children, `lax_cor_devices`
    and `nyc_cor_devices`. Also note that we use a separate `nxos_config` module ([https://docs.ansible.com/ansible/latest/collections/cisco/nxos/nxos_config_module.html#ansible-collections-cisco-nxos-nxos-config-module](https://docs.ansible.com/ansible/latest/collections/cisco/nxos/nxos_config_module.html#ansible-collections-cisco-nxos-nxos-config-module))
    to accommodate the new device type.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行这个剧本时，它将自动包含其子组，`lax_cor_devices`和`nyc_cor_devices`。此外，请注意，我们使用单独的`nxos_config`模块([https://docs.ansible.com/ansible/latest/collections/cisco/nxos/nxos_config_module.html#ansible-collections-cisco-nxos-nxos-config-module](https://docs.ansible.com/ansible/latest/collections/cisco/nxos/nxos_config_module.html#ansible-collections-cisco-nxos-nxos-config-module))来适应新的设备类型。
- en: Ansible Conditionals
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible条件语句
- en: Ansible conditionals are similar to conditional statements in programming languages.
    Ansible uses conditional keywords to only run a task when a given condition is
    met. In many cases, the execution of a play or task may depend on the value of
    a fact, variable, or the previous task result. For example, if you have a play
    to upgrade router images, you want to include a step to make sure the new router
    image is on the device before you move on to the next play of rebooting the router.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible条件语句类似于编程语言中的条件语句。Ansible使用条件关键字仅在给定条件满足时运行任务。在许多情况下，剧本或任务的执行可能取决于事实、变量或先前任务的结果。例如，如果您有一个升级路由器映像的剧本，您希望在继续到下一个重启路由器的剧本之前，确保新的路由器映像已经在设备上。
- en: 'In this example, we will look at the `when` clause, which is supported for
    all modules. The `when` clause is useful when you need to check the output of
    a variable or a play execution result and act accordingly. Some of the conditions
    are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将查看`when`子句，它适用于所有模块。`when`子句在您需要检查变量或剧本执行结果的输出并根据结果采取行动时非常有用。以下是一些条件：
- en: Equal to (`eq`)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等于（`eq`）
- en: Not equal to (`neq`)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不等于（`neq`）
- en: Greater than (`gt`)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大于（`gt`）
- en: Greater than or equal to (`ge`)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大于或等于（`ge`）
- en: Less than (`lt`)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小于（`lt`）
- en: Less than or equal to (`le`)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小于或等于（`le`）
- en: Contains
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含
- en: 'Let’s take a look at the following playbook named `ios_conditional.yml`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下名为`ios_conditional.yml`的剧本：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the playbook, there are two tasks. In the first task, we use the `register`
    module to save the output of the command `show` `run` | `i hostname` in a variable
    called `output`. The `output` variable contains a `stdout` list with the output.
    We use the `when` clause to only show the output when the hostname is `nyc-edg-r2`.
    Let’s execute the playbook:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在剧本中，有两个任务。在第一个任务中，我们使用`register`模块将`show run | i hostname`命令的输出保存到名为`output`的变量中。`output`变量包含一个包含输出的`stdout`列表。我们使用`when`子句仅在主机名为`nyc-edg-r2`时显示输出。让我们执行剧本：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can see the output of `lax-edg-r1`, `lax-edg-r2`, and `nyc-edg-r1` were skipped
    because they did not meet the condition. Furthermore, we can see the `changed=0`
    output for all the devices. This is in accordance with the idempotency feature
    of Ansible.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`lax-edg-r1`、`lax-edg-r2`和`nyc-edg-r1`的输出被跳过了，因为它们没有满足条件。此外，我们还可以看到所有设备的`changed=0`输出。这与Ansible的幂等性功能一致。
- en: Configuration Change
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置更改
- en: 'We can combine the conditional with configuration changes—for example, in the
    following playbook, `ios_conditional_config.yml`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将条件与配置更改结合起来——例如，在以下剧本中，`ios_conditional_config.yml`：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We would only change the logging buffer when the condition is met. Here is
    the output when we execute the playbook for the first time:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有在条件满足时才会更改日志缓冲区。以下是第一次执行剧本时的输出：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `nyc-edg-r2` device console will show the configuration is changed:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`nyc-edg-r2`设备控制台将显示配置已更改：'
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, when we run the playbook for the second time, the same change is NOT
    applied again because it is already changed:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们第二次运行剧本时，相同的更改不再应用，因为它已经更改：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How cool is that? With a simple playbook, we can safely apply a configuration
    change to only the devices we want to apply the change to with idempotency in
    check.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这有多酷？只需一个简单的剧本，我们就可以安全地将配置更改应用到我们想要更改的设备上，同时检查幂等性。
- en: Ansible Network Facts
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible 网络事实
- en: Prior to 2.5, Ansible networking shipped with a number of vendor-specific fact
    modules. As a result, the naming and usage of the facts were different between
    vendors. Starting with version 2.5, Ansible started to standardize its network
    fact modules. The Ansible network fact modules gather information from a system
    and store the results in facts prefixed with `ansible_net_`. The data collected
    by these modules is documented in the *return values* in the module documentation.
    This is useful as we can gather network facts and only perform tasks based on
    them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.5版本之前，Ansible 网络附带了一些厂商特定的事实模块。因此，不同厂商的事实命名和用法不同。从2.5版本开始，Ansible 开始标准化其网络事实模块。Ansible
    网络事实模块从系统收集信息，并将结果存储在以`ansible_net_`为前缀的事实中。这些模块收集的数据在模块文档的*返回值*中进行了记录。这很有用，因为我们可以收集网络事实，并根据它们执行任务。
- en: 'As an example of the `ios_facts` module, below is the content of the `ios_facts_playbook`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`ios_facts`模块的示例，以下为`ios_facts_playbook`的内容：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We are introducing a concept of variables in this playbook. The double curly
    brackets of `{{ }}` indicates it is a variable and the value of the variable should
    be presented for the output.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个剧本中，我们引入了一个变量的概念。双大括号`{{ }}`表示它是一个变量，变量的值应该用于输出。
- en: 'Upon execution of the playbook, here is a partial output:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 执行剧本后，这里是部分输出：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can now leverage the facts to combine with our conditional clause to customize
    our operations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以利用这些事实与我们的条件语句结合，以自定义我们的操作。
- en: Ansible Loops
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible 循环
- en: 'Ansible provides a number of looping functions in the playbook: standard loops,
    looping over files, sub-elements, `do-until`, and many more. In this section,
    we will look at two of the most commonly used loop forms: standard loops and looping
    over hash values.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 在 playbook 中提供了一系列循环函数：标准循环、遍历文件、子元素、`do-until` 以及更多。在本节中，我们将探讨两种最常用的循环形式：标准循环和遍历哈希值。
- en: Standard Loops
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准循环
- en: 'Standard loops in playbooks are often used to easily perform similar tasks
    multiple times. The syntax for standard loops is very easy: the `{{ item }}` variable
    is the placeholder looping over the `loop` list. In our next example, `standard_loop.yml`,
    we will loop over the items in the `loop` list with the `echo` command showing
    the output from our `localhost`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 playbook 中，标准循环通常用于轻松地多次执行类似任务。标准循环的语法非常简单：`{{ item }}` 变量是循环遍历 `loop` 列表的占位符。在我们的下一个示例
    `standard_loop.yml` 中，我们将使用 `echo` 命令遍历 `loop` 列表中的项目，并显示来自我们的 `localhost` 的输出。
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s go ahead and execute the playbook:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续执行 playbook：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Using the same concept, we can systematically add VLANs to our devices. Here
    is an example of adding three VLANs to a host with a playbook titled `standard_loop_vlan_example.yml`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的概念，我们可以系统地使用 playbook 向我们的设备添加 VLAN。以下是一个使用名为 `standard_loop_vlan_example.yml`
    的 playbook 向主机添加三个 VLAN 的示例：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The playbook output is as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: playbook 输出如下：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As we can see from the playbook, the loop list can be read from a variable,
    which gives greater flexibility to the structure of your playbook:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从 playbook 中我们可以看到，循环列表可以读取自一个变量，这为你的 playbook 结构提供了更大的灵活性：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The standard loop is a great time saver when it comes to performing redundant
    tasks in a playbook. Let us see how we can loop over a dictionary in the next
    section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 标准循环在 playbook 中执行重复性任务时是一个节省时间的好方法。让我们看看我们如何在下一节中遍历字典。
- en: Looping over Dictionaries
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历字典
- en: When we need to generate a configuration, we often have an entity with more
    than one attribute associated with it. If you think about the VLAN example in
    the last section, each VLAN would have several unique attributes, such as a description,
    a gateway IP address, and possibly others. Often, we can use a dictionary to represent
    the entity to incorporate multiple attributes into it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要生成配置时，我们通常会有一个与多个属性相关联的实体。如果你考虑上一节中的 VLAN 示例，每个 VLAN 都会有几个独特的属性，例如描述、网关
    IP 地址，可能还有其他属性。通常，我们可以使用字典来表示实体，以将其多个属性合并到其中。
- en: 'Let’s expand on the previous example to include a dictionary variable in `standard_loop_vlan_example_2.yml`.
    We defined the dictionary values for three `vlan` each with a nested dictionary
    for the description and the IP address:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展之前的示例，在 `standard_loop_vlan_example_2.yml` 中包含一个字典变量。我们为三个 `vlan` 定义了字典值，每个
    `vlan` 都有一个嵌套字典用于描述和 IP 地址：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the playbook, we configure the first task to add the VLANs by using the key
    of the items. In the second task, we proceed with configuring the VLAN interfaces
    using the values within each of the items. Note that we use the `parents` parameter
    to uniquely identify the section the commands should be checked against. This
    is due to the fact that the description and the IP address are both configured
    under the `interface vlan <number>` subsection in the configuration.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 playbook 中，我们通过使用项目的键来配置第一个任务以添加 VLAN。在第二个任务中，我们使用每个项目中的值来配置 VLAN 接口。请注意，我们使用
    `parents` 参数来唯一标识应该检查命令的章节。这是因为描述和 IP 地址都是在配置中的 `interface vlan <number>` 子章节下配置的。
- en: 'Before we execute the command, we need to make sure the layer 3 interface feature
    is enabled on the `nyc-cor-r1` device:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们执行命令之前，我们需要确保在 `nyc-cor-r1` 设备上启用了三层接口功能：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can run the playbook as we have done previously. We can see the dictionary
    being looped through:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像之前一样运行 playbook。我们可以看到正在循环的字典：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can verify the end result on the device:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在设备上验证最终结果：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For more loop types of Ansible, feel free to check out the corresponding documentation
    ([https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_loops.html)).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Ansible 的更多循环类型，请随时查看相应的文档([https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_loops.html))。
- en: Looping over dictionaries takes some practice the first few times you use them.
    But just like standard loops, looping over dictionaries will be an invaluable
    tool in our tool belt. An Ansible loop is a tool that can save us time and make
    the playbook more readable. In the next section, we will look at Ansible templates
    that allow us to make systematic changes to text files commonly used for network
    device configuration.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次使用字典进行循环时需要一些练习。但就像标准循环一样，使用字典循环将成为我们工具箱中的无价之宝。Ansible循环是一个可以节省我们时间并使playbook更易读的工具。在下一节中，我们将探讨Ansible模板，这些模板允许我们对网络设备配置中常用的文本文件进行系统性的更改。
- en: Templates
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: Ever since I started working as a network engineer, I have always used some
    kind of network templating system. In my experience, many of the network devices
    have sections of the network configuration that are identical, especially if these
    devices serve the same role in the network.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我开始担任网络工程师以来，我始终使用某种网络模板系统。根据我的经验，许多网络设备的网络配置部分是相同的，尤其是如果这些设备在网络中扮演相同的角色。
- en: Most of the time, when we need to provision a new device, we use the same configuration
    in the form of a template, replace the necessary fields, and copy the file over
    to the new device. With Ansible, you can automate all of the work by using the
    templating feature ([https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_templating.html)).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，当我们需要部署新设备时，我们使用模板形式的相同配置，替换必要的字段，然后将文件复制到新设备上。使用Ansible，您可以通过使用模板功能([https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html))来自动化所有工作。
- en: Ansible uses Jinja ([https://jinja.palletsprojects.com/en/3.1.x/](https://jinja.palletsprojects.com/en/3.1.x/))
    templating to enable dynamic expressions and access to variables and facts. Jinja
    has its own syntax and method of doing loops and conditionals; fortunately, we
    just need to know the very basics of it for our purpose. The Ansible template
    module is an important tool that we will be using in our daily tasks, and we will
    spend more of this section exploring it. We will learn the syntax by gradually
    building up our playbook from some simple tasks to more complex ones.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible使用Jinja ([https://jinja.palletsprojects.com/en/3.1.x/](https://jinja.palletsprojects.com/en/3.1.x/))
    模板来启用动态表达式和访问变量和事实。Jinja有其自己的语法和循环、条件的方法；幸运的是，为了我们的目的，我们只需要了解它的基础知识。Ansible模板模块是我们日常任务中将要使用的重要工具，我们将在本节中更多地探讨它。我们将通过逐步构建我们的playbook，从一些简单的任务到更复杂的任务，来学习语法。
- en: The basic syntax for template usage is very simple; we just need to specify
    the source file and the destination location that we want to copy it to.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 模板使用的语法非常简单；我们只需指定源文件和我们要复制到的目标位置。
- en: 'Let us create a new directory called `Templates` and start to create our playbooks.
    We will create an empty file for now:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`Templates`的新目录，并开始创建我们的playbook。我们现在将创建一个空文件：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then we will use the following playbook, `template_1.yml`, to copy `file1`
    to `file2`. Note that the playbook is executed on the control machine only:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用以下playbook，`template_1.yml`，将`file1`复制到`file2`。请注意，playbook仅在控制机上执行：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Executing the playbook will create a new file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 执行playbook将创建一个新文件：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In our templates, the source files can have any extension, but since they are
    processed through the Jinja2 template engine, let’s create a text file called
    `nxos.j2` as the template source. The template will follow the Jinja convention
    of using double curly braces to specify the variables, as well as using the curly
    brace plus the percentage sign to specify commands:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模板中，源文件可以有任意扩展名，但由于它们将通过Jinja2模板引擎进行处理，让我们创建一个名为`nxos.j2`的文本文件作为模板源。模板将遵循Jinja约定，使用双大括号来指定变量，以及使用大括号加百分号来指定命令：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can now put together a playbook to create network configuration templates
    based on the `nxos.j2` file.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以组合一个playbook，根据`nxos.j2`文件创建网络配置模板。
- en: The Jinja Template Variables
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jinja模板变量
- en: 'The `template_2.yml` playbook expands on the previous template example with
    the following additions:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`template_2.yml` playbook在先前的模板示例的基础上增加了以下内容：'
- en: The source file is `nxos.j2`.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源文件是`nxos.j2`。
- en: The destination filename is now a variable taken from the `nexus_devices` variable
    defined in the playbook.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标文件名现在是从playbook中定义的`nexus_devices`变量中获取的变量。
- en: Each of the devices within `nexus_devices` contains the variables that would
    be substituted or looped over within the template.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nexus_devices`中的每个设备都包含在模板中将被替换或循环遍历的变量。'
- en: 'The playbook might look more complex than the last one, but if you take out
    the variable definition portion, it is very similar to our simple template playbook
    from earlier:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个playbook可能看起来比上一个复杂，但如果去掉变量定义部分，它与之前简单的模板playbook非常相似：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Let us not execute the playbook just yet; we still need to take a look at the
    `if` conditional statements and `for` loops enclosed within the `{% %}` symbols
    from the `Jinja2` template.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不要立即执行playbook；我们还需要查看`Jinja2`模板中的`{% %}`符号内的`if`条件语句和`for`循环。
- en: Jinja Template Loops
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jinja模板循环
- en: 'There are two `for` loops in our `nxos.j2` template; one loops over the VLANs
    and the other loops over the VLAN interfaces:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`nxos.j2`模板中，有两个`for`循环；一个循环遍历VLAN，另一个循环遍历VLAN接口：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you recall, we can also loop through a list as well as a dictionary in Jinja.
    In our example, the `vlans` variable is a list, while the `vlan_interfaces` variable
    is a list of dictionaries.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，我们也可以在Jinja中循环遍历列表以及字典。在我们的例子中，`vlans`变量是一个列表，而`vlan_interfaces`变量是一个字典列表。
- en: The `vlan_interfaces` loop is nested inside a conditional. This is the last
    thing that we will incorporate into our playbook before we execute the playbook.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`vlan_interfaces`循环嵌套在一个条件语句中。在我们执行playbook之前，这是我们将要整合到playbook中的最后一件事。'
- en: Jinja Template Conditional
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jinja模板条件语句
- en: 'Jinja supports an `if` conditional check. We have added this conditional statement
    in two locations within the `nxos.j2` template; one is with the `netflow` variable
    and the other is the `l3_vlan_interfaces` variable. Only when the condition is
    `True` will we execute the statements within the block:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja支持`if`条件检查。我们在`nxos.j2`模板中的两个位置添加了这个条件语句；一个是`netflow`变量，另一个是`l3_vlan_interfaces`变量。只有当条件为`True`时，我们才会执行块内的语句：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the playbook, we have declared `netflow_enable` to be `True` for `nx-os-v1`
    and `False` for `nx-osv-2`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在playbook中，我们已将`netflow_enable`声明为`nx-os-v1`的`True`和`nx-osv-2`的`False`：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, we are ready to run our playbook:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备运行我们的playbook：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Do you remember that the destination files are named after the `{{ item.key
    }}.conf?` Two files have been created with the device names:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得目标文件是以`{{ item.key }}.conf`命名的吗？已经创建了两个以设备名称命名的文件：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let’s check the similarities and differences of the two configuration files
    to make sure all of our intended changes are in place. Both files should contain
    the static items, such as `feature ospf`, the hostnames and other variables should
    be substituted accordingly, and only `nx-osv-1.conf` should have `netflow` enabled
    as well as the layer 3 `vlan` interface configuration:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这两个配置文件的相似之处和不同之处，以确保所有预期的更改都已到位。两个文件都应该包含静态项，例如`feature ospf`，主机名和其他变量应相应替换，并且只有`nx-osv-1.conf`应该启用`netflow`以及三层`vlan`接口配置：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s take a look at the `nx-osv-2.conf` file:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`nx-osv-2.conf`文件：
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Neat, huh? This can certainly save us a ton of time for something that previously
    required repeated copying and pasting. Personally, the template module was a big
    game-changer for me. This module alone was enough to motivate me to learn and
    use Ansible a few years ago.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 真的吗？这确实可以为我们节省大量时间，因为之前需要重复复制粘贴。就我个人而言，模板模块对我来说是一个巨大的变革。仅此模块就足以激励我在几年前学习并使用Ansible。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a grand tour of the open-source automation framework
    Ansible. Unlike Pexpect-based and API-driven network automation scripts, Ansible
    provides a higher layer of abstraction called a playbook to automate our network
    devices.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们全面了解了开源自动化框架Ansible。与基于Pexpect和API驱动的网络自动化脚本不同，Ansible提供了一个更高层次的抽象，称为playbook，用于自动化我们的网络设备。
- en: Ansible is a full-featured automation framework capable of managing large infrastructures.
    Our focus is on managing network devices, but Ansible is capable of managing servers,
    databases, cloud infrastructures, and more. We have only touched the surface of
    its capabilities. If you feel Ansible is a tool you would like to learn more about,
    the Ansible documentation is an excellent source of reference. The Ansible community
    is friendly and welcoming if you would like to get involved.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是一个功能齐全的自动化框架，能够管理大型基础设施。我们的重点是管理网络设备，但Ansible还能够管理服务器、数据库、云基础设施等等。我们只是触及了其功能的一角。如果你觉得Ansible是一个你想要了解更多信息的工具，Ansible文档是一个极好的参考资料来源。如果你想要参与，Ansible社区友好且欢迎。
- en: In *Chapter 5*,*Docker Containers for Network Engineers*, we will start to learn
    about Docker and the world of containers.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第5章*，*网络工程师的Docker容器*，我们将开始学习Docker和容器世界。
- en: Join our book community
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的书籍社区
- en: 'To join our community for this book – where you can share feedback, ask questions
    to the author, and learn about new releases – follow the QR code below:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入我们这本书的社区——在那里你可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
- en: '![](img/QR_Code2903617220506617062.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2903617220506617062.png)'
