- en: Chapter 8. The Itertools Module
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 迭代工具模块
- en: Functional programming emphasizes stateless programming. In Python this leads
    us to work with generator expressions, generator functions, and iterables. In
    this chapter, we'll look at the itertools library with numerous functions to help
    us work with iterable collections.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程强调无状态编程。在Python中，这导致我们使用生成器表达式、生成器函数和可迭代对象。在本章中，我们将研究`itertools`库，其中有许多函数可以帮助我们处理可迭代的集合。
- en: We introduced iterator functions in [Chapter 3](ch03.html "Chapter 3. Functions,
    Iterators, and Generators"), *Functions, Iterators, and Generators*. In this chapter,
    we'll expand on that superficial introduction. We used some related functions
    in [Chapter 5](ch05.html "Chapter 5. Higher-order Functions"), *Higher-order Functions*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](ch03.html "第3章. 函数、迭代器和生成器")中介绍了迭代器函数，*函数、迭代器和生成器*。在本章中，我们将扩展对其的简单介绍。我们在[第5章](ch05.html
    "第5章. 高阶函数")中使用了一些相关函数，*高阶函数*。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some of the functions merely behave like they are proper, lazy Python iterables.
    It's important to look at the implementation details for each of these functions.
    Some of them create intermediate objects, leading to the potential of consuming
    a large amount of memory. Since implementations might change with Python releases,
    we can't provide function-by-function advice here. If you have performance or
    memory issues, ensure that you check the implementation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数只是表现得像是合适的、惰性的Python可迭代对象。重要的是要查看每个函数的实现细节。其中一些函数会创建中间对象，导致可能消耗大量内存。由于实现可能会随着Python版本的发布而改变，我们无法在这里提供逐个函数的建议。如果您遇到性能或内存问题，请确保检查实现。
- en: 'There are a large number of iterator functions in this module. We''ll examine
    some of the functions in the next chapter. In this chapter, we''ll look at three
    broad groupings of iterator functions. These are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块中有大量的迭代器函数。我们将在下一章中检查一些函数。在本章中，我们将看一下三种广泛的迭代器函数。它们如下：
- en: Functions that work with infinite iterators. These can be applied to any iterable
    or an iterator over any collection; they will consume the entire source.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与无限迭代器一起工作的函数。这些函数可以应用于任何可迭代对象或任何集合上的迭代器；它们将消耗整个源。
- en: Functions that work with finite iterators. These can either accumulate a source
    multiple times, or they produce a reduction of the source.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与有限迭代器一起工作的函数。这些函数可以多次累积源，或者它们会产生源的减少。
- en: 'The tee iterator function which clones an iterator into several copies that
    can each be used independently. This provides a way to overcome the primary limitation
    of Python iterators: they can be used once only.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tee迭代器函数可以将迭代器克隆为几个可以独立使用的副本。这提供了一种克服Python迭代器的主要限制的方法：它们只能使用一次。
- en: We need to emphasize an important limitation of iterables that we've touched
    upon in other places.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要强调一个重要的限制，这是我们在其他地方提到过的。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Iterables can be used only once.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代对象只能使用一次。
- en: This can be astonishing because there's no error. Once exhausted, they appear
    to have no elements and will raise the `StopIteration` exception every time they're
    used.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能令人惊讶，因为没有错误。一旦耗尽，它们似乎没有元素，并且每次使用时都会引发`StopIteration`异常。
- en: 'There are some other features of iterators that aren''t such profound limitations.
    They are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器的一些其他特性并不是如此深刻的限制。它们如下：
- en: There's no `len()` function for an iterable. In almost every other respect,
    they appear to be a container.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可迭代对象没有`len()`函数。在几乎所有其他方面，它们似乎都是容器。
- en: Iterables can do `next()` operations, unlike a container.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可迭代对象可以进行`next()`操作，而容器不行。
- en: The `for` statement makes the distinction between containers and iterables invisible;
    containers will produce an iterable via the `iter()` function. An iterable simply
    returns itself.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`语句使容器和可迭代对象之间的区别变得不可见；容器将通过`iter()`函数产生一个可迭代对象。可迭代对象只是返回自身。'
- en: These points will provide some necessary background for this chapter. The idea
    of the `itertools` module is to leverage what iterables can do to create succinct,
    expressive applications without the complex-looking overheads associated with
    the details of managing the iterables.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些观点将为本章提供一些必要的背景。`itertools`模块的理念是利用可迭代对象的功能来创建简洁、表达力强的应用程序，而不需要复杂的管理可迭代对象的细节。
- en: Working with the infinite iterators
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与无限迭代器一起工作
- en: 'The `itertools` module provides a number of functions that we can use to enhance
    or enrich an iterable source of data. We''ll look at the following three functions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools`模块提供了许多函数，我们可以用它们来增强或丰富可迭代的数据源。我们将看一下以下三个函数：'
- en: '`count()`: This is an unlimited version of the `range()` function'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count()`: 这是`range()`函数的无限版本'
- en: '`cycle()`: This will reiterate a cycle of values'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cycle()`: 这将重复迭代一组值'
- en: '`repeat()`: This can repeat a single value an indefinite number of times'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeat()`: 这可以无限次重复单个值'
- en: Our goal is to understand how these various iterator functions can be used in
    generator expressions and with generator functions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是了解这些各种迭代器函数如何在生成器表达式和生成器函数中使用。
- en: Counting with count()
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用count()进行计数
- en: 'The built-in `range()` function is defined by an upper limit: the lower limit
    and step values are optional. The `count()` function, on the other hand, has a
    start and optional step, but no upper limit.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`range()`函数由上限定义：下限和步长是可选的。另一方面，`count()`函数有一个起始和可选的步长，但没有上限。
- en: 'This function can be thought of as the primitive basis for a function like
    `enumerate()`. We can define the `enumerate()` function in terms of `zip()` and
    `count()` functions, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以被认为是像`enumerate()`这样的函数的原始基础。我们可以用`zip()`和`count()`函数来定义`enumerate()`函数，如下所示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `enumerate()` function behaves as if it's a `zip()` function that uses the
    `count()` function to generate the values associated with some iterator.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate()`函数的行为就像使用`count()`函数生成与某个迭代器相关联的值的`zip()`函数。'
- en: 'Consequently, the following two commands are equivalent to each other:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下两个命令彼此等价：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Both will emit a sequence of numbers of two tuples paired with items from the
    iterator.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都会发出与迭代器中的项目配对的两个元组的数字序列。
- en: 'The `zip()` function is made slightly simpler with the use of the `count()`
    function, as shown in the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()`函数在使用`count()`函数时变得稍微简单，如下命令所示：'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will provide values of 1, 4, 7, 10, and so on, as the identifiers for each
    value from the enumerator. This is a challenge because `enumerate` doesn't provide
    a way to change the step.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提供1、4、7、10等值，作为枚举器的每个值的标识符。这是一个挑战，因为`enumerate`没有提供更改步长的方法。
- en: 'The following command describes the `enumerate()` function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令描述了`enumerate()`函数：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `count()` function permits non-integer values. We can use something like
    the `count(0.5, 0.1)` method to provide floating-point values. This will accumulate
    a substantial error if the increment value doesn't have an exact representation.
    It's generally better to use the `(0.5+x*.1 for x in count())` method to assure
    that representation errors don't accumulate.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`count()`函数允许非整数值。我们可以使用类似`count(0.5, 0.1)`的方法提供浮点值。如果增量值没有精确表示，这将累积相当大的误差。通常最好使用`(0.5+x*.1
    for x in count())`方法来确保表示错误不会累积。'
- en: 'Here''s a way to examine the accumulating error. We''ll define a function,
    which will evaluate items from an iterator until some condition is met. Here''s
    how we can define the `until()` function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种检查累积误差的方法。我们将定义一个函数，该函数将评估来自迭代器的项目，直到满足某个条件。以下是我们如何定义`until()`函数的方法：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We'll get the next value from the iterator. If it passes the test, that's our
    value. Otherwise, we'll evaluate this function recursively to search for a value
    that passes the test.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从迭代器中获取下一个值。如果通过测试，那就是我们的值。否则，我们将递归地评估这个函数，以搜索通过测试的值。
- en: 'We''ll provide a source iterable and a comparison function as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供一个源可迭代对象和一个比较函数，如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we evaluate the `until(neq, source)` method, we find the result is as
    follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估`until(neq, source)`方法时，我们发现结果如下：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After 928 iterations, the sum of the error bits has accumulated to ![Counting
    with count()](graphics/B03652_08_01.jpg). Neither value has an exact binary representation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 经过928次迭代，错误位的总和累积到![Counting with count()](graphics/B03652_08_01.jpg)。两个值都没有精确的二进制表示。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `count()` function is close to the Python recursion limit. We'd need to
    rewrite our `until()` function to use tail-call optimization to locate counts
    with larger accumulated errors.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`count()`函数接近Python递归限制。我们需要重写我们的`until()`函数，使用尾递归优化来定位具有更大累积误差的计数。'
- en: 'The smallest detectible difference can be computed as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最小可检测差异可以计算如下：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After just six steps, the `count(0, 0.1)` method has accumulated a measurable
    error of ![Counting with count()](graphics/B03652_08_02.jpg). Not a large error,
    but within 1000 steps, it will be considerably larger.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 仅经过六步，`count(0, 0.1)`方法已经累积了一个可测的误差![Counting with count()](graphics/B03652_08_02.jpg)。不是很大的误差，但在1000步内，它将变得相当大。
- en: Reiterating a cycle with cycle()
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用cycle()重复循环
- en: The `cycle()` function repeats a sequence of values. We can imagine using it
    to solve silly fizz-buzz problems.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`cycle()`函数重复一系列值。我们可以想象使用它来解决愚蠢的fizz-buzz问题。'
- en: Visit [http://rosettacode.org/wiki/FizzBuzz](http://rosettacode.org/wiki/FizzBuzz)
    for a comprehensive set of solutions to a fairly trivial programming problem.
    Also see [https://projecteuler.net/problem=1](https://projecteuler.net/problem=1)
    for an interesting variation on this theme.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[http://rosettacode.org/wiki/FizzBuzz](http://rosettacode.org/wiki/FizzBuzz)获取对一个相当琐碎的编程问题的全面解决方案。还可以参见[https://projecteuler.net/problem=1](https://projecteuler.net/problem=1)获取这个主题的有趣变化。
- en: 'We can use the `cycle()` function to emit sequences of `True` and `False` values
    as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`cycle()`函数发出`True`和`False`值的序列，如下所示：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we zip together a finite collection of numbers, we''ll get a set of triples
    with a number, and two flags showing whether or not the number is a multiple of
    3 or a multiple of 5\. It''s important to introduce a finite iterable to create
    a proper upper bound on the volume of data being generated. Here''s a sequence
    of values and their multiplier flags:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一组有限的数字压缩在一起，我们将得到一组三元组，其中一个数字和两个标志，显示该数字是否是3的倍数或5的倍数。引入有限的可迭代对象以创建正在生成的数据的适当上限是很重要的。以下是一系列值及其乘法器标志：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can now decompose the triples and use a filter to pass numbers which are
    multiples and reject all others:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以分解三元组，并使用过滤器传递是倍数的数字并拒绝所有其他数字：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function has another, more valuable use for exploratory data analysis.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数还有另一个更有价值的用途，用于探索性数据分析。
- en: 'We often need to work with samples of large sets of data. The initial phases
    of cleansing and model creation are best developed with small sets of data and
    tested with larger and larger sets of data. We can use the `cycle()` function
    to fairly select rows from within a larger set. The population size, ![Reiterating
    a cycle with cycle()](graphics/B03652_08_03.jpg), and the desired sample size,
    ![Reiterating a cycle with cycle()](graphics/B03652_08_04.jpg), denotes how long
    we can use a cycle:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要处理大量数据的样本。清洗和模型创建的初始阶段最好使用小数据集开发，并使用越来越大的数据集进行测试。我们可以使用`cycle()`函数从较大的集合中公平选择行。人口规模，![使用cycle()重复循环](graphics/B03652_08_03.jpg)，和期望的样本大小，![使用cycle()重复循环](graphics/B03652_08_04.jpg)，表示我们可以使用循环的时间长短：
- en: '![Reiterating a cycle with cycle()](graphics/B03652_08_05.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![使用cycle()重复循环](graphics/B03652_08_05.jpg)'
- en: 'We''ll assume that the data can be parsed with the `csv` module. This leads
    to an elegant way to create subsets. We can create subsets using the following
    commands:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设数据可以使用`csv`模块解析。这导致了一种优雅的方式来创建子集。我们可以使用以下命令创建子集：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We created a `cycle()` function based on the selection factor, `c`. For example,
    we might have a population of 10 million records: a 1,000-record subset involves
    picking 1/10,000 of the records. We assumed that this snippet of code is nestled
    securely inside a `with` statement that opens the relevant files. We also avoided
    showing details of any dialect issues with the CSV format files.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据选择因子`c`创建了一个`cycle()`函数。例如，我们可能有一千万条记录的人口：选择 1,000 条记录的子集涉及选择 1/10,000 的记录。我们假设这段代码片段被安全地嵌套在一个打开相关文件的`with`语句中。我们还避免显示与CSV格式文件的方言问题的细节。
- en: We can use a simple generator expression to filter the data using the `cycle()`
    function and the source data that's available from the CSV reader. Since the `chooser`
    expression and the expression used to write the rows are both non-strict, there's
    little memory overhead from this kind of processing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个简单的生成器表达式来使用`cycle()`函数和来自CSV读取器的源数据来过滤数据。由于`chooser`表达式和用于写入行的表达式都是非严格的，所以从这种处理中几乎没有内存开销。
- en: We can—with a small change—use the `random.randrange(c)` method instead of the
    `cycle(c)` method to achieve a randomized selection of a similar sized subset.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个小改变，使用`random.randrange(c)`方法而不是`cycle(c)`方法来实现类似大小的子集的随机选择。
- en: We can also rewrite this method to use `compress()`, `filter()`, and `islice()`
    functions, as we'll see later in this chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以重写这个方法来使用`compress()`、`filter()`和`islice()`函数，这些我们将在本章后面看到。
- en: This design will also reformat a file from any nonstandard CSV-like format into
    a standardized CSV format. As long as we define parser functions that return consistently
    defined tuples and write consumer functions that write tuples to the target files,
    we can do a great deal of cleansing and filtering with relatively short, clear
    scripts.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计还可以将文件从任何非标准的类CSV格式重新格式化为标准的CSV格式。只要我们定义返回一致定义的元组的解析器函数，并编写将元组写入目标文件的消费者函数，我们就可以用相对简短、清晰的脚本进行大量的清洗和过滤。
- en: Repeating a single value with repeat()
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`repeat()`重复单个值
- en: 'The `repeat()` function seems like an odd feature: it returns a single value
    over and over again. It can serve as a replacement for the `cycle()` function.
    We can extend our data subset selection function using the `repeat(0)` method
    instead of the `cycle(range(100))` method in an expression line, for example,`(x==0
    for x in some_function)`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat()`函数似乎是一个奇怪的特性：它一遍又一遍地返回一个单个值。它可以作为`cycle()`函数的替代。我们可以使用`repeat(0)`方法来扩展我们的数据子集选择函数，而不是在表达式行中使用`cycle(range(100))`方法，例如，`(x==0
    for x in some_function)`。'
- en: 'We can think of the following commands:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑以下命令：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This allows us to make a simple parameter change, which will either pick all
    data or pick a subset of data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们可以进行简单的参数更改，要么选择所有数据，要么选择数据的子集。
- en: 'We can embed this in nested loops to create more complex structures. Here''s
    a simple example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个嵌套在循环中，以创建更复杂的结构。这里有一个简单的例子：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We created repeating sequences of numbers using the `times` parameter on the
    `repeat()` function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`repeat()`函数的`times`参数创建了重复的数字序列。
- en: Using the finite iterators
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用有限迭代器
- en: 'The `itertools` module provides a number of functions that we can use to produce
    finite sequences of values. We''ll look at ten functions in this module, plus
    some related built-in functions:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools`模块提供了许多函数，我们可以用它们来生成有限的值序列。我们将在这个模块中看到十个函数，以及一些相关的内置函数：'
- en: '`enumerate()`: This function is actually part of the `__builtins__` package,
    but it works with an iterator and is very similar to other functions in the `itertools`
    module.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enumerate()`: 这个函数实际上是`__builtins__`包的一部分，但它可以与迭代器一起使用，与`itertools`模块中的其他函数非常相似。'
- en: '`accumulate()`: This function returns a sequence of reductions of the input
    iterable. It''s a higher-order function and can do a variety of clever calculations.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accumulate()`: 这个函数返回输入可迭代对象的一系列减少。它是一个高阶函数，可以进行各种巧妙的计算。'
- en: '`chain()`: This function combines multiple iterables serially.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chain()`: 这个函数将多个可迭代对象串联起来。'
- en: '`groupby()`: This function uses a function to decompose a single iterable into
    a sequence of iterables over subsets of the input data.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupby()`: 这个函数使用一个函数将单个可迭代对象分解为输入数据子集的可迭代对象序列。'
- en: '`zip_longest()`: This function combines elements from multiple iterables. The
    built-in `zip()` function truncates the sequence at the length of the shortest
    iterable. The `zip_longest()` function pads the shorter iterables with the given
    fillvalue.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip_longest()`: 这个函数将来自多个可迭代对象的元素组合在一起。内置的`zip()`函数会将序列截断到最短可迭代对象的长度。`zip_longest()`函数会用给定的填充值填充较短的可迭代对象。'
- en: '`compress()`: This function filters one iterable based on a second iterable
    of `Boolean` values.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compress()`: 这个函数基于第二个`Boolean`值可迭代对象来过滤第一个可迭代对象。'
- en: '`islice()`: This function is the equivalent of a slice of a sequence when applied
    to an iterable.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`islice()`: 当应用于可迭代对象时，这个函数相当于对序列的切片。'
- en: '`dropwhile()` and `takewhile()`: Both of these functions use a `Boolean` function
    to filter items from an iterable. Unlike `filter()` or `filterfalse()`, these
    functions rely on a single `True` or `False` value to change their filter behavior
    for all subsequent values.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dropwhile()`和`takewhile()`: 这两个函数都使用一个`Boolean`函数来过滤可迭代的项。与`filter()`或`filterfalse()`不同，这些函数依赖于单个`True`或`False`值来改变它们对所有后续值的过滤行为。'
- en: '`filterfalse()`: This function applies a filter function to an iterable. This
    complements the built-in `filter()` function.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filterfalse()`: 这个函数对可迭代对象应用一个过滤函数。这是内置的`filter()`函数的补充。'
- en: '`starmap()`: This function maps a function to an iterable sequence of tuples
    using each iterable as an `*args` argument to the given function. The `map()`
    function does a similar thing using multiple parallel iterables.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`starmap()`: 这个函数将一个函数映射到一个元组的可迭代序列，使用每个可迭代对象作为给定函数的`*args`参数。`map()`函数使用多个并行可迭代对象做类似的事情。'
- en: We've grouped these functions into approximate categories. The categories are
    roughly related to concepts of restructuring an iterable, filtering, and mapping.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将这些函数分成了大致的类别。这些类别与重构可迭代对象、过滤和映射的概念大致相关。
- en: Assigning numbers with enumerate()
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用enumerate()分配数字
- en: 'In [Chapter 7](ch07.html "Chapter 7. Additional Tuple Techniques"), *Additional
    Tuple Techniques*, we used the `enumerate()` function to make a naïve assignment
    of rank numbers to sorted data. We can do things like pairing up a value with
    its position in the original sequence, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。其他元组技术")中，*其他元组技术*，我们使用`enumerate()`函数对排序数据进行了天真的排名分配。我们可以做一些事情，比如将一个值与其在原始序列中的位置配对，如下所示：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will sort the items in `raw_values` into order, create two tuples with
    an ascending sequence of numbers, and materialize an object we can use for further
    calculations. The command and the result are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将对`raw_values`中的项目进行排序，创建两个具有升序数字序列的元组，并实现我们可以用于进一步计算的对象。命令和结果如下：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In [Chapter 7](ch07.html "Chapter 7. Additional Tuple Techniques"), *Additional
    Tuple Techniques* we implemented an alternative form of enumerate, `rank()` function,
    which would handle ties in a more statistically useful way.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。其他元组技术")中，*其他元组技术*，我们实现了一个替代形式的enumerate，`rank()`函数，它将以更具统计意义的方式处理并列。
- en: This is a common feature that is added to a parser to record the source data
    row numbers. In many cases, we'll create some kind of `row_iter()` function to
    extract the string values from a source file. This might iterate over the `string`
    values in tags of an XML file or in columns of a CSV file. In some cases, we might
    even be parsing data presented in an HTML file parsed with Beautiful Soup.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的功能，它被添加到解析器中以记录源数据行号。在许多情况下，我们将创建某种`row_iter()`函数，以从源文件中提取字符串值。这可能会迭代XML文件中标签的`string`值，或者CSV文件的列中的值。在某些情况下，我们甚至可能会解析用Beautiful
    Soup解析的HTML文件中呈现的数据。
- en: In [Chapter 4](ch04.html "Chapter 4. Working with Collections"), *Working with
    Collections*, we parsed an XML to create a simple sequence of position tuples.
    We then created legs with a start, end, and distance. We did not, however, assign
    an explicit leg number. If we ever sorted the trip collection, we'd be unable
    to determine the original ordering of the legs.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。与集合一起工作")中，*与集合一起工作*，我们解析了一个XML文件，创建了一个简单的位置元组序列。然后我们创建了带有起点、终点和距离的`Leg`。然而，我们没有分配一个明确的`Leg`编号。如果我们对行程集合进行排序，我们将无法确定`Leg`的原始顺序。
- en: 'In [Chapter 7](ch07.html "Chapter 7. Additional Tuple Techniques"), *Additional
    Tuple Techniques*, we expanded on the basic parser to create namedtuples for each
    leg of the trip. The output from this enhanced parser looks as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。其他元组技术")中，*其他元组技术*，我们扩展了基本解析器，为行程的每个`Leg`创建了命名元组。增强解析器的输出如下所示：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first `Leg` function is a short trip between two points on the Chesapeake
    Bay.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`Leg`函数是在切萨皮克湾上两点之间的短途旅行。
- en: 'We can add a function that will build a more complex tuple with the input order
    information as part of the tuple. First, we''ll define a slightly more complex
    version of the `Leg` class:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加一个函数，它将构建一个更复杂的元组，其中包含输入顺序信息作为元组的一部分。首先，我们将定义`Leg`类的一个稍微复杂的版本：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is similar to the `Leg` instance shown in [Chapter 7](ch07.html "Chapter 7. Additional
    Tuple Techniques"), *Additional Tuple Techniques* but it includes the order as
    well as the other attributes. We''ll define a function that decomposes pairs and
    creates `Leg` instances as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于[第7章](ch07.html "第7章。其他元组技术")中显示的`Leg`实例，*其他元组技术*，但它包括顺序以及其他属性。我们将定义一个函数，将成对分解并创建`Leg`实例如下：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can use this function to enumerate each pair of starting and ending points.
    We'll decompose the pair and then reassemble the `order`, `start`, and `end` parameters
    and the `haversine(start,end)` parameter's value as a single `Leg` instance. This
    `generator` function will work with an iterable sequence of pairs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此函数对每对起始和结束点进行枚举。我们将分解该对，然后重新组装`order`、`start`和`end`参数以及`haversine(start,end)`参数的值作为单个`Leg`实例。这个`generator`函数将与可迭代序列一起工作。
- en: 'In the context of the preceding explanation, it is used as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的解释的背景下，它的用法如下：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We've parsed the original file into the path points, created start-end pairs,
    and then created a trip that was built of individual `Leg` objects. The `enumerate()`
    function assures that each item in the iterable sequence is given a unique number
    that increments from the default starting value of 0\. A second argument value
    can be given to provide an alternate starting value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将原始文件解析为路径点，创建了起始-结束对，然后创建了一个由单个`Leg`对象构建的行程。`enumerate()`函数确保可迭代序列中的每个项目都被赋予一个唯一的数字，该数字从默认的起始值0递增。可以提供第二个参数值以提供替代的起始值。
- en: Running totals with accumulate()
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用accumulate()进行累积总数
- en: The `accumulate()` function folds a given function into an iterable, accumulating
    a series of reductions. This will iterate over the running totals from another
    iterator; the default function is `operator.add()`. We can provide alternative
    functions to change the essential behavior from sum to product. The Python library
    documentation shows a particularly clever use of the `max()` function to create
    a sequence of maximum values so far.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`accumulate()`函数将给定的函数折叠到可迭代对象中，累积一系列的减少。这将迭代另一个迭代器中的累积总数；默认函数是`operator.add()`。我们可以提供替代函数来改变从总和到乘积的基本行为。Python库文档显示了`max()`函数的一个特别巧妙的用法，以创建迄今为止的最大值序列。'
- en: One application of running totals is quartiling data. We can compute the running
    total for each sample and divide them into quarters with an `int(4*value/total)`
    calculation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 累积总数的一个应用是对数据进行四分位数处理。我们可以计算每个样本的累积总数，并用`int(4*value/total)`计算将它们分成四分之一。
- en: In the *Assigning numbers with enumerate()* section, we introduced a sequence
    of latitude-longitude coordinates that describe a sequence of legs on a voyage.
    We can use the distances as a basis for quartiling the waypoints. This allows
    us to determine the midpoint in the trip.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用enumerate()分配数字*部分，我们介绍了一系列描述航行中一系列航段的纬度-经度坐标。我们可以使用距离作为四分位数航路点的基础。这使我们能够确定航行的中点。
- en: 'The value of the `trip` variable looks as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`trip`变量的值如下：'
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Each `Leg` object has a start point, an end point, and a distance. The calculation
    of quartiles looks like the following example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Leg`对象都有一个起点、一个终点和一个距离。四分位数的计算如下例所示：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We extracted the distance values and computed the accumulated distances for
    each leg. The last of the accumulated distances is the total. We've added `1.0`
    to the total to assure that `4*d/total` is 3.9983, which truncates to 3\. Without
    the `+1.0`, the final item would have a value of `4`, which is an impossible fifth
    quartile. For some kinds of data (with extremely large values) we might have to
    add a larger value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提取了距离数值，并计算了每段的累积距离。累积距离的最后一个就是总数。我们将`1.0`添加到总数中，以确保`4*d/total`为3.9983，这将截断为3。如果没有`+1.0`，最终的项目将具有值`4`，这是一个不可能的第五个四分位数。对于某些类型的数据（具有极大的值），我们可能需要添加一个更大的值。
- en: 'The value of the `quartiles` variable is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`quartiles`变量的值如下：'
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can use the `zip()` function to merge this sequence of quartile numbers with
    the original data points. We can also use functions like `groupby()` to create
    distinct collections of the legs in each quartile.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`zip()`函数将这个四分位数序列与原始数据点合并。我们还可以使用`groupby()`等函数来创建每个四分位数中各段的不同集合。
- en: Combining iterators with chain()
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用chain()组合迭代器
- en: We can use the `chain()` function to combine a collection of iterators into
    a single, overall iterator. This can be helpful to combine data that was decomposed
    via the `groupby()` function. We can use this to process a number of collections
    as if they were a single collection.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`chain()`函数将一系列迭代器组合成一个单一的整体迭代器。这对于组合通过`groupby()`函数分解的数据非常有用。我们可以使用这个来处理多个集合，就好像它们是一个单一的集合一样。
- en: 'In particular, we can combine the `chain()` function with the `contextlib.ExitStack()`
    method to process a collection of files as a single iterable sequence of values.
    We can do something like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们可以将`chain()`函数与`contextlib.ExitStack()`方法结合使用，以处理文件集合作为单个可迭代值序列。我们可以做如下操作：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We've created an `ExitStack` object that can contain a number of individual
    contexts open. When the `with` statement finishes, all items in the `ExitStack`
    object will be closed properly. We created a simple sequence of open file objects;
    these objects were also entered into the `ExitStack` object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`ExitStack`对象，可以包含许多单独的上下文打开。当`with`语句结束时，`ExitStack`对象中的所有项目都将被正确关闭。我们创建了一个简单的打开文件对象序列；这些对象也被输入到了`ExitStack`对象中。
- en: Given the sequence of files in the `files` variable, we created a sequence of
    CSV readers in the `readers` variable. In this case, all of our files have a common
    tab-delimited format, which makes it very pleasant to open all of the files with
    a simple, consistent application of a function to the sequence of files.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`files`变量中的文件序列，我们在`readers`变量中创建了一系列CSV读取器。在这种情况下，我们所有的文件都有一个共同的制表符分隔格式，这使得使用一个简单、一致的函数对文件序列进行打开非常愉快。
- en: 'We could also open the files using the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下命令打开文件：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, we chained all of the readers into a single iterator with `chain(*readers)`.
    This was used to yield the sequence of rows from all of the files.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将所有的读取器链接成一个单一的迭代器，使用`chain(*readers)`。这用于从所有文件中产生行的序列。
- en: It's important to note that we can't return the `chain(*readers)` object. If
    we do, this would exit the `with` statement context, closing all the source files.
    Instead, we must yield individual rows so that the `with` statement context is
    kept active.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们不能返回`chain(*readers)`对象。如果这样做，将退出`with`语句上下文，关闭所有源文件。相反，我们必须产生单独的行，以保持`with`语句上下文处于活动状态。
- en: Partitioning an iterator with groupby()
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用groupby()对迭代器进行分区
- en: We can use the `groupby()` function to partition an iterator into smaller iterators.
    This works by evaluating the given `key()` function for each item in the given
    iterable. If the key value matches the previous item's key, the two items are
    part of the same partition. If the key does not match the previous item's key,
    the previous partition is ended and a new partition is started.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`groupby()`函数将迭代器分成较小的迭代器。这是通过对给定可迭代对象中的每个项目评估给定的`key()`函数来实现的。如果键值与前一个项目的键值匹配，则两个项目属于同一分区。如果键值与前一个项目的键值不匹配，则结束前一个分区并开始一个新的分区。
- en: The output from the `groupby()` function is a sequence of two tuples. Each tuple
    has the group's key value and an iterable over the items in the group. Each group's
    iterator can be preserved as a tuple or processed to reduce it to some summary
    value. Because of the way the group iterators are created, they can't be preserved.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupby()`函数的输出是两个元组的序列。每个元组都有组的键值和组中项目的可迭代对象。每个组的迭代器可以保留为元组，也可以处理以将其减少为某些摘要值。由于组迭代器的创建方式，它们无法被保留。'
- en: In the *Running totals with accumulate()* section, earlier in the chapter, we
    showed how to compute quartile values for an input sequence.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用accumulate()计算累积总数*部分，在本章的前面，我们展示了如何计算输入序列的四分位值。
- en: 'Given the `trip` variable with the raw data and the quartile variable with
    the quartile assignments, we can group the data using the following commands:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 给定具有原始数据的`trip`变量和具有四分位数分配的`quartile`变量，我们可以使用以下命令对数据进行分组：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will start by zipping the quartile numbers with the raw trip data, iterating
    over two tuples. The `groupby()` function will use the given `lambda` variable
    to group by the quartile number. We used a `for` loop to examine the results of
    the `groupby()` function. This shows how we get a group key value and an iterator
    over members of the group.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从原始行程数据开始，将四分位数与原始行程数据一起进行迭代。`groupby（）`函数将使用给定的`lambda`变量按四分位数分组。我们使用`for`循环来检查`groupby（）`函数的结果。这显示了我们如何获得组键值和组成员的迭代器。
- en: The input to the `groupby()` function must be sorted by the key values. This
    will assure that all of the items in a group will be adjacent.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupby（）`函数的输入必须按键值排序。这将确保组中的所有项目都是相邻的。'
- en: 'Note that we can also create groups using the `defaultdict(list)` method, as
    follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还可以使用`defaultdict（list）`方法创建组，如下所示：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We created a `defaultdict` class with a `list` object as the value associated
    with each key. Each item will have the given `key()` function applied to create
    a key value. The item is appended to the list in the `defaultdict` class with
    the given key.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`defaultdict`类，其中`list`对象作为与每个键关联的值。每个项目将应用给定的`key（）`函数以创建键值。项目将附加到具有给定键的`defaultdict`类中的列表中。
- en: Once all of the items are partitioned, we can then return each partition as
    an iterator over the items that share a common key. This is similar to the `groupby()`
    function because the input iterator to this function isn't necessarily sorted
    in precisely the same order; it's possible that the groups might have the same
    members, but the order might differ.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有项目被分区，我们就可以将每个分区作为共享公共键的项目的迭代器返回。这类似于`groupby（）`函数，因为传递给此函数的输入迭代器不一定按照完全相同的顺序排序；可能会有相同成员的组，但顺序可能不同。
- en: Merging iterables with zip_longest() and zip()
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`zip_longest（）`和`zip（）`合并可迭代对象
- en: 'We saw the `zip()` function in [Chapter 4](ch04.html "Chapter 4. Working with
    Collections"), *Working with Collections*. The `zip_longest()` function differs
    from the `zip()` function in an important way: where the `zip()` function stops
    at the end of the shortest iterable, the `zip_longest()` function pads short iterables
    and stops at the end of the longest iterable.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](ch04.html "第4章。与集合一起工作")*与集合一起工作*中看到了`zip（）`函数。`zip_longest（）`函数与`zip（）`函数有一个重要的区别：`zip（）`函数在最短的可迭代对象结束时停止，而`zip_longest（）`函数填充短的可迭代对象，并在最长的可迭代对象结束时停止。
- en: The `fillvalue` keyword parameter allows filling with a value other than the
    default value, `None`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`fillvalue`关键字参数允许使用除默认值`None`之外的值进行填充。'
- en: For most exploratory data analysis applications, padding with a default value
    is statistically difficult to justify. The **Python Standard Library** document
    shows a few clever things which can be done with the `zip_longest()` function.
    It's difficult to expand on these without drifting far from our focus on data
    analysis.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数探索性数据分析应用程序，使用默认值进行填充在统计上很难证明。**Python标准库**文档显示了一些可以使用`zip_longest（）`函数完成的巧妙事情。很难在不远离我们对数据分析的关注的情况下扩展这些内容。
- en: Filtering with compress()
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`compress（）`进行过滤
- en: The built-in `filter()` function uses a predicate to determine if an item is
    passed or rejected. Instead of a function that calculates a value, we can use
    a second, parallel iterable to determine which items to pass and which to reject.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`filter（）`函数使用谓词来确定是否传递或拒绝项目。我们可以使用第二个并行可迭代对象来确定要传递哪些项目，要拒绝哪些项目，而不是使用计算值的函数。
- en: 'We can think of the `filter()` function as having the following definition:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`filter（）`函数视为具有以下定义：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We cloned the iterable using the `tee()` function. (We'll look at this function
    in detail later.) We evaluated the filter predicate for each value. Then we provided
    the original iterable and the filter function iterable to compress, pass, and
    reject values. This builds the features of the `filter()` function from the more
    primitive features of the `compress()` function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`tee（）`函数克隆了可迭代对象。（我们稍后将详细讨论这个函数。）我们对每个值评估了过滤谓词。然后我们将原始可迭代对象和过滤函数可迭代对象提供给`compress`，传递和拒绝值。这从`compress（）`函数的更原始特性中构建了`filter（）`函数的特性。
- en: 'In the *Reiterating a cycle with cycle()* section of this chapter, we looked
    at data selection using a simple generator expression. Its essence was as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的*使用cycle（）重复循环*部分，我们看到了使用简单的生成器表达式进行数据选择。其本质如下：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We defined a function which would produce a value `1` followed by *c-1* zeroes.
    This cycle would be repeated, allowing to pick only *1/c* rows from the source.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个函数，它将产生一个值`1`，后跟*c-1*个零。这个循环将被重复，允许从源中仅选择*1/c*行。
- en: We can replace the `cycle(range(c))` function with the `repeat(0)` function
    to select all rows. We can also replace it with the `random.randrange(c)` function
    to randomize the selection of rows.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`repeat（0）`函数替换`cycle（range（c））`函数以选择所有行。我们还可以用`random.randrange（c）`函数替换它以随机选择行。
- en: 'The keep expression is really just a `compress(some_source, chooser)` method.
    If we make that change, the processing is simplified:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 保持表达式实际上只是一个`compress（some_source，chooser）`方法。如果我们进行这种更改，处理将变得简化：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We''ve defined three alternative selection rules: `all`, `subset`, and `randomized`.
    The subset and randomized versions will pick *1/c* rows from the source. The `chooser`
    expression will build an iterable over `True` and `False` values based on one
    of the selection rules. The rows to be kept are selected by applying the source
    iterable to the row selection iterable.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三种替代选择规则：`all`，`subset`和`randomized`。子集和随机化版本将从源中选择*1/c*行。`chooser`表达式将根据选择规则之一构建一个`True`和`False`值的可迭代对象。应用源可迭代对象到行选择可迭代对象来选择要保留的行。
- en: Since all of this is non-strict, rows are not read from the source until required.
    This allows us to process very large sets of data efficiently. Also, the relative
    simplicity of the Python code means that we don't really need a complex configuration
    file and an associated parser to make choices among the selection rules. We have
    the option to use this bit of Python code as the configuration for a larger data
    sampling application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些都是非严格的，直到需要时才从源中读取行。这使我们能够高效地处理非常大的数据集。此外，Python代码的相对简单意味着我们实际上不需要复杂的配置文件和相关解析器来在选择规则中进行选择。我们可以选择使用这段Python代码作为更大数据采样应用程序的配置。
- en: Picking subsets with islice()
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用islice()选择子集
- en: 'In [Chapter 4](ch04.html "Chapter 4. Working with Collections"), *Working with
    Collections*, we looked at slice notation to select subsets from a collection.
    Our example was to pair up items sliced from a `list` object. The following is
    a simple list:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。与集合一起工作")中，*与集合一起工作*，我们看到了使用切片表示法从集合中选择子集。我们的示例是从`list`对象中切片出成对的项目。以下是一个简单的列表：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can create pairs using list slices as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用列表切片创建成对的元素，如下所示：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `islice()` function gives us similar capabilities without the overhead
    of materializing a `list` object, and it looks like the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`islice()`函数为我们提供了类似的功能，而不需要实例化`list`对象，并且看起来像以下内容：'
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We created two independent iterators over a flat list of data points. These
    might be two separate iterators over an open file or a database result set. The
    two iterators need to be independent so that change in one `islice()` function
    doesn't interfere with the other `islice()` function.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个扁平数据点列表上创建了两个独立的迭代器。这些可能是打开文件或数据库结果集上的两个独立迭代器。这两个迭代器需要是独立的，以便一个`islice()`函数的更改不会干扰另一个`islice()`函数。
- en: 'The two sets of arguments to the `islice()` function are similar to the `flat[0::2]`
    and `flat[1::2]` methods. There''s no slice-like shorthand, so the start and stop
    argument values are required. The step can be omitted and the default value is
    1\. This will produce a sequence of two tuples from the original sequence:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`islice()`函数的两组参数类似于`flat[0::2]`和`flat[1::2]`方法。没有类似切片的简写，因此需要指定开始和结束参数值。步长可以省略，默认值为1。这将从原始序列产生两个元组的序列：'
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Since `islice()` works with an iterable, this kind of design will work with
    extremely large sets of data. We can use this to pick a subset out of a larger
    set of data. In addition to using the `filter()` or `compress()` functions, we
    can also use the `islice(source,0,None,c)` method to pick ![Picking subsets with
    islice()](graphics/B03652_08_06.jpg) items from a larger set of data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`islice()`与可迭代对象一起工作，这种设计可以处理非常大的数据集。我们可以使用它从较大的数据集中选择一个子集。除了使用`filter()`或`compress()`函数外，我们还可以使用`islice(source,0,None,c)`方法从较大的数据集中选择![使用islice()选择子集](graphics/B03652_08_06.jpg)项。
- en: Stateful filtering with dropwhile() and takewhile()
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用dropwhile()和takewhile()进行有状态过滤
- en: The `dropwhile()` and `takewhile()` functions are stateful filter functions.
    They start in one mode; the given `predicate` function is a kind of flip-flop
    that switches the mode. The `dropwhile()` function starts in reject mode; when
    the function becomes `False`, it switches to pass mode. The `takewhile()` function
    starts in pass mode; when the given function becomes `False`, it switches into
    reject mode.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`dropwhile()`和`takewhile()`函数是有状态的过滤函数。它们以一种模式开始；给定的`predicate`函数是一种开关，可以切换模式。`dropwhile()`函数以拒绝模式开始；当函数变为`False`时，它切换到通过模式。`takewhile()`函数以通过模式开始；当给定函数变为`False`时，它切换到拒绝模式。'
- en: Since these are filters, both functions will consume the entire iterable. Given
    an infinite iterator like the `count()` function, it will continue indefinitely.
    Since there's no simple integer overflow in Python, an ill-considered use of `dropwhile()`
    or `takewhile()` functions won't crash after a few billion iterations with integer
    overflow. It really can run for a very, very long time.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些是过滤器，两个函数都将消耗整个可迭代对象。给定一个像`count()`函数这样的无限迭代器，它将无限继续。由于Python中没有简单的整数溢出，对`dropwhile()`或`takewhile()`函数的不考虑使用不会在整数溢出后经过几十亿次迭代后崩溃。它确实可以运行非常非常长的时间。
- en: 'We can use these with file parsing to skip headers or footers in the input.
    We use the `dropwhile()` function to reject header rows and pass the remaining
    data. We use the `takewhile()` function to pass data and reject trailer rows.
    We''ll return to the simple GPL file format shown in [Chapter 3](ch03.html "Chapter 3. Functions,
    Iterators, and Generators"), *Functions, Iterators, and Generators*. The file
    has a header that looks as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些与文件解析一起使用，以跳过输入中的标题或页脚。我们使用`dropwhile()`函数来拒绝标题行并传递剩余数据。我们使用`takewhile()`函数来传递数据并拒绝尾部行。我们将返回[第3章](ch03.html
    "第3章。函数、迭代器和生成器")中显示的简单GPL文件格式，*函数、迭代器和生成器*。该文件的标题如下所示：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is followed by rows that look like the following example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是以下示例的行：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can easily locate the final line of the headers—the `#` line—using a parser
    based on the `dropwhile()` function, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用基于`dropwhile()`函数的解析器轻松定位标题的最后一行——`#`行，如下所示：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We created a CSV reader to parse the lines based on tab characters. This will
    neatly separate the `color` three tuple from the name. The three tuple will need
    further parsing. This will produce an iterator that starts with the `#` line and
    continues with the rest of the file.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个CSV读取器，以制表符为基础解析行。这将从名称中整齐地分离出`color`三元组。三元组需要进一步解析。这将产生一个以`#`行开头并继续文件其余部分的迭代器。
- en: 'We can use the `islice()` function to discard the first item of an iterable.
    We can then parse the color details as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`islice()`函数丢弃可迭代对象的第一项。然后我们可以按以下方式解析颜色细节：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `islice(rows, 1, None)` expression is similar to asking for a `rows[1:]`
    slice: the first item is quietly discarded. Once the last of the heading rows
    have been discarded, we can parse the color tuples and return more useful color
    objects.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`islice(rows, 1, None)`表达式类似于请求`rows[1:]`切片：第一项被悄悄丢弃。一旦标题行的最后一行被丢弃，我们就可以解析颜色元组并返回更有用的颜色对象。'
- en: 'For this particular file, we can also use the number of columns located by
    the CSV reader function. We can use the `dropwhile(lambda row: len(row) == 1,
    rdr)` method to discard header rows. This doesn''t always work out well in general.
    Locating the last line of the headers is often easier than trying to locate some
    general feature that distinguishes header (or trailer) lines from the meaningful
    file content.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '对于这个特定的文件，我们还可以使用CSV读取器函数定位的列数。我们可以使用`dropwhile(lambda row: len(row) == 1,
    rdr)`方法来丢弃标题行。这在一般情况下并不总是奏效。定位标题行的最后一行通常比尝试定位一些区分标题（或尾部）行与有意义的文件内容的一般特征更容易。'
- en: Two approaches to filtering with filterfalse() and filter()
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用filterfalse()和filter()进行过滤的两种方法
- en: 'In [Chapter 5](ch05.html "Chapter 5. Higher-order Functions"), *Higher-order
    Functions* we looked at the built-in `filter()` function. The `filterfalse()`
    function from the `itertools` module could be defined from the `filter()` function,
    as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。高阶函数")中，*高阶函数*我们看了内置的`filter()`函数。`itertools`模块中的`filterfalse()`函数可以从`filter()`函数中定义如下：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As with the `filter()` function, the predicate function can be of `None` value.
    The value of the `filter(None, iterable)` method is all the `True` values in the
    iterable. The value of the `filterfalse(None, iterable)` method is all of the
    `False` values from the iterable:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与`filter()`函数一样，谓词函数可以是`None`值。`filter(None, iterable)`方法的值是可迭代对象中的所有`True`值。`filterfalse(None,
    iterable)`方法的值是可迭代对象中的所有`False`值：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The point of having the `filterfalse()` function is to promote reuse. If we
    have a succinct function that makes a filter decision, we should be able to use
    that function to partition input in to pass and reject groups without having to
    fiddle around with logical negation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有`filterfalse()`函数的目的是促进重用。如果我们有一个简洁的函数可以做出过滤决定，我们应该能够使用该函数将输入分成通过和拒绝组，而不必费力地处理逻辑否定。
- en: 'The idea is to execute the following commands:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令的想法是：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will obviously include all items from the source. The `test()` function
    is unchanged, and we can't introduce a subtle logic bug through improper use of
    `()`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显然包括源自所有项目。`test()`函数保持不变，我们不能通过不正确使用`()`引入微妙的逻辑错误。
- en: Applying a function to data via starmap() and map()
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过starmap()和map()将函数应用于数据
- en: 'The built-in `map()` function is a higher-order function that applies a `map()`
    function to items from an iterable. We can think of the simple version of the
    `map()` function, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`map()`函数是一个高阶函数，它将`map()`函数应用于可迭代对象中的项目。我们可以将`map()`函数的简单版本看作如下：
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This works well when the `arg_iter` parameter is a list of individual values.
    The `starmap()` function in the `itertools` module is simply the `*a` version
    of the `map()` function, which is as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当`arg_iter`参数是单个值列表时，这很有效。`itertools`模块中的`starmap()`函数只是`map()`函数的`*a`版本，如下所示：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This reflects a small shift in the semantics of the `map()` function to properly
    handle a tuple-of-tuples structure.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这反映了`map()`函数语义的小变化，以正确处理元组结构。
- en: The `map()` function can also accept multiple iterables; the values from these
    additional iterables are zipped and it behaves like the `starmap()` function.
    Each zipped item from the source iterables becomes multiple arguments to the given
    function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数也可以接受多个可迭代对象；这些额外可迭代对象的值被压缩，并且它的行为类似于`starmap()`函数。源可迭代对象的每个压缩项都成为给定函数的多个参数。'
- en: 'We can think of the `map(function, iter1, iter2, ..., itern)` method being
    defined as the following two commands:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`map(function, iter1, iter2, ..., itern)`方法定义为以下两个命令：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Various iterator values are used to construct a tuple of arguments via the `*args`
    construct. In effect, `starmap()` function is like this more general case. We
    can build the simple `map()` function from the more general `starmap()` function.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 各种迭代器值被用来通过`*args`构造一个参数元组。实际上，`starmap()`函数就像这种更一般的情况。我们可以从更一般的`starmap()`函数构建简单的`map()`函数。
- en: 'When we look at the trip data, from the preceding commands, we can redefine
    the construction of a `Leg` object based on the `starmap()` function. Prior to
    creating `Leg` objects, we created pairs of points. Each pair looks as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看行程数据时，可以根据前面的命令重新定义基于`starmap()`函数的`Leg`对象的构造。在创建`Leg`对象之前，我们创建了点对。每对如下所示：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We could use the `starmap()` function to assemble the `Leg` objects, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`starmap()`函数来组装`Leg`对象，如下所示：
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `legs()` function creates pairs of point objects that reflect the start
    and end of a leg of the voyage. Given these pairs, we can create a simple function,
    `make_leg`, which accepts a pair of `Points` object, and returns a `Leg` object
    with the start point, end point, and distance between the two points.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`legs()`函数创建反映航程的腿的起点和终点的点对象对。有了这些对，我们可以创建一个简单的函数`make_leg`，它接受一对`Points`对象，并返回一个具有起点、终点和两点之间距离的`Leg`对象。'
- en: The benefit of the `starmap(function, some_list)` method is to replace a potentially
    wordy `(function(*args) for args in some_list)` generator expression.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`starmap(function, some_list)`方法的好处是可以替换潜在冗长的`(function(*args) for args in
    some_list)`生成器表达式。'
- en: Cloning iterators with tee()
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用tee()克隆迭代器
- en: The `tee()` function gives us a way to circumvent one of the important Python
    rules for working with iterables. The rule is so important, we'll repeat it here.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`tee()`函数为我们提供了一种规避处理可迭代对象的重要Python规则的方法。这条规则非常重要，我们在这里重复一遍。'
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Iterators can be used only once.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器只能使用一次。
- en: 'The `tee()` function allows us to clone an iterator. This seems to free us
    from having to materialize a sequence so that we can make multiple passes over
    the data. For example, a simple average for an immense dataset could be written
    in the following way:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`tee()`函数允许我们克隆一个迭代器。这似乎使我们摆脱了必须实现一个序列以便我们可以对数据进行多次遍历的限制。例如，对于一个庞大的数据集，可以按照以下方式编写一个简单的平均值：'
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This would compute an average without appearing to materialize the entire dataset
    in memory in any form.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这将计算平均值，而不会以任何形式在内存中出现整个数据集。
- en: While interesting in principle, the `tee()` function's implementation suffers
    from a severe limitation. In most Python implementations, the cloning is done
    by materializing a sequence. While this circumvents the "one time only" rule for
    small collections, it doesn't work out well for immense collections.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在原则上很有趣，但`tee()`函数的实现受到严重限制。在大多数Python实现中，克隆是通过实现一个序列来完成的。虽然这可以规避小集合的“一次性”规则，但对于庞大的集合来说效果不佳。
- en: Also, the current implementation of the `tee()` function consumes the source
    iterator. It might be nice to create some syntactic sugar to allow unlimited use
    of an iterator. This is difficult to manage in practice. Instead, Python obliges
    us to optimize the `tee()` function carefully.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`tee()`函数的当前实现会消耗源迭代器。可能会很好地创建一些语法糖来允许对迭代器进行无限使用。这在实践中很难管理。相反，Python要求我们仔细优化`tee()`函数。
- en: The itertools recipes
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: itertools配方
- en: The *itertools* chapter of the Python library documentation, *Itertools* *Recipes*,
    is outstanding. The basic definitions are followed by a series of recipes that
    are extremely clear and helpful. Since there's no reason to reproduce these, we'll
    reference them here. They should be considered as required reading on functional
    programming in Python.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Python库文档的*itertools*章节，*Itertools* *Recipes*，是非常出色的。基本定义后面是一系列非常清晰和有用的配方。由于没有理由重复这些，我们将在这里引用它们。它们应该被视为Python中函数式编程的必读内容。
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*10.1.2* section, *Itertools Recipes* of *Python Standard Library*, is a wonderful
    resource. See'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python标准库*的*10.1.2*章节，*Itertools Recipes*，是一个很好的资源。参见'
- en: '[https://docs.python.org/3/library/itertools.html#itertools-recipes](https://docs.python.org/3/library/itertools.html#itertools-recipes).'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/itertools.html#itertools-recipes](https://docs.python.org/3/library/itertools.html#itertools-recipes)。'
- en: It's important to note that these aren't importable functions in the `itertools`
    modules. A recipe needs to be read and understood and then, perhaps, copied or
    modified before inclusion in an application.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这些不是`itertools`模块中可导入的函数。需要阅读和理解一个配方，然后可能在应用程序中复制或修改它。
- en: 'The following table summarizes some of the recipes that show functional programming
    algorithms built from the itertools basics:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表总结了一些从itertools基础构建的函数式编程算法的配方：
- en: '| Function Name | Arguments | Results |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 函数名称 | 参数 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `take` | `(n, iterable)` | This returns the first n items of the iterable
    as a list. This wraps a use of `islice()` in a simple name. |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `take` | `(n, iterable)` | 这将可迭代对象的前n个项目作为列表返回。这在一个简单的名称中包装了`islice()`的使用。'
- en: '| `tabulate` | `(function, start=0)` | This returns `function(0)` and `function(1)`.
    This is based on a `map(function, count())`. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `tabulate` | `(function, start=0)` | 这返回`function(0)`和`function(1)`。这基于`map(function,
    count())`。'
- en: '| `consume` | `(iterator, n)` | This advances the iterator n steps ahead. If
    *n* is `None`, iterator consumes the steps entirely. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `consume` | `(iterator, n)` | 这将迭代器向前推进n步。如果*n*是`None`，迭代器将完全消耗这些步骤。'
- en: '| `nth` | `(iterable, n, default=None)` | This returns the nth item or a default
    value. This wraps the use of `islice()` in a simple name. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `nth` | `(iterable, n, default=None)` | 这返回第n个项目或默认值。这在一个简单的名称中包装了`islice()`的使用。'
- en: '| `quantify` | `(iterable, pred=bool)` | This counts how many times the predicate
    is true. This uses `sum()` and `map()`, and relies on the way a Boolean predicate
    is effectively 1 when converted to an integer value. |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `quantify` | `(iterable, pred=bool)` | 这计算谓词为真的次数。这使用`sum()`和`map()`，并依赖于布尔谓词在转换为整数值时的方式。'
- en: '| `padnone` | `(iterable)` | This returns the sequence elements and then returns
    `None` indefinitely. This can create functions that behave like `zip_longest()
    or map()`. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `padnone` | `(iterable)` | 这返回序列元素，然后无限返回`None`。这可以创建行为类似于`zip_longest()或map()`的函数。'
- en: '| `ncycles` | `(iterable, n)` | This returns the sequence elements *n* times.
    |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `ncycles` | `(iterable, n)` | 这将序列元素*n*次返回。'
- en: '| `dotproduct` | `(vec1, vec2)` | This is the essential definition of a dot
    product. Multiply two vectors and find the sum of the result. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `dotproduct` | `(vec1, vec2)` | 这是点积的基本定义。将两个向量相乘并找到结果的和。'
- en: '| `flatten` | `(listOfLists)` | This flattens one level of nesting. This chains
    the various lists together into a single list. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `flatten` | `(listOfLists)` | 这将嵌套的一级展平。这将各种列表链接成一个单一的列表。'
- en: '| `repeatfunc` | `(func, times=None, *args)` | This calls to `func` repeatedly
    with specified arguments. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `repeatfunc` | `(func, times=None, *args)` | 这使用指定的参数重复调用`func`。'
- en: '| `pairwise` | `(iterable):` | `s -> (s0,s1), (s1,s2), (s2, s3).` |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `pairwise` | `(iterable):` | `s -> (s0,s1), (s1,s2), (s2, s3).` |'
- en: '| `grouper` | `(iterable, n, fillvalue=None)` | Collect data into fixed length
    chunks or blocks. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `grouper` | `(iterable, n, fillvalue=None)` | 将数据收集到固定长度的块中。'
- en: '| `roundrobin` | `(*iterables)` | `roundrobin(''ABC'', ''D'', ''EF'') --> A
    D E B F C` |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `roundrobin` | `(*iterables)` | `roundrobin(''ABC'', ''D'', ''EF'') --> A
    D E B F C` |'
- en: '| `partition` | `(pred, iterable)` | This uses a predicate to partition entries
    into `False` entries and `True` entries. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `partition` | `(pred, iterable)` | 这使用谓词将条目分成`False`条目和`True`条目。'
- en: '| `unique_ everseen` | `(iterable, key=None)` | This lists unique elements,
    preserving order. Remembers all elements ever seen. `unique_ everseen(''AAAABBBCCDAABBB'')
    - -> A B C D.` |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `unique_ everseen` | `(iterable, key=None)` | 这列出唯一的元素，保留顺序。记住所有已经看到的元素。`unique_
    everseen(''AAAABBBCCDAABBB'') - -> A B C D.` |'
- en: '| `unique_ justseen` | `(iterable, key=None)` | This lists unique elements,
    preserving order. Remembers only the element just seen. `unique_justseen(''AAAABBBCCDAABBB'')
    - -> A B C D A B.` |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `unique_justseen` | `(iterable, key=None)` | 这列出了唯一的元素，保留顺序。只记住刚看到的元素。`unique_justseen(''AAAABBBCCDAABBB'')
    - -> A B C D A B.`|'
- en: '| `iter_except` | `(func, exception, first=None)` | Call a function repeatedly
    until an exception is raised. This can be used to iterate until `KeyError` or
    `IndexError`. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `iter_except` | `(func, exception, first=None)` | 反复调用函数，直到引发异常。这可以用于迭代直到`KeyError`或`IndexError`。|'
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've looked at a number of functions in the `itertools` module.
    This library module provides a number of functions that help us to work with iterators
    in sophisticated ways.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看过了`itertools`模块中的许多函数。这个库模块提供了许多函数，帮助我们以复杂的方式处理迭代器。
- en: We've looked at the infinite iterators; these repeat without terminating. These
    include the `count()`, `cycle()`, and `repeat()` functions. Since they don't terminate,
    the consuming function must determine when to stop accepting values.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过了无限迭代器；这些重复而不终止。这些包括`count()`、`cycle()`和`repeat()`函数。由于它们不终止，消耗函数必须确定何时停止接受值。
- en: We've also looked at a number of finite iterators. Some of these are built-in
    and some of these are part of the `itertools` module. These work with a source
    iterable, so they terminate when that iterable is exhausted. These functions include
    `enumerate()`, `accumulate()` , `chain()` , `groupby()` , `zip_longest()`, `zip()`,
    `compress()`, `islice()`, `dropwhile()`, `takewhile()`, `filterfalse()`, `filter()`,
    `starmap()`, and `map()`. These functions allow us to replace possibly complex
    generator expressions with simpler-looking functions.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看过了许多有限迭代器。其中一些是内置的，一些是`itertools`模块的一部分。这些与源可迭代对象一起工作，因此当该可迭代对象耗尽时它们终止。这些函数包括`enumerate()`、`accumulate()`、`chain()`、`groupby()`、`zip_longest()`、`zip()`、`compress()`、`islice()`、`dropwhile()`、`takewhile()`、`filterfalse()`、`filter()`、`starmap()`和`map()`。这些函数允许我们用看起来更简单的函数替换可能复杂的生成器表达式。
- en: Additionally, we looked at the recipes from the documentation, which provide
    yet more functions we can study and copy for our own applications. The recipes
    list shows a wealth of common design patterns.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还研究了文档中的配方，这些配方提供了更多我们可以研究和复制到我们自己的应用程序中的函数。配方列表显示了丰富的常见设计模式。
- en: In [Chapter 9](ch09.html "Chapter 9. More Itertools Techniques"), *More Itertools
    Techniques*, we'll continue our study of the `itertools` module. We'll look at
    the iterators focused on permutations and combinations. These don't apply to processing
    large sets of data. They're a different kind of iterator-based tool.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](ch09.html "第9章。更多迭代工具技术")中，*更多迭代工具技术*，我们将继续研究`itertools`模块。我们将看看专注于排列和组合的迭代器。这些不适用于处理大量数据。它们是一种不同类型的基于迭代器的工具。
