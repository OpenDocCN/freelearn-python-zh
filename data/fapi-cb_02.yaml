- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Working with Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数据一起工作
- en: '**Data handling** is the backbone of any web application, and this chapter
    is dedicated to mastering this critical aspect. You will embark on a journey of
    working with data in FastAPI, where you’ll learn the intricacies of integrating,
    managing, and optimizing data storage using both **Structured Query Language**
    (**SQL**) and **NoSQL** databases. We’ll cover how FastAPI, combined with powerful
    database tools, can create efficient and scalable data management solutions.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据处理**是任何Web应用的骨架，本章致力于掌握这一关键方面。您将开始一段在FastAPI中处理数据的旅程，您将学习如何使用**结构化查询语言**（**SQL**）和**NoSQL**数据库来集成、管理和优化数据存储的复杂性。我们将介绍FastAPI如何与强大的数据库工具结合，以创建高效和可扩展的数据管理解决方案。'
- en: Starting with SQL databases, you’ll get hands-on experience in setting up a
    database, implementing **create, read, update and delete** (**CRUD**) operations,
    and understanding the nuances of working with SQLAlchemy – a popular **object-relational
    mapping** (**ORM**) option for Python. We’ll then shift gears to NoSQL databases,
    delving into the world of **MongoDB.** You’ll learn how to integrate it with FastAPI,
    handle dynamic data structures, and leverage the flexibility and scalability of
    NoSQL solutions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从SQL数据库开始，您将获得实际操作经验，包括设置数据库、实现**创建、读取、更新和删除**（**CRUD**）操作，以及理解与 SQLAlchemy（Python中流行的**对象关系映射**（**ORM**）选项）一起工作的细微差别。然后我们将转向NoSQL数据库，深入**MongoDB**的世界。您将学习如何将其与FastAPI集成，处理动态数据结构，并利用NoSQL解决方案的灵活性和可扩展性。
- en: But it’s not just about storing and retrieving data. This chapter also focuses
    on best practices for securing sensitive data and managing transactions and concurrency
    in your databases. You’ll explore how to protect your data from vulnerabilities
    and ensure the integrity and consistency of your application’s data operations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不仅仅是存储和检索数据。本章还关注保护敏感数据和管理数据库中的事务和并发性的最佳实践。您将探索如何保护您的数据免受漏洞的侵害，并确保应用程序数据操作的完整性和一致性。
- en: By the end of this chapter, you’ll not only have a solid understanding of how
    to work with various database systems in FastAPI but also the skills to build
    robust and secure data models for your web applications. Whether it’s implementing
    complex queries, optimizing database performance, or ensuring data security, this
    chapter provides the tools and knowledge you need to manage your application’s
    data effectively.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您不仅将深入了解如何在FastAPI中处理各种数据库系统，还将具备构建健壮和安全的Web应用数据模型所需的技能。无论是实现复杂查询、优化数据库性能还是确保数据安全，本章都提供了您管理应用程序数据所需的技术和知识。
- en: 'In this chapter, we’re going to cover the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Setting up SQL databases
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 SQL 数据库
- en: Understanding CRUD operations with SQLAlchemy
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SQLAlchemy 理解 CRUD 操作
- en: Integrating MongoDB for NoSQL data storage
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成 MongoDB 用于 NoSQL 数据存储
- en: Working with data validation and serialization
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数据验证和序列化一起工作
- en: Working with file uploads and downloads
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与文件上传和下载一起工作
- en: Handling asynchronous data operations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异步数据操作
- en: Securing sensitive data and best practices
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护敏感数据及最佳实践
- en: Each topic is designed to equip you with the necessary skills and knowledge
    to handle data in FastAPI efficiently, ensuring your applications are not only
    functional but also secure and scalable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主题都旨在为您提供处理FastAPI中数据的必要技能和知识，确保您的应用程序不仅功能齐全，而且安全且可扩展。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To effectively run and understand the code in this chapter, ensure you have
    the following set up. If you’ve followed [*Chapter 1*](B21025_01.xhtml#_idTextAnchor020),
    *First Steps with FastAPI*, you should already have some of these installed:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地运行和理解本章中的代码，请确保您已设置以下内容。如果您已经跟随了[*第1章*](B21025_01.xhtml#_idTextAnchor020)，*FastAPI
    的第一步*，您应该已经安装了一些这些内容：
- en: '**Python**: Make sure you’ve installed Python version 3.9 or higher on your
    computer.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python**：请确保您已在计算机上安装了3.9或更高版本的Python。'
- en: '`pip install fastapi[all]` command. As we saw in [*Chapter 1*](B21025_01.xhtml#_idTextAnchor020),
    *First Steps with FastAPI*, this command also installs **Uvicorn**, an ASGI server
    that’s necessary to run your FastAPI application.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip install fastapi[all]` 命令。正如我们在[*第1章*](B21025_01.xhtml#_idTextAnchor020)，*FastAPI
    的第一步*中看到的，此命令还安装了**Uvicorn**，这是一个必要的ASGI服务器，用于运行您的FastAPI应用程序。'
- en: '**Integrated development environment** (**IDE**): A suitable IDE such as **VS
    Code** or **PyCharm** should be installed. These IDEs offer excellent support
    for Python and FastAPI development, providing features such as syntax highlighting,
    code completion, and easy debugging.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成开发环境**（**IDE**）：应安装合适的 IDE，例如 **VS Code** 或 **PyCharm**。这些 IDE 为 Python
    和 FastAPI 开发提供了出色的支持，包括语法高亮、代码补全和易于调试等功能。'
- en: '**MongoDB**: For the NoSQL database portions of this chapter, MongoDB needs
    to be installed on your local machine. Download and install the free community
    version server suitable for your operating system from [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MongoDB**：对于本章的 NoSQL 数据库部分，您需要在本地机器上安装 MongoDB。从 [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community)
    下载并安装适合您操作系统的免费社区版服务器。'
- en: 'Make sure that MongoDB is correctly installed by running from the command line
    the Mongo Deamon:'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过命令行运行 Mongo Deamon 来确保 MongoDB 已正确安装：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: $ C:\Program>Files\MongoDB\Server\7.0\bin\mongod -- version
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ C:\Program>Files\MongoDB\Server\7.0\bin\mongod -- version
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**MongoDB tools**: While optional, tools such as the **MongoDB Shell** ([https://www.mongodb.com/try/download/shell](https://www.mongodb.com/try/download/shell))
    and **MongoDB Compass GUI** ([https://www.mongodb.com/try/download/compass](https://www.mongodb.com/try/download/compass))
    can greatly enhance your interaction with the MongoDB server. They provide a more
    user-friendly interface for managing databases, running queries, and visualizing
    data structures.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MongoDB 工具**：虽然不是必需的，但像 **MongoDB Shell** ([https://www.mongodb.com/try/download/shell](https://www.mongodb.com/try/download/shell))
    和 **MongoDB Compass GUI** ([https://www.mongodb.com/try/download/compass](https://www.mongodb.com/try/download/compass))
    这样的工具可以极大地增强您与 MongoDB 服务器的交互。它们提供了一个更用户友好的界面来管理数据库、运行查询和可视化数据结构。'
- en: All the code and examples used throughout this chapter are available on GitHub
    for reference and download. Visit [https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter02](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter02)
    on GitHub to access the repository.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有代码和示例均可在 GitHub 上供参考和下载。请访问 [https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter02](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter02)
    以访问存储库。
- en: Setting up SQL databases
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 SQL 数据库
- en: In the world of data handling, the power of Python meets the efficiency of SQL
    databases. This recipe aims to introduce you to how to integrate SQL databases
    within your application, a crucial skill for any developer looking to build robust
    and scalable web applications.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据处理的世界里，Python 的力量与 SQL 数据库的效率相结合。本食谱旨在向您介绍如何在您的应用程序中集成 SQL 数据库，这对于任何希望构建健壮和可扩展的
    Web 应用程序的开发者来说是一项关键技能。
- en: SQL is the standard language for managing and manipulating relational databases.
    When combined with FastAPI, it unlocks a world of possibilities in data storage
    and retrieval.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 是管理和管理关系型数据库的标准语言。当与 FastAPI 结合使用时，它解锁了数据存储和检索的无限可能。
- en: FastAPI’s compatibility with SQL databases is facilitated through ORMs. The
    most popular one is **SQLAlchemy**. We will focus on it in this recipe.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 与 SQL 数据库的兼容性是通过 ORM 实现的。其中最受欢迎的是 **SQLAlchemy**。在本食谱中，我们将重点关注它。
- en: Getting ready
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To begin, you’ll need to have FastAPI and SQLAlchemy installed in your virtual
    environment. If you followed the steps in [*Chapter 1*](B21025_01.xhtml#_idTextAnchor020),
    *First Steps with FastAPI*, you should have FastAPI already set up. For SQLAlchemy,
    a simple `pip` command is all that’s needed:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要确保 FastAPI 和 SQLAlchemy 已安装到您的虚拟环境中。如果您遵循了 [*第 1 章*](B21025_01.xhtml#_idTextAnchor020)，*FastAPI
    的第一步* 中的步骤，那么您应该已经设置了 FastAPI。对于 SQLAlchemy，只需一个简单的 `pip` 命令即可：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once installed, the next step is to configure SQLAlchemy so that it can work
    with FastAPI. This involves setting up the database connection – a process we
    will walk through step by step.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，下一步是配置 SQLAlchemy，使其能够与 FastAPI 一起工作。这涉及到设置数据库连接——我们将一步步进行。
- en: How to do it…
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Now, let’s dive deeper into configuring SQLAlchemy for your FastAPI application.
    SQLAlchemy acts as the bridge between your Python code and the database, allowing
    you to interact with the database using Python classes and objects rather than
    writing raw SQL queries.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入地探讨如何为您的 FastAPI 应用程序配置 SQLAlchemy。SQLAlchemy 作为您 Python 代码和数据库之间的桥梁，允许您使用
    Python 类和对象而不是编写原始 SQL 查询来与数据库交互。
- en: After installing SQLAlchemy, the next step is to configure it within your FastAPI
    application. This involves defining your database models – a representation of
    your database tables in Python code. In SQLAlchemy, models are typically defined
    using classes, with each class corresponding to a table in the database, and each
    attribute of the class corresponding to a column in the table.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 SQLAlchemy 后，下一步是在你的 FastAPI 应用程序中配置它。这涉及到定义你的数据库模型——在 Python 代码中表示数据库表。在
    SQLAlchemy 中，模型通常使用类来定义，每个类对应于数据库中的一个表，每个类的属性对应于表中的一个列。
- en: Follow these steps to go through the process.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行操作。
- en: 'Create a new folder called `sql_example`, move inside it, and then create a
    file called `database.py` there. Write a `base` class to be used as a reference:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前目录下创建一个名为 `sql_example` 的新文件夹，进入该文件夹后，再创建一个名为 `database.py` 的文件。编写一个用作参考的
    `base` 类：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To define a model in SQLAlchemy, you need to create a base class that derives
    from the `DeclarativeBase` class. This `Base` class maintains a catalog of classes
    and tables you’ve defined and is central to SQLAlchemy’s ORM functionality.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在 SQLAlchemy 中定义一个模型，你需要创建一个从 `DeclarativeBase` 类派生的基类。这个 `Base` 类维护了你定义的类和表的目录，并且是
    SQLAlchemy ORM 功能的核心。
- en: 'You can learn more by reading the official documentation: [https://docs.sqlalchemy.org/en/13/orm/extensions/declarative/index.xhtml](https://docs.sqlalchemy.org/en/13/orm/extensions/declarative/index.xhtml).'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以通过阅读官方文档来了解更多信息：[https://docs.sqlalchemy.org/en/13/orm/extensions/declarative/index.xhtml](https://docs.sqlalchemy.org/en/13/orm/extensions/declarative/index.xhtml)。
- en: 'Once you have your `Base` class, you can start defining your models. For instance,
    if you have a table for users, your model might look something like this:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你有了你的 `Base` 类，你就可以开始定义你的模型了。例如，如果你有一个用户表，你的模型可能看起来像这样：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this model, `User` class corresponds to a table named `user` in the database,
    with columns for `id`, `name`, and `email`. Each `class attribute` specifies the
    data type of the column.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个模型中，`User` 类对应于数据库中名为 `user` 的表，包含 `id`、`name` 和 `email` 列。每个 `class attribute`
    指定了列的数据类型。
- en: Once your models have been defined, the next step is to connect to the database
    and create these tables. SQLAlchemy uses a connection string to define the details
    of the database it needs to connect to. The format of this connection string varies
    depending on the database system you are using.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你的模型被定义，下一步就是连接到数据库并创建这些表。SQLAlchemy 使用连接字符串来定义它需要连接到的数据库的详细信息。这个连接字符串的格式取决于你使用的数据库系统。
- en: 'For example, a connection string for a SQLite database might look like this:'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，SQLite 数据库的连接字符串可能看起来像这样：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`test.db` database file the first time you connect to it.'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一次连接到 `test.db` 数据库文件时。
- en: 'You will use the `DATABASE_URL` connection string to create an `Engine` object
    in SQLAlchemy that represents the core interface to the database:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将使用 `DATABASE_URL` 连接字符串在 SQLAlchemy 中创建一个 `Engine` 对象，该对象代表与数据库的核心接口：
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With the engine created, you can proceed to create your tables in the database.
    You can do this by passing your `base` class and the engine to SQLAlchemy’s `create_all`
    method:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建好引擎后，你可以继续在数据库中创建你的表。你可以通过传递你的 `base` 类和引擎到 SQLAlchemy 的 `create_all` 方法来完成此操作：
- en: '[PRE7]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that you’ve defined all the abstractions of the database in your code, you
    can proceed with setting the database connection.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了代码中数据库的所有抽象，你可以继续设置数据库连接。
- en: Establishing a database connection
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立数据库连接
- en: The final part of setting up a SQL database setup is establishing a database
    connection. This connection allows your application to communicate with the database,
    executing queries and retrieving data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 SQL 数据库的最后一部分是建立数据库连接。这个连接允许你的应用程序与数据库通信，执行查询并检索数据。
- en: Database connections are managed with sessions. A session in SQLAlchemy represents
    a *workspace* for your objects, a place where you can add new records or fetch
    existing ones. Each session is bound to a single database connection.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库连接由会话管理。在 SQLAlchemy 中，会话代表了一个用于你的对象的 *工作区*，一个你可以添加新记录或检索现有记录的地方。每个会话都绑定到一个单独的数据库连接。
- en: 'To manage sessions, we need to create a `SessionLocal` class. This class will
    be used to create and manage session objects for the interactions with the database.
    Here’s how you can create it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理会话，我们需要创建一个 `SessionLocal` 类。这个类将被用来创建和管理与数据库交互的会话对象。以下是创建它的方法：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `sessionmaker` function creates a factory for sessions. The `autocommit`
    and `autoflush` parameters are set to `False`, meaning you have to manually commit
    transactions and manage them when your changes are flushed to the database.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`sessionmaker` 函数创建会话的工厂。`autocommit` 和 `autoflush` 参数设置为 `False`，这意味着你必须手动提交事务并在更改刷新到数据库时管理它们。'
- en: 'With the `SessionLocal` class in place, you can create a function that will
    be used in your FastAPI route functions to get a new database session. We can
    create it in the `main.py` module like so:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SessionLocal` 类就绪后，你可以创建一个函数，该函数将在你的 FastAPI 路由函数中使用，以获取一个新的数据库会话。我们可以在 `main.py`
    模块中这样创建它：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In your route functions, you can use this function as a dependency to communicate
    with the database.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的路由函数中，你可以使用此函数作为依赖项与数据库通信。
- en: 'In FastAPI, this can be done with the `Depends` class. In the `main.py` file,
    you can then add an endpoint:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FastAPI 中，这可以通过 `Depends` 类来完成。在 `main.py` 文件中，你可以添加一个端点：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This approach ensures that a new session is created for each request and closed
    when the request is finished, which is crucial for maintaining the integrity of
    your database transactions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确保为每个请求创建一个新的会话，并在请求完成后关闭，这对于维护数据库事务的完整性至关重要。
- en: 'You can then run the server with the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令运行服务器：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you try to call the endpoint `GET` at `localhost:8000/users` you will get
    an empty list since no users have been added already.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在 `localhost:8000/users` 上调用 `GET` 端点，你会得到一个空列表，因为没有添加任何用户。
- en: See also
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can discover more on how to set up a session in **SQLAlchemy** on the documentation
    page:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在文档页面上了解更多关于如何在 **SQLAlchemy** 中设置会话的信息：
- en: '*SQLAlchemy* *session*: [https://docs.sqlalchemy.org/en/20/orm/session_basics.xhtml](https://docs.sqlalchemy.org/en/20/orm/session_basics.xhtml)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SQLAlchemy* *会话*：[https://docs.sqlalchemy.org/en/20/orm/session_basics.xhtml](https://docs.sqlalchemy.org/en/20/orm/session_basics.xhtml)'
- en: Understanding CRUD operations with SQLAlchemy
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SQLAlchemy 理解 CRUD 操作
- en: After setting up your SQL database with FastAPI, the next crucial step is creating
    database models. This process is central to how your application interacts with
    the database. **Database models** in SQLAlchemy are essentially Python classes
    that represent tables in your SQL database. They provide a high-level, object-oriented
    interface to manipulate database records as if they were regular Python objects.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 FastAPI 设置好 SQL 数据库后，下一个关键步骤是创建数据库模型。这个过程对于你的应用程序如何与数据库交互至关重要。在 SQLAlchemy
    中的 **数据库模型** 实质上是代表 SQL 数据库中表的 Python 类。它们提供了一个高级的面向对象接口，可以像处理常规 Python 对象一样操作数据库记录。
- en: In this recipe, we will set up the **create, read, update and delete** (**CRUD**)
    endpoints to interact with the database.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将设置 **创建、读取、更新和删除** （**CRUD**） 端点以与数据库交互。
- en: Getting ready
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: With the models set up, you can now implement CRUD operations. These operations
    form the backbone of most web applications, allowing you to interact with the
    database.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好模型后，你现在可以实施 CRUD 操作。这些操作构成了大多数网络应用程序的骨架，允许你与数据库交互。
- en: How to do it…
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: For each operation, we will create a dedicated endpoint implementing the interacting
    operation with the database.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个操作，我们将创建一个专门的端点，以实现与数据库的交互操作。
- en: Creating a new user
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新用户
- en: 'To add a new user, we’ll use a `POST` request. In the `main.py` file, we must
    define an endpoint that receives user data, creates a new `User` instance in the
    body request, and adds it to the database:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加新用户，我们将使用 `POST` 请求。在 `main.py` 文件中，我们必须定义一个端点，该端点接收用户数据，在请求体中创建一个新的 `User`
    实例，并将其添加到数据库中：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In a few lines, you’ve created the endpoint to add a new user to the database.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在几行代码中，你已经创建了添加新用户到数据库的端点。
- en: Reading a specific user
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取特定用户
- en: 'To get a single user, we are going to use a `GET` endpoint:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取单个用户，我们将使用 `GET` 端点：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The endpoint will return a `404` response status if the user does not exist.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户不存在，端点将返回 `404` 响应状态。
- en: Updating a user
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新用户
- en: 'Updating a record via an API offers various approaches, including `PUT`, `PATCH`,
    or `POST` methods. Despite theoretical nuances, the choice of method often boils
    down to personal preference. I favor using a `POST` request and augmenting the
    `/user` endpoint with a `user_id` parameter. This simplifies the process, minimizing
    the need for extensive memorization. You can integrate this endpoint within the
    `main.py` module like so:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过API更新记录提供了各种方法，包括`PUT`、`PATCH`或`POST`方法。尽管在理论上存在细微差别，但方法的选择通常取决于个人偏好。我倾向于使用`POST`请求，并通过添加`user_id`参数来增强`/user`端点。这简化了过程，最大限度地减少了需要大量记忆的需求。您可以在`main.py`模块中这样集成此端点：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is all you need to do to create the endpoint to update a user record in
    the database.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是创建数据库中更新用户记录端点所需做的所有事情。
- en: Deleting a user
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除用户
- en: 'To conclude, deleting a user within the same `main.py` module involves utilizing
    a `DELETE` request, as shown here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要在同一`main.py`模块中删除用户，需要使用`DELETE`请求，如下所示：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These endpoints cover the basic CRUD operations and demonstrate how FastAPI
    can be integrated with SQLAlchemy for database operations. By defining these endpoints,
    your application can create, retrieve, update, and delete user data, providing
    a fully functional API for client interactions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些端点涵盖了基本的CRUD操作，并展示了如何将FastAPI与SQLAlchemy集成以进行数据库操作。通过定义这些端点，您的应用程序可以创建、检索、更新和删除用户数据，为客户端交互提供一个完全功能的API。
- en: 'Now that you have implemented all the operations, you can spin the server by
    running:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经实现了所有操作，您可以通过运行以下命令来启动服务器：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then open the inreactive documentation at `http://localhost:8000/docs` and start
    playing with the endpoints by creating, reading, updating and deleting users.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开inreactive文档在`http://localhost:8000/docs`，并开始通过创建、读取、更新和删除用户来尝试这些端点。
- en: Mastering these CRUD operations in FastAPI is a significant step in building
    dynamic and data-driven web applications. With the knowledge of how to integrate
    FastAPI endpoints with SQLAlchemy models, you are well-equipped to develop complex
    and efficient applications.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在FastAPI中掌握这些CRUD操作是构建动态和以数据驱动的Web应用程序的重要一步。通过了解如何将FastAPI端点与SQLAlchemy模型集成，您已经具备了开发复杂和高效应用程序的能力。
- en: See also
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can find a clear quick start on how to set up the ORM for CRUD operations
    with SQLAlchemy on the official documentation page:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档页面上找到如何使用SQLAlchemy设置ORM以进行CRUD操作的清晰快速入门指南：
- en: '*SQLAlchemy ORM Quick* *Start*: [https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml](https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SQLAlchemy ORM快速入门*: [https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml](https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml)'
- en: Integrating MongoDB for NoSQL data storage
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成MongoDB进行NoSQL数据存储
- en: Transitioning from SQL to NoSQL databases opens up a different paradigm in data
    storage and management. **NoSQL databases**, like MongoDB, are known for their
    flexibility, scalability, and ability to handle large volumes of unstructured
    data. In this recipe, we’ll explore how to integrate MongoDB, a popular NoSQL
    database, with FastAPI.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从SQL迁移到NoSQL数据库在数据存储和管理方面开辟了不同的范式。**NoSQL数据库**，如MongoDB，以其灵活性、可扩展性和处理大量非结构化数据的能力而闻名。在本食谱中，我们将探讨如何将流行的NoSQL数据库MongoDB与FastAPI集成。
- en: NoSQL databases differ from traditional SQL databases in that they often allow
    for more dynamic and flexible data models. MongoDB, for example, stores data in
    **binary JSON** (**BSON**) format, which can easily accommodate changes in data
    structure. This is particularly useful in applications that require rapid development
    and frequent updates to the database schema.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库与传统SQL数据库的不同之处在于，它们通常允许更动态和灵活的数据模型。例如，MongoDB以**二进制JSON**（**BSON**）格式存储数据，可以轻松适应数据结构的变化。这对于需要快速开发和频繁更新数据库模式的应用程序特别有用。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you’ve installed MongoDB on your machine. If you haven’t done it yet,
    you can download the installer from [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已在您的机器上安装了MongoDB。如果您还没有安装，您可以从[https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community)下载安装程序。
- en: FastAPI doesn’t provide a built-in ORM for NoSQL databases. However, integrating
    MongoDB into FastAPI is straightforward thanks to Python’s powerful libraries.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI不提供用于NoSQL数据库的内置ORM。然而，由于Python强大的库，将MongoDB集成到FastAPI中非常简单。
- en: We’ll use `pymongo`, a Python package driver to interact with MongoDB.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`pymongo`，一个Python包驱动程序来与MongoDB交互。
- en: First, ensure you have MongoDB installed and running on your machine.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保您已经在您的机器上安装并运行了 MongoDB。
- en: 'Then, you can install `pymongo` with `pip`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用 `pip` 安装 `pymongo`：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With `pymongo` installed, we can now establish a connection to a MongoDB instance
    and start performing database operations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了 `pymongo` 之后，我们现在可以建立与 MongoDB 实例的连接并开始执行数据库操作。
- en: How to do it…
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We can quickly connect our application to a Mongo DB instance running on our
    local machine by by applying the following steps.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤快速将我们的应用程序连接到本地机器上运行的 Mongo DB 实例。
- en: 'Create a new project folder called `nosql_example`. Start by defining connection
    configuration in a `database.py` file:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `nosql_example` 的新项目文件夹。首先，在一个 `database.py` 文件中定义连接配置：
- en: '[PRE18]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, `mydatabase` is the name of your database. You can replace
    it with the name you prefer. Here, `MongoClient` establishes a connection to a
    MongoDB instance running locally on the *default port* *of 27017*.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，`mydatabase` 是您数据库的名称。您可以用您喜欢的名称替换它。在这里，`MongoClient` 通过连接到本地运行的 MongoDB
    实例的 *默认端口* 27017 来建立连接。
- en: 'Once the connection has been set up, you can define your collections (equivalent
    to tables in SQL databases) and start interacting with them. MongoDB stores data
    in collections of documents, where each document is a JSON-like structure:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦连接建立，您就可以定义您的集合（在 SQL 数据库中相当于表）并开始与之交互。MongoDB 将数据存储在文档集合中，其中每个文档都是一个类似 JSON
    的结构：
- en: '[PRE19]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, `user_collection` is a reference to the `users` collection in your MongoDB
    database.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`user_collection` 是您 MongoDB 数据库中 `users` 集合的引用。
- en: 'To test the connection, you can create an endpoint that will retrieve all users
    that should return an empty list in a `main.py` file:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试连接，您可以在 `main.py` 文件中创建一个端点，该端点将检索所有用户，应该返回一个空列表：
- en: '[PRE20]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, run your `mongod` instance. You can do it from the command line:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行您的 `mongod` 实例。您可以从命令行执行此操作：
- en: '[PRE21]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you run on Windows the command will be:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您在 Windows 上运行，命令将是：
- en: '[PRE22]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And that''s it. To test it, in a separate terminal window, spin up the FastAPI
    server by running the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。为了测试它，在另一个终端窗口中，通过运行以下命令启动 FastAPI 服务器：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Then, simply open your browser at http://localhost:8000/users; you will get
    an empty list. This means that your database connection is correctly working.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，只需打开您的浏览器到 http://localhost:8000/users；您将看到一个空列表。这意味着您的数据库连接正在正确工作。
- en: Now that the connection has been set up, we are going to create an endpoint
    to add a user and one to retrieve a specific user with an ID. We’ll create both
    endpoints in the `main.py` module.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在连接已经建立，我们将创建一个用于添加用户和用于通过 ID 获取特定用户的端点。我们将在 `main.py` 模块中创建这两个端点。
- en: Creating a new user
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新用户
- en: 'To add a new document to a collection, use the `insert_one` method:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要向集合中添加新文档，请使用 `insert_one` 方法：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The endpoint we’ve just created returns the affected `id` number in the response
    to be used as input for other endpoints.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的端点在响应中返回受影响的 `id` 号，用作其他端点的输入。
- en: Reading a user
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取用户
- en: 'To retrieve a document, you can use the `find_one` method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索一个文档，您可以使用 `find_one` 方法：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the user with the specified ID doesn’t exist, it will return a response status
    of 404.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定的用户不存在，它将返回一个状态码为 404 的响应。
- en: In Mongo, the ID of the document is not stored in plain text, but in a 12-byte
    object. That’s why we need to initialize a dedicated `bson.ObjectId` when querying
    the database and explicitly decode to `str` when returning the value through the
    response.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mongo 中，文档的 ID 不会以纯文本形式存储，而是一个 12 字节的对象。这就是为什么在查询数据库时需要初始化一个专门的 `bson.ObjectId`，并在通过响应返回值时显式解码到
    `str`。
- en: 'You can then spin up the server with `uvicorn`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用 `uvicorn` 启动服务器：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can see the endpoints on the interactive documentation page: [http://localhost:8000/docs](http://localhost:8000/docs).
    Ensure you test every endpoint and the interaction among them thoroughly.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在交互式文档页面看到端点：[http://localhost:8000/docs](http://localhost:8000/docs)。确保您彻底测试每个端点及其之间的交互。
- en: By integrating MongoDB with FastAPI, you gain the ability to handle dynamic,
    schemaless data structures, which is a significant advantage in many modern web
    applications. This recipe has equipped you with the knowledge to set up MongoDB,
    define models and collections, and perform CRUD operations, providing a solid
    foundation for building versatile and scalable applications with FastAPI and MongoDB.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: By integrating MongoDB with FastAPI, you gain the ability to handle dynamic,
    schemaless data structures, which is a significant advantage in many modern web
    applications. This recipe has equipped you with the knowledge to set up MongoDB,
    define models and collections, and perform CRUD operations, providing a solid
    foundation for building versatile and scalable applications with FastAPI and MongoDB.
- en: See also
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: See also
- en: 'You can dig into how to use the **PyMongo** Python client by reading the official
    documentation:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 'You can dig into how to use the **PyMongo** Python client by reading the official
    documentation:'
- en: '*PyMongo* *documentation*: [https://pymongo.readthedocs.io/en/stable/](https://pymongo.readthedocs.io/en/stable/)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PyMongo* *documentation*: [https://pymongo.readthedocs.io/en/stable/](https://pymongo.readthedocs.io/en/stable/)'
- en: Working with data validation and serialization
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Working with data validation and serialization
- en: Effective data validation stands as a cornerstone of robust web applications,
    ensuring that incoming data meets predefined criteria and remains safe for processing.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Effective data validation stands as a cornerstone of robust web applications,
    ensuring that incoming data meets predefined criteria and remains safe for processing.
- en: FastAPI harnesses the power of Pydantic, a Python library dedicated to data
    validation and serialization. By integrating Pydantic models, FastAPI streamlines
    the process of validating and serializing data, offering an elegant and efficient
    solution. This recipe shows how to utilize Pydantic models within FastAPI applications,
    exploring how they enable precise validation and seamless data serialization.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI harnesses the power of Pydantic, a Python library dedicated to data
    validation and serialization. By integrating Pydantic models, FastAPI streamlines
    the process of validating and serializing data, offering an elegant and efficient
    solution. This recipe shows how to utilize Pydantic models within FastAPI applications,
    exploring how they enable precise validation and seamless data serialization.
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Getting ready
- en: '**Pydantic models** are essentially Python classes that define the structure
    and validation rules of your data. They use Python’s type annotations to validate
    that incoming data matches the expected format. When you use a Pydantic model
    in your FastAPI endpoints, FastAPI automatically validates incoming request data
    against the model.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pydantic models** are essentially Python classes that define the structure
    and validation rules of your data. They use Python’s type annotations to validate
    that incoming data matches the expected format. When you use a Pydantic model
    in your FastAPI endpoints, FastAPI automatically validates incoming request data
    against the model.'
- en: 'In this recipe, we’re going to use Pydantic’s email validator, which comes
    with the default `pydantic` package distribution. However, it needs to be installed
    in your environment. You can do this by running the following command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 'In this recipe, we’re going to use Pydantic’s email validator, which comes
    with the default `pydantic` package distribution. However, it needs to be installed
    in your environment. You can do this by running the following command:'
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once the package has been installed, you are ready to start this recipe.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Once the package has been installed, you are ready to start this recipe.
- en: How to do it…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: How to do it…
- en: 'Let’s use it in the previous project. In the `main.py` module, we’ll modify
    the `UserCreate` class, which is used to accept only valid `email` fields:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 'Let’s use it in the previous project. In the `main.py` module, we’ll modify
    the `UserCreate` class, which is used to accept only valid `email` fields:'
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '{'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"name": "John Doe",'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "John Doe",'
- en: '"email": "invalidemail.com",'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '"email": "invalidemail.com",'
- en: '}'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'class UserResponse(User):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'class UserResponse(User):'
- en: 'id: str'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 'id: str'
- en: '@app.get("/user")'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '@app.get("/user")'
- en: 'def get_user(user_id: str) -> UserResponse:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_user(user_id: str) -> UserResponse:'
- en: db_user = user_collection.find_one(
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: db_user = user_collection.find_one(
- en: '{'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"_id": ObjectId(user_id)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '"_id": ObjectId(user_id)'
- en: if ObjectId.is_valid(user_id)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: if ObjectId.is_valid(user_id)
- en: else None
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: else None
- en: '}'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: )
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'if db_user is None:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'if db_user is None:'
- en: raise HTTPException(
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: raise HTTPException(
- en: status_code=404,
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: status_code=404,
- en: detail="User not found"
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: detail="User not found"
- en: )
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: db_user["id"] = str(db_user["_id"])
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: db_user["id"] = str(db_user["_id"])
- en: User object and then serializes the returned UserResponse object back into JSON.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: User object and then serializes the returned UserResponse object back into JSON.
- en: This automatic serialization and deserialization make working with JSON data
    in FastAPI straightforward and type-safe.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: This automatic serialization and deserialization make working with JSON data
    in FastAPI straightforward and type-safe.
- en: Advanced validation techniques
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Advanced validation techniques
- en: '**Pydantic** offers a range of advanced validation techniques that you can
    leverage in FastAPI. These include custom validators and complex data types.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pydantic** offers a range of advanced validation techniques that you can
    leverage in FastAPI. These include custom validators and complex data types.'
- en: '`@field_validator`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`@field_validator`.'
- en: 'For example, you could add a validator to ensure that a user’s age is within
    a certain range:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'For example, you could add a validator to ensure that a user’s age is within
    a certain range:'
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'class Tweet(BaseModel):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Tweet(BaseModel):'
- en: 'content: str'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 'content: str'
- en: 'hashtags: list[str]'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'hashtags: list[str]'
- en: 'class User(BaseModel):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 'class User(BaseModel):'
- en: 'name: str'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: str'
- en: 'email: EmailStr'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 'email: EmailStr'
- en: 'age: Optional[int]'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 'age: Optional[int]'
- en: User model has an optional tweets field, which is a list of Tweet objects.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 用户模型有一个可选的tweets字段，它是一个Tweet对象的列表。
- en: By leveraging Pydantic’s advanced validation features, you can ensure that the
    data your FastAPI application processes is not only in the correct format but
    also adheres to your specific business logic and constraints. This provides a
    robust and flexible way to handle data validation and serialization in your FastAPI
    applications.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用Pydantic的高级验证功能，您可以确保FastAPI应用程序处理的数据不仅格式正确，而且符合您的特定业务逻辑和约束。这为在FastAPI应用程序中处理数据验证和序列化提供了一种强大且灵活的方法。
- en: See also
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can learn more about the potential of Pydantic validators on the documentation
    page:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在文档页面了解更多关于Pydantic验证器的潜力：
- en: '*Pydantic* *validators*: [https://docs.pydantic.dev/latest/concepts/validators/](https://docs.pydantic.dev/latest/concepts/validators/)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pydantic* *验证器*: [https://docs.pydantic.dev/latest/concepts/validators/](https://docs.pydantic.dev/latest/concepts/validators/)'
- en: Working with file uploads and downloads
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文件上传和下载
- en: Handling files is a common requirement in web applications, whether it’s uploading
    user avatars, downloading reports, or processing data files. FastAPI provides
    efficient and easy-to-implement methods for both uploading and downloading files.
    This recipe will guide you through how to set up and implement file handling in
    FastAPI.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中处理文件是一个常见的需求，无论是上传用户头像、下载报告还是处理数据文件。FastAPI提供了高效且易于实现的文件上传和下载方法。本食谱将指导您如何设置和实现FastAPI中的文件处理。
- en: Getting ready
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let’s create a new project directory called `uploads_and_downloads` that contains
    a `main.py` module with a folder called `uploads`. This will contain the files
    from the application side. The directory structure will look like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的项目目录，名为`uploads_and_downloads`，其中包含一个名为`main.py`的模块和一个名为`uploads`的文件夹。这将包含应用程序侧的文件。目录结构将如下所示：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can now proceed to create the appropriate endpoints.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续创建适当的端点。
- en: How to do it…
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To handle file uploads in FastAPI, you must use the `File` and `UploadFile`
    classes from FastAPI. The `UploadFile` class is particularly useful as it provides
    an asynchronous interface and spools large files to disk to avoid memory exhaustion.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要在FastAPI中处理文件上传，您必须使用FastAPI中的`File`和`UploadFile`类。`UploadFile`类特别有用，因为它提供了一个异步接口，并将大文件滚存到磁盘以避免内存耗尽。
- en: 'In the `main.py` module, you can define the endpoint to upload files like so:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.py`模块中，您可以定义如下上传文件的端点：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, `upload_file` is an endpoint that accepts an uploaded file
    and returns its filename. The file is received in the form of an `UploadFile`
    object, which you can then save to disk or process further.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`upload_file`是一个端点，它接受一个上传的文件并返回其文件名。文件以`UploadFile`对象的形式接收，然后您可以将其保存到磁盘或进一步处理。
- en: Implementing file uploads
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 实现文件上传
- en: When implementing file uploads, it’s essential to handle the file data correctly
    to ensure it is saved without corruption. Here’s an example of how you can save
    the uploaded file to a directory on your server.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现文件上传时，正确处理文件数据至关重要，以确保文件保存时不会损坏。以下是如何将上传的文件保存到服务器上目录的一个示例。
- en: Create a new folder project called `uploads_downloads`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的项目文件夹`uploads_downloads`。
- en: 'In the `main.py` module, create the `upload_file` endpoint:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.py`模块中创建`upload_file`端点：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This code snippet opens a new file in write-binary mode in the `uploads` directory
    and uses `shutil.copyfileobj` to copy the file content from the `UploadFile` object
    to the new file.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段在`uploads`目录中以写二进制模式打开一个新文件，并使用`shutil.copyfileobj`将文件内容从`UploadFile`对象复制到新文件。
- en: Important note
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In a production environment, remember to handle exceptions and errors appropriately,
    especially for larger files
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，请记住适当地处理异常和错误，特别是对于较大的文件
- en: Create a text file called `content.txt` with some text in it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含一些文本的文本文件`content.txt`。
- en: Start the server by running the `uvicorn main:app` command. Then, access the
    interactive documentation; you’ll observe that the endpoint we just created for
    file uploads includes a mandatory field prompting users to upload a file. Upon
    testing the endpoint by uploading a file, you’ll discover the uploaded file residing
    within the designated `uploads` folder.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `uvicorn main:app` 命令来启动服务器。然后，访问交互式文档；你会观察到我们刚刚为文件上传创建的端点包含一个强制字段，提示用户上传文件。通过上传文件测试端点，你会发现上传的文件位于指定的
    `uploads` 文件夹中。
- en: Managing file downloads and storage
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 管理文件下载和存储
- en: Downloading files is the reverse process of uploading. In FastAPI, you can easily
    set up an endpoint to serve files for download. The `FileResponse` class is particularly
    useful for this purpose. It streams files from the server to the client, making
    it efficient for serving large files.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下载文件是上传的逆过程。在 FastAPI 中，你可以轻松设置一个端点来提供文件下载。`FileResponse` 类对此特别有用。它从服务器流式传输文件到客户端，这使得为大型文件提供服务变得高效。
- en: 'Here’s a simple file download endpoint:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的文件下载端点：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this example, `download_file` is an endpoint that serves files from the `uploads`
    directory for download. Here, `FileResponse` automatically sets the appropriate
    content-type header based on the file type and handles streaming the file to the
    client.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`download_file` 是一个端点，它从 `uploads` 目录提供文件供下载。在这里，`FileResponse` 会根据文件类型自动设置适当的内容类型头，并处理将文件流式传输到客户端。
- en: The content of the file will be the response body of the endpoint.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 文件内容将是端点的响应体。
- en: Handling file storage is another crucial aspect, especially when dealing with
    a large number of files or large file sizes. It’s often advisable to store files
    in a dedicated file storage system rather than directly on your web server. Cloud
    storage solutions such as **Amazon S3**, **Google Cloud Storage**, or **Azure
    Blob Storage** can be integrated into your FastAPI application for scalable and
    secure file storage. Additionally, consider implementing cleanup routines or archival
    strategies to manage the life cycle of the files you store.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文件存储是另一个关键方面，尤其是在处理大量文件或大文件大小时。通常建议将文件存储在专门的文件存储系统中，而不是直接存储在您的 Web 服务器上。可以将云存储解决方案如
    **Amazon S3**、**Google Cloud Storage** 或 **Azure Blob Storage** 集成到您的 FastAPI
    应用程序中，以实现可扩展和安全的文件存储。此外，考虑实施清理程序或归档策略来管理您存储的文件的生命周期。
- en: See also
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can learn more about how to manage uploaded files on the official documentation
    page:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档页面上了解更多关于如何管理上传文件的信息：
- en: '*FastAPI request* *files*: [https://fastapi.tiangolo.com/tutorial/request-files/](https://fastapi.tiangolo.com/tutorial/request-files/)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*FastAPI 请求* *文件*: [https://fastapi.tiangolo.com/tutorial/request-files/](https://fastapi.tiangolo.com/tutorial/request-files/)'
- en: Handling asynchronous data operations
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异步数据操作
- en: '**Asynchronous programming** is a core feature of FastAPI that allows you to
    develop highly efficient web applications. It allows your application to handle
    multiple tasks concurrently, making it particularly well-suited for I/O-bound
    operations, such as database interactions, file handling, and network communication.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步编程** 是 FastAPI 的一个核心特性，它允许你开发高度高效的 Web 应用程序。它允许你的应用程序同时处理多个任务，使其特别适合 I/O
    密集型操作，如数据库交互、文件处理和网络通信。'
- en: Let’s delve into leveraging asynchronous programming in FastAPI for data operations,
    enhancing the performance and responsiveness of your applications.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨在 FastAPI 中利用异步编程进行数据操作，以增强应用程序的性能和响应能力。
- en: Getting ready
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作
- en: FastAPI is built on Starlette and Pydantic, which provide a robust foundation
    for writing asynchronous code in Python using the `asyncio` library with `async`/`await`
    syntax.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 是基于 Starlette 和 Pydantic 构建的，它们为使用 `asyncio` 库和 `async`/`await` 语法在
    Python 中编写异步代码提供了一个强大的基础。
- en: The `asyncio` library allows you to write non-blocking code that can pause its
    execution while waiting for I/O operations to complete, and then resume where
    it left off, all without blocking the main execution thread.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio` 库允许你编写非阻塞代码，在等待 I/O 操作完成时可以暂停其执行，然后从上次停止的地方继续执行，而无需阻塞主执行线程。'
- en: This recipe demonstrates the benefits of using `asyncio` with FastAPI in a simple,
    practical example.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了在简单、实用的例子中使用 `asyncio` 和 FastAPI 的好处。
- en: How to do it…
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Let's create an application with two endpoints, one that runs a sleeping operation,
    the other that run the sleeping operation as well but in asynchrounous mode. Create
    a new project folder called `async_example` containing the `main.py` module. Fill
    the module as follows.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含两个端点的应用程序，一个运行睡眠操作，另一个也运行睡眠操作但以异步模式运行。创建一个新的项目文件夹`async_example`，包含`main.py`模块。按照以下内容填充模块。
- en: 'Let’s start by creating the FastAPI server object class:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建FastAPI服务器对象类：
- en: '[PRE35]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '2.  Now, let’s create an endpoint that sleeps for 1 second:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.  现在，让我们创建一个睡眠1秒的端点：
- en: '[PRE36]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The sleeping operation represents the waiting time to get a response from the
    database in a real-life scenario.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 睡眠操作代表在实际场景中从数据库获取响应的等待时间。
- en: '3.  Now, let’s create the same endpoint for the `async def` version. The sleeping
    operation will be the sleep function from the `asyncio` module:'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.  现在，让我们为`async def`版本创建相同的端点。睡眠操作将是来自`asyncio`模块的sleep函数：
- en: '[PRE37]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, we have two endpoints, `GET /sync` and `GET/async`, that are similar except
    for the fact the second contains a non-blocking sleeping operation.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个端点，`GET /sync`和`GET/async`，它们除第二个包含非阻塞睡眠操作外，其他都相似。
- en: Once we have our application with the endpoints, let's create a separate Python
    script to measure the time to serve a traffic demand. Let’s call it `timing_api_calls.py`
    and start building it through the following steps.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了带有端点的应用程序，让我们创建一个单独的Python脚本来测量服务流量需求的时间。让我们称它为`timing_api_calls.py`，并通过以下步骤开始构建它。
- en: 'Let’s define the function to run the server:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义运行服务器的函数：
- en: '[PRE38]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '2.  Now, let’s define the start of the server as a context manager:'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.  现在，让我们将服务器的开始定义为上下文管理器：
- en: '[PRE39]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '3.  Now, we can define a function that makes *n* concurrent requests to a specified
    path endpoint:'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.  现在，我们可以定义一个函数，该函数向指定的路径端点发送*n*个并发请求：
- en: '[PRE40]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '4.  At this point, we can gather the operations into a main function, make
    *n* calls for each of the endpoints, and print the time to serve all the calls
    to the terminal:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4.  在这一点上，我们可以将操作组合到主函数中，为每个端点调用*n*次，并将服务所有调用的时间打印到终端：
- en: '[PRE41]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '5.  Finally, we can run the main function in the `asyncio` event loop:'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 5.  最后，我们可以在`asyncio`事件循环中运行主函数：
- en: '[PRE42]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now that we have built our timing script, let''s run it from the command terminal
    as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了我们的计时脚本，让我们从命令终端按照以下方式运行它：
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Time taken to make 10 requests to sync endpoint: 2.3172452449798584 seconds'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到同步端点的10次请求所需时间：2.3172452449798584秒
- en: 'Time taken to make 10 requests to async endpoint: 2.3033862113952637 seconds'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到异步端点的10次请求所需时间：2.3033862113952637秒
- en: '[PRE44]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'if __name__ == "__main__":'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: asyncio.run(main(n=100))
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: asyncio.run(main(n=100))
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Time taken to make 100 requests to sync endpoint: 6.424988269805908 seconds'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到同步端点的100次请求所需时间：6.424988269805908秒
- en: 'Time taken to make 100 requests to async endpoint: 2.423431873321533 seconds'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到异步端点的100次请求所需时间：2.423431873321533秒
- en: '[PRE46]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
