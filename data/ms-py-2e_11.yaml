- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Debugging – Solving the Bugs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 – 解决错误
- en: The previous chapter showed you how to add logging and tests to your code, but
    no matter how many tests you have, you will always have bugs. The biggest problem
    will always be external variables such as user input and different environments.
    At some point sooner or later, we will need to debug issues with our code, or
    worse, the code that was written by someone else.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章向您展示了如何将日志和测试添加到您的代码中，但无论您有多少测试，您总会遇到错误。最大的问题将是外部变量，如用户输入和不同的环境。迟早，我们需要调试我们的代码，或者更糟糕的是，别人的代码。
- en: There are many debugging techniques and, most certainly, you have already used
    a few of them. Within this chapter, we are going to focus on print/trace debugging
    and interactive debugging.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多调试技术，并且肯定您已经使用了一些。在本章中，我们将重点关注打印/跟踪调试和交互式调试。
- en: Debugging using print statements, stack traces, and logging is one of the most
    versatile methods to work with, and it is most likely the first type of debugging
    you ever used. Even a `print('Hello world')` can be considered this type, as the
    output will show you that your code is being executed correctly. There is obviously
    no point in explaining how and where to place print statements to debug your code,
    but there are quite a few nice tricks using decorators and other Python modules
    that render this type of debugging a lot more useful, such as `faulthandler`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用打印语句、堆栈跟踪和日志记录进行调试是工作中最灵活的方法之一，这很可能是你第一次使用的调试类型。甚至一个`print('Hello world')`也可以被认为是这种类型，因为输出会显示你的代码正在正确执行。显然，解释如何以及在哪里放置打印语句来调试代码是没有意义的，但使用装饰器和其他Python模块有很多不错的技巧，可以使这种类型的调试变得更有用，例如`faulthandler`。
- en: Interactive debugging is a more complicated debugging method. It allows you
    to debug a program while it’s still running. Using this method, it’s even possible
    to change variables while the application is running and pause the application
    at any point desired. The downside is that it requires some knowledge about the
    debugger commands to be really useful.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式调试是一种更复杂的调试方法。它允许你在程序仍在运行时进行调试。使用这种方法，甚至可以在应用程序运行时更改变量，并在任何想要的点上暂停应用程序。缺点是它需要一些关于调试器命令的知识才能真正有用。
- en: 'To summarize, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们将涵盖以下主题：
- en: Non-interactive debugging using `print`, `trace`, `logging`, and `faulthandler`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`print`、`trace`、`logging`和`faulthandler`的非交互式调试
- en: Interactive debugging using `pdb`, `ipython`, `jupyter`, and other debuggers
    and debugging services
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pdb`、`ipython`、`jupyter`和其他调试器和调试服务进行交互式调试
- en: Non-interactive debugging
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非交互式调试
- en: The most basic form of debugging is adding a simple print statement into your
    code to see what is still working and what isn’t. This is useful in a variety
    of cases and likely to help solve most of your issues.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 调试的最基本形式是在你的代码中添加一个简单的打印语句，以查看哪些还在工作，哪些没有。这在各种情况下都很有用，并且很可能会帮助你解决大多数问题。
- en: 'Later in this chapter, we will show some interactive debugging methods, but
    those are not always suitable. Interactive debugging tends to become difficult
    or even impossible in cases such as:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将展示一些交互式调试方法，但它们并不总是合适的。交互式调试在以下情况下往往变得困难或甚至不可能：
- en: Multithreaded environments
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程环境
- en: Multiple servers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个服务器
- en: Bugs that are hard (or take a long time) to reproduce
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难以（或需要很长时间）复现的错误
- en: Closed-off remote servers such as Google App Engine or Heroku
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭的远程服务器，如Google App Engine或Heroku
- en: Both interactive and non-interactive debugging methods have their merits, but
    I personally opt for non-interactive debugging 90% of the time, since a simple
    print/log statement is usually enough to analyze the cause of a problem. I find
    interactive debugging to be mostly helpful when writing code which uses large
    and complicated external libraries, where it can be hard to analyze which attributes,
    properties, and methods are available for objects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式和非交互式调试方法都有其优点，但我在90%的情况下会选择非交互式调试，因为简单的打印/日志语句通常足以分析问题的原因。我发现交互式调试在编写使用大型和复杂外部库的代码时非常有帮助，在这些情况下，很难分析对象有哪些属性、属性和方法可用。
- en: 'A basic example of this (I’ve been known to do similar) with a generator can
    be as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的示例（我做过类似的事情）可以使用生成器如下：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This shows exactly where the code does, and consequently, does not reach. Without
    this example, you might have expected the first `print` to come immediately after
    the `hiding_generator()` call. Since it’s a generator, however, nothing will be
    executed until we `yield` an item. Assuming you would have some setup code before
    the first `yield`, it won’t run until `next` is actually called. Additionally,
    `print('c')` is never executed and can be considered unreachable code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了代码的确切执行位置，以及没有执行的位置。如果没有这个例子，你可能预期第一个 `print` 会立即跟在 `hiding_generator()`
    调用之后。然而，由于它是一个生成器，所以直到我们 `yield` 一个项目之前，什么都不会执行。假设你有一些在第一个 `yield` 之前的设置代码，它不会运行，直到
    `next` 实际被调用。此外，`print('c')` 永远不会被执行，可以被认为是不可达的代码。
- en: 'Although this is one of the simplest ways to debug functions using `print`
    calls, it’s not always the most convenient way. We can start by making an auto-print
    function that prints the line of code that it’s going to execute:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是使用 `print` 调用来调试函数的一种简单方法，但并不总是最方便的方法。我们可以先创建一个自动打印函数，它会打印它将要执行的代码行：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, it automatically prints the line number, the name of the function,
    and the line of code it will execute next for you. That way, if you have a slow
    bit of code, you can see which line is stalling because it will be printed before
    execution.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它会自动打印行号、函数名称以及它将要执行的下一行代码。这样，如果你有一段运行缓慢的代码，你可以看到是哪一行导致的延迟，因为它会在执行前被打印出来。
- en: With this specific instance, there’s no real use for a generator, but you could
    easily incorporate some timings so you can see the delay between two `next(print_code)`
    statements. Or perhaps a counter to see how often this particular bit of code
    has been run.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定实例中，生成器并没有真正的用途，但你可以轻松地加入一些计时，以便你可以看到两个 `next(print_code)` 语句之间的延迟。或者也许是一个计数器，用来查看这段特定的代码运行了多少次。
- en: Inspecting your script using trace
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用跟踪来检查你的脚本
- en: Simple print statements are useful in a lot of cases since you can easily incorporate
    print statements in nearly every application. It does not matter whether it’s
    remote or local, threaded or using multiprocessing. It works almost everywhere,
    making it the most universal solution available – in addition to logging, that
    is. The general solution is often not the best solution for every situation, however.
    A nice alternative to our previous function is the `trace` module. It offers you
    a way to trace every executed line, including the runtime. The downside of tracing
    so much data is that it can quickly become overly verbose, as we will see in the
    next example.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的打印语句在许多情况下都很有用，因为你可以轻松地将打印语句集成到几乎每一个应用中。它无关乎是远程还是本地，线程还是使用多进程。它几乎在所有地方都能工作，使其成为最通用的解决方案——除了日志记录之外。然而，通用的解决方案通常并不是每个情况下最好的解决方案。我们之前函数的一个很好的替代方案是
    `trace` 模块。它为你提供了一种方法来跟踪每一条执行的代码，包括运行时间。但是，跟踪这么多数据的缺点是它可能会很快变得过于冗长，正如我们将在下一个例子中看到的那样。
- en: 'To demonstrate, we will use our previous code but without print statements:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们将使用我们之前的代码，但不包含打印语句：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we execute the code with the `trace` module:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用 `trace` 模块来执行代码：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `trace` module shows you exactly which line is being executed with function
    names and, more importantly, which line was caused by which statement (or statements).
    Additionally, it shows you at what time it was executed relative to the start
    time of the program. This is due to the `--timing` flag.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`trace` 模块会显示确切执行了哪一行，包括函数名称，更重要的是，哪一行是由哪个（或哪些）语句引起的。此外，它还会显示相对于程序开始时间的执行时间。这是由于
    `--timing` 标志。'
- en: And it still seems fairly reasonable in terms of output, right? Within this
    example, it does because this is about the most basic code there is. As soon as
    you add an `import`, for example, your screen will be flooded with output. In
    spite of the fact that you can opt to ignore specific modules and directories
    by using command-line parameters, it is still too verbose in many cases.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出的角度来看，这似乎是相当合理的，对吧？在这个例子中，它之所以合理，是因为这可能是最基础的代码了。一旦你添加了一个 `import`，例如，你的屏幕就会被输出信息淹没。尽管你可以通过使用命令行参数来选择性地忽略特定的模块和目录，但在许多情况下，它仍然过于冗长。
- en: 'We can also enable the `trace` module selectively with a little bit of effort:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过一点努力有选择性地启用 `trace` 模块：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code shows a context manager that temporarily enables and disables the
    `trace` module to selectively trace code. In this example, we used `sys.settrace`
    with `tracer.globaltrace` as an argument, but you could also hook to your own
    tracing functions to customize the output.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码展示了如何通过临时启用和禁用`trace`模块来选择性地跟踪代码的上下文管理器。在这个例子中，我们使用了`sys.settrace`并将`tracer.globaltrace`作为参数，但您也可以连接到自己的跟踪函数来自定义输出。
- en: 'When executing this, we get this output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此操作时，我们得到以下输出：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, to illustrate, if we were to run the same code with the trace module enabled,
    we would get a lot of output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了说明，如果我们启用跟踪模块运行相同的代码，我们会得到大量的输出：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `wc` (word count) command shows us that this command gave us `252` lines,
    `2881` words, or `38716` characters of output, so I would generally recommend
    using the context decorator instead. Executing a trace on any reasonably sized
    script will generate a scary amount of output.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`wc`（单词计数）命令显示此命令给出了`252`行，`2881`个单词，或`38716`个字符的输出，因此我通常会建议使用上下文装饰器。对任何合理大小的脚本执行跟踪将生成大量的输出。'
- en: There are a few extra options with the `trace` module, such as showing which
    code is (not) executed, which can be useful to detect code coverage.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`trace`模块有一些额外的选项，例如显示哪些代码被执行（或未执行），这有助于检测代码覆盖率。'
- en: In addition to the arguments we already passed to `trace`, we can easily change
    the output or add extra filters by wrapping or replacing `tracer.globaltrace`
    as the `sys.settrace()` argument. As arguments, the function needs to accept `frame`,
    `event`, and `arg`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们已传递给`trace`的参数外，我们还可以通过包装或替换`sys.settrace()`参数中的`tracer.globaltrace`来轻松更改输出或添加额外的过滤器。作为参数，该函数需要接受`frame`，`event`和`arg`。
- en: The `frame` is a Python stack frame that contains references to the code and
    the filename and can be used to inspect the scope at that point in the stack.
    This is the same frame you can extract when using the `traceback` module.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`frame`是Python堆栈帧，其中包含对代码和文件名的引用，可以用来检查堆栈中的作用域。这是您在使用`traceback`模块时可以提取的相同帧。'
- en: 'The `event` argument is a string that can have the following values (from the
    standard Python documentation):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`event`参数是一个字符串，可以有以下值（来自标准Python文档）：'
- en: '| **Parameter** | **Description** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **描述** |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `call` | A function is called (or some other code block entered). The global
    trace function is called; `arg` is `None`. The return value specifies the local
    trace function. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `call` | 调用一个函数（或进入其他代码块）。调用全局跟踪函数；`arg`为`None`。返回值指定局部跟踪函数。|'
- en: '| `line` | The interpreter is about to execute a new line of code or re-execute
    the condition of a loop. The local trace function is called; `arg` is `None`;
    the return value specifies the new local trace function. See `Objects/lnotab_notes.txt`
    (in the Python source repository) for a detailed explanation of how this works.
    Per-line events may be disabled for a frame by setting `f_trace_lines` to `False`
    on that `frame`. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `line` | 解释器即将执行新的代码行或重新执行循环的条件。调用局部跟踪函数；`arg`为`None`；返回值指定新的局部跟踪函数。有关此功能的详细解释，请参阅`Objects/lnotab_notes.txt`（位于Python源代码库中）。可以通过在`frame`上设置`f_trace_lines`为`False`来禁用每行事件。|'
- en: '| `return` | A function (or another code block) is about to return. The local
    trace function is called; `arg` is the value that will be returned, or `None`
    if the event is caused by an exception being raised. The trace function’s return
    value is ignored. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `return` | 函数（或另一个代码块）即将返回。调用局部跟踪函数；`arg`是即将返回的值，如果事件是由抛出异常引起的，则为`None`。跟踪函数的返回值被忽略。|'
- en: '| `exception` | This means an exception has occurred. The local trace function
    is called; `arg` is a tuple (`exception`, `value`, `traceback`). The return value
    specifies the new local trace function. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `exception` | 这表示发生了异常。调用局部跟踪函数；`arg`是一个元组（`exception`，`value`，`traceback`）。返回值指定新的局部跟踪函数。|'
- en: '| `opcode` | The interpreter is about to execute a new opcode (see the `dis`
    module for opcode details). The local trace function is called; `arg` is `None`;
    the return value specifies the new local trace function. Per-opcode events are
    not emitted by default: they must be explicitly requested by setting `f_trace_opcodes`
    to `True` on the frame. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `opcode` | 解释器即将执行一个新的操作码（有关操作码的详细信息，请参阅`dis`模块）。调用局部跟踪函数；`arg`为`None`；返回值指定新的局部跟踪函数。默认情况下不会发出每操作码事件：必须在帧上显式请求将`f_trace_opcodes`设置为`True`。|'
- en: Lastly, the `arg` argument depends on the `event` argument as illustrated by
    the documentation above. In general, if `arg` is `None`, the return value of this
    function will be used as the local trace function, allowing you to override this
    for a specific scope. With `exception` events, it will be a tuple containing `exception`,
    `value`, and `traceback`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`arg`参数依赖于`event`参数，如上述文档所示。一般来说，如果`arg`是`None`，则此函数的返回值将用作局部跟踪函数，允许你为特定作用域覆盖它。对于`exception`事件，它将是一个包含`exception`、`value`和`traceback`的元组。
- en: 'Now let’s create a little snippet that can selectively trace our code by filtering
    on filename:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个可以按文件名筛选来选择性跟踪我们代码的小片段：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By using the `frame` argument, we can retrieve the code we are currently executing,
    and from that, the filename the code currently exists in. Naturally, you could
    also filter for different functions or only filter to a specific depth. Since
    we hand the tracing and outputting off to `tracer.globaltrace()`, we only check
    the `filename` for a place up in the stack. You could return `trace()` instead
    and handle the `print()` yourself.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`frame`参数，我们可以检索当前正在执行的代码，并从中获取代码当前所在的文件名。自然地，你也可以根据不同的函数或仅过滤到特定的深度进行筛选。由于我们将跟踪和输出委托给`tracer.globaltrace()`，我们只检查堆栈中的`filename`。你也可以返回`trace()`并自行处理`print()`。
- en: 'When executing this code, you should get:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此代码时，你应该得到：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, this excludes the code from `contextlib`, which we saw in the
    earlier example.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这排除了`contextlib`中的代码，我们在前面的例子中已经看到了。
- en: Debugging using logging
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用日志进行调试
- en: In *Chapter 10*, *Testing and Logging – Preparing for Bugs*, we saw how to create
    custom loggers, set the levels for them, and add handlers to specific levels.
    We are going to use the `logging.DEBUG` level to log now, which is nothing special
    by itself, but with a few decorators, we can add some very useful debug-only code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第10章*，*测试和日志 – 准备错误*中，我们看到了如何创建自定义记录器，为它们设置级别，并将处理程序添加到特定级别。我们现在将使用`logging.DEBUG`级别进行日志记录，这本身并没有什么特别之处，但通过几个装饰器，我们可以添加一些非常有用的仅调试代码。
- en: 'Whenever I’m debugging, I always find it very useful to know the input and
    output for a function. The basic version with a decorator is simple enough to
    write; just print the `args`, `kwargs`, and `return` value and you are done. The
    following example goes a little further. By using the `inspect` module, we can
    retrieve the default arguments as well, making it possible to show all arguments
    with the argument names and values in all cases, even if the argument was not
    specified:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在调试时，总是觉得知道函数的输入和输出非常有用。使用装饰器的基本版本足够简单，只需打印`args`、`kwargs`和`return`值即可完成。以下示例更进一步。通过使用`inspect`模块，我们可以检索默认参数，使得在所有情况下都能显示所有参数的名称和值，即使参数未指定：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s analyze how this code executes:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这段代码是如何执行的：
- en: The decorator executes `function()` as normal with the given `*args` and `**kwargs`
    passed along unmodified, while storing the result to both display and `return`
    later.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 装饰器会以正常方式执行`function()`，同时将未修改的`*args`和`**kwargs`传递给函数，并将结果存储起来以供稍后显示和`return`。
- en: The `finally` section of the `try`/`finally` generates an `inspect.Signature()`
    object from `function()`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`try`/`finally`的`finally`部分从`function()`生成一个`inspect.Signature()`对象。'
- en: Now we generate an `inspect.BoundArguments()` object by binding `*args` and
    `**kwargs` using the previously generated `signature`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们通过使用之前生成的`signature`将`*args`和`**kwargs`绑定，生成一个`inspect.BoundArguments()`对象。
- en: Now we can tell the `inspect.BoundArguments()` object to apply the default arguments
    so we can see the value of arguments not passed in `*args` and `**kwargs`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以告诉`inspect.BoundArguments()`对象应用默认参数，这样我们就可以看到未在`*args`和`**kwargs`中传递的参数的值。
- en: Lastly, we output the full function name, the formatted arguments, and the `result`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们输出完整的函数名、格式化的参数和`result`。
- en: 'When we execute the code, we should see the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行代码时，我们应该看到以下内容：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Very nice of course, as we have a clear sight of when the function is called,
    which parameters were used, and what is returned. However, this is something you
    will probably only execute when you are actively debugging your code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这很好，因为我们能清楚地看到函数何时被调用，使用了哪些参数，以及返回了什么。然而，这通常是你在积极调试代码时才会执行的操作。
- en: 'You can also make the regular `logging.debug` statements in your code quite
    a bit more useful by adding a debug-specific logger, which shows more information.
    Simply replace the logging config of the preceding example with this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过添加一个特定于调试的记录器来使你的代码中的常规`logging.debug`语句更有用，该记录器显示更多信息。只需将前一个示例的日志配置替换为以下内容：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then your result will be something like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你的结果将类似于以下内容：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It shows the time relative to the start of the application in milliseconds and
    the log level. This is followed by an identification block that shows the filename,
    line number, and function name that originated the logs. Of course, there is a
    `message` at the end, which contains the result of our log call.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示相对于应用程序开始的时间（以毫秒为单位）和日志级别。接着是一个标识块，显示产生日志的文件名、行号和函数名。当然，在最后还有一个`message`，其中包含我们日志调用的结果。
- en: Showing the call stack without exceptions
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无异常显示调用堆栈
- en: 'When looking at how and why a piece of code is being run, it’s often useful
    to see the entire stack trace. Simply raising an exception is, of course, an option.
    However, that will kill the current code execution, which is generally not something
    we are looking for. This is where the `traceback` module comes in handy. With
    just a simple call to `traceback.print_stack()`, we get a full stack list:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看代码是如何以及为什么被运行时，查看整个堆栈跟踪通常很有用。当然，抛出一个异常也是一个选择。然而，这将终止当前的代码执行，这通常不是我们想要的。这就是`traceback`模块派上用场的地方。只需简单调用`traceback.print_stack()`，我们就能得到完整的堆栈列表：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `ShowMyStack.run()` function shows a regular `traceback.print_stack()` call,
    which shows the entire stack trace to that point in the stack. You could place
    `traceback.print_stack()` anywhere in your code to see where it is being called
    from.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShowMyStack.run()`函数显示了一个常规的`traceback.print_stack()`调用，它显示了堆栈中的整个堆栈跟踪。你可以在代码的任何地方放置`traceback.print_stack()`以查看它是如何被调用的。'
- en: Since the full stack trace can be quite large, it is often useful to use the
    `limit` argument to only show a few levels, which is what we do in the second
    run.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于完整的堆栈跟踪可能相当大，因此通常很有用使用`limit`参数只显示几个级别，这就是我们在第二次运行中所做的。
- en: 'This results in the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致以下结果：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the traceback simply prints without any exceptions. The `traceback`
    module actually has quite a few other methods for printing tracebacks based on
    exceptions and such, but you probably won’t need them often. The most useful one
    is probably the `limit` parameter we’ve demonstrated. A positive limit number
    shows you only a specific number of frames. In most cases, you don’t need a full
    stack trace, so this can be quite useful to limit the output.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，堆栈跟踪简单地打印出来，没有任何异常。实际上，`traceback`模块还有许多其他方法可以基于异常等打印堆栈跟踪，但你可能不会经常需要它们。最有用的可能就是我们已经展示的`limit`参数。正数限制数字只显示特定数量的帧。在大多数情况下，你不需要完整的堆栈跟踪，所以这可以非常有用，以限制输出。
- en: Alternatively, we can also specify a negative limit, which trims the stack from
    the other side. This is mostly useful when printing the stack from a decorator
    where you want to hide the decorator from the trace. If you want to limit both
    sides, you will have to do it manually using `format_list(stack)` with a stack
    from `extract_stack(f, limit)`, the usage of which is similar to the `print_stack()`
    function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以指定一个负数限制，这将从另一侧裁剪堆栈。这在从装饰器打印堆栈时很有用，你希望隐藏装饰器从跟踪中。如果你想限制两边，你必须手动使用`format_list(stack)`和`extract_stack(f,
    limit)`的堆栈，其用法与`print_stack()`函数类似。
- en: The negative limit support was added in Python 3.5\. Before that, only positive
    limits were supported.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.5中添加了对负数限制的支持。在此之前，只支持正数限制。
- en: Handling crashes using faulthandler
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用faulthandler处理崩溃
- en: The `faulthandler` module helps when debugging really low-level crashes, that
    is, crashes that should only be possible when using low-level access to memory,
    such as C extensions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`faulthandler`模块在调试真正低级别的崩溃时很有帮助，即当使用低级别访问内存（如C扩展）时才可能发生的崩溃。'
- en: 'For example, here’s a bit of code that *will* cause your Python interpreter
    to crash:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是一段会导致你的Python解释器崩溃的代码：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It results in something similar to the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 结果类似于以下内容：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That’s quite an ugly response, of course, and gives you no possibility to handle
    the error. Just in case you are wondering, having a `try/except` structure won’t
    help you in these cases either. The following code will crash in exactly the same
    way:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个相当丑陋的响应，并且没有给你处理错误的可能性。如果你想知道，拥有 `try/except` 结构在这些情况下也不会帮助你。以下代码将以完全相同的方式崩溃：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is where the `faulthandler` module helps. It will still cause your interpreter
    to crash, but at least you will see a proper error message raised, so it’s a good
    default if you (or any of the sub-libraries) have any interaction with raw memory:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`faulthandler` 模块有所帮助。它仍然会导致你的解释器崩溃，但至少你会看到一个适当的错误消息被抛出，所以如果你（或任何子库）与原始内存有任何交互，这是一个好的默认设置：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It results in something along these lines:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 结果大致如下：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Obviously, it’s not desirable to have a Python application exit in this manner
    as the code won’t exit with a normal cleanup. Resources won’t be closed cleanly
    and your exit handler won’t be called. If you somehow need to catch this behavior,
    your best bet is to wrap the Python executable in a separate script using something
    like `subprocess.run([sys.argv[0], '` `T_09_faulthandler_enabled.py'])`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，以这种方式让 Python 应用程序退出是不可取的，因为代码不会以正常清理的方式退出。资源将无法被干净地关闭，并且你的退出处理程序不会被调用。如果你需要以某种方式捕获这种行为，最好的办法是将
    Python 可执行文件包裹在一个单独的脚本中，使用类似 `subprocess.run([sys.argv[0], '` `T_09_faulthandler_enabled.py'])`
    的方法。
- en: Interactive debugging
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式调试
- en: Now that we have discussed basic debugging methods that will always work, we
    will look at interactive debugging for some more advanced debugging techniques.
    The previous debugging methods made variables and stacks visible through modifying
    the code and/or foresight. This time around, we will look at a slightly smarter
    method, which constitutes doing the same thing interactively, but once the need
    arises.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了始终有效的基本调试方法，我们将探讨一些更高级的调试技术中的交互式调试。之前的调试方法通过修改代码和/或预见性来使变量和堆栈可见。这一次，我们将看看一个稍微聪明一点的方法，即交互式地做同样的事情，但一旦需要。
- en: Console on demand
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求控制台
- en: 'When testing some Python code, you may have used the interactive console a
    couple of times, since it’s a simple yet effective tool for testing your Python
    code. What you might not have known is that it is actually simple to start your
    own shell from within your code. So, whenever you want to drop into a regular
    shell from a specific point in your code, that’s easily possible:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试一些 Python 代码时，你可能已经使用过交互式控制台几次，因为它是一个简单而有效的测试 Python 代码的工具。你可能不知道的是，实际上从你的代码中启动自己的
    shell 非常简单。所以，无论何时你想从代码的特定点进入一个常规 shell，这都是很容易实现的：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When executing that, we will drop into an interactive console halfway:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，我们将进入一个交互式控制台的中途：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To exit this console, we can use *^d* (*Ctrl* + *D*) on Linux/Mac systems and
    *^z* (*Ctrl* + *Z*) on Windows systems.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出这个控制台，我们可以在 Linux/Mac 系统上使用 *^d* (*Ctrl* + *D*)，在 Windows 系统上使用 *^z* (*Ctrl*
    + *Z*)。
- en: One important thing to note here is that the local scope is not shared between
    the two. Even though we passed along `locals()` to share the local variables for
    convenience, this relation is not bidirectional.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一个重要事情是，局部作用域在这两个之间不是共享的。尽管我们传递了 `locals()` 以便方便地共享局部变量，但这种关系不是双向的。
- en: The result is that even though we set `some_variable` to `456` in the interactive
    session, it does not carry over to the outside function. You can modify variables
    in the outside scope through direct manipulation (for example, setting the properties)
    if you wish, but all variables declared locally will remain local.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，尽管我们在交互会话中将 `some_variable` 设置为 `456`，但它并没有传递到外部函数。如果你愿意，你可以通过直接操作（例如，设置属性）在外部作用域中修改变量，但所有局部声明的变量将保持局部。
- en: Naturally, modifying mutable variables will affect both scopes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，修改可变变量将影响两个作用域。
- en: Debugging using Python debugger (pdb)
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 调试器 (pdb) 进行调试
- en: 'When it comes to actually debugging code, the regular interactive console just
    isn’t suited. With a bit of effort, you can make it work, but it’s just not all
    that convenient for debugging since you can only see the current scope and can’t
    jump around the stack easily. With `pdb` (Python debugger), this is easily possible.
    So, let’s look at a simple example of using `pdb`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当真正调试代码时，常规的交互式控制台并不适合。经过一些努力，你可以让它工作，但这对调试来说并不那么方便，因为你只能看到当前的作用域，而且不能轻易地在堆栈中跳转。使用
    `pdb` (Python 调试器)，这很容易实现。所以，让我们看看使用 `pdb` 的一个简单例子：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This example is pretty much identical to the one in the previous paragraph,
    except that this time we end up in the `pdb` console instead of a regular interactive
    console. So let’s give the interactive debugger a try:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子几乎与前一段落中的例子相同，只是这次我们最终进入的是 `pdb` 控制台而不是常规的交互式控制台。所以，让我们尝试一下交互式调试器：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, we’ve actually modified the value of `some_variable` now. In
    this case, we used the full `continue` command, but all the `pdb` commands have
    short versions as well. So, using `c` instead of `continue` gives the same result.
    Just typing `some_variable` (or any other variable) will show the contents and
    setting the variable will simply set it, just as we would expect from an interactive
    session.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们实际上已经修改了 `some_variable` 的值。在这种情况下，我们使用了完整的 `continue` 命令，但所有的 `pdb`
    命令都有简写版本。所以，使用 `c` 而不是 `continue` 会得到相同的结果。只需键入 `some_variable`（或任何其他变量）即可显示其内容，设置变量将简单地将其设置，就像我们期望从交互式会话中那样。
    |
- en: 'To get started with `pdb`, first of all, a list of the most useful (full) stack
    movement and manipulation commands with shorthands is shown here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 `pdb`，首先，这里显示了最有用的（完整）堆栈移动和操作命令及其缩写列表：
- en: '| **Command** | **Explanation** |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **说明** |'
- en: '| `h(elp)` | This shows the list of commands (this list). |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `h(elp)` | 这显示了命令列表（此列表）。 |'
- en: '| `h(elp) command` | This shows the help for the given command. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `h(elp) command` | 这显示了给定命令的帮助。 |'
- en: '| `w(here)` | Current stack trace with an arrow at the current frame. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `w(here)` | 当前堆栈跟踪，并在当前帧处有一个箭头。 |'
- en: '| `d(own)` | Move down/to a newer frame in the stack. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `d(own)` | 向下/移动到堆栈中的较新帧。 |'
- en: '| `u(p)` | Move up/to an older frame in the stack. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `u(p)` | 向上/移动到堆栈中的较旧帧。 |'
- en: '| `s(tep)` | Execute the current line and stop as soon as possible. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `s(tep)` | 执行当前行，并尽可能快地停止。 |'
- en: '| `n(ext)` | Execute the current line and stop at the next line within the
    current function. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `n(ext)` | 执行当前行，并在当前函数内的下一行停止。 |'
- en: '| `r(eturn)` | Continue execution until the function returns. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `r(eturn)` | 继续执行直到函数返回。 |'
- en: '| `c(ont(inue))` | Continue execution up to the next breakpoint. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `c(ont(inue))` | 继续执行直到下一个断点。 |'
- en: '| `l(ist) [first[, last]]` | List the lines of source code (by default, 11
    lines) around the current line. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `l(ist) [first[, last]]` | 列出当前行周围的源代码行（默认为11行）。 |'
- en: '| `ll &#124; longlist` | List all of the source code for the current function
    or frame. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `ll &#124; longlist` | 列出当前函数或帧的所有源代码。 |'
- en: '| `source expression` | List the source code for the given object. This is
    similar to `longlist`. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `source expression` | 列出给定对象的源代码。这与 `longlist` 类似。 |'
- en: '| `a(rgs)` | Print the arguments for the current function. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `a(rgs)` | 打印当前函数的参数。 |'
- en: '| `pp expression` | Pretty-print the given expression. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `pp expression` | 美化打印给定表达式。 |'
- en: '| `! statement` | Execute the statement at the current point in the stack.
    Normally, the `!` sign is not needed, but this can be useful if there are collisions
    with debugger commands. For example, try `b = 123`. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `! statement` | 在堆栈的当前点执行语句。通常不需要 `!` 符号，但如果与调试器命令有冲突，这可能很有用。例如，尝试 `b = 123`。
    |'
- en: '| `interact` | Open an interactive Python shell session similar to the previous
    paragraph. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `interact` | 打开一个类似于前一段落的交互式Python shell会话。 |'
- en: Many more commands are available and some of them will be covered by the following
    paragraphs. All commands are covered by the built-in help, however, so be sure
    to use the `h/help [command]` command if needed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他命令可用，其中一些将在以下段落中介绍。不过，所有命令都包含在内置的帮助中，所以如果需要，请务必使用 `h/help [command]` 命令。
- en: Breakpoints
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断点
- en: 'Breakpoints are points where the debugger will halt the code execution and
    allow you to debug from that point. We can create breakpoints using either code
    or commands. First, let’s enter the debugger using `pdb.set_trace()`. This is
    effectively a hardcoded breakpoint:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 断点是调试器将停止代码执行并允许你从该点进行调试的点。我们可以使用代码或命令来创建断点。首先，让我们使用 `pdb.set_trace()` 进入调试器。这实际上是一个硬编码的断点：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'So far, nothing new has happened, but let’s now open the interactive debugging
    session and try a few breakpoint commands. Here’s a list of the most useful breakpoint
    commands before we start:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，还没有发生任何新的事情，但现在让我们打开交互式调试会话并尝试一些断点命令。在我们开始之前，这里有一份最常用断点命令的列表：
- en: '| **Command** | **Explanation** |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **说明** |'
- en: '| `b(reak)` | Show the list of breakpoints. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `b(reak)` | 显示断点列表。 |'
- en: '| `b(reak) [filename:]lineno` | Place a breakpoint at the given line number
    and, optionally, file. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `b(reak) [filename:]lineno` | 在给定的行号和可选的文件中放置断点。 |'
- en: '| `b(reak) function[, condition]` | Place a breakpoint at the given function.
    The condition is an expression that must evaluate to `True` for the breakpoint
    to work. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `b(reak) function[, condition]` | 在指定的函数处设置断点。条件是一个表达式，必须评估为 `True` 才能使断点生效。|'
- en: '| `cl(ear) [filename:]lineno` | Clear the breakpoint (or breakpoints) at this
    line. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `cl(ear) [filename:]lineno` | 清除此行上的断点（或断点）。|'
- en: '| `cl(ear) breakpoint [breakpoint ...]` | Clear the breakpoint (or breakpoints)
    with these numbers. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `cl(ear) breakpoint [breakpoint ...]` | 使用这些数字清除断点（或断点）。|'
- en: 'Now let’s execute this code and enter the interactive debugger to try the commands:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行这段代码并进入交互式调试器来尝试这些命令：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'That was a lot of output, but it’s actually not as complex as it seems:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然输出很多，但实际上并不像看起来那么复杂：
- en: First, we used the `source print_value` command to see the source for the `print_value`
    function.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用 `source print_value` 命令查看 `print_value` 函数的源代码。
- en: After that, we knew the line number of the first `print` statement, which we
    used to place a breakpoint (`b 5`) at line 5.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们知道第一个 `print` 语句的行号，我们使用它来在行5处设置断点 (`b 5`)。
- en: To check whether we were still at the right position, we used the `w` command.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检查我们是否仍然在正确的位置，我们使用了 `w` 命令。
- en: Since the breakpoint was set, we used `c` to continue up to the next breakpoint.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于已经设置了断点，我们使用 `c` 继续执行到下一个断点。
- en: Having stopped at the breakpoint at line 5, we used `w` again to confirm that
    and show the current stack.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第5行断点处停止后，我们再次使用 `w` 来确认并显示当前的堆栈。
- en: We listed the code of the current function using `ll`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `ll` 列出了当前函数的代码。
- en: We listed the breakpoints using `b`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `b` 列出了断点。
- en: We removed the breakpoint again using `cl 1` with the breakpoint number from
    the previous command.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `cl 1` 和之前命令中的断点编号再次使用 `cl` 命令移除了断点。
- en: We continued (`c`) until the program exits or reaches the next breakpoint if
    available.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续 (`c`) 直到程序退出或达到下一个断点（如果有的话）。
- en: It all seems a bit complicated in the beginning, but you’ll see that it’s actually
    a very convenient way of debugging once you’ve tried a few times.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时似乎有点复杂，但一旦你尝试了几次，你会发现这实际上是一种非常方便的调试方式。
- en: 'To make it even better, this time we will execute the breakpoint only when
    `value = 3`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让它更好，这次我们只在 `value = 3` 时执行断点：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To list what we have done:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出我们所做的一切：
- en: First, using `source print_value`, we looked for the line number and variable
    name.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用 `source print_value`，我们查找行号和变量名。
- en: After that, we placed a breakpoint with the `value == 3` condition.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们使用 `value == 3` 条件设置了断点。
- en: Then we continued execution using `c`. As you can see, the values `0`, `1`,
    and `2` are printed as normal.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用 `c` 继续执行。正如你所看到的，值 `0`、`1` 和 `2` 被正常打印出来。
- en: The breakpoint was reached at value `3`. To verify, we used `a` to see the function
    arguments.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在值 `3` 处达到了断点。为了验证，我们使用 `a` 来查看函数参数。
- en: We changed the variable before `print()` was executed.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `print()` 执行之前，我们更改了变量。
- en: We continued to execute the rest of the code.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续执行代码的其余部分。
- en: Catching exceptions
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获异常
- en: 'All of these have been manual calls to the `pdb.set_trace()` function, but
    in general, you are just running your application and not really expecting issues.
    This is where exception catching can be very handy. In addition to importing `pdb`
    yourself, you can run scripts through `pdb` as a module as well. Let’s examine
    this bit of code, which dies as soon as it reaches zero division:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是在手动调用 `pdb.set_trace()` 函数，但通常你只是在运行你的应用程序，并不真正期望出现问题。这就是异常捕获非常有用的地方。除了自己导入
    `pdb`，你还可以通过 `pdb` 作为模块运行脚本。让我们检查一下这段代码，它在达到零除时立即崩溃：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we run it through the `pdb` module, we can end up in the Python debugger
    whenever it crashes:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过 `pdb` 模块运行它，我们可以在它崩溃时进入Python调试器：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A useful little trick within `pdb` is to use the *Enter* button, which, by default,
    will execute the previously executed command again. This is very useful when stepping
    through the program.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdb` 中一个有用的技巧是使用 *Enter* 按钮，默认情况下，它将再次执行之前执行的命令。这在逐步执行程序时非常有用。'
- en: Aliases
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 别名
- en: Aliases can be a really useful feature to make your life easier. If you “live”
    in a Linux/Unix shell like I do, you are probably already familiar with them,
    but essentially an alias is just a shorthand to save you from having to type (or
    even remember) a long and complicated command.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 别名可以是一个非常实用的功能，可以让你的生活更轻松。如果你像我一样“生活在”Linux/Unix shell中，你可能已经熟悉它们了，但本质上别名只是一个简写，可以让你不必输入（甚至记住）一个长而复杂的命令。
- en: Which aliases are useful for you depends on your preferences of course, but
    I personally like an alias for the `pprint` (pretty print) module. Within my projects,
    I often use `pf=pprint.pformat` and `pp=pprint.pprint` as aliases, but the same
    goes for `pdb` where I find `pd` a useful shorthand for pretty printing the `__dict__`
    for a given object.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些别名对你有用取决于你的个人喜好，但就我个人而言，我喜欢为 `pprint`（美化打印）模块设置别名。在我的项目中，我经常使用 `pf=pprint.pformat`
    和 `pp=pprint.pprint` 作为别名，但在 `pdb` 中，我发现 `pd` 是一个用于美化打印给定对象 `__dict__` 的有用缩写。
- en: 'The `pdb` commands for aliases are relatively straightforward and very easy
    to use:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdb` 命令的别名相对简单且非常易于使用：'
- en: '| `alias` | List all aliases. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `alias` | 列出所有别名。 |'
- en: '| `alias name command` | Create an alias. The command can be any valid Python
    expression, so you can do the following to print all properties for an object:`alias
    pd pp %1.__dict__` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `alias name command` | 创建一个别名。命令可以是任何有效的 Python 表达式，因此您可以执行以下操作以打印对象的全部属性：`alias
    pd pp %1.__dict__` |'
- en: '| `unalias name` | Remove an alias. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `unalias name` | 删除一个别名。 |'
- en: Make sure to use these to your advantage. Within Linux/Unix systems, you have
    probably noticed that many commands (`ls`, `rm`, `cd`) are very short to save
    you some typing; you can do the same with these aliases.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 确保充分利用这些功能。在 Linux/Unix 系统中，您可能已经注意到许多命令（`ls`、`rm`、`cd`）非常简短，以节省您输入；您可以使用这些别名做同样的事情。
- en: commands
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令
- en: 'The `commands` command is a little complicated but very useful. It allows you
    to execute commands whenever a specific breakpoint is encountered. To illustrate
    this, let’s start from a simple example again:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`commands` 命令有些复杂但非常有用。它允许您在遇到特定断点时执行命令。为了说明这一点，让我们再次从一个简单的例子开始：'
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The code is simple enough, so now we’ll add the breakpoint and the commands,
    as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单，所以现在我们将添加断点和命令，如下所示：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, we can easily add commands to the breakpoint. After removing
    the breakpoint, these commands won’t be executed anymore because they are linked
    to the breakpoint.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以轻松地向断点添加命令。在移除断点后，这些命令将不再执行，因为它们与断点相关联。
- en: These can be really useful to add some automatic debug `print` statements to
    your breakpoint; for example, to see the value of all of the variables in the
    local scope. You can always manually do a `print(locals())` of course, but these
    can save you a lot of time while debugging.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能可以非常方便地添加一些自动调试 `print` 语句到您的断点；例如，查看局部作用域中所有变量的值。当然，您始终可以手动执行 `print(locals())`，但这些可以在调试过程中节省您大量时间。
- en: Debugging with IPython
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 IPython 进行调试
- en: While the generic Python console is useful, it can be a little rough around
    the edges. The IPython console offers a whole new world of extra features, which
    make it a much nicer console to work with. One of those features is a more convenient
    debugger.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通用的 Python 控制台很有用，但它可能有些粗糙。IPython 控制台提供了一整套额外功能，使其成为一个更舒适的终端来工作。其中之一是一个更方便的调试器。
- en: 'First, make sure you have `ipython` installed:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请确保您已安装 `ipython`：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, let’s try the debugger with a very basic script:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试使用一个非常基本的脚本来使用调试器：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we run IPython and tell it to run the script in debug mode:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们运行 IPython 并告诉它以调试模式运行脚本：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, not all that different from `pdb`. But it automatically shows
    the surrounding code in a readable format, which is very useful. Additionally,
    the shown code has syntax highlighting, which helps with readability as well.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，与 `pdb` 并无太大差异。但它会自动以可读的格式显示周围的代码，这非常有用。此外，显示的代码具有语法高亮，这有助于提高可读性。
- en: If you install the `ipdb` module, you get features similar to the `pdb` module,
    which allow for triggering breakpoints from your code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您安装了 `ipdb` 模块，您将获得与 `pdb` 模块类似的功能，这允许您从代码中触发断点。
- en: Debugging with Jupyter
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Jupyter 进行调试
- en: Jupyter is amazing for ad hoc development and makes it really easy to see what’s
    going on in your code for small scripts. For larger scripts, it can quickly become
    more difficult because you normally only get the non-interactive stack trace and
    have to resort to a different method for changing external code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter 对于临时开发非常出色，使得查看小脚本中的代码变得非常容易。对于较大的脚本，这可能会迅速变得困难，因为您通常只能获得非交互式的堆栈跟踪，并且必须求助于不同的方法来更改外部代码。
- en: 'Since 2020, however, Jupyter has added a (currently experimental) visual debugger
    to make it possible to debug your code as it happens in a very convenient way.
    To get started, make sure you have a recent version of Jupyter and install both
    the `@jupyterlab/debugger` extension and the `xeus-python` (XPython) kernel for
    Jupyter. To make sure everything works without too much effort, I strongly recommend
    using `conda` for this operation:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，自 2020 年以来，Jupyter 添加了一个（目前处于实验性阶段）的视觉调试器，以便以非常方便的方式调试你的代码。要开始，请确保你有最新的 Jupyter
    版本，并安装 `@jupyterlab/debugger` 扩展和 Jupyter 的 `xeus-python`（XPython）内核。为了确保一切都能轻松工作，我强烈建议使用
    `conda` 进行此操作：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The current installation instructions for Conda can be found on the JupyterLab
    debugger GitHub page: [https://jupyterlab.readthedocs.io/en/latest/user/debugger.html](Chapter_11.xhtml)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Conda 的当前安装说明可以在 JupyterLab 调试器 GitHub 页面上找到：[https://jupyterlab.readthedocs.io/en/latest/user/debugger.html](Chapter_11.xhtml)
- en: 'For a regular Python virtual environment, you can try the binary wheel (`.whl`)
    packages so you don’t have to compile anything. Due to the currently experimental
    nature of this feature, it is not supported in all environments yet. At the time
    of writing, binary wheels are available for Python 3.6, 3.7 and 3.8 for OS X,
    Linux, and Windows. A list of available versions can be found here: [https://pypi.org/project/xeus-python/#files](Chapter_11.xhtml)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常规的 Python 虚拟环境，你可以尝试二进制轮（`.whl`）包，这样你就不需要编译任何东西。由于这个功能目前处于实验性阶段，因此它尚未在所有环境中得到支持。在撰写本文时，二进制轮适用于
    Python 3.6、3.7 和 3.8，适用于 OS X、Linux 和 Windows。可用的版本列表可以在以下位置找到：[https://pypi.org/project/xeus-python/#files](Chapter_11.xhtml)
- en: 'Now we can start `jupyter lab` as normal:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像平常一样启动 `jupyter lab`：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If everything is working as expected, you should see the JupyterLab launcher
    now, with both Python 3 and the XPython kernels available:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按预期工作，你现在应该能看到 JupyterLab 启动器，其中提供了 Python 3 和 XPython 内核：
- en: '![](img/B15882_11_01.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_11_01.png)'
- en: 'Figure 11.1: JupyterLab Python and XPython kernels'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：JupyterLab Python 和 XPython 内核
- en: 'Since only `xeus-python` (XPython) currently supports debugging, we will have
    to open that one. Now we will add our script from before so we can demonstrate
    the debugger. If everything is working correctly, you should see the debug buttons
    at the top-right part of your screen:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有 `xeus-python`（XPython）目前支持调试，我们不得不打开它。现在我们将添加之前的脚本，以便我们可以演示调试器。如果一切正常工作，你应该能在屏幕右上角看到调试按钮：
- en: '![](img/B15882_11_02.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_11_02.png)'
- en: 'Figure 11.2: Regular Jupyter console output'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：常规 Jupyter 控制台输出
- en: 'Now we can start debugging by following these steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以按照以下步骤开始调试：
- en: Enable the debug toggle at the top right.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用右上角的调试切换。
- en: Click on a line to add a breakpoint.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击一行以添加断点。
- en: Run the code.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。
- en: 'If everything is set up correctly, it should look something like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切设置正确，它应该看起来像这样：
- en: '![](img/B15882_11_03.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_11_03.png)'
- en: 'Figure 11.3: Debugging using Jupyter'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：使用 Jupyter 进行调试
- en: From this point on, you can use the buttons in the debugging pane on the right
    to step over/in/out of the next statement to walk through the code.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，你可以使用右侧调试面板中的按钮来跳过/进入/退出下一语句，以遍历代码。
- en: Other debuggers
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他调试器
- en: 'The `pdb` debugger is simply the Python default, but far from the only option
    to debug Python code. Some of the currently noteworthy debuggers are as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdb` 调试器只是 Python 的默认调试器，但远非调试 Python 代码的唯一选项。一些目前值得注意的调试器如下：'
- en: '`ipdb`: The `pdb` debugger wrapped in an IPython shell'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipdb`：将 `pdb` 调试器包装在 IPython 壳中的调试器'
- en: '`pudb`: A full-screen command-line debugger'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pudb`：一个全屏的命令行调试器'
- en: '`pdbpp` (pdb++): An extension to the regular `pdb` module, which adds tab completion,
    syntax highlighting, and a few other useful features to `pdb`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pdbpp`（pdb++）：`pdb` 模块的一个扩展，它为 `pdb` 添加了自动补全、语法高亮和一些其他有用的功能'
- en: '`Werkzeug`: A web-based debugger that allows debugging of web applications
    while they are running'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Werkzeug`：一个基于 Web 的调试器，允许在应用程序运行时进行调试'
- en: There are many others, of course, and there isn’t a single one that’s the absolute
    best. As is the case with all tools, they all have their advantages and their
    flaws, and the one that is best for your current purpose can be properly decided
    only by you. Chances are that your current Python IDE already has an integrated
    debugger. The PyCharm IDE, for example, even offers built-in remote debugging
    so you can debug applications running on cloud providers from your local graphical
    interface.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有很多其他的选择，而且没有一个绝对是最棒的。就像所有工具一样，它们都有各自的优点和缺点，最适合你当前目的的工具只能由你自己决定。很可能你的当前
    Python IDE 已经集成了调试器。例如，PyCharm IDE 甚至提供了内置的远程调试功能，这样你就可以从本地的图形界面调试在云服务提供商上运行的应用程序。
- en: Debugging services
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试服务
- en: In addition to debugging when you encounter a problem, there are times when
    you simply need to keep track of errors for later debugging. This can be especially
    difficult if your application is running on remote servers or on computers not
    controlled by you. For this type of error tracking, there are a few very useful
    open-source packages available.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在遇到问题时进行调试之外，有时你只需要跟踪错误以供以后调试。如果你的应用程序运行在远程服务器或不受你控制的计算机上，这可能会特别困难。对于这种错误跟踪，有一些非常实用的开源软件包可用。
- en: Elastic APM
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Elastic APM
- en: Elastic APM is part of the Elastic Stack and can keep track of errors, performance,
    logs, and other data for you. This system can help you track not only Python applications
    but supports a whole range of other languages and applications as well. The Elastic
    Stack (which is built around Elasticsearch) is an extremely versatile and very
    well-maintained stack of software which I highly recommend.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Elastic APM 是 Elastic Stack 的一部分，可以为你跟踪错误、性能、日志和其他数据。这个系统不仅可以跟踪 Python 应用程序，还支持一系列其他语言和应用程序。Elastic
    Stack（它围绕 Elasticsearch 构建）是一个极其灵活且维护得非常好的软件堆栈，我强烈推荐。
- en: The only downside of the Elastic Stack is that it is a very heavy set of applications,
    which quickly requires a number of dedicated servers to maintain reasonable performance.
    It does scale very well, however; if you ever need more processing power, you
    can simply add a new machine to your cluster and everything will automatically
    rebalance for you.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Elastic Stack的唯一缺点是它是一套非常庞大的应用程序，很快就需要大量的专用服务器来维持合理的性能。然而，它扩展得非常好；如果你需要更多的处理能力，你只需向你的集群添加一台新机器，一切都会自动为你重新平衡。
- en: Sentry
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Sentry
- en: 'Sentry is an open-source error management system that allows you to collect
    errors from a wide range of languages and frameworks. Some notable features are:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Sentry 是一个开源的错误管理系统，允许你从广泛的编程语言和框架中收集错误。一些显著的功能包括：
- en: Grouping of errors so you only get one (or a configurable number of) notification
    of errors per type of error
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将错误分组，这样你只会收到一种（或可配置数量的）错误通知
- en: Being able to mark an error as “fixed” so it re-alerts you when it occurs again
    while still showing you the previous occurrences
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够将错误标记为“已修复”，这样当它再次发生时，它会重新提醒你，同时仍然显示之前的出现
- en: Showing a full stack trace including surrounding code
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示完整的堆栈跟踪，包括周围的代码
- en: Keeping track of code versions/releases so you know which version (re-)introduced
    an error
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪代码版本/发布，以便你知道哪个版本（重新）引入了错误
- en: Assign errors to a specific **developer** to fix
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将错误分配给特定的**开发者**修复
- en: While the Sentry application is mainly focused on web applications, it can easily
    be used for regular applications and scripts as well.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Sentry应用程序主要关注Web应用程序，但它也可以很容易地用于常规应用程序和脚本。
- en: Historically, Sentry started as a small error-grouping application that could
    be used as an app within an existing Django application, or as a separate installation
    depending on your needs. Since that time, very little of that lightweight structure
    remains; it has grown into a fully fledged error tracking system that has native
    support for many programming languages and frameworks.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，Sentry 最初是一个小的错误分组应用程序，它可以作为一个现有 Django 应用程序中的应用程序使用，或者根据你的需求作为单独的安装。从那时起，那种轻量级结构的大部分已经不复存在；它已经发展成为一个完整的错误跟踪系统，它对许多编程语言和框架提供了原生支持。
- en: 'Over time, Sentry has gravitated more and more toward the commercial hosted
    platform, however, so hosting the application yourself has become more difficult
    with that. The time that a simple `pip install sentry` was enough to get it running
    is long gone. These days, Sentry is a heavy application that relies on the following
    running services:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，Sentry越来越多地转向商业托管平台，因此自行托管应用程序变得更加困难。简单使用`pip install sentry`就能运行的时代已经一去不复返了。如今，Sentry是一个重量级的应用程序，依赖于以下运行的服务：
- en: PostgreSQL
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: Redis
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis
- en: Memcached
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Memcached
- en: Symbolicator
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号化器
- en: Kafka
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kafka
- en: Snuba
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Snuba
- en: So if you wish to try Sentry, I would recommend trying the free tier of the
    hosted Sentry to see if you like it first. Manually installing is not really a
    valid option anymore, so if you wish to run it self-hosted, your only realistic
    option is to use the `docker-compose` files provided.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你想尝试Sentry，我建议先尝试托管Sentry的免费套餐，看看你是否喜欢它。手动安装不再是可行的选项，所以如果你想自行托管，你唯一现实的选择是使用提供的`docker-compose`文件。
- en: When self-hosting, you should keep in mind that it is a heavy application that
    requires a significant amount of resources to run and can easily fill a decently
    sized dedicated server. It is still lighter than Elastic APM, however.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当自行托管时，你应该记住它是一个重量级的应用程序，需要大量的资源来运行，并且很容易填满一个相当大的专用服务器。然而，它仍然比Elastic APM轻。
- en: In my experience, you need at least about 2-3 GiB of RAM and about 2 CPU cores
    to run current versions of Sentry. Depending on your load, you might need something
    much heavier, but that is the bare minimum.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，你需要至少大约2-3 GiB的RAM和大约2个CPU核心来运行当前版本的Sentry。根据你的负载，你可能需要更重的配置，但这是最低要求。
- en: Exercises
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'For local development, a few small utility functions can make your life much
    easier. We have already seen an example of this with the `print_code` generator
    and the `trace` context wrapper. See if you can extend one of these to:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地开发，一些小的实用函数可以使你的生活更加轻松。我们已经看到了`print_code`生成器和`trace`上下文包装器的例子。看看你是否可以扩展其中一个到：
- en: Execute code with a timeout so you can see where your application is stalling
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以超时方式执行代码，以便你可以看到应用程序在哪里停滞
- en: Measure the duration of the execution
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量执行时长
- en: Show how often that specific bit of code has been executed
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示特定代码块被执行了多少次
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_11.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些练习的示例答案可以在GitHub上找到：[https://github.com/mastering-python/exercises](Chapter_11.xhtml)。我们鼓励你提交自己的解决方案，并从他人的解决方案中学习其他方法。
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explained a few different debugging techniques and gotchas. There
    is, of course, much more that can be said about debugging, but I hope you have
    acquired a nice vantage point for debugging your Python code now. Interactive
    debugging techniques are very useful for single-threaded applications and locations
    where interactive sessions are available.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了几种不同的调试技术和注意事项。当然，关于调试还有很多可以说的，但我希望你现在已经对调试Python代码有了很好的理解。交互式调试技术在单线程应用程序和有交互会话的地方非常有用。
- en: But since that’s not always the case, we also discussed some non-interactive
    options.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于情况并不总是如此，我们也讨论了一些非交互式选项。
- en: To recap, in this chapter, we talked about non-interactive debugging with `print`
    statements, `logging`, `trace`, `traceback`, `asyncio`, and `faulthandler`. We
    also explored interactive debugging with the Python debugger, IPython, and Jupyter,
    as well as learning about alternative debuggers.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，在本章中，我们讨论了使用`print`语句、`logging`、`trace`、`traceback`、`asyncio`和`faulthandler`的非交互式调试。我们还探讨了使用Python调试器、IPython和Jupyter的交互式调试，以及了解其他调试器。
- en: In the next chapter, we will see how to monitor and improve both CPU and memory
    performance, as well as finding and fixing memory leaks.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何监控和改进CPU和内存性能，以及查找和修复内存泄漏。
- en: Join our community on Discord
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](Chapter_11.xhtml)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：[https://discord.gg/QMzJenHuJf](Chapter_11.xhtml)
- en: '![](img/QR_Code156081100001293319171.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code156081100001293319171.png)'
