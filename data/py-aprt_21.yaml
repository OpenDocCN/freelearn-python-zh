- en: Notes
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: '##'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '##'
- en: 1Though more and more projects are starting to be “primarily Python 3” or even
    “Python 3 only”.[↩](chap04.xhtml#fnref-established)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 1尽管越来越多的项目开始“主要是Python 3”甚至“仅限Python 3”。[↩](chap04.xhtml#fnref-established)
- en: 2We don’t cover *regular expressions* – also known as *regexes* – in this book.
    See the documentation for the Python Standard Library `re` module for more information.
    [https://docs.python.org/3/library/re.html](https://docs.python.org/3/library/re.html)[↩](chap07.xhtml#fnref-regex)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 2我们不在本书中涵盖*正则表达式*，也称为*regexes*。有关更多信息，请参阅Python标准库`re`模块的文档。[https://docs.python.org/3/library/re.html](https://docs.python.org/3/library/re.html)[↩](chap07.xhtml#fnref-regex)
- en: 3Technically modules don’t have to be simple source code files, but for the
    purposes of this book that is a sufficient definition.[↩](chap08.xhtml#fnref-modules-as-files)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 3从技术上讲，模块不一定是简单的源代码文件，但对于本书的目的，这是一个足够的定义。[↩](chap08.xhtml#fnref-modules-as-files)
- en: 4Technically some of these compiled languages *do* provide mechanisms for defining
    functions dynamically at runtime. However, these methods are by far the exception
    rather than the rule in almost all situations.[↩](chap08.xhtml#fnref-dynamic-functions)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 4从技术上讲，一些编译语言确实提供了在运行时动态定义函数的机制。然而，在几乎所有情况下，这些方法都是例外而不是规则。[↩](chap08.xhtml#fnref-dynamic-functions)
- en: 5Python code is actually compiled to byte-code, so in that sense Python has
    a compiler. But the compiler is doing substantially different kinds of work than
    what you might be used to from popular compiled, statically-typed languages.[↩](chap08.xhtml#fnref-no-compiler)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 5Python代码实际上是编译成字节码的，因此从这个意义上说，Python有一个编译器。但是编译器所做的工作与您从流行的编译、静态类型语言中所熟悉的工作大不相同。[↩](chap08.xhtml#fnref-no-compiler)
- en: 6You’ll notice that here we’ve referred to the *object reference* with the name
    `x` as `x`. This is admittedly a bit sloppy since, of course, `x` will generally
    mean *the object referred to by the object reference with the name `x`*. But that’s
    a mouthful and a bit overly pedantic. Generally speaking, the context of the use
    of reference names will be sufficient to tell you whether we mean the object or
    the reference.[↩](chap09.xhtml#fnref-reference-names)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 6您会注意到，这里我们用名称`x`来引用*对象引用*，并将其表示为`x`。这有点懒散，因为当然，`x`通常意味着*由名称`x`的对象引用引用的对象*。但这有点啰嗦和过于迂腐。一般来说，引用名称的使用上下文足以告诉您我们是指对象还是引用。[↩](chap09.xhtml#fnref-reference-names)
- en: 7Garbage collection is an advanced topic that we won’t cover in this book. In
    short, though, it’s the system by which Python deallocates and reclaims resources
    (i.e. objects) which it determines are no longer in use.[↩](chap09.xhtml#fnref-garbage-collection)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 7垃圾回收是一个我们在本书中不会涵盖的高级主题。简而言之，这是Python用来释放和回收它确定不再使用的资源（即对象）的系统。[↩](chap09.xhtml#fnref-garbage-collection)
- en: 8Since assigning a list reference to another name doesn’t copy the list, you
    may be wondering how you *could* make copy if you wanted. This requires other
    techniques which we’ll look at later when we cover lists in more detail.[↩](chap09.xhtml#fnref-copying-lists)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 8由于将列表引用分配给另一个名称不会复制列表，您可能想知道如果需要的话*如何*进行复制。这需要其他技术，我们稍后在更详细地讨论列表时会看到。[↩](chap09.xhtml#fnref-copying-lists)
- en: 9Note, however, that Python does not enforce this behavior. It is entirely possible
    to create an object which reports that it is not value-identical to itself. We’ll
    look at how to do this — should you for some reason feel the urge — in later chapters.[↩](chap09.xhtml#fnref-non-identical-objects)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 9然而，请注意，Python不强制执行此行为。完全有可能创建一个对象，该对象报告它与自身不是值相同。我们将在后面的章节中看看如何做到这一点 - 如果您因某种原因感到有冲动的话。[↩](chap09.xhtml#fnref-non-identical-objects)
- en: 10Though there’s no universally accepted terminology, you’ll often see the term
    *parameters* or *formal parameters* used to mean the names declared at the function
    definition. Likewise, the term *arguments* is often used to mean the actual objects
    passed into a function (and, thus, bound to the parameters). We’ll use this terminology
    as needed throughout this book.[↩](chap09.xhtml#fnref-parameters-vs-arguments)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 10虽然没有普遍接受的术语，但您经常会看到术语*参数*或*形式参数*用来表示在函数定义中声明的名称。同样，术语*参数*经常用来表示传递给函数的实际对象（因此，绑定到参数）。我们将根据需要在本书中使用这些术语。[↩](chap09.xhtml#fnref-parameters-vs-arguments)
- en: 11And this behavior is part of the syntax implementation, not the type system.[↩](chap09.xhtml#fnref-not-the-type-system)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 11这种行为是语法实现的一部分，而不是类型系统的一部分。[↩](chap09.xhtml#fnref-not-the-type-system)
- en: 12Back in Python 2 days `range()` was a function which returned a list. The
    Python 3 version of `range` is much more efficient, useful and powerful.[↩](chap10.xhtml#fnref-range)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 12在Python 2时代，`range()`是一个返回列表的函数。Python 3版本的`range`更加高效、有用和强大。[↩](chap10.xhtml#fnref-range)
- en: '13This, of course, brings to mind the classic joke: The two hardest problems
    in programming are naming, cache coherence, and off-by-one errors.[↩](chap10.xhtml#fnref-one-off)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 13当然，这让人想起了一个经典笑话：编程中最困难的两个问题是命名、缓存一致性和一次性错误。[↩](chap10.xhtml#fnref-one-off)
- en: 14Arguably, it’s poor design to have a module containing functions of the same
    name, because of this issue.[↩](chap10.xhtml#fnref-overwrite)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 14可以说，一个包含相同名称函数的模块设计不好，因为会出现这个问题。[↩](chap10.xhtml#fnref-overwrite)
- en: 15We cover the iterable protocol in detail later in this chapter.[↩](chap12.xhtml#fnref-cover-iterable-protocol-later)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 15我们稍后在本章中详细介绍可迭代协议。[↩](chap12.xhtml#fnref-cover-iterable-protocol-later)
- en: 16Well, they can, but recall that iterating over a dictionary yields only the
    keys![↩](chap12.xhtml#fnref-dictionary-sources)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 16嗯，它们可以，但请记住，遍历字典只会产生键！[↩](chap12.xhtml#fnref-dictionary-sources)
- en: 17We often just use the term *generator* to refer to generator functions, though
    sometimes it may be necessary to distinguish generator *functions* from generator
    *expressions*, which we cover later.[↩](chap12.xhtml#fnref-just-generator)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 17我们经常只使用术语*生成器*来指代生成器函数，尽管有时可能需要区分生成器*函数*和生成器*表达式*，我们稍后会涵盖这一点。[↩](chap12.xhtml#fnref-just-generator)
- en: 18The authors are sworn by sacred oath never to use either Fibonacci or Quicksort
    implementations in demonstrations or exercises.[↩](chap12.xhtml#fnref-no-fibonacci)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 18作者们发誓永远不会在演示或练习中使用斐波那契或快速排序的实现。
- en: 19This has nothing whatsoever to do with the order in which you should watch
    the episodes of Star Wars. If that’s what you’re looking for, might we suggest
    [Machete Order](http://www.nomachetejuggling.com/2011/11/11/the-star-wars-saga-suggested-viewing-order/).[↩](chap12.xhtml#fnref-machete-order)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 19这与您应该观看Star Wars剧集的顺序无关。如果您正在寻找这方面的建议，我们可以建议[Machete Order](http://www.nomachetejuggling.com/2011/11/11/the-star-wars-saga-suggested-viewing-order/)。
- en: 20In fact, it is possible to change the class of an object at runtime, although
    this is an advanced topic, and the technique is only rarely used.[↩](chap13.xhtml#fnref-fixed)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 20实际上，可以在运行时更改对象的类，尽管这是一个高级话题，而且这种技术很少被使用。
- en: 21It’s generally unhelpful to think about the *destruction* of objects in Python.
    Better to think of objects becoming unreachable.[↩](chap13.xhtml#fnref-unreachable)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 21在Python中，考虑对象的*销毁*通常是没有帮助的。最好考虑对象变得不可访问。
- en: 22The *formal* arguments of a function are the arguments listed in the function
    *definition*.[↩](chap13.xhtml#fnref-formal)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 22函数的*形式*参数是函数*定义*中列出的参数。
- en: 23The *actual* arguments of a function are the arguments listed in a function
    *call*.[↩](chap13.xhtml#fnref-actual)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 23函数的*实际*参数是函数*调用*中列出的参数。
- en: 24Nor any language, for that matter.[↩](chap14.xhtml#fnref-detecting-encoding)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '24或者任何语言。 '
- en: 25You can get the full details of the with-statements syntactic equivalence
    in [PEP 343](https://www.python.org/dev/peps/pep-0343/).[↩](chap14.xhtml#fnref-see-pep-343)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 25您可以在[PEP 343](https://www.python.org/dev/peps/pep-0343/)中找到关于with语句的语法等价的完整细节。
- en: 26You can learn all about the BMP format [here](https://en.wikipedia.org/wiki/BMP_file_format).[↩](chap14.xhtml#fnref-bmp-details)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 26您可以在[这里](https://en.wikipedia.org/wiki/BMP_file_format)了解有关BMP格式的所有细节。
- en: 27Like, for example, *sequence* protocol is for tuple-like-objects.[↩](chap14.xhtml#fnref-like-sequence-protocol)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 27比如，*sequence*协议是用于类似元组的对象。
- en: 28**E**asier to **A**sk **F**orgiveness Than **P**ermission[↩](chap14.xhtml#fnref-EAFP)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 28**E**asier to **A**sk **F**orgiveness Than **P**ermission
- en: 29Test-driven development, or TDD, is a form of software development where tests
    are written first, i.e. before you write the actual functionality to be tested.
    This may seem backwards at first, but it can be a surprisingly powerful technique.
    You can learn more about TDD [here](https://en.wikipedia.org/wiki/Test-driven_development).[↩](chap15.xhtml#fnref-test-driven-development)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 29测试驱动开发，或TDD，是一种软件开发形式，其中测试是首先编写的，即在编写要测试的实际功能之前。这乍看起来可能有些反常，但它实际上是一种非常强大的技术。您可以在[这里](https://en.wikipedia.org/wiki/Test-driven_development)了解更多关于TDD的信息。
- en: 30Note that we don’t actually try to test any functionality yet. This is just
    the initial skeleton of our test suite that lets us verify that the test method
    executes.[↩](chap15.xhtml#fnref-no-actual-test)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 30请注意，我们实际上并没有尝试测试任何功能。这只是我们测试套件的初始框架，让我们验证测试方法是否执行。
- en: 31A tenet of TDD is that your tests should fail before they pass, and you should
    only ever write enough implementation code to make you tests pass. In this way,
    your tests stand as a complete description how your code should behave.[↩](chap15.xhtml#fnref-tdd-fail-edit-pass)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 31TDD的原则是，您的测试应该在通过之前失败，并且您只能编写足够的实现代码来使测试通过。通过这种方式，您的测试就是对代码应该如何行为的完整描述。
- en: 32You may have noticed that the `setUp()` and `tearDown()` method names aren’t
    in line with what PEP 8 prescribes. This is because the `unittest` module predates
    those parts of PEP 8 which specify the convention of function names being in lower
    case with underscores. There are several such cases in the Python standard library
    but most new Python code follows the PEP 8 style.[↩](chap15.xhtml#fnref-unittest-naming-conventions)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 32您可能已经注意到，`setUp()`和`tearDown()`方法的名称与PEP 8规定的不一致。这是因为`unittest`模块早于PEP 8规定的函数名称应为小写并带下划线的部分。Python标准库中有几种这样的情况，但大多数新的Python代码都遵循PEP
    8风格。
- en: 33If we were strictly interpreting TDD here, this amount of implementation would
    have been too much. To make our existing test pass, we didn’t need to actually
    implement line counting; we just needed to return the value 4\. Subsequent tests
    would have then forced us to continually “update” our implementation as they described
    a more complete version of the analysis algorithm. We think you’ll agree that
    such a dogmatic approach would be inappropriate here and, frankly, in real development
    as well.[↩](chap15.xhtml#fnref-bypassing-tdd)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 33如果我们在这里严格解释TDD，这种实现量就太多了。为了使现有的测试通过，我们不需要实际实现行计数；我们只需要返回值4。随后的测试将不断强迫我们“更新”我们的实现，因为它们描述了更完整的分析算法版本。我们认为您会同意，在这里以及实际开发中，这种教条主义的方法都是不合适的。
- en: 34Notice that we can use `print` with or without parentheses. Don’t be alarmsed
    – we haven’t regressed to Python 2\. In this context `print` is a PDB *command*
    rather than a Python 3 *function*.[↩](chap16.xhtml#fnref-pdb_commands)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 34请注意，我们可以使用`print`，无论是否带括号。不要惊慌——我们没有退回到Python 2。在这种情况下，`print`是PDB的*命令*，而不是Python
    3的*函数*。
