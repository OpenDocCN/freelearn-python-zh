- en: Chapter 8. Improving Performance – Part One
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。提高性能 – 第一部分
- en: 'Let''s recap what you learned in the previous chapter. We started with a program
    that appeared harmless until some parameters were tweaked. This change revealed
    performance issues. Hence, we performed a *search operation* (profiling) to catch
    the *culprits* (the bottlenecks). Now, let''s see what we can do to speed up the
    application code. To be specific, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下上一章学到的内容。我们从一个看似无害的程序开始，直到一些参数被调整。这种变化揭示了性能问题。因此，我们执行了*搜索操作*（性能分析）来捕捉*罪魁祸首*（瓶颈）。现在，让我们看看我们可以做些什么来加快应用程序代码。具体来说，我们将涵盖以下主题：
- en: Cutting down the runtime of the *Gold Hunt* application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少黄金狩猎应用程序的运行时间
- en: 'Learning to improve the application performance using the following ways:'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习以下方法来提高应用程序性能：
- en: Making changes to the algorithm
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改算法
- en: Avoiding the function re-evaluation
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免函数重新评估
- en: Using the list and dictionary comprehensions
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列表和字典推导式
- en: Using generator expressions
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成器表达式
- en: Using tricks to improve the performance of code involving loops
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用技巧提高涉及循环的代码的性能
- en: Choosing the right data structures
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的数据结构
- en: Discussing the `collections` and `itertools` modules briefly
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要讨论`collections`和`itertools`模块
- en: In summary, this chapter will cover several (but not all) techniques to speed
    up the application. Some of these can be directly applied to alleviate the performance
    problems of the *Gold Hunt* scenario from the previous chapter. For the rest,
    we will use generic examples to illustrate the efficacy of those techniques.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本章将介绍几种（但不是全部）加快应用程序速度的技术。其中一些可以直接应用于缓解上一章中*黄金狩猎*场景的性能问题。对于其余的，我们将使用通用示例来说明这些技术的有效性。
- en: Prerequisite for the chapter
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章的先决条件
- en: Have you already read [Chapter 7](ch07.html "Chapter 7. Performance – Identifying
    Bottlenecks"), *Performance – Identifying Bottlenecks*? It teaches you how to
    identify the performance bottlenecks. A part of this chapter uses the same problem
    that was discussed in the previous chapter and gradually improves its performance.
    Also, in this chapter, it is assumed that you already know how to profile the
    code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经阅读了[第7章](ch07.html "第7章。性能 – 识别瓶颈")*性能 – 识别瓶颈*了吗？它教您如何识别性能瓶颈。本章的一部分使用了上一章讨论的相同问题，并逐步提高其性能。此外，在本章中，我们假设您已经知道如何对代码进行性能分析。
- en: This is how the chapter is organized
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这是本章的组织方式
- en: We will start with first part of the performance improvements for the *Gold
    Hunt* scenario. The aim is to provide you with a practical example of how to approach
    the problem and gradually cut down the runtime. The following chart shows a preview
    of what will be accomplished by the end of this chapter—this is the same chart
    shown in the previous chapter. The application runtime is about to be cut down
    by more than 50%!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍*黄金狩猎*场景的性能改进的第一部分。目标是提供一个实际示例，说明如何解决问题，并逐步减少运行时间。以下图表显示了本章结束时将要完成的内容的预览——这是与上一章相同的图表。应用程序的运行时间将减少超过50%！
- en: '![This is how the chapter is organized](img/B05034_08_33.png.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![这是本章的组织方式](img/B05034_08_33.png.jpg)'
- en: The second half of this book will show you many ways to improve the application
    speed. For this discussion, we will use generic examples, as not all techniques
    can be applied directly to the *Gold Hunt* scenario. The second half will serve
    as a handy reference for performance improvements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的后半部分将向您展示许多提高应用速度的方法。为了这次讨论，我们将使用通用示例，因为并非所有技术都可以直接应用于*黄金狩猎*场景。后半部分将作为性能改进的便捷参考。
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The Python wiki has documented several performance improvement tips. Some of
    these will be covered here. Refer to [https://wiki.python.org/moin/PythonSpeed/PerformanceTips](https://wiki.python.org/moin/PythonSpeed/PerformanceTips)
    for further details.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Python维基百科记录了几个性能改进技巧。其中一些将在本章中介绍。有关更多详细信息，请参阅[https://wiki.python.org/moin/PythonSpeed/PerformanceTips](https://wiki.python.org/moin/PythonSpeed/PerformanceTips)。
- en: Revisiting the Gold Hunt scenario
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾黄金狩猎场景
- en: At this point, you should go back to [Chapter 7](ch07.html "Chapter 7. Performance
    – Identifying Bottlenecks"), *Performance – Identifying Bottlenecks*, and refresh
    your memory on the *Gold Hunt* scenario. To summarize the problem, a circular
    field has gold coins scattered all over and you need to pick as many coins as
    you can while traveling across the field. However, you can only pick the coins
    lying inside the small search circles. We wrote an application code and discussed
    how tweaking the `search_radius` and `field_coins` (total scattered coins) parameters
    impact the performance. In the upcoming discussion, we will gradually improve
    the performance of this code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你应该回到[第7章](ch07.html "第7章。性能 – 识别瓶颈")，*性能 – 识别瓶颈*，并回顾一下*黄金狩猎*场景。为了总结问题，一个圆形区域散布着金币，你需要穿越整个区域尽可能多地捡起金币。然而，你只能捡起位于小搜索圆圈内的金币。我们编写了一个应用程序代码，并讨论了调整`search_radius`和`field_coins`（总散布金币）参数如何影响性能。在接下来的讨论中，我们将逐步提高这段代码的性能。
- en: Selecting a problem size
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择问题规模
- en: '| *In order to* *see a real difference in the timing after optimizing the code,
    let''s increase the problem size further. In the previous chapter, **The Great
    Dwarf** wanted us to put one million coins on the field. **Let''s double the deal**.
    Now, there are **two million** gold coins up for grabs! In short,* `search_radius`
    *and* `field_coins` *will be set to* `0.1` *and* `2000000`*, respectively.* |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| *为了* *在优化代码后看到时间上的真正差异，让我们进一步增加问题规模。在上一章中，**大矮人**要我们在场地上放置一百万枚金币。**让我们翻倍**。现在，有**两百万**金币可以争夺！简而言之，*`search_radius`*和*`field_coins`*将分别设置为*`0.1`*和*`2000000`*。|'
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Caution! Read this before running any example**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意！在运行任何示例之前阅读此内容**'
- en: Running the examples in this chapter can consume a lot of computational resources
    (the sample output will be shown in this chapter so you don't have to run these).
    The `goldhunt_0.py` file, for instance, takes nearly two minutes to complete on
    a 64 bit Linux machine with an 8 GB RAM and a good processor with only a few running
    tasks. It also consumes quite a bit of memory during the execution. The performance
    is not that bad for this system configuration. In general, it will depend on the
    specifications of your machine. So, be careful! One strategy is to set `field_coins=5000`
    and `search_radius=1` and see how well the application runs. Then, progressively
    tweak these parameters to an acceptable configuration.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例可能会消耗大量计算资源（本章将展示示例输出，因此您不必运行这些示例）。例如，`goldhunt_0.py`文件在一个64位Linux机器上完成需要近两分钟，该机器有8GB
    RAM，处理器性能良好且只有少量运行任务。在执行过程中，它也消耗了相当多的内存。对于这种系统配置，性能并不算太差。一般来说，它将取决于您机器的规格。所以，要小心！一种策略是将`field_coins`设置为`5000`，`search_radius`设置为`1`，看看应用程序运行得如何。然后，逐步调整这些参数到一个可接受的配置。
- en: Profiling the initial code
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析初始代码
- en: 'We will start with the source `goldhunt_0.py` file (see the supporting code
    for the chapter). This is same as `goldhunt_inefficient.py` except for the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从源`goldhunt_0.py`文件开始（参见本章的支持代码）。这与`goldhunt_inefficient.py`相同，除了以下方面：
- en: It profiles the game execution using `cProfile` and prints the statistics. Thus,
    it also includes the functions from the `profiling_goldhunt.py module`. Although
    combining these two modules is not the best practice, it will help simplify the
    upcoming illustrations.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用`cProfile`分析游戏执行并打印统计信息。因此，它还包括`profiling_goldhunt.py模块`中的函数。虽然将这两个模块结合起来不是最佳实践，但它将有助于简化即将到来的说明。
- en: The updated `play_game()` function is shown next. It uses the new parameter
    values, as shown:![Profiling the initial code](img/B05034_08_03.png.jpg)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个展示的是更新后的`play_game()`函数。它使用新的参数值，如下所示：![分析初始代码](img/B05034_08_03.png.jpg)
- en: 'The code can be run as follows—if necessary, tweak the input arguments to `GoldHunt()`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以按以下方式运行——如果需要，调整`GoldHunt()`的输入参数：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following screenshot shows the profiling statistics for this run:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了这次运行的性能分析统计：
- en: '![Profiling the initial code](img/B05034_08_04.png.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![分析初始代码](img/B05034_08_04.png.jpg)'
- en: Notice that `find_coins` eats up a significant amount of time. The next on the
    list is `generate_random_points`. Let's see what we can do to improve the performance.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`find_coins`消耗了相当多的时间。接下来是`generate_random_points`。让我们看看我们能做些什么来提高性能。
- en: Optimizing Gold Hunt – Part one
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化黄金狩猎——第一部分
- en: It is time for some action. This section is organized in the following manner—you
    will learn some techniques to optimize the code and speedup the application. These
    techniques will be directly applied to improve the performance of the *Gold Hunt*
    game.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候采取一些行动了。本节按以下方式组织——你将学习一些优化代码和加速应用程序的技术。这些技术将直接应用于提高 *黄金狩猎* 游戏的性能。
- en: This is the first part of the optimization task. Here, the performance will
    be improved in three steps. We will call these *optimization pass one*, *pass
    two*, and *pass three*. After implementing each of these strategies, the code
    will be re-profiled to get an understanding of the speedup accomplished. Let's
    get started with *optimization pass one*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是优化任务的第一部分。在这里，性能将通过三个步骤得到提升。我们将称之为 *优化第一步*、*第二步* 和 *第三步*。在实施每个策略之后，代码将重新进行性能分析，以了解所实现的加速。让我们从
    *优化第一步* 开始。
- en: Tweaking the algorithm – The square root
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整算法——平方根
- en: 'The profiling output (refer to the *Profiling the initial code* section) shows
    the `find_distance` method as the bottleneck. As a starter, let''s make some changes
    to this algorithm so that it runs faster. Here is the original method that was
    presented in the *Reviewing the initial code* section in [Chapter 7](ch07.html
    "Chapter 7. Performance – Identifying Bottlenecks"), *Performance – Identifying
    Bottlenecks*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析输出（参考 *性能分析初始代码* 部分）显示 `find_distance` 方法是瓶颈。作为一个起点，让我们对这个算法做一些修改，使其运行得更快。以下是
    [第7章](ch07.html "第7章。性能——识别瓶颈") 中 *审查初始代码* 部分提出的原始方法，*性能——识别瓶颈*：
- en: '![Tweaking the algorithm – The square root](img/B05034_08_05.png.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![调整算法——平方根](img/B05034_08_05.png.jpg)'
- en: The method computes the distance to each gold coin from the center of the search
    circle and determines whether or not the given gold coin lies inside the search
    circle. The computed distance, denoted by `dist`, is a square root.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法计算从搜索圆心到每个金币的距离，并确定给定的金币是否位于搜索圆内。计算出的距离，表示为 `dist`，是一个平方根。
- en: 'Do we really need to compute a square root? The square root computation is
    time consuming and in this case unnecessary. All we are doing is just comparing
    two numbers. Can we avoid that by comparing the square of two numbers instead?
    Confused? Have a look at the following comparison:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的需要计算平方根吗？平方根的计算很耗时，在这种情况下是不必要的。我们只是比较两个数。我们能否通过比较两个数的平方来避免这种情况？困惑了吗？看看下面的比较：
- en: '![Tweaking the algorithm – The square root](img/B05034_08_06.png.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![调整算法——平方根](img/B05034_08_06.png.jpg)'
- en: 'We have two positive numbers, *a=4* and *b=9*. Obviously, *a* is smaller than
    *b*. So, the comparison *a < b* will always return `true`. This is applicable
    even for the comparison of their square roots. The same logic can be applied to
    our problem. The `dist` and `self.search_radius` variables can be considered as
    square roots of two numbers. We have got the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个正数，*a=4* 和 *b=9*。显然，*a* 小于 *b*。因此，比较 *a < b* 总是会返回 `true`。即使比较它们的平方根也适用。同样的逻辑可以应用到我们的问题上。`dist`
    和 `self.search_radius` 变量可以被视为两个数的平方根。我们得到了以下代码：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or, we can say `dist` is the square root of some number, `dist_square`, given
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以这样说，`dist` 是某个数，`dist_square` 的平方根，如下所示：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we already know the value of `self.search_radius`. Now, imagine it as
    a square root of another number, `search_radius_square`. This number is not already
    available, and it needs to be computed as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们已经知道了 `self.search_radius` 的值。现在，想象它作为另一个数，`search_radius_square` 的平方根。这个数目前还没有，需要按照以下方式计算：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As the last step, we will need to compare these two numbers instead of their
    square roots:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们需要比较这两个数，而不是它们的平方根：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Tweaking the algorithm – The square root](img/B05034_08_07.png.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![调整算法——平方根](img/B05034_08_07.png.jpg)'
- en: '| *That''s a good observation! It requires us to do an extra computation to
    find out the square of* `self.search_radius`*. But, we do not need to compute
    that for every iteration inside the* `for` *loop. The* `self.search_radius` *does
    not change inside the loop. So, this computation can be done just once before
    the* `for` *loop.* |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| *这是一个很好的观察！它需要我们进行额外的计算来找出* `self.search_radius`* 的平方。但是，我们不需要在 *for* 循环的每次迭代中都进行这个计算。*self.search_radius*
    在循环中不会改变。因此，这个计算可以在 *for* 循环之前只做一次。* |'
- en: Gold Hunt optimization – Pass one
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 黄金狩猎优化——第一步
- en: 'Putting it all together, the updated `find_coins` method is shown next:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，更新的 `find_coins` 方法如下所示：
- en: '![Gold Hunt optimization – Pass one](img/B05034_08_08.png.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![金矿优化 – 第一次通过](img/B05034_08_08.png.jpg)'
- en: 'It is now time to profile this code again and see if we get any improvement
    in the performance. The supporting source file, `goldhunt_pass1.py`, has these
    changes incorporated. It can be run as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候再次配置此代码，看看我们是否能获得性能上的任何改进。支持源文件`goldhunt_pass1.py`已包含这些更改。可以按照以下方式运行：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following screenshot shows the profiling statistics for this run:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了本次运行的配置文件统计信息：
- en: '![Gold Hunt optimization – Pass one](img/B05034_08_09.png.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![金矿优化 – 第一次通过](img/B05034_08_09.png.jpg)'
- en: Compare the timings with that of the original code. There is a significant improvement
    in the application's runtime. Earlier, the total runtime was more than 100 seconds,
    but this optimization has brought it down to less than 60 seconds! You can also
    compare the first row in the output (`find_coins`) against the original timings.
    The timings noted by the profiler will depend on the machine specifications and
    the input values chosen.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将计时与原始代码的计时进行比较。应用程序的运行时间有显著提高。之前，总运行时间超过100秒，但这次优化将其降低到60秒以下！你还可以将输出中的第一行（`find_coins`）与原始计时进行比较。分析器的计时将取决于机器规格和选择的输入值。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The timings will vary slightly even if you run the same program again. There
    are two reasons behind this; first, we are distributing the gold coins randomly
    on the field. As a result, for each run, there will be a variation in the total
    number of coins appended to the list. The second factor that influences this is
    the other running processes on your system. Ideally, you should run it under the
    same environment to reduce these variations (or *noise*). For example, close other
    running applications so that they don't interfere with the timing. During the
    performance benchmarking process, quite often, the same application is run multiple
    times and an average time is noted to reduce the effect of these variations.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 即使再次运行相同的程序，计时也会略有变化。这背后有两个原因；首先，我们在战场上随机分配金币。因此，对于每次运行，列表中附加的总金币数都会有所变化。第二个影响因素是系统上的其他运行进程。理想情况下，你应该在相同的环境中运行它以减少这些变化（或*噪声*）。例如，关闭其他正在运行的应用程序，以免它们干扰计时。在性能基准测试过程中，经常多次运行相同的应用程序，并记录平均时间以减少这些变化的影响。
- en: Skipping the dots
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳过点
- en: 'The **dot** notation in Python enables access to the attributes of the given
    object. Take a look at the following code from the previous example. This is taken
    from the `for` loop of the `find_coins` method:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的**点**表示法允许访问给定对象的属性。看看以下代码，这是从上一个例子中的`find_coins`方法的`for`循环中取出的。这个例子是：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this loop, for every iteration, the `collected_coins.append` function is
    re-evaluated. Recall that in [Chapter 6](ch06.html "Chapter 6. Design Patterns"),
    *Design Patterns*, you learned about the first-class functions. Let's represent
    `collected_coins.append` with a local function. This avoids the function re-evaluation
    (skips the dots) and will help speed up the loop.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个循环中，对于每一次迭代，`collected_coins.append`函数都会被重新评估。回想一下，在[第6章](ch06.html "第6章。设计模式")中，你学习了关于一等函数的内容。让我们用一个局部函数来表示`collected_coins.append`。这样可以避免函数的重新评估（跳过点），并有助于加快循环速度。
- en: Gold Hunt optimization – Pass two
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 金矿优化 – 第二次通过
- en: 'In pass two, we will improve the code from the earlier pass (*optimization
    pass one*). The `goldhunt_pass2.py` file in the supporting code bundle incorporates
    all the changes to be discussed next. Here is the modified `find_coins` method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次通过中，我们将改进之前通过（*优化第一次通过*）的代码。支持代码包中的`goldhunt_pass2.py`文件包含了接下来要讨论的所有更改。以下是修改后的`find_coins`方法：
- en: '![Gold Hunt optimization – Pass two](img/B05034_08_10.png.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![金矿优化 – 第二次通过](img/B05034_08_10.png.jpg)'
- en: 'Here, a local function called `append_coins_function` is assigned to the built-in
    `append` function of a Python `list`. This avoids the re-evaluation of the `append`
    function. Similarly, `self.xref` and `self.yref` are represented with local variables.
    Let''s profile this new code and see if we get any improvements. The command is
    as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个名为`append_coins_function`的局部函数被分配给Python `list`的内置`append`函数。这样可以避免`append`函数的重新评估。同样，`self.xref`和`self.yref`也被表示为局部变量。让我们配置这个新代码，看看我们是否能获得任何改进。命令如下：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Gold Hunt optimization – Pass two](img/B05034_08_11.png.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![金矿优化 – 第二次通过](img/B05034_08_11.png.jpg)'
- en: There is an improvement in the performance, but the results are not as impressive
    as the first pass of the optimization. It is still a reasonable improvement of
    about 10 seconds or more than 15%.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 性能有所提升，但结果并不像优化的第一个步骤那样令人印象深刻。这仍然是一个合理的提升，大约10秒或超过15%。
- en: '| *You can make similar changes elsewhere in the code, but before you jump
    the gun, Sir Foo has an important message for you.* |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| *你可以在代码的其他地方进行类似的更改，但在你急于行动之前，Sir Foo 有一个重要的信息要告诉你。* |'
- en: '![Gold Hunt optimization – Pass two](img/B05034_08_12.png.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![金矿优化 – 第二个步骤](img/B05034_08_12.png.jpg)'
- en: '| *That is an excellent point! Care should be taken while adopting such techniques.
    You should document the code or define a project-specific coding convention so
    that the local functions clearly stand out. This will help other developers understand
    the purpose of such assignments. More generally, do not overdo it and see if there
    is a real benefit.* |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| *这是一个非常好的观点！在采用此类技术时应谨慎行事。你应该记录代码或定义一个项目特定的编码规范，以便局部函数可以清楚地突出。这将帮助其他开发者理解此类赋值的目的。更普遍地说，不要过度使用，看看是否有真正的益处。*
    |'
- en: Using local scope
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用局部作用域
- en: 'While looking for a variable or a function definition, Python first searches
    the following **namespaces** in that order: **local**, **global**, and **built-in**.
    In simpler terms, it first looks for local variables or functions, then performs
    the search at the module level, and if nothing can be found, it looks for a built-in
    function or variable name. So, the look up for local variables or functions is
    the fastest. Using a local function in place of a global or built-in function
    may help improve the performance. The amount of speedup you get will depend on
    the problem.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当寻找变量或函数定义时，Python会按照以下顺序搜索以下**命名空间**：**局部**、**全局**和**内置**。用更简单的话说，它首先寻找局部变量或函数，然后在模块级别进行搜索，如果找不到任何东西，它会寻找内置函数或变量名称。因此，查找局部变量或函数是最快的。用局部函数替换全局或内置函数可能有助于提高性能。你获得的速度提升将取决于问题。
- en: Let's review the `generate_random_points` function. The original code is shown
    next. Refer to the *Reviewing the initial code* section in [Chapter 7](ch07.html
    "Chapter 7. Performance – Identifying Bottlenecks"), *Performance – Identifying
    Bottlenecks*, where it was explained.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 `generate_random_points` 函数。原始代码如下所示。请参阅[第7章](ch07.html "第7章。性能 – 识别瓶颈")中的*回顾初始代码*部分，*性能
    – 识别瓶颈*，其中进行了解释。
- en: '![Using local scope](img/B05034_08_13.png.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![使用局部作用域](img/B05034_08_13.png.jpg)'
- en: In the original function, we are calling various functions of the built-in modules,
    `random` and `math`. Let's update `generate_random_points` in the next optimization
    pass.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始函数中，我们调用内置模块 `random` 和 `math` 的各种函数。让我们在下一个优化步骤中更新 `generate_random_points`。
- en: Gold Hunt optimization – Pass three
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 金矿优化 – 第三个步骤
- en: Let's go further into the optimization process. We will replace the built-in
    function calls in the `generate_random_points` function with local ones. The reworked
    code is shown next. Here, the `l_uniform` variable represents the `random.uniform`
    function. Likewise, you can see the other assignments in this code snippet.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步深入优化过程。我们将用局部函数替换 `generate_random_points` 函数中的内置函数调用。修改后的代码如下所示。在这里，`l_uniform`
    变量代表 `random.uniform` 函数。同样，你可以在这段代码片段中看到其他赋值。
- en: '![Gold Hunt optimization – Pass three](img/B05034_08_14.png.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![金矿优化 – 第三个步骤](img/B05034_08_14.png.jpg)'
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The optimization accomplished after this step is a combination of using local
    scope and skipping the dots. As an exercise, you can try to separate these components.
    For example, to avoid using dots, at the top of the module, import `pi`, `cos`
    and other symbols, and directly use them in the function. Then compare the performance
    with and without the use of local functions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤之后的优化是将使用局部作用域和跳过点结合起来。作为一个练习，你可以尝试将这些组件分开。例如，为了避免使用点，在模块顶部导入`pi`、`cos`和其他符号，并在函数中直接使用它们。然后比较使用和不使用局部函数的性能。
- en: 'Also, before implementing such a code, ask yourself a few questions: By using
    local scope, is the code quality getting compromised (is it harder to read and
    maintain)? Does the final performance improvement outweigh all other factors?'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在实现此类代码之前，问自己几个问题：通过使用局部作用域，代码质量是否受到影响（是否更难阅读和维护）？最终的性能提升是否超过了所有其他因素？
- en: 'You can also find this code in `goldhunt_pass3.py`. The following is the `cProfile`
    output for this file. There is only a minor improvement in the overall timing.
    The real difference will be noticeable if you compare the second row of the list
    (`generate_random_points`) with the corresponding output of *optimization pass
    two*:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在`goldhunt_pass3.py`中找到此代码。以下是该文件的`cProfile`输出。整体时间上只有轻微的改进。如果您将列表的第二行（`generate_random_points`）与*优化通过二*的对应输出进行比较，真正的差异将变得明显：
- en: '![Gold Hunt optimization – Pass three](img/B05034_08_15.png.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![黄金狩猎优化 – 第三个通过](img/B05034_08_15.png.jpg)'
- en: The total runtime has been reduced to ~2.6 seconds from an initial ~ 3.2 seconds.
    Increasing the problem size (number of coins) could make this difference further
    noticeable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 总运行时间已从最初的约3.2秒减少到约2.6秒。增加问题规模（硬币数量）可以使这种差异更加明显。
- en: '| *But it looks like someone is not quite impressed with the speedup...* |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| *但看起来有人对这种加速并不太满意...* |'
- en: '![Gold Hunt optimization – Pass three](img/B05034_08_16.png.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![黄金狩猎优化 – 第三个通过](img/B05034_08_16.png.jpg)'
- en: '| *Absolutely! The task to improve the **Gold Hunt** game performance is far
    from over! Before we do that, let''s discuss some other techniques that help speed
    up the application. We will use generic examples as many of these techniques are
    not relevant in the context of the previously mentioned game scenario.**In the
    next chapter, we will revisit the **Gold Hunt** problem and speed up the application
    further using NumPy and parallelization. It will be a drastic improvement in the
    performance. If you do not want to break the continuity, read the next chapter
    first and then come back here for the rest of the discussion.* |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| *绝对可以！提高**黄金狩猎**游戏性能的任务还远未结束！在我们这么做之前，让我们讨论一些其他有助于加快应用程序速度的技术。我们将使用通用示例，因为许多这些技术在前文提到的游戏场景中并不相关。**在下一章中，我们将重新审视**黄金狩猎**问题，并使用NumPy和并行化进一步加快应用程序的速度。这将带来显著的性能提升。如果您不想打断连贯性，请先阅读下一章，然后再回来继续讨论。*
    |'
- en: Performance improvement goodies
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能提升技巧
- en: Let's spend some time discussing miscellaneous tips and tricks that help improve
    the runtime performance of the code. You can still apply a few of these techniques
    to the *Gold Hunt* problem, but let's just use generic examples to explain these
    concepts.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花些时间讨论一些有助于提高代码运行时性能的杂项技巧和窍门。您仍然可以将其中的一些技术应用到*黄金狩猎*问题上，但让我们只使用通用示例来解释这些概念。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: All the illustrations in this section can be found in the supporting file, `misc_performance.py`.
    To compare the performance, we will use the `timeit` module that was discussed
    in [Chapter 7](ch07.html "Chapter 7. Performance – Identifying Bottlenecks"),
    *Performance – Identifying Bottlenecks* (refer to the *Measuring runtime of small
    code snippets* section). See also the `timeit` documentation, [https://docs.python.org/3/library/timeit.html](https://docs.python.org/3/library/timeit.html).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中所有的插图都可以在辅助文件`misc_performance.py`中找到。为了比较性能，我们将使用在第7章中讨论的`timeit`模块，*性能
    – 识别瓶颈*（请参阅*测量小代码片段的运行时间*部分）。另请参阅`timeit`文档，[https://docs.python.org/3/library/timeit.html](https://docs.python.org/3/library/timeit.html)。
- en: List comprehension
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表推导
- en: '**List comprehension** is a compact way of creating a Python `list`. It is
    often used to replace the nested `for` loops or the `map` and `filter` functionality.
    Besides being compact, it is also efficient compared to, for instance, an equivalent
    `for` loop. The basic syntax is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表推导**是创建Python `列表`的一种紧凑方式。它常被用来替换嵌套的`for`循环或`map`和`filter`功能。除了紧凑之外，与例如等效的`for`循环相比，它也更为高效。其基本语法如下：'
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This creates a list with elements: `[0, 1, 4, 9, 16]`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含以下元素的列表：`[0, 1, 4, 9, 16]`
- en: 'The preceding syntax is equivalent to the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语法等同于以下：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's wrap these code blocks in two functions. We will measure the performance
    of each function using the `timeit` module. The previously mentioned file, `misc_performance.py`,
    also has these functions. To get a better idea of the performance gain, we will
    select a larger problem size. As noted a few times earlier in this book, select
    a problem size depending on what your machine can comfortably handle.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些代码块封装在两个函数中。我们将使用`timeit`模块来衡量每个函数的性能。之前提到的文件`misc_performance.py`也有这些函数。为了更好地了解性能提升，我们将选择更大的问题规模。正如本书中多次提到的，根据您的机器能够舒适处理的问题规模来选择。
- en: 'The following code fragment shows these functions:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了这些函数：
- en: '![List comprehension](img/B05034_08_17.png.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![列表推导式](img/B05034_08_17.png.jpg)'
- en: 'The `sample_size_1` variable is chosen sufficiently large to see a difference.
    The runtime is captured using the `timeit.timeit` method, whose first argument
    is a string representing the function name. The second argument is a `setup` parameter
    that tells us where to look for this function. The runtime performance can be
    compared by executing the script, as:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`sample_size_1`变量被选择得足够大，以便可以看到差异。使用`timeit.timeit`方法捕获运行时间，其第一个参数是一个表示函数名称的字符串。第二个参数是一个`setup`参数，它告诉我们在哪里查找此函数。可以通过执行脚本进行比较运行性能，如下所示：'
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As can be seen from the following output, the list comprehension is faster
    compared to an equivalent `for` loop:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下输出所示，列表推导式与等效的`for`循环相比更快：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As an exercise, try comparing the timings of a nested `for` loop and an equivalent
    list comprehension syntax. Refer to the `list_comprehension_ex2` function in the
    `misc_performance.py` file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个练习，尝试比较嵌套`for`循环与等效列表推导式语法的计时。请参考`misc_performance.py`文件中的`list_comprehension_ex2`函数。
- en: 'In the *Gold Hunt* problem, it is also possible to use list comprehension in
    the `generate_random_points` function. For example, you can optionally write `theta`
    as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在*黄金狩猎*问题中，也可以在`generate_random_points`函数中使用列表推导式。例如，你可以选择性地将`theta`编写如下：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: But before making such changes, read the next chapter, which shows how the NumPy
    package drastically improves the performance of this function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但在做出这样的更改之前，请阅读下一章，其中展示了NumPy包如何极大地提高此函数的性能。
- en: Recording execution time
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录执行时间
- en: 'In the previous section, we used the `timeit.timeit` function to record and
    compare the performance of list comprehension against a classical `for` loop.
    Let''s wrap the `timeit` code into a utility function so that we can reuse it
    for the rest of the discussion. The `run_timeit` function is shown next:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前节中，我们使用`timeit.timeit`函数记录并比较列表推导式与经典`for`循环的性能。让我们将`timeit`代码封装成一个实用函数，以便我们可以将其用于后续的讨论。`run_timeit`函数如下所示：
- en: '![Recording execution time](img/B05034_08_18.png.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![记录执行时间](img/B05034_08_18.png.jpg)'
- en: Here, `func_1` and `func_2` are the function names (strings) whose execution
    time needs to be recorded. The `number` argument in the `timeit.timeit` function
    indicates the number of times the given function is executed. The callers of `run_timeit`
    can tune this number by using the optional `num` argument. See the documentation
    for further details.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`func_1`和`func_2`是需要记录执行时间的函数名称（字符串）。`timeit.timeit`函数中的`number`参数表示给定函数执行的次数。`run_timeit`的调用者可以通过使用可选的`num`参数来调整这个数字。请参阅文档以获取更多详细信息。
- en: Tip
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This function does not do any error checking. As an exercise, you can add that
    capability. For example, add the `try…except` clause to catch errors if the function
    is not found.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数不执行任何错误检查。作为一个练习，你可以添加这个功能。例如，添加`try…except`子句以捕获如果函数未找到的错误。
- en: In the upcoming discussion, we will use `run_timeit` to compare the performance
    of two functionally equivalent code blocks.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的讨论中，我们将使用`run_timeit`来比较两个功能等效的代码块的性能。
- en: Dictionary comprehension
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典推导式
- en: Just like the list comprehension, a **dictionary comprehension** is the syntactic
    construct to create a Python dictionary object. The following functions show two
    ways to create a dictionary. The first one (`no_dict_comprehension`) uses a `for`
    loop to create a dictionary, whereas the second function shows the dictionary
    comprehension syntax.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就像列表推导式一样，**字典推导式**是创建Python字典对象的语法结构。以下函数展示了两种创建字典的方法。第一个（`no_dict_comprehension`）使用`for`循环创建字典，而第二个函数展示了字典推导式语法。
- en: '![Dictionary comprehension](img/B05034_08_19.png.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![字典推导式](img/B05034_08_19.png.jpg)'
- en: 'As noted in the previous section, from now onwards, we will use the `run_timeit`
    utility function to record timings. The `timeit` output after executing this code
    is shown next:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，从现在开始，我们将使用`run_timeit`实用函数来记录时间。执行此代码后的`timeit`输出如下：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Swapping conditional block and for loops
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交换条件块和for循环
- en: 'Consider the following trivial code. There is a top-level `for` loop with an
    `if…else` condition block. Depending on the value of the `num` variable (assume
    it changes), either `if` or `else` condition is executed. As before, an appropriate
    integer for the `sample_size_1` variable should be chosen:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下简单的代码。有一个顶层的`for`循环和一个`if…else`条件块。根据`num`变量的值（假设它发生变化），将执行`if`或`else`条件。和之前一样，应该为`sample_size_1`变量选择一个合适的整数：
- en: '![Swapping conditional block and for loops](img/B05034_08_20.png.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![交换条件块和for循环](img/B05034_08_20.png.jpg)'
- en: 'We can write the same code by swapping the `for` loop and the `if…else` block.
    The new function has a top-level `if…else` block. Inside each condition statement,
    we have the same `for` loop. The following `if_condition_loop_opt` function shows
    this (its output remains the same):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过交换`for`循环和`if…else`块来编写相同的代码。新函数有一个顶层的`if…else`块。在每一个条件语句中，我们都有相同的`for`循环。下面的`if_condition_loop_opt`函数展示了这一点（其输出保持不变）：
- en: '![Swapping conditional block and for loops](img/B05034_08_21.png.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![交换条件块和for循环](img/B05034_08_21.png.jpg)'
- en: 'Let''s find out the winner between these two functions:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来找出这两个函数之间的胜者：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To summarize, the function with a top-level `if…else` block runs faster compared
    to the function with a top-level `for` loop.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，具有顶层`if…else`块的函数比具有顶层`for`循环的函数运行得更快。
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This was a simple example where the swapping of the `for` loop and condition
    blocks was easy. However, in the real world, weigh in the advantages of making
    such modifications over the risk of introducing bugs. Does the profiling really
    show this code block as a major bottleneck? If you finally decide to go ahead
    with it, add enough automated tests to make sure that the function output remains
    the same! See [Chapter 5](ch05.html "Chapter 5. Unit Testing and Refactoring"),
    *Unit Testing and Refactoring*, to learn how to write unit tests.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，其中交换`for`循环和条件块很容易。然而，在现实世界中，权衡进行此类修改的优势与引入错误的风险。性能分析真的显示这个代码块是一个主要的瓶颈吗？如果你最终决定继续进行，请添加足够的自动化测试以确保函数输出保持不变！参见[第5章](ch05.html
    "第5章。单元测试和重构")，*单元测试和重构*，了解如何编写单元测试。
- en: '''try'' it out in a loop'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在循环中尝试
- en: Remember the **Easier to ask for forgiveness than permission** (**EAFP**) principle
    that encourages using the `try…except` clause? It was discussed briefly in [Chapter
    2](ch02.html "Chapter 2. Dealing with Exceptions"), *Dealing with Exceptions*.
    Let's see how a `try…except` clause can save some execution time. Consider the
    following function, which populates a list in a `for` loop based on the value
    of `i`. Only for the first iteration of the `for` loop (`i=0`), the `if` statement
    is executed. For all other values of `i`, it executes the `else` block, `val /=i`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 记住**求饶比求许可更容易**（**EAFP**）原则，它鼓励使用`try…except`子句？这在[第2章](ch02.html "第2章。处理异常")，*处理异常*中简要讨论过。让我们看看`try…except`子句如何节省一些执行时间。考虑以下函数，它根据`i`的值在`for`循环中填充一个列表。只有对于`for`循环的第一个迭代（`i=0`），执行`if`语句。对于所有其他`i`的值，它执行`else`块，`val
    /=i`。
- en: '![''try'' it out in a loop](img/B05034_08_22.png.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![在循环中尝试](img/B05034_08_22.png.jpg)'
- en: Let's replace the `if…else` block with a `try…except` clause. The `try` clause
    will always try to execute the `val /= i` statement. When we have `i=0`, it raises
    the `ZeroDivisionError` exception, which is handled in the `except` clause.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`try…except`子句替换`if…else`块。`try`子句将始终尝试执行`val /= i`语句。当我们有`i=0`时，它引发`ZeroDivisionError`异常，该异常在`except`子句中处理。
- en: '![''try'' it out in a loop](img/B05034_08_23.png.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![在循环中尝试](img/B05034_08_23.png.jpg)'
- en: 'Here, we need to catch the error only for the initial value, `i=0`. For the
    rest of the loop, the code should run smoothly. The `try…except` clause effectively
    gets rid of the extra checks imposed by the `if…else` condition block. In other
    words, we will no longer need to check `if i==0` for each value of `i`. As a result,
    the code runs faster. The execution time for these functions is shown next—clearly,
    the `using_try` function performs better:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需要捕获初始值`i=0`的错误。对于循环的其余部分，代码应该运行顺畅。`try…except`子句有效地消除了`if…else`条件块强加的额外检查。换句话说，我们不再需要为每个`i`的值检查`if
    i==0`。因此，代码运行得更快。下面显示了这些函数的执行时间——显然，`using_try`函数表现更好：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Choosing the right data structures
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择合适的数据结构
- en: This is fairly a broad topic. The choice of data structure largely depends on
    the problem you are trying to solve. In this section, we will limit our discussion
    to just one example that shows how the right choice of data structure improves
    the runtime performance. Observe the `data_struct_choice_list` function; it first
    creates a list object, `mylist`. Next, inside a `for` loop, the code checks if
    `j` is one of the elements of `mylist` and updates the `val` parameter accordingly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当广泛的话题。数据结构的选择很大程度上取决于你试图解决的问题。在本节中，我们将仅讨论一个示例，以展示正确选择数据结构如何提高运行时性能。观察`data_struct_choice_list`函数；它首先创建一个列表对象`mylist`。接下来，在`for`循环内部，代码检查`j`是否是`mylist`的元素之一，并相应地更新`val`参数。
- en: '![Choosing the right data structures](img/B05034_08_24.png.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![选择合适的数据结构](img/B05034_08_24.png.jpg)'
- en: Now look at the following `data_struct_choice_set` function. Instead of a `list`
    object, it creates a `set` object denoted by the `myset` variable. The syntax
    is similar to the `list` or dictionary comprehension syntax we saw earlier (the
    rest of the code remains the same and both the functions return the same value).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看下面的`data_struct_choice_set`函数。它不是创建一个`list`对象，而是创建一个由`myset`变量表示的`set`对象。语法与我们之前看到的`list`或字典推导式语法类似（其余代码保持不变，并且这两个函数返回相同的值）。
- en: '![Choosing the right data structures](img/B05034_08_25.png.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![选择合适的数据结构](img/B05034_08_25.png.jpg)'
- en: When it comes to checking the membership of an element, the Python `set` is
    faster compared to a `list`. In other words, the "`if (j in myset)`" operation
    is faster compared to "`if (j in mylist)`". As summarized in a table in [Chapter
    7](ch07.html "Chapter 7. Performance – Identifying Bottlenecks"), *Performance
    – Identifying Bottlenecks*, the average-case time complexity of this operation
    is *O(1)* for `set` and *O(n)* for `list`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到检查元素是否属于集合时，Python的`set`比`list`更快。换句话说，"`if (j in myset)`"操作比"`if (j in
    mylist)`"操作更快。如[第7章](ch07.html "第7章。性能 – 识别瓶颈")中的表格总结所示，*性能 – 识别瓶颈*，这个操作的平均时间复杂度对于`set`是*O(1)*，对于`list`是*O(n)*。
- en: 'The `timeit` output for these two functions is shown next. Clearly, the function
    that implements `set` is much faster compared to the one that implements `list`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下文展示了这两个函数的`timeit`输出。显然，实现`set`的函数比实现`list`的函数要快得多：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Have you noticed a problem in this example? The runtime reported by `timeit`
    includes the time required to create the `list` and `set` objects. For an accurate
    comparison, you should only compare the `for` loops in these functions. In other
    words, move the `list` and `set` creation part out of the function definition
    and then do the timing comparison.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到这个例子中的问题？`timeit`报告的运行时间包括了创建`list`和`set`对象所需的时间。为了进行准确的比较，你应该只比较这些函数中的`for`循环。换句话说，将`list`和`set`的创建部分移出函数定义，然后进行时间比较。
- en: Let's continue the discussion on the data structures and review Python's `collections`
    module next.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论数据结构，并接下来回顾Python的`collections`模块。
- en: The collections module
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合模块
- en: The `collections` module offers a number of special purpose container data types.
    Let's review a few of the common ones. If you want to know about the other data
    structures in this module, see the Python documentation ([https://docs.python.org/3/library/collections.html](https://docs.python.org/3/library/collections.html)).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections`模块提供了一些特殊用途的容器数据类型。让我们回顾其中的一些常见类型。如果你想知道这个模块中的其他数据结构，请参阅Python文档([https://docs.python.org/3/library/collections.html](https://docs.python.org/3/library/collections.html))。'
- en: The deque class
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`deque`类'
- en: 'The `deque` class enables appending or deleting elements from either side of
    the `deque` data structure. The `append` and `pop` operations in `deque` class
    are memory efficient and thread-safe with a complexity of *O(1)*. The following
    code shows a simple way to create `deque` and then remove the rightmost element:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`deque`类允许从`deque`数据结构的任一侧添加或删除元素。`deque`类中的`append`和`pop`操作内存高效且线程安全，复杂度为*O(1)*。以下代码展示了创建`deque`并移除最右侧元素的一种简单方法：'
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s compare the performance of `deque` with an equivalent `list`. Observe
    the following two functions, where we call the `pop()` method of the `list` and
    `deque` classes—note that we are creating the `list` and `deque` objects outside
    of these functions to make sure that the reported timing is not influenced by
    the object creation:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较 `deque` 与等效 `list` 的性能。观察以下两个函数，其中我们调用 `list` 和 `deque` 类的 `pop()` 方法——请注意，我们在这两个函数外部创建
    `list` 和 `deque` 对象，以确保报告的计时不受对象创建的影响：
- en: '![The deque class](img/B05034_08_26.png.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![deque 类](img/B05034_08_26.png.jpg)'
- en: 'The following `timeit` output shows that the `pop()` operation on `deque` is
    faster compared to that of `list`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `timeit` 输出显示了在 `deque` 上执行 `pop()` 操作比在 `list` 上更快：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So, when should we use `deque`? In general, if your code involves a lot of operations
    where the data needs to be appended or popped from one of the ends, `deque` is
    preferred over a `list`. But, if the code needs fast random access to the elements,
    `list` is a better choice of data structure.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们应该在什么情况下使用 `deque`？一般来说，如果你的代码涉及大量需要在两端进行数据追加或弹出操作的操作，`deque` 比列表更受欢迎。但是，如果代码需要快速随机访问元素，`list`
    是更好的数据结构选择。
- en: The defaultdict class
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: defaultdict 类
- en: 'The `defaultdict` class is derived from the built-in `dict` class. If you try
    to access a key that doesn''t exist, a simple Python dictionary throws a `KeyError`
    exception. But, a `defaultdict` class creates a new key instead. This can be better
    explained with the following example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict` 类是从内置的 `dict` 类派生出来的。如果你尝试访问一个不存在的键，一个简单的 Python 字典会抛出 `KeyError`
    异常。但是，`defaultdict` 类会创建一个新的键。这可以通过以下示例更好地解释：'
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The standard dictionary object, `d1`, doesn''t have an `''a''` key, so it throws
    an error. If you try to access this key with a `defaultdict` class, it simply
    creates it, as shown in the following example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 标准字典对象 `d1` 没有 `'a'` 键，因此会抛出错误。如果你尝试使用 `defaultdict` 类访问这个键，它将简单地创建它，如下例所示：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The built-in `setdefault()` method of the standard dictionary does a similar
    job. If the key you are trying to access does not exist, it inserts a new key
    in the dictionary, assigns a default value to it, and returns this default. However,
    using `defaultdict` is faster compared to the `setdefault` method. Refer to the
    documentation ([https://docs.python.org/3/library/stdtypes.html#dict](https://docs.python.org/3/library/stdtypes.html#dict))
    for more information.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 标准字典的内置 `setdefault()` 方法执行类似的功能。如果你试图访问的键不存在，它会在字典中插入一个新的键，并给它分配一个默认值，然后返回这个默认值。然而，与
    `setdefault` 方法相比，使用 `defaultdict` 更快。有关更多信息，请参阅文档([https://docs.python.org/3/library/stdtypes.html#dict](https://docs.python.org/3/library/stdtypes.html#dict))。
- en: This is just one of the features offered by `defaultdict`. It also provides
    an efficient means to count the number of times an element occurs in a container.
    Let's see this with an example. The following `dict_counter` function defines
    a `list` called `game_characters`. There are many repeating elements in this `list`.
    The function uses a standard dictionary to count how many times each element occurs,
    and then returns this dictionary.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 `defaultdict` 提供的功能之一。它还提供了一种有效的方法来计算容器中元素出现的次数。让我们通过一个例子来看看。以下 `dict_counter`
    函数定义了一个名为 `game_characters` 的列表。这个列表中有许多重复的元素。该函数使用标准字典来计算每个元素出现的次数，然后返回这个字典。
- en: '![The defaultdict class](img/B05034_08_27.png.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![defaultdict 类](img/B05034_08_27.png.jpg)'
- en: 'For example, the output of this function will be a dictionary:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个函数的输出将是一个字典：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `sample_size_1` is just a multiplication factor to make this list big enough
    to see the difference in the execution time. In this example, it is chosen as
    `100000`. Now, let''s write a function that uses a `defaultdict` class to do the
    same job. Take a look at how compact the resulting code is:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`sample_size_1` 只是一个乘数，使得这个列表足够大，以便可以看到执行时间上的差异。在这个例子中，它被选为 `100000`。现在，让我们编写一个使用
    `defaultdict` 类来完成相同工作的函数。看看结果代码是多么紧凑：'
- en: '![The defaultdict class](img/B05034_08_28.png.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![defaultdict 类](img/B05034_08_28.png.jpg)'
- en: 'Let''s compare the performance of these two functions. The following `timeit`
    output confirms that the function implementing `defaultdict` runs faster:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较这两个函数的性能。以下 `timeit` 输出确认实现 `defaultdict` 的函数运行得更快：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The counting operation can also be performed using the `collections.Counter`
    class. The syntax is simple and efficient compared to a `defaultdict` class (we
    will not discuss the `Counter` class in this book). As an exercise, read the documentation
    and write a function that uses the `Counter` class for the earlier example.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 计数操作也可以使用`collections.Counter`类来完成。与`defaultdict`类相比，其语法简单且高效（我们将在本书中不讨论`Counter`类）。作为练习，阅读文档并编写一个使用`Counter`类的函数，用于前面的示例。
- en: Generators and generator expressions
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器和生成器表达式
- en: A **generator** is basically an iterator. It is a powerful tool to handle a
    very large, or an infinite data set. A generator function is written just like
    a regular function, but is characterized by the use of the `yield` statement.
    It is similar to a `return` statement, in the sense that it returns a value. However,
    a generator function "freezes" the current environment after it yields. So, the
    next time you want a value, the generator function continues from where it left
    off and yields the next value.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成器**基本上是一个迭代器。它是一个强大的工具，用于处理非常大的数据集或无限数据集。生成器函数的编写方式与常规函数相同，但其特点是使用`yield`语句。在返回值方面，它与`return`语句类似。然而，生成器函数在`yield`之后“冻结”了当前环境。因此，下次您想要一个值时，生成器函数将从上次离开的地方继续，并返回下一个值。'
- en: 'In other words, a generator returns values (say from a list) one at a time,
    keeps track of the current state of the iteration (remembers all the values it
    has returned in the previous calls), and when called again, it picks up from the
    position where it left off. When you add a `yield` statement to a function, it
    automatically becomes a generator function. Let''s write a trivial example to
    understand this concept better:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，生成器一次返回一个值（例如从列表中），跟踪迭代当前状态（记住它在之前的调用中返回的所有值），并在再次被调用时，从上次离开的位置继续。当您向函数中添加`yield`语句时，它自动成为生成器函数。让我们写一个简单的例子来更好地理解这个概念：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `get_data()` function returns a generator object, `g`. The `next()` function
    is just one way of getting the values from the generator:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_data()`函数返回一个生成器对象`g`。`next()`函数只是从生成器中获取值的一种方法：'
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For the first iteration in the `get_data()` function, we have `i=0` . So, the
    value returned by the generator is `i*i=0`. Now comes the interesting part. Let''s
    call the `next()` function again:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`get_data()`函数的第一个迭代中，我们有`i=0`。因此，生成器返回的值是`i*i=0`。现在到了有趣的部分。让我们再次调用`next()`函数：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It returned the value as `1`. This corresponds to the next value of the iterator
    in the `get_data()` function, `i=1`, which makes `i*i=1`. If we call `next()`
    one more time, it will return the result for `i=2`, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回了`1`这个值。这对应于`get_data()`函数中迭代器的下一个值，即`i=1`，这使得`i*i=1`。如果我们再次调用`next()`，它将返回`i=2`的结果，如下所示：
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will continue until the generator is exhausted with all the values. If
    we call `next()` again, it raises a `StopIteration` exception, as shown next:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将一直持续到生成器耗尽所有值。如果我们再次调用`next()`，它将引发一个`StopIteration`异常，如下所示：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using the `yield` statement is one way of creating a generator function, and
    hence a generator object. Let's learn about the generator expression, which provides
    another way to create a generator object.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`yield`语句是创建生成器函数，从而创建生成器对象的一种方法。让我们来了解生成器表达式，它提供了创建生成器对象的另一种方式。
- en: Generator expressions
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: The generator expression is proposed as *PEP 289* and is summarized as a high
    performance memory efficient generalization of list comprehension and generators.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式被提议为*PEP 289*，并总结为列表推导式和生成器的高性能内存高效泛化。
- en: Tip
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Refer to [https://www.python.org/dev/peps/pep-0289](https://www.python.org/dev/peps/pep-0289)
    for further details on *PEP 289*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有关*PEP 289*的更多详细信息，请参阅[https://www.python.org/dev/peps/pep-0289](https://www.python.org/dev/peps/pep-0289)。
- en: 'The basic syntax for a generator expression is similar to that of a list comprehension.
    Instead of square brackets `[]`, it uses the round brackets `()` to create a generator
    object:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式的语法与列表推导式类似。它使用圆括号`()`而不是方括号`[]`来创建生成器对象：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We already saw how to use the `next()` function to get values out of a generator
    object. You can also get the data from a generator using a `for` loop, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用`next()`函数从生成器对象中获取值。您也可以使用`for`循环从生成器中获取数据，如下所示：
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s see a simple example where a generator expression can be used. The built-in
    `sum` function accepts an iterable as an input. It sums all the elements of that
    iterable and returns the total sum as a single value:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子，其中可以使用生成器表达式。内置的 `sum` 函数接受一个可迭代对象作为输入。它将可迭代对象的所有元素相加，并返回一个单一的总和值：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that you can even pass a `list` to the `sum()` method to get the same result.
    Next, we will compare the memory efficiency of a generator expression with that
    of a list comprehension.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你甚至可以将一个 `list` 传递给 `sum()` 方法以获得相同的结果。接下来，我们将比较生成器表达式与列表推导式的内存效率。
- en: Comparing the memory efficiency
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较内存效率
- en: For a moderately-sized problem, the runtime performance of a list comprehension
    is typically better compared to an equivalent generator expression. We won't make
    that comparison here. Instead, we will see how the generator expression and the
    list comprehension compare when it comes to memory consumption.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于中等规模的问题，列表推导式的运行时性能通常比等效的生成器表达式更好。我们在这里不会进行这种比较。相反，我们将看看生成器表达式和列表推导式在内存消耗方面的比较。
- en: 'In the previous chapter, we saw how to use the `memory_profiler` package. Let''s
    use it here to profile the memory usage. Create a `compare_memory.py` file or
    download it from the supporting code bundle for this chapter. The code is shown
    next:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何使用 `memory_profiler` 包。让我们在这里使用它来分析内存使用情况。创建一个 `compare_memory.py`
    文件或从本章的支持代码包中下载它。代码如下：
- en: '![Comparing the memory efficiency](img/B05034_08_29.png.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![比较内存效率](img/B05034_08_29.png.jpg)'
- en: 'The `list_comp_memory` function creates a `list` using the list comprehension
    syntax. The `generator_expr_memory` function creates a generator object using
    the generator expression syntax. The `@profile` decorator marks the function for
    profiling by the memory profiler. Let''s run the `memory_profiler` function on
    this file:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`list_comp_memory` 函数使用列表推导式语法创建一个 `list`。`generator_expr_memory` 函数使用生成器表达式语法创建一个生成器对象。`@profile`
    装饰器标记该函数以供内存分析器进行性能分析。让我们在这个文件上运行 `memory_profiler` 函数：'
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is the output of this run:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这次运行的输出：
- en: '![Comparing the memory efficiency](img/B05034_08_30.png.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![比较内存效率](img/B05034_08_30.png.jpg)'
- en: 'Let''s review the output achieved from the profiling done on the `compare_memory.py`
    file:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下对 `compare_memory.py` 文件进行的性能分析所得到的输出：
- en: The `Increment` column indicates that the list comprehension creates a `list`
    and puts it in the memory. In the present example, it consumes about 0.37 MiB.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Increment` 列表明列表推导式创建一个 `list` 并将其放入内存中。在本例中，它消耗了大约 0.37 MiB。'
- en: The memory profiler reports the usage in MiB. For the generator expression,
    it reports 0.0 MiB or interprets it as only a few bytes in this example.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存分析器报告的使用量为 MiB。对于生成器表达式，它报告 0.0 MiB 或在本例中将其解释为只有几个字节。
- en: If you increase the `sample_size` variable further, the memory consumed by the
    list comprehension will increase accordingly.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你进一步增加 `sample_size` 变量，列表推导式消耗的内存将相应增加。
- en: For a very large `sample_size`, your computer may even choke while creating
    the `list` with the list comprehension.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于非常大的 `sample_size`，你的计算机在创建列表推导式中的 `list` 时甚至可能会崩溃。
- en: With the generator expression, the memory consumed will remain constant, no
    matter how large the data size gets. This is an extremely useful feature when
    operating on a very large or an infinite data set.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成器表达式时，无论数据大小如何，消耗的内存将保持不变。当操作非常大的或无限的数据集时，这是一个极其有用的特性。
- en: Generator expressions or list comprehensions?
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成器表达式或列表推导式？
- en: '![Generator expressions or list comprehensions?](img/B05034_08_31.png.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![生成器表达式或列表推导式？](img/B05034_08_31.png.jpg)'
- en: '| *Good question. How to decide between generator expressions and list comprehensions?
    The choice depends on the type of problem you are dealing with. The following
    points should help you make that decision:* |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| *好问题。如何在生成器表达式和列表推导式之间做出选择？选择取决于你处理的问题类型。以下要点将帮助你做出决定：* |'
- en: Use generator expressions when you are working with a very large (or infinite)
    data set, iterated over only once. The list comprehension puts the whole list
    in the memory, which works fine on small or mid-sized data sets. However, as the
    data size grows bigger, you will notice problems. The generator expression, on
    the other hand, uses constant memory. It returns data on the fly. Once the data
    is generated, the memory is freed.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您处理一个非常大的（或无限的）数据集，并且只迭代一次时，请使用生成器表达式。列表推导式会将整个列表放入内存中，这对于小型或中型数据集来说工作良好。然而，随着数据集大小的增加，您会发现问题。另一方面，生成器表达式使用的是恒定内存。它即时返回数据。一旦数据生成，内存就会被释放。
- en: This is really another way to put the first point. Do not use generator expressions
    if you want to loop over the whole data set several times. In such cases, use
    the list comprehension.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这实际上是将第一个观点的另一种说法。如果您想多次遍历整个数据集，请不要使用生成器表达式。在这种情况下，请使用列表推导式。
- en: Generator expressions do not support list operations such as **slicing**. So,
    if you want to perform such operations, use the list comprehension.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器表达式不支持列表操作，如**切片**。因此，如果您想执行此类操作，请使用列表推导式。
- en: The itertools module
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: itertools模块
- en: Now that we know how the generator expressions work, let's briefly review `itertools`,
    another important built-in module in Python. It provides functionality to create
    iterators for efficient looping. The `itertools` module offers several building
    blocks for iterators. Some of the frequently used iterators include `count()`,
    `repeat()`, `chain()`, `groupBy()`, `tee()`, `product()`, `permutation()`, `combination()`,
    and so on. This is just a partial list of the supported functionality. In this
    chapter, we will only review the `chain()` iterator.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了生成器表达式的工作原理，让我们简要回顾一下`itertools`，这是Python中另一个重要的内置模块。它提供了创建迭代器的功能，以实现高效的循环。`itertools`模块为迭代器提供了几个构建块。一些常用的迭代器包括`count()`、`repeat()`、`chain()`、`groupBy()`、`tee()`、`product()`、`permutation()`、`combination()`等等。这只是支持的功能的部分列表。在本章中，我们只将回顾`chain()`迭代器。
- en: Note
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Refer to [https://docs.python.org/3/library/itertools.html](https://docs.python.org/3/library/itertools.html)
    for information on other iterators offered by the `itertools` module.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`itertools`模块提供的其他迭代器的信息，请参阅[https://docs.python.org/3/library/itertools.html](https://docs.python.org/3/library/itertools.html)。
- en: The itertools.chain iterator
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: itertools.chain迭代器
- en: 'This iterator is used to chain multiple iterators together. It can take lists,
    tuples, generators, or even a combination of these iterators as an input. Let''s
    review a simple example that shows how to create a `chain` object:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个迭代器用于将多个迭代器连接在一起。它可以接受列表、元组、生成器，甚至这些迭代器的组合作为输入。让我们回顾一个简单的例子，说明如何创建一个`chain`对象：
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The simplest way to view the contents of this `chain` object is to print it
    as a new `list` object:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这个`chain`对象内容的最简单方法是将它打印为一个新的`list`对象：
- en: '[PRE33]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As can be seen, the `chain` iterator combined the two input lists and a tuple
    (or the iterators). Sometimes, you want to perform identical operations on more
    than one list or any other iterable data structures. The `chain` iterator enables
    this by combining or chaining these data structures. More importantly, it does
    not consume any significant amount of memory. Just like a generator, the memory
    consumed by a `chain` object remains constant even when the size of the data grows
    bigger. It is also important to note that, just like a generator, a `chain` object
    can be used to iterate over a given data set only once. This is illustrated by
    the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，`chain`迭代器将两个输入列表和一个元组（或迭代器）组合在一起。有时，您可能想要在多个列表或任何其他可迭代数据结构上执行相同的操作。`chain`迭代器通过组合或连接这些数据结构来实现这一点。更重要的是，它不会消耗任何显著的内存。就像生成器一样，`chain`对象消耗的内存保持恒定，即使数据的大小增加。同样重要的是要注意，就像生成器一样，`chain`对象只能用于迭代给定的数据集一次。以下代码说明了这一点：
- en: '[PRE34]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can compare the memory efficiency of a `chain` object with an equivalent
    code that combines the input lists. The code is shown next. The `for` loop in
    these functions is just to illustrate how the `chain` object can be used in a
    loop.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`chain`对象的内存效率与合并输入列表的等效代码进行比较。代码如下所示。这些函数中的`for`循环只是为了说明`chain`对象如何在循环中使用。
- en: '![The itertools.chain iterator](img/B05034_08_32.png.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![The itertools.chain iterator](img/B05034_08_32.png.jpg)'
- en: 'You can also find this code in `compare_memory.py`. In this file, just add
    the `@profile` decorator. With this change, run the memory profiler as an exercise.
    The following can be observed from the memory profiler output (not shown here):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 `compare_memory.py` 文件中找到这段代码。在这个文件中，只需添加 `@profile` 装饰器。通过这个更改，将内存分析器作为练习运行。以下是从内存分析器输出中可以观察到的（此处未显示）：
- en: The `chain` object consumes about 0.004 MiB memory and the consumption remains
    constant even after you increase the size of the input lists, `data_1`, `data_2`
    and `data_3`.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chain` 对象消耗大约 0.004 MiB 的内存，并且即使你增加输入列表 `data_1`、`data_2` 和 `data_3` 的大小，其消耗也保持不变。'
- en: The `list_memory` function consumes nearly 0.383 MiB of memory to create the
    `mylist` object. The memory consumed by this function increases with the input
    data size.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list_memory` 函数在创建 `mylist` 对象时消耗了近 0.383 MiB 的内存。该函数消耗的内存随着输入数据大小的增加而增加。'
- en: Exercises
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'A few exercises were already suggested. Let''s list a few of these. (Note that
    the solution are not provided for these exercises.):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '已经提出了一些练习。让我们列出其中的一些。（注意，这些练习没有提供解决方案）： '
- en: 'Write a list comprehension syntax for a nested `for` loop. Compare the timings
    of a nested `for` loop and the list comprehension. Here is an example:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为嵌套的 `for` 循环编写一个列表推导式语法。比较嵌套 `for` 循环和列表推导式的执行时间。以下是一个示例：
- en: '[PRE35]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Write a generator expression for the preceding list comprehension. You just
    need to change the outer square brackets `[]` to the round brackets `()`.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为前面的列表推导式编写一个生成器表达式。你只需要将外层的方括号 `[]` 改为圆括号 `()`。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned many techniques that help cut down the application's
    runtime. We started by improving the speed of the *Gold Hunt* application. The
    total time taken to run this application was improved by more than 50%—we accomplished
    this by changing the algorithm so that it does not need to compute the square
    root for distance comparison. Two more changes knocked off a few more seconds
    from the total execution time. We avoided the function re-evaluation (skipped
    the "dots") and preferred local scope for the variables over global scope. This
    was the end of *part one* of the performance improvement for the *Gold Hunt* program.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了多种有助于减少应用程序运行时间的技巧。我们首先通过提高 **《黄金狩猎》** 应用程序的速度开始。运行此应用程序的总时间提高了超过 50%——我们通过更改算法，使其不需要计算距离比较的平方根来实现这一点。另外两个更改又从总执行时间中节省了几秒钟。我们避免了函数重新评估（跳过了“点”）并优先考虑局部作用域的变量而不是全局作用域。这是
    **《黄金狩猎》** 程序性能改进的第一部分的结束。
- en: Moving on, the chapter taught you a number of ways that help speed up the code.
    It illustrated how a list comprehension does a better job compared to an equivalent
    `for` loop. We also saw how the choice of data structure affects the performance.
    The chapter further introduced us to the generator expressions that offer memory
    advantage over the list comprehensions. Additionally, we also briefly reviewed
    the functionality offered by the `itertools` and `collections` modules.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，本章教你多种加快代码速度的方法。它说明了列表推导式与等效的 `for` 循环相比做得更好。我们还看到了数据结构的选择如何影响性能。本章进一步介绍了提供比列表推导式内存优势的生成器表达式。此外，我们还简要回顾了
    `itertools` 和 `collections` 模块提供的功能。
- en: We promised *The Great Dwarf* further improvements to the application. In the
    next chapter, let's learn the things that will help us keep our promise!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们承诺对应用程序进行进一步的改进，**《伟大的矮人》**。在下一章中，让我们学习那些能帮助我们履行承诺的东西！
