- en: Chapter 3. Djagios – a Nagios Clone in Django
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 Djagios - Django中的Nagios克隆
- en: In this chapter, we'll be creating a server status monitoring solution similar
    to **Nagios**. It is understandable if you have never heard of Nagios as it is
    not something that comes up in day-to-day conversations between web developers.
    In a nutshell, Nagios can tell you the status of your servers (which can be in
    the thousands) in one screen. You can configure alerts based on conditions, for
    example, if some critical server becomes unresponsive, so that you can be on top
    of problems before your users start to notice any service degradation. Nagios
    is an amazing piece of software that is used by millions of organizations around
    the world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个类似于**Nagios**的服务器状态监控解决方案。如果您从未听说过Nagios，那是可以理解的，因为它不是在Web开发人员的日常对话中经常出现的东西。简而言之，Nagios可以在一个屏幕上告诉您服务器的状态（可以达到数千台）。您可以根据条件配置警报，例如，如果某个关键服务器变得无响应，这样您就可以在用户开始注意到任何服务降级之前解决问题。Nagios是一个令人惊叹的软件，被全球数百万组织使用。
- en: 'Our goal in this chapter is to create something similar, albeit very simple.
    Our Nagios clone, creatively named **Djagios,** will allow users to set up monitoring
    for simple stats from their servers. We will allow the monitoring of the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是创建一个类似的东西，尽管非常简单。我们的Nagios克隆品，创意地命名为**Djagios**，将允许用户设置监视其服务器的简单统计信息。我们将允许监视以下内容：
- en: System load
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统负载
- en: Disk usage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘使用情况
- en: We will also be developing a web page where this data will be shown to the user
    in a nice tabular format. The user will also see an overview of how their servers
    are doing, and if any alerts are active on those systems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将开发一个网页，用户可以在其中以漂亮的表格格式查看这些数据。用户还将看到他们的服务器的概述，以及这些系统上是否有任何活动警报。
- en: 'Here are some of the things that we will be looking at in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章我们将要研究的一些内容：
- en: What Django management commands are and how to create a custom one
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django管理命令以及如何创建自定义命令
- en: Using the Django shell to test out small pieces of code quickly
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django shell快速测试代码的小片段
- en: Complicated validation of Django Model fields
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django模型字段的复杂验证
- en: Slightly more complicated uses of the built-in generic views
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置通用视图的稍微复杂的用法
- en: Creating an API endpoint to accept data from external sources
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个API端点以接受来自外部来源的数据
- en: Securing these API endpoints with simple shared secret keys
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简单的共享密钥保护这些API端点
- en: Testing API endpoints using simple tools
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简单工具测试API端点
- en: Code pack
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码包
- en: 'This chapter''s code pack has a basic Django application setup with a SQLite
    database already configured. However, there isn''t much code in the code pack
    because this chapter did not require user accounts or any other pre-existing setup.
    You can unzip the code pack, create a new virtual environment, activate it, and
    run the following commands from within the code folder to get up and running:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包已经设置了一个基本的Django应用程序，并配置了一个SQLite数据库。但是，代码包中没有太多代码，因为本章不需要用户帐户或任何其他预先存在的设置。您可以解压缩代码包，创建一个新的虚拟环境，激活它，并从代码文件夹中运行以下命令以启动和运行：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求
- en: Let's talk a bit about what we want from our end product before we start writing
    up some code. As mentioned before, we're looking to create a server monitoring
    solution. What exactly will it do? How can we implement the required functionality?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，让我们谈谈我们对最终产品的期望。如前所述，我们希望创建一个服务器监控解决方案。它将具体做什么？我们如何实现所需的功能？
- en: As our inspiration for Djagios is Nagios, let's look at how Nagios works. While
    Nagios is a huge application with understandably complex programming, it is in
    the end a client-server application. The server, which is just another computer,
    contains the Nagios installation. The clients, which are the systems that you
    want to monitor, run small plugin scripts that gather data and push it to the
    server. The server takes these data points and, based on how it's configured,
    sends out alerts if required. It also stores these data points and can show them
    in a simple tabular layout, giving you an instant overview of all the computer
    systems in your infrastructure.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对Djagios的灵感来自Nagios，让我们看看Nagios是如何工作的。虽然Nagios是一个庞大的应用程序，具有可以理解的复杂编程，但它最终是一个客户端-服务器应用程序。服务器，也就是另一台计算机，包含Nagios安装。客户端，也就是您想要监视的系统，运行小型插件脚本来收集数据并将其推送到服务器。服务器接收这些数据点，并根据其配置情况发送警报（如果需要）。它还存储这些数据点，并可以以简单的表格布局显示它们，让您立即了解基础架构中所有计算机系统的概况。
- en: We'll be creating something similar. Our server will be a Django application
    that will accept data points using an HTTP endpoint. The application will also
    include a web page where all these data points will be shown next to the client
    they came from. Our clients will be simple shell scripts that upload the data
    to our server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建类似的东西。我们的服务器将是一个Django应用程序，将使用HTTP端点接受数据点。该应用程序还将包括一个网页，其中所有这些数据点将显示在客户端旁边。我们的客户端将是简单的shell脚本，用于将数据上传到我们的服务器。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the rest of the chapter, I will call the Django application, the **server**,
    and the systems that you want to monitor, the **node**. These are common terms
    used in many other projects that you will encounter in your programming career
    and they often mean similar things in those other projects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我将把Django应用程序称为**服务器**，将您想要监视的系统称为**节点**。这些是您在编程生涯中会遇到的许多其他项目中常用的术语，它们在这些其他项目中通常意味着类似的东西。
- en: Instead of developing all of these things at once, we'll take an incremental
    approach. We'll first create the models to store our data points. Next, instead
    of moving directly to creating the HTTP endpoint to accept the data points and
    client-side plugin scripts, we'll take a simpler approach and come up with a way
    to generate some fake data to test. An finally, we will create the web page to
    show our users the latest status of the client nodes and the triggered alerts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与其一次性开发所有这些东西，我们将采取渐进式的方法。我们首先创建模型来存储我们的数据点。接下来，我们不会直接转向创建HTTP端点来接受数据点和客户端插件脚本，而是采取更简单的方法，想出一种方法来生成一些虚假数据进行测试。最后，我们将创建网页来向用户显示客户端节点的最新状态和触发的警报。
- en: With fake data to test, we can be confident that our status page and alerting
    system are working correctly. We can then move forward to the next step, which
    will be creating the HTTP endpoint to gather data points from clients and client-side
    plugin scripts.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用虚假数据进行测试，我们可以确信我们的状态页面和警报系统正常工作。然后我们可以继续下一步，即创建HTTP端点以从客户端和客户端插件脚本收集数据点。
- en: In real-world projects, this incremental approach to building software systems
    is often the best way to complete projects. Create simple features and test them
    extensively to make sure that they work. Once you are confident of their correctness,
    add more functionality and repeat the testing phase. This way is analogous to
    how a tall building is constructed. If you are confident that the foundation is
    strong, you can build one floor at a time without worrying if the whole thing
    will fall down on your head.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的项目中，逐步构建软件系统通常是完成项目的最佳方式。创建简单的功能并对其进行广泛测试，以确保其正常工作。一旦您对其正确性有信心，就添加更多功能并重复测试阶段。这种方式类似于建造高楼。如果您确信基础牢固，您可以一次建造一层，而不必担心整个建筑会倒在您头上。
- en: The model
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: What information should we record for the data points? We definitely need the
    name of the node that is sending the data. We also need to record the time at
    which we got the data point so that we can figure out the latest status of the
    node. Of course, we need to know the type and value of the data point. The type
    of the data point is simply the name of the quantity that we are measuring, such
    as CPU usage, memory usage, uptime, and so on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们记录数据点需要记录什么信息？我们肯定需要记录发送数据的节点的名称。我们还需要记录获取数据点的时间，以便我们可以找出节点的最新状态。当然，我们需要知道数据点的类型和值。数据点的类型只是我们正在测量的数量的名称，例如CPU使用率，内存使用率，正常运行时间等。
- en: 'For now, I think these are all the things that we need to measure:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我认为这些是我们需要测量的所有东西：
- en: Node name
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点名称
- en: Date and time
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期和时间
- en: Type
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型
- en: Value
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价值
- en: While thinking about which fields we needed in our model, I thought of another
    approach. It involved having a different model for each data point type, so we
    could have Django models named `SystemLoad`, `MemoryUsage`, `DiskUsage`, `Uptime`,
    and so on. However, once I thought about it further, I figured out that doing
    so would be very restrictive as now we'd need to define a new model every time
    we wanted to measure something new. Having the type of the data point as another
    field in our model gives us a lot of flexibility in terms of recording new types
    of information.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑我们模型中需要哪些字段时，我想到了另一种方法。它涉及为每种数据点类型创建不同的模型，因此我们可以有名为`SystemLoad`，`MemoryUsage`，`DiskUsage`，`Uptime`等的Django模型。然而，一旦我进一步考虑了一下，我发现这样做将非常限制，因为现在每当我们想要测量新的东西时，我们都需要定义一个新的模型。在我们的模型中添加数据点的类型作为另一个字段，可以在记录新类型的信息方面给我们很大的灵活性。
- en: As you'll see later on, there are pros and cons to both approaches.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 后面您将看到这两种方法的利弊。
- en: 'Let''s start a new Django application in our project. In your command line,
    type the following, making sure that your virtual environment is activated and
    that you are in the project folder:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目中开始一个新的Django应用程序。在命令行中，输入以下内容，确保您的虚拟环境已激活，并且您在项目文件夹中：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add this new app to the list of `INSTALLED_APPS` in `djagios/settings.py`,
    and then add our data point model to `data_collector/models.py`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个新应用程序添加到`djagios/settings.py`中的`INSTALLED_APPS`列表中，然后将我们的数据点模型添加到`data_collector/models.py`中：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Save the file and then run migrations to add it to our database:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，然后运行迁移以将其添加到我们的数据库中：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While the model is pretty simple, there is one thing you should be aware of.
    To keep things simple, I made the decision to store only numeric values; hence,
    the `data_value` field is of the `FloatField` type. If this were a real-world
    project, you would have a set of requirements that would dictate if you could
    make the same compromise. You might have to record text values as well, for instance,
    the status of some service you might be running. For Djagios, we are OK with numeric
    values only as all the stats that we want to measure are just numbers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然模型非常简单，但有一件事情你应该知道。为了保持简单，我决定仅存储数字值；因此，`data_value`字段是`FloatField`类型。如果这是一个现实世界的项目，您可能会有一系列要求，这些要求将决定您是否可以做出相同的妥协。例如，您可能还必须记录文本值，例如，您可能正在运行的某些服务的状态。对于Djagios，我们只接受数字值，因为我们想要测量的所有统计数据都只是数字。
- en: Fake data generation
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚假数据生成
- en: Before moving on to the next step, which is creating the status page, we should
    come up with a way to generate some fake data. This will help us while creating
    the status page and debug any issues that we encounter along the way. Without
    any data, we could spend time creating the perfect status page, only to find out
    later when we add data that some aspect of it, such as the design or data layout
    scheme, won't work.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一步，即创建状态页面之前，我们应该想出一种方法来生成一些虚假数据。这将在创建状态页面并在途中调试任何问题时帮助我们。没有任何数据，我们可能会花时间创建完美的状态页面，只是后来发现当我们添加数据时，其中的某些方面，如设计或数据布局方案，不起作用。
- en: Django management commands
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django管理命令
- en: Django has a very useful feature called management commands. It allows us to
    create Python scripts that can interact with the rest of the Django app code we
    write, including our models.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Django有一个非常有用的功能，叫做管理命令。它允许我们创建可以与我们编写的Django应用程序代码以及我们的模型进行交互的Python脚本。
- en: The reason we can't just write a simple Python script that imports our models
    is that Django, like all web frameworks, has many dependencies and requires a
    complex setup to make sure that every thing is configured properly before we can
    use its features. For example, accessing the database depends on Django knowing
    where the settings file is because it contains the configuration for the database.
    Without knowing how to read the database, you can't query the models.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能只编写一个简单的Python脚本来导入我们的模型，原因是Django，像所有的Web框架一样，有许多依赖项，并且需要进行复杂的设置，以确保在使用其功能之前一切都配置正确。例如，访问数据库取决于Django知道设置文件在哪里，因为它包含数据库的配置。不知道如何读取数据库，就无法查询模型。
- en: 'Let''s conduct a little test. Make sure that your virtual environment is activated
    and that you are in the project directory. Next, start up the Python shell by
    typing the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一个小测试。确保您的虚拟环境已激活，并且您在项目目录中。接下来，通过输入以下内容启动Python shell：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will start a new Python interactive shell where you can type Python statements
    and have them executed immediately. You''ll know that you are in a Python shell
    because your prompt will change to `>>>`. Now, let''s try importing our `DataPoint`
    model in this shell:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个新的Python交互式shell，在这里您可以输入Python语句并立即执行它们。您会知道您在Python shell中，因为您的提示符将更改为`>>>`。现在，让我们尝试在这个shell中导入我们的`DataPoint`模型：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Press *Enter* and you might be surprised by the huge error message that is
    printed. Don''t worry, you don''t need to read all of it. The most important part
    is the last line. It will be similar to this (though not exactly as it might change
    slightly between different Django versions):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Enter*，您可能会对打印的巨大错误消息感到惊讶。不用担心，您不需要阅读所有内容。最重要的部分是最后一行。它将类似于这样（尽管可能会在不同的Django版本之间略有变化）：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It looks intimidating, but let's look at it in parts. The first part before
    the colon `:` is the exception name. Here, Django raised the `ImproperlyConfigured`
    exception. Then there is a sentence telling you that some setting was requested,
    but settings are not yet configured. The last sentence is a helpful message about
    how to fix this.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来令人生畏，但让我们分部分来看。冒号`:`之前的第一部分是异常名称。在这里，Django引发了`ImproperlyConfigured`异常。然后有一句话告诉您请求了某个设置，但设置尚未配置。最后一句是关于如何解决此问题的有用消息。
- en: While you can take the steps that are listed in the error message and get your
    scripts to run outside of Django, using a management command is almost always
    the best option. With a management command, you don't need to set up Django manually.
    It's done for you automatically before your script is run and you can avoid having
    to worry about setting environment variables such as `DJANGO_SETTINGS_MODULE`
    or calling `settings.configure()`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以按照错误消息中列出的步骤并使您的脚本在Django之外运行，但使用管理命令几乎总是最佳选择。使用管理命令，您无需手动设置Django。在运行脚本之前，它会自动为您完成，并且您可以避免担心设置环境变量，如`DJANGO_SETTINGS_MODULE`或调用`settings.configure()`。
- en: 'To create a new management command, we first have to create two new Python
    modules to hold our command script. Type the following in your command line from
    the project root directory:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的管理命令，我们首先必须创建两个新的Python模块来保存我们的命令脚本。从项目根目录的命令行中输入以下内容：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What these commands do is create a module called `management` under the `data_collector`
    module folder, and then create another module called `commands` in the `management`
    module. We do this by first creating the folders for the modules and then creating
    empty `__init__.py` files so that Python recognizes these folders as modules.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令的作用是在`data_collector`模块文件夹下创建一个名为`management`的模块，然后在`management`模块中创建另一个名为`commands`的模块。我们首先创建模块的文件夹，然后创建空的`__init__.py`文件，以便Python将这些文件夹识别为模块。
- en: 'Next, let''s try creating a simple management command that just prints out
    a list of the data points that we have in our database so far. Create a new `data_collector/management/commands/sample_data.py`
    file and give it the following content:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试创建一个简单的管理命令，只需打印出我们数据库中目前为止的数据点列表。创建一个新的`data_collector/management/commands/sample_data.py`文件，并给它以下内容：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Save this file and go back to your command prompt. Then run the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此文件，然后返回到命令提示符。然后运行以下命令：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see the following output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'That''s it. That''s all there is to creating Django management commands. As
    you can see, we were able to use methods on our `DataPoint` model in a script
    that was run on the command line, as opposed to being run as part of an HTTP response
    view. A few things to note about Django management commands are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。这就是创建Django管理命令的全部内容。正如您所看到的，我们能够在命令行上运行脚本时使用我们的`DataPoint`模型的方法，而不是作为HTTP响应视图的一部分运行。关于Django管理命令的一些注意事项如下：
- en: Your command has the same name as the name of the file that contains the command.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的命令与包含命令的文件的名称相同。
- en: In order to be a valid management command, the source file should always define
    a `Command` class, which will be a base class of `BaseCommand`.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了成为有效的管理命令，源文件应始终定义一个`Command`类，它将是`BaseCommand`的基类。
- en: Django will call the `handle` method of your `Command` class. This method is
    the starting point of whatever functionality you want to provide from your script.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django将调用您的`Command`类的`handle`方法。这个方法是您想要从脚本提供的任何功能的起点。
- en: We'll take a look at the `*args` and `**options` parameters next when we modify
    the `sample_data.py` command to actually add sample data. If you want further
    information about Django management commands, you should look at the documentation
    at [https://docs.djangoproject.com/en/stable/howto/custom-management-commands/](https://docs.djangoproject.com/en/stable/howto/custom-management-commands/).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当我们修改`sample_data.py`命令以实际添加示例数据时，我们将看一下`*args`和`**options`参数。如果您想进一步了解Django管理命令的信息，您应该查看[https://docs.djangoproject.com/en/stable/howto/custom-management-commands/](https://docs.djangoproject.com/en/stable/howto/custom-management-commands/)上的文档。
- en: 'Let''s modify our command class to add fake data. Here''s the modified `Command`
    class code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的命令类来添加虚假数据。这是修改后的`Command`类代码：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are a couple of new things here. Let''s look at the `add_arguments` method
    first. Most management commands need arguments to do something useful. As we''re
    adding sample data to the database, our command will need the values to add. These
    are provided to the command in the form of arguments on the command line. If you
    don''t have much experience with working with command lines, arguments are all
    the things that you type after the command name. For example, let''s take a look
    at the command we use to create new Django applications in a project:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新东西。让我们首先看一下`add_arguments`方法。大多数管理命令需要参数才能做一些有用的事情。由于我们正在向数据库添加示例数据，我们的命令将需要添加的值。这些值以参数的形式提供给命令行。如果你没有太多使用命令行的经验，参数就是在命令名称后面输入的所有东西。例如，让我们看一下我们用来在项目中创建新的Django应用程序的命令：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we use the `startapp` Django management command, which is a built-in command,
    and the app name is an argument to the app.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`startapp` Django管理命令，这是一个内置命令，而应用程序名称是应用程序的参数。
- en: 'We want our custom command to accept three arguments: the node name, data type,
    and value of the data point. In the `add_arguments` method, we tell Django to
    require and parse three arguments for this command.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的自定义命令接受三个参数：节点名称、数据类型和数据点的值。在`add_arguments`方法中，我们告诉Django为这个命令需要和解析三个参数。
- en: 'The `options` parameter to the `handle` method is a dictionary that holds all
    the arguments that were defined and passed to the command by the user. In the
    `handle` method, we simply assign the values for each option to a variable. In
    case the user misses or adds extra arguments while calling the command, Django
    will print an error message as well as inform them of what the required parameters
    are. For example, if I call the command now without any parameter, here''s what
    happens:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle`方法的`options`参数是一个字典，保存了用户定义并传递给命令的所有参数。在`handle`方法中，我们只是将每个选项的值分配给一个变量。如果用户在调用命令时漏掉或添加了额外的参数，Django将打印出一个错误消息，并告诉他们需要的参数是什么。例如，如果我现在调用命令而没有任何参数，会发生什么：'
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is useful information if the user forgets how to use a management command.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户忘记了如何使用管理命令，这是有用的信息。
- en: 'Now that we have the argument values in variables, we create a new data point
    and save it. Finally, we print out all the data points that we have in the database.
    Let''s try running our command now and see what output we get:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了变量中的参数值，我们创建一个新的数据点并保存它。最后，我们打印出数据库中所有的数据点。让我们现在尝试运行我们的命令，看看我们得到什么输出：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: While the command successfully created a new data point, the output isn't very
    helpful. We have no idea what information this data point holds. Let's fix this.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然命令成功创建了一个新的数据点，但输出并不是很有用。我们不知道这个数据点包含什么信息。让我们来修复这个问题。
- en: A better model representation
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的模型表示
- en: 'Whenever Django prints out a model instance, it first tries to see if there
    is a `__str__` method defined for the model class. If it finds this method, it
    uses the output from it; otherwise, it falls back to a default implementation
    that just prints the class name, as we can see here. To make Django print out
    a more useful representation for our data point model, add this `__str__` method
    to our `DataPoint` model class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每当Django打印出一个模型实例时，它首先尝试查看模型类是否定义了`__str__`方法。如果找到这个方法，它就使用它的输出；否则，它会退回到一个默认实现，只打印类名，就像我们在这里看到的那样。为了让Django打印出一个更有用的数据点模型表示，将这个`__str__`方法添加到我们的`DataPoint`模型类中：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s run our `sample_data` command again now and see how its output has changed:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在再次运行我们的`sample_data`命令，看看它的输出如何改变了：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That''s better. Now we see that the data point we added has been saved to the
    database correctly. Go ahead and create a couple of more data points. Use as many
    different node names as you want, but try to keep the data type limited to one
    of **load** or **disk_usage** as we''ll be creating code specific to these data
    types later. Here''s the sample data that I added to my database for reference:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 好了。现在我们看到我们添加的数据点已经正确保存到数据库中。继续创建更多的数据点。使用尽可能多的不同节点名称，但尝试将数据类型限制为**load**或**disk_usage**中的一个，因为我们稍后将创建特定于这些数据类型的代码。这是我为参考添加到数据库的示例数据：
- en: '| Node name | Data type | Data value |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 节点名称 | 数据类型 | 数据值 |'
- en: '| --- | --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `web01` | `load` | `5.0` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `web01` | `load` | `5.0` |'
- en: '| `web01` | `load` | `1.0` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `web01` | `load` | `1.0` |'
- en: '| `web01` | `load` | `1.5` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `web01` | `load` | `1.5` |'
- en: '| `web01` | `disk_usage` | `0.5` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `web01` | `disk_usage` | `0.5` |'
- en: '| `web02` | `load` | `7.0` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `web02` | `load` | `7.0` |'
- en: '| `web02` | `load` | `9.0` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `web02` | `load` | `9.0` |'
- en: '| `web02` | `disk_usage` | `0.85` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `web02` | `disk_usage` | `0.85` |'
- en: '| `dbmaster` | `disk_usage` | `0.8` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `dbmaster` | `disk_usage` | `0.8` |'
- en: '| `dbmaster` | `disk_usage` | `0.95` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `dbmaster` | `disk_usage` | `0.95` |'
- en: Now that we have a way to add sample data and added some to our database, let's
    create the status page that will show all this data to our users.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种添加示例数据并将其添加到数据库中的方法，让我们创建一个状态页面，向用户展示所有这些数据。
- en: Status page
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态页面
- en: Our status page needs to show the user the status of their complete infrastructure
    in one view. To do so, a table feels like the appropriate design component. As
    the most important information to the user is going to be the latest status of
    their servers, our status page will need to show only one table row per node and
    list only the latest values for each different data type that we have in the database
    for that node.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的状态页面需要以一种视图显示用户完整基础设施的状态。为此，表感觉像是一个合适的设计组件。由于对用户最重要的信息将是他们服务器的最新状态，我们的状态页面将需要仅显示每个节点的一行表，并且仅列出我们在数据库中为该节点拥有的每种不同数据类型的最新值。
- en: 'For the sample data that I added to my database, we would ideally want a table
    similar to this on the status page:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我添加到数据库中的示例数据，我们理想情况下希望状态页面上有一个类似这样的表：
- en: '![Status page](img/00698_03_01.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![状态页面](img/00698_03_01.jpg)'
- en: As you can see, we only mention each node once, and group the different data
    types so that all information about a node is shown in one place and the user
    doesn't have to search through the table to find what they are looking for. As
    a bonus, we also show the last updated time in a nice way instead of just showing
    the time of the latest data point.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们只提到每个节点一次，并且将不同的数据类型分组，这样所有关于节点的信息都显示在一个地方，用户不必在表中搜索他们要找的内容。作为一个奖励，我们还以一种好看的方式显示最后更新的时间，而不仅仅是显示最新数据点的时间。
- en: If you are thinking that showing our data points in a nice and consolidated
    manner like this will not be simple, I'm afraid you are right. We could get all
    the data points from the database in one query using `DataPoint.objects.all()`
    and then group them in our Python code, but that would be inefficient once the
    number of data points in our database grows. For server monitoring solutions,
    it isn't uncommon to have a couple of million data points. We can't go about getting
    and grouping all the million data points every time the user wants to see the
    status page. That would make loading the page unbearably slow.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为像这样以一种好看和整合的方式显示我们的数据点不会简单，恐怕你是对的。我们可以使用`DataPoint.objects.all()`从数据库中获取所有数据点，然后在我们的Python代码中对它们进行分组，但一旦我们数据库中的数据点数量增加，这种方法就会变得低效。对于服务器监控解决方案，拥有几百万数据点并不罕见。我们不能每次用户想要查看状态页面时都去获取和分组所有百万数据点。这将使加载页面变得难以忍受缓慢。
- en: Luckily for us, SQL—the language used to query data from databases—provides
    us with some very powerful constructs that we can use to get just the information
    we want, without having to go through all the rows of data that we could have
    in our data points table. Let's think about what we need.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，SQL——用于从数据库查询数据的语言——为我们提供了一些非常强大的结构，我们可以使用它们来获取我们想要的信息，而不必遍历我们数据点表中可能有的所有数据行。让我们想想我们需要什么。
- en: For starters, we'd like to know the different node names in our database. For
    each node name, we also need to know the types of data that are available for
    it. In our example, while both **web01** and **web02** have the **load** and **disk_usage**
    data type available, the **dbmaster** node only has data for the **disk_usage**
    data type (or metric). For cases like this, the SQL language provides us with
    a `DISTINCT` query clause. Adding `DISTINCT` to our query instructs the database
    to return unique rows only. That is, all duplicate rows are only returned once.
    This way, we can get a list of all the different nodes and data types in our database
    without having to go over each record.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想知道我们数据库中的不同节点名称。对于每个节点名称，我们还需要知道可用的数据类型。在我们的示例中，虽然**web01**和**web02**都有**load**和**disk_usage**数据类型可用，但**dbmaster**节点只有**disk_usage**数据类型（或指标）的数据。对于这样的情况，SQL语言为我们提供了一个`DISTINCT`查询子句。在我们的查询中添加`DISTINCT`指示数据库仅返回唯一行。也就是说，所有重复行只返回一次。这样，我们就可以获取我们数据库中所有不同节点和数据类型的列表，而无需遍历每条记录。
- en: We need to experiment a bit to figure out how to translate the SQL query into
    something we can use with the Django ORM. We could write our view code and then
    keep changing it to figure out the right way to get the data we want, but that
    is very cumbersome. Instead, Django provides us with a very convenient shell to
    do these kinds of experimentations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要进行一些实验，以找出如何将SQL查询转换为我们可以在Django ORM中使用的内容。我们可以编写我们的视图代码，然后不断更改它以找出获取我们想要的数据的正确方法，但这非常麻烦。相反，Django为我们提供了一个非常方便的shell来进行这些实验。
- en: 'If you remember, at the start of this chapter, I showed you why you couldn''t
    just start a Python shell and import the model. Django complained about not having
    been set up properly before being used. Instead, Django has its own way of launching
    a Python shell, one that makes sure that all the dependencies of setting up Django
    are met before you start using the shell. To start this shell, type the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，本章的开头，我向你展示了为什么你不能只启动一个Python shell并导入模型。Django抱怨在使用之前没有被正确设置。相反，Django有自己的启动Python
    shell的方式，确保在开始使用shell之前满足了设置Django的所有依赖关系。要启动这个shell，输入以下内容：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Like before, this will put you in a Python shell, which you can tell by the
    changed prompt. Now, let''s try importing our `DataPoint` model:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 像之前一样，这会让你进入一个Python shell，你可以通过改变的提示来告诉。现在，让我们尝试导入我们的`DataPoint`模型：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This time you shouldn''t get any errors. Now type the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这次你不应该会得到任何错误。现在输入以下内容：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, you can query the model and see the output of the query immediately.
    The Django shell is one of the most useful components in Django, and you will
    often find yourself experimenting in the shell to figure out the correct way to
    do something before you write the final code in your views.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你可以查询模型并立即看到查询的输出。Django shell是Django中最有用的组件之一，你经常会发现自己在shell中进行实验，以找出在编写最终代码之前正确的做法。
- en: 'So, back to our problem of getting distinct node names and data types from
    our database. If you search the Django documentation for the **distinct** keyword,
    you should see this link in the results:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，回到我们从数据库中获取不同节点名称和数据类型的问题。如果你在Django文档中搜索**distinct**关键字，你应该会在结果中看到这个链接：
- en: '[https://docs.djangoproject.com/en/stable/ref/models/querysets/#distinct](https://docs.djangoproject.com/en/stable/ref/models/querysets/#distinct).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.djangoproject.com/en/stable/ref/models/querysets/#distinct](https://docs.djangoproject.com/en/stable/ref/models/querysets/#distinct)。'
- en: 'If you read what the documentation says, you should figure out that this is
    exactly what we need in order to use the `DISTINCT` clause. But how do we use
    it? Let''s try it out in the shell:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您阅读文档中的内容，您应该会发现这正是我们需要使用`DISTINCT`子句的原因。但是我们如何使用它呢？让我们在shell中尝试一下：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Hmm? That didn't change anything. Why not? Let's think about what is happening
    here. We asked Django to query the database for all the data points and then return
    only one row for each duplicated data. If you are familiar with SQL, the distinct
    clause works by comparing each field in the rows of data you selected. However,
    as by default Django selects all the rows from a database table when querying
    a model, the data that the SQL query sees also includes the primary key, which
    is by definition unique for each row. This is why we see all of our data, even
    though we have used the distinct clause.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯？这没有改变任何东西。为什么？让我们想想这里发生了什么。我们要求Django查询数据库中的所有数据点，然后仅返回每个重复数据的一行。如果您熟悉SQL，不同的子句通过比较您选择的数据行中的每个字段来工作。但是，由于默认情况下，Django在查询模型时会选择数据库表中的所有行，因此SQL查询看到的数据也包括主键，这根据定义对于每一行都是唯一的。这就是为什么我们看到所有数据，即使我们使用了不同的子句。
- en: 'In order to make use of the distinct clause, we need to limit the fields in
    the data that we are asking the database to return to us. For our particular use
    case, we only need to know the unique pairs of node name and data type. The Django
    ORM provides another method, `values`, that we can use to limit the fields that
    Django selects. Let''s try it out first without the distinct clause to see what
    data it returns:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用不同的子句，我们需要限制我们要求数据库返回给我们的数据中的字段。对于我们特定的用例，我们只需要知道节点名称和数据类型的唯一对。Django ORM提供了另一个方法`values`，我们可以使用它来限制Django选择的字段。让我们首先尝试一下没有不同子句，看看返回什么数据：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That seems to do the trick. Now our data only includes the two fields that
    we wanted to run the distinct query on. Let''s add the distinct clause as well
    and see what we get:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎起了作用。现在我们的数据只包括我们想要运行不同查询的两个字段。让我们也添加不同的子句，看看我们得到了什么：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Voila! That seems to have done the trick. Now our Django ORM query only returns
    unique pairs of node names and data types, which is exactly what we needed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这似乎起了作用。现在我们的Django ORM查询只返回唯一的节点名称和数据类型对，这正是我们需要的。
- en: One important thing to note is that after we added the `values` method to the
    ORM query, the returned data was no longer our `DataPoint` model class. Instead,
    it was dictionaries with just the field values that we asked for. Thus, any functions
    that you have defined on the model are not accessible on these dictionaries. If
    you think about it, this is obvious because without the complete fields, Django
    has no way to populate the model objects. It also won't matter if you listed all
    of your model fields in the `values` method arguments. It will still only return
    dictionaries, not the model objects.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点要注意的是，当我们在ORM查询中添加了`values`方法后，返回的数据不再是我们的`DataPoint`模型类。相反，它是只包含我们要求的字段值的字典。因此，您在模型上定义的任何函数都无法在这些字典上访问。如果您仔细想想，这是显而易见的，因为没有完整的字段，Django无法填充模型对象。即使您在`values`方法参数中列出了所有模型字段，它仍然只会返回字典，而不是模型对象。
- en: 'Now that we have figured out how to get the data in the format we want, without
    having to loop over each row of data in our database, let''s create the template,
    view, and URL configuration for our status page. Starting with the view code,
    change `data_collector/views.py` to have these contents:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经弄清楚了如何以我们想要的格式获取数据，而无需循环遍历我们数据库中的每一行数据，让我们为我们的状态页面创建模板、视图和URL配置。从视图代码开始，将`data_collector/views.py`更改为以下内容：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It''s a little complicated, so let''s break it up into parts. First, we get
    a list of node name and data type pairs, using the query we came up with before.
    The result of the query, which we store in `nodes_and_data_types`, is similar
    to the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点复杂，所以让我们分成几部分。首先，我们使用之前想出的查询获取节点名称和数据类型对的列表。我们将查询的结果存储在`nodes_and_data_types`中，类似于以下内容：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we've seen before, this is a list of all unique node name and data type pairs
    in our database. So, as our **dbmaster** node doesn't have any data for the **load**
    data type, you won't find that pair in this list. I'll explain in a while why
    running the distinct query helps us reduce the amount of load we need to put on
    our database.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，这是我们数据库中所有唯一的节点名称和数据类型对的列表。因此，由于我们的**dbmaster**节点没有任何**load**数据类型的数据，您在此列表中找不到该对。稍后我会解释为什么运行不同的查询有助于我们减少对数据库的负载。
- en: Next, we loop over each of these pairs; that's the for loop you can see in the
    code. For each node name and data type pair, we run a query to get us the latest
    data point. First, we filter down to only the data points that we are interested
    in—those that match the node name and data type we specified. Then, we call the
    `latest` method and get the most recently updated data point.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们循环遍历每对；这是您在代码中看到的for循环。对于每个节点名称和数据类型对，我们运行一个查询，以获取最新的数据点。首先，我们筛选出我们感兴趣的数据点，即与我们指定的节点名称和数据类型匹配的数据点。然后，我们调用`latest`方法并获取最近更新的数据点。
- en: The `latest` method takes the name of a field, orders the query using this field,
    and then returns the last row of data as per that ordering. It should be noted
    that `latest` can work with any field type that can be ordered, including numbers,
    not just date time fields.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`latest`方法接受一个字段的名称，使用该字段对查询进行排序，然后根据该排序返回数据的最后一行。应该注意的是，`latest`可以与任何可以排序的字段类型一起使用，包括数字，而不仅仅是日期时间字段。'
- en: I would like to point out the use of `setdefault` here. Calling `setdefault`
    on a dictionary makes sure that if the key provided doesn't exist in the dictionary
    already, the value passed as the second parameter is set for that key. This is
    a pretty useful pattern that I and a lot of Python programmers use when we are
    creating a dictionary in which all the keys need to have values of the same type—a
    dictionary in this case.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我想指出这里使用了`setdefault`。在字典上调用`setdefault`可以确保如果提供的键在字典中不存在，那么第二个参数传递的值将被设置为该键的值。这是一个非常有用的模式，我和很多Python程序员在创建字典时使用，其中所有的键都需要具有相同类型的值-在这种情况下是一个字典。
- en: This allows us to ignore the scenario in which the key does not previously exist
    in the dictionary. Without using `setdefault`, we would first have to check whether
    the key exists. If it did, we would modify that. If it didn't, we would create
    a new dictionary, modify that, and then assign it to `status_data_dict`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们可以忽略键以前不存在于字典中的情况。如果不使用`setdefault`，我们首先必须检查键是否存在。如果存在，我们将修改它。如果不存在，我们将创建一个新的字典，修改它，然后将其分配给`status_data_dict`。
- en: The `setdefault` method returns the value of the given key as well, whether
    it had to set it to the default value or not. We save that in the `data_point_map`
    variable in our code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`setdefault`方法也返回给定键的值，无论它是否必须将其设置为默认值。我们在代码中将其保存在`data_point_map`变量中。'
- en: 'Finally, we add the `status_data_dict` dictionary to the context and return
    it. We''ll see in our template how we go over this data and display it to the
    user. I said earlier that I would explain how the distinct query helped us reduce
    the load on the database. Let''s look at an example scenario. Assume that we have
    the same three nodes in our infrastructure that we saw in our sample data: **web01**,
    **web02**, and **dbmaster**. Let''s say that we have had monitoring running for
    one whole day, collecting stats for both load and disk usage on all three nodes
    every minute. Doing the math, we should have the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`status_data_dict`字典添加到上下文中并返回它。我们将在我们的模板中看到如何处理这些数据并向用户显示它。我之前说过我会解释不同的查询是如何帮助我们减少数据库负载的。让我们看一个例子。假设我们的基础设施中有相同的三个节点，我们在样本数据中看到了：**web01**，**web02**和**dbmaster**。假设我们已经运行了一整天的监控，每分钟收集所有三个节点的负载和磁盘使用情况的统计数据。做一下计算，我们应该有以下结果：
- en: 'Number of nodes x number of data types x number of hours x 60:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 节点数x数据类型数x小时数x60：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Thus, our data base has 8,640 data point objects. Now, with the code that we
    have in our view, we will only need to retrieve six data point objects from the
    database to show the user an updated status page plus the one distinct query.
    If we had to get all the data points, we would have to transfer the data for all
    those 8,640 data points from the database, and then use only six of them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的数据库有8,640个数据点对象。现在，有了我们在视图中的代码，我们只需要从数据库中检索六个数据点对象，就可以向用户显示一个更新的状态页面，再加上一个不同的查询。如果我们必须获取所有数据点，我们将不得不从数据库中传输所有这些8,640个数据点的数据，然后只使用其中的六个。
- en: 'For the template, create a folder called `templates` in the `data_collector`
    directory. Then, create a `status.html` file in the template folder and give it
    the following content:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模板，创建一个名为`templates`的文件夹在`data_collector`目录中。然后，在模板文件夹中创建一个名为`status.html`的文件，并给它以下内容：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There shouldn''t be many surprises here. Ignoring the `load humanize` line,
    our template simply creates a table using the data dictionary that we generated
    in our view earlier. The two nested `for` loops might look a bit complicated,
    but looking at the data that we are looping over should make things clear:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不应该有太多意外。忽略`load humanize`行，我们的模板只是使用我们在视图中生成的数据字典创建一个表。两个嵌套的`for`循环可能看起来有点复杂，但看一下我们正在循环的数据应该会让事情变得清晰：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first for loop gets the node name and dictionary mapping data type to the
    latest data point. The inner for loop then iterates over the data type and the
    latest data point for the type and generates the table rows. We use the `forloop.first`
    flag to print the node name only if the inner loop is running for the first time.
    Django provides a few other useful flags related to for loops in templates. Take
    a look at the documentation at [https://docs.djangoproject.com/en/stable/ref/templates/builtins/#for](https://docs.djangoproject.com/en/stable/ref/templates/builtins/#for).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个for循环获取节点名称和将数据类型映射到最新数据点的字典。然后内部for循环遍历数据类型和该类型的最新数据点，并生成表行。我们使用`forloop.first`标志仅在内部循环第一次运行时打印节点名称。Django在模板中提供了一些与for循环相关的其他有用的标志。查看文档[https://docs.djangoproject.com/en/stable/ref/templates/builtins/#for](https://docs.djangoproject.com/en/stable/ref/templates/builtins/#for)。
- en: When we print the `datetime` field for a data point, we use the `naturaltime`
    filter. This filter is part of the humanize template tags provided as part of
    Django, which is why we needed to use the `load humanize` line at the start of
    the template. The `naturaltime` template filter outputs a date time value in a
    format that is easy for humans to understand, for example, two seconds ago, one
    hour ago, 20 minutes ago, and so on. You need to add `django.contrib.humanize`
    to the list of `INSTALLED_APPS` in `djagios/settings.py` before you can load the
    `humanize` template tags.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印数据点的`datetime`字段时，我们使用`naturaltime`过滤器。这个过滤器是Django提供的humanize模板标签的一部分，这就是为什么我们需要在模板的开头使用`load
    humanize`行。`naturaltime`模板过滤器以易于人类理解的格式输出日期时间值，例如，两秒前，一小时前，20分钟前等等。在你加载`humanize`模板标签之前，你需要将`django.contrib.humanize`添加到`djagios/settings.py`的`INSTALLED_APPS`列表中。
- en: 'The final step in completing our status page is to add it to the URL configuration.
    As the status page is what the user wants to see most often from a monitoring
    system, let''s make it the home page. Make the URL configuration file at `djagios/urls.py`
    contain the following content:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 完成我们的状态页面的最后一步是将其添加到URL配置中。由于状态页面是用户最常想要从监控系统中看到的页面，让我们把它作为主页。让`djagios/urls.py`中的URL配置文件包含以下内容：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That''s it. Run the development server:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。运行开发服务器：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Access the status page at `http://127.0.0.1:8000`. If you have followed the
    steps so far, you should see a status page similar to the following one. Of course,
    your page will show data from your database:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`http://127.0.0.1:8000`上的状态页面。如果您迄今为止已经按照步骤进行操作，您应该会看到一个类似以下页面的状态页面。当然，您的页面将显示来自您的数据库的数据：
- en: '![Status page](img/00698_03_02.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![状态页面](img/00698_03_02.jpg)'
- en: Alerts
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 警报
- en: Now that we have a basic status page up and running, let's talk about allowing
    the user to configure some alert conditions. For now, we will inform the user
    of any alert condition by showing that node's information in red color on the
    status page.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个基本的状态页面，让我们谈谈允许用户配置一些警报条件。目前，我们将通过在状态页面上以红色显示该节点的信息来通知用户任何警报条件。
- en: First, we need to figure out what kind of alerts we want our users to set. From
    there, we can figure out the technical details. So, let's think about it. Given
    that the data types we are recording all have numeric values, it makes sense that
    the user should be able to set thresholds. They can, for instance, set an alert
    if the system load of any node goes above 1.0 or if the disk usage of a node goes
    above 80%.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要弄清楚我们希望用户设置什么样的警报。从那里，我们可以弄清楚技术细节。所以，让我们考虑一下。鉴于我们记录的所有数据类型都具有数值数值，用户应该能够设置阈值是有意义的。例如，他们可以设置警报，如果任何节点的系统负载超过1.0，或者如果节点的磁盘使用率超过80%。
- en: Furthermore, maybe our users don't want to have the same alert conditions for
    each node. A database node is expected to handle a lot of system load, so maybe
    our users want to have a separate alert condition for the database node. Finally,
    if they are doing maintenance on some of the nodes, they may want to stop some
    alerts from triggering.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，也许我们的用户不希望为每个节点设置相同的警报条件。数据库节点预计会处理大量的系统负载，因此也许我们的用户希望为数据库节点设置单独的警报条件。最后，如果他们正在对一些节点进行维护，他们可能希望停止一些警报的触发。
- en: 'From all this, it seems that our alerts need to have fields to hold the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从所有这些来看，似乎我们的警报需要具有以下字段：
- en: Data type on which to trigger
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发的数据类型
- en: Maximum value to trigger on
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发的最大值
- en: Minimum value to trigger on
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发的最小值
- en: Node name to trigger on
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发的节点名称
- en: If the alert is currently active
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果警报当前处于活动状态
- en: Of these, the data type and active status are required fields that should never
    be null. The node name can be an empty string in which the alert conditions will
    be checked for each node. If the node name is not an empty string, it will be
    checked for nodes whose names match the provided string exactly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，数据类型和活动状态是必填字段，不应为空。节点名称可以是空字符串，在这种情况下，将检查每个节点的警报条件。如果节点名称不是空字符串，则将检查名称与提供的字符串完全匹配的节点。
- en: As for the maximum and minimum values, one of those is required. This is so
    that the user may set alerts for just the maximum value without having to care
    about the minimum value for the data points. This will require manual validation
    in the model.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 至于最大值和最小值，其中一个是必需的。这样用户可以仅设置最大值的警报，而不必关心数据点的最小值。这将需要在模型中进行手动验证。
- en: The model
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: 'Let''s look at the model. To keep things simple, we''ll use the `data_collector`
    app instead of creating a new one for alerts. Here is the code for our `Alert`
    model. Put this in `data_collector/models.py` after the `DataPoint` model code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看模型。为了保持简单，我们将使用`data_collector`应用程序，而不是为警报创建一个新的应用程序。以下是我们的`Alert`模型的代码。将其放在`data_collector/models.py`中的`DataPoint`模型代码之后：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Due to our special requirements for the min and max fields, we had to override
    the `save` method. As you can probably tell, our custom `save` method raises an
    error if both the min and max values are not set. As there is no way to express
    this condition with normal Django field configuration, we have to override the
    `save` method and add our custom logic here. This is a pretty common thing to
    do in Django if you have some custom validation requirements that depend on more
    than one field.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对最小和最大字段的特殊要求，我们不得不重写`save`方法。您可能已经注意到，我们的自定义`save`方法如果未设置最小和最大值，则会引发错误。由于没有办法使用正常的Django字段配置表达这种条件，我们不得不重写`save`方法并在这里添加我们的自定义逻辑。如果您有一些依赖于多个字段的自定义验证要求，这在Django中是一种非常常见的做法。
- en: One more thing to note is the `blank=True` parameter to the min and max `FloatField`.
    This is required so that any model forms constructed from this model, which we
    will use for the `create` and `update` views later, allow blank values for these
    fields.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事要注意，那就是对最小和最大`FloatField`的`blank=True`参数。这是必需的，以便从该模型构建的任何模型表单（稍后我们将用于`create`和`update`视图）允许这些字段的空值。
- en: Make and run migrations to add this to your database.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并运行迁移以将其添加到您的数据库中。
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Management views
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理视图
- en: The users will need some views that they can use to manage alerts. They will
    need pages to view all the alerts defined in the system, a page to create new
    alerts and edit existing ones, and some way to delete alerts they no longer require.
    All of these are achievable using the generic view provided by Django and some
    templates. Let's get to it!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将需要一些视图来管理警报。他们将需要页面来查看系统中定义的所有警报，创建新警报和编辑现有警报的页面，以及删除不再需要的警报的某种方式。所有这些都可以使用Django提供的通用视图和一些模板来实现。让我们开始吧！
- en: 'First, let''s look at the list view first. Add this to `data_collector/views.py`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们先看看列表视图。将其添加到`data_collector/views.py`中：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Remember to import `ListView` from `django.views.generic` and `Alert` from
    `data_collector.models`. Next, create the `alerts_list.html` template file in
    `data_collector/templates` and give it the following content:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 记得从`django.views.generic`中导入`ListView`和从`data_collector.models`中导入`Alert`。接下来，在`data_collector/templates`中创建`alerts_list.html`模板文件，并给它以下内容：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, edit `djagios/urls.py`. Import the new view, and then add this to
    the URL patterns:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，编辑`djagios/urls.py`。导入新视图，然后将其添加到URL模式中：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To test it out, open `http://127.0.0.1:8000/alerts/`. You should see the **No
    Alerts Defined** message. The list view is pretty basic. The `ListVew` generic
    view renders a template with all the objects for the specified model, providing
    the list of objects in the `object_list` template context variable. Next, let's
    look at the view to create new alerts.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试它，打开`http://127.0.0.1:8000/alerts/`。你应该会看到**没有定义警报**的消息。列表视图非常基本。`ListVew`通用视图使用指定模型的所有对象渲染模板，提供`object_list`模板上下文变量中的对象列表。接下来，让我们看看创建新警报的视图。
- en: 'In the `data_collector/view.py` file, first import the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在`data_collector/view.py`文件中，首先导入以下内容：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then add this view class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加这个视图类：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Nothing new in the view code. The template code is quite simple as well. Put
    this code in `data_collector/templates/create_or_update_alert.html`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图代码中没有新内容。模板代码也非常简单。将这段代码放入`data_collector/templates/create_or_update_alert.html`中：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As in previous chapters, we use the `object` context variable to decide if
    this template was used from `CreateView` or `UpdateView` and change some elements
    based on this. Otherwise, it''s pretty straightforward. Let''s see the code for
    `UpdateView` as well:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 和以前的章节一样，我们使用`object`上下文变量来决定这个模板是从`CreateView`还是`UpdateView`中使用的，并根据此更改一些元素。否则，它非常直接了当。让我们也看看`UpdateView`的代码：
- en: '[PRE38]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It''s an almost identical copy of the previous create view. Make sure that
    you have imported the `UpdateView` generic view. We still need to add both of
    these views to our URL configuration. In the `djagios/urls.py` file, import both
    `NewAlertView` and `EditAlertView` and add these patterns:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎是前一个创建视图的完全相同的副本。确保你已经导入了`UpdateView`通用视图。我们仍然需要将这两个视图添加到我们的URL配置中。在`djagios/urls.py`文件中，导入`NewAlertView`和`EditAlertView`，并添加这些模式：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Before we can test these views, we should add links to allow users to get to
    these views. Modify the `alerts_list.html` template to match this code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们测试这些视图之前，我们应该添加链接，让用户可以到达这些视图。修改`alerts_list.html`模板以匹配这段代码：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Two new lines, which are highlighted, have been added. Now, let''s see what
    our alerts list page looks like. As before, open `http://127.0.0.1:8000/alerts/`
    in your browser. You should see a page as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 已添加了两行新的高亮显示的行。现在，让我们看看我们的警报列表页面是什么样子的。和以前一样，在浏览器中打开`http://127.0.0.1:8000/alerts/`。你应该会看到以下页面：
- en: '![Management views](img/00698_03_03.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![管理视图](img/00698_03_03.jpg)'
- en: 'Click on the **Add New Alert** link and you should see the form to create an
    alert. Fill it in with some sample data and click on the **Create** button. If
    your form didn''t have any errors, you should be back to the alerts list view
    and your screen should now list the new alert, as shown in the following screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**添加新警报**链接，你应该会看到创建警报的表单。填写一些示例数据，然后点击**创建**按钮。如果你的表单没有任何错误，你应该会回到警报列表视图，并且你的屏幕现在应该列出新的警报，如下面的截图所示：
- en: '![Management views](img/00698_03_04.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![管理视图](img/00698_03_04.jpg)'
- en: 'All that''s left now is to allow users the option to delete their alerts. For
    this, create a view that subclasses from the generic `DeleteView`, remembering
    to import `DeleteView` from `django.views.generic` first. Here''s the code you
    should put in `data_collector/view.py`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是允许用户删除他们的警报的选项。为此，创建一个从通用`DeleteView`继承的视图，记得首先从`django.views.generic`中导入`DeleteView`。以下是你应该放入`data_collector/view.py`中的代码：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a new `data_collector/templates/delete_alert.html` template:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`data_collector/templates/delete_alert.html`模板：
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, import `DeleteAlertView` in `djagios/urls.py` and add this new pattern:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`djagios/urls.py`中导入`DeleteAlertView`，并添加这个新的模式：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, let''s add a link to the delete view from the alerts list page. Edit
    the `alerts_list.html` template and add this line right after the **Edit** link:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们从警报列表页面添加一个链接到删除视图。编辑`alerts_list.html`模板，在**编辑**链接后面添加这一行：
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now when you open the alerts list view, you should see a **Delete** link. Your
    screen should look similar to the following screenshot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你打开警报列表视图时，你应该会看到一个**删除**链接。你的屏幕应该看起来类似于以下截图：
- en: '![Management views](img/00698_03_05.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![管理视图](img/00698_03_05.jpg)'
- en: If you click on the **Delete** link, you should see a confirmation page. If
    you confirm the deletion, you will see that your alert will be gone from the list
    page. These are all the views that we will need to manage alerts. Let's move on
    to detecting alert conditions and showing them in the status page.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**删除**链接，你应该会看到一个确认页面。如果你确认删除，你会发现你的警报将从列表页面消失。这些是我们需要管理警报的所有视图。让我们继续检测警报条件并在状态页面显示它们。
- en: Showing triggered alerts on the status page
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在状态页面显示触发的警报
- en: As I said before, we want our users to see any nodes that have an alert triggered
    highlighted on the status page. Say that they defined an alert for when the disk
    usage on any node goes beyond `0.85` and the latest data point that we have for
    **dbmaster** disk usage has the value `0.9`. When the user visits the status page,
    we would like the row showing the disk usage of the **dbmaster** node to be highlighted
    in red so that the user is immediately aware of the alert and is able to take
    actions to correct this.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，我们希望我们的用户在状态页面上看到任何触发警报的节点都被突出显示。假设他们定义了一个警报，当任何节点的磁盘使用率超过`0.85`时触发，而我们对**dbmaster**磁盘使用率的最新数据点的值为`0.9`。当用户访问状态页面时，我们希望显示**dbmaster**节点的磁盘使用情况的行以红色突出显示，以便用户立即意识到警报并能够采取措施纠正这一情况。
- en: 'Change `StatusView` in `data_collector/view.py` to match the following code.
    The changed bits are highlighted:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将`data_collector/view.py`中的`StatusView`更改为匹配以下代码。更改的部分已经高亮显示：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: What we have done here is to check, for each data point that we retrieve, whether
    it triggers any alert. We do this by comparing the min and max values in every
    alert with the data point value, but only if the data point data type and node
    name match those in the alert. If the data point value is outside of the alert
    range, we mark the data point as having triggered an alert.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是，对于我们检索到的每个数据点，检查它是否触发了任何警报。我们通过比较每个警报中的最小值和最大值与数据点值来做到这一点，但只有当数据点数据类型和节点名称与警报中的匹配时。如果数据点值超出了警报范围，我们将标记数据点为触发了警报。
- en: This is another technique often used by me in a number of projects I've done.
    As models are just Python objects, you can attach extra information to them on
    the fly. No need to define `has_alert` on the `DataPoint` class. Just add it to
    the objects when needed. Be careful though. It's not a good programming practice
    to do something like this, because someone trying to understand the `DataPoint`
    class will have no idea that the `has_alert` attribute event exists unless they
    look at the code for the view class. As we only use this attribute in the view
    and template, it's fine for us. However, if we passed the `DataPoint` objects
    around and more code started using this attribute, it would be much better to
    define it on the class itself so that anyone looking at the class code would know
    it existed.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在许多项目中经常使用的另一种技术。由于模型只是Python对象，你可以在运行时向它们附加额外的信息。不需要在`DataPoint`类上定义`has_alert`。只需在需要时将其添加到对象中。不过要小心。这样做并不是一个好的编程实践，因为试图理解`DataPoint`类的人将不知道`has_alert`属性甚至存在，除非他们查看视图类的代码。由于我们只在视图和模板中使用这个属性，对我们来说是可以的。但是，如果我们传递`DataPoint`对象并且更多的代码开始使用这个属性，最好还是在类本身上定义它，这样查看类代码的人就会知道它的存在。
- en: 'We need to modify the `status.html` template as well to make use of the `has_alert`
    attribute that we have added to the data points. Change it to match the following
    code. As before, the modified portions have been highlighted:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改`status.html`模板，以利用我们已经添加到数据点的`has_alert`属性。将其更改为以下代码。与之前一样，修改的部分已经被突出显示：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'That''s it. In order to test it out, you need to create some `Alert` objects
    that will be triggered by `DataPoints` in your database. For the sample data that
    I used, I created one `Alert` object with the **disk_usage** data type and a max
    value of 0.5\. After creating the alert, my status screen highlighted the nodes
    that triggered the alert. You screen will show something similar:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。为了测试它，你需要创建一些在你的数据库中由`DataPoints`触发的`Alert`对象。对于我使用的示例数据，我创建了一个数据类型为**disk_usage**，最大值为0.5的`Alert`对象。创建警报后，我的状态屏幕突出显示了触发警报的节点。你的屏幕会显示类似的内容：
- en: '![Showing triggered alerts on the status page](img/00698_03_06.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![在状态页面上显示触发的警报](img/00698_03_06.jpg)'
- en: 'To test whether our highlighting code works correctly, I added another data
    point for the **dbmaster** disk usage metric, using the following command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的突出显示代码是否正确工作，我添加了另一个**dbmaster**磁盘使用率指标的数据点，使用以下命令：
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: After refreshing the status page, the alert condition for the **dbmaster** node
    disappeared. You should do a similar test to see for yourself.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新状态页面后，**dbmaster**节点的警报条件消失了。你应该进行类似的测试来亲自看看。
- en: 'That''s it! It''s been hard work, but our monitoring tool is now starting to
    shape up. We have a status page that shows the latest node statuses, highlighting
    any that have alerts. The highlights disappear once the alert condition is resolved.
    We have a page to manage our alerts as well. All in all, we can say that the user-facing
    parts of the application are almost finished. One thing that would be pretty helpful
    is a navigation bar. Add this just after the start of the `body` tag in `templates/base.html`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！虽然很辛苦，但我们的监控工具现在开始成形了。我们有一个显示最新节点状态的状态页面，突出显示任何有警报的节点。一旦警报条件解决，突出显示就会消失。我们也有一个页面来管理我们的警报。总的来说，我们可以说应用程序的用户界面部分几乎已经完成了。一个相当有帮助的东西是一个导航栏。在`templates/base.html`的`body`标签开始后添加这个：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Refresh the status page and you should see a simple navigation menu at the top
    of the page.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新状态页面，你应该会看到页面顶部有一个简单的导航菜单。
- en: Accepting data from remote systems
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接受来自远程系统的数据
- en: 'Now that users can see the status of their infrastructure and manage alerts,
    it''s time to move on to the next step: getting data from real sources instead
    of using Django management commands to input sample data.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户可以看到他们基础设施的状态并管理警报了，是时候继续下一步了：从真实来源获取数据，而不是使用Django管理命令输入示例数据。
- en: To do so, we will create an API **endpoint** that accepts data from remote systems.
    An API endpoint is just a fancy name for a Django view that doesn't have a template
    to render. The response from an API endpoint is typically either just a 200 OK
    status or a JSON response. API endpoints are not meant to be used by human users.
    Instead, they are meant to be used by different software systems to connect together
    and share information.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将创建一个接受来自远程系统的API端点。API端点只是一个不需要渲染模板的Django视图的花哨名称。API端点的响应通常要么只是一个200
    OK状态，要么是一个JSON响应。API端点不是为人类用户使用的。相反，它们是为不同的软件系统连接在一起并共享信息而设计的。
- en: The API endpoint that we need to create will be a simple view that accepts a
    POST request with all the information needed to create a new `DataPoint` object.
    To make sure that malicious users can't spam our database with random data, we
    will also add a simple authentication mechanism to our API endpoint so that it
    will accept data only from authorized sources.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的API端点将是一个简单的视图，接受一个带有创建新`DataPoint`对象所需信息的POST请求。为了确保恶意用户不能用随机数据垃圾邮件式地填充我们的数据库，我们还将在API端点中添加一个简单的身份验证机制，以便它只接受来自授权来源的数据。
- en: 'To create an API endpoint, we''ll use the `django.view.generic.View` class,
    implementing only the POST handler. To parse the request data, we''ll be creating
    a model form on the fly. Edit `data_collector/views.py` and add the following
    code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个API端点，我们将使用`django.view.generic.View`类，只实现POST处理程序。为了解析请求数据，我们将动态创建一个模型表单。编辑`data_collector/views.py`并添加以下代码：
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: There are a couple of new things here that we need to look at. Firstly, we have
    used the `META` attribute on the request object to access a request. If you have
    knowledge of how the HTTP protocol works, you should be familiar with headers.
    If not, a good explanation is available at [https://www.jmarshall.com/easy/http/](https://www.jmarshall.com/easy/http/).
    Explaining headers in detail is beyond the scope of this book, but simply stated,
    headers are extra pieces of information added to an HTTP request by the client.
    We'll see how to add them in the next section when we test our API view.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新的东西需要我们注意。首先，我们使用了请求对象的`META`属性来访问请求。如果您了解HTTP协议的工作原理，您应该熟悉头部。如果不了解，可以在[https://www.jmarshall.com/easy/http/](https://www.jmarshall.com/easy/http/)找到一个很好的解释。详细解释头部超出了本书的范围，但简单地说，头部是客户端在HTTP请求中添加的额外信息。在下一节中，当我们测试API视图时，我们将看到如何添加它们。
- en: Django automatically normalizes all header names and adds them to the `META`
    dictionary. Here, we are using a custom header **Auth-Secret** to make sure that
    only clients that have our secret key can use this view.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Django会自动规范化所有头部名称并将它们添加到`META`字典中。在这里，我们使用自定义头部**Auth-Secret**来确保只有拥有我们秘钥的客户端才能使用这个视图。
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about what goes into the META dictionary and how it is consturcted
    is available in the Django docs at [https://docs.djangoproject.com/en/stable/ref/request-response/#django.http.HttpRequest.META](https://docs.djangoproject.com/en/stable/ref/request-response/#django.http.HttpRequest.META).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有关META字典中的内容以及其构造方式的更多信息，请参阅Django文档[https://docs.djangoproject.com/en/stable/ref/request-response/#django.http.HttpRequest.META](https://docs.djangoproject.com/en/stable/ref/request-response/#django.http.HttpRequest.META)。
- en: The next thing that we need to look at is the `modelform_factory` function.
    It's a neat little function provided by Django that returns a `ModelForm` subclass
    for the given model. You can customize the model form to a certain degree using
    the arguments to this function. Here, we limit the number of fields that can be
    edited. Why use a model form in the first place?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要看的是`modelform_factory`函数。这是Django提供的一个很好的小函数，它返回给定模型的`ModelForm`子类。您可以使用此函数的参数对模型表单进行一定程度的自定义。在这里，我们限制了可以编辑的字段数量。为什么首先使用模型表单呢？
- en: What we wanted from the API endpoint was a method to create new `DataPoint`
    models. Model forms provide exactly the functionality that we need to do this
    plus they handle data validation for us. We could have created a separate model
    form class in a `forms.py` file and then used that in our view as we have done
    before, but there are two reasons we didn't.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从API端点中想要的是创建新的`DataPoint`模型的方法。模型表单正好提供了我们需要做到这一点的功能，而且它们还为我们处理了数据验证。我们本可以在`forms.py`文件中创建一个单独的模型表单类，然后像以前一样在视图中使用它，但我们没有这样做的两个原因。
- en: Firstly, this was the only place in our code where we use a model form for the
    `DataPoint` method. If we needed to use it in other places as well, defining the
    model form in a single place would be the best programming practice. However,
    as we don't, we can get away with defining the model form dynamically where we
    need it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是我们的代码中唯一使用模型表单的地方，用于`DataPoint`方法。如果我们需要在其他地方也使用它，那么在单个地方定义模型表单将是最佳的编程实践。然而，由于我们不需要，在需要时动态定义模型表单就可以了。
- en: Secondly, we didn't need any customizations to the model form class. If we wanted
    to, say, override the `save` method as we've done previously, we would have been
    forced to define the class instead of using the `modelform_factory` method.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们不需要对模型表单类进行任何自定义。如果我们想要，比如，像之前所做的那样覆盖`save`方法，我们将被迫定义类而不是使用`modelform_factory`方法。
- en: 'After getting the model form class, we use it like any model form class to
    either create the new data point or return a response indicating that the data
    validation failed. To make our new endpoint available via a URL, import the following
    in `djagios/urls.py`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 获取模型表单类之后，我们可以像使用任何模型表单类一样使用它，要么创建新的数据点，要么返回指示数据验证失败的响应。要使我们的新端点通过URL可用，请在`djagios/urls.py`中导入以下内容：
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, add this URL pattern:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加此URL模式：
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `csrf_exempt` decorator is used because, by default, Django uses CSRF protection
    for POST requests. However, this is usually used on web forms, not API endpoints.
    So we have to disable it, otherwise Django won't allow our POST request to succeed.
    Now, let's look at how to test out our new view.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`csrf_exempt`装饰器是因为默认情况下，Django对POST请求使用CSRF保护。然而，这通常用于Web表单，而不是API端点。因此，我们必须禁用它，否则Django不会允许我们的POST请求成功。现在，让我们看看如何测试我们的新视图。
- en: Tip
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can get more information about CSRF protection provided by Django at [https://docs.djangoproject.com/en/stable/ref/csrf/](https://docs.djangoproject.com/en/stable/ref/csrf/).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.djangoproject.com/en/stable/ref/csrf/](https://docs.djangoproject.com/en/stable/ref/csrf/)获取有关Django提供的CSRF保护的更多信息。
- en: Testing API endpoints
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试API端点
- en: You can't simply test this API endpoint in your browser because it's a POST
    request and there's no template that can render a form in your browser. However,
    a lot of great tools are available to make manual POST requests. The one that
    I suggest you use is Postman. It's a Google Chrome app, so you don't need to install
    any dependencies. As long as you have Google Chrome installed on your machine,
    you can get Postman from [https://www.getpostman.com/](https://www.getpostman.com/).
    After you have installed it, start it up and you should see a screen similar to
    the following one. Don't worry if your Postman screen isn't exactly the same.
    It can be that the version you downloaded is a newer one. The main parts of Postman
    should be the same.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能简单地在浏览器中测试此API端点，因为它是一个POST请求，而且没有模板可以在浏览器中呈现一个表单。但是，有很多很好的工具可用于进行手动的POST请求。我建议您使用的是Postman。它是一个Google
    Chrome应用，因此您不需要安装任何依赖项。只要您的计算机上安装了Google Chrome，您就可以从[https://www.getpostman.com/](https://www.getpostman.com/)获取Postman。安装后，启动它，您应该看到一个类似以下屏幕的界面。如果您的Postman界面不完全相同，不要担心。可能是您下载的版本更新了。Postman的主要部分应该是相同的。
- en: '![Testing API endpoints](img/00698_03_07.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![测试API端点](img/00698_03_07.jpg)'
- en: Using Postman is simple. I will walk you through the entire process step by
    step, including an image for each step to make it clear what I mean. At the end
    of this process, we should be able to use our API endpoint to generate a new data
    point.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Postman很简单。我将逐步为您讲解整个过程，包括每个步骤的图像，以便清楚地说明我的意思。在这个过程结束时，我们应该能够使用我们的API端点生成一个新的数据点。
- en: 'As a side note, if you are using a Linux- or Unix-based OS, such as Ubuntu
    or Mac OS X, and are more comfortable using the command line, you can use the
    `curl` utility to make the POST request. It is usually faster for simpler requests.
    To make the same request using `curl` as the one I demonstrate here in Postman,
    type this on your command prompt:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果您使用的是Linux或Unix操作系统，如Ubuntu或Mac OS X，并且更习惯使用命令行，您可以使用`curl`实用程序来进行POST请求。对于更简单的请求，它通常更快。要使用`curl`进行与我在Postman中演示的相同请求，请在命令提示符上键入以下内容：
- en: '[PRE52]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To make this request using Postman, perform the following steps:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Postman进行此请求，请执行以下步骤：
- en: Select the request type. We want to make a POST request, so select POST from
    the drop-down menu:![Testing API endpoints](img/00698_03_08.jpg)
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择请求类型。我们要进行POST请求，因此从下拉菜单中选择POST：![测试API端点](img/00698_03_08.jpg)
- en: Enter the URL you want to make the request to. In our case, it is `http://127.0.0.1:8000/record/`:![Testing
    API endpoints](img/00698_03_09.jpg)
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入您要发出请求的URL。在我们的情况下，它是`http://127.0.0.1:8000/record/`：![测试API端点](img/00698_03_09.jpg)
- en: Add our custom authentication header. Open up the **Headers** tab and add the
    **Auth-Secret** header with a value of **supersecretkey**:![Testing API endpoints](img/00698_03_10.jpg)
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加我们的自定义身份验证标头。打开**标头**选项卡，并添加值为**supersecretkey**的**Auth-Secret**标头：![测试API端点](img/00698_03_10.jpg)
- en: 'Finally, add our POST parameters to the **Body** section. The sample data that
    I used was as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将我们的POST参数添加到**Body**部分。我使用的示例数据如下：
- en: 'node_name: `web01`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'node_name: `web01`'
- en: 'data_type: `disk_usage`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'data_type: `disk_usage`'
- en: 'data_value: `0.72`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'data_value: `0.72`'
- en: '![Testing API endpoints](img/00698_03_11.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![测试API端点](img/00698_03_11.jpg)'
- en: 'That''s it. Our request is now set up. Click on the **Send** button next to
    the URL textbox and you should see an empty response below the body parameters.
    To confirm that the request worked properly, look at the status code of the response.
    It should be **200 OK**:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们的请求现在已经设置好了。单击URL文本框旁边的**发送**按钮，您应该在参数体下方看到一个空的响应。要确认请求是否正常工作，请查看响应的状态代码。它应该是**200
    OK**：
- en: '![Testing API endpoints](img/00698_03_12.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![测试API端点](img/00698_03_12.jpg)'
- en: Open up the status page for our application at `http://127.0.0.1:8000/` and
    you should see the latest data point value displayed there. That's it, we're done!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们应用程序的状态页面`http://127.0.0.1:8000/`，您应该看到最新的数据点值显示在那里。就是这样，我们完成了！
- en: Note
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As explained at the start of this section, you can also use command-line tools
    such as `curl` to upload data to the API. Using such tools, you can come up with
    shell scripts that automatically update the web app with real data from your computer
    systems. This is how Nagios and a lot of data monitoring tools operate as well.
    The servers have API endpoints that listen for data, and then simple scripts gather
    and upload data to the servers from the client nodes.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节开头所解释的那样，您还可以使用诸如`curl`之类的命令行工具来上传数据到API。使用这样的工具，您可以编写shell脚本，自动从计算机系统更新Web应用程序的真实数据。这也是Nagios和许多数据监控工具的运行方式。服务器有API端点来监听数据，然后简单的脚本从客户节点收集并上传数据到服务器。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was a pretty demanding chapter, and you learned a lot of new information.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当苛刻的章节，你学到了很多新信息。
- en: For starters, we looked at Django management commands. They are an important
    feature of Django. All Django commands that you run, such as `python manage.py
    startapp`, are management commands as well, so you should already know how powerful
    they can be. In bigger projects, you almost always have a few management commands
    to automate your tasks for you.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看了Django管理命令。它们是Django的一个重要特性。您运行的所有Django命令，例如`python manage.py startapp`，也是管理命令，因此您应该已经知道它们可以有多么强大。在更大的项目中，您几乎总是有一些管理命令来自动化您的任务。
- en: We also looked at how Django creates a string representation of our models using
    the `__str__` method on our model class. It's not just used when printing to the
    console either. Any time you try to use your model objects as strings, even in
    your templates, Django uses this representation, so it's important to have a good
    format that can immediately give you all the important information about an object.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看了Django如何使用我们模型类上的`__str__`方法创建模型的字符串表示。它不仅在控制台打印时使用。每当您尝试将模型对象用作字符串时，甚至在模板中，Django都会使用这个表示，因此拥有一个可以立即为您提供有关对象的所有重要信息的良好格式非常重要。
- en: This chapter also introduced advance query methods, specifically the `distinct`
    and `values` methods that allow you to issue more complicated SQL queries to get
    data in exactly the format you want from the database. However, this is just the
    beginning. In later chapters, we might need to use more complicated query methods.
    You might want to look at the Django documentation for `queryset` methods at [https://docs.djangoproject.com/en/stable/ref/models/querysets/](https://docs.djangoproject.com/en/stable/ref/models/querysets/)
    to learn about more methods of querying the databases that Django provides.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还介绍了高级查询方法，特别是`distinct`和`values`方法，允许您发出更复杂的SQL查询，以从数据库中获取您想要的数据格式。然而，这只是个开始。在以后的章节中，我们可能需要使用更复杂的查询方法。您可能需要查看Django文档中关于`queryset`方法的更多信息，网址为[https://docs.djangoproject.com/en/stable/ref/models/querysets/](https://docs.djangoproject.com/en/stable/ref/models/querysets/)。
- en: In addition to getting data from the database in a format that we wanted, we
    also looked at preparing a somewhat complicated data structure with the data to
    pass all the required information to templates, and then saw how to use that data
    structure in our templates.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 除了以我们想要的格式从数据库中获取数据之外，我们还研究了如何准备一个相当复杂的数据结构，以便将所有必需的信息传递给模板，然后看到如何在我们的模板中使用该数据结构。
- en: Often, you have complicated data validation rules that you need to ensure are
    passing before you can save data to a database. We looked at how to achieve this
    in this chapter by overriding the `save` method of our model classes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您需要确保通过复杂的数据验证规则才能将数据保存到数据库。在本章中，我们看到了如何通过覆盖模型类的`save`方法来实现这一点。
- en: Finally, you learned how to create simple API endpoints and how to test them
    using `curl` or Postman. Overall, this was a big chapter that introduced a lot
    of new concepts that will be used in later chapters.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您学会了如何创建简单的API端点以及如何使用`curl`或Postman对其进行测试。总的来说，这是一个介绍了许多新概念的重要章节，这些概念将在以后的章节中使用。
