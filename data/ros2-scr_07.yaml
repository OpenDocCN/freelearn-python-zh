- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Topics – Sending and Receiving Messages between Nodes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题 – 在节点之间发送和接收消息
- en: Now that you can write nodes, how can you make several nodes communicate with
    each other, and how can you interact with existing nodes in an application?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你能够编写节点了，你如何让多个节点相互通信，以及如何与应用程序中的现有节点交互？
- en: 'There are three kinds of communication in ROS 2: topics, services, and actions.
    In this chapter, we will dive into ROS 2 topics.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 2 中有三种通信方式：主题、服务和动作。在本章中，我们将深入研究 ROS 2 主题。
- en: To understand how topics work, we will start with a real-life analogy. This
    will allow you to grasp the concept using existing and common knowledge. Then,
    you will dive into the code and write a publisher and a subscriber inside a node—first
    with existing interfaces, and then by building custom interfaces. You will also
    use ROS 2 tools such as the **ros2** command line and **rqt_graph** to introspect
    topics and unlock more functionalities.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解主题是如何工作的，我们将从现实生活中的类比开始。这将帮助你利用现有的和常见的知识来掌握这个概念。然后，你将深入代码，在节点内部编写一个发布者和一个订阅者——首先使用现有的接口，然后通过构建自定义接口。你还将使用
    ROS 2 工具，如 **ros2** 命令行和 **rqt_graph** 来检查主题并解锁更多功能。
- en: By the end of this chapter, you will be able to make your nodes communicate
    with each other using ROS 2 topics. You will learn by writing code and will be
    provided with an additional challenge at the end of this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用 ROS 2 主题让你的节点相互通信。你将通过编写代码来学习，并在本章末尾提供额外的挑战。
- en: Topics are used everywhere in ROS 2\. Whether you wish to create an application
    from scratch or use existing ROS plugins, you will have to use topics.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 主题在 ROS 2 中无处不在。无论你希望从头开始创建一个应用程序还是使用现有的 ROS 插件，你都将不得不使用主题。
- en: We will use the code inside the **ch4** folder in this book’s GitHub repository
    ([https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch))
    as a starting point. You can find the final code in the **ch5** folder.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用本书 GitHub 仓库中 **ch4** 文件夹内的代码([https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch))作为起点。你可以在
    **ch5** 文件夹中找到最终代码。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is a ROS 2 topic?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS 2 主题是什么？
- en: Writing a topic publisher
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写主题发布者
- en: Writing a topic subscriber
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写主题订阅者
- en: Additional tools to handle topics
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理主题的附加工具
- en: Creating a custom interface for a topic
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为主题创建自定义接口
- en: Topic challenge – closed-loop control
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题挑战 – 闭环控制
- en: What is a ROS 2 topic?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROS 2 主题是什么？
- en: You discovered the concept of topics through hands-on experiments in [*Chapter
    3*](B22403_03.xhtml#_idTextAnchor092). With this, you should have a basic intuition
    of how things work.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过在 [*第3章*](B22403_03.xhtml#_idTextAnchor092) 中的动手实验发现了主题的概念。通过这个，你应该对事物是如何工作的有一个基本的直觉。
- en: I am now going to start from scratch again and explain topics—not by running
    code, but by using a real-life analogy that makes it easier to understand. We
    will build an example, step by step, and then recap the most important points.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在将从零开始再次解释主题——不是通过运行代码，而是通过使用使理解更简单的现实生活类比。我们将逐步构建一个示例，然后总结最重要的要点。
- en: A publisher and a subscriber
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布者和订阅者
- en: For this analogy, I will use radio transmitters and receivers. As this is a
    simplified example, not everything I’ll say about radio will be correct, but the
    point here is to understand ROS 2 topics.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个类比，我将使用无线电发射机和接收机。由于这是一个简化的例子，我说的关于无线电的每一件事可能都不完全正确，但这里的重点是理解 ROS 2 主题。
- en: Let’s start with one radio transmitter. This radio transmitter will send some
    data at a given frequency. To make it easier for people to remember, this frequency
    is usually represented by a number, such as *98.7*. We can even think of *98.7*
    as a name. If you want to listen to the radio, you know you have to connect your
    device to *98.7*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一台无线电发射机开始。这台无线电发射机将在指定的频率上发送一些数据。为了便于人们记忆，这个频率通常用一个数字表示，例如 *98.7*。我们甚至可以把
    *98.7* 看作一个名字。如果你想收听广播，你知道你需要将你的设备连接到 *98.7*。
- en: 'In this case, we can say that *98.7* is a topic. The radio transmitter is a
    **publisher** on this topic:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以这样说，*98.7* 是一个主题。这个主题上的无线电发射机是一个 **发布者**：
- en: '![Figure 5.1 – Radio transmitter publishing to the 98.7 topic](img/B22403_05_1.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 无线电发射机向 98.7 主题发布](img/B22403_05_1.jpg)'
- en: Figure 5.1 – Radio transmitter publishing to the 98.7 topic
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 无线电发射机向 98.7 主题发布
- en: Now, let’s say you want to listen to that radio from your phone. You will ask
    your phone to connect to *98.7* to receive the data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想用你的手机收听那台收音机。你将要求你的手机连接到 *98.7* 来接收数据。
- en: With this analogy, the phone is then a **subscriber** to the *98.7* topic.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个类比，手机就是 *98.7* 主题的 **订阅者**。
- en: One important thing to note here is that both the radio transmitter and the
    phone must use the same type of frequency. For example, if the radio transmitter
    is using an AM signal, and if the phone is trying to decode an FM signal, it will
    not work.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一个重要事项是，无线电发射台和手机必须使用相同类型的频率。例如，如果无线电发射台使用调幅信号，而手机试图解码调频信号，那么它将不起作用。
- en: Similarly, with ROS 2 topics, both the publisher and subscriber must use the
    same data type. This data type is called an **interface**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在 ROS 2 主题中，发布者和订阅者必须使用相同的数据类型。这种数据类型被称为 **接口**。
- en: 'This is what defines a topic: a **name** and an interface:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是定义主题的内容：一个 **名称** 和一个接口：
- en: '![Figure 5.2 – Publisher and subscriber using the same interface](img/B22403_05_2.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 使用相同接口的发布者和订阅者](img/B22403_05_2.jpg)'
- en: Figure 5.2 – Publisher and subscriber using the same interface
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 使用相同接口的发布者和订阅者
- en: With that, the communication is complete. The radio transmitter publishes an
    AM signal on the *98.7* topic. The phone subscribes to the *98.7* topic, decoding
    an AM signal.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，通信就完成了。无线电发射台在 *98.7* 主题上发布调幅信号。电话订阅 *98.7* 主题，解码调幅信号。
- en: Multiple publishers and subscribers
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个发布者和订阅者
- en: 'In real life, there won,t be just one device trying to listen to the radio.
    Let’s add a few more devices, each one subscribing to the *98.7* topic and decoding
    an AM signal:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，不会只有一个设备试图收听广播。让我们添加一些更多的设备，每个设备都订阅 *98.7* 主题并解码调幅信号：
- en: '![Figure 5.3 – Topic with multiple subscribers](img/B22403_05_3.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 具有多个订阅者的主题](img/B22403_05_3.jpg)'
- en: Figure 5.3 – Topic with multiple subscribers
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 具有多个订阅者的主题
- en: As you can see, one topic can have several subscribers. Each subscriber will
    get the same data. On the other hand, we could also have several publishers for
    one topic.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一个主题可以有多个订阅者。每个订阅者都会得到相同的数据。另一方面，我们也可以为同一个主题有多个发布者。
- en: 'Imagine that there is another radio transmitter, also publishing an AM signal
    to *98.7*. In this case, both the data from the first transmitter and the second
    transmitter are received by all listening devices:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，还有一个无线电发射台，也在向 *98.7* 发送调幅信号。在这种情况下，来自第一个发射台和第二个发射台的数据都被所有收听设备接收：
- en: '![Figure 5.4 – Multiple publishers and subscribers](img/B22403_05_4.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 多个发布者和订阅者](img/B22403_05_4.jpg)'
- en: Figure 5.4 – Multiple publishers and subscribers
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 多个发布者和订阅者
- en: The preceding figure shows boxes. Each box represents a node. Thus, we have
    two radio transmitter nodes, both containing a publisher to the *98.7* topic.
    We also have three nodes (phone, radio receiver, and car), each one containing
    a subscriber to *98.7*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图中显示了方框。每个方框代表一个节点。因此，我们有两个无线电发射台节点，都包含一个向 *98.7* 主题发布的发布者。我们还有三个节点（电话、收音机和汽车），每个节点都包含一个
    *98.7* 的订阅者。
- en: Note that one subscriber is not aware of the other subscribers. When you listen
    to the radio on your phone, you have no idea who else is listening to the radio,
    and on what device.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一个订阅者并不知道其他订阅者。当你用手机收听广播时，你不知道还有谁在收听广播，以及他们在什么设备上。
- en: Also, the phone, the radio receiver and the car are not aware of who is publishing
    on the radio. They only know they have to subscribe to *98.7*; they don’t know
    what’s behind it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，电话、收音机和汽车并不知道谁在广播。它们只知道它们需要订阅 *98.7*；它们不知道背后是什么。
- en: On the other side, both radio transmitters are not aware of each other and of
    who is receiving the data. They just publish on the topic, regardless of who is
    listening. Thus, we say that topics are **anonymous**. Publishers and subscribers
    are not aware of other publishers and subscribers. They only publish or subscribe
    to a topic, using its name and interface.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一边，两个无线电发射台并不知道彼此以及谁在接收数据。它们只是在主题上发布，不管谁在收听。因此，我们说主题是 **匿名的**。发布者和订阅者并不知道其他发布者和订阅者。他们只通过名称和接口发布或订阅主题。
- en: Any combination of publishers and subscribers is possible. For example, you
    could have two publishers on the topic and zero subscribers. In this case, the
    data is still correctly published, but no one receives it. Alternatively, you
    could have zero publishers and one or more subscribers. The subscribers will listen
    to the topic but will receive nothing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者和订阅者的任何组合都是可能的。例如，你可以在一个主题上有两个发布者而没有订阅者。在这种情况下，数据仍然被正确发布，但没有人为其接收。或者，你也可以有零个发布者和一个或多个订阅者。订阅者将监听主题，但不会收到任何内容。
- en: Multiple publishers and subscribers inside one node
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个节点内部有多个发布者和订阅者
- en: A node is not limited to having just one publisher or one subscriber.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 节点不仅限于只有一个发布者或一个订阅者。
- en: Let’s add another radio to our example. We will name it *101.3*, and its data
    type is FM signal.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的例子中添加另一个无线电。我们将命名为*101.3*，其数据类型为FM信号。
- en: 'The second radio transmitter is now publishing both on the *98.7* topic and
    the *101.3* topic, sending the appropriate type of data for each topic. Let’s
    also make the car listen to the *101.3* topic:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个无线电发射器现在同时在*98.7*主题和*101.3*主题上发布，为每个主题发送适当类型的数据。让我们也让汽车监听*101.3*主题：
- en: '![Figure 5.5 – A node with two publishers](img/B22403_05_5.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 具有两个发布者的节点](img/B22403_05_5.jpg)'
- en: Figure 5.5 – A node with two publishers
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 具有两个发布者的节点
- en: As you can see, the second radio transmitter can publish on several topics,
    so long as it uses the correct name and interface for each topic.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，第二个无线电发射器可以在多个主题上发布，只要它为每个主题使用正确的名称和接口。
- en: 'Now, imagine that the car, while listening to the radio, is also sending its
    GPS coordinates to a remote server. We could create a topic named **car_location**,
    and the interface would contain a latitude and a longitude. The car node now contains
    one subscriber to the *98.7* topic, and one publisher to the **car_location**
    topic:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下，当汽车在收听广播的同时，也将它的GPS坐标发送到一个远程服务器。我们可以创建一个名为**car_location**的主题，其接口将包含纬度和经度。汽车节点现在包含一个订阅*98.7*主题的订阅者，和一个发布**car_location**主题的发布者：
- en: '![Figure 5.6 – A node with both a publisher and a subscriber](img/B22403_05_6.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 具有发布者和订阅者的节点](img/B22403_05_6.jpg)'
- en: Figure 5.6 – A node with both a publisher and a subscriber
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 具有发布者和订阅者的节点
- en: In the preceding figure, I have also added another node for the server, represented
    by a computer. The server node will subscribe to the **car_location** topic so
    that it can receive the GPS coordinates. Of course, both the publisher and subscriber
    are using the same interface (latitude and longitude).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我还为服务器添加了另一个节点，用一台计算机表示。服务器节点将订阅**car_location**主题，以便接收GPS坐标。当然，发布者和订阅者都在使用相同的接口（纬度和经度）。
- en: Thus, inside one node, you can have any number of publishers and subscribers
    to different topics with different data types. A node can communicate with several
    nodes at the same time.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在一个节点内部，你可以有任意数量的发布者和订阅者，针对不同主题和不同数据类型。一个节点可以同时与多个节点通信。
- en: Wrapping things up
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: ROS 2 nodes can send messages to other nodes using topics.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 2节点可以使用主题向其他节点发送消息。
- en: Topics are mostly used to send data streams. For example, you could create a
    hardware driver for a camera sensor, and publish images taken from the camera.
    Other nodes can then subscribe to the topic and receive the images. You could
    also publish a stream of commands for a robot to move, and so on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 主题主要用于发送数据流。例如，你可以为相机传感器创建一个硬件驱动程序，并发布从相机拍摄的照片。其他节点可以订阅该主题并接收照片。你也可以发布一个用于机器人移动的命令流，等等。
- en: There are many possibilities for when to use topics, and you will get to know
    more about them as you progress throughout this book.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用主题的可能性有很多，随着你在本书中的进展，你会了解更多关于它们的信息。
- en: 'Here are some important points about how topics work:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于主题如何工作的一些重要点：
- en: A topic is defined by a name and an interface.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题由一个名称和一个接口定义。
- en: A topic name must start with a letter and can be followed by other letters,
    numbers, underscores, tildes, and slashes. For the real-life analogy with radio,
    I used numbers with dots as topic names. Although it made the examples easier,
    this is not valid for ROS 2 topics. To make it valid, instead of *98.7*, we would
    have to create a topic named `radio_98_7`.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题名称必须以字母开头，可以跟其他字母、数字、下划线、波浪符和斜杠。对于与无线电的真实类比，我使用了带点的数字作为主题名称。虽然这使例子更容易理解，但这对于ROS
    2主题是不适用的。为了使其有效，我们不应该使用*98.7*，而应该创建一个名为`radio_98_7`的主题。
- en: Any publisher or subscriber to a topic must use the same interface.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何主题的发布者或订阅者都必须使用相同的接口。
- en: Publishers and subscribers are anonymous. They are not aware of each other;
    they just know they are publishing or subscribing to a topic.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者和订阅者是匿名的。它们不知道彼此；它们只知道它们正在发布或订阅一个主题。
- en: A node can contain several publishers and subscribers to different topics.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个节点可以包含多个不同主题的发布者和订阅者。
- en: Now, how do you create a publisher or a subscriber?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如何创建发布者或订阅者？
- en: You will do this by adding some code to your nodes. As you saw previously, you
    can write a Python node using **rclpy** and a C++ node using **rclcpp**. With
    those two libraries, you can create publishers and subscribers directly in your
    nodes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过向你的节点添加一些代码来完成这项工作。正如你之前看到的，你可以使用**rclpy**编写Python节点，使用**rclcpp**编写C++节点。使用这两个库，你可以在你的节点中直接创建发布者和订阅者。
- en: Writing a topic publisher
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写主题发布者
- en: In this section, you’ll write your first ROS 2 publisher. To work on the core
    concepts, we will create a new ROS 2 application and build upon it in the following
    chapters. This application will be super minimalistic so that we can focus on
    the concept we want to learn, nothing else.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将编写你的第一个ROS 2发布者。为了处理核心概念，我们将创建一个新的ROS 2应用程序，并在接下来的章节中在此基础上构建。这个应用程序将非常简约，这样我们就可以专注于我们想要学习的概念，其他什么都不考虑。
- en: What we want to do for now is publish a number on a topic. This topic is new
    and we will *create* it. You don’t really create a topic—you create a publisher
    or a subscriber to that topic. This will automatically create the topic name,
    which will be registered on the graph.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想要做的是就一个主题发布一个数字。这个主题是新的，我们将*创建*它。你实际上并不是创建一个主题——你创建的是对该主题的发布者或订阅者。这将自动创建主题名称，该名称将在图中注册。
- en: To write a publisher, we need a node. We could use the first node we created
    in the previous chapter, but the purpose of the node is not the same. Hence, we
    will create a new node named **number_publisher**. In this node, we will create
    a publisher. As to the topic we want to publish to, we will have to choose a name
    and an interface.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写发布者，我们需要一个节点。我们可以使用上一章中创建的第一个节点，但节点的目的并不相同。因此，我们将创建一个新的节点，命名为**number_publisher**。在这个节点中，我们将创建一个发布者。至于我们想要发布的主题，我们必须选择一个名称和接口。
- en: Now, let’s get started with Python.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始使用Python。
- en: Writing a Python publisher
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Python发布者
- en: To write a publisher, we need to create a node; to create a node, we need a
    package. To make things simple, let’s continue using the **my_py_pkg** package.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写发布者，我们需要创建一个节点；要创建节点，我们需要一个包。为了简化事情，让我们继续使用**my_py_pkg**包。
- en: Creating a node
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个节点
- en: 'Navigate inside the **my_py_pkg** package, create a Python file, and make it
    executable:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在**my_py_pkg**包内部导航，创建一个Python文件，并使其可执行：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, open this file, use the node OOP template (given in [*Chapter 4*](B22403_04.xhtml#_idTextAnchor157)),
    and modify the required fields to give names that make sense:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开这个文件，使用节点OOP模板（在[*第4章*](B22403_04.xhtml#_idTextAnchor157)中给出），并修改所需的字段，以给出有意义的名称：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that you have a **main()** function and a **NumberPublisherNode** class
    for your node, we can create a publisher.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了你的节点的主函数和**NumberPublisherNode**类，我们可以创建一个发布者。
- en: Adding a publisher to the node
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在节点中添加发布者
- en: Where can we create a publisher in this node? We will do that in the constructor.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在哪里可以创建一个发布者？我们将在构造函数中完成这项工作。
- en: 'And before we write the code, we need to ask ourselves a question: what is
    the name and the interface for this topic?'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写代码之前，我们需要问自己一个问题：这个主题的名称和接口是什么？
- en: '**Case 1**: You’re publishing to a topic that already exists (other publishers
    or subscribers on that topic), and then you use the same name and interface'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**情况1**：你正在向一个已存在的主题发布（该主题的其他发布者或订阅者），然后你使用相同的名称和接口'
- en: '**Case 2**: You create a publisher for a new topic (what we are doing now),
    and then you have to choose a name and interface'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**情况2**：你为一个新的主题创建发布者（我们现在正在做），然后你必须选择一个名称和接口'
- en: For the name, let’s keep it simple and use **number**. If we publish a number,
    we can expect to receive this number on a **number** topic. If you were to publish
    a temperature, you could name the topic **temperature**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于名称，让我们保持简单，使用**number**。如果我们发布一个数字，我们可以在**number**主题上期望接收到这个数字。如果你要发布温度，你可以将主题命名为**temperature**。
- en: 'For the interface, you have two choices: use an existing interface or create
    a custom one. To get started, we will use an existing interface. To make this
    easier, I will just tell you what to use; you’ll learn how to find other interfaces
    yourself later.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接口，你有两个选择：使用现有的接口或创建一个自定义接口。为了开始，我们将使用现有的接口。为了使这个过程更简单，我将直接告诉你使用什么；你将在以后自己学习如何找到其他接口。
- en: 'Let’s use **example_interfaces/msg/Int64**. To get more details about what’s
    in the interface, we can run **ros2 interface show <interface_name>** in the Terminal:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用**example_interfaces/msg/Int64**。要获取接口中包含的更多详细信息，我们可以在终端中运行**ros2 interface
    show <interface_name>**：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Great—this is exactly what we need: an **int64** number.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——这正是我们需要的：一个**int64**数字。
- en: 'Now that we have this information, let’s create the publisher. First, import
    the interface, and then create the publisher in the constructor:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这些信息，让我们创建发布者。首先，导入接口，然后在构造函数中创建发布者：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To import the interface, we must specify the name of the package (**example_interfaces**),
    then the folder name for topic messages (**msg**), and finally the class for the
    interface (**Int64**).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入接口，我们必须指定包的名称（**example_interfaces**），然后是主题消息的文件夹名称（**msg**），最后是接口的类（**Int64**）。
- en: 'To create the publisher, we must use the **create_publisher()** method from
    the **Node** class. Inheriting from this class gives us access to all ROS 2 functionalities.
    In this method, you have to provide three arguments:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建发布者，我们必须使用**Node**类的**create_publisher()**方法。从该类继承使我们能够访问所有ROS 2功能。在这个方法中，你必须提供三个参数：
- en: '`Int64` from the `example_interfaces` package.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自`example_interfaces`包的`Int64`。
- en: '`number`.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number`。'
- en: '`10` every time.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次使用`10`。
- en: With this, we now have a publisher on the **number** topic. However, if you
    just run your code like this, nothing will happen. A publisher won’t publish automatically
    on a topic. You have to write the code for that to happen.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们现在在**number**主题上有一个发布者。然而，如果你只是这样运行你的代码，什么也不会发生。发布者不会自动在主题上发布。你必须编写代码来实现这一点。
- en: Publishing with a timer
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用计时器发布
- en: A common behavior in robotics is to do *X* action every *Y* seconds—for example,
    publish an image from a camera every **0.5** seconds, or in this case, publish
    a number on a topic every **1.0** second. As seen in [*Chapter 4*](B22403_04.xhtml#_idTextAnchor157),
    to do this, you must implement a timer and a callback function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器人技术中，一个常见的做法是每**Y**秒执行**X**个动作——例如，每**0.5**秒从摄像头发布一张图像，或者在这种情况下，每**1.0**秒在主题上发布一个数字。如[第4章](B22403_04.xhtml#_idTextAnchor157)中所示，为了做到这一点，你必须实现一个计时器和回调函数。
- en: 'Modify the code inside the node so that you publish on the topic from a timer
    callback:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 修改节点内的代码，以便在计时器回调中发布到主题：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After creating the publisher with **self.create_publisher()**, we create a timer
    with **self.create_timer()**. Here, we say that we want the **publish_number()**
    method to be called every **1.0** second. This will happen when the node is spinning.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用**self.create_publisher()**创建发布者后，我们使用**self.create_timer()**创建一个计时器。在这里，我们说我们希望每**1.0**秒调用一次**publish_number()**方法。这将在节点旋转时发生。
- en: On top of that, I also added a log at the end of the constructor to say that
    the node has been started. I usually do this as a best practice so that I can
    see when the node is fully initialized on the Terminal.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我在构造函数的末尾添加了一个日志，说明节点已启动。我通常这样做作为最佳实践，这样我就可以在终端上看到节点何时完全初始化。
- en: 'In the **publish_number()** method, we publish on the topic:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在**publish_number()**方法中，我们在主题上发布：
- en: We create an object from the `Int64` class. This is the interface—in other words,
    the message to send.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`Int64`类创建一个对象。这就是接口——换句话说，是要发送的消息。
- en: This object contains a `data` field. How do we know this? We found this previously
    when we ran `ros2 interface show example_interfaces/msg/Int64`. Thus, we provide
    a number in the `data` field of the message. For simplicity, we specify the same
    number every time we run the callback function.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此对象包含一个`data`字段。我们是如何知道这个的？我们之前在运行`ros2 interface show example_interfaces/msg/Int64`时找到了这个。因此，我们在消息的`data`字段中提供一个数字。为了简单起见，我们每次运行回调函数时都指定相同的数字。
- en: We publish the message using the `publish()` method from the publisher.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用发布者的`publish()`方法发布消息。
- en: This code structure is super common in ROS 2\. Any time you want to publish
    data from a sensor, you will write something similar.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代码结构在ROS 2中非常常见。每次你想从传感器发布数据时，你都会编写类似的内容。
- en: Building the publisher
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建发布者
- en: To try your code, you need to install the node.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试你的代码，你需要安装节点。
- en: 'Before we do this, since we’re using a new dependency (**example_interfaces**
    package), we also need to add one line to the **package.xml** file of the **my_py_pkg**
    package:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做之前，由于我们使用了一个新的依赖项（**example_interfaces** 包），我们还需要向 **my_py_pkg** 包的 **package.xml**
    文件中添加一行：
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you add more functionalities inside your package, you will add any other
    ROS 2 dependency here.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您在包内添加更多功能，您将在这里添加任何其他 ROS 2 依赖项。
- en: 'To install the node, open the **setup.py** file from the **my_py_pkg** package
    and add a new line to create another executable:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装节点，打开 **my_py_pkg** 包中的 **setup.py** 文件并添加一行以创建另一个可执行文件：
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Make sure you add a comma between each line; otherwise, you could encounter
    some strange errors when building the package.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在每一行之间添加一个逗号；否则，在构建包时可能会遇到一些奇怪的错误。
- en: Here, we’ve created a new executable named **number_publisher**.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 **number_publisher** 的新可执行文件。
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'This time, as you can see from this example, the node name, filename, and executable
    name are the same: `number_publisher`. This is a common thing to do. Just remember
    that those names represent three different things.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，如您从这个示例中看到的那样，节点名称、文件名和可执行文件名是相同的：`number_publisher`。这是一件常见的事情。只需记住，这些名称代表三件不同的事情。
- en: 'Now, go to your workspace root directory and build the **my_py_pkg** package:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前往您的工作空间根目录并构建 **my_py_pkg** 包：
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can add **--symlink-install** if you want to, so that you don’t need to
    run **colcon build** every time you modify the **number_publisher** node.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想，可以添加 **--symlink-install**，这样您就不需要每次修改 **number_publisher** 节点时都运行 **colcon
    build**。
- en: Running the publisher
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行发布者
- en: 'After the package has been built successfully, source your workspace and start
    the node:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在包成功构建后，源工作空间并启动节点：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The node is running, but apart from the initial log, nothing is displayed. That’s
    normal—we didn’t ask the node to print anything else.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 节点正在运行，但除了初始日志外，没有显示任何内容。这是正常的——我们没有要求节点打印其他任何内容。
- en: How do we know that the publisher is working? We could write a subscriber node
    right away and see if we receive the messages. But before we do that, we can test
    the publisher directly from the Terminal.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道发布者正在工作？我们可以立即编写一个订阅者节点并查看我们是否收到消息。但在我们这样做之前，我们可以直接从终端测试发布者。
- en: 'Open a new Terminal window and list all topics:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口并列出所有主题：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, you can find the **/****number** topic.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以找到 **/****number** 主题。
- en: Note
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As you can see, there is an added leading slash in front of the topic name.
    We only wrote `number` in the code, not `/number`. This is because ROS 2 names
    (nodes, topics, and so on) are organized inside namespaces. Later, we will see
    that you can add a namespace to put all your topics or nodes inside the `/abc`
    namespace, for example. In this case, the topic name would be `/abc/number`. Here,
    as no namespace is provided, a leading slash is added to the name, even if we
    don’t provide it in the code. We could call this the *global* namespace.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，主题名称前增加了一个前置斜杠。我们在代码中只写了 `number`，而不是 `/number`。这是因为 ROS 2 名称（节点、主题等）是在命名空间内组织的。稍后，我们将看到您可以为所有主题或节点添加一个命名空间，例如放入
    `/abc` 命名空间中。在这种情况下，主题名称将是 `/abc/number`。在这里，因为没有提供命名空间，所以名称前添加了一个前置斜杠，即使我们在代码中没有提供它。我们可以称这为
    *全局* 命名空间。
- en: 'With the **ros2 topic echo <topic_name>** command, you can subscribe to the
    topic directly from the subscriber and see what’s being published. We will learn
    more about this command later in this chapter:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **ros2 topic echo <topic_name>** 命令，您可以直接从订阅者订阅主题并查看正在发布的内容。我们将在本章后面了解更多关于这个命令的信息：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, we get one new message per second, which contains a **data**
    field with a value of **2**. This is exactly what we wanted to do in the code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们每秒得到一条新消息，其中包含一个值为 **2** 的 **data** 字段。这正是我们在代码中想要做的。
- en: With that, we’ve finished our first Python publisher. Let’s switch to C++.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了我们的第一个 Python 发布者。让我们切换到 C++。
- en: Writing a C++ publisher
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 C++ 发布者
- en: Here, the process is the same as for Python. We will create a new node, and
    in this node, add a publisher and a timer. In the timer callback function, we
    will create a message and publish it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，过程与 Python 相同。我们将创建一个新的节点，并在该节点中添加一个发布者和计时器。在计时器回调函数中，我们将创建一个消息并发布它。
- en: I will go a bit more quickly in this section as the explanations are the same.
    We will just focus on the specificities of the C++ syntax with ROS 2.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我会在这一节中稍微快一点，因为解释是相同的。我们只需关注 ROS 2 中 C++ 语法的具体性。
- en: Note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For everything related to C++ in this book, make sure you follow the explanations
    using the GitHub code on the side. I may not provide the full code, only the important
    snippets that are crucial for comprehension.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中与C++相关的所有内容，请确保你遵循使用GitHub代码旁边的解释。我可能不会提供完整的代码，只提供对理解至关重要的重要片段。
- en: Creating a node with a publisher and a timer
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个带有发布者和计时器的节点
- en: 'First, let’s create a new file for our **number_publisher** node in the **my_cpp_pkg**
    package:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在**my_cpp_pkg**包中为我们的**number_publisher**节点创建一个新的文件：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Open this file and write the code for the node. You can start from the OOP
    template and add the publisher, timer, and callback function. The complete code
    for this chapter can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 打开这个文件并编写节点的代码。你可以从OOP模板开始，添加发布者、计时器和回调函数。本章的完整代码可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch)。
- en: 'I will now comment on a few important lines:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在将对几行重要的代码进行注释：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To include an interface for a topic, use **"<package_name>/msg/<message_name>.hpp"**.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含一个主题的接口，使用**"<package_name>/msg/<message_name>.hpp"**。
- en: 'Then, in the constructor, add the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在构造函数中添加以下内容：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In C++, we also use the **create_publisher()** method from the **Node** class.
    The syntax is a bit different since templates are used, but you can still find
    the topic interface, topic name, and queue size (as a reminder, you can set it
    to **10** every time).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，我们也使用**Node**类的**create_publisher()**方法。由于使用了模板，语法略有不同，但你仍然可以找到主题接口、主题名称和队列大小（作为提醒，你可以每次都设置为**10**）。
- en: 'The publisher is also declared as a private attribute in the class:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者也在类中声明为私有属性：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we use the **rclcpp::Publisher** class, and as for many things
    in ROS 2, we use a shared pointer. For several common classes, ROS 2 provides**::SharedPtr**,
    which would be the same thing as writing **std::shared_ptr<the publisher>**.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用了**rclcpp::Publisher**类，对于ROS 2中的许多事物，我们使用共享指针。对于几个常见的类，ROS 2提供了**::SharedPtr**，这和写**std::shared_ptr<the
    publisher>**是同一回事。
- en: 'Let’s go back to the constructor:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到构造函数：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After creating the publisher, we create a timer to call the **publishNumber**
    method every **1.0** second. Finally, we print a log so that we know that the
    constructor code has been executed:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建发布者之后，我们创建一个计时器，每**1.0**秒调用一次**publishNumber**方法。最后，我们打印一条日志，以便我们知道构造函数代码已被执行：
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is the callback method. As for Python, we create an object from the interface
    class, after which we fill any field from this interface and publish the message.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是回调方法。至于Python，我们从接口类创建一个对象，然后填充这个接口的任何字段并发布消息。
- en: Building and running the publisher
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建和运行发布者
- en: Once you’ve written the node with the publisher, timer, and callback function,
    it’s time to build it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你写好了带有发布者、计时器和回调函数的节点，就是时候构建它了。
- en: 'As we did for Python, open the **package.xml** file of the **my_cpp_pkg** package
    and add one line for the dependency to **example_interfaces**:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对Python所做的那样，打开**my_cpp_pkg**包的**package.xml**文件，并为**example_interfaces**依赖项添加一行：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, open the **CMakeLists.txt** file from the **my_cpp_pkg** package and
    add the following lines:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从**my_cpp_pkg**包中打开**CMakeLists.txt**文件并添加以下行：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For any new dependency, we need to add a new **find_package()** line.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何新的依赖项，我们需要添加一个新的**find_package()**行。
- en: Then, we create a new executable. Note that we also provide **example_interfaces**
    in the arguments of **ament_target_dependencies()**. If you omit this, you will
    get an error during compilation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个新的可执行文件。请注意，我们还在**ament_target_dependencies()**的参数中提供了**example_interfaces**。如果你省略了这个，你将在编译时遇到错误。
- en: Finally, there’s no need to re-create the **install()** block. Just add the
    executable in a new line, without any commas between the lines.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，没有必要重新创建**install()**块。只需在新的一行中添加可执行文件，行与行之间不要有任何逗号。
- en: 'Now, you can build, source, and run:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以构建、源和运行：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The node containing the publisher is up and running. By using **ros2 topic list**
    and **ros2 topic echo <topic_name>**, you can find the topic and see what’s being
    published.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 包含发布者的节点正在运行。通过使用**ros2 topic list**和**ros2 topic echo <topic_name>**，你可以找到主题并查看正在发布的内容。
- en: Now that you’ve created a publisher and you know it’s working, it’s time to
    learn how to create a subscriber for that topic.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个发布者并且知道它在工作，是时候学习如何为该主题创建一个订阅者了。
- en: Writing a topic subscriber
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写主题订阅者
- en: To continue improving our application, let’s create a new node that will subscribe
    to the **/number** topic. Each number that’s received will be added to a counter.
    We want to print the counter every time it’s updated.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续改进我们的应用程序，让我们创建一个新的节点，该节点将订阅**/number**主题。接收到的每个数字都将添加到计数器中。我们希望在计数器更新时打印计数器。
- en: As we did previously, let’s start the full explanations with Python, and then
    see the syntax specificities with C++.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所做的那样，让我们先用Python进行完整解释，然后看看C++的语法特性。
- en: Writing a Python subscriber
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Python订阅者
- en: You can find the complete code for this Python node on GitHub. Many things we
    need to do here are identical to what we did previously, so I won’t fully detail
    every step. Instead, we will focus on the most important things so that we can
    write the subscriber.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到这个Python节点的完整代码。这里我们需要做的许多事情与之前所做的相同，所以我不将每一步都详细说明。相反，我们将关注最重要的事情，以便我们可以编写订阅者。
- en: Creating a Python node with a subscriber
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建具有订阅者的Python节点
- en: 'Create a new node named **number_counter** inside the **my_py_pkg** package:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在**my_py_pkg**包内创建一个名为**number_counter**的新节点：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this file, you can write the code for the node and add a subscriber. Here’s
    the explanation, step by step:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，你可以编写节点的代码并添加一个订阅者。以下是逐步解释：
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since we want to create a subscriber to receive what we sent with the publisher,
    we need to use the same interface. Hence, we import **Int64** as well. Then, we
    can create the subscriber:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要创建一个订阅者来接收我们通过发布者发送的内容，因此我们需要使用相同的接口。因此，我们也导入**Int64**。然后，我们可以创建订阅者：
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As for publishers, we will create subscribers in the node’s constructor. Here,
    we use the **create_subscription()** method from the **Node** class. With this
    method, you need to provide four arguments:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于发布者，我们将在节点的构造函数中创建订阅者。在这里，我们使用**Node**类的**create_subscription()**方法。使用此方法时，你需要提供四个参数：
- en: '`Int64`. This needs to be the same for both the publisher and subscriber.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int64`。这需要发布者和订阅者都相同。'
- en: '`number`. This is the same name as for the publisher. Note that I don’t provide
    any additional slash here. This will be added automatically, so the topic name
    will become `/number`.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number`。这与发布者的名称相同。注意，我这里没有提供任何额外的斜杠。这将被自动添加，因此主题名称将是`/number`。'
- en: '`/number` topic, it will be received here, and we will be able to use it and
    process it inside the callback method (that we need to implement).'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当接收到**/number**主题时，它将在这里被接收，我们将在回调方法（我们需要实现的方法）内部使用它和处理它。
- en: '`10` and forget about it for now.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10`并暂时忘记它。'
- en: 'Now, let’s see the implementation for the callback method, which I named **callback_number**:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看回调方法的实现，我将它命名为**callback_number**：
- en: Note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As a best practice, I recommend naming callback methods for topics `callback_<topic>`.
    By adding the `callback_` prefix, you make it clear that this method is a callback
    and shouldn’t be called directly in the code. This can prevent lots of errors
    in the future.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，我建议为主题命名回调方法为`callback_<topic>`。通过添加`callback_`前缀，你可以清楚地表明这是一个回调方法，不应该在代码中直接调用。这可以防止未来出现许多错误。
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In a subscriber callback, you receive the message directly in the parameters
    of the function. Since we know that **Int64** contains a **data** field, we can
    access it with **msg.data**.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在订阅者回调中，你直接在函数的参数中接收消息。由于我们知道**Int64**包含一个**data**字段，我们可以使用**msg.data**来访问它。
- en: Now, we add the received number to a **counter_** attribute and print the counter
    every time with a ROS 2 log.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将接收到的数字添加到**counter_**属性中，并使用ROS 2日志在每次更新时打印计数器。
- en: Note
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As a best practice, I have specified the `Int64` type for the `msg` argument
    of the method. This isn’t mandatory for Python code to work, but it adds an extra
    level of safety (we are sure that we should receive `Int64` and nothing else)
    and it can sometimes make your IDE work better with auto-completion.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，我已经指定了方法的`msg`参数的`Int64`类型。这对于Python代码工作不是强制性的，但它增加了额外的安全级别（我们确信我们应该接收`Int64`而不是其他任何东西），有时它可以使你的IDE在自动完成时工作得更好。
- en: To finish the node, don’t forget to add the **main()** function after the **NumberCounterNode**
    class.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成节点，别忘了在**NumberCounterNode**类之后添加**main()**函数。
- en: Running the Python subscriber
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行Python订阅者
- en: 'Now, to try the code, add a new executable to the **setup.py** file of your
    Python package:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了尝试代码，向你的Python包的**setup.py**文件中添加一个新的可执行文件：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then, build the package and source the workspace (from now on, I will not write
    those commands every time since they’re always the same).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，构建包并源码化工作空间（从现在起，我将不会每次都写这些命令，因为它们总是相同的）。
- en: 'Now, run each node (**number_publisher** and **number_counter**) in a different
    Terminal:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在不同的终端中运行每个节点（**number_publisher** 和 **number_counter**）。
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, the **number_counter** node adds **2** to the counter every
    **1.0** second. If you see this, then the publish/subscribe communication between
    your two nodes is working.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，**number_counter** 节点每 **1.0** 秒将 **2** 添加到计数器中。如果你看到这个，那么你两个节点之间的发布/订阅通信是正常工作的。
- en: You can start and stop the **number_publisher** node and see that every time
    you start it, **number_counter** continues to add numbers from the current count.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以启动和停止 **number_publisher** 节点，并看到每次启动它时，**number_counter** 都会从当前计数继续添加数字。
- en: Writing a C++ subscriber
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 C++ 订阅者
- en: Let’s create the **number_counter** node in C++. The principle is the same,
    so let’s just focus on the syntax here.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 C++ 中创建一个 **number_counter** 节点。原理是相同的，所以我们只需关注这里的语法。
- en: Creating a C++ node with a subscriber
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个具有订阅者的 C++ 节点
- en: 'Create a new file for your node:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的节点创建一个新文件：
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Open this file and write the code for the node (once again, the complete code
    is on GitHub).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 打开此文件并编写节点的代码（再次提醒，完整的代码在 GitHub 上）。
- en: 'To create a subscriber in your node, run the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的节点中创建一个订阅者，请运行以下代码：
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We find the same components as for Python (but in a different order): topic
    interface, topic name, queue size, and callback for received messages. For **_1**
    to work, don’t forget to add **using namespace std::placeholders;** before it.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了与 Python 相同的组件（但顺序不同）：主题接口、主题名称、队列大小和接收消息的回调。为了 **_1** 能正常工作，别忘了在它之前添加
    **using namespace std::placeholders;**。
- en: Note
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Even if the `rclpy` and `rclcpp` libraries are supposed to be based on the same
    underlying code, there can still be some differences in the API. Don’t worry if
    the code sometimes doesn’t look the same between Python and C++.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `rclpy` 和 `rclcpp` 库应该基于相同的底层代码，API 之间仍然可能存在一些差异。如果代码有时在 Python 和 C++ 之间看起来不同，请不要担心。
- en: 'The subscriber object is declared as a private attribute:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者对象被声明为一个私有属性：
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We use the **rclcpp::Subscription** class here, and once again, we create a
    shared pointer to that object.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的是 **rclcpp::Subscription** 类，并且再次创建了一个指向该对象的智能指针。
- en: 'We then have the callback method, **callbackNumber**:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有回调方法，**callbackNumber**：
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The message we receive in the callback is also a (**const**) shared pointer.
    Hence, don’t forget to use **->** when accessing the **data** field.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调中接收到的消息也是一个（**const**）智能指针。因此，在访问 **data** 字段时，别忘了使用 **->**。
- en: In this callback, we add the received number to the counter and print it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个回调中，我们将接收到的数字添加到计数器中并打印出来。
- en: Running the C++ subscriber
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行 C++ 订阅者
- en: 'Create a new executable for that node. Open **CMakeLists.txt** and add the
    following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为该节点创建一个新的可执行文件。打开 **CMakeLists.txt** 并添加以下代码：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Then, build **my_cpp_pkg**, source the workspace, and run both the publisher
    and the subscriber node in different Terminals. You should see a similar output
    to what we had with Python.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，构建 **my_cpp_pkg**，源码化工作空间，并在不同的终端中运行发布者和订阅者节点。你应该会看到与使用 Python 时类似的输出。
- en: Running the Python and C++ nodes together
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同时运行 Python 和 C++ 节点
- en: We’ve just created a publisher and subscriber for both Python and C++. The topic
    we use has the same name (**number**) and interface (**example_interfaces/msg/Int64**).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚为 Python 和 C++ 都创建了一个发布者和订阅者。我们使用的主题具有相同的名称（**number**）和接口（**example_interfaces/msg/Int64**）。
- en: If the topic is the same, it means that you could start the Python **number_publisher**
    node with the C++ **number_counter** node, for example.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主题相同，这意味着你可以用 C++ 的 **number_counter** 节点启动 Python 的 **number_publisher**
    节点，例如。
- en: 'Let’s verify that:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证一下：
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can also try the opposite by running the C++ **number_publisher** node with
    the Python **number_counter** node.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以尝试相反的操作，通过运行 C++ 的 **number_publisher** 节点与 Python 的 **number_counter**
    节点。
- en: Why is it working? Simply because ROS 2 is language-agnostic. You could have
    any node written in any (supported) programming language, and this node could
    communicate with all the other nodes in the network, using topics and other ROS
    2 communications.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它会工作？简单来说，因为 ROS 2 是语言无关的。你可以用任何（支持的）编程语言编写任何节点，并且这个节点可以与网络中的所有其他节点通信，使用主题和其他
    ROS 2 通信。
- en: ROS 2 communications happen at a lower level, using **Data Distribution Service**
    (**DDS**). This is the middleware part and is responsible for sending and receiving
    messages between nodes. When you write a Python or C++ node, you are using the
    same DDS functionality, with an API implemented in either **rclpy** or **rclcpp**.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 2通信在较低级别发生，使用**数据分发服务**（**DDS**）。这是中间件部分，负责在节点之间发送和接收消息。当你编写Python或C++节点时，你正在使用相同的DDS功能，API在**rclpy**或**rclcpp**中实现。
- en: I will not go too far with this explanation as it’s quite advanced and not really
    in the scope of this book. If there is just one thing to remember from this, it’s
    that Python and C++ nodes can communicate with each other using ROS 2 communication
    features. You can create some nodes in Python and other nodes in C++; just make
    sure to use the same communication name and interface on both sides.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会对这个解释过于深入，因为它相当高级，并且并不真正属于这本书的范围。如果你从这个中只记住一件事，那就是Python和C++节点可以使用ROS 2通信功能相互通信。你可以在Python中创建一些节点，在C++中创建其他节点；只需确保在两边使用相同的通信名称和接口。
- en: Additional tools to handle topics
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理主题的附加工具
- en: You’ve just written a bunch of nodes containing publishers and subscribers.
    We will now explore how ROS 2 tools can help you do more things with topics.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经编写了一组包含发布者和订阅者的节点。现在我们将探索ROS 2工具如何帮助你使用主题做更多的事情。
- en: 'We will explore the following topics:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索以下主题：
- en: Introspection with `rqt_graph`
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`rqt_graph`进行自省
- en: Introspection and debugging with the `ros2 topic` command line
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ros2 topic`命令行进行自省和调试
- en: Changing a topic name when starting a node
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启动节点时更改主题名称
- en: Replaying topic data with bags
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用bags重放主题数据
- en: Introspecting topics with rqt_graph
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用rqt_graph自省主题
- en: We used **rqt_graph** to visualize nodes in [*Chapter 3*](B22403_03.xhtml#_idTextAnchor092).
    Let’s run it again and see how to introspect the publisher and subscriber we have
    just created.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**rqt_graph**在[*第3章*](B22403_03.xhtml#_idTextAnchor092)中可视化节点。让我们再次运行它，看看如何自省我们刚刚创建的发布者和订阅者。
- en: 'First, start both the **number_publisher** and **number_counter** nodes (from
    any package: **my_py_pkg** or **my_cpp_pkg**).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，启动**number_publisher**和**number_counter**节点（从任何包：**my_py_pkg**或**my_cpp_pkg**）。
- en: 'Then, start **rqt_graph** in another Terminal:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在另一个终端中启动**rqt_graph**：
- en: '[PRE32]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If needed, refresh the view a few times and select **Nodes/Topics (all)**.
    You can also uncheck the **Dead sinks** box and the **Leaf topics** box. This
    will allow you to see topics even if there is just one subscriber and no publisher,
    or one publisher and no subscriber:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，刷新视图几次，并选择**节点/主题（全部）**。你也可以取消选择**死端**框和**叶主题**框。这将允许你看到主题，即使只有一个订阅者没有发布者，或者只有一个发布者没有订阅者：
- en: '![Figure 5.7 – The number topic on rqt_graph](img/B22403_05_7.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7 – rqt_graph上的数字主题](img/B22403_05_7.jpg)'
- en: Figure 5.7 – The number topic on rqt_graph
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – rqt_graph上的数字主题
- en: There, we can see the **number_publisher** node and the **number_counter** node.
    In the middle, we have the **/number** topic, and we can see which node is a publisher
    or a subscriber.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，我们可以看到**number_publisher**节点和**number_counter**节点。中间是**/number**主题，我们可以看到哪个节点是发布者或订阅者。
- en: 'The **rqt_graph** package can be extremely useful when debugging topics. Imagine
    that you run some nodes and you’re wondering why topic messages are not received
    by a subscriber. Maybe those nodes are not using the same topic name. You can
    easily see this with **rqt_graph**:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**rqt_graph**包在调试主题时可以非常有用。想象一下，你运行了一些节点，你想知道为什么主题消息没有被订阅者接收。可能这些节点没有使用相同的主题名称。你可以很容易地用**rqt_graph**看到这一点：'
- en: '![Figure 5.8 – Topic name mismatch between publisher and subscriber](img/B22403_05_8.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8 – 发布者和订阅者之间的主题名称不匹配](img/B22403_05_8.jpg)'
- en: Figure 5.8 – Topic name mismatch between publisher and subscriber
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 发布者和订阅者之间的主题名称不匹配
- en: In this example, I made an intentional error in the topic name inside the publisher.
    Instead of **number**, I have written **numberr**. With **rqt_graph**, I can see
    where the issue is. The two nodes are not communicating with each other.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我在发布者内部的主题名称中故意犯了一个错误。我应该写**number**，但我写了**numberr**。使用**rqt_graph**，我可以看到问题所在。这两个节点没有相互通信。
- en: The ros2 topic command line
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ros2 topic命令行
- en: With **ros2 node**, we get additional command-line tools for nodes. For topics,
    we will use **ros2 topic**.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**ros2 node**，我们为节点获得了额外的命令行工具。对于主题，我们将使用**ros2 topic**。
- en: If you run **ros2 topic -h**, you’ll see that there are quite a lot of commands.
    You already know some of them. Here, I will do a quick recap and explore a few
    more commands that can be useful when debugging topics.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行**ros2 topic -h**，你会看到有很多命令。你已经知道其中的一些。在这里，我将快速回顾一下，并探索一些在调试主题时可能有用的更多命令。
- en: 'First, to list all topics, use **ros2** **topic list**:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要列出所有主题，使用**ros2 topic list**：
- en: '[PRE33]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, we get the **/number** topic. You will also always get **/parameter_events**
    and **/rosout** (all ROS 2 logs are published on this topic).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们得到了**/number**主题。你还会始终得到**/parameter_events**和**/rosout**（所有ROS 2日志都发布在这个主题上）。
- en: 'With **ros2 topic info <topic_name>**, you can get the interface for the topic,
    as well as the number of publishers and subscribers for that topic:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**ros2 topic info <topic_name>**，你可以获取该主题的接口，以及该主题的发布者和订阅者数量：
- en: '[PRE34]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, to go further and see the details for the interface, you can run the
    following command:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了进一步查看接口的详细信息，你可以运行以下命令：
- en: '[PRE35]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With this, we have all the information we need to create an additional publisher
    or subscriber to the topic.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个命令，我们就有了创建附加发布者或订阅者所需的所有信息。
- en: 'On top of that, we can also directly subscribe to the topic from the Terminal
    with **ros2 topic echo <topic_name>**. That’s what we did just after writing the
    publisher so that we can make sure it’s working before we write any subscriber:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以直接使用**ros2 topic echo <topic_name>**从终端订阅主题。这就是我们在编写发布者之后所做的那样，以确保在编写任何订阅者之前它能够正常工作：
- en: '[PRE36]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'On the other hand, you can publish to a topic directly from the Terminal with
    **ros2 topic pub -r <frequency> <topic_name> <interface> <message_in_json>**.
    To test this, stop all nodes, and start only the **number_counter** node in one
    Terminal. Apart from the first log, nothing will be printed. Then, run the following
    command in another Terminal:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你可以直接从终端向主题发布消息，使用**ros2 topic pub -r <frequency> <topic_name> <interface>
    <message_in_json>**。为了测试这个，停止所有节点，并在一个终端中只启动**number_counter**节点。除了第一条日志外，不会打印任何内容。然后，在另一个终端中运行以下命令：
- en: '[PRE37]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will publish on the **/number** topic at **2.0** Hertz (every **0.5**
    seconds). When you run this, you’ll see some logs on the **number_counter** node,
    meaning that the messages have been received:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在**/number**主题上以**2.0**赫兹（每**0.5**秒）发布。当你运行这个命令时，你会在**number_counter**节点上看到一些日志，这意味着消息已经被接收：
- en: '[PRE38]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This way, you can test a subscriber without having to write a publisher first.
    Note that this only really works for topics with a simple interface. When the
    interface contains too many fields, it becomes too complicated to write everything
    on the Terminal.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以在不先写一个发布者的情况下测试一个订阅者。请注意，这仅适用于具有简单接口的主题。当接口包含太多字段时，在终端上写所有内容会变得过于复杂。
- en: Note
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Both `ros2 topic echo` and `ros2 topic pub` can save you lots of time, and it’s
    also great for collaborating with other people on a project. You could be responsible
    for writing a publisher, and someone else would write a subscriber. With those
    command-line tools, both of you can make sure the topic communication is working.
    Then, when you run the two nodes together, you know that the data you send or
    receive is correct.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`ros2 topic echo`和`ros2 topic pub`都可以节省你很多时间，这对于与其他人合作进行项目也非常有用。你可以负责编写发布者，而其他人则编写订阅者。使用这些命令行工具，你们两个人都可以确保主题通信正常工作。然后，当你一起运行这两个节点时，你知道你发送或接收的数据是正确的。'
- en: Changing a topic name at runtime
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在运行时更改主题名称
- en: In [*Chapter 4*](B22403_04.xhtml#_idTextAnchor157), you learned how to change
    a node name at runtime—that is, by adding **--ros-args -r __node:=<new_name>**
    after the **ros2** **run** command.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B22403_04.xhtml#_idTextAnchor157)中，你学习了如何在运行时更改节点名称——即通过在**ros2 run**命令后添加**--ros-args
    -r __node:=<new_name>**。
- en: So, for any additional argument you pass after **ros2 run**, add **--ros-args**,
    but only once.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`ros2 run`之后传递的任何附加参数，都添加`**--ros-args**`，但只需添加一次。
- en: Then, you can also change a topic name at runtime. To do that, add another **-r**,
    followed by **<topic_name>:=<new_topic_name>**.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你还可以在运行时更改主题名称。为此，添加另一个**-r**，后跟**<topic_name>:=<new_topic_name>**。
- en: 'For example, let’s rename our topic from **number** to **my_number**:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们将我们的主题从**number**重命名为**my_number**：
- en: '[PRE39]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, if we start the **number_counter** node, to be able to receive the messages,
    we also need to modify the topic name:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们启动**number_counter**节点，为了能够接收消息，我们还需要修改主题名称：
- en: '[PRE40]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With this, the communication will work, but this time using the **my_number**
    topic.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个命令，通信将正常工作，但这次使用的是**my_number**主题。
- en: 'To make things a bit more interesting, let’s keep those two nodes running,
    and let’s run another publisher to this topic, using the same **number_publisher**
    node. As you know, we can’t have two nodes running with the same name. Thus, we
    will have to rename both the node and the topic. In a third Terminal, run the
    following code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让事情更有趣，让我们让这两个节点继续运行，并运行另一个发布者到这个主题，使用相同的**number_publisher**节点。正如你所知，我们不能有两个节点使用相同的名称。因此，我们必须重命名节点和主题。在第三个终端中，运行以下代码：
- en: '[PRE41]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: After you run this, you’ll see that the **number_counter** receives messages
    twice as fast since there are two nodes publishing one message every **1.0** second.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，你会发现**number_counter**接收消息的速度是原来的两倍，因为有两个节点每**1.0**秒发布一条消息。
- en: 'On top of that, let’s start **rqt_graph**:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们启动**rqt_graph**：
- en: '![Figure 5.9 – Two publishers and a subscriber, with a renamed topic](img/B22403_05_9.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9 – 两个发布者和一个订阅者，主题已重命名](img/B22403_05_9.jpg)'
- en: Figure 5.9 – Two publishers and a subscriber, with a renamed topic
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – 两个发布者和一个订阅者，主题已重命名
- en: We’ll see that we have two nodes containing a publisher on the **my_number**
    topic, and one node containing a subscriber.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会看到有两个节点在**my_number**主题上有一个发布者，还有一个节点有一个订阅者。
- en: Changing topic names at runtime will be quite useful for you, especially when
    you want to run several existing nodes that you can’t modify. Even if you can’t
    rewrite the code, you can modify the names at runtime. Now, let’s continue with
    the tools and explore ROS 2 bags.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时更改主题名称将对你非常有用，特别是当你想运行几个无法修改的现有节点时。即使你不能重写代码，你也可以在运行时修改名称。现在，让我们继续使用工具并探索ROS
    2 bags。
- en: Replaying topic data with bags
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用bags回放主题数据
- en: 'Imagine this scenario: you’re working on a mobile robot that’s supposed to
    perform in a certain way when navigating outside and while it’s raining.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 想象这样一个场景：你正在为一个移动机器人工作，该机器人在户外导航时以及下雨时应该以某种方式表现。
- en: 'Now, this means you will need to run the robot in those conditions so that
    you can develop your application. There are a few problems: maybe you won’t have
    access to the robot every time, or you can’t take it outside, or it’s simply not
    raining every day.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这意味着你需要在这些条件下运行机器人，以便你可以开发你的应用程序。有几个问题：你可能不会每次都能接触到机器人，或者你不能将它带出去，或者它并不是每天都下雨。
- en: A solution to this is to use ROS 2 bags. Bags allow you to record a topic and
    replay it later. Thus, you can run the experiment once with the required conditions,
    and then replay the data just like it was recorded. With this data, you can develop
    your application.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是使用ROS 2 bags。Bags允许你记录一个主题并在以后回放它。因此，你可以一次在所需条件下运行实验，然后回放数据，就像它被记录下来一样。有了这些数据，你可以开发你的应用程序。
- en: 'Let’s consider another scenario: you work with a piece of hardware that isn’t
    stable yet. Most of the time, it doesn’t work properly. You could record a bag
    while the hardware is working fine, and then replay this bag to develop your application
    instead of running the hardware again and again and wasting time on this.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个场景：你与一个还不稳定的硬件一起工作。大多数时候，它不能正常工作。你可以在硬件正常工作时记录一个bags，然后回放这个bags来开发你的应用程序，而不是反复运行硬件并浪费时间。
- en: To work with ROS 2 bags, you must use the **ros2 bag** command-line tool. Let’s
    learn how to save and replay a topic with bags.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用ROS 2 bags，你必须使用**ros2 bag**命令行工具。让我们学习如何使用bags保存和回放一个主题。
- en: First, stop all nodes and run the **number_publisher** node only.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，停止所有节点，只运行**number_publisher**节点。
- en: 'We already know that the topic name is **/number**. You can retrieve that with
    **ros2 topic list** if needed. Then, in another Terminal, record the bag with
    **ros2 bag record <list of topics> -o <bag_name>**. To make things more organized,
    I suggest that you create a **bags** folder and record from within this folder:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道主题名称是**/number**。如果需要，你可以使用**ros2 topic list**检索它。然后，在另一个终端中，使用**ros2
    bag record <list of topics> -o <bag_name>**记录bags。为了使事情更有条理，我建议你创建一个**bags**文件夹，并在该文件夹内进行记录：
- en: '[PRE42]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'At this point, the bag is recording and saving all incoming messages inside
    a database. Let it run for a few seconds, then stop it with *Ctrl* + *C*:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，bags正在记录并保存数据库中所有传入的消息。让它运行几秒钟，然后使用*Ctrl* + *C*停止它：
- en: '[PRE43]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The **ros2 bag** command will exit, and you’ll end up with a new directory named
    **bag1**. In this directory, you will find a **.mcap** file containing the recorded
    messages and a YAML file with more information. If you open this YAML file, you’ll
    see the recorded duration, number of recorded messages, and topics that were recorded.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**ros2 bag** 命令将退出，你将得到一个名为 **bag1** 的新目录。在这个目录中，你会找到一个包含记录消息的 **.mcap** 文件和一个包含更多信息的
    YAML 文件。如果你打开这个 YAML 文件，你会看到记录的持续时间、记录的消息数量和记录的主题。'
- en: Now, you can replay the bag, which means you’ll publish on the topic exactly
    like it was done when recording.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以回放数据包，这意味着你将按照记录时的方式在主题上发布。
- en: 'Stop the **number_publisher** node and replay the bag with **ros2 bag** **play
    <path_to_bag>**:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 停止 **number_publisher** 节点，并使用 **ros2 bag play <path_to_bag>** 回放数据包：
- en: '[PRE44]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will publish all the recorded messages, with the same duration as the recording.
    So, if you record for 3 minutes and 14 seconds, the bag will replay the topic
    for 3 minutes and 14 seconds. Then, the bag will exit, and you can play it again
    if you want.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发布所有记录的消息，持续时间与记录相同。所以，如果你记录了3分14秒，数据包将回放主题3分14秒。然后，数据包将退出，如果你想再次播放，可以继续播放。
- en: While the bag is playing, you can run your subscriber(s). You can do a quick
    test with **ros2 topic echo /number** and see the data. You can also run your
    **number_counter** node, and you will see that the messages are received.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据包播放时，你可以运行你的订阅者。你可以使用 **ros2 topic echo /number** 来进行快速测试并查看数据。你还可以运行你的 **number_counter**
    节点，你会看到消息被接收。
- en: You are now able to save and replay a topic using ROS 2 bags. You can explore
    more advanced options with **ros2** **bag -h**.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用 ROS 2 数据包来保存和回放一个主题。你可以使用 **ros2 bag -h** 来探索更多高级选项。
- en: As you’ve seen, there are quite a few available tools for topics. Use these
    tools as often as possible to introspect, debug, and test your topics. They will
    save you lots of time when you’re developing your ROS 2 application.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，有很多可用的工具用于主题。尽可能多地使用这些工具来检查、调试和测试你的主题。它们将在你开发 ROS 2 应用程序时为你节省大量时间。
- en: We’re almost done with topics. So far, all we’ve done is use existing interfaces.
    Now, let’s learn how to create a custom interface.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了主题的学习。到目前为止，我们所做的一切都是使用现有接口。现在，让我们学习如何创建一个自定义接口。
- en: Creating a custom interface for a topic
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为主题创建自定义接口
- en: When creating a publisher or subscriber for a topic, you know that you have
    to use a name and an interface.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当为主题创建发布者或订阅者时，你知道你必须使用一个名称和一个接口。
- en: 'It’s quite easy to publish or subscribe to an existing topic: you’ll find the
    name and interface using the **ros2** command line, and use that in your code.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 发布或订阅现有主题非常简单：你将使用 **ros2** 命令行找到名称和接口，并在你的代码中使用它。
- en: 'Now, if you want to start a publisher or subscriber for a new topic, you will
    need to choose a name and interface by yourself:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你想为一个新的主题启动发布者或订阅者，你需要自己选择名称和接口：
- en: '**Name**: No problem—it’s just a chain of characters'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：没问题——它只是一系列字符'
- en: '**Interface**: You have two choices—using an existing interface that works
    with your topic or creating a new one'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口**：你有两个选择——使用与你的主题一起工作的现有接口或创建一个新的接口'
- en: Let’s try to apply the ROS 2 philosophy of not reinventing the wheel. When you
    create a new topic, check if there is any existing interface that can match your
    needs. If so, then use it; don’t recreate it.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试应用 ROS 2 的哲学，即不重新发明轮子。当你创建一个新的主题时，检查是否有任何现有的接口可以满足你的需求。如果有，那么就使用它；不要重新创建。
- en: First, you’ll learn where you can find existing interfaces. Then, you’ll learn
    how to create a new one.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你会学习在哪里可以找到现有接口。然后，你会学习如何创建一个新的接口。
- en: Note
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s quite common to use the word *message* when talking about topic interfaces.
    I could have named this section *Creating a custom message*. In the following
    section, when I talk about messages, I’m referring to topic interfaces.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论主题接口时使用“消息”这个词是很常见的。我本可以把这个部分命名为“创建自定义消息”。在接下来的部分中，当我提到消息时，我指的是主题接口。
- en: Using existing interfaces
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用现有接口
- en: Before you start a new publisher or subscriber for a topic, take some time to
    think about what kind of data you want to send or receive. Then, check if an already
    existing interface contains what you need.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在你为主题启动新的发布者或订阅者之前，花点时间思考你想要发送或接收哪种类型的数据。然后，检查是否已经存在的接口包含你所需要的内容。
- en: Where to find interfaces
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口的位置
- en: 'Just like nodes, interfaces are organized in packages. You can find the most
    common packages for ROS 2 interfaces here: [https://github.com/ros2/common_interfaces](https://github.com/ros2/common_interfaces).
    Not all existing interfaces are listed here, but it’s already quite a lot. For
    other interfaces, a simple search on the internet should bring you to the corresponding
    GitHub repository.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 就像节点一样，接口也是按包组织的。您可以在以下位置找到 ROS 2 接口最常见的包：[https://github.com/ros2/common_interfaces](https://github.com/ros2/common_interfaces)。这里并没有列出所有现有的接口，但已经相当多了。对于其他接口，简单的网络搜索应该会带您到相应的
    GitHub 仓库。
- en: In this common interfaces repository, you can find the **Twist** message we
    used with Turtlesim, inside the **geometry_msgs** package. As you can see, for
    topic interfaces, we then have an additional **msg** folder, which contains all
    the message definitions for that package.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个常见的接口仓库中，您可以在 **geometry_msgs** 包中找到我们与 Turtlesim 一起使用的 **Twist** 消息。如您所见，对于主题接口，我们随后有一个额外的
    **msg** 文件夹，其中包含该包的所有消息定义。
- en: Now, let’s say you want to create a driver node for a camera and publish the
    images to a topic. If you look inside the **sensor_msgs** package, and then inside
    the **msg** folder, you’ll find a file named **Image.msg**. This *Image* message
    is probably suitable for your needs. It is also used by a lot of other people,
    so it will even make your life easier.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您想为相机创建一个驱动节点并将图像发布到主题。如果您查看 **sensor_msgs** 包，然后查看 **msg** 文件夹，您会找到一个名为
    **Image.msg** 的文件。这个 *Image* 消息可能适合您的需求。它也被很多人使用，这将使您的生活更加容易。
- en: Using an existing interface in your code
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在您的代码中使用现有接口
- en: 'To use this message, make sure you’ve installed the package that contains the
    message—in this case, **sensor_msgs**. As a quick reminder, to install a ROS 2
    package, you can run **sudo apt** **install ros-<distro>-<package-name>**:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此消息，请确保您已安装包含消息的包——在这种情况下，**sensor_msgs**。作为一个快速提醒，要安装 ROS 2 包，您可以在终端中运行
    **sudo apt install ros-<distro>-<package-name>**：
- en: '[PRE45]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Maybe the package was already installed. If not, source your environment again
    afterward. Then, you can find the details regarding the interface with **ros2
    interface** **show <interface>**:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 可能该包已经安装了。如果没有，安装后再次source您的环境。然后，您可以使用 **ros2 interface show <interface>**
    命令找到有关接口的详细信息：
- en: '[PRE46]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To use this message in your code, just follow what we did in this chapter (with
    the **example_interfaces/msg/Int64** message):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的代码中使用此消息，只需遵循本章中我们所做的那样（使用 **example_interfaces/msg/Int64** 消息）：
- en: In the `package.xml` file of the package where you write your nodes, add the
    dependency to the interface package.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您编写节点的包的 `package.xml` 文件中，添加对接口包的依赖。
- en: In your code, import the message and use it in your publisher or subscriber.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码中导入消息并在发布者或订阅者中使用它。
- en: 'For C++ only: Add the dependency to the interface package in the `CMakeLists.txt`
    file.'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅限 C++：在 `CMakeLists.txt` 文件中将依赖项添加到接口包中。
- en: We will see another example of this process very soon, just after we create
    our interface.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建接口之后，很快我们就会看到这个过程的另一个例子。
- en: At this point, you know how to find and use existing messages in your code.
    But should you always do that?
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经知道如何在代码中查找和使用现有的消息。但您是否应该总是这样做？
- en: When not to use existing messages
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当不使用现有消息时
- en: For common use cases, sensors, and actuators, you will probably find what you
    need. However, if the interface doesn’t match exactly what you want, you will
    have to create a new one.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常见的用例、传感器和执行器，您可能会找到您需要的东西。然而，如果接口与您想要的完全不符，您将不得不创建一个新的接口。
- en: 'There are a few packages containing basic interfaces, such as **example_interfaces**,
    or even **std_msgs**. You could be tempted to use them in your code. As a best
    practice, it’s better to avoid it. Just read the comments from the message definitions
    to be sure of that:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个包包含基本接口，例如 **example_interfaces**，甚至 **std_msgs**。您可能会被诱惑在代码中使用它们。作为一个最佳实践，最好是避免这样做。只需阅读消息定义中的注释以确保这一点：
- en: '[PRE47]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, the **std_msgs** package is deprecated, and **example_interfaces**
    is only recommended to make tests—which is what we’ve done in this chapter so
    far to help us learn various topics.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，**std_msgs** 包已被弃用，而**example_interfaces** 仅推荐用于测试——这正是我们在本章到目前为止所做的一切，以帮助我们学习各种主题。
- en: As a general rule, if you don’t find exactly what you need in the existing interface
    packages, then create your own interface. It’s not hard to do and will always
    be the same process.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，如果您在现有的接口包中没有找到您需要的东西，那么就创建自己的接口。这并不难做，而且总是同一个过程。
- en: Creating a new topic interface
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的主题接口
- en: You will now create your first custom interface for a topic. We will see how
    to set a package up for that, how to create and build the interface, and how to
    use it in our code.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将创建你的第一个针对主题的自定义接口。我们将看到如何为该包设置，如何创建和构建接口，以及如何在我们的代码中使用它。
- en: Creating and setting up an interfaces package
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和设置接口包
- en: Before we create any topic interface (message), we need to create a new package
    and set it up for building interfaces. As a best practice, in your application,
    you will have one package dedicated to custom interfaces. This means that you
    create interfaces only in this package, and you keep this package only for interfaces—no
    nodes or other things, just interfaces. This will make it much easier when you’re
    scaling the application and will help you avoid creating a dependency mess.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建任何主题接口（消息）之前，我们需要创建一个新的包，并为其构建接口设置。作为一个最佳实践，在你的应用程序中，你将有一个专门用于自定义接口的包。这意味着你只在这个包中创建接口，并且你只保留这个包用于接口——没有节点或其他东西，只有接口。这将使你在扩展应用程序时更加容易，并帮助你避免创建依赖混乱。
- en: A common practice when naming this interface package is to start with the name
    of your application or robot and add the **_interfaces** suffix. So, if your robot
    is named **abc**, you should use **abc_interfaces**.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名这个接口包时，一个常见的做法是以你的应用程序或机器人的名称开头，并添加 **_interfaces** 后缀。所以如果你的机器人命名为 **abc**，你应该使用
    **abc_interfaces**。
- en: We don’t have a robot for this example, so let’s just name the package **my_robot_interfaces**.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中我们没有机器人，所以我们只需将包命名为 **my_robot_interfaces**。
- en: 'Create a new package with the **ament_cmake** build type and no dependencies.
    You don’t even need to provide the build type since **ament_cmake** is the one
    used by default. Navigate to the **src** directory of your workspace and create
    this package:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **ament_cmake** 构建类型创建一个新的包，并且没有依赖项。你甚至不需要提供构建类型，因为 **ament_cmake** 是默认使用的。导航到你的工作空间的
    **src** 目录并创建这个包：
- en: '[PRE48]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'At this point, your workspace should contain three packages: **my_py_pkg**,
    **my_cpp_pkg**, and **my_robot_interfaces**.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的工作空间应该包含三个包：**my_py_pkg**、**my_cpp_pkg** 和 **my_robot_interfaces**。
- en: 'We need to set this new package up and modify a few things so it can build
    messages. Go into the package, remove the **src** and **include** directories,
    and create a new **msg** folder:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置这个新包并修改一些设置，以便它可以构建消息。进入包中，删除 **src** 和 **include** 目录，并创建一个新的 **msg**
    文件夹：
- en: '[PRE49]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, open the **package.xml** file for this package. After **<buildtool_depend>ament_cmake</buildtool_depend>**,
    add the following three lines. I recommend that you just copy and paste them so
    that you don’t make any mistakes:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开这个包的 **package.xml** 文件。在 **<buildtool_depend>ament_cmake</buildtool_depend>**
    之后，添加以下三行。我建议你直接复制粘贴，以免出错：
- en: '[PRE50]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With that, the **package.xml** file is complete and you won’t have to do anything
    else with it for now. Open the **CMakeLists.txt** file. After **find_package(ament_cmake
    REQUIRED)**, and before **ament_package()**, add the following lines (you can
    also remove the **if(BUILD_TESTING)** block):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，**package.xml** 文件就完成了，你现在不需要对它做任何事情。打开 **CMakeLists.txt** 文件。在 **find_package(ament_cmake
    REQUIRED)** 之后，在 **ament_package()** 之前，添加以下几行（你也可以删除 **if(BUILD_TESTING)** 块）：
- en: '[PRE51]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: There’s not much to understand about these lines you’re adding. They will find
    some dependencies (**rosidl** packages) and prepare your package so that it can
    build interfaces.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这些你添加的行并没有太多需要理解的。它们将找到一些依赖项（**rosidl** 包），并为你的包准备，以便它可以构建接口。
- en: At this point, your package is ready and you can add new interfaces. You will
    only need to do this setup phase once. At this point, adding a new interface is
    very quick.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的包已经准备好了，你可以添加新的接口。你只需要进行一次这个设置阶段。在这个阶段，添加一个新的接口非常快。
- en: Creating and building a new topic interface
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和构建一个新的主题接口
- en: Let’s say we want to create a publisher to send some kind of hardware status
    for our robot, including the robot version, internal temperature, a flag to know
    if the motors are ready, and a debug message.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个发布者来发送机器人的一些硬件状态，包括机器人版本、内部温度、一个标志来知道电机是否就绪，以及一个调试信息。
- en: 'We’ve looked at existing interfaces and nothing matches. How can you name this
    new interface? Here are the rules you have to follow:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经查看过现有的接口，但没有一个匹配。你该如何命名这个新的接口？以下是你必须遵循的规则：
- en: Use UpperCamelCase—for example, HardwareStatus
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用大驼峰命名法——例如，HardwareStatus
- en: Don’t write `Msg` or `Interface` in the name as this would add unnecessary redundancy
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在名称中使用`Msg`或`Interface`，因为这会增加不必要的冗余
- en: Use `.msg` for the file extension
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.msg` 作为文件扩展名
- en: 'Following these rules, create a new file named **HardwareStatus.msg** in the
    **msg** folder:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这些规则，在**msg**文件夹中创建一个名为**HardwareStatus.msg**的新文件：
- en: '[PRE52]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Inside this file, we can add the definition for the message. Here’s what you
    can use:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们可以添加消息的定义。以下是你可以使用的内容：
- en: 'Built-in types, such as `bool`, `byte`, `int64`, `float64`, and `string`, as
    well as arrays of those types. You can find the complete list here: [https://docs.ros.org/en/rolling/Concepts/Basic/About-Interfaces.html#field-types](https://docs.ros.org/en/rolling/Concepts/Basic/About-Interfaces.html#field-types).'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置类型，如`bool`、`byte`、`int64`、`float64`和`string`，以及这些类型的数组。你可以在这里找到完整的列表：[https://docs.ros.org/en/rolling/Concepts/Basic/About-Interfaces.html#field-types](https://docs.ros.org/en/rolling/Concepts/Basic/About-Interfaces.html#field-types)。
- en: Other existing messages, using the name of the package, followed by the name
    of the message —for example, `geometry_msgs/Twist` (don’t add the `msg` folder
    here).
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他现有消息，使用包名后跟消息名——例如，`geometry_msgs/Twist`（在此处不要添加`msg`文件夹）。
- en: 'To make things simple here, we will start with only built-in types. Write the
    following inside the message file:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们在这里只使用内置类型。在消息文件中写入以下内容：
- en: '[PRE53]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: For each field, we provide the data type, and then the name of the field.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个字段，我们提供数据类型，然后是字段名。
- en: Now, how are we going to build this message? How can we get a Python or C++
    class that we can include and use in our code?
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何构建这个消息？我们如何获取一个Python或C++类，我们可以将其包含并用于我们的代码中？
- en: 'To build the message, you simply have to add one line to **CMakelists.txt**,
    specifying the relative path to the message file:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建消息，你只需在**CMakelists.txt**中添加一行，指定消息文件的相对路径：
- en: '[PRE54]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: For each new interface you build in this package, you will add one line inside
    the **rosidl_generate_interfaces()** function. *Don’t add any commas between*
    *the lines.*
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在这个包中构建的每个新接口，你将在**rosidl_generate_interfaces()**函数内部添加一行。*不要在行之间添加任何逗号*。
- en: 'Now, save all the files and build your new package:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，保存所有文件并构建你的新包：
- en: '[PRE55]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The build system will take the interface definition you’ve written and use
    it to generate source code for Python and C++:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统将使用你编写的接口定义来生成Python和C++的源代码：
- en: '![Figure 5.10 – Build system for interfaces](img/B22403_05_10.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![图5.10 – 接口构建系统](img/B22403_05_10.jpg)'
- en: Figure 5.10 – Build system for interfaces
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 – 接口构建系统
- en: 'Once you’ve built the package, make sure you source the environment. You should
    be able to see your interface from the Terminal (don’t forget to use auto-completion
    to build the command faster and be sure you have the correct name):'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建了包，请确保源环境。你应该能在终端中看到你的接口（别忘了使用自动完成来快速构建命令并确保你有正确的名称）：
- en: '[PRE56]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If you see this, it means that the build process succeeded. If you can’t see
    the interface in the Terminal, then you need to go back and check that you did
    all the steps correctly.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到这个，这意味着构建过程成功。如果你在终端中看不到接口，那么你需要回去检查你是否正确完成了所有步骤。
- en: Using your custom message in your code
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在你的代码中使用自定义消息
- en: Let’s say you want to use your new interface in the **number_publisher** node
    you created in this chapter, inside the **my_py_pkg** package.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要在这个章节中创建的**number_publisher**节点中使用你的新接口，在**my_py_pkg**包内。
- en: 'First, open the **package.xml** file from the **my_py_pkg** package and add
    a dependency to **my_robot_interfaces**:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开**my_py_pkg**包中的**package.xml**文件，并添加对**my_robot_interfaces**的依赖项：
- en: '[PRE57]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, for Python, do the following:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于Python，执行以下操作：
- en: 'Import the message by by adding the following import line in your code:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在代码中添加以下导入行来导入消息：
- en: '[PRE58]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Create a publisher and specify the `HardwareStatus` interface.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个发布者并指定`HardwareStatus`接口。
- en: 'Create a message in your code, like so:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码中创建一个消息，如下所示：
- en: '[PRE59]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re using VS Code, the message might not be recognized after you import
    it. Close VS Code and open it again in a sourced environment. So, make sure the
    interface has been built correctly, then source the environment, and open VS code.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用VS Code，导入消息后可能无法识别。关闭VS Code，然后在源环境中重新打开它。所以，请确保接口已正确构建，然后源环境，并打开VS code。
- en: 'If you want to use this message in your C++ node from the **my_cpp_pkg** package,
    add the dependency to **my_robot_interfaces** in the **package.xml** file of **my_cpp_package**.
    Then, do the following:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在**my_cpp_pkg**包的C++节点中使用此消息，请将**my_robot_interfaces**的依赖项添加到**my_cpp_package**的**package.xml**文件中。然后执行以下操作：
- en: 'Import the message by adding the following `include` line in your code:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在代码中添加以下`include`行来导入消息：
- en: '[PRE60]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Create a publisher and specify the interface with `<my_robot_interfaces::msg::``HardwareStatus>`.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个发布者并指定接口为`<my_robot_interfaces::msg::HardwareStatus>`。
- en: 'Create a message in your code, like so:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码中创建一个消息，如下所示：
- en: '[PRE61]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'When using VS code, the C++ include will not be recognized. You need to add
    a new line to the **c_cpp_properties.json** file that was auto-generated (inside
    a **.vscode** folder) when you started VS Code. You can find this file from VS
    Code using the explorer on the left. Then, in the **includePath** array, add the
    following line:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用VS code时，C++的包含文件将不会被识别。你需要向自动生成的**c_cpp_properties.json**文件（位于**.vscode**文件夹内）添加一行新内容。你可以使用VS
    Code的左侧资源管理器找到此文件。然后在**includePath**数组中添加以下行：
- en: '[PRE62]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You can now create and use your custom interface for topics. As you’ve seen,
    first, check whether there’s any existing interface that matches your needs. If
    there is, don’t reinvent the wheel. If nothing matches perfectly, however, don’t
    hesitate to create your own interface. To do that, you must create a new package
    dedicated to interfaces. Once you’ve finished the setup process for this package,
    you can add as many interfaces as you want.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以创建并使用你自己的主题界面。正如你所看到的，首先检查是否有任何现有的界面符合你的需求。如果有，就别重新发明轮子。然而，如果没有任何东西完全匹配，请不要犹豫，创建你自己的界面。为此，你必须创建一个专门用于界面的新包。一旦你完成了这个包的设置过程，你就可以添加你想要的任意数量的界面。
- en: Before we wrap things up, I will give you an additional challenge so that you
    can practice the concepts that were covered in this chapter.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束之前，我将给你一个额外的挑战，这样你就可以练习本章中涵盖的概念。
- en: Topic challenge – closed-loop control
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题挑战 – 闭环控制
- en: Here’s a challenge for you so that you can continue practicing creating nodes,
    publishers, and subscribers. We will start a new ROS 2 project and improve it
    throughout the following chapters, as we discover more concepts.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个挑战给你，这样你就可以继续练习创建节点、发布者和订阅者。我们将开始一个新的ROS 2项目，并在接下来的章节中随着我们发现更多概念来改进它。
- en: I encourage you to read the instructions and take the time to complete this
    challenge before you check the solution. Practicing is the key to effective learning.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你阅读说明，并在检查解决方案之前花时间完成这个挑战。练习是有效学习的关键。
- en: I will not provide a full explanation of all the steps, just a few remarks on
    the important points. You can find the complete solution code on GitHub, for both
    Python and C++.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会提供所有步骤的完整解释，只是对重要点进行一些说明。你可以在GitHub上找到完整的解决方案代码，包括Python和C++。
- en: Your challenge is to write a controller for the **turtlesim** node. So far,
    we’ve just used simple and basic numbers to publish and subscribe to topics. With
    this, you can practice as if you were working on a real robot.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 你的挑战是编写**turtlesim**节点的控制器。到目前为止，我们只是使用简单的数字来发布和订阅主题。有了这个，你可以像在实际机器人上工作一样进行练习。
- en: Challenge
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挑战
- en: 'The goal is simple: we want to make the turtle move in a circle. On top of
    this, we also want to modify the velocity of the turtle, whether it’s on the right
    or left of the screen.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 目标很简单：我们希望让海龟在圆形路径上移动。除此之外，我们还希望修改海龟的速度，无论它在屏幕的左侧还是右侧。
- en: 'To get the *X* coordinate of a turtle on the screen, you can subscribe to the
    **pose** topic for that turtle. Then, finding the middle of the screen is easy:
    the minimum *X* value on the left is **0**, and the maximum *X* value on the right
    is about **11**. We will assume that the *X* coordinate for the middle of the
    screen is **5.5**.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取屏幕上海龟的*X*坐标，你可以订阅该海龟的**pose**主题。然后，找到屏幕中间很容易：左侧的最小*X*值是**0**，右侧的最大*X*值大约是**11**。我们将假设屏幕中间的*X*坐标是**5.5**。
- en: You can then send a command velocity by publishing to the **cmd_vel** topic
    for the turtle. To make the turtle move in a circle, you just have to publish
    constant values for the linear *X* and angular *Z* velocities. Use **1.0** for
    both velocities if the turtle is on the left (*X* < 5.5), and **2.0** for both
    if the turtle is on the right.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向海龟的**cmd_vel**主题发布命令速度来发送速度命令。为了使海龟在圆形路径上移动，你只需要发布恒定的线性*X*和角速度*Z*值。如果海龟在左侧（*X*
    < 5.5），则两个速度都使用**1.0**；如果海龟在右侧，则两个速度都使用**2.0**。
- en: 'Follow these steps to get started:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤开始：
- en: Create a new package (let’s name it `turtle_controller`). You can decide to
    create either a Python or C++ package. If you do both, make sure you give each
    a different name.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的包（让我们称它为`turtle_controller`）。你可以决定创建Python或C++包。如果你两者都创建，请确保给每个包一个不同的名称。
- en: Inside this package, create a new node named `turtle_controller`.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个包中，创建一个名为 `turtle_controller` 的新节点。
- en: In the node’s constructor, add a publisher (command velocity) and a subscriber
    (pose).
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在节点的构造函数中添加一个发布者（命令速度）和一个订阅者（姿态）。
- en: 'This is where it’s a bit different from before: instead of creating a timer
    and publishing from the timer callback, you can publish directly from the subscriber
    callback. The `turtlesim` node is constantly publishing on the `pose` topic. Publishing
    a command from the subscriber callback allows you to create some kind of closed-loop
    control. You can get the current *X* coordinate and send a different velocity
    command, depending on where the turtle is.'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这与之前有点不同：不是创建一个定时器并从定时器回调中发布，而是可以直接从订阅者回调中发布。`turtlesim` 节点持续在 `pose` 主题上发布。从订阅者回调中发布命令允许你创建某种闭环控制。你可以获取当前的
    *X* 坐标，并根据海龟的位置发送不同的速度命令。
- en: To test your code, create an executable out of your code. Then, run **turtlesim**
    in one Terminal and your node in another. You should see the turtle drawing a
    circle, with a different velocity depending on where the turtle is.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的代码，从你的代码中创建一个可执行文件。然后，在一个终端中运行 **turtlesim**，在另一个终端中运行你的节点。你应该看到海龟在画圈，速度根据海龟的位置不同而不同。
- en: Solution
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: You can find the complete code (for both Python and C++) and package organization
    on GitHub.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到完整的代码（Python 和 C++）以及包的组织结构。
- en: 'Here are the most important steps for the Python node. The code starts with
    all the required import lines:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Python 节点最重要的步骤。代码从所有必需的导入行开始：
- en: '[PRE63]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here, we import **Twist** from **geometry_msgs** and **Pose** from **turtlesim**.
    You can find those interfaces by running **turtlesim_node** and exploring topics
    with the **ros2 topic** and **ros2 interface** command-line tools.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入 **Twist** 来自 **geometry_msgs** 和 **Pose** 来自 **turtlesim**。你可以通过运行
    **turtlesim_node** 并使用 **ros2 topic** 和 **ros2 interface** 命令行工具探索主题来找到这些接口。
- en: 'Then, we create a class for our node, with a constructor:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为我们的节点创建一个类，并包含一个构造函数：
- en: '[PRE64]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'As you can see, we just create a publisher and a subscriber. There’s no timer
    as we plan to use the publisher directly from the subscriber callback:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们只创建了一个发布者和一个订阅者。我们没有使用定时器，因为我们计划直接从订阅者回调中使用发布者：
- en: '[PRE65]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This is the subscriber callback. Whenever we receive a new **Pose** message,
    we create a new command (a **Twist** message). Then, depending on the current
    *X* coordinate of the turtle, we give different values for the velocity. Finally,
    we publish the new velocity command.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们订阅者回调。每当收到一个新的 **Pose** 消息时，我们创建一个新的命令（一个 **Twist** 消息）。然后，根据海龟当前的 *X* 坐标，我们给出不同的速度值。最后，我们发布新的速度命令。
- en: That’s it for this challenge. It can be a bit challenging to understand how
    to start, but in the end, you can see that there is not so much code to write.
    I encourage you to come back to this challenge in a few days and try again without
    looking at the solution. This way, you can check if you understood the concept
    of topics correctly.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这个挑战的全部内容。理解如何开始可能有点挑战性，但最终你会发现要编写的代码并不多。我鼓励你在几天后再次回到这个挑战，尝试不查看解决方案。这样，你可以检查你是否正确理解了主题的概念。
- en: Summary
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you worked on ROS 2 topics.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了 ROS 2 主题。
- en: Topics allow nodes to communicate with each other using a publish/subscribe
    mechanism. Topics are made for unidirectional data streams and are anonymous.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 主题允许节点通过发布/订阅机制相互通信。主题是为单向数据流设计的，并且是匿名的。
- en: You can write topic publishers and subscribers directly in your nodes by using
    **rclpy** for Python and **rclcpp** for C++.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接在你的节点中使用 **rclpy**（Python）和 **rclcpp**（C++）来编写主题发布者和订阅者。
- en: 'To write a publisher, you must do the following:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个发布者，你必须执行以下操作：
- en: First, check what topic name and interface you must send. Import the interface
    into the code and create a publisher in the node’s constructor.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查你必须发送的主题名称和接口。将接口导入到代码中，并在节点构造函数中创建一个发布者。
- en: To publish, you must create a message, fill in the different fields, and publish
    the message with your publisher.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要发布消息，你必须创建一个消息，填写不同的字段，并使用你的发布者发布该消息。
- en: You can potentially publish a message from anywhere in the code. A common structure
    is to add a timer and publish from the timer callback. If it makes sense, you
    can also publish from a subscriber callback directly.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代码的任何位置发布消息。一个常见的结构是在定时器中添加并从定时器回调中发布。如果合理，你也可以直接从订阅者回调中发布。
- en: 'To write a subscriber, you must do the following:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 要向订阅者发送消息，你必须执行以下操作：
- en: As for the publisher, you need to know what name and interface to receive. Import
    the interface and create a subscriber in the node’s constructor.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于发布者而言，您需要知道要接收的名称和接口。导入接口并在节点构造函数中创建一个订阅者。
- en: When creating the subscriber, you will need to specify a callback function.
    It’s in this callback function that you can receive and process incoming messages.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当创建订阅者时，您需要指定一个回调函数。正是在这个回调函数中，您可以接收和处理传入的消息。
- en: 'If you create a publisher or subscriber for a new topic and no interface matches
    your needs, you might need to create a custom interface. In this case, you must
    do the following:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为新的主题创建发布者或订阅者，且没有接口符合您的需求，您可能需要创建一个自定义接口。在这种情况下，您必须执行以下操作：
- en: Create and configure a new package dedicated to interfaces for your robot or
    application.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的机器人或应用程序创建并配置一个专门用于接口的新包。
- en: Add your topic interface inside the package and build the package.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包内添加您的主题接口并构建包。
- en: Now, you can use this custom interface in your publishers/subscribers, just
    like any other interface.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以在发布者/订阅者中使用这个自定义接口，就像使用任何其他接口一样。
- en: To try a publisher or a subscriber, simply build the package where the node
    is, source the environment, and run the node. You can then use the **ros2** command-line
    tools, as well as **rqt_graph**, to introspect your application and solve potential
    issues.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试一个发布者或订阅者，只需在节点所在的位置构建包，源环境，并运行节点。然后，您可以使用**ros2**命令行工具，以及**rqt_graph**，来内省您的应用程序并解决潜在问题。
- en: After topics, the next logical step is to learn about ROS 2 services. This is
    what we will cover in the following chapter.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在主题之后，下一个逻辑步骤是了解ROS 2服务。这正是我们将在下一章中介绍的内容。
