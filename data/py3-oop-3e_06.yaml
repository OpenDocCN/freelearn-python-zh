- en: Python Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python数据结构
- en: 'In our examples so far, we''ve already seen many of the built-in Python data
    structures in action. You''ve probably also covered many of them in introductory
    books or tutorials. In this chapter, we''ll discuss the object-oriented features
    of these data structures, when they should be used instead of a regular class,
    and when they should not be used. In particular, we''ll be covering the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们已经看到了许多内置的Python数据结构在行动。你可能也在入门书籍或教程中了解了它们中的许多。在本章中，我们将讨论这些数据结构的面向对象特性，它们应该在什么情况下代替常规类使用，以及它们不应该在什么情况下使用。特别是，我们将涵盖以下主题：
- en: Tuples and named tuples
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组和命名元组
- en: Dataclasses
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类
- en: Dictionaries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典
- en: Lists and sets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表和集合
- en: How and why to extend built-in objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何和为什么扩展内置对象
- en: Three types of queues
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三种类型的队列
- en: Empty objects
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空对象
- en: 'Let''s start with the most basic Python built-in, one that we''ve seen many
    times already, the one that we''ve extended in every class we have created: the
    `object`. Technically, we can instantiate an `object` without writing a subclass,
    as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基本的Python内置对象开始，这是我们已经多次见过的，我们在创建的每个类中都扩展了它：`object`。技术上，我们可以不写子类就实例化一个`object`，如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Unfortunately, as you can see, it's not possible to set any attributes on an
    `object` that was instantiated directly. This isn't because the Python developers
    wanted to force us to write our own classes, or anything so sinister. They did
    this to save memory; a lot of memory. When Python allows an object to have arbitrary
    attributes, it takes a certain amount of system memory to keep track of what attributes
    each object has, for storing both the attribute name and its value. Even if no
    attributes are stored, memory is allocated for *potential* new attributes. Given
    the dozens, hundreds, or thousands of objects (every class extends an object)
    in a typical Python program; this small amount of memory would quickly become
    a large amount of memory. So, Python disables arbitrary properties on `object`,
    and several other built-ins, by default.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，正如你所看到的，直接实例化的`object`上无法设置任何属性。这并不是因为Python开发者想要强迫我们编写自己的类，或者任何如此邪恶的事情。他们这样做是为了节省内存；大量的内存。当Python允许一个对象具有任意属性时，它需要一定量的系统内存来跟踪每个对象具有哪些属性，包括存储属性名称及其值。即使没有存储属性，也会为*潜在的*新属性分配内存。考虑到典型的Python程序中可能有数十、数百或数千个对象（每个类都扩展了对象），这样一小块内存很快就会变成大量的内存。因此，Python默认禁用了`object`和几个其他内置对象的任意属性。
- en: It is possible to restrict arbitrary properties on our own classes using **slots**.
    Slots are beyond the scope of this book, but you now have a search term if you
    are looking for more information. In normal use, there isn't much benefit to using
    slots, but if you're writing an object that will be duplicated thousands of times
    throughout the system, they can help save memory, just as they do for `object`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**槽**来限制我们自己的类上的任意属性。槽超出了本书的范围，但如果你在寻找更多信息，你现在有一个搜索词。在正常使用中，使用槽并没有多少好处，但如果你正在编写将在整个系统中重复数千次的对象，它们可以帮助节省内存，就像它们对`object`所做的那样。
- en: 'It is, however, trivial to create an empty object class of our own; we saw
    it in our earliest example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，创建我们自己的空对象类是非常简单的；我们在最早期的例子中看到了它：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And, as we''ve already seen, it''s possible to set attributes on such classes
    as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，可以在这样的类上设置属性，如下所示：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we wanted to group properties together, we could store them in an empty object
    like this. But we are usually better off using other built-ins designed for storing
    data. It has been stressed throughout this book that classes and objects should
    only be used when you want to specify *both* data and behaviors. The main reason
    to write an empty class is to quickly block something out, knowing we'll come
    back later to add behavior. It is much easier to adapt behaviors to a class than
    it is to replace a data structure with an object and change all references to
    it. Therefore, it is important to decide from the outset whether the data is just
    data, or whether it is an object in disguise. Once that design decision is made,
    the rest of the design naturally falls into place.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将属性组合在一起，我们可以将它们存储在一个空对象中，如下所示。但通常我们更倾向于使用其他专为存储数据设计的内置函数。本书一直强调，只有当你想指定**数据**和**行为**时，才应该使用类和对象。编写一个空类的主要原因是为了快速排除某些内容，知道我们稍后会回来添加行为。将行为适应类比用对象替换数据结构并更改所有对其的引用要容易得多。因此，从一开始就决定数据仅仅是数据，还是伪装成对象的，这一点很重要。一旦做出这个设计决策，其余的设计就会自然而然地就位。
- en: Tuples and named tuples
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组和命名元组
- en: Tuples are objects that can store a specific number of other objects in order.
    They are *immutable*, meaning we can't add, remove, or replace objects on the
    fly. This may seem like a massive restriction, but the truth is, if you need to
    modify a tuple, you're using the wrong data type (usually, a list would be more
    suitable). The primary benefit of tuples' immutability is that we can use them
    as keys in dictionaries, and in other locations where an object requires a hash
    value.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是可以按顺序存储其他特定数量对象的对象。它们是**不可变**的，这意味着我们无法在运行时添加、删除或替换对象。这看起来可能是一个巨大的限制，但事实是，如果你需要修改元组，你使用的数据类型是错误的（通常，列表会更合适）。元组不可变性的主要好处是我们可以将它们用作字典的键，以及在需要对象哈希值的其他位置。
- en: Tuples are used to store data; behavior cannot be associated with a tuple. If
    we require behavior to manipulate a tuple, we have to pass the tuple into a function
    (or method on another object) that performs the action.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 元组用于存储数据；无法将行为与元组关联。如果我们需要行为来操作元组，我们必须将元组传递给一个函数（或另一个对象上的方法）以执行该操作。
- en: Tuples should generally store values that are somehow different from each other.
    For example, we would not put three stock symbols in a tuple, but we might create
    a tuple containing a stock symbol with its current, high, and low prices for the
    day. The primary purpose of a tuple is to aggregate different pieces of data together
    into one container. Thus, a tuple can be the easiest tool to replace the *object
    with no data* idiom.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 元组通常应存储彼此不同的值。例如，我们不会在元组中放入三个股票代码，但我们可以创建一个包含股票代码及其当日当前价、最高价和最低价的元组。元组的主要目的是将不同的数据片段聚合到一个容器中。因此，元组可以是最容易替换“无数据对象”习语的工具。
- en: 'We can create a tuple by separating values with a comma. Usually, tuples are
    wrapped in parentheses to make them easy to read and to separate them from other
    parts of an expression, but this is not always mandatory. The following two assignments
    are identical (they record a stock, the current price, the high, and the low,
    for a rather profitable company):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过用逗号分隔值来创建一个元组。通常，元组被括号包围以使其易于阅读，并与其他表达式的其他部分区分开来，但这并非总是必需的。以下两个赋值是相同的（它们记录了一家相当盈利公司的股票、当前价格、最高价和最低价）：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we''re grouping a tuple inside of some other object, such as a function
    call, list comprehension, or generator, the parentheses are required. Otherwise,
    it would be impossible for the interpreter to know whether it is a tuple or the
    next function parameter. For example, the following function accepts a tuple and
    a date, and returns a tuple of the date and the middle value between the stock''s
    high and low value:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在某个其他对象内部组合一个元组，例如函数调用、列表推导或生成器，则需要括号。否则，解释器将无法知道它是一个元组还是下一个函数参数。例如，以下函数接受一个元组和日期，并返回一个包含日期和股票最高价与最低价之间中间值的元组：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The tuple is created directly inside the function call by separating the values
    with commas and enclosing the entire tuple in parentheses. This tuple is then
    followed by a comma to separate it from the second argument.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 元组直接在函数调用内部通过用逗号分隔值并包围整个元组在括号中创建。然后，元组后面跟着一个逗号，以将其与第二个参数分开。
- en: This example also illustrates *tuple unpacking*. The first line inside the function
    unpacks the `stock` parameter into four different variables. The tuple has to
    be exactly the same length as the number of variables, or it will raise an exception.
    We can also see an example of tuple unpacking in the last clause, where the tuple
    returned from inside the function is unpacked into two values, `mid_value` and
    `date`. Granted, this is a strange thing to do, since we supplied the date to
    the function in the first place, but it gave us a chance to see unpacking at work.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子也说明了*元组解包*。函数内部的第 一行将`stock`参数解包成四个不同的变量。元组必须与变量的数量完全相同，否则会引发异常。我们还可以在最后一条语句中看到元组解包的例子，其中函数返回的元组被解包成两个值，`mid_value`和`date`。当然，这做起来很奇怪，因为我们最初已经向函数提供了日期，但这给了我们一个机会看到解包是如何工作的。
- en: 'Unpacking is a very useful feature in Python. We can group variables together
    to make storing and passing them around simpler, but the moment we need to access
    all of them, we can unpack them into separate variables. Of course, sometimes
    we only need access to one of the variables in the tuple. We can use the same
    syntax that we use for other sequence types (lists and strings, for example) to
    access an individual value:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 解包是Python中的一个非常有用的特性。我们可以将变量分组在一起，以便更容易地存储和传递它们，但当我们需要访问所有变量时，我们可以将它们解包成单独的变量。当然，有时我们只需要访问元组中的一个变量。我们可以使用与其他序列类型（例如列表和字符串）相同的语法来访问单个值：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can even use slice notation to extract larger pieces of tuples, as demonstrated
    in the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用切片符号来提取元组的更大部分，如下所示：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These examples, while illustrating how flexible tuples can be, also demonstrate
    one of their major disadvantages: readability. How does someone reading this code
    know what is in the second position of a specific tuple? They can guess, from
    the name of the variable we assigned it to, that it is `high` of some sort, but
    if we had just accessed the tuple value in a calculation without assigning it,
    there would be no such indication. They would have to paw through the code to
    find where the tuple was declared before they could discover what it does.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例虽然说明了元组有多灵活，但也展示了它们的一个主要缺点：可读性。阅读这段代码的人如何知道特定元组的第二个位置是什么？他们可以猜测，从我们分配给它的变量的名字来看，它可能是某种“高”值，但如果我们在没有分配的情况下直接在计算中访问元组值，就没有这样的提示。他们必须翻遍代码，找到元组声明的地方，才能发现它的作用。
- en: Accessing tuple members directly is fine in some circumstances, but don't make
    a habit of it. Such so-called *magic numbers* (numbers that seem to come out of
    thin air with no apparent meaning within the code) are the source of many coding
    errors and lead to hours of frustrated debugging. Try to use tuples only when
    you know that all the values are going to be useful at once and it's normally
    going to be unpacked when it is accessed. If you have to access a member directly,
    or by using a slice, and the purpose of that value is not immediately obvious,
    at least include a comment explaining where it came from.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，直接访问元组成员是可以的，但不要养成这种习惯。这种所谓的*魔法数字*（似乎从空中出现，在代码中没有明显的意义）是许多编码错误的来源，并导致数小时的沮丧调试。尽量只在知道所有值都将同时有用并且通常在访问时会被解包的情况下使用元组。如果你必须直接访问成员或使用切片，并且该值的用途不是立即显而易见，至少包括一个注释说明它从何而来。
- en: Named tuples
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名元组
- en: So, what do we do when we want to group values together, but know we're frequently
    going to need to access them individually? There are actually several options.
    We could use an empty object, as discussed previously (but that is rarely useful,
    unless we anticipate adding behavior later), or we could use a dictionary (most
    useful if we don't know exactly how much data or which specific data will be stored),
    as we'll cover in a later section. Two other options are named tuples, which we'll
    discuss here, and dataclasses, in the next section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当我们想要将值分组在一起，但又知道我们经常需要单独访问它们时，我们该怎么办呢？实际上有几个选择。我们可以使用一个空对象，正如之前所讨论的（但这很少有用，除非我们预计以后会添加行为），或者我们可以使用一个字典（如果我们不知道确切的数据量或哪些具体数据将被存储，这非常有用），我们将在后面的章节中介绍。另外两种选择是命名元组，我们将在本节中讨论，以及数据类，在下一节中介绍。
- en: If we do not need to add behavior to the object, and we know in advance which
    attributes we need to store, we can use a named tuple. Named tuples are tuples
    with attitude. They are a great way to group read-only data together.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要向对象添加行为，并且事先知道需要存储哪些属性，我们可以使用命名元组。命名元组是带有态度的元组。它们是分组只读数据的一个好方法。
- en: 'Constructing a named tuple takes a bit more work than a normal tuple. First,
    we have to import `namedtuple`, as it is not in the namespace by default. Then,
    we describe the named tuple by giving it a name and outlining its attributes.
    This returns a class-like object that we can instantiate with the required values
    as many times as we want, as demonstrated in the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 构建命名元组比正常元组要复杂一些。首先，我们必须导入 `namedtuple`，因为它默认不在命名空间中。然后，我们通过给它一个名称并概述其属性来描述命名元组。这返回一个类对象，我们可以用所需值实例化它，并且可以多次实例化，如下所示：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `namedtuple` constructor accepts two arguments. The first is an identifier
    for the named tuple. The second is a list of string attributes that the named
    tuple requires. The result is an object that can be called just like a normal
    class to instantiate other objects. The constructor must have exactly the correct
    number of arguments that can be passed in as arguments or keyword arguments. As
    with normal objects, we can create as many instances of this *class* as we like,
    with different values for each.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`namedtuple` 构造函数接受两个参数。第一个是一个用于命名元组的标识符。第二个是命名元组所需的字符串属性列表。结果是可以通过像正常类一样调用来实例化其他对象的实例。构造函数必须具有恰好正确的参数数量，这些参数可以作为参数或关键字参数传递。与正常对象一样，我们可以创建任意数量的此类实例，每个实例具有不同的值。'
- en: Be careful not to use a reserved keyword (class, for example) as an attribute
    for a named tuple.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不要将保留关键字（例如 class）用作命名元组的属性。
- en: 'The resulting `namedtuple` can then be packed, unpacked, indexed, sliced, and
    otherwise treated like a normal tuple, but we can also access individual attributes
    on it as if it were an object:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的 `namedtuple` 可以像正常元组一样打包、解包、索引、切片，以及其他处理，但我们也可以像访问对象上的单个属性一样访问它：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Remember that creating named tuples is a two-step process. First, use `collections.namedtuple`
    to create a class, and then construct instances of that class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，创建命名元组是一个两步过程。首先，使用 `collections.namedtuple` 创建一个类，然后构建该类的实例。
- en: 'Named tuples are perfect for many *data only* representations, but they are
    not ideal for all situations. Like tuples and strings, named tuples are immutable,
    so we cannot modify an attribute once it has been set. For example, the current
    value of my company''s stock has gone down since we started this discussion, but
    we can''t set the new value, as can be seen in the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 命名元组非常适合许多仅用于数据的表示，但它们并不适用于所有情况。像元组和字符串一样，命名元组是不可变的，因此一旦设置属性后，我们无法修改它。例如，自从我们开始这次讨论以来，我们公司股票的当前价值已经下降，但我们无法设置新值，如下所示：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If we need to be able to change stored data, a dataclass may be what we need
    instead.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要能够更改存储的数据，数据类可能就是我们需要的东西。
- en: Dataclasses
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类
- en: Dataclasses are basically regular objects w
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类基本上是常规对象，但带有一些额外的特性。
- en: ith a clean syntax for predefining attributes. There are a few ways to create
    one, and we'll explore each in this section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了用于预定义属性的简洁语法。有几种创建方法，我们将在本节中逐一探讨。
- en: 'The simplest way is to use a similar construct to that used for named tuples,
    as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是使用与命名元组类似的构造，如下所示：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once instantiated, the stock object can be used like any regular class. You
    can access and update attributes and can even assign other arbitrary attributes
    to the object, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实例化，股票对象就可以像任何常规类一样使用。您可以访问和更新属性，甚至可以给对象分配其他任意属性，如下所示：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At first glance, it seems like dataclasses don''t give you much benefit over
    a normal object with an appropriate constructor:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，数据类似乎并没有比具有适当构造函数的正常对象带来多少好处：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The obvious benefit is that with `make_dataclass`, you get to define the class
    in one line instead of six. If you look a little closer, you''ll see that the
    dataclass also gives you a much more useful string representation than the regular
    version. It also provides an equality comparison for free. The following example
    compares the regular class to these dataclass features:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 明显的好处是，使用 `make_dataclass`，您可以在一行中定义类，而不是六行。如果您再仔细一点，您会发现数据类还提供了一个比常规版本更有用的字符串表示。它还免费提供等价比较。以下示例比较了常规类与这些数据类功能：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we''ll soon see, dataclasses also have many other useful features. But first,
    let''s look at an alternative (and more common) way to define a dataclass. Refer
    to the following block of code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们很快就会看到的，数据类还有许多其他有用的功能。但首先，让我们看看定义数据类的另一种（更常见）方法。参考以下代码块：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you haven't seen type hints before, this syntax probably looks truly bizarre.
    These so-called variable annotations were introduced to the language in Python
    3.6\. I'm classifying type hints as *beyond the scope of this book*, so I'll leave
    you to do a web search if you want to find out more about them. For now, just
    know that the preceding is truly legal Python syntax, and that it works. You don't
    have to take my word for it; just run the code and observe the lack of syntax
    errors!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前没有见过类型提示，这种语法可能看起来真的很奇怪。这些所谓的变量注解是在 Python 3.6 中引入到语言中的。我将类型提示归类为**本书范围之外的内容**，所以如果您想了解更多关于它们的信息，请自行进行网络搜索。现在，只需知道前面的确实是合法的
    Python 语法，并且它确实有效。您不必相信我的话；只需运行代码并观察是否存在语法错误！
- en: If you don't feel like using type hints or your attribute takes a value with
    a complicated type or set of types, specify the type as `Any`. You can pull the
    `Any` type into your namespace using `from typing import Any`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用类型提示，或者您的属性接受一个复杂类型或类型集的值，请指定类型为`Any`。您可以使用`from typing import Any`将`Any`类型引入您的命名空间。
- en: The `dataclass` function is applied as a class decorator. We encountered decorators
    in a previous chapter when we were discussing properties. I promised then that
    we'll go into more detail about them in a future chapter. I'll keep that promise
    in chapter 10\. For now, just know that the syntax is required to generate a dataclass.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`dataclass`函数作为类装饰器应用。我们在上一章讨论属性时遇到了装饰器。我承诺在未来的章节中会详细介绍它们。我将在第10章履行这个承诺。现在，只需知道这种语法是生成数据类所必需的。'
- en: 'Granted, this syntax isn''t much less verbose than the regular class with `__init__`,
    but it gives us access to several additional dataclass features. For example,
    you can specify a default value for a dataclass. Perhaps the market is currently
    closed and you don''t know what the values for the day are:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 承认，这种语法与带有`__init__`的常规类相比并没有少多少冗余，但它给了我们访问几个额外的数据类功能。例如，您可以指定数据类的默认值。也许市场目前关闭，您不知道当天的值：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can construct this class with just the stock name; the rest of the values
    will take on the defaults. But you can still specify values if you prefer, as
    follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用股票名称来构建这个类；其余的值将采用默认值。但您仍然可以指定值，如下所示：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We saw earlier that dataclasses automatically support equality comparison.
    If all the attributes compare as equal, then the dataclass also compares as equal.
    By default, dataclasses do not support other comparisons, such as less than or
    greater than, and they can''t be sorted. However, you can easily add comparisons
    if you wish, demonstrated as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，数据类自动支持相等比较。如果所有属性都相等，则数据类也相等。默认情况下，数据类不支持其他比较，如小于或大于，并且不能排序。但是，如果您愿意，可以轻松添加比较，如下所示：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'All that we changed in this example was adding the `order=True` keyword to
    the dataclass constructor. But that gives us the opportunity to sort and compare
    the following values:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们所做的唯一改变是在数据类构造函数中添加了`order=True`关键字。但这给了我们排序和比较以下值的机会：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When a dataclass receives the `order=True` argument, it will, by default, compare
    the values based on each of the attributes in the order they were defined. So,
    in this case, it first compares the name on the two classes. If those are the
    same, it compares the current price. If those are also the same, it will compare
    the highs and then the lows. You can customize the sort order by providing a `sort_index`
    attribute inside a `__post_init__` method on the class, but I'll leave you to
    search the web to get the full details of this and other advanced usages (such
    as immutability), as this section is getting rather long and we have a lot of
    other data structures to study.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据类接收到`order=True`参数时，它将默认根据每个属性定义的顺序比较值。因此，在这种情况下，它首先比较两个类上的名称。如果它们相同，它将比较当前价格。如果这些也相同，它将比较最高价和最低价。您可以通过在类的`__post_init__`方法内提供一个`sort_index`属性来自定义排序顺序，但我将让您自行上网搜索以获取此和其他高级用法（如不可变性）的完整细节，因为这一部分已经相当长，我们还有许多其他数据结构要研究。
- en: Dictionaries
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: Dictionaries are incredibly useful containers that allow us to map objects directly
    to other objects. An empty object with attributes to it is a sort of dictionary;
    the names of the properties map to the property values. This is actually closer
    to the truth than it sounds; internally, objects normally represent attributes
    as a dictionary, where the values are properties or methods on the objects (see
    the `__dict__` attribute if you don't believe me). Even the attributes on a module
    are stored, internally, in a dictionary.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是非常有用的容器，允许我们直接将对象映射到其他对象。一个具有属性的空对象就像是一种字典；属性的名称映射到属性值。这实际上比听起来更接近真相；内部，对象通常将属性表示为字典，其中值是对象上的属性或方法（如果你不相信我，请查看`__dict__`属性）。甚至模块上的属性也是内部存储在字典中的。
- en: Dictionaries are extremely efficient at looking up a value, given a specific
    key object that maps to that value. They should always be used when you want to
    find one object based on some other object. The object that is being stored is
    called the **value**; the object that is being used as an index is called the
    **key**. We've already seen dictionary syntax in some of our previous examples.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 字典在根据特定的键对象查找值方面非常高效。当你想根据其他对象找到某个对象时，应该始终使用字典。被存储的对象称为**值**；用作索引的对象称为**键**。我们在之前的某些示例中已经看到了字典的语法。
- en: Dictionaries can be created either using the `dict()` constructor or using the
    `{}` syntax shortcut. In practice, the latter format is almost always used. We
    can prepopulate a dictionary by separating the keys from the values using a colon,
    and separating the key value pairs using a comma.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 字典可以通过使用`dict()`构造函数或使用`{}`语法快捷方式来创建。实际上，后者格式几乎总是被使用。我们可以通过使用冒号分隔键和值，以及使用逗号分隔键值对来预先填充字典。
- en: 'For example, in a stock application, we would most often want to look up prices
    by the stock symbol. We can create a dictionary that uses stock symbols as keys,
    and tuples (you could also used named tuples or dataclasses as values, of course)
    of current, high, and low as values, like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个股票应用程序中，我们通常会想通过股票符号来查找价格。我们可以创建一个使用股票符号作为键的字典，以及包含当前价、最高价和最低价的元组（当然，你也可以使用命名元组或数据类作为值）。如下所示：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As we''ve seen in previous examples, we can then look up values in the dictionary
    by requesting a key inside square brackets. If the key is not in the dictionary,
    it will raise an exception, demonstrated as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的示例，我们可以在字典中通过请求方括号内的键来查找值。如果键不在字典中，它将引发异常，如下所示：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can, of course, catch the `KeyError` and handle it. But we have other options.
    Remember, dictionaries are objects, even if their primary purpose is to hold other
    objects. As such, they have several behaviors associated with them. One of the
    most useful of these methods is the `get` method; it accepts a key as the first
    parameter and an optional default value if the key doesn''t exist:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以捕获`KeyError`并处理它。但我们还有其他选择。记住，字典是对象，即使它们的目的是持有其他对象。因此，它们具有与之相关的几种行为。其中最有用的方法之一是`get`方法；它接受一个键作为第一个参数，如果键不存在，则接受一个可选的默认值：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For even more control, we can use the `setdefault` method. If the key is in
    the dictionary, this method behaves just like `get`; it returns the value for
    that key. Otherwise, if the key is not in the dictionary, it will not only return
    the default value we supply in the method call (just like `get` does); it will
    also set the key to that same value. Another way to think of it is that `setdefault`
    sets a value in the dictionary only if that value has not previously been set.
    Then, it returns the value in the dictionary; either the one that was already
    there, or the newly provided default value, as can be seen in the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更多的控制，我们可以使用`setdefault`方法。如果键在字典中，此方法的行为就像`get`一样；它返回该键的值。否则，如果键不在字典中，它不仅会返回我们在方法调用中提供的默认值（就像`get`做的那样）；它还会将该键设置为该值。另一种思考方式是，`setdefault`仅在值之前未设置的情况下才在字典中设置值。然后，它返回字典中的值；要么是已经存在的值，要么是新提供的默认值，如下所示：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `GOOG` stock was already in the dictionary, so when we tried to `setdefault`
    it to an invalid value, it just returned the value already in the dictionary.
    `BBRY` was not in the dictionary, so `setdefault` returned the default value and
    set the new value in the dictionary for us. We then check that the new stock is,
    indeed, in the dictionary.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOOG` 股票已经在字典中，所以当我们尝试将其 `setdefault` 到一个无效值时，它只是返回字典中已有的值。`BBRY` 不在字典中，所以
    `setdefault` 返回了默认值，并为我们设置了字典中的新值。然后我们检查新股票确实在字典中。'
- en: 'Three other very useful dictionary methods are `keys()`, `values()`, and `items()`.
    The first two return an iterator over all the keys and all the values in the dictionary.
    We can use these like lists or in `for` loops if we want to process all the keys
    or values. The `items()` method is probably the most useful; it returns an iterator
    over tuples of `(key, value)` pairs for every item in the dictionary. This works
    great with tuple unpacking in a `for` loop to loop over associated keys and values.
    This example does just that to print each stock in the dictionary with its current
    value:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个非常实用的字典方法：`keys()`、`values()` 和 `items()`。前两个返回字典中所有键和所有值的迭代器。如果我们想处理所有的键或值，我们可以像使用列表一样使用它们或在
    `for` 循环中使用它们。`items()` 方法可能是最有用的；它返回一个迭代器，遍历字典中每个项的 `(key, value)` 对。这非常适合在 `for`
    循环中进行元组解包，以遍历相关的键和值。这个例子就是这样做的，以打印出字典中每个股票及其当前值：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Each key/value tuple is unpacked into two variables named `stock` and `values`
    (we could use any variable names we wanted, but these both seem appropriate) and
    then printed in a formatted string.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键/值元组被解包成两个变量，分别命名为 `stock` 和 `values`（我们可以使用任何我们想要的变量名，但这两个似乎都很合适），然后以格式化的字符串形式打印出来。
- en: Notice that the stocks show up in the same order in which they were inserted.
    This was not true until Python 3.6, and was not a formal part of the language
    definition until Python 3.7\. Before that, the underlying dict implementation
    used a different underlying data structure that was not ordered. It's quite rare
    to need ordering in dictionaries, but if you do and you need to support Python
    3.5 or older, make sure you use the `OrderedDict` class instead, which is available
    from the `collections` module.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，股票显示的顺序与它们被插入的顺序相同。在 Python 3.6 之前，这不是真的，直到 Python 3.7 才成为语言定义的正式部分。在此之前，底层字典实现使用了一个不同的底层数据结构，它不是有序的。在字典中需要排序的情况相当罕见，但如果确实需要，并且需要支持
    Python 3.5 或更早版本，请确保使用 `OrderedDict` 类，它可以从 `collections` 模块中获取。
- en: 'So, there are numerous ways to retrieve data from a dictionary once it has
    been instantiated: we can use square brackets as index syntax, the `get` method,
    the `setdefault` method, or iterate over the `items` method, among others.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦实例化了一个字典，就有许多方法可以检索数据：我们可以使用方括号作为索引语法，使用 `get` 方法，使用 `setdefault` 方法，或者遍历
    `items` 方法，等等。
- en: 'Finally, as you likely already know, we can set a value in a dictionary using
    the same indexing syntax we use to retrieve a value:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如你可能已经知道的，我们可以使用与检索值相同的索引语法在字典中设置一个值：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Google's price is higher today, so I've updated the tuple value in the dictionary.
    We can use this index syntax to set a value for any key, regardless of whether
    the key is in the dictionary. If it is in the dictionary, the old value will be
    replaced with the new one; otherwise, a new key/value pair will be created.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于今天谷歌的价格更高，所以我已更新了字典中的元组值。我们可以使用这种索引语法为任何键设置值，无论该键是否在字典中。如果它在字典中，旧值将被新值替换；否则，将创建一个新的键/值对。
- en: 'We''ve been using strings as dictionary keys, so far, but we aren''t limited
    to string keys. It is common to use strings as keys, especially when we''re storing
    data in a dictionary to gather it together (instead of using an object or dataclass
    with named properties). But we can also use tuples, numbers, or even objects we''ve
    defined ourselves as dictionary keys. We can even use different types of keys
    in a single dictionary, as demonstrated in the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止一直在使用字符串作为字典键，但我们并不局限于字符串键。使用字符串作为键很常见，特别是当我们将数据存储在字典中以收集它们时（而不是使用具有命名属性的对象或数据类）。但我们也可以使用元组、数字，甚至是我们自己定义的对象作为字典键。我们甚至可以在单个字典中使用不同类型的键，如下所示：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code shows several different types of keys we can supply to a dictionary.
    It also shows one type of object that cannot be used. We've already used lists
    extensively, and we'll be seeing many more details of them in the next section.
    Because lists can change at any time (by adding or removing items, for example),
    they cannot **hash** to a specific value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了我们可以提供给字典的几种不同类型的键。它还展示了一种不能使用的对象类型。我们已经广泛使用了列表，我们将在下一节看到更多关于它们的细节。因为列表可以在任何时候改变（例如，通过添加或删除项），它们不能**哈希**到特定的值。
- en: Objects that are **hashable** basically have a defined algorithm that converts
    the object into a unique integer value for rapid lookup in the dictionary. This
    hash is what is actually used to find values in a dictionary. For example, strings
    map to integers based on the byte values of the characters in the string, while
    tuples combine hashes of the items inside the tuple. Any two objects that are
    somehow considered equal (such as strings with the same characters or tuples with
    the same values) should have the same hash value, and the hash value for an object
    should never ever change. Lists, however, can have their contents changed, which
    would change their hash value (two lists should only be equal if their contents
    are the same). Because of this, they can't be used as dictionary keys. For the
    same reason, dictionaries cannot be used as keys into other dictionaries.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**可哈希**的对象基本上有一个将对象转换为唯一整数值的算法，以便在字典中进行快速查找。这个哈希值实际上是用来在字典中查找值的。例如，字符串根据字符串中字符的字节值映射到整数，而元组则结合元组内项的哈希值。任何被认为相等（如具有相同字符的字符串或具有相同值的元组）的两个对象都应该有相同的哈希值，并且对象的哈希值永远不应该改变。然而，列表的内容可以改变，这会改变其哈希值（两个列表只有在内容相同的情况下才应该相等）。正因为如此，它们不能用作字典键。出于同样的原因，字典也不能用作其他字典的键。'
- en: In contrast, there are no limits on the types of objects that can be used as
    dictionary values. We can use a string key that maps to a list value, for example,
    or we can have a nested dictionary as a value in another dictionary.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，用作字典值的对象类型没有限制。例如，我们可以使用一个字符串键映射到一个列表值，或者我们可以在另一个字典中有一个嵌套字典作为值。
- en: Dictionary use cases
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典使用案例
- en: Dictionaries are extremely versatile and have numerous uses. There are two major
    ways that dictionaries can be used. The first is dictionaries where all the keys
    represent different instances of similar objects; for example, our stock dictionary.
    This is an indexing system. We use the stock symbol as an index to the values.
    The values could even have been complicated, self-defined objects that had methods
    to make buy and sell decisions or set a stop-loss, rather than our simple tuples.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 字典非常灵活，有众多用途。字典可以有两种主要的使用方式。第一种是所有键都代表类似对象的不同实例的字典；例如，我们的股票字典。这是一个索引系统。我们使用股票符号作为值的索引。值甚至可以是复杂的、自定义的对象，具有进行买卖决策或设置止损的方法，而不仅仅是我们的简单元组。
- en: The second design is dictionaries where each key represents some aspect of a
    single structure; in this case, we'd probably use a separate dictionary for each
    object, and they'd all have similar (though often not identical) sets of keys.
    This latter situation can often also be solved with named tuples or dataclasses.
    This can be confusing; how do we decide which to use?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种设计是每个键代表单个结构的某个方面的字典；在这种情况下，我们可能会为每个对象使用一个单独的字典，并且它们都会有相似（尽管通常不是完全相同）的键集。这种后一种情况通常也可以用命名元组或数据类来解决。这可能会让人困惑；我们如何决定使用哪种？
- en: We should typically use dataclasses when we know exactly what attributes the
    data must store, especially if we also want to use the class definition as documentation
    for the end user.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们知道数据必须存储的确切属性时，我们通常会使用数据类，特别是如果我们还想将类定义作为最终用户的文档时。
- en: Dataclasses are a newer addition to the Python standard library (since Python
    3.7). I expect them to replace named tuples for a huge number of use cases. Named
    tuples may also be useful if you are going to be returning them from functions.
    That allows the calling function to use tuple unpacking if it is useful to do
    so. Dataclasses are not iterable, so you can't loop over or unpack their values.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类是Python标准库中的一个较新的添加（自Python 3.7以来）。我预计它们将取代许多命名元组的使用场景。如果打算从函数返回它们，命名元组也可能很有用。这允许调用函数在需要时使用元组解包。数据类是不可迭代的，因此不能遍历或解包它们的值。
- en: On the other hand, dictionaries would be a better choice if the keys describing
    the object are not known in advance, or if different objects will have some variety
    in their keys. If we don't know in advance what all the keys are going to be,
    it's probably better to use a dictionary.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果描述对象的键事先未知，或者不同的对象在键上有所差异，那么字典会是一个更好的选择。如果我们事先不知道所有键是什么，那么使用字典可能更好。
- en: Technically, most Python objects are implemented using dictionaries under the
    hood. You can see this by loading an object into the interactive interpreter and
    looking at the `obj.__dict__` magic attribute. When you access an attribute on
    an object using `obj.attr_name`, it essentially translates the lookup to `obj['attr_name']`
    under the hood. It's more complicated than that, but you get the gist. Even dataclasses
    have a `__dict__` attribute, which just goes to show how versatile dictionaries
    really are. Note that not all objects are stored in dictionaries, however. There
    are a few special types, such as lists, dictionaries, and datetimes that are implemented
    in a different way, mostly for efficiency purposes. It would certainly be odd
    if an instance of `dict` had a `__dict__` attribute that was an instance of `dict`,
    wouldn't it?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，大多数 Python 对象都是在底层使用字典实现的。你可以通过将一个对象加载到交互式解释器中并查看 `obj.__dict__` 魔术属性来看到这一点。当你使用
    `obj.attr_name` 在对象上访问属性时，它本质上是在底层将查找转换为 `obj['attr_name']`。这比那更复杂，但你能抓住要点。甚至数据类也有一个
    `__dict__` 属性，这仅仅表明字典有多么灵活。请注意，并非所有对象都存储在字典中。有一些特殊类型，如列表、字典和日期时间，是以不同的方式实现的，主要是为了效率。如果
    `dict` 实例的 `__dict__` 属性是一个 `dict` 实例，那当然会很奇怪，不是吗？
- en: Using defaultdict
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `defaultdict`
- en: 'We''ve seen how to use `setdefault` to set a default value if a key doesn''t
    exist, but this can get a bit monotonous if we need to set a default value every
    time we look up a value. For example, if we''re writing code that counts the number
    of times a letter occurs in a given sentence, we could do the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 `setdefault` 来设置一个默认值，如果键不存在的话，但如果每次查找值时都需要设置默认值，这可能会变得有点单调。例如，如果我们正在编写代码来计算一个句子中某个字母出现的次数，我们可以这样做：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Every time we access the dictionary, we need to check that it has a value already,
    and if not, set it to zero. When something like this needs to be done every time
    an empty key is requested, we can use a different version of the dictionary, called
    `defaultdict`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们访问字典时，都需要检查它是否已经有了一个值，如果没有，就将其设置为零。当每次请求一个空键时都需要这样做时，我们可以使用字典的不同版本，称为 `defaultdict`：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code looks like it couldn't possibly work. The `defaultdict` accepts a
    function in its constructor. Whenever a key is accessed that is not already in
    the dictionary, it calls that function, with no parameters, to create a default
    value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来根本不可能工作。`defaultdict` 在其构造函数中接受一个函数。每当访问一个不在字典中的键时，它会调用该函数，不带任何参数，以创建一个默认值。
- en: In this case, the function it calls is `int`, which is the constructor for an
    integer object. Normally, integers are created simply by typing an integer number
    into our code, and if we do create one using the `int` constructor, we pass it
    the item we want to create (for example, to convert a string of digits into an
    integer). But if we call `int` without any arguments, it returns, conveniently,
    the number zero. In this code, if the letter doesn't exist in the `defaultdict`,
    the number zero is returned when we access it. Then, we add one to this number
    to indicate that we've found an instance of that letter, and the next time we
    find one, that number will be returned and we can increment the value again.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它调用的函数是 `int`，这是整数对象的构造函数。通常，我们通过在代码中输入一个整数来创建整数，如果我们使用 `int` 构造函数创建一个，我们传递给它我们想要创建的项目（例如，将数字字符串转换为整数）。但是，如果我们不带任何参数调用
    `int`，它将方便地返回数字零。在这段代码中，如果字母不存在于 `defaultdict` 中，当我们访问它时将返回数字零。然后，我们给这个数字加一，以表示我们找到了该字母的一个实例，下次我们再找到它时，这个数字将被返回，我们再次增加值。
- en: The `defaultdict` is useful for creating dictionaries of containers. If we want
    to create a dictionary of closing stock prices for the past 30 days, we could
    use a stock symbol as the key and store the prices in `list`; the first time we
    access the stock price, we would want it to create an empty list. Simply pass
    `list` into the `defaultdict`, and it will be called every time an empty key is
    accessed. We can do similar things with sets or even empty dictionaries if we
    want to associate one with a key.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict`对于创建容器字典很有用。如果我们想创建过去30天的收盘价字典，我们可以使用股票代码作为键，并将价格存储在`list`中；当我们第一次访问股票价格时，我们希望它创建一个空列表。只需将`list`传递给`defaultdict`，每次访问空键时它都会被调用。如果我们想将一个空集合或空字典与一个键关联起来，我们可以做类似的事情。'
- en: 'Of course, we can also write our own functions and pass them into the `defaultdict`.
    Suppose we want to create a `defaultdict` where each new element contains a tuple
    of the number of items inserted into the dictionary at that time and an empty
    list to hold other things. It''s unlikely that we would want to create such an
    object, but let''s have a look:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以编写自己的函数并将它们传递给`defaultdict`。假设我们想创建一个`defaultdict`，其中每个新元素都包含一个元组，表示在该时刻插入字典中的项目数量，以及一个空列表来存储其他东西。我们不太可能想创建这样的对象，但让我们看看：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When we run this code, we can access empty keys and insert them into the list
    all in a single statement:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此代码时，我们可以在一个单独的语句中访问空键并将它们插入到列表中：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When we print `dict` at the end, we see that the counter really was working.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印`dict`在最后，我们看到计数器确实在起作用。
- en: This example, while succinctly demonstrating how to create our own function
    for `defaultdict`, is not actually very good code; using a global variable means
    that if we created four different `defaultdict` segments that each used `tuple_counter`,
    it would count the number of entries in all dictionaries, rather than having a
    different count for each one. It would be better to create a class and pass a
    method on that class to `defaultdict`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子虽然简洁地展示了如何为`defaultdict`创建自己的函数，但实际上代码并不好；使用全局变量意味着如果我们创建了四个不同的`defaultdict`段，每个都使用了`tuple_counter`，它将计算所有字典中的条目数，而不是每个字典都有自己的计数。最好创建一个类并将该类的方法传递给`defaultdict`。
- en: Counter
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数器
- en: 'You''d think that you couldn''t get much simpler than `defaultdict(int)`, but
    the *I want to count specific instances in an iterable* use case is common enough
    that the Python developers created a specific class for it. The previous code
    that counts characters in a string can easily be calculated in a single line:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为`defaultdict(int)`已经很简单了，但“我想在可迭代对象中计数特定实例”的使用场景足够常见，以至于Python开发者为它创建了一个特定的类。之前计算字符串中字符数量的代码可以很容易地在一行中计算：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `Counter` object behaves like a beefed-up dictionary where the keys are
    the items being counted and the values are the quantities of such items. One of
    the most useful functions is the `most_common()` method. It returns a list of
    (key, count) tuples ordered by the count. You can optionally pass an integer argument
    into `most_common()` to request only the top most common elements. For example,
    you could write a simple polling application as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter`对象的行为类似于一个增强的字典，其中键是被计数的项，值是这些项的数量。最有用的函数之一是`most_common()`方法。它返回一个按计数排序的（键，计数）元组列表。你可以可选地传递一个整数参数到`most_common()`，以请求只获取最常见的元素。例如，你可以编写一个简单的投票应用程序如下：'
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Presumably, you'd get the responses from a database or by using a computer vision
    algorithm to count the kids who raised their hands. Here, we hardcode it so that
    we can test the `most_common` method. It returns a list that has only one element
    (because we requested one element in the parameter). This element stores the name
    of the top choice at position zero, hence the double `[0][0]` at the end of the
    call. I think they look like a surprised face, don't you? Your computer is probably
    amazed it can count data so easily. It's ancestor, Hollerith's tabulating machine
    developed for the 1890 US census, must be so jealous!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 想必你会从数据库中获取响应，或者通过使用计算机视觉算法来计数举手的孩子。在这里，我们将其硬编码，以便我们可以测试`most_common`方法。它返回一个只有一个元素的列表（因为我们请求了一个参数中的元素）。这个元素存储了位置为零的最高选择的名字，因此调用末尾的`[0][0]`。我认为它们看起来像惊讶的表情，不是吗？你的电脑可能对它能够如此容易地计数数据感到惊讶。它的祖先，霍勒里斯的制表机，是为1890年美国人口普查开发的，一定非常嫉妒！
- en: Lists
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: Lists are the least object-oriented of Python's data structures. While lists
    are, themselves, objects, there is a lot of syntax in Python to make using them
    as painless as possible. Unlike many other object-oriented languages, lists in
    Python are simply available. We don't need to import them and rarely need to call
    methods on them. We can loop over a list without explicitly requesting an iterator
    object, and we can construct a list (as with a dictionary) with custom syntax.
    Further, list comprehensions and generator expressions turn them into a veritable
    Swiss Army knife of computing functionality.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是Python数据结构中最非面向对象的。虽然列表本身是对象，但Python中有大量的语法来使使用它们尽可能无痛。与许多其他面向对象的语言不同，Python中的列表是直接可用的。我们不需要导入它们，也很少需要调用它们的方法。我们可以遍历列表而不需要显式请求迭代器对象，并且我们可以使用自定义语法构造列表（就像字典一样）。此外，列表推导和生成器表达式使它们成为计算功能的瑞士军刀。
- en: We won't go into too much detail of the syntax; you've seen it in introductory
    tutorials across the web and in previous examples in this book. You can't code
    Python for very long without learning how to use lists! Instead, we'll be covering
    when lists should be used, and their nature as objects. If you don't know how
    to create or append to a list, how to retrieve items from a list, or what *slice
    notation* is, I direct you to the official Python tutorial, posthaste. It can
    be found online at [http://docs.python.org/3/tutorial/](http://docs.python.org/3/tutorial/).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会过多地介绍语法；你已经在网络上的入门教程和本书之前的例子中看到了它。你不可能长时间编写Python代码而不学习如何使用列表！相反，我们将讨论何时应该使用列表，以及它们作为对象的本性。如果你不知道如何创建或向列表中追加，如何从列表中检索项目，或者什么是*切片表示法*，我建议你立即查阅官方Python教程。它可以在网上找到，网址是[http://docs.python.org/3/tutorial/](http://docs.python.org/3/tutorial/)。
- en: In Python, lists should normally be used when we want to store several instances
    of the *same* type of object; lists of strings or lists of numbers; most often,
    lists of objects we've defined ourselves. Lists should always be used when we
    want to store items in some kind of order. Often, this is the order in which they
    were inserted, but they can also be sorted by other criteria.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，当我们想要存储同一类型的多个实例时，通常应该使用列表；字符串列表或数字列表；通常是自定义对象的列表。当我们想要按某种顺序存储项目时，应该始终使用列表。通常，这是它们被插入的顺序，但它们也可以根据其他标准进行排序。
- en: 'As we saw in the case study from the previous chapter, lists are also very
    useful when we need to modify the contents: insert to, or delete from, an arbitrary
    location of the list, or update a value within the list.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章的案例研究中看到的，当我们需要修改内容时，列表也非常有用：向列表中插入或从列表中删除任意位置的内容，或者更新列表中的值。
- en: Like dictionaries, Python lists use an extremely efficient and well-tuned internal
    data structure so we can worry about what we're storing, rather than how we're
    storing it. Many object-oriented languages provide different data structures for
    queues, stacks, linked lists, and array-based lists. Python does provide special
    instances of some of these classes, if optimizing access to huge sets of data
    is required. Normally, however, the list data structure can serve all these purposes
    at once, and the coder has complete control over how they access it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与字典一样，Python列表使用一个极其高效和调优良好的内部数据结构，这样我们就可以关注我们存储的内容，而不是如何存储它。许多面向对象的语言为队列、栈、链表和基于数组的列表提供了不同的数据结构。Python确实提供了这些类的一些特殊实例，如果需要优化对大量数据的访问。然而，通常情况下，列表数据结构可以同时满足所有这些目的，并且程序员可以完全控制它们如何访问它。
- en: Don't use lists for collecting different attributes of individual items. We
    do not want, for example, a list of the properties a particular shape has. Tuples,
    named tuples, dictionaries, and objects would all be more suitable for this purpose.
    In some languages, they might create a list in which each alternate item is a
    different type; for example, they might write `['a', 1, 'b', 3]` for our letter
    frequency list. They'd have to use a strange loop that accesses two elements in
    the list at once or a modulus operator to determine which position was being accessed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用列表来收集单个项目的不同属性。我们不想，例如，有一个特定形状的属性列表。元组、命名元组、字典和对象都更适合这个目的。在某些语言中，他们可能会创建一个列表，其中每个交替的项目是不同类型；例如，他们可能会为我们的字母频率列表写`['a',
    1, 'b', 3]`。他们必须使用一个奇怪的循环同时访问列表中的两个元素，或者使用模运算符来确定正在访问哪个位置。
- en: 'Don''t do this in Python. We can group related items together using a dictionary,
    as we did in the previous section, or using a list of tuples. Here''s a rather
    convoluted counter-example that demonstrates how we could perform the frequency
    example using a list. It is much more complicated than the dictionary examples,
    and illustrates the effect choosing the right (or wrong) data structure can have
    on the readability of our code. This is demonstrated as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中不要这样做。我们可以使用字典，就像我们在上一节中所做的那样，或者使用元组列表来将相关项分组在一起。以下是一个相当复杂的反例，演示了我们可以如何使用列表执行频率示例。它比字典示例复杂得多，并说明了选择正确（或错误）的数据结构对我们的代码可读性的影响。这如下所示：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code starts with a list of possible characters. The `string.ascii_letters`
    attribute provides a string of all the letters, lowercase and uppercase, in order.
    We convert this to a list, and then use list concatenation (the `+` operator causes
    two lists to be merged into one) to add one more character, a space. These are
    the available characters in our frequency list (the code would break if we tried
    to add a letter that wasn't in the list, but an exception handler could solve
    this).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从一个可能的字符列表开始。`string.ascii_letters` 属性提供了一个包含所有字母（大小写）的字符串，并按顺序排列。我们将这个字符串转换为列表，然后使用列表连接（`+`
    运算符将两个列表合并为一个）添加一个额外的字符，一个空格。这些就是我们的频率列表中可用的字符（如果我们尝试添加不在列表中的字母，代码会出错，但异常处理程序可以解决这个问题）。
- en: The first line inside the function uses a list comprehension to turn the `CHARACTERS`
    list into a list of tuples. List comprehensions are an important, non-object-oriented
    tool in Python; we'll be covering them in detail in the next chapter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 函数内部的第一行使用列表推导将 `CHARACTERS` 列表转换为元组列表。列表推导是 Python 中一个重要的非面向对象工具；我们将在下一章详细讲解它们。
- en: Then, we loop over each of the characters in the sentence. We first look up
    the index of the character in the `CHARACTERS` list, which we know has the same
    index in our frequencies list, since we just created the second list from the
    first. We then update that index in the frequencies list by creating a new tuple,
    discarding the original one. Aside from garbage collection and memory waste concerns,
    this is rather difficult to read!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历句子中的每个字符。我们首先在 `CHARACTERS` 列表中查找字符的索引，我们知道这个索引在我们的频率列表中也是相同的，因为我们刚刚从第一个列表创建了第二个列表。然后我们通过创建一个新的元组来更新频率列表中的那个索引，丢弃原始的元组。除了垃圾回收和内存浪费的担忧之外，这相当难以阅读！
- en: 'Like dictionaries, lists are objects too, and they have several methods that
    can be invoked upon them. Here are some common ones:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 和字典一样，列表也是对象，并且它们有多个可以在其上调用的方法。以下是一些常见的方法：
- en: The `append(element)` method adds an element to the end of the list
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`append(element)` 方法将一个元素添加到列表的末尾'
- en: The `insert(index, element)` method inserts an item at a specific position
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert(index, element)` 方法在指定位置插入一个项目'
- en: The `count(element)` method tells us how many times an element appears in the
    list
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count(element)` 方法告诉我们一个元素在列表中出现的次数'
- en: The `index()`method tells us the index of an item in the list, raising an exception
    if it can't find it
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index()` 方法告诉我们列表中项目的索引，如果找不到它则抛出异常'
- en: The `find()`method does the same thing, but returns `-1` instead of raising
    an exception for missing items
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find()` 方法做同样的事情，但如果没有找到项目则返回 `-1` 而不是抛出异常'
- en: The `reverse()` method does exactly what it says—turns the list around
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse()` 方法确实如其名所示——将列表反转'
- en: The `sort()` method has some rather intricate object-oriented behaviors, which
    we'll cover now
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort()` 方法有一些相当复杂的面向对象行为，我们现在将讲解'
- en: Sorting lists
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序列表
- en: Without any parameters, `sort` will generally do as expected. If it's a list
    of strings, it will place them in alphabetical order. This operation is case sensitive,
    so all capital letters will be sorted before lowercase letters; that is, `Z` comes
    before `a`. If it's a list of numbers, they will be sorted in numerical order.
    If a list of tuples is provided, the list is sorted by the first element in each
    tuple. If a mixture containing unsortable items is supplied, the sort will raise
    a `TypeError` exception.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 不带任何参数，`sort` 通常会按预期工作。如果是一个字符串列表，它将按字母顺序排列。这个操作是区分大小写的，所以所有大写字母都会在所有小写字母之前排序；也就是说，`Z`
    在 `a` 之前。如果是一个数字列表，它们将按数值顺序排序。如果提供了一个包含不可排序项的列表，排序将引发 `TypeError` 异常。
- en: 'If we want to place objects we define ourselves into a list and make those
    objects sortable, we have to do a bit more work. The special `__lt__ ` method,
    which stands for *less than*, should be defined on the class to make instances
    of that class comparable. The `sort` method on the list will access this method
    on each object to determine where it goes in the list. This method should return
    `True` if our class is somehow less than the passed parameter, and `False` otherwise.
    Here''s a rather silly class that can be sorted based on either a string or a
    number:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将我们定义的对象放入列表中并使这些对象可排序，我们必须做更多的工作。特殊的 `__lt__` 方法，代表“小于”，应该在类中定义，以便该类的实例可以进行比较。列表上的
    `sort` 方法将访问每个对象上的此方法以确定它在列表中的位置。此方法应该在我们类以某种方式小于传递的参数时返回 `True`，否则返回 `False`。以下是一个相当愚蠢的类，可以根据字符串或数字进行排序：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `__repr__` method makes it easy to see the two values when we print a list.
    The `__lt__` method''s implementation compares the object to another instance
    of the same class (or any duck-typed object that has `string`, `number`, and `sort_num`
    attributes; it will fail if those attributes are missing). The following output
    illustrates this class in action when it comes to sorting:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`__repr__` 方法使得在打印列表时很容易看到两个值。`__lt__` 方法的实现是将对象与同一类的另一个实例（或任何具有 `string`、`number`
    和 `sort_num` 属性的 duck-typed 对象）进行比较（如果这些属性缺失，它将失败）。以下输出展示了当涉及到排序时这个类是如何工作的：'
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The first time we call `sort`, it sorts by numbers because `sort_num` is `True`
    on all the objects being compared. The second time, it sorts by letters. The `__lt__`
    method is the only one we need to implement to enable sorting. Technically, however,
    if it is implemented, the class should normally also implement the similar `__gt__`,
    `__eq__`, `__ne__`, `__ge__`, and `__le__` methods so that all of the `<`, `>`,
    `==`, `!=`, `>=`, and `<=` operators also work properly. You can get this for
    free by implementing `__lt__` and `__eq__`, and then applying the `@total_ordering`
    class decorator to supply the rest:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用 `sort` 时，它按数字排序，因为所有被比较的对象上 `sort_num` 都是 `True`。第二次，它按字母排序。我们只需要实现 `__lt__`
    方法来启用排序。然而，从技术上讲，如果实现了它，类通常也应该实现类似的 `__gt__`、`__eq__`、`__ne__`、`__ge__` 和 `__le__`
    方法，以便所有 `<`、`>`、`==`、`!=`、`>=` 和 `<=` 运算符也能正常工作。通过实现 `__lt__` 和 `__eq__`，然后应用
    `@total_ordering` 类装饰器来提供其余部分，你可以免费获得这些功能：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is useful if we want to be able to use operators on our objects. However,
    if all we want to do is customize our sort orders, even this is overkill. For
    such a use case, the `sort` method can take an optional `key` argument. This argument
    is a function that can translate each object in a list into an object that can
    somehow be compared. For example, we can use `str.lower` as the key argument to
    perform a case-insensitive sort on a list of strings, as can be seen in the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有用，如果我们想能够在我们的对象上使用运算符。然而，如果我们只想自定义我们的排序顺序，即使是这样做也是过度的。对于这样的用例，`sort` 方法可以接受一个可选的
    `key` 参数。这个参数是一个函数，可以将列表中的每个对象转换成可以比较的对象。例如，我们可以使用 `str.lower` 作为键参数，在字符串列表上执行不区分大小写的排序，如下所示：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Remember, even though `lower` is a method on string objects, it is also a function
    that can accept a single argument, `self`. In other words, `str.lower(item)` is
    equivalent to `item.lower()`. When we pass this function as a key, it performs
    the comparison on lowercase values instead of doing the default case-sensitive
    comparison.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，尽管 `lower` 是字符串对象上的一个方法，但它也是一个可以接受单个参数 `self` 的函数。换句话说，`str.lower(item)`
    等同于 `item.lower()`。当我们把这个函数作为键传递时，它会在小写值上执行比较，而不是执行默认的大小写敏感比较。
- en: 'There are a few sort key operations that are so common that the Python team
    has supplied them so you don''t have to write them yourself. For example, it is
    common to sort a list of tuples by something other than the first item in the
    list. The `operator.itemgetter` method can be used as a key to do this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些排序键操作非常常见，Python 团队已经提供了它们，这样你就不必自己编写它们。例如，按列表中的第一个元素以外的其他元素对元组列表进行排序是很常见的。可以使用
    `operator.itemgetter` 方法作为键来完成这个操作：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `itemgetter` function is the most commonly used one (it works if objects
    are dictionaries, too), but you will sometimes find use for `attrgetter` and `methodcaller`,
    which return attributes on an object and the results of method calls on objects
    for the same purpose. Refer to the `operator` module documentation for more information.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`itemgetter` 函数是最常用的一个（如果对象是字典也可以使用），但有时你也会用到 `attrgetter` 和 `methodcaller`，它们返回对象的属性和对象方法调用的结果，用于相同的目的。有关更多信息，请参阅
    `operator` 模块文档。'
- en: Sets
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: Lists are extremely versatile tools that suit many container object applications.
    But they are not useful when we want to ensure that objects in list are unique.
    For example, a song library may contain many songs by the same artist. If we want
    to sort through the library and create a list of all the artists, we would have
    to check the list to see whether we've added the artist already, before we add
    them again.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是极其多才多艺的工具，适用于许多容器对象应用。但是，当我们想要确保列表中的对象是唯一的时候，它们就不再有用。例如，一个音乐库可能包含许多同一艺术家的歌曲。如果我们想要在库中排序并创建所有艺术家的列表，我们必须在再次添加之前检查列表，看看我们是否已经添加了该艺术家。
- en: This is where sets come in. Sets come from mathematics, where they represent
    an unordered group of (usually) unique numbers. We can add a number to a set five
    times, but it will show up in the set only once.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是集合发挥作用的地方。集合来自数学，它们代表一个无序的（通常是）唯一数字的组。我们可以将一个数字添加到集合中五次，但它只会出现在集合中一次。
- en: 'In Python, sets can hold any hashable object, not just numbers. Hashable objects
    are the same objects that can be used as keys in dictionaries; so again, lists
    and dictionaries are out. Like mathematical sets, they can store only one copy
    of each object. So if we''re trying to create a list of song artists, we can create
    a set of string names and simply add them to the set. This example starts with
    a list of (song, artist) tuples and creates a set of the artists:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，集合可以包含任何可哈希的对象，而不仅仅是数字。可哈希的对象是那些可以用作字典键的对象；因此，列表和字典又排除了。像数学集合一样，它们只能存储每个对象的单个副本。所以如果我们试图创建一个歌曲艺术家的列表，我们可以创建一个字符串名称的集合，并将它们简单地添加到集合中。这个例子从一个包含（歌曲，艺术家）元组的列表开始，创建了一个艺术家集合：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There is no built-in syntax for an empty set as there is for lists and dictionaries;
    we create a set using the `set()` constructor. However, we can use the curly braces
    (borrowed from dictionary syntax) to create a set, so long as the set contains
    values. If we use colons to separate pairs of values, it''s a dictionary, as in
    `{''key'': ''value'', ''key2'': ''value2''}`. If we just separate values with
    commas, it''s a set, as in `{''value'', ''value2''}`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '与列表和字典不同，没有为空集合提供内置语法；我们使用 `set()` 构造函数创建集合。然而，只要集合包含值，我们就可以使用大括号（从字典语法中借用）来创建一个集合。如果我们使用冒号分隔值对，它就是一个字典，例如
    `{''key'': ''value'', ''key2'': ''value2''}`。如果我们只是用逗号分隔值，它就是一个集合，例如 `{''value'',
    ''value2''}`。'
- en: 'Items can be added individually to the set using its `add` method. If we run
    this script, we see that the set works as advertised:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用集合的 `add` 方法单独向集合中添加项目。如果我们运行这个脚本，我们会看到集合按预期工作：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you''re paying attention to the output, you''ll notice that the items are
    not printed in the order they were added to the sets. Sets are inherently unordered
    due to a hash-based data structure for efficiency. Because of this lack of ordering,
    sets cannot have items looked up by index. The primary purpose of a set is to
    divide the world into two groups: *things that are in the set*, and *things that
    are not in the set*. It is easy to check whether an item is in a set or to loop
    over the items in a set, but if we want to sort or order them, we have to convert
    the set to a list. This output shows all three of these activities:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了输出，你会注意到项目不是按照它们被添加到集合中的顺序打印的。由于基于哈希的数据结构以提高效率，集合本身是无序的。由于这种无序性，集合不能通过索引查找项目。集合的主要目的是将世界分为两组：*集合中的事物*和*不在集合中的事物*。检查一个项目是否在集合中或遍历集合中的项目很容易，但如果我们想要对它们进行排序或排序，我们必须将集合转换为列表。这个输出显示了所有这三个活动：
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: While the primary *feature* of a set is uniqueness, that is not its primary
    *purpose*. Sets are most useful when two or more of them are used in combination.
    Most of the methods on the set type operate on other sets, allowing us to efficiently
    combine or compare the items in two or more sets. These methods have strange names,
    since they use the terminology used in mathematics. We'll start with three methods
    that return the same result, regardless of which is the calling set and which
    is the called set.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然集合的主要特征是唯一性，但这并不是它的主要用途。当两个或多个集合组合使用时，集合最有用。集合类型上的大多数方法都作用于其他集合，使我们能够有效地组合或比较两个或多个集合中的项目。这些方法有奇怪的名字，因为它们使用了数学中的术语。我们将从三个返回相同结果的方法开始，无论调用集合和被调用集合是哪一个。
- en: The `union` method is the most common and easiest to understand. It takes a
    second set as a parameter and returns a new set that contains all elements that
    are in *either* of the two sets; if an element is in both original sets, it will,
    of course, only show up once in the new set. Union is like a logical `or` operation.
    Indeed, the `|` operator can be used on two sets to perform the union operation,
    if you don't like calling methods.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`union`方法是最常见的，也最容易理解。它接受一个作为参数的第二个集合，并返回一个新集合，该集合包含两个集合中的所有元素；如果一个元素在原始的两个集合中，它当然只会在新集合中出现一次。Union就像一个逻辑`or`操作。实际上，如果你不喜欢调用方法，可以使用`|`运算符对两个集合执行并集操作。'
- en: Conversely, the intersection method accepts a second set and returns a new set
    that contains only those elements that are in *both* sets. It is like a logical
    `and` operation, and can also be referenced using the `&` operator.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，交集方法接受一个第二个集合，并返回一个新集合，该集合仅包含两个集合中都有的元素。它就像一个逻辑`and`操作，也可以使用`&`运算符来引用。
- en: 'Finally, the `symmetric_difference` method tells us what''s left; it is the
    set of objects that are in one set or the other, but not both. The following example
    illustrates these methods by comparing some artists preferred by two different
    people:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`symmetric_difference`方法告诉我们剩下的是什么；它是那些在一个集合或另一个集合中但不在两个集合中的对象的集合。以下示例通过比较两个不同的人喜欢的某些艺术家来说明这些方法：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we run this code, we see that these three methods do what the print statements
    suggest they will do:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们会看到这三个方法都做了打印语句所暗示的事情：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: These methods all return the same result, regardless of which set calls the
    other. We can say `first_artists.union(second_artists)` or `second_artists.union(first_artists)`
    and get the same result. There are also methods that return different results
    depending on who is the caller and who is the argument.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法无论哪个集合调用另一个集合都返回相同的结果。我们可以说`first_artists.union(second_artists)`或`second_artists.union(first_artists)`并得到相同的结果。还有一些方法根据调用者和参数返回不同的结果。
- en: These methods include `issubset` and `issuperset`, which are the inverse of
    each other. Both return a `bool`. The `issubset` method returns `True`, if all
    of the items in the calling set are also in the set passed as an argument. The
    `issuperset` method returns `True` if all of the items in the argument are also
    in the calling set. Thus, `s.issubset(t)` and `t.issuperset(s)` are identical.
    They will both return `True` if `t` contains all the elements in `s`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法包括`issubset`和`issuperset`，它们是彼此的逆。两者都返回一个布尔值。`issubset`方法在调用集合中的所有项目也在作为参数传递的集合中时返回`True`。`issuperset`方法在参数中的所有项目也在调用集合中时返回`True`。因此，`s.issubset(t)`和`t.issuperset(s)`是相同的。如果`t`包含`s`中的所有元素，它们都会返回`True`。
- en: 'Finally, the `difference` method returns all the elements that are in the calling
    set, but not in the set passed as an argument; this is like half a `symmetric_difference`.
    The `difference` method can also be represented by the `-` operator. The following
    code illustrates these methods in action:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`difference`方法返回调用集合中但在作为参数传递的集合中不存在的所有元素；这就像半个`symmetric_difference`。`difference`方法也可以用`-`运算符表示。以下代码展示了这些方法的作用：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This code simply prints out the response of each method when called from one
    set on the other. Running it gives us the following output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只是简单地打印出从一个集合调用另一个集合时每个方法的响应。运行它给出以下输出：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `difference` method, in the second case, returns an empty set, since there
    are no items in `bands` that are not in `first_artists`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，`difference`方法返回一个空集，因为`bands`中没有不在`first_artists`中的项目。
- en: The `union`, `intersection`, and `difference` methods can all take multiple
    sets as arguments; they will return, as we might expect, the set that is created
    when the operation is called on all the parameters.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`union`、`intersection`和`difference`方法都可以接受多个集合作为参数；正如我们可能预期的，它们将返回当操作被调用在所有参数上时创建的集合。'
- en: So, the methods on sets clearly suggest that sets are meant to operate on other
    sets, and that they are not just containers. If we have data coming in from two
    different sources and need to quickly combine them in some way, so as to determine
    where the data overlaps or is different, we can use set operations to efficiently
    compare them. Or, if we have data incoming that may contain duplicates of data
    that has already been processed, we can use sets to compare the two and process
    only the new data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，集合上的方法清楚地表明，集合旨在操作其他集合，并且它们不仅仅是容器。如果我们从两个不同的来源接收数据，并需要以某种方式快速合并它们，以确定数据重叠或不同，我们可以使用集合操作来有效地比较它们。或者，如果我们接收到的数据可能包含已经处理过的数据的重复项，我们可以使用集合来比较这两个数据集，并只处理新数据。
- en: Finally, it is valuable to know that sets are much more efficient than lists
    when checking for membership using the `in` keyword. If you use the `value in
    container` syntax on a set or a list, it will return `True` if one of the elements
    in `container` is equal to `value`, and `False` otherwise. However, in a list,
    it will look at every object in the container until it finds the value, whereas
    in a set, it simply hashes the value and checks for membership. This means that
    a set will find the value in the same amount of time no matter how big the container
    is, but a list will take longer and longer to search for a value as the list contains
    more and more values.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，了解集合在检查成员资格时比列表更有效率是有价值的。如果你在集合或列表上使用`value in container`语法，如果`container`中的任何一个元素等于`value`，它将返回`True`，否则返回`False`。然而，在列表中，它将检查容器中的每个对象，直到找到该值，而在集合中，它只是对值进行哈希并检查成员资格。这意味着无论容器有多大，集合都会在相同的时间内找到值，但列表随着包含更多值而搜索值所需的时间会越来越长。
- en: Extending built-in functions
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展内置函数
- en: We discussed briefly in [Chapter 3](ba7b3eb7-17cc-4f1c-bb74-fb7d5ee7d517.xhtml),
    *When Objects Are Alike*, how built-in data types can be extended using inheritance.
    Now, we'll go into more detail as to when we would want to do that.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](ba7b3eb7-17cc-4f1c-bb74-fb7d5ee7d517.xhtml)中简要讨论了*当对象相似时*，如何使用继承扩展内置数据类型。现在，我们将更详细地讨论我们何时想要这样做。
- en: When we have a built-in container object that we want to add functionality to,
    we have two options. We can either create a new object, which holds that container
    as an attribute (composition), or we can subclass the built-in object and add
    or adapt methods on it to do what we want (inheritance).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个想要添加功能的内置容器对象时，我们有两个选择。我们可以创建一个新的对象，它将该容器作为属性持有（组合），或者我们可以创建内置对象的子类，并添加或修改方法以实现我们想要的功能（继承）。
- en: Composition is usually the best alternative if all we want to do is use the
    container to store some objects using that container's features. That way, it's
    easy to pass that data structure into other methods and they will know how to
    interact with it. But we need to use inheritance if we want to change the way
    the container actually works. For example, if we want to ensure every item in
    a `list` is a string with exactly five characters, we need to extend `list` and
    override the `append()` method to raise an exception for invalid input. We'd also
    minimally have to override `__setitem__(self,``index,``value)`, a special method
    on lists that is called whenever we use the `x[index]``=``"value"` syntax, and
    the `extend()` method.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想使用容器来存储一些对象并利用该容器的特性，那么组合通常是最好的选择。这样，很容易将这种数据结构传递给其他方法，它们将知道如何与之交互。但是，如果我们想要改变容器实际工作的方式，我们就需要使用继承。例如，如果我们想要确保`list`中的每个元素都是一个恰好有五个字符的字符串，我们需要扩展`list`并重写`append()`方法来为无效输入抛出异常。我们可能还需要最小化地重写`__setitem__(self,
    index, value)`，这是一个列表上的特殊方法，每次我们使用`x[index] = "value"`语法时都会被调用，以及`extend()`方法。
- en: 'Yes, lists are objects. All that special non-object-oriented looking syntax
    we''ve been looking at for accessing lists or dictionary keys, looping over containers,
    and similar tasks, is actually `syntactic sugar` that maps to an object-oriented
    paradigm underneath. We might ask the Python designers why they did this. Isn''t
    object-oriented programming *always* better? That question is easy to answer.
    In the following hypothetical examples, which is easier to read, as a programmer?
    Which requires less typing?:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，列表是对象。我们之前看到的用于访问列表或字典键、遍历容器和类似任务的特殊非面向对象语法，实际上是映射到面向对象范式的 `syntactic sugar`。我们可能会问
    Python 设计者为什么这样做。面向对象编程难道不是“总是”更好的吗？这个问题很容易回答。在以下假设的例子中，作为程序员，哪个更容易阅读？哪个需要更少的输入？：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The highlighted sections show what object-oriented code might look like (in
    practice, these methods actually exist as special double-underscore methods on
    associated objects). Python programmers agree that the non-object-oriented syntax
    is easier both to read and to write. Yet all of the preceding Python syntaxes
    map to object-oriented methods underneath the hood. These methods have special
    names (with double-underscores before and after) to remind us that there is a
    better syntax out there. However, it gives us the means to override these behaviors.
    For example, we can make a special integer that always returns `0` when we add
    two of them together, demonstrated as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的部分显示了面向对象代码可能的样子（实际上，这些方法作为特殊双下划线方法存在于相关对象上）。Python 程序员一致认为，非面向对象的语法在阅读和编写时都更容易。然而，所有前面的
    Python 语法在底层都映射到面向对象的方法。这些方法有特殊的名字（前后都有双下划线），以提醒我们还有更好的语法。然而，它给了我们覆盖这些行为的方法。例如，我们可以创建一个特殊的整数，当我们将其与另一个整数相加时，它总是返回
    `0`，如下所示：
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is an extremely bizarre thing to do, granted, but it perfectly illustrates
    these object-oriented principles in action:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做非常奇怪，但它完美地说明了这些面向对象原则的实际应用：
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The awesome thing about the `__add__` method is that we can add it to any class
    we write, and if we use the `+` operator on instances of that class, it will be
    called. This is how string, tuple, and list concatenation works, for example.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`__add__` 方法的神奇之处在于我们可以将其添加到我们编写的任何类中，如果我们使用该类的实例上的 `+` 运算符，它将被调用。这就是字符串、元组和列表连接工作的方式。'
- en: This is true of all the special methods. If we want to use `x``in``myobj` syntax
    for a custom-defined object, we can implement `__contains__`. If we want to use
    the `myobj[i]``=``value` syntax, we supply a `__setitem__` method, and if we want
    to use `something``=``myobj[i]`, we implement `__getitem__`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点对所有特殊方法都适用。如果我们想为自定义对象使用 `x``in``myobj` 语法，我们可以实现 `__contains__`。如果我们想使用
    `myobj[i]``=``value` 语法，我们提供 `__setitem__` 方法，而如果我们想使用 `something``=``myobj[i]`，我们实现
    `__getitem__`。
- en: 'There are 33 of these special methods in the `list` class. We can use the `dir`
    function to see all of them, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列表类中有 33 个这样的特殊方法。我们可以使用 `dir` 函数查看所有这些方法，如下所示：
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Furthermore, if we desire additional information on how any of these methods
    work, we can use the `help` function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们想了解这些方法中的任何一种的工作方式，我们可以使用 `help` 函数：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `+` operator on lists concatenates two lists. We don't have room to discuss
    all of the available special functions in this book, but you are now able to explore
    all this functionality with `dir` and `help`. The official online Python reference
    ([https://docs.python.org/3/](https://docs.python.org/3/)) has plenty of useful
    information as well. Focus especially on the abstract base classes discussed in
    the `collections` module.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表上的 `+` 运算符将两个列表连接起来。我们没有足够的空间来讨论本书中所有可用的特殊函数，但你现在可以使用 `dir` 和 `help` 探索所有这些功能。官方在线
    Python 参考 ([https://docs.python.org/3/](https://docs.python.org/3/)) 也有大量有用的信息。特别关注
    `collections` 模块中讨论的抽象基类。
- en: 'So, to get back to the earlier point about when we would want to use composition
    versus inheritance: if we need to somehow change any of the methods on the class,
    including the special methods, we definitely need to use inheritance. If we used
    composition, we could write methods that perform the validation or alterations
    and ask the caller to use those methods, but there is nothing stopping them from
    accessing the property directly. They could insert an item into our list that
    does not have five characters, and that might confuse other methods in the list.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回到我们之前讨论的关于何时使用组合而不是继承的问题：如果我们需要以某种方式更改类上的任何方法，包括特殊方法，我们绝对需要使用继承。如果我们使用组合，我们可以编写执行验证或更改的方法，并要求调用者使用这些方法，但没有任何阻止他们直接访问属性的方法。他们可以在我们的列表中插入一个没有五个字符的项目，这可能会使列表中的其他方法产生混淆。
- en: Often, the need to extend a built-in data type is an indication that we're using
    the wrong sort of data type. It is not always the case, but if we are looking
    to extend a built-in, we should carefully consider whether or not a different
    data structure would be more suitable.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，需要扩展内置数据类型的需求表明我们可能使用了错误类型的数据。这并不总是这种情况，但如果我们正在寻找扩展内置类型，我们应该仔细考虑是否不同的数据结构会更合适。
- en: Case study
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: 'To tie everything together, we''ll be writing a simple link collector, which
    will visit a website and collect every link on every page it finds in that site.
    Before we start, though, we''ll need some test data to work with. Simply write
    some HTML files to work with that contain links to each other and to other sites
    on the internet, something like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将所有这些内容串联起来，我们将编写一个简单的链接收集器，它将访问一个网站并收集该网站上每个页面的每个链接。在我们开始之前，我们需要一些测试数据来工作。只需编写一些包含相互链接以及指向互联网上其他网站的链接的HTML文件即可，类似于以下内容：
- en: '[PRE50]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Name one of the files `index.html` so it shows up first when pages are served.
    Make sure the other files exist, and keep things complicated so that there is
    lots of linking between them. The examples for this chapter include a directory
    called `case_study_serve` (one of the lamest personal websites in existence!)
    if you would rather not set them up yourself.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将其中一个文件命名为`index.html`，以便在页面被提供时首先显示。确保其他文件存在，并使事情复杂化，以便它们之间有大量的链接。如果不想自己设置，本章的示例包括一个名为`case_study_serve`的目录（现有最糟糕的个人网站之一！）。
- en: 'Now, start a simple web server by entering the directory containing all these
    files and run the following command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过进入包含所有这些文件的目录并运行以下命令来启动一个简单的Web服务器：
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This will start a server running on port 8000; you can see the pages you made
    by visiting `http://localhost:8000/` in your web browser.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在端口8000上启动一个服务器；您可以通过在Web浏览器中访问`http://localhost:8000/`来查看您创建的页面。
- en: 'The goal is to pass our collector the base URL for the site (in this case:
    `http://localhost:8000/`), and have it create a list containing every unique link
    on the site. We''ll need to take into account three types of URLs (links to external
    sites, which start with `http://`, absolute internal links, which start with a
    `/` character, and relative links, for everything else). We also need to be aware
    that pages may link to each other in a loop; we need to be sure we don''t process
    the same page multiple times, or it may never end. With all this uniqueness going
    on, it sounds like we''re going to need some sets.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是传递给我们的收集器网站的基准URL（在这个例子中：`http://localhost:8000/`），并让它创建一个包含网站上每个唯一链接的列表。我们需要考虑三种类型的URL（指向外部网站的链接，以`http://`开头，绝对内部链接，以`/`字符开头，以及相对链接，用于其他所有内容）。我们还需要意识到页面可能通过循环相互链接；我们需要确保我们不会多次处理同一页面，否则它可能永远不会结束。考虑到所有这些独特性，听起来我们可能需要一些集合。
- en: 'Before we get into that, let''s start with the basics. Here''s the code to
    connect to a page and parse all the links in that page:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨之前，让我们从基础知识开始。以下是连接到页面并解析该页面中所有链接的代码：
- en: '[PRE52]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is a short piece of code, considering what it's doing. It connects to the
    server in the argument passed on the command line, downloads the page, and extracts
    all the links on that page. The `__init__` method uses the `urlparse` function
    to extract just the hostname from the URL; so even if we pass in `http://localhost:8000/some/page.html`,
    it will still operate on the top level of the `http://localhost:8000/` host. This
    makes sense, because we want to collect all the links on the site, although it
    assumes every page is connected to the index by some sequence of links.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很短，考虑到它所做的事情。它连接到命令行参数传递的服务器，下载页面，并提取该页面上所有的链接。`__init__` 方法使用 `urlparse`
    函数从URL中提取主机名；因此，即使我们传递 `http://localhost:8000/some/page.html`，它仍然在 `http://localhost:8000/`
    主机的高级别上操作。这很有意义，因为我们想要收集网站上所有的链接，尽管它假设每个页面都通过一系列链接与索引相连。
- en: The `collect_links` method connects to and downloads the specified page from
    the server, and uses a regular expression to find all the links on the page. Regular
    expressions are an extremely powerful string processing tool. Unfortunately, they
    have a steep learning curve; if you haven't used them before, I strongly recommend
    studying any of the many entire books or websites on the topic. If you don't think
    they're worth knowing about, try writing the preceding code without them and you'll
    change your mind.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`collect_links` 方法连接到并从服务器下载指定的页面，并使用正则表达式在该页面上找到所有链接。正则表达式是一个非常强大的字符串处理工具。不幸的是，它们的学习曲线很陡峭；如果你以前没有使用过它们，我强烈建议你研究关于这个主题的许多完整书籍或网站。如果你认为它们不值得了解，试着在不使用它们的情况下编写前面的代码，你会改变主意的。'
- en: 'The example also stops in the middle of the `collect_links` method to print
    the value of links. This is a common way to test a program as we''re writing it:
    stop and output the value to ensure it is the value we expect. Here''s what it
    outputs for our example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 示例还在 `collect_links` 方法的中间停止以打印链接的值。这是我们编写程序时测试程序的一种常见方式：停止并输出值以确保它是我们期望的值。以下是它为我们示例输出的内容：
- en: '[PRE53]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'So, now we have a collection of all the links in the first page. What can we
    do with it? We can''t just pop the links into a set to remove duplicates, because
    links may be relative or absolute. For example, `contact.html` and `/contact.html`
    point to the same page. So the first thing we should do is normalize all the links
    to their full URL, including the hostname and relative path. We can do this by
    adding a `normalize_url` method to our object:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们收集了第一页上所有的链接。我们能用它做什么呢？我们不能简单地将链接放入一个集合中以去除重复项，因为链接可能是相对的或绝对的。例如，`contact.html`
    和 `/contact.html` 都指向同一个页面。所以我们应该做的第一件事是将所有链接规范化为它们的完整URL，包括主机名和相对路径。我们可以通过给我们的对象添加一个
    `normalize_url` 方法来实现这一点：
- en: '[PRE54]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This method converts each URL to a complete address that includes a protocol
    and a hostname. Now, the two contact pages have the same value and we can store
    them in a set. We'll have to modify `__init__` to create the set, and `collect_links`
    to put all the links into it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将每个URL转换为包含协议和主机名的完整地址。现在，两个联系页面具有相同的值，我们可以将它们存储在集合中。我们将不得不修改 `__init__`
    以创建集合，并将 `collect_links` 修改为将所有链接放入其中。
- en: 'Then, we''ll have to visit all the non-external links and collect them too.
    But wait a minute; if we do this, how do we keep from revisiting a link when we
    encounter the same page twice? It looks like we''re actually going to need two
    sets: a set of collected links, and a set of visited links. This suggests that
    we were wise to choose a set to represent our data; we know that sets are most
    useful when we''re manipulating more than one of them. Let''s set these up as
    follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们还需要访问所有非外部链接并将它们也收集起来。但是等等；如果我们这样做，当我们遇到相同的页面两次时，我们如何避免重复访问链接呢？看起来我们实际上需要两个集合：一个是收集到的链接集合，另一个是已访问的链接集合。这表明我们选择集合来表示数据是明智的；我们知道集合在处理多个集合时最有用。让我们按照以下方式设置它们：
- en: '[PRE55]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The line that creates the normalized list of links uses a `set` comprehension
    (we''ll be covering these in detail in the next chapter). Once again, the method
    stops to print out the current values, so we can verify that we don''t have our
    sets confused, and that `difference` really was the method we wanted to call to
    collect `unvisited_links`. We can then add a few lines of code that loop over
    all the unvisited links and add them to the collection as well, demonstrated as
    follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 创建包含链接的标准化列表的行使用了一个`set`推导式（我们将在下一章详细讲解这些内容）。再次强调，该方法会停止打印当前值，以便我们可以验证我们没有混淆集合，并且确实调用了`difference`方法来收集`unvisited_links`。然后我们可以添加几行代码，遍历所有未访问的链接并将它们添加到集合中，如下所示：
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `if` statement ensures that we are only collecting links from the one website;
    we don''t want to go off and collect all the links from all the pages on the internet
    (unless we''re Google or Internet Archive!). If we modify the main code at the
    bottom of the program to output the collected links, we can see it seems to have
    collected them all, as can be seen in the following block of code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句确保我们只从单个网站收集链接；我们不希望离开并从互联网上的所有页面收集所有链接（除非我们是谷歌或互联网档案馆！）。如果我们修改程序底部的主体代码以输出收集到的链接，我们可以看到它似乎已经收集了它们，如下面的代码块所示：'
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'It displays all the links we''ve collected, and only once, even though many
    of the pages in my example linked to each other multiple times, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了所有收集到的链接，并且只显示一次，尽管在我的示例中许多页面相互链接多次，如下所示：
- en: '[PRE58]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Even though it collected links *to* external pages, it didn't go off collecting
    links *from* any of the external pages we linked to. This is a great little program
    if we want to collect all the links on a site. But it doesn't give me all the
    information I might need to build a site map; it tells me which pages I have,
    but it doesn't tell me which pages link to other pages. If we want to do that
    instead, we're going to have to make some modifications.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它收集了指向外部页面的链接，但它并没有从我们链接到的任何外部页面收集链接。如果我们想收集网站上所有的链接，这是一个很棒的程序。但它并没有给我提供我可能需要构建网站地图的所有信息；它告诉我我有哪些页面，但它没有告诉我哪些页面链接到其他页面。如果我们想做到这一点，我们不得不做一些修改。
- en: 'The first thing we should do is look at our data structures. The set of collected
    links doesn''t work any more; we want to know which links were linked to from
    which pages. We can turn that set into a dictionary of sets for each page we visit.
    The dictionary keys will represent the exact same data that is currently in the
    set. The values will be sets of all the links on that page. The changes are as
    follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先应该查看我们的数据结构。收集到的链接集合不再起作用；我们想知道哪些链接是从哪些页面链接过来的。我们可以将这个集合转换成每个访问的页面的集合字典。字典的键将代表当前集合中确切相同的数据。值将是该页面上所有链接的集合。以下是更改内容：
- en: '[PRE59]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: There are surprisingly few changes; the line that originally created a union
    of two sets has been replaced with three lines that update the dictionary. The
    first of these simply tells the dictionary what the collected links for that page
    are. The second creates an empty set for any items in the dictionary that have
    not already been added to the dictionary using `setdefault`. The result is a dictionary
    that contains all the links as its keys, mapped to sets of links for all the internal
    links, and empty sets for the external links.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 改变很少；原本创建两个集合并集的行已被替换为三条更新字典的行。第一条简单地告诉字典该页面的收集链接是什么。第二条使用`setdefault`为字典中尚未添加到字典中的任何项创建一个空集合。结果是包含所有链接作为键的字典，映射到所有内部链接的链接集合，以及外部链接的空集合。
- en: 'Finally, instead of recursively calling `collect_links`, we can use a queue
    to store the links that haven''t been processed yet. This implementation won''t
    support concurrency, but this would be a good first step to creating a multithreaded
    version that makes multiple requests in parallel to save time:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不再递归调用`collect_links`，而是可以使用队列来存储尚未处理的链接。这种实现不会支持并发，但这将是创建一个多线程版本的良好第一步，该版本可以并行发送多个请求以节省时间：
- en: '[PRE60]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: I had to manually strip any trailing forward slashes in the `normalize_url`
    method to remove duplicates in this version of the code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我不得不手动在`normalize_url`方法中删除任何尾随的正斜杠，以消除此代码版本中的重复项。
- en: Because the end result is an unsorted dictionary, there is no restriction on
    which order the links should be processed in. Therefore, we could just as easily
    have used a `LifoQueue` instead of a `Queue` here. A priority queue probably wouldn't
    make a lot of sense, since there is no obvious priority to attach to a link in
    this case.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 因为最终结果是未排序的字典，所以没有限制链接应该以什么顺序处理。因此，我们也可以同样容易地使用`LifoQueue`而不是`Queue`。在这种情况下，优先队列可能没有太多意义，因为没有明显的优先级可以附加到链接上。
- en: Exercises
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: The best way to learn how to choose the correct data structure is to do it wrong
    a few times (intentionally or accidentally!). Take some code you've recently written,
    or write some new code that uses a list. Try rewriting it using some different
    data structures. Which ones make more sense? Which ones don't? Which have the
    most elegant code?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何选择正确的数据结构的最佳方式是先错误地做几次（故意或意外地！）！取一些你最近写的代码，或者写一些使用列表的新代码。尝试使用不同的数据结构重写它。哪一些更有意义？哪一些没有？哪一些的代码最优雅？
- en: Try this with a few different pairs of data structures. You can look at examples
    you've done for previous chapter exercises. Are there objects with methods where
    you could have used dataclasses, `namedtuple`, or `dict` instead? Attempt both
    and see. Are there dictionaries that could have been sets because you don't really
    access the values? Do you have lists that check for duplicates? Would a set suffice?
    Or maybe several sets? Would one of the queue implementations be more efficient?
    Is it useful to restrict the API to the top of a stack rather than allowing random
    access to the list?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 用几对不同数据结构对的方法试一试。你可以查看之前章节练习中做的例子。有没有对象有方法，你可以使用数据类、`namedtuple`或`dict`来代替？尝试两种方法，看看。有没有字典可以变成集合，因为你实际上并没有访问值？你有没有检查重复的列表？一个集合是否足够？或者可能是几个集合？队列实现中的一个是否更高效？将API限制在栈顶而不是允许随机访问列表是否有用？
- en: If you want some specific examples to work with, try adapting the link collector
    to also save the title used for each link. Perhaps you can generate a site map
    in HTML that lists all the pages on the site, and that contains a list of links
    to other pages, named with the same link titles.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一些具体的例子来操作，尝试调整链接收集器，使其也保存每个链接使用的标题。也许你可以生成一个HTML网站地图，列出网站上的所有页面，并包含一个指向其他页面的链接列表，这些链接使用相同的链接标题。
- en: Have you written any container objects recently that you could improve by inheriting
    a built-in and overriding some of the *special* double-underscore methods? You
    may have to do some research (using `dir` and `help`, or the Python library reference)
    to find out which methods need overriding. Are you sure inheritance is the correct
    tool to apply; could a composition-based solution be more effective? Try both
    (if it's possible) before you decide. Try to find different situations where each
    method is better than the other.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你最近是否编写过任何可以通过继承内置类型并重写一些特殊双下划线方法来改进的容器对象？你可能需要做一些研究（使用`dir`和`help`，或者Python库参考）来找出哪些方法需要重写。你确定继承是正确的工具吗？基于组合的解决方案可能更有效？在你决定之前，尝试两种方法（如果可能的话）。尝试找到不同的情况下，每种方法比另一种方法更好的情况。
- en: If you were familiar with the various Python data structures and their uses
    before you started this chapter, you may have been bored. But if that is the case,
    there's a good chance you use data structures too much! Look at some of your old
    code and rewrite it to use more self-made classes. Carefully consider the alternatives
    and try them all out; which one makes for the most readable and maintainable system?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这章开始之前就已经熟悉了各种Python数据结构和它们的用途，你可能感到无聊。但如果是这样的话，你很可能过度使用了数据结构！看看你的一些旧代码，并尝试将其重写为使用更多自定义类。仔细考虑替代方案，并尝试所有方案；哪一个能让你构建出最易读和可维护的系统？
- en: Always critically evaluate your code and design decisions. Make a habit of reviewing
    old code and take note if your understanding of *good design* has changed since
    you've written it. Software design has a large aesthetic component, and like artists
    with oil on canvas, we all have to find the style that suits us best.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 总是批判性地评估你的代码和设计决策。养成回顾旧代码的习惯，并注意自从你编写它以来你对“良好设计”的理解是否发生了变化。软件设计有很大的美学成分，就像在画布上用油画的艺术家一样，我们都需要找到最适合我们的风格。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've covered several built-in data structures and attempted to understand how
    to choose one for specific applications. Sometimes, the best thing we can do is
    create a new class of objects, but often, one of the built-ins provides exactly
    what we need. When it doesn't, we can always use inheritance or composition to
    adapt them to our use cases. We can even override special methods to completely
    change the behavior of built-in syntaxes.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了几个内置的数据结构，并尝试理解如何为特定的应用选择一个。有时，我们能做的最好的事情就是创建一个新的对象类，但通常，内置的其中一个就能提供我们所需的一切。当它不能满足需求时，我们总能使用继承或组合来适应我们的使用场景。我们甚至可以覆盖特殊方法来完全改变内置语法的行为。
- en: In the next chapter, we'll discuss how to integrate the object-oriented and
    not-so-object-oriented aspects of Python. Along the way, we'll discover that it's
    more object-oriented than it looks at first sight!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何整合Python的面向对象和非面向对象方面。在这个过程中，我们会发现Python的面向对象特性比第一眼看上去要丰富得多！
