- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Comprehensions and Generators
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和生成器
- en: ”It’s not the daily increase but daily decrease. Hack away at the unessential.”
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “不是每天的增量，而是每天的减量。砍掉不必要的东西。”
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Bruce Lee
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——李小龙
- en: The second part of the above quote, “hack away at the unessential,” is to us
    what makes a computer program elegant. We constantly strive to find better ways
    of doing things so that we do not waste time or memory.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 上述引言的第二部分，“砍掉不必要的东西”，对我们来说正是使计算机程序优雅的原因。我们不断努力寻找更好的做事方式，以便我们不浪费时间或内存。
- en: There are valid reasons for not pushing our code up to the maximum limit. For
    example, sometimes we have to sacrifice readability or maintainability to achieve
    a negligible improvement. It does not make sense to have a web page served in
    1 second with unreadable, complicated code when we could serve it in 1.05 seconds
    with readable, clean code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些合理的理由不将我们的代码推到最大极限。例如，有时我们不得不牺牲可读性或可维护性以换取微小的改进。当我们可以用可读、干净的代码在1.05秒内提供服务时，用难以阅读、复杂的代码在1秒内提供服务是没有意义的。
- en: On the other hand, sometimes it is perfectly reasonable to try to shave off
    a millisecond from a function, especially when the function is meant to be called
    thousands of times. One millisecond saved over thousands of calls adds up to seconds
    saved overall, which might be meaningful for your application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有时尝试从函数中节省一毫秒是完全合理的，特别是当函数打算被调用数千次时。在数千次调用中节省的一毫秒可以累积成秒，这可能会对你的应用程序有意义。
- en: In light of these considerations, the focus of this chapter will not be to give
    you the tools to push your code to the absolute limits of performance and optimization
    *no matter what* , but rather to enable you to write efficient, elegant code that
    reads well, runs fast, and does not waste resources in an obvious way.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些因素，本章的重点不是给你工具来让你的代码无论什么情况下都能达到性能和优化的绝对极限，而是让你能够编写高效、优雅的代码，易于阅读，运行速度快，并且不会以明显的方式浪费资源。
- en: 'In this chapter, we are going to cover the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: The `map()` , `zip()` , and `filter()` functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()`、`zip()`和`filter()`函数'
- en: Comprehensions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解
- en: Generators
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器
- en: Performance
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能
- en: We will perform several measurements and comparisons and cautiously draw some
    conclusions. Please do keep in mind that on a different machine with a different
    setup or operating system, results may vary.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行多次测量和比较，并谨慎地得出一些结论。请务必记住，在不同的机器、不同的设置或操作系统上，结果可能会有所不同。
- en: 'Take a look at this code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这段代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Both functions return the square of `n` , but which is faster? From a simple
    benchmark that we ran, it looks like the second is slightly faster. If you think
    about it, it makes sense: calculating the power of a number involves multiplication.
    Therefore, whatever algorithm you may use to perform the power operation, it is
    not likely to beat a simple multiplication such as the one in `square2` .'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都返回`n`的平方，但哪个更快？从我们运行的一个简单基准测试来看，第二个似乎稍微快一点。如果你这么想，这是有道理的：计算一个数的幂涉及乘法。因此，无论你使用什么算法来执行幂运算，都不太可能打败`square2`中的简单乘法。
- en: Do we care about this result? In most cases, no. If you are coding an e-commerce
    website, chances are you will never need to raise a number to the second power,
    and if you do, it is likely to be a sporadic operation. You do not need to concern
    yourself with saving a fraction of a microsecond on a function you call a few
    times.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关心这个结果吗？在大多数情况下，不关心。如果你正在编写一个电子商务网站，你很可能永远不需要将一个数字提高到平方，即使你这样做，也很可能是偶尔的操作。你不需要担心在调用几次函数时节省几分之一微秒。
- en: So, when does optimization become important? One common case is when you have
    to deal with huge collections of data. If you are applying the same function on
    a million `customer` objects, then you want your function to be tuned up to its
    best. Gaining one-tenth of a second on a function called one million times saves
    you 100,000 seconds, which is about 27.7 hours. So, let us focus on collections,
    and see which tools Python gives you to handle them with efficiency and grace.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，何时优化变得重要呢？一个常见的例子是当你必须处理大量数据时。如果你要对一百万个`customer`对象应用相同的函数，那么你希望你的函数调优到最佳状态。对一个被调用一百万次的函数节省十分之一秒可以节省100,000秒，这大约是27.7小时。因此，让我们关注集合，看看Python为你提供了哪些工具来高效、优雅地处理它们。
- en: Many of the concepts we will see in this chapter are based on iterators and
    iterables, which we encountered in *Chapter 3* , *Conditionals and Iteration*
    . We will see how to code a custom iterator and iterable objects in *Chapter 6*
    , *OOP, Decorators, and Iterators* .
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将看到的大多数概念都是基于迭代器和可迭代对象，我们在 *第 3 章* ，*条件语句和迭代* 中遇到了它们。我们将看到如何在 *第 6 章* ，*面向对象编程、装饰器和迭代器*
    中编码自定义迭代器和可迭代对象。
- en: 'Some of the objects we are going to explore in this chapter are iterators,
    which save memory by only operating on a single element of a collection at a time
    rather than creating a modified copy. As a result, some extra work is needed if
    we just want to show the result of the operation. We will often resort to wrapping
    the iterator in a `list()` constructor. This is because passing an iterator to
    `list()` exhausts it and puts all the generated items in a newly created list,
    which we can easily print to show you its content. Let us see an example of using
    the technique on a `range` object:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探索的一些对象是迭代器，它们通过一次只操作集合中的一个元素来节省内存，而不是创建一个修改后的副本。因此，如果我们只想显示操作的结果，就需要做一些额外的工作。我们通常会求助于将迭代器包裹在
    `list()` 构造函数中。这是因为将迭代器传递给 `list()` 会耗尽它，并将所有生成的项放入一个新创建的列表中，我们可以轻松地打印出来以显示其内容。让我们看看在
    `range` 对象上使用该技术的例子：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have highlighted the result of typing `range(7)` into a Python console. Notice
    that it does not show the contents of the `range` because `range` never actually
    loads the entire sequence of numbers into memory. The second highlighted line
    shows how wrapping the `range` in a `list()` allows us to see the numbers it generates.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经突出显示了在 Python 控制台中输入 `range(7)` 的结果。注意，它并没有显示 `range` 的内容，因为 `range` 从来不会实际将整个数字序列加载到内存中。第二个突出显示的行显示了将
    `range` 包裹在 `list()` 中是如何使我们能够看到它生成的数字的。
- en: Let us start looking at the various tools that Python provides for efficiently
    operating on collections of data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始查看 Python 为高效操作数据集合提供的各种工具。
- en: The map, zip, and filter functions
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`map`、`zip` 和 `filter` 函数'
- en: 'We will start by reviewing `map()` , `filter()` , and `zip()` , which are the
    main built-in functions you can employ when handling collections, and then we
    will learn how to achieve the same results using two important constructs: **comprehensions**
    and **generators** .'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先回顾 `map()`、`filter()` 和 `zip()`，这些是处理集合时可以使用的内置函数的主要函数，然后我们将学习如何使用两个重要的结构：**列表推导式**和**生成器**来实现相同的结果。
- en: map
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`map`'
- en: 'According to the official Python documentation ( [https://docs.python.org/3/library/functions.html#map](https://docs.python.org/3/library/functions.html#map)
    ), the following is true:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Python 的官方文档（[https://docs.python.org/3/library/functions.html#map](https://docs.python.org/3/library/functions.html#map)），以下内容是正确的：
- en: map(function, iterable, *iterables)
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`map(function, iterable, *iterables)`'
- en: ''
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Return an iterator that applies function to every item of iterable, yielding
    the results. If additional iterables arguments are passed, function must take
    that many arguments and is applied to the items from all iterables in parallel.
    With multiple iterables, the iterator stops when the shortest iterable is exhausted.
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回一个迭代器，它将函数应用于可迭代对象的每个元素，并产生结果。如果传递了额外的可迭代参数，函数必须接受那么多参数，并且将并行应用于所有可迭代对象中的元素。在有多个可迭代对象的情况下，迭代器在最短的迭代器耗尽时停止。
- en: 'We will explain the concept of yielding later in the chapter. For now, let
    us translate this into code—we will use a `lambda` function that takes a variable
    number of positional arguments, and returns them as a tuple:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面解释生成器的概念。现在，让我们将其转换为代码——我们将使用一个接受可变数量位置参数的 `lambda` 函数，并返回一个元组：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, you can see why we have to wrap calls in `list()` . Without
    it, we get the string representation of a `map` object. Python’s default string
    representation for objects gives their type and memory location which, in this
    context, is not particularly useful to us.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到为什么我们必须将调用包裹在 `list()` 中。没有它，我们会得到一个 `map` 对象的字符串表示形式。Python 对象的默认字符串表示会给出它们的类型和内存位置，在这个上下文中，这对我们来说并不特别有用。
- en: You can also notice how the elements of each iterable are applied to the function;
    at first, the first element of each iterable is applied, then the second one of
    each iterable, and so on. Notice also that `map()` stops when the shortest of
    the iterables we called it with is exhausted. This is a very useful behavior;
    it does not force us to level off all the iterables to a common length, nor does
    it break if they are not all the same length.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以注意到每个可迭代元素的函数应用方式；最初，每个可迭代元素的第一个元素被应用，然后是每个可迭代元素的第二个元素，依此类推。请注意，`map()`
    在我们调用的最短可迭代对象耗尽时停止。这是一个非常有用的行为；它不会强迫我们将所有可迭代对象调整到相同的长度，也不会在它们长度不同时中断。
- en: As a more interesting example, suppose we have a collection of student dictionaries,
    each of which contains a nested dictionary of the student’s credits. We want to
    sort the students based on the sum of their credits. However, the data as it is
    does not allow for a straightforward application of the sorting function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 作为更有趣的例子，假设我们有一个包含学生字典的集合，每个字典中都有一个嵌套的学生学分字典。我们希望根据学生学分的总和对学生进行排序。然而，现有的数据并不允许直接应用排序函数。
- en: To solve the problem, we are going to apply the **decorate-sort-undecorate**
    idiom (also known as **Schwartzian transform** ). It is a technique that was quite
    popular in older Python versions, when sorting did not support the use of *key
    functions* . Nowadays, it is not needed as often, but it still occasionally comes
    in handy.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将应用 **装饰-排序-取消装饰** 惯用（也称为 **Schwartzian 转换**）。这是一种在较旧的 Python 版本中相当流行的技术，当时排序不支持使用
    *键函数*。如今，它不再经常需要，但它偶尔仍然很有用。
- en: To **decorate** an object means to transform it, either adding extra data to
    it or putting it into another object. Conversely, to **undecorate** an object
    means to revert the decorated object to its original form.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要 **装饰** 一个对象意味着对其进行转换，无论是向其添加额外数据还是将其放入另一个对象中。相反，要 **取消装饰** 一个对象意味着将装饰过的对象恢复到其原始形式。
- en: This technique has nothing to do with Python decorators, which we will explore
    later in the book.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术与 Python 装饰器无关，我们将在本书的后面部分探讨。
- en: 'In the following example, we can see how `map()` is used to apply this idiom:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们可以看到 `map()` 是如何应用这个惯用的：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let us start by understanding what each student object is. In fact, let us
    print the first one:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来了解每个学生对象是什么。实际上，让我们打印第一个：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can see that it is a dictionary with two keys: `id` and `credits` . The
    value of `credits` is also a dictionary in which there are three subject/grade
    key/value pairs. As you may recall from *Chapter 2* , *Built-in Data Types* ,
    calling `dict.values()` returns an iterable object, with only the dictionary’s
    values. Therefore, `sum(student["credits"].values())` for the first student is
    equivalent to `sum((9, 6, 7))` .'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到这是一个包含两个键的字典：`id` 和 `credits`。`credits` 的值也是一个字典，其中包含三个科目/成绩键值对。如您从 *第2章*
    ，*内置数据类型* 中回忆的那样，调用 `dict.values()` 返回一个可迭代对象，其中只有字典的值。因此，第一个学生的 `sum(student["credits"].values())`
    等同于 `sum((9, 6, 7))`。
- en: 'Let us print the result of calling `decorate` with the first student:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印调用 `decorate` 时第一个学生的结果：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we decorate all the students like this, we can sort them on their total number
    of credits by just sorting the list of tuples. To apply the decoration to each
    item in `students` , we call `map(decorate, students)` . We sort the result, and
    then we undecorate in a similar fashion.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样装饰所有学生，我们只需对元组列表进行排序，就可以根据他们的总学分数对他们进行排序。为了将装饰应用到 `students` 中的每个项上，我们调用
    `map(decorate, students)`。我们排序结果，然后以类似的方式取消装饰。
- en: 'Printing `students` after running the whole code yields the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行整个代码后打印 `students` 会得到以下结果：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the student objects have indeed been sorted by the sums of their
    credits.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，学生对象确实是根据他们学分的总和进行排序的。
- en: 'For more on the *decorate-sort-undecorate* idiom, there is a good introduction
    in the *Sorting HOW TO* section of the official Python documentation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 *装饰-排序-取消装饰* 惯用，官方 Python 文档的 *排序 HOW TO* 部分有一个很好的介绍：
- en: '[https://docs.python.org/3.12/howto/sorting.html#decorate-sort-undecorate](https://docs.python.org/3.12/howto/sorting.html#decorate-sort-undecorate)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3.12/howto/sorting.html#decorate-sort-undecorate](https://docs.python.org/3.12/howto/sorting.html#decorate-sort-undecorate)'
- en: One thing to notice about the sorting part is what happens when two or more
    students share the same total sum. The sorting algorithm would then proceed to
    sort the tuples by comparing the `student` objects with each other. This does
    not make any sense and, in more complex cases, could lead to unpredictable results,
    or even errors. If you want to avoid this issue, one simple solution is to create
    a three-tuple instead of a two-tuple, having the sum of credits in the first position,
    the position of the `student` object in the original `students` list in second
    place, and the `student` object itself in third place. This way, if the sum of
    credits is the same, the tuples will be sorted against the position, which will
    always be different, and therefore enough to resolve the sorting between any pair
    of tuples.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在排序部分需要注意的一点是，当两个或多个学生的总分相同时会发生什么。排序算法将接着通过比较 `student` 对象来对元组进行排序。这没有任何意义，并且在更复杂的情况下可能会导致不可预测的结果，甚至错误。如果你想要避免这个问题，一个简单的解决方案是创建一个三重元组而不是双重元组，将学分总和放在第一个位置，`student`
    对象在原始 `students` 列表中的位置放在第二个位置，`student` 对象本身放在第三个位置。这样，如果学分总和相同，元组将根据位置进行排序，位置总是不同的，因此足以解决任何一对元组之间的排序问题。
- en: zip
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: zip
- en: We have already covered `zip()` in the previous chapters, so let us just define
    it properly, after which we want to show you how you could combine it with `map()`
    .
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前面的章节中介绍了 `zip()`，所以让我们正确地定义它，之后我们想向你展示如何将它与 `map()` 结合使用。
- en: 'According to the Python documentation ( [https://docs.python.org/3/library/functions.html#zip](https://docs.python.org/3/library/functions.html#zip)
    ), the following applies:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python文档（[https://docs.python.org/3/library/functions.html#zip](https://docs.python.org/3/library/functions.html#zip)），以下适用：
- en: zip(*iterables, strict=False)
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: zip(*iterables, strict=False)
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '... returns an iterator of tuples, where the i-th tuple contains the i-th element
    from each of the argument iterables.'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '... 返回一个元组的迭代器，其中第 i 个元组包含来自每个参数可迭代对象的第 i 个元素。'
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Another way to think of zip() is that it turns rows into columns, and columns
    into rows. This is similar to transposing a matrix.
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一种思考 `zip()` 的方式是它将行转换为列，将列转换为行。这与矩阵转置类似。
- en: 'Let us see an example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we are zipping together the average and the grade for the last exam for
    each student. Notice how easy it is to reproduce `zip()` using `map()` (the last
    two instructions of the example). Once again, we have to use `list()` to visualize
    the results.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将每个学生的平均分和最后一次考试的成绩进行组合。注意，使用 `map()`（示例中的最后两条指令）来重现 `zip()` 是多么简单。再次，我们必须使用
    `list()` 来可视化结果。
- en: 'Like `map()` , `zip()` will normally stop as soon as it reaches the end of
    the shortest iterable. This can, however, mask problems with the input data, leading
    to bugs. For example, suppose we need to combine a list of students’ names and
    a list of grades into a dictionary mapping each student’s name to their grade.
    A mistake in data entry could result in the list of grades being shorter than
    the list of students. Here is an example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `map()` 类似，`zip()` 通常会在到达最短可迭代对象的末尾时停止。然而，这可能会掩盖输入数据的问题，导致错误。例如，假设我们需要将学生名单和成绩列表合并到一个字典中，将每个学生的名字映射到他们的成绩。数据输入错误可能会导致成绩列表比学生名单短。以下是一个例子：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notice that there is no entry for `"Alice"` in the dictionary. The default
    behavior of `zip()` has masked the data error. For this reason, the `strict` keyword-only
    parameter was added in Python 3.10. If `zip()` receives `strict=True` as an argument,
    it raises an exception if the iterables do not all have the same length:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，字典中没有 `"Alice"` 的条目。`zip()` 的默认行为掩盖了数据错误。因此，在Python 3.10中添加了仅关键字参数 `strict`。如果
    `zip()` 接收到 `strict=True` 作为参数，当可迭代对象长度不相同时，它会引发异常：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `itertools` module also provides a `zip_longest()` function. It behaves
    like `zip()` but stops only when the longest iterable is exhausted. Shorter iterables
    are padded with a value that can be specified as an argument, which defaults to
    `None` .
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools` 模块还提供了一个 `zip_longest()` 函数。它的行为类似于 `zip()`，但只有在最长的可迭代对象耗尽时才会停止。较短的迭代器将被指定为参数的值填充，默认为
    `None` 。'
- en: filter
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: filter
- en: 'According to the Python documentation ( [https://docs.python.org/3/library/functions.html#filter](https://docs.python.org/3/library/functions.html#filter)
    ), the following applies:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python文档（[https://docs.python.org/3/library/functions.html#filter](https://docs.python.org/3/library/functions.html#filter)），以下适用：
- en: filter(function, iterable)
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: filter(function, iterable)
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Construct an iterator from those elements of iterable for which function is
    true. iterable may be either a sequence, a container which supports iteration,
    or an iterator. If function is None, the identity function is assumed, that is,
    all elements of iterable that are false are removed.
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从可迭代对象中构建一个迭代器，该迭代器对于函数为真。可迭代对象可以是序列、支持迭代的容器或迭代器。如果函数是 None，则假定是恒等函数，即移除可迭代对象中所有为假的元素。
- en: 'Let us see a quick example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个快速示例：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice how the second call to `filter()` is equivalent to the first one. If
    we pass a function that takes one argument and returns the argument itself, only
    those arguments that are `True` will make the function return `True` . This behavior
    is the same as passing `None` . It is often a good exercise to mimic some of the
    built-in Python behaviors. When you succeed, you can say you fully understand
    how Python behaves in a specific situation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到第二个 `filter()` 调用与第一个调用等效。如果我们传递一个接受一个参数并返回该参数本身的函数，只有那些使函数返回 `True` 的参数才会使函数返回
    `True`。这种行为与传递 `None` 相同。模仿一些内置的 Python 行为通常是一个很好的练习。当你成功时，你可以说你完全理解了 Python 在特定情况下的行为。
- en: 'Armed with `map()` , `zip()` , and `filter()` (and several other functions
    from the Python standard library), we can manipulate sequences very effectively.
    But these functions are not the only way to do it. Let us look at one of the most
    powerful features of Python: *comprehensions* .'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有了 `map()`、`zip()`、`filter()`（以及 Python 标准库中的几个其他函数），我们可以非常有效地操作序列。但这些都是实现方式之一。让我们看看
    Python 最强大的功能之一：*理解*。
- en: Comprehensions
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解
- en: A comprehension is a concise notation for performing some operation on each
    element of a collection of objects, and/or selecting a subset of elements that
    satisfy some condition. They are borrowed from the functional programming language
    Haskell ( [https://www.haskell.org/](https://www.haskell.org/) ) and, together
    with iterators and generators, contribute to giving Python a functional flavor.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 理解是一种对一组对象中的每个元素执行某些操作或选择满足某些条件的元素子集的简洁表示。它们借鉴了函数式编程语言 Haskell ([https://www.haskell.org/](https://www.haskell.org/))，并与迭代器和生成器一起，为
    Python 增添了函数式风格。
- en: 'Python offers several types of comprehensions: list, dictionary, and set. We
    will concentrate on list comprehensions; once you understand them, the other types
    will be easy to grasp.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了多种类型的理解：列表、字典和集合。我们将专注于列表理解；一旦你理解了它们，其他类型就会很容易掌握。
- en: 'Let us start with a simple example. We want to calculate a list with the squares
    of the first 10 natural numbers. We could use a `for` loop and append a square
    to the list in each iteration:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始。我们想要计算一个包含前 10 个自然数的平方的列表。我们可以使用 `for` 循环并在每次迭代中将一个平方数追加到列表中：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is not very elegant as we have to initialize the list first. With `map()`
    , we can achieve the same thing in just one line of code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很优雅，因为我们必须首先初始化列表。使用 `map()`，我们可以在一行代码中实现相同的功能：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let us see how to achieve the same result using a list comprehension:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用列表理解达到相同的结果：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is much easier to read, and we no longer need to use a lambda. We have
    placed a `for` loop within square brackets. Let us now filter out the odd squares.
    We will show you how to do it with `map()` and `filter()` first, before then using
    a list comprehension again:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这更容易阅读，我们不再需要使用 lambda。我们已经在方括号内放置了一个 `for` 循环。现在让我们过滤掉奇数平方。我们首先会展示如何使用 `map()`
    和 `filter()` 来实现，然后再使用列表理解：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We think that the difference in readability is now evident. The list comprehension
    reads much better. It is almost English: give us all squares ( `n**2` ) for `n`
    between 0 and 9 if `n` is even.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为，现在可读性的差异已经很明显。列表理解读起来更顺畅。它几乎就像英语：如果 n 是偶数，请给出 0 到 9 之间所有平方数（`n**2`）。
- en: 'According to the Python documentation ( [https://docs.python.org/3.12/tutorial/datastructures.html#list-comprehensions](https://docs.python.org/3.12/tutorial/datastructures.html#list-comprehensions)
    ), the following is true:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Python 文档 ([https://docs.python.org/3.12/tutorial/datastructures.html#list-comprehensions](https://docs.python.org/3.12/tutorial/datastructures.html#list-comprehensions))，以下是真的：
- en: A list comprehension consists of brackets containing an expression followed
    by a for clause, then zero or more for or if clauses. The result will be a new
    list resulting from evaluating the expression in the context of the for and if
    clauses which follow it.
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表理解由包含一个表达式、后跟一个 `for` 子句、然后是零个或多个 `for` 或 `if` 子句的括号组成。结果将是一个新列表，该列表是在评估随后的
    `for` 和 `if` 子句的上下文中的表达式后生成的。
- en: Nested comprehensions
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套列表推导
- en: 'Let us see an example of nested loops. This is quite common because many algorithms
    involve iterating on a sequence using two placeholders. The first one runs through
    the whole sequence, left to right. The second one does, too, but it starts from
    the first one, instead of 0. The concept is that of testing all pairs without
    duplication. Let us see the classical `for` loop equivalent:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看嵌套循环的一个例子。这相当常见，因为许多算法都涉及使用两个占位符迭代一个序列。第一个占位符从左到右遍历整个序列。第二个占位符也这样做，但它从第一个占位符开始，而不是从0开始。这个概念是测试所有对而不重复。让我们看看经典的`for`循环等效：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you print `pairs` at the end, you get the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在最后打印`pairs`，您将得到以下内容：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'All the tuples with the same letter are those where `b` is at the same position
    as `a` . Now, let us see how we can translate this to a list comprehension:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所有具有相同字母的元组都是那些`b`位于与`a`相同位置的元组。现在，让我们看看我们如何将这个转换成列表推导：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that because the `for` loop over `b` depends on `a` , it must come after
    the `for` loop over `a` in the comprehension. If you swap them around, you will
    get a name error.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为`for`循环中的`b`依赖于`a`，所以在推导中它必须位于`a`的`for`循环之后。如果您交换它们的位置，您将得到一个命名错误。
- en: Another way of achieving the same result is to use the `combinations_with_replacement()`
    function from the `itertools` module (which we briefly introduced in *Chapter
    3* , *Conditionals and Iteration* ). You can read more about it in the official
    Python documentation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相同结果的另一种方法是使用`itertools`模块中的`combinations_with_replacement()`函数（我们在*第3章*，*条件与迭代*中简要介绍了它）。您可以在官方Python文档中了解更多信息。
- en: Filtering a comprehension
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推导的过滤
- en: We can also apply filtering to a comprehension. Let us first do it with `filter()`
    , and find all Pythagorean triples whose short sides are numbers smaller than
    10. A **Pythagorean triple** is a triple *(a, b, c)* of integer numbers satisfying
    the equation *a* ² *+ b* ² *= c* ² .
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将过滤应用于推导。让我们首先使用`filter()`，找到所有短边小于10的毕达哥拉斯三元组。**毕达哥拉斯三元组**是一组满足方程*a² +
    b² = c²*的整数数的三元组*(a, b, c)*。
- en: 'We obviously do not want to test a combination twice, and therefore, we will
    use a trick similar to the one we saw in the previous example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然不希望测试组合两次，因此，我们将使用与上一个示例中看到类似的技巧：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, we generated a list of *three-tuples* , `triples` . Each
    tuple contains two integer numbers (the legs), and the hypotenuse of the Pythagorean
    triangle, whose legs are the first two numbers in the tuple. For example, when
    `a` is 3 and `b` is 4, the tuple will be `(3, 4, 5.0)` , and when `a` is 5 and
    `b` is 7, the tuple will be `(5, 7, 8.602325267042627)` .
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们生成了一组*三元组*，`triples`。每个元组包含两个整数数（两腿），以及勾股三角形的斜边，其两腿是元组中的前两个数。例如，当`a`是3且`b`是4时，元组将是`(3,
    4, 5.0)`，当`a`是5且`b`是7时，元组将是`(5, 7, 8.602325267042627)`。
- en: After generating all the `triples` , we need to filter out all those where the
    hypotenuse is not an integer number. To achieve this, we filter based on `float_number.is_integer()`
    being `True` . This means that of the two example tuples we just showed you, the
    one with hypotenuse `5.0` will be retained, while the one with the `8.602325267042627`
    hypotenuse will be discarded.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成所有`triples`之后，我们需要过滤掉那些斜边不是整数数的所有情况。为了实现这一点，我们根据`float_number.is_integer()`为`True`进行过滤。这意味着在我们刚刚向您展示的两个示例元组中，斜边为`5.0`的那个将被保留，而斜边为`8.602325267042627`的那个将被丢弃。
- en: 'This is good, but we do not like the fact that the triple has two integer numbers
    and a float—they are all supposed to be integers. We can use `map()` to fix this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但我们不喜欢三元组中有两个整数数和一个浮点数——它们都应该都是整数。我们可以使用`map()`来解决这个问题：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice the step we added. We slice each element in `triples` , taking only
    the first two elements. Then, we concatenate the slice with a one-tuple, containing
    the integer version of that float number that we did not like. This code is getting
    quite complicated. We can achieve the same result with a much simpler list comprehension:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们添加的步骤。我们切片`triples`中的每个元素，只取前两个元素。然后，我们将切片与包含我们不喜欢的那浮点数的整数版本的单一元组连接起来。这段代码变得越来越复杂。我们可以用更简单的列表推导来实现相同的结果：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That is cleaner, easier to read, and shorter. There is still room for improvement,
    though. We are still wasting memory by constructing a list with many triples that
    we end up discarding. We can fix that by combining the two comprehensions into
    one:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更简洁、更易读、更短。尽管如此，仍有改进的空间。我们仍然在构建一个包含许多最终会被丢弃的三元组的列表中浪费内存。我们可以通过将两个推导式合并为一个来解决这个问题：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that is elegant. By generating the triples and filtering them in the same
    list comprehension, we avoid keeping any triple that does not pass the test in
    memory. Notice that we used an `assignment expression` to avoid needing to compute
    the value of `sqrt(a**2 + b**2)` twice.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是优雅的。通过在同一个列表推导式中生成三元组和过滤它们，我们避免了在内存中保留任何未通过测试的三元组。注意，我们使用了一个`赋值表达式`来避免需要两次计算`sqrt(a**2
    + b**2)`的值。
- en: Dictionary comprehensions
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典推导式
- en: 'Dictionary comprehensions work exactly like list comprehensions, but to construct
    dictionaries. There is only a slight difference in the syntax. The following example
    will suffice to explain everything you need to know:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 字典推导式与列表推导式的工作方式完全相同，但用于构建字典。在语法上只有细微的差别。以下示例足以解释你需要知道的一切：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you print `lettermap` , you will see the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打印`lettermap`，你会看到以下内容：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, we are enumerating the sequence of all lowercase ASCII
    letters (using the `enumerate` function). We then construct a dictionary with
    the resulting letter/number pairs as keys and values. Notice how the syntax is
    similar to the familiar dictionary syntax.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在枚举所有小写ASCII字母的序列（使用`enumerate`函数）。然后我们构建一个字典，将结果字母/数字对作为键和值。注意语法与熟悉的字典语法相似。
- en: 'There is also another way to do the same thing:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种做同样事情的方法：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, we are feeding a generator expression (we will talk more about
    these later in this chapter) to the `dict` constructor.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们向`dict`构造函数提供了一个生成器表达式（我们将在本章后面更多地讨论这些内容）。
- en: 'Dictionaries do not allow duplicate keys, as shown in the following example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 字典不允许重复键，如下例所示：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We create a dictionary with the letters of the string `"Hello"` as keys and
    the same letters, but with the case swapped, as values. Notice that there is only
    one `"l": "L"` pair. The constructor does not complain; it simply reassigns duplicates
    to the last value. Let us make this clearer with another example that assigns
    to each key its position in the string:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '我们创建了一个字典，以字符串`"Hello"`中的字母作为键，以相同字母但大小写互换作为值。注意，只有一个`"l": "L"`对。构造函数不会抱怨；它只是将重复的值重新分配给最后一个值。让我们用一个将每个键分配到字符串中位置的另一个例子来使这一点更清晰：'
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Notice the value associated with the letter `l: 3` . The `l: 2` pair is not
    there; it has been overridden by `l: 3` .'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '注意与字母`l`关联的值：`3`。`l: 2`对不存在；它已被`l: 3`覆盖。'
- en: Set comprehensions
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合推导式
- en: 'Set comprehensions are similar to list and dictionary ones. Let us see one
    quick example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 集合推导式与列表和字典推导式类似。让我们看一个快速示例：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice how for set comprehensions, as for dictionaries, duplication is not allowed,
    and therefore the resulting set has only four letters. Also, notice that the expressions
    assigned to `letters1` and `letters2` produce equivalent sets.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于集合推导式，就像字典一样，不允许重复，因此结果集合只有四个字母。此外，注意分配给`letters1`和`letters2`的表达式产生等效的集合。
- en: The syntax used to create `letters1` is similar to that of a dictionary comprehension.
    You can spot the difference only by the fact that dictionaries require keys and
    values, separated by colons, while sets do not. For `letters2` , we fed a generator
    expression to the `set()` constructor.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`letters1`使用的语法与字典推导式类似。你只能通过以下事实来发现差异：字典需要键和值，通过冒号分隔，而集合不需要。对于`letters2`，我们向`set()`构造函数提供了一个生成器表达式。
- en: Generators
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器
- en: '**Generators** are based on the concept of *iteration* , as we said before,
    and they allow coding patterns that combine elegance with efficiency.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成器**基于我们之前提到的**迭代**概念，并允许结合优雅与效率的编码模式。'
- en: 'Generators are of two types:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器有两种类型：
- en: '**Generator functions** : These are similar to regular functions, but instead
    of returning results through `return` statements, they use `yield` , which allows
    them to suspend and resume their state between each call.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成器函数**：这些与常规函数类似，但它们不是通过`return`语句返回结果，而是使用`yield`，这允许它们在每次调用之间挂起和恢复其状态。'
- en: '**Generator expressions** : These are similar to the list comprehensions we
    have seen in this chapter, but instead of returning a list, they return an object
    that produces results one by one.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成器表达式**：这些与我们在本章中看到的列表推导式类似，但它们返回的对象会逐个产生结果。'
- en: Generator functions
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器函数
- en: 'Generator functions behave like regular functions in all respects, except for
    one difference: instead of collecting results and returning them at once, they
    are automatically turned into iterators that yield results one at a time.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数在所有方面都表现得像常规函数，只有一个区别：它们不是一次性收集结果并返回，而是自动转换为迭代器，一次产生一个结果。
- en: Suppose we asked you to count from 1 to 1,000,000. You start, and at some point,
    we ask you to stop. After some time, we ask you to resume. As long as you can
    remember the last number you reached, you will be able to continue where you left
    off. For example, if we stopped you after 31,415, you would just go on with 31,416,
    and so on. The point is that you do not need to remember all the numbers you said
    before 31,415, nor do you need them to be written down somewhere. Generators behave
    in much the same way.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要求你从1数到1,000,000。你开始数，在某个时刻，我们要求你停下来。过了一段时间，我们要求你继续。只要你记得你最后到达的数字，你就能从你离开的地方继续。例如，如果我们在你数到31,415后停下来，你就可以从31,416继续数下去。关键是，你不需要记住你之前说的所有数字，也不需要将它们写下来。生成器的行为与此非常相似。
- en: 'Take a good look at the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看下面的代码：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The result of the two `print` statements will be the same: `[0, 1, 4, 9, 16,
    25, 36, 49, 64, 81]` . But there is an important difference between the two functions.
    `get_squares()` is a classic function that collects all the squares of numbers
    in *[0, n)* in a list, and returns it. On the other hand, `get_squares_gen()`
    is a generator and behaves differently. Each time the interpreter reaches the
    `yield` line, its execution is suspended. The only reason those `print` statements
    return the same result is because we fed `get_squares_gen()` to the `list()` constructor,
    which exhausts the generator completely by asking for the next element until a
    `StopIteration` is raised. Let us see this in detail:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`print`语句的结果将是相同的：`[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]`。但这两个函数之间有一个重要的区别。`get_squares()`是一个经典函数，它将*[0,
    n)*区间内所有数字的平方收集到一个列表中，并返回它。另一方面，`get_squares_gen()`是一个生成器，其行为不同。每次解释器到达`yield`行时，它的执行就会暂停。那些`print`语句返回相同结果的原因仅仅是因为我们将`get_squares_gen()`传递给了`list()`构造函数，它通过请求下一个元素直到抛出`StopIteration`异常来完全耗尽生成器。让我们详细看看这一点：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Each time we call `next()` on the generator object, we either start it (the
    first `next()` ) or make it resume from the last suspension point (any other `next()`
    ). The first time we call `next()` on it, we get 0, which is the square of 0,
    then 1, then 4, then 9, and since the `for` loop stops after that ( `n` is 4),
    the generator naturally ends. A classic function would at that point just return
    `None` , but to comply with the iteration protocol, a generator will instead raise
    a `StopIteration` exception.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们对生成器对象调用`next()`时，我们要么启动它（第一次`next()`），要么从最后一个暂停点恢复（任何其他`next()`）。我们第一次调用`next()`时，得到0，这是0的平方，然后是1，然后是4，然后是9，由于`for`循环在那之后停止（`n`是4），生成器自然结束。在这一点上，一个经典函数会简单地返回`None`，但为了遵守迭代协议，生成器会抛出一个`StopIteration`异常。
- en: This explains how a `for` loop works. When you call `for k in range(n)` , what
    happens under the hood is that the `for` loop gets an iterator out of `range(n)`
    and starts calling `next` on it, until `StopIteration` is raised, which tells
    the `for` loop that the iteration has reached its end.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了`for`循环的工作原理。当你调用`for k in range(n)`时，幕后发生的事情是`for`循环从`range(n)`中获取一个迭代器，并开始调用它的`next`方法，直到抛出`StopIteration`异常，这告诉`for`循环迭代已达到其结束。
- en: Having this behavior built into every iteration aspect of Python makes generators
    even more powerful because once we have written them, we will be able to plug
    them into whatever iteration mechanism we want.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种行为内置到Python的每个迭代方面，使得生成器更加强大，因为一旦我们编写了它们，我们就能将它们插入到我们想要的任何迭代机制中。
- en: At this point, you are probably asking yourself why you would want to use a
    generator instead of a regular function. The answer is to save time and (especially)
    memory.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能正在问自己，为什么你想使用生成器而不是常规函数。答案是节省时间和（尤其是）内存。
- en: 'We will talk more about performance later, but for now, let us concentrate
    on one aspect: sometimes, generators allow you to do something that would not
    be possible with a simple list. For example, say you want to analyze all permutations
    of a sequence. If the sequence has a length of *N* , then the number of its permutations
    is *N!* . This means that if the sequence is 10 elements long, the number of permutations
    is 3,628,800. But a sequence of 20 elements would have 2,432,902,008,176,640,000
    permutations. They grow factorially.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论性能，但现在，让我们集中在一个方面：有时，生成器允许你做一些用简单列表不可能做到的事情。例如，假设你想分析一个序列的所有排列。如果序列的长度为*N*，那么它的排列数是*N!*。这意味着如果序列有10个元素，排列数是3,628,800。但20个元素的序列将有2,432,902,008,176,640,000个排列。它们以阶乘的方式增长。
- en: Now imagine you have a classic function that is attempting to calculate all
    permutations, put them in a list, and return it to you. With 10 elements, it would
    require probably a few seconds, but for 20 elements there is simply no way that
    it could be done (it would take thousands of years and require billions of gigabytes
    of memory).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，你有一个经典函数，试图计算所有排列，将它们放入列表中，然后返回给你。对于10个元素，可能只需要几秒钟，但对于20个元素，根本无法完成（它可能需要数千年，并需要数十亿千兆字节的内存）。
- en: 'On the other hand, a generator function will be able to start the computation
    and give you back the first permutation, then the second, and so on. Of course,
    you will not have the time to process them all—there are too many—but at least
    you will be able to work with some of them. Sometimes the amount of data you have
    to iterate over is so huge that you cannot keep it all in memory in a list. In
    this case, generators are invaluable: they make possible that which otherwise
    would not be.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，生成器函数能够开始计算，并给你返回第一个排列，然后是第二个，以此类推。当然，你可能没有时间处理它们全部——因为太多了——但至少你将能够处理其中的一些。有时，你必须迭代的数量数据如此巨大，以至于你不能将它们全部保存在列表中。在这种情况下，生成器是无价的：它们使得那些在其他情况下不可能的事情成为可能。
- en: So, to save memory (and time), use generator functions whenever possible.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了节省内存（和时间），尽可能使用生成器函数。
- en: 'It is also worth noting that you can use the `return` statement in a generator
    function. It will cause a `StopIteration` exception to be raised, effectively
    ending the iteration. If a `return` statement were to make the function return
    something, it would break the iteration protocol. Python’s consistency prevents
    this and allows us great ease when coding. Let us see a quick example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，你可以在生成器函数中使用`return`语句。它将引发`StopIteration`异常，从而有效地结束迭代。如果`return`语句使函数返回某些内容，它将破坏迭代协议。Python的这种一致性防止了这种情况，并使我们编码时更加方便。让我们看一个简单的例子：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code yields all terms of the geometric progression, *a, aq, aq2,
    aq3, ...* . When the progression produces a term that is greater than 100,000,
    the generator stops (with a `return` statement). Running the code produces the
    following result:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了几何级数的所有项，*a, aq, aq2, aq3, ...*。当级数产生一个大于100,000的项时，生成器停止（使用`return`语句）。运行代码会产生以下结果：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The next term would have been `156250` , which is too big.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个项将是`156250`，这太大了。
- en: Going beyond next
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越`next`
- en: 'Generator objects have methods that allow us to control their behavior: `send()`
    , `throw()` , and `close()` . The `send()` method allows us to communicate a value
    back to the generator object, while `throw()` and `close()` , respectively, allow
    us to raise an exception within the generator and close it. Their use is quite
    advanced, and we will not be covering them here in detail, but we want to spend
    a few words on `send()` , with a simple example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器对象有方法可以让我们控制它们的行为：`send()`、`throw()`和`close()`。`send()`方法允许我们向生成器对象发送一个值，而`throw()`和`close()`分别允许我们在生成器内部引发异常并关闭它。它们的使用相当高级，我们在这里不会详细讨论，但我们要简单谈谈`send()`，以下是一个简单的例子：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding iterator creates a generator object that will run forever. You
    can keep calling it, and it will never stop. But what if you wanted to stop it
    at some point? One solution is to use a global variable to control the `while`
    loop:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的迭代器创建了一个会无限运行的生成器对象。你可以不断调用它，它永远不会停止。但如果你想在某个时刻停止它呢？一个解决方案是使用全局变量来控制`while`循环：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We initially set `stop = False` , and until we change it to `True` , the generator
    will just keep going, like before. After we change `stop` to `True` though, the
    `while` loop will exit, and the following call to `next` will raise a `StopIteration`
    exception. This trick works, but it is not a satisfactory solution. The function
    depends on an external variable, which can lead to problems. For example, the
    generator could inadvertently be stopped if another, unrelated function changes
    the global variable. Functions should ideally be self-contained and not rely on
    a global state.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初将 `stop` 设置为 `False`，直到我们将其更改为 `True`，生成器将像之前一样继续运行。但是，当我们把 `stop` 改为 `True`
    时，`while` 循环将退出，接下来的 `next` 调用将引发一个 `StopIteration` 异常。这个技巧是可行的，但不是一个令人满意的解决方案。函数依赖于外部变量，这可能导致问题。例如，如果另一个无关的函数更改了全局变量，生成器可能会意外停止。函数理想上应该是自包含的，不应依赖于全局状态。
- en: 'The generator `send()` method takes a single argument, which is passed into
    the generator function as the value of the `yield` expression. We can use this
    to pass a flag value into the generator to signal that it should stop:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器的 `send()` 方法接受一个单一参数，该参数作为 `yield` 表达式的值传递给生成器函数。我们可以使用这个方法将一个标志值传递给生成器，以指示它应该停止：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Executing this code produces the following output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码将产生以下输出：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We think it is worth going through this code line by line, as if we were executing
    it, to see whether we can understand what is going on.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为逐行分析这段代码是值得的，就像我们正在执行它一样，以了解正在发生什么。
- en: We start the generator execution with a call to `next()` ( `#C` ). Within the
    generator, `n` is set to the same value as `start` . The `while` loop is entered,
    execution stops ( `#A` ), and `n` ( `0` ) is yielded back to the caller. `0` is
    printed on the console.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用 `next()`（`#C`）开始生成器的执行。在生成器内部，`n` 被设置为与 `start` 相同的值。进入 `while` 循环，执行停止（`#A`），并将
    `n`（`0`）返回给调用者。`0` 在控制台上打印。
- en: We then call `send()` ( `#D` ), execution resumes, `result` is set to `"Wow!"`
    (still `#A` ), and its type and value are printed on the console ( `#B` ). `result`
    is not `"Q"` , so `n` is incremented by 1 and execution goes back to the top of
    the loop. The `while` condition is `True` , so another iteration of the loop is
    started. Execution again stops at `#A` , and `n` ( `1` ) is yielded back to the
    caller. `1` is printed on the console.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用 `send()`（`#D`），执行继续，`result` 被设置为 `"Wow!"`（仍然是 `#A`），其类型和值再次在控制台上打印（`#B`）。`result`
    不是 `"Q"`，所以 `n` 增加 1，执行回到循环的顶部。`while` 条件为 `True`，因此开始另一个循环迭代。执行再次在 `#A` 处停止，并将
    `n`（`1`）返回给调用者。`1` 在控制台上打印。
- en: At this point, we call `next()` ( `#E` ), execution is resumed ( `#A` ), and
    because we are not sending anything to the generator explicitly, the `yield n`
    expression ( `#A` ) returns `None` (the behavior is the same as when we call a
    function that does not return anything). `result` is therefore set to `None` ,
    and its type and value are again printed on the console ( `#B` ). Execution continues,
    `result` is not `"Q"` , so `n` is incremented by 1, and we start another loop
    again. Execution stops again ( `#A` ) and `n` ( `2` ) is yielded back to the caller.
    `2` is printed on the console.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们调用 `next()`（`#E`），执行继续（`#A`），因为我们没有明确地向生成器发送任何内容，所以 `yield n` 表达式（`#A`）返回
    `None`（行为与调用不返回任何内容的函数相同）。因此，`result` 被设置为 `None`，其类型和值再次在控制台上打印（`#B`）。执行继续，`result`
    不是 `"Q"`，所以 `n` 增加 1，然后再次开始另一个循环。执行再次停止（`#A`），并将 `n`（`2`）返回给调用者。`2` 在控制台上打印。
- en: Now we call `send` again ( `#F` ), this time passing the argument `"Q"` . The
    generator resumes, `result` is set to `"Q"` ( `#A` ), and its type and value are
    printed on the console again ( `#B` ). When we reach the `if` statement again,
    `result == "Q"` evaluates to `True` , and the `while` loop is stopped by the `break`
    statement. The generator naturally terminates, which means a `StopIteration` exception
    is raised. You can see the traceback of the exception in the last few lines printed
    on the console.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们再次调用 `send`（`#F`），这次传递参数 `"Q"`。生成器继续执行，`result` 被设置为 `"Q"`（`#A`），其类型和值再次在控制台上打印（`#B`）。当我们再次到达
    `if` 语句时，`result == "Q"` 评估为 `True`，`while` 循环通过 `break` 语句停止。生成器自然终止，这意味着引发了一个
    `StopIteration` 异常。您可以在控制台打印的最后几行中看到异常的跟踪信息。
- en: This is not at all simple to understand at first, so if it is not clear to you,
    do not be discouraged. You can keep reading and come back to this example later.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点在最初并不容易理解，所以如果您对此感到困惑，请不要气馁。您可以继续阅读，稍后再回到这个例子。
- en: Using `send()` allows for interesting patterns, and it is worth noting that
    `send()` can also be used to start the execution of a generator (provided you
    call it with `None` ).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`send()`允许有趣的模式，并且值得注意的是，`send()`也可以用来启动生成器的执行（只要你用`None`调用它）。
- en: The yield from expression
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`yield from`表达式'
- en: 'Another interesting construct is the `yield from` expression. This expression
    allows you to yield values from a sub-iterator. Its use allows for quite advanced
    patterns, so let us see a quick example of it:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的构造是`yield from`表达式。这个表达式允许你从子迭代器产生值。它的使用允许相当高级的模式，所以让我们快速看看它的一个例子：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The code above prints the numbers `4` , `9` , and `16` on the console (on separate
    lines). By now, we expect you to be able to understand it by yourself, but let
    us quickly recap what happens. The `for` loop outside the function gets an iterator
    from `print_squares(2, 5)` and calls `next()` on it until iteration is over. Every
    time the generator is called, execution is suspended (and later resumed) on `yield
    n**2` , which returns the square of the current `n` . Let us see how we could
    use a `yield from` expression to achieve the same result:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码在控制台（单独的行）上打印了数字`4`、`9`和`16`。到现在为止，我们希望你自己能够理解它，但让我们快速回顾一下发生了什么。函数外部的`for`循环从`print_squares(2,
    5)`获取一个迭代器，并对其调用`next()`直到迭代结束。每次调用生成器时，执行会在`yield n**2`处暂停（稍后恢复），这返回了当前`n`的平方。让我们看看我们如何使用`yield
    from`表达式来实现相同的结果：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This code produces the same result, but as you can see, `yield from` is actually
    running a sub-iterator, `(n**2 ...)` . The `yield from` expression returns to
    the caller each value the sub-iterator is producing. It is shorter and reads better.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码产生了相同的结果，但正如你所见，`yield from`实际上是在运行一个子迭代器`(n**2 ...)`。`yield from`表达式返回子迭代器产生的每个值。它更短，读起来更好。
- en: Generator expressions
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: In addition to generator functions, generators can also be created using **generator
    expressions** . The syntax to create a generator expression is the same as for
    a list comprehension, except that we use round brackets instead of square brackets.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 除了生成器函数之外，生成器还可以使用**生成器表达式**来创建。创建生成器表达式的语法与列表推导式相同，只是我们使用圆括号而不是方括号。
- en: A generator expression will generate the same sequence of values as an equivalent
    list comprehensions. However, instead of immediately creating a list object containing
    the entire sequence in memory, the generator will yield the values one at a time.
    It is important to remember that you can only iterate over a generator once. After
    that, it will be exhausted.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式将生成与等效列表推导式相同的值序列。然而，生成器不会立即在内存中创建包含整个序列的列表对象，而是逐个产生值。重要的是要记住，你只能迭代生成器一次。之后，它将耗尽。
- en: 'Let us see an example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see from the output when we try to print it, `cubes_gen` is a generator
    object. To see the values it generates, we can use a `for` loop or a manual set
    of calls to `next` , or simply feed it to a `list()` constructor, which is what
    we did.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如从尝试打印时的输出所看到的，`cubes_gen`是一个生成器对象。要查看它产生的值，我们可以使用一个`for`循环或手动调用`next()`，或者简单地将其传递给`list()`构造函数，这正是我们所做的。
- en: Notice how, once the generator has been exhausted, there is no way to recover
    the same elements from it again. We need to recreate it if we want to use it from
    scratch again.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦生成器耗尽，就无法再次从中恢复相同的元素。如果我们想从头开始再次使用它，我们需要重新创建它。
- en: 'In the next few examples, let us see how to reproduce `map()` and `filter()`
    using generator expressions. First, let’s look at `map()` :'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个例子中，让我们看看如何使用生成器表达式来重现`map()`和`filter()`。首先，让我们看看`map()`：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the previous example, `s1` and `s2` are both equal to the sum of `adder(0,
    1)` , `adder(1, 2)` , `adder(2, 3)` , and so on, which translates to `sum(1, 3,
    5, ...)` . We find the generator expression syntax to be much more readable, though.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`s1`和`s2`都等于`adder(0, 1)`、`adder(1, 2)`、`adder(2, 3)`等之和，这相当于`sum(1,
    3, 5, ...)`。我们发现生成器表达式语法更容易阅读。
- en: 'Now for `filter()` :'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看`filter()`：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In this example, `odd_cubes1` and `odd_cubes2` are equivalent: they generate
    a sequence of odd cubes. Yet again, we prefer the generator syntax. This should
    be evident when things get a little more complicated:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`odd_cubes1`和`odd_cubes2`是等效的：它们生成一个奇数立方序列。再次，我们更喜欢生成器语法。当事情变得稍微复杂一些时，这一点应该很明显：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding code creates two iterators, `cubes1` and `cubes2` . Both will
    yield the same sequence of tuples *(n, n3)* where `n` is a multiple of 3 or 5.
    If you print the list of values obtained from either, you get the following: `[(0,
    0), (3, 27), (5, 125), (6, 216), (9, 729), (10, 1000), (12, 1728), (15, 3375),
    (18, 5832)]` .'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了两个迭代器`cubes1`和`cubes2`。它们都将产生相同的元组序列*(n, n3)*，其中`n`是3或5的倍数。如果你打印从任一迭代器获得的值列表，你会得到以下结果：`[(0,
    0), (3, 27), (5, 125), (6, 216), (9, 729), (10, 1000), (12, 1728), (15, 3375),
    (18, 5832)]`。
- en: Notice that the generator expression is much easier to read. It may be debatable
    for trivial examples, but as soon as you start performing more complex operations,
    the superiority of the generator syntax is evident. It is shorter, simpler, and
    more elegant.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到生成器表达式更容易阅读。对于简单的例子，这可能是有争议的，但一旦开始执行更复杂的操作，生成器语法的优越性就显而易见了。它更短，更简单，也更优雅。
- en: 'Now, let us ask you: what is the difference between the following lines of
    code?'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们问你：以下两行代码之间的区别是什么？
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Strictly speaking, they all produce the same sum. The expressions to get `s2`
    and `s3` are equivalent because the brackets in `s2` are redundant. Both are generator
    expressions passed to the `sum()` function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，它们都产生了相同的总和。获取`s2`和`s3`的表达式是等效的，因为`s2`中的括号是多余的。两者都是传递给`sum()`函数的生成器表达式。
- en: The expression to get `s1` is different, though. Here we are passing the result
    of a list comprehension to `sum()` . This wastes both time and memory because
    we first create a list of a million elements (which has to be stored in memory).
    We then pass the list to `sum` , which iterates over it, after which we discard
    the list. It is much better to use a generator expression, as we do not need to
    wait for a list to be constructed, and we do not need to store the entire sequence
    of 1 million values in memory.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`s1`的表达式是不同的。在这里，我们正在将列表推导式的结果传递给`sum()`。这既浪费了时间又浪费了内存，因为我们首先创建了一个包含一百万个元素的列表（必须存储在内存中）。然后我们将列表传递给`sum`，它遍历这个列表，之后我们丢弃这个列表。使用生成器表达式会更好，因为我们不需要等待列表构建完成，也不需要将一百万个值的整个序列存储在内存中。
- en: 'So, *watch out for extra parentheses when you write your expressions* . Details
    like this are easy to miss, but they can make a significant difference. For example,
    look at the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*在编写表达式时要小心额外的括号*。这样的细节很容易忽略，但它们可以产生重大差异。例如，看看下面的代码：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we run this, we get:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们会得到：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'On the other hand, if we comment out the first line, and uncomment the second
    one, this is the result:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们取消注释第一行，并取消注释第二行，这是结果：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The difference between the two lines is that in the first, the Python interpreter
    must construct a list with the squares of the first ten billion numbers to pass
    to the `sum` function. That list is huge, and we ran out of memory, so the operating
    system killed the process.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行代码之间的区别在于，在第一行中，Python解释器必须构建一个包含前十亿个数的平方的列表，以传递给`sum`函数。这个列表非常大，所以我们耗尽了内存，操作系统杀死了进程。
- en: When we remove the square brackets, we no longer have a list. The `sum` function
    receives a generator, which yields 0, 1, 4, 9, and so on, and computes the sum
    without needing to keep all the values in memory.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们移除方括号时，我们不再有一个列表。`sum`函数接收一个生成器，它产生0、1、4、9等，并计算总和，而不需要将所有值都保留在内存中。
- en: Some performance considerations
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些性能考虑
- en: There are usually multiple ways of achieving the same result. We can use any
    combination of `map()` , `zip()` , and `filter()` , or choose to go with a comprehension
    or a generator. We may even decide to go with `for` loops. Readability is often
    a factor in choosing between these approaches. List comprehensions or generator
    expressions are often easier to read than complex combinations of `map()` and
    `filter()` . For more complicated operations, generator functions or `for` loops
    are often better.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有几种方法可以达到相同的结果。我们可以使用`map()`、`zip()`和`filter()`的任何组合，或者选择使用推导式或生成器。我们甚至可以决定使用`for`循环。在决定这些方法之间的选择时，可读性通常是一个因素。列表推导式或生成器表达式通常比复杂的`map()`和`filter()`组合更容易阅读。对于更复杂的操作，生成器函数或`for`循环通常更好。
- en: 'Besides readability concerns, however, we must also consider performance when
    deciding which approach to use. There are two factors that need to be considered
    when comparing the performance of different implementations: `space` and `time`
    .'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了可读性方面的考虑，我们在决定使用哪种方法时还必须考虑性能。在比较不同实现性能时需要考虑两个因素：`空间`和`时间`。
- en: Space refers to the amount of memory that your data structures are going to
    use. The best way to choose is to ask yourself if you really need a list (or tuple),
    or whether a generator would work instead.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 空间指的是你的数据结构将要使用的内存量。最好的选择是问问自己你是否真的需要一个列表（或元组），或者是否可以使用生成器。
- en: 'If the answer is yes to the latter, go with the generator, as it will save
    a lot of space. The same goes for functions: if you do not actually need them
    to return a list or tuple, then you can transform them into generator functions
    as well.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对后者的回答是肯定的，就选择生成器，因为它会节省大量空间。对于函数也是如此：如果你实际上不需要它们返回列表或元组，那么你也可以将它们转换为生成器函数。
- en: Sometimes, you will have to use lists (or tuples); for example, there are algorithms
    that scan sequences using multiple pointers, and others need to iterate over the
    sequence more than once. A generator (function or expression) can be iterated
    over only once before it is exhausted, so in these situations, it would not be
    the right choice.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你将不得不使用列表（或元组）；例如，有些算法使用多个指针扫描序列，还有一些需要多次遍历序列。生成器（函数或表达式）在耗尽之前只能迭代一次，所以在这种情况下，它可能不是最佳选择。
- en: Time is a bit more complicated than space because it depends on more variables,
    and it is not always possible to state that *X is faster than Y* with absolute
    certainty for all cases. However, based on tests run on Python today, we can say
    that on average, `map()` exhibits performance similar to comprehensions and generator
    expressions, while `for` loops are consistently slower.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 时间比空间复杂一些，因为它依赖于更多的变量，并且对于所有情况，我们并不总是能够绝对肯定地说“X比Y快”。然而，基于今天在Python上运行的测试，我们可以这样说，平均而言，`map()`的性能与推导式和生成器表达式相似，而`for`循环则始终较慢。
- en: To appreciate the reasoning behind these statements fully, we need to understand
    how Python works, which is a bit outside the scope of this book as it is quite
    technical and detailed. Let us just say that `map()` and comprehensions run at
    C language speed within the interpreter, while a Python `for` loop is run as Python
    bytecode within the Python Virtual Machine, which is often much slower.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解这些陈述背后的推理，我们需要了解Python是如何工作的，这超出了本书的范围，因为它相当技术性和详细。我们只能说，在解释器中，`map()`和推导式以C语言的速度运行，而Python的`for`循环在Python虚拟机中以Python字节码的形式运行，这通常要慢得多。
- en: There are several different implementations of Python. The original one, and
    still the most common one, is CPython ( [https://github.com/python/cpython](https://github.com/python/cpython)
    ), which is written in C. C is one of the most powerful and popular programming
    languages still used today.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Python有几种不同的实现方式。最初的一个，也是目前最常见的一个，是CPython（[https://github.com/python/cpython](https://github.com/python/cpython)），它是用C语言编写的。C语言是今天仍在使用的最强大和最受欢迎的编程语言之一。
- en: 'In the rest of this section, we will perform some simple experiments to verify
    these performance claims. We will write a small piece of code that collects the
    results of `divmod(a, b)` for a set of integer pairs, `(a, b)` . We will use the
    `time()` function from the `time` module to calculate the elapsed time of the
    operations that we perform:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的剩余部分，我们将进行一些简单的实验来验证这些性能主张。我们将编写一小段代码，收集整数对`(a, b)`的`divmod(a, b)`的结果。我们将使用`time`模块中的`time()`函数来计算我们执行的操作的经过时间：
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you can see, we are creating three lists: `floop` , `compr` , and `gener`
    . Running the code produces the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在创建三个列表：`floop`、`compr`和`gener`。运行代码会产生以下结果：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The list comprehension runs in ~71% of the time taken by the `for` loop. The
    generator expression was slightly faster than that, with ~69%. The difference
    in time between the list comprehension and generator expression is hardly significant,
    and if you re-run the example a few times, you will probably also see the list
    comprehension take less time than the generator expression.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式的执行时间大约占`for`循环时间的71%。生成器表达式的执行速度略快，大约为69%。列表推导式和生成器表达式之间的时间差异几乎不显著，如果你多次重新运行示例，你可能会看到列表推导式比生成器表达式用时更少。
- en: It is worth noting that, within the body of the `for` loop, we are appending
    data to a list. This implies that, behind the scenes, the Python interpreter occasionally
    has to resize the list to allocate space for more items to be appended. We guessed
    that creating a list of zeros, and simply filling it with the results, might have
    sped up the `for` loop, but we were wrong. Try it for yourself; you just need
    `mx * (mx - 1) // 2` elements to be pre-allocated.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在`for`循环的主体中，我们正在向列表中追加数据。这意味着在幕后，Python解释器偶尔需要调整列表的大小，为追加更多项分配空间。我们猜测，创建一个零列表，并简单地填充结果，可能会加快`for`循环的速度，但我们错了。自己试试看；你只需要`mx
    * (mx - 1) // 2`个元素预先分配。
- en: The approach we used here for timing execution is rather naïve. In *Chapter
    11* , *Debugging and Profiling* , we will look at better ways of profiling code
    and timing execution.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里用于计时执行的方法相当天真。在*第11章*，*调试和性能分析*中，我们将探讨更好的代码性能分析和计时方法。
- en: 'Let us see a similar example that compares a `for` loop and a `map()` call:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个类似的例子，比较`for`循环和`map()`调用：
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This code is conceptually similar to the previous example. The only thing that
    has changed is that we are applying the `abs()` function instead of `divmod()`
    , and we have only one loop instead of two nested ones. Execution gives the following
    result:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在概念上与前面的例子相似。唯一不同的是，我们正在应用`abs()`函数而不是`divmod()`，我们只有一个循环而不是两个嵌套循环。执行结果如下：
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This time, `map` was the fastest: it took ~53% of the time required by the
    list comprehension, and ~31% of the time needed by the `for` loop.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`map`是最快的：它所需的时间是列表推导式的约53%，是`for`循环所需时间的约31%。
- en: The results from these experiments give us a rough indication of the relative
    speed of `for` loops, list comprehensions, generator expressions, and the `map()`
    function. Do not rely too heavily on these results though, as the experiments
    we performed here are rather simplistic, and accurately measuring and comparing
    execution times is difficult. Measurements can easily be affected by several factors,
    such as other processes running on the same computer. Performance results are
    also heavily dependent on the hardware, operating system, and Python version.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实验的结果给我们提供了一个关于`for`循环、列表推导式、生成器表达式和`map()`函数相对速度的大致指示。然而，不要过分依赖这些结果，因为我们在这里进行的实验相当简单，准确测量和比较执行时间是很困难的。测量很容易受到多个因素的影响，例如在同一台计算机上运行的其它进程。性能结果也严重依赖于硬件、操作系统和Python版本。
- en: It is clear that `for` loops are slower than comprehensions or `map()` , so
    it is worth discussing why we nevertheless often prefer them over the alternatives.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`for`循环比列表推导式或`map()`函数慢，所以讨论为什么我们仍然经常选择它们而不是替代方案是值得的。
- en: Do not overdo comprehensions and generators
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要过度使用列表推导式和生成器
- en: We have seen how powerful comprehensions and generator expressions can be. However,
    we find that the more you try to do within a single comprehension or generator
    expression, the harder it becomes to read, understand, and therefore maintain
    or change.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了列表推导式和生成器表达式有多么强大。然而，我们发现，你在一个单一的列表推导式或生成器表达式中尝试做的事情越多，就越难阅读、理解和维护或更改。
- en: 'If you consider the Zen of Python again, there are a few lines that, we think,
    are worth keeping in mind when dealing with optimized code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次考虑Python的禅意，有几行代码我们认为在处理优化代码时值得记住：
- en: '[PRE50]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Comprehensions and generator expressions are more implicit than explicit, can
    be quite difficult to read and understand, and can be difficult to explain. Sometimes,
    you have to break them apart using the inside-out technique to understand what
    is going on.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式和生成器表达式比显式表达式更隐晦，可能相当难以阅读和理解，也可能难以解释。有时，你必须使用从内到外的技术将其分解，才能理解正在发生的事情。
- en: To give you an example, let us talk a bit more about Pythagorean triples. Just
    to remind you, a Pythagorean triple is a tuple of positive integers *(a, b, c)*
    such that *a* ² *+ b* ² *= c* ² . We saw how to calculate them in the *Filtering
    a comprehension* section, but we did it in a very inefficient way. We scanned
    all pairs of numbers below a certain threshold, calculating the hypotenuse, and
    filtering out those that were not valid Pythagorean triples.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你一个例子，让我们再详细谈谈毕达哥拉斯三元组。只是为了提醒你，毕达哥拉斯三元组是一个正整数元组 *(a, b, c)*，其中 *a*² + *b*²
    = *c*²。我们在*过滤列表推导式*部分看到了如何计算它们，但我们以一种非常低效的方式做了这件事。我们扫描了低于某个阈值的所有数字对，计算斜边，并过滤掉那些不是有效的毕达哥拉斯三元组的数字对。
- en: 'A better way to get a list of Pythagorean triples is to generate them directly.
    There are many different formulas you can use to do this; here we will use the
    **Euclidean formula** . This formula says that any triple *(a, b, c)* , where
    *a = m* ² *- n* ² *, b = 2mn* and *c = m* ² *+ n* ² , with *m* and *n* positive
    integers such that *m > n* , is a Pythagorean triple. For example, when *m = 2*
    and *n = 1* , we find the smallest triple: *(3, 4, 5)* .'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 获取毕达哥拉斯三元组的更好方法是直接生成它们。你可以使用许多不同的公式来做这件事；在这里，我们将使用 **欧几里得公式**。这个公式表明，任何三元组 *(a,
    b, c)*，其中 *a = m* ² *- n* ²*，*b = 2mn*，*c = m* ² *+ n* ²，*m* 和 *n* 是满足 *m > n*
    的正整数，都是一个毕达哥拉斯三元组。例如，当 *m = 2* 和 *n = 1* 时，我们找到最小的三元组：*(3, 4, 5)*。
- en: 'There is one catch though: consider the triple *(6, 8, 10)* , which is like
    *(3, 4, 5)* , only all the numbers are multiplied by *2* . This triple is Pythagorean,
    since *6* ² *+ 8* ² *= 10* ² , but we can derive it from *(3, 4, 5)* simply by
    multiplying each of its elements by *2* . The same goes for *(9, 12, 15)* , *(12,
    16, 20)* , and in general for all the triples that we can write as *(3k, 4k, 5k)*
    , with *k* being a positive integer greater than *1* .'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一个问题：考虑三元组 *(6, 8, 10)*，它类似于 *(3, 4, 5)*，只是所有的数字都乘以了 *2*。这个三元组是毕达哥拉斯三元组，因为
    *6* ² *+ 8* ² *= 10* ²，但我们可以通过将它的每个元素乘以 *2* 从 *(3, 4, 5)* 推导出来。同样适用于 *(9, 12,
    15)*，*(12, 16, 20)*，以及一般地，我们可以写成 *(3k, 4k, 5k)* 的所有三元组，其中 *k* 是大于 *1* 的正整数。
- en: 'A triple that cannot be obtained by multiplying the elements of another one
    by some factor, *k* , is called **primitive** . Another way of stating this is
    as follows: if the three elements of a triple are **coprime** , then the triple
    is primitive. Two numbers are coprime when they do not share any prime factor
    among their divisors, that is, when their **greatest common divisor** ( **GCD**
    ) is *1* . For example, 3 and 5 are coprime, while 3 and 6 are not because they
    are both divisible by 3.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 不能通过将另一个三元组的元素乘以某个因子 *k* 得到的三元组被称为 **原始的**。另一种说法是：如果一个三元组的三个元素是 **互质的**，那么这个三元组是原始的。两个数互质是指它们在它们的除数中没有共享任何质因数，也就是说，当它们的
    **最大公约数** ( **GCD** ) 是 *1* 时。例如，3 和 5 是互质的，而 3 和 6 不是，因为它们都可以被 3 整除。
- en: 'The Euclidean formula tells us that if *m* and *n* are coprime, and *m - n*
    is odd, the triple they generate is *primitive* . In the following example, we
    will write a generator expression to calculate all the primitive Pythagorean triples
    whose hypotenuse, *c* , is less than or equal to some integer, *N* . This means
    we want all triples for which *m* ² *+ n* ² *≤ N* . When *n* is *1* , the formula
    looks like this: *m* ² *≤ N - 1* , which means we can approximate the calculation
    with an upper bound of *m ≤ N* ^(1/2) .'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得公式告诉我们，如果 *m* 和 *n* 互质，并且 *m - n* 是奇数，它们生成的三元组是 *原始的*。在下面的例子中，我们将编写一个生成器表达式来计算所有斜边
    *c* 小于或等于某个整数 *N* 的原始毕达哥拉斯三元组。这意味着我们想要所有满足 *m* ² *+ n* ² *≤ N* 的三元组。当 *n* 为 *1*
    时，公式看起来是这样的：*m* ² *≤ N - 1*，这意味着我们可以用 *m ≤ N* ^(1/2) 的上界来近似计算。
- en: 'To recap: *m* must be greater than *n* , they must also be coprime, and their
    difference *m - n* must be odd. Moreover, to avoid useless calculations, we will
    put the upper bound for *m* at *floor(sqrt(N)) + 1* .'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下：*m* 必须大于 *n*，它们也必须是互质的，并且它们的差 *m - n* 必须是奇数。此外，为了避免无用的计算，我们将 *m* 的上界设置为
    *floor(sqrt(N)) + 1*。
- en: The `floor` function for a real number, *x* , gives the maximum integer, *n*
    , such that *n < x* , for example, *floor(3.8) = 3* , *floor(13.1) = 13* . Taking
    *floor(sqrt(N)) + 1* means taking the integer part of the square root of *N* and
    adding a minimal margin just to make sure we do not miss any numbers.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 实数 *x* 的 `floor` 函数给出最大的整数 *n*，使得 *n < x*，例如，*floor(3.8) = 3*，*floor(13.1) =
    13*。取 *floor(sqrt(N)) + 1* 的意思是取 *N* 的平方根的整数部分，并加上一个最小的边距，以确保我们不会错过任何数字。
- en: 'Let us put all of this into code, step by step. We start by writing a simple
    `gcd()` function that uses **Euclid’s algorithm** :'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步将这些内容放入代码中。我们首先编写一个简单的 `gcd()` 函数，它使用 **欧几里得算法**：
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The explanation of Euclid’s algorithm is available on the web, so we will not
    spend any time talking about it here as we need to focus on the generator expression.
    The next step is to use the knowledge we gathered before to generate a list of
    primitive Pythagorean triples:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得算法的解释可以在网上找到，所以我们不会在这里花费时间讨论它，因为我们需要专注于生成器表达式。下一步是使用我们之前收集的知识来生成一个原始毕达哥拉斯三元组的列表：
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is not easy to read, so let us go through it line by line. At `#3` , we
    start a generator expression that creates triples. You can see from `#4` and `#5`
    that we are looping on `m` in *[1, M]* , with *M* being the integer part of *sqrt(N)*
    , plus *1* . On the other hand, `n` loops within *[1, m)* , to respect the *m
    > n* rule. It is worth noting how we calculated *sqrt(N)* , that is, `N**.5` ,
    which is just another way to do it that we wanted to show you.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不易阅读，让我们逐行分析。在`#3`行，我们开始一个生成器表达式，创建三元组。你可以从`#4`和`#5`看到，我们在`*[1, M]*`上循环`m`，其中`M`是`*sqrt(N)*`的整数部分，加上`*1*`。另一方面，`n`在`*[1,
    m)*`范围内循环，以遵守`*m > n*`规则。值得注意的是我们如何计算`*sqrt(N)*`，即`N**.5`，这是我们想展示的另一种方法。
- en: 'At `#6` , you can see the filtering conditions to make the triples primitive:
    `(m - n) % 2` evaluates to `True` when `(m - n)` is odd, and `gcd(m, n) == 1`
    means `m` and `n` are coprime. With these in place, we know the triples will be
    primitive. This takes care of the innermost generator expression. The outermost
    one starts at `#2` and finishes at `#7` . We take the triples `(a, b, c) in (...innermost
    generator...)` such that `c <= N` .'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在`#6`处，你可以看到用于使三元组成为原始的筛选条件：`(m - n) % 2`在`(m - n)`为奇数时评估为`True`，而`gcd(m, n)
    == 1`意味着`m`和`n`是互质的。有了这些条件，我们知道三元组将是原始的。这解决了最内层的生成器表达式。最外层的生成器表达式从`#2`开始，到`#7`结束。我们取三元组`(a,
    b, c)`，其中`c <= N`，来自`(...innermost generator...)`。
- en: Finally, at `#1` , we apply sorting to present the list in order. At `#8` ,
    after the outermost generator expression is closed, you can see that we specify
    the sorting key to be the sum `a + b + c` . This is just our personal preference;
    there is no mathematical reason behind it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`#1`处，我们应用排序来按顺序展示列表。在`#8`处，在外层生成器表达式关闭后，你可以看到我们指定排序键为`a + b + c`的总和。这仅仅是我们个人的偏好；背后没有数学上的原因。
- en: This code is certainly not easy to understand or explain. Code like this is
    also difficult to debug or modify. It should have no place in a professional environment.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码当然不容易理解或解释。这样的代码也难以调试或修改。它不应该出现在专业环境中。
- en: 'Let us see whether we can rewrite this code into something more readable:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们能否将此代码重写为更易读的形式：
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This is much easier to read. Let us go through it, line by line. You will see
    it is also much easier to understand.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码更容易阅读。让我们逐行分析。你会发现它也更容易理解。
- en: 'We start looping at `#1` and `#2` , over the same ranges as in the previous
    example. On line `#3` , we filter for primitive triples. On line `#4` , we deviate
    a bit from what we were doing before: we calculate `c` , and on line `#5` , we
    filter on `c` being less than or equal to `N` . We only calculate `a` and `b`
    , and yield the resulting tuple if `c` satisfies that condition. We could have
    calculated the values of `a` and `b` earlier, but by delaying until we know all
    conditions for a valid triple are satisfied, we avoid wasting time and CPU cycles.
    On the last line, we apply sorting with the same key we were using in the generator
    expression example.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`#1`和`#2`开始循环，范围与上一个示例相同。在`#3`行，我们筛选原始三元组。在`#4`行，我们稍微偏离了之前的行为：我们计算`c`，在`#5`行，我们筛选`c`小于或等于`N`。我们只计算`a`和`b`，如果`c`满足该条件，则产生结果元组。我们本可以在更早的时候计算`a`和`b`的值，但通过推迟到我们知道所有有效三元组的条件都满足，我们避免了浪费时间和CPU周期。在最后一行，我们使用与生成器表达式示例中相同的键进行排序。
- en: We hope you agree that this example is easier to understand. If we ever need
    to modify the code, this will be much easier, and less error-prone to work with,
    than the generator expression.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你会同意这个示例更容易理解。如果我们需要修改代码，这将更容易，并且与生成器表达式相比，工作起来更不容易出错。
- en: 'If you print the results of both examples, you will get this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打印出这两个示例的结果，你会得到以下内容：
- en: '[PRE54]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: There is often a trade-off between performance and readability, and it is not
    always easy to get the balance right. Our advice is to try to use comprehensions
    and generator expressions whenever you can. But if the code starts to become complicated
    to modify or difficult to read or explain, you may want to refactor it into something
    more readable.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能和可读性之间往往存在权衡，而且并不总是容易找到平衡点。我们的建议是尽可能使用列表推导和生成器表达式。但如果代码开始变得难以修改或难以阅读或解释，你可能想要将其重构为更易读的形式。
- en: Name localization
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 名称本地化
- en: 'Now that we are familiar with all types of comprehensions and generator expressions,
    let us talk about name localization within them. Python 3 localizes loop variables
    in all four forms of comprehensions: list, dictionary, set, and generator expressions.
    This behavior is different from that of the `for` loop. Let us look at some simple
    examples to show all the cases:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了所有类型的推导式和生成器表达式，让我们来谈谈它们内部的名称本地化。Python 3 在所有四种推导式形式中本地化循环变量：列表、字典、集合和生成器表达式。这种行为与
    `for` 循环的行为不同。让我们看看一些简单的例子来展示所有情况：
- en: '[PRE55]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding code, we declare a global name, `A = 100.` We then have list,
    dictionary, and set comprehensions, and a generator expression. Even though they
    all use the name `A` , none of them alter the global name, `A` . On the other
    hand, the `for` loop at the end does modify the global `A` . The last `print`
    statement prints 4.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个全局名称，`A = 100.` 然后，我们有列表、字典和集合推导式，以及一个生成器表达式。尽管它们都使用了名称 `A`，但它们都没有改变全局名称
    `A`。另一方面，最后的 `for` 循环确实修改了全局的 `A`。最后的 `print` 语句打印了 4。
- en: 'Let us see what happens if the global `A` was not there:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果全局的 `A` 不存在会发生什么：
- en: '[PRE56]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The preceding code would work in the same way with any other type of comprehension
    or with a generator expression. After we run the first line, `A` is not defined
    in the global namespace. Once again, the `for` loop behaves differently:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在处理任何其他类型的理解或生成器表达式时都会以相同的方式工作。运行第一行后，`A` 在全局命名空间中未定义。再次，`for` 循环的行为不同：
- en: '[PRE57]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The preceding code shows that after a `for` loop, if the loop variable was
    not defined before it, we can find it in the global namespace. We can verify this
    by inspecting the dictionary returned by the `globals()` built-in function:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码表明，在 `for` 循环之后，如果循环变量在它之前未定义，我们可以在全局命名空间中找到它。我们可以通过检查 `globals()` 内置函数返回的字典来验证这一点：
- en: '[PRE58]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Along with various built-in global names (which we have not reproduced here),
    we see `''A'': 4` .'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '除了各种内置的全局名称（我们在此没有重复），我们还看到了 `''A'': 4` 。'
- en: Generation behavior in built-ins
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置函数的生成器行为
- en: Generator-like behavior is quite common among the built-in types and functions.
    This is a major difference between Python 2 and Python 3. In Python 2, functions
    such as `map()` , `zip()` , and `filter()` returned lists instead of iterable
    objects. The idea behind this change is that if you need to make a list of those
    results, you can always wrap the call in a `list()` class. On the other hand,
    if you just need to iterate and want to keep the impact on memory as light as
    possible, you can use those functions safely. Another notable example is the `range()`
    function. In Python 2, it returned a list, and there was another function called
    `xrange()` that behaved like the `range()` function now behaves in Python 3.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器行为在内置类型和函数中相当常见。这是 Python 2 和 Python 3 之间的一个主要区别。在 Python 2 中，`map()`、`zip()`
    和 `filter()` 等函数返回列表而不是可迭代对象。这种变化背后的想法是，如果你需要创建一个包含这些结果的列表，你总是可以用 `list()` 类来包装调用。另一方面，如果你只需要迭代并且希望尽可能减少内存影响，你可以安全地使用这些函数。另一个值得注意的例子是
    `range()` 函数。在 Python 2 中，它返回一个列表，还有一个名为 `xrange()` 的函数，其行为与 Python 3 中 `range()`
    函数的行为相似。
- en: The idea of functions and methods that return iterable objects is quite widespread.
    You can find it in the `open()` function, which is used to operate on file objects
    (we will see it in *Chapter 8* , *Files and Data Persistence* ), but also in `enumerate()`
    , in the dictionary `keys()` , `values()` , and `items()` methods, and several
    other places.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和方法返回可迭代对象的想法相当普遍。你可以在 `open()` 函数中找到它，该函数用于操作文件对象（我们将在 *第 8 章* ，*文件和数据持久性*
    中看到它），也可以在 `enumerate()`、字典的 `keys()`、`values()` 和 `items()` 方法以及几个其他地方找到。
- en: 'It all makes sense: Python aims to reduce the memory footprint by avoiding
    wasting space wherever possible, especially in those functions and methods that
    are used extensively in most situations.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都有道理：Python 旨在通过尽可能避免浪费空间来减少内存占用，尤其是在那些在大多数情况下广泛使用的函数和方法中。
- en: At the beginning of this chapter, we said that it makes more sense to optimize
    the performance of code that has to deal with large collections of objects, rather
    than shaving off a few milliseconds from a function that we call twice a day.
    That is precisely what Python itself is doing here.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们说过，优化必须处理大量对象代码的性能比从每天调用两次的函数中节省几毫秒更有意义。这正是 Python 本身在这里所做的事情。
- en: One last example
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后一个例子
- en: Before we finish this chapter, we will show you a simple problem that Fabrizio
    used to give to candidates for a Python developer role in a company he used to
    work for.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成这一章之前，我们将向你展示一个简单的问题，Fabrizio 曾经用它来测试应聘他曾经工作过的公司 Python 开发者职位的候选人。
- en: 'The problem is the following: write a function that returns the terms of the
    sequence *0 1 1 2 3 5 8 13 21 ...* , up to some limit, *N* .'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 问题如下：编写一个函数，返回数列 *0 1 1 2 3 5 8 13 21 ...* 的项，直到某个限制 *N* 。
- en: If you have not recognized it, that is the Fibonacci sequence, which is defined
    as *F(0) = 0, F(1) = 1* and, for any *n > 1* , *F(n) = F(n-1) + F(n-2)* . This
    sequence is excellent for testing knowledge about recursion, memoization techniques,
    and other technical details, but in this case, it was a good opportunity to check
    whether the candidate knew about generators.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有认出它，那就是斐波那契数列，它被定义为 *F(0) = 0, F(1) = 1* ，并且对于任何 *n > 1* ，*F(n) = F(n-1)
    + F(n-2)* 。这个数列非常适合测试关于递归、记忆化技术以及其他技术细节的知识，但在这个情况下，这是一个检查候选人是否了解生成器的好机会。
- en: 'Let us start with a rudimentary version, and then improve on it:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基础版本开始，然后对其进行改进：
- en: '[PRE59]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'From the top: we set up the `result` list to a starting value of `[0]` . Then
    we start the iteration from the next element ( `next_n` ), which is 1. While the
    next element is not greater than `N` , we keep appending it to the list and calculating
    the next value in the sequence. We calculate the next element by taking a slice
    of the last two elements in the `result` list and passing it to the `sum` function.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始：我们将 `result` 列表设置为起始值 `[0]`。然后我们从下一个元素（`next_n`）开始迭代，它是 1。当下一个元素不大于 `N`
    时，我们继续将其追加到列表中，并计算序列中的下一个值。我们通过从 `result` 列表中的最后两个元素中取一个切片并将其传递给 `sum` 函数来计算下一个元素。
- en: If you struggle to understand the code, it can help to add some `print()` statements
    so that you can see how values change during execution.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你难以理解代码，添加一些 `print()` 语句可能会有所帮助，这样你就可以看到在执行过程中值是如何变化的。
- en: When the loop condition evaluates to `False` , we exit the loop and return `result`
    . You can see the result of those `print` statements in the comments next to each
    of them.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环条件评估为 `False` 时，我们退出循环并返回 `result`。你可以看到每个 `print` 语句旁边的注释中的结果。
- en: 'At this point, Fabrizio would ask the candidate the following question: *What
    if I just wanted to iterate over those numbers?* A good candidate would then change
    the code to the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，Fabrizio 会问候选人以下问题：*如果我只想迭代这些数字怎么办？* 一个好的候选人会相应地更改代码如下：
- en: '[PRE60]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This is actually one of the solutions he was given. Now, the `fibonacci()` function
    is a *generator function* . First, we yield 0, and then, if `N` is 0, we `return`
    (this will cause a `StopIteration` exception to be raised). If that is not the
    case, we start looping, yielding `b` at every iteration, before updating `a` and
    `b` . This solution relies on the fact that we only need the last two elements
    ( `a` and `b` ) to be able to produce the next one.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是他被给出的解决方案之一。现在，`fibonacci()` 函数是一个 *生成器函数* 。首先，我们产生 0，然后，如果 `N` 是 0，我们
    `return`（这将引发 `StopIteration` 异常）。如果不是这种情况，我们开始循环，在每次迭代中产生 `b`，然后更新 `a` 和 `b`。这个解决方案依赖于我们只需要最后两个元素（`a`
    和 `b`）来产生下一个元素。
- en: 'This code is much better, has a lighter memory footprint, and all we have to
    do to get a list of Fibonacci numbers is wrap the call with `list()` , as usual.
    We can make it even more elegant, though:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码更好，内存占用更少，我们只需要用 `list()` 包装调用，就像平常一样，就可以得到斐波那契数的列表。不过，我们可以让它更加优雅：
- en: '[PRE61]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The whole body of the function is now only four lines, or five if you count
    the docstring. Notice how, in this case, using tuple assignment ( `a, b = 0, 1`
    and `a, b = b, a + b` ) helps in making the code shorter and more readable.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的主体现在只有四行，如果你把文档字符串也算上，则是五行。注意，在这种情况下，使用元组赋值（`a, b = 0, 1` 和 `a, b = b, a
    + b`）如何有助于使代码更短、更易读。
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the concepts of iteration and generation a bit
    more deeply. We looked at the `map()` , `zip()` , and `filter()` functions in
    detail, and learned how to use them as an alternative to a regular `for` loop
    approach.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们更深入地探讨了迭代和生成的概念。我们详细研究了 `map()`、`zip()` 和 `filter()` 函数，并学习了如何将它们用作常规
    `for` 循环方法的替代方案。
- en: Then, we covered the concept of comprehensions to construct lists, dictionaries,
    and sets. We explored their syntax and how to use them as an alternative to both
    the classic `for` loop approach and the `map()` , `zip()` , and `filter()` functions.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了构建列表、字典和集合的推导式概念。我们探讨了它们的语法以及如何将它们用作经典`for`循环方法以及`map()`、`zip()`和`filter()`函数的替代方案。
- en: 'Finally, we talked about the concept of generators in two forms: generator
    functions and expressions. We learned how to save time and space by using generation
    techniques. We also saw how operations that are infeasible to perform with lists
    can be performed with generators instead.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了生成器的两种形式：生成器函数和表达式。我们学习了如何通过使用生成技术来节省时间和空间。我们还看到了原本用列表无法执行的操作，可以用生成器来完成。
- en: We talked about performance and saw that `for` loops come last in terms of speed,
    but they provide the best readability and flexibility to change. On the other
    hand, functions such as `map()` and `filter()` , and comprehensions, can be much
    faster.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了性能，并看到在速度方面，`for`循环排在最后，但它们提供了最佳的可读性和灵活性，便于更改。另一方面，`map()`和`filter()`等函数以及推导式可以更快。
- en: The complexity of the code written using these techniques grows exponentially,
    so to favor readability and ease of maintainability, we still need to use the
    classic `for` loop approach at times. Another difference is in the name localization,
    where the `for` loop behaves differently from all other types of comprehensions.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些技术编写的代码的复杂度呈指数增长，因此为了提高可读性和易于维护，我们有时仍然需要使用经典的`for`循环方法。另一个区别在于名称本地化，`for`循环的行为与其他所有类型的推导式不同。
- en: The next chapter will be all about objects and classes. It is structurally similar
    to this one, in that we will not explore many different subjects—just a few of
    them—but we will try to delve deeper into them.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将全部关于对象和类。在结构上与这一章相似，即我们不会探索很多不同的主题——只是其中的一些——但我们将尝试更深入地探讨它们。
- en: Join our community on Discord
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_5.xhtml)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '[加入我们的Discord社区](https://discord.com/invite/uaKmaz7FEC)'
- en: '![img](img/QR_Code119001106417026468.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code119001106417026468.png)'
