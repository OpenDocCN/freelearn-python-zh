- en: Building Your Own Extension
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建你自己的扩展
- en: From the first chapter of this book, we have been adding Flask extensions to
    our app in order to add new features and to save us from spending lots of time
    reinventing the wheel. Up to this point, it has been unknown how these Flask extensions
    worked.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从这本书的第一章开始，我们就一直在我们的应用中添加 Flask 扩展，以便添加新功能并节省我们花费大量时间重新发明轮子的时间。到目前为止，这些 Flask
    扩展是如何工作的还一直是个谜。
- en: 'In this chapter, we''ll learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: How to create two simple Flask extensions in order to better understand Flask
    internals and allow you to extend Flask with your own functionality
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建两个简单的 Flask 扩展，以便更好地理解 Flask 内部机制，并允许你使用自己的功能扩展 Flask。
- en: How to extend Jinja
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何扩展 Jinja
- en: How to create a Python package, ready to be published to PyPI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个 Python 包，准备发布到 PyPI
- en: Creating a YouTube Flask extension
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 YouTube Flask 扩展
- en: 'To begin, the first extension we are going to create is a simple extension
    that allows the embedding of YouTube videos in Jinja templates using the following
    tag:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将要创建的第一个扩展是一个简单的扩展，它允许使用以下标签在 Jinja 模板中嵌入 YouTube 视频：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `video_id` object is the code after `v` in any YouTube URL. For example,
    in the URL `https://www.youtube.com/watch?v=_OBlgSz8sSM`, the `video_id` object
    is `_OBlgSz8sSM`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`video_id` 对象是任何 YouTube URL 中 `v` 后面的代码。例如，在 URL `https://www.youtube.com/watch?v=_OBlgSz8sSM`
    中，`video_id` 对象是 ` _OBlgSz8sSM`。'
- en: For now, the code for this extension resides in `__init__.py`. However, this
    is only for development and debugging purposes. When the code is ready to be shared,
    it is moved into its own project directory.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个扩展的代码位于 `__init__.py` 文件中。然而，这只是为了开发和调试目的。当代码准备好分享时，它会被移动到它自己的项目目录中。
- en: 'The first thing that any Flask extension needs is the object that will be initialized
    on the app. This object will handle adding its `Blueprint` object to the app and
    registering the `youtube` function on Jinja:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 Flask 扩展都需要的是将在 `app` 对象上初始化的对象。这个对象将处理将其 `Blueprint` 对象添加到应用中并在 Jinja 中注册
    `youtube` 函数：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So far, the only thing this code does is initialize an empty blueprint on the
    `app` object.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这段代码所做的唯一事情是在 `app` 对象上初始化一个空的蓝图。
- en: Notice the code marked with bold. In the `YouTube` class, we have to register
    the function to Jinja in the `init_app` method. We can now use the `youtube` Jinja
    function on our templates.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意用粗体标记的代码。在 `YouTube` 类中，我们必须在 `init_app` 方法中注册函数到 Jinja。现在我们可以在模板中使用 `youtube`
    Jinja 函数了。
- en: 'The next piece of code needed is a representation of a video. The following
    is a class that handles the parameters from the Jinja function and renders HTML
    to display in the template:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步需要的代码是视频的表示。以下是一个处理 Jinja 函数参数并渲染 HTML 以在模板中显示的类：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This object is created from the `youtube` function in the template, and any
    arguments passed in the template are given to this object to render the HTML.
    There is also a new object in this code, `Markup`, which was not used before.
    The `Markup` class is Flask's way of automatically escaping HTML, or marking it
    as safe to include in the template. If we just returned HTML, Jinja would auto
    escape it because it does not know whether it is safe or not. This is Flask's
    way of protecting your site from **cross-site scripting attacks**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象是从模板中的 `youtube` 函数创建的，并且模板中传递的任何参数都会传递给这个对象以渲染 HTML。在这段代码中还有一个新的对象，`Markup`，之前没有使用过。`Markup`
    类是 Flask 自动转义 HTML 或将其标记为安全包含在模板中的方式。如果我们只是返回 HTML，Jinja 会自动转义它，因为它不知道它是否安全。这是
    Flask 保护你的网站免受 **跨站脚本攻击** 的方式。
- en: 'The next step is to create the function that will be registered in Jinja:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建将在 Jinja 中注册的函数：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we have to create the HTML that will add the video to the page. In
    a new folder named `youtube` in the `templates` directory, create a new HTML file
    named `video.html` and add the following code to it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须创建将视频添加到页面的 HTML。在 `templates` 目录下名为 `youtube` 的新文件夹中，创建一个名为 `video.html`
    的新 HTML 文件，并向其中添加以下代码：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is all the code that''s needed to embed YouTube videos in your templates.
    Let''s test this out now. In `__init__.py`, initialize the `Youtube` class below
    the `Youtube` class definition:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是嵌入 YouTube 视频到模板中所需的所有代码。现在让我们来测试一下。在 `__init__.py` 文件中，在 `Youtube` 类定义下方初始化下面的
    `Youtube` 类：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In `__init__.py`, use the `youtube_ext` variable, which contains the initialized class, and
    use the `init_app` method we created to register it on the app:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `__init__.py` 中，使用包含初始化类的 `youtube_ext` 变量，并使用我们创建的 `init_app` 方法将其注册到应用上：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, as a simple example, add the `youtube` function to the top of the blog
    home page on `templates/blog/home.html`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为一个简单的例子，将 `youtube` 函数添加到 `templates/blog/home.html` 的博客主页顶部：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will have the following result:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '![](img/92fe397f-1ed7-4802-b4bd-300759ec0d67.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/92fe397f-1ed7-4802-b4bd-300759ec0d67.png)'
- en: Creating a Python package
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Python 包
- en: 'In order to make our new Flask extension available to others, we have to create
    an installable Python package from the code we have written so far. To begin,
    we need a new project directory outside of our current application directory.
    We will need two things: a `setup.py` file, which we will fill in later, and a
    folder named `flask_youtube`. In the `flask_youtube` directory, we will have an
    `__init__.py` file, which contains all the code that we wrote for our extension.
    This includes the `Youtube` and the `Video` Python classes.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的新 Flask 扩展可供他人使用，我们必须将我们迄今为止编写的代码创建成一个可安装的 Python 包。首先，我们需要在当前应用程序目录之外创建一个新的项目目录。我们需要两样东西：一个
    `setup.py` 文件，稍后我们将填写它，以及一个名为 `flask_youtube` 的文件夹。在 `flask_youtube` 目录中，我们将有一个
    `__init__.py` 文件，其中包含我们为扩展编写的所有代码。这包括 `Youtube` 和 `Video` Python 类。
- en: Also, inside the `flask_youtube` directory, we will need a `templates` directory,
    which holds the `youtube` directory that we put in our app's `templates` directory.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 `flask_youtube` 目录内，我们还需要一个 `templates` 目录，它包含我们放在应用程序 `templates` 目录中的
    `youtube` 目录。
- en: In order to turn this code into a Python package, we use the library named `setuptools`.
    Now, `setuptools` is a Python package that allows developers to easily create
    installable packages for their code. `setuptools` bundles code so that `pip` and
    `easy_install` can automatically install them, and will even upload your package
    to the **Python Package Index** (**PyPI**).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此代码转换为 Python 包，我们使用名为 `setuptools` 的库。现在，`setuptools` 是一个 Python 包，它允许开发者轻松地为他们的代码创建可安装的包。`setuptools`
    将代码打包，以便 `pip` 和 `easy_install` 可以自动安装它们，甚至可以将您的包上传到 **Python 包索引**（**PyPI**）。
- en: All the packages that we have been installed from `pip` have come from PyPI.
    To see all the available packages, go to [https://pypi.python.org/pypi](https://pypi.python.org/pypi).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `pip` 安装的所有包都来自 PyPI。要查看所有可用的包，请访问 [https://pypi.python.org/pypi](https://pypi.python.org/pypi)。
- en: 'All you need to do to get this functionality is fill out the `setup.py` file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需填写 `setup.py` 文件即可获得此功能：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code uses the `setup` function from `setuptools` to find your source code
    and make sure that the machine that is installing your code has the required packages.
    Most of the attributes are rather self-explanatory, except the package attribute,
    which uses the `find_packages` function from `setuptools`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用 `setuptools` 的 `setup` 函数来查找您的源代码，并确保安装您的代码的机器具有所需的包。大多数属性都是相当自解释的，除了包属性，它使用
    `setuptools` 的 `find_packages` 函数。
- en: The `package` attribute finds which parts of the source code are part of the
    package to be released. We use the `find_packages` method to automatically find
    which parts of the code to include. This is based on some sane defaults, such
    as looking for directories with `__init__.py` files and excluding common file
    extensions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`package` 属性查找源代码中哪些部分是包的一部分。我们使用 `find_packages` 方法自动查找要包含的代码部分。这是基于一些合理的默认值，例如查找包含
    `__init__.py` 文件的目录，并排除常见的文件扩展名。'
- en: 'We must also declare a manifest file that the `setuptools` will use to know
    how to create our package. This includes rules for cleaning up files, and what
    folders that are not Python modules to include:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须声明一个清单文件，`setuptools` 将使用它来了解如何创建我们的包。这包括清理文件的规则，以及哪些不是 Python 模块的文件夹需要包含：
- en: '`MANIFEST.in`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`MANIFEST.in`'
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Although it is not mandatory, this setup also contains metadata about the author
    and the license, which would be included on the PyPI page if we were to upload
    this there. There is a lot more customization available in the `setup` function,
    so I encourage you to read the documentation at [http://pythonhosted.org/setuptools/](http://pythonhosted.org/setuptools/).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是强制性的，但此设置还包含有关作者和许可证的元数据，如果我们将它上传到 PyPI，这些信息将包含在 PyPI 页面上。`setup` 函数中还有许多可用的自定义选项，所以我鼓励您阅读
    [http://pythonhosted.org/setuptools/](http://pythonhosted.org/setuptools/) 的文档。
- en: 'You can now install this package on your machine by running the following commands:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过运行以下命令在您的机器上安装此包：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This installs your code into your Python `packages` directory, or if you''re
    using `virtualenv`, it installs it to the local `packages` directory. Then, you
    can import your place on package via the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将您的代码安装到您的 Python `packages` 目录中，或者如果您正在使用 `virtualenv`，它将安装到本地的 `packages`
    目录。然后，您可以通过以下代码导入您的包：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating blog posts with videos
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建包含视频的博客帖子
- en: We are now going to extend our blog so that users can include videos on their
    posts. This is a nice feature and is useful for showing how to create a new feature
    that includes database schema change and migration, as well as giving a review
    on Jinja2 and WTForms.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将扩展我们的博客，以便用户可以在他们的帖子中包含视频。这是一个很好的功能，并且对于展示如何创建一个包含数据库模式更改和迁移的新功能很有用，同时还可以对
    Jinja2 和 WTForms 进行评论。
- en: 'First, we need to add a new column named `youtube_id` (on the following highlighted
    code) to our `Post` SQLAlchemy model on the `blog/models.py` file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在 `blog/models.py` 文件中的 `Post` SQLAlchemy 模型上添加一个名为 `youtube_id` 的新列（以下为高亮代码）：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we are able to store our user''s YouTube ID to go along with their posts.
    Next we need to include our new field on the `Post` form. So, in the `blog/forms.py`
    file, we add the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够存储用户的 YouTube ID，以便与他们的帖子一起使用。接下来，我们需要在我们的 `Post` 表单中包含我们的新字段。因此，在 `blog/forms.py`
    文件中，我们添加以下内容：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we need to change the `edit` and `new_post` controllers:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要更改 `edit` 和 `new_post` 控制器：
- en: '`blog/controllers.py`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`blog/controllers.py`:'
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We are setting the `Post.youtube_id` SQLAlchemy model attribute to the form `youtube_id` field,
    and for the `edit` method, we have the same thing when the forms have been submitted
    (POST HTTP method), and it''s the other way around when the form is shown:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将 SQLAlchemy 模型属性 `Post.youtube_id` 设置为表单中的 `youtube_id` 字段，对于 `edit` 方法，当表单已提交（POST
    HTTP 方法）时，情况相同，而当表单显示时则相反：
- en: '`blog/controllers.py`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`blog/controllers.py`:'
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we just have to include this new field on our Jinja2 templates. On
    our `templates/blog/post.html`, we render this field if it exists on the database:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需在我们的 Jinja2 模板中包含这个新字段。在我们的 `templates/blog/post.html` 中，如果数据库中存在该字段，我们将渲染此字段：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To finish, we change our new post and edit the post templates. Just look for
    the change in the provided code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们更改我们的新帖子并编辑帖子模板。只需查找提供的代码中的更改。
- en: Modifying the response with Flask extensions
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Flask 扩展修改响应
- en: So, we have created an extension that adds new functionality to our templates.
    But how would we create an extension that modifies the behavior of our app at
    the request level? To demonstrate this, let's create an extension that modifies
    all the responses from Flask by compressing the contents of the response. This
    is a common practice in web development in order to speed up page load times,
    as compressing objects with a method such as `gzip` is very fast and relatively
    cheap, CPU-wise. Normally, this would be handled at the server level. So, unless
    you wish to host your app with only Python code, which is possible and will be
    covered in [Chapter 13](380101ac-fb85-4e2e-b664-8d6de77928f4.xhtml), *Deploying
    Flask Apps*, this extension really doesn't have much use in the real world.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建了一个扩展，为我们的模板添加了新的功能。但我们是怎样创建一个在请求级别修改我们应用行为的扩展的呢？为了演示这一点，让我们创建一个扩展，通过压缩响应的内容来修改
    Flask 的所有响应。这是网络开发中的一种常见做法，为了加快页面加载时间，因为使用 `gzip` 等方法压缩对象非常快且相对便宜，从 CPU 的角度来看。通常，这会在服务器级别处理。所以，除非您希望仅使用
    Python 代码托管您的应用，这是可能的，并且将在第 13 章[部署 Flask 应用]中介绍，这个扩展在现实世界中实际上并没有太多用途。
- en: To achieve this, we will use the `gzip` module in the Python standard library
    to compress the contents after each request is processed. We will also have to
    add special HTTP headers into the response in order for the browser to know that
    the content is compressed. We will also need to check in the HTTP request headers
    whether the browser can accept gzipped content.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用 Python 标准库中的 `gzip` 模块在每次请求处理完毕后压缩内容。我们还需要在响应中添加特殊的 HTTP 头部，以便浏览器知道内容已被压缩。我们还需要检查
    HTTP 请求头部，以确定浏览器是否可以接受压缩内容。
- en: 'Just as before, our content will initially reside in the `__init__.py` file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们的内容最初将驻留在 `__init__.py` 文件中：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Just as with the previous extension, our initializer for the compressed object
    accommodates both the normal Flask setup and the application factory setup. In
    the `after_request` method, instead of registering a blueprint, we register a
    new function on the `after-request` event so that our extension can compress the
    results.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的扩展一样，我们为压缩对象提供的初始化器既适用于正常的 Flask 设置，也适用于应用程序工厂设置。在 `after_request` 方法中，我们不是注册一个蓝图，而是在
    `after-request` 事件上注册一个新的函数，以便我们的扩展可以压缩结果。
- en: The `after_request` method is where the real logic of the extension comes into
    play. First, it checks whether the browser accepts gzip encoding by looking at
    the `Accept-Encoding` value in the request header. If the browser does not accept
    gzip, or the browser did not return a successful response, the function just returns
    the content and makes no modifications to the content. However, if the browser
    does except our content and the response was successful, then the content will
    be compressed. We use another standard library class named `BytesIO`, which allows
    file streams to be written and stored in memory, rather than being stored in an
    intermediate file. This is necessary because the `GzipFile` object expects to
    write to a file object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`after_request` 方法是扩展真正逻辑发挥作用的地方。首先，它通过查看请求头中的 `Accept-Encoding` 值来检查浏览器是否接受
    gzip 编码。如果浏览器不接受 gzip，或者浏览器没有返回成功的响应，函数就直接返回内容，不对内容进行任何修改。然而，如果浏览器接受我们的内容并且响应是成功的，那么内容将被压缩。我们使用另一个名为
    `BytesIO` 的标准库类，它允许文件流在内存中写入和存储，而不是存储在中间文件中。这是必要的，因为 `GzipFile` 对象期望写入文件对象。'
- en: After the data is compressed, we set the response object data to the results
    of the compression and set the necessary HTTP header values in the response as
    well. Finally, the gzip content is returned to the browser, and the browser then
    decompresses the content, significantly speeding up the page load times.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 数据压缩后，我们将响应对象的数据设置为压缩的结果，并在响应中设置必要的 HTTP 头部值。最后，gzip 内容被返回给浏览器，然后浏览器对其进行解压缩，显著加快页面加载时间。
- en: In order to test the functionality in your browser, you have to disable Flask
    Debug Toolbar because, at the time of writing, there is a bug in its code where
    it expects all responses to be encoded in UTF-8.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在浏览器中测试功能，你必须禁用 Flask Debug Toolbar，因为在编写本文时，它的代码中存在一个错误，它期望所有响应都编码为 UTF-8。
- en: If you reload the page, nothing should look different. However, if you use the
    developer tools in the browser of your choice and inspect the responses, you will
    see that they are compressed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新加载页面，看起来应该没有不同。然而，如果你使用你选择的浏览器的开发者工具检查响应，你会看到它们已经被压缩。
- en: Summary
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now that we have looked at two different examples of different types of Flask
    extensions, you should have a very clear understanding of how most of the Flask
    extensions that we used work. Using the knowledge that you have now, you should
    be able to add any extra functionality to Flask that you need for your specific
    application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经研究了不同类型的 Flask 扩展的两个不同示例，你应该对大多数我们使用的 Flask 扩展的工作方式有非常清晰的理解。利用你现在的知识，你应该能够为你的特定应用程序添加任何额外的
    Flask 功能。
- en: In the next chapter, we are going to look at how to add testing to our application
    to take out the guesswork of whether the changes we made to the code have broken
    any of the functionality of our application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何将测试添加到我们的应用程序中，以消除我们做出的代码更改是否破坏了应用程序功能的功能性猜测。
