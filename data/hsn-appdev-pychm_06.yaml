- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Seamless Testing, Debugging, and Profiling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无缝测试、调试和性能分析
- en: In [*Chapter 5*](B19644_05.xhtml#_idTextAnchor112), *Version Control with Git
    in PyCharm*, I talked about *The Joel Test*. This test is just a list of best
    practices. At the top of the list is the use of version control, which was the
    subject of the previous chapter. If you looked up the list, you were probably
    not surprised to see testing was also on the list. Formalized software testing
    practices such as **test-driven development** (**TDD**) and **behavior-driven
    development** (**BDD**) are the cornerstones of software quality control. Working
    with these methodologies helps you create software that is less likely to fail
    in production. Done correctly, it also has side benefits, such as preventing scope
    creep and allowing for effective refactoring on projects that might have neglected
    best practices and taken on a lot of technical debt.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 5 章*](B19644_05.xhtml#_idTextAnchor112)，“PyCharm 中使用 Git 进行版本控制”，我谈到了
    *乔尔测试*。这个测试只是一个最佳实践的列表。列表的顶端是使用版本控制，这是上一章的主题。如果你查看了这个列表，你可能不会对测试也出现在列表上感到惊讶。形式化的软件测试实践，如
    **测试驱动开发**（**TDD**）和 **行为驱动开发**（**BDD**），是软件质量控制的基础。使用这些方法有助于你创建在生产环境中不太可能失败的应用程序。如果做得正确，它还有附带的好处，例如防止范围蔓延，并允许在可能忽视了最佳实践和承担了大量技术债务的项目上进行有效的重构。
- en: 'Several levels of testing are in practice today, including the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 目前实践中存在多个测试级别，包括以下内容：
- en: '**Unit testing**, which aims to test basic low-level functionality at the level
    of functions or classes'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**，旨在在函数或类级别测试基本低级功能'
- en: '**Integration testing**, which aims to test how components within a larger
    system work together'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**，旨在测试更大系统中组件之间的协作方式'
- en: '**User interface testing**, which aims to test how interactive elements of
    a system work'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户界面测试**，旨在测试系统交互元素的工作方式'
- en: '**End-to-end testing**, which tests an entire system in a production-like environment'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**，在类似生产环境中对整个系统进行测试'
- en: Like all well-established programming languages, Python has a rich set of testing
    libraries available. And since Python is “batteries included,” there are some
    fine testing tools built into the standard library. Naturally, third-party solutions
    have evolved and are available via [PyPi.org](http://PyPi.org).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有成熟的编程语言一样，Python 拥有一套丰富的测试库。由于 Python 是“内置电池”，因此标准库中包含了一些优秀的测试工具。自然地，第三方解决方案已经发展起来，并通过
    [PyPi.org](http://PyPi.org) 提供。
- en: I cut my teeth on Java’s **JUnit** library, and later on its .NET port called
    **NUnit**. I found it made software development very enjoyable. There’s just something
    fun about starting your day with a set of tests that don’t pass, and throughout
    the day, writing the code to make each one pass. If you’re disciplined, you will
    write the bare minimum code needed, and gradually you will see progress as your
    testing tool changes color from red to green. You shouldn’t take shortcuts, and
    you shouldn’t be tempted to write in functionality that seems cool but that you
    might not need later. When I made the leap to Python years ago, I was pleased
    to see so many options regarding testing libraries and frameworks. I was equally
    pleased to see that PyCharm supports most of the popular ones right in the IDE.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 Java 的 **JUnit** 库上磨炼了我的技能，后来又转向其 .NET 版本 **NUnit**。我发现这使得软件开发变得非常愉快。每天开始时，有一套无法通过的测试，然后整天编写代码让每个测试通过，这很有趣。如果你自律，你会编写所需的最少代码，随着你的测试工具颜色从红色变为绿色，你将逐渐看到进步。你不应该走捷径，也不应该被诱惑去编写看似酷炫但可能以后不需要的功能。当我多年前跳转到
    Python 时，我很高兴看到关于测试库和框架的许多选项。我也同样高兴地看到 PyCharm 在 IDE 中支持大多数流行的工具。
- en: In this chapter, we’ll be looking at creating unit tests in Python code while
    following the tenets of TDD. In TDD, you generally create a set of tests designed
    to prove your software meets a set of requirements. These tests are written before
    you create any functionality in your program, and they start as failures. Your
    job is to make the tests pass with the simplest code possible.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在遵循 TDD（测试驱动开发）原则的同时，在 Python 代码中创建单元测试。在 TDD 中，你通常创建一组旨在证明你的软件满足一系列要求的测试。这些测试在你创建程序中的任何功能之前编写，并且最初是失败的。你的任务是使用尽可能简单的代码使测试通过。
- en: Along the way, you’ll need to use a debugger to step through problematic code
    that either inexplicably fails, or perhaps worse, inexplicably works. Once your
    code works and passes tests, you usually want to consider the speed of execution.
    The **National Health Service** (**NHS**) in Great Britain developed an algorithm
    that matched organ donations to patients in the system. The complex algorithm
    had to be fast because there is a limited window of time during which a harvested
    organ is viable for transplant. Similar time constraints exist in many other types
    of applications. As developers, we need tools to help us pinpoint efficiency bottlenecks.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，你可能需要使用调试器逐步通过有问题的代码，这些代码要么无法解释地失败，或许更糟的是，无法解释地工作。一旦你的代码运行正常并通过测试，你通常想要考虑执行速度。大不列颠的**国家卫生服务**（**NHS**）开发了一个算法，将器官捐赠与系统中的患者匹配。这个复杂的算法必须快速，因为摘取的器官在移植前有一个有限的时间窗口是可行的。许多其他类型的应用程序也存在类似的时间限制。作为开发者，我们需要工具来帮助我们定位效率瓶颈。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Unit testing in Python with PyCharm
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PyCharm 在 Python 中进行单元测试
- en: Using PyCharm’s powerful visual debugger
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PyCharm 强大的可视化调试器
- en: Working with PyCharm’s profiling tools to find performance bottlenecks in your
    code
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PyCharm 的性能分析工具来查找代码中的性能瓶颈
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the prerequisites for this chapter:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为本章的先决条件：
- en: A working installation of Python 3.10 or later
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装好 Python 3.10 或更高版本
- en: A working installation of PyCharm
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装好 PyCharm
- en: The sample code for this chapter, which can be found at [https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-06](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-06
    )
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的示例代码，可在[https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-06](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-06
    )找到
- en: Testing, testing, 1-2-3
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试，测试，1-2-3
- en: 'Unit testing is a practice designed to prove your code works as designed. A
    good set of tests will match a functional specification. A great set of tests
    will do that but also account for any obvious paths of failure. To get started,
    let’s get our feet wet with something simple: your bank account. OK, it doesn’t
    have to be yours. Consider a typical transaction where you buy something at a
    store using your ATM card.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一种旨在证明你的代码按设计工作的实践。一组好的测试将匹配功能规范。一组优秀的测试将做到这一点，但也会考虑到任何明显的失败路径。为了入门，让我们从一些简单的事情开始：你的银行账户。好吧，它不一定是你的。考虑一个典型的交易，你使用
    ATM 卡在商店购买东西。
- en: 'You visit your favorite brick-and-mortar bookstore to pick up your next excellent
    read in the field of software development. Let’s say you find a copy of my first
    book, *Real World Implementation of C# Design Patterns*, published by Packt. Given
    its status as an instant classic, you can’t resist picking up a copy at any price.
    You tap your card on the bookstore’s point-of-sale system and two things happen:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你前往你最喜欢的实体书店挑选你下一本关于软件开发领域的优秀读物。假设你找到了我第一本书的副本，*《C# 设计模式的实际应用实现》*，由 Packt 出版。鉴于其作为即时经典的地位，你无法抗拒以任何价格购买一本。你将卡片在书店的收银系统上刷一下，然后发生两件事：
- en: The equivalent of $39.95 – which is an absolute steal by the way – is taken
    out of your bank account.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相当于 39.95 美元——顺便说一句，这是一个绝对的便宜货——从你的银行账户中扣除。
- en: The same amount is transferred into the bank account of the bookstore.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相同的金额被转入书店的银行账户。
- en: This is a transactional operation. Formally speaking, a transaction is a multi-step
    operation where every step must complete without errors. It should be an all-or-nothing
    set of operations. If the first step completes but the second fails, then $39.95
    just vanishes from your bank account and you don’t get to go home with your book.
    If the second step works but the first fails, you get a free book, but the local
    bookseller goes broke. We need both steps to complete, or at worst, fail completely
    so that no money changes hands.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个事务性操作。从形式上讲，一个事务是一个多步骤操作，每个步骤都必须无错误地完成。它应该是一个全有或全无的操作集。如果第一步完成但第二步失败，那么
    39.95 美元就会从你的银行账户中消失，你无法带着书回家。如果第二步工作但第一步失败，你将得到一本免费的书，但当地的书店会破产。我们需要两个步骤都完成，或者最坏的情况是，完全失败，这样就不会有任何金钱交易。
- en: This level of criticality is a good scenario for learning about unit testing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重要性的水平是学习单元测试的好场景。
- en: Unit testing in Python using PyCharm
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PyCharm 在 Python 中进行单元测试
- en: Create a new project in PyCharm using the plain Python project template. Let’s
    call it `bank_account`. You’ll find the completed example in the source repository
    for this chapter, but if you’d like to practice creating and testing the necessary
    code, just follow along.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PyCharm 中使用纯 Python 项目模板创建一个新的项目。我们可以称它为 `bank_account`。你可以在本章的源代码库中找到完成的示例，但如果你想要练习创建和测试必要的代码，只需按照以下步骤进行。
- en: 'PyCharm created a file called `main.py`. We’ll use it in a moment, but let’s
    put our bank transaction code in a separate module. One of the tenets of writing
    good code is writing **testable code**, and the best way to write testable code
    is to follow the **single-responsibility principle** (**SRP**), where you create
    units of code that have only one responsibility. SRP is part of a larger set of
    rules for creating a resilient coding architecture called **SOLID**, which is
    an acronym for the following principles:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 创建了一个名为 `main.py` 的文件。我们稍后会使用它，但让我们将我们的银行交易代码放入一个单独的模块中。编写良好代码的一个原则是编写
    **可测试的代码**，而编写可测试代码的最佳方式是遵循 **单一职责原则** （**SRP**），其中你创建只有单一职责的代码单元。SRP 是一个更大集合的规则的一部分，用于创建一个名为
    **SOLID** 的健壮编码架构，SOLID 是以下原则的缩写：
- en: '**Single-responsibility** **principle** (**SRP**)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责** **原则** （**SRP**）'
- en: '**Open-closed** **principle** (**OCP**)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭** **原则** （**OCP**）'
- en: '**Liskov substitution** **principle** (**LSP**)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换** **原则** （**LSP**）'
- en: '**Interface segregation** **principle** (**ISP**)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离** **原则** （**ISP**）'
- en: '**Dependency inversion** **principle** (**DIP**)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖倒置** **原则** （**DIP**）'
- en: SOLID is normally considered when developing a **fully object-oriented** (**FOO**)
    architecture using static languages that are strictly object-oriented. Java, C++,
    and C# are classic examples of such languages. Python allows for many different
    development paradigms, and its implementation of **object-oriented programming**
    (**OOP**) isn’t as complete, or maybe not as traditional, as many others. If you’ve
    never heard of SOLID as a Python developer, that’s probably why. Books and blogs
    exist where people have tried to shoehorn Python code to fit, but in my opinion,
    it often feels forced.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID 通常在开发使用静态语言（这些语言严格面向对象）的 **完全面向对象** （**FOO**） 架构时考虑。Java、C++ 和 C# 是此类语言的经典例子。Python
    允许许多不同的开发范式，并且它的 **面向对象编程** （**OOP**） 实现并不像许多其他语言那样完整，或者可能不是那么传统。如果你作为 Python
    开发者从未听说过 SOLID，那可能就是原因。有书籍和博客，人们试图将 Python 代码塞进去，但在我看来，这通常感觉是勉强的。
- en: SRP is one you should absolutely follow. It fits into any language and any paradigm.
    Simply put, the elements you make, be they functions, Python packages, or objects,
    should do only one thing, and do it well. By breaking up the responsibilities
    of your code, you can create reusable elements that can easily be unit tested,
    and therefore easily maintained. Everything should do one thing. Of course, there
    will be something tying it all together – maybe a `main` function in a program
    whose only purpose is to call everything else and provide a flow for your program.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: SRP 是你应该绝对遵循的原则。它适用于任何语言和任何范式。简单来说，你创建的元素，无论是函数、Python 包还是对象，都应该只做一件事，并且做好这件事。通过分解代码的责任，你可以创建可重用的元素，这些元素可以轻松地进行单元测试，因此也容易维护。每一件事都应该只做一件事。当然，总会有一些东西将它们全部联系在一起——可能是一个程序中的
    `main` 函数，它的唯一目的就是调用其他所有内容，并为你的程序提供流程。
- en: OCP states that once you have shipped a class to production, you should never
    change it. You should write your code in such a way that your classes are open
    to extension, but closed for modification. This principle is designed to protect
    the functionality you’ve already tested and shipped. If you open the class and
    change it, then you introduce the risk of bugs and you have to retest your entire
    program. If you limit your changes to an extension, then you only need to worry
    about testing the extension.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: OCP 表示一旦你将一个类发布到生产环境中，你就永远不应该更改它。你应该以这样的方式编写代码，使得你的类可以扩展，但不可修改。这个原则旨在保护你已经测试并发布的功能。如果你打开类并更改它，那么你将引入引入错误的风险，你必须重新测试整个程序。如果你将更改限制在扩展上，那么你只需要担心测试扩展。
- en: LSP doesn’t translate easily to Python. It states that any sub-class should
    be able to replace its superclass without affecting the correctness of the program.
    In other words, if a program is using a base class, it should be able to work
    correctly when you substitute a derived class for the base class. When you adhere
    to LSP, you are promoting the concept of polymorphism within your classes. This
    allows different objects to be treated uniformly through their common supertype,
    which leads to more flexible and modular designs. Implementing LSP is hard in
    dynamic languages such as Python since these languages allow for dynamic typing
    and late binding of method calls. For this reason, LSP is even more crucial than
    it is in static, strongly typed languages. The challenge comes with the lack of
    a strict compile type check you get in C#, C++, or Java. Any design mistakes you
    make will not surface until runtime. As a Python developer, you must design very
    carefully, and test with more intensity than you might in other languages.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: LSP在Python中不容易实现。它指出，任何子类都应该能够在不影响程序正确性的情况下替换其超类。换句话说，如果一个程序正在使用基类，那么在用派生类替换基类时，程序应该能够正确运行。当你遵守LSP时，你正在推广类内多态的概念。这允许通过它们的共同超类型统一地处理不同的对象，从而实现更灵活和模块化的设计。在像Python这样的动态语言中实现LSP很困难，因为这些语言允许动态类型和方法的后期绑定。因此，LSP在静态强类型语言中的重要性甚至更高。挑战在于缺乏C#、C++或Java中获得的严格编译类型检查。你犯的任何设计错误都不会在运行时显现出来。作为一个Python开发者，你必须非常小心地进行设计，并且比在其他语言中更加强烈地进行测试。
- en: ISP states that classes or modules should have interfaces that are tailored
    to their specific needs. An interface that specifies the structure and behavior
    of a class should not contain anything that is not needed by that class. This
    doesn’t translate well into Python since Python lacks the traditional interfaces
    found in languages such as Java and C#. The word interface can be taken to mean
    a regular superclass, in which case the superclass shouldn’t contain properties
    and methods that are never used within a subclass.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ISP指出，类或模块应该具有针对其特定需求的接口。指定类结构和行为的接口不应包含对该类不必要的任何内容。这不太适用于Python，因为Python缺乏像Java和C#这样的语言中找到的传统接口。接口一词可以理解为普通超类，在这种情况下，超类不应该包含在子类中从未使用过的属性和方法。
- en: DIP is a fundamental principle in object-oriented programming that deals with
    the dependencies between classes and modules. It states that high-level modules
    should not depend on low-level modules, but both should depend on abstractions.
    Additionally, it emphasizes that abstractions should not depend on details; rather,
    details should depend on abstractions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: DIP是面向对象编程中的一个基本原则，它处理类和模块之间的依赖关系。它指出，高级模块不应该依赖于低级模块，但两者都应该依赖于抽象。此外，它强调抽象不应该依赖于细节；相反，细节应该依赖于抽象。
- en: 'Here are the key ideas of DIP:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是DIP的关键思想：
- en: '**High-level modules should not depend on low-level modules**: High-level modules
    represent the higher-level logic or functionality of an application, while low-level
    modules deal with the implementation details and lower-level operations. According
    to DIP, high-level modules should not directly depend on low-level modules. Instead,
    both should depend on abstractions.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级模块不应该依赖于低级模块**：高级模块代表应用程序的高级逻辑或功能，而低级模块处理实现细节和低级操作。根据DIP，高级模块不应该直接依赖于低级模块。相反，两者都应该依赖于抽象。'
- en: '**Abstractions should not depend on details**: Abstractions, such as interfaces
    or abstract classes, define contracts that specify the behavior and functionality
    expected from the collaborating objects. DIP states that these abstractions should
    not depend on the specific implementation details of the lower-level modules.
    It promotes the idea of programming to interfaces rather than concrete implementations.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象不应该依赖于细节**：抽象，如接口或抽象类，定义了合同，指定了协作对象预期的行为和功能。DIP指出，这些抽象不应该依赖于底层模块的具体实现细节。它提倡面向接口编程而不是具体实现。'
- en: To adhere to DIP, it is essential to introduce abstractions, such as interfaces
    or abstract classes, and program against those abstractions rather than concrete
    implementations. This promotes loose coupling and allows for greater flexibility
    and maintainability in the code base. Ensure you don’t confuse this with **dependency
    injection** (**DI**). They are related, but not the same thing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循迪普原则（DIP），引入抽象，例如接口或抽象类，并针对这些抽象进行编程，而不是针对具体的实现进行编程，这是至关重要的。这促进了松散耦合，并使得代码库具有更大的灵活性和可维护性。确保你不会将此与**依赖注入**（**DI**）混淆。它们是相关的，但不是同一件事。
- en: DI is a design pattern or technique that facilitates the implementation of DIP.
    DI is a way to provide the dependencies required by a class from an external source,
    rather than having the class create or manage its dependencies internally.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: DI 是一种设计模式或技术，它促进了迪普原则的实施。DI 是一种从外部源提供类所需依赖项的方式，而不是让类内部创建或管理其依赖项。
- en: In DI, the responsibility of creating and providing dependencies is delegated
    to an external entity, typically called an “injector” or “container.” The container
    is responsible for creating instances of classes and injecting their dependencies.
    This allows for better decoupling and flexibility and easier testing since dependencies
    can easily be substituted or mocked during unit testing.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DI 中，创建和提供依赖项的责任被委托给一个外部实体，通常称为“注入器”或“容器”。容器负责创建类的实例并注入其依赖项。这允许更好的解耦和灵活性，并且由于在单元测试期间可以轻松地替换或模拟依赖项，因此更容易进行测试。
- en: DI can be seen as an implementation strategy for achieving the principles outlined
    in DIP. It helps in adhering to DIP by providing a mechanism that inverts the
    control of dependencies and separates the creation of objects from their usage.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: DI 可以被视为实现迪普原则中概述的原则的实施策略。它通过提供一种反转依赖项控制机制，将对象的创建与其使用分离，从而有助于遵循迪普原则。
- en: In summary, DIP is a guideline for designing modular, loosely coupled systems,
    while DI is a technique or pattern that’s used to implement DIP, which it does
    by externalizing the responsibility of managing dependencies.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，DIP 是设计模块化、松散耦合系统的指南，而 DI 是一种用于实现 DIP 的技术或模式，它通过外部化管理依赖项的责任来实现这一点。
- en: If you are interested in this kind of architecture, you should check out that
    book I plugged earlier as SOLID is covered extensively throughout, albeit with
    C# as the language. SRP, however, fits nicely with any language or paradigm, Python
    included.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对此类架构感兴趣，你应该查看我之前提到的那本书，因为 SOLID 原则在其中得到了广泛的覆盖，尽管语言是 C#。然而，SRP 与任何语言或范式都很好地结合，包括
    Python。
- en: When you stick with functions and classes that only do one thing, and do it
    well, testing them is a breeze because the functionality is isolated. Functions
    or classes that try to do too much are harder to test because of the interplay
    between dependencies. Let’s build something to make this clear.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你坚持使用只做一件事情并且做得很好的函数和类时，测试它们就变得非常容易，因为功能是隔离的。试图做太多事情的函数或类由于依赖项之间的相互作用而更难测试。让我们构建一些东西来使这一点更清楚。
- en: Choosing a test library
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择测试库
- en: 'Several popular unit testing libraries are available for Python 3\. Some of
    the most widely used include the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python 3，有几种流行的单元测试库可用。以下是一些最广泛使用的：
- en: '`unittest`: This is Python’s built-in unit testing framework, often referred
    to as `unittest`. It provides a set of classes and methods for writing and running
    tests. `unittest` follows the xUnit style of unit testing and offers features
    such as test discovery, test fixtures, and assertion methods.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unittest`：这是 Python 的内置单元测试框架，通常被称为 `unittest`。它提供了一套用于编写和运行测试的类和方法。`unittest`
    遵循 xUnit 风格的单元测试，并提供了测试发现、测试固定作用域和断言方法等功能。'
- en: '`pytest`: `pytest` is a popular, feature-rich testing framework that provides
    a more concise and expressive way of writing tests compared to `unittest`. It
    supports test discovery, fixtures, parameterized tests, and powerful assertion
    methods. `pytest` is known for its simplicity and flexibility.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest`：`pytest` 是一个流行的、功能丰富的测试框架，它提供了一种比 `unittest` 更简洁、更易于表达的方式来编写测试。它支持测试发现、固定作用域、参数化测试和强大的断言方法。`pytest`
    以其简单性和灵活性而闻名。'
- en: '`nose`: `nose` is another popular testing framework that extends the capabilities
    of `unittest`. It provides additional features, such as automatic test discovery,
    test generators, plugins, and advanced test selection and filtering options. While
    `nose` is widely used, its popularity has declined in recent years in favor of
    `pytest`.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nose`：`nose` 是另一个流行的测试框架，它扩展了 `unittest` 的功能。它提供了额外的功能，例如自动测试发现、测试生成器、插件以及高级测试选择和过滤选项。虽然
    `nose` 被广泛使用，但近年来其受欢迎程度有所下降，转而支持 `pytest`。'
- en: '`doctest`: `doctest` is a unique testing framework that allows you to write
    tests in the form of interactive examples within docstrings or documentation comments.
    It extracts and executes the examples as tests, verifying that the actual output
    matches the expected output. `doctest` is well-suited for testing code documentation
    and examples.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doctest`：`doctest` 是一个独特的测试框架，允许您在文档字符串或文档注释中以交互示例的形式编写测试。它提取并执行这些示例作为测试，验证实际输出是否与预期输出匹配。`doctest`
    非常适合测试代码文档和示例。'
- en: These are just a few examples of popular unit testing libraries in Python. Each
    library has its own features, style, and strengths, so it’s worth exploring them
    to find the one that aligns best with your project’s requirements and your personal
    preferences. The neat thing about working with PyCharm is that it supports all
    of these testing libraries, and the UI for running tests and viewing the results
    is always the same.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是 Python 中流行的单元测试库的一些例子。每个库都有自己的特性、风格和优势，因此值得探索，以找到最适合您项目需求和您个人偏好的库。与 PyCharm
    一起工作的好处是，它支持所有这些测试库，并且运行测试和查看结果的 UI 总是一致的。
- en: Since this is a book on PyCharm rather than an exposition on testing frameworks,
    I’m going to be using the `unittest` library, which is part of Python’s standard
    library. This will keep our sample code free of external dependencies.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一本关于 PyCharm 的书，而不是关于测试框架的阐述，我将使用 `unittest` 库，它是 Python 标准库的一部分。这将使我们的示例代码不依赖于外部依赖项。
- en: Adding a bank account class
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加银行账户类
- en: Right-click the project title in the project window and select `bank_account.py.`
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目窗口中右键单击项目标题，并选择 `bank_account.py`。
- en: 'Next, add the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加以下代码：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So far, we’ve created a class called `BankAccount`, created a constructor,
    and initialized three member variables called `name`, `account number`, and `balance`.
    Next, we’ll add a method designed to handle withdrawing money, but only if the
    amount is less than the balance:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个名为 `BankAccount` 的类，创建了一个构造函数，并初始化了三个成员变量，分别称为 `name`、`account
    number` 和 `balance`。接下来，我们将添加一个用于处理取款的方法，但前提是取款金额必须小于余额：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the amount that’s withdrawn is more than `balance`, we throw a `ValueError`
    and issue a message stating `Account overdrawn!`. Next, we need a method to add
    money to the account. It needs to be a positive number; otherwise, we’ll be doing
    a withdrawal, not a deposit:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果取出的金额超过 `balance`，我们将抛出一个 `ValueError` 并显示一条消息，指出 `Account overdrawn!`。接下来，我们需要一个方法来向账户中添加资金。它需要是一个正数；否则，我们将进行取款而不是存款：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So far, so good, right? Since our methods have some business logic in them,
    we should create a unit test for them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，对吧？由于我们的方法中包含一些业务逻辑，我们应该为它们创建单元测试。
- en: Testing the bank account class
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试银行账户类
- en: 'Right-click the title of the project in the project window and select **New**
    | **Python File**, but this time, make it a Python unit test, as shown in *Figure
    6**.1*:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目窗口中右键单击项目标题，并选择 **新建** | **Python 文件**，但这次，将其设置为 Python 单元测试，如图 *图 6**.1*
    所示：
- en: '![Figure 6.1: There are several templates for a new Python file](img/B19644_Figure_6.01.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1：有几种模板用于创建新的 Python 文件](img/B19644_Figure_6.01.jpg)'
- en: 'Figure 6.1: There are several templates for a new Python file'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：有几种模板用于创建新的 Python 文件
- en: There are several conventions for working with test files. Some think it’s a
    good idea to have a folder that contains just tests. Others think the test file
    should be right next to the file it is testing. I like this convention because
    it allows me to easily see which files in my project lack testing. Per a similar
    convention, I’m going to name the file `back_account_test.py`. Conventions dictate
    I either start or end the name of my file with the word *test*. I have put it
    at the end because if I don’t, the test file won’t be next to the file it is testing
    within the file explorer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理测试文件方面存在几种约定。有些人认为创建一个仅包含测试的文件夹是个好主意。其他人则认为测试文件应该紧挨着它所测试的文件。我喜欢这种约定，因为它让我能轻松地看到项目中哪些文件缺少测试。按照类似的约定，我将文件命名为`back_account_test.py`。约定规定，我的文件名要么以单词*test*开头，要么以它结尾。我把它放在了末尾，因为如果不这样做，测试文件就不会在文件资源管理器中紧挨着它所测试的文件。
- en: 'PyCharm creates the file, but it isn’t empty. The code in the file looks like
    this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm创建了文件，但它不是空的。文件中的代码看起来是这样的：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The IDE has presented us with a template containing a testing class that inherits
    from Python’s built-in unit testing framework. The framework is simply but unimaginatively
    called `unittest`. The template contains the required import at the top of the
    file, a testing class, one test method, and a `dunder-main` block that allows
    the script to run standalone. To get the test working, you need to modify this
    file. Start by adding an import to the file containing the class you want to test.
    The added line is in bold:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 集成开发环境（IDE）为我们提供了一个包含继承自Python内置单元测试框架的测试类的模板。这个框架简单而缺乏想象力地被称为`unittest`。模板包含文件顶部的必需导入、一个测试类、一个测试方法和一个允许脚本独立运行的`dunder-main`块。为了使测试工作，你需要修改这个文件。首先，向包含你想要测试的类的文件中添加一个导入。添加的行如下所示（加粗）：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, change the name of the class to `BankAccountTestCase`. Then, take out
    the `test_something(self)` method entirely and replace it with this one:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将类的名称更改为`BankAccountTestCase`。然后，完全移除`test_something(self)`方法，并用这个方法替换它：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To be honest, this is kind of a silly test because the constructor logic is
    extremely simple. Even I would be tempted to skip it. That isn’t always the case,
    though. If you’re doing something complicated in the constructor, you should unit-test
    it. Here, the example serves as a simple one to get us moving. All we did here
    was create a new instance of the `BankAccount` class and pass in a name, an account
    number, and an initial balance. Then, we used the `unittest` class’ `assertEqual`
    method to check each of the member variables to make sure they were set properly.
    There’s pretty much no way they weren’t unless you made a mistake, which is exactly
    the point.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，这是一个有点愚蠢的测试，因为构造函数的逻辑非常简单。即使是我也会想跳过它。但情况并不总是这样。如果你在构造函数中做了复杂的事情，你应该对其进行单元测试。在这里，这个例子作为一个简单的例子，让我们开始。我们在这里所做的只是创建了一个`BankAccount`类的新实例，并传递了一个名称、一个账户号码和一个初始余额。然后，我们使用了`unittest`类的`assertEqual`方法来检查每个成员变量，以确保它们被正确设置。除非你犯了错误，否则几乎不可能出错，这正是重点所在。
- en: 'Beware of the pesky self-typing self):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '小心那些讨厌的自定义self):'
- en: Having done a whole chapter on the miracles of auto-completion, I have to admit
    that sometimes, it can be annoying. This is one of those times. The instant you
    type the opening parenthesis of your test method, PyCharm is going to fill in
    the word `self`, along with the closing parenthesis and the colon for the end
    of the line. Because I type rapidly, I used to often wind up with something like
    `test_init(selfsel):` before I caught what happened. I’ve trained my right hand
    to find the *End* key on the keyboard as soon as I hit the opening parenthesis.
    This jumps you to the end of the auto-completed line. Hit *Enter*, and you’ll
    be right where you want to be.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成了一章关于自动补全奇迹的讨论后，我必须承认，有时它可能会让人感到烦恼。这就是那种时候。当你输入测试方法的开始括号时，PyCharm就会自动填充单词`self`，以及结束括号和行尾的冒号。因为我打字很快，所以我经常在意识到发生了什么之前，就打出了类似`test_init(selfsel):`的东西。我已经训练我的右手，在按下开始括号的同时，立即找到键盘上的*End*键。这会将你带到自动完成的行尾。按下*Enter*键，你就能到达你想要的位置。
- en: 'We’re going to add two more tests below the first one. The first test will
    test the `withdraw` method. Type in the new method below the first test, but above
    the line with the `dunder-main` test:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第一个测试下方添加两个更多的测试。第一个测试将测试`withdraw`方法。在第一个测试下方，但在带有`dunder-main`测试的行上方输入新的方法：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Type the test for the deposit below the `test_withdraw` method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test_withdraw`方法下方输入存款测试：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you haven’t guessed yet, these two tests are going to fail. That’s OK. I
    like to see them fail so that I know the whole testing setup is working. One of
    the benefits and side effects of being a long-time software developer is you don’t
    just assume anything will just work, regardless of who wrote it or how much the
    thing costs. Call it a survival instinct. If you skip this step, then may the
    odds be ever in your favor.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有猜到，这两个测试将会失败。这没关系。我喜欢看到它们失败，这样我知道整个测试设置是正常工作的。作为长期软件开发者的一个好处和副作用是，你不会假设任何东西都会正常工作，无论是谁写的，或者这个事物花了多少钱。称之为生存本能。如果你跳过这个步骤，那么愿好运永远在你这边。
- en: Running the tests
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'Let’s run our tests. Like many things, there are lots of ways to run the tests.
    You have no doubt noticed the appearance of green arrows in your test code, as
    seen in *Figure 6**.2*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的测试。像许多事情一样，运行测试有很多种方法。你无疑已经注意到了在你的测试代码中出现了绿色箭头，如图 *图 6.2* 所示。
- en: '![Figure 6.2: Green run arrows will appear in the IDE as you create your tests](img/B19644_Figure_6.02.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2：创建测试时，IDE 中将出现绿色运行箭头](img/B19644_Figure_6.02.jpg)'
- en: 'Figure 6.2: Green run arrows will appear in the IDE as you create your tests'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：创建测试时，IDE 中将出现绿色运行箭头
- en: 'These green arrows trigger a menu when you click them. For now, we’ll click
    the first item, which is `BankAccountTestCase`, the test runner will appear in
    the tool window at the bottom of the IDE window. You can see mine in *Figure 6**.3*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绿色箭头在你点击时会触发一个菜单。现在，我们将点击第一个项目，即 `BankAccountTestCase`，测试运行器将出现在 IDE 窗口底部的工具窗口中。你可以看到我的
    *图 6.3*：
- en: '![Figure 6.3: The test runner shows the tests that run, including those that
    passed and failed, and the console output](img/B19644_Figure_6.03.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3：测试运行器显示了运行的测试，包括通过和未通过的测试，以及控制台输出](img/B19644_Figure_6.03.jpg)'
- en: 'Figure 6.3: The test runner shows the tests that run, including those that
    passed and failed, and the console output'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3：测试运行器显示了运行的测试，包括通过和未通过的测试，以及控制台输出
- en: 'The test runner itself has a complete set of tools integrated into its window.
    I’ve numbered them in *Figure 6**.3*:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行器本身在其窗口中集成了完整的一套工具。我在 *图 6.3* 中对它们进行了编号：
- en: This pane shows the tests that passed and those that failed. They are displayed
    in a hierarchy that matches the call hierarchy.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此面板显示了通过和未通过的测试。它们以与调用层次结构相匹配的层次结构显示。
- en: This pane shows the console output from the test run itself.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此面板显示了测试运行的控制台输出。
- en: Above the output pane is a summary of the number of passing tests, along with
    how long the test suite ran.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输出面板上方是通过测试的数量摘要，以及测试套件运行的时间。
- en: 'To the left on the same toolbar is a collection of five buttons, followed by
    a vertical ellipsis. The ✓ and ⃠ buttons will filter out all the passed and failed
    tests, respectively. Filtering out the passed tests lets you focus solely on what
    failed. Filtering out the failed tests reduces the general malaise and utter hopelessness
    that you’ll feel when you have 5 out of 100 tests that passed. When this happens,
    I usually eat a sandwich and I feel better. Look at it this way: so long as you
    have failing tests, your job is probably safe because it would take longer to
    train a replacement than it would to wait until everything starts working. See
    it as a glass half-full. The next three before the ellipsis allow you to sort
    your test results, import tests from another file, and review your test run history.
    Say you have a test that was passing, then it failed and you wanted to go back
    and look at the last time it passed. That history is there if you need it. The
    ellipsis holds a few more options, including some miscellaneous settings for the
    test runner itself.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一工具栏的左侧是一组五个按钮，之后跟着一个垂直省略号。✓ 和 ⃠ 按钮将分别过滤掉所有通过和未通过测试。过滤掉通过测试让你能专注于未通过的部分。过滤掉未通过测试可以减少当你有
    100 个测试中只有 5 个通过时那种普遍的沮丧感和彻底的绝望感。当这种情况发生时，我通常会吃个三明治，感觉会好一些。这样想：只要你有未通过的测试，你的工作可能还是安全的，因为训练一个替代者可能需要更长的时间，而不是等待一切开始正常工作。把它看作是半满的玻璃杯。省略号之前的下三个按钮允许你排序测试结果，从另一个文件导入测试，并回顾你的测试运行历史。假设你有一个测试是通过的，然后失败了，你想回去看看它最后一次通过的时间。如果你需要，历史记录就在那里。省略号还包含一些其他选项，包括针对测试运行器本身的杂项设置。
- en: This toolbar allows you to rerun all the tests, rerun only those that failed,
    and stop a long-running test. Again, we have a vertical ellipsis, but this one
    has an interesting option for toggling **Auto Test**. Turning this option on will
    continually run your tests, for those of you who can’t stand the cursor travel
    time back down to the rerun button.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个工具栏允许你重新运行所有测试，只重新运行失败的测试，以及停止长时间运行的测试。再次强调，我们有一个垂直省略号，但这个省略号有一个有趣的选项，可以切换**自动测试**。开启这个选项后，对于那些无法忍受光标回到重新运行按钮的时间的人来说，测试将不断运行。
- en: When you run tests for the first time, PyCharm will create run configurations
    for you automatically. You can see them in the **Run configuration** dropdown
    on the top toolbar.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次运行测试时，PyCharm会自动为你创建运行配置。你可以在顶部工具栏的**运行配置**下拉菜单中看到它们。
- en: Fixing the failing tests
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复失败的测试
- en: 'We have two tests that will always fail, no matter what we do. Let’s start
    by altering the `test_withdraw(self)` method in the `bank_account_test.py` file.
    Change it to this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个测试总是会失败，无论我们做什么。让我们先从`bank_account_test.py`文件中的`test_withdraw(self)`方法开始修改。改为如下：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first line instantiates the `BankAccount` class with some testable values.
    Next, we invoke the `withdraw` method and withdraw $2,000\. I hope it is for something
    fun! Usually, it is my daughters borrowing my wallet to either shop for clothes
    or maybe buy raw materials for an engineering project. I can hope, right? I now
    expect my balance to drop from $4,000 to $2,000\. So, I use the `assertEqual`
    method on the `unittest` class, which is the superclass for my `BankAccountTestCase`
    class. I pass in `test_account.balance`, which will be compared with the expected
    result.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行实例化了`BankAccount`类，并使用了一些可测试的值。接下来，我们调用`withdraw`方法，取出$2,000。我希望它是为了做一些有趣的事情！通常情况下，是我的女儿们借我的钱包去购物或者可能为工程项目的原材料购买。我可以期待，对吧？我现在期待我的余额从$4,000降到$2,000。所以，我使用`unittest`类的`assertEqual`方法，它是我的`BankAccountTestCase`类的超类。我传入`test_account.balance`，这将与预期结果进行比较。
- en: 'I fully expect this test to pass! Click the rerun failed tests button shown
    in *Figure 6**.3*. It passed! Now, let’s write the `test_deposit` method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我完全期待这个测试会通过！点击*图6**.3*中显示的重新运行失败的测试按钮。它通过了！现在，让我们编写`test_deposit`方法：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The explanation here is the same as the last one, except this time, we are depositing
    $5,000 into my account. This rarely happens in real life, so give me a moment
    while I celebrate.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的解释与上一条相同，只是这次，我们将$5,000存入我的账户。这种情况在现实生活中很少发生，所以请给我一点时间，让我庆祝一下。
- en: Rerun the failed tests. They should all pass now! But we’re not done yet, are
    we?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行失败的测试。现在它们都应该通过了！但我们还没有完成，对吧？
- en: So far, these tests have followed the no-fault path. This means that so far,
    I’ve only tested the methods while running them as I designed them. Users in the
    real world will never do this. We need to test fault paths as well.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这些测试都遵循了无故障路径。这意味着到目前为止，我只测试了按照我设计的运行方法。现实世界中的用户永远不会这样做。我们需要测试故障路径。
- en: Testing the fault paths
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试故障路径
- en: 'There is one obvious fault path we designed into the system: the overdraft.
    What will happen if we try to take out more money than is available in the current
    balance? Or as my daughters might say, how do we generate a signal that tells
    us it’s time to come home from the mall and hide the receipts?'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在设计系统时故意设置了一个明显的故障路径：透支。如果我们试图取出比当前余额更多的钱，会发生什么？或者，用我女儿们可能会说的话，我们如何生成一个信号，告诉我们是时候从商场回家并隐藏收据了？
- en: 'We account for this in our code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中考虑了这一点：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, we check if the new balance will be a negative number. If it
    is, we throw a `ValueError`. This test is going to be a little different. Instead
    of using `assertEquals` to test a no-fault result, we want to verify that when
    this condition exists, we not only throw an error but that we throw the right
    kind of error. This is important because we expect `ValueError`, but if some other
    error is produced, the tests will give us a false positive if we only test for
    a generic `Exception`. Add the following test `BankAccountTestCase` class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们检查新的余额是否会变成负数。如果是，我们抛出一个`ValueError`。这个测试将会有一点不同。我们不是使用`assertEquals`来测试无故障的结果，而是想验证当这个条件存在时，我们不仅抛出一个错误，而且抛出正确的错误类型。这很重要，因为我们期望抛出`ValueError`，但如果产生了其他错误，如果我们只测试通用的`Exception`，测试将会给出一个错误的阳性结果。在`BankAccountTestCase`类中添加以下测试：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As before, we instantiate the `BankAccount` class with some testable values.
    For the test, we want to assert that the withdraw method raises a `ValueError`
    if we pass in more money than what exists in the balance. Here, we use `self.assertRaises`,
    which takes three arguments. The first argument is the type of error we expect.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们使用一些可测试的值实例化`BankAccount`类。对于测试，我们想要断言如果传入的金额超过余额，`withdraw`方法会引发`ValueError`。在这里，我们使用`self.assertRaises`，它接受三个参数。第一个参数是我们期望的错误类型。
- en: The second argument is the method under test. Note that we’re passing a reference
    to the function lambda-style. We aren’t executing the function since we need the
    `assertRaises` function to do that. Finally, we need to pass in the value of any
    arguments – in this case, some numbers that are bigger than the four grand I used
    for instantiation. In this case, I pass in `5000`. When I run this test, it should
    pass because the function will fail with the `ValueError` exception I expect.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是受测试的方法。注意，我们以lambda风格传递函数的引用。我们不需要执行函数，因为我们需要`assertRaises`函数来做这件事。最后，我们需要传递任何参数的值——在这个例子中，一些比实例化时用的四千更大的数字。在这种情况下，我传入`5000`。当我运行这个测试时，它应该通过，因为函数会因我期望的`ValueError`异常而失败。
- en: 'There is just one test left: we need to be sure that when we pass a negative
    number into the `deposit` method, we get a `ValueError`. I’ll leave this one for
    you to practice with. The full working code is in the repository code for this
    chapter.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下只有一个测试：我们需要确保当我们向`deposit`方法传入负数时，会得到`ValueError`。我将这个留给你练习。完整的代码在章节代码库中。
- en: Generating tests automatically
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动生成测试
- en: 'So far, we’ve spent some time writing the `BankAccout` class, but think back
    to our original idea for a use case for unit testing: a financial transaction.
    This time, we’re going to write some code that needs to be tested, but instead
    of a generic test template, we’re going to generate a more exact test.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经花了一些时间编写`BankAccout`类，但回想一下我们最初为单元测试编写的用例：一个金融交易。这次，我们将编写一些需要测试的代码，但我们将生成一个更精确的测试，而不是通用的测试模板。
- en: 'Let’s start with the code we will be testing. Create a new file in your project
    called `transaction.py`. The contents of this file should look as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将要测试的代码开始。在你的项目中创建一个名为`transaction.py`的新文件。这个文件的 内容应该如下所示：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We’ll need the `BankAccount` class since the whole idea is to write code that
    transfers money from one account to another in response to the sale of an item.
    Speaking of *item*, let’s make a class to represent what we’ll be buying:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`BankAccount`类，因为整个想法是编写代码，在物品销售时从一个账户转移到另一个账户。说到*物品*，让我们创建一个类来表示我们将要购买的东西：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There’s nothing too crazy here – just two instance variables called `name`
    and `price`. Now for the hard part: we need a class to represent a transaction.
    Remember, a transaction is an atomic operation. All the steps should be completed.
    If there are any errors along the way, everything that happened before the error
    needs to be rolled back:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么太疯狂的东西——只是两个实例变量`name`和`price`。现在到了困难的部分：我们需要一个类来表示交易。记住，交易是一个原子操作。所有步骤都应该完成。如果在过程中出现任何错误，之前发生的一切都需要回滚：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We started the class with a constructor that initializes two bank accounts
    and an item. After this comes the logic for the transaction itself:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用构造函数开始这个类，它初始化两个银行账户和一个项目。然后是交易本身的逻辑：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We need to store the original balances. If anything goes awry, we’ll need this
    information to put everything back the way it was. Next comes the part where money
    changes hands. I’ll wrap it in a `try`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要存储原始余额。如果出现任何问题，我们需要这些信息来将一切恢复原状。接下来是金钱交换的部分。我将用`try`来封装：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We attempt to withdraw money from the buyer’s account, then deposit the same
    amount into the seller’s account. If a `ValueError` is thrown, we put all the
    money back by restoring the balances to their original values. Once the money
    has been restored, we should still raise an error so that the primary application
    knows the error occurred. This function will need to report the result to a user
    interface to let the user know what happened with the transaction. The last line
    handles this for us. In a real application, you might want to create your own
    custom error that might yield more information, but this one serves us well for
    demonstrative purposes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试从买家的账户中取款，然后将相同金额存入卖家的账户。如果抛出`ValueError`异常，我们将通过恢复余额到原始值将所有钱款退回。一旦钱款被恢复，我们仍然应该抛出一个错误，以便主应用程序知道错误发生了。这个函数需要向用户界面报告结果，让用户知道交易发生了什么。最后一行为我们处理了这一点。在实际应用中，你可能想创建自己的自定义错误，以便提供更多信息，但这个错误对于演示目的来说已经足够好了。
- en: Generating the transaction test
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成交易测试
- en: 'Earlier, we created a new test using the `class Transaction`. Then, click the
    **Generate…** menu option, as seen in *Figure 6**.4*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用`class Transaction`创建了一个新的测试。然后，点击*图6.4*中所示的**“生成…”**菜单选项：
- en: '![Figure 6.4: The Generate… menu item can be found when you right-click your
    class definition](img/B19644_Figure_6.04.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4：当你右键单击类定义时，可以找到“生成…”菜单项](img/B19644_Figure_6.04.jpg)'
- en: 'Figure 6.4: The Generate… menu item can be found when you right-click your
    class definition'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：当你右键单击类定义时，可以找到“生成…”菜单项
- en: 'Next, click **Test…**, as seen in *Figure 6**.5*:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击*图6.5*中所示**“测试…”**：
- en: '![Figure 6.5: Click the Test… button to generate your test](img/B19644_Figure_6.05.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5：点击“测试…”按钮以生成测试](img/B19644_Figure_6.05.jpg)'
- en: 'Figure 6.5: Click the Test… button to generate your test'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：点击“测试…”按钮以生成测试
- en: 'At this point, a dialog box will appear where you can control the test that
    will be generated, as seen in *Figure 6**.6*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，将弹出一个对话框，你可以控制将要生成的测试，如*图6.6*所示：
- en: '![Figure 6.6: PyCharm is about to generate a unit test file based on these
    settings](img/B19644_Figure_6.06.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6：PyCharm将根据这些设置生成一个单元测试文件](img/B19644_Figure_6.06.jpg)'
- en: 'Figure 6.6: PyCharm is about to generate a unit test file based on these settings'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：PyCharm将根据这些设置生成一个单元测试文件
- en: PyCharm is about to create a file called `test_transaction.py`. Within that
    file, instead of a generic test class name, there will be a class definition called
    `TestTransaction`. Finally, within the file, assuming you leave the checkbox ticked,
    a test method stub will be generated called `test_do_transaction`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm将创建一个名为`test_transaction.py`的文件。在该文件中，将不会有一个通用的测试类名，而将有一个名为`TestTransaction`的类定义。最后，在文件中，假设你勾选了复选框，将生成一个名为`test_do_transaction`的测试方法占位符。
- en: 'The resulting file contains this code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文件包含以下代码：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Way back in [*Chapter 1*](B19644_01.xhtml#_idTextAnchor014), I told you that
    one of the benefits of an IDE is that it can reduce boilerplate. The first time,
    PyCharm generated some generic boilerplate for us. At least we didn’t have to
    type it in, but it was almost as much effort to change what it generated. This
    time, there is even less work to do. If I had many methods in my class, there
    would be a correctly named stub for each of them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B19644_01.xhtml#_idTextAnchor014)中，我告诉过你们，IDE的一个好处是可以减少样板代码。第一次，PyCharm为我们生成了一些通用的样板代码。至少我们不必手动输入，但修改它所生成的内容也需要相当多的努力。这次，我们甚至有更少的工作要做。如果我的类中有许多方法，将为每个方法生成一个正确命名的占位符。
- en: All I must do now is write the code that makes the `test_do_transaction` method
    pass. Behold!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在必须编写使`test_do_transaction`方法通过的代码。看吧！
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We started with the required imports. I know I’m going to need two tests, rather
    than just the one PyCharm generated. PyCharm generated one test method, which
    I’m using for the no-fault path. I’ll pass in something that works the way the
    method is intended to work. Since I know I have two tests, I can reuse the seller
    account to keep my test **DRY**. If you’re not familiar with the acronym, it stands
    for **Don’t Repeat Yourself**. By hoisting this code to the top of the file, I
    only need to type it once. This code will initialize a seller’s bank account with
    a balance of $4,000\. It also sets up the item we will be purchasing, which will
    not change between tests:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从必要的导入开始。我知道我需要两个测试，而不仅仅是PyCharm生成的那个。PyCharm生成了一个测试方法，我正在用它来测试无故障路径。我将传入一些按预期工作的事物。既然我知道我有两个测试，我可以重用卖家账户来保持测试的**DRY**。如果你不熟悉这个缩写，它代表**不要重复自己**。通过将此代码提升到文件顶部，我只需要输入一次。这段代码将初始化一个卖家银行账户，余额为$4,000。它还设置了我们将要购买的物品，这些在测试之间不会改变：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we will move on to the test class itself, which was generated for us.
    We already have this part:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续进行测试类本身，这个类是为我们生成的。我们已经有这部分内容了：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'I’m replacing the generated `self.fail()` with code that I hope will cause
    the test to pass:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在用我希望能使测试通过的自定义代码替换生成的`self.fail()`：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As usual, I instantiate the classes I’ll be using in the test. So far, I’ve
    made two accounts and an item with a price. Next, I’ll run the method under test:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我在测试中实例化了将要使用的类。到目前为止，我已经创建了两个账户和一个带有价格的物品。接下来，我将运行测试方法：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, I’ll check my results:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我会检查我的结果：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You might be tempted to get fancy with the test code. Be careful with this.
    Fancy test code is as likely to break as the purposefully fancy code it is meant
    to test. If you are testing complicated math, please don’t duplicate the calculation
    in the test and then compare it to the code under test. You should be plugging
    in known inputs and checking for known outputs. Nothing more!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想用花哨的测试代码。小心这个。花哨的测试代码和它打算测试的花哨代码一样容易出错。如果你正在测试复杂的数学，请不要在测试中重复计算，然后将其与被测试的代码进行比较。你应该输入已知输入并检查已知输出。仅此而已！
- en: 'This test represents the no-fault path. I fully expect this to pass since this
    exercise merely entails everything working under ideal conditions. Let’s see if
    I’m right. Click any of the green run buttons. My result is shown in *Figure 6**.7*:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试代表了无故障路径。我完全期待它会通过，因为这个练习仅仅是在理想条件下工作的所有事情。让我们看看我是否正确。点击任何一个绿色的运行按钮。我的结果在*图6**.7*中显示：
- en: '![Figure 6.7: So far, so good! My test is passing!](img/B19644_Figure_6.07.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7：到目前为止，一切顺利！我的测试通过了！](img/B19644_Figure_6.07.jpg)'
- en: 'Figure 6.7: So far, so good! My test is passing!'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：到目前为止，一切顺利！我的测试通过了！
- en: We need a test for at least one fault path. In this case, it will be to test
    what happens when I don’t have enough in my account to cover buying a book.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要至少一个故障路径的测试。在这种情况下，我们将测试当我账户中的余额不足以购买一本书时会发生什么。
- en: 'Here’s my test for that case:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我针对该情况的测试：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When I left for work today, I had at least $9,000 in my account. But my daughter
    Phoebe “borrowed” my card out of my jacket pocket. She said she was going to create
    a robotic bicycle factory. I thought nothing of it. She was kidding, right? So,
    I go to the bookstore after work, intent on picking up the latest masterpiece:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我今天离开去上班时，我的账户中至少有$9,000。但我的女儿菲比从我的夹克口袋里“借”了我的卡。她说她要创建一个机器人自行车工厂。我没有在意。她在开玩笑，对吧？所以，我下班后去书店，打算买最新的杰作：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The transaction occurs. Do you know that sound that Pac-Man makes when he gets
    eaten by a ghost? I’m making that sound now. The sale will fail; let’s see if
    the transaction rolls back correctly:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 交易发生了。你知道当Pac-Man被幽灵吃掉时发出的声音吗？我现在就在模仿这个声音。这次销售将失败；让我们看看交易是否能够正确回滚：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This last piece of code verifies that both the buyer and seller balances are
    returned to their original values. Run the tests – they should both pass! See
    *Figure 6**.8* for my triumphant test run. I can’t wait to go home and relax!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这段最后的代码验证了买家和卖家的余额都回到了原始值。运行测试——它们都应该通过！见*图6**.8*查看我胜利的测试运行。我迫不及待地想回家放松！
- en: '![Figure 6.8: I’d better call my wife and tell her to keep dinner warm for
    me](img/B19644_Figure_6.08.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8：我最好给我的妻子打电话，让她为我热饭](img/B19644_Figure_6.08.jpg)'
- en: 'Figure 6.8: I’d better call my wife and tell her to keep dinner warm for me'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：我最好给我的妻子打电话，让她为我热饭
- en: It looks like I was a little overconfident. The output window shows a set of
    stack traces for everything that went wrong. It’s so long that I had to scroll
    down quite a bit to get to the good part of this screenshot. In the trace (which
    is not shown), I can see that a few of the errors I thought would be thrown were,
    and that’s fine. The two we can see here are not. First, I intended to verify
    that the message coming from the exception matched the value I assigned in the
    definition. Again, I’m doing this to make sure the error I threw is the one we’re
    seeing and not some other error resulting from a mistake. It looks like I didn’t
    understand the structure of the error, and in fact, there is no attribute called
    message. I coulda swore! Wait – that’s probably from some other language. OK,
    I can look that up.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我有点过于自信了。输出窗口显示了一组所有出错的堆栈跟踪。它太长了，我不得不向下滚动很多才能到达这个截图的好部分。在跟踪（此处未显示）中，我可以看到一些我以为会抛出的错误确实发生了，这很好。我们在这里可以看到的两个不是。首先，我打算验证异常传来的消息是否与我定义中指定的值匹配。再次，我这样做是为了确保我抛出的错误是我们看到的错误，而不是由于错误导致的其他错误。看起来我没有理解错误的结构，实际上，没有名为message的属性。我发誓！等等——那可能来自其他语言。好吧，我可以查一下。
- en: 'The other, more disturbing error is that my transaction didn’t roll back! As
    you look at the trace, you’ll see that there are hyperlinks throughout that allow
    you to navigate directly to the fault code mentioned in the trace. It is very
    easy to move around and look for problems. I can find the line for the first problem
    in the list of stack traces, as shown in *Figure 6**.9*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个更令人不安的错误是我的事务没有回滚！当你查看跟踪信息时，你会看到其中包含超链接，允许你直接导航到跟踪中提到的错误代码。移动和查找问题非常容易。我可以在堆栈跟踪列表中找到第一个问题的行，如图*图6.9*所示：
- en: '![Figure 6.9: The stack traces are riddled with hyperlinks that will jump you
    to the offending section of your code](img/B19644_Figure_6.09.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9：堆栈跟踪中充满了超链接，可以直接跳转到代码中的问题部分](img/B19644_Figure_6.09.jpg)'
- en: 'Figure 6.9: The stack traces are riddled with hyperlinks that will jump you
    to the offending section of your code'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：堆栈跟踪中充满了超链接，可以直接跳转到代码中的问题部分
- en: 'Clicking this link takes me to the problematic code shown in *Figure 6**.10*:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 点击这个链接会带我去*图6.10*中显示的问题代码：
- en: '![Figure 6.10: Fiddlesticks! The IDE even told me line 34 was wrong, but I
    didn’t listen](img/B19644_Figure_6.10.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图6.10：哎呀！IDE甚至告诉我第34行是错误的，但我没有听](img/B19644_Figure_6.10.jpg)'
- en: 'Figure 6.10: Fiddlesticks! The IDE even told me line 34 was wrong, but I didn’t
    listen'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：哎呀！IDE甚至告诉我第34行是错误的，但我没有听
- en: 'I have a few options here, don’t I? I could use the documentation features
    in PyCharm by hovering over the `e` variable. We talked about automatic documentation
    features in [*Chapter 4*](B19644_04.xhtml#_idTextAnchor077). *Figure 6**.11* shows
    what this looks like in case you’ve been skipping around:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我有几个选择，不是吗？我可以通过悬停在`e`变量上使用PyCharm的文档功能。我们在[*第4章*](B19644_04.xhtml#_idTextAnchor077)中讨论了自动文档功能。*图6.11*显示了如果你一直在跳来跳去，这会是什么样子：
- en: '![Figure 6.11: The auto-documentation feature will give me a link to the official
    documentation](img/B19644_Figure_6.11.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图6.11：自动文档功能将给我一个链接到官方文档](img/B19644_Figure_6.11.jpg)'
- en: 'Figure 6.11: The auto-documentation feature will give me a link to the official
    documentation'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：自动文档功能将给我一个链接到官方文档
- en: There’s no easy answer here, is there? Sure, I could click on the link at the
    bottom and go to the Python site and read the documentation. If I do that, though,
    I’ll lose any credibility with you, the reader. Read the manual with y’all watching?
    No chance! I’m sure I’d find the answer but at the expense of my pride.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有简单的答案，对吧？当然，我可以点击底部的链接并访问Python网站阅读文档。不过，如果我那么做，我就会失去你，读者，对我的信任。当你们都在看着的时候阅读手册？不可能！我确信我会找到答案，但代价是我的自尊。
- en: 'I have another idea! I’ve talked about PyCharm’s console before. I’d like to
    try something out. Check out *Figure 6**.12*:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我还有一个想法！我之前谈过PyCharm的控制台。我想试试。看看*图6.12*：
- en: '![Figure 6.12: If the PyCharm Console button (2) isn’t on your toolbar, click
    the ellipses (1) to turn it on](img/B19644_Figure_6.12.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图6.12：如果PyCharm控制台按钮（2）不在你的工具栏上，点击省略号（1）来打开它](img/B19644_Figure_6.12.jpg)'
- en: 'Figure 6.12: If the PyCharm Console button (2) isn’t on your toolbar, click
    the ellipses (1) to turn it on'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：如果PyCharm控制台按钮（2）不在你的工具栏上，点击省略号（1）来打开它
- en: 'The arrow pointing to *2* will open the PyCharm console. If you’ve never done
    this, that icon won’t be on the toolbar. You’ll need to click the ellipsis at
    *1* and click the **Python Console** area. This will add it to your toolbar. My
    console session is shown in *Figure 6**.13*:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 指向*2*的箭头将打开PyCharm控制台。如果你从未这样做过，该图标不会在工具栏上。你需要点击*1*处的省略号，然后点击**Python控制台**区域。这将将其添加到你的工具栏中。我的控制台会话如*图6**.13*所示：
- en: '![Figure 6.13: Revisiting the console allows us to do a quick experiment to
    solve our error](img/B19644_Figure_6.13.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图6.13：重新访问控制台允许我们快速实验以解决我们的错误](img/B19644_Figure_6.13.jpg)'
- en: 'Figure 6.13: Revisiting the console allows us to do a quick experiment to solve
    our error'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13：重新访问控制台允许我们快速实验以解决我们的错误
- en: 'In the console, I first hit *Enter* on the first line. I did that for you.
    If I hadn’t, the console would have bunched everything up and it wouldn’t look
    as pretty. Next, I typed the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中，我首先在第一行按了*Enter*键。我为你做了这件事。如果我没有这样做，控制台会把所有东西都挤在一起，看起来不会那么漂亮。接下来，我输入了以下内容：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: I suspect that if I convert the check into a string, I will get the message
    I am looking for. Call it intuition. Or call it “I looked it up with **ChatGPT**
    while your back was turned.” I’m going with intuition.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我怀疑如果我把检查转换为字符串，我会得到我想要的消息。称之为直觉。或者称之为“我背着你用**ChatGPT**查看了。”我选择直觉。
- en: 'If I type in `str(check)`, the Python REPL will evaluate the expression and
    print the result. The idea works. I can correct my code. Line 34 in `test_transaction.py`
    will now be as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我输入`str(check)`，Python交互式解释器将评估表达式并打印结果。这个想法是可行的。我可以纠正我的代码。`test_transaction.py`中的第34行现在将是以下内容：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, if I run the test again, it will fail, as shown in *Figure 6**.14*:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我再次运行测试，它将失败，如*图6**.14*所示：
- en: '![Figure 6.14: Progress can be measured in software development by the rate
    at which the list of errors is reduced](img/B19644_Figure_6.14.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图6.14：软件开发中的进度可以通过错误列表减少的速度来衡量](img/B19644_Figure_6.14.jpg)'
- en: 'Figure 6.14: Progress can be measured in software development by the rate at
    which the list of errors is reduced'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14：软件开发中的进度可以通过错误列表减少的速度来衡量
- en: We expected this. The list of problems got shorter, so it’s a victory! Let’s
    clear out the last problem. The transaction is failing to correctly reset the
    value of the seller’s account after the transaction fails. We could stare at it
    for a while, or we could take a more proactive approach by firing up PyCharm’s
    debugger and stepping through the whole test.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预料到了这一点。问题列表变短了，所以这是一个胜利！让我们清除最后一个问题。交易失败后，事务未能正确重置卖家的账户值。我们可以盯着它看一会儿，或者我们可以通过启动PyCharm的调试器并逐步通过整个测试来采取更积极主动的方法。
- en: Working with PyCharm’s debugger
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PyCharm的调试器
- en: In [*Chapter 1*](B19644_01.xhtml#_idTextAnchor014), I lauded PyCharm’s debugger
    as the single biggest reason to use an IDE versus a command-line debugger such
    as the standard Python debugger, which is called **pdb**. Don’t get me wrong –
    you should learn to use pdb because there will be times when the IDE isn’t available.
    However, I suspect that once you use PyCharm’s, you’ll prefer it over anything
    else. Let’s see if I’m right.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B19644_01.xhtml#_idTextAnchor014)中，我赞扬了PyCharm的调试器是使用IDE而不是像标准Python调试器（称为**pdb**）这样的命令行调试器的最大原因。请别误会——你应该学会使用pdb，因为有时IDE不可用。然而，我怀疑一旦你使用了PyCharm的，你将更喜欢它。让我们看看我是否正确。
- en: 'We have a problem in our `Transaction` class that isn’t quite accurate. When
    it comes to testing, there are always two possibilities:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Transaction`类中有一个问题，并不完全准确。在测试时，总有两种可能性：
- en: The code is failing because of a flaw in the code under test.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码失败是因为待测试代码中的缺陷。
- en: The code is failing because of the test code.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码失败是因为测试代码的问题。
- en: 'Since we don’t know which possibility is correct at this point, the debugger
    is going to allow us to step through our code one line at a time and inspect its
    inner workings. To do this, we need to set a breakpoint. A breakpoint marks a
    spot in your code where you would like to halt its execution and inspect the contents
    of the variables, the stack, and so on. You can create a breakpoint by clicking
    the line number in the gutter within the editor, as shown in *Figure 6**.15*.
    I’m going to add a breakpoint to the beginning of the test so that we can walk
    through it. The test starts on line 25, so I’ll click on that line number; observe
    that the line number has been replaced with a red dot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们目前不知道哪种可能性是正确的，调试器将允许我们逐行执行我们的代码并检查其内部工作原理。为此，我们需要设置一个断点。断点标记了您代码中的一个位置，您希望在此处停止执行并检查变量的内容、堆栈等。您可以通过在编辑器中的空白处点击行号来创建一个断点，如图*图6.15*所示。我将把断点添加到测试的开始处，这样我们就可以逐步执行它。测试从第25行开始，所以我将点击那个行号；观察发现行号已被一个红色圆点所替代：
- en: '![Figure 6.15: Click a line number to create a breakpoint, which will replace
    the number with a red dot](img/B19644_Figure_6.15.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图6.15：点击行号以创建断点，该断点将用红色圆点替换数字](img/B19644_Figure_6.15.jpg)'
- en: 'Figure 6.15: Click a line number to create a breakpoint, which will replace
    the number with a red dot'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15：点击行号以创建断点，该断点将用红色圆点替换数字
- en: 'Next, we need to run the debugger. Click the green arrow in the editor window
    next to the method definition for the `test_transaction_overdraw_fault(self)`
    method. This time, click the **Debug ‘Python tests for tes…’** option, shown in
    *Figure 6**.16*, to run the failed test:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要运行调试器。在编辑器窗口中方法定义`test_transaction_overdraw_fault(self)`旁边点击绿色箭头。这次，点击*图6.16*中显示的**“调试‘Python
    tests for tes…’**选项，以运行失败的测试：
- en: '![Figure 6.16: Clicking the green arrows provides a menu that can be used to
    make variations to a running test, including running the debugger](img/B19644_Figure_6.16.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图6.16：点击绿色箭头提供菜单，可用于对正在运行的测试进行修改，包括运行调试器](img/B19644_Figure_6.16.jpg)'
- en: 'Figure 6.16: Clicking the green arrows provides a menu that can be used to
    make variations to a running test, including running the debugger'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16：点击绿色箭头提供菜单，可用于对正在运行的测试进行修改，包括运行调试器
- en: 'When the debugger is run, the program will start, then stop on line 25 of our
    test. The IDE transformed significantly. Let’s look at *Figure 6**.17*:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当调试器运行时，程序将开始，然后在我们的测试的第25行停止。IDE发生了显著变化。让我们看看*图6.17*：
- en: '![Figure 6.17: The paused debugger in PyCharm](img/B19644_Figure_6.17.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图6.17：PyCharm中的暂停调试器](img/B19644_Figure_6.17.jpg)'
- en: 'Figure 6.17: The paused debugger in PyCharm'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17：PyCharm中的暂停调试器
- en: There are a few things you might notice right away. First, the run buttons at
    the top of the IDE are now green, and the red stop button is illuminated (*1*).
    These are all visual clues showing that something is running, which of course
    we do.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会立即注意到一些事情。首先，IDE顶部的运行按钮现在是绿色的，红色的停止按钮是亮的（*1*）。这些都是视觉线索，表明有东西正在运行，当然我们确实在运行。
- en: The bottom half of the IDE is now taken up by the debugger tools (*2*). There
    is also a tab bar present (*3*), which allows you to run multiple debugging sessions
    at the same time. This can be handy when developing RESTful microservice architectures,
    which we’ll talk about in several of the upcoming chapters, most notably in *Chapter
    9*, *Creating a RESTful API* *with FastAPI*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: IDE的下半部分现在被调试工具（*2*）占据。还有一个标签栏（*3*），允许您同时运行多个调试会话。这在开发RESTful微服务架构时很有用，我们将在接下来的几章中讨论这一点，特别是在*第9章*，*使用FastAPI创建RESTful
    API*。
- en: There is a list of threads on the right-hand side (*4*), which allows you to
    switch between and inspect the various threads at play. However, most of the time,
    you’re going to land in the right place and might use this only rarely. The area
    at location *5* shows everything that is currently in scope. Right now, that is
    just `self`, which you can see is an instance of the `TestTransaction` class.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧有一个线程列表（*4*），允许您在各个线程之间切换并检查它们。然而，大多数时候，您会到达正确的位置，可能只会偶尔使用它。位于位置*5*的区域显示了当前作用域内的所有内容。目前，那只是`self`，您可以看到它是`TestTransaction`类的一个实例。
- en: '*6* shows two tabs that allow you to switch between the view we’re seeing right
    now, which allows you to inspect the state of the program at area *5*. If you
    switch this tab to `print` statements will appear so that you can review the output
    as the program runs.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*6*显示了两个标签，允许您在我们现在看到的视图之间切换，这允许您在*5*区域检查程序的状态。如果您切换此标签，将显示`print`语句，以便您可以在程序运行时查看输出。'
- en: The toolbar marked with *7* houses a set of very useful tools, while the expression
    window (*8*) allows you to add a watch or evaluate an expression using whatever
    is currently in scope.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为*7*的工具栏包含一组非常实用的工具，而表达式窗口(*8*)允许您使用当前作用域内的任何内容添加一个监视器或评估一个表达式。
- en: 'The most useful parts of the debugging window are the inspection area (*5*),
    the tab switch, which you can use to swap between the variable and thread inspector
    and console output (*6*), and the debugging toolbar (*7*). Let’s take a closer
    look at the debugging toolbar:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 调试窗口最有用的部分是检查区域(*5*)，标签切换，您可以使用它来在变量检查器和线程检查器以及控制台输出(*6*)之间切换，以及调试工具栏(*7*)。让我们更仔细地看看调试工具栏：
- en: '![Figure 6.18: The debugging toolbar in PyCharm](img/B19644_Figure_6.18.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图6.18：PyCharm中的调试工具栏](img/B19644_Figure_6.18.jpg)'
- en: 'Figure 6.18: The debugging toolbar in PyCharm'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18：PyCharm中的调试工具栏
- en: 'I’ve numbered each button. Let’s review them:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为每个按钮编号。让我们回顾一下：
- en: This button restarts the debugging run. You can find a duplicate restart button
    at the top of the IDE window near the run button.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此按钮重新启动调试运行。您可以在IDE窗口顶部靠近运行按钮的位置找到重复的重新启动按钮。
- en: This button stops the debugging run. You can find a duplicate stop button at
    the top of the IDE window near the restart button.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此按钮停止调试运行。您可以在IDE窗口顶部靠近重新启动按钮的位置找到重复的停止按钮。
- en: This is the **Continue** button. The debugger will stop at any breakpoint it
    hits and wait until you use one of the step buttons (*5* – *8*) or you hit this
    button to continue the run.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是**Continue**按钮。调试器将在遇到任何断点时停止，并等待您使用(*5* – *8*)中的一个步骤按钮或您点击此按钮以继续运行。
- en: The **Pause** button will pause the run. This can be useful if you’re running
    a loop or an algorithm that takes a while and you want to pause the run.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Pause**按钮将暂停运行。如果您正在运行一个循环或需要一段时间才能完成的算法，并且想要暂停运行，这可能会很有用。'
- en: The **Step Over** button will execute the current line where the debugger has
    paused. If that line is a function call to a function in your program, the function
    will execute normally and return, after which you’ll be taken to the next line
    of your code, where the debugger will remain paused. Here, you’re stepping over
    the execution of the next line.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Step Over**按钮将执行调试器暂停的当前行。如果该行是调用您程序中函数的函数调用，该函数将正常执行并返回，之后您将转到代码的下一行，调试器将保持暂停。在这里，您正在跳过下一行的执行。'
- en: In contrast, this is the **Step Into** button. If your debugger has paused on
    a line containing a function call, clicking this button will allow you to step
    into that function and step through as if you had placed a breakpoint at the beginning
    of the function. **Step Over** skips past this execution, while this button steps
    into it.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相反，这是**Step Into**按钮。如果您的调试器暂停在包含函数调用的行上，点击此按钮将允许您进入该函数并像在函数开始处放置断点一样逐步执行。**Step
    Over**跳过此执行，而此按钮进入它。
- en: '**Step Into My Code** is a game changer! This button is just like the **Step
    Into** button (*6*), except this one will not step into code that you didn’t create.
    By that, I mean the **Step Into** button will happily step you into the bowels
    of your third-party library code, or into the code comprising Python itself. This
    is rarely useful. The **Step Into My Code** button will only step into code that
    is part of your project.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Step Into My Code**是一个变革性的功能！这个按钮就像**Step Into**按钮(*6*)一样，只不过这个按钮不会进入您未创建的代码。我的意思是，**Step
    Into**按钮会高兴地让您进入第三方库代码的深处，或者进入构成Python本身的代码。这很少有用。**Step Into My Code**按钮只会进入您项目的一部分代码。'
- en: This is the **Step Out** button. If you find yourself stepping into some code
    that clearly isn’t a problem, or maybe you’ve taken into library code you didn’t
    create, the step-out code will jump you back out to the point where you entered.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是**Step Out**按钮。如果您发现自己进入了一些显然不是问题的代码，或者您可能已经进入了您未创建的库代码，退出代码将带您回到进入的点。
- en: Attention Visual Studio users
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Visual Studio用户
- en: The buttons in the PyCharm debugger work differently than they do in Visual
    Studio! This took some getting used to for me. In Visual Studio, you can click
    the green button on the top toolbar to start the debugging session. When you hit
    a breakpoint, you can hit the same button to continue. In PyCharm, the continue
    button is in the debugging toolbar, in area *3* in *Figure 6**.18*. If you were
    to click the same button you used to launch the debugger, you would launch a second
    debug session. PyCharm will generally complain when you do this unless you’ve
    checked the box in the run configuration that allows multiple runs at the same
    time.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 调试器中的按钮与 Visual Studio 中的按钮工作方式不同！这对我来说需要一些适应。在 Visual Studio 中，你可以点击顶部工具栏上的绿色按钮来开始调试会话。当你遇到断点时，你可以点击相同的按钮来继续。在
    PyCharm 中，继续按钮位于调试工具栏中，*图 6**.18* 中的区域 *3*。如果你点击用于启动调试器的相同按钮，你会启动第二个调试会话。除非你在运行配置中勾选了允许同时运行多个的复选框，否则
    PyCharm 通常会对此表示不满。
- en: Using the debugger to find and fix our test problem
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用调试器查找和修复我们的测试问题
- en: Our unit test revealed a problem in our code. When our transaction fails due
    to an overdraft error, we expect the balances of our buyer and seller to revert
    to their original values. At this point, the seller is getting $39.95 in credit
    following a failed transaction. Let’s use the debugger to step through and see
    if we can figure out why this is happening.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单元测试揭示了代码中的问题。当我们的交易由于透支错误失败时，我们期望买方和卖方的余额恢复到原始值。在这个时候，卖家在交易失败后获得了 $39.95
    的信用。让我们使用调试器逐步执行并看看我们是否能找出这是为什么。
- en: 'Per *Figure 6**.19*, we’ve started the debugger on our unit test and we’ve
    stopped at line 25 in `test_transaction.py`. At this stage, nothing in the test
    method has run. When you’re looking at a highlighted line in PyCharm’s debugger,
    you need to remember that the highlighted line has not been executed yet. To execute
    the line, click the `buyer_account` has been instantiated, and our highlight will
    move to and stop on line 26, as shown in *Figure 6**.19*:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 *图 6**.19*，我们已经启动了我们的单元测试的调试器，并且已经停止在 `test_transaction.py` 中的第 25 行。在这个阶段，测试方法中的任何内容都没有运行。当你正在查看
    PyCharm 调试器中的高亮行时，你需要记住，高亮行尚未执行。要执行该行，请点击 `buyer_account` 已经实例化，并且我们的高亮将移动并停止在
    *图 6**.19* 中显示的第 26 行：
- en: '![Figure 6.19: Having clicked the Step Over button, the debugger has been stopped
    on line 26](img/B19644_Figure_6.19.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.19：点击了“单步执行”按钮，调试器已停止在第 26 行](img/B19644_Figure_6.19.jpg)'
- en: 'Figure 6.19: Having clicked the Step Over button, the debugger has been stopped
    on line 26'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.19：点击了“单步执行”按钮后，调试器已停止在第 26 行
- en: To see the content of the objects, you’ll need to twirl open the caret, which
    I’ve circled in *Figure 6**.19*. You can see that `buyer_account` has a balance
    of $5\. However, what we’re interested in here is the seller account since that’s
    where the problem lies.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看对象的内容，你需要展开箭头，我在 *图 6**.19* 中用圆圈标出。你可以看到 `buyer_account` 的余额为 $5\. 然而，我们这里感兴趣的是卖家账户，因为问题就出在这里。
- en: Click line 30 to add a breakpoint there, then click the `do_transaction()` method
    to watch it execute. Click the **Step Into My Code** button. Refer to *Figure
    6**.18* and look at *7* if you don’t remember which button I mean.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 点击第 30 行以在那里添加断点，然后点击 `do_transaction()` 方法来监视其执行。点击 **进入我的代码** 按钮。如果你不记得是哪个按钮，请参考
    *图 6**.18* 并查看 *7*。
- en: 'This will take us to line 17 in `transaction.py`. Step over lines 17 and 18
    to arrive at line 19 and inspect our state. You’ll see the problem, which is shown
    in *Figure 6**.20*:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带我们到 `transaction.py` 中的第 17 行。单步执行第 17 和 18 行，到达第 19 行并检查我们的状态。你会看到问题，如 *图
    6**.20* 所示：
- en: '![Figure 6.20: The debugger reveals that the starting value of the seller balance
    is wrong](img/B19644_Figure_6.20.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.20：调试器显示卖家余额的起始值错误](img/B19644_Figure_6.20.jpg)'
- en: 'Figure 6.20: The debugger reveals that the starting value of the seller balance
    is wrong'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.20：调试器显示卖家余额的起始值错误
- en: The debugger reveals that the original seller balance is $4,039.95, where we
    would expect it to be $4,000\. You can see this value in two places. The variables
    window shows it to us (*1*), but you can also hover over any in-scope variable
    in the editor window (*2*) and see its value.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器显示原始卖家余额为 $4,039.95，而我们预期它应该是 $4,000\. 你可以在两个地方看到这个值。变量窗口显示给我们 (*1*)，但你也可以在编辑器窗口中悬停在任何作用域变量上
    (*2*) 来查看其值。
- en: 'Now, why would our starting balance be wrong? It’s a scope problem! Since I
    hoisted the `seller_account` variable to line 5 in `test_transaction.py` up to
    a global, the first test successfully changes the balance to $4,039.95 just like
    it should. Since it is global, that number remains. To fix this, we need to reset
    the balance of the seller account at the beginning of the `test_transaction_overdraw_fault(self)`
    method. We started our debugging efforts on line 25\. Let’s just make our change
    there. Click the stop button on the debugger toolbar, then add this line on line
    25:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为什么我们的起始余额会是错误的呢？这是一个作用域问题！由于我在`test_transaction.py`的第5行将`seller_account`变量提升到全局，第一个测试成功地将余额更改为$4,039.95，就像它应该做的那样。由于它是全局的，这个数字就保留了下来。为了修复这个问题，我们需要在`test_transaction_overdraw_fault(self)`方法的开始处重置卖家账户的余额。我们开始调试工作是在第25行。让我们就在那里做我们的更改。点击调试工具栏上的停止按钮，然后在第25行添加以下代码：
- en: '[PRE29]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Rerun your tests without debugging. Be bold! Assume it worked! If you’re not
    following along, kindly move to the edge of your seat and begin biting your nails
    nervously. Will our hero triumph in *Figure 6**.21*? Cue organ music: duhn duhn
    duuuuuhn!'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 不带调试重新运行测试。大胆一点！假设它成功了！如果您没有跟上，请礼貌地移到座位边缘，开始紧张地咬指甲。我们的英雄在*图6**.21*中会取得胜利吗？提示管弦乐：duhn
    duhn duuuuuhn！
- en: '![Figure 6.21: Victory!](img/B19644_Figure_6.21.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图6.21：胜利！](img/B19644_Figure_6.21.jpg)'
- en: 'Figure 6.21: Victory!'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21：胜利！
- en: It works! Now, it’s time to head home and heat up dinner since we’ve restored
    everyone’s faith in the international banking industry.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 它成功了！现在，是时候回家加热晚餐了，因为我们已经恢复了人们对国际银行业的信心。
- en: Checking test coverage
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查测试覆盖率
- en: Unit tests are most effective when there are tests to cover every class, method,
    function, or module in your program. As your software code grows, it is easy to
    forget to write tests or maybe to put them off until you have more time. PyCharm
    has a tool that can tell you what your test coverage is and helps you find unexploited
    opportunities for testing more of your work than you might have on your own.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试在覆盖程序中的每个类、方法、函数或模块时最为有效。随着软件代码的增长，很容易忘记编写测试，或者可能推迟到有更多时间再进行。PyCharm有一个工具可以告诉您测试覆盖率是多少，并帮助您找到测试更多工作的未开发机会，这可能比您自己能想到的还要多。
- en: 'To check your test coverage, you just need to run your tests a little bit differently.
    We’ve been running our tests individually from within the test files. We need
    to run all the tests together so that we can have a comprehensive report of where
    we are missing coverage. For this, we will make a new run configuration. Click
    the run configurations dropdown on the toolbar and click `unittest` template.
    Make sure you use my settings, as shown in *Figure 6**.22*:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查测试覆盖率，您只需稍微改变一下运行测试的方式。我们一直是在测试文件内部单独运行测试。我们需要一起运行所有测试，以便我们可以有一个全面的报告，显示我们在哪些地方缺少覆盖率。为此，我们将创建一个新的运行配置。点击工具栏上的运行配置下拉菜单，然后点击`unittest`模板。请确保您使用的是我的设置，如*图6**.22*所示：
- en: '![Figure 6.22: Create a run configuration that runs all your tests at once](img/B19644_Figure_6.22.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图6.22：创建一个一次性运行所有测试的运行配置](img/B19644_Figure_6.22.jpg)'
- en: 'Figure 6.22: Create a run configuration that runs all your tests at once'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.22：创建一个一次性运行所有测试的运行配置
- en: For the script path, enter the folder where your tests are located. Set the
    pattern to `*_test.py`. This will make the test runner find all files that end
    with `_test.py`, which is different from the defaults. The defaults will look
    for files beginning with “test.” I don’t particularly like this because it bunches
    all the tests together in the project file window instead of putting the test
    right next to the file it is testing.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于脚本路径，请输入存放测试的文件夹。设置模式为`*_test.py`。这将使测试运行器找到所有以`_test.py`结尾的文件，这与默认设置不同。默认设置将查找以“test.”开头的文件。我不太喜欢这种做法，因为它会将所有测试都堆放在项目文件窗口中，而不是将测试放在被测试文件旁边。
- en: 'By setting the pattern and setting the test runner to a folder rather than
    a single file, the runner will find all files matching the pattern and run them
    as tests. Speaking of running, you can do that by clicking the ellipsis next to
    the run and debug buttons. See *Figure 6**.23* to locate the **Run ‘All Tests’**
    **with Coverage** menu item:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置模式和将测试运行器设置为文件夹而不是单个文件，运行器将找到所有符合模式的文件并将它们作为测试运行。说到运行，您可以通过点击运行和调试按钮旁边的省略号来完成。参见*图6**.23*以定位**运行‘所有测试’****带有覆盖率**菜单项：
- en: '![Figure 6.23: Run ‘All Tests’ with Coverage allows you to run your tests and
    find out how much of your application isn’t covered by unit tests](img/B19644_Figure_6.23.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图6.23：使用“运行所有测试”并启用覆盖率可以让你运行测试并找出你的应用程序中有多少部分没有被单元测试覆盖](img/B19644_Figure_6.23.jpg)'
- en: 'Figure 6.23: Run ‘All Tests’ with Coverage allows you to run your tests and
    find out how much of your application isn’t covered by unit tests'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.23：使用“运行所有测试”并启用覆盖率可以让你运行测试并找出你的应用程序中有多少部分没有被单元测试覆盖
- en: 'The first time you do this, you’ll likely see an error message – not from your
    code, but from PyCharm. See *Figure 6**.24* to see what I mean:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次这样做时，你可能会看到一个错误消息——不是来自你的代码，而是来自PyCharm。见图6.24以了解我的意思：
- en: '![Figure 6.24: The first time you run test coverage, you’ll be warned if you
    haven’t installed the coverage software or enabled the bundled copy](img/B19644_Figure_6.24.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图6.24：第一次运行测试覆盖率时，如果你还没有安装覆盖率软件或启用捆绑版本，你会收到警告](img/B19644_Figure_6.24.jpg)'
- en: 'Figure 6.24: The first time you run test coverage, you’ll be warned if you
    haven’t installed the coverage software or enabled the bundled copy'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.24：第一次运行测试覆盖率时，如果你还没有安装覆盖率软件或启用捆绑版本，你会收到警告
- en: 'Running with coverage requires some software, `coverage.py`, which we haven’t
    installed. You have two options here: you can either add `coverage.py` to your
    project, or you can use the bundled version that ships with PyCharm. I prefer
    using the bundled version. You can click the word *enable* in the error message,
    which is displayed as a blue hyperlink, and PyCharm will turn on this setting
    for you. If you’d like to manage this setting yourself, see *Figure 6**.25* to
    see where the setting can be found:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用覆盖率运行需要一些软件，即`coverage.py`，我们还没有安装。这里你有两个选择：你可以将`coverage.py`添加到你的项目中，或者你可以使用与PyCharm捆绑的版本。我更喜欢使用捆绑版本。你可以点击错误消息中的单词“启用”，它显示为一个蓝色超链接，PyCharm会为你打开这个设置。如果你想自己管理这个设置，请参阅图6.25以查看设置在哪里：
- en: '![Figure 6.25: The setting for using the bundled coverage.py file allows you
    to use coverage.py without you having to add it to your project](img/B19644_Figure_6.25.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图6.25：使用捆绑的coverage.py文件的设置允许你使用coverage.py而无需将其添加到你的项目中](img/B19644_Figure_6.25.jpg)'
- en: 'Figure 6.25: The setting for using the bundled coverage.py file allows you
    to use coverage.py without you having to add it to your project'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.25：使用捆绑的coverage.py文件的设置允许你使用coverage.py而无需将其添加到你的项目中
- en: 'With `coverage.py` enabled, rerun your coverage test. Let’s see how we do:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 启用`coverage.py`后，重新运行覆盖率测试。让我们看看我们做得怎么样：
- en: '![Figure 6.26: I wish my grades in college were this good!](img/B19644_Figure_6.26.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图6.26：我希望我在大学时的成绩能这么好！](img/B19644_Figure_6.26.jpg)'
- en: 'Figure 6.26: I wish my grades in college were this good!'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.26：我希望我在大学时的成绩能这么好！
- en: 'Holy smokes! We have 100% coverage in the transaction tests, but a miserable
    failure in the `bank_account_test.py` file – that is, if you consider 94% coverage
    a failure. Being a perfectionist, I would like to see how I missed those points.
    I can double-click the line showing the 94% in `bank_account_test.py` and I’ll
    be treated to a color-coded gutter. Here, again, I must apologize for the book
    being printed in black and white. Area *1* in *Figure 6**.26* is colored red.
    These are the lines that are not covered by the tests. To be truthful, I don’t
    remember typing these in. I don’t need them since my test runner is executing
    my tests for me. I can simply remove these lines and re-format my file with *Ctrl*
    + *Alt* + *L*/*Cmd* + *Opt* + *L*. Rerun the test with coverage. My results in
    *Figure 6**.27* show that we’re close:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 天哪！交易测试中我们实现了100%的覆盖率，但在`bank_account_test.py`文件中却惨不忍睹——如果你认为94%的覆盖率算失败的话。作为一个完美主义者，我想看看我是如何错过这些点的。我可以通过双击显示`bank_account_test.py`中94%的行来查看，我会看到一个彩色编码的侧边栏。在这里，我再次为这本书是黑白印刷表示歉意。图6.26中的区域*1*被涂成了红色。这些是测试未覆盖的行。说实话，我不记得我输入过这些。我不需要它们，因为我的测试运行器会为我执行测试。我可以简单地删除这些行，并用*Ctrl*
    + *Alt* + *L*/*Cmd* + *Opt* + *L*重新格式化我的文件。重新运行带有覆盖率的测试。图6.27中的结果显示我们接近了：
- en: '![Figure 6.27: We have achieved 100% coverage! Keep this up and you might get
    a raise](img/B19644_Figure_6.27.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图6.27：我们已经实现了100%的覆盖率！继续保持，你可能会得到加薪](img/B19644_Figure_6.27.jpg)'
- en: 'Figure 6.27: We have achieved 100% coverage! Keep this up and you might get
    a raise'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.27：我们已经实现了100%的覆盖率！继续保持，你可能会得到加薪
- en: 'The `bank_account_test.py` file now has 100% coverage, but at the top, I can
    still see that the `bank_account` folder only has 98% coverage. This simply will
    not stand! Right now, I have my project explorer window closed to maximize space
    for the editor and coverage window. If I open it back up, having run with coverage,
    I will get some more information. *Figure 6**.28* shows where we should look.
    The `bank_account.py` file only has 92% coverage. Upon double-clicking to open
    it, I’ll see the lines I’m missing colored red, as seen in *Figure 6**.28*:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`bank_account_test.py`文件现在有100%的覆盖率，但在顶部，我仍然可以看到`bank_account`文件夹只有98%的覆盖率。这绝对不行！目前，我将我的项目资源管理器窗口关闭，以最大化编辑器和覆盖率窗口的空间。如果我重新打开它，在运行了覆盖率之后，我会得到更多信息。*图6**.28*显示了我们应该查看的地方。`bank_account.py`文件只有92%的覆盖率。双击打开它，我会看到我遗漏的行被红色标记，如图*6**.28*所示：'
- en: '![Figure 6.28: The grayish-red area in the gutter indicates that lines 17 and
    18 are not covered by any unit test](img/B19644_Figure_6.28.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图6.28：页边空白处的灰色红色区域表示第17行和第18行没有被任何单元测试覆盖](img/B19644_Figure_6.28.jpg)'
- en: 'Figure 6.28: The grayish-red area in the gutter indicates that lines 17 and
    18 are not covered by any unit test'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.28：页边空白处的灰色红色区域表示第17行和第18行没有被任何单元测试覆盖
- en: It looks like we have another unit test to write. I forgot to write a test for
    the error condition. This is legitimate! As you may recall, I left the deposit
    test as a challenge for you. I wrote it in my code for this book, but I forgot
    to write the error test. Coverage saves the day!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们还需要编写另一个单元测试。我忘记编写错误条件的测试了。这是合法的！如你所回忆，我把存款测试留给你作为一个挑战。我在这本书的代码中编写了它，但忘记编写错误测试。覆盖率救了这一天！
- en: 'Open `bank_account_test.py` and add the following test, which will cover the
    case of trying to deposit a negative number:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`bank_account_test.py`并添加以下测试，该测试将覆盖尝试存入负数的场景：
- en: '[PRE30]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run the test and verify it passes, then rerun the **All Tests** configuration
    with coverage. My result is shown in *Figure 6**.29*:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试并验证其通过，然后重新运行带有覆盖率的**所有测试**配置。我的结果如图*6**.29*所示：
- en: '![Figure 6.29: We have achieved 100% coverage for all files](img/B19644_Figure_6.29.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图6.29：我们已经对所有文件实现了100%的覆盖率](img/B19644_Figure_6.29.jpg)'
- en: 'Figure 6.29: We have achieved 100% coverage for all files'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.29：我们已经对所有文件实现了100%的覆盖率
- en: This time, we should have a perfect score! Now that we’re feeling fine, I’ll
    point out the coverage window on the right-hand side of the screen. It shows a
    list of the results, which we’ve already seen. Note the shield icon in the right
    toolbar. You can show or hide the coverage window by clicking this shield.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们应该得到满分！现在我们感觉很好，我将指出屏幕右侧的覆盖率窗口。它显示了一个结果列表，我们之前已经看到了。注意右侧工具栏中的盾牌图标。你可以通过点击这个盾牌来显示或隐藏覆盖率窗口。
- en: Test coverage output
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试覆盖率输出
- en: 'In addition to the graphical display, PyCharm outputs a report for the coverage
    run. You will see the output mentioned in the output window alongside the usual
    test output. Mine states the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 除了图形显示之外，PyCharm还会为覆盖率运行输出一个报告。你将在输出窗口中看到提到的输出，与通常的测试输出并列。我的输出如下：
- en: '[PRE31]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The XML file is generated by `coverage.py`, which we enabled earlier. As you
    might have guessed, `coverage.py` is a popular Python tool for measuring code
    coverage during test runs. It is an open source tool that helps you identify which
    parts of your Python code are being exercised by your tests and which parts are
    not. The tool works by collecting information about which lines of code are executed
    during a test run and then generating a report that shows the percentage of code
    coverage. The XML output is used by PyCharm to render the color-coded UI displays
    we’ve been using. The XML output can also be used by your `coverage.py` to fail
    a build if test coverage is below a set threshold.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: XML文件是由我们之前启用的`coverage.py`生成的。正如你可能猜到的，`coverage.py`是一个流行的Python工具，用于在测试运行期间测量代码覆盖率。它是一个开源工具，可以帮助你识别你的Python代码哪些部分被测试所执行，哪些部分没有被执行。该工具通过收集测试运行期间代码执行的信息，然后生成一个报告，显示代码覆盖率百分比。XML输出被PyCharm用于渲染我们一直在使用的彩色UI显示。XML输出也可以由你的`coverage.py`使用，如果测试覆盖率低于设定的阈值，则会导致构建失败。
- en: Profiling performance
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析
- en: The first step in creating a great program is getting the program fully working.
    The second step is to perform automated testing to prove that the program works
    as intended. The final step ought to be tweaking the code so that the program
    runs as fast and as efficiently as possible. Poorly performing programs run the
    risk of having a low adoption rate at best, and may simply be unusable at worst.
    In England, the NHS has an algorithm that was designed to match organ transplant
    recipients to recently harvested organs. The algorithm is complicated but extremely
    time-sensitive. Harvested organs must be transplanted quickly; otherwise, their
    tissues will die and become useless. In short, the algorithm must be extremely
    accurate; otherwise, the transplanted organ may be rejected, resulting in the
    patient’s death. It must also be fast since the organ will lose viability, which
    may also result in patient death. Suddenly, I’m very glad for my job dealing with
    hardware system capacity planning and forecasting. Nobody has ever died because
    my database queries were too slow. At least, not that I know of.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个优秀程序的第一步是确保程序完全运行正常。第二步是执行自动化测试以证明程序按预期工作。最后一步应该是调整代码，使程序尽可能快和高效地运行。性能不佳的程序最坏的情况可能是无法使用，最好的情况也可能因为低采用率而无法推广。在英国，NHS有一个算法，旨在将器官移植接受者与最近采集的器官相匹配。该算法复杂但时间敏感。采集的器官必须迅速移植；否则，其组织将死亡并变得无用。简而言之，该算法必须非常准确；否则，移植的器官可能会被拒绝，导致患者死亡。它还必须快速，因为器官将失去活力，这也可能导致患者死亡。突然间，我很高兴我的工作是处理硬件系统容量规划和预测。没有人因为我数据库查询太慢而死亡。至少，据我所知。
- en: In addition to being able to run your tests with coverage, you can also run
    with performance profiling. While the coverage report tells you graphically which
    areas of your code remain untested, PyCharm’s profiler gives you reports on which
    parts of your code are consuming the lion’s share of the overall runtime. This
    allows you to spot bottlenecks so that you can focus your refactoring efforts
    toward making the code, and its execution, more efficient.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够使用覆盖率运行测试外，您还可以使用性能分析运行测试。虽然覆盖率报告以图形方式告诉您哪些代码区域尚未经过测试，但PyCharm的性能分析器会向您报告哪些代码部分消耗了整体运行时间的很大一部分。这使您能够发现瓶颈，从而可以将重构努力集中在使代码及其执行更高效上。
- en: Similar to there being several testing libraries that are widely used by Python
    developers, there is also a variety of profiling tools, including Yappi, cProfile,
    and VMProf. PyCharm supports them all, but they do not work the same. cProfile
    is built into Python, and so is the default profiler. Yappi is an improvement
    over cProfile because it allows you to profile multithreaded applications and
    supports CPU time profiling. VMProf supports statistical sampling. When you profile
    using this tool, it won’t simply time a single run of your program; instead, it
    will run and sample multiple runs, providing you with a more realistic performance
    profile. PyCharm will use VMProf if it is available. If not, it will look for
    Yappi. If it can’t find Yappi, then it will use the cProfile solution built into
    Python. For this book, I will stick to the default cProfile tool.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 与存在多个广泛使用的测试库一样，Python开发者也有各种各样的性能分析工具，包括Yappi、cProfile和VMProf。PyCharm支持它们所有，但它们的工作方式并不相同。cProfile是Python内置的，也是默认的性能分析器。Yappi是cProfile的改进，因为它允许您对多线程应用程序进行性能分析，并支持CPU时间分析。VMProf支持统计抽样。当您使用此工具进行性能分析时，它不会简单地计时您的程序的单次运行；相反，它会运行并抽样多次运行，为您提供更真实的性能分析。如果可用，PyCharm将使用VMProf。如果不可用，它将寻找Yappi。如果找不到Yappi，它将使用Python内置的cProfile解决方案。对于本书，我将坚持使用默认的cProfile工具。
- en: Profiling in PyCharm
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在PyCharm中进行性能分析
- en: 'The code we’ll be profiling can be found in this book’s repository, in the
    `chapter-06` folder. The `profiling.py` file contains the following code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要进行性能分析的代码可以在本书的仓库中找到，位于`chapter-06`文件夹中。`profiling.py`文件包含以下代码：
- en: '[PRE32]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code will compare two ways of computing the sum of the integers, ranging
    from one to an upper limit expressed as *n*, whose default value is 1,000,000\.
    The `custom_sum` function loops through all the elements, adding each to a running
    sum. The `built_in_sum` function utilizes the built-in `sum()` method of Python.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将比较两种计算整数和的方法，范围从1到以*n*表示的上限，其默认值为1,000,000。`custom_sum`函数遍历所有元素，将每个元素加到累计和中。`built_in_sum`函数利用Python的内置`sum()`方法。
- en: In the main scope, we will use commenting to swap between the two function calls
    to test both methods. We will be looking at our custom summing function first,
    so the call to `built_in_sum` is commented out for now.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在主作用域中，我们将使用注释在两个函数调用之间切换，以测试两种方法。我们将首先查看我们的自定义求和函数，因此`built_in_sum`的调用目前已被注释掉。
- en: The typical claim is that built-in functions are generally faster than any code
    you might write. In this example, we will be able to fact-check that claim and
    further qualify it with runtime statistics through our profiling process. Let’s
    get started.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的说法是内置函数通常比任何你可能会编写的代码都要快。在这个例子中，我们将能够通过我们的分析过程来核实这个说法，并通过运行时统计进一步对其进行限定。让我们开始吧。
- en: 'As with testing and coverage, we can start a profiling run by using either
    the green arrows within the editor or the run button ellipsis at the top of the
    screen. *Figure 6**.30* shows both options:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 就像测试和覆盖率一样，我们可以通过使用编辑器内的绿色箭头或屏幕顶部的运行按钮省略号来启动配置文件运行。图6.30显示了这两种选项：
- en: '![Figure 6.30: You can run a profile using either the ellipsis menu at the
    top right or by clicking the green arrow next to the dunder-main entry point on
    line 14](img/B19644_Figure_6.30.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图6.30：你可以使用右上角的省略号菜单或通过点击第14行dunder-main入口点旁边的绿色箭头来运行配置文件](img/B19644_Figure_6.30.jpg)'
- en: 'Figure 6.30: You can run a profile using either the ellipsis menu at the top
    right or by clicking the green arrow next to the dunder-main entry point on line
    14'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.30：你可以使用右上角的省略号菜单或通过点击第14行dunder-main入口点旁边的绿色箭头来运行配置文件
- en: 'When the profile run is complete, we will be provided with a performance report,
    as seen in *Figure 6**.31*:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置文件运行完成后，我们将获得一个性能报告，如图6.31所示。31：
- en: '![Figure 6.31: The performance profile for the custom_sum function](img/B19644_Figure_6.31.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图6.31：自定义sum函数的性能配置文件](img/B19644_Figure_6.31.jpg)'
- en: 'Figure 6.31: The performance profile for the custom_sum function'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.31：自定义sum函数的性能配置文件
- en: On my computer, which in this case is a VMWare virtual machine with a very modest
    configuration (2 cores, 4 GB of RAM, and a 7,200 RPM spinning disk), the `custom_sum`
    function completed in 41 ms. The time and the percentage are a little bunched
    together on my display, but we can see that 100% of the time was spent in the
    `custom_sum` function. If this were a more complicated program with many functions
    being called during the run, we’d see a full listing of each function and how
    much time was spent on each. Pay attention to the **Own Time** column versus the
    **Time** column.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的电脑上，这是一个VMWare虚拟机，配置非常简单（2个核心，4GB的RAM，7200RPM的旋转硬盘），`custom_sum`函数完成了41毫秒。时间和百分比在我的显示上有点拥挤，但我们可以看到100%的时间都花在了`custom_sum`函数上。如果这是一个更复杂的程序，在运行期间调用了许多函数，我们会看到每个函数的完整列表以及每个函数花费的时间。注意**自有时长**列与**时间**列之间的区别。
- en: In PyCharm’s performance profiler, the **Time** column shows the total time
    spent executing a particular function or method, including the time spent executing
    any sub-functions or methods called within it.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在PyCharm的性能分析器中，**时间**列显示了执行特定函数或方法所花费的总时间，包括执行其中任何子函数或方法所花费的时间。
- en: On the other hand, the **Own Time** column shows the time spent executing only
    the code within the function or method itself, excluding any time spent executing
    sub-functions or methods. This means that the **Own Time** column can give you
    a better understanding of the performance of the code within a specific function
    or method, independent of any external factors such as the performance of other
    functions or methods it calls.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**自有时长**列显示了仅执行函数或方法本身代码所花费的时间，不包括执行子函数或方法所花费的时间。这意味着**自有时长**列可以让你更好地理解特定函数或方法内代码的性能，而不受任何外部因素（如其他函数或方法性能）的影响。
- en: To illustrate the difference, consider a function, *A()*, that calls two other
    functions, *B()* and *C()*. If you look at the **Time** column for *A()*, it will
    include the time spent executing both *B()* and *C()* in addition to the time
    spent executing the code within *A()* itself. However, if you look at the **Own
    Time** column for *A()*, it will only show the time spent executing the code within
    *A()* and not the time spent executing *B()* and *C()*.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明差异，考虑一个函数*A()*，它调用两个其他函数*B()*和*C()*。如果你查看*A()*的**时间**列，它将包括执行*B()*和*C()*所花费的时间，以及执行*A()*本身代码所花费的时间。然而，如果你查看*A()*的**自有时长**列，它将只显示执行*A()*内代码所花费的时间，而不显示执行*B()*和*C()*所花费的时间。
- en: In general, the **Time** column can give you a sense of the overall performance
    impact of a particular function or method, while the **Own Time** column can help
    you focus on the performance of the code within that function or method.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，**时间**列可以让你对特定函数或方法的整体性能影响有一个大致的了解，而**自身时间**列可以帮助你专注于该函数或方法内部的代码性能。
- en: Comparing performance versus the built-in sum() function
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与内置的 sum() 函数的性能比较
- en: 'Let’s see how my 72 ms runtime fares against the built-in Python `sum()` function.
    Alter the bottom of the `main.py` file by commenting out the `custom_sum` function
    and commenting in the `built_in_sum` function, like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我的 72 毫秒运行时间与内置的 Python `sum()` 函数相比如何。通过在 `main.py` 文件的底部注释掉 `custom_sum`
    函数并注释掉 `built_in_sum` 函数来进行修改，如下所示：
- en: '[PRE33]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run a profile with this configuration. You can see my result in *Figure 6**.32*:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置运行配置文件。你可以在 *图 6.32* 中看到我的结果：
- en: '![Figure 6.32: The built-in sum function appears to run significantly faster
    at 11 ms](img/B19644_Figure_6.32.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.32：内置的 sum 函数似乎在 11 毫秒内运行得更快](img/B19644_Figure_6.32.jpg)'
- en: 'Figure 6.32: The built-in sum function appears to run significantly faster
    at 11 ms'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.32：内置的 sum 函数似乎在 11 毫秒内运行得更快
- en: Wow, there’s no contest! On my computer, leveraging the built-in `sum()` function
    is seven times faster! In real life, I advise running each profile a few times
    and taking an average since the runtimes can vary. In my case, subsequent runs
    of the `built_in_sum` function ranged from 11 ms to 26 ms, which is a pretty wide
    variance.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这根本不是比赛！在我的电脑上，利用内置的 `sum()` 函数快了七倍！在现实生活中，我建议运行每个配置文件几次并取平均值，因为运行时间可能会有所不同。在我的情况下，`built_in_sum`
    函数的后续运行时间从 11 毫秒到 26 毫秒不等，这是一个相当大的差异。
- en: Viewing the call graph
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看调用图
- en: 'In addition to the statistics table, you can also view the profile as a call
    graph. This graph represents a tree-like view of your program’s run, as shown
    in *Figure 6**.33*:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 除了统计表之外，你还可以将配置文件以调用图的形式查看。此图表示了程序运行的树状视图，如图 *图 6.33* 所示：
- en: '![Figure 6.33: The call graph shows a tree-like view of the program run](img/B19644_Figure_6.33.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.33：调用图显示了程序运行的树状视图](img/B19644_Figure_6.33.jpg)'
- en: 'Figure 6.33: The call graph shows a tree-like view of the program run'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.33：调用图显示了程序运行的树状视图
- en: The nodes in the call graph are shaded green and red. The darker the shade of
    red, the more time was spent on the function indicated by that node. In *Figure
    6**.33*, pretty much all of the time is being spent in the `custom_sum` function,
    which is as dark a red as it gets (trust me). The built-in `print` method takes
    up a tiny but non-zero amount of time when it prints the sum in the main function.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 调用图中的节点被涂成绿色和红色。红色越深，表示该节点所指示的函数花费的时间越多。在 *图 6.33* 中，几乎所有的时间都花在了 `custom_sum`
    函数上，它的红色最深（相信我）。当在主函数中打印求和结果时，内置的 `print` 方法占用了极小但非零的时间。
- en: Navigating using the performance profile
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用性能配置文件进行导航
- en: 'You can navigate to a function using either the statistics table or the corresponding
    node in the call graph. Just right-click, as shown in *Figure 6**.34*:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用统计表或调用图中的相应节点来导航到函数。只需右键单击，如图 *图 6.34* 所示：
- en: '![Figure 6.34: You can navigate to your code by right-clicking the function
    and selecting Navigate to Source](img/B19644_Figure_6.34.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.34：你可以通过右键单击函数并选择“导航到源”来导航到你的代码](img/B19644_Figure_6.34.jpg)'
- en: 'Figure 6.34: You can navigate to your code by right-clicking the function and
    selecting Navigate to Source'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.34：你可以通过右键单击函数并选择“导航到源”来导航到你的代码
- en: You can do the same thing on the call graph. Upon right-clicking a node on the
    call graph, you’ll get the same navigation option to take you to the source. This
    can help you navigate straight to any code you might want to inspect.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在调用图中做同样的事情。在调用图上右键单击一个节点时，你会得到相同的导航选项，带你到源代码。这可以帮助你直接导航到任何你可能想要检查的代码。
- en: Performance cProfile snapshots
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cProfile 性能快照
- en: 'When you do a profile run with cProfile, PyCharm will save a `.pstat` files
    are generated in my home folder:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 cProfile 进行配置文件运行时，PyCharm 将在您的家目录中保存 `.pstat` 文件：
- en: '[PRE34]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When I’m doing serious profiling work, I will often copy these files into a
    more convenient folder and alter their names to indicate the conditions under
    which they were run. For example, in our example, I might call the first `.pstat`
    file something like `custom_sum_performance_1.pstat`; the second might be called
    `built_in_sum_performance_1.pstat`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当我进行严肃的性能分析工作时，我通常会把这些文件复制到一个更方便的文件夹中，并更改它们的名称以表明它们是在什么条件下运行的。例如，在我们的例子中，我可能会将第一个
    `.pstat` 文件命名为 `custom_sum_performance_1.pstat`；第二个可能被命名为 `built_in_sum_performance_1.pstat`。
- en: I’m doing this so that I have a baseline performance profile for each. In real
    life, I suspect you will rarely have such an easy alternative to what we’ve presented
    here. You’ll more likely have several versions of a function using different approaches
    to algorithm design. In those cases, keeping your `.pstat` files so that you can
    compare them with future runs can be very handy, if for no other reason than to
    brag at your next employee review.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我这样做是为了为每个文件都有一个基准性能配置文件。在现实生活中，我怀疑您很少会有我们在这里展示的这样简单的替代方案。您更有可能有几个使用不同算法设计方法的函数版本。在这些情况下，保留您的
    `.pstat` 文件以便与未来的运行进行比较可能非常有用，即使只是为了在下次员工评审时炫耀。
- en: 'You can open your older `.pstat` files using the **Tools** menu, as shown in
    *Figure 6**.35*:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用**工具**菜单打开您较旧的 `.pstat` 文件，如图 *图 6* 所示。35*：
- en: '![Figure 6.35: You can open your old snapshots via the Tools menu](img/B19644_Figure_6.35.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.35：您可以通过工具菜单打开您的旧快照](img/B19644_Figure_6.35.jpg)'
- en: 'Figure 6.35: You can open your old snapshots via the Tools menu'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.35：您可以通过工具菜单打开您的旧快照
- en: Opening this `.pstat` file will show the statistics table and call graph. If
    you’ve refactored the names of the functions, then you shouldn’t expect the navigation
    to still work; however, you can see the old results and compare them against a
    newer run.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 打开此 `.pstat` 文件将显示统计表和调用图。如果您已经重构了函数的名称，那么您不应该期望导航仍然有效；然而，您可以看到旧的结果，并将它们与较新的一次运行进行比较。
- en: Overall, PyCharm’s ability to open and compare old `.pstat` files can be a useful
    tool for tracking the performance of your code over time and identifying areas
    where performance improvements can be made.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，PyCharm 打开和比较旧 `.pstat` 文件的能力可以是一个有用的工具，用于跟踪代码随时间的变化性能，并识别可以改进性能的领域。
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Testing, debugging, and profiling are high-level tasks we can use to analyze
    applications to look for improvements in correctness and performance, but they
    can be quite confusing to beginner developers. PyCharm offers straightforward
    and intuitive interfaces for these processes, making them more accessible and
    streamlined.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 测试、调试和性能分析是我们可以用来分析应用程序以寻找改进正确性和性能的高级任务，但对于初学者开发者来说可能会相当复杂。PyCharm 为这些过程提供了直观和直观的界面，使它们更容易访问和简化。
- en: Unit testing is the process of making sure the individual components of a large
    system work as intended. PyCharm has convenient commands to generate test skeletons/boilerplate
    code that usually takes time for developers to write manually. While testing a
    program, it is important to consider expected faults, as well as the obvious tests
    for intended functionality.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是确保大型系统各个组件按预期工作的过程。PyCharm 提供了方便的命令来生成测试骨架/样板代码，这通常需要开发者手动编写，会花费很多时间。在测试程序时，考虑预期的错误以及针对预期功能的明显测试是很重要的。
- en: In a debugging session, developers attempt to narrow down and identify the causes
    of bugs and errors that are detected during testing. With a graphical interface,
    combined with various options to track the values of variables throughout a program,
    PyCharm allows us to debug our programs dynamically with considerable freedom.
    The various stepping functions also provide us with a flexible way to step through
    the program we are trying to debug.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试会话中，开发者试图缩小并确定在测试期间检测到的错误和错误的起因。结合图形界面和跟踪程序中变量值的各种选项，PyCharm 允许我们以相当大的自由度动态地调试我们的程序。各种单步执行函数也为我们提供了灵活地遍历我们试图调试的程序的方式。
- en: Lastly, the goal of profiling is to analyze the performance of a program and
    find ways to improve it. This can include looking for faster ways to compute a
    value or identifying a bottleneck in the program. With the ability to generate
    comprehensive statistics on the running time of each function that’s executed,
    as well as call graphs, PyCharm helps developers navigate the different components
    of a profiled program with ease.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，性能分析的目标是分析程序的性能并找到改进的方法。这可能包括寻找计算值的更快方式或识别程序中的瓶颈。PyCharm能够生成关于每个执行函数的运行时间的综合统计数据，以及调用图，这使得开发者能够轻松地导航已分析程序的不同组件。
- en: This chapter also marks the end of the second part of this book, where we focused
    on improving our development productivity. From here, we will be considering the
    usage of PyCharm in more specialized fields, namely web development and data science
    projects.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 本章也标志着本书第二部分的结束，我们在此部分专注于提高我们的开发效率。从现在起，我们将考虑PyCharm在更多专业领域的使用，特别是Web开发和数据科学项目。
- en: In the next chapter, we will cover the basics of three universal web development
    languages – JavaScript, HTML, and CSS – within the context of PyCharm.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍在PyCharm环境中三种通用网络开发语言的基础——JavaScript、HTML和CSS。
- en: Questions
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: What is testing in the context of software development? What are the different
    testing methods?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在软件开发背景下，测试是什么？有哪些不同的测试方法？
- en: How does PyCharm support testing processes?
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PyCharm如何支持测试过程？
- en: What is debugging in the context of software development?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在软件开发背景下，调试是什么？
- en: How does PyCharm support debugging processes?
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PyCharm如何支持调试过程？
- en: What is profiling in the context of software development?
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在软件开发背景下，性能分析是什么？
- en: How does PyCharm support profiling processes?
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PyCharm如何支持性能分析过程？
- en: What is the significance of run arrows in PyCharm’s editor?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PyCharm编辑器中的运行箭头有什么意义？
- en: Further reading
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及主题的信息，请查看以下资源：
- en: '*Agile Software Development, Principles, Patterns, and Practices*, Martin,
    R. C. (2003). Prentice Hall.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《敏捷软件开发：原则、模式和实战》，马丁，R. C. (2003)。普伦蒂斯·霍尔出版社。
- en: '*Clean Architecture: A Craftsman’s Guide to Software Structure and Design*,
    Martin, R. C. (2017). Prentice Hall.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《整洁架构：软件结构和设计的工匠指南》，马丁，R. C. (2017)。普伦蒂斯·霍尔出版社。
- en: '*Real-World Implementation of C# Design Patterns*, Van Horn, B and Symons,
    V. (2022). Packt Publishing.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《C#设计模式的实际应用》，范·霍恩，B 和 西蒙斯，V. (2022)。Packt出版社。
- en: Be sure to check out the companion website for the book at[https://www.pycharm-book.com](https://www.pycharm-book.com)*.*
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请务必查看本书的配套网站[https://www.pycharm-book.com](https://www.pycharm-book.com)*.*
- en: 'Part 3: Web Development in PyCharm'
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：在PyCharm中进行Web开发
- en: This part of the book focuses on web development processes in Python programming
    and what support PyCharm has in store for web projects. Readers will be able to
    use PyCharm and its features to efficiently develop their web applications.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分书籍专注于Python编程中的Web开发过程以及PyCharm为Web项目提供的支持。读者将能够使用PyCharm及其功能来高效地开发他们的Web应用程序。
- en: 'This part has the following chapters:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 7*](B19644_07.xhtml#_idTextAnchor172), *Web Development with JavaScript,
    HTML, and CSS*'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19644_07.xhtml#_idTextAnchor172), *使用JavaScript、HTML和CSS进行Web开发*'
- en: '[*Chapter 8*](B19644_08.xhtml#_idTextAnchor203), *Building a Dynamic Web Application
    with Flask*'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19644_08.xhtml#_idTextAnchor203), *使用Flask构建动态Web应用程序*'
- en: '[*Chapter 9*](B19644_09.xhtml#_idTextAnchor223), *Creating a RESTful API with
    FastAPI*'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19644_09.xhtml#_idTextAnchor223), *使用FastAPI创建RESTful API*'
- en: '[*Chapter 10*](B19644_10.xhtml#_idTextAnchor243), *More full stack frameworks:
    Django and Pyramid*'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19644_10.xhtml#_idTextAnchor243), *更多全栈框架：Django和Pyramid*'
- en: '*Chapter 11*, *Understanding Database Management in PyCharm*'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第11章*，*在PyCharm中理解数据库管理*'
