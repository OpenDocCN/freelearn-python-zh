- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章
- en: '**What is a monolith?**'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是单体？**'
- en: A monolith is a software application that is created in a single block. This
    application runs as a single process. It can only be deployed in unison, although
    multiple identical copies can be created.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用是指以单个块创建的软件应用程序。该应用程序作为单个进程运行。它只能一起部署，尽管可以创建多个相同的副本。
- en: '**What problems can monoliths run into?**'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单体可能会遇到什么问题？**'
- en: 'As they grow, monoliths can experience the following problems:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 随着发展，单体可能会遇到以下问题：
- en: The code becomes too big and difficult to read.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码变得太大且难以阅读。
- en: Scalability problems.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性问题。
- en: The need to coordinate deployments.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要协调部署。
- en: Bad usage of resources.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源的不良使用。
- en: It's not possible to use conflicting technologies for different situations (for
    example, different versions of the same library, or two programming languages).
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可能在不同情况下使用冲突的技术（例如，相同库的不同版本，或两种编程语言）。
- en: A single bug and deployment can affect the whole system.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个错误和部署可能会影响整个系统。
- en: '**Can you describe the microservice architecture?**'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你能描述微服务架构吗？**'
- en: The microservice architecture is a collection of loosely coupled specialized
    services that work in unison to provide a comprehensive service.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是一组松散耦合的专业化服务的集合，它们协同工作以提供全面的服务。
- en: '**What is the most important property of a microservice?**'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**微服务最重要的特性是什么？**'
- en: The most important property of a microservice is that they can be deployed independently
    so that they can be developed independently.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务最重要的特性是它们可以独立部署，以便可以独立开发。
- en: '**What are the main challenges that we need to overcome when migrating from
    a monolith to a microservice?**'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从单体架构迁移到微服务时，我们需要克服的主要挑战是什么？**'
- en: 'Possible challenges include the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的挑战包括以下内容：
- en: Big changes are needed that require us to change the way the services operate,
    including the culture of the teams. This can result in training, which is costly.
  id: totrans-18
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要进行大的变更，需要我们改变服务的运行方式，包括团队的文化。这可能导致成本高昂的培训。
- en: Debugging a distributed system is more complicated.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试分布式系统更加复杂。
- en: We need to plan changes so that they don't interrupt the service.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要计划变更，以便不中断服务。
- en: There's a significant amount of overhead for each microservice that's developed.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个开发的微服务都会产生大量开销。
- en: We need to find a balance between allowing each team to decide how to work and
    standardizing to avoid reinventing the wheel.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要在允许每个团队决定如何工作和标准化以避免重复造轮之间找到平衡。
- en: We need to document the service so that we can interact with another team.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要记录服务，以便与另一个团队进行交互。
- en: '**How can we make such a migration?**'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们如何进行这样的迁移？**'
- en: We need to analyze the system, measure, plan accordingly, and execute the plan.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要分析系统，测量，相应地计划并执行计划。
- en: '**Describe how we can use a load balancer to migrate from an old server to
    a new one, without interrupting the system. **'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**描述我们如何使用负载均衡器从旧服务器迁移到新服务器，而不中断系统。**'
- en: First, we have to configure the load balancer so that it points to the old web
    server, which will make the traffic cross through the web server.  Then, we have
    to change the DNS record so that it points to the load balancer. After the traffic
    has gone through the load balancer, we need to create a new entry for the new
    service so that the load balancer splits the traffic between both. After confirming
    that everything works as expected, we need to remove the entry from the old service.
    Now, all the traffic will be routed to the new service.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须配置负载均衡器，使其指向旧的Web服务器，这将使流量通过Web服务器。然后，我们必须更改DNS记录，使其指向负载均衡器。流量经过负载均衡器后，我们需要为新服务创建一个新条目，以便负载均衡器在两者之间分配流量。确认一切按预期工作后，我们需要从旧服务中删除条目。现在，所有流量将路由到新服务。
- en: Chapter 2
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章
- en: '**What are the characteristics of RESTful applications?**'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**RESTful应用程序的特征是什么？**'
- en: 'While a RESTful application is understood as a web interface that makes URIs
    into object representations and manipulates them through HTTP methods (and normally
    formats the requests with JSON), the textbook characteristics of a REST architecture
    are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然RESTful应用程序被理解为将URI转换为对象表示并通过HTTP方法操纵它们的Web界面（通常使用JSON格式化请求），但REST架构的典型特征如下：
- en: Uniform interface
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一接口
- en: Client-server
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端-服务器
- en: Stateless
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态
- en: Cacheable
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可缓存
- en: Layered system
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层系统
- en: Code on demand (optional)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按需代码（可选）
- en: You can find out more about the REST architecture at [https://restfulapi.net/](https://restfulapi.net/).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://restfulapi.net/](https://restfulapi.net/)了解有关REST架构的更多信息。
- en: '**What are the advantages of using Flask-RESTPlus?**'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用Flask-RESTPlus的优势是什么？**'
- en: 'Some of the advantages of using Flask-RESTPlus are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Flask-RESTPlus的一些优势包括：
- en: Automatic Swagger generation.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动生成Swagger。
- en: A framework that can define and parse inputs and marshal outputs.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以定义和解析输入并整理输出的框架。
- en: It allows us to structure the code in namespaces.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许我们在命名空间中组织代码。
- en: '**What are some alternatives to Flask-RESTPlus?**'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Flask-RESTPlus的一些替代方案是什么？**'
- en: Other alternatives include Flask-RESTful (this is similar to Flask-RESTPlus,
    but it doesn't support Swagger) and the Django REST framework, which has a rich
    ecosystem that's full of third-party extensions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 其他选择包括Flask-RESTful（这类似于Flask-RESTPlus，但它不支持Swagger）和Django REST框架，它拥有丰富的生态系统，充满了第三方扩展。
- en: Name the Python package used through the tests to fix the time.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名用于测试以修复时间的Python软件包。
- en: '`freezegun`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`freezegun`。'
- en: '**Describe the authentication flow.**'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**描述认证流程。**'
- en: An encoded token is generated by the authentication system (the User Backend).
    This token is encoded with a private key that only the User Backend has. This
    token is encoded in JWT and contains a user ID, as well as other parameters that,
    for example, tell us how long the token is valid for. This token is included in
    the `Authentication` header.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 认证系统（用户后端）生成编码的令牌。此令牌使用只有用户后端拥有的私钥进行编码。此令牌以JWT编码，并包含用户ID以及其他参数，例如告诉我们令牌有效的时间。此令牌包含在`Authentication`标头中。
- en: The token is obtained from the header and decoded using the corresponding public
    key, which is stored in the Thoughts Backend. This allows us to obtain the user
    ID independently with the certainty that it has been validated by the User Backend.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌从标头中获取，并使用相应的公钥进行解码，该公钥存储在Thoughts后端中。这使我们能够独立获取用户ID，并确信它已被用户后端验证。
- en: '**Why did we choose SQLAlchemy as a database interface?**'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么我们选择SQLAlchemy作为数据库接口？**'
- en: SQLAlchemy is well supported in Flask and allows us to define already existing
    databases. It is highly configurable and allows us to work at a low level, that
    is, near the underlying SQL, and at a higher level, which removes the need for
    any boilerplate code. In our use case, we inherited a database from the legacy
    system, thereby making the need to work seamlessly with an existing schema a necessity.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy在Flask中得到很好的支持，并允许我们定义已经存在的数据库。它高度可配置，并允许我们在低级别（即接近底层SQL）和高级别上工作，从而消除了任何样板代码的需求。在我们的用例中，我们从遗留系统继承了一个数据库，因此需要与现有模式无缝工作。
- en: Chapter 3
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章
- en: '**What does the FROM keyword do in a Dockerfile?**'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Dockerfile中的FROM关键字是做什么的？**'
- en: It starts our image from an existing one, adding more layers to it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它从现有的镜像开始，向其添加更多的层。
- en: '**How would you start a container with its predefined command?**'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何使用预定义命令启动容器？**'
- en: 'You would run the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您将运行以下命令：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Why won''t creating a step to remove files from a Dockerfile create a smaller
    image?**'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么在Dockerfile中创建一个删除文件的步骤不会创建一个更小的镜像？**'
- en: Due to the layered structure of the filesystem that's used by Docker, each step
    in a Docker file creates a new layer. The filesystem is the result of all the
    operations working in tandem. The final image includes all the existing layers;
    adding a layer never reduces the size of the image. A new step for deleting will
    not be present in the final image, but it will always be available as part of
    the previous layer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker使用的文件系统具有分层结构，Docker文件中的每个步骤都会创建一个新的层。文件系统是所有操作协同工作的结果。最终镜像包括所有现有的层；添加一个层永远不会减小镜像的大小。删除的新步骤将不会出现在最终镜像中，但它将始终作为前一个层的一部分可用。
- en: '**How does a multistage Dockerfile work?**'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**多阶段Dockerfile是如何工作的？**'
- en: A multistage Dockerfile contains more than one stage, each of which will start
    with a `FROM` command, which specifies the image that acts as the starting point.
    Data can be generated in one stage and then copied to another.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段Dockerfile包含多个阶段，每个阶段都将以`FROM`命令开始，该命令指定作为起点的镜像。数据可以在一个阶段生成，然后复制到另一个阶段。
- en: Multistage builds are useful if we wish to reduce the size of the final images;
    only the resulting data will be copied to the final stage.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段构建在我们希望减小最终镜像大小时非常有用；只有生成的数据将被复制到最终阶段。
- en: '**What is the difference between the run and exec commands?**'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行和执行命令之间有什么区别？**'
- en: The `run` command starts a new container from an image, while the `exec` command
    connects to an already existing running container. Note that if the container
    stops while you are executing it, the session will be closed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`命令从镜像启动一个新的容器，而`exec`命令连接到已经存在的运行中的容器。请注意，如果在执行时容器停止，会话将被关闭。'
- en: Stopping a container can occur in an `exec` session. The main process that is
    keeping the container running is the `run` command. If you kill the command or
    stop it in any other way, the container will stop and the session will be closed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`exec`会话中停止容器可能会发生。保持容器运行的主要进程是`run`命令。如果您终止命令或以其他方式停止它，容器将停止，会话将被关闭。
- en: '**When should we use the -it flag?**'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**何时应该使用-it标志？**'
- en: When you need to keep a Terminal open, for example, to run `bash` commands interactively.
    Remember the mnemonic *interactive Terminal*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要保持终端打开时，例如交互式运行`bash`命令。请记住这个助记符*交互式终端*。
- en: '**What are the alternatives to using uWSGI to serve web Python applications?**'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**除了使用uWSGI来提供Web Python应用程序之外，还有哪些替代方案？**'
- en: Any web server that supports the WSGI web protocol can be used as an alternative.
    The most popular alternatives are Gunicorn, which aims to be easy to use and configure, `mod_wsgi`,
    an extension of the popular Apache web server that supports WSGI Python modules,
    and CherryPy, which includes its own web framework.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 任何支持WSGI网络协议的Web服务器都可以作为替代方案。最受欢迎的替代方案是Gunicorn，旨在易于使用和配置，`mod_wsgi`是流行的Apache
    Web服务器的扩展，支持WSGI Python模块，以及CherryPy，它包括自己的Web框架。
- en: '**What is docker-compose used for?**'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**docker-compose用于什么？**'
- en: '`docker-compose` allows for easy orchestration, that is, we can coordinate
    several interconnected Docker containers so that they work in unison. It also
    helps us configure Docker commands since we can use the `docker-compose.yaml`
    file to store the configuration parameters for all the affected containers.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose`允许轻松编排，也就是说，我们可以协调多个相互连接的Docker容器，使它们协同工作。它还帮助我们配置Docker命令，因为我们可以使用`docker-compose.yaml`文件来存储所有受影响容器的配置参数。'
- en: '**Can you describe what a Docker tag is?**'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你能描述一下Docker标签是什么吗？**'
- en: A Docker tag is a way of labeling images while keeping their root names. It
    typically marks different versions of the same application or software. By default,
    the `latest` tag will be applied to an image build.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Docker标签是一种在保持其根名称的同时标记图像的方法。它通常标记相同应用程序或软件的不同版本。默认情况下，`latest`标签将应用于图像构建。
- en: '**Why do we need to push images to a remote registry?**'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么我们需要将镜像推送到远程注册表？**'
- en: We push images to a remote registry so that we can share images with other systems
    and other developers. Docker builds images locally unless they need to be pushed
    to another repository so that other Docker services can use them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将镜像推送到远程注册表，以便与其他系统和开发人员共享镜像。除非需要将镜像推送到另一个存储库，否则Docker会在本地构建镜像，以便其他Docker服务可以使用它们。
- en: Chapter 4
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章
- en: '**Does increasing the number of deployments reduce the quality of deployments?**'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**增加部署数量是否会降低部署的质量？**'
- en: No; it has been shown that increasing the number of deployments has a strong
    correlation with their quality increasing. A system that is capable of deploying
    quickly has to rely on strong automated tests, which increases the stability and
    overall quality of the system.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不会；已经证明增加部署数量与其质量增加有很强的相关性。一个能够快速部署的系统必须依赖于强大的自动化测试，这会增加系统的稳定性和整体质量。
- en: '**What is a pipeline?**'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是管道？**'
- en: A pipeline is an ordered succession of steps or stages that are used to perform
    a build. If one of the steps fails, the build stops. The order of steps should
    aim to maximize the early detection of problems.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是用于执行构建的有序步骤或阶段的连续顺序。如果其中一个步骤失败，构建将停止。步骤的顺序应该旨在最大程度地早期检测问题。
- en: '**How do we know if our main branch can be deployed?**'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们如何知道我们的主分支是否可以部署？**'
- en: If we automatically run our pipeline to generate a build on each commit, we
    should detect problems on the main branch as soon as they are committed. The build
    should assure us that the top commit of the main branch can be deployed. A breakage
    in the main branch should be fixed as soon as possible.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们自动运行我们的管道以在每次提交时生成构建，我们应该在提交时尽快检测主分支上的问题。构建应该让我们确信主分支的顶部提交可以部署。主分支的中断应该尽快修复。
- en: '**What is the main configuration source for Travis CI?**'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Travis CI的主要配置来源是什么？**'
- en: The `.travis.yml` file, which can be found in the root directory of the repository.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`.travis.yml`文件，可以在存储库的根目录中找到。'
- en: '**By default, when does Travis CI send notification emails?**'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Travis CI默认在何时发送通知邮件？**'
- en: Travis CI sends notification emails whenever a build breaks and when a previously
    broken branch passes successfully. Successful builds occur when the previous commit
    was successful but not reported.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Travis CI在构建中断时发送通知邮件，以及先前中断的分支成功通过时发送通知邮件。成功的构建发生在先前的提交成功但未报告的情况下。
- en: '**How can we avoid merging a broken branch into our main branch?**'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们如何避免将中断的分支合并到主分支？**'
- en: We can avoid this by configuring in GitHub, which ensures that the branch passes
    the build before we merge it into a protected branch. To ensure that the feature
    branch has not deviated from the main one, we need to force it to merge with a
    build. It needs to be up to date with the main branch for this to happen.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在GitHub中进行配置来避免这种情况，这可以确保分支在合并到受保护的分支之前通过构建。为了确保功能分支没有偏离主分支，我们需要强制它与构建合并。为了实现这一点，它需要与主分支保持最新。
- en: '**Why should we avoid storing secrets in a Git repository?**'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么我们应该避免将机密存储在Git存储库中？**'
- en: Due to the way Git works, any secret that's introduced can be retrieved by looking
    at the commit history, even if it's been removed. Since the commit history can
    be replicated in any cloned repository, it makes it impossible for us to verify
    whether it's correct—we can't rewrite the commit history into a cloned repository.
    Secrets should not be stored in Git repositories unless they are properly encrypted.
    Any secret that's stored by mistake should be removed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Git的工作方式，任何引入的机密都可以通过查看提交历史来检索，即使它已被删除。由于提交历史可以在任何克隆的存储库中复制，这使得我们无法验证它是否正确
    - 我们无法将提交历史重写到克隆的存储库中。除非正确加密，机密不应存储在Git存储库中。任何错误存储的机密都应该被删除。
- en: Chapter 5
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章
- en: '**What is a container orchestrator?**'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是容器编排器？**'
- en: A container orchestrator is a system where we can deploy multiple containers
    that work in unison, as well as manage provisioning and deployment in an ordered
    fashion.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 容器编排器是一个系统，我们可以在其中部署多个容器，这些容器可以协同工作，并以有序的方式管理供应和部署。
- en: '**In Kubernetes, what is a node?**'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在Kubernetes中，什么是节点？**'
- en: A node is a physical server or virtual machine that is part of the cluster.
    Nodes can be added or removed from the cluster and Kubernetes will migrate or
    restart the running containers accordingly.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 节点是集群中的物理服务器或虚拟机。节点可以被添加或从集群中移除，Kubernetes会相应地迁移或重新启动正在运行的容器。
- en: '**What is the difference between a pod and a container?**'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Pod和容器之间有什么区别？**'
- en: A pod can contain several containers that share the same IP. To deploy a container
    in Kubernetes, we need to associate it with a pod.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Pod可以包含多个共享相同IP的容器。要在Kubernetes中部署容器，我们需要将其与一个Pod关联起来。
- en: '**What is the difference between a job and a pod?**'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**作业和Pod之间有什么区别？**'
- en: A pod is expected to run constantly. A job, or cron job, performs a single action,
    and then all the pod containers finish their execution.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Pod预期会持续运行。一个作业或定时作业执行单个操作，然后所有Pod容器完成它们的执行。
- en: '**When should we add an Ingress?**'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们何时应该添加Ingress？**'
- en: We should add an Ingress when we need to be able to access a service externally
    from the cluster.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要能够从集群外部访问服务时，我们应该添加Ingress。
- en: '**What is a namespace?**'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**命名空间是什么？**'
- en: A namespace is a virtual cluster. All of the definitions that are inside a cluster
    need to have unique names.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是一个虚拟集群。集群中的所有定义都需要具有唯一的名称。
- en: '**How can we define a Kubernetes element in a file?**'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们如何在文件中定义Kubernetes元素？**'
- en: We need to specify it in YAML format and provide information about its API version,
    the kind of element it is, a metadata section with a name and namespace, and the
    element's definition in a `spec` section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以YAML格式指定它，并提供关于其API版本、元素类型、具有名称和命名空间的元数据部分，以及`spec`部分中的元素定义。
- en: '**What is the difference between the kubectl get and describe commands?**'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**kubectl get和describe命令有什么区别？**'
- en: '`kubectl get` obtains several elements, such as services or pods, and displays
    their basic information. `describe`, on the other hand, accesses a single element
    and presents much more information about it.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl get`获取多个元素，如服务或pod，并显示它们的基本信息。另一方面，`describe`访问单个元素并呈现更多关于它的信息。'
- en: '**What does the CrashLoopBackOff error indicate?**'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CrashLoopBackOff错误表示什么？
- en: This error indicates that a container has finished executing the defined starting
    command. This error only occurs in relation to pods since they're never supposed
    to stop executing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误表明一个容器已经执行了定义的启动命令。这个错误只与pod有关，因为它们永远不应该停止执行。
- en: Chapter 6
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: '**What are the three microservices that we are deploying?**'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在部署的三个微服务是什么？
- en: 'The following are the three microservices that we are deploying:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们正在部署的三个微服务：
- en: The Users Backend, which controls authentication and how users are handled.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户后端用于控制身份验证和用户处理方式。
- en: The Thoughts Backend, which stores thoughts and allows us to create and search
    for them.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thoughts Backend用于存储思想并允许我们创建和搜索它们。
- en: The Frontend, which provides us with a user interface so that we can interact
    with the system. It calls the other two microservices through RESTful calls.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端为我们提供了一个用户界面，以便我们可以与系统进行交互。它通过RESTful调用调用其他两个微服务。
- en: '**Which of the three microservices requires the other two microservices to
    be available?**'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这三个微服务中哪一个需要其他两个微服务可用？
- en: The Frontend calls the other two microservices, so they need to be available
    for the Frontend to work.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前端调用其他两个微服务，因此它们需要对前端可用。
- en: '**Why do we need to use external IPs to connect to microservices while they''re
    running in docker-compose?**'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们需要在运行docker-compose时使用外部IP连接到微服务？
- en: '`docker-compose` creates an internal network for each microservice, so they
    need to communicate using an external IP so that they''re routed properly. While
    we''re exposing ports in the host computer, the external host IP can be used.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose`为每个微服务创建一个内部网络，因此它们需要使用外部IP进行通信，以便正确路由。虽然我们在主机计算机上暴露端口，但可以使用外部主机IP。'
- en: '**What are the main Kubernetes objects that are required for each application?**'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个应用程序所需的主要Kubernetes对象是什么？
- en: For each microservice, we provide a deployment (which automatically generates
    a pod), a service, and an Ingress.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个微服务，我们提供一个部署（自动生成一个pod）、一个服务和一个Ingress。
- en: '**Are any of the objects not required?**'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有没有任何不需要的对象？
- en: An Ingress for the Users Backend and the Thoughts Backend isn't strictly required
    since they can be accessed through the node port, but it does make accessing them
    easier.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 用户后端和Thoughts后端的Ingress并不是绝对必需的，因为它们可以通过节点端口访问，但这样做可以更轻松地访问它们。
- en: '**Can we detect issues if we scale to more than one pod or any other microservice?**'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们扩展到多个pod或任何其他微服务，我们能检测到问题吗？
- en: The Users Backend and Thoughts Backend creates a pod with two containers, which
    includes the database. If we create multiple pods, we will be creating multiple
    databases, and alternating between them can cause issues.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 用户后端和Thoughts后端创建了一个包含两个容器的pod，其中包括数据库。如果我们创建多个pod，将创建多个数据库，并在它们之间交替可能会导致问题。
- en: For example, if we create a new thought in one of the pods, we won't be able
    to search for it if the request was made in another pod.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们在一个pod中创建一个新的想法，如果请求是在另一个pod中进行的，我们将无法搜索到它。
- en: On the other hand, the Frontend can be scaled with no issue.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，前端可以轻松扩展。
- en: '**Why are we using the /etc/hosts file?**'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为什么要使用`/etc/hosts`文件？
- en: We are using this file so that we can define a `host` that routes to our local
    Kubernetes cluster. This avoids us having to define an FQDN and configure a DNS
    server.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用这个文件来定义一个`host`，将其路由到我们的本地Kubernetes集群。这样我们就不必定义FQDN并配置DNS服务器。
- en: Chapter 7
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: '**Why shouldn''t we manage our own Kubernetes cluster?**'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们不应该管理自己的Kubernetes集群？
- en: Since Kubernetes is an abstraction layer, it is more convenient to have a cloud
    provider take care of maintenance and management, as well as security best practices.
    It's also quite cheap to delegate clusters to an existing commercial cloud provider.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Kubernetes是一个抽象层，让云提供商负责维护、管理和安全最佳实践更加方便。将集群委托给现有的商业云提供商也非常便宜。
- en: '**Can you name some commercial cloud providers that have a managed Kubernetes
    solution?**'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能说出一些具有托管Kubernetes解决方案的商业云提供商吗？
- en: Amazon Web Services, Google Cloud Services, Microsoft Azure, Digital Ocean,
    and IBM Cloud are all commercial cloud providers that have a managed Kubernetes
    solution.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊网络服务、谷歌云服务、微软Azure、Digital Ocean和IBM Cloud都是商业云提供商，提供了托管的Kubernetes解决方案。
- en: '**What action do you need to perform to be able to push to an AWS Docker registry?**'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要执行什么操作才能推送到AWS Docker注册表？
- en: 'You need to log in to your Docker daemon. You can obtain the login command
    by using the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要登录到Docker守护程序。您可以使用以下代码获取登录命令：
- en: '[PRE1]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**What tool do we use to set up an EKS cluster?**'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用什么工具来设置EKS集群？
- en: '`eksctl` allows us to create the whole cluster from the command line, as well
    as scale it up or down as required.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`eksctl`允许我们从命令行创建整个集群，并根据需要进行扩展或缩减。'
- en: '**What are the main changes we made in this chapter so that we could use the
    YAML files from the previous chapters?**'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在本章中做了哪些主要更改，以便我们可以使用之前章节中的YAML文件？
- en: We had to change the image definition to be able to use the AWS registries.
    We included the liveness and readiness probes, as well as a deployment strategy.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须更改图像定义才能使用AWS注册表。我们包括了活跃性和就绪性探针，以及部署策略。
- en: These are only added to the `frontend` deployment. Adding the rest of the deployments
    is left to you as an exercise.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只添加到`frontend`部署中。将其余部署添加留给你作为练习。
- en: '**Are there any Kubernetes elements that are not required in this cluster?**'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个集群中有没有不需要的Kubernetes元素？
- en: The Ingress element isn't strictly required since the Thoughts Backend and the
    Users Backend can't be accessed externally. The frontend service is capable of
    creating an externally facing ELB.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Ingress元素并不是严格要求的，因为Thoughts Backend和Users Backend无法从外部访问。前端服务能够创建一个面向外部的ELB。
- en: Don't feel like you're limited by our configuration. You can manually configure
    an ELB so that you can access the cluster in different ways, so you can use the
    Ingress configuration if you wish.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不要觉得我们的配置限制了你。你可以手动配置ELB，这样你就可以以不同的方式访问集群，如果你愿意，你可以使用Ingress配置。
- en: '**Why do we need to control the DNS associated with an SSL certificate?**'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们为什么需要控制与SSL证书关联的DNS？**'
- en: We need to prove that we own the DNS so that the SSL certificate can verify
    that only legitimate owners of the DNS address have access to a certificate for
    that DNS. This is the root element of HTTPS and states that you are communicating
    privately with the owner of a particular DNS.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要证明我们拥有DNS，以便SSL证书可以验证只有DNS地址的合法所有者才能访问该DNS的证书。这是HTTPS的根本要素，并且表明您正在与特定DNS的所有者进行私人通信。
- en: '**What is the difference between the liveness and the readiness probes?**'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**存活探针和就绪探针之间有什么区别？**'
- en: If the readiness probe fails, the pod won't accept requests until it passes
    again. If the liveness probe fails, the container will be restarted.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果就绪探针失败，Pod将不接受请求，直到再次通过。如果存活探针失败，容器将被重新启动。
- en: '**Why are rolling updates important in production environments?**'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**滚动更新在生产环境中为什么重要？**'
- en: They are important as they avoid interruptions in the service. They add workers
    one by one while removing old ones, ensuring that the number of available workers
    at any time remains the same.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它们很重要，因为它们避免了服务中断。它们一次添加一个工作进程，同时删除旧的工作进程，确保任何时候可用的工作进程数量保持不变。
- en: '**What is the difference between autoscaling pods and nodes?**'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**自动缩放Pod和节点之间有什么区别？**'
- en: Since nodes are reflected in physical instances, scaling them affects the resources
    that are in the system. Meanwhile, scaling pods uses the resources that are available
    to them, but doesn't modify them.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于节点反映在物理实例中，对它们进行扩展会影响系统中的资源。与此同时，扩展Pod使用它们可用的资源，但不会修改它们。
- en: In other words, increasing the number of nodes we have adds more hardware that
    needs to be run on the system. This has a cost associated with it in that we need
    to hire more hardware from our cloud provider. Increasing the number of pods we
    have doesn't have a cost in terms of hardware, which is why there should be some
    overhead to allow for increases.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，增加节点数量会增加需要在系统上运行的硬件。这是有成本的，因为我们需要从云提供商那里租用更多的硬件。增加Pod数量在硬件方面没有成本，这就是为什么应该有一些额外的开销来允许增加。
- en: Both strategies should be coordinated so that we can react quickly to load increases
    and, at the same time, reduce the amount of hardware that's being utilized so
    that we can reduce costs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 两种策略应该协调，以便我们可以迅速对负载增加做出反应，并同时减少正在使用的硬件数量，以便降低成本。
- en: '**In this chapter, we deployed our own database containers. In production,
    this isn''t required. However, if you''re connected to an already existing database,
    how would you do this?**'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在本章中，我们部署了自己的数据库容器。在生产中，这是不需要的。但是，如果您连接到已经存在的数据库，您将如何做到这一点？**'
- en: The first step would be to change the environment variables in the `thoughts_backend/deployment.yaml` and `users_backend/deployment.yaml` files.
    The main one to connect to is `POSTGRES_HOST`, but the user and password will
    probably have to change as well.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是更改`thoughts_backend/deployment.yaml`和`users_backend/deployment.yaml`文件中的环境变量。主要连接的是`POSTGRES_HOST`，但用户和密码可能也需要更改。
- en: Instead of connecting to `POSTGRES_HOST` as an IP or DNS address directly, we
    could create an internal Kubernetes service called `postgres-db` that points toward
    an external address. This could help us abstract the address of the external database.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个名为`postgres-db`的内部Kubernetes服务，它指向外部地址，而不是直接连接到`POSTGRES_HOST`作为IP或DNS地址。这可以帮助我们抽象外部数据库的地址。
- en: This would be deployed in one go to ensure that we can connect to the external
    database.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这将一次性部署，以确保我们可以连接到外部数据库。
- en: Then, we can remove the database containers that were described in the deployments,
    that is, `thoughts-backend-db` and `users-backend-db`. The images for these containers
    are only used for testing and development.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以删除部署中描述的数据库容器，即`thoughts-backend-db`和`users-backend-db`。这些容器的映像仅用于测试和开发。
- en: Chapter 8
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章
- en: '**What is the difference between using a script to push new code to servers
    and using a configuration management tool such as Puppet?**'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用脚本将新代码推送到服务器和使用Puppet等配置管理工具之间有什么区别？**'
- en: When using a script to push new code to servers, every server needs to have
    the code pushed individually. *Puppet* and other configuration management tools
    have a centralized server that receives new data and distributes it appropriately.
    They also monitor the fact that the servers are running as expected and can perform
    remediation tasks.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用脚本将新代码推送到服务器时，每台服务器都需要单独推送代码。*Puppet*和其他配置管理工具有一个集中的服务器，接收新数据并适当分发。它们还监视服务器是否按预期运行，并可以执行补救任务。
- en: Configuration management tools are used for big clusters since they reduce the
    amount of work that needs to be handled in custom scripts.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理工具用于大型集群，因为它们减少了需要在自定义脚本中处理的工作量。
- en: '**What is the core idea behind DevOps?**'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**DevOps的核心理念是什么？**'
- en: The core idea behind DevOps is to empower teams so that they have control over
    performing their own deployments and their infrastructure. This requires a safety
    network in the form of automated procedures to ensure that these operations are
    easy, safe, and quick to perform.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps的核心理念是赋予团队控制权，使他们能够自行部署和管理基础设施。这需要一套自动化程序作为安全网络，以确保这些操作易于进行、安全且快速。
- en: '**What are the advantages of using GitOps?**'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用GitOps的优势是什么？**'
- en: 'The main advantages of using GitOps are as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GitOps的主要优势如下：
- en: Git is a common tool that most teams already know how to use.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git是大多数团队已经知道如何使用的常见工具。
- en: It keeps a copy of the infrastructure definition, which means we can use it
    as a backup and recover from catastrophic failures or create a new cluster based
    on a previous definition with ease.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它保留了基础设施定义的副本，这意味着我们可以将其用作备份，并从灾难性故障中恢复，或者轻松地基于先前的定义创建新的集群。
- en: The infrastructure changes are versioned, which means we can make small discrete
    changes one by one and revert any of them if there's a problem.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施更改是有版本的，这意味着我们可以逐个进行小的离散更改，并在出现问题时撤消其中任何一个。
- en: '**Can only GitOps be used in Kubernetes clusters?**'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Kubernetes集群只能使用GitOps吗？**'
- en: Though GitOps does have synergy with Kubernetes, since Kubernetes can be controlled
    by YAML files, there's nothing stopping us from using a Git repository to control
    a cluster.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管GitOps与Kubernetes具有协同作用，因为Kubernetes可以通过YAML文件进行控制，但没有什么能阻止我们使用Git存储库来控制集群。
- en: '**Where does the Flux deployment live?**'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Flux部署位于哪里？**'
- en: It lives in its own Kubernetes cluster so that it can pull data from Git.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 它位于自己的Kubernetes集群中，以便可以从Git中提取数据。
- en: '**What do you need to configure in GitHub so that Flux can access it?**'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您需要在GitHub中配置什么，以便Flux可以访问它？**'
- en: You need to add an SSH key to the deployment keys of the GitHub repository.
    You can obtain an SSH key by calling `fluxctl identity`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将SSH密钥添加到GitHub存储库的部署密钥中。您可以通过调用`fluxctl identity`来获取SSH密钥。
- en: '**When you''re working in production environments, what features that are provided
    by GitHub ensure that we have control over deployments?**'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在生产环境中工作时，GitHub提供的哪些功能确保我们对部署有控制？**'
- en: We need to have review and approval before we can merge into the main branch,
    which triggers a deployment. The inclusion of code owners to force approval from
    specific users can help us control delicate areas.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以合并到主分支之前，需要进行审查和批准，这会触发部署。强制从特定用户那里获得批准的代码所有者的包含可以帮助我们控制敏感区域。
- en: Chapter 9
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章
- en: '**When new business features are received, what analysis needs to be done in
    a system working under a microservice architecture?**'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在微服务架构下运行的系统中，当收到新的业务功能时，需要进行哪些分析？**'
- en: We need to determine what microservice or microservices the new business feature
    affects. A feature that affects multiple microservices makes its implementation
    more difficult.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确定新业务功能影响哪个微服务或多个微服务。影响多个微服务的功能使其实施更加困难。
- en: '**If a feature requires two or more microservices to be changed, how do we
    decide which should be changed first?**'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果一个功能需要更改两个或更多微服务，我们如何决定首先更改哪个？**'
- en: This should be done in a back-to-forward way in order to keep backward compatibility.
    New features should be added while keeping backward compatibility in mind, so
    the possibilities are limited. Once the backend is ready, the frontend can be
    changed accordingly so that we can take advantage of the new feature.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该以向后兼容的方式进行，以保持向后兼容性。在考虑向后兼容性的情况下添加新功能，因此可能性有限。一旦后端准备就绪，前端可以相应地进行更改，以便我们可以利用新功能。
- en: '**How does Kubernetes help us set up multiple environments?**'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Kubernetes如何帮助我们设置多个环境？**'
- en: Creating new namespaces is very easy in Kubernetes. Since the definition of
    the system is encapsulated in YAML files, they can be copied and modified to create
    a duplicate environment. This can be used as a baseline and then evolved.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中创建新的命名空间非常容易。由于系统的定义封装在YAML文件中，它们可以被复制和修改以创建一个重复的环境。这可以用作基线，然后进行演变。
- en: '**How do code reviews work?**'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代码审查是如何工作的？**'
- en: The code in one branch is compared with the main branch. Another developer can
    look at the differences between them and make comments, asking for clarification
    or changes. These can then be discussed and then the code can be approved if the
    reviewer thinks it's good enough. The merge can be blocked until it has one or
    more approvals.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个分支中的代码与主分支进行比较。另一个开发人员可以查看它们之间的差异并进行评论，要求澄清或更改。然后可以讨论这些评论，如果审阅者认为代码足够好，那么代码就可以被批准。合并可以被阻止，直到它获得一个或多个批准。
- en: '**What is the main bottleneck for code reviews?**'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代码审查的主要瓶颈是什么？**'
- en: The main bottleneck is not having a reviewer to provide feedback and approve
    the code. That's why it's important to have enough people that can perform the
    role of a reviewer.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 主要瓶颈是没有审阅者提供反馈并批准代码。这就是为什么有足够的人可以担任审阅者角色非常重要。
- en: '**Under GitOps principles, are the reviews for deployment different from code
    reviews?**'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**根据GitOps原则，部署的审查与代码审查不同吗？**'
- en: No; under GitOps, the deployments are treated as code, so they can be reviewed
    just like any other code review.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 不；在GitOps下，部署被视为代码，因此它们可以像任何其他代码审查一样进行审查。
- en: '**Why is it important to have a clear path to deployment once a feature is
    ready to be merged into the main branch?**'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一旦功能准备合并到主分支中，为什么有一个清晰的部署路径是重要的？**'
- en: It's important to have a clear path to deployment so that everyone is on the
    same page. It also provides a clear expectation of how fast deployments can happen.
    By doing this, we can specify when a review is required.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要有一个清晰的部署路径，以便每个人都在同一页面上。它还提供了部署速度的明确期望。通过这样做，我们可以指定何时需要审查。
- en: '**Why are database migrations different from regular code deployments? **'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么数据库迁移与常规代码部署不同？**'
- en: They are different because they can't be rolled back easily. While a code deployment
    can be rolled back so that the previous image is deployed again, database migrations
    make changes to the schema of the database or data, which may cause data loss
    if they're reverted. Normally, database migrations are forward-only, and any problems
    that occur need to be corrected with a new deployment.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不同，因为无法轻松回滚。虽然代码部署可以回滚以便重新部署以前的镜像，但数据库迁移会对数据库或数据的模式进行更改，如果它们被回滚可能会导致数据丢失。通常，数据库迁移只能向前进行，任何出现的问题都需要通过新的部署进行更正。
- en: This is the main reason why we have to take extra care with database migrations
    and ensure they are not backward incompatible.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们必须特别小心数据库迁移，并确保它们不向后兼容的主要原因。
- en: Chapter 10
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章
- en: '**What is the observability of a system?**'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**系统的可观察性是什么？**'
- en: It's the capacity of a system. It lets you know what its internal state is.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是系统的容量。它让您知道其内部状态是什么。
- en: '**What are the different severity levels that are available in logs by default?**'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**默认情况下日志中有哪些不同的严重级别？**'
- en: In order of increasing severity, the different severity levels are `DEBUG`,
    `INFO`, `WARNING`, `ERROR`, and `CRITICAL`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 按严重性递增的不同严重级别是`DEBUG`、`INFO`、`WARNING`、`ERROR`和`CRITICAL`。
- en: '**What are metrics used for?**'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**指标用于什么？**'
- en: Metrics allow you to find out the aggregated statuses of the events that are
    occurring on the system and allow you to understand the general state of the system.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 指标允许您了解系统上发生的事件的聚合状态，并了解系统的一般状态。
- en: '**Why do you need to add a request ID to the logs?**'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么需要在日志中添加请求ID？**'
- en: You need to add a request ID to the logs so that you can group all of the logs
    that correspond to the same request.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要向日志中添加请求ID，以便您可以将与同一请求对应的所有日志分组在一起。
- en: '**What kinds of metrics are available in Prometheus?**'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Prometheus中有哪些类型的指标？**'
- en: Counters, which count a particular event; gauges, which keep track of a value
    that can go either up or down; and histograms (or summaries), which track events
    with a value associated with them, such as the times that events occur or when
    the status codes of requests are being returned.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器，用于计算特定事件；仪表，用于跟踪可以上升或下降的值；以及直方图（或摘要），用于跟踪与值相关联的事件，例如事件发生的时间或请求返回的状态代码。
- en: '**What is the 75th percentile in a metric and how is it different from the
    average? **'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**度量中的75th百分位数是什么，它与平均值有何不同？**'
- en: For histograms, the *75^(th)* percentile is where *25%* of the events are higher
    than the average, while *75%* are lower than it. The average is found by adding
    all of the values together and dividing that value by the number of values that
    were added together initially. Typically, the average will be close to the 50th
    percentile, although this depends on how the values are distributed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于直方图，*75^(th)*百分位数是平均值高于*25%*的事件的位置，而低于它的事件占*75%*。平均值是通过将所有值相加并将该值除以最初相加在一起的值的数量来找到的。通常，平均值将接近50th百分位数，尽管这取决于值的分布方式。
- en: The *90^(th)*-*95^(th)* percentile is good if we wish to determine latency since
    it provides upper times for requests, not counting outliers. The average can be
    skewed by outliers and thus not provide a realistic number for the vast majority
    of requests.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*90^(th)*-*95^(th)*百分位数对于确定延迟很有用，因为它提供了请求的上限时间，不包括异常值。平均值可能会被异常值所偏离，因此不能为绝大多数请求提供真实的数字。'
- en: '**What are the four golden signals?**'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**四个黄金信号是什么？**'
- en: The four golden signals are four measurements that gather a description of a
    system's health. They are the latency of requests, the amount of traffic, the
    percentage of returned errors, and the saturation of resources.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 四个黄金信号是收集系统健康描述的四个测量值。它们是请求的延迟、流量量、返回错误的百分比和资源的饱和度。
- en: Chapter 11
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章
- en: '**What are the differences between releasing changes in a microservice architecture
    system and a monolith?**'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在微服务架构系统和单体架构中发布更改有哪些不同？**'
- en: Releasing a change in a monolith will only involve one repository since the
    monolith is only one code base. Some changes that are made in a microservice architecture
    will need us to change two or more microservices so that we can allocate them.
    This requires more planning and care since we need to ensure that this is properly
    coordinated. In a properly architecture microservice system, such multirepository
    changes should be relatively rare since they incur overhead.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体架构中发布更改只涉及一个存储库，因为单体只是一个代码库。在微服务架构中进行的一些更改将需要我们更改两个或更多微服务，以便我们可以分配它们。这需要更多的规划和关注，因为我们需要确保这是正确协调的。在正确架构的微服务系统中，这种多存储库更改应该相对罕见，因为它们会产生额外的开销。
- en: '**Why should release changes be small in a microservice architecture?**'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么在微服务架构中发布更改应该小？**'
- en: The advantage of microservices is that we can release microservices in parallel,
    which is quicker than a monolith release. However, given that a release in a microservice
    could potentially affect other microservices, they should work in an iterative
    way, reducing the size of the changes and increasing their rate of deployment.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的优势在于我们可以并行发布微服务，这比单体发布更快。然而，鉴于微服务中的发布可能会影响其他微服务，它们应该以迭代方式工作，减少更改的规模并增加部署速度。
- en: A small change is less risky and easier to roll back if that's required.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 小的更改风险较小，如果需要，可以更容易地回滚。
- en: '**How does semantic versioning work?**'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**语义版本如何工作？**'
- en: 'In semantic versioning, versions have three numbers: a *Major* version number,
    a *Minor* version number, and a *Patch* version number. These are all separated
    by dots:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在语义版本中，版本有三个数字：*Major*版本号，*Minor*版本号和*Patch*版本号。它们之间都用点分隔：
- en: An increase in a Patch version only fixes bugs and security problems.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补丁版本的增加只修复错误和安全问题。
- en: An increase in a Minor version adds more features, but without backward-incompatible
    changes.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 次要版本的增加会增加更多功能，但不会引入向后不兼容的更改。
- en: An increase in a Major version produces backward-incompatible changes.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要版本的增加会产生不向后兼容的更改。
- en: '**What are the problems with semantic versioning for internal interfaces in
    a microservice architecture system?**'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**微服务架构系统中内部接口的语义版本控制存在哪些问题？**'
- en: Since deployments in microservices are very common, and backward compatibility
    is very important, the meaning of a *major* release becomes diluted. Also, most
    of the consumers of the microservices are internal, so implicit communication
    between versions is less important.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务中的部署非常常见，向后兼容性非常重要，因此*主要*发布的含义变得淡化。此外，大多数微服务的消费者是内部的，因此版本之间的隐式通信变得不那么重要。
- en: When releases become common, semantic versioning loses meaning since the objective
    is to continuously refine and improve the product, instead of marking big releases.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当发布变得常见时，语义版本控制失去了意义，因为目标是不断完善和改进产品，而不是标记大的发布。
- en: '**What are the advantages of adding a version endpoint?**'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加版本端点的优势是什么？**'
- en: 'Any consumer that uses a microservice can request its version in the same way
    they can make any other request: by using a RESTful call.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用微服务的消费者都可以以与进行任何其他请求相同的方式请求其版本：通过使用RESTful调用。
- en: '**How can we fix the dependency problem in this chapter''s code?**'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们如何解决本章代码中的依赖问题？**'
- en: The code in this chapter has a dependency problem between TO BE FILLED.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码存在依赖问题。
- en: '**What configuration variables should we store in a shared ConfigMap?**'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们应该在共享ConfigMap中存储哪些配置变量？**'
- en: We should store the configuration variables that are accessed by multiple microservices.
    Preemptively, we should store most of the configuration variables so that they
    can be reused.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该存储被多个微服务访问的配置变量。我们应该预先存储大部分配置变量，以便它们可以被重复使用。
- en: '**Describe the advantages and disadvantages of putting all the configuration
    variables into a single shared ConfigMap.**'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**描述将所有配置变量放入单个共享ConfigMap的优缺点。**'
- en: A single shared ConfigMap makes the configuration variables very explicit. It
    encourages everyone to reuse them and tell others what the configuration is used
    for in other microservices.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一个共享的ConfigMap使配置变量非常明确。它鼓励每个人重复使用它们，并告诉其他人配置用于其他微服务的用途。
- en: Changing the dependency of a microservice will trigger a restart, so changing
    a ConfigMap that acts as a dependency for everything will cause all the microservices
    in the cluster to restart, which is time-consuming.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 更改微服务的依赖将触发重新启动，因此更改作为一切依赖的ConfigMap将导致集群中的所有微服务重新启动，这是耗时的。
- en: Also, a single ConfigMap file can end up being quite big, and splitting it into
    several smaller ones can help us organize the data more efficiently.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，单个ConfigMap文件可能会变得相当大，将其拆分为几个较小的文件可以帮助我们更有效地组织数据。
- en: '**What''s the difference between a Kubernetes ConfigMap and a Kubernetes Secret?**'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Kubernetes ConfigMap和Kubernetes Secret有什么区别？**'
- en: Kubernetes Secrets are better protected against unintentional access. The direct
    access tools won't display the Secret in plain text. Access to Secrets also needs
    to be configured in a more explicit way. On the other hand, ConfigMaps can be
    configured in bulk, so a pod will be able to access all of the values that have
    been stored in the ConfigMap.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes Secrets更好地防止意外访问。直接访问工具不会以明文显示Secret。对Secret的访问也需要以更明确的方式进行配置。另一方面，ConfigMaps可以进行批量配置，因此pod将能够访问ConfigMap中存储的所有值。
- en: '**How can we change a Kubernetes Secret?**'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们如何更改Kubernetes Secret？**'
- en: We can change a Secret using `kubectl edit`, but it will need to be encoded
    in Base64 format.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`kubectl edit`更改Secret，但它需要以Base64格式进行编码。
- en: 'For example, to replace the `postgres-password` secret with the `someotherpassword` value,
    we can use the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要用以下代码替换`postgres-password`秘密为`someotherpassword`值：
- en: '[PRE2]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once restarted, our pods will be able to use the new Secret.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦重新启动，我们的pod将能够使用新的Secret。
- en: '**Imagine that, based on our configuration, we decided to change public_key.pub from
    a Secret to a ConfigMap. What changes do we have to make?**'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**假设基于我们的配置，我们决定将public_key.pub从Secret更改为ConfigMap。我们需要做哪些更改？**'
- en: 'We need to change the ConfigMap so that it includes the file in `configuration.yaml`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改ConfigMap，以便它包含`configuration.yaml`中的文件：
- en: '[PRE3]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note the indentation to delimitate the file. The `|` char marks a multiline
    string.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意缩进以界定文件。 `|`字符标记多行字符串。
- en: 'Then, in the `deployment.yaml` file, we need to change the source of the mount
    from a Secret to a ConfigMap:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`deployment.yaml`文件中，我们需要将挂载的来源从Secret更改为ConfigMap：
- en: '[PRE4]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Remember to apply these changes to the ConfigMap first so that they are available
    when the deployment files are applied.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 记得先将这些更改应用到ConfigMap中，以便在应用部署文件时它们是可用的。
- en: Note that this method creates an environment variable called `public_key.pub`,
    along with the content of the file, since it is applied as part of the `shared-config`
    ConfigMap. An alternative is to create an independent ConfigMap.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此方法创建了一个名为`public_key.pub`的环境变量，以及文件的内容，因为它作为`shared-config` ConfigMap的一部分应用。另一种方法是创建一个独立的ConfigMap。
- en: The Secret can be deleted after all the pods have been restarted.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有pod重新启动后，可以删除Secret。
- en: Chapter 12
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章
- en: '**Why is a leading architect convenient for a microservice architecture system?**'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么对于微服务架构系统来说，有一个领先的架构师很方便？**'
- en: Structuring a system in a microservice architecture allows us to create independent
    services that can be handled in parallel. These services still need to communicate
    with each other and cooperate.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中构建系统允许我们创建可以并行处理的独立服务。这些服务仍然需要相互通信和合作。
- en: Independent teams usually don't have a grasp of the big picture and tend to
    focus on their own projects. To help with the coordination and evolution of the
    system as a whole, independent teams need a leading architect who has a high-level
    overview of the system.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 独立团队通常无法把握全局，倾向于专注于自己的项目。为了协调和整体系统的发展，独立团队需要一个高层次概览系统的首席架构师。
- en: '**What is Conway''s Law?**'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**康威定律是什么？**'
- en: Conway's Law is an adage that says that software structures replicate the communication
    structures of the organization that writes it.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 康威定律是一句谚语，它说软件结构复制了编写它的组织的沟通结构。
- en: This implies that, to change the way the software is structured, the organization needs
    to change, which is a much more difficult task.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，要改变软件的结构，组织需要改变，这是一项更加困难的任务。
- en: To successfully design and evolve big systems, the organization needs to be
    taken into account and planned accordingly.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功设计和发展大型系统，组织需要考虑并相应地进行规划。
- en: '**How is technical debt introduced?**'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**技术债务是如何引入的？**'
- en: There are a lot of ways in which technical debt can be created.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务可以以许多方式产生。
- en: 'Normally, technical debt falls into one of the following four categories or
    a mix of them:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，技术债务可以分为以下四类或它们的混合：
- en: By developing too quickly without taking the time to analyze other options
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过过快地发展而没有花时间分析其他选项
- en: By making a compromise to shorten development time while knowing that the comprise
    will need to be fixed later
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过妥协缩短开发时间，同时知道这种妥协以后需要修复
- en: By not having a good enough understanding of the current system or tools, or
    having a lack of training or expertise
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过对当前系统或工具的了解不够充分，或者缺乏培训或专业知识
- en: By making incorrect assumptions regarding an external problem, thereby designing
    for something that doesn't necessarily need to be fixed
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过对外部问题做出错误假设，从而为不一定需要修复的东西设计
- en: '**Why is it important to create a culture so that we can work continuously
    to reduce technical debt?**'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么重要建立一种文化，以便我们可以持续减少技术债务？**'
- en: It's important to create a culture so that we can avoid *software rot*, which
    is the continuous decay of performance and reliability due to adding complexity
    to existing software. Unless addressing technical debt becomes a continuous process,
    the day-to-day pressure of making new releases means we won't be able to perform
    maintenance.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是建立一种文化，以避免*软件腐烂*，即由于向现有软件添加复杂性而导致性能和可靠性持续下降。除非解决技术债务成为一个持续的过程，否则日常发布的压力意味着我们将无法进行维护。
- en: '**Why is it important to document problems in releases and share them with
    the rest of the team?**'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么重要记录发布中的问题并与团队其他成员分享？**'
- en: This is important since every team can learn from the experience and solutions
    of others and improve their processes. This can also create an open culture where
    people aren't afraid of taking responsibility for their mistakes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为每个团队都可以从其他人的经验和解决方案中学习，并改进他们的流程。这也可以创造一种开放的文化，人们不会害怕对自己的错误负责。
- en: '**What is the main objective of a post-mortem meeting?**'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**事后总结会议的主要目标是什么？**'
- en: The main objective of a post-mortem meeting is to create follow-up tasks that
    fix the causes of an incident. To do so, we need to be as confident as possible
    that the root cause has been successfully detected (this is also the secondary
    objective).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 事后总结会议的主要目标是创建解决事故原因的后续任务。为此，我们需要尽可能确信已成功检测到根本原因（这也是次要目标）。
