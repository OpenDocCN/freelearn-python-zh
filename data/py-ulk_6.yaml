- en: Chapter 6. Test-Driven Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。测试驱动开发
- en: 'In this chapter, we will discuss some good concepts that are to be applied
    during testing. First, we will take a look at how we can create mock or stubs
    easily to test functionalities that are not present in the system. Then, we will
    cover how to write test cases with parameterization. Custom test runners can be
    of great help to write test utilities for a specific project. Then, we will cover
    how to test threaded applications, and utilize concurrent execution to decrease
    the overall time spent on test suite runs. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论一些在测试期间要应用的良好概念。首先，我们将看看我们如何可以轻松地创建模拟或存根来测试系统中不存在的功能。然后，我们将介绍如何编写参数化的测试用例。自定义测试运行器对于为特定项目编写测试实用程序非常有帮助。然后，我们将介绍如何测试线程化应用程序，并利用并发执行来减少测试套件运行的总时间。我们将涵盖以下主题：
- en: Mock for tests
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试用的Mock
- en: Parameterization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数化
- en: Creating custom test runners
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义测试运行器
- en: Testing threaded applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试线程化应用程序
- en: Running test cases in parallel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行运行测试用例
- en: Mock for tests
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试用的Mock
- en: '**Key 1: Mock what you do not have.**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键1：模拟你所没有的。**'
- en: When we are using test driven development, we have to write test cases for the
    components that rely on other components that are not written yet or take a lot
    of time to execute. This is close to impossible until we create mocks and stubs.
    In this scenario, stubs or mocks are very useful. We use a fake object instead
    of a real one to write the test case. This can be made very easy if we use tools
    that are provided by the language. For example, in the following code, we only
    have the interface for the worker class, and no real implementation of it. We
    want to test the `assign_if_free` function.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用测试驱动开发时，我们必须为依赖于尚未编写或执行时间很长的其他组件的组件编写测试用例。在我们创建模拟和存根之前，这几乎是不可行的。在这种情况下，存根或模拟非常有用。我们使用一个假对象而不是真实对象来编写测试用例。如果我们使用语言提供的工具，这可以变得非常简单。例如，在以下代码中，我们只有工作类接口，没有其实施。我们想测试`assign_if_free`函数。
- en: 'Instead of writing any stub ourselves, we use the `create_autospec` function
    to create a mock object from the definition of the Worker abstract class. We also
    set up a return value for the function call of checking whether worker was busy
    or not:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是自己编写任何存根，而是使用`create_autospec`函数从Worker抽象类的定义中创建一个模拟对象。我们还为检查工作是否忙碌的函数调用设置了返回值：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To set up return values, we can also use functions to return conditional responses,
    as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置返回值，我们也可以使用函数来返回条件响应，如下所示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also set methods to raise exceptions using the `side_effect` attribute
    of mock, as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用mock的`side_effect`属性来设置方法抛出异常，如下所示：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Another use is to check whether a method was called and with what arguments,
    as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用途是检查方法是否被调用以及调用时使用的参数，如下所示：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Parameterization
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数化
- en: '**Key 2: Manageable inputs to tests.**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键2：可管理的测试输入。**'
- en: 'For the tests where we have to test various inputs for the same functionality
    or transformations, we have to write test cases to cover test different inputs.
    We can use parameterization here. In this way, we invoke the same test case with
    different inputs, hence, decreasing time and errors that are associated with it.
    Newer Python versions 3.4 or higher include a very useful method, `subTest` in
    `unittest.TestCase`, which makes it very easy to add parameterized tests. In the
    test output, please note that the parameterized values are also available:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们必须测试同一功能或转换的多种输入的测试，我们必须编写测试用例来覆盖不同的输入。在这里，我们可以使用参数化。这样，我们可以用不同的输入调用相同的测试用例，从而减少与它相关的时间和错误。较新的Python版本3.4或更高版本包括一个非常有用的方法，`unittest.TestCase`中的`subTest`，这使得添加参数化测试变得非常容易。在测试输出中，请注意参数化值也是可用的：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will give us the following output:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This also means that if we needed the *currying* that is running tests for
    all combinations of inputs, then this can be done very easily. We have to write
    a function that returns curried arguments, and then we can use `subTest` to have
    mini tests run with curried arguments. This way it is very easy to explain to
    new people on the team how to write test cases with minimum language jargon, as
    follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着，如果我们需要运行所有输入组合的*柯里化*测试，那么这可以非常容易地完成。我们必须编写一个返回柯里化参数的函数，然后我们可以使用`subTest`来运行带有柯里化参数的迷你测试。这样，向团队中的新成员解释如何用最少的语言术语编写测试用例就变得非常容易，如下所示：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will give us the following output:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'But, this works only for new versions of Python. For the older versions, we
    can perform similar work using dynamism of language. We can implement this feature
    ourselves, as shown in the following code snippet. We use a decorator to stick
    the parameterize value to test case, and then in `metaclass`, we create a new
    wrapper function that calls the original function with the required parameters:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这仅适用于Python的新版本。对于旧版本，我们可以利用语言的动态性执行类似的工作。我们可以自己实现这个功能，如下面的代码片段所示。我们使用装饰器将参数化值粘接到测试用例上，然后在`metaclass`中创建一个新的包装函数，该函数使用所需的参数调用原始函数：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creating custom test runners
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义测试运行器
- en: '**Key 3: Getting information from test system.**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键3：从测试系统中获取信息。**'
- en: 'The flow of unit test is like this: `unittest TestProgram` in `unittest.main`
    is the primary object that runs everything. Test cases are collected by test discovery
    or by loading modules that were passed via command line. If no test runner is
    specified to the main function, by default, `TextTestRunner` is used. Test suite
    is passed to the runner''s run function to give back a `TestResult` object.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的流程如下：`unittest.TestProgram`在`unittest.main`中是运行一切的主要对象。测试用例通过测试发现或通过命令行传递的模块加载来收集。如果没有指定给主函数的测试运行器，则默认使用`TextTestRunner`。测试套件传递给运行器的`run`函数，以返回一个`TestResult`对象。
- en: The custom test runners are a great way to get information in a specific output
    format, from the test system, manage run sequence, store results in a database,
    or create new features for project needs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义测试运行器是获取特定输出格式信息、管理运行顺序、将结果存储在数据库中或为项目需求创建新功能的好方法。
- en: 'Let''s now take a look at an example to create an XML output of test cases,
    you may need something like this to integrate with continuous integration systems,
    which are only able to work with some XML format. As in the following code snippet
    `XMLTestResult` is the class that gives the test result in the XML format. The
    `TsRunner` class test runner then puts the same information on the `stdout` stream.
    We also add the time taken for the test case as well. The `XMLify` class is sending
    information to test the `TsRunner` runner class in an XML format. The `XMLRunner`
    class is putting this information in the XML format on `stdout`, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个例子，创建测试用例的XML输出，你可能需要这样的东西来与只能处理某些XML格式的持续集成系统集成。如下面的代码片段所示，`XMLTestResult`是提供XML格式测试结果的类。`TsRunner`类测试运行器然后将相同的信息放在`stdout`流上。我们还添加了测试用例所需的时间。`XMLify`类以XML格式向测试`TsRunner`运行器类发送信息。`XMLRunner`类将此信息以XML格式放在`stdout`上，如下所示：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s assume that we use this `XMLRunner` on the test cases, as shown in the
    following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在测试用例上使用此`XMLRunner`，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will get the following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Testing threaded applications
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试线程应用程序
- en: '**Key 4: Make threaded application tests like nonthreaded ones.**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键4：使线程应用程序测试类似于非线程化测试。**'
- en: 'My experience with testing on threaded application is to perform the following
    actions:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我在测试线程应用程序方面的经验是执行以下操作：
- en: Try to make the threaded application as nonthreaded as possible for tests. By
    this, I mean that group logic that is nonthreaded in one code segment. Do not
    try to test business logic with thread logic. Try to keep them separate.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使线程应用程序在测试中尽可能非线程化。我的意思是，在一个代码段中，将非线程化的逻辑分组。不要尝试用线程逻辑测试业务逻辑。尽量将它们分开。
- en: Work with as little global state as possible. Functions should pass around objects
    that are needed to work.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能地使用最少的全局状态。函数应该传递所需工作的对象。
- en: Try to make queues of tasks to synchronize them. Instead of creating producer
    consumer chains yourself, first try to use queues.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试创建任务队列以同步它们。而不是自己创建生产者消费者链，首先尝试使用队列。
- en: Also note that sleep statements make test cases run slower. If you add up sleeps
    in the code for more than 20 places, the whole test suite starts to become slow.
    Threaded code should pass on information with events and notifications rather
    than a while loop checking some condition.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还要注意，sleep语句会使测试用例运行得更慢。如果你在代码中添加了超过20个sleep，整个测试套件开始变慢。线程代码应该通过事件和通知传递信息，而不是通过while循环检查某些条件。
- en: 'The `_thread` module in Python 2 and the `_thread` module in Python 3 are a
    big help as you can start functions as threads, shown as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2中的`_thread`模块和Python 3中的`_thread`模块非常有用，因为你可以以线程的形式启动函数，如下所示：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Running test cases in parallel
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行运行测试用例
- en: '**Key 5: Faster test suite execution**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键5：加快测试套件执行速度**'
- en: 'When we have accumulated a lot of test cases in the project, it takes a lot
    of time to execute all of the test cases. We have to make the test run in parallel
    to decrease the time that is taken overall. In this case, the `py.test` testing
    framework does a fantastic job of simplifying the ability to run tests in parallel.
    To make this work, we have to first install the `py.test` library, and then use
    its runner to run the test cases. The `py.test` library has an `xdist` plugin,
    which adds the capability to run tests in parallel, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在项目中积累了大量测试用例时，执行所有测试用例需要花费很多时间。我们必须使测试并行运行以减少整体所需的时间。在这种情况下，`py.test`测试框架在简化并行运行测试的能力方面做得非常出色。为了使这成为可能，我们首先需要安装`py.test`库，然后使用其运行器来运行测试用例。`py.test`库有一个`xdist`插件，它增加了并行运行测试的能力，如下所示：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you want to dive deeper into this topic, you can refer to [https://pypi.python.org/pypi/pytest-xdist](https://pypi.python.org/pypi/pytest-xdist).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解这个主题，可以参考[https://pypi.python.org/pypi/pytest-xdist](https://pypi.python.org/pypi/pytest-xdist)。
- en: Summary
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Testing is very important in creating a stable application. In this chapter,
    we discussed how we mock the objects to create an easy separation on concerns
    to test different components. Parameterization is very useful to test various
    transformation logics. The most important take away is to try to create functionalities
    that are needed by your project as test utilities. Try to stick with the `unittest`
    module. Use other libraries for parallel execution as they support the `unittest`
    tests as well.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建稳定的应用程序中，测试非常重要。在本章中，我们讨论了如何模拟对象以创建易于分离关注点的环境来测试不同的组件。参数化对于测试各种转换逻辑非常有用。最重要的经验是尝试创建项目所需的测试实用程序功能。尽量坚持使用`unittest`模块。使用其他库进行并行执行，因为它们也支持`unittest`测试。
- en: In the next chapter, we will cover optimization techniques for Python.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Python的优化技术。
