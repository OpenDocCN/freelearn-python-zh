- en: Chapter 3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章
- en: 'Project 1.1: Data Acquisition Base Application'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 1.1：数据采集基础应用
- en: 'The beginning of the data pipeline is acquiring the raw data from various sources.
    This chapter has a single project to create a **command-line** **application**
    (**CLI**) that extracts relevant data from files in CSV format. This initial application
    will restructure the raw data into a more useful form. Later projects (starting
    in [*Chapter** 9*](ch013.xhtml#x1-2080009), [*Project 3.1: Data Cleaning Base*
    *Application*](ch013.xhtml#x1-2080009)) will add features for cleaning and validating
    the data.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据管道的开始是从各种来源获取原始数据。本章有一个单一的项目，创建一个**命令行** **应用程序**（**CLI**），从CSV格式的文件中提取相关数据。这个初始应用程序将把原始数据重新结构化为更有用的形式。后续的项目（从第9章开始）将添加数据清理和验证的功能。
- en: 'This chapter’s project covers the following essential skills:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目涵盖了以下基本技能：
- en: Application design in general. This includes an object-oriented design and the
    SOLID design principles, as well as functional design.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用应用程序设计。这包括面向对象的设计和SOLID设计原则，以及功能设计。
- en: A few CSV file processing techniques. This is a large subject area, and the
    project focuses on restructuring source data into a more usable form.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些CSV文件处理技术。这是一个很大的主题领域，项目重点是重新构建源数据为更可用的形式。
- en: CLI application construction.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行应用程序构建。
- en: Creating acceptance tests using the Gherkin language and **behave** step definitions.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gherkin语言和**behave**步骤定义创建验收测试。
- en: Creating unit tests with mock objects.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模拟对象创建单元测试。
- en: We’ll start with a description of the application, and then move on to talk
    about the architecture and construction. This will be followed by a detailed list
    of deliverables.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从对应用程序的描述开始，然后转到讨论架构和构建。这将随后是一个详细的交付成果列表。
- en: 3.1 Description
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 描述
- en: Analysts and decision-makers need to acquire data for further analysis. In many
    cases, the data is available in CSV-formatted files. These files may be extracts
    from databases or downloads from web services.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 分析师和决策者需要获取数据以进行进一步分析。在许多情况下，数据以CSV格式文件的形式可用。这些文件可能是数据库的提取或从网络服务下载的。
- en: For testing purposes, it’s helpful to start with something relatively small.
    Some of the Kaggle data sets are very, very large, and require sophisticated application
    design. One of the most fun small data sets to work with is Anscombe’s Quartet.
    This can serve as a test case to understand the issues and concerns in acquiring
    raw data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，从相对较小的事物开始是有帮助的。一些Kaggle数据集非常大，需要复杂的应用程序设计。其中最有趣的小数据集之一是Anscombe的四重奏。这可以作为测试案例来理解获取原始数据的问题和关注点。
- en: 'We’re interested in a few key features of an application to acquire data:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对应用程序获取数据的一些关键特性感兴趣：
- en: When gathering data from multiple sources, it’s imperative to convert it to
    a common format. Data sources vary, and will often change with software upgrades.
    The acquisition process needs to be flexible with respect to data sources and
    avoid assumptions about formats.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从多个来源收集数据时，将其转换为通用格式至关重要。数据来源多种多样，并且随着软件升级通常会发生变化。采集过程需要根据数据来源的灵活性，避免对格式的假设。
- en: A CLI application permits a variety of automation possibilities. For example,
    a CLI application can be ”wrapped” to create a web service. It can be run from
    the command line manually, and it can be automated through enterprise job scheduling
    applications.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行应用程序允许各种自动化可能性。例如，命令行应用程序可以被“包装”以创建一个网络服务。它可以手动从命令行运行，也可以通过企业作业调度应用程序进行自动化。
- en: The application must be extensible to reflect source changes. In many cases,
    enterprise changes are not communicated widely enough, and data analysis applications
    discover changes ”the hard way” — a source of data suddenly includes unexpected
    or seemingly invalid values.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序必须可扩展以反映源变化。在许多情况下，企业变更的沟通并不充分，数据分析应用程序通过“艰难的方式”发现变化——数据源突然包括意外的或看似无效的值。
- en: 3.1.1 User experience
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 用户体验
- en: The **User Experience** (**UX**) will be a command-line application with options
    to fine-tune the data being gathered. This essential UX pattern will be used for
    many of this book’s projects. It’s flexible and can be made to run almost anywhere.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户体验**（**UX**）将是一个带有调整收集数据选项的命令行应用程序。这种基本的UX模式将用于本书的许多项目。它很灵活，几乎可以在任何地方运行。'
- en: 'Our expected command line should look something like the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望的命令行应该看起来像以下这样：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `-o`` quartet` argument specifies a directory into which the resulting extracts
    are written. The source file contains four separate series of data. Each of the
    series can be given an unimaginative name like `quartet/series_1.json`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`-o` `quartet` 参数指定了结果提取写入的目录。源文件包含四个独立的数据系列。每个系列可以给一个不太引人注目的名字，如 `quartet/series_1.json`。'
- en: The positional argument, `Anscombe_quartet_data.csv`, is the name of the downloaded
    source file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 位置参数 `Anscombe_quartet_data.csv` 是下载的源文件名。
- en: While there’s only one file – at the present time – a good design will work
    with multiple input files and multiple source file formats.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然目前只有一个文件，但良好的设计将能够处理多个输入文件和多种源文件格式。
- en: In some cases, a more sophisticated ”dashboard” or ”control panel” application
    might be desirable as a way to oversee the operation of the data acquisition process.
    The use of a web-based API can provide a very rich interactive experience. An
    alternative is to use tools like **rich** or **Textual** to build a small text-based
    display. Either of these choices should be built as a wrapper that executes the
    essential CLI application as a subprocess.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，一个更复杂的“仪表板”或“控制面板”应用可能更受欢迎，作为监控数据采集过程的一种方式。使用基于Web的API可以提供非常丰富的交互体验。另一种选择是使用像
    **rich** 或 **Textual** 这样的工具来构建一个小型的基于文本的显示。这两种选择都应构建为执行基本CLI应用的子进程的包装器。
- en: Now that we’ve seen an overview of the application’s purpose and UX, let’s take
    a look at the source data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了应用的目的和用户体验概述，让我们来看看源数据。
- en: 3.1.2 About the source data
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 关于源数据
- en: 'Here’s the link to the dataset we’ll be using:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将使用的数据集链接：
- en: '[https://www.kaggle.com/datasets/carlmcbrideellis/data-anscombes-quartet](https://www.kaggle.com/datasets/carlmcbrideellis/data-anscombes-quartet)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.kaggle.com/datasets/carlmcbrideellis/data-anscombes-quartet](https://www.kaggle.com/datasets/carlmcbrideellis/data-anscombes-quartet)'
- en: You’ll need to register with Kaggle to download this data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要注册Kaggle才能下载这些数据。
- en: The Kaggle URL presents a page with information about the CSV-formatted file.
    Clicking the **Download** button will download the small file of data to your
    local computer.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Kaggle URL 提供了一个包含CSV格式文件信息的页面。点击 **下载** 按钮将数据小文件下载到你的本地计算机。
- en: The data is available in this book’s GitHub repository’s `data` folder, also.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 数据也存在于本书GitHub仓库的 `data` 文件夹中。
- en: Once the data is downloaded, you can open the `Anscombe_quartet_data.csv` file
    to inspect the raw data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 数据下载后，你可以打开 `Anscombe_quartet_data.csv` 文件来检查原始数据。
- en: The file contains four series of (*x,y*) pairs in each row. We can imagine each
    row as having [(*x*[1]*,y*[1])*,*(*x*[2]*,y*[2])*,*(*x*[3]*,y*[3])*,*(*x*[4]*,y*[4])].
    It is, however, compressed, as we’ll see below.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 文件包含每行四个 (*x,y*) 对的数据系列。我们可以想象每一行有 [(*x*[1]*,y*[1])*,*(*x*[2]*,y*[2])*,*(*x*[3]*,y*[3])*,*(*x*[4]*,y*[4])]。然而，它被压缩了，如下所示。
- en: We might depict the idea behind this data with an entity-relationship diagram
    as shown in [*Figure 3.1*](#3.1).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个实体关系图来描述这一数据背后的理念，如图 [*图3.1*](#3.1) 所示。
- en: '![Figure 3.1: Notional entity-relationship diagram ](img/file8.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1：概念实体关系图](img/file8.jpg)'
- en: 'Figure 3.1: Notional entity-relationship diagram'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：概念实体关系图
- en: 'Interestingly, the data is not organized as four separate (*x,y*) pairs. The
    downloaded file is organized as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，数据并非以四个独立的 (*x,y*) 对的形式组织。下载的文件组织如下：
- en: '![[x1,2,3,y1,y2,y3,x4,y4] ](img/file9.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![[x1,2,3,y1,y2,y3,x4,y4]](img/file9.jpg)'
- en: We can depict the actual source entity type in an ERD, as shown in [*Figure
    3.2*](#3.2).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在ERD中描述实际的源实体类型，如图 [*图3.2*](#3.2) 所示。
- en: '![Figure 3.2: Source entity-relationship diagram ](img/file10.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2：源实体关系图](img/file10.jpg)'
- en: 'Figure 3.2: Source entity-relationship diagram'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：源实体关系图
- en: One part of this application’s purpose is to disentangle the four series into
    separate files. This forces us to write some transformational processing to rearrange
    each row’s data elements into four separate data sets.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本应用的一部分目的是将四个系列数据分开到不同的文件中。这迫使我们编写一些转换处理程序，以重新排列每一行的数据元素到四个独立的数据集中。
- en: 'The separate series can then be saved into four separate files. We’ll look
    more deeply at the details of creating the separate files for a separate project
    in [*Chapter** 11*](ch015.xhtml#x1-26400011), [*Project 3.7: Interim Data Persistence*](ch015.xhtml#x1-26400011).
    For this project, any file format for the four output files will do nicely; ND
    JSON serialization is often ideal.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将单独的系列保存到四个单独的文件中。我们将在[*第11章*](ch015.xhtml#x1-26400011)、[*项目3.7：临时数据持久化*](ch015.xhtml#x1-26400011)中更深入地探讨为单独项目创建单独文件的细节。对于这个项目，四个输出文件可以采用任何文件格式；ND
    JSON序列化通常是理想的。
- en: We encourage you to take a look at the file before moving on to consider how
    it needs to be transformed into distinct output files.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励你在继续考虑如何将其转换为不同的输出文件之前查看该文件。
- en: Given this compressed file of source data, the next section will look at the
    expanded output files. These will separate each series to make them easier to
    work with.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个源数据的压缩文件，下一节将查看扩展的输出文件。这些文件将分离每个系列，以便更容易处理。
- en: 3.1.3 About the output data
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.3 关于输出数据
- en: 'The ND JSON file format is described in [http://ndjson.org](http://ndjson.org)
    and [https://jsonlines.org](https://jsonlines.org). The idea is to put each individual
    entity into a JSON document written as a single physical line. This fits with
    the way the Python `json.dumps()` function works: if no value is provided for
    the `indent` parameter (or if the value is `indent=None`), the text will be as
    compact as possible.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ND JSON文件格式在[http://ndjson.org](http://ndjson.org)和[https://jsonlines.org](https://jsonlines.org)中描述。想法是将每个单独的实体放入一个作为单行编写的JSON文档中。这与Python
    `json.dumps()` 函数的工作方式相符：如果没有为`indent`参数提供值（或者如果值为`indent=None`），文本将尽可能紧凑。
- en: 'The `series_1.json` output file should start like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`series_1.json` 输出文件应该像这样开始：'
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Each row is a distinct, small JSON document. The row is built from a subset
    of fields in the input file. The values are strings: we won’t be attempting any
    conversions until the cleaning and validating projects in [*Chapter** 9*](ch013.xhtml#x1-2080009),
    [*Project 3.1:* *Data Cleaning Base Application*](ch013.xhtml#x1-2080009).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都是一个独特的、小的JSON文档。该行由输入文件中的字段子集构建而成。值是字符串：我们不会在[*第9章*](ch013.xhtml#x1-2080009)、[*项目3.1：数据清洗基础应用程序*](ch013.xhtml#x1-2080009)中的清理和验证项目之前尝试任何转换。
- en: We’ll require the user who runs this application to create a directory for the
    output and provide the name of the directory on the command line. This means the
    application needs to present useful error messages if the directory doesn’t actually
    exist. The `pathlib.Path` class is very helpful for confirming a directory exists.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要求运行此应用程序的用户创建输出目录并在命令行上提供目录名称。这意味着如果目录实际上不存在，应用程序需要显示有用的错误消息。`pathlib.Path`
    类对于确认目录存在非常有帮助。
- en: Further, the application should be cautious about overwriting any existing files.
    The `pathlib.Path` class is very helpful for confirming a file already exists.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，应用程序应谨慎覆盖任何现有文件。`pathlib.Path` 类对于确认文件是否已存在非常有帮助。
- en: This section has looked at the input, processing, and output of this application.
    In the next section, we’ll look at the overall architecture of the software.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了此应用程序的输入、处理和输出。在下一节中，我们将探讨软件的整体架构。
- en: 3.2 Architectural approach
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 架构方法
- en: We’ll take some guidance from the C4 model ( [https://c4model.com](https://c4model.com))
    when looking at our approach.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在审视我们的方法时，我们将借鉴C4模型（[https://c4model.com](https://c4model.com)）的一些指导。
- en: '**Context**: For this project, a context diagram would show a user extracting
    data from a source. You may find it helpful to draw this diagram.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**：对于这个项目，上下文图将显示用户从源提取数据。你可能觉得绘制这个图会有所帮助。'
- en: '**Containers**: This project will run on the user’s personal computer. As with
    the context, the diagram is small, but some readers may find it helpful to take
    the time to draw it.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**：此项目将在用户的个人计算机上运行。与上下文一样，图很小，但一些读者可能觉得花时间绘制它会有所帮助。'
- en: '**Components**: We’ll address these below.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**：我们将在下面讨论这些问题。'
- en: '**Code**: We’ll touch on this to provide some suggested directions.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码**：我们将简要介绍一些建议的方向。'
- en: 'We can decompose the software architecture into these two important components:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将软件架构分解为这两个重要组件：
- en: '`model`: This module has definitions of target objects. In this project, there’s
    only a single class here.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model`：此模块包含目标对象的定义。在这个项目中，这里只有一个类。'
- en: '`extract`: This module will read the source document and creates model objects.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图3.3：获取应用程序模型
- en: 'Additionally, there will need to be these additional functions:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`extract`：此模块将读取源文档并创建模型对象。'
- en: A function for parsing the command-line options.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于解析命令行选项的函数。
- en: A `main()` function to parse options and do the file processing.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于解析选项和执行文件处理的`main()`函数。
- en: 'As suggested in [*Chapter** 1*](ch005.xhtml#x1-170001), [*Project Zero: A Template
    for Other Projects*](ch005.xhtml#x1-170001), the initialization of logging will
    often look like the following example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还需要这些额外的函数：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The idea is to write the `main()` function in a way that maximizes reuse. Avoiding
    logging initialization means other applications can more easily import this application’s
    `main()` function to reuse the data acquisition features.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是编写`main()`函数以最大化重用。避免日志初始化意味着其他应用程序可以更容易地导入此应用程序的`main()`函数以重用数据获取功能。
- en: Initializing logging within the `main()` function can undo previous logging
    initialization. While there are ways to have a composite application tolerate
    each `main()` function doing yet another initialization of logging, it seems simpler
    to refactor this functionality outside the important processing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中初始化日志可能会撤销之前的日志初始化。虽然有一些方法可以让复合应用程序容忍每个`main()`函数进行另一次日志初始化，但将此功能重构到重要处理之外似乎更简单。
- en: For this project, we’ll look at two general design approaches for the model
    and extract components. We’ll utilize this opportunity to highlight the importance
    of adhering to SOLID design principles.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将探讨模型和提取组件的两种通用设计方法。我们将利用这个机会来强调遵循SOLID设计原则的重要性。
- en: First, we’ll show an object-oriented design using class definitions. After that,
    we’ll show a functional design, using only functions and stateless objects.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 未在图中显示的是其他三个子类，它们使用不同的列对从四个系列中创建`XYPair`对象。
- en: 3.2.1 Class design
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 类设计
- en: One possible structure for the classes and functions of this application is
    shown in [*Figure 3.3*](#3.3).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`csv.DictReader`，源将从`list[str]`变为
- en: '![Figure 3.3: Acquisition Application Model ](img/file11.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: 我们已将此更改所需的修订作为您的设计工作的一部分。
- en: 'Figure 3.3: Acquisition Application Model'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，似乎使用`csv.DictReader`是一个更好的选择。如果CSV文件的第一行没有名称，可以提供列名。
- en: The `model` module contains a single class definition for the raw `XYPair`.
    Later, this is likely to expand and change. For now, it can seem like over-engineering.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`model`模块包含一个用于原始`XYPair`的单个类定义。稍后，这可能会扩展和改变。目前，它可能看起来像是过度设计。'
- en: The `acquisition` module contains a number of classes that collaborate to build
    `XYPair` objects for any of the four series. The abstract `PairBuilder` class
    defines the general features of creating an `XYPair` object.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`acquisition`模块包含多个类，它们协同工作以构建任何四个系列中的`XYPair`对象。抽象的`PairBuilder`类定义了创建`XYPair`对象的一般特性。'
- en: Each subclass of the `PairBuilder` class has a slightly different implementation.
    Specifically, the `Series1Pair` class has a `from_row()` method that assembles
    a pair from the *x*[1,2,3] and *y*[1] values. Not shown in the diagram are the
    three other subclasses that use distinct pairs of columns to create `XYPair` objects
    from the four series.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`PairBuilder`类的每个子类都有略微不同的实现。具体来说，`Series1Pair`类有一个`from_row()`方法，它从*x*[1,2,3]和*y*[1]值组装一个对。'
- en: The diagram and most of the examples here use `list[str]` as the type for a
    row from a CSV reader.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的大部分图示和示例使用`list[str]`作为CSV读取器中一行的类型。
- en: If a `csv.DictReader` is used, the source changes from `list[str]` to
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将展示一个使用类定义的对象式设计。之后，我们将展示一个仅使用函数和无状态对象的功能式设计。
- en: '`dict[str,`` str]`. This small, but important, change will ripple throughout
    the examples.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第1章**](ch005.xhtml#x1-170001)中建议的[*项目零：其他项目的模板*](ch005.xhtml#x1-170001)，日志初始化通常如下所示：
- en: In many cases, it seems like a `csv.DictReader` is a better choice. Column names
    can be provided if the CSV file does not have names in the first row.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本应用程序的类和函数的一个可能结构如图[*图3.3*](#3.3)所示。
- en: We’ve left the revisions needed for this change as part of the design work for
    you.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict[str, str]`。这个虽小但重要的变化将在所有示例中产生连锁反应。'
- en: The overall `Extract` class embodies the various algorithms for using an instance
    of the `PairBuilder` class and a row of source data to build `XYPair` instances.
    The `build_pair(list[str])`` ->`` XYPair` method makes a single item from a row
    parsed from a CSV file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 整个`Extract`类体现了使用`PairBuilder`类的一个实例和一行源数据来构建`XYPair`实例的各种算法。`build_pair(list[str])`
    -> `XYPair`方法从CSV文件解析的一行中提取单个项目。
- en: The job of the `main()` function is to create instances of each of the four
    `PairBuilder` subclasses. These instances are then used to create four instances
    of the `Extract` class. These four `Extract` objects can then build four `XYPair`
    objects from each source row.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数的职责是创建四个`PairBuilder`子类的实例。然后，这些实例被用来创建四个`Extract`类的实例。这四个`Extract`对象可以构建来自每个源行的四个`XYPair`对象。'
- en: The `dataclass.asdict()` function can be used to convert an `XYPair` object
    into a `dict[str,`` str]` object. This can be serialized by `json.dumps()` and
    written to an appropriate output file. This conversion operation seems like a
    good choice for a method in the abstract `PairBuilder` class. This can be used
    to write an `XYPair` object to an open file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`dataclass.asdict()`函数将`XYPair`对象转换为`dict[str, str]`对象。这可以通过`json.dumps()`序列化并写入适当的输出文件。这种转换操作似乎是一个很好的选择，可以在抽象的`PairBuilder`类的方法中实现。这可以用来将`XYPair`对象写入打开的文件。
- en: The top-level functions, `main()` and `get_options()`, can be placed in a separate
    module, named `acquisition`. This module will import the various class definitions
    from the `model` and `csv_extract` modules.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层函数`main()`和`get_options()`可以放在一个名为`acquisition`的单独模块中。此模块将从`model`和`csv_extract`模块导入各种类定义。
- en: It’s often helpful to review the SOLID design principles. In particular, we’ll
    look closely at the **Dependency Inversion principle**.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 审查SOLID设计原则通常很有帮助。特别是，我们将仔细研究**依赖倒置原则**。
- en: 3.2.2 Design principles
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 设计原则
- en: We can look at the SOLID design principles to be sure that the object-oriented
    design follows those principles.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看SOLID设计原则来确保面向对象设计遵循这些原则。
- en: '**Single Responsibility**: Each of the classes seems to have a single responsibility.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责**：每个类似乎只有一个职责。'
- en: '**Open-Closed**: Each class seems open to extension by adding subclasses.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭原则**：每个类似乎都可以通过添加子类来扩展。'
- en: '**Liskov Substitution**: The `PairBuilder` class hierarchy follows this principle
    since each subclass is identical to the parent class.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换**：`PairBuilder`类层次结构遵循此原则，因为每个子类都与父类相同。'
- en: '**Interface Segregation**: The interfaces for each class are minimized.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离**：每个类的接口都进行了最小化。'
- en: '**Dependency Inversion**: There’s a subtle issue regarding dependencies among
    classes. We’ll look at this in some detail.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖倒置**：关于类之间依赖的问题很微妙。我们将对此进行一些详细的研究。'
- en: One of the SOLID design principles suggests avoiding tight coupling between
    the `PairBuilder` subclasses and the `XYPair` class. The idea would be to provide
    a protocol (or interface) for the `XYPair` class. Using the protocol in type annotations
    would permit any type that implemented the protocol to be provided to the class.
    Using a protocol would break a direct dependency between the `PairBuilder` subclasses
    and the `XYPair` class.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID设计原则之一建议避免`PairBuilder`子类和`XYPair`类之间的紧密耦合。想法是提供一个`XYPair`类的协议（或接口）。在类型注解中使用协议将允许提供实现了协议的任何类型给类。使用协议将打破`PairBuilder`子类和`XYPair`类之间的直接依赖。
- en: This object-oriented design issue surfaces often, and generally leads to drawn-out,
    careful thinking about the relationships among classes and the SOLID design principles.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个面向对象设计问题经常出现，通常会导致对类之间的关系和SOLID设计原则进行长时间的、仔细的思考。
- en: 'We have the following choices:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下几种选择：
- en: Have a direct reference to the `XYPair` class inside the `PairBuilder` class.
    This would be `def`` from_row(row:`` list[str])`` ->`` XYPair:`. This breaks the
    Dependency Inversion principle.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`PairBuilder`类内部直接引用`XYPair`类。这将违反依赖倒置原则。
- en: Use `Any` as the type annotation. This would be `def`` from_row(row:`` list[str])`` ->`` Any:`.
    This makes the type hints less informative.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用`Any`作为类型注解。这将`def from_row(row: list[str]) -> Any:`。这使得类型注解不那么信息丰富。'
- en: Attempt to create a protocol for the resulting type, and use this in the type
    hints.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试为结果类型创建一个协议，并在类型注解中使用它。
- en: Introduce a type alias that (for now) only has one value. In future expansions
    of the `model` module, additional types might be introduced.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入一个类型别名，目前只包含一个值。在 `model` 模块未来的扩展中，可能会引入其他类型。
- en: 'The fourth alternative gives us the flexibility we need for type annotation
    checking. The idea is to include a type alias like the following in the `model`
    module:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第四种替代方案为我们提供了所需的类型注解检查的灵活性。想法是在 `model` 模块中包含一个类似以下的类型别名：
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As alternative classes are introduced, the definition of `RawData` can be expanded
    to include the alternatives. This might evolve to look like the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 随着替代类的引入，`RawData` 的定义可以扩展以包含这些替代项。这可能会演变成以下形式：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This permits extension to the `PairBuilder` subclasses as the `model` module
    evolves. The `RawData` definition needs to be changed as new classes are introduced.
    Annotation-checking tools like **mypy** cannot spot the invalid use of any of
    the classes that comprise the alternative definitions of the `RawData` type alias.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许在 `model` 模块演变过程中扩展到 `PairBuilder` 子类。随着新类的引入，需要更改 `RawData` 定义。注解检查工具如 **mypy**
    无法检测到 `RawData` 类型别名替代定义中任何类的无效使用。
- en: Throughout the rest of the application, classes and functions can use `RawData`
    as an abstract class definition. This name represents a number of alternative
    definitions, any one of which might be used at run-time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的其余部分，类和函数可以使用 `RawData` 作为抽象类定义。这个名字代表了许多替代定义，其中任何一个都可能在使用时被使用。
- en: 'With this definition of `RawData`, the `PairBuilder` subclasses can use a definition
    of the following form:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种 `RawData` 定义，`PairBuilder` 子类可以使用以下形式的定义：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A similar analysis holds for the `main()` function. This can be directly tied
    to the `Extract` class and the various subclasses of the `PairBuilder` class.
    It’s very important for these classes to be injected at run time, generally based
    on command-line arguments.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `main()` 函数，也有类似的结论。这可以直接与 `Extract` 类以及 `PairBuilder` 类的各种子类相关联。在运行时，基于命令行参数注入这些类非常重要。
- en: 'For now, it’s easiest to provide the class names as default values. A function
    like the following might be used to get options and configuration parameters:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，最简单的方法是提供类名作为默认值。以下函数可能用于获取选项和配置参数：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `defaults` namespace is provided as an argument value to the `ArgumentParser.parse_args()`
    method. This set of defaults serves as a kind of dependency injection throughout
    the application. The `main` function can use these class names to build an instance
    of the given extract class, and then process the given source files.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaults` 命名空间作为 `ArgumentParser.parse_args()` 方法的参数值提供。这个默认值集合在整个应用程序中充当一种依赖注入。`main`
    函数可以使用这些类名构建给定提取类的实例，然后处理给定的源文件。'
- en: A more advanced CLI could provide options and arguments to tailor the class
    names. For more complex applications, these class names would be read from a configuration
    file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的 CLI 可以提供选项和参数来定制类名。对于更复杂的应用程序，这些类名将来自配置文件。
- en: An alternative to the object-oriented design is a functional design. We’ll look
    at that alternative in the next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象设计的替代方案是函数式设计。我们将在下一节中探讨这个替代方案。
- en: 3.2.3 Functional design
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 函数式设计
- en: The general module structure shown in [*Class design*](#x1-620001) applies to
    a functional design also. The `model` module with a single class definition is
    also a part of a functional design; this kind of module with a collection of dataclass
    definitions is often ideal.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*类设计*](#x1-620001) 部分中显示的一般模块结构也适用于函数式设计。具有单个类定义的 `model` 模块也是函数式设计的一部分；这种包含数据类定义集合的模块通常是理想的。
- en: As noted above in the [*Design principles*](#x1-630002) section, the `model`
    module is best served by using a type variable, `RawData`, as a placeholder for
    any additional types that may be developed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述在 [*设计原则*](#x1-630002) 部分，`model` 模块最好通过使用类型变量 `RawData` 作为可能开发的其他类型的占位符来提供服务。
- en: The `csv_extract` module will use a collection of independent functions to build
    `XYPair` objects. Each function will be similar in design.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`csv_extract` 模块将使用一系列独立的函数来构建 `XYPair` 对象。每个函数的设计将相似。'
- en: 'Here are some example functions with type annotations:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些带有类型注解的示例函数：
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These functions can then be used by an `extract()` function to create the `XYPair`
    objects for each of the four series represented by a single row of the source
    file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数然后可以被`extract()`函数使用，为源文件单行表示的四个系列中的每一个创建`XYPair`对象。
- en: 'One possibility is to use the following kind of definition:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的方法是使用以下类型的定义：
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This `extract()` function can then apply all of the given builder functions
    (`series_1_pair()` to `series_4_pair()`) to the given row to create `XYPair` objects
    for each of the series.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此`extract()`函数可以将所有给定的构建函数（从`series_1_pair()`到`series_4_pair()`）应用到给定的行上，为每个系列创建`XYPair`对象。
- en: This design will also require a function to apply `dataclass.asdict()` and `json.dumps()`
    to convert `XYPair` objects into strings that can be written to an NDJSON file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计还需要一个函数来应用`dataclass.asdict()`和`json.dumps()`，将`XYPair`对象转换为可以写入NDJSON文件的字符串。
- en: Because the functions used are provided as argument values, there is little
    possibility of a dependency issue among the various functions that make up the
    application. The point throughout the design is to avoid binding specific functions
    in arbitrary places. The `main()` function should provide the row-building functions
    to the `extract` function. These functions can be provided via command-line arguments,
    a configuration file, or be default values if no overrides are given.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因为使用的函数作为参数值提供，所以应用程序中由各种函数组成的各种函数之间出现依赖问题的可能性很小。设计中的重点是避免在任意位置绑定特定的函数。`main()`函数应向`extract`函数提供行构建函数。这些函数可以通过命令行参数、配置文件提供，或者在没有提供覆盖值的情况下作为默认值。
- en: We’ve looked at the overall objective of the project, and two suggested architectural
    approaches. We can now turn to the concrete list of deliverables.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了项目的整体目标，以及两种建议的架构方法。现在我们可以转向具体的交付物列表。
- en: 3.3 Deliverables
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 交付物
- en: 'This project has the following deliverables:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目有以下交付物：
- en: Documentation in the `docs` folder.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docs`文件夹中的文档。'
- en: Acceptance tests in the `tests/features` and `tests/steps` folders.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests/features`和`tests/steps`文件夹中的验收测试。'
- en: Unit tests for model module classes in the `tests` folder.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests`文件夹中模型模块类的单元测试。'
- en: Mock objects for the `csv_extract` module tests will be part of the unit tests.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`csv_extract`模块测试的模拟对象将是单元测试的一部分。'
- en: Unit tests for the `csv_extract` module components in the `tests` folder.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests`文件夹中`csv_extract`模块组件的单元测试。'
- en: Application to acquire data from a CSV file in the `src` folder.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序用于从`src`文件夹中的CSV文件获取数据。
- en: An easy way to start is by cloning the project zero directory to start this
    project. Be sure to update the `pyproject.toml` and `README.md` when cloning;
    the author has often been confused by out-of-date copies of old projects’ metadata.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的方法是从零目录克隆项目开始这个项目。确保在克隆时更新`pyproject.toml`和`README.md`；作者经常被旧项目元数据过时的副本所困惑。
- en: We’ll look at a few of these deliverables in a little more detail. We’ll start
    with some suggestions for creating the acceptance tests.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更详细地查看其中的一些交付物。我们将从创建验收测试的建议开始。
- en: 3.3.1 Acceptance tests
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 验收测试
- en: The acceptance tests need to describe the overall application’s behavior from
    the user’s point of view. The scenarios will follow the UX concept of a command-line
    application that acquires data and writes output files. This includes success
    as well as useful output in the event of failure.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试需要从用户的角度描述整体应用程序的行为。场景将遵循命令行应用程序获取数据和写入输出文件的UX概念。这包括成功以及失败时的有用输出。
- en: 'The features will look something like the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 功能将类似于以下内容：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This more complex feature will require several step definitions. These include
    the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更复杂的功能将需要几个步骤定义。这些包括以下内容：
- en: '`@given(’The`` "{name}"`` source`` file`` exists’)`. This function should copy
    the example file from a source data directory to the temporary directory used
    to run the test.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@given(‘The “{name}” source file exists’)`。此函数应将示例文件从源数据目录复制到用于运行测试的临时目录。'
- en: '`@given(’the`` "{name}"`` directory`` exists’)`. This function can create the
    named directory under the directory used to run the test.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@given(‘the “{name}” directory exists’)`。此函数可以在运行测试的目录下创建名为的目录。'
- en: '`@then(’the`` "{name}"`` file`` exists’)`. This function can check for the
    presence of the named file in the output directory.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@then(‘the “{name}” file exists’)`。此函数可以检查输出目录中是否存在名为的文件。'
- en: '`@then(’the`` "quartet/series_1.json"`` file`` starts`` with`` ...’)`. This
    function will examine the first line of the output file. In the event the test
    fails, it will be helpful to display the contents of the file to help debug the
    problem. A simple `assert` statement might not be ideal; a more elaborate `if`
    statement is needed to write debugging output and raise an `AssertionError` exception.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@then(‘the`` "quartet/series_1.json"`` file`` starts`` with`` …)`。此函数将检查输出文件的第一行。如果测试失败，显示文件内容将有助于调试问题。简单的`assert`语句可能不是最佳选择；需要更复杂的`if`语句来写入调试输出并引发`AssertionError`异常。'
- en: 'Because the application under test consumes and produces files, it is best
    to make use of the **behave** tool’s `environment.py` module to define two functions
    to create (and destroy) a temporary directory used when running the test. The
    following two functions are used by **behave** to do this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因为正在测试的应用程序消耗和生成文件，最好利用**behave**工具的`environment.py`模块定义两个函数来创建（并销毁）在运行测试时使用的临时目录。以下两个函数被**behave**用于此目的：
- en: '`before\_scenario(context,`` scenario)`: This function can create a directory.
    The `tempfile` module has a `mkdtemp()` function that handles this. The directory
    needs to be placed into the context so it can be removed.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`before_scenario(context,` `scenario)`：此函数可以创建一个目录。`tempfile`模块的`mkdtemp()`函数可以处理此操作。需要将目录放入上下文中，以便可以删除。'
- en: '`after_scenario(context,`` scenario)`: This function can remove the temporary
    directory.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after_scenario(context,` `scenario)`：此函数可以删除临时目录。'
- en: 'The format for one of the `Then` clauses has a tiny internal inconsistency.
    The following uses a mixture of `"` and `’` to make it clear where values are
    inserted into the text:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个`Then`子句的格式存在微小的内部不一致性。以下使用`"`和`’`的混合来明确指出值插入文本的位置：
- en: '[PRE10]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Some people may be bothered by the inconsistency. One choice is to use `’` consistently.
    When there aren’t too many feature files, this pervasive change is easy to make.
    Throughout the book, we’ll be inconsistent, leaving the decision to make changes
    for consistency up to you.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会被这种不一致性所困扰。一个选择是始终一致地使用`’`。当特征文件不多时，这种普遍的改变很容易实现。在整个书中，我们将保持不一致，将是否进行更改以保持一致性的决定留给您。
- en: Also, note the `When` clause command is rather long and complicated. The general
    advice when writing tests like this is to use a summary of the command and push
    the details into the step implementation function. We’ll address this in a later
    chapter when the command becomes even longer and more complicated.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意`When`子句命令相当长且复杂。在编写此类测试时的一般建议是使用命令的摘要并将细节推入步骤实现函数。我们将在命令变得更长和更复杂时在后面的章节中讨论这一点。
- en: In addition to the scenario where the application works correctly, we also need
    to consider how the application behaves when there are problems. In the next section,
    we’ll touch on the various ways things might go badly, and how the application
    should behave.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了应用程序正常工作的情况外，我们还需要考虑当出现问题时应用程序的行为。在下一节中，我们将讨论各种可能出错的方式以及应用程序应该如何表现。
- en: 3.3.2 Additional acceptance scenarios
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 其他验收场景
- en: 'The suggested acceptance test covers only one scenario. This single scenario
    — where everything works — can be called the ”happy path”. It would be wise to
    include scenarios in which various kinds of errors occur, to be sure the application
    is reliable and robust in the face of problems. Here are some suggested error
    scenarios:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 建议的验收测试仅覆盖一个场景。这个单一的场景——即一切正常工作——可以称为“快乐路径”。明智的做法是包括各种错误发生的场景，以确保应用程序在面对问题时是可靠和健壮的。以下是一些建议的错误场景：
- en: Given the `Anscombe\_quartet\_data.csv` source file does not exist.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设`Anscombe_quartet_data.csv`源文件不存在。
- en: Given the `quartet` directory does not exist.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设`quartet`目录不存在。
- en: When we run the command `python`` src/acquire.py`` --unknown`` option`
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们运行命令`python`` src/acquire.py`` --unknown`` option`
- en: Given an `Anscombe\_quartet\_data.csv` source file exists, and the file is in
    the wrong format. There are numerous kinds of formatting problems.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设`Anscombe_quartet_data.csv`源文件存在，但文件格式不正确。存在多种格式问题。
- en: The file is empty.
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件为空。
- en: The file is not a proper CSV file, but is in some other format.
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件不是一个合适的CSV文件，而是某种其他格式。
- en: The file’s contents are in valid CSV format, but the column names do not match
    the expected column names.
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件内容处于有效的CSV格式，但列名与预期的列名不匹配。
- en: Each of the unhappy paths will require examining the log file to be sure it
    has the expected error messages. The **behave** tool can capture logging information.
    The `context` available in each step function has attributes that include captured
    logging output. Specifically, `context.log_capture` contains a `LogCapture` object
    that can be searched for an error message.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每个不愉快的路径都需要检查日志文件，以确保它包含预期的错误消息。**behave**工具可以捕获日志信息。每个步骤函数中可用的`context`具有包含捕获的日志输出的属性。具体来说，`context.log_capture`包含一个可以搜索错误消息的`LogCapture`对象。
- en: See [https://behave.readthedocs.io/en/stable/api.html#behave.runner.Context](https://behave.readthedocs.io/en/stable/api.html#behave.runner.Context)
    for the content of the context.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://behave.readthedocs.io/en/stable/api.html#behave.runner.Context](https://behave.readthedocs.io/en/stable/api.html#behave.runner.Context)以了解上下文的内容。
- en: 'These unhappy path scenarios will be similar to the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不愉快的路径场景将与以下内容相似：
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will also require some new step definitions to handle the new `Given` and
    `Then` steps.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将需要一些新的步骤定义来处理新的`Given`和`Then`步骤。
- en: When working with Gherkin, it’s helpful to establish clear language and consistent
    terminology. This can permit a few step definitions to work for a large number
    of scenarios. It’s a common experience to recognize similarities after writing
    several scenarios, and then choose to alter scenarios to simplify and normalize
    steps.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Gherkin时，建立清晰的语言和一致的术语是有帮助的。这可以允许几个步骤定义适用于大量场景。在编写几个场景之后，识别相似性是一种常见经验，然后选择修改场景以简化并标准化步骤。
- en: The **behave** tool will extract missing function definitions. The code snippets
    can be copied and pasted into a steps module.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**behave**工具将提取缺失的功能定义。代码片段可以复制并粘贴到步骤模块中。'
- en: Acceptance tests cover the application’s overall behavior. We also need to test
    the individual components as separate units of code. In the next section, we’ll
    look at unit tests and the mock objects required for those tests.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接受测试覆盖了应用程序的整体行为。我们还需要测试作为单独代码单元的各个组件。在下一节中，我们将查看单元测试以及这些测试所需的模拟对象。
- en: 3.3.3 Unit tests
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 单元测试
- en: There are two suggested application architectures in [*Architectural approach*](#x1-610002).
    Class-based design includes two functions and a number of classes. Each of these
    classes and functions should be tested in isolation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*架构方法*](#x1-610002)中有两种建议的应用架构。基于类的设计包括两个功能和多个类。这些类和功能都应该单独进行测试。
- en: Functional design includes a number of functions. These need to be tested in
    isolation. Some developers find it easier to isolate function definitions for
    unit testing. This often happens because class definitions may have explicit dependencies
    that are hard to break.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 功能设计包括多个功能。这些需要在单独的情况下进行测试。一些开发者发现，为了单元测试，隔离功能定义更容易。这通常是因为类定义可能有明确的依赖关系，这些依赖关系很难打破。
- en: We’ll look at a number of the test modules in detail. We’ll start with tests
    for the `model` module.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细查看一些测试模块。我们将从`model`模块的测试开始。
- en: Unit testing the model
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元测试模型
- en: 'The `model` module only has one class, and that class doesn’t really do very
    much. This makes it relatively easy to test. A test function something like the
    following should be adequate:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`model`模块只有一个类，而这个类实际上并没有做很多。这使得测试相对容易。一个类似于以下测试函数应该是足够的：'
- en: '[PRE12]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This test uses the `sentinel` object from the `unittest.mock` module. Each `sentinel`
    attribute — for example, `sentinel.X` — is a unique object. They’re easy to provide
    as argument values and easy to spot in results.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试使用`unittest.mock`模块中的`sentinel`对象。每个`sentinel`属性——例如，`sentinel.X`——是一个独特的对象。它们作为参数值很容易提供，并且在结果中很容易被发现。
- en: In addition to testing the `model` module, we also need to test the `csv_extract`
    module, and the overall `acquire` application. In the next section, we’ll look
    at the extract unit test cases.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测试`model`模块之外，我们还需要测试`csv_extract`模块以及整个`acquire`应用程序。在下一节中，我们将查看提取单元测试用例。
- en: Unit testing the PairBuilder class hierarchy
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元测试PairBuilder类层次结构
- en: When following an object-oriented design, the suggested approach is to create
    a `PairBuilder` class hierarchy. Each subclass will perform slightly different
    operations to build an instance of the `XYPair` class.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循面向对象设计时，建议的方法是创建一个`PairBuilder`类层次结构。每个子类将执行略微不同的操作来构建`XYPair`类的实例。
- en: Ideally, the implementation of the `PairBuilder` subclasses is not tightly coupled
    to the `XYPair` class. There is some advice in the [*Design principles*](#x1-630002)
    section on how to support dependency injection via type annotations. Specifically,
    the `model` module is best served by using a type variable, `RawData`, as a placeholder
    for any additional types that may be developed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，`PairBuilder` 子类的实现不应与 `XYPair` 类紧密耦合。在 [*设计原则*](#x1-630002) 部分有一些关于如何通过类型注解支持依赖注入的建议。具体来说，`model`
    模块最好通过使用类型变量 `RawData` 作为可能开发的任何额外类型的占位符来提供服务。
- en: When testing, we want to replace this class with a mock class to assure that
    the interface for the family of `RawData` classes — currently only a single class,
    `XYPair` — is honored.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试时，我们希望用模拟类替换这个类，以确保对 `RawData` 类族（目前仅有一个类，`XYPair`）的接口得到尊重。
- en: A `Mock` object (built with the `unittest.mock` module) works out well as a
    replacement class. It can be used for the `XYPair` class in the subclasses of
    the `PairBuilder` class.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Mock` 对象（使用 `unittest.mock` 模块构建）作为替换类效果很好。它可以用于 `PairBuilder` 类的子类中的 `XYPair`
    类。
- en: 'The tests will look like the following example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将类似于以下示例：
- en: '[PRE13]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The idea is to use a `Mock` object to replace the specific class defined in
    the `Series1Pair` class. After the `from_row()` method is evaluated, the test
    case confirms that the mock class was called exactly once with the expected two
    `sentinel` objects. A further check would confirm that the value of `xypair` was
    also a mock object.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是使用 `Mock` 对象来替换 `Series1Pair` 类中定义的特定类。在 `from_row()` 方法评估后，测试用例确认模拟类恰好被调用一次，并带有预期的两个
    `sentinel` 对象。进一步的检查将确认 `xypair` 的值也是一个模拟对象。
- en: This use of `Mock` objects guarantees that no additional, unexpected processing
    was done on the objects. The interface for creating a new `XYPair` was performed
    correctly by the `Series1Pair` class.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 `Mock` 对象的使用保证了没有对对象进行额外的、意外的处理。创建新的 `XYPair` 的接口由 `Series1Pair` 类正确执行。
- en: Similar tests are required for the other pair-building classes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对其他配对构建类也需要进行类似的测试。
- en: In addition to testing the `model` and `csv_extract` modules, we also need to
    test the overall `acquire` application. In the next section, we’ll look at the
    `acquire` application unit test cases.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测试 `model` 和 `csv_extract` 模块外，我们还需要测试整个 `acquire` 应用程序。在下一节中，我们将查看 `acquire`
    应用程序单元测试用例。
- en: Unit testing the remaining components
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元测试剩余组件
- en: The test cases for the overall `Extract` class will also need to use `Mock`
    objects to replace components like a `csv.reader` and instances of the `PairBuilder`
    subclasses.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对整个 `Extract` 类的测试用例也需要使用 `Mock` 对象来替换 `csv.reader` 和 `PairBuilder` 子类的实例。
- en: As noted above in the [*Functional design*](#x1-640003) section, the `main()`
    function needs to avoid having explicitly named classes or functions. The names
    need to be provided via command-line arguments, a configuration file, or as default
    values.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述在 [*功能设计*](#x1-640003) 部分中，`main()` 函数需要避免显式命名类或函数。名称需要通过命令行参数、配置文件或默认值提供。
- en: The unit tests should exercise the `main()` function with `Mock` objects to
    be sure that it is defined with flexibility and extensions in mind.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该使用 `Mock` 对象来测试 `main()` 函数，以确保它具有灵活性和扩展性。
- en: 3.4 Summary
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 摘要
- en: This chapter introduced the first project, the Data Acquisition Base Application.
    This application extracts data from a CSV file with a complex structure, creating
    four separate series of data points from a single file.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了第一个项目，数据采集基础应用程序。该应用程序从一个具有复杂结构的 CSV 文件中提取数据，从一个文件中创建四个独立的数据点系列。
- en: To make the application complete, we included a command-line interface and logging.
    This will make sure the application behaves well in a controlled production environment.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使应用程序完整，我们包括了命令行界面和日志记录。这将确保应用程序在受控的生产环境中表现良好。
- en: An important part of the process is designing an application that can be extended
    to handle data from a variety of sources and in a variety of formats. The base
    application contains modules with very small implementations that serve as a foundation
    for making subsequent extensions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 过程的一个重要部分是设计一个可以扩展以处理来自各种来源和格式的数据的应用程序。基本应用程序包含实现非常小的模块，作为后续扩展的基础。
- en: Perhaps the most difficult part of this project is creating a suite of acceptance
    tests to describe the proper behavior. It’s common for developers to compare the
    volume of test code with the application code and claim testing is taking up ”too
    much” of their time.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可能这个项目最困难的部分是创建一套验收测试来描述适当的行为。开发者通常会将测试代码的量与应用程序代码的量进行比较，并声称测试占用了“太多”的时间。
- en: Pragmatically, a program without automated tests cannot be trusted. The tests
    are every bit as important as the code they’re exercising.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 实用主义地讲，没有自动化测试的程序是不可信的。测试与它们所执行的代码一样重要。
- en: The unit tests are — superficially — simpler. The use of mock objects makes
    sure each class is tested in isolation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试——表面上——更简单。使用模拟对象确保每个类都是独立测试的。
- en: This base application acts as a foundation for the next few chapters. The next
    chapter will add RESTful API requests. After that, we’ll have database access
    to this foundation.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基础应用程序作为接下来几章的基石。下一章将添加RESTful API请求。之后，我们将对这个基础进行数据库访问。
- en: 3.5 Extras
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 额外内容
- en: Here are some ideas for you to add to this project.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些想法供您添加到这个项目中。
- en: 3.5.1 Logging enhancements
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.1 日志增强
- en: We skimmed over logging, suggesting only that it’s important and that the initialization
    for logging should be kept separate from the processing within the `main()` function.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地提到了日志记录，只是建议它很重要，并且日志的初始化应该与`main()`函数内的处理保持分离。
- en: The `logging` module has a great deal of sophistication, however, and it can
    help to explore this. We’ll start with logging ”levels”.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`logging`模块非常复杂，但探索它是有帮助的。我们将从日志“级别”开始。
- en: 'Many of our logging messages will be created with the `INFO` level of logging.
    For example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大多数日志消息都将使用`INFO`级别的日志创建。例如：
- en: '[PRE14]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This application has a number of possible error situations that are best reflected
    with **error**-level logging.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序有许多可能出现的错误情况，最好用**错误**级别的日志来反映。
- en: Additionally, there is a tree of named loggers. The root logger, named `""`,
    has settings that apply to all the lower-level loggers. This tree tends to parallel
    the way object inheritance is often used to create classes and subclasses. This
    can make it advantageous to create loggers for each class. This permits setting
    the logging level to **debug** for one of many classes, allowing for more focused
    messages.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个命名的日志记录器树。根日志记录器，名为`""`，具有适用于所有较低级别日志记录器的设置。这个树通常与对象继承通常用于创建类和子类的方式平行。这可以使得为每个类创建日志记录器具有优势。这允许将日志级别设置为**调试**，以便于多个类中的一个，从而允许更集中的消息。
- en: This is often handled through a logging configuration file. This file provides
    the configuration for logging, and avoids the potential complications of setting
    logging features through command-line options.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常通过日志配置文件来处理。此文件提供了日志配置，并避免了通过命令行选项设置日志功能可能带来的潜在复杂性。
- en: 'There are three extras to add to this project:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个额外内容需要添加到这个项目中：
- en: Create loggers for each individual class.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个单独的类创建日志记录器。
- en: Add debug-level information. For example, the `from_row()` function is a place
    where debugging might be helpful for understanding why an output file is incorrect.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加调试级别的信息。例如，`from_row()`函数是一个可能有助于理解为什么输出文件不正确的调试位置。
- en: Get the logging configuration from an initialization file. Consider using a
    file in **TOML** format as an alternative to the **INI** format, which is a first-class
    part of the `logging` module.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从初始化文件中获取日志配置。考虑使用**TOML**格式的文件作为**INI**格式的替代，后者是`logging`模块的一部分。
- en: 3.5.2 Configuration extensions
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.2 配置扩展
- en: We’ve described a little of the CLI for this application. This chapter has provided
    a few examples of the expected behavior. In addition to command-line parameters,
    it can help to have a configuration file that provides the slowly changing details
    of how the application works.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经简要描述了此应用程序的CLI。本章提供了一些预期行为的示例。除了命令行参数外，拥有一个提供应用程序工作方式的缓慢变化细节的配置文件也有帮助。
- en: In the discussion in the [*Design principles*](#x1-630002) section, we looked
    closely at dependency inversion. The intent is to avoid an explicit dependency
    among classes. We want to ”invert” the relationship, making it indirect. The idea
    is to inject the class name at run time, via parameters.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*设计原则*](#x1-630002)部分的讨论中，我们仔细研究了依赖倒置。目的是避免类之间有显式的依赖关系。我们希望“反转”这种关系，使其变得间接。想法是在运行时通过参数注入类名。
- en: 'Initially, we can do something like the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们可以做如下操作：
- en: '[PRE15]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This provides a base level of parameterization. Some global variables are used
    to ”inject” the run-time classes. These initializations can be moved to the `argparse.Namespace`
    initialization value for the `ArgumentParser.parse_args()` method.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了参数化的基础级别。一些全局变量被用来“注入”运行时类。这些初始化可以移动到`ArgumentParser.parse_args()`方法的`argparse.Namespace`初始化值中。
- en: The initial values for this `argparse.Namespace` object can be literal values,
    essentially the same as shown in the global variable parameterization shown in
    the previous example.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`argparse.Namespace`对象的初始值可以是字面值，本质上与上一个示例中显示的全局变量参数化相同。
- en: It is more flexible to have the initial values come from a parameter file that’s
    separate from the application code. This permits changing the configuration without
    touching the application and introducing bugs through inadvertent typing mistakes.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个与应用程序代码分开的参数文件中获取初始值更为灵活。这允许在不接触应用程序的情况下更改配置，并通过无意中的打字错误引入错误。
- en: 'There are two popular alternatives for a configuration file that can be used
    to fine-tune the application. These are:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于配置文件，有两种流行的替代方案可以用来微调应用程序。这些是：
- en: A separate Python module that’s imported by the application. A module name like
    `config.py` is popular for this.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个由应用程序导入的独立的Python模块。对于这个用途，模块名如`config.py`很受欢迎。
- en: A non-Python text file that’s read by the application. The TOML file format,
    parsed by the `tomllib` module, is ideal.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个由应用程序读取的非Python文本文件。由`tomllib`模块解析的TOML文件格式是理想的。
- en: Starting with Python 3.11, the `tomllib` module is directly available as part
    of the standard library. Older versions of Python should be upgraded to 3.11 or
    later.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.11版本开始，`tomllib`模块作为标准库的一部分直接可用。较旧版本的Python应升级到3.11或更高版本。
- en: When working with a TOML file, the class name will be a string. The simple and
    reliable way to translate the class name from string to class object is to use
    the `eval()` function. An alternative is to provide a small dictionary with class
    name strings and class objects. Class names can be resolved through this mapping.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当与TOML文件一起工作时，类名将是一个字符串。将类名从字符串转换为类对象的一个简单可靠的方法是使用`eval()`函数。另一种方法是提供一个包含类名字符串和类对象的字典。可以通过这种映射解析类名。
- en: Some developers worry that the `eval()` function allows a class of Evil Super
    Geniuses to tweak the configuration file in a way that will crash the application.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者担心`eval()`函数允许一类邪恶超级天才以某种方式修改配置文件，从而导致应用程序崩溃。
- en: What these developers fail to notice is that the entire Python application is
    plain text. The Evil Super Genius can more easily edit the application and doesn’t
    need to do complicated, nefarious things to the parameter file.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这些开发者没有注意到整个Python应用程序是纯文本的。邪恶超级天才更容易编辑应用程序，并且不需要对参数文件进行复杂的、恶意的操作。
- en: Further, ordinary OS-level ownership and permissions can restrict access to
    the parameter file to a few trustworthy individuals.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，普通的操作系统级别的所有权和权限可以限制对参数文件的访问，仅限于少数可信赖的个人。
- en: Don’t forget to include unit test cases for parsing the parameter file. Also,
    an acceptance test case with an invalid parameter file will be an important part
    of this project.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记包括解析参数文件的单元测试用例。此外，一个无效参数文件的验收测试用例将是这个项目的重要部分。
- en: 3.5.3 Data subsets
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.3 数据子集
- en: 'To work with large files it will be necessary to extract a subset of the data.
    This involves adding features like the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理大文件，将需要提取数据的一个子集。这涉及到添加以下类似的功能：
- en: Create a subclass of the `Extract` class that has an upper limit on the number
    of rows created. This involves a number of unit tests.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`Extract`类的子类，该子类对创建的行数有一个上限。这涉及到许多单元测试。
- en: Update the CLI options to include an optional upper limit. This, too, will involve
    some additional unit test cases.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新CLI选项以包括一个可选的上限。这也将涉及一些额外的单元测试用例。
- en: Update the acceptance test cases to show operation with the upper limit.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新验收测试用例以显示使用上限的操作。
- en: Note that switching from the `Extract` class to the `SubsetExtract` class is
    something that should be based on an optional command-line parameter. If the `--limit`
    option is not given, then the `Extract` class is used. If the `--limit` option
    is given (and is a valid integer), then the `SubsetExtract` class is used. This
    will lead to an interesting set of unit test cases to make sure the command-line
    parsing works properly.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从`Extract`类切换到`SubsetExtract`类应该基于一个可选的命令行参数。如果没有提供`--limit`选项，则使用`Extract`类。如果提供了`--limit`选项（并且是一个有效的整数），则使用`SubsetExtract`类。这将导致一系列有趣的单元测试案例，以确保命令行解析正常工作。
- en: 3.5.4 Another example data source
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.4 另一个示例数据源
- en: Perhaps the most important extra for this application is to locate another data
    source that’s of interest to you.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用来说，最重要的额外工作可能是找到另一个对你感兴趣的数据源。
- en: 'See the **CO****2** **PPM — Trends in Atmospheric Carbon Dioxide** data set,
    available at [https://datahub.io/core/co2-ppm](https://datahub.io/core/co2-ppm),
    for some data that’s somewhat larger. This has a number of odd special-case values
    that we’ll explore in [*Chapter** 6*](ch010.xhtml#x1-1460006), [*Project 2.1:
    Data Inspection Notebook*](ch010.xhtml#x1-1460006).'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅**CO2 PPM —大气二氧化碳趋势**数据集，可在[https://datahub.io/core/co2-ppm](https://datahub.io/core/co2-ppm)找到，这是一些相对较大的数据。这个数据集有几个奇特的特殊值，我们将在[*第6章*](ch010.xhtml#x1-1460006)，[*项目2.1：数据检查笔记本*](ch010.xhtml#x1-1460006)中进行探讨。
- en: 'This project will require you to manually download and unzip the file. In later
    chapters, we’ll look at automating these two steps. See [*Chapter** 4*](ch008.xhtml#x1-780004),
    [*Data* *Acquisition Features: Web APIs and Scraping*](ch008.xhtml#x1-780004)
    specifically, for projects that will expand on this base project to properly acquire
    the raw data from a CSV file.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将需要你手动下载和解压文件。在后面的章节中，我们将探讨如何自动化这两个步骤。具体请参阅[*第4章*](ch008.xhtml#x1-780004)，[*数据获取功能：Web
    API和抓取*](ch008.xhtml#x1-780004)，其中将扩展这个基础项目，以正确地从CSV文件获取原始数据。
- en: What’s important is locating a source of data that’s in CSV format and small
    enough that it can be processed in a few seconds. For large files, it will be
    necessary to extract a subset of the data. See [*Data subsets*](#x1-760003) for
    advice on handling large sets of data.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是找到一种CSV格式的数据源，并且足够小，可以在几秒钟内处理。对于大型文件，将需要提取数据的一个子集。有关处理大量数据集的建议，请参阅[*数据子集*](#x1-760003)。
