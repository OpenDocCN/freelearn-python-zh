- en: Type Variables and Operators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型变量和运算符
- en: In the last chapter, you learned a little bit about the history of Python. You learned
    the steps to install Python and some basic syntax of the language. In the basic
    syntax, you learned about types of comments that can be used in the code, various
    types of quotes, escape sequence that can be handy, and finally, you learned about
    the formatting of strings. In this chapter, you will learn about assignment statements,
    arithmetic operators, comparison operators, assignment operators, bitwise operators,
    logical operators, membership operators, and identity operators.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你了解了一些关于Python的历史。你学习了安装Python的步骤和语言的一些基本语法。在基本语法中，你学习了代码中可以使用的注释类型、各种类型的引号、有用的转义序列，以及最后，你学习了字符串的格式化。在本章中，你将学习关于赋值语句、算术运算符、比较运算符、赋值运算符、位运算符、逻辑运算符、成员运算符和身份运算符。
- en: Variables
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'So, what is a variable? Consider that your house needs a name. You place a
    nameplate at the front gate of your house. People will now recognize your house
    through that nameplate. That nameplate can be considered as variable. Like a nameplate
    points to the house, a variable points to the value that is stored in memory.
    When you create a variable, the interpreter will reserve some space in the memory
    to store values. Depending on the data type of the variable, the interpreter allocates
    memory and makes a decision to store a particular data type in the reserved memory.
    Various data types, such as integers, decimals, or characters, can be stored by
    assigning different data types to the variables. Python variables are usually
    dynamically typed, that is, the type of the variable is interpreted during runtime
    and you need not specifically provide a type to the variable name, unlike what
    other programming languages require. There are certain rules or naming conventions
    for naming variables. The following are the rules:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是变量呢？考虑一下你的房子需要一个名字。你在房子的前门放置一个门牌。现在人们将通过这个门牌来识别你的房子。这个门牌可以被视为变量。就像门牌指向房子一样，变量指向存储在内存中的值。当你创建一个变量时，解释器会在内存中预留一些空间来存储值。根据变量的数据类型，解释器分配内存并决定在预留的内存中存储特定的数据类型。可以通过将不同的数据类型赋给变量来存储各种数据类型，例如整数、小数或字符。Python变量通常是动态类型的，这意味着变量的类型是在运行时解释的，你不需要为变量名指定类型，这与其他编程语言的要求不同。变量命名有一定的规则或命名约定。以下是一些规则：
- en: Reserved key words such as `if`, `else`, and so on cannot be used for naming
    variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留关键字，如`if`、`else`等，不能用于变量命名
- en: Variable names can begin with `_`, `$`, or a letter
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名可以以`_`、`$`或字母开头
- en: Variable names can be in lower case and uppercase
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名可以是小写和大写
- en: Variable names cannot start with a number
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名不能以数字开头
- en: White space characters are not allowed in the naming of a variable
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量命名不允许使用空白字符
- en: You can assign values to the variable using `=` or assignment operator.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`=`或赋值运算符给变量赋值。
- en: '**Syntax:**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法：**'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Single assignment
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单次赋值
- en: 'Here, we will illustrate the use of the assignment operator (`=`) with an example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将通过一个示例来展示赋值运算符（`=`）的使用：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, we assigned three different values to three variables using the `=`
    operator.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`=`运算符将三个不同的值赋给了三个变量。
- en: Multiple assignment
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多次赋值
- en: 'A single value can be assigned to several variables simultaneously. For example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可以同时将一个值赋给多个变量。例如：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Data types in Python
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的数据类型
- en: 'What is a data type in any programming language? Let''s try to understand with
    a real life problem. We use water, oil, liquid soap, syrups, and so on in our
    day to day life. How do you categorize these items? Let''s take another set of
    examples of bar soap, cell phone, and so on; what classification would you like
    to give these items? Answer to all these questions is simple: solid, liquid, and
    gases. Yes, we have these three broader classifications for any item that we have
    heard about or used in our day to day life. Same is the case in the programming
    world. Each and every thing needs to be categorized under different types. There
    are many types of data, such as numbers, strings, character, images, and so on.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言中的数据类型是什么？让我们用一个现实生活中的问题来尝试理解。我们在日常生活中使用水、油、液体肥皂、糖浆等等。你是如何对这些物品进行分类的？让我们再举一些例子，比如条状肥皂、手机等等；你希望对这些物品进行什么分类？所有这些问题的答案都很简单：固体、液体和气体。是的，我们对任何我们听说过或在我们日常生活中使用过的物品都有这三个更广泛的分类。在编程世界中也是如此。每一件事都需要被归类到不同的类型中。有许多类型的数据，如数字、字符串、字符、图像等等。
- en: 'Data types can be broadly categorized into five different types, listed as
    follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型可以大致分为五种不同类型，如下所示：
- en: Numbers
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: String
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Tuples
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组
- en: List
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: Dictionary
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典
- en: Numeric data types or numbers
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值数据类型或数字
- en: There are generally four numeric data types in Python. They are integers, long
    integers, floating point numbers, and complex numbers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Python中通常有四种数值数据类型。它们是整数、长整数、浮点数和复数。
- en: Integers and long integers
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数和长整数
- en: 'Integers include zero, all of the positive whole numbers, and all of the negative
    whole numbers. The interpreter first checks the expression on the right hand side
    of the assignment operator and then binds the value with its variable name; this
    process is termed as variable definition or initialization. The `int` or integer
    data type ranges from -2^(31) to (2^(31)-1); the leading minus sign shows the
    negative values. Beyond these ranges, the interpreter will add `L` to indicate
    a long integer, as shown in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 整数包括零，所有的正整数，以及所有的负整数。解释器首先检查赋值运算符右侧的表达式，然后将值与其变量名绑定；这个过程被称为变量定义或初始化。`int`或整数数据类型范围从-2^(31)到(2^(31)-1)；前面的负号表示负值。超出这些范围，解释器会在数字后添加`L`来表示长整数，如下面的截图所示：
- en: '![](img/image_02_001-3.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/image_02_001-3.jpg)'
- en: Floating point numbers
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点数
- en: 'Numbers with certain places after the decimal point are referred to as floating
    point numbers in the programming language:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言中，小数点后有特定位置的数字被称为浮点数：
- en: The floating point number type ranges approximately from -10 to 10^(^308) and
    has 16 digits of precision.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数类型大约从-10到10^(^308)的范围，有16位精度。
- en: 'There are two ways to write a floating point number. It can be written using
    ordinary decimal notation or scientific notation. Scientific notation is often
    useful for mentioning very large numbers, as shown in the following screenshot:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有两种方式可以写浮点数。它可以使用普通的十进制表示法或科学记数法来写。科学记数法通常用于表示非常大的数字，如下面的截图所示：
- en: '![](img/image_02_002-2.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/image_02_002-2.jpg)'
- en: Complex numbers
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复数
- en: A complex number has both real and imaginary parts, and Python allows you to
    specify this data type in a very easy and convenient way.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 复数既有实部又有虚部，Python允许你以非常简单和方便的方式指定这种数据类型。
- en: '**Syntax:**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法：**'
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: OR
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, `x` is the real part and `y` is the imaginary part. Here, `j` plays the
    role of iota.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`x`是实部，`y`是虚部。在这里，`j`扮演虚数单位的作用。
- en: 'It will be clearer with the following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图将更加清晰：
- en: '![](img/image_02_003-2.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/image_02_003-2.jpg)'
- en: Here, we declare two variables to denote complex numbers. One way to achieve
    is to use `complex()` method and the other way is to use the standard notation
    as used in mathematics.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明两个变量来表示复数。一种实现方式是使用`complex()`方法，另一种方式是使用数学中常用的标准符号。
- en: In standard complex number notation, *x+ij*, *i* is used to denote the starting
    of the imaginary part and stands for iota. *j* denotes the imaginary part. The
    credit for conceiving the idea of complex numbers goes to Italian mathematician
    Gerolamo Cardano in 1545.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的复数表示法中，*x+ij*，*i*用来表示虚部的开始，代表虚数单位。*j*表示虚部。复数概念的提出归功于意大利数学家杰罗拉莫·卡尔达诺在1545年。
- en: 'Source: [https://en.wikipedia.org/wiki/Complex_number](https://en.wikipedia.org/wiki/Complex_number)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://en.wikipedia.org/wiki/Complex_number](https://en.wikipedia.org/wiki/Complex_number)
- en: Boolean data type
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔数据类型
- en: A Boolean data type generally has only two values `'True'` or `'False'`. Boolean
    data type is a sub type of integers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数据类型通常只有两个值 `'True'` 或 `'False'`。布尔数据类型是整数类型的一个子类型。
- en: '**Syntax:**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法：**'
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Boolean data types can be referred to as an on and off switch, which has only
    two values to chose from:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数据类型可以被视为一个开/关开关，它只有两个可选值：
- en: '![](img/image_02_004-2.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_004-2.jpg)'
- en: In the preceding example, we try to compare the value of `x` with the value
    of `y`, and when we use the `==` operator, the value of the Boolean is returned
    as `True`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们尝试比较`x`的值与`y`的值，当我们使用`==`运算符时，布尔值返回`True`。
- en: String data types
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串数据类型
- en: A Python string is a contiguous sequence of Unicode characters. Single quotes
    or double quotes can be used to denote a string, as we saw in [Chapter 1](lrn-py-7d_ch01.html),
    *Getting Started with Python*. For multiline string representation, `'''` or `"""`
    can be used.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Python字符串是一系列连续的Unicode字符。可以使用单引号或双引号来表示字符串，正如我们在[第1章](lrn-py-7d_ch01.html)，“Python入门”中看到的。对于多行字符串表示，可以使用`'''`或`"""`。
- en: '**Syntax:**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法：**'
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will understand better with the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图可以帮助你更好地理解：
- en: '![](img/image_02_005-2.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_005-2.jpg)'
- en: More details on strings, tuples, list, and dictionary will be covered in the
    coming chapters.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关于字符串、元组、列表和字典的更多细节将在接下来的章节中介绍。
- en: American Standard Code for Information Interchange (ASCII) character sets
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 美国信息交换标准代码（ASCII）字符集
- en: The succeeding table shows the mapping of the first 128 ASCII codes to character
    values. The left column digits are the leftmost digits of the ASCII code. The
    top row's digits represent the rightmost digits. For example, the ASCII code of
    character *A* would be *65*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了前128个ASCII码与字符值的映射。左列数字是ASCII码的最左位数字。顶行的数字代表最右位数字。例如，字符*A*的ASCII码是*65*。
- en: '|  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |'
- en: '| 0 | NUL | SOH | STX | ETX | EOT | ENQ | ACK | BEL | BS | HT |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 0 | NUL | SOH | STX | ETX | EOT | ENQ | ACK | BEL | BS | HT |'
- en: '| 1 | LF | VT | FF | CR | SO | SI | DLE | DCI | DC2 | DC3 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 1 | LF | VT | FF | CR | SO | SI | DLE | DCI | DC2 | DC3 |'
- en: '| 2 | DC4 | NAK | SYN | ETB | CAN | EM | SUB | ESC | FS | GS |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 2 | DC4 | NAK | SYN | ETB | CAN | EM | SUB | ESC | FS | GS |'
- en: '| 3 | RS | US | SP | ! | " | # | $ | % | & | ` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 3 | RS | US | SP | ! | " | # | $ | % | & | ` |'
- en: '| 4 | ( | ) | * | + | , | - | . | / | 0 | 1 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 4 | ( | ) | * | + | , | - | . | / | 0 | 1 |'
- en: '| 5 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | : | ; |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | : | ; |'
- en: '| 6 | < | = | > | ? | @ | A | B | C | D | E |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 6 | < | = | > | ? | @ | A | B | C | D | E |'
- en: '| 7 | F | G | H | I | J | K | L | M | N | O |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 7 | F | G | H | I | J | K | L | M | N | O |'
- en: '| 8 | P | Q | R | S | T | U | V | W | X | Y |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 8 | P | Q | R | S | T | U | V | W | X | Y |'
- en: '| 9 | Z | [ |  | ] | ^ | _ | '' | a | b | c |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 9 | Z | [ |  | ] | ^ | _ | '' | a | b | c |'
- en: '| 10 | d | e | f | g | h | i | j | k | l | m |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 10 | d | e | f | g | h | i | j | k | l | m |'
- en: '| 11 | n | o | p | q | r | s | t | u | v | w |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 11 | n | o | p | q | r | s | t | u | v | w |'
- en: '| 12 | x | y | z | { | &#124; | } | ~ | DEL |  |  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 12 | x | y | z | { | &#124; | } | ~ | DEL |  |  |'
- en: ASCII was developed primarily for telegraph code. Bell labs brought out 7-bit
    teleprinter code for commercial promotion and official work on the ASCII code
    began on October 6, 1960.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII 主要是为了电报代码而开发的。贝尔实验室推出了7位电传打字机代码以进行商业推广，ASCII代码的官方工作始于1960年10月6日。
- en: 'Source: [https://en.wikipedia.org/wiki/ASCII](https://en.wikipedia.org/wiki/ASCII)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://en.wikipedia.org/wiki/ASCII](https://en.wikipedia.org/wiki/ASCII)
- en: Conversion functions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换函数
- en: 'In order to convert a character value to ASCII code, the `ord()` function is
    used, and for converting ASCII code to character, the `chr()` function is used,
    as shown in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将字符值转换为ASCII码，使用`ord()`函数，而将ASCII码转换为字符，则使用`chr()`函数，如下面的截图所示：
- en: '![](img/image_02_006-2.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_006-2.jpg)'
- en: Here, when we want to get the ASCII code for `'A'`, it shows `65`, which you
    can easily get from the aforementioned table. The letter `'A'` can be located
    on the sixth row and fifth column; thus, its value is `65`. Likewise, we can get
    the letter corresponding to a particular ASCII code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当我们想要获取字符`'A'`的ASCII码时，它显示为`65`，你可以很容易地从上述表中得到。字母`'A'`位于第六行第五列；因此，它的值是`65`。同样，我们可以获取与特定ASCII码对应的字母。
- en: Arithmetic expressions
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术表达式
- en: 'Arithmetic expressions in any language comprise operands and operators. For
    reference, *x* and *y* are used as operands having values *10* and *20*, respectively. The
    following table shows the precedence order:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 任何语言的算术表达式都由操作数和运算符组成。为了参考，使用 *x* 和 *y* 作为具有值 *10* 和 *20* 的操作数。以下表格显示了优先级顺序：
- en: '| **Operator** | **Description** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** |'
- en: '| `**` | **Exponent**: Performs exponential (power) calculations on operators
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `**` | **指数**: 在运算符上执行指数（幂）计算 |'
- en: '| `*` | **Multiplication**: Multiplies values on either side of the operator
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `*` | **乘法**: 乘以运算符两边的值 |'
- en: '| `/` | **Division**: Divides the left-hand operand by the right-hand operand
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `/` | **除法**: 将左操作数除以右操作数 |'
- en: '| `%` | **Modulus**: Divides the left-hand operand by the right-hand operand
    and returns the remainder |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `%` | **取模**: 将左操作数除以右操作数并返回余数 |'
- en: '| `+` | **Addition**: Adds values on either side of the operator |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `+` | **加法**: 在运算符两边添加值 |'
- en: '| `-` | **Subtraction**: Subtracts the right-hand operand from the left-hand
    operand |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `-` | **减法**: 从左操作数减去右操作数 |'
- en: In an arithmetic expression, generally, the rule of **Bracket, Of, Division,
    Multiplication, Addition, and Subtraction** (**BODMAS**) is followed, and operators
    have their own precedence order. Exponentiation enjoys a higher precedence order,
    while addition and subtraction have a lower precedence order.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在算术表达式中，通常遵循**括号、乘除、加减**（**BODMAS**）的规则，并且运算符有自己的优先级顺序。指数具有更高的优先级，而加法和减法具有较低的优先级。
- en: 'The decreasing precedence order is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 递减的优先级顺序如下：
- en: Exponent
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数
- en: Unary negation
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元取反
- en: Multiplication, division, modulus
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法、除法、取模
- en: Addition, subtraction
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加法、减法
- en: If operands are of the same data type, then the resulting value is also of that
    type. However, addition of two `int` data types can produce a `long` integer.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数的数据类型相同，则结果值也是该类型。然而，两个 `int` 数据类型的加法可以产生一个 `long` 整数。
- en: Mixed mode arithmetic
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合模式算术
- en: The arithmetic operation involving both integer and floating point numbers is
    called **mixed mode arithmetic**. When each operand is of a different data type,
    the resulting value is of the more general type, and `float` is the more general
    type.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及整数和浮点数的算术运算称为**混合模式算术**。当每个操作数的数据类型不同时，结果值是更通用的类型，而 `float` 是更通用的类型。
- en: 'The following screenshot will make it clearer for you:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图将使您更清楚：
- en: '![](img/image_02_007-2.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_007-2.jpg)'
- en: Mixed Mode Conversion
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合模式转换
- en: In the preceding example, `11/2.0`, the less general type integer, `11`, is
    temporarily and automatically converted into float `11.0`. Then, the calculation
    is performed. It is called **mixed mode conversion**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子 `11/2.0` 中，较不通用的类型整数 `11` 被临时自动转换为浮点数 `11.0`。然后执行计算。这被称为**混合模式转换**。
- en: Type conversions
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'It is easy to convert the data type of operands using a type conversion function.
    Let''s understand with some examples:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型转换函数很容易转换操作数的数据类型。让我们通过一些例子来理解：
- en: '![](img/image_02_008-2.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_008-2.jpg)'
- en: In the preceding screenshot, `4.77` is converted into `4`. In order to convert
    `4.77` into the `int` data type, the `int()` function is used. Likewise, if you
    want to convert into `float`, use the `float()` function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，`4.77` 被转换为 `4`。为了将 `4.77` 转换为 `int` 数据类型，使用了 `int()` 函数。同样，如果您想转换为
    `float`，请使用 `float()` 函数。
- en: Operators
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: 'Python supports the following types of operators:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Python 支持以下类型的运算符：
- en: Arithmetic operators.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算符。
- en: Comparison operators
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较运算符
- en: Assignment operators
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: Bitwise operators
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位运算符
- en: Logical operators
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: Membership operators
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员运算符
- en: Identity operators
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识运算符
- en: Arithmetic operators
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术运算符
- en: 'Arithmetic expressions comprise operands and operators:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 算术表达式由操作数和运算符组成：
- en: '| **Operator** | **Description** |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** |'
- en: '| `**` | **Exponent**: Performs exponential (power) calculations on operands
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `**` | **指数**: 在操作数上执行指数（幂）计算 |'
- en: '| `*` | **Multiplication**: Performs multiplication between operands |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `*` | **乘法**: 在操作数之间执行乘法 |'
- en: '| `/` | **Division**: Performs division between operands |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `/` | **除法**: 在操作数之间执行除法 |'
- en: '| `%` | **Modulus**: Performs modulus division between operands |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `%` | **取模**: 在操作数之间执行取模除法 |'
- en: '| `+` | **Addition**: Performs addition between operands |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `+` | **加法**: 在操作数之间执行加法 |'
- en: '| `-` | **Subtraction**: Performs subtraction between operands |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `-` | **减法**：在操作数之间执行减法 |'
- en: We have already discussed the precedence order of the operators.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了运算符的优先级顺序。
- en: Comparison operators
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较运算符
- en: 'Like any other language, Python also supports comparison operators. Comparison
    operators return `True` or `False`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他语言一样，Python 也支持比较运算符。比较运算符返回 `True` 或 `False`：
- en: '| **Operator** | **Description** |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** |'
- en: '| `==` | Checks the equality |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `==` | 检查相等性 |'
- en: '| `<` | Returns `True` if the left-hand side operand is less than the right-hand
    side operand |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 如果左侧操作数小于右侧操作数，则返回 `True` |'
- en: '| `>` | Returns `True` if the left-hand side operand is greater than the right-hand
    side operand |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 如果左侧操作数大于右侧操作数，则返回 `True` |'
- en: '| `<=` | Returns `True` if the left-hand side operand is less than or equal
    to the right-hand side operand |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 如果左侧操作数小于或等于右侧操作数，则返回 `True` |'
- en: '| `>=` | Returns `True` if the left-hand side operand is greater than or equal
    to the right-hand side operand |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 如果左侧操作数大于或等于右侧操作数，则返回 `True` |'
- en: '| `!=` | Returns `True` if the left-hand side operand is not equal to the right-hand
    side operand |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | 如果左侧操作数不等于右侧操作数，则返回 `True` |'
- en: '| `<>` | Returns `True` if the left-hand side operand is not equal to the right-hand
    side operand |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `<>` | 如果左侧操作数不等于右侧操作数，则返回 `True` |'
- en: 'Some examples of comparison operators and their outcome are shown in the following
    screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了比较运算符的一些示例及其结果：
- en: '![](img/image_02_009-2.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_009-2.jpg)'
- en: 'Let''s evaluate the following expression:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们评估以下表达式：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, the `and` operator is used, `b` is evaluated only once, and `c` will
    not be evaluated if `a < b` is found `False`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用了 `and` 运算符，`b` 只被评估一次，如果发现 `a < b` 为 `False`，则 `c` 不会被评估：
- en: '![](img/image_02_010-2.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_010-2.jpg)'
- en: In the preceding example, `12<5` is evaluated first; if it is `False`, then
    the next expression will not be evaluated. If the operands are of different types,
    then they are converted to a common type. Otherwise, the `==` and `!=` operators
    always consider objects of different types to be unequal.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`12<5` 首先被评估；如果它是 `False`，则下一个表达式将不会评估。如果操作数是不同类型，则它们将被转换为共同类型。否则，`==`
    和 `!=` 运算符始终认为不同类型的对象是不相等的。
- en: 'Let''s look at two different scenarios where we try to evaluate a `float` data
    type with an `int` data type, as shown:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个不同的场景，其中我们尝试用 `int` 数据类型评估 `float` 数据类型，如下所示：
- en: '![](img/image_02_011-2.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_011-2.jpg)'
- en: Here, the operator evaluates to `True` in both the cases, as the interpreter
    converts one data type to another and then compares both the values.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，运算符都评估为 `True`，因为解释器将一种数据类型转换为另一种数据类型，然后比较两个值。
- en: 'Comparison between different data types:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 不同数据类型之间的比较：
- en: Numbers are compared arithmetically
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字按算术方式比较
- en: Strings are compared as per the alphabetical order, using the numeric equivalents
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串按字母顺序比较，使用数字等效值
- en: Tuples and lists are compared according to the alphabetical order using the
    comparison of corresponding elements, which we will see in the coming chapters
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组与列表根据对应元素的比较进行字母顺序比较，我们将在接下来的章节中看到
- en: Variants of assignment operator
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赋值运算符的变体
- en: 'Earlier in the chapter, you learned about the assignment operator, `=`. Now,
    we will see some more variants of the assignment operator, often used in combination
    with arithmetic operators:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早些时候，你学习了赋值运算符 `=`。现在，我们将看到一些赋值运算符的变体，这些变体通常与算术运算符一起使用：
- en: '| **Operator** | **Description** |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** |'
- en: '| `=` | `x=y` , `y` is assigned to `x` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `=` | `x=y` ，`y` 被赋值给 `x` |'
- en: '| `+=` | `x+=y` is equivalent to `x=x+y` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `+=` | `x+=y` 等价于 `x=x+y` |'
- en: '| `-=` | `x-=y` is equivalent to `x=x-y` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `-=` | `x-=y` 等价于 `x=x-y` |'
- en: '| `*=` | `x*=y` is equivalent to `x=x*y` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `*=` | `x*=y` 等价于 `x=x*y` |'
- en: '| `/=` | `x/=y` is equivalent to `x=x/y` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `/=` | `x/=y` 等价于 `x=x/y` |'
- en: '| `**=` | `x**=y` is equivalent to `x=x**y` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `**=` | `x**=y` 等价于 `x=x**y` |'
- en: 'Here, we will look at a few examples of the variants of the assignment operator:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将查看赋值运算符变体的几个示例：
- en: '![](img/image_02_012-2.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_012-2.jpg)'
- en: Bitwise operators
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位运算符
- en: 'Python supports bitwise operations. You might have come across *AND*, *OR*,
    or complementary operations:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Python 支持位运算。你可能已经遇到过 *AND*、*OR* 或补码运算：
- en: '| **Operator** | **Description** |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** |'
- en: '| `&#124;` | Performs binary *OR* operation |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `|` | 执行二进制 *OR* 运算 |'
- en: '| `&` | Performs binary *AND* operation |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 执行二进制 *AND* 操作 |'
- en: '| `~` | Performs binary *XOR* operation |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `~` | 执行二进制 *XOR* 操作 |'
- en: '| `^` | Performs binary one''s complement operation |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 执行二进制一位补码操作 |'
- en: '| `<<` | **Left shift operator**: The left-hand side operand bit is moved left
    by the number specified on the right-hand side |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `<<` | **左移运算符**：将左侧操作数的位向左移动右侧指定的位数 |'
- en: '| `>>` | **Right shift operator**: The left-hand side operand bit is moved
    right by the number specified on the right-hand side |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `>>` | **右移运算符**：将左侧操作数的位向右移动右侧指定的位数 |'
- en: 'The following screenshot illustrates the various usages of bitwise operators:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了位运算符的各种用法：
- en: '![](img/image_02_013-2.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_013-2.jpg)'
- en: '`~x` will give `-241`, which is in *2''s complement* form due to a signed binary
    number.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`~x` 将给出 `-241`，这是由于有符号二进制数的 *2''s complement* 形式。'
- en: Logical operators
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'Python supports logical operators *AND*, *OR*, and *NOT*:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Python 支持逻辑运算符 *AND*、*OR* 和 *NOT*：
- en: '| **Operator** | **Description** |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** |'
- en: '| `and` | Returns `True` if both the right-hand and left-hand sides of the
    operator are true |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `and` | 如果运算符的左右两侧都为真，则返回 `True` |'
- en: '| `or` | Returns `True` if any side, either the right-hand side or the left-hand
    side, of the operator is true |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `or` | 如果运算符的任一侧（右侧或左侧）为真，则返回 `True` |'
- en: '| `not` | If condition in the `not` operator is `True`, the `not` operator
    makes it `False` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `not` | 如果 `not` 运算符中的条件为 `True`，则 `not` 运算符将其变为 `False` |'
- en: 'These only evaluate their second argument if needed for their outcome, as shown
    in the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符仅在需要其结果时才评估它们的第二个参数，如下面的截图所示：
- en: '![](img/image_02_014-2.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_014-2.jpg)'
- en: Membership operators
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成员运算符
- en: 'Python has two membership operators to test the membership in a sequence, such
    as a string, list, tuple, and others:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有两个成员运算符用于测试序列中的成员资格，例如字符串、列表、元组等：
- en: '| **Operator** | **Description** |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** |'
- en: '| `in` | Returns `True` if the specified operand is found in the sequence |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `in` | 如果指定的操作数在序列中找到，则返回 `True` |'
- en: '| `not in` | Returns `True` if the specified operand is not found in the sequence
    |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `not in` | 如果指定的操作数不在序列中，则返回 `True` |'
- en: 'The following screenshot will make it clearer for you:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图将使情况更清晰：
- en: '![](img/image_02_015-2.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_015-2.jpg)'
- en: In the preceding screenshot, we try to search for the character, `'o'`, in the
    string, `'John'`, and it returns `True`. However, `'k'` is not present in the
    string, and hence, it returns `False`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们尝试在字符串 `'John'` 中搜索字符 `'o'`，并返回 `True`。然而，`'k'` 不在字符串中，因此返回 `False`。
- en: Identity operators
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份运算符
- en: 'Given in the table are the two identity operators:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中给出了两个身份运算符：
- en: '| **Operator** | **Description** |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** |'
- en: '| `is` | Returns `True` if two variables point to the same object and `False`,
    otherwise |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `is` | 如果两个变量指向同一对象，则返回 `True`，否则返回 `False` |'
- en: '| `is not` | Returns `False` if two variables point to the same object and
    `True`, otherwise |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `is not` | 如果两个变量指向同一对象，则返回 `False`，否则返回 `True` |'
- en: 'The following screenshot shows that the value can be same but `id` can be different.
    It returns `True` if `id` is the same:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示值可以相同，但 `id` 可以不同。如果 `id` 相同，则返回 `True`：
- en: '![](img/image_02_016-2.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_016-2.jpg)'
- en: Here, as both `x` and `y` contain the same value (`10`), `id()` returns the
    same value for both. However, when `x` and `y` are provided with the same list,
    `id()` returns different values. This could be attributed to the fact that when
    `x` and `y` have `10` assigned to them, it essentially means that both are pointing
    to the same memory address, which has a value of `10`, while in the case of a
    list, this could be different. Why different? That is because lists are immutable,
    which means they can't be changed. So, when we assign the same list to `y`, it
    means that a new memory address is blocked again for a new list.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，由于 `x` 和 `y` 包含相同的值（`10`），`id()` 对两者都返回相同的值。然而，当 `x` 和 `y` 被提供相同的列表时，`id()`
    返回不同的值。这可以归因于当 `x` 和 `y` 被赋予 `10` 时，实际上意味着两者都指向相同的内存地址，该地址的值为 `10`，而在列表的情况下，这可能是不同的。为什么不同？这是因为列表是不可变的，这意味着它们不能被更改。因此，当我们将相同的列表赋给
    `y` 时，这意味着为新的列表再次分配了一个新的内存地址。
- en: The `id()` function returns the *identity* of an object. This is an integer
    (or long integer), which is guaranteed to be unique and constant for this object
    during its lifetime. It is similar to memory addresses in the C language.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`id()` 函数返回对象的 *标识*。这是一个整数（或长整数），在对象的整个生命周期内保证是唯一且恒定的。它类似于 C 语言中的内存地址。'
- en: 'However, there is a small twist in our `id()` function. Python supports same
    memory allocation for integers only up to `256`. It will be clearer with the following
    screenshot:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的 `id()` 函数有一个小转折。Python 只支持整数到 `256` 的相同内存分配。以下截图将更清晰：
- en: '![](img/image_02_017-2.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_017-2.jpg)'
- en: Here, as you can see, once we pass values above `256` for `x` and `y`, both
    are given different memory allocations by the interpreter, but if the values are
    `256`, then the same memory allocation is provided for both `x` and `y`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，正如你所看到的，一旦我们为 `x` 和 `y` 传递超过 `256` 的值，解释器会为它们分配不同的内存空间，但如果值是 `256`，那么 `x`
    和 `y` 将会得到相同的内存分配。
- en: Operator precedence
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符优先级
- en: 'Operators with the highest precedence are placed on the top:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级最高的运算符放在顶部：
- en: '| **Operator** | **Description** |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** |'
- en: '| `( )` | Parentheses |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `( )` | 括号 |'
- en: '| `x[index]`,`x[index1:index2]`,`f(arg...)`,`x.attribute` | Subscription, slicing,
    call, and attribute reference |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `x[index]`,`x[index1:index2]`,`f(arg...)`,`x.attribute` | 订阅，切片，调用，和属性引用
    |'
- en: '| `**` | Exponentiation |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `**` | 幂运算 |'
- en: '| `+x`, `-x`, `~x` | Positive, negative, and bitwise *NOT* |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `+x`, `-x`, `~x` | 正数，负数和位运算 *NOT* |'
- en: '| `*`, `/`, `%` | Multiplication, division, and remainder |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `*`, `/`, `%` | 乘法，除法和余数 |'
- en: '| `+`, `-` | Addition and subtraction |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `+`, `-` | 加法和减法 |'
- en: '| `<<`, `>>` | Shifts |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `<<`, `>>` | 移位 |'
- en: '| `&` | Bitwise *AND* |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 位运算 *AND* |'
- en: '| `^` | Bitwise *XOR* |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 位运算 *XOR* |'
- en: '| `&#124;` | Bitwise *OR* |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 位运算 *OR* |'
- en: '| `in`, `not in`, `is`, `is not`, `<`, `<=`, `>`, `>=`, `!=`, `==` | Comparisons,
    including membership tests and identity tests |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `in`, `not in`, `is`, `is not`, `<`, `<=`, `>`, `>=`, `!=`, `==` | 比较运算符，包括成员测试和身份测试
    |'
- en: '| `not x` | Boolean *NOT* |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `not x` | 布尔 *NOT* |'
- en: '| `and` | Boolean *AND* |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `and` | 布尔 *AND* |'
- en: '| `or` | Boolean *OR* |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `or` | 布尔 *OR* |'
- en: '| `if...else` | Conditional expression |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `if...else` | 条件表达式 |'
- en: '| `lambda` | Lambda expression |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `lambda` | Lambda 表达式 |'
- en: Operators that have the same precedence are evaluated from left to right, except
    for comparisons and exponentiation. Comparisons can be chained arbitrarily.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相同优先级的运算符从左到右进行评估，除了比较和指数运算。比较可以任意链式使用。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about various data types available in Python and
    the naming conventions required. You also learned about the Python character set
    and about converting a character set to ASCII code and vice versa, using `ord()`
    and `chr()` methods available in the language. In the next chapter, you will learn
    about two different data types, namely string and tuples.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 Python 中可用的各种数据类型和所需的命名约定。你还学习了 Python 字符集以及如何使用语言中可用的 `ord()` 和 `chr()`
    方法将字符集转换为 ASCII 码以及相反操作。在下一章中，你将学习两种不同的数据类型，即字符串和元组。
