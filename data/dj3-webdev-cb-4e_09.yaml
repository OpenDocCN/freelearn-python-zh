- en: Importing and Exporting Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入和导出数据
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Importing data from a local CSV file
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本地CSV文件导入数据
- en: Importing data from a local Excel file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本地Excel文件导入数据
- en: Importing data from an external JSON file
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从外部JSON文件导入数据
- en: Importing data from an external XML file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从外部XML文件导入数据
- en: Preparing paginated sitemaps for search engines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为搜索引擎准备分页站点地图
- en: Creating filterable RSS feeds
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可过滤的RSS订阅
- en: Using the Django REST framework to create an API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django REST框架创建API
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Once in a while, your data needs to be transported from a local format to the
    database, imported from external resources, or provided to third parties. In this
    chapter, we will take a look at some practical examples of how to write management
    commands and APIs to do this.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，您的数据需要从本地格式传输到数据库，从外部资源导入，或者提供给第三方。在这一章中，我们将看一些实际的例子，演示如何编写管理命令和API来实现这一点。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For working with the code of this chapter, you will need the latest stable version
    of Python, MySQL, or PostgreSQL database and a Django project with a virtual environment.
    Also, make sure to install Django, Pillow, and database bindings into your virtual
    environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用本章的代码，您需要最新稳定版本的Python、MySQL或PostgreSQL数据库，以及一个带有虚拟环境的Django项目。还要确保在虚拟环境中安装Django、Pillow和数据库绑定。
- en: 'You can find all of the code for this chapter in the `ch09` directory of the
    GitHub repository: [https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub存储库的`ch09`目录中找到本章的所有代码：[https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition)。
- en: Importing data from a local CSV file
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从本地CSV文件导入数据
- en: The **Comma-Separated Values** (**CSV**) format is probably the simplest way
    to store tabular data in a text file. In this recipe, we will create a management
    command that imports data from a CSV file to a Django database. We will need a
    CSV list of songs. You can easily create such a file with Excel, Calc, or another
    spreadsheet application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**逗号分隔值**（**CSV**）格式可能是在文本文件中存储表格数据的最简单方式。在这个示例中，我们将创建一个管理命令，将数据从CSV文件导入到Django数据库中。我们需要一个歌曲的CSV列表。您可以使用Excel、Calc或其他电子表格应用程序轻松创建这样的文件。'
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s create a `music` app that we''ll be using throughout this chapter:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`music`应用程序，我们将在本章中使用它：
- en: 'Create the `music` app itself and put it under `INSTALLED_APPS` in the settings:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`music`应用程序本身，并将其放在设置中的`INSTALLED_APPS`下：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Song` model there should contain the `uuid`, `artist`, `title`, `url`,
    and `image` fields. We''ll also extend `CreationModificationDateBase` to add creation
    and modification timestamps, as well as `UrlBase` to add methods to work with
    the model''s detail URLs:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Song`模型应该包含`uuid`、`artist`、`title`、`url`和`image`字段。我们还将扩展`CreationModificationDateBase`以添加创建和修改时间戳，以及`UrlBase`以添加用于处理模型详细URL的方法：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Make and run migrations with the following commands:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建和运行迁移：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, let''s add a simple administration for the `Song` model:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们为`Song`模型添加一个简单的管理：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Also, we need a form for validating and creating `Song` models in the import
    scripts. It''s the most straightforward model form, as follows:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们需要一个用于验证和创建导入脚本中的`Song`模型的表单。它是最简单的模型表单，如下所示：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create and use a management command that imports songs
    from a local CSV file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建和使用一个管理命令，从本地CSV文件导入歌曲：
- en: 'Create a CSV file with the column names, `artist`, `title`, and `url`, in the
    first row. Add some song data to it in the next rows matching the columns. For
    example, it could be a `data/music.csv` file with content like this:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个CSV文件，第一行包含列名`artist`、`title`和`url`。在接下来的行中添加一些歌曲数据，与列匹配。例如，可以是一个内容如下的`data/music.csv`文件：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the `music` app, create a `management` directory and then a `commands` directory
    in the new `management` directory. Put empty `__init__.py` files in both new directories
    to make them Python packages.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`music`应用程序中，创建一个`management`目录，然后在新的`management`目录中创建一个`commands`目录。在这两个新目录中都放入空的`__init__.py`文件，使它们成为Python包。
- en: 'Add an `import_music_from_csv.py` file there with the following content:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那里添加一个名为`import_music_from_csv.py`的文件，内容如下：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, in the same file for the `Command` class, create a `prepare()` method:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`Command`类的同一文件中，创建一个`prepare()`方法：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we should create the `main()` method:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们应该创建`main()`方法：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ll finish the class with the `finalize()` method:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`finalize()`方法完成这个类：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To run the import, call the following in the command line:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行导入，请在命令行中调用以下命令：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Django management commands are scripts with `Command` classes deriving from
    `BaseCommand` and overwriting the `add_arguments()` and `handle()` methods. The `help`
    attribute defines the help text for the management command. It can be seen when
    you type the following in the command line:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Django管理命令是从`BaseCommand`派生的`Command`类的脚本，并覆盖`add_arguments()`和`handle()`方法。`help`属性定义了管理命令的帮助文本。当您在命令行中输入以下内容时，可以看到它：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Django management commands use the built-in `argparse` module to parse the passed
    arguments. The `add_arguments()` method defines what positional or named arguments
    should be passed to the management command. In our case, we will add a positional
    `file_path` argument of the Unicode type. By having the `nargs` variable set to
    the `1` attribute, we allow only one value.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Django管理命令使用内置的`argparse`模块来解析传递的参数。`add_arguments()`方法定义了应该传递给管理命令的位置或命名参数。在我们的情况下，我们将添加一个Unicode类型的位置参数`file_path`。通过将`nargs`变量设置为`1`属性，我们只允许一个值。
- en: To learn about the other arguments that you can define and how to do this, refer
    to the official `argparse` documentation at [https://docs.python.org/3/library/argparse.html#adding-arguments](https://docs.python.org/3/library/argparse.html#adding-arguments).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解您可以定义的其他参数以及如何做到这一点，请参阅官方的`argparse`文档[https://docs.python.org/3/library/argparse.html#adding-arguments](https://docs.python.org/3/library/argparse.html#adding-arguments)。
- en: 'At the beginning of the `handle()` method, the `verbosity` argument is checked.
    Verbosity defines how much Terminal output the command should provide from 0,
    not giving any logging, to 3, providing extensive logging. You can pass this named
    argument to the command as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在`handle()`方法的开始，检查`verbosity`参数。Verbosity定义了命令应该提供多少终端输出，从0，不提供任何日志，到3，提供详尽的日志。您可以将这个命名参数传递给命令，如下所示：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We also expect the filename as the first positional argument. `options["file_path"]`
    returns a list of the values with the length defined in `nargs`. In our case, `nargs`
    equals one; therefore, `options["file_path"]` will be equal to a list of one element.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还期望文件名作为第一个位置参数。`options["file_path"]`返回一个值的列表，其长度由`nargs`定义。在我们的情况下，`nargs`等于一；因此，`options["file_path"]`将等于一个元素的列表。
- en: 'It''s a good practice to split the logics of your management command into multiple
    smaller methods, for example, like we use in this script with `prepare()`, `main()`,
    and `finalize()`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的管理命令的逻辑分割成多个较小的方法是一个很好的做法，例如，就像我们在这个脚本中使用的`prepare()`，`main()`和`finalize()`一样：
- en: The `prepare()` method sets import counters to zero. It could also be used for
    any other setup that is necessary for the script.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prepare()`方法将导入计数器设置为零。它也可以用于脚本所需的任何其他设置。'
- en: In the `main()` method, we execute the main logic of the management command.
    At first, we open the given file for reading and pass its pointer to `csv.DictReader`.
    The first line in the file is assumed to contain headings for each of the columns.
    `DictReader` uses them as keys for the dictionaries for each row. When we iterate
    through the rows, we pass the dictionaries to the model form and try to validate
    it. If validation passes, a song is saved and `imported_counter` is incremented.
    If validation fails, because of too long values, missing required values, wrong
    types, or other validation errors, `skipped_counter` is incremented. If verbosity
    is equal or greater than `NORMAL` (which is number 1), each imported or skipped
    song is also printed out together with possible validation errors.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`main()`方法中，我们执行管理命令的主要逻辑。首先，我们打开给定的文件进行读取，并将其指针传递给`csv.DictReader`。文件中的第一行被假定为每列的标题。`DictReader`将它们用作每行的字典的键。当我们遍历行时，我们将字典传递给模型表单，并尝试验证它。如果验证通过，歌曲将被保存，并且`imported_counter`将被递增。如果验证失败，因为值过长，缺少必需值，错误类型或其他验证错误，`skipped_counter`将被递增。如果verbosity等于或大于`NORMAL`（即数字1），每个导入或跳过的歌曲也将与可能的验证错误一起打印出来。
- en: The `finalize()` method prints out how many songs were imported and how many
    were skipped because of validation errors.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finalize()`方法打印出导入了多少首歌曲，以及因验证错误而被跳过了多少首。'
- en: If you want to debug the errors of a management command while developing it,
    pass the `--traceback` parameter to it. When an error occurs, you will see the
    full stack trace of the problem.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在开发时调试管理命令的错误，请将`--traceback`参数传递给它。当发生错误时，您将看到问题的完整堆栈跟踪。
- en: 'Assuming we invoked the command twice with `--verbosity=1` or higher, the output
    we could expect might be as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用`--verbosity=1`或更高的参数两次调用命令，我们可以期望的输出可能如下：
- en: '![](img/669d9ec1-88f7-4d11-922c-f42b822c335f.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/669d9ec1-88f7-4d11-922c-f42b822c335f.png)'
- en: As you can see, when a song is being imported a second time, it doesn't pass
    the `unique_together` constraint and therefore is skipped.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，当一首歌被导入第二次时，它不会通过`unique_together`约束，因此会被跳过。
- en: See also
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Importing data from a local Excel file* recipe
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从本地Excel文件导入数据*食谱'
- en: The *Importing data from an external JSON file* recipe
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从外部JSON文件导入数据*食谱'
- en: The *Importing data from an external XML file* recipe
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从外部XML文件导入数据*食谱'
- en: Importing data from a local Excel file
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从本地Excel文件导入数据
- en: Another popular format for storing tabular data is an Excel spreadsheet. In
    this recipe, we will import songs from a file of this format.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 存储表格数据的另一种流行格式是Excel电子表格。在这个食谱中，我们将从这种格式的文件中导入歌曲。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s start with the `music` app that we created in the previous recipe. To
    read Excel files, you will need to install the `openpyxl` package, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从之前的食谱中创建的`music`应用程序开始。要读取Excel文件，您需要安装`openpyxl`包，如下所示：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create and use a management command that imports songs
    from a local XLSX file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建并使用一个管理命令，从本地XLSX文件导入歌曲：
- en: 'Create an XLSX file with the column names Artist, Title, and URL in the first
    row. Add some song data to it in the next rows matching the columns. You can do
    this in a spreadsheet application, by saving the CSV file from the previous recipe
    as an XLSX file, `data/music.xlsx`. Here is an example:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个XLSX文件，其中包含列名Artist、Title和URL在第一行。在接下来的行中添加一些与列匹配的歌曲数据。您可以在电子表格应用程序中执行此操作，将前一个食谱中的CSV文件保存为XLSX文件，`data/music.xlsx`。以下是一个示例：
- en: '![](img/593e1328-3062-435a-8fa8-c186382cc759.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/593e1328-3062-435a-8fa8-c186382cc759.png)'
- en: If you haven't done so, in the `music` app, create a `management` directory
    and then a `commands` subdirectory beneath it. Add empty `__init__.py` files in
    both of the new directories to make them Python packages.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果还没有这样做，在`music`应用程序中，创建一个`management`目录，然后在其下创建一个`commands`子目录。在这两个新目录中添加空的`__init__.py`文件，使它们成为Python包。
- en: 'Add an `import_music_from_xlsx.py` file with the following content:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`import_music_from_xlsx.py`的文件，内容如下：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, in the same file for the `Command` class, create a `prepare()` method:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在相同的文件中为`Command`类创建一个`prepare()`方法：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, create the `main()` method there:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在那里创建`main()`方法：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And we''ll finish the class with the `finalize()` method:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用`finalize()`方法完成类：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To run the import, call the following in the command line:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行导入，请在命令行中调用以下命令：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The principle of importing from an XLSX file is the same as with CSV. We open
    the file, read it row by row, form data dictionaries, validate them via a model
    form, and create the `Song` objects from the provided data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从XLSX文件导入的原则与CSV相同。我们打开文件，逐行读取，形成数据字典，通过模型表单验证它们，并从提供的数据创建`Song`对象。
- en: Again, we are using the `prepare()`, `main()`, and `finalize()` methods to split
    the logic into more atomic parts.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们使用`prepare()`、`main()`和`finalize()`方法将逻辑分割成更多的原子部分。
- en: 'Here is a detailed explanation of the `main()` method as it is probably the
    only different part of the management command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`main()`方法的详细说明，因为它可能是管理命令的唯一不同部分：
- en: Excel files are workbooks containing sheets as different tabs.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Excel文件是包含不同选项卡的工作簿。
- en: We are using the `openpyxl` library to open a file passed as a positional argument
    to the command. Then, we read the first sheet from the workbook.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`openpyxl`库打开作为命令的位置参数传递的文件。然后，我们从工作簿中读取第一个工作表。
- en: The first row contains the column captions. We skip it.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行包含列标题。我们跳过它。
- en: Afterward, we will read the rows one by one as lists of values, use the `zip()`
    function to create dictionaries, pass them to a model form, validate, and create
    the `Song` objects from them.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们将逐行读取行作为值列表，使用`zip()`函数创建字典，将它们传递给模型表单，验证，并从中创建`Song`对象。
- en: If there are any validation errors and verbosity is greater than or equal to `NORMAL`,
    then we output the validation errors.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在任何验证错误并且verbosity大于或等于`NORMAL`，那么我们将输出验证错误。
- en: Once again, the management command will print out the imported songs to the
    console, unless you set `--verbosity=0`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次，管理命令将把导入的歌曲打印到控制台上，除非您设置`--verbosity=0`。
- en: 'If we run the command twice with `--verbosity=1` or higher, the output would
    be as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`--verbosity=1`或更高的参数运行命令两次，输出将如下所示：
- en: '![](img/48543c7a-7dce-4d37-90fd-a1626e570c48.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48543c7a-7dce-4d37-90fd-a1626e570c48.png)'
- en: You can learn more about how to work with Excel files at [http://www.python-excel.org/](http://www.python-excel.org/).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://www.python-excel.org/](http://www.python-excel.org/)了解有关如何处理Excel文件的更多信息。
- en: See also
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Importing data from a local CSV file* recipe
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本地CSV文件导入数据的方法
- en: The *Importing data from an external JSON file* recipe
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从外部JSON文件导入数据的方法
- en: The *Importing data from an external XML file* recipe
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从外部XML文件导入数据的方法
- en: Importing data from an external JSON file
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从外部JSON文件导入数据
- en: The [Last.fm](http://last.fm) music website has an API under the [https://ws.audioscrobbler.com/](https://ws.audioscrobbler.com/)
    domain that you can use to read the albums, artists, tracks, events, and more.
    The API allows you to either use the JSON or XML format. In this recipe, we will
    import the top tracks tagged `indie` using the JSON format.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[Last.fm](http://last.fm)音乐网站在[https://ws.audioscrobbler.com/](https://ws.audioscrobbler.com/)域下有一个API，您可以使用它来读取专辑、艺术家、曲目、事件等等。该API允许您使用JSON或XML格式。在这个方法中，我们将使用JSON格式导入标记为“indie”的热门曲目。'
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Follow these steps to import data in the JSON format from `Last.fm`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤从`Last.fm`导入JSON格式的数据：
- en: Let's start with the `music` app that we created in the *Importing data from
    a local CSV file* recipe.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从我们在*从本地CSV文件导入数据*方法中创建的`music`应用程序开始。
- en: To use [Last.fm](http://last.fm), you need to register and get an API key. The
    API key can be
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用[Last.fm](http://last.fm)，您需要注册并获取API密钥。API密钥可以是
- en: created at [https://www.last.fm/api/account/create](https://www.last.fm/api/account/create).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://www.last.fm/api/account/create](https://www.last.fm/api/account/create)创建。
- en: The API key has to be set in the settings as `LAST_FM_API_KEY`. We recommend
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API密钥必须在设置中设置为`LAST_FM_API_KEY`。我们建议
- en: 'providing it from the secrets file or an environment variable and drawing that
    into your settings, as shown here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从秘密文件提供它或从环境变量中提取它并将其绘制到您的设置中，如下所示：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Also, install the `requests` library in your virtual environment using the
    following command:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要使用以下命令在虚拟环境中安装`requests`库：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s check the structure of the JSON endpoint for the top indie tracks (`https://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=indie&api_key=YOUR_API_KEY&format=json`),
    which should look something like this:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来看看用于热门indie曲目的JSON端点的结构（`https://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=indie&api_key=YOUR_API_KEY&format=json`），它应该看起来像这样：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We want to read the track `name`, `artist`, `URL`, and medium-sized images.
    In addition, we are interested in how many pages there exist in total, which is
    provided as meta information at the end of the JSON file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要读取曲目的`名称`、`艺术家`、`URL`和中等大小的图像。此外，我们对总共有多少页感兴趣，这是在JSON文件的末尾作为元信息提供的。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create a `Song` model and a management command, which
    imports the top tracks from [Last.fm](http://last.fm) to the database in JSON
    format:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个`Song`模型和一个管理命令，该命令以JSON格式将[Last.fm](http://last.fm)的热门曲目导入到数据库中：
- en: If you haven't done so, in the `music` app, create a `management` directory,
    and then a `commands` subdirectory beneath it. Add empty `__init__.py` files in
    both of the new directories to make them Python packages.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未这样做，在`music`应用程序中，创建一个`management`目录，然后在其中创建一个`commands`子目录。在这两个新目录中添加空的`__init__.py`文件，使它们成为Python包。
- en: 'Add an `import_music_from_lastfm_json.py` file with the following content:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`import_music_from_lastfm_json.py`文件，内容如下：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, in the same file for the `Command` class, create a `prepare()` method:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`Command`类的同一文件中，创建一个`prepare()`方法：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, create the `main()` method there:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在那里创建`main()`方法：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Each page from the paginated feed will be saved by the `save_page()` method
    that we should create, as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分页源的每一页将由我们应该创建的`save_page()`方法保存，如下所示：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And we''ll finish the class with the `finalize()` method:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`finalize()`方法完成类：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To run the import, call the following in the command line:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行导入，请在命令行中调用以下命令：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As mentioned before, the arguments for scripts can be **positional** if they
    just list a sequence of strings, or **named** if they start with a `--` and a
    variable name. The named `--max_pages` argument limits the imported data to three
    pages. Just skip it, or explicitly pass 0 (zero) if you want to download all of
    the available top tracks.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，脚本的参数可以是**位置**的，如果它们只列出一系列字符串，或者**命名**的，如果它们以`--`和变量名开头。命名的`--max_pages`参数将导入的数据限制为三页。如果要下载所有可用的热门曲目，请跳过它，或者明确传递0（零）。
- en: Beware that there are around 4,500 pages as detailed in the `totalPages` value,
    and this will take a long time and a lot of processing.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`totalPages`值中详细说明了大约有4,500页，这将需要很长时间和大量处理。
- en: 'The structure of our script is similar to the previous import scripts:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本结构与以前的导入脚本类似：
- en: The `prepare()` method is for the setup
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prepare()`方法用于设置'
- en: The `main()` method handles the requests and processes the responses
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main()`方法处理请求并处理响应'
- en: The `save_page()` method saves songs from a single pagination page
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save_page()`方法保存单个分页页面的歌曲'
- en: The `finalize()` method prints out the import statistics
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finalize()`方法打印出导入统计信息'
- en: In the `main()` method, we use `requests.get()` to read the data from [Last.fm](http://last.fm),
    passing the `params` query parameters. The response object has a built-in method
    called `json()`, which converts a JSON string into a parsed dictionary object.
    From the first request, we learn about the total number of pages and then read
    each of them and call the `save_page()` method to parse information and save the
    songs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`方法中，我们使用`requests.get()`来读取来自[Last.fm](http://last.fm)的数据，传递`params`查询参数。响应对象具有名为`json()`的内置方法，它将JSON字符串转换为解析后的字典对象。从第一个请求中，我们了解到总页数，然后读取每一页并调用`save_page()`方法来解析信息并保存歌曲。
- en: In the `save_page()` method, we read the values from the tracks and build a
    dictionary necessary for the model form. We validate the form. If the data is
    valid, the `Song` object is created.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`save_page()`方法中，我们从曲目中读取值并构建模型表单所需的字典。我们验证表单。如果数据有效，则创建`Song`对象。
- en: One interesting part of the import is downloading and saving the image. Here,
    we also use `requests.get()` to retrieve the image data and then we pass it to
    `File` through `BytesIO`, which is accordingly used in the `image.save()` method.
    The first parameter of `image.save()` is a filename that will be overwritten anyway
    by the value from the `upload_to` function and is necessary only for the file
    extension.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的一个有趣部分是下载和保存图像。在这里，我们还使用`requests.get()`来检索图像数据，然后我们通过`BytesIO`将其传递给`File`，这将相应地在`image.save()`方法中使用。
    `image.save()`的第一个参数是一个文件名，无论如何都将被`upload_to`函数的值覆盖，并且仅对于文件扩展名是必需的。
- en: If the command is invoked with a `--verbosity=1` or higher, we will see detailed
    information about the import just like in the previous recipes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`--verbosity=1`或更高的命令调用，我们将看到有关导入的详细信息，就像在以前的食谱中一样。
- en: You can learn more about how to work with [Last.fm](http://last.fm) at [https://www.last.fm/api/](https://www.last.fm/api/).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.last.fm/api/](https://www.last.fm/api/)了解有关如何使用[Last.fm](http://last.fm)的更多信息。
- en: See also
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Importing data from a local CSV file* recipe
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从本地CSV文件导入数据*食谱'
- en: The *Importing data from a local Excel file* recipe
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从本地Excel文件导入数据*食谱'
- en: The *Importing data from an external XML file* recipe
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从外部XML文件导入数据*食谱'
- en: Importing data from an external XML file
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从外部XML文件导入数据
- en: Just as we showed what could be done with JSON in the preceding recipe, the
    [Last.fm](http://last.fm) file also allows you to take data from its services
    in XML format. In this recipe, we will show you how to do this.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的食谱中展示的可以使用JSON做的事情一样，[Last.fm](http://last.fm)文件还允许您以XML格式从其服务中获取数据。在这个食谱中，我们将向您展示如何做到这一点。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Follow these steps to import data in the XML format from [Last.fm](http://last.fm):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤从[Last.fm](http://last.fm)导入XML格式的数据：
- en: Let's start with the `music` app that we created in the *Importing data from
    a local CSV file* recipe.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从我们在*从本地CSV文件导入数据*食谱中创建的`music`应用程序开始。
- en: To use [Last.fm](http://last.fm), you need to register and get an API key. The
    API key can be
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用[Last.fm](http://last.fm)，您需要注册并获取API密钥。 API密钥可以是
- en: created at [https://www.last.fm/api/account/create](https://www.last.fm/api/account/create).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://www.last.fm/api/account/create](https://www.last.fm/api/account/create)创建
- en: The API key has to be set in the settings as `LAST_FM_API_KEY`. We recommend
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API密钥必须在设置中设置为`LAST_FM_API_KEY`。我们建议
- en: 'providing it from the secrets file or an environment variable and drawing that
    into your settings, as shown here:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 提供它来自秘密文件或环境变量，并将其绘制到您的设置中，如下所示：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Also, install the `requests` and `defusedxml` libraries in your virtual environment
    using the following commands:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要使用以下命令在虚拟环境中安装`requests`和`defusedxml`库：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s check the structure of the JSON endpoint for the top indie tracks (`https://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=indie&api_key=YOUR_API_KEY&format=xml`),
    which should look something like this:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查顶级独立曲目的JSON端点的结构（`https://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=indie&api_key=YOUR_API_KEY&format=xml`），应该看起来像这样：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create a `Song` model and a management command, which
    imports the top tracks from [Last.fm](http://last.fm) to the database in XML format:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建`Song`模型和一个管理命令，该命令以XML格式将顶级曲目从[Last.fm](http://last.fm)导入到数据库中：
- en: If you haven't done so, in the `music` app, create a `management` directory
    and then a `commands` subdirectory beneath it. Add empty `__init__.py` files in
    both of the new directories to make them Python packages.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未这样做，请在`music`应用程序中创建一个`management`目录，然后在其中创建一个`commands`子目录。在两个新目录中都添加空的`__init__.py`文件，使它们成为Python包。
- en: 'Add an `import_music_from_lastfm_xml.py` file with the following content:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`import_music_from_lastfm_xml.py`的文件，其中包含以下内容：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, in the same file for the `Command` class, create a `prepare()` method:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后，在`Command`类的同一文件中，创建一个`prepare()`方法： '
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, create the `main()` method there:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在那里创建`main()`方法：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Each page from the paginated feed will be saved by the `save_page()` method
    that we should create, as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分页源的每个页面将由我们应该创建的`save_page()`方法保存，如下所示：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We''ll finish the class with the `finalize()` method:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`finalize()`方法完成课程：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To run the import, call the following in the command line:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行导入，请在命令行中调用以下内容：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The process is analogous to the JSON approach. Using the `requests.get()` method,
    we read the data from [Last.fm](http://last.fm), passing the query parameters
    as `params`. The XML content of the response is passed to the `ElementTree` parser
    from the `defusedxml` module, and the `root` node is returned.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程类似于JSON方法。使用`requests.get()`方法，我们从[Last.fm](http://last.fm)读取数据，将查询参数作为`params`传递。响应的XML内容传递给`defusedxml`模块的`ElementTree`解析器，并返回`root`节点。
- en: The `defusedxml` module is a safer replacement for the `xml` module. It prevents
    XML bombs—a vulnerability allowing the attacker to use a few hundred bytes of
    XML data to occupy Gigabytes of memory.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`defusedxml`模块是`xml`模块的更安全的替代品。它可以防止XML炸弹——一种允许攻击者使用几百字节的XML数据占用几GB内存的漏洞。'
- en: The `ElementTree` nodes have the `find()` and `findall()` methods, where you
    can pass `XPath` queries to filter out specific subnodes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`ElementTree`节点具有`find()`和`findall()`方法，您可以通过这些方法传递`XPath`查询来过滤特定的子节点。'
- en: 'The following is a table of the available XPath syntax supported by `ElementTree`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`ElementTree`支持的可用XPath语法表：
- en: '| **XPath syntax component** | **Meaning** |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **XPath语法组件** | **含义** |'
- en: '| `tag` | This selects all of the child elements with the given tag. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `tag` | 这会选择具有给定标签的所有子元素。'
- en: '| `*` | This selects all of the child elements. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 这会选择所有子元素。'
- en: '| `.` | This selects the current node. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 这会选择当前节点。 |'
- en: '| `//` | This selects all of the subelements on all of the levels beneath the
    current element. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `//` | 这会选择当前元素下所有级别的所有子元素。'
- en: '| `..` | This selects the parent element. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `..` | 这会选择父元素。'
- en: '| `[@attrib]` | This selects all of the elements that have the given attribute.
    |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `[@attrib]` | 这会选择具有给定属性的所有元素。 |'
- en: '| `[@attrib=''value'']` | This selects all of the elements for which the given
    attribute has the given value. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `[@attrib=''value'']` | 这会选择具有给定值的给定属性的所有元素。 |'
- en: '| `[tag]` | This selects all of the elements that have a child named tag. Only
    immediate children are supported. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `[tag]` | 这会选择具有名为tag的子元素的所有元素。仅支持直接子元素。 |'
- en: '| `[position]` | This selects all of the elements that are located at the given
    position. The position can either be an integer (`1` is the first position), the
    `last()` expression (for the last position), or a position relative to the last
    position (for example, `last()-1`). |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `[position]` | 这会选择位于给定位置的所有元素。位置可以是整数（`1`是第一个位置），`last()`表达式（用于最后位置），或相对于最后位置的位置（例如，`last()-1`）。'
- en: Therefore, in the `main()` method, using `root.find("tracks").attrib.get("totalPages",
    1)`, we read the total amount of pages, defaulting to one if the data is missing
    somehow. We will save the first page and then go through the other pages one by
    one and save them too.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`main()`方法中，使用`root.find("tracks").attrib.get("totalPages", 1)`，我们读取页面的总数，如果数据不完整，则默认为1。我们将保存第一页，然后逐个保存其他页面。
- en: In the `save_page()` method, `root.findall("tracks/track")` returns an iterator
    through the `<track>` nodes under the `<tracks>` node. With `track_node.find("image[@size='medium']")`,
    we get the medium-sized image. Again, `Song` creation happens through the model
    form which is used to validate the incoming data.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在`save_page()`方法中，`root.findall("tracks/track")`返回一个迭代器，通过`<tracks>`节点下的`<track>`节点。使用`track_node.find("image[@size='medium']")`，我们获得中等大小的图像。同样，`Song`的创建是通过用于验证传入数据的模型表单完成的。
- en: If we call the command with `--verbosity=1` or higher, we will see detailed
    information about the imported songs just like in the previous recipes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`--verbosity=1`或更高的命令调用，我们将看到有关导入歌曲的详细信息，就像在以前的食谱中一样。
- en: There's more...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can learn more from the following links:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下链接了解更多信息：
- en: Read about how to work with [Last.fm](http://last.fm) at [https://www.last.fm/api/](https://www.last.fm/api/).
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读如何在[Last.fm](http://last.fm)上使用[https://www.last.fm/api/](https://www.last.fm/api/)。
- en: Read about XPath at [https://en.wikipedia.org/wiki/XPath](https://en.wikipedia.org/wiki/XPath).
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://en.wikipedia.org/wiki/XPath](https://en.wikipedia.org/wiki/XPath)上阅读有关XPath的信息。
- en: The full documentation of `ElementTree` can be found at [https://docs.python.org/3/library/xml.etree.elementtree.html](https://docs.python.org/3/library/xml.etree.elementtree.html).
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://docs.python.org/3/library/xml.etree.elementtree.html](https://docs.python.org/3/library/xml.etree.elementtree.html)找到`ElementTree`的完整文档。
- en: See also
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Importing data from a local CSV file* recipe
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从本地CSV文件导入数据*食谱'
- en: The *Importing data from a local Excel file* recipe
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从本地Excel文件导入数据*食谱'
- en: The *Importing data from an external JSON file* recipe
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从外部JSON文件导入数据*食谱'
- en: Preparing paginated sitemaps for search engines
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为搜索引擎准备分页站点地图
- en: '**Sitemaps** protocol tells search engines about all different pages on your
    website. Usually, it''s a single `sitemap.xml` file that informs what can be indexed
    and how often. If you have lots of different pages on your website, you can also
    split and paginate the XML file to render each list of resources faster.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**站点地图**协议告诉搜索引擎有关网站上所有不同页面的信息。通常，它是一个单一的`sitemap.xml`文件，通知可以被索引以及频率。如果您的网站上有很多不同的页面，您还可以拆分和分页XML文件，以更快地呈现每个资源列表。'
- en: In this recipe, we will show you how to create a paginated sitemap to use in
    your Django website.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将向您展示如何创建一个分页站点地图，以在您的Django网站中使用。
- en: Getting ready
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this and further recipes, we need to extend the `music` app and add list
    and detail views there:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个和其他食谱，我们需要扩展`music`应用程序并在那里添加列表和详细视图：
- en: 'Create the `views.py` file with the following content:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有以下内容的`views.py`文件：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create the `urls.py` file with the following content:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有以下内容的`urls.py`文件：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Include that URL configuration into the project''s URL configuration:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该URL配置包含到项目的URL配置中：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create a template for the song list view:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为歌曲列表视图创建一个模板：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, create one for the song detail view:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为歌曲详细视图创建一个：
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To add the paginated sitemap, follow these steps:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加分页网站地图，请按照以下步骤操作：
- en: 'Include `django.contrib.sitemaps` in `INSTALLED_APPS` in the settings:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置中的`INSTALLED_APPS`中包含`django.contrib.sitemaps`：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Modify `urls.py` of your project as follows:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下方式修改项目的`urls.py`：
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If you look at `http://127.0.0.1:8000/sitemap.xml`, you will see the index
    with paginated sitemaps:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看`http://127.0.0.1:8000/sitemap.xml`，您将看到带有分页网站地图的索引：
- en: '[PRE44]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here each page will display up to 50 entries with a URL, its last modification,
    and priority:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 每个页面将显示最多50个条目，带有URL、最后修改时间和优先级：
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When your site is ready and published to production, you can inform **Google
    Search Engine** about your pages with the `ping_google` management command provided
    by the sitemap framework. Execute this command at the production server as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的网站准备就绪并发布到生产环境时，您可以使用网站地图框架提供的`ping_google`管理命令通知**Google搜索引擎**有关您的页面。在生产服务器上执行以下命令：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: There's more...
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can learn more from the following links:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下链接了解更多信息：
- en: Read about the sitemaps protocol at [https://www.sitemaps.org/](https://www.sitemaps.org/)
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[这里](https://www.sitemaps.org/)阅读有关网站地图协议的信息。
- en: Read more about Django sitemap framework at
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[这里](https://docs.djangoproject.com/en/3.0/ref/contrib/sitemaps/)阅读有关Django网站地图框架的更多信息
- en: '[https://docs.djangoproject.com/en/3.0/ref/contrib/sitemaps/](https://docs.djangoproject.com/en/3.0/ref/contrib/sitemaps/)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.djangoproject.com/en/3.0/ref/contrib/sitemaps/](https://docs.djangoproject.com/en/3.0/ref/contrib/sitemaps/)'
- en: See also
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating filterable RSS feeds* recipe
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建可过滤的RSS订阅*示例'
- en: Creating filterable RSS feeds
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可过滤的RSS订阅
- en: Django comes with a **syndication feed framework** that allows you to create
    **Really Simple Syndication** (**RSS**) and **Atom** feeds. RSS and Atom feeds
    are XML documents with specific semantics. They can be subscribed to an RSS reader,
    such as Feedly, or they can be aggregated in other websites, mobile applications,
    or desktop applications. In this recipe, we will create an RSS feed that provides
    information about songs. Moreover, the results will be filterable by URL query
    parameters.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Django带有一个**聚合源框架**，允许您创建**真正简单的聚合**（**RSS**）和**Atom**源。RSS和Atom源是具有特定语义的XML文档。它们可以订阅到RSS阅读器，如Feedly，或者它们可以在其他网站、移动应用程序或桌面应用程序中进行聚合。在这个示例中，我们将创建一个提供有关歌曲信息的RSS源。此外，结果将可以通过URL查询参数进行过滤。
- en: Getting ready
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start by creating the `music` app from the *Importing data from a local CSV
    file* and *Preparing paginated sitemaps for search engines* recipes. Specifically,
    follow the steps in the *Getting ready* section to set up the models, forms, 
    views, URL configurations, and templates.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，根据*从本地CSV文件导入数据*和*为搜索引擎准备分页网站地图*的步骤创建`music`应用程序。具体来说，请按照*准备工作*部分中的步骤设置模型、表单、视图、URL配置和模板。
- en: 'To the view listing songs, we will add filtering by artist that later will
    be used by the RSS feed too:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列出歌曲的视图，我们将添加按艺术家过滤的功能，稍后RSS订阅也将使用该功能：
- en: 'Add a filter form to `forms.py`. It will have the `artist` choice field with
    all artist names sorted alphabetically with letter case ignored:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`forms.py`中添加一个过滤表单。它将具有`artist`选择字段，其中所有艺术家名称都按字母顺序排序，忽略大小写：
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Enhance the `SongList` view with the methods to manage the filtering: the `get()`
    method will handle the filtering and display results, the `get_form_kwargs()`
    method will prepare the keyword arguments for the filter form, and the `get_queryset()`
    method will filter songs by artist:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用方法增强`SongList`视图来管理过滤：`get()`方法将处理过滤并显示结果，`get_form_kwargs()`方法将为过滤表单准备关键字参数，`get_queryset()`方法将按艺术家过滤歌曲：
- en: '[PRE48]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Modify the song list template to add the form for filtering:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改歌曲列表模板以添加过滤表单：
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you now check the song list view in the browser and filter songs by, let''s
    say, Lana Del Rey, you would see results like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在在浏览器中检查歌曲列表视图并按照，比如说，Lana Del Rey进行歌曲过滤，您将看到以下结果：
- en: '![](img/cfefc603-0bcb-4f52-9c22-eceda7cd8df6.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfefc603-0bcb-4f52-9c22-eceda7cd8df6.png)'
- en: The URL of the filtered song list will be `http://127.0.0.1:8000/en/songs/?artist=Lana+Del+Rey`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤后的歌曲列表的URL将是`http://127.0.0.1:8000/en/songs/?artist=Lana+Del+Rey`。
- en: How to do it...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Now, we will add the RSS feed to the music app:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向音乐应用程序添加RSS订阅：
- en: 'In the `music` app, create the `feeds.py` file and add the following content:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`music`应用程序中，创建`feeds.py`文件并添加以下内容：
- en: '[PRE50]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create a template for the song descriptions in the RSS feed:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为RSS源中的歌曲描述创建一个模板：
- en: '[PRE51]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Plug in the RSS feed in the URL configuration of the app:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的URL配置中插入RSS源：
- en: '[PRE52]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the template of the song list view, add a link to the RSS feed:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在歌曲列表视图的模板中，添加到RSS源的链接：
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works...
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you refresh the filtered list view at `http://127.0.0.1:8000/en/songs/?artist=Lana+Del+Rey`,
    you will see the Subscribe to RSS feed link that leads to `http://127.0.0.1:8000/en/songs/rss/?artist=Lana+Del+Rey`.
    This will be the RSS feed of up to 30 songs filtered by the artist.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您刷新`http://127.0.0.1:8000/en/songs/?artist=Lana+Del+Rey`上的过滤列表视图，您将看到指向`http://127.0.0.1:8000/en/songs/rss/?artist=Lana+Del+Rey`的订阅RSS订阅链接。这将是按艺术家筛选的最多30首歌曲的RSS订阅。
- en: 'The `SongFeed` class takes care of automatically generating the XML markup
    for the RSS feed. We specified the following methods there:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`SongFeed`类负责自动生成RSS源的XML标记。我们在那里指定了以下方法：'
- en: The `get_object()` method defines the context dictionary for the `Feed` class
    that will be used by other methods.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_object()`方法为`Feed`类定义了上下文字典，其他方法将使用它。'
- en: The `title()` method defines the title of the feed depending on whether the
    results are filtered or not.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title()`方法根据结果是否被过滤定义了源的标题。'
- en: The `link()` method returns the URL of the list view, whereas `feed_url()` returns
    the URL of the feed. Both of them are using a helper method, `get_named_url()`,
    which forms a URL by pathname and query parameters.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`link()`方法返回列表视图的URL，而`feed_url()`返回订阅的URL。它们都使用一个辅助方法`get_named_url()`，该方法通过路径名和查询参数形成URL。'
- en: The `items()` method returns the `queryset` of songs, optionally filtered by
    artist.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`items()`方法返回歌曲的`queryset`，可以按艺术家进行筛选。'
- en: The `item_pubdate()` method returns the creation date of the song.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`item_pubdate()`方法返回歌曲的创建日期。'
- en: To see all of the available methods and properties of the `Feed` class that
    we are extending, refer to the following documentation at [https://docs.djangoproject.com/en/3.0/ref/contrib/syndication/#feed-class-reference](https://docs.djangoproject.com/en/3.0/ref/contrib/syndication/#feed-class-reference).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们正在扩展的`Feed`类的所有可用方法和属性，请参阅以下文档：[https://docs.djangoproject.com/en/3.0/ref/contrib/syndication/#feed-class-reference](https://docs.djangoproject.com/en/3.0/ref/contrib/syndication/#feed-class-reference)。
- en: See also
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Importing data from a local CSV file* recipe
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从本地CSV文件导入数据*示例'
- en: The *Preparing paginated sitemaps for search engines* recipe
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为搜索引擎准备分页站点地图*示例'
- en: Using Django REST framework to create an API
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Django REST框架创建API
- en: When you need to create a RESTful API for your models to transfer data to and
    from third parties, the **Django REST framework** is probably the best tool you
    can use. This framework has extensive documentation and a Django-centric implementation,
    helping to make it more maintainable. In this recipe, you will learn how to use
    the Django REST framework to allow your project partners, mobile clients, or Ajax-based
    website to access data on your site to create, read, update, and delete content
    as appropriate.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要为您的模型创建RESTful API以便与第三方传输数据时，**Django REST框架**可能是您可以使用的最佳工具。该框架有广泛的文档和基于Django的实现，有助于使其更易于维护。在这个示例中，您将学习如何使用Django
    REST框架，以允许您的项目合作伙伴、移动客户端或基于Ajax的网站访问您网站上的数据，以适当地创建、读取、更新和删除内容。
- en: Getting ready
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First of all, install the Django REST Framework in your virtual environment
    using the following command:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在虚拟环境中使用以下命令安装Django REST框架：
- en: '[PRE54]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Add `"rest_framework"` to `INSTALLED_APPS` in the settings.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置的`INSTALLED_APPS`中添加`"rest_framework"`。
- en: 'Then, enhance the `music` app that we defined in the *Importing data from a
    local CSV file* recipe. You will also want to collect the static files provided
    by the Django REST framework for the pages it provides to be as nicely styled
    as possible:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，增强我们在*从本地CSV文件导入数据*示例中定义的`music`应用程序。您还希望收集Django REST框架提供的静态文件，以使其提供的页面样式尽可能漂亮：
- en: '[PRE55]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How to do it...
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To integrate a new RESTful API in our `music` app, execute the following steps:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的`music`应用程序中集成新的RESTful API，请执行以下步骤：
- en: 'Add configurations for the Django REST framework to the settings, as shown
    here:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置中为Django REST框架添加配置，如下所示：
- en: '[PRE56]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the `music` app, create the `serializers.py` file with the following content:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`music`应用程序中，创建`serializers.py`文件，内容如下：
- en: '[PRE57]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add two new class-based views to the `views.py` file in the `music` app:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`music`应用程序的`views.py`文件中添加两个基于类的视图：
- en: '[PRE58]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, plug in the new views to the project URL configuration:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将新视图插入到项目URL配置中：
- en: '[PRE59]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works...
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'What we created here is an API for the music, where you can read a paginated
    song list, create a new song, and read, change, or delete a single song by ID.
    Reading is allowed without authentication, but you have to have a user account
    with the appropriate permissions to add, change, or delete a song. The Django
    REST framework provides you with web-based API documentation that is shown when
    you access the API endpoints in a browser via `GET`. Without logging in, the framework
    would display something like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建的是一个音乐API，您可以阅读分页的歌曲列表，创建新歌曲，并通过ID阅读、更改或删除单个歌曲。阅读是允许的，无需身份验证，但是您必须拥有具有适当权限的用户帐户才能添加、更改或删除歌曲。Django
    REST框架为您提供基于Web的API文档，当您通过`GET`在浏览器中访问API端点时会显示出来。未登录时，框架会显示类似以下内容：
- en: '![](img/cd2daa28-8624-4711-a718-076ef523be69.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd2daa28-8624-4711-a718-076ef523be69.png)'
- en: 'Here''s how you can approach the created API:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以使用创建的API的方法：
- en: '| **URL** | **HTTP Method** | **Description** |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| **URL** | **HTTP方法** | **描述** |'
- en: '| `/rest-api/songs/` | `GET` | List songs paginated by 50. |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `/rest-api/songs/` | `GET` | 按50页列出歌曲。 |'
- en: '| `/rest-api/songs/` | `POST` | Create a new song if the requesting user is
    authenticated and authorized to create songs. |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `/rest-api/songs/` | `POST` | 如果请求的用户经过身份验证并被授权创建歌曲，则创建新歌曲。 |'
- en: '| `/rest-api/songs/b328109b-``5ec0-4124-b6a9-e963c62d212c/` | `GET` | Get a
    song with the ID `b328109b-5ec0-4124-b6a9-e963c62d212c`. |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `/rest-api/songs/b328109b-``5ec0-4124-b6a9-e963c62d212c/` | `GET` | 获取ID为`b328109b-5ec0-4124-b6a9-e963c62d212c`的歌曲。
    |'
- en: '| `/rest-api/songs/b328109b-``5ec0-4124-b6a9-e963c62d212c/` | `PUT` | Update
    a song with the ID `b328109b-5ec0-4124-b6a9-e963c62d212c` if the user is authenticated
    and authorized to change songs. |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `/rest-api/songs/b328109b-``5ec0-4124-b6a9-e963c62d212c/` | `PUT` | 如果用户经过身份验证并被授权更改歌曲，则更新ID为`b328109b-5ec0-4124-b6a9-e963c62d212c`的歌曲。
    |'
- en: '| `/rest-api/songs/b328109b-``5ec0-4124-b6a9-e963c62d212c/` | `DELETE` | Delete
    the song with the ID `b328109b-5ec0-4124-b6a9-e963c62d212c` if the user is authenticated
    and authorized to delete songs. |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `/rest-api/songs/b328109b-``5ec0-4124-b6a9-e963c62d212c/` | `DELETE` | 如果用户经过身份验证并被授权删除歌曲，则删除ID为`b328109b-5ec0-4124-b6a9-e963c62d212c`的歌曲。
    |'
- en: 'You might ask how you would use the API practically. For example, we might
    use the `requests` library to create a new song from a Python script, as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问如何实际使用API。例如，我们可以使用`requests`库从Python脚本中创建新歌曲，如下所示：
- en: '[PRE60]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The same could be done via **Postman** app, which provides a user-friendly
    interface for submitting requests, as seen here:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过**Postman**应用程序来实现，该应用程序提供了一个用户友好的界面来提交请求，如下所示：
- en: '![](img/0605f718-271f-428b-a134-5e1a8cbbe6a9.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0605f718-271f-428b-a134-5e1a8cbbe6a9.png)'
- en: 'You can also try out the APIs via integrated forms under the framework-generated
    API documentation when logged in, as shown in the following screenshot:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当登录时，您还可以通过框架生成的API文档下的集成表单尝试API，如下截图所示：
- en: '![](img/63df3efe-5bfc-4179-9916-e2c4fd7aada4.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63df3efe-5bfc-4179-9916-e2c4fd7aada4.png)'
- en: Let's take a quick look at how the code that we wrote works. In the settings,
    we have set the access to be dependent on the permissions of the Django system.
    For anonymous requests, only reading is allowed. Other access options include
    allowing any permission to everyone, any permission only to authenticated users,
    any permission to staff users, and so on. The full list can be found at [https://www.django-rest-framework.org/api-guide/permissions/](https://www.django-rest-framework.org/api-guide/permissions/).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下我们编写的代码是如何工作的。在设置中，我们已经设置了访问权限取决于Django系统的权限。对于匿名请求，只允许阅读。其他访问选项包括允许任何用户拥有任何权限，只允许经过身份验证的用户拥有任何权限，允许工作人员用户拥有任何权限等等。完整列表可以在[https://www.django-rest-framework.org/api-guide/permissions/](https://www.django-rest-framework.org/api-guide/permissions/)上找到。
- en: Then, in the settings, pagination is set. The current option is to have the
    limit and offset parameters as in an SQL query. Other options are to have either
    the pagination by page numbers for rather static content or cursor pagination
    for real-time data. We set the default pagination to 50 items per page.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在设置中，设置了分页。当前选项是将限制和偏移参数设置为SQL查询中的参数。其他选项是对静态内容使用页面编号进行分页，或者对实时数据使用游标分页。我们将默认分页设置为每页50个项目。
- en: Later, we define a serializer for the songs. It controls the data that will
    be shown in the output and validates the input. There are various ways to serialize
    relations in the Django REST framework, and we chose the most verbose one in our
    example.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们为歌曲定义了一个序列化程序。它控制将显示在输出中的数据并验证输入。在Django REST框架中，有各种序列化关系的方法，我们在示例中选择了最冗长的方法。
- en: To read more about how to serialize relations, refer to the documentation at
    [https://www.django-rest-framework.org/api-guide/relations/](https://www.django-rest-framework.org/api-guide/relations/).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何序列化关系，请参阅[https://www.django-rest-framework.org/api-guide/relations/](https://www.django-rest-framework.org/api-guide/relations/)上的文档。
- en: After defining the serializers, we created two class-based views to handle the
    API endpoints and plugged them into the URL configuration. In the URL configuration,
    we also have a rule (`/api-auth/`) for browsable API pages, login, and logout.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了序列化程序之后，我们创建了两个基于类的视图来处理API端点，并将它们插入到URL配置中。在URL配置中，我们还有一个规则（`/api-auth/`）用于可浏览的API页面，登录和注销。
- en: See also
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Preparing paginated sitemaps for search engines* recipe
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为搜索引擎准备分页站点地图*食谱'
- en: The *Creating filterable RSS feeds* recipe
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建可过滤的RSS提要*食谱'
- en: The *Testing an API created using Django REST framework* recipe in [Chapter
    11](f22676ec-495d-430d-a535-06a7c9001e61.xhtml)*, Testing*
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第11章](f22676ec-495d-430d-a535-06a7c9001e61.xhtml)*，测试*中的*使用Django REST框架创建的API进行测试*食谱
