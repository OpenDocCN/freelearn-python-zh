- en: Chapter 3. Database Abstraction Layer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。数据库抽象层
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating a new model
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新模型
- en: Creating a model from a csv file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从csv文件创建模型
- en: Batch upload of your data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量上传你的数据
- en: Moving your data from one database to another
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的数据从一个数据库迁移到另一个数据库
- en: Creating a model from existing MySQL and PostgreSQL databases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从现有的MySQL和PostgreSQL数据库创建模型
- en: Efficiently searching by tag
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过标签高效搜索
- en: Accessing your database from multiple applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从多个应用程序访问你的数据库
- en: Hierarchical category tree
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层次分类树
- en: Creating records on demand
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按需创建记录
- en: OR, LIKE, BELONGS, and more on Google App Engine
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，LIKE，BELONGS，以及更多关于Google App Engine的内容
- en: Replacing slow virtual fields with DB views
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用DB视图替换慢速虚拟字段
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The **Database Abstraction Layer (DAL)** is probably the major strength of web2py.
    The DAL exposes a simple **Applications Programming Interface (API)** to the underlying
    SQL syntax, and this may hide its true power. In the recipes of this chapter,
    we provide examples of non-trivial applications of the DAL, such as building queries
    to search by tags efficiently and building a hierarchical category tree.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库抽象层（DAL）**可能是web2py的主要优势。DAL向底层的SQL语法暴露了一个简单的**应用程序编程接口（API）**，这可能会隐藏其真正的力量。在本章的食谱中，我们提供了DAL的非平凡应用示例，例如构建高效按标签搜索的查询和构建层次分类树。'
- en: Creating a new model
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新模型
- en: As shown in the recipes in the previous chapter, most applications require a
    database, and building the database model is the first step in the design of the
    application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章的食谱所示，大多数应用程序都需要数据库，构建数据库模型是应用程序设计的第一步。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Here we assume that you have a newly created application, and you will be putting
    the models in a file called `models/db_custom.py`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们假设你有一个新创建的应用程序，你将把模型放入一个名为`models/db_custom.py`的文件中。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First of all, you need a database connection. This is created by the DAL object.
    For example:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要一个数据库连接。这是由DAL对象创建的。例如：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that this line is already in the file `models/db.py`, and therefore you
    may not need it, unless you deleted it or need to connect to a different database.
    By default, web2py connects to an `sqlite` database stored in file storage.sqlite.
    This file is located in the application's databases folder. If the file is not
    there, it is created by web2py when the application is first executed.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这一行已经存在于`models/db.py`文件中，因此你可能不需要它，除非你删除了它或需要连接到不同的数据库。默认情况下，web2py连接到存储在文件存储.sqlite中的`sqlite`数据库。此文件位于应用程序的数据库文件夹中。如果该文件不存在，则在应用程序首次执行时由web2py创建。
- en: SQLite is fast, and stores all data in one single file. This means that your
    data can be easily transferred from one application to another. In fact, the `sqlite`
    database(s) are packaged by web2py together with the applications. It provides
    full SQL support, including translations, joins, and aggregates. Moreover SQLite
    comes standard with Python 2.5 and later, and therefore, it is already available
    to your web2py installation.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SQLite速度快，并且将所有数据存储在一个单独的文件中。这意味着你的数据可以轻松地从应用程序转移到另一个应用程序。实际上，`sqlite`数据库（们）是由web2py与应用程序一起打包的。它提供了完整的SQL支持，包括翻译、连接和聚合。此外，SQLite从Python
    2.5及以后的版本开始就自带了，因此，它已经包含在你的web2py安装中了。
- en: There are two disadvantages of SQLite. One is that it does not enforce column
    types, and there is no `ALTER TABLE` except for adding and dropping columns. The
    other disadvantage is that the entire database is locked by any transaction that
    requires write access. Therefore, the database cannot be accessed concurrently
    except for reading.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SQLite有两个缺点。一个是它不强制执行列类型，除了添加和删除列之外，没有`ALTER TABLE`。另一个缺点是任何需要写访问权限的事务都会锁定整个数据库。因此，数据库除了读取之外不能并发访问。
- en: These features make it a good option for development purposes and low-traffic
    websites, but not a viable solution for high-traffic sites.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些特性使其成为开发目的和低流量网站的不错选择，但不是高流量网站的可行解决方案。
- en: In the following recipe, we will show you how to connect to a different type
    of database.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的食谱中，我们将向你展示如何连接到不同类型的数据库。
- en: 'Once we have a `db` object, we can use the `define_table` method to define
    new tables. For example:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了`db`对象，我们就可以使用`define_table`方法来定义新表。例如：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The syntax is always the same. The first argument is the **table name**, and
    it is followed by a list of Field(s). The field constructor takes the following
    arguments:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 语法始终相同。第一个参数是**表名**，其后跟一个字段列表。字段构造函数接受以下参数：
- en: '**The field name**'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字段名**'
- en: '**The field type:** This can take values having any of the following datatypes
    - `string` (default), `text, boolean, integer, double, password, date, time, datetime,
    upload, blob, reference other_table, list:string, list:integer`, and `list:reference
    other_table`. Internally, `upload, password`, and `list` types are equivalent
    to `string`, but at the web2py level, they are handled differently.'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字段类型**：这可以接受以下数据类型之一的值 - `string`（默认），`text, boolean, integer, double, password,
    date, time, datetime, upload, blob, reference other_table, list:string, list:integer`，和
    `list:reference other_table`。内部，`upload, password` 和 `list` 类型等同于 `string`，但在
    web2py 级别，它们被不同地处理。'
- en: '`length=512:` This is the maximum length for string-based fields. It is ignored
    for non-text based fields.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length=512:` 这是基于字符串的字段的最大长度。对于非文本字段，此值被忽略。'
- en: '`default=None:` This is the default value when a new record is inserted. The
    value of this attribute can be a function that is called when a value is needed
    (for example, on record insert, if no value is specified).'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default=None:` 这是插入新记录时的默认值。此属性的值可以是当需要值时调用的函数（例如，在记录插入时，如果没有指定值）。'
- en: '`update=None:` This works the same as default, but the value is used only on
    update, not on insert.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update=None:` 这与默认值相同，但仅在更新时使用该值，而不是在插入时使用。'
- en: '`ondelete=''CASCADE'':` This maps onto the corresponding SQL `ON DELETE` attribute.'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ondelete=''CASCADE'':` 这映射到相应的 SQL `ON DELETE` 属性。'
- en: '`notnull=False:` This specifies whether the field value can be `NULL` or not
    (enforced at database level).'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notnull=False:` 这指定字段值是否可以是 `NULL`（在数据库级别强制执行）。'
- en: '`unique=False:` This specifies whether the field value must be unique or not
    (enforced at database level).'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique=False:` 这指定字段值是否必须是唯一的（在数据库级别强制执行）。'
- en: '`requires=[]:` This is a list of web2py validators (enforced at the level of
    web2py forms). Most field types have default validators.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requires=[]:` 这是一组 web2py 验证器（在 web2py 表单级别强制执行）。大多数字段类型都有默认验证器。'
- en: '`required=False:` This is not to be confused with requires, and it tells web2py
    that a value for this field must be specified during insert and update. For a
    `required` field, default and update values are ignored. Unless used together
    with `notnull=True`, the `None` value is an acceptable value, even if the field
    is required.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required=False:` 这不要与 requires 混淆，并且它告诉 web2py 在插入和更新期间必须指定此字段的值。对于 `required`
    字段，默认值和更新值将被忽略。除非与 `notnull=True` 一起使用，否则即使字段是必需的，`None` 值也是可接受的。'
- en: '`readable=True:` This specifies whether the field is readable in forms or not.'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readable=True:` 这指定字段在表单中是否可读。'
- en: '`writable=True:` This specifies whether the field is writable in forms or not.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writable=True:` 这指定字段在表单中是否可写。'
- en: '`represent=(lambda value: value):` This is a function that is used to display
    the value of the field in forms and tables.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`represent=(lambda value: value):` 这是一个用于在表单和表中显示字段值的函数。'
- en: '`widget=SQLHTML.widgets.string.widget:` This is a function that will build
    the input widget in forms.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`widget=SQLHTML.widgets.string.widget:` 这是一个将在表单中构建输入小部件的函数。'
- en: '`label="Field Name":` This is the label to be used for this field in forms.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label="Field Name":` 这是用于表单中此字段的标签。'
- en: '`comment="...":` This is a comment to be added to this field in forms.'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comment="...":` 这是在表单中添加到该字段的注释。'
- en: The `Field` constructor has other attributes that are specific to upload type
    fields. See the web2py book for further information.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Field` 构造函数还有其他特定于上传类型字段的属性。有关更多信息，请参阅 web2py 书籍。'
- en: 'The `define_table` method also takes three named arguments:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`define_table` 方法还接受三个命名参数：'
- en: '[PRE2]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`migrate=True:` This instructs web2py to create the table if it does not exist,
    or alter it if it does not match the model definition. This process is accompanied
    by the creation of metadata files. The metadata files have the form `databases/<hash>_<name>.table`,
    and will be used to keep track of changes in the model, and perform automatic
    migrations. Set `migrate=False` to disable automatic migrations.'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`migrate=True:` 这指示 web2py 在不存在时创建表，或在它不匹配模型定义时修改它。此过程伴随着元数据文件的创建。元数据文件的形式为
    `databases/<hash>_<name>.table`，并将用于跟踪模型的变化，并执行自动迁移。将 `migrate=False` 设置为禁用自动迁移。'
- en: '`fake_migrate=False:` Sometimes the above metadata gets corrupt (or accidentally
    deleted), and needs to be re-created. If the model matches the database table
    content, then set `fake_migrate=True`, and web2py will rebuild the metadata.'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fake_migrate=False:` 有时上述元数据会损坏（或意外删除），需要重新创建。如果模型与数据库表内容匹配，则设置`fake_migrate=True`，web2py将重新构建元数据。'
- en: '`format=''%(id)s'':` This is a format string that determines how records of
    this table should be represented when referenced by another table in forms (for
    example in select dropboxes). The format can be a function that takes a row object
    that returns a string.'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format=''%(id)s'':` 这是一个格式化字符串，它决定了当其他表在表单（例如在选择下拉框中）中引用此表的记录时应如何表示。格式可以是一个函数，它接受一个行对象并返回一个字符串。'
- en: There's more...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In all databases, but SQLite and Google App Engine datastore, if you change
    a table definition, an `ALTER TABLE` is issued to make sure the database matches
    the model. In SQLite, the `ALTER TABLE` is only performed when a column is added
    or deleted, not when a field type changes (because SQLite does not enforce it).
    In Google App Engine datastore, there is no concept of `ALTER TABLE`, and columns
    can be added but not deleted; web2py will ignore columns not listed in the model.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有数据库中，但SQLite和Google App Engine数据存储，如果您更改表定义，则会发出`ALTER TABLE`以确保数据库与模型匹配。在SQLite中，只有在添加或删除列时才会执行`ALTER
    TABLE`，而不是当字段类型更改时（因为SQLite不强制执行）。在Google App Engine数据存储中，没有`ALTER TABLE`的概念，可以添加列但不能删除；web2py将忽略模型中未列出的列。
- en: Completely removing a `define_table` from the model does not result in a `DROP
    TABLE`. The table simply becomes inaccessible to web2py until the corresponding
    `define_table` is put back. This prevents accidental deletion of data. You can
    drop tables in web2py using the command `db.<name>.drop()`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 完全从模型中删除`define_table`不会导致`DROP TABLE`。该表只是直到相应的`define_table`被放回，对web2py不可访问。这防止了数据的意外删除。您可以使用`db.<name>.drop()`命令在web2py中删除表。
- en: Creating a model from a CSV file
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从CSV文件创建模型
- en: Consider the scenario in which you have a CSV file and you do not know much
    about it. Yet you want to create a web application to access the data in the CSV
    file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个场景：您有一个CSV文件，您对它知之甚少。但您仍然想创建一个Web应用程序来访问CSV文件中的数据。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: I will assume you have the csv file in a folder
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我将假设您有一个csv文件在文件夹中
- en: '`/tmp/mydata.csv`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`/tmp/mydata.csv`'
- en: You will also need a program called `csvstudio`, which you can download from
    [http://csvstudio.googlecode.com/hg/csvstudio.py](http://csvstudio.googlecode.com/hg/csvstudio.py).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要一个名为`csvstudio`的程序，您可以从[http://csvstudio.googlecode.com/hg/csvstudio.py](http://csvstudio.googlecode.com/hg/csvstudio.py)下载。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This first step consists of looking at the csv file:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是查看csv文件：
- en: '[PRE3]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the file is not corrupt, and it is in a standard csv format, then csvstudio
    will generate a report listing the CSV columns, data types, and data ranges.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件没有损坏，并且是标准的csv格式，那么csvstudio将生成一个报告，列出CSV列、数据类型和数据范围。
- en: If the file is in a non-standard CSV format, or is, for example, in XLS, try
    importing it in Excel, and save it again in CSV.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果文件是非标准的CSV格式，或者例如是XLS格式，尝试在Excel中导入它，然后再以CSV格式保存。
- en: You may also want to try using **Google Refine** to clean up the CSV file.
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您还可能想尝试使用**Google Refine**来清理CSV文件。
- en: 'Once you know that `csvstudio` can correctly read the file, run the following
    command:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您知道`csvstudio`可以正确读取文件，运行以下命令：
- en: '[PRE4]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: csvstudio creates a file called db1.py that contains a web2py model that is
    compatible with the data. mytable, here, is the name you choose to give to the
    table.
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: csvstudio创建一个名为db1.py的文件，其中包含一个与数据兼容的web2py模型。在这里，mytable是您为表选择的名称。
- en: Move this file into your application's `models` folder.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件移动到您的应用程序的`models`文件夹中。
- en: Now you need to clean up the data, so that you can import it in web2py.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您需要清理数据，以便可以在web2py中导入。
- en: '[PRE5]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The file, `mydata2.csv`, now contains the same data as the original file, but
    the column names have been cleaned up to be compatible with the generated model.
    The field values have been stripped of any leading and trailing spaces.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件`mydata2.csv`现在包含与原始文件相同的数据，但列名已被清理以与生成的模型兼容。字段值已去除任何前导和尾随空格。
- en: At this point, all you have to do is run your application and call `appadmin`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，您只需运行您的应用程序并调用`appadmin`。
- en: '[PRE6]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You should see the model you generated. Click on the model name, and you will
    see an upload link at the bottom. Upload the `mydata2.csv` file to populate your
    table.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该能看到你生成的模型。点击模型名称，你将在底部看到一个上传链接。上传`mydata2.csv`文件以填充你的表格。
- en: There's more...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you prefer to upload the csv file from a shell instead of using the `appadmin`
    interface, you can do so.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢从shell上传csv文件而不是使用`appadmin`界面，你可以这样做。
- en: 'From insider the main web2py folder, run the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从主web2py文件夹内部，运行以下命令：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You will get a web2py shell (-S app opens the shell in the application context,
    `-M` loads the models, and `-N` prevents cron jobs from running).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个web2py shell（-S app在应用程序上下文中打开shell，-M加载模型，-N防止cron作业运行）。
- en: 'From inside the shell do the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell内部执行以下操作：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Et voila, the data is in the database. When you use the shell do not forget
    to `db.commit()`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，数据已经在数据库中了。当你使用shell时，别忘了执行`db.commit()`。
- en: If for any reason this does not work (perhaps because the CSV file is non-standard,
    and there is no way to normalize it), try following our next recipe.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于任何原因这不起作用（可能是因为CSV文件是非标准的，无法进行标准化），请尝试按照我们的下一个食谱操作。
- en: Batch upload of your data
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批量上传你的数据
- en: Here, we will assume you have data in a flat file of known `structure`. You
    want to create a database model and import the data in the database.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设你有一个已知`结构`的平面文件中的数据。你想要创建一个数据库模型并将数据导入数据库。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For same of the argument, we will assume the file is in /tmp/data.txt, and
    has the following structure:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们假设文件位于/tmp/data.txt，具有以下结构：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Each row is a record ending in `\n`. The fields are separated by &mdash;. The
    first column contains`<first name> <last name>`. The second column contains an
    annual salary value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都是一个以`\n`结尾的记录。字段由&mdash;分隔。第一列包含`<first name> <last name>`。第二列包含年薪值。
- en: As usual, we will assume you have a new application called `app`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们假设你有一个名为`app`的新应用程序。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The first thing you do is create a model in your `app` called `models/db1.py`
    containing the following data:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你首先需要做的是在你的`app`中创建一个名为`models/db1.py`的模型，包含以下数据：
- en: '[PRE10]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, you would write a script, for example:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你会编写一个脚本，例如：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This script can read the data, parse it, and put it into the db, as follows:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此脚本可以读取数据，解析它，并将其放入数据库中，如下所示：
- en: '[PRE12]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, from the web2py folder run the following script:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，从web2py文件夹运行以下脚本：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that the importer is a Python script, but not a module (that is why we
    put it in the `private` folder and not the `modules` folder. It is executed in
    our application context, as if it were a controller. In fact, you can copy the
    code into a controller, and run it from a browser as well.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，导入器是一个Python脚本，而不是一个模块（这就是为什么我们把它放在`private`文件夹而不是`modules`文件夹中。它在我们的应用程序上下文中执行，就像是一个控制器。实际上，你可以将代码复制到一个控制器中，并通过浏览器运行它。
- en: There's more...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The previous script works fine if the data is clean. You may need to validate
    each record before inserting it. This is again a two-step procedure. First you
    need to add validators to your model, for example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据是干净的，前面的脚本运行良好。你可能需要在插入之前验证每个记录。这又是一个两步过程。首先，你需要向你的模型添加验证器，例如：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then you need to call validators on import and check for errors:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要调用导入时的验证器并检查错误：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Records that cause errors will not be inserted, and you can deal with them manually.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 导致错误的记录将不会被插入，你可以手动处理它们。
- en: Moving your data from one database to another
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据从一个数据库迁移到另一个数据库
- en: So, at this point, you have built your application, and you have data in your
    SQLite database. But let's say you need to move to a production MySQL or PostgreSQL
    environment.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到目前为止，你已经构建了你的应用程序，并且你的SQLite数据库中有数据。但是假设你需要迁移到生产MySQL或PostgreSQL环境。
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Here we assume you have an application called `app`, data in the `sqlite://storage.sqlite`
    database, and you want to move your data to a different database:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个名为`app`的应用程序，数据在`sqlite://storage.sqlite`数据库中，你想要将数据迁移到不同的数据库：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Edit your model `db.py`, and replace the following:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑你的模型`db.py`，并替换以下内容：
- en: '[PRE17]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With the following:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下：
- en: '[PRE18]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a file called `applications/app/private/mover.py` that contains the
    following data:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`applications/app/private/mover.py`的文件，包含以下数据：
- en: '[PRE19]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run this file with the following command (run it only once or you end up with
    duplicate records):'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行此文件（只运行一次，否则你会得到重复的记录）：
- en: '[PRE20]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Change the model `db.py`, and change the following:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改模型`db.py`，并修改以下：
- en: '[PRE21]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To the following:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到以下：
- en: '[PRE22]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There's more...
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Actually, web2py comes with the following script:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，web2py附带以下脚本：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This script performs tasks and variations using command-line options. Read the
    file for more information.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本使用命令行选项执行任务和变体。阅读文件以获取更多信息。
- en: Creating a model from existing MySQL and PostgreSQL databases
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从现有的MySQL和PostgreSQL数据库创建模型
- en: It is often necessary to access an existing database from a web2py application.
    This is possible under some conditions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通常需要从web2py应用程序访问现有的数据库。在某些条件下这是可能的。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to connect to an existing database, it must be one that''s supported.
    At the time of writing, this includes **MySQL, PostgreSQL, MSSQL, DB2, Oracle,
    Informix, FireBase**, and **Sybase**. You must know the database type (for example
    `mysql` or `postgres)`, the database name (for example, `mydb)`, and the hostname
    and port where the database server is running (for example `127.0.0.1:3306` for
    `mysql` or `127.0.0.1:5432` for `postgres)`. You must have a valid username and
    password to access the database. In summary, you must know the following URI strings:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接到现有的数据库，它必须是被支持的数据库。在撰写本文时，这包括**MySQL、PostgreSQL、MSSQL、DB2、Oracle、Informix、FireBase**和**Sybase**。您必须知道数据库类型（例如`mysql`或`postgres`），数据库名称（例如，`mydb`），以及数据库服务器运行的主机名和端口号（例如`mysql`的`127.0.0.1:3306`或`postgres`的`127.0.0.1:5432`）。您必须有一个有效的用户名和密码来访问数据库。总之，您必须知道以下URI字符串：
- en: '`mysql://username:password@127.0.0.1:3306/mydb`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mysql://username:password@127.0.0.1:3306/mydb`'
- en: '`postgres://username:password@127.0.0.1:5432/mydb`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postgres://username:password@127.0.0.1:5432/mydb`'
- en: 'Assuming you can connect to this database, you will only be able to access
    those tables that meet the following conditions:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您可以连接到此数据库，您只能访问满足以下条件的表：
- en: Each table to be accessed must have a unique auto-increment integer primary
    key (whether called `id` or not). For PostgreSQL, you can also have compound primary
    keys (comprised of several fields), and not necessarily of `SERIAL` type (see
    **keyed tables** on web2py book).
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个要访问的表都必须有一个唯一的自增整数主键（无论是否称为`id`）。对于PostgreSQL，您也可以有复合主键（由多个字段组成），并且不一定必须是`SERIAL`类型（参见web2py书籍中的**键表**）。
- en: Records must be referenced by their primary key.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录必须通过其主键进行引用。
- en: The web2py model must include a `define_table` statement for each table to be
    accessed, listing all fields and their types.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: web2py模型必须为每个要访问的表包含一个`define_table`语句，列出所有字段及其类型。
- en: In the following, we will also assume your system supports the `mysql` command
    to access the database locally (to extract MySQL models), or your system has installed
    the `psycopg2` python module (to extract PostgreSQL models, see installation recipes).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下内容中，我们还将假设您的系统支持使用`mysql`命令本地访问数据库（以提取MySQL模型），或者您的系统已安装了`psycopg2` Python模块（以提取PostgreSQL模型，请参阅安装说明）。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First you need to query the database and come up with a possible model compatible
    with the content of the database. This can be done by running the following scripts
    that comes with web2py:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要查询数据库，并制定一个与数据库内容兼容的可能模型。这可以通过运行以下随web2py提供的脚本完成：
- en: 'To build web2py models from a MySQL database, use:'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从MySQL数据库构建web2py模型，请使用：
- en: '[PRE24]'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To build web2py models from a PostgreSQL database, use:'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从PostgreSQL数据库构建web2py模型，请使用：
- en: '[PRE25]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The scripts are not perfect, but they will generate a db1.py file that describes
    the database tables.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些脚本并不完美，但它们将生成一个db1.py文件，描述数据库表。
- en: Edit this model to remove tables that you do not need to access. Improve the
    field types (for example, a string field may be a password), and add validators.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑此模型以删除您不需要访问的表。改进字段类型（例如，字符串字段可能是密码），并添加验证器。
- en: Then move this file into the `models/` folder of your application.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将此文件移动到您的应用程序的`models/`文件夹中。
- en: Finally, edit the original `db.py` model, and replace the URI string with the
    one for this database.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编辑原始的`db.py`模型，并用此数据库的URI字符串替换它。
- en: 'For MySQL, write:'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于MySQL，请编写：
- en: '[PRE26]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For PostgreSQL, write:'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于PostgreSQL，请编写：
- en: '[PRE27]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We disable all migrations, because the table already exists and web2py should
    not attempt to create or alter it.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们禁用了所有迁移，因为表已经存在，web2py不应该尝试创建或修改它。
- en: Unfortunately, accessing the existing database is one of the most tricky tasks
    in web2py, because the database was not created by web2py, and web2py needs to
    make some guesses. The only way to fix these problems is by manually editing the
    model file, and using independent knowledge of the database content.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，访问现有的数据库是web2py中最棘手的任务之一，因为数据库不是由web2py创建的，web2py需要做出一些猜测。解决这些问题的唯一方法是手动编辑模型文件，并使用对数据库内容的独立知识。
- en: There's more...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'Actually, the `extract_pgsql_models.py` has the following additional features:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`extract_pgsql_models.py`还具有以下附加功能：
- en: It uses ANSI Standard `INFORMATION_SCHEMA` (this might work with other RDBMS)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用ANSI标准`INFORMATION_SCHEMA`（这可能与其他RDBMS一起工作）。
- en: It detects legacy keyed tables (not having an `id` as its primary key)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它检测具有`id`作为其主键的键表（没有`id`）。
- en: It connects directly to running databases, so there's no need to do an SQL dump
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它直接连接到正在运行的数据库，因此不需要进行SQL转储。
- en: It handles `notnull, unique`, and referential constraints
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它处理`notnull, unique`和引用约束。
- en: It detects the most common datatypes and default values
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它检测最常见的数据类型和默认值。
- en: It supports PostgreSQL columns comments (that is, for documentation)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持PostgreSQL列注释（即，用于文档）。
- en: If you have to use it against other RDBMS that support ANSI `INFORMATION_SCHEMA`
    (for example, MSSQL Server), import and use the proper Python connector, and remove
    the `postgreSQL` specific queries (pg_ `tables` for comments)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您必须使用它来对抗支持ANSI `INFORMATION_SCHEMA`的其他RDBMS（例如，MSSQL Server），则导入并使用适当的Python连接器，并删除特定的`postgreSQL`查询（pg_
    `tables`用于注释）。
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You cannot mix references between normal auto-increment primary keys tables
    (type='id') and keyed tables (primarykey=['field1',`'field2'])`. If you use both
    in your database, you have to manually define auto-increment primary keys as keyed
    tables at the web2py model (removing `id` type, and adding the primary key parameter
    to `define_table)`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能在普通自增主键表（type='id'）和键表（primarykey=['field1',`'field2'`])之间混合引用。如果您在数据库中使用两者，您必须在web2py模型中将键表手动定义为自增主键（移除`id`类型，并将主键参数添加到`define_table`）。
- en: Efficiently searching by tag
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效的标签搜索
- en: Whether you are building a social network, a content management system, or an
    ERP system, you eventually need the ability to tag records. This recipe shows
    you a way to efficiently search for records by tag.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是在构建社交网络、内容管理系统还是ERP系统，您最终都需要记录标记的能力。这个配方向您展示了一种通过标签高效搜索记录的方法。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Here we assume the following two models:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设以下两个模型：
- en: 'A model for containing the data:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含数据的模型：
- en: '[PRE28]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A model for storing the tags:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储标签的模型：
- en: '[PRE29]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, `name` is the tag name.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`name`是标签名称。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We want to search all records having at least one of the tags in the list:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想搜索列表中至少有一个标签的所有记录：
- en: '[PRE30]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For this purpose, we create a search function:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了这个目的，我们创建了一个搜索函数：
- en: '[PRE31]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Similarly, if you want to search for records that have all the tags (as opposed
    to one of those in the list):'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，如果您想搜索具有所有标签的记录（而不是列表中的任何一个）：
- en: '[PRE32]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice that these two functions work for any table that is passed as first argument.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两个函数适用于任何作为第一个参数传递的表。
- en: In both functions, the query involves two tables.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个函数中，查询涉及两个表。
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: web2py interprets this as join.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: web2py将其解释为连接。
- en: There's more...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'This system works great if users are free to choose the tag names. Sometimes,
    you want to restrict tags to a well defined set. In that case, the model needs
    to be updated:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统如果用户可以自由选择标签名称，效果很好。有时，您可能希望将标签限制在定义良好的集合中。在这种情况下，模型需要更新：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, the link table implements a many-to-many relation between data records
    and tag items.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，链接表实现了数据记录和标签项之间的多对多关系。
- en: In this case, we need to modify our search functions, so first we convert a
    list of tag names (tags) into a list of tag IDs, and then perform the previous
    query. This can be done using a `subquery:`
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要修改我们的搜索函数，因此首先我们将标签名称列表（tags）转换为标签ID列表，然后执行之前的查询。这可以通过使用`subquery:`来完成。
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The technique we implemented here is known as the **Toxi** method, and is described
    in a more general and abstract way at the following link:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里实施的技术被称为**Toxi**方法，并在以下链接中以更通用和抽象的方式描述：
- en: '[http://www.pui.ch/phred/archives/2005/04/tags-database-schemas.html](http://www.pui.ch/phred/archives/2005/04/tags-database-schemas.html).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.pui.ch/phred/archives/2005/04/tags-database-schemas.html](http://www.pui.ch/phred/archives/2005/04/tags-database-schemas.html).'
- en: Accessing your database from multiple applications
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从多个应用程序访问你的数据库
- en: One way to build distributed applications, is by having the same database available
    to multiple applications. Unfortunately, this is more than a matter of connecting
    to the database. In fact, the different applications need to be aware of the table
    content and other metadata, which is stored in the model definition.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 构建分布式应用程序的一种方法，是让多个应用程序可以访问相同的数据库。不幸的是，这不仅仅是连接到数据库的问题。实际上，不同的应用程序需要了解表内容和其他元数据，这些元数据存储在模型定义中。
- en: There are three ways to do this, and they are not equivalent. It depends on
    whether the applications share a file system, and the degree of autonomy you want
    to give to the two applications.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法可以实现这一点，它们并不等价。这取决于应用程序是否共享文件系统，以及你希望给予两个应用程序多少自主权。
- en: Getting ready
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will assume you have two web2py applications, one called `app1`, and one
    called `app2`, where `app1` connects to a database through the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设你已经有两个web2py应用程序，一个叫做`app1`，另一个叫做`app2`，其中`app1`通过以下方式连接到数据库：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, URI is some connection string. It does not matter whether this is SQLite
    or a client/server database. We will also assume that the model used by `app1`
    is stored in `models/db1.py`, although the name is unimportant here.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，URI是一些连接字符串。无论是SQLite还是客户端/服务器数据库，这都无关紧要。我们还将假设`app1`使用的模型存储在`models/db1.py`中，尽管这里的名称并不重要。
- en: Now we want `app2` to connect to the same database.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们希望`app2`连接到同一个数据库。
- en: How to do it...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: It is also a common scenario that you want the two applications to be autonomous,
    although able to share data. **Autonomous** means that you want to be able to
    distribute each application without the other one.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个常见的场景，你希望两个应用程序是自主的，尽管能够共享数据。**自主**意味着你希望能够独立分发每个应用程序，而无需另一个应用程序。
- en: If this is the case, each application needs its own copy of the model and its
    own database metadata. The only way to achieve this is by duplication of code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样的话，每个应用程序都需要自己的模型副本和自己的数据库元数据。实现这一点的唯一方法是通过代码的复制。
- en: 'You must follow these steps:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须遵循以下步骤：
- en: 'Edit the URI string of `app2` so that it looks the same as `app1`, but disable
    migrations:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`app2`的URI字符串，使其看起来与`app1`相同，但禁用迁移：
- en: '[PRE37]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Copy the model file `models/d1.py` from `app1` into `app2`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`app1`中的模型文件`models/d1.py`复制到`app2`中。
- en: Notice that only `app1` will be able to perform migrations (if both were able
    to do it, the situation would get very confused). If you change the model in `app1`,
    you will have to copy the model file again.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有`app1`能够执行迁移（如果两个都能做，情况会变得非常混乱）。如果你在`app1`中更改模型，你必须再次复制模型文件。
- en: Although this solution breaks the **Don't Repeat Yourself** (DRY) pattern, it
    guarantees complete autonomy to each application, and they can access the same
    database even if running on separate servers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个解决方案打破了**不要重复自己**（DRY）模式，但它保证了每个应用程序的完全自主性，即使它们在不同的服务器上运行，也可以访问相同的数据库。
- en: 'If the two applications are running on the same server, instead of copying
    the model file, you can just make a symbolic link:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个应用程序运行在同一台服务器上，你不需要复制模型文件，只需创建一个符号链接即可：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now you have only one model file.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只有一个模型文件。
- en: There's more...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Sometimes you need a script (not a web application) to be able to access a web2py
    model. This can be done by accessing the metadata only, without executing the
    actual model file.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要一个脚本（而不是一个网络应用程序）来访问web2py模型。这可以通过仅访问元数据来实现，而不需要执行实际的模型文件。
- en: 'Here is a python script (not a web2py model) that can do it:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个可以做到这一点的Python脚本（而不是web2py模型）：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice the `auto_import=True`. It tells the DAL to look in the specified folder
    for the meta-data associated to the URI connection, and rebuilds the models on
    the fly, in memory. Models defined in this way have the right names and field
    types, but they will not have the correct values of other attributes, such as
    readable, writable, default, validators, and so on. This is because those attributes
    cannot be serialized in the metadata, and are probably not needed in this scenario.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`auto_import=True`。它告诉DAL在指定的文件夹中查找与URI连接关联的元数据，并在内存中动态重建模型。以这种方式定义的模型具有正确的名称和字段类型，但它们将不具有其他属性的正确值，例如可读性、可写性、默认值、验证器等。这是因为这些属性不能在元数据中进行序列化，并且在这个场景中可能也不需要。
- en: Hierarchical category tree
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层次化分类树
- en: Sooner or later, any application needs a way to categorize data, and categories
    must be stored in a tree, because each category has a parent and possibly subcategories.
    A category without a subcategory is a leaf of the tree. If there are categories
    without a parent, we create a fictitious root tree node, and append all of them
    as subcategories of the root.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序迟早都需要一种对数据进行分类的方法，并且类别必须以树的形式存储，因为每个类别都有一个父类，可能还有子类别。没有子类别的类别是树的叶子。如果有没有父类的类别，我们创建一个虚构的根树节点，并将它们作为根的子类别附加。
- en: The main issue is how to store categories with parent-child relations in a database
    table, and efficiently add nodes and queries for ancestors and descendants of
    a node.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 主要问题是如何在数据库表中存储具有父子关系的类别，以及高效地添加节点和查询节点的祖先和后代。
- en: This can be done using a modified pre-order tree traversal algorithm, described
    as follows.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过修改的先序树遍历算法来实现，如下所述。
- en: How to do it...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The key trick consists of storing each node in its own record with two integer
    attributes, left and right, so that all its ancestors have a left attribute lower
    than or equal to the left attribute of the current node, and a right attribute
    larger than the one of the current node. Similarly, all descendants will have
    a left larger or equal than the current left and a right smaller than the current
    right. In formula:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 关键技巧是将每个节点存储在其自己的记录中，带有两个整数属性，左和右，这样所有祖先的左属性都小于或等于当前节点的左属性，而右属性大于当前节点的右属性。同样，所有后代都将有一个大于或等于当前左的左属性和小于当前右的右属性。在公式中：
- en: '`A` is parent of `B` if `A.ileft<=B.ileft`, and `A.iright>B.iright`.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `A.ileft<=B.ileft` 且 `A.iright>B.iright`，则 `A` 是 `B` 的父类。
- en: Notice that `A.iright - A.ileft` is always the number of descendants.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `A.iright - A.ileft` 总是后代的数量。
- en: 'The following is a possible implementation:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个可能的实现：
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This allows us to perform the following operations:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们执行以下操作：
- en: 'Define your own tree table (mytree) and proxy object (treeproxy):'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义自己的树表（mytree）和代理对象（treeproxy）：
- en: '[PRE41]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Insert a new node:'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入一个新的节点：
- en: '[PRE42]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Append some nodes:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一些节点：
- en: '[PRE43]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Search ancestors and descendants:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索祖先和后代：
- en: '[PRE44]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Delete a node and all its descendants:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除一个节点及其所有后代：
- en: '[PRE45]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Creating records on demand
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按需创建记录
- en: 'It is common that we need to get a record or update a record, based on a condition,
    yet the record may not exist. If the record does not exist, we want to create
    it. In this recipe, we will show two utility functions that can serve this purpose:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常需要根据条件获取或更新记录，但记录可能不存在。如果记录不存在，我们希望创建它。在这个菜谱中，我们将展示两个可以满足此目的的实用函数：
- en: '`get_or_create`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_or_create`'
- en: '`update_or_create`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_or_create`'
- en: For this to work, we need to pass enough `field:value` pairs to create the missing
    record.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这可行，我们需要传递足够的 `field:value` 对来创建缺失的记录。
- en: How to do it...
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Here is the code for `get_or_create:`
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是 `get_or_create` 的代码：
- en: '[PRE46]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Notice how table(**fields) selects a record from the table, matching the requested
    fields, and returns None if the record does not exist. In this latter case, the
    record is inserted. Then, table.insert(...) returns a reference to the inserted
    record, which, for practical purposes, gets the record just inserted.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意如何通过表(**字段)选择与请求字段匹配的记录，如果记录不存在则返回 None。在这种情况下，将插入记录。然后，table.insert(...)
    返回插入记录的引用，对于实际目的来说，就是获取刚刚插入的记录。
- en: 'Here is an example of usage:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是一个使用示例：
- en: '[PRE47]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The code for `update_or_create` is very similar, but we need two sets of variables&mdash;
    variables for the **search** (before update) and variables to be **updated:**
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`update_or_create` 的代码非常相似，但我们需要两组变量&mdash; 用于 **搜索**（在更新之前）的变量和用于 **更新**的变量：'
- en: '[PRE48]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And here is an example of usage:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是一个使用示例：
- en: '[PRE49]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: OR, LIKE, BELONGS, and more on Google App Engine
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OR、LIKE、BELONGS 以及更多在 Google App Engine 上的应用
- en: A major limitation of the **Google App Engine** (GAE) is the inability to perform
    queries that use the OR, BELONGS(IN), and LIKE operators.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google App Engine** (GAE) 的一个主要限制是无法执行使用 OR、BELONGS(IN) 和 LIKE 操作符的查询。'
- en: The web2py DAL provides a system for abstracting database queries, and it works
    on **Relational Databases** (RDBS) as well as on GAE but, still, it is crippled
    by the limitations mentioned. Here we show some workarounds.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: web2py DAL 提供了一个抽象数据库查询的系统，它不仅适用于 **关系数据库** (RDBS)，也适用于 GAE，但仍然受到前面提到的限制。这里我们展示了些解决方案。
- en: We have created an additional API that allows merging, filtering, and sorting
    records after they are extracted from the GAE storage, at the web2py level. They
    can be used to mimic the missing features, and will make your GAE code portable
    to RDBS too.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个额外的 API，允许在从 GAE 存储中提取记录后在 web2py 层面上合并、过滤和排序记录。它们可以用来模拟缺失的功能，并将您的 GAE
    代码也移植到 RDBS。
- en: Current supported RDBS are SQLite, MySQL, PostgreSQL, MSSQL, DB2, Informix,
    Oracle, FireBird, and Ingres.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当前支持的 RDBS 是 SQLite、MySQL、PostgreSQL、MSSQL、DB2、Informix、Oracle、FireBird 和 Ingres。
- en: GAE is the only currently supported NoDB. Other adapters are under development.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: GAE 是目前唯一支持的 NoDB。其他适配器正在开发中。
- en: Getting ready
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In the following recipe, we plan to develop an application to run on GAE, and
    we connect to the database using the following logic:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下菜谱中，我们计划开发一个在 GAE 上运行的应用程序，并使用以下逻辑连接到数据库：
- en: '[PRE50]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We assume the following models, as an example:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设以下模型作为示例：
- en: '[PRE51]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How to do it...
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: After setting up the GAE model that we described previously, let's see how to
    do insert and update records, do joins and other manipulations in the following
    sections.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置我们之前描述的 GAE 模型之后，让我们看看如何在以下部分中执行插入和更新记录、执行连接和其他操作。
- en: Record insert
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录插入
- en: 'To test the rest of the code, you may want to insert some records in the tables.
    You can do this with `appadmin` or programmatically. The following code will work
    fine on GAE with the caveats that the IDs returned by the `insert` method are
    not sequential on GAE:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试其余的代码，您可能想在表中插入一些记录。您可以使用 `appadmin` 或以编程方式完成此操作。以下代码在 GAE 上运行良好，但有警告，即
    `insert` 方法返回的 ID 在 GAE 上不是顺序的：
- en: '[PRE52]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Record update
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录更新
- en: 'The `update` on GAE works as you would normally expect. Both syntaxes are supported:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: GAE 上的 `update` 操作与您预期的正常操作一样。两种语法都受支持：
- en: '[PRE53]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And also:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以及：
- en: '[PRE54]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Joins
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'On a relational database, you can do the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系数据库中，您可以执行以下操作：
- en: '[PRE55]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This produces the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下结果：
- en: '[PRE56]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This does not work on GAE. You have to perform the query without the join, using
    recursive `selects`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 GAE 上不起作用。您必须在不使用连接的情况下执行查询，使用递归 `selects`。
- en: '[PRE57]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, `row.product.name` performs recursive `selects`, and gets you the name
    of the product referenced by `row.product.`
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`row.product.name` 执行递归 `selects`，并获取由 `row.product.` 引用的产品的名称。
- en: Logical OR
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑 OR
- en: 'On an RDBS, you can implement `OR` in queries using the &mdash; operator:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RDBS 上，您可以使用 &mdash; 操作符在查询中实现 `OR`：
- en: '[PRE58]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This does not work on GAE, because `OR` is not supported (at the time of writing).
    If the queries involve the same field, you can use the `IN` operator:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 GAE 上不起作用，因为不支持 `OR` 操作（在撰写本文时）。如果查询涉及相同的字段，可以使用 `IN` 操作符：
- en: '[PRE59]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is a portable and efficient solution. In the most general case, you may
    need to perform the `OR` operation at the web2py level as opposed to at the database
    level.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个便携且高效的解决方案。在最一般的情况下，您可能需要在 web2py 层面上而不是在数据库层面上执行 `OR` 操作。
- en: '[PRE60]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this latter case, the`&mdash`; is not between queries, but between rows object,
    and it is performed after the records are fetched. This presents some problems
    because the original order is lost, and because of the increased memory and resource
    consumption penalty.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种后一种情况下，`&mdash;` 不是在查询之间，而是在行对象之间，并且是在记录检索之后执行的。这带来了一些问题，因为原始顺序丢失了，并且由于增加了内存和资源消耗的惩罚。
- en: OR with orderby
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有 `orderby` 的 `OR`
- en: 'On a relational database you can do the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系数据库中，您可以执行以下操作：
- en: '[PRE61]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'But, again on GAE, you have to perform the `OR` at web2py level. Therefore
    you also have to sort at the web2py level:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，再次在 GAE 上，您必须在 web2py 层面上执行 `OR` 操作。因此，您还必须在 web2py 层面上进行排序：
- en: '[PRE62]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `sort` method of the `rows` objects take a function of the row, and must
    return an expression to sort about. They can also be used with RDBS to implement
    sorting, when the expression is too complex to implement at the database level.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`rows` 对象的 `sort` 方法接受一个行函数，并必须返回一个用于排序的表达式。它们也可以与 RDBS 一起使用以实现排序，当表达式过于复杂而无法在数据库级别实现时。'
- en: OR with more complex orderby
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有复杂 `orderby` 的 `OR`
- en: 'Consider the following query that involves a `OR`, a `JOIN`, and an ordering,
    and would only work on RDBS:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下涉及 `OR`、`JOIN` 和排序的查询，并且仅在 RDBS 上工作：
- en: '[PRE63]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You can rewrite it for GAE using the `sort` method, and a recursive `select`
    in the `sort` argument:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `sort` 方法以及 `sort` 参数中的递归 `select` 来重写它：
- en: '[PRE64]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This works, but it may be inefficient. You may want to cache the mapping of
    `row.buyer` into `buyer_names:`
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以工作，但可能效率不高。您可能希望缓存 `row.buyer` 到 `buyer_names:` 的映射。
- en: '[PRE65]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here, `buyer_names` is a mapping between `ids` and `names`, and it is cached
    every hour (3600 seconds). `sort` tries to pick the names from `buyer_names` if
    possible, or else it performs the recursive select.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`buyer_names` 是 `ids` 和 `names` 之间的映射，并且每小时（3600秒）缓存一次。`sort` 尝试从 `buyer_names`
    中选择名称，如果可能的话，否则执行递归选择。
- en: LIKE
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LIKE
- en: 'On a relational database, you can, for example, search all records with a name
    starting with the letter `C` followed by anything (%):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系数据库中，例如，你可以搜索所有以字母 `C` 开头后跟任何内容（%）的记录：
- en: '[PRE66]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'But GAE neither supports full text search, nor anything that resembles the
    SQL `LIKE` operator. Once more, we have to select all records and perform the
    filtering at the web2py level. We can use the `find` method of the `rows` object:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 但 GAE 既不支持全文搜索，也不支持类似 SQL `LIKE` 操作符的任何内容。再一次，我们必须选择所有记录并在 web2py 层面上执行过滤。我们可以使用
    `rows` 对象的 `find` 方法：
- en: '[PRE67]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Of course, this is expensive, and not recommended for large tables (more than
    a few hundred records). If this kind of search is critical for your application,
    perhaps you should not be using GAE.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这很昂贵，不推荐用于大型表（超过几百条记录）。如果这种搜索对你的应用程序至关重要，也许你不应该使用 GAE。
- en: date and datetime manipulations
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日期和日期时间操作
- en: 'The same problem occurs for queries involving other expressions, such as date
    and datetime manipulations. Consider the following query that works on relational
    databases but not on GAE:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及其他表达式（如日期和日期时间操作）的查询，也会出现相同的问题。考虑以下在关系数据库上工作但在 GAE 上不工作的查询：
- en: '[PRE68]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'On GAE you would have to rewrite it as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GAE 上，你必须将其重写如下：
- en: '[PRE69]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Replacing slow virtual fields with DB views
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用数据库视图替换慢速虚拟字段
- en: 'Consider the following table:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下表：
- en: '[PRE70]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: You need to add a field called `total price` that is computed when records are
    retrieved, and is defined as the product of price by quantity for each record.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要添加一个字段，称为 `total price`，在检索记录时计算，定义为每个记录的价格乘以数量。
- en: The normal way to do it is by using **virtual fields:**
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的做法是使用 **虚拟字段**：
- en: '[PRE71]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then you can do the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以执行以下操作：
- en: '[PRE72]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This is fine, but computing virtual fields at the web2py level can be slow.
    Moreover, you would not be used to involving the virtual fields in queries.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以的，但在 web2py 层面上计算虚拟字段可能会很慢。此外，你可能不习惯在查询中涉及虚拟字段。
- en: Here we propose an alternate solution that involves creating a database view
    for the table, which includes the column with computed fields, and provides a
    way for web2py to access it.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们提出了一种替代方案，该方案涉及为表创建一个数据库视图，该视图包括包含计算字段的列，并为 web2py 提供了访问它的方式。
- en: How to do it...
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Given the table, do the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 给定表，执行以下操作：
- en: '[PRE73]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now, you can use `db.purchase_plus` anywhere you would use `db.numbers_plus`,
    except for inserts, with a performance increase when compared to the `VirtualFields`
    solution.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在任何使用 `db.numbers_plus` 的地方使用 `db.purchase_plus`，除了插入操作，与 `VirtualFields`
    解决方案相比，性能有所提升。
- en: How it works...
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following line checks whether the view has been created already:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行检查视图是否已经创建：
- en: '[PRE74]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'If not, it instructs the database to create it:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，它指示数据库创建它：
- en: '[PRE75]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Finally, it defines a new web2py model, which maps into the table:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它定义了一个新的 web2py 模型，该模型映射到表：
- en: '[PRE76]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This model includes all fields from the `db.purchase` table, the new field `total_price`,
    and sets `migrate=False`, so that web2py does not attempt to create the table
    (it should not because this is not a new table, it's a view, and has been already
    created).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型包括 `db.purchase` 表中的所有字段，新的字段 `total_price`，并将 `migrate=False` 设置为，这样 web2py
    就不会尝试创建表（它不应该尝试创建，因为这个不是新表，而是一个视图，并且已经创建）。
- en: There's more...
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Notice that not all supported databases support views, and not all of those
    that do have an `information_schema.tables`. Therefore, this recipe is not guaranteed
    to work on all supported databases, and will make your application not portable.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，并非所有支持的数据库都支持视图，并且并非所有支持视图的数据库都有 `information_schema.tables`。因此，这个菜谱不能保证在所有支持的数据库上都能工作，并且会使你的应用程序不可移植。
