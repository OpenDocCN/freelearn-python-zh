- en: 'Chapter 2.  Arrays: Foundational Collections'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。数组：基础集合
- en: Quite often, our applications need to store multiple pieces of user data or
    objects in memory at runtime. One solution is to define multiple fields (properties)
    in our various classes to store each of our required data points. Unfortunately,
    even when working with the simplest workflows, this approach quickly becomes ineffective.
    We will either have too many fields to work with, or we simply won't have any
    way of anticipating all of the dynamic requirements for our project at compile
    time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见，我们的应用程序在运行时需要在内存中存储多个用户数据或对象。一个解决方案是在我们的各种类中定义多个字段（属性）来存储我们所需的数据点。不幸的是，即使在处理最简单的流程时，这种方法也会很快变得无效。我们可能需要处理太多的字段，或者我们根本无法在编译时预测我们项目的所有动态需求。
- en: One solution to this problem is to use an array. Arrays are simple collections
    of data, and they are one of the most common data structures you will encounter
    in your day-to-day programming experience due to the fact that many other data
    structures are built on top of them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是使用数组。数组是简单的数据集合，由于许多其他数据结构都是建立在它们之上，因此它们是你日常编程经验中遇到的最常见的数据结构之一。
- en: Arrays are containers that hold a fixed number of items of a particular type.
    The size of an array in C and its descendant languages are determined when the
    array is created, and the length remains fixed from that point forward. Each item
    in an array is called an **element**, and each element can be accessed by its
    index number. Generally speaking, an array is a collection of data items that
    can be selected by indices that are determined at runtime.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是包含特定类型固定数量项的容器。在C语言及其后裔语言中，数组的大小在创建数组时确定，并且从那时起长度保持固定。数组中的每个项称为**元素**，每个元素都可以通过其索引号访问。一般来说，数组是可以通过运行时确定的索引选择的数据项集合。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Definition
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义
- en: Mutable arrays versus immutable arrays
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变数组与不可变数组
- en: Example applications for arrays
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的示例应用
- en: Linear searches
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性搜索
- en: Primitive arrays
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本数组
- en: Object arrays
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象数组
- en: Mixed arrays
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合数组
- en: Multidimensional arrays
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多维数组
- en: Jagged arrays
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锯齿形数组
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that arrays in most languages use what is known as a **zero-based index**,
    meaning that the first item in the array has an index of 0, the second has an
    index of 1, and so on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，大多数语言中的数组使用所谓的**零基索引**，这意味着数组中的第一个项目索引为0，第二个为1，依此类推。
- en: '**Off-by-one errors** occur when the source code attempts to access an item
    at a given index that is one point away from the actual item you intended to access.
    This type of mistake is common to new and experienced programmers alike and can
    very often be the source of **Index is out of range** or **Index is out of bounds**
    runtime errors.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**索引错误**发生在源代码试图访问一个比实际想要访问的项目索引远一点的给定索引时。这种错误对于新手和经验丰富的程序员都是常见的，并且往往会导致**索引超出范围**或**索引超出界限**的运行时错误。'
- en: '![Arrays: Foundational Collections](img/00002.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![数组：基础集合](img/00002.jpeg)'
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Compile time and runtime**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译时间和运行时间**'
- en: In compiled programming languages (as opposed to interpreted languages), the
    difference between compile time and runtime is simply the difference between when
    an application is compiled and when it is run. During compiling, the high-level
    source code that the developer has written is fed into another program (usually
    called a compiler, oddly enough). The compiler checks whether the source code
    has the proper syntax, confirms type constraints are enforced, optimizes the code,
    and then produces an executable in a low-level language that the target architecture
    can utilize. If a program succeeds in compiling, we know that the source code
    is well formed and the resulting executable can be started. Note that developers
    will sometimes use the term *compile time* to include the actual process of writing
    the source code, although this is semantically incorrect.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译型编程语言（与解释型语言相对）中，编译时间和运行时间之间的区别仅仅是应用程序编译和运行之间的区别。在编译过程中，开发者编写的高级源代码被输入到另一个程序（通常称为编译器，奇怪的是）。编译器检查源代码是否有正确的语法，确认类型约束得到执行，优化代码，然后生成目标架构可以利用的低级语言的可执行文件。如果一个程序成功编译，我们知道源代码是良好形成的，生成的可执行文件可以启动。请注意，开发者有时会使用术语*编译时间*来包括编写源代码的实际过程，尽管这在语义上是不正确的。
- en: During runtime, the compiled code runs in the execution environment, but it
    can still experience errors. For example, attempting to divide by zero, dereferencing
    null memory pointers, running out of memory, or attempting to access resources
    that do not exist could all potentially crash your application if your source
    code does not handle these scenarios gracefully.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，编译后的代码在执行环境中运行，但它仍然可能遇到错误。例如，尝试除以零、取消引用空内存指针、内存不足或尝试访问不存在的资源都可能导致你的应用程序崩溃，如果你的源代码没有优雅地处理这些场景。
- en: Mutable versus immutable arrays
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变数组与不可变数组
- en: Typically, languages that are based on the C language share many of the same
    fundamental characteristics. For example, in C the size of a plain array cannot
    be changed once the array has been created. Since the four languages we are examining
    here are all based on C, the arrays we will be working with also have a fixed
    length in. However, although the size of an array cannot be changed, the contents
    of the structure can change after the array is created.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，基于C语言的编程语言共享许多相同的根本特性。例如，在C语言中，一旦创建了一个普通数组，其大小就不能改变。由于我们在这里检查的四种语言都是基于C语言的，因此我们将要处理的数组也将具有固定长度。然而，尽管数组的大小不能改变，但在数组创建后，结构的内容可以改变。
- en: So, are arrays mutable or immutable? In terms of mutability, we say that *plain
    C arrays are * *immutable* because the structure itself cannot change once it
    has been created. For this reason, it is typically a bad idea to use a plain C
    array for anything other than static datasets. This is because, whenever the dataset
    changes, your program will need to copy the modified data into a new array object
    and dispose of the old one, which are both costly operations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，数组是可变的还是不可变的？在可变性的术语中，我们说*普通C数组是* *不可变的*，因为一旦创建结构本身就不能改变。因此，通常不建议将普通C数组用于除静态数据集之外的其他用途。这是因为，每当数据集发生变化时，你的程序需要将修改后的数据复制到一个新的数组对象中，并丢弃旧的一个，这两个操作都是昂贵的操作。
- en: Most of the array objects you will be working with in higher-level languages
    are not plain C arrays, but rather wrapper classes created for the developer's
    convenience. Array wrapper classes encapsulate the complexities of the underlying
    data structure in favor of methods that handle the heavy lifting behind the scenes
    and properties that expose the characteristics of the dataset.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级语言中，你将要处理的数组对象大多数不是普通的C数组，而是为开发者的便利而创建的包装类。数组包装类封装了底层数据结构的复杂性，以便于处理幕后重负载的方法和暴露数据集特性的属性。
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Whenever a language provides a wrapper class for a particular type or data structure,
    you should take advantage of it. These are more convenient than writing your own
    implementation, and typically more reliable.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时，一种语言为特定类型或数据结构提供了一个包装类，你应该利用它。这些比编写自己的实现更方便，并且通常更可靠。
- en: 'Case study: users logged in to a web service'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究：登录到网络服务的用户
- en: '**Business problem**: A developer has created an application that logs mobile
    users in to a particular web service. Due to limitations in the server hardware,
    the web service can only permit 30 connected users at any given time. Therefore,
    the developer needs a way to track and limit the number of mobile device users
    who have connected to the service. In order to avoid duplicate users being permitted
    to log in and overload the service, a simple count of the connections is insufficient,
    as the developer will have no way of differentiating between the owners of each
    connection. Maintaining an array of objects representing a logged-in user is chosen
    as a core component of the solution.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**业务问题**：一位开发者创建了一个应用程序，用于将移动用户登录到特定的网络服务。由于服务器硬件的限制，该网络服务在任何给定时间只能允许30个连接的用户。因此，开发者需要一种方法来跟踪和限制连接到服务的移动设备用户数量。为了避免允许重复用户登录并超载服务，简单的连接计数是不够的，因为开发者将无法区分每个连接的所有者。维护一个表示已登录用户的对象数组被选为解决方案的核心组件。'
- en: '**C#**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are a few important pieces of the preceding example we need to make note
    of. First, we are storing our `User` instances in a private class field called
    `_users`. Next, the constructor is instantiating a new array of `User` objects.
    Finally, we are instantiating the array to be 0 items in length and then assigning
    that collection to our private backer field. This is because our array doesn''t
    have any users assigned to it yet, and we don''t want to further complicate this
    code by trying to keep track of null values. In a real-world example, you might
    choose to instantiate and assign the private backer field all in one line:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，有几个重要的部分我们需要注意。首先，我们将`User`实例存储在一个名为`_users`的私有类字段中。接下来，构造函数正在实例化一个新的`User`对象数组。最后，我们将数组实例化为长度为0的集合，并将其分配给我们的私有后端字段。这是因为我们的数组还没有分配任何用户，我们不希望通过尝试跟踪空值来进一步复杂化此代码。在现实世界的例子中，你可能会选择在一行中实例化和分配私有后端字段：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The former example is more verbose and, therefore, more readable. However,
    using the more succinct example takes up less space. Either approach will work.
    Next we''ll look at a method that allows us to add `User` objects to the array:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个例子更为冗长，因此更易于阅读。然而，使用更简洁的例子则占用的空间更少。两种方法都可以行得通。接下来，我们将探讨一种方法，允许我们将`User`对象添加到数组中：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we introduced a private method for some form of **validation**. The purpose
    of this method is to determine whether adding a user to the array is a valid operation
    at this time. First, we declared a `bool` variable called `containsUser`. We'll
    use this flag to signal whether or not the array already contains the `User` object
    being passed in. Next, we performed a `for` loop to check every object in the
    array against the passed in `User` object. If we find a match, we set the `containsUser`
    flag to `true` and break out of the `for` loop to save processor time. If `containsUser`
    is `true`, we know that the user object was found, and adding another copy would
    be a violation of our specified business rules. So, the method returns `false`.
    If the user does not exist in the array, execution continues.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们引入了一个私有方法来进行某种形式的**验证**。此方法的目的在于确定在此时刻将用户添加到数组中是否是一个有效的操作。首先，我们声明了一个名为`containsUser`的`bool`变量。我们将使用此标志来指示数组是否已经包含正在传递的`User`对象。接下来，我们执行了一个`for`循环来检查数组中的每个对象与传递的`User`对象是否匹配。如果我们找到一个匹配项，我们将`containsUser`标志设置为`true`并退出`for`循环以节省处理器时间。如果`containsUser`为`true`，我们知道找到了用户对象，添加另一个副本将违反我们指定的业务规则。因此，该方法返回`false`。如果用户不存在于数组中，则执行继续。
- en: 'Next, we checked whether the array already contains 30 or more items by evaluating
    its `Length` property. If `true`, we return `false` because the array is full
    according to our business rules and adding more would be a violation. Otherwise,
    we return `true` and program execution can continue:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过评估其`Length`属性来检查数组是否已经包含30个或更多项。如果是`true`，则返回`false`，因为根据我们的业务规则，数组已满，添加更多将构成违规。否则，返回`true`，程序执行可以继续：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This method is called once the user has been authenticated, which is the only
    time we want to add a user to the user rolls. In this method, we validated the
    add user operation by calling the `CanAddUser()` method. If the `CanAddUser()` method
    returns `true`, method execution continues. First, we used the `Array` wrapper
    class'' `Resize()` method to grow the array by one and make room for our new addition.
    Next, we assigned the new `User` object to the last position in the resized array.
    Finally, we performed some simple housekeeping by logging the user id and new
    length of the `_users` array to the console:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在用户经过身份验证后调用，这是我们想要将用户添加到用户名单中的唯一时间。在这个方法中，我们通过调用`CanAddUser()`方法来验证添加用户操作。如果`CanAddUser()`方法返回`true`，则方法执行继续。首先，我们使用`Array`包装类的`Resize()`方法将数组扩展一个元素，为新添加的对象腾出空间。接下来，我们将新的`User`对象赋值到调整大小后的数组中的最后一个位置。最后，我们通过将用户ID和新的`_users`数组长度记录到控制台来进行一些简单的维护：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This method is called when a previously authenticated user has been logged out
    of the web service. It uses the array wrapper class' `IndexOf()` method to determine
    whether the passed-in `User` object exists in the array. Since the `IndexOf()` returns
    `-1` if no matching object can be found, this method confirms that the value of
    `i` is equal to `-1`. If the value of `index` is equal to `-1` we perform some
    housekeeping in the form of a console message stating this user ID is not currently
    logged in. Otherwise, we begin the process of deleting an object from an array.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个先前认证的用户从网络服务中注销时，会调用此方法。它使用数组包装类的`IndexOf()`方法来确定传递的`User`对象是否存在于数组中。由于`IndexOf()`在找不到匹配对象时返回`-1`，此方法确认`i`的值等于`-1`。如果`index`的值等于`-1`，我们执行一些维护工作，例如在控制台中显示此用户ID当前未登录的消息。否则，我们开始从数组中删除对象的进程。
- en: First, we have to create a temporary array that is one element shorter than
    the old array. Next, we loop from 0 to the length of the new array, with `i` marking
    the position in the new array and `j` marking the position in the old array. If
    `i` equals the position of the item we want to remove, we increment `j` to skip
    past that element in the old array. Finally, we assign a user we intend to keep
    from the correct position in the old array to the new array. Once we're done iterating
    over the array, we assign the new list to the `_users` property. After this, we
    perform some simple housekeeping by logging the deleted user ID and new length
    of the `_users` array to the console.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个比旧数组少一个元素的临时数组。接下来，我们从0循环到新数组的长度，其中`i`标记新数组中的位置，`j`标记旧数组中的位置。如果`i`等于我们想要删除的项目位置，我们就增加`j`以跳过旧数组中的该元素。最后，我们将从旧数组中正确位置的用户分配到新数组中。一旦我们遍历完数组，我们就将新列表分配给`_users`属性。之后，我们通过在控制台记录已删除的用户ID和`_users`数组的新长度来执行一些简单的维护工作。
- en: '**Java**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are a few important pieces of the preceding example we need to make note
    of. First, we are storing our `User` instances in a private class field called
    `_users`. Next, the constructor is instantiating a new array of `User` objects.
    Finally, we are instantiating the array as 0 items in length and then assigning
    that collection to our private backer field. This is because our array doesn''t
    have any users assigned to it yet, and we don''t want to further complicate this
    code by trying to keep track of null values. In a real-world example, you might
    choose to instantiate and assign the private backer field all in one line:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，有几个重要的部分我们需要注意。首先，我们将`User`实例存储在一个名为`_users`的私有类字段中。其次，构造函数正在实例化一个新的`User`对象数组。最后，我们将数组实例化为长度为0的集合，并将其分配给我们的私有后端字段。这是因为我们的数组还没有分配任何用户，我们不希望通过尝试跟踪空值来进一步复杂化此代码。在现实世界的示例中，你可能会选择在一行中实例化和分配私有后端字段：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The former example is more verbose and, therefore, more readable. However,
    using the more succinct example takes up less space. As with C#, either approach
    will work:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例更冗长，因此更易读。然而，使用更简洁的示例会占用更少的空间。与C#一样，两种方法都可以工作：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we are introducing a private method for some sort of validation. The purpose
    of this method is to determine whether adding a user to the array is a valid operation
    at this time. First, we declared a `boolean` variable called `containsUser`. We'll
    use this flag to signal whether or not the array already contains the `User` object
    being passed in. Next, we performed a `for` loop to check every object in the
    array against the passed-in `User` object. If we find a match, we set the `containsUser`
    flag to `true` and break out of the `for` loop to save processor time. If `containsUser`
    is true`,` we know the user object was found, and adding another copy would be
    a violation of our specified business rules. So, the method returns `false`. If
    the user does not exist in the array, execution continues.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们引入一个私有方法来进行某种验证。这个方法的目的在于确定在这个时候将用户添加到数组中是否是一个有效的操作。首先，我们声明了一个名为`containsUser`的`boolean`变量。我们将使用这个标志来表示数组是否已经包含正在传递的`User`对象。接下来，我们执行一个`for`循环来检查数组中的每个对象与传递的`User`对象是否匹配。如果我们找到一个匹配项，我们将`containsUser`标志设置为`true`并退出`for`循环以节省处理器时间。如果`containsUser`为`true`，我们知道找到了用户对象，添加另一个副本将违反我们指定的业务规则。因此，该方法返回`false`。如果用户不存在于数组中，执行将继续。
- en: 'Next, we check whether the array already contains 30 or more items by evaluating
    its `Length` property. If `true`, we return `false` because the array is full
    according to our business rules, and adding more would be a violation. Otherwise,
    we return `true`, and program execution can continue:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过评估其 `Length` 属性来检查数组是否已经包含 30 个或更多项目。如果是 `true`，我们返回 `false`，因为根据我们的业务规则，数组已满，添加更多将是一种违规行为。否则，我们返回
    `true`，程序执行可以继续：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This method is called once the user has been authenticated, which is the only
    time we want to add a user to the user rolls. In this method, we validated the
    add user operation by calling the `CanAddUser()` method. If `CanAddUser()` returns
    `true`, the method execution continues. First, we used the `Arrays` wrapper class''
    `copyOf()` method to create a new copy of the array that is one element larger,
    making room for our new addition. Next, we assign the new `User` object to the
    last position in the resized array. Finally, we performed some simple housekeeping
    by logging the user id and the new length of the `_users` array to the console:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在用户认证后调用，这是我们想要将用户添加到用户名单的唯一时间。在此方法中，我们通过调用 `CanAddUser()` 方法验证了添加用户操作。如果
    `CanAddUser()` 返回 `true`，则方法执行继续。首先，我们使用 `Arrays` 包装类的 `copyOf()` 方法创建一个新数组的新副本，为我们的新添加腾出空间。接下来，我们将新的
    `User` 对象分配给调整大小后的数组中的最后一个位置。最后，我们通过将用户 ID 和 `_users` 数组的新长度记录到控制台来进行一些简单的维护工作：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method is called when a previously authenticated user has been logged out
    of the web service. First, it loops through the `_users` array to locate a matching
    object to the `User` object that has been passed in. We instantiate the index
    value to `-1` so that, if no matching object can be found, this value does not
    change. This method next confirms that the value of `index` is equal to `-1`.
    If `true`, we perform some housekeeping by logging in to the console this user
    id is not currently logged in. Otherwise, we begin the process of deleting the
    object from the `_users` array.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当之前认证的用户从网络服务中注销时，会调用此方法。首先，它会遍历 `_users` 数组以定位与传入的 `User` 对象匹配的对象。我们将索引值初始化为
    `-1`，这样，如果找不到匹配的对象，此值不会改变。接下来，此方法确认 `index` 的值是否等于 `-1`。如果是 `true`，我们通过在控制台记录此用户
    ID 当前未登录来进行一些维护工作。否则，我们开始从 `_users` 数组中删除对象的过程。
- en: First, we have to create a temporary array that is one element shorter than
    the old array. Next, we loop from 0 to the length of the new array, with `i` marking
    the position in the new array and `j` marking the position in the old array. If
    `i` equals the position of the item we want to remove, we increment `j` to skip
    past that element in the old array. Finally, we assign a user we intend to keep
    from the correct position in the old array to the new array. Once we're done looping,
    we assign the new list to the `_users` property. After this, we perform some simple
    housekeeping by logging the deleted user id and new length of the `_users` array
    to the console.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个比旧数组少一个元素的临时数组。然后，我们从 0 遍历到新数组的长度，`i` 标记新数组中的位置，`j` 标记旧数组中的位置。如果
    `i` 等于要删除的项目位置，我们增加 `j` 以跳过旧数组中的该元素。最后，我们将从旧数组中正确位置的用户分配到新数组中。一旦我们完成循环，我们将新列表分配给
    `_users` 属性。之后，我们通过将删除的用户 ID 和 `_users` 数组的新长度记录到控制台来进行一些简单的维护工作。
- en: '**Objective-C**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'Working with a primitive C array in Objective-C is considerably different than
    in C# or Java, predominantly because Objective-C does not provide methods for
    working *directly* with the primitive type. However, Objective-C does provide
    the `NSArray` wrapper class, which we will use in our code example here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 中与原始 C 数组一起工作与在 C# 或 Java 中相当不同，主要是因为 Objective-C 不提供直接与原始类型一起工作的方法。然而，Objective-C
    提供了 `NSArray` 包装类，我们将在下面的代码示例中使用它：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'First, our Objective-C class interface defines an **ivar** property for our
    array. Next, our initializer instantiates the `_users` object using the `[NSArrayarray]`
    convenience initializer:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的 Objective-C 类接口为我们的数组定义了一个 **ivar** 属性。接下来，我们的初始化器使用 `[NSArray array]`
    便利初始化器实例化 `_users` 对象：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `canAddUser:` method also serves as internal validation in our Objective-C
    example. The purpose of this method is to determine whether adding a user to the
    array is a valid operation at this time. Since we''re working with `NSArray`,
    we have access to the `containsUser:` method, which can immediately determine
    whether the passed-in `User` object exists in the `_users` array. Don''t be fooled
    by the simplicity of this code, however, because, under the `NSArray` hood, the
    `containsUser:` method looks something like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`canAddUser:`方法也作为我们Objective-C示例中的内部验证。此方法的目的是在当前时间将用户添加到数组中是否是一个有效的操作。由于我们正在使用`NSArray`，我们可以访问`containsUser:`方法，该方法可以立即确定传入的`User`对象是否存在于`_users`数组中。然而，不要被这段代码的简单性所迷惑，因为在`NSArray`的底层，`containsUser:`方法看起来像这样：'
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If that code looks familiar, it should because it is nearly identical in function
    to our previous C# and Java examples. The `containsObject:` method exists for
    our convenience, and it performs the heavy lifting for us behind the scenes. Again,
    if the user object is found, adding another copy is a violation of our specified
    business rules, and the method returns `false`. If the user does not exist, execution
    continues.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这段代码看起来很熟悉，那是因为它在功能上几乎与我们的之前的C#和Java示例相同。`containsObject:`方法是为了我们的方便而存在的，并且在我们背后执行繁重的工作。再次强调，如果找到用户对象，添加另一个副本将违反我们指定的业务规则，并且方法返回`false`。如果用户不存在，则执行继续。
- en: 'Next, we check whether the array already contains 30 or more items by evaluating
    its `count` property. If `true`, we return `false` because the array is full according
    to our business rules, and adding more would be a violation. Otherwise, we return
    `true`, and program execution can continue:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过评估其`count`属性来检查数组是否已经包含30个或更多项。如果是，则返回`false`，因为根据我们的业务规则，数组已满，添加更多将违反规则。否则，返回`true`，程序执行可以继续：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This method is called once the user has been authenticated, which is the only
    time we want to add a user to the user rolls. In this method, we validated the
    add user operation by calling `canAddUser:`. If `canAddUser:` returns `true`,
    the method execution continues. We use the `NSArray` class'' `arrayByAddingObject:`
    method to create a new copy of the array that includes our new `User` object.
    Last, we performed some simple housekeeping by logging the user id and new length
    of the `_users` array to the console:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是在用户认证成功后调用的，这是我们唯一想要将用户添加到用户角色列表中的时候。在这个方法中，我们通过调用`canAddUser:`来验证添加用户操作。如果`canAddUser:`返回`true`，则方法执行继续。我们使用`NSArray`类的`arrayByAddingObject:`方法创建一个包含我们新的`User`对象的新数组副本。最后，我们通过将用户id和`_users`数组的新长度记录到控制台来进行一些简单的维护操作：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method is called when a previously authenticated user has been logged out
    of the web service. First, it uses the `NSArray indexOfObject:` array to get an
    index for any object matching the `User` object that has been passed in. If the
    object is not found, the method returns `NSNotFound`, which is equivalent to `NSIntegerMax`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当之前认证过的用户从网络服务中注销时，将调用此方法。首先，它使用`NSArray indexOfObject:`数组来获取与已传入的`User`对象匹配的任何对象的索引。如果找不到对象，则方法返回`NSNotFound`，这相当于`NSIntegerMax`。
- en: This method next confirms that the value of `index` is equal to `NSNotFound`.
    If `true`, we perform some housekeeping by logging in to the console to which
    this user id is not currently logged in. Otherwise, we begin the process of deleting
    the object from the `_users` array.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接下来确认`index`的值是否等于`NSNotFound`。如果是，我们通过将此用户id当前未登录的控制台记录到控制台来进行一些维护操作。否则，我们开始从`_users`数组中删除对象的过程。
- en: Unfortunately, `NSArray` does not provide a method for deleting an object from
    the underlying immutable array, so we need to get a little creative. First, we
    create a temporary array object called `newUsers` to hold all the `User` objects
    that we want to keep. Next, we loop through the `_users` array, checking each
    object to see whether it matches the `User` we want to delete. If there is no
    match, we add it to the `newUsers` array in the same way we added a new user to
    `_users` when a user is authenticated. If the `User` object matches, we simply
    skip it, effectively deleting it from the final array of objects. As you can imagine,
    this procedure is very costly, and this pattern should be avoided if at all possible.
    Once the loop is complete, we assign the new array to the `_users` property. Finally,
    we perform some simple housekeeping by logging the deleted user id and the new
    count of the `_users` array to the console.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`NSArray` 不提供从底层不可变数组中删除对象的方法，因此我们需要有点创意。首先，我们创建一个名为 `newUsers` 的临时数组对象来保存我们想要保留的所有
    `User` 对象。然后，我们遍历 `_users` 数组，检查每个对象是否与我们要删除的 `User` 匹配。如果没有匹配项，我们以与将新用户添加到 `_users`
    时相同的方式将其添加到 `newUsers` 数组中。如果 `User` 对象匹配，我们简单地跳过它，从而从最终对象数组中删除它。正如你所想象的那样，这个程序非常耗时，如果可能的话，应尽量避免这种模式。一旦循环完成，我们将新数组赋值给
    `_users` 属性。最后，我们通过将删除的用户 ID 和 `_users` 数组的新计数记录到控制台来进行一些简单的维护工作。
- en: '**Swift**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Working with a primitive C array in Swift is very similar to doing so in C#
    or Java, in that it provides the `Array` class, which we will use in our code
    example here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中与原始 C 数组一起工作与在 C# 或 Java 中做得很相似，因为它提供了 `Array` 类，我们将在下面的代码示例中使用它：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We only need one class property to support our array of users. Swift arrays
    are type-dependent just as in C# and Java, and we must declare the type when declaring
    the array property. Note the difference in how Swift initializes arrays by surrounding
    the type name or object class name with the subscription operator, rather than
    appending the operator to the name:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要一个类属性来支持我们的用户数组。Swift 数组与 C# 和 Java 一样具有类型依赖性，我们必须在声明数组属性时声明类型。注意 Swift
    初始化数组的方式，它是通过在类型名称或对象类名称周围使用订阅操作符，而不是将其附加到名称上：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `canAddUser:` method also serves as internal validation. The purpose of
    this method is to determine whether adding a user to the array is a valid operation
    at this time. First, we're using the `Array.contains()` method to determine whether
    the user we want to add already exists in the array. If the user object is found,
    adding another copy is a violation of our specified business rules, and the method
    returns `false`. If the user does not exist, execution continues.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`canAddUser:` 方法也用作内部验证。此方法的目的在于确定在此时刻将用户添加到数组中是否是一个有效的操作。首先，我们使用 `Array.contains()`
    方法来确定我们想要添加的用户是否已经存在于数组中。如果找到用户对象，添加另一个副本将违反我们指定的业务规则，并且方法返回 `false`。如果用户不存在，则继续执行。'
- en: 'Next, we use the `count` property of the `_users` array to check that the total
    number of objects within the array is not greater than or equal to 30\. If `true`,
    we return `false` because the array is full according to our business rules, and
    adding more would be a violation. Otherwise, we return `true`, and program execution
    can continue:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `_users` 数组的 `count` 属性来检查数组内的对象总数是否不大于或等于 30。如果为 `true`，则返回 `false`，因为根据我们的业务规则，数组已满，添加更多将违反规则。否则，返回
    `true`，程序执行可以继续：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Again, this method is called once the user has been authenticated, which is
    the only time we want to add a user to the user rolls. In this method, we validate
    the add user operation by calling the `canAddUser()` method. If `canAddUser()`
    returns `true`, the method execution continues, and we add the user to the array
    using the `Array.append()` method. Last, we perform some simple housekeeping by
    logging the user id and new length of the `_users` array to the console:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，此方法是在用户经过认证后调用的，这是我们想要将用户添加到用户名单的唯一时间。在这个方法中，我们通过调用 `canAddUser()` 方法来验证添加用户操作。如果
    `canAddUser()` 返回 `true`，则方法执行继续，我们使用 `Array.append()` 方法将用户添加到数组中。最后，我们通过将用户
    ID 和 `_users` 数组的新长度记录到控制台来进行一些简单的维护工作：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Finally, to remove a user during logout, we first need to determine whether
    the object exists in the array and get its index within the array. Swift allows
    us to simultaneously declare the `index` variable, perform this check, and assign
    a value to `index`. If this check returns `true`, we call `Array.removeAtIndex()`
    to take the `user` object out of the array. Finally, we perform some simple housekeeping
    by logging the deleted user ID and the new count of the `_users` array to the
    console.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了在注销时删除用户，我们首先需要确定该对象是否存在于数组中，并获取其在数组中的索引。Swift 允许我们同时声明`index`变量，执行此检查，并将值赋给`index`。如果此检查返回`true`，我们调用`Array.removeAtIndex()`从数组中移除`user`对象。最后，我们通过记录被删除的用户ID和`_users`数组的新计数到控制台来进行一些简单的维护工作。
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Separation of concerns**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**关注点分离**'
- en: When you examine the previous examples, you might wonder what happens to all
    those `User` objects we have been adding once we are done with them. If so, great
    catch! If you look closely, you will see we have not instantiated or modified
    a single `User` object in this example-only the array that was contained the objects.
    This is by design.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查前面的例子时，你可能会想知道当我们完成对它们的使用后，所有那些`User`对象会发生什么。如果是这样，那是个很好的发现！如果你仔细观察，你会看到在这个例子中我们没有实例化或修改任何一个`User`对象——只有包含对象的数组被修改了。这是有意为之的。
- en: In object-oriented programming, the concept of **separation of concerns** dictates
    that computer programs should be broken up into distinct operational features
    that overlap as little as possible. For example, a class named `LoggedInUserArray`,
    which operates as a wrapper to an underlying array structure, should only manipulate
    its array's operations and have little bearing on objects within the array. In
    this case, the inner workings and details of the `User` class objects that are
    passed in are not the `LoggedInUserArray` class's concern.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，**关注点分离**的概念规定，计算机程序应该被分解成尽可能少重叠的操作特性。例如，一个名为`LoggedInUserArray`的类，作为底层数组结构的包装器，应该只操作其数组的操作，对数组中的对象影响很小。在这种情况下，传入的`User`类对象的内部工作和细节不是`LoggedInUserArray`类的关注点。
- en: Once each `User` is removed from the array, the object goes on its merry way.
    If the application retains no other references to the `User` object, some form
    of **garbage collection** will eventually dispose it off from memory. Either way,
    the `LoggedInUserArray` class is not responsible for garbage collection and remains
    agnostic concerning these types of detail.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦每个`User`从数组中移除，该对象就会继续其愉快的旅程。如果应用程序没有保留对`User`对象的任何其他引用，那么某种形式的**垃圾回收**最终会将其从内存中清除。无论如何，`LoggedInUserArray`类不负责垃圾回收，并且对这些细节保持中立。
- en: Advanced topics
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级主题
- en: 'Now that we have seen how arrays are used in common practice, let''s examine
    a few advanced topics relating to arrays: search patterns and variations on the
    basic types of objects that can be stored in an array.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了数组在常见实践中的应用，让我们来探讨一些与数组相关的高级主题：搜索模式和数组中可以存储的基本对象类型的变体。
- en: Linear search
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性搜索
- en: When learning about data structures, it is impossible to avoid discussing the
    subjects of **searching** and **sorting**. Without the ability to search a data
    structure, the data would be fairly useless to us. Without the ability to sort
    the data set for use in a particular application, the data would be extremely
    tedious to manage.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习数据结构时，不可避免地要讨论**搜索**和**排序**这两个主题。如果没有在数据结构中进行搜索的能力，数据对我们来说将几乎毫无用处。如果没有对数据集进行排序以便在特定应用中使用的能力，数据的管理将变得极其繁琐。
- en: The steps or process we follow to perform a search or a sort of a particular
    data structure are called an **algorithm**. The performance or the complexity
    of an algorithm in computer science is measured using the **big O notation**,
    which is derived from the function *f(n) =* **O** *(g(n))*, read as *f of n equals
    big oh of g of n*. In the simplest terms, **big** **O** is the terminology we
    use to describe the worst case for how long an algorithm takes to run. For example,
    if we know the index of the object we are searching for in an array, it takes
    only one comparison to locate and retrieve that object. Therefore, the worst case
    requires one comparison, and the cost of the search is **O**(*1*).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行特定数据结构的搜索或排序所遵循的步骤或过程称为**算法**。算法在计算机科学中的性能或复杂度是通过使用**大 O 表示法**来衡量的，它来源于函数
    *f(n) =* **O** *(g(n))*，读作*f of n equals big oh of g of n*。用最简单的术语来说，**大 O** 是我们用来描述算法运行最长时间的最坏情况的术语。例如，如果我们知道在数组中搜索的对象的索引，那么只需要一次比较就可以定位和检索该对象。因此，最坏情况需要一次比较，搜索的成本是
    **O**(*1*)。
- en: 'Although we will examine searching and sorting in much greater detail later,
    for now, we will examine **linear searching**, or sequential searching, which
    is the simplest and least efficient pattern for searching a collection. Iteration
    means repeating a process over and over again. With a linear search, we iterate
    sequentially over the collection of objects until we find a match to our search
    pattern. For collections containing *n* items, the best-case search is when the
    target value is equal to the first item in the collection, which means, only one
    comparison is required. In the worst-case scenario, the target value is not found
    in the collection at all, which means *n* comparisons are required. This means
    the cost of a linear search is **O**(*n*). If you look back at the code examples,
    you will see **O**(*n*) searches in several places:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将在稍后更详细地研究搜索和排序，但到目前为止，我们将研究**线性搜索**，或顺序搜索，这是搜索集合中最简单且效率最低的模式。迭代意味着重复执行一个过程。在线性搜索中，我们按顺序遍历对象集合，直到找到与我们的搜索模式匹配的项。对于包含
    *n* 个项目的集合，最佳搜索情况是目标值等于集合中的第一个项目，这意味着只需要一次比较。在最坏的情况下，目标值根本不在集合中，这意味着需要 *n* 次比较。这意味着线性搜索的成本是
    **O**(*n*)。如果你回顾代码示例，你会在几个地方看到 **O**(*n*) 搜索：
- en: '**C#**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'Here''s the linear search algorithm from our C# code but reformatted to use
    a `for` loop, which better demonstrates the concept of **O**(*n*) cost:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们 C# 代码中的线性搜索算法，但已重新格式化以使用 `for` 循环，这更好地说明了 **O**(*n*) 成本的概念：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Java**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'Here''s the linear search algorithm from our Java code but reformatted to use
    a `for` loop, which better demonstrates the concept of **O**(*n*) cost:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们 Java 代码中的线性搜索算法，但已重新格式化以使用 `for` 循环，这更好地说明了 **O**(*n*) 成本的概念：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Objective-C**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'Here''s the linear search algorithm from our Objective-C code but reformatted
    to use a `for` loop which better demonstrates the concept of **O**(*n*) cost:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们 Objective-C 代码中的线性搜索算法，但已重新格式化以使用 `for` 循环，这更好地说明了 **O**(*n*) 成本的概念：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Swift**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Our Swift code does not include an example of a linear search, but one example
    could look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Swift 代码中没有包含线性搜索的示例，但一个示例可能看起来像这样：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Primitive arrays
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始数组
- en: Primitive arrays are simply arrays that only contain primitive types. In C#,
    Java, and Swift, you declare a primitive array by declaring an array on a primitive
    type. As a weakly typed language, Objective-C does not support explicitly typed
    arrays, and therefore does not support explicitly primitive arrays.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数组是仅包含原始类型的数组。在 C#、Java 和 Swift 中，你通过在原始类型上声明一个数组来声明一个原始数组。作为弱类型语言，Objective-C
    不支持显式类型化的数组，因此也不支持显式原始数组。
- en: '**C#**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Java**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Objective-C**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Swift**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Object arrays
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象数组
- en: Object arrays are simply arrays that contain only instances of a particular
    object. In C#, Java, and Swift, you declare an object array by declaring an array
    on class. As a weakly typed language, Objective-C does not support explicitly
    typed arrays and, therefore, does not support explicitly object arrays.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对象数组是仅包含特定对象实例的数组。在 C#、Java 和 Swift 中，你通过在类上声明一个数组来声明一个对象数组。作为弱类型语言，Objective-C
    不支持显式类型化的数组，因此也不支持显式对象数组。
- en: '**C#**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Java**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Objective-C**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Swift**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Mixed arrays
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合数组
- en: When working with arrays, you declare the array using one data type, and all
    of the elements in the array must match that data type. Typically, this constraint
    is suitable, since the elements are normally closely related to one another or
    share similar property values. At other times, the elements in your array are
    not closely related or do not have similar property values. In these circumstances,
    it is desirable to have the ability to mix-and-match types within the same array.
    C# and Java share a similar mechanism for accomplishing this--declaring the array
    as the root class object type. Arrays in Objective-C are already mixed by default
    due to the language being weakly typed. Swift provides the `AnyObject` type for
    declaring mixed arrays.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当与数组一起工作时，您使用一种数据类型声明数组，并且数组中的所有元素都必须匹配该数据类型。通常，这种约束是合适的，因为元素通常彼此紧密相关或共享相似的性质值。在其他时候，数组中的元素并不紧密相关或没有相似的性质值。在这些情况下，您可能希望能够在同一数组中混合匹配类型。C#和Java都提供了类似的机制来实现这一点——将数组声明为根类对象类型。由于Objective-C语言是弱类型，其数组默认就是混合的。Swift提供了`AnyObject`类型来声明混合数组。
- en: '**C#**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Java**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Objective-C**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Swift**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Working with mixed arrays can seem convenient at the first glance, but be aware
    that you as the developer take the responsibility for type checking away from
    the compiler. This won't be a major adjustment for developers with weakly typed
    languages such as Objective-C, but developers experienced in strongly typed languages
    will need to be very attentive to this concern.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与混合数组一起工作可能看起来很方便，但请注意，作为开发人员，您将类型检查的责任从编译器移走。对于像Objective-C这样的弱类型语言的开发人员来说，这不会是一个重大的调整，但经验丰富的强类型语言开发人员需要对此问题非常关注。
- en: Multidimensional arrays
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多维数组
- en: A multidimensional array is an array containing one or more additional arrays.
    The four languages we are working with can each support multidimensional arrays
    of *1...n* dimensions. However, be aware that multidimensional arrays greater
    than three levels deep become extremely difficult to manage.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组是一个包含一个或多个额外数组的数组。我们正在使用的四种语言都可以支持*1...n*维度的多维数组。然而，请注意，超过三个级别的多维数组管理起来会变得极其困难。
- en: It sometimes helps to conceptualize multidimensional arrays in terms relative
    to their dimensions. For example, a 2D array might have rows and columns, or *x*
    and *y* values. Similarly, a 3D array might have *x*, *y*, and *z* values. Let's
    look at an example of 2D and 3D arrays in each language.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将多维数组概念化为与它们的维度相关的内容会有所帮助。例如，一个二维数组可能有行和列，或者*x*和*y*值。同样，一个三维数组可能有*x*、*y*和*z*值。让我们看看每种语言中二维和三维数组的示例。
- en: '**C#**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'Multidimensional arrays in C# are created with the `[,]` syntax, where each
    `,` represents one additional dimension within the array. The corresponding `new`
    initializer must provide the correct number of size arguments to match the definition
    or the code will not compile:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的多维数组使用`[,]`语法创建，其中每个逗号代表数组中的一个额外维度。相应的`new`初始化器必须提供正确数量的尺寸参数以匹配定义，否则代码将无法编译：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Java**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'The syntax for creating multidimensional arrays in Java simply involves stringing
    pairs of `[]` where each pair represents one dimension within the array. The corresponding
    `new` initializer must provide the correct number of bracketed size arguments
    to match the definition or the code will not compile:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中创建多维数组的语法简单涉及将`[]`配对连接起来，其中每一对代表数组中的一个维度。相应的`new`初始化器必须提供正确数量的括号大小参数以匹配定义，否则代码将无法编译：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Objective-C**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: Objective-C does not directly support multidimensional arrays with the `NSArray`
    class. If a multidimensional array is required in your code, you will need to
    use `NSMutableArray` or a plain C array, both of which are outside the scope of
    this chapter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C不直接支持`NSArray`类中的多维数组。如果您的代码需要多维数组，您将需要使用`NSMutableArray`或一个普通的C数组，这两者都不在本章的范围内。
- en: '**Swift**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Multidimensional arrays in Swift can seem somewhat confusing at first glance,
    but what you need to realize is that you are creating arrays of arrays. The definition
    syntax is `[[Int]]` while the initialization syntax is `[[1, 2], [3, 4]]` where
    the values used at initialization can be any value of the specified type:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中的多维数组一开始看起来可能有些令人困惑，但您需要意识到您正在创建数组的数组。定义语法是`[[Int]]`，初始化语法是`[[1, 2], [3,
    4]]`，其中初始化时使用的值可以是指定类型的任何值：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Jagged Arrays
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锯齿状数组
- en: Jagged arrays are created when a multidimensional array contains arrays of different
    sizes. There are rare scenarios when such a design is necessary, but be aware
    that jagged arrays can be very complex and difficult to manage. C#, Java, and
    Swift support jagged arrays. Objective-C does not support multidimensional arrays
    using `NSArray`, and therefore, does not support jagged arrays using it. As with
    multidimensional arrays, Objective-C can support jagged arrays using either `NSMutableArray`
    or plain C arrays.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当多维数组包含不同大小的数组时，会创建交错数组。在极少数情况下，这种设计是必要的，但请注意，交错数组可能非常复杂且难以管理。C#、Java和Swift支持交错数组。Objective-C不支持使用`NSArray`的多维数组，因此也不支持使用它来创建交错数组。与多维数组类似，Objective-C可以使用`NSMutableArray`或纯C数组来支持交错数组。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the basic definition of an array structure, how
    arrays look in memory, and how each of the four languages we are discussing implement
    some form of the plain C array structure. Next, we discussed the difference between
    mutable and immutable arrays. Using examples, we looked at how each of the four
    languages we are discussing implements arrays and array functionality. In the
    remainder of the chapter, we examined the linear search algorithm and introduced
    the big **O** notation, including how this notation is applied to arrays with
    examples of simple iteration. We discussed the difference between primitive arrays,
    object arrays, and mixed arrays. Finally, we examined multidimensional arrays
    and their counterpart, jagged arrays.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了数组结构的基本定义，数组在内存中的样子，以及我们讨论的四种语言如何实现纯C数组结构。接下来，我们讨论了可变数组和不可变数组之间的区别。通过示例，我们探讨了四种语言如何实现数组和数组功能。在本章的剩余部分，我们研究了线性搜索算法，并介绍了大**O**符号，包括如何将此符号应用于数组，并举例说明简单的迭代。我们讨论了原始数组、对象数组和混合数组之间的区别。最后，我们研究了多维数组及其对应项，交错数组。
- en: As a final note, it is important to know when to use an array. Arrays are great
    for containing small lists of constant data or data that changes very little to
    not at all. If you find yourself constantly manipulating the data in your array
    or constantly adding and removing objects, then you will want to examine alternative
    data structures such as the List which we will discuss in the following chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的注意事项，了解何时使用数组是很重要的。数组非常适合存储少量恒定数据或变化极小甚至不变化的数据。如果你发现自己经常在操作数组中的数据，或者经常添加和删除对象，那么你可能需要考虑使用其他数据结构，例如列表，我们将在下一章中讨论。
