- en: Common Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的设计模式
- en: 'Design patterns have been a widespread topic in software engineering since
    their original inception in the famous **Gang of Four** (**GoF**) book, *Design
    Patterns: Elements of Reusable Object-Oriented Software*. Design patterns help
    to solve common problems with abstractions that work for certain scenarios. When
    they are implemented properly, the general design of the solution can benefit
    from them.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自从它们最初出现在著名的**四人帮**（**GoF**）的书籍*《设计模式：可复用面向对象软件的元素》*中以来，设计模式一直是软件工程中的一个广泛讨论的话题。设计模式有助于解决一些常见的问题，这些问题是针对特定场景的抽象。当它们被正确实现时，解决方案的一般设计可以从中受益。
- en: In this chapter we take a look at some of the most common design patterns, but
    not from the perspective of tools to apply under certain conditions (once the
    patterns have been devised), but rather we analyze how design patterns contribute
    to clean code. After presenting a solution that implements a design pattern, we
    analyze how the final implementation is comparatively better as if we had chosen
    a different path.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从最常见的设计模式的角度来看，但不是从在特定条件下应用工具的角度（一旦设计出模式），而是分析设计模式如何有助于编写清晰的代码。在介绍实现设计模式的解决方案后，我们将分析最终实现与选择不同路径相比是如何更好的。
- en: As part of this analysis, we will see how to concretely implement design patterns
    in Python. As a result of that, we will see that the dynamic nature of Python
    implies some differences of implementation, with respect to other static typed
    languages, for which many of the design patterns were originally thought of. This
    means that there are some particularities about design patterns that you should
    bear in mind when it comes to Python, and, in some cases, trying to apply a design
    pattern where it doesn't really fit is non-Pythonic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个分析的过程中，我们将看到如何在Python中具体实现设计模式。由此产生的结果是，我们将看到Python的动态特性意味着在实现上存在一些差异，与其他静态类型的语言相比，许多设计模式最初是针对这些语言而设计的。这意味着在涉及Python时，设计模式有一些特殊之处，你应该记住，有些情况下，试图应用一个设计模式，而它实际上并不适用于Python，是不符合Python风格的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Common design patterns.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的设计模式。
- en: Design patterns that don't apply in Python, and the idiomatic alternative that
    should be followed.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中不适用的设计模式，以及应该遵循的惯用替代方案。
- en: The Pythonic way of implementing the most common design patterns.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中实现最常见的设计模式的Python风格。
- en: Understanding how good abstractions evolve naturally into patterns.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解良好的抽象是如何自然地演变成模式的。
- en: Considerations for design patterns in Python
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的设计模式考虑事项
- en: Object-oriented design patterns are ideas of software construction that appear
    in different scenarios when we deal with models of the problem we're solving.
    Because they're high-level ideas, it's hard to think of them as being tied to
    particular programming languages. They are instead more general concepts about
    how objects will interact in the application. Of course, they will have their
    implementation details, varying from language to language, but that doesn't form
    the essence of a design pattern.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的设计模式是软件构建的想法，在解决问题模型时出现在不同的场景中。因为它们是高层次的想法，很难将它们视为与特定编程语言相关联。相反，它们更多是关于对象在应用程序中如何交互的一般概念。当然，它们会有它们的实现细节，从语言到语言会有所不同，但这并不构成设计模式的本质。
- en: That's the theoretical aspect of a design pattern, the fact that it is an abstract
    idea that expresses concepts about the layout of the objects in the solution.
    There are plenty of other books and several other resources about object-oriented
    design, and design patterns in particular, so in this book, we are going to focus
    on those implementation details for Python.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设计模式的理论方面，它是一个关于解决方案中对象布局的抽象概念。关于面向对象设计和设计模式的其他书籍和资源有很多，所以在本书中，我们将专注于Python的这些实现细节。
- en: Given the nature of Python, some of the classical design patterns aren't actually
    needed. That means that Python already supports features that render those patterns
    invisible. Some argue that they don't exist in Python, but keep in mind that invisible
    doesn't mean non-existing. They are there, just embedded in Python itself, so
    it's likely that we won't even notice them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于Python的特性，一些经典的设计模式实际上并不需要。这意味着Python已经支持了使这些模式不再需要的功能。有人认为它们在Python中不存在，但请记住，不可见并不意味着不存在。它们确实存在，只是嵌入在Python本身中，所以我们可能甚至不会注意到它们。
- en: Others have a much simpler implementation, again thanks to the dynamic nature
    of the language, and the rest of them are practically the same as they are in
    other platforms, with small differences.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 其他的实现方式要简单得多，这要归功于语言的动态特性，其余的实现方式在其他平台上几乎是一样的，只有细微的差异。
- en: In any case, the important goal for achieving clean code in Python is knowing
    what patterns to implement and how. That means recognizing some of the patterns
    that Python already abstracts and how we can leverage them. For instance, it would
    be completely non-Pythonic to try to implement the standard definition of the
    iterator pattern (as we would do in different languages), because (as we have
    already covered) iteration is deeply embedded in Python, and the fact that we
    can create objects that will directly work in a `for` loop makes this the right
    way to proceed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，在Python中实现清晰的代码的重要目标是知道要实现哪些模式以及如何实现。这意味着要识别Python已经抽象出来的一些模式以及我们如何利用它们。例如，尝试实现迭代器模式的标准定义（就像我们在其他语言中所做的那样）是完全不符合Python风格的，因为（正如我们已经讨论过的）迭代在Python中已经深深嵌入，我们可以创建的对象可以直接在`for`循环中工作，这是正确的做法。
- en: Something similar happens with some of the creational patterns. Classes are
    regular objects in Python, and so are functions. As we have seen in several examples
    so far, they can be passed around, decorated, reassigned, and so on. That means
    that whatever kind of customization we would like to make to our objects, we can
    most likely do it without needing any particular setup of factory classes. In
    addition, there is no special syntax for creating objects in Python (no new keyword,
    for example). This is another reason why, most of the time, a simple function
    call will just work as a factory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一些创建型模式也存在类似的情况。在Python中，类是常规对象，函数也是。正如我们之前在几个示例中看到的那样，它们可以被传递、装饰、重新分配等。这意味着无论我们想对对象进行什么样的定制，我们很可能可以在不需要任何特定的工厂类设置的情况下完成。此外，在Python中没有创建对象的特殊语法（例如没有new关键字）。这也是为什么大多数情况下，简单的函数调用就可以作为工厂。
- en: Other patterns are still needed, and we will see how, with some small adaptations,
    we can make them more Pythonic, taking full advantage of the features that the
    language provides (magic methods or the standard library).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 其他模式仍然是必需的，我们将看到如何通过一些小的调整，使它们更符合Python的特点，充分利用语言提供的特性（魔术方法或标准库）。
- en: Out of all the patterns available, not all of them are equally frequent, nor
    useful, so we will focus on the main ones, those that we would expect to see the
    most in our applications, and we will do so by following a pragmatic approach.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有可用的模式中，并非所有模式都同样频繁，也不同样有用，因此我们将专注于主要的模式，那些我们期望在我们的应用程序中最常见的模式，并且我们将通过实用的方法来做到这一点。
- en: Design patterns in action
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式的实际应用
- en: The canonical reference in this subject, as written by the GoF, introduces 23
    design patterns, each falling under one of the creational, structural, and behavioral
    categories. There are even more patterns or variations of existing ones, but rather
    than learning all of these patterns off by heart, we should focus on keeping two
    things in mind. Some of the patterns are invisible in Python, and we use them probably without
    even noticing. Secondly, not all patterns are equally common; some of them are
    tremendously useful, and so they are found very frequently, while others are for
    more specific cases.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 作为GoF所写的这个主题的权威参考，介绍了23种设计模式，每一种都属于创建型、结构型和行为型中的一种。甚至还有更多的模式或现有模式的变体，但我们不应该死记所有这些模式，而是应该专注于牢记两件事。一些模式在Python中是看不见的，我们可能在不知不觉中使用它们。其次，并非所有模式都同样常见；其中一些模式非常有用，因此它们经常出现，而其他模式则更适用于特定情况。
- en: In this section, we will revisit the most common patterns, those that are most
    likely to emerge from our design. Note the use of the word *emerge* here. It is
    important. We should not force the application of a design pattern to the solution
    we are building, but rather evolve, refactor, and improve our solution until a
    pattern emerges.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重新审视最常见的模式，这些模式最有可能从我们的设计中出现。请注意这里使用了“出现”这个词。这很重要。我们不应该强制将设计模式应用于我们正在构建的解决方案，而是应该演变、重构和改进我们的解决方案，直到出现一个模式。
- en: Design patterns are therefore not invented but discovered. When a situation
    that occurs repeatedly in our code reveals itself, the general and more abstract
    layout of classes, objects, and related components appears under a name by which
    we identify a pattern.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，设计模式并非是被发明出来的，而是被发现的。当我们的代码中反复出现的情况揭示出来时，类、对象和相关组件的一般和更抽象的布局以一种名称出现，我们通过这个名称来识别一个模式。
- en: Thinking the same thing, but now backward, we realize that the name of a design
    pattern wraps up a lot of concepts. This is probably the best thing about design
    patterns; they provide a language. Through design patterns, it's easier to communicate
    design ideas effectively. When two or more software engineers share the same vocabulary,
    and one of them mentions builder, the rest of them can immediately think about
    all the classes, and how they would be related, what their mechanics would be,
    and so on, without having to repeat this explanation all over again.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 思考同样的事情，但现在是向后看，我们意识到设计模式的名称包含了许多概念。这可能是设计模式最好的地方；它们提供了一种语言。通过设计模式，更容易有效地传达设计思想。当两个或更多的软件工程师共享相同的词汇时，其中一个提到构建器，其他人可以立即想到所有的类，它们之间的关系，它们的机制等，而无需再次重复这个解释。
- en: The reader will notice that the code shown in this chapter is different from
    the canonical or original envisioning of the design pattern in question. There
    is more than one reason for this. The first reason is that the examples take a
    more pragmatic approach, aimed at solutions for particular scenarios rather than
    exploring general design theory. The second reason is that the patterns are implemented
    with the particularities of Python, which in some cases are very subtle, but in
    other cases, the differences are noticeable, generally simplifying the code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 读者会注意到，本章中显示的代码与所讨论的设计模式的规范或原始构想不同。这有不止一个原因。第一个原因是示例采用了更加务实的方法，旨在解决特定场景的问题，而不是探索一般的设计理论。第二个原因是这些模式是根据Python的特点实现的，在某些情况下可能非常微妙，但在其他情况下，差异是明显的，通常简化了代码。
- en: Creational patterns
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建型模式
- en: In software engineering, creational patterns are those that deal with object
    instantiation, trying to abstract away much of the complexity (like determining
    the parameters to initialize an object, all the related objects that might be
    needed, etc.), in order to leave the user with a simpler interface, that should
    be safer to use. The basic form of object creation could result in design problems
    or added complexity to the design. Creational design patterns solve this problem
    by somehow controlling this object creation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，创建型模式处理对象实例化，试图抽象掉大部分复杂性（比如确定初始化对象的参数，可能需要的所有相关对象等），以便为用户留下一个更简单、更安全的接口。对象创建的基本形式可能导致设计问题或增加设计的复杂性。创建型设计模式通过某种方式控制对象的创建来解决这个问题。
- en: Out of the five patterns for creating objects, we will discuss mainly the variants
    that are used to avoid the singleton pattern, and replace it with the Borg pattern
    (most commonly used in Python applications), discussing their differences and
    advantages.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对象的五种模式中，我们将主要讨论用于避免单例模式并用 Borg 模式替代的变体（在 Python 应用程序中最常用），讨论它们的区别和优势。
- en: Factories
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂
- en: As was mentioned in the introduction, one of the core features of Python is
    that everything is an object, and as such, they can all be treated equally. This
    means that there are no special distinctions of things that we can or cannot do
    with classes, functions, or custom objects. They can all be passed by parameter,
    assigned, and so on.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在介绍中提到的，Python 的一个核心特性是一切都是对象，因此它们都可以平等对待。这意味着对类、函数或自定义对象没有特殊的区分。它们都可以作为参数传递、赋值等。
- en: It is for this reason that many of the factory patterns are not really needed.
    We could just simply define a function that will construct a set of objects, and
    we can even pass the class that we want to create by a parameter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正因为如此，许多工厂模式实际上并不是真正需要的。我们只需简单地定义一个函数来构造一组对象，甚至可以通过参数传递要创建的类。
- en: Singleton and shared state (monostate)
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例和共享状态（单态）
- en: The singleton pattern, on the other hand, is something not entirely abstracted
    away by Python. The truth is that most of the time, this pattern is either not
    really needed or is a bad choice. There are a lot of problems with singletons
    (after all, they are, in fact, a form of global variables for object-oriented
    software, and as such, are a bad practice). They are hard to unit test, the fact
    that they might be modified at any time by any object makes them hard to predict,
    and their side-effects can be really problematic.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，单例模式并不是完全被 Python 抽象化的东西。事实上，大多数情况下，这种模式要么不是真正需要的，要么是一个糟糕的选择。单例存在很多问题（毕竟，它们实际上是面向对象软件的全局变量形式，因此是一种不好的实践）。它们很难进行单元测试，它们可能随时被任何对象修改，这使得它们很难预测，它们的副作用可能会带来真正的问题。
- en: As a general principle, we should avoid using singletons as much as possible.
    If in some extreme case, they are required, the easiest way of achieving this
    in Python is by using a module. We can create an object in a module, and once
    it's there, it will be available from every part of the module that is imported.
    Python itself makes sure that modules are already singletons, in the sense that
    no matter how many times they're imported, and from how many places, the same
    module is always the one that is going to be loaded into `sys.modules`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个一般原则，我们应该尽量避免使用单例。如果在某些极端情况下需要它们，Python 中最简单的实现方式是使用模块。我们可以在一个模块中创建一个对象，一旦在那里，它将从模块的每个部分中可用。Python
    本身确保模块已经是单例，无论它们被导入多少次，从多少地方导入，始终是相同的模块将被加载到“sys.modules”中。
- en: Shared state
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享状态
- en: Rather than forcing our design to have a singleton in which only one instance
    is created, no matter how the object is invoked, constructed, or initialized,
    it is better to replicate the data across multiple instances.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与其强制设计为只创建一个实例的单例，无论对象如何被调用、构造或初始化，还不如在多个实例之间复制数据。
- en: The idea of the monostate pattern (SNGMONO) is that we can have many instances
    that are just regular objects, without having to care whether they're singletons
    or not (seeing as they're just objects). The good thing about this pattern is
    that these objects will have their information synchronized, in a completely transparent
    way, without us having to worry about how this works internally.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 单态模式（SNGMONO）的想法是我们可以有许多实例，它们只是普通对象，而不必关心它们是否是单例（因为它们只是对象）。这种模式的好处是这些对象的信息将以完全透明的方式同步，而无需我们担心这是如何在内部工作的。
- en: This makes this pattern a much better choice, not only for its convenience,
    but also because it is less error-prone, and suffers from fewer of the disadvantages
    of singletons (regarding their testability, creating derived classes, and so on).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得这种模式成为一个更好的选择，不仅因为它的便利性，而且因为它更少受到单例的缺点的影响（关于它们的可测试性、创建派生类等）。
- en: We can use this pattern on many levels, depending on how much information we
    need to synchronize.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在许多级别上使用这种模式，这取决于我们需要同步多少信息。
- en: In its simplest form, we can assume that we only need to have one attribute
    to be reflected across all instances. If that is the case, the implementation
    is as trivial as using a class variable, and we just need to take care in providing
    a correct interface to update and retrieve the value of the attribute.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式中，我们可以假设只需要一个属性在所有实例中反映。如果是这种情况，实现就像使用一个类变量一样简单，我们只需要确保提供正确的接口来更新和检索属性的值。
- en: 'Let''s say we have an object that has to pull a version of a code in a Git
    repository by the latest `tag`. There might be multiple instances of this object,
    and when every client calls the method for fetching the code, this object will
    use the `tag` version from its attribute. At any point, this `tag` can be updated
    for a newer version, and we want any other instance (new or already created) to
    use this new branch when the `fetch` operation is being called, as shown in the
    following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个对象，必须通过最新的“标签”从 Git 存储库中拉取代码的版本。可能会有多个此对象的实例，当每个客户端调用获取代码的方法时，此对象将使用其属性中的“标签”版本。在任何时候，此“标签”都可以更新为更新版本，我们希望任何其他实例（新创建的或已创建的）在调用“获取”操作时使用这个新分支，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The reader can simply verify that creating multiple objects of the `GitFetcher`
    type with different versions will result in all objects being set with the latest
    version at any time, as shown in the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 读者只需验证创建具有不同版本的“GitFetcher”类型的多个对象将导致所有对象在任何时候都设置为最新版本，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the case that we need more attributes, or that we wish to encapsulate the
    shared attribute a bit more, to make the design cleaner, we can use a descriptor.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要更多属性，或者希望更好地封装共享属性，使设计更清晰，我们可以使用描述符。
- en: 'A descriptor, like the one shown in the following code, solves the problem,
    and while it''s true that it requires more code, it also encapsulates a more concrete
    responsibility, and part of the code is actually moved away from our original
    class, making either one of them more cohesive and compliant with the single responsibility
    principle:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 像下面代码中所示的描述符解决了问题，虽然它需要更多的代码，但它也封装了更具体的责任，部分代码实际上从我们的原始类中移开，使它们中的任何一个更具凝聚性和符合单一责任原则：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Apart from these considerations, it's also true that the pattern is now more
    reusable. If we want to repeat this logic, we just have to create a new descriptor
    object that would work (complying with the DRY principle).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些考虑因素外，模式现在更具可重用性。如果我们想重复这个逻辑，我们只需创建一个新的描述符对象，它将起作用（符合DRY原则）。
- en: 'If we now want to do the same, but for the current branch, we create this new
    class attribute, and the rest of the class is kept intact, while still having
    the desired logic in place, as shown in the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在想做同样的事情，但是针对当前的分支，我们创建这个新的类属性，而类的其余部分保持不变，同时仍然具有所需的逻辑，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The balance and trade-off of this new approach should be clear by now. This
    new implementation uses a bit more code, but it's reusable, so it saves lines
    of code (and duplicated logic) in the long run. Once again, refer to the three
    or more instances rule to decide if you should create such an abstraction.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新方法的平衡和权衡现在应该是清楚的。这种新实现使用了更多的代码，但它是可重用的，因此从长远来看它节省了代码行数（和重复的逻辑）。再次参考三个或更多实例的规则，以决定是否应该创建这样的抽象。
- en: Another important benefit of this solution is that it also reduces the repetition
    of unit tests. Reusing code here will give us more confidence on the overall quality
    of the solution, because now we just have to write unit tests for the descriptor
    object, not for all the classes that use it (we can safely assume that they're
    correct as long as the unit tests prove the descriptor to be correct).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案的另一个重要好处是它还减少了单元测试的重复。在这里重用代码将使我们对解决方案的整体质量更有信心，因为现在我们只需要为描述符对象编写单元测试，而不是为使用它的所有类编写单元测试（只要单元测试证明描述符是正确的，我们就可以安全地假设它们是正确的）。
- en: The borg pattern
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: borg模式
- en: The previous solutions should work for most cases, but if we really have to
    go for a singleton (and this has to be a really good exception), then there is
    one last better alternative to it, only this is a riskier one.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的解决方案对大多数情况都适用，但如果我们真的必须使用单例（这必须是一个非常好的例外情况），那么还有一个更好的替代方案，尽管这是一个更有风险的选择。
- en: This is the actual monostate pattern, referred to as the borg pattern in Python.
    The idea is to create an object that is capable of replicating all of its attributes
    among all instances of the same class. The fact that absolutely every attribute
    is being replicated has to be a warning to keep in mind undesired side-effects.
    Still, this pattern has many advantages over the singleton.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实际的单态模式，在Python中被称为borg模式。其思想是创建一个对象，能够在同一类的所有实例之间复制其所有属性。绝对复制每个属性的事实必须警示我们要注意不良副作用。尽管如此，这种模式比单例模式有很多优点。
- en: 'In this case, we are going to split the previous object into two—one that works
    over Git tags, and the other over branches. And we are using the code that will
    make the borg pattern work:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将之前的对象分成两个部分——一个用于Git标签，另一个用于分支。我们使用的代码将使borg模式起作用：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Both objects have a base class, sharing their initialization method. But then
    they have to implement it again in order to make the borg logic work. The idea
    is that we use a class attribute that is a dictionary to store the attributes,
    and then we make the dictionary of each object (at the time it's being initialized)
    to use this very same dictionary. This means that any update on the dictionary
    of an object will be reflected in the class, which will be the same for the rest
    of the objects because their class is the same, and dictionaries are mutable objects
    that are passed as a reference. In other words, when we create new objects of
    this type, they will all use the same dictionary, and this dictionary is constantly being updated.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个对象都有一个基类，共享它们的初始化方法。但是它们必须再次实现它，以使borg逻辑起作用。其思想是使用一个类属性，它是一个字典，用于存储属性，然后使每个对象的字典（在初始化时）使用这个完全相同的字典。这意味着对一个对象的字典的任何更新都会反映在类中，因为它们的类是相同的，而字典是可变对象，是作为引用传递的。换句话说，当我们创建这种类型的新对象时，它们都将使用相同的字典，并且这个字典会不断更新。
- en: Note that we cannot put the logic of the dictionary on the base class, because
    this will mix the values among the objects of different classes, which is not
    what we want. This boilerplate solution is what would make many think it's actually
    an idiom rather than a pattern.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不能将字典的逻辑放在基类上，因为这将使不同类的对象混合值，这不是我们想要的。这种样板解决方案会让许多人认为这实际上是一种习惯用语，而不是一种模式。
- en: 'A possible way of abstracting this in a way that achieves the DRY principle
    would be to create a mixin class, as shown in the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 实现DRY原则的一种可能的抽象方式是创建一个mixin类，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This time, we are using the mixin class to create the dictionary with the attributes
    in each class in case it doesn't already exist, and then continuing with the same
    logic.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们使用mixin类在每个类中创建具有属性的字典（如果它尚不存在），然后继续相同的逻辑。
- en: This implementation should not have any major problems with inheritance, so
    it's a more viable alternative.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现在继承方面不应该有任何主要问题，因此这是一个更可行的替代方案。
- en: Builder
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建造者
- en: The builder pattern is an interesting pattern that abstracts away all the complex
    initialization of an object. This pattern does not rely on any particularity of
    the language, so it's as equally applicable in Python as it would be in any other
    language.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式是一个有趣的模式，它抽象了对象的所有复杂初始化。这种模式不依赖于语言的任何特性，因此在Python中同样适用于任何其他语言。
- en: While it solves a valid case, it's usually also a complicated case that is more
    likely to appear in the design of a framework, library, or an API. Similar to
    the recommendations given for descriptors, we should reserve this implementation
    for cases where we expect to expose an API that is going to be consumed by multiple
    users.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它解决了一个有效的情况，但通常也是一个更可能出现在框架、库或API设计中的复杂情况。与描述符的建议类似，我们应该将这种实现保留给我们期望公开的API将被多个用户使用的情况。
- en: The high level idea of this patter is that we need to create a complex object,
    that is an object that also requires many others to work with. Rather than letting
    the user create all those auxiliary objects, and then assign them to the main
    one, we would like to create an abstraction that allows all of that to be done
    in a single step. In order to achieve this, we will have a builder object that
    knows how to create all the parts and link them together, giving the user an interface
    (which could be a class method), to parametrize all the information about what
    the resulting object should look like.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的高层思想是，我们需要创建一个复杂的对象，这个对象也需要许多其他对象一起工作。我们不希望让用户创建所有这些辅助对象，然后将它们分配给主要对象，而是希望创建一个抽象，允许所有这些在一个步骤中完成。为了实现这一点，我们将有一个构建对象，它知道如何创建所有部分并将它们链接在一起，给用户一个接口（可能是一个类方法），以参数化有关所得对象应该看起来像什么的所有信息。
- en: Structural patterns
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构模式
- en: Structural patterns are useful for situations where we need to create simpler
    interfaces or objects that are more powerful by extending their functionality
    without adding complexity to their interfaces.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 结构模式对于需要创建更简单的接口或通过扩展功能而使对象更强大而不增加接口复杂性的情况非常有用。
- en: The best thing about these patterns is that we can create more interesting objects,
    with enhanced functionality, and we can achieve this in a clean way; that is,
    by composing multiple single objects (the clearest example of this being the composite
    pattern), or by gathering many simple and cohesive interfaces.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式最好的地方在于我们可以创建更有趣的对象，具有增强的功能，并且可以以一种干净的方式实现这一点；也就是说，通过组合多个单一对象（这个最清晰的例子就是组合模式），或者通过收集许多简单而紧密的接口。
- en: Adapter
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器
- en: The adapter pattern is probably one of the simplest design patterns there are,
    and one of the most useful ones at the same time. Also known as a wrapper, this
    pattern solves the problem of adapting interfaces of two or more objects that
    are not compatible.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式可能是最简单的设计模式之一，同时也是最有用的设计模式之一。也被称为包装器，这种模式解决了两个或多个不兼容对象的接口适配问题。
- en: We typically encounter the situation where part of our code works with a model
    or set of classes that were polymorphic with respect to a method. For example,
    if there were multiple objects for retrieving data with a `fetch()` method, then
    we want to maintain this interface so we don't have to make major changes to our
    code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们的代码的一部分与一个模型或一组类一起工作，这些类在某个方法方面是多态的。例如，如果有多个对象用于检索具有`fetch（）`方法的数据，那么我们希望保持这个接口，这样我们就不必对我们的代码进行重大更改。
- en: But then we come to a point where the need to add a new data source, and alas,
    this one won't have a `fetch()` method. To make things worse, not only is this
    type of object not compatible, but it is also not something we control (perhaps
    a different team decided on the API, and we cannot modify the code).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当我们需要添加一个新的数据源时，这个数据源却没有`fetch（）`方法。更糟糕的是，这种类型的对象不仅不兼容，而且也不是我们控制的（也许是另一个团队决定了API，我们无法修改代码）。
- en: Instead of using this object directly, we adopt its interface to the one we
    need. There are two ways of doing this.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不直接使用这个对象，而是将其接口采用到我们需要的接口上。有两种方法可以做到这一点。
- en: The first way would be to create a class that inherits from the one we want
    to use, and that creates an alias for the method (if required, it will also have
    to adapt the parameters and the signature).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是创建一个从我们想要使用的类继承的类，并为该方法创建一个别名（如果需要，还必须调整参数和签名）。
- en: 'By means of inheritance, we import the external class and create a new one
    that will define the new method, calling the one that has a different name. In
    this example, let''s say the external dependency has a method named `search()`,
    which takes only one parameter for the search because it queries in a different
    fashion, so our `adapter` method not only calls the external one, but it also
    translates the parameters accordingly, as shown in the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过继承，我们导入外部类并创建一个新类，该类将定义新方法，调用具有不同名称的方法。在这个例子中，假设外部依赖项有一个名为`search（）`的方法，它只接受一个参数进行搜索，因为它以不同的方式查询，所以我们的`adapter`方法不仅调用外部方法，而且还相应地转换参数，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It might be the case that our class already derives from another one, in which
    case, this will end up as a case of multiple inheritances, which Python supports,
    so it shouldn't be a problem. However, as we have seen many times before, inheritance
    comes with more coupling (who knows how many other methods are being carried from
    the external library?), and it's inflexible. Conceptually, it also wouldn't be
    the right choice because we reserve inheritance for situations of specification
    (an **is a** kind of relationship), and in this case, it's not clear at all that
    our object has to be one of the kinds that are provided by a third-party library
    (especially since we don't fully comprehend that object).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们的类已经从另一个类派生出来了，在这种情况下，这将成为多重继承的情况，Python支持这一点，所以这不应该是一个问题。然而，正如我们以前多次看到的那样，继承会带来更多的耦合（谁知道有多少其他方法是从外部库中继承而来的？），而且它是不灵活的。从概念上讲，这也不是正确的选择，因为我们将继承保留给规范的情况（一种**是一个**的关系），在这种情况下，我们完全不清楚我们的对象是否必须是第三方库提供的那种对象之一（特别是因为我们并不完全理解那个对象）。
- en: 'Therefore, a better approach would be to use composition instead. Assuming
    that we can provide our object with an instance of `UsernameLookup`, the code
    would be as simple as just redirecting the petition prior to adopting the parameters,
    as shown in the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更好的方法是使用组合。假设我们可以为我们的对象提供一个`UsernameLookup`的实例，那么代码就会变得很简单，只需在采用参数之前重定向请求，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we need to adopt multiple methods, and we can devise a generic way of adapting
    their signature as well, it might be worth using the `__getattr__()` magic method
    to redirect requests towards the wrapped object, but as always with generic implementations,
    we should be careful of not adding more complexity to the solution.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要采用多种方法，并且我们可以想出一种通用的方法来调整它们的签名，那么使用`__getattr__()`魔术方法将请求重定向到包装对象可能是值得的，但是像所有通用实现一样，我们应该小心不要给解决方案增加更多的复杂性。
- en: Composite
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: There will be parts of our programs that require us to work with objects that
    are made out of other objects. We have base objects that have a well-defined logic,
    and then we will have other container objects that will group a bunch of base
    objects, and the challenge is that we want to treat both of them (the base and
    the container objects) without noticing any differences.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序中将有一些部分需要我们处理由其他对象组成的对象。我们有基本对象，具有明确定义的逻辑，然后我们将有其他容器对象，将一堆基本对象分组，挑战在于我们希望处理这两种对象（基本对象和容器对象）而不会注意到任何差异。
- en: The objects are structured in a tree hierarchy, where the basic objects would
    be the leaves of the tree, and the composed objects intermediate nodes. A client
    might want to call any of them to get the result of a method that is called. The
    composite object, however, will act as a client; this also will pass this request
    along with all the objects it contains whether they are leaves or other intermediate
    notes until they all are processed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对象按树形层次结构组织，基本对象将是树的叶子，组合对象是中间节点。客户可能希望调用它们中的任何一个来获得调用的方法的结果。然而，组合对象将充当客户端；它也将传递这个请求以及它包含的所有对象，无论它们是叶子还是其他中间节点，直到它们都被处理。
- en: 'Imagine a simplified version of an online store in which we have products.
    Say that we offer the possibility of grouping those products, and we give customers
    a discount per group of products. A product has a price, and this value will be
    asked for when the customers come to pay. But a set of grouped products also has
    a price that has to be computed. We will have an object that represents this group
    that contains the products, and that delegates the responsibility of asking the
    price to each particular product (which might be another group of products as
    well), and so on, until there is nothing else to compute. The implementation of
    this is shown in the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个在线商店的简化版本，在这个商店里我们有产品。假设我们提供了将这些产品分组的可能性，并且我们给顾客每组产品提供折扣。产品有一个价格，当顾客来付款时，就会要求这个价格。但是一组分组的产品也有一个必须计算的价格。我们将有一个代表这个包含产品的组的对象，并且将责任委托给每个特定产品询问价格（这个产品也可能是另一组产品），等等，直到没有其他东西需要计算。这个实现如下代码所示：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We expose the public interface through a property, and leave the `price` as
    a private attribute. The `ProductBundle` class uses this property to compute the
    value with the discount applied by first adding all the prices of all the products
    it contains.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个属性公开公共接口，并将`price`作为私有属性。`ProductBundle`类使用这个属性来计算值，并首先添加它包含的所有产品的价格。
- en: The only discrepancy between these objects is that they are created with different
    parameters. To be fully compatible, we should have tried to mimic the same interface
    and then added extra methods for adding products to the bundle but using an interface
    that allows the creation of complete objects. Not needing these extra steps is
    an advantage that justifies this small difference.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象之间唯一的差异是它们是用不同的参数创建的。为了完全兼容，我们应该尝试模仿相同的接口，然后添加额外的方法来向包中添加产品，但使用一个允许创建完整对象的接口。不需要这些额外的步骤是一个可以证明这个小差异的优势。
- en: Decorator
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: Don't confuse the decorator pattern with the concept of a Python decorator which
    we have gone through in [Chapter 5](f5d9c7e4-4092-48de-a22c-564df482b021.xhtml),
    *Using Decorators to Improve Our Code*. There is some resemblance, but the idea
    of the design pattern is quite different.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将装饰器模式与我们在[第5章](f5d9c7e4-4092-48de-a22c-564df482b021.xhtml)中介绍的Python装饰器的概念混淆，*使用装饰器改进我们的代码*。它们有一些相似之处，但设计模式的想法是完全不同的。
- en: This pattern allows us to dynamically extend the functionality of some objects,
    without needing inheritance. It's a good alternative to multiple inheritance in
    creating more flexible objects.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式允许我们动态扩展一些对象的功能，而不需要继承。这是创建更灵活对象的多重继承的一个很好的替代方案。
- en: We are going to create a structure that let's a user define a set of operations
    (decorations) to be applied over an object, and we'll see how each step takes
    place in the specified order.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个结构，让用户定义要应用于对象的一组操作（装饰），并且我们将看到每个步骤按指定顺序进行。
- en: The following code example is a simplified version of an object that constructs
    a query in the form of a dictionary from parameters that are passed to it (it
    might be an object that we would use for running queries to elasticsearch, for
    instance, but the code leaves out distracting implementation details to focus
    on the concepts of the pattern).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例是一个以参数形式从传递给它的参数构造字典形式的查询的对象的简化版本（例如，它可能是我们用于运行到elasticsearch的查询的对象，但代码省略了分散注意力的实现细节，以便专注于模式的概念）。
- en: 'In its most basic form, the query just returns the dictionary with the data
    it was provided when it was created. Clients expect to use the `render()` method
    of this object:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最基本的形式中，查询只返回创建时提供的数据的字典。客户端期望使用此对象的`render()`方法。
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now we want to render the query in different ways by applying transformations
    to the data (filtering values, normalizing them, and so on). We could create decorators
    and apply them to the `render` method, but that wouldn't be flexible enough what
    if we want to change them at runtime? Or if we want to select some of them, but
    not others?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想通过对数据应用转换来以不同的方式呈现查询（过滤值，标准化等）。我们可以创建装饰器并将它们应用于`render`方法，但这不够灵活，如果我们想在运行时更改它们怎么办？或者如果我们只想选择其中一些，而不选择其他一些呢？
- en: The design is to create another object, with the same interface and the capability
    of enhancing (decorating) the original result through many steps, but which can
    be combined. These objects are chained, and each one of them does what it was
    originally supposed to do, plus something else. This something else is the particular
    decoration step.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 设计是创建另一个对象，具有相同的接口和通过多个步骤增强（装饰）原始结果的能力，但可以组合。这些对象被链接在一起，每个对象都会做最初应该做的事情，再加上其他一些东西。这些其他东西就是特定的装饰步骤。
- en: 'Since Python has duck typing, we don''t need to create a new base class and
    make these new objects part of that hierarchy, along with `DictQuery`. Simply
    creating a new class that has a `render()` method will be enough (again, polymorphism
    should not require inheritance). This process is shown in the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python具有鸭子类型，我们不需要创建一个新的基类，并使这些新对象成为该层次结构的一部分，以及`DictQuery`。只需创建一个具有`render()`方法的新类就足够了（再次，多态性不应该需要继承）。这个过程在下面的代码中显示：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `QueryEnhancer` phrase has an interface that is compatible with what the
    clients of `DictQuery` are expecting, so they are interchangeable. This object
    is designed to receive a decorated one. It's going to take the values from this
    and convert them, returning the modified version of the code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueryEnhancer`短语具有与`DictQuery`的客户端期望的接口兼容的接口，因此它们是可互换的。这个对象被设计为接收一个装饰过的对象。它将从中获取值并将其转换，返回代码的修改版本。'
- en: 'If we want to remove all values that evaluate to `False` and normalize them
    to form our original query, we would have to use the following schema:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要删除所有评估为`False`的值并将它们标准化以形成我们的原始查询，我们将不得不使用以下模式：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a pattern that we can also implement in different ways, taking advantage
    of the dynamic nature of Python, and the fact that functions are objects. We could
    implement this pattern with functions that are provided to the base decorator
    object (`QueryEnhancer`), and define each decoration step as a function, as shown
    in the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们也可以以不同方式实现的模式，利用Python的动态特性和函数是对象的事实。我们可以使用提供给基本装饰器对象（`QueryEnhancer`）的函数来实现这种模式，并将每个装饰步骤定义为一个函数，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With respect to the client, nothing has changed because this class maintains
    the compatibility through its `render()` method. Internally, however, this object
    is used in a slightly different fashion, as shown in the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 就客户端而言，由于这个类通过其`render()`方法保持兼容性，因此没有改变。但在内部，这个对象的使用方式略有不同，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, `remove_empty` and `case_insensitive` are just regular
    functions that transform a dictionary.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`remove_empty`和`case_insensitive`只是转换字典的常规函数。
- en: In this example, the function-based approach seems easier to understand. There
    might be cases with more complex rules that rely on data from the object being
    decorated (not only its result), and in those cases, it might be worth going for
    the object-oriented approach, especially if we really want to create a hierarchy
    of objects where each class actually represents some knowledge we want to make
    explicit in our design.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，基于函数的方法似乎更容易理解。可能存在更复杂的规则，这些规则依赖于被装饰对象的数据（不仅仅是其结果），在这种情况下，可能值得采用面向对象的方法，特别是如果我们真的想要创建一个对象层次结构，其中每个类实际上代表了我们想要在设计中明确表示的某些知识。
- en: Facade
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观
- en: Facade is an excellent pattern. It's useful in many situations where we want
    to simplify the interaction between objects. The pattern is applied where there
    is a relation of many-to-many among several objects, and we want them to interact.
    Instead of creating all of these connections, we place an intermediate object
    in front of many of them that act as a facade.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Facade是一个很好的模式。它在许多情况下都很有用，当我们想要简化对象之间的交互时。该模式适用于多个对象之间存在多对多关系，并且我们希望它们进行交互。我们不是创建所有这些连接，而是在它们前面放置一个作为外观的中间对象。
- en: The facade works as a hub or a single point of reference in this layout. Every
    time a new object wants to connect to another one, instead of having to have *N*
    interfaces for all *N* possible objects it needs to connect to, it will instead
    just talk to the facade, and this will redirect the request accordingly. Everything
    that's behind the facade is completely opaque to the rest of the external objects.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 门面在这个布局中充当一个中心或单一的参考点。每当一个新对象想要连接到另一个对象时，它不需要为所有可能连接到的*N*个对象拥有*N*个接口，而是只需与门面交谈，门面会相应地重定向请求。门面后面的一切对外部对象完全不透明。
- en: Apart from the main and obvious benefit (the decoupling of objects), this pattern
    also encourages a simpler design with fewer interfaces and better encapsulation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了主要和明显的好处（对象的解耦），这种模式还鼓励更简单的设计，更少的接口和更好的封装。
- en: This is a pattern that we can use not only for improving the code of our domain
    problem but also to create better APIs. If we use this pattern and provide a single
    interface, acting as a single point of truth or entry point for our code, it will
    be much easier for our users to interact with the functionality exposed. Not only
    that, but by exposing a functionality and hiding everything behind an interface,
    we are free of changing or refactoring that underlying code as many times as we
    want, because as long as it is behind the facade, it will not break backward compatibility,
    and our users will not be affected.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们不仅可以用来改进我们领域问题的代码，还可以用来创建更好的API的模式。如果我们使用这种模式并提供一个单一的接口，作为我们代码的单一真相点或入口点，那么我们的用户与暴露的功能交互将会更容易。不仅如此，通过暴露一个功能并隐藏一切在接口后面，我们可以自由地改变或重构底层代码，因为只要它在门面后面，它就不会破坏向后兼容性，我们的用户也不会受到影响。
- en: Note how this idea of using facades is not even limited to objects and classes,
    but also applies to packages (technically, packages are objects in Python, but
    still). We can use this idea of the facade to decide the layout of a package;
    that is, what is visible to the user and importable, and what is internal and
    should not be imported directly.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用门面的这个想法不仅仅局限于对象和类，还适用于包（在技术上，包在Python中也是对象，但仍然）。我们可以使用门面的这个想法来决定包的布局；即，对用户可见和可导入的内容，以及内部的内容，不应该直接导入。
- en: When we create a directory to build a package, we place the `__init__.py` file
    along with the rest of the files. This is the root of the module, a sort of facade.
    The rest of the files define the objects to export, but they shouldn't be directly
    imported by clients. The `init` file should import them and then clients should
    get them from there. This creates a better interface because users only need to
    know a single entry point from which to get the objects, and more importantly,
    the package (the rest of the files) can be refactored or rearranged as many times
    as needed, and this will not affect clients as long as the main API on the `init`
    file is maintained. It is of utmost importance to keep principles like this one
    in mind in order to build maintainable software.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个目录来构建一个包时，我们将`__init__.py`文件与其余文件放在一起。这是模块的根，一种门面。其余的文件定义要导出的对象，但它们不应该被客户端直接导入。`init`文件应该导入它们，然后客户端应该从那里获取它们。这样创建了一个更好的接口，因为用户只需要知道一个单一的入口点来获取对象，更重要的是，包（其余的文件）可以根据需要进行重构或重新排列，只要`init`文件上的主要API得到维护，这不会影响客户端。牢记这样的原则是非常重要的，以构建可维护的软件。
- en: There is an example of this in Python itself, with the `os` module. This module
    groups an operating system's functionality, but underneath it, uses the `posix` module
    for **Portable Operating System Interface** (**POSIX**) operating systems (this
    is called `nt` in Windows platforms). The idea is that, for portability reasons,
    we shouldn't ever really import the `posix` module directly, but always the `os` module.
    It is up to this module to determine from which platform it is being called, and
    expose the corresponding functionality.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Python本身就有一个例子，使用`os`模块。这个模块将操作系统的功能分组在一起，但在底层，它使用`posix`模块来处理**可移植操作系统接口**（**POSIX**）操作系统（在Windows平台上称为`nt`）。这个想法是，出于可移植性的原因，我们不应该直接导入`posix`模块，而应该始终导入`os`模块。这个模块要确定它被调用的平台，并公开相应的功能。
- en: Behavioral patterns
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为模式
- en: Behavioral patterns aim to solve the problem of how objects should cooperate,
    how they should communicate, and what their interfaces should be at run-time.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 行为模式旨在解决对象应该如何合作，它们应该如何通信，以及运行时它们的接口应该是什么的问题。
- en: 'We discuss mainly the following behavioral patterns:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要讨论以下行为模式：
- en: Chain of responsibility
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链
- en: Template method
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法
- en: Command
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: State
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态
- en: This can be accomplished statically by means of inheritance or dynamically by
    using composition. Regardless of what the pattern uses, what we will see throughout
    the following examples is that what these patterns have in common is the fact
    that the resulting code is better in some significant way, whether this is because
    it avoids duplication or creates good abstractions that encapsulate behavior accordingly
    and decouple our models.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过继承静态地实现，也可以通过组合动态地实现。无论模式使用什么，我们将在接下来的例子中看到，这些模式的共同之处在于，最终的代码在某种重要的方式上更好，无论是因为它避免了重复，还是因为它创建了良好的抽象，封装了相应的行为，并解耦了我们的模型。
- en: Chain of responsibility
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 责任链
- en: Now we are going to take another look at our event systems. We want to parse
    information about the events that happened on the system from the log lines (text
    files, dumped from our HTTP application server, for example), and we want to extract
    this information in a convenient way.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要再次审视我们的事件系统。我们想要从日志行（例如从我们的HTTP应用服务器转储的文本文件）中解析系统上发生的事件的信息，并以一种方便的方式提取这些信息。
- en: In our previous implementation, we achieved an interesting solution that was
    compliant with the open/closed principle and relied on the use of the `__subclasses__()`
    magic method to discover all possible event types and process the data with the
    right event, resolving the responsibility through a method encapsulated on each
    class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们先前的实现中，我们实现了一个有趣的解决方案，符合开闭原则，并依赖于使用`__subclasses__()`魔术方法来发现所有可能的事件类型，并使用正确的事件处理数据，通过每个类上封装的方法解决责任。
- en: This solution worked for our purposes, and it was quite extensible, but as we'll
    see, this design pattern will bring additional benefits.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案对我们的目的是有效的，并且它是相当可扩展的，但正如我们将看到的，这种设计模式将带来额外的好处。
- en: 'The idea here is that we are going to create the events in a slightly different
    way. Each event still has the logic to determine whether or not it can process
    a particular log line, but it will also have a successor. This successor is a
    new event, the next one in the line, that will continue processing the text line
    in case the first one was not able to do so. The logic is simple—we chain the
    events, and each one of them tries to process the data. If it can, then it just
    returns the result. If it can''t, it will pass it to its successor and repeat,
    as shown in the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是，我们将以稍微不同的方式创建事件。每个事件仍然具有确定是否可以处理特定日志行的逻辑，但它还将具有一个后继者。这个后继者是一个新的事件，是行中的下一个事件，它将继续处理文本行，以防第一个事件无法这样做。逻辑很简单——我们链接这些事件，每个事件都尝试处理数据。如果可以，它就返回结果。如果不能，它将把它传递给它的后继者并重复，如下所示的代码：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this implementation, we create the `event` objects, and arrange them in
    the particular order in which they are going to be processed. Since they all have
    a `process()` method, they are polymorphic for this message, so the order in which
    they are aligned is completely transparent to the client, and either one of them
    would be transparent too. Not only that, but the `process()` method has the same
    logic; it tries to extract the information if the data provided is correct for
    the type of object handling it, and if not, it moves on to the next one in the
    line.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种实现，我们创建了`event`对象，并按照它们将被处理的特定顺序排列它们。由于它们都有一个`process()`方法，它们对于这个消息是多态的，所以它们被排列的顺序对于客户端来说是完全透明的，它们中的任何一个也是透明的。不仅如此，`process()`方法也具有相同的逻辑；它尝试提取信息，如果提供的数据对于处理它的对象类型是正确的，如果不是，它就继续到下一个对象。
- en: 'This way, we could `process` a login event in the following way:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以按以下方式`process`登录事件：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note how `LogoutEvent` received `LoginEvent` as its successor, and when it was
    asked to process something that it couldn't handle, it redirected to the correct
    object. As we can see from the `type` key on the dictionary, `LoginEvent` was
    the one that actually created that dictionary.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`LogoutEvent`作为其后继者接收了`LoginEvent`，当它被要求处理无法处理的内容时，它会重定向到正确的对象。从字典的`type`键上可以看出，`LoginEvent`实际上是创建了该字典的对象。
- en: This solution is flexible enough, and shares an interesting trait with our previous
    one—all conditions are mutually exclusive. As long as there are no collisions,
    and no piece of data has more than one handler, processing the events in any order
    will not be an issue.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案足够灵活，并且与我们先前的解决方案共享一个有趣的特性——所有条件都是互斥的。只要没有冲突，没有数据有多个处理程序，以任何顺序处理事件都不会成为问题。
- en: But what if we cannot make such an assumption? With the previous implementation,
    we could still change the `__subclasses__()` call for a list that we made according
    to our criteria, and that would have worked just fine. And what if we wanted that
    order of precedence to be determined at runtime (by the user or client, for example)?
    That would be a shortcoming.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们不能做出这样的假设呢？通过先前的实现，我们仍然可以将`__subclasses__()`调用更改为根据我们的标准制作的列表，这样也可以正常工作。如果我们希望优先顺序在运行时（例如由用户或客户端）确定呢？那将是一个缺点。
- en: With the new solution, it's possible to accomplish such requirements, because
    we assemble the chain at runtime, so we can manipulate it dynamically as we need
    to.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有了新的解决方案，我们可以实现这样的要求，因为我们在运行时组装链条，所以我们可以根据需要动态地操纵它。
- en: 'For example, now we add a generic type that groups both the login and logout
    a session event, as shown in the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，现在我们添加了一个通用类型，将登录和注销会话事件分组，如下所示的代码：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If for some reason, and in some part of the application, we want to capture
    this before the login event, this can be done by the following `chain`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，在应用程序的某个部分，我们希望在登录事件之前捕获这个，可以通过以下`chain`来实现：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By changing the order, we can, for instance, say that a generic session event
    has a higher priority than the login, but not the logout, and so on.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改变顺序，我们可以，例如，说一个通用会话事件比登录事件具有更高的优先级，但不是注销事件，依此类推。
- en: The fact that this pattern works with objects makes it more flexible with respect
    to our previous implementation, which relied on classes (and while they are still objects
    in Python, they aren't excluded from some degree of rigidity).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式与对象一起工作的事实使它相对于我们先前的依赖于类的实现更加灵活（虽然它们在Python中仍然是对象，但它们并不排除一定程度的刚性）。
- en: The template method
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板方法
- en: The `template` method is a pattern that yields important benefits when implemented
    properly. Mainly, it allows us to reuse code, and it also makes our objects more
    flexible and easy to change while preserving polymorphism.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`template`方法是一种在正确实现时产生重要好处的模式。主要是，它允许我们重用代码，而且还使我们的对象更灵活，更容易改变，同时保持多态性。'
- en: The idea is that there is a class hierarchy that defines some behavior, let's
    say an important method of its public interface. All of the classes of the hierarchy
    share a common template and might need to change only certain elements of it.
    The idea, then, is to place this generic logic in the public method of the parent
    class that will internally call all other (private) methods, and these methods
    are the ones that the derived classes are going to modify; therefore, all the
    logic in the template is reused.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是，有一个类层次结构，定义了一些行为，比如说它的公共接口中的一个重要方法。层次结构中的所有类共享一个公共模板，并且可能只需要更改其中的某些元素。因此，这个想法是将这个通用逻辑放在父类的公共方法中，该方法将在内部调用所有其他（私有）方法，而这些方法是派生类将要修改的方法；因此，模板中的所有逻辑都被重用。
- en: Avid readers might have noticed that we already implemented this pattern in
    the previous section (as part of the chain of responsibility example). Note that
    the classes derived from `Event` implement only one thing their particular pattern.
    For the rest of the logic, the template is in the `Event` class. The `process`
    event is generic, and relies on two auxiliary methods `can_process()` and `process()`
    (which in turn calls `_parse_data()`).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 热心的读者可能已经注意到，我们在上一节中已经实现了这种模式（作为责任链示例的一部分）。请注意，从`Event`派生的类只实现了它们特定的模式。对于其余的逻辑，模板在`Event`类中。`process`事件是通用的，并依赖于两个辅助方法`can_process()`和`process()`（后者又调用`_parse_data()`）。
- en: These extra methods rely on a class attribute pattern. Therefore, in order to
    extend this with a new type of object, we just have to create a new derived class
    and place the regular expression. After that, the rest of the logic will be inherited
    with this new attribute changed. This reuses a lot of code because the logic for
    processing the log lines is defined once and only once in the parent class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外的方法依赖于类属性模式。因此，为了用新类型的对象扩展这个模式，我们只需要创建一个新的派生类并放置正则表达式。之后，其余的逻辑将继承这个新属性的变化。这样做可以重用大量的代码，因为处理日志行的逻辑只在父类中定义一次。
- en: This makes the design flexible because preserving the polymorphism is also easily
    achievable. If we need a new event type that for some reason needs a different
    way of parsing data, we only override this private method in that subclass, and
    the compatibility will be kept, as long as it returns something of the same type
    as the original one (complying with Liskov's substitution and open/closed principles).
    This is because it is the parent class that is calling the method from the derived
    classes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得设计变得灵活，因为保持多态性也很容易实现。如果我们需要一个新的事件类型，由于某种原因需要以不同的方式解析数据，我们只需要在子类中覆盖这个私有方法，兼容性将得到保持，只要它返回与原始类型相同的类型（符合Liskov的替换和开闭原则）。这是因为是父类调用派生类的方法。
- en: This pattern is also useful if we are designing our own library or framework.
    By arranging the logic this way, we give users the ability to change the behavior
    of one of the classes quite easily. They would have to create a subclass and override
    the particular private method, and the result will be a new object with the new
    behavior that is guaranteed to be compatible with previous callers of the original
    object.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在设计自己的库或框架，这种模式也很有用。通过这种方式安排逻辑，我们使用户能够相当容易地改变其中一个类的行为。他们只需要创建一个子类并覆盖特定的私有方法，结果将是一个具有新行为的新对象，保证与原始对象的调用者兼容。
- en: Command
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令
- en: The command pattern provides us with the ability to separate an action that
    needs to be done from the moment that it is requested to its actual execution.
    More than that, it can also separate the original request issued by a client from
    its recipient, which might be a different object. In this section, we are going
    to focus mainly on the first aspect of the patterns; the fact that we can separate
    how an order has to be run from when it actually executes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式为我们提供了将需要执行的操作与请求执行的时刻分开的能力。更重要的是，它还可以将客户端发出的原始请求与接收者分开，接收者可能是一个不同的对象。在本节中，我们将主要关注模式的第一个方面；我们可以将命令如何运行与它实际执行的时刻分开。
- en: We know we can create callable objects by implementing the `__call__()` magic
    method, so we could just initialize the object and then call it later on. In fact,
    if this is the only requirement, we might even achieve this through a nested function
    that, by means of a closure, creates another function to achieve the effect of
    a delayed execution. But this pattern can be extended to ends that aren't so easily
    achievable.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们可以通过实现`__call__()`魔术方法来创建可调用对象，因此我们可以初始化对象，然后以后再调用它。事实上，如果这是唯一的要求，我们甚至可以通过一个嵌套函数来实现这一点，通过闭包创建另一个函数来实现延迟执行的效果。但是这种模式可以扩展到不那么容易实现的地方。
- en: The idea is that the command might also be modified after its definition. This
    means that the client specifies a command to run, and then some of its parameters
    might be changed, more options added, and so on, until someone finally decides
    to perform the action.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是命令在定义后也可以被修改。这意味着客户端指定要运行的命令，然后可能更改一些参数，添加更多选项等，直到最终有人决定执行这个动作。
- en: Examples of this can be found in libraries that interact with databases. For
    instance, in `psycopg2` (a PostgreSQL client library), we establish a connection.
    From this, we get a cursor, and to that cursor we can pass an SQL statement to
    run. When we call the `execute` method, the internal representation of the object
    changes, but nothing is actually run in the database. It is when we call `fetchall()`
    (or a similar method) that the data is actually queried and is available in the
    cursor.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的例子可以在与数据库交互的库中找到。例如，在`psycopg2`（一个PostgreSQL客户端库）中，我们建立一个连接。从这个连接中，我们得到一个游标，然后我们可以向这个游标传递要运行的SQL语句。当我们调用`execute`方法时，对象的内部表示会发生变化，但实际上并没有在数据库中运行任何东西。只有当我们调用`fetchall()`（或类似的方法）时，数据才会被查询并在游标中可用。
- en: The same happens in the popular **Object Relational Mapper SQLAlchemy** (**ORM SQLAlchemy**).
    A query is defined through several steps, and once we have the `query` object,
    we can still interact with it (add or remove filters, change the conditions, apply
    for an order, and so on), until we decide we want the results of the query. After
    calling each method, the `query` object changes its internal properties and returns `self`
    (itself).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在流行的**对象关系映射SQLAlchemy**（**ORM SQLAlchemy**）中也是如此。查询是通过几个步骤定义的，一旦我们有了`query`对象，我们仍然可以与之交互（添加或删除过滤器，更改条件，申请排序等），直到我们决定要查询的结果。在调用每个方法之后，`query`对象会改变其内部属性并返回`self`（它自己）。
- en: These are examples that resemble the behavior that we would like to achieve.
    A very simple way of creating this structure would be to have an object that stores
    the parameters of the commands that are to be run. After that, it has to also
    provide methods for interacting with those parameters (adding or removing filters,
    and so on). Optionally, we can add tracing or logging capabilities to that object
    to audit the operations that have been taking place. Finally, we need to provide
    a method that will actually perform the action. This one can be just `__call__()` or
    a custom one. Let's call it `do()`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是类似我们想要实现的行为的示例。创建这种结构的一个非常简单的方法是拥有一个对象，该对象存储要运行的命令的参数。之后，它还必须提供与这些参数交互的方法（添加或删除过滤器等）。可选地，我们可以向该对象添加跟踪或日志记录功能，以审计已经发生的操作。最后，我们需要提供一个实际执行操作的方法。这个方法可以是`__call__()`或自定义的方法。让我们称之为`do()`。
- en: State
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态
- en: The state pattern is a clear example of reification in software design, making
    the concept of our domain problem an explicit object rather than just a side value.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式是软件设计中具体化的一个明显例子，使我们的领域问题的概念成为一个显式对象，而不仅仅是一个边值。
- en: In [Chapter 8](9f77174d-125b-4fdc-8cfb-563d15edcb64.xhtml), *Unit Testing and
    Refactoring*, we had an object that represented a merge request, and it had a
    state associated with it (open, closed, and so on). We used an enum to represent
    those states because, at that point, they were just data holding a value the string
    representation of that particular state. If they had to have some behavior, or
    the entire merge request had to perform some actions depending on its state and
    transitions, this would not have been enough.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](9f77174d-125b-4fdc-8cfb-563d15edcb64.xhtml)中，*单元测试和重构*，我们有一个代表合并请求的对象，并且它有一个与之关联的状态（打开、关闭等）。我们使用枚举来表示这些状态，因为在那时，它们只是保存特定状态的字符串表示的数据。如果它们需要有一些行为，或者整个合并请求需要根据其状态和转换执行一些操作，这是不够的。
- en: The fact that we are adding behavior, a runtime structure, to a part of the
    code has to make us think in terms of objects, because that's what objects are
    supposed to do, after all. And here comes the reification—now the state cannot
    just simply be an enumeration with a string; it needs to be an object.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在向代码的一部分添加行为，一个运行时结构，这让我们必须以对象的方式思考，因为毕竟这就是对象应该做的。这就是具体化的意义——现在状态不能只是一个带有字符串的枚举；它需要是一个对象。
- en: Imagine that we have to add some rules to the merge request say, that when it
    moves from open to closed, all approvals are removed (they will have to review
    the code again)—and that when a merge request is just opened, the number of approvals
    is set to zero (regardless of whether it's a reopened or a brand new merge request).
    Another rule could be that when a merge request is merged, we want to delete the
    source branch, and of course, we want to forbid users from performing invalid
    transitions (for example, a closed merge request cannot be merged, and so on).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们必须向合并请求添加一些规则，比如说，当它从打开状态变为关闭状态时，所有的批准都被移除（他们将不得不重新审查代码）——当合并请求刚刚打开时，批准的数量被设置为零（无论是重新打开的还是全新的合并请求）。另一个规则可能是，当合并请求被合并时，我们希望删除源分支，当然，我们还希望禁止用户执行无效的转换（例如，关闭的合并请求不能被合并等）。
- en: If we were to put all that logic into a single place, namely in the `MergeRequest`
    class, we will end up with a class that has lots of responsibilities (a poor design),
    probably many methods, and a very large number of `if` statements. It would be
    hard to follow the code and to understand which part is supposed to represent
    which business rule.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们把所有这些逻辑都放在一个地方，即`MergeRequest`类中，我们最终会得到一个责任很多（设计不佳）、可能有很多方法和非常多的`if`语句的类。很难跟踪代码并理解哪一部分应该代表哪个业务规则。
- en: It's better to distribute this into smaller objects, each one with fewer responsibilities,
    and the state objects are a good place for this. We create an object for each
    kind of state we want to represent, and, in their methods, we place the logic
    for the transitions with the aforementioned rules. The `MergeRequest` object will
    then have a state collaborator, and this, in turn, will also know about `MergeRequest` (the
    double-dispatching mechanism is needed to run the appropriate actions on `MergeRequest`
    and handle the transitions).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将这些分布到更小的对象中，每个对象负责更少的责任，状态对象是一个很好的地方。我们为要表示的每种状态创建一个对象，并在它们的方法中放置与上述规则的转换逻辑。然后，`MergeRequest`对象将有一个状态协作者，而这个协作者也将了解`MergeRequest`（需要双重分派机制来在`MergeRequest`上运行适当的操作并处理转换）。
- en: 'We define a base abstract class with the set of methods to be implemented,
    and then a subclass for each particular `state` we want to represent. Then the `MergeRequest`
    object delegates all the actions to `state`, as shown in the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个基本的抽象类，其中包含要实现的方法集，然后为我们要表示的每种特定`state`创建一个子类。然后，`MergeRequest`对象将所有操作委托给`state`，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following list outlines some clarifications about implementation details
    and the design decisions that should be made:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表概述了一些关于实现细节和设计决策的澄清：
- en: The state is a property, so not only is it public, but there is a single place
    with the definitions of how states are created for a merge request, passing `self` as
    a parameter.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态是一个属性，因此不仅是公共的，而且有一个单一的地方定义了如何为合并请求创建状态，将`self`作为参数传递。
- en: 'The abstract base class is not strictly needed, but there are benefits to having
    it. First, it makes the kind of object we are dealing with more explicit. Second,
    it forces every substate to implement all the methods of the interface. There
    are two alternatives to this:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象基类并不是严格需要的，但拥有它也有好处。首先，它使我们正在处理的对象类型更加明确。其次，它强制每个子状态实现接口的所有方法。对此有两种替代方案：
- en: We could have not put the methods, and let `AttributeError` raise when trying
    to perform an invalid action, but this is not correct, and it doesn't express
    what happened.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们本可以不放置方法，让`AttributeError`在尝试执行无效操作时引发，但这是不正确的，也不能表达发生了什么。
- en: Related to this point is the fact that we could have just used a simple base
    class and left those methods empty, but then the default behavior of not doing
    anything doesn't make it any clearer what should happen. If one of the methods
    in the subclass should do nothing (as in the case of merge), then it's better
    to let the empty method just sit there and make it explicit that for that particular
    case, nothing should be done, as opposed to force that logic to all objects.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与这一点相关的是，我们本可以只使用一个简单的基类并留下那些方法为空，但是这样做的默认行为并不清楚应该发生什么。如果子类中的某个方法应该什么都不做（如合并的情况），那么最好让空方法保持原样，并明确表示对于特定情况，不应该做任何事情，而不是强制所有对象都遵循这个逻辑。
- en: '`MergeRequest` and `MergeRequestState` have links to each other. The moment
    a transition is made, the former object will not have extra references and should
    be garbage-collected, so this relationship should be always 1:1\. With some small
    and more detailed considerations, a weak reference might be used.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MergeRequest`和`MergeRequestState`彼此之间有链接。一旦进行转换，前一个对象将不再有额外的引用，应该被垃圾回收，因此这种关系应该始终是1:1。在一些小而更详细的考虑中，可以使用弱引用。'
- en: 'The following code shows some examples of how the object is used:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何使用对象的一些示例：
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The actions for transitioning states are delegated to the `state` object, which `MergeRequest`
    holds at all times (this can be any of the subclasses of `ABC`). They all know
    how to respond to the same messages (in different ways), so these objects will
    take the appropriate actions corresponding to each transition (deleting branches,
    raising exceptions, and so on), and will then move `MergeRequest` to the next
    state.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 状态转换的操作被委托给`MergeRequest`始终持有的`state`对象（这可以是`ABC`的任何子类）。它们都知道如何以不同的方式响应相同的消息，因此这些对象将根据每个转换采取相应的操作（删除分支、引发异常等），然后将`MergeRequest`移动到下一个状态。
- en: Since `MergeRequest` delegates all actions to its `state` object, we will find
    that this typically happens every time the actions that it needs to do are in
    the form `self.state.open()`, and so on. Can we remove some of that boilerplate?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`MergeRequest`将所有操作委托给其`state`对象，我们会发现每次需要执行的操作都是`self.state.open()`这种形式。我们能否删除一些样板代码？
- en: 'We could, by means of `__getattr__()`, as it is portrayed in the following
    code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`__getattr__()`来实现，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: On the one hand, it is good that we reuse some code and remove repetitive lines.
    This gives the abstract base class even more sense. Somewhere, we want to have
    all possible actions documented, listed in a single place. That place used to
    be the `MergeRequest` class, but now those methods are gone, so the only remaining
    source of that truth is in `MergeRequestState`. Luckily, the type annotation on
    the `state` attribute is really helpful for users to know where to look for the
    interface definition.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，我们重用一些代码并删除重复的行是好事。这使得抽象基类更有意义。在某个地方，我们希望将所有可能的操作记录下来，列在一个地方。那个地方过去是`MergeRequest`类，但现在这些方法都消失了，所以唯一剩下的真相来源是`MergeRequestState`。幸运的是，`state`属性上的类型注解对用户来说非常有帮助，可以知道在哪里查找接口定义。
- en: A user can simply take a look and see that everything that `MergeRequest` doesn't
    have will be asked of its `state` attribute. From the `init` definition, the annotation
    will tell us that this is an object of the `MergeRequestState` type, and by looking
    at this interface, we will see that we can safely ask for the `open()`, `close()`,
    and `merge()` methods on it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以简单地查看并了解`MergeRequest`没有的所有内容都将要求其`state`属性具有。从`init`定义中，注解会告诉我们这是`MergeRequestState`类型的对象，并通过查看此接口，我们将看到我们可以安全地要求其`open()`、`close()`和`merge()`方法。
- en: The null object pattern
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空对象模式
- en: The null object pattern is an idea that relates to the good practices that were
    mentioned in previous chapters of this book. Here, we are formalizing them, and
    giving more context and analysis to this idea.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 空对象模式是与本书前几章提到的良好实践相关的一个想法。在这里，我们正在正式化它们，并为这个想法提供更多的背景和分析。
- en: The principle is rather simple—functions or methods must return objects of a
    consistent type. If this is guaranteed, then clients of our code can use the objects
    that are returned with polymorphism, without having to run extra checks on them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 原则相当简单——函数或方法必须返回一致类型的对象。如果这得到保证，那么我们代码的客户端可以使用返回的对象进行多态，而无需对它们进行额外的检查。
- en: In the previous examples, we explored how the dynamic nature of Python made
    things easier for most design patterns. In some cases, they disappear entirely,
    and in others, they are much easier to implement. The main goal of design patterns
    as they were originally thought of is that methods or functions should not explicitly
    name the class of the object that they need in order to work. For this reason,
    they propose the creation of interfaces and a way of rearranging the objects to
    make them fit these interfaces in order to modify the design. But most of the
    time, this is not needed in Python, and we can just pass different objects, and
    as long as they respect the methods they must have, then the solution will work.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们探讨了Python的动态特性如何使大多数设计模式变得更容易。在某些情况下，它们完全消失，在其他情况下，它们更容易实现。设计模式最初的目标是，方法或函数不应该明确命名它们需要的对象的类。因此，它们提出了创建接口和重新排列对象的方法，使它们适应这些接口以修改设计。但在Python中大多数情况下，这是不需要的，我们可以只传递不同的对象，只要它们遵守必须具有的方法，解决方案就会起作用。
- en: On the other hand, the fact that objects don't necessarily have to comply with
    an interface requires us to be more careful as to the things that are returning
    from such methods and functions. In the same way that our functions didn't make
    any assumptions about what they were receiving, it's fair to assume that clients
    of our code will not make any assumptions either (it is our responsibility to
    provide objects that are compatible). This can be enforced or validated with design
    by contract. Here, we will explore a simple pattern that will help us avoid these
    kinds of problems.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对象不一定要遵守接口的事实要求我们更加小心，以确保从这些方法和函数返回的东西。就像我们的函数没有对它们接收到的东西做出任何假设一样，可以合理地假设我们代码的客户也不会做出任何假设（我们有责任提供兼容的对象）。这可以通过契约式设计来强制执行或验证。在这里，我们将探讨一种简单的模式，可以帮助我们避免这些问题。
- en: Consider the chain or responsibility design pattern explored in the previous
    section. We saw how flexible it is and its many advantages, such as decoupling
    responsibilities into smaller objects. One of the problems it has is that we never
    actually know what object will end up processing the message, if any. In particular,
    in our example, if there was no suitable object to process the log line, then
    the method would simply return `None`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在前一节中探讨的责任链设计模式。我们看到了它有多么灵活以及它的许多优点，比如将责任解耦为更小的对象。它存在的问题之一是，我们实际上永远不知道哪个对象最终会处理消息，如果有的话。特别是在我们的例子中，如果没有合适的对象来处理日志行，那么该方法将简单地返回`None`。
- en: 'We don''t know how users will use the data we passed, but we do know that they
    are expecting a dictionary. Therefore, the following error might occur:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道用户将如何使用我们传递的数据，但我们知道他们期望得到一个字典。因此，可能会发生以下错误：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this case, the fix is rather simple—the default value of the `process()`
    method should be an empty dictionary rather than `None`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，修复方法相当简单——`process()`方法的默认值应该是一个空字典，而不是`None`。
- en: Ensure that you return objects of a consistent type.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 确保返回一致类型的对象。
- en: But what if the method didn't return a dictionary, but a custom object of our
    domain?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果该方法没有返回字典，而是我们领域的自定义对象呢？
- en: 'To solve this problem, we should have a class that represents the empty state
    for that object and return it. If we have a class that represents users in our
    system, and a function that queries users by their ID, then in the case that a
    user is not found, it should do one of the following two things:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们应该有一个代表该对象的空状态的类并返回它。如果我们有一个代表系统中用户的类，并且有一个按ID查询用户的函数，那么在找不到用户的情况下，它应该执行以下两种操作之一：
- en: Raise an exception
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引发异常
- en: Return an object of the `UserUnknown` type
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个`UserUnknown`类型的对象
- en: But in no case should it return `None`. The phrase `None` doesn't represent
    what just happened, and the caller might legitimately try to ask methods to it,
    and it will fail with `AttributeError`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但在任何情况下，它都不应该返回`None`。短语`None`并不代表刚刚发生的事情，调用者可能会合理地尝试向其请求方法，但会因为`AttributeError`而失败。
- en: We have discussed exceptions and their pros and cons earlier on, so we should
    mention that this `null` object should just have the same methods as the original
    user and do nothing for each one of them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过异常及其利弊，所以我们应该提到这个`null`对象应该只有与原始用户相同的方法，并对每个方法都不做任何操作。
- en: The advantage of using this structure is that not only are we avoiding an error
    at runtime but also that this object might be useful. It could make the code easier
    to test, and it can even, for instance, help in debugging (maybe we could put
    logging into the methods to understand why that state was reached, what data was
    provided to it, and so on).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种结构的优势不仅在于我们在运行时避免了错误，而且这个对象可能是有用的。它可以使代码更容易测试，甚至可以帮助调试（也许我们可以在方法中放置日志以了解为什么达到了这种状态，提供了什么数据等）。
- en: 'By exploiting almost all of the magic methods of Python, it would be possible
    to create a generic `null` object that does absolutely nothing, no matter how
    it is called, but which can be called from almost any client. Such an object would
    slightly resemble a `Mock` object. It is not advisable to go down that path because
    of the following reasons:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用Python的几乎所有魔术方法，可以创建一个绝对什么都不做的通用`null`对象，无论如何调用它，但几乎可以从任何客户端调用。这样的对象略微类似于`Mock`对象。不建议走这条路，因为有以下原因：
- en: It loses meaning with the domain problem. Back in our example, having an object
    of the `UnknownUser` type makes sense, and gives the caller a clear idea that
    something went wrong with the query.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它失去了与领域问题的意义。回到我们的例子中，拥有`UnknownUser`类型的对象是有意义的，并且让调用者清楚地知道查询出了问题。
- en: It doesn't respect the original interface. This is problematic. Remember that
    the point is that an `UnknownUser` is a user, and therefore it must have the same
    methods. If the caller accidentally asks for a method that is not there, then,
    in that case, it should raise an `AttributeError` exception, and that would be
    good. With the generic `null` object that can do anything and respond to anything,
    we would be losing this information, and bugs might creep in. If we opt for creating
    a `Mock` object with `spec=User`, then this anomaly would be caught, but again,
    using a `Mock` object to represent what is actually an empty state harms the intention
    revealing the degree of the code.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不尊重原始接口。这是有问题的。请记住，`UnknownUser`是一个用户，因此它必须具有相同的方法。如果调用者意外地要求不存在的方法，那么在这种情况下，它应该引发`AttributeError`异常，这是好的。使用通用的`null`对象，它可以做任何事情并对任何事情做出响应，我们将丢失这些信息，可能会引入错误。如果我们选择创建一个带有`spec=User`的`Mock`对象，那么这种异常将被捕获，但再次使用`Mock`对象来表示实际上是一个空状态的东西会损害代码的意图。
- en: This pattern is a good practice that allows us to maintain polymorphism in our
    objects.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式是一个很好的实践，它允许我们在对象中保持多态性。
- en: Final thoughts about design patterns
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于设计模式的最终想法
- en: We have seen the world of design patterns in Python, and in doing so, we have
    found solutions to common problems, as well as more techniques that will help
    us achieve a clean design.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在Python中看到了设计模式的世界，并且在这样做时，我们找到了解决常见问题的解决方案，以及更多的技术，这些技术将帮助我们实现一个清晰的设计。
- en: All of this sounds good, but it begs the question, how good are design patterns?
    Some people argue that they do more harm than good, that they were created for
    languages whose limited type system (and lack of first-class functions) makes
    it impossible to accomplish things we would normally do in Python. Others claim
    that design patterns force a design solution, creating some bias that limits a
    design that would have otherwise emerged, and which would have been better. Let's
    look at each of these points in turn.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些听起来都不错，但问题是，设计模式有多好呢？有人认为它们弊大于利，认为它们是为了那些类型系统有限（和缺乏一流函数）的语言而创建的，这些语言无法完成我们通常在Python中完成的事情。还有人声称设计模式强制了设计解决方案，产生了一些限制本来会出现的设计的偏见，而且本来会更好。让我们依次看看这些观点。
- en: The influence of patterns over the design
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计对设计的影响
- en: A design patterns, as with any other topic in software engineering, cannot be
    good or bad in and of itself, but rather in how it's implemented. In some cases,
    there is actually no need for a design pattern, and a simpler solution would do.
    Trying to force a pattern where it doesn't fit is a case of over-engineering,
    and that's clearly bad, but it doesn't mean that there is a problem with the design
    patterns, and most likely in these scenarios, the problem is not even related
    to patterns at all. Some people try to over-engineer everything because they don't
    understand what flexible and adaptable software really means. As we mentioned
    before in this book, making good software is not about anticipating future requirements
    (there is no point in doing futurology), but just solving the problem that we
    have at hand right now, in a way that doesn't prevent us from making changes to
    it in the future. It doesn't have to handle those changes now; it just needs to
    be flexible enough so that it can be modified in the future. And when that future
    comes, we will still have to remember the rule of three or more instances of the
    same problem before coming up with a generic solution or a proper abstraction.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式，就像软件工程中的任何其他主题一样，本身并不是好坏之分，而是取决于它的实现方式。在某些情况下，实际上并不需要设计模式，一个更简单的解决方案就可以。试图在不适合的地方强行使用模式是一种过度设计的情况，这显然是不好的，但这并不意味着设计模式有问题，而且在这些情况下，问题很可能根本与模式无关。有些人试图过度设计一切，因为他们不理解灵活和适应性软件的真正含义。正如我们在本书中之前提到的，制作好的软件并不是关于预测未来的需求（进行未来学是没有意义的），而只是解决我们目前手头的问题，以一种不会阻止我们在将来对其进行更改的方式。它不必现在就处理这些变化；它只需要足够灵活，以便将来可以进行修改。当未来到来时，我们仍然必须记住三个或更多相同问题的实例才能提出通用解决方案或适当的抽象。
- en: This is typically the point where the design patterns should emerge, once we
    have identified the problem correctly and are able to recognize the pattern and
    abstract accordingly.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是设计模式应该出现的时候，一旦我们正确识别了问题并能够识别模式并相应地抽象出来。
- en: Let's come back to the topic of the suitability of the patterns to the language.
    As we said in the introduction of the chapter, design patterns are high-level
    ideas. They typically refer to the relation of objects and their interactions.
    It's hard to think that such things might disappear from one language to another.
    It's true that some patterns are actually implemented manually in Python, as is
    the case of the iterator pattern (which, as it was heavily discussed earlier in
    the book, is built in Python), or a strategy (because, instead, we would just
    pass functions as any other regular object; we don't need to encapsulate the strategy
    method into an object the function itself would be an object).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到模式与语言适应性的话题。正如我们在本章的介绍中所说，设计模式是高层次的想法。它们通常指的是对象及其相互作用的关系。很难想象这些东西会从一种语言消失到另一种语言。有些模式实际上是在Python中手动实现的，比如迭代器模式（正如本书前面大量讨论的那样，在Python中内置了迭代器模式），或者策略（因为我们可以像传递其他常规对象一样传递函数；我们不需要将策略方法封装到一个对象中，函数本身就是一个对象）。
- en: But other patterns are actually needed, and they indeed solve problems, as in
    the case of the decorator and composite patterns. In other cases, there are design
    patterns that Python itself implements, and we just don't always see them, as
    in the case of the facade pattern that we discussed in the section on `os`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 但其他模式实际上是需要的，它们确实解决了问题，比如装饰器和组合模式。在其他情况下，Python本身实现了设计模式，我们并不总是看到它们，就像我们在`os`部分讨论的外观模式一样。
- en: As to our design patterns leading our solution in a wrong direction, we have
    to be careful here. Once again, it's better if we start designing our solution
    by thinking in terms of the domain problem and creating the right abstractions,
    and then later see whether there is a design pattern that emerges from that design.
    Let's say that it does. Is that a bad thing? The fact that there is already a
    solution to the problem we're trying to solve cannot be a bad thing. It would
    be bad to reinvent the wheel, as happens many times in our field. Moreover, the
    fact that we are applying a pattern, something already proven and validated, should
    give us greater confidence in the quality of what we are building.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 至于我们的设计模式是否会导致我们的解决方案走向错误方向，我们在这里必须小心。再次强调，最好的做法是从领域问题的角度开始设计解决方案，创建正确的抽象，然后再看是否有设计模式从该设计中出现。假设确实有。那是一件坏事吗？已经有一个解决我们正在尝试解决的问题的解决方案这个事实不能是一件坏事。重复造轮子是坏事，这在我们的领域中经常发生。此外，应用一种已经被证明和验证的模式，应该让我们对我们正在构建的东西的质量更有信心。
- en: Names in our models
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们模型中的名称
- en: Should we mention that we are using a design pattern in our code?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中是否应该提到我们正在使用设计模式？
- en: 'If the design is good and the code is clean, it should speak for itself. It
    is not recommended that you name things after the design patterns you are using
    for a couple of reasons:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设计良好，代码干净，它应该自说明。不建议您根据您使用的设计模式来命名事物，原因有几个：
- en: Users of our code and other developers don't need to know the design pattern
    behind the code, as long as it works as intended.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们代码的用户和其他开发人员不需要知道代码背后的设计模式，只要它按预期工作即可。
- en: Stating the design pattern ruins the intention revealing principle. Adding the
    name of the design pattern to a class makes it lose part of its original meaning.
    If a class represents a query, it should be named `Query` or `EnhancedQuery`,
    something that reveals the intention of what that object is supposed to do. `EnhancedQueryDecorator`
    doesn't mean anything meaningful, and the `Decorator` suffix creates more confusion
    than clarity.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 说明设计模式会破坏意图揭示原则。在类名中添加设计模式的名称会使其失去部分原始含义。如果一个类代表一个查询，它应该被命名为“Query”或“EnhancedQuery”，以显示该对象应该执行的意图。
    “EnhancedQueryDecorator”没有任何有意义的含义，“Decorator”后缀会带来更多混乱而不是清晰。
- en: Mentioning the design patterns in docstrings might be acceptable because they
    work as documentation, and expressing the design ideas (again, communicating)
    in our design is a good thing. However, this should not be needed. Most of the
    time, though, we do not need to know that a design pattern is there.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档字符串中提到设计模式可能是可以接受的，因为它们作为文档，并且在我们的设计中表达设计思想（再次交流）是一件好事。然而，这并不是必要的。大多数情况下，我们不需要知道设计模式在那里。
- en: The best designs are those in which design patterns are completely transparent
    to the users. An example of this is how the facade pattern appears in the standard
    library, making it completely transparent to users as to how to access the `os`
    module. An even more elegant example is how the iterator design pattern is so
    completely abstracted by the language that we don't even have to think about it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的设计是那些设计模式对用户完全透明的设计。一个例子是外观模式如何出现在标准库中，使用户完全透明地访问“os”模块。更优雅的例子是迭代器设计模式如何被语言完全抽象化，以至于我们甚至不必考虑它。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Design patterns have always been seen as proven solutions to common problems.
    This is a correct assessment, but in this chapter, we explored them from the point
    of view of good design techniques, patterns that leverage clean code. In most
    of the cases, we looked at how they provide a good solution to preserve polymorphism,
    reduce coupling, and create the right abstractions that encapsulate details as
    needed. All traits that relate to the concepts explored in [Chapter 8](9f77174d-125b-4fdc-8cfb-563d15edcb64.xhtml),
    *Unit Testing and Refactoring*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式一直被视为常见问题的成熟解决方案。这是一个正确的评估，但在本章中，我们从良好设计技术的角度探讨了它们，这些模式利用了干净的代码。在大多数情况下，我们看到它们如何提供了保留多态性、减少耦合和创建正确的抽象以封装所需细节的良好解决方案。所有这些特征都与[第8章](9f77174d-125b-4fdc-8cfb-563d15edcb64.xhtml)中探讨的概念相关，即“单元测试和重构”。
- en: Still, the best thing about design patterns is not the clean design we can obtain
    from applying them, but the extended vocabulary. Used as a communication tool,
    we can use their names to express the intention of our design. And sometimes,
    it's not the entire pattern that we need to apply, but we might need to take a
    particular idea (a substructure, for example) of a pattern from our solution,
    and here, too, they prove to be a way of communicating more effectively.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，设计模式最好的地方不是我们可以从应用它们中获得的干净设计，而是扩展的词汇。作为一种交流工具，我们可以使用它们的名称来表达我们设计的意图。有时，我们不需要应用整个模式，而是可能需要从我们的解决方案中采用特定的想法（例如子结构），在这里，它们也被证明是更有效地交流的一种方式。
- en: When we create solutions by thinking in terms of patterns, we are solving problems
    at a more general level. Thinking in terms of design patterns, brings us closer
    to higher-level design. We can slowly "zoom-out" and think more in terms of an
    architecture. And now that we are solving more general problems, it's time to
    start thinking about how the system is going to evolve and be maintained in the
    long run (how it's going to scale, change, adapt, and so on).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过模式思考解决问题时，我们是在更一般的层面上解决问题。以设计模式思考，使我们更接近更高级别的设计。我们可以慢慢“放大”并更多地考虑架构。现在我们正在解决更一般的问题，是时候开始考虑系统如何在长期内发展和维护（如何扩展、改变、适应等）。
- en: For a software project to be successful in these goals, it requires clean code
    at its core, but the architecture also has to be clean as well, which is what
    we are going to look at in the next chapter.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要使软件项目在这些目标中取得成功，它需要以干净的代码为核心，但架构也必须是干净的，这是我们将在下一章中讨论的内容。
- en: References
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Here is a list of information you can refer to:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些你可以参考的信息列表：
- en: '*GoF*: The book written by Erich Gamma, Richard Helm, Ralph Johnson, and John
    Vlissides named *Design Patterns: Elements of Reusable Object-Oriented Software*'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GoF*：由Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides撰写的书籍，名为*设计模式：可复用面向对象软件的元素*'
- en: '*SNGMONO*: An article written by Robert C. Martin, 2002 named *SINGLETON and
    MONOSTATE*'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SNGMONO*：一篇由Robert C. Martin于2002年撰写的文章，名为*SINGLETON and MONOSTATE*'
- en: '*The Null Object Pattern*, written by Bobby Woolf'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《空对象模式》，作者Bobby Woolf
