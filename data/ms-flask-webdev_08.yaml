- en: Building RESTful APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 RESTful API
- en: '**Representational State Transfer** (**REST**) is an architectural style that
    is used to implement web services. It was defined by Roy Fielding in his PhD dissertation
    in 2000\. REST aims to implement a standard for uniform and predefined operations
    between systems. These systems can be client browsers, mobile applications, servers
    running parallel worker processes—you name it. By using HTTP methods, REST is
    platform- and programming-language-agnostic, and decouples the client and the
    server for easier development. This is typically used in web **single-page applications**
    (**SPAs**) that need to pull or update user information on the server. REST is
    also used to provide outside developers with a common interface to access user
    data. For example, Facebook and Twitter use REST in their application program
    interface, or API.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**表征状态转移**（**REST**）是一种用于实现Web服务的架构风格。它由Roy Fielding在2000年的博士论文中定义。REST旨在实现系统之间统一和预定义操作的标准。这些系统可以是客户端浏览器、移动应用程序、运行并行工作进程的服务器——你名之。通过使用HTTP方法，REST是平台和编程语言无关的，并且解耦客户端和服务器，以便更容易地进行开发。这通常用于需要从服务器拉取或更新用户信息的Web**单页应用程序**（**SPAs**）。REST还用于为外部开发者提供一个通用的接口来访问用户数据。例如，Facebook和Twitter在其应用程序程序接口（或API）中使用REST。'
- en: You can take a look at Roy Fielding's original dissertation on REST at [https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)查看Roy
    Fielding关于REST的原始论文。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: 'The HTTP protocol: requests, responses, methods, headers, and the URI format'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP协议：请求、响应、方法、头部和URI格式
- en: How to build a REST service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建REST服务
- en: How to secure a REST service using JWT
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用JWT保护REST服务
- en: What is REST?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是REST？
- en: Before getting into the details of REST, and since it is a style for communication
    between systems, let's first have a quick dive into the actual protocol that it
    uses, on which this whole book is based.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解REST之前，由于它是一种系统间通信的风格，让我们首先快速了解一下它所使用的实际协议，这本书的整个基础。
- en: HTTP
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP
- en: The **Hypertext Transfer Protocol** (**HTTP**) is a request–response protocol
    that belongs to layer 7 (the application layer). This layer interacts with the
    application itself. Some other protocols that belong to layer 7 are the **Simple
    Mail Transfer protoco**l (**SMTP**), **Network File System** (**NFS**), and the **File
    Transfer Protocol** (**FTP**), to name a few.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**超文本传输协议**（**HTTP**）是一种属于第7层（应用层）的请求-响应协议。这一层与应用程序本身进行交互。属于第7层的其他协议还包括**简单邮件传输协议**（**SMTP**）、**网络文件系统**（**NFS**）、**文件传输协议**（**FTP**）等。'
- en: HTTP was designed to be used by clients (user agents) to request resources from
    a server. These resources can be HTML files or any other content, such as JSON,
    XML, or media files. These requests for resources are identified by the network
    using **unified resource locators** (**URLs**).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP被设计为供客户端（用户代理）从服务器请求资源使用。这些资源可以是HTML文件或任何其他内容，如JSON、XML或媒体文件。这些资源请求由网络使用**统一资源定位符**（**URLs**）标识。
- en: 'A URL is a specific type of URI, composed of the following elements:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: URL是一种特定的URI类型，由以下元素组成：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding `<authority>` part:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `<authority>` 部分：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is an example URL using our application:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们应用程序的一个示例URL：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s separate out the elements of this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分别列出这个的元素：
- en: '| **Scheme** | **HTTP** |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **方案** | **HTTP** |'
- en: '| `authority.host` | `someserver.com` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `authority.host` | `someserver.com` |'
- en: '| `authority.port` | `5000` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `authority.port` | `5000` |'
- en: '| `path` | `blog/user/user1` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `path` | `blog/user/user1` |'
- en: '| `query` | `title=sometitle` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `query` | `title=sometitle` |'
- en: '| `fragment` | `1` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `fragment` | `1` |'
- en: 'Next, we will quickly look at an HTTP request message from a user agent to
    a server. This is a GET request from a Mozilla browser, as shown in the highlighted
    text in the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将快速查看一个用户代理向服务器发送的HTTP请求消息。这是一个来自Mozilla浏览器的GET请求，如下面的代码中高亮显示的文本所示：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So an HTTP request is composed of the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个HTTP请求由以下部分组成：
- en: '**Request line**: Further composed of `<Request method> <Request URI> <HTTP
    version>`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求行**：进一步由`<Request method> <Request URI> <HTTP version>`组成'
- en: '**Request header**: Contains information about what the client accepts, the
    user agent, cookies, and even basic authentication credentials'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求头**: 包含客户端接受的信息、用户代理、cookies以及甚至基本的认证凭证'
- en: '**A** **blank line**: Separates the header from the body section'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个空白行**: 将头部与主体部分分开'
- en: '**Request body**: Optional'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求体**: 可选'
- en: Accepted HTTP request methods are `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`,
    `OPTIONS`, `TRACE`, and `PATCH`. The REST specification will use them to identify
    application type operations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接受的HTTP请求方法有`GET`、`HEAD`、`POST`、`PUT`、`DELETE`、`CONNECT`、`OPTIONS`、`TRACE`和`PATCH`。REST规范将使用它们来识别应用程序类型操作。
- en: 'An HTTP response to a request looks like the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP响应请求看起来如下：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It''s composed of the following elements:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它由以下元素组成：
- en: '**Status line**: The status of the response'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态行**: 响应的状态'
- en: '**Response headers**: Contains information about the content type, length,
    the server type (in our example, it''s Flask''s development server itself), date,
    and whether it can send set-cookie operations'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应头**: 包含有关内容类型、长度、服务器类型（在我们的例子中，是Flask的开发服务器本身）、日期以及是否可以发送set-cookie操作的信息'
- en: A blank line
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空白行
- en: '**Response body**: In our example, this is a JSON response, probably a REST
    service response'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应体**: 在我们的例子中，这是一个JSON响应，可能是REST服务响应'
- en: 'Status response codes are also very significant to REST. These fall into the
    following categories:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 状态响应代码对REST也非常重要。它们分为以下类别：
- en: '**Informational**: 1XX'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息性**: 1XX'
- en: '**Successful**: 2XX'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成功**: 2XX'
- en: '**Redirection**: 3XX'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重定向**: 3XX'
- en: '**Client error**: 4XX'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端错误**: 4XX'
- en: '**Server error**: 5XX'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器错误**: 5XX'
- en: For further details on status response codes, take a look at RFC2616 at [https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有关状态响应代码的更多详细信息，请参阅RFC2616在[https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。
- en: REST definition and best practices
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST定义和最佳实践
- en: 'Before getting into the details of REST, let''s look at an example. With a
    client—in this case, a web browser—and a server, the client sends a request to
    the server over HTTP for some models, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解REST之前，让我们看看一个例子。有一个客户端——在这种情况下，是一个网页浏览器——和一个服务器，客户端通过HTTP向服务器发送请求以获取一些模型，如下所示：
- en: '![](img/dec57efd-0837-4883-bd2d-9971b1a10913.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dec57efd-0837-4883-bd2d-9971b1a10913.png)'
- en: 'The server will then respond with a document containing all the models, as
    follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将随后响应一个包含所有模型的文档，如下所示：
- en: '![](img/6ea3f8b0-ab4c-4648-a50b-5b69e62d2552.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ea3f8b0-ab4c-4648-a50b-5b69e62d2552.png)'
- en: 'The client can then modify the data on the server through a `PUT` HTTP request,
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以通过以下`PUT` HTTP请求修改服务器上的数据：
- en: '![](img/f8282865-f224-433a-b137-67f923f75a0a.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f8282865-f224-433a-b137-67f923f75a0a.png)'
- en: Then, the server will respond that it has modified the data. This is a very
    simplified example, but it will serve as a backdrop to how REST is defined.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，服务器将响应它已修改数据。这是一个非常简化的例子，但它将作为REST定义的背景。
- en: Rather than a strict standard, REST lays out a set of constraints on communications
    to define a methodology that can be implemented in many ways. These constraints
    are born out of years of trial and error with other communication protocols, such
    as the **Remote Procedure Call** (**RPC**) or **Simple Object Access Protocol**
    (**SOAP**). These protocols fell by the wayside because of their strictness, verbosity,
    and the fact that it is difficult to use them to create APIs. The issues with
    these systems were identified, and REST's constraints were created to keep these
    issues from happening again.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与严格的规范不同，REST定义了一套对通信的约束，以定义一种可以以多种方式实施的方法。这些约束源于与其他通信协议（如远程过程调用**RPC**或简单对象访问协议**SOAP**）多年来的试验和错误。这些协议因为其严格性、冗长性以及难以用于创建API的事实而被废弃。这些问题被识别出来，REST的约束被创建出来，以防止这些问题再次发生。
- en: 'REST provides the following guiding constraints:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: REST提供了以下指导性约束：
- en: '**Separation of concerns between the client and server**: The client and server
    should be able to evolve or change independently as long as the API does not change.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端和服务器之间的关注点分离**: 只要API不改变，客户端和服务器应该能够独立地演变或改变。'
- en: '**Stateless**: Any information that is necessary to handle requests is stored
    in the request itself or by the client. An example of the server being stateless
    is the `session` object in Flask. The `session` object does not store its information
    on the server, but stores it on the client in a cookie. The cookie is sent along
    with every request for the server to parse and determine whether the necessary
    data for the requested resource is stored inside it, rather than the server storing
    session information for every user.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态：**处理请求所需的所有必要信息都存储在请求本身或客户端中。服务器无状态的例子是Flask中的`session`对象。`session`对象不在服务器上存储其信息，而是在客户端的cookie中存储。cookie与每个请求一起发送，以便服务器解析并确定是否在cookie中存储了请求资源的必要数据，而不是服务器为每个用户存储会话信息。
    |'
- en: '**Uniform interface**: There are many different parts to this constraint, which
    are as follows:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一接口：**这个约束有许多不同的部分，如下所述： |'
- en: The interface is based around resources, which in our case are models.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口是基于资源构建的，在我们的案例中是模型。 |
- en: Data sent by the server is not the actual data in the server, but a representation.
    For example, a JSON abstraction of the data is sent with each request, rather
    than the actual database.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器发送的数据不是服务器中的实际数据，而是一种表示。例如，每个请求都发送数据的JSON抽象，而不是实际的数据库。 |
- en: The data sent by the server is enough to allow the client to modify the data
    on the server. In the preceding example, the IDs that are passed to the client
    fill this role.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器发送的数据足以允许客户端修改服务器上的数据。在先前的示例中，传递给客户端的ID扮演了这一角色。 |
- en: Every resource provided by the API must be represented and accessed in the same
    manner. For example, one resource cannot be represented in XML and while another
    is represented in JSON.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: API提供的每个资源都必须以相同的方式进行表示和访问。例如，一个资源不能以XML表示，而另一个以JSON表示。 |
- en: '**Layered system:** Load balancers, proxies, caches, and other servers and
    services can act between the client and the server, as long as the final result
    is the same as if they were not there. This improves performance, scalability,
    and availability.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分层系统：**负载均衡器、代理、缓存以及其他服务器和服务可以在客户端和服务器之间执行，只要最终结果与它们不存在时相同。这提高了性能、可扩展性和可用性。
    |'
- en: '**Cacheability: **Clients can cache responses, so a server must define whether
    a response is cacheable or not. This improves performance.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存性：**客户端可以缓存响应，因此服务器必须定义响应是否可缓存。这可以提高性能。 |'
- en: 'When a system adheres to all these constraints, it is considered to be a RESTful
    system. The most common forms of RESTful systems are built of HTTP and JSON. Each
    resource is located on its own URL path and is modified with different HTTP request
    methods. Generally, this takes the following form:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个系统遵守所有这些约束时，它被认为是RESTful系统。最常见的形式是由HTTP和JSON构建的。每个资源都位于自己的URL路径上，并使用不同的HTTP请求方法进行修改。通常，这具有以下形式：
    |
- en: '| **HTTP method** | **URL** | **Action** |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP方法** | **URL** | **操作** |'
- en: '| `GET` | `http://host/resource` | Get all the resource representations |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `http://host/resource` | 获取所有资源表示 |'
- en: '| `GET` | `http://host/resource/1` | Get the resource with an ID of `1` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `http://host/resource/1` | 通过ID为`1`获取资源 |'
- en: '| `POST` | `http://host/resource` | Create a new resource from the form data
    in the `POST` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `http://host/resource` | 从`POST`请求中的表单数据创建新的资源 |'
- en: '| `PUT` | `http://host/resource/1` | Modify the existing data of the resource
    with the ID of `1` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `http://host/resource/1` | 修改ID为`1`的资源现有数据 |'
- en: '| `DELETE` | `http://host/resource/1` | Delete the resource with the ID of
    `1` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `http://host/resource/1` | 删除ID为`1`的资源 |'
- en: 'As an example, a response to the second `GET` request would look like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对第二个`GET`请求的响应可能如下所示： |
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In RESTful APIs, it is also very important that we return the correct HTTP
    status code with the response data to notify the clients of what actually happened
    on the server without the clients resorting to parsing the returned message. Here
    is a list of the main HTTP codes that are used in RESTful APIs, along with their
    meaning:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在RESTful API中，返回正确的HTTP状态代码与响应数据一起，也非常重要，以便通知客户端服务器上实际发生了什么，而无需客户端解析返回的消息。以下是RESTful
    API中使用的HTTP代码列表及其含义： |
- en: '| **HTTP code** | **Name** | **Meaning** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP代码** | **名称** | **含义** |'
- en: '| `200` | OK | The default code of HTTP. The request was successful, and the
    data was returned. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `200` | OK | HTTP的默认代码。请求成功，并返回了数据。 |'
- en: '| `201` | Created | The request was successful, and a new resource was created
    on the server. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `201` | 已创建 | 请求成功，并在服务器上创建了一个新资源。 |'
- en: '| `204` | No content | The request was successful, but the response returned
    no content. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `204` | 无内容 | 请求成功，但响应没有返回内容。 |'
- en: '| `400` | Bad request | The request was denied because of some perceived client
    error—either it was a malformed request or it was missing the required data. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `400` | 错误请求 | 请求被拒绝，因为客户端存在某些感知到的错误——要么是请求格式不正确，要么是缺少所需的数据。'
- en: '| `401` | Unauthorized | The request was denied because the client was not
    authenticated, and it should be authenticated before requesting this resource
    again. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `401` | 未授权 | 请求被拒绝，因为客户端未认证，在再次请求此资源之前应该进行认证。'
- en: '| `403` | Forbidden | The request was denied because the client does not have
    permission to access this resource. This is in contrast to the `401` code, which
    assumes that the user is not authenticated. The `403` code says the resource is
    not accessible regardless of authentication. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `403` | 禁止 | 请求被拒绝，因为客户端没有权限访问此资源。这与`401`代码不同，`401`代码假设用户未认证。`403`代码表示无论认证与否，资源都不可访问。'
- en: '| `404` | Not found | The requested resource does not exist. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `404` | 未找到 | 请求的资源不存在。 |'
- en: '| `405` | Method not allowed | The request was denied because the HTTP method
    is not available for the URL. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `405` | 方法不允许 | 请求被拒绝，因为HTTP方法对于URL不可用。 |'
- en: '| `500` | Internal server error | The web server responds with this status
    code when it has encountered an unexpected condition that prevented it from fulfilling
    the request from the client. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `500` | 内部服务器错误 | 当Web服务器遇到意外条件，阻止其满足客户端请求时，会以这个状态码响应。 |'
- en: '| `501` | Not implemented | This error is shown when it does not support the
    functionality required to process the request. This is the appropriate response
    when the server does not recognize the request method. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `501` | 未实现 | 当不支持处理请求所需的功能时显示此错误。当服务器不识别请求方法时，这是适当的响应。'
- en: '| `502` | Bad gateway | When the server is acting as a gateway or proxy and
    receives an invalid response from the upstream server. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `502` | 网关错误 | 当服务器作为网关或代理并从上游服务器收到无效响应时。 |'
- en: '| `503` | Service unavailable | Currently unable to handle the request because
    of temporary overloading or maintenance of the server.  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `503` | 服务不可用 | 目前无法处理请求，因为服务器暂时过载或维护。'
- en: '| `504` | Gateway timeout | Did not receive a timely response from the upstream
    server. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `504` | 网关超时 | 未从上游服务器及时收到响应。 |'
- en: Setting up a RESTful Flask API
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置RESTful Flask API
- en: In our app, we will create a RESTful interface to the blog post data in our
    database. The representations of the data will be sent as JSON. The data will
    be retrieved and modified using the general form in the preceding table, but the
    URI will be `/api/posts`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将创建一个RESTful接口来访问我们数据库中的博客文章数据。数据表示将作为JSON发送。数据将通过使用前面表格中的通用形式检索和修改，但URI将是`/api/posts`。
- en: 'If you haven''t already downloaded and accessed the example code given for
    this chapter and taken a look at the Flask URL maps for the API, then a simple
    way of doing this can be seen in the root directory of the application, as shown
    in the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有下载并访问本章提供的示例代码，也没有查看API的Flask URL映射，那么在应用程序的根目录中可以找到一个简单的方法，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We are going to implement an authentication endpoint for the API and the necessary
    endpoints to create a CRUD API for the blog posts.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为API实现一个认证端点以及创建博客文章CRUD API所需的端点。
- en: We could just use the standard Flask views to create the API, but the Flask
    extension **Flask Restful** makes the task much easier and will help us adhere
    to a full REST compliance (RESTful).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标准的Flask视图来创建API，但Flask扩展**Flask Restful**可以使任务变得更加简单，并将帮助我们遵守完整的REST兼容性（RESTful）。
- en: 'To include this new dependency in our application, you can find the following
    in the `requirements.txt` file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此新依赖项包含到我们的应用程序中，您可以在`requirements.txt`文件中找到以下内容：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We are going to create a new module for the API. The application structure
    looks like the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的模块用于API。应用程序结构如下面的代码所示：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once again, the idea is to structure our application so that it can grow easily.
    This time, for each application module we add—such as a blog, shared photos, you
    name it—we create a new module inside the `api/` module itself where all the API
    logic is defined. A different approach could be to include the REST API inside
    each module.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们的想法是构建一个易于扩展的应用程序。这次，对于每个添加的应用程序模块——比如博客、共享照片，等等——我们将在`api/`模块内部创建一个新的模块，其中定义了所有API逻辑。另一种方法可能是将REST
    API包含在每个模块中。
- en: Just like with all the other modules, there is a `create_module` function on
    the `api/__init__.py` that handles its own initialization for the main factory
    function, `create_app` . The `PostApi` class will also have its route defined
    with the `add_resource()` method of the `Api` object.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有其他模块一样，`api/__init__.py`中有一个`create_module`函数，它处理主工厂函数`create_app`的初始化。`PostApi`类也将使用`Api`对象的`add_resource()`方法定义其路由。
- en: 'This can be seen in the provided code file, `api/__init__.py`, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在提供的代码文件`api/__init__.py`中看到，如下所示：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It can also be seen in the `create_app` function in `__init__.py` file, as
    follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以在`__init__.py`文件中的`create_app`函数中看到，如下所示：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The control logic and views for our `Post` API are stored in a new folder named
    `api/blog` in the `controllers.py` file. Inside the `controllers.py`, we are going
    to create the API itself, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`Post` API的控制逻辑和视图存储在名为`api/blog`的新文件夹中的`controllers.py`文件中。在`controllers.py`内部，我们将创建API本身，如下所示：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In Flask Restful, every REST resource is defined as a class that inherits from
    the `Resource` object. Much like the `MethodView` object shown in [Chapter 4](33c572f2-ce0e-40da-b46a-a7e13ba85496.xhtml),
    *Creating Controllers with Blueprints*, any class that inherits from the `Resource`
    object defines its logic with methods named after the HTTP methods. For example,
    when the `GET` HTTP method hits the `PostApi` class, the `get` method will be
    executed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flask Restful中，每个REST资源都定义为继承自`Resource`对象的一个类。这与[第4章](33c572f2-ce0e-40da-b46a-a7e13ba85496.xhtml)中展示的`MethodView`对象类似，*使用蓝图创建控制器*，任何继承自`Resource`对象的类都使用以HTTP方法命名的函数定义其逻辑。例如，当`GET`
    HTTP方法击中`PostApi`类时，将执行`get`方法。
- en: JWT authentication
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JWT认证
- en: To solve our authentication problems, `Flask-Login` could be used and the cookie
    data from the login could be checked. However, this would require developers who
    wish to use our API to have their program login through the web interface. We
    could also have developers send their login data with every request, but it's
    a good design practice to only send sensitive information when absolutely necessary.
    Instead, our API will provide an `auth/api` endpoint that allows them to send
    login credentials and get an access token back.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决我们的认证问题，可以使用`Flask-Login`并检查登录的cookie数据。然而，这要求希望使用我们API的开发者通过网页界面登录他们的程序。我们也可以让开发者将登录数据与每个请求一起发送，但良好的设计实践是在绝对必要时才发送敏感信息。相反，我们的API将提供一个`auth/api`端点，允许他们发送登录凭证并获取一个访问令牌。
- en: For the authentication mechanism, we are going to use **JSON Web Token** (**JWT**)
    to create access tokens for the consumers of our API upon login. A JWT token asserts
    which user is logged in, thereby saving the server another call to the database
    for authentication. This token has an expiration date encoded inside it that will
    not allow the token to be used after it expires. This means that even if the token
    is stolen by a malicious user, it will only be useful for a limited amount of
    time before the client has to reauthenticate. As always, be sure to use HTTPS
    to encrypt all your client–server connections.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于认证机制，我们将使用**JSON Web Token**（**JWT**）在用户登录时为我们的API消费者创建访问令牌。JWT令牌声明了哪个用户已登录，从而节省服务器对数据库进行认证的另一个调用。此令牌内部编码了过期日期，不允许在过期后使用该令牌。这意味着即使令牌被恶意用户窃取，它也只有在客户端需要重新认证之前的一段时间内才有用。一如既往，请确保使用HTTPS来加密所有客户端-服务器连接。
- en: 'To leverage this feature, we are going to use another Flask extension—Flask-JWT-extended.
    You will find its dependency declared in the `requirements.txt` file, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这个特性，我们将使用另一个Flask扩展——Flask-JWT-extended。你将在`requirements.txt`文件中找到其依赖项的声明，如下所示：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The initialization of the extension is going to be made on the `auth` module.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的初始化将在`auth`模块中进行。
- en: 'Look at the following `auth/__init__.py` file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下`auth/__init__.py`文件：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we use the following helper function to authenticate users that are defined
    on the same file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下辅助函数在同一个文件中认证用户：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The definition of the login endpoint itself can be found at `auth/controllers.py`,
    as shown in the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 登录端点的定义可以在`auth/controllers.py`中找到，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, we verify whether the request includes a JSON body. For this, we use
    a `request.is_json` function from Flask. Next, we extract the username and password
    from the JSON body using `request.json.get`. Then we check the user's credentials
    using the previous help function, `authenticate`. Finally, we return the JWT access
    token using the username as our identity.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们验证请求是否包含JSON正文。为此，我们使用Flask中的`request.is_json`函数。接下来，我们使用`request.json.get`从JSON正文中提取用户名和密码。然后我们使用之前的帮助函数`authenticate`检查用户的凭证。最后，我们使用用户名作为我们的身份返回JWT访问令牌。
- en: 'Users of our API will have to pass the token that is received from this resource
    to any method that requires user credentials. In order to test this code, a tool
    named **curl** will be used. Curl is a command-line tool included in Bash that
    allows for the creation and manipulation of HTTP requests. To test it, use the `curl`utility
    to first log in, as shown in the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们API的用户必须将从这个资源收到的令牌传递给任何需要用户凭证的方法。为了测试此代码，将使用一个名为**curl**的工具。Curl是Bash中包含的一个命令行工具，它允许创建和操作HTTP请求。要测试它，使用`curl`实用程序首先登录，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We then use the `-H` flag to send the request header stating that the content
    body is JSON and the `-d` flag to send the request body data. Next, we can use
    the token to access API-protected resources, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`-H`标志发送请求头，表明内容正文是JSON，并使用`-d`标志发送请求正文数据。接下来，我们可以使用令牌来访问受API保护的资源，如下所示：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note how the access token is sent on the request header user `Authorization:
    Bearer <TOKEN>` convention. If we try to access the same resource without any
    token, we get the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '注意访问令牌是如何在请求头中按照`Authorization: Bearer <TOKEN>`约定发送的。如果我们尝试在没有令牌的情况下访问相同的资源，我们会得到以下结果：'
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As expected, we get an HTTP `401` status code. To protect API endpoints, we
    just have to use the `flask-jwt-extended` decorator `@jwt_required`, and to fetch
    the username, we use the `get_jwt_identity()` function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，我们得到了HTTP `401`状态码。为了保护API端点，我们只需使用`flask-jwt-extended`装饰器`@jwt_required`，并且为了获取用户名，我们使用`get_jwt_identity()`函数。
- en: The `flask-jwt-extended` decorator provides some extra functionalities, such
    as token expiration, the ability to refresh token endpoints, and many configuration
    options. You can read more about it at [http://flask-jwt-extended.readthedocs.io/en/latest/](http://flask-jwt-extended.readthedocs.io/en/latest/).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`flask-jwt-extended`装饰器提供了一些额外的功能，例如令牌过期、刷新令牌端点的功能以及许多配置选项。您可以在[http://flask-jwt-extended.readthedocs.io/en/latest/](http://flask-jwt-extended.readthedocs.io/en/latest/)了解更多信息。'
- en: Get requests
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GET请求
- en: For some of our `GET`, `PUT`, and `DELETE` requests, our API will need the ID
    of the post that is to be modified.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的某些`GET`、`PUT`和`DELETE`请求，我们的API将需要修改的帖子的ID。
- en: The data to be sent to the client must be a representation of the `Post` objects
    in JSON, so how will our `Post` objects be translated? Flask Restful provides
    a way of translating any object into JSON through the `fields` object and the
    `marshal_with` function decorator.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到客户端的数据必须是`Post`对象的表示，那么我们的`Post`对象将如何转换呢？Flask Restful提供了一种通过`fields`对象和`marshal_with`函数装饰器将任何对象转换为JSON的方法。
- en: Output formatting
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出格式化
- en: The output format is defined by creating a dictionary of `field` objects that
    represent basic types. The key of the field defines what attribute the field will
    try to translate. By passing the dictionary to the `marshal_with` decorator, any
    object that the `get` method attempts to return will be first translated using
    the dictionary. This also works for lists of objects. Let's look at a simple way
    of implementing this API endpoint. The following example code takes pagination
    into account, but we will show you how this works later.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 输出格式是通过创建一个表示基本类型的`field`对象的字典来定义的。字段的键定义了字段将尝试转换的属性。通过将字典传递给`marshal_with`装饰器，`get`方法尝试返回的任何对象都将首先使用该字典进行转换。这也适用于对象列表。让我们看看实现此API端点的一种简单方法。以下示例代码考虑了分页，但我们将在稍后向您展示它是如何工作的。
- en: 'Look at the following `api/blog/controllers.py` file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下`api/blog/controllers.py`文件：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'While reloading the API in the browser, every `Post` object will be shown in
    JSON format. Note the `HTMLField` on the fields declaration. The problem is that
    the API should not return HTML from the WYSIWYG editor in the post creation form.
    As stated earlier, the server should not be concerned with the UI, and the HTML
    is purely for output specification. To solve this, we will need a custom field
    object that strips HTML from the strings. In a new file in the `api/blog/` folder
    named `fields.py`, we have the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中重新加载API时，每个`Post`对象将以JSON格式显示。注意字段声明中的`HTMLField`。问题是API不应该从帖子创建表单中的WYSIWYG编辑器返回HTML。如前所述，服务器不应该关心UI，HTML纯粹是输出规范。为了解决这个问题，我们需要一个自定义字段对象，它将从字符串中删除HTML。在`api/blog/`文件夹中的新文件`fields.py`中，我们有以下内容：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The exception block is to take into account Python2 and Python3 compatibility,
    since the standard library has changed for the `HTMLParser` module in Python3. We
    now have a `strip_tags` function that will return any string that has been cleaned
    of HTML tags. A new field type, called `HTMLfield`, is defined by inheriting from
    the `fields.Raw` class and sending values through the `strip_tags` function. If
    the page is reloaded, all HTML is gone and only the text will remain.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 异常块是为了考虑Python2和Python3的兼容性，因为Python3中`HTMLParser`模块的标准库已经改变。我们现在有一个`strip_tags`函数，它将返回任何被清理了HTML标签的字符串。通过从`fields.Raw`类继承并使用`strip_tags`函数传递值，定义了一个新的字段类型，称为`HTMLfield`。如果页面被重新加载，所有的HTML都会消失，只剩下文本。
- en: 'Flask Restful provides many default fields, as shown in the following list:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Flask Restful提供了许多默认字段，如下所示列表：
- en: '`fields.String`: This converts the value using `str()`.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.String`：使用`str()`转换值。'
- en: '`fields.FormattedString`: This passes the formatted string in Python with the
    variable name in brackets.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.FormattedString`：传递带有括号中变量名的Python格式化字符串。'
- en: '`fields.Url`: This provides the same functionality as the Flask `url_for` function.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.Url`：这提供了与Flask `url_for`函数相同的功能。'
- en: '`fields.DateTime`: This converts a Python `date` or `datetime` object to a
    string. The `format` keyword argument specifies whether the string should be an
    `ISO8601` date or an `RFC822` date.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.DateTime`：将Python `date`或`datetime`对象转换为字符串。`format`关键字参数指定字符串应该是`ISO8601`日期还是`RFC822`日期。'
- en: '`fields.Float`: This converts the value to a string representation of a float.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.Float`：将值转换为浮点数的字符串表示。'
- en: '`fields.Integer`: This converts the value to a string representation of an
    integer.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.Integer`：将值转换为整数的字符串表示。'
- en: '`fields.Nested`: This allows nested objects to be represented by another dictionary
    of field objects.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.Nested`：允许通过另一个字段对象字典表示嵌套对象。'
- en: '`fields.List`: Much like the MongoEngine API, this field takes another field
    type as an argument and tries to convert a list of values into a JSON list of
    the field types.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.List`：与MongoEngine API非常相似，这个字段接受另一个字段类型作为参数，并尝试将值列表转换为字段类型的JSON列表。'
- en: '`fields.Boolean`: This converts the value to a string representation of a `boolean`
    argument.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.Boolean`：将值转换为`boolean`参数的字符串表示。'
- en: 'There are two more fields that are added to the returned data: the author and
    the tags. The comments will be left out because they should be contained under
    their own resource.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的数据中增加了两个字段：作者和标签。评论将被省略，因为它们应该包含在其自己的资源下。
- en: The `author` field uses the attribute keyword argument of the `field` class.
    This allows any attribute of the object to be represented rather than just base-level
    properties. Because the many-to-many relationship of the tags returns a list of
    objects, the same solution cannot be used with the tags. A list of tag dictionaries
    can now be returned using the `NestedField` type inside a `ListField` and another
    dictionary of fields. This has the added benefit of giving the end users of the
    API a tag ID so that they can query as easily as if there were a tag API.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`author`字段使用`field`类的属性关键字参数。这允许表示对象的任何属性，而不仅仅是基本级别的属性。因为标签的多对多关系返回一个对象列表，所以不能使用相同的解决方案来处理标签。现在可以使用`NestedField`类型在`ListField`内部和另一个字段字典返回一个标签字典列表。这给API的最终用户带来了额外的便利，使他们能够像有标签API一样轻松地进行查询。'
- en: Request arguments
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求参数
- en: While sending a `GET` request to the base of the resource, our API currently
    sends all the `Post` objects in the database. This is acceptable if the number
    of objects is low or the number of people using the API is low. However, if either
    increases, the API will put a large amount of stress on the database. Much like
    the web interface, the API should be paginated as well.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当向资源的根发送 `GET` 请求时，我们的 API 当前发送数据库中的所有 `Post` 对象。如果对象数量较少或使用 API 的人数较少，这是可以接受的。然而，如果任一数量增加，API
    将对数据库造成大量压力。与网络界面类似，API 也应该分页。
- en: 'In order to achieve this, our API will need to accept a `GET` query string
    parameter called `page` that specifies which page is to be loaded. Flask Restful
    provides a method to grab request data and parse it. If the required arguments
    aren''t there, or the types don''t match, Flask Restful will autocreate a JSON
    error message. In a new file in the `api/blog/` folder named `parsers.py`, you
    will find the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们的 API 需要接受一个名为 `page` 的 `GET` 查询字符串参数，该参数指定要加载的页面。Flask Restful 提供了一种方法来获取请求数据并解析它。如果缺少必要的参数，或者类型不匹配，Flask
    Restful 将自动创建一个 JSON 错误消息。在 `api/blog/` 文件夹中的新文件 `parsers.py` 中，你可以找到以下代码：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following code is what we should have on the `PostApi` class when the request
    has no post ID key:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求没有 post ID 键时，以下代码是我们应该在 `PostApi` 类中拥有的代码：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, `RequestParser` looks for the `page` variable in either
    the query string or the request header and returns the page of `Post` objects
    from that page. Again, we are making the page size configurable with the same
    value as for the web view page version. We use the `current_app` Flask proxy to
    fetch any value from our configuration.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`RequestParser` 在查询字符串或请求头中查找 `page` 变量，并返回该页面的 `Post` 对象。同样，我们使用与网络视图页面版本相同的值来配置页面大小。我们使用
    `current_app` Flask 代理来获取我们的配置中的任何值。
- en: 'After a parser object is created with `RequestParser`, arguments can be added
    using the `add_argument` method. The first argument of `add_argument` is the key
    of the argument that is to be parsed, but `add_argument` also takes a lot of keyword
    arguments, as shown in the following list:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `RequestParser` 创建解析器对象后，可以使用 `add_argument` 方法添加参数。`add_argument` 的第一个参数是要解析的参数的键，但
    `add_argument` 还接受许多关键字参数，如下所示列表所示：
- en: '`action`: This is what the parser does with the value after it has been successfully
    parsed. The two available options are `store` and `append`. The `store` option
    adds the parsed value to the returned dictionary. The `append` options adds the
    parsed value to the end of a list in the dictionary.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action`: 解析器在成功解析值后对值执行的操作。两个可用的选项是 `store` 和 `append`。`store` 选项将解析值添加到返回的字典中。`append`
    选项将解析值添加到字典中列表的末尾。'
- en: '`case_sensitive`: This is a boolean argument to allow or disallow the keys
    to be case insensitive.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`case_sensitive`: 这是一个布尔参数，用于允许或禁止键不区分大小写。'
- en: '`choices`: This is like MongoEngine, a list of the allowed values for the argument.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`choices`: 这类似于 MongoEngine，是参数允许值的列表。'
- en: '`default`: This is the value that is produced if the argument is absent from
    the request.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`: 如果请求中缺少参数，则生成的值。'
- en: '`dest`: This is the key to add the parsed value to in the returned data.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dest`: 这是添加解析值到返回数据中的键。'
- en: '`help`: This is a message to return to the user if validation fails.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help`: 这是当验证失败时返回给用户的消息。'
- en: '`ignore`: This is a boolean argument to allow or disallow failures of the type
    conversion.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore`: 这是一个布尔参数，用于允许或禁止类型转换失败。'
- en: '`location`: This indicates where to look for the data. The locations available
    are as follows:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location`: 这表示查找数据的位置。可用的位置如下：'
- en: '`args` to look in the `GET` query string'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args` 用于在 `GET` 查询字符串中查找'
- en: '`headers` to look in the HTTP request headers'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers` 用于在 HTTP 请求头中查找'
- en: '`form` to look in the HTTP `POST` data'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`form` 用于在 HTTP `POST` 数据中查找'
- en: '`cookies` to look in the HTTP cookies'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cookies` 用于在 HTTP 钩子中查找'
- en: '`json` to look in any sent JSON'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json` 用于查找任何发送的 JSON'
- en: '`files` to look in the `POST` file data'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`files` 用于在 `POST` 文件数据中查找'
- en: '`required`: This is a boolean argument to determine whether the argument is
    optional.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required`: 这是一个布尔参数，用于确定该参数是否为可选的。'
- en: '`store_missing`: This is a boolean argument to determine whether the default
    value should be stored if the argument is not in the request.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store_missing`: 这是一个布尔参数，用于确定如果参数不在请求中，是否应该存储默认值。'
- en: '`type`: This is the Python type to convert the passed value.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`: 这是将传递的值转换为的 Python 类型。'
- en: 'Using the Flask Restful parser, it is very easy to add new parameters to the
    API. For example, let''s add a user argument that allows us to search for all
    posts that have been made by a user. First, in the `api/blog/parsers.py` file,
    we have the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Flask Restful解析器，向API添加新参数非常简单。例如，让我们添加一个用户参数，允许我们搜索所有由用户创建的帖子。首先，在`api/blog/parsers.py`文件中，我们有以下内容：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, in the `api/blog/controllers.py` file, we have the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`api/blog/controllers.py`文件中，我们有以下内容：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When Flask's `abort` function is called from `Resource`, Flask Restful will
    automatically create an error message to be returned with the status code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当从`Resource`中调用Flask的`abort`函数时，Flask Restful将自动创建一个错误消息，并带有状态码返回。
- en: 'To test the API, we use `curl`for the sake of simplicity, but feel free to
    use any other tool available to interact with HTTP APIs. After requesting an access
    token from our authentication endpoint, request `post` with `id=1`, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化测试API，我们使用`curl`，但你可以自由使用任何其他可用的工具与HTTP API交互。在从我们的认证端点请求访问令牌后，请求`post`并使用`id=1`，如下所示：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Or you can request all posts as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以这样请求所有帖子：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that the response only fetches the first page, as intended. Now let''s
    request page two, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，响应只获取第一页，正如预期的那样。现在让我们请求第二页，如下所示：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, you can request for posts from a certain user as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以这样请求特定用户的帖子：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Post requests
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POST请求
- en: 'The `POST` methods on REST are used for resource creation, not that this isn''t
    considered an idempotent method. Using our new knowledge of the Flask Restful
    parser, we can cover the `POST` endpoint. First, we will need a parser that will
    take a title, the body text, and a list of tags. In the `parser.py` file, find
    the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: REST中的`POST`方法用于资源创建，尽管这不是一个幂等的方法。使用我们对Flask Restful解析器的新知识，我们可以处理`POST`端点。首先，我们需要一个解析器，它将接受标题、正文文本和标签列表。在`parser.py`文件中找到以下内容：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, we have created a helper function, called `add_tags_to_post`, to add tags
    to a post. If the tags don't exist, it will add them to the database. We will
    use it on `POST` and `PUT` requests. Nothing new here—just a simple SQLAlchemy
    helper function to help us keep our code concise.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个名为`add_tags_to_post`的辅助函数，用于向帖子添加标签。如果标签不存在，它将它们添加到数据库中。我们将在`POST`和`PUT`请求中使用它——这里没有新内容，只是一个简单的SQLAlchemy辅助函数，帮助我们使代码更简洁。
- en: 'Next, the `PostApi` class will need a `post` method to handle incoming requests.
    The `post` method will use the given values for the title and body text. Also,
    if the `tags` key exists, then add the tags to the post, which creates new tags
    if the passed ones do not exist, as shown in the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`PostApi`类需要一个`post`方法来处理传入的请求。`post`方法将使用给定的标题和正文文本值。如果存在`tags`键，则将标签添加到帖子中，如果传递的标签不存在，则会创建新的标签，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At the `return` statement, if a tuple is returned, the second argument is treated
    as the status code. There is also a third value that acts as extra header values
    by passing a dictionary. Also, note the `get_jwt_identity` that we use to fetch
    the user ID from the JWT token. This was set up at the login phase where we used
    the user ID to set the JWT identity.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在`return`语句中，如果返回了一个元组，第二个参数被视为状态码。还有一个第三个值，通过传递一个字典作为额外的头部值。此外，请注意我们使用的`get_jwt_identity`函数，用于从JWT令牌中获取用户ID。这是在登录阶段设置的，我们使用用户ID来设置JWT身份。
- en: 'To pass `POST` variables, the `d` flag is used, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要传递`POST`变量，使用`d`标志，如下所示：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The ID of the newly created post should be returned. If you go to the browser,
    you should see our newly created post, which was made by the user that you used
    to generate the authentication token.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 应返回新创建帖子的ID。如果你去浏览器，你应该能看到我们使用你用来生成认证令牌的用户创建的新帖子。
- en: Put requests
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PUT请求
- en: 'As listed in the table at the beginning of this chapter, `PUT` requests are
    used to change the values of an existing resource. Like the `post` method, the
    first thing that we should do is create a new parser in `parsers.py`, as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头表格中所示，`PUT`请求用于更改现有资源的值。就像`post`方法一样，我们应该做的第一件事是在`parsers.py`中创建一个新的解析器，如下所示：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The logic for the `put` method is very similar to the `post` method. The main
    difference is that each change is optional and any request that does not provide
    `post_id` is denied, as shown in the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`put`方法的逻辑与`post`方法非常相似。主要区别是每个更改都是可选的，任何不提供`post_id`的请求都会被拒绝，如下面的代码所示：'
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Also note that, just as we did with the controller for web views, we are denying
    any request to change a blog post that was not made by the creator of the blog
    post him or herself.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，就像我们对待网页视图控制器一样，我们拒绝任何非博客文章创作者本人提出的更改博客文章的请求。
- en: 'To test this method, `curl` can also create `PUT` requests with the `-X` flag,
    as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个方法，`curl` 也可以使用 `-X` 标志创建 `PUT` 请求，如下所示：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Delete requests
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除请求
- en: 'Finally, in the following code we have the `DELETE` request, which is the simplest
    of the four supported methods. The main difference with the `delete` method is
    that it returns no content, which is the accepted standard with `DELETE` requests:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在下面的代码中，我们有 `DELETE` 请求，这是四种支持的方法中最简单的一个。与 `delete` 方法的主要区别是它不返回任何内容，这是 `DELETE`
    请求的接受标准：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Again, we can test using the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，我们可以使用以下方法进行测试：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If everything is successfully deleted, you should receive a `204` status code
    and nothing should show up.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切删除成功，你应该收到 `204` 状态码，并且不应该有任何内容显示。
- en: Before we move on from REST completely, there is one final challenge for you
    to test your understanding of Flask Restful. Try to create a comments API that
    is not only modifiable from `http://localhost:5000/api/comments`, but that also
    allows developers to modify only those comments on a specific post by using the
    URL format `http://localhost:5000/api/post/<int:post_id>/comments`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完全离开 REST 之前，有一个最后的挑战要测试你对 Flask Restful 的理解。尝试创建一个 API，不仅可以从 `http://localhost:5000/api/comments`
    进行修改，而且允许开发者通过使用 URL 格式 `http://localhost:5000/api/post/<int:post_id>/comments`
    仅修改特定文章的评论。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Our `Post` API is now a complete feature. If a developer wants, then they can
    create a desktop or mobile application using this API, all without using HTML
    scraping, which is a very long and tedious process. Giving the developers who
    wish to use your website as a platform the ability to do so will increase your
    site's popularity, as they will essentially give you free advertising with their
    app or website.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Post` API 现在已经是一个完整的特性。如果开发者想的话，他们可以使用这个 API 创建桌面或移动应用程序，而无需使用 HTML 抓取，这是一个非常漫长且繁琐的过程。给那些希望将你的网站作为平台使用的开发者提供这样的能力，将增加你网站的知名度，因为他们实际上会通过他们的应用程序或网站给你提供免费广告。
- en: In the next chapter, we will use the popular program Celery to run programs
    and tasks asynchronously with our application.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用流行的程序 Celery 来异步运行程序和任务，与我们的应用程序一起使用。
