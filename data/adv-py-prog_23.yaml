- en: '*Chapter 20*: The Decorator Pattern'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第20章*：装饰器模式'
- en: As we saw in the previous chapter, using an **adapter**, the first structural
    design pattern, you can adapt an object implementing a given interface to implement
    another interface. This is called **interface** **adaptation** and includes the
    kinds of patterns that encourage composition over inheritance, and it could bring
    benefits when you have to maintain a large codebase.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，使用**适配器**，第一个结构化设计模式，你可以将实现给定接口的对象适配到实现另一个接口。这被称为**接口****适配**，包括那些鼓励组合而非继承的模式的种类，这在你需要维护大型代码库时可能会带来好处。
- en: 'A second interesting structural pattern to learn about is the **decorator**
    pattern, which allows us to add responsibilities to an object dynamically and
    transparently (without affecting other objects); this will be the topic of this
    chapter. Throughout our discussions, we will learn more about a specific usage
    of this design pattern: **memoization**.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得学习的有趣的结构模式是**装饰器**模式，它允许我们动态且透明地（不影响其他对象）地向对象添加职责；这将是本章的主题。在我们讨论的过程中，我们将了解更多关于这个设计模式的具体用法：**记忆化**。
- en: 'We will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论以下主题：
- en: Introducing the decorator pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍装饰器模式
- en: Real-world examples
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现实世界示例
- en: Use cases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例
- en: Implementation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be accessed through this link: [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter20](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter20).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以通过此链接访问：[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter20](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter20)。
- en: Introducing the decorator pattern
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍装饰器模式
- en: As Python developers, we can write decorators in a `func_in`, as input and returns
    another function object, `func_out`. It is a commonly used technique for extending
    the behavior of a function, method, or class.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Python开发者，我们可以在`func_in`中编写装饰器，作为输入并返回另一个函数对象`func_out`。这是一种常用的技术，用于扩展函数、方法或类的行为。
- en: But this feature should not be completely new to you. We have already seen how
    to use the built-in `property` decorator, which makes a method appear as a variable
    in both [*Chapter 16*](B17499_16_Final_SS_ePub.xhtml#_idTextAnchor276), *The Factory
    Pattern*, and [*Chapter 17*](B17499_17_Final_SS_ePub.xhtml#_idTextAnchor289),
    *The Builder Pattern*. There are also several other useful built-in decorators
    in Python. In the *Implementation* section of this chapter, we will learn how
    to implement and use our own decorators.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个特性不应该对你来说完全陌生。我们已经在[*第16章*](B17499_16_Final_SS_ePub.xhtml#_idTextAnchor276)，“工厂模式”，和[*第17章*](B17499_17_Final_SS_ePub.xhtml#_idTextAnchor289)，“建造者模式”中看到了如何使用内置的`property`装饰器，它使得一个方法在两种模式中都可以像变量一样出现。Python中还有几个其他有用的内置装饰器。在本章的*实现*部分，我们将学习如何实现和使用我们自己的装饰器。
- en: Note that there is no one-to-one relationship between the decorator pattern
    and Python's decorator feature. Python decorators can actually do much more than
    the decorator pattern. One of the things they can be used for is to implement
    the decorator pattern ([j.mp/moinpydec](http://j.mp/moinpydec)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，装饰器模式与Python的装饰器特性之间没有一对一的关系。Python装饰器实际上可以做比装饰器模式更多的事情。它们可以用作实现装饰器模式的事情之一([j.mp/moinpydec](http://j.mp/moinpydec))。
- en: Now, let's discuss some examples where the decorator pattern applies.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一些适用装饰器模式的示例。
- en: Real-world examples
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现实世界示例
- en: The decorator pattern is generally used for extending the functionality of an
    object. In everyday life, examples of functionality extensions are adding a holder
    stand to a phone or using different camera lenses.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式通常用于扩展对象的功能。在日常生活中，功能扩展的例子包括给手机添加支架或使用不同的相机镜头。
- en: 'In the Django framework, which uses decorators a lot, we have the `View` decorators,
    which can be used for the following ([j.mp/djangodec](http://j.mp/djangodec)):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在大量使用装饰器的Django框架中，我们有`View`装饰器，它可以用于以下操作([j.mp/djangodec](http://j.mp/djangodec))：
- en: Restricting access to views based on the HTTP request
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据HTTP请求限制对视图的访问
- en: Controlling the caching behavior on specific views
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制特定视图的缓存行为
- en: Controlling compression on a per-view basis
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于视图控制压缩
- en: Controlling caching based on specific HTTP request headers
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据特定的HTTP请求头控制缓存
- en: 'Both the Pyramid framework and the Zope application server also use decorators
    to achieve various goals, such as the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Pyramid框架和Zope应用程序服务器也使用装饰器来实现各种目标，如下所示：
- en: Registering a function as an event subscriber
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数注册为事件订阅者
- en: Protecting a method with a specific permission
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特定权限保护方法
- en: Implementing the adapter pattern
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现适配器模式
- en: To be more concrete, we will iterate the specific use cases of the design pattern
    in the next section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更具体，我们将在下一节中迭代设计模式的具体用例。
- en: Use cases
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例
- en: 'The decorator pattern shines when used for implementing cross-cutting concerns
    ([j.mp/wikicrosscut](http://j.mp/wikicrosscut)). Examples of cross-cutting concerns
    are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于实现横切关注点时，装饰器模式特别出色（[j.mp/wikicrosscut](http://j.mp/wikicrosscut)）。横切关注点的例子如下：
- en: Data validation
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据验证
- en: Caching
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Logging
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录
- en: Monitoring
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控
- en: Debugging
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试
- en: Business rules
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务规则
- en: Encryption
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密
- en: In general, all parts of an application that are generic and can be applied
    to many different parts of it are considered to be cross-cutting concerns.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有通用的应用程序部分，可以应用于它的许多不同部分，都被认为是横切关注点。
- en: Another popular example of using the decorator pattern is **graphical user interface**
    (**GUI**) toolkits. In a GUI toolkit, we want to be able to add features such
    as borders, shadows, colors, and scrolling to individual components/widgets.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用装饰器模式的另一个流行例子是**图形用户界面**（**GUI**）工具包。在GUI工具包中，我们希望能够为单个组件/小部件添加诸如边框、阴影、颜色和滚动等特性。
- en: Now, let's move on to the implementation part of the chapter, in which we will
    see how the decorator pattern helps with memoization.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续本章的实现部分，我们将看到装饰器模式如何帮助实现缓存。
- en: Implementation
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: Python decorators are generic and very powerful. You can find many examples
    of how they can be used in the decorator library of `python.org` ([j.mp/pydeclib](http://j.mp/pydeclib)).
    In this section, we will see how we can implement a memoization decorator ([j.mp/memoi](http://j.mp/memoi)).
    All recursive functions can benefit from memoization, so let's try a function,
    `number_sum()`, that returns the sum of the first `n` numbers. Note that this
    function is already available in the `math` module as `fsum()`, but let's pretend
    it is not.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Python装饰器是通用的且非常强大。你可以在`python.org`的装饰器库中找到许多它们如何被使用的例子（[j.mp/pydeclib](http://j.mp/pydeclib)）。在本节中，我们将看到我们如何实现一个缓存装饰器（[j.mp/memoi](http://j.mp/memoi)）。所有递归函数都可以从缓存中受益，所以让我们尝试一个函数，`number_sum()`，它返回前`n`个数的和。注意，这个函数已经在`math`模块中作为`fsum()`可用，但让我们假装它不可用。
- en: 'First, let''s look at the naive implementation (the `number_sum_naive.py` file):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看朴素实现（`number_sum_naive.py` 文件）：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A sample execution of this example shows how slow this implementation is. It
    takes roughly 3 seconds to calculate the sum of the first 30 numbers on a MacBook,
    which can be seen when executing the `python number_sum_naive.py` command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的样本执行显示了这种实现有多慢。在MacBook上计算前30个数的和大约需要3秒钟，这可以通过执行`python number_sum_naive.py`命令来看到：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's see whether using memoization can help us improve the performance number.
    In the following code, we use `dict` for caching the already computed sums. We
    also change the parameter passed to the `number_sum()` function. We want to calculate
    the sum of the first 300 numbers instead of only the first 30.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用缓存是否可以帮助我们提高性能。在下面的代码中，我们使用`dict`来缓存已计算的和。我们还更改了传递给`number_sum()`函数的参数。我们想要计算前300个数的和，而不仅仅是前30个。
- en: 'Here is the new version of the code, using memoization:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用缓存的新代码版本：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Executing the memoization-based code shows that performance improves dramatically
    and is acceptable even for computing large values.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 执行基于缓存的代码显示性能显著提高，即使是计算大数值也是可接受的。
- en: 'A sample execution, using `python number_sum.py`, is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`python number_sum.py`执行的样本执行如下：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But there are already a few problems with this approach. While the performance
    is not an issue any longer, the code is not as clean as it is when not using memoization.
    And what happens if we decide to extend the code with more math functions and
    turn it into a module? We can think of several functions that would be useful
    for our module, for problems such as Pascal's triangle or the Fibonacci numbers
    suite algorithm.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种方法已经存在一些问题。虽然性能不再是问题，但代码的整洁性不如不使用记忆化时。如果我们决定扩展代码以包含更多的数学函数并将其转变为一个模块，会发生什么呢？我们可以想到几个对我们模块有用的函数，例如帕斯卡三角形或斐波那契数列算法问题。
- en: 'So, if we wanted a function in the same module as `number_sum()`, for the Fibonacci
    numbers suite, using the same memoization technique, we would add code that looks
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想在同一个模块中创建一个与`number_sum()`相同的函数，用于斐波那契数列，并使用相同的记忆化技术，我们会添加如下代码：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Do you notice the problem already? We ended up with a new `dict` called `cache_fib`,
    which acts as our cache for the `fibonacci()` function, and a function that is
    more complex than it would be without using memoization. Our module is becoming
    unnecessarily complex. Is it possible to write these functions keeping them as
    simple as the naive versions, but achieving performance similar to the performance
    of the functions that use memoization?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经注意到这个问题了吗？我们最终得到了一个新的`dict`，名为`cache_fib`，它作为我们的`fibonacci()`函数的缓存，以及一个比不使用记忆化更复杂的函数。我们的模块正变得不必要地复杂。是否有可能编写这些函数，使它们尽可能简单，但又能达到使用记忆化函数的性能？
- en: Fortunately, it is, and the solution is to use the decorator pattern.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，确实如此，解决方案是使用装饰器模式。
- en: 'First, we create a `memoize()` decorator, as shown in the following example.
    Our decorator accepts the `fn` function, which needs to be memoized, as an input.
    It uses `dict` named `cache` as the cached data container. The `functools.wraps()`
    function is used for convenience when creating decorators. It is not mandatory
    but a good practice to use it since it makes sure that the documentation, and
    the signature of the function that is decorated, is preserved ([j.mp/funcwraps](http://j.mp/funcwraps)).
    The `*args` argument list is required in this case because the functions that
    we want to decorate accept input arguments (such as the `n` argument for our two
    functions):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`memoize()`装饰器，如下面的示例所示。我们的装饰器接受需要记忆化的`fn`函数作为输入。它使用名为`cache`的`dict`作为缓存数据容器。`functools.wraps()`函数用于在创建装饰器时方便使用。虽然不是强制性的，但使用它是良好的实践，因为它确保了装饰的函数的文档和签名被保留（[j.mp/funcwraps](http://j.mp/funcwraps)）。在这种情况下，`*args`参数列表是必需的，因为我们想要装饰的函数接受输入参数（例如我们两个函数的`n`参数）：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we can use our `memoize()` decorator with the naive version of our functions.
    This has the benefit of readable code without performance impact. We apply a decorator
    using what is known as decoration (or a decoration line). A decoration uses the
    `@name` syntax, where `name` is the name of the decorator that we want to use.
    It is nothing more than syntactic sugar for simplifying the usage of decorators.
    We can even bypass this syntax and execute our decorator manually, but that is
    left as an exercise for you.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们的`memoize()`装饰器与函数的原始版本一起使用。这的好处是代码可读性高，而不会影响性能。我们使用所谓的装饰（或装饰行）来应用装饰器。装饰使用`@name`语法，其中`name`是我们想要使用的装饰器的名称。这不过是一种语法糖，用于简化装饰器的使用。我们甚至可以绕过这种语法并手动执行装饰器，但这留给你作为练习。
- en: 'So, the `memoize()` decorator can be used with our recursive functions as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`memoize()`装饰器可以按照以下方式与我们的递归函数一起使用：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the last part of the code, via the `main()` function, we show how to use
    the decorated functions and measure their performance. The `to_execute` variable
    is used to hold a list of tuples containing the reference to each function and
    the corresponding `timeit.Timer()` call (to execute it while measuring the time
    spent), thus avoiding code repetition. Note how the `__name__` and `__doc__` method
    attributes show the proper function names and documentation values, respectively.
    Try removing the `@functools.wraps(fn)` decoration from `memoize()`, and see whether
    this is still the case.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的最后部分，通过`main()`函数，我们展示了如何使用装饰过的函数并测量它们的性能。`to_execute`变量用于保存一个包含每个函数引用和相应的`timeit.Timer()`调用的元组列表（在测量时间的同时执行），从而避免代码重复。注意`__name__`和`__doc__`方法属性分别显示了正确的函数名称和文档值。尝试从`memoize()`中移除`@functools.wraps(fn)`装饰，看看是否仍然如此。
- en: 'Here is the last part of the code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的最后部分：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s recapitulate how we write the complete code of our math module (the
    `mymath.py` file):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下如何编写我们数学模块的完整代码（`mymath.py`文件）：
- en: After the import of Python's `functools` module that we will be using, we define
    the `memoize()` decorator function.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入我们将要使用的Python的`functools`模块之后，我们定义了`memoize()`装饰器函数。
- en: Then, we define the `number_sum()` function, decorated using `memoize()`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了`number_sum()`函数，并使用`memoize()`进行了装饰。
- en: We also define the `fibonacci()` function, as decorated.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还定义了`fibonacci()`函数，并对其进行了装饰。
- en: Finally, we add the `main()` function, as shown earlier, and use the usual trick
    to call it.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加了前面展示的`main()`函数，并使用通常的技巧来调用它。
- en: 'Here is a sample output when executing the `python mymath.py` command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`python mymath.py`命令时，这是一个示例输出：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: (The execution times might differ in your case.)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: （执行时间可能因情况而异。）
- en: At this point, we end up with readable code and acceptable performance. Now,
    you might argue that this is not the decorator pattern, since we don't apply it
    at runtime. The truth is that a decorated function cannot be undecorated, but
    you can still decide at runtime whether the decorator will be executed or not.
    That's an interesting exercise left for you.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们得到了可读的代码和可接受的性能。现在，你可能会争辩说这并不是装饰器模式，因为我们没有在运行时应用它。事实是，装饰过的函数不能被去装饰，但你仍然可以在运行时决定装饰器是否执行。这是一个有趣的练习，留给你。
- en: Note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Use a decorator that acts as a wrapper, which decides whether or not the real
    decorator is executed based on some condition.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个充当包装器的装饰器，它根据某些条件决定是否执行真正的装饰器。
- en: 'Another interesting property of decorators not covered in this chapter is that
    you can decorate a function with more than one decorator. So, here''s another
    exercise: create a decorator that helps you to debug recursive functions, apply
    it to `number_sum()` and `fibonacci()`, and finally, determine the order in which
    the multiple decorators are executed.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 本章未涵盖的装饰器的另一个有趣特性是，你可以用多个装饰器装饰一个函数。所以，这里有一个练习：创建一个帮助调试递归函数的装饰器，将其应用于`number_sum()`和`fibonacci()`，并最终确定多个装饰器执行的顺序。
- en: Summary
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter covered the decorator pattern and its relationship to the Python
    programming language. We used the decorator pattern conveniently to extend the
    behavior of an object without using inheritance. Python, with its built-in decorator
    feature, extends the decorator concept even more, by allowing us to extend the
    behavior of any callable (function, method, or class) without using inheritance
    or composition.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了装饰器模式及其与Python编程语言的关系。我们方便地使用了装饰器模式来扩展对象的行为，而不使用继承。Python通过其内置的装饰器功能，甚至进一步扩展了装饰器概念，允许我们扩展任何可调用对象（函数、方法或类）的行为，而不使用继承或组合。
- en: We have seen a few examples of real-world objects that are decorated, such as
    cameras. From a software point of view, both Django and Pyramid use decorators
    to achieve different goals, such as controlling HTTP compression and caching.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些装饰过的现实世界对象的例子，例如相机。从软件的角度来看，Django和Pyramid都使用装饰器来实现不同的目标，例如控制HTTP压缩和缓存。
- en: 'The decorator pattern is a great solution for implementing cross-cutting concerns
    because they are generic and do not fit well into the OOP paradigm. We mentioned
    several categories of cross-cutting concerns in the *Use cases* section. In fact,
    in the *Implementation* section, a cross-cutting concern was demonstrated: memoization.
    We saw how decorators can help us to keep our functions clean, without sacrificing
    performance.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式是实现横切关注点的一个很好的解决方案，因为它们是通用的，并且不适合很好地融入面向对象范式。我们在*用例*部分提到了几个横切关注点的类别。实际上，在*实现*部分，我们演示了一个横切关注点：记忆化。我们看到了装饰器如何帮助我们保持函数的整洁，同时不牺牲性能。
- en: The next chapter covers the bridge pattern.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍桥接模式。
- en: Questions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the main motivation for the decorator pattern?
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 装饰器模式的主要动机是什么？
- en: Why is the decorator pattern particularly relevant in Python?
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么装饰器模式在Python中特别相关？
- en: How does the decorator pattern help with memoization?
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 装饰器模式如何帮助实现记忆化？
