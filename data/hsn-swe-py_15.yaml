- en: Anatomy of a Service
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务的解剖结构
- en: The next logical chunk of functionality to attack in `hms_sys` is the Artisan
    Gateway Service. This service waits for input from either Artisan or Central Office
    end users, creating or updating object data as needed, and perhaps synchronizing
    that data with the web store system's database. Both of the end user applications
    are expected to communicate with the Artisan Gateway Service on a completely random
    basis; whenever someone wants to make a change to the data, it'll be ready and
    waiting to process that request.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在`hms_sys`中攻击的下一个逻辑功能块是Artisan Gateway服务。该服务等待来自Artisan或中央办公室最终用户的输入，根据需要创建或更新对象数据，并可能将该数据与网络商店系统的数据库同步。预计两个最终用户应用程序将完全随机地与Artisan
    Gateway服务通信；每当有人想要更改数据时，它都会准备好并等待处理该请求。
- en: 'Before we can really implement this service, however, we need to work out how
    any service can or should work, written in Python. To that end, we will have to
    examine and understand the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们真正实现这项服务之前，我们需要解决任何服务可以或应该如何在Python中编写的问题。为此，我们将不得不检查和理解以下内容：
- en: 'The basic implementation of the structure of a service, including the following:'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务结构的基本实现，包括以下内容：
- en: Options for managing the configuration of a service instance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理服务实例配置的选项
- en: How a service can read and respond to requests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何服务可以读取并响应请求
- en: 'How and when a service is launched in the following environments:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务在以下环境中如何启动和何时启动：
- en: A reasonably modern, POSIX-compliant system (Linux, for example)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个相当现代的、符合POSIX标准的系统（例如Linux）
- en: Windows
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows
- en: Whether there are other, better designs that will work in any OS that Python
    is available on
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有其他更好的设计，可以在Python可用的任何操作系统上运行
- en: In order to better understand these facets of the implementation and execution
    of a service, we'll build a basic service structure from the ground up, which
    can then be used as a foundation for the final Artisan Gateway Service.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解服务的实现和执行的这些方面，我们将从头开始构建一个基本的服务结构，然后可以将其用作最终的Artisan Gateway服务的基础。
- en: What is a service?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是服务？
- en: Services, at their most basic, are simply programs that run in the background
    on a computer. They typically wait for input from somewhere, perform some actions
    based on that input, and return data that, at a minimum, indicates that the actions
    that were undertaken either succeeded or failed. At the most basic level, the
    input might not even be something that is visible to a user; services that wait
    for network activities, monitor filesystems, or even just run on some sort of
    timer-controlled basis, are very common in many operating systems today.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 服务在最基本的层面上只是在计算机后台运行的程序。它们通常等待来自某个地方的输入，根据该输入执行一些操作，并返回数据，至少表明所采取的操作是成功还是失败。在最基本的层面上，输入甚至可能不是对用户可见的东西；等待网络活动、监视文件系统，甚至只是在某种定时控制的基础上运行的服务，在今天的许多操作系统中都很常见。
- en: 'Services should always be available, running continuously, for as long as the
    host machine is running; this has some implications for how they are written and
    implemented, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 服务应始终可用，持续运行，只要主机机器正在运行；这对于它们的编写和实现有一些影响，如下所示：
- en: 'They have to be very fault-tolerant: a service that crashes and dies every
    time something unexpected happens, and has to be restarted as a result, is of
    little use.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们必须非常容错：每当发生意外情况时崩溃并死机的服务，并且必须因此重新启动，是没有什么用的。
- en: They should, arguably, be as functionally self-contained as is possible; external
    dependencies that could fail (and cause a running service to crash as a result)
    should be examined with a critical eye.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们应该尽可能是功能上自包含的；可能会失败的外部依赖项（并导致运行中的服务崩溃）应该受到严格的审视。
- en: Because their operations may be completely invisible to the user, there is a
    lot of potential for a poorly designed or implemented service to overrun system
    resources, which could eventually take down an entire machine. Even if there is
    no multi-processing involved, care needs to be taken and discipline exercised,
    in order to avoid things such as loops that never terminate or functionality that
    leaves orphan objects, data, or functions in memory. If these occur, it's just
    a matter of time (or load on the service) until the memory or available CPU dwindles
    to nothing.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为它们的操作可能对用户完全不可见，所以设计不良或实现不良的服务可能会占用系统资源，最终可能导致整个机器崩溃。即使没有涉及多处理，也需要小心和纪律，以避免诸如永不终止的循环或将孤立对象、数据或功能留在内存中的功能等问题。如果发生这些情况，只是时间问题（或服务的负载），直到内存或可用CPU减少到零。
- en: Service structure
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务结构
- en: 'All that said, services aren''t necessarily all that complex. If there are
    operating system facilities available to manage the actual code execution (startup
    and shutdown), they might not be any more complex, structurally, than the following
    code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，服务并不一定非常复杂。如果有操作系统设施可用于管理实际的代码执行（启动和关闭），它们在结构上可能并不比以下代码更复杂：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When the preceding code is run, it generates no user-visible output, but watching
    the system logs (using `tail -f /var/log/syslog`, on a Linux machine) shows that
    it is doing what it''s supposed to, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行前面的代码时，它不会生成用户可见的输出，但是观察系统日志（在Linux机器上使用`tail -f /var/log/syslog`）会显示它正在按预期进行操作，如下所示：
- en: It writes the starting message to the log file before entering the main loop.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进入主循环之前，它将启动消息写入日志文件。
- en: 'In each pass through the loop, it does the following:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每次循环中，它执行以下操作：
- en: Writes a message to the log, with the iteration number
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将带有迭代号的消息写入日志
- en: Sleeps for 10 seconds
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 休眠10秒
- en: Increments the iteration counter
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加迭代计数器
- en: 'The exiting message is not being written to the log file, but that''s expected
    at this point, since the only way to stop the main loop is to kill the program
    itself, and that terminates the program without exiting the loop. A typical log
    output, from startup through a few iterations, looks as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 退出消息没有被写入日志文件，但这在这一点上是预期的，因为停止主循环的唯一方法是终止程序本身，这将终止程序而不退出循环。从启动到几次迭代的典型日志输出如下：
- en: '![](assets/dca94723-260b-4259-8c2e-6b36f357ca94.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dca94723-260b-4259-8c2e-6b36f357ca94.png)'
- en: This isn't much of a service, to be sure, but it illustrates what might be considered
    the bare minimum of the functionality that would be common to any service.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然不是一个服务，但它说明了可能被认为是任何服务共同功能的最低限度。
- en: 'At the heart of most services is a loop that runs until the service is shut
    down or killed. Within that loop is where the service will actually check for
    input, in one of several ways. Some of the more common variants include the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数服务的核心是一个循环，直到服务被关闭或终止。在循环中，服务将实际检查输入，有几种方式。一些更常见的变体包括以下内容：
- en: It could be waiting on a request coming in over a network socket (a web service
    would use this approach).
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以等待通过网络套接字传入的请求（Web服务将使用此方法）。
- en: It could be waiting on incoming data from standard input (`stdin`).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以等待来自标准输入（stdin）的传入数据。
- en: It could actively poll for incoming messages from an external queue system,
    such as RabbitMQ, or cloud-based equivalents, such as AWS's SQS or Google Cloud
    Platform's Cloud Pub/Sub.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以主动轮询来自外部队列系统的传入消息，例如RabbitMQ，或基于云的等效系统，例如AWS的SQS或Google Cloud Platform的Cloud
    Pub/Sub。
- en: These are only a few of the possibilities for service input. Other mechanisms
    that don't lend themselves to a direct waiting-for-something model could always
    push events into a local queue, and have the service watching or polling from
    that queue mechanism.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是服务输入的一些可能性。其他机制不适合直接等待某些模型的事件，可以将事件推送到本地队列，并让服务从该队列机制中观察或轮询。
- en: 'In all but the most basic of services, incoming requests will have to be evaluated,
    to determine what functionality has to be called in order to handle the request.
    The most common mechanism for associating incoming request data to a specific
    functionality is probably a large `if…elif…else` structure that passes the responsibility
    for handling a request to specific and dedicated functions, looking something
    like the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最基本的服务外，传入的请求将需要进行评估，以确定必须调用哪些功能来处理请求。将传入请求数据与特定功能相关联的最常见机制可能是一个大的`if…elif…else`结构，将处理请求的责任传递给特定和专用功能，看起来像以下内容：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each of the `handle_{something}_request` functions, then, would be responsible
    for taking the incoming request, determining what to do with it, and returning
    the resultant data.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个`handle_{something}_request`函数将负责处理传入的请求，确定如何处理它，并返回结果数据。
- en: 'There is a standard Python library, `python-daemon`, that takes this basic
    approach a step further, allowing a function to be wrapped in a basic daemon context.
    The same basic function, with a `python-daemon DaemonContext` wrapped around it,
    is very similar, and is shown in the following snippet:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个标准的Python库`python-daemon`，它进一步采用了这种基本方法，允许将函数包装在基本的守护程序上下文中。相同的基本函数，使用`python-daemon
    DaemonContext`包装，非常相似，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The terms **service** and **daemon** are, for the purposes of this book, interchangeable;
    they both refer to the same sort of background process program.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**服务**和**守护程序**在本书中是可以互换的；它们都指的是同一种后台进程程序。
- en: 'The execution of this code yields almost identical results (barring the filename
    that appears in the log messages, it is identical, in fact). The actual differences
    are effectively invisible, once the daemon code is running. Using `DaemonContext`
    provides some operational aspects that the bare-bones, function-only code does
    not deal with, which are considered to be best practices for daemon processes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码产生几乎相同的结果（除了在日志消息中出现的文件名，实际上是相同的）。一旦守护进程代码运行，实际的差异基本上是看不见的。使用`DaemonContext`提供了一些操作方面，这些操作方面是裸骨的，仅处理功能的代码所不涉及的，这被认为是守护进程进程的最佳实践：
- en: Assuring that any open files associated with the command during startup get
    closed
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在启动期间与命令相关联的任何打开文件都被关闭
- en: Changing the working directory for the process to a known and/or secure directory
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将进程的工作目录更改为已知和/或安全的目录
- en: Setting the file-creation permissions mask, so that the files created by the
    processes will have a known (and securable) permissions set
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置文件创建权限掩码，以便进程创建的文件将具有已知（且可安全）的权限设置
- en: Performing system-level process setup, to allow the process itself to run in
    the background
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行系统级进程设置，以允许进程本身在后台运行
- en: Dissociating the process from any Terminal activity, so that it won't respond
    to Terminal input once the daemon process is launched
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将进程与任何终端活动分离，以便在启动守护进程进程后不响应终端输入
- en: Although `python-daemon` is a standard library, it may not be part of a standard
    Python installation. If not, it can be installed with `pip install python-daemon`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`python-daemon`是一个标准库，但它可能不是标准Python安装的一部分。如果不是，可以使用`pip install python-daemon`进行安装。
- en: The `python-daemon` module, then, provides a very easy way to manage a lot of
    the best-practice operations for writing daemons and services. There is, however,
    a potential problem with using it. It won't work on systems that don't have a
    Unix-like password database (it depends on the `pwd` module, which is Unix-only).
    That rules it out for services that need to run on Windows systems, at the very
    least.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`python-daemon`模块提供了一种非常简单的方法来管理编写守护程序和服务的最佳实践操作。但是，使用它可能存在潜在问题。它不适用于没有类Unix密码数据库的系统（它依赖于`pwd`模块，仅适用于Unix）。至少对于需要在Windows系统上运行的服务，这将排除它。
- en: Ultimately, though, knowing that a service implementation doesn't have to be
    much more than a single function call with a perpetual loop, the main concern (outside
    of the implementation of the service's logic) is probably how to get the host
    operating system to start, stop, and manage the service instance. We'll examine
    that in considerably more detail at the end of the chapter, but there are a few
    other common service implementation patterns and concerns that bear some examination,
    first.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，知道服务实现不必多于一个永久循环的单个函数调用，主要关注点（除了服务逻辑的实现）可能是如何让主机操作系统启动、停止和管理服务实例。我们将在本章末尾更详细地讨论这一点，但首先需要检查一些其他常见的服务实现模式和关注点。
- en: Configuration
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: 'Services frequently have to be configurable without making changes to the actual
    service code, so that the end users or managers of active services don''t have
    to be developers themselves, in order to be able to effectively manage running
    service instances. There are several options that can be used to read configuration
    and setting values from files, each with its own strengths and weaknesses. In
    order to better compare and contrast them, let''s examine the variations that
    provide the configuration for a service that does the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 服务经常需要进行配置，而不必更改实际的服务代码，以便最终用户或活动服务的管理者不必自己成为开发人员，就能有效地管理运行的服务实例。有几种选项可用于从文件中读取配置和设置值，每种都有其自身的优势和劣势。为了更好地进行比较和对比，让我们检查一下提供以下服务配置的变化：
- en: 'Logs information, warning, error, and critical level messages:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录信息、警告、错误和严重级别的消息：
- en: Information and warning level messages to a console
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向控制台输出信息和警告级别的消息
- en: Everything, including information and warning level messages, to a single, common
    log file, whose location is configurable
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有信息，包括信息和警告级别的消息，都记录到一个单一的通用日志文件中，其位置是可配置的
- en: 'Listens for input messages from a queue service, such as RabbitMQ, or a cloud-based
    queue service, such as AWS''s SQS or Google Cloud Platform''s Pub/Sub, and needs
    to know the following:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听来自队列服务的输入消息，例如RabbitMQ，或者基于云的队列服务，例如AWS的SQS或Google Cloud Platform的Pub/Sub，并且需要知道以下内容：
- en: A queue name or URL to listen to
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要监听的队列名称或URL
- en: How often to check for incoming messages
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多久检查一次传入消息
- en: The credentials for access to the queue in question
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问所讨论队列的凭据
- en: Windows-style .ini files
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows风格的.ini文件
- en: 'Python has a standard package for working with INI files (or, at least, files
    that are similar to basic Windows INI files): `configparser`. A compatible INI-like
    file that provides the configuration for previously listed items might look something
    such as the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个用于处理INI文件（或者至少类似于基本Windows INI文件的文件）的标准包：`configparser`。一个兼容的类似INI的文件，提供了先前列出的项目的配置，可能看起来像以下内容：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Some of the advantages of an INI-style configuration file include the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: INI风格配置文件的一些优点包括以下内容：
- en: The file structure allows for comments to be used. Any line starting with a
    `#` or `;` is a comment, and is not parsed, which allows for configuration files
    to be documented inline.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件结构允许使用注释。任何以`#`或`;`开头的行都是注释，不会被解析，这允许在配置文件中进行内联文档。
- en: Values specified in the `[DEFAULT]` section are inherited by all of the other
    sections, and are available as specified originally, or to be overridden in later
    sections.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`[DEFAULT]`部分指定的值会被所有其他部分继承，并且按照最初指定的方式可用，或者在后续部分中进行覆盖。
- en: The format itself has been around for a long time, so it's very mature and stable.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该格式本身已经存在很长时间，因此非常成熟和稳定。
- en: 'This configuration file''s values can be examined with a simple script, listing
    the available values in each configuration section and showing some of the potential
    disadvantages of the format, as parsed with `configparser` tools:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用一个简单的脚本检查此配置文件的值，列出每个配置部分中的可用值，并显示使用`configparser`工具解析的格式的一些潜在缺点：
- en: '![](assets/652d2502-74c7-4453-a560-6cb446c03c9f.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/652d2502-74c7-4453-a560-6cb446c03c9f.png)'
- en: The script that generated this output is in the code for *Iteration 3*, at `hms-gateway/scratch-space/configuration-examples/ini_config.py`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 生成此输出的脚本位于*Iteration 3*的代码中，位于`hms-gateway/scratch-space/configuration-examples/ini_config.py`。
- en: 'Some of the potential disadvantages of the format include the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 该格式的一些潜在缺点包括以下内容：
- en: The values in the `[DEFAULT]` configuration section are inherited by all other
    sections, even if they are not relevant. The `queue_type` and `queue_check` values
    are available in the `console_log` and `file_log` sections, for example, where
    they aren't really relevant.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[DEFAULT]`配置部分中的值会被所有其他部分继承，即使它们与实际情况无关。例如，`queue_type`和`queue_check`值在`console_log`和`file_log`部分中是可用的，尽管它们实际上并不相关。'
- en: 'All configuration values are strings, and would probably have to be converted
    to their real value types: an `int` for `queue_check` and `rabbit_config:port`,
    probably a `list` of `str` values for `console_log:capture`, a conversion to `bool`
    values for any that might appear, and so on.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有配置值都是字符串，可能需要转换为它们的实际值类型：`int`类型的`queue_check`和`rabbit_config:port`，可能是`str`值的`list`类型的`console_log:capture`，以及可能出现的其他任何值的`bool`类型转换等。
- en: The format only really supports two levels of configuration data (sections and
    their members).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该格式实际上只支持两个级别的配置数据（部分和其成员）。
- en: None of these constraints are likely to be too problematic, though. Knowing
    that they exist is generally going to be enough to plan for how they will be accommodated,
    and the shape of that accommodation might be nothing more complicated than having
    no `[DEFAULT]` section, and grouping configuration values into more coherent sections,
    such as `logging` and `queue`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些约束可能不会太有问题。知道它们的存在通常足以计划如何对其进行适应，而适应的形式可能不会比没有`[DEFAULT]`部分更复杂，将配置值分组到更连贯的部分中，例如`logging`和`queue`。
- en: JSON files
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON文件
- en: 'JSON data structures are also a viable candidate for storing configuration
    file data. JSON supports data of different types, and complex data structures.
    Both are advantages, however trivial they might be, over the basic INI-file structure.
    There is no predefined organizational structure, though, so figuring out how configuration
    values should be grouped or organized is something that developers will have to
    give some thought to. There is also no inheritance of configuration data across
    sections, because there are no sections to inherit from. Still, it''s a simple,
    robust, and reasonably easy-to-understand option. An approximate JSON equivalent
    of the preceding INI-flavored configuration file might look something such as
    the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: JSON数据结构也是存储配置文件数据的一个可行选择。JSON支持不同类型和复杂的数据结构。这两者都是优势，尽管可能微不足道，但它们超过了基本的INI文件结构。虽然没有预定义的组织结构，但是确定配置值应该如何分组或组织是开发人员需要考虑的事情。配置数据也没有跨部分继承，因为没有可以继承的部分。尽管如此，它是一个简单、强大且相对容易理解的选项。前面的INI风格配置文件的近似JSON等效可能如下所示：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If JSON has any disadvantages (with respect to its use as a configuration-file
    format), they'd include the fact that there isn't a good way to allow in-file
    comments. The `load` and `loads` functions provided by Python's `json` module (for
    converting a JSON string and a JSON file, respectively) raise an error, `JSONDecodeError`,
    if there is anything other than data structure in the JSON data being parsed.
    That's not a deal-breaker, but there are definitely advantages to having the ability
    to add comments (and thus, documentation) to a configuration file, especially
    if that configuration is going to be managed by someone that isn't a developer,
    or isn't willing (or able) to dig into the code itself, in order to work out how
    to configure some aspect of a system.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果JSON有任何缺点（就其作为配置文件格式的使用而言），它们可能包括没有好的方法允许文件内注释。Python的`json`模块提供的`load`和`loads`函数（分别用于转换JSON字符串和JSON文件）如果在解析JSON数据时除了数据结构之外还有其他内容，会引发错误`JSONDecodeError`。这并不是致命问题，但是在配置文件中添加注释（因此，文档）的能力确实有很多优势，特别是如果该配置将由不是开发人员或不愿意（或无法）深入代码本身以解决系统某个方面的配置的人来管理。
- en: YAML files
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAML文件
- en: 'Another good contender for configuration files is YAML. YAML acts like JSON
    in many respects, in that it provides structured and typed data representations,
    and can support complex, nested data structures. In addition, it allows for inline
    comments, and the `pyyaml` module supports hinting for data structures that would
    not be usable at all in a JSON-based approach. YAML, like Python, uses indentation
    as a structural organization mechanism, indicating (in YAML''s case) the key/value
    relationship between items. An equivalent to the preceding JSON configuration
    file (with comments, and breaking all elements (objects, list members, and so
    on) into discrete items in the file), would look  like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的配置文件候选者是YAML。YAML在许多方面类似于JSON，它提供了结构化和类型化的数据表示，并支持复杂的嵌套数据结构。此外，它允许内联注释，`pyyaml`模块支持对在基于JSON的方法中根本无法使用的数据结构进行提示。YAML像Python一样，使用缩进作为结构组织机制，指示（在YAML的情况下）项目之间的键/值关系。前面的JSON配置文件的等效形式（带有注释，并将所有元素（对象、列表成员等）分解为文件中的离散项）可能如下所示：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We'll build on the idea of using YAML to configure a service later in this chapter.
    YAML obviously isn't the only option, but it's one of the better ones, allowing
    for a good combination of ease of understanding, the ability to comment/document,
    and the availability of more than one value type.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面继续讨论使用YAML配置服务的想法。显然，YAML并不是唯一的选择，但它是更好的选择之一，允许很好地结合易于理解、注释/文档的能力以及多个值类型的可用性。
- en: Logging service activities
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录服务活动
- en: 'Since services often run invisibly, in the background, they usually log their
    activities in some fashion, if only to provide some visibility into what happened
    during a service call where something went awry. Python provides a module, `logging`,
    that allows for a lot of flexibility for logging events and messages from a running
    program. The following is a very simple, brute-force example of a reasonably complete
    logging process:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务通常在后台不可见地运行，它们通常以某种方式记录其活动，即使只是为了提供对服务调用期间发生的事情的一些可见性。Python提供了一个`logging`模块，允许从运行中的程序记录事件和消息的灵活性。以下是一个非常简单、蛮力的完整记录过程的例子：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When executed, the preceding script generates the following log output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，前面的脚本会生成以下日志输出：
- en: '![](assets/d327f806-4d00-4481-a03f-48c932ce127a.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d327f806-4d00-4481-a03f-48c932ce127a.png)'
- en: 'A Python `Logger` object (which is what''s returned by the `getLogger` call)
    can be set up to pay attention to log messages of varying priority levels. In
    order from the least to the most critical (from a production-system standpoint),
    the default levels available (and some typical uses for them) are as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`Logger`对象（由`getLogger`调用返回）可以设置为关注不同优先级级别的日志消息。从最不重要到最重要（从生产系统的角度来看），可用的默认级别（以及它们的一些典型用途）如下：
- en: '`DEBUG`: Recording information about processes as they run, steps they undertake,
    and the like, with an eye toward providing some visibility into the details of
    how the code was executed.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEBUG`：记录进程运行时的信息、它们所采取的步骤等，以便提供对代码执行细节的一些可见性。'
- en: '`INFO`: Informational items, such as the start and end times of request-handling
    processes; and perhaps details or metrics on the processes themselves, such as
    what arguments were passed, or if a given execution took longer than expected,
    but still completed.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INFO`：信息项，例如请求处理过程的开始和结束时间；也许还有关于进程本身的详细信息或指标，例如传递了什么参数，或者给定的执行时间比预期长，但仍然完成了。'
- en: '`WARNING`: Conditions that didn''t prevent processes or operations from completing,
    but that were suspect for some reason, such as taking a lot longer than expected
    to complete.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WARNING`：并未阻止进程或操作完成，但因某种原因可疑的条件，例如完成时间远远超出预期。'
- en: '`ERROR`: Actual errors that were encountered as the code executed, perhaps
    including detailed trace-back information that would help a developer figure out
    what actually caused the error in question.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ERROR`：代码执行时遇到的实际错误，可能包括详细的回溯信息，可帮助开发人员找出实际导致错误的原因。'
- en: '`CRITICAL`: Recording information that was intercepted before a critical/fatal
    failure of the running code – something that actually killed the execution. In
    well-designed and implemented code, especially for a service that is intended
    to always be available, this level of message recording should rarely be needed.
    Errors would be captured and logged as `ERROR`-level items, any cleanup that would
    be required after the error was encountered would be undertaken, a response indicating
    that an error occurred would be sent back to the requester, and the service would
    just keep going, waiting for the next request.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CRITICAL`：记录在运行代码发生关键/致命故障之前拦截的信息 - 实际上导致执行终止的东西。在设计良好且实施良好的代码中，特别是对于始终可用的服务，很少需要记录此级别的消息。错误将被捕获并记录为`ERROR`级别的项目，错误发生后需要进行任何清理，将会进行，将发送一个指示发生错误的响应给请求者，服务将继续等待下一个请求。'
- en: The actual handling and recording of the messages of any given level are controlled
    by the `Logger` object, and/or by its various handlers. The `Logger` object itself
    will not accept messages with a priority lower than its set priority. Having `logger.setLevel(logging.DEBUG)` in
    the example code would allow any of the standard message priorities, while changing
    it to `logger.setLevel(logging.ERROR)` would only allow `ERROR` and `CRITICAL`
    messages to be accepted. Similarly, the handlers will ignore any incoming messages
    that fall below the priority they've been configured to accept – `file_handler.setLevel(logging.DEBUG)`, in
    the previous example.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 任何给定级别的消息的实际处理和记录由`Logger`对象及/或其各种处理程序控制。`Logger`对象本身不会接受优先级低于其设置的优先级的消息。在示例代码中使用`logger.setLevel(logging.DEBUG)`将允许任何标准消息优先级，而将其更改为`logger.setLevel(logging.ERROR)`将仅允许接受`ERROR`和`CRITICAL`消息。同样，处理程序将忽略任何低于其配置接受的优先级的传入消息
    - 在上一个示例中使用`file_handler.setLevel(logging.DEBUG)`。
- en: 'By combining detailed logging in the code itself, including `DEBUG`-level items
    wherever it is necessary, and some configuration of the allowed message-priorities,
    the same code can fine-tune its own log output for different environments. For
    example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在代码本身中结合详细的日志记录，包括在必要时使用`DEBUG`级别的项目，并对允许的消息优先级进行一些配置，相同的代码可以为不同的环境微调其自己的日志输出。例如：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code set logs the following, depending on the differences in logging priorities
    set up in the `logger`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码集根据在`logger`中设置的日志优先级的差异记录以下内容：
- en: '![](assets/f124f29f-90d6-4d36-9d11-f63cc7ef9c75.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f124f29f-90d6-4d36-9d11-f63cc7ef9c75.png)'
- en: The complete script that generates this log information is in the *Iteration
    3* code, at `hms-gateway/scratch-space/logging-examples/logging-example.py`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 生成此日志信息的完整脚本位于*迭代3*代码中，位于`hms-gateway/scratch-space/logging-examples/logging-example.py`。
- en: Like YAML configuration, we'll build on this logging structure later in this
    chapter, as a part of building a reusable base daemon structure.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与YAML配置一样，我们将在本章后面构建在此日志结构的基础上，作为构建可重用的基础守护程序结构的一部分。
- en: Handling requests and generating responses
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理请求和生成响应
- en: Most services will follow some sort of a request-response process model. A request
    is received, whether from a human user interacting with the service or some other
    process; the service then reads the request, determines what to do with it, performs
    whatever actions are needed, and generates and returns a response.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数服务都会遵循某种请求-响应过程模型。接收到一个请求，无论是来自与服务交互的人类用户还是其他进程；然后服务读取请求，确定如何处理它，执行所需的任何操作，并生成并返回响应。
- en: There are at least three distinct request types that are common enough to warrant
    a detailed examination – filesystem, HTTP/web message, and queue-based – each
    with its own baseline assumptions about how requests will be presented to a service,
    and each with its own resultant implications for design and execution.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有三种常见的请求类型足以值得进行详细检查 - 文件系统、HTTP/web消息和基于队列的请求 - 每种请求类型都对服务接收到请求的方式有其自己的基本假设，并对设计和执行产生不同的影响。
- en: The responses generated for any given request type usually imply a response
    mechanism of the same basic type. That is, a request that comes in from some filesystem
    variant will usually generate a response that is also expressed as some sort of
    filesystem output. That may not always be the case, but the odds are good that
    it will be in many (perhaps most) cases.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何给定的请求类型生成的响应通常意味着相同基本类型的响应机制。也就是说，来自某种文件系统变体的请求通常会生成一种以某种文件系统输出形式表达的响应。这可能并非总是如此，但很可能在许多（也许大多数）情况下都是如此。
- en: Filesystem – based
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于文件系统
- en: Requests and responses from and to the local filesystem are typically (and unsurprisingly)
    concerned with reading and writing data from and to local files. The simplest
    request-and-response structure of this type is a service that reads data from
    one file, processes it, and writes the results out to another file, possibly deleting
    or flushing out the incoming file on every read, and either replacing the output
    file on every write, or appending to it as each response is generated and returned.
    Implementations for single input and output files may leverage the `stdin` and
    `stdout` functionality of Python's `sys` module, or override either (or both)
    of them.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 来自本地文件系统的请求和响应通常（并不奇怪地）涉及从本地文件读取和写入数据。这种类型的最简单的请求和响应结构是一个服务从一个文件中读取数据，处理它，并将结果写入另一个文件，可能在每次读取时删除或清空传入的文件，并在每次写入时替换输出文件，或者在生成和返回每个响应时追加到它。单个输入和输出文件的实现可以利用Python的`sys`模块的`stdin`和`stdout`功能，或者覆盖其中的一个（或两个）。
- en: Both Windows and POSIX operating systems (Linux, macOS) have special file types,
    called **named pipes,** that reside on the filesystem and act like files, in that
    they can be opened, read from, and written to by using standard file-access code.
    The main difference is that a named pipe file can be opened and written to/read
    from by multiple different processes at the same time. That, then, allows for
    any number of processes to add requests to a file, queuing them up for a service
    to read and handle. Named pipes can also be used for service output.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Windows和POSIX操作系统（Linux，macOS）都有特殊的文件类型，称为**命名管道**，它们驻留在文件系统上，并且像文件一样运行，可以通过标准文件访问代码打开、读取和写入。主要区别在于，命名管道文件可以同时被多个不同的进程打开和写入/读取。这样，任意数量的进程可以向文件添加请求，将它们排队等待服务读取和处理。命名管道也可以用于服务输出。
- en: Another variant is monitoring for changes to files in the local filesystem,
    including the creation of new files, and changes to (or even the deletion of)
    existing files in a given location. At its most basic, this would involve generating
    and maintaining a list of files to keep track of, and periodically checking the
    actual filesystem structure for those files' existence and modified time. An implementation
    that follows this pattern might have a common input-file directory, and, as each
    iteration through the main service loop occurred, it would check for new files,
    read them, execute, and remove the file once processing was complete (in order
    to keep the number of files being monitored reasonably small).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种变体是监视本地文件系统中文件的更改，包括在给定位置创建新文件，以及更改（甚至删除）现有文件。在最基本的情况下，这将涉及生成和维护要跟踪的文件列表，并定期检查实际的文件系统结构，以确定这些文件的存在和修改时间。遵循这种模式的实现可能会有一个常见的输入文件目录，并且在每次通过主服务循环时，它会检查新文件，读取它们，执行并在处理完成后删除文件（以保持要监视的文件数量相对较小）。
- en: For scenarios where the number of files being monitored is large enough that
    creating and refreshing that list is too computationally expensive to be practical,
    monitoring filesystem events with functionality from the `pyinotify` library is
    a viable alternative, though there have been differences in what's available between
    POSIX/Linux and Windows versions of the library.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于监视的文件数量足够大，以至于创建和刷新该列表的计算成本太高，不切实际，使用`pyinotify`库的功能来监视文件系统事件是一个可行的替代方案，尽管在POSIX/Linux和Windows版本的库之间存在差异。
- en: HTTP- or web-based
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于HTTP或Web的
- en: HTTP-based services (web services), as the name implies, use the HTTP protocol
    to receive requests and transmit responses to those requests. As a subset of network-aware
    services, web services allow access to the service from machines other than the
    one that the service is actually running on. Web services don't have to be accessible
    on the public internet; they can live entirely in a local network, and operate
    just as well inside of those boundaries. They do, however, have to conform to
    some basic minimum standards, and could benefit from adhering to others.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 基于HTTP的服务（Web服务），顾名思义，使用HTTP协议接收请求并向这些请求发送响应。作为网络感知服务的子集，Web服务允许从除服务实际运行的机器之外的机器访问服务。Web服务不一定要在公共互联网上可访问；它们可以完全存在于本地网络中，并且在这些边界内同样有效。但是，它们必须遵守一些基本的最低标准，并且可能受益于遵守其他标准。
- en: 'It is likely that the most important of those standards is adhering to the
    request methods of the HTTP protocol. The methods that are most commonly seen
    in websites, and that are supported by any web browser worthy of the name, are
    as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 遵守HTTP协议的请求方法可能是最重要的标准之一。在网站中最常见的方法，并且任何名副其实的Web浏览器都支持的方法如下：
- en: '`GET`: Used to retrieve data'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：用于检索数据'
- en: '`POST`: Used to create data using an attached payload, even though `POST` is
    typically used in web applications, for both `create` and `update` operations'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：用于使用附加有效负载创建数据，尽管`POST`通常用于Web应用程序的`create`和`update`操作'
- en: 'There are several other methods available in the protocol, including:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 协议中还有其他几种可用的方法，包括：
- en: '`PUT` and `PATCH`: Intended to update data using an attached payload, in whole
    or in part, respectively'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`和`PATCH`：用于使用附加有效负载整体或部分更新数据'
- en: '`DELETE`: Intended to delete data'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：用于删除数据'
- en: '`OPTIONS`: Intended to provide data that indicates what methods are available,
    especially methods that can create or alter data on the receiving system, such
    as `POST`, `PUT`, and `DELETE` requests, and, most especially, if a request is
    being made to the service from somewhere other than the service''s domain itself'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIONS`：用于提供指示可用方法的数据，特别是可以在接收系统上创建或更改数据的方法，例如`POST`，`PUT`和`DELETE`请求，尤其是如果请求是从服务的域之外的地方发出的'
- en: Other methods that might come into play include `HEAD`, `CONNECT`, and `TRACE`. Depending
    on the design and implementation of the service, each HTTP method can be implemented
    as specific functions or methods of a class, allowing each request type to be
    able to enforce any requirements specific to it, while still allowing some functionality
    for common needs, such as the extraction of a payload for `POST`, `PUT`, and `PATCH`
    requests.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可能涉及的方法包括`HEAD`，`CONNECT`和`TRACE`。根据服务的设计和实现，每种HTTP方法都可以作为类的特定函数或方法来实现，使得每种请求类型都能够强制执行其特定的任何要求，同时仍然允许一些常见需求的功能，比如提取`POST`，`PUT`和`PATCH`请求的有效负载。
- en: A response from a web-service call, even if it's an empty response, is effectively
    required; otherwise, the calling client will wait until the request times out.
    Web service responses are limited to data types that can be transmitted by the
    HTTP protocol, which isn't very limited, but may require some additional development
    effort to support binary-resource responses (for example, images). As things stand,
    at the time of writing this book, most responses that can be represented purely
    in text seem to be returned as JSON data structures, but XML, HTML, and plain-text
    responses are also in the realm of possibilities.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Web服务调用的响应，即使是空响应，也是必需的；否则，调用客户端将等待直到请求超时。Web服务响应受限于可以通过HTTP协议传输的数据类型，这并不是非常有限的，但可能需要一些额外的开发工作来支持二进制资源响应（例如图像）。就目前而言，在撰写本书时，大多数纯文本表示的响应似乎以JSON数据结构返回，但XML、HTML和纯文本响应也是可能的。
- en: 'Although it''s certainly possible to write a full-blown web service purely
    in Python, there are a fair number of protocol-related items that might be better
    handled by any of several libraries, packages, or frameworks, if only because
    doing so would reduce the volume of code to be written, tested, and maintained.
    Options include, but are not limited to, the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然完全可以纯粹用Python编写一个完整的Web服务，但有许多与协议相关的项目可能最好由几个库、包或框架中的任何一个来处理，因为这样做将减少需要编写、测试和维护的代码量。选项包括但不限于以下内容：
- en: Writing a web service as a **Web Server Gateway Interface*** (***WSGI**) application
    that is accessible through an Apache or NGINX web server
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个作为**Web服务器网关接口**（**WSGI**）应用程序的Web服务，可以通过Apache或NGINX Web服务器访问
- en: Using the Django REST framework
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django REST框架
- en: Using the Flask-RESTful extension to the Flask framework
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flask框架的Flask-RESTful扩展
- en: A web- server- and framework-based solution will also benefit from security
    updates to the underlying web server and framework software, without requiring
    in-house security audits.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Web服务器和框架的解决方案也将受益于底层Web服务器和框架软件的安全更新，而无需进行内部安全审计。
- en: If a web service is expected to be exposed to the public internet, any of these
    are much better options than writing a service from the ground up, for that reason
    alone. It won't eliminate the need to be conscious of potential security concerns,
    but it will reduce the scope of those concerns to the code for the service's functionality
    itself.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果期望将Web服务暴露给公共互联网，任何这些选项都比从头开始编写服务要好得多，仅仅因为这个原因。这不会消除对潜在安全问题的意识，但它会将这些问题的范围减少到服务功能本身的代码。
- en: Message- queue-based
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于消息队列的
- en: 'Message queue systems, such as RabbitMQ and the various cloud-based options,
    have several advantages going for them for certain types of applications. They
    generally allow pretty much any message format to be used, provided that it can
    be expressed as text, and they allow messages to remain in a pending state until
    they are explicitly retrieved and dealt with, keeping messages safe and ready
    to use until the final consumer of those messages is ready to consume them. By
    way of example, consider the following scenario:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列系统，如RabbitMQ和各种基于云的选项，对于某些类型的应用有几个优势。它们通常允许几乎任何消息格式的使用，只要它可以表示为文本，并且它们允许消息保持在挂起状态，直到它们被明确检索和处理，使消息保持安全并准备好使用，直到这些消息的最终消费者准备消费它们。例如，考虑以下情景：
- en: Two users are sending messages to a service through a distributed queue that
    lives on the Message-Queue Server
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个用户通过存在于消息队列服务器上的分布式队列向服务发送消息
- en: 'User #1 sends their first message'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户#1发送了他们的第一条消息
- en: The service receives and acts on that message, but may not have deleted it in
    the queue yet
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务接收并处理该消息，但可能尚未在队列中删除它
- en: The service is restarted for some reason – to update it to a new version, perhaps,
    or because the server itself is being rebooted
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于某种原因重新启动服务-可能是为了将其更新到新版本，或者因为服务器本身正在重新启动
- en: 'In any case, before the service comes back online, User #2 sends their first
    message.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论如何，在服务重新上线之前，用户#2发送了他们的第一条消息。
- en: 'User #1 sends another message'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户#1发送了另一条消息
- en: 'Before the target service completes its startup, the scenario looks as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标服务完成启动之前，情景如下：
- en: '![](assets/ceb3060d-8151-48d2-afe2-71df72ce3c92.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ceb3060d-8151-48d2-afe2-71df72ce3c92.png)'
- en: Once the target service has completed its startup, all it has to do to fulfill
    the pending requests in those messages is poll the Message-Queue Server to retrieve
    any pending messages, and execute against them, just like it was doing before
    it was restarted.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦目标服务完成启动，它只需轮询消息队列服务器以检索任何挂起的消息，并对其执行，就像在重新启动之前一样。
- en: 'From the perspective of User #1 and User #2, there has been no interruption
    in access to the service (though there may have been a noticeable, or even significant,
    delay in getting their responses back). That would hold true whether the inactive
    period for the target service was a few seconds, or a few hours. Either way, the
    messages/commands that the end users sent were saved until they could be acted
    upon, so no effort was lost.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户#1和用户#2的角度来看，他们对服务的访问没有中断（尽管他们可能在收到响应时出现了明显甚至显著的延迟）。无论目标服务的不活动期是几秒还是几小时，这都是成立的。无论如何，最终用户发送的消息/命令都会被保存，直到可以执行，因此没有任何努力会被浪费。
- en: If the responses to those requests are also transmitted through a queue-based
    process, the same persistence of messages would hold true. So, as soon as the
    responses have been generated and sent by the target service, the users are able
    to receive them, even if they shut down and went home for the day before they
    were sent. Response messages would wait until the receiving system was active
    again, at which point they'd be delivered and acted upon.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对这些请求的响应也通过队列过程传输，那么消息的持久性也是成立的。因此，一旦响应由目标服务生成并发送，用户就能够接收到它们，即使在发送之前他们已经关闭并回家了。响应消息会等到接收系统再次活动时，然后它们将被传递并执行。
- en: Queue-based request-and-response cycles are, then, *very* well suited for managing
    log running and/or asynchronous processes, provided that the code that's acting
    on the messages takes that possibility into account.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 基于队列的请求和响应循环非常适合管理长时间运行和/或异步进程，只要处理消息的代码考虑到这种可能性。
- en: Other request types
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他请求类型
- en: 'Python provides access to enough general-purpose networking functionality that
    services can be written from scratch to read and respond to pretty much any sort
    of network traffic desired. The web- and queue-based service types are specific
    applications of that functionality, under the hood, supported to varying degrees
    by additional libraries that address some of the needs specific to each, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了足够的通用网络功能，可以从头开始编写服务，以读取和响应几乎任何所需的网络流量。Web和基于队列的服务类型是该功能的具体应用，在底层由额外的库支持，以不同程度地满足每种服务的特定需求，如下所示：
- en: Web services will probably make at least some use of the functionality provided
    by the `http.server`, or `socket` modules; the `http.server.HTTPServer` or `socketserver.TCPServer`
    classes are the most likely starting points, but `http.server.ThreadingHTTPServer`
    is also potentially viable.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务可能会至少部分使用`http.server`或`socket`模块提供的功能；`http.server.HTTPServer`或`socketserver.TCPServer`类是最可能的起点，但`http.server.ThreadingHTTPServer`也有潜在的可行性。
- en: 'Queue-based services may have libraries available that are specifically built
    to interact with the underlying queue service they''re attached to, including
    the following:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于队列的服务可能有专门构建的库可用，用于与它们附加的底层队列服务进行交互，包括以下内容：
- en: '`pika`, for RabbitMQ queue-services'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pika`，用于RabbitMQ队列服务'
- en: '`boto3`, for AWS SQS services, starting with creating a `boto3.SQS.Client`
    object'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boto3`，用于AWS SQS服务，从创建`boto3.SQS.Client`对象开始'
- en: Socket-based services that don't have some sort of supporting library available
    will probably start with the `socketserver.TCPServer` class noted in the previous
    lists, or perhaps with its UDP equivalent, `socketserver.UDPServer`. There are
    also `Threading` and `Forking` mix-in classes available, which can be used to
    provide basic server classes that support threading or (on POSIX-compliant systems)
    forking for servers, in order to handle larger user load levels.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 没有某种支持库的基于套接字的服务可能会从前面的列表中指出的`socketserver.TCPServer`类开始，或者可能从其UDP等效`socketserver.UDPServer`开始。还有`Threading`和`Forking`混合类可用，可用于提供支持线程或（在符合POSIX的系统上）分叉的基本服务器类，以处理更大的用户负载水平。
- en: Request and response formats
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求和响应格式
- en: From a purely technical/functional perspective, service implementations can
    be data- and format-agnostic. That is, there's no functional reason why a service
    cannot accept raw binary data input and return raw binary output. Data is data,
    after all. However, even in cases where a service really is concerned with data
    that isn't readily readable by human beings, there are advantages to formatting
    the incoming requests and outgoing responses, to afford some degree of human readability.
    At a minimum, it makes the debugging of requests and responses easier.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从纯技术/功能的角度来看，服务实现可以是数据和格式无关的。也就是说，没有功能上的理由，一个服务不能接受原始二进制数据输入并返回原始二进制输出。毕竟，数据就是数据。然而，即使在服务真正关心的数据不容易被人类读取的情况下，格式化传入请求和传出响应也有优势，可以提供一定程度的人类可读性。至少，这样可以使请求和响应的调试更容易。
- en: 'In that respect, request and response data share a lot of the concerns that
    were noted about the needs of configuration files, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，请求和响应数据与配置文件需求有很多相似之处，如下所示：
- en: Being able to pass structured and typed data around is similarly advantageous
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够传递结构化和类型化的数据同样有利
- en: Allowing that data structure to be at least somewhat comprehensible to a casual
    reader/observer feels like a good thing, too
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让数据结构至少在某种程度上对休闲读者/观察者可理解，也是一件好事
- en: The ability to represent reasonably complex data structures—lists and nested
    objects—also feels advantageous
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够表示相当复杂的数据结构——列表和嵌套对象——也感觉有利
- en: Given the same types of concerns, a similar solution to address them makes sense,
    which means that using a serialization format, such as JSON or YAML, also makes
    sense. Doing so introduces a bit of additional development effort overhead; for
    example, converting incoming data from JSON to a native data structure, or an
    outbound native data structure response to JSON. That effort will generally be
    pretty trivial, though.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到相同类型的问题，解决方案也是类似的，这意味着使用JSON或YAML等序列化格式也是有道理的。这样做会增加一些额外的开发工作量；例如，将JSON格式的传入数据转换为本地数据结构，或者将本地数据结构响应转换为JSON。不过，这种努力通常会相当微不足道。
- en: Of those two formats, JSON is arguably a better general*-*purpose solution.
    It's well established, and it's directly supported across a wider range of potential
    service clients, if only because it is, essentially, a native data format for
    web browsers. YAML is still a viable alternative, though, particularly in cases
    where there is no web browser client support needed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种格式中，JSON可以说是更好的通用*-*用途解决方案。它已经得到了很好的建立，并且在更广泛的潜在服务客户端中得到了直接支持，因为它本质上是Web浏览器的本地数据格式。然而，YAML仍然是一个可行的替代方案，特别是在不需要Web浏览器客户端支持的情况下。
- en: A generic service design
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用服务设计
- en: Given the configuration and logging possibilities that we've explored so far,
    the bare-bones service-as-a-function approach feels less and less viable, unless
    it's reasonable to expect that only one service will ever need to be written.
    Taking that basic approach is still possible, to be sure, but if there's ever
    a need to create another service, it'd be more efficient (and, at least, a somewhat
    more effective use of developer time) if there were a common starting point for
    creating any service, no matter what it's expected to do. To that end, then, we'll
    define a set of **abstract base classes** (**ABC**) that define the lowest common
    denominators of features and functionality that we'll expect from any service
    or daemon going forward, and we'll use that as our starting point for the Artisan
    Gateway Service of `hms_sys`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们迄今探讨的配置和日志可能性，除非可以合理地期望只需要编写一个服务，否则裸骨的服务作为函数的方法似乎越来越不可行。当然，仍然可以采用这种基本方法，但是如果有必要创建另一个服务，那么如果有一个通用的起点来创建任何服务，无论它预期要做什么，将更有效（至少在某种程度上更有效地利用开发人员的时间）。因此，我们将定义一组**抽象基类**（**ABC**），它们定义了我们将来期望从任何服务或守护进程中获得的功能和功能的最低公共分母，并将其用作`hms_sys`的Artisan
    Gateway Service的起点。
- en: 'The rationale for defining a service as a class, rather than as a function,
    is centered around the fact that we can reasonably expect at least a handful of
    properties and methods that would be common to all services/daemons, that would
    be difficult, tedious, and/or hard to maintain in a simple, function-based design.
    These include the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务定义为类而不是函数的原因在于，我们可以合理地期望至少有一些属性和方法对所有服务/守护进程都是共同的，这在简单的基于函数的设计中可能难以维护。这些包括以下内容：
- en: A centralized logging facility, built along the lines of the example logging
    code presented earlier
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿着之前介绍的示例日志记录代码的中心化日志记录设施
- en: A strong possibility that configuration values for the service will need to
    be accessible across multiple endpoints, which is probably easier to manage with
    a class-based design
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务的配置值很可能需要在多个端点之间访问，这可能更容易通过基于类的设计来管理
- en: The ability to use what might be called pluggable request, response, and formatting mechanisms
    will almost certainly be a lot easier to develop and maintain, since those would
    be represented by classes that encapsulate all of the necessary functionality
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可插拔的请求、响应和格式化机制几乎肯定会更容易开发和维护，因为这些机制将由封装所有必要功能的类表示
- en: The classes defined here do not leverage any of the available standard library
    entities that were noted earlier (for example, normal, threaded, or forking variants
    of `socketserver.TCPServer`). They are, instead, a baseline starting point for
    *any* service, at least at one level, and could potentially use any of those server
    classes as additional mix-ins, if desired. At another level, they could be considered
    purely illustrative of the kinds of functionality needed in a service class, though
    they are also viable for use as a service class, for some applications.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里定义的类没有利用之前提到的任何可用标准库实体（例如，`socketserver.TCPServer`的正常、线程化或分叉变体）。它们只是*任何*服务的基线起点，至少在某个层面上，并且如果需要的话，可能会使用任何这些服务器类作为附加的混合。在另一个层面上，它们可以被认为纯粹是服务类所需功能的示例，尽管它们也可以用作某些应用程序的服务类。
- en: These classes are also purely synchronous*.* They handle one request at a time,
    processing it to completion and returning a response, before acquiring the next
    request and handling it. That will probably suffice for low-load scenarios, of
    the sort expected in the context of the `hms_sys` system projects, but might not
    be enough for other use cases, especially if real-time responses and higher computational-cost
    processes get involved. We'll examine some options for dealing with those kinds
    of scenarios in [chapter 19](0f8e550d-d950-4551-ba4b-b652003658a5.xhtml), *Multiprocessing
    and HPC in Python*, while discussing local process-scaling options.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类也是纯粹的同步*。它们一次处理一个请求，处理完毕并返回响应，然后获取下一个请求并处理。这可能足够应付低负载场景，比如在`hms_sys`系统项目的情境中预期的那种，但对于其他用例可能不够，特别是如果涉及实时响应和更高计算成本的过程。在[第19章](0f8e550d-d950-4551-ba4b-b652003658a5.xhtml)中，我们将讨论处理这些情况的一些选项，*Python中的多进程和HPC*，同时讨论本地进程扩展选项。
- en: 'The collection of ABCs that we''re going to build is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要构建的ABC集合如下：
- en: '![](assets/d8f71825-442b-49b7-82ac-a42364164950.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d8f71825-442b-49b7-82ac-a42364164950.png)'
- en: 'Consider the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: '`BaseDaemon` is a starting point for creating classes that actually provide
    the service itself'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseDaemon`是创建实际提供服务的类的起点'
- en: '`BaseRequestHandler` provides a starting point for defining callable objects
    that will be used to actually handle an incoming request, and that will be responsible
    for formatting the results using an instance of a class derived from `BaseResponseFormatter`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseRequestHandler`提供了一个起点，用于定义可调用对象，用于实际处理传入的请求，并负责使用从`BaseResponseFormatter`派生的类的实例格式化结果'
- en: '`BaseResponseFormatter` is a similar, callable-object class that will convert
    a response data structure into a serialized string value, ready to be returned
    as a message in a queue, an HTTP response, or whatever other format is best suited
    for the specific response requirement'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseResponseFormatter`是一个类似的可调用对象类，它将把响应数据结构转换为序列化的字符串值，准备好作为队列中的消息、HTTP响应或者其他最适合特定响应需求的格式返回'
- en: The BaseDaemon ABC
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BaseDaemon ABC
- en: 'The implementation of `BaseDaemon` starts, unsurprisingly, with a standard
    ABC definition, and some class-level attributes/constants, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseDaemon`的实现始于一个标准的ABC定义，以及一些类级别的属性/常量，如下所示：'
- en: '[PRE8]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Since logging is a critical aspect of any service, making sure that some logging
    parameters are always available is a good idea. That starts with setting up a
    class-level constant that stores the default logging configuration, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于日志记录是任何服务的关键方面，确保一些日志记录参数始终可用是一个好主意。首先是设置一个存储默认日志配置的类级常量，如下所示：
- en: '[PRE9]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Those defaults are used by a common `_create_logger` method, provided as a
    concrete method by the class, to assure that logging will always be available,
    but that the parameters that control it can be overridden:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些默认值由一个名为`_create_logger`的通用方法使用，该方法由类提供为具体方法，以确保日志始终可用，但可以覆盖控制它的参数：
- en: '[PRE10]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After checking to see whether a logger name has been specified, the `_logging`
    class attribute is used to define a common log output format, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查是否指定了日志记录器名称之后，使用`_logging`类属性来定义一个通用的日志输出格式，如下所示：
- en: '[PRE11]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The same logging settings allow for independent control of the file and console
    output for logging. The file-based log output needs a `logfile` specification,
    and allows for an independent `level`, as well:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的日志设置允许独立控制日志的文件和控制台输出。基于文件的日志输出需要一个`logfile`规范，并允许独立的`level`：
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As each logging output is created and attached, the logging level is used to
    reset the `final_level` value, which will eventually allow the setup process to
    fine-tune the logging level for the logger object that the output is being attached
    to. The console logger output setup looks much the same as the file logger output,
    minus the filename, which it doesn''t need:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每个日志输出的创建和附加，日志级别用于重置`final_level`值，最终允许设置过程对输出附加的日志对象进行日志级别的微调。控制台日志输出设置看起来与文件日志输出类似，只是没有文件名，因为它不需要：
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In order to assure that logging will always be available, all of the setup
    so far executes in a `try…except` structure. If any errors occur during the process
    of setting up logging, a final `RuntimeError` is raised, with the intention of
    stopping all execution, so that whatever''s causing the logging failures must
    be fixed:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保日志始终可用，到目前为止的所有设置都在`try…except`结构中执行。如果在设置日志过程中发生任何错误，将引发最终的`RuntimeError`，目的是停止所有执行，以便修复导致日志失败的任何问题：
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once the instance''s `logger` object property has been created, logging any
    message is simply a matter of calling one of the instance''s various logging methods.
    Those methods – `critical`, `debug`, `error`, `info`, and `warn` – all look more
    or less alike, and will write the message supplied to the various pieces of logger
    output with the appropriate priority, or will fall back to printing the message,
    if the `logger` hasn''t been created yet:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实例的`logger`对象属性被创建，记录任何消息只是简单地调用实例的各种记录方法之一。这些方法——`critical`、`debug`、`error`、`info`和`warn`——看起来多少相似，并将消息写入各种日志记录输出的适当优先级，或者如果尚未创建`logger`，则退回到打印消息：
- en: '[PRE15]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The properties of the class are, for the most part, typical of the structures
    and patterns that have been used in earlier code, with typical type and value
    checking attached to their related setter methods:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的属性在很大程度上与早期代码中使用的结构和模式相似，其相关的setter方法附加了典型的类型和值检查：
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The setter method for the `config_file` property is worth a closer look, perhaps,
    since it performs some checking, to make sure that the value passed is a readable
    file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`config_file`属性的setter方法值得更仔细地查看，因为它执行了一些检查，以确保传递的值是一个可读文件：'
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once the configuration file has been verified as ready for use, another concrete
    method provided by the class, `configure`, can be called to read and apply it
    to an instance of the class. The `configure` method is responsible for reading
    the file, converting it to a common data structure, and handing it off to a required/abstract
    method that actually applies the configuration data to the instance: `_on_configuration_loaded`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置文件被验证为可供使用，该类提供的另一个具体方法`configure`可以被调用来读取并将其应用到类的实例。`configure`方法负责读取文件，将其转换为通用数据结构，并将其传递给一个实际将配置数据应用到实例的必需/抽象方法：`_on_configuration_loaded`。
- en: 'This division of responsibilities allows for a single common method, `configure`, to
    be consistently available, while allowing for the specific needs of any given
    class to be abstracted and made the responsibility of the derived class, `_on_configuration_loaded`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这种责任划分允许一个通用方法`configure`始终可用，同时允许任何给定类的特定需求被抽象化并成为派生类`_on_configuration_loaded`的责任：
- en: '[PRE18]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `_on_configuration_loaded` method can contain some concrete code that other
    classes may choose to use, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`_on_configuration_loaded`方法可以包含其他类可能选择使用的一些具体代码，如下所示：'
- en: '[PRE19]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If this standard configuration is used, it will be looking for a YAML configuration
    file that might look something like the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用了这个标准配置，它将寻找一个类似以下的YAML配置文件：
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It is worth noting that the various configuration methods may well deal with
    logging settings, and need to log messages before logging is complete. That is
    why the logging methods shown earlier have the fall-back-to-printing functionality.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，各种配置方法可能会处理日志记录设置，并且在日志记录完成之前需要记录消息。这就是之前显示的日志记录方法具有回退到打印功能的原因。
- en: 'The default implementation that was just shown does exactly that. That accounts
    for all of the code that executes when an instance of `BaseDaemon` is created.
    The initialization itself is pretty basic, though there are a couple of new and
    noteworthy items in it, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚显示的默认实现确实做到了这一点。这就是创建`BaseDaemon`实例时执行的所有代码。初始化本身非常基本，尽管其中有一些新的值得注意的项目，如下所示：
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first items of note are the calls to `signal.signal()`. These use Python's
    `signal` module to set up signal-event-handling processes, so that a running instance
    of the class, if it's killed at the OS level or interrupted in a Terminal session,
    will not just immediately die. Instead, those calls trap the termination (`SIGTERM`)
    and interruption (`SIGINT`) signals that the OS has issued, and allow the running
    code to react to them before terminating execution. In this case, they both call
    the instance's `stop` method, which gives the service instance the opportunity
    to tell its `main` loop to terminate, and thus allows for a graceful shutdown.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的第一项是对`signal.signal()`的调用。这些使用Python的`signal`模块来设置信号事件处理过程，以便如果类的运行实例在操作系统级别被终止或在终端会话中被中断，它不会立即死掉。相反，这些调用会捕获操作系统发出的终止（`SIGTERM`）和中断（`SIGINT`）信号，并允许运行的代码在终止执行之前对其做出反应。在这种情况下，它们都调用实例的`stop`方法，这给了服务实例机会告诉它的`main`循环终止，从而实现了优雅的关闭。
- en: The easiest way for that to be implemented is to have an instance value (`self._running`,
    in this case) that is used by the main loop of the service to determine whether
    to continue. That flag value is set at the end of the previous `__init__` method.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的最简单方法是有一个实例值（在这种情况下是`self._running`），该值由服务的主循环用于确定是否继续。该标志值在上一个`__init__`方法的末尾设置。
- en: 'Although the `main` loop method of a service class is the most important aspect
    of the class (without one, the service doesn''t actually do anything, after all),
    that `main` loop is something that is going to be specific to the derived class.
    It''s required, but it cannot really be implemented at the ABC''s level, so it''s
    made an abstract method, as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然服务类的`main`循环方法是类的最重要的方面（毕竟没有这个方法，服务实际上什么也做不了），但`main`循环是特定于派生类的。它是必需的，但实际上不能在ABC级别实现，因此将其作为抽象方法，如下所示：
- en: '[PRE22]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In order to allow for processes that need to fire off before a service starts
    and after it terminates, we''re providing concrete methods for each `preflight`
    and `cleanup`. These methods were made concrete, rather than abstract, so that
    they''d always be available, but could be overridden on an as-needed basis. They
    do nothing more than log that they have been called in their default implementations:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许在服务启动之前和终止之后需要触发的进程，我们为每个`preflight`和`cleanup`提供了具体的方法。这些方法被设置为具体方法，而不是抽象方法，以便它们始终可用，但可以根据需要进行重写。它们的默认实现只是记录它们已被调用：
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `preflight` method might be useful for implementing a `reload` method (a
    process that, without stopping the service instance, reacquires any local, potentially
    altered data, before resuming), for services that could benefit from one.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`preflight`方法可能对实现`reload`方法（在不停止服务实例的情况下，重新获取任何本地、可能被更改的数据，然后恢复）很有用。'
- en: 'Finally, service instances need to be able to be started, stopped, and maybe
    restarted, with single, simple commands. The methods that correspond to those
    are quite simple, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，服务实例需要能够通过单个简单的命令启动、停止，甚至可能重新启动。相应的方法非常简单，如下所示：
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This class uses several packages/libraries that need to be included, so we
    have to make sure to include them in the module that the class lives in, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类使用了几个需要包含的包/库，因此我们必须确保将它们包含在类所在的模块中，如下所示：
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With this code available, creating a new service class (equivalent to the simple,
    function-based example at the start of the chapter) is quite simple:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，创建一个新的服务类（相当于本章开头的简单基于函数的示例）就非常简单了：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following screenshot shows the output and logged messages from starting
    `testdaemon`, and from killing it after a few iterations. It shows all of the
    behavior we''d expect from the code in place:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了从启动`testdaemon`到杀死它后的几次迭代的输出和记录的消息。它显示了我们期望的代码行为：
- en: '![](assets/454e7be8-4bf7-4fda-834d-84cdee59f034.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/454e7be8-4bf7-4fda-834d-84cdee59f034.png)'
- en: This basic service doesn't use any request handler classes—it's just too simple
    to need them—but a more realistic service implementation will almost certainly
    need that ability. Each handler class will need to be registered before the service
    instance is started, and will need a way to associate some property or value from
    an incoming request, to identify a handler class to create, in order to generate
    a response to the request.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本服务不使用任何请求处理程序类——它太简单了，不需要它们——但更现实的服务实现几乎肯定需要这种能力。每个处理程序类都需要在服务实例启动之前注册，并且需要一种方法来关联来自传入请求的某个属性或值，以识别要创建的处理程序类，以生成对请求的响应。
- en: During execution, as requests come in, those requests will have to be examined
    in order to identify the key that determines what handler class will be used to
    create an instance. Execution can then be handed off to that instance to create
    the response.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行过程中，随着请求的到来，这些请求必须被检查，以确定确定哪个处理程序类将用于创建一个实例。然后执行可以交给该实例来创建响应。
- en: 'The handler class registration process is not difficult, but has a fair amount
    of type and value checking within it, to avoid bad, ambiguous, or conflicting
    results later on. It''s implemented as a class method, so that the association
    between the keys (endpoints, commands, message types, or whatever applies to an
    incoming request), and the handler classes behind those keys, can be established
    before the service is even instantiated:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序类注册过程并不困难，但其中有相当多的类型和值检查，以避免以后出现不良、模糊或冲突的结果。它被实现为一个类方法，这样在服务实例化之前就可以建立键（端点、命令、消息类型或适用于传入请求的任何内容）和这些键后面的处理程序类之间的关联：
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The process for finding a class to instantiate to handle a given request, given
    a key, is also not difficult; see the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 查找要实例化以处理给定请求的类的过程，给定一个键，也不难；请参阅以下代码：
- en: '[PRE28]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This method will return an instance of the first class that it can find that
    matches an incoming request key, and it will return for the longest key-match
    it can find, in order to both allow the same class to handle multiple keys, and
    to (hopefully) eliminate the possibility of a bad key-match. Consider a web service
    that interacts with `client` objects that can have subordinate `client` objects,
    allowing access to those clients by using paths that include the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将返回它能找到的第一个与传入请求键匹配的实例，并且它将返回它能找到的最长键匹配，以便允许同一个类处理多个键，并且（希望）消除坏键匹配的可能性。考虑一个与`client`对象交互的Web服务，这些对象可以有从属的`client`对象，通过包含以下内容的路径来访问这些客户端：
- en: '`/client/{client_id}`: Uses a `client_handler` object to handle requests'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/client/{client_id}`：使用`client_handler`对象处理请求'
- en: '`/client/{client_id}/client/{subordinate_id``}`: Uses a `subordinate_handler`
    object to handle requests'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/client/{client_id}/client/{subordinate_id}`：使用`subordinate_handler`对象处理请求'
- en: In order to make sure that a request that should be handled by a `subordinate_handler`
    doesn't accidentally acquire and use a `client_handler`, the matching process
    iterates over the list of endpoint keys, from longest to shortest, matches the
    longer one first, and returns the appropriate class.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保应该由`subordinate_handler`处理的请求不会意外地获取并使用`client_handler`，匹配过程会迭代端点键列表，从最长到最短，首先匹配较长的键，然后返回适当的类。
- en: The BaseRequestHandler and BaseResponseFormatter ABCs
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BaseRequestHandler和BaseResponseFormatter ABCs
- en: Without a concrete implementation derived from these classes, there's really
    not much to them. They use the same standard property structure that has been
    in play throughout this book for their properties, with typical type checking.
    The only new concept that they present is a combination of abstraction (which
    is nothing new) and the utilization of Python's `__call__` magic method.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 没有从这些类派生的具体实现，它们实际上并没有什么。它们使用了本书中一直在使用的相同标准属性结构，具有典型的类型检查。它们提出的唯一新概念是抽象的组合（这并不新鲜）和利用Python的`__call__`魔术方法。
- en: We'll look at these classes (indirectly, at least) when the concrete implementations
    derived from them are created for the `hms_sys` Artisan Gateway Service, in the
    next chapter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中间接地查看这些类（至少是间接地），当从这些类派生的具体实现为`hms_sys` Artisan Gateway Service创建时。
- en: 'When a class has a `__call__` method, instances of that class can be called
    as if they were functions, with the required arguments defined in the signature
    of the `__call__` method itself. In effect, callable class-instances can be thought
    of as **configurable functions**. Each instance of a callable class can have completely
    different state data that remains consistent within its own scope. As a simple
    example, consider the following code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类有一个`__call__`方法时，该类的实例可以被调用，就好像它们是函数，其所需的参数在`__call__`方法本身的签名中定义。实际上，可调用的类实例可以被认为是**可配置的函数**。可调用类的每个实例可以具有完全不同的状态数据，在其自己的范围内保持一致。举个简单的例子，考虑以下代码：
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Suppose that we create an instance and call it the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们创建一个实例并称之为以下内容：
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will then get the following output:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将得到以下输出：
- en: '![](assets/a81d4231-db3e-46e7-94f5-9c18aee31e63.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a81d4231-db3e-46e7-94f5-9c18aee31e63.png)'
- en: 'We can create additional instances, and call them, too, without affecting the
    results of the first instance:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建额外的实例，并调用它们，而不会影响第一个实例的结果：
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding code yields the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码产生以下结果：
- en: '![](assets/19c5d758-3fb6-4d78-bb29-a752e0a99b16.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/19c5d758-3fb6-4d78-bb29-a752e0a99b16.png)'
- en: By making the `__call__` method of these two classes abstract, we are effectively
    requiring them to implement a `__call__` method that allows each instance to be
    called as if it were a function, while simultaneously allowing each instance to
    access the properties and methods available to any instances of the class.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这两个类的`__call__`方法设为抽象，我们实际上要求它们实现一个`__call__`方法，允许每个实例被调用，就好像它是一个函数，同时允许每个实例访问任何类实例可用的属性和方法。
- en: 'Applying that to `BaseRequestHandler`, it means that each instance would have
    a direct reference to the `daemon` instance, with all of its logging facilities,
    its `start`, `stop`, and `restart` methods, and the original configuration file;
    therefore, the following would apply:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 将其应用到`BaseRequestHandler`，这意味着每个实例都将直接引用`daemon`实例，具有其所有的日志记录设施，其`start`、`stop`和`restart`方法，以及原始配置文件；因此，以下内容将适用：
- en: A request handler instance wouldn't have to do anything terribly complicated
    to log process details as a request was being handled
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求处理程序实例不必做任何非常复杂的事情来记录处理细节
- en: Configuration of individual request handlers would be feasible, and could even
    live in the same configuration file that the daemon itself used, although at present,
    the configuration would still have to be read and acted upon
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对个别请求处理程序的配置是可行的，甚至可以存储在守护程序本身使用的同一配置文件中，尽管目前，配置仍然必须被读取和执行
- en: It'd be possible to write one or more handlers (with appropriate caution, including
    authentication and authorization) that would allow a service request to restart
    the service
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以编写一个或多个处理程序（需要适当的注意，包括身份验证和授权），允许服务请求重新启动服务
- en: 'Other service daemons, with more/other functionality at the level of the service
    instance itself, could also provide a common functionality that would be accessible
    to each endpoint. Structurally, then, a service that uses a full set of these
    request handler and response formatter objects would entail the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 其他服务守护程序，具有更多/其他功能，可以在服务实例本身的级别提供对每个端点可访问的公共功能。因此，使用完整一套这些请求处理程序和响应格式化程序对象的服务将包括以下内容：
- en: 'A single service instance, derived from `BaseDaemon`, that has the following:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个从`BaseDaemon`派生的单个服务实例，具有以下内容：
- en: One to many `BaseRequestHandler`-derived classes registered and available to
    be instantiated and called in response to incoming requests, each of which can,
    in turn, create and call instances of any of several `BaseResponseFormatter`-derived
    classes, to generate the final output data
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个到多个`BaseRequestHandler`派生类被注册并可用于实例化和响应传入请求，每个类又可以创建和调用多个`BaseResponseFormatter`派生类的实例，以生成最终的输出数据
- en: With an implementation of `main` that determines which class to create and call
    for each request, based on the registration of those classes.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一个`main`的实现，根据这些类的注册确定为每个请求创建和调用哪个类。
- en: 'The flow of a request-response cycle for the Artisan Gateway Service, implemented
    with request handlers for Artisan and product interactions and response formatters,
    might look something like the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用请求处理程序处理工匠和产品交互以及响应格式化程序实现的工匠网关服务的请求-响应循环流程可能如下所示：
- en: '![](assets/21cd1d0b-25a9-4454-8e6b-92bd69649429.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/21cd1d0b-25a9-4454-8e6b-92bd69649429.png)'
- en: 'Step by step:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步：
- en: A **Request** is sent to the **Artisan Gateway Service**
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**请求**被发送到**工匠网关服务**
- en: The service determines, from some predefined `context` in the **Request**, that
    the **Artisan Handler** class should be instantiated and called
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务根据**请求**中的预定义`context`确定应该实例化和调用**工匠处理程序**类
- en: That handler knows that it needs to generate JSON output, so, after performing
    whatever processing is needed to generate a response that can be formatted, it
    acquires a **JSON Formatter** instance and calls the instance to generate the
    final **Response**
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该处理程序知道它需要生成JSON输出，因此，在执行生成可以格式化的响应所需的任何处理之后，它获取一个**JSON格式化程序**实例并调用该实例生成最终的**响应**
- en: The Response is returned to the **Artisan Handler**
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应被返回给**工匠处理程序**
- en: The **Artisan Handler** returns the **Response** to the **Artisan Gateway Service**
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**工匠处理程序**将**响应**返回给**工匠网关服务**'
- en: The **Artisan Gateway Service** returns the **Response** to the originator of
    the **Request**
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**工匠网关服务**将**响应**返回给**请求**的发起者'
- en: 'Most of that process hinges on concrete implementation that is not provided
    by the `BaseRequestHandler` and `BaseResponseFormatter` classes. They are, as
    shown in the preceding diagram, very simple. `BaseRequestHandler` starts with
    a standard abstract class structure, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分流程依赖于`BaseRequestHandler`和`BaseResponseFormatter`类未提供的具体实现。正如前面的图表所示，它们非常简单。`BaseRequestHandler`从标准的抽象类结构开始，如下所示：
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Each derived class can have a default formatter class associated with it, so
    that the eventual call of the instances of the class doesn''t require a formatter
    to be specified, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 每个派生类可以有一个与之关联的默认格式化程序类，因此该类的实例的最终调用不需要指定格式化程序，如下所示：
- en: '[PRE33]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Request handlers could benefit from having access to the service/daemon instance
    that they were created by. If nothing else, that allows the handler classes to
    use the daemon''s logging facilities. Accordingly, then, we''ll keep track of
    that daemon as a property of the instance, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请求处理程序可以从它们被创建的服务/守护实例中受益。至少，这允许处理程序类使用守护程序的日志记录设施。因此，我们将跟踪该守护程序作为实例的属性，如下所示：
- en: '[PRE34]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The initialization of an instance has to provide an argument to set the instance''s
    `daemon` property, but there''s not much else to it:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 实例的初始化必须提供一个参数来设置实例的`daemon`属性，但除此之外没有太多内容：
- en: '[PRE35]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Since the whole point of the ABC is to require instances to be callable by
    the service that created them, we''ll require a `__call__` method. Any time an
    instance is called, it will have an incoming request that needs to be processed
    and responded to. It also feels like a good idea to allow a `formatter` to be
    passed that could override the default `formatter` type, specified as a class
    attribute. As concrete implementations of handler classes are written, some thought
    will need to be given to how to handle cases where the class doesn''t specify
    a `formatter` type, and no `formatter` type is provided in the call itself. That
    may well vary considerably across request types, though, so there''s little point
    in going into any depth on that concern just yet:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ABC的整个重点是要求实例可以被创建它们的服务调用，我们将需要一个`__call__`方法。每当实例被调用时，它将有一个需要处理和响应的传入请求。允许传递一个`formatter`也是一个好主意，它可以覆盖默认的`formatter`类型，指定为一个类属性。随着处理程序类的具体实现的编写，需要考虑如何处理类没有指定`formatter`类型，并且在调用本身中没有提供`formatter`类型的情况。尽管这可能会在请求类型之间有很大的差异，但现在还没有必要深入讨论这个问题：
- en: '[PRE36]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `BaseResponseFormatter` ABC also starts as a standard abstract class. It
    also uses the same `daemon` property, and adds a `request_handler` property that
    uses a similar setter method, allowing a formatter instance to access the request
    instance that created it, as well as the daemon instance that the request was
    received by:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseResponseFormatter` ABC也开始作为一个标准的抽象类。它也使用相同的`daemon`属性，并添加一个`request_handler`属性，使用类似的setter方法，允许格式化程序实例访问创建它的请求实例，以及接收请求的守护实例：'
- en: '[PRE38]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `request_handler`, then, needs to be required when creating an instance,
    for much the same reason that `daemon` is required:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 请求处理程序在创建实例时需要被要求，原因与需要要求`daemon`相同：
- en: '[PRE39]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, as with `BaseRequestHandler`, we''ll require a `__call__` method to
    be implemented by any derived classes:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，与`BaseRequestHandler`一样，我们将要求任何派生类实现一个`__call__`方法：
- en: '[PRE40]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In general, classes (especially if they are concrete classes) that are this
    simple (having only one method, plus their initializer, `__init__`) are not the
    best implementation approach. A class with a single method can usually be handled
    as a single function instead, even if the function has a more complex set of arguments.
    The formatter classes may well end up falling into this category as concrete implementation
    progresses. If they do, refactoring them into (hopefully simple) functions will
    be undertaken, but for now, `BaseResponseFormatter` will be left standing, as
    it has been written.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，类（特别是具体类）如果这么简单（只有一个方法，加上它们的初始化器`__init__`）并不是最佳的实现方法。一个只有一个方法的类通常可以被处理为一个单独的函数，即使该函数有一组更复杂的参数。随着具体实现的进展，格式化程序类很可能会落入这个类别。如果是这样，将对其进行重构（希望是简单的）函数，但目前`BaseResponseFormatter`将被保留下来，因为它已经被编写。
- en: 'The `BaseRequestHandler` ABC is less of a concern on that count. Requests that
    interact with different backend data objects can be grouped into handlers for
    those object types; for example, an `ArtisanHandler` for artisans and a `ProductHandler`
    for products. It''s not a great stretch to anticipate that each of those handlers
    will have, at a minimum, methods for various CRUD operations that will be called,
    as requests are handled by the `__call__` method, but other needs arise in specific
    use cases and service contexts, as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseRequestHandler` ABC在这方面不太值得担心。与不同后端数据对象交互的请求可以被分组到这些对象类型的处理程序中；例如，为工匠创建一个`ArtisanHandler`，为产品创建一个`ProductHandler`。可以预见到，每个处理程序至少会有一些用于各种CRUD操作的方法，这些方法将在`__call__`方法处理请求时被调用，但在特定用例和服务上下文中还会出现其他需求，如下所示：'
- en: In a web service context, there could be as many as five additional methods
    to be implemented – one each for `HEAD`, `CONNECT`, `OPTIONS`, `TRACE`, and `PATCH`
    HTTP methods
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Web服务上下文中，可能需要实现多达五种额外的方法 - 每种方法对应一个`HEAD`、`CONNECT`、`OPTIONS`、`TRACE`和`PATCH`
    HTTP方法
- en: In service contexts that don't have such a rigidly defined set of operations
    as the HTTP methods of a web service, there is even more potential for additional
    methods – even as many as one per business process that requests need to be supported
    for
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有像Web服务的HTTP方法那样严格定义的操作集的服务上下文中，甚至还有更多的潜力可以添加额外的方法 - 甚至每个业务流程可能需要支持的请求都可以有一个方法
- en: Even with these levels of complexity, implementing functions to handle the request/response
    cycles would be feasible. They'd just be larger, more complex functions, with
    a strong potential for being more difficult to change or maintain on a long-term
    basis.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有这些复杂性，实现处理请求/响应周期的功能也是可行的。它们只是更大、更复杂的功能，很可能更难以长期改变或维护。
- en: Integrating a service with the OS
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将服务与操作系统集成
- en: 'The last substantial piece of the service implementation puzzle, before getting
    into the concrete functionality, is getting a service program written in Python,
    to actually execute as a service at the OS level. The specifics of that process
    vary, unsurprisingly, across different operating systems (and even vary, to some
    extent, across different versions of some operating systems – Linux, in particular),
    but there are common operations that must be addressed across the board, as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入具体功能之前，服务实现难题的最后一个重要部分是编写一个用Python编写的服务程序，以实际在操作系统级别执行服务。该过程的具体细节会因不同的操作系统而异（尤其是在不同版本的某些操作系统
    - 尤其是Linux上），但有一些通用操作必须在各个方面进行处理，如下所示：
- en: Services need to be started when the machine they run on boots up
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务需要在所运行的机器启动时启动
- en: Services need to stop gracefully, when the machine they run on is powered down
    or rebooted
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务需要在所运行的机器被关闭或重新启动时优雅地停止
- en: Services need to be able to be restarted (which is generally little more than
    a stop-then-start process)
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务需要能够重新启动（通常只是一个停止-然后-启动的过程）
- en: Some service models might also benefit from being able to reload their data
    and/or configurations without interrupting service access in the process, particularly
    if the equivalent reload process that would occur from a restart is time-consuming.
    There may be other useful operations for specific scenarios.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一些服务模型可能还会受益于能够重新加载它们的数据和/或配置，而不会在此过程中中断服务访问，特别是如果等效的重新加载过程比重新启动耗时。可能还有其他特定场景下有用的操作。
- en: An exploration of these mechanisms will use the `testdaemon` class that was
    shown earlier.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些机制的探索将使用之前展示的`testdaemon`类。
- en: Running a service using systemctl (Linux)
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用systemctl运行服务（Linux）
- en: 'Linux distributions are moving away from their old System V-style startup processes
    to a newer mechanism, the `systemd` daemon, and its associated `systemctl` command-line
    tool. Services managed by `systemd`/`systemctl` require, at a minimum, a configuration
    file that defines startup and shutdown processes, a type definition that controls
    how those processes will be handled by the OS, and whatever executables are needed
    to start or stop the service processes. A bare-bones `testdaemon.service` configuration
    file could be as simple as the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Linux发行版正在摆脱旧的System V风格的启动进程，转向一个更新的机制，即`systemd`守护进程及其相关的`systemctl`命令行工具。由`systemd`/`systemctl`管理的服务至少需要一个定义启动和关闭过程的配置文件，一个控制这些过程如何被操作系统处理的类型定义，以及启动或停止服务进程所需的可执行文件。一个最简单的`testdaemon.service`配置文件可能如下所示：
- en: '[PRE41]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding code, the following apply:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下内容适用：
- en: The `Unit`/`Description` entry is simply a short description of the service,
    often nothing more than a name.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unit`/`Description`条目只是服务的简短描述，通常不过是一个名称。'
- en: '`Service`/`Type` defines how the startup process will be handled by the `systemd`
    daemon. In this case, the execution will be forked, so that whatever process called
    it is no longer associated with it, and can terminate without stopping the service
    itself.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Service`/`Type`定义了启动过程将由`systemd`守护程序处理的方式。在这种情况下，执行将被分叉，以便调用它的任何进程不再与它关联，并且可以在不停止服务本身的情况下终止。'
- en: '`Service`/`ExecStart` defines a process for starting the service, in this case,
    by executing the `testdaemon.py` file as a Python script.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Service`/`ExecStart`定义了启动服务的进程，本例中通过执行`testdaemon.py`文件作为Python脚本来执行。'
- en: '`Service`/`ExecStop` defines a process for stopping the service, in this case,
    by killing all of the processes with `testdaemon.py` in their name.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Service`/`ExecStop`定义了停止服务的进程，本例中通过杀死所有进程的方式来停止服务，这些进程的名称中带有`testdaemon.py`。'
- en: 'Assuming that the actual `testdaemon` class can be imported from some installed
    package, the `testdaemon.py` script that starts the service can be as simple as
    the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 假设实际的`testdaemon`类可以从某个已安装的包中导入，启动服务的`testdaemon.py`脚本可以简单如下：
- en: '[PRE42]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With both of those files in place, the commands for starting, restarting, and
    stopping the service from the command line are, respectively, as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个文件，从命令行启动，重新启动和停止服务的命令分别如下：
- en: '[PRE43]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The services managed by `systemd` must be enabled in order to start at boot,
    as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 由`systemd`管理的服务必须启用才能在启动时启动，如下所示：
- en: '[PRE44]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding command requires that an install specification be added to the
    corresponding `systemd` `.service` file, as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令要求在相应的`systemd` `.service`文件中添加安装规范，如下所示：
- en: '[PRE45]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There are a lot of other options available to `systemd` service configurations,
    but these bare-bones settings will allow a service to be auto-started and managed
    with standard command-line tools.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd`服务配置还有很多其他选项，但这些最基本的设置将允许使用标准命令行工具自动启动和管理服务。'
- en: Running a service using NSSM (Windows)
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NSSM（Windows）运行服务
- en: 'The easiest way to install services written in Python on a Windows machine
    is to use **Non-Sucking Service Manager** (**NSSM**). NSSM provides a simple way
    to wrap a specific executable (the main `python.exe` file, in this case), along
    with arguments (the `testdaemon.py` script), and make them available as a Windows
    service. Starting NSSM with `nssm install` provides a window with all of the fields
    needed for basic service setup, as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows机器上安装用Python编写的服务的最简单方法是使用**Non-Sucking Service Manager**（**NSSM**）。
    NSSM提供了一种简单的方式来包装特定的可执行文件（主要是`python.exe`文件），以及参数（`testdaemon.py`脚本），并将它们作为Windows服务提供。使用`nssm
    install`启动NSSM提供了一个窗口，其中包含了基本服务设置所需的所有字段，如下所示：
- en: '![](assets/ec5bc509-575e-401e-a3f8-7de333ec98cf.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ec5bc509-575e-401e-a3f8-7de333ec98cf.png)'
- en: 'Once the Install service button is clicked, the service is available in the
    Windows Services manager, where its Startup Type can be altered, if needed, along
    with all of the other standard Windows service settings and properties:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 单击安装服务按钮后，服务将在Windows服务管理器中可用，如果需要，可以更改其启动类型，以及所有其他标准Windows服务设置和属性：
- en: '![](assets/d27c76b7-4c6b-4722-b938-fca95ec1b9fa.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d27c76b7-4c6b-4722-b938-fca95ec1b9fa.png)'
- en: Changes can also be made to the NSSM-created properties of the service, by running
    `nssm install <service-name>`, which presents the same UI that was used to create
    the service entry.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过运行`nssm install <service-name>`更改由NSSM创建的服务的属性，该命令显示用于创建服务条目的相同UI。
- en: If an NSSM-packaged service fails to start, it will log useful information to
    the standard Windows Event Log; debugging startup problems should start there.
    Odds are good that if there are any issues, they will be permissions-related,
    such as the service's account not having access to the script file, a configuration
    file, and so on.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果NSSM打包的服务无法启动，它将向标准Windows事件日志记录有用的信息；调试启动问题应从那里开始。如果有任何问题，很可能与权限相关，例如服务帐户无法访问脚本文件、配置文件等。
- en: macOS, launchd, and launchctl
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS，launchd和launchctl
- en: 'The **Macintosh operating system** (**macOS**) is, under the hood, a Unix variant,
    so in many respects, there will be fewer issues or differences than there are
    between Linux and Windows service installations. macOS provides approximate equivalents
    to `systemd` and `systemctl`: the `launchd` and `launchctl` programs, respectively.
    They provide the same sort of service startup and shutdown control capabilities,
    at a minimum, with a lot of additional options for handling service processes,
    based on all kinds of system events.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**Macintosh操作系统**（**macOS**）在底层是Unix变种，因此在许多方面，与Linux和Windows服务安装相比，问题或差异会更少。
    macOS提供了与`systemd`和`systemctl`大致相当的东西：`launchd`和`launchctl`程序。它们提供了与最小限度的服务启动和关闭控制功能相同类型的服务，还提供了许多额外的选项，用于处理基于各种系统事件的服务进程。'
- en: '**Disclaimer**: While writing this book, no macOS machine was available to
    test with, so, while this section should be complete and usable as it stands,
    there may be issues that weren''t identified before publication'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**免责声明**：在撰写本书时，没有macOS机器可供测试，因此，尽管本节应该是完整的并且可以按原样使用，但在出版之前可能存在未识别的问题。'
- en: 'A bare-bones `launchd`-compatible service configuration file needs to contain
    a service label, the program that is executed when the service starts up, and
    any arguments that the program needs: exactly what `systemd` needs, although the
    configuration files for `launchd`-managed services are XML files. A basic starting
    point configuration, using `testdaemon.py` as the script to launch the actual
    service object and providing both run-at-load and keep-alive controls, looks as
    follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一个最基本的`launchd`兼容的服务配置文件需要包含一个服务标签，当服务启动时执行的程序，以及程序需要的任何参数：正是`systemd`所需的，尽管`launchd`管理的服务的配置文件是XML文件。使用`testdaemon.py`作为启动实际服务对象的脚本，并提供运行时加载和保持活动控制的基本起点配置如下：
- en: '[PRE46]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'That configuration, once in one of the standard locations for `launchd` files,
    allows the service to be started, restarted, and stopped, respectively, as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置在`launchd`文件的标准位置之一，该服务可以分别启动、重新启动和停止，如下所示：
- en: '[PRE47]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Managing services on other systems
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在其他系统上管理服务
- en: 'Although the current trend for managing service processes in Linux systems
    is, as noted, moving toward `systemd`/`systemctl`, there may be operational systems
    that still use System V-style initialization scripts. A bare-bones starting point
    for such a script would look something like the following:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管目前在Linux系统中管理服务进程的趋势是，正如所指出的，向着`systemd`/`systemctl`发展，但仍然可能有一些操作系统仍在使用System
    V风格的初始化脚本。这样一个脚本的最基本起点可能如下所示：
- en: '[PRE48]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In a System V-managed context, the service itself has to take responsibility
    for making sure that it detaches from whatever process called it – a Terminal
    session, or the startup processes of the OS itself. Otherwise, the service process
    may simply start, then terminate before it actually does anything.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在System V管理的环境中，服务本身必须负责确保它与调用它的任何进程（终端会话或操作系统本身的启动进程）分离。否则，服务进程可能只是启动，然后在实际执行任何操作之前终止。
- en: Since this scenario should be less and less common as time goes on, but is still
    possible, there is a class in the `daemons` module, `BaseDaemonizable`, that handles
    daemonizing a service class instance, including writing the **process ID** (**PID**)
    to a file in a known location, in case that's needed for some part of a service
    process. Deriving a service class from that, instead of `BaseDaemon`, should take
    care of the majority of the different needs, while still preserving the `BaseDaemon`
    structure.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，这种情况可能会越来越少见，但仍然有可能。在`daemons`模块中有一个类`BaseDaemonizable`，它处理服务类实例的守护进程化，包括将**进程ID**（PID）写入到已知位置的文件中，以防服务进程的某部分需要。从那里派生一个服务类，而不是从`BaseDaemon`派生，应该能够满足大部分不同的需求，同时仍然保留`BaseDaemon`的结构。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The service foundations that were created in this chapter should provide a solid,
    common starting point for nearly any service, although tweaks to the structure
    or overrides of existing functionality may be required for specific use cases.
    With the foundations in place, the path is clear to actually creating the Artisan
    Gateway Service in `hms_sys`, which will connect the Artisan and Central Office
    data flows in the next chapter.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 本章创建的服务基础应该为几乎任何服务提供一个坚实的共同起点，尽管可能需要对结构进行微调或覆盖现有功能以满足特定用例的要求。有了这些基础，路径就清晰了，可以在`hms_sys`中实际创建Artisan
    Gateway Service，它将在下一章中连接Artisan和Central Office的数据流。
