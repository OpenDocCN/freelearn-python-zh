- en: Applying Machine Learning in Robotics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在机器人中应用机器学习
- en: This chapter provides a hands-on introduction to **machine learning **(**ML**)
    in robotics. Although we assume that you have not yet worked in such a field,
    it will be helpful to have some background in statistics and data analytics. In
    any case, this chapter intends to be a gentle introduction to the topic, favoring
    intuition instead of complex mathematical formulations, and putting the focus
    on understanding the common concepts used in the field of ML.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了机器人中机器学习（ML）的实战介绍。尽管我们假设您尚未在这个领域工作，但拥有一些统计学和数据分析背景将有所帮助。无论如何，本章旨在对主题进行温和的介绍，更倾向于直觉而非复杂的数学公式，并将重点放在理解机器学习领域中常用的概念。
- en: Throughout this chapter, we will devote the discussion to such concepts by providing
    specific examples of robots. This is somewhat original because most references
    and books on ML give examples oriented to data science. Hence, as you become more
    familiar with robotics, it should be easier for you to understand the concepts
    this way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过提供特定机器人的具体示例来讨论这些概念。这在某种程度上是原创的，因为大多数关于机器学习的参考书籍和书籍都提供了面向数据科学的应用示例。因此，随着您对机器人学的熟悉，您应该更容易以这种方式理解这些概念。
- en: With the explanations about deep learning, you will understand how crucial this
    technique is for the robot to acquire knowledge of its surroundings through the
    processing of raw data coming from the robot's camera (2D and/or 3D) and specific
    distance sensors. With the specific example of object recognition explained in
    this chapter, you will learn how raw image data is processed in order to build
    robot's knowledge in the robot, making it capable to take smart actions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对深度学习的解释，您将了解这项技术对于机器人通过处理来自机器人摄像头的原始数据（2D和/或3D）以及特定距离传感器获取周围环境知识是多么关键。在本章中，通过解释对象识别的具体示例，您将学习原始图像数据是如何被处理以构建机器人在机器人中的知识，使其能够采取智能行动。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Setting up the system for TensorFlow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 TensorFlow 系统环境
- en: How ML is being applied in Robotics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习在机器人中的应用
- en: The ML pipeline
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习（ML）管道
- en: A methodology to programmatically apply ML in robotics
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种将机器学习程序化应用于机器人的方法
- en: Deep learning applied to robotics— computer vision
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用于机器人的深度学习——计算机视觉
- en: The concrete application we will do for GoPiGo3 deals with computer vision,
    the most common perception task in robotics. Equipped with this capability, the
    robot should be aware of the objects around itself, making it capable to interact
    with them. As a result of this chapter, we expect you to develop the basic insight
    of when and how to apply deep learning in robotics.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为 GoPiGo3 实现的具体应用涉及计算机视觉，这是机器人中最常见的感知任务。装备了这种能力，机器人应该能够意识到它周围的物体，使其能够与之交互。通过本章的学习，我们期望您能够掌握在机器人中何时以及如何应用深度学习的基本见解。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the examples in this chapter, we will use **TensorFlow** ([https://www.tensorflow.org/](https://www.tensorflow.org/)),
    the ML framework open-sourced by Google in 2015, which has become the big brother
    in the data science community because of all of the people involved as active
    developers or end users.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的示例，我们将使用 TensorFlow（[https://www.tensorflow.org/](https://www.tensorflow.org/)），这是谷歌在
    2015 年开源的机器学习框架，由于所有积极参与开发或作为最终用户的众多人员，它已成为数据科学社区中的大哥大。
- en: The main TensorFlow API is developed in Python and is the one we are going to
    use. To install it, we need to have the well-known `pip` Python package manager
    in our system. Even though it comes bundled with the Ubuntu OS, we provide the
    instructions for installing it. Later, we will cover the TensorFlow installation
    process.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow 的主要 API 是用 Python 开发的，我们将使用它。为了安装它，我们需要在我们的系统中安装知名的 `pip` Python
    软件包管理器。尽管它捆绑在 Ubuntu 操作系统中，但我们提供了安装说明。稍后，我们将介绍 TensorFlow 的安装过程。
- en: Let's first provide the path for the code of this chapter, and then describe
    the step-by-step procedure to configure your laptop with TensorFlow.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先提供本章代码的路径，然后描述配置笔记本电脑以使用 TensorFlow 的逐步过程。
- en: In this chapter, we will make use of the code located in the `Chapter10_Deep_Learning_` folder
    at [https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter10_Deep_Learning_](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter10_Deep_Learning_).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用位于[https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter10_Deep_Learning_](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter10_Deep_Learning_)的`Chapter10_Deep_Learning_`文件夹中的代码。
- en: 'Copy its files to the **ROS**(short for** Robot Operating System**) workspace
    to have them available and leave the rest outside the `src` folder:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将其文件复制到**ROS**（即**机器人操作系统**）工作空间，以便它们可用，并将其余部分留在`src`文件夹之外：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This way, you will have a cleaner ROS environment. As usual, you need to rebuild
    the workspace on the laptop:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你将拥有一个更干净的ROS环境。像往常一样，你需要在笔记本电脑上重新构建工作空间：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, let's start with the setup for TensorFlow.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们开始设置TensorFlow。
- en: Setting up the system for TensorFlow
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置TensorFlow的系统环境
- en: First, we will set up `pip`, the Python package manager and afterward the framework
    for performing ML, that is, TensorFlow.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将设置`pip`，Python包管理器，然后是执行机器学习（ML）的框架，即TensorFlow。
- en: Installing pip
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装pip
- en: Ubuntu distributions typically ship with `pip` preinstalled. Unless a Python
    library requests you to upgrade, you can stay with the same version. In any case,
    we recommend working with the latest one, as explained in the following.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu发行版通常预装了`pip`。除非Python库要求你升级，否则你可以保持相同的版本。在任何情况下，我们建议使用最新版本，如下所述。
- en: Installing the latest version
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装最新版本
- en: 'This section applies to the case in which you need to install `pip` or upgrade
    it:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分适用于你需要安装或升级`pip`的情况：
- en: 'First, remove the previous version if there is one:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，如果有旧版本，请先删除它：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We do this because the Ubuntu repository may not have the latest version of
    `pip`. In the next step, you will access the original source to get all of the
    updates.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为Ubuntu仓库可能没有`pip`的最新版本。在下一步中，你将访问原始源以获取所有更新。
- en: 'Download the installation script and execute it:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载安装脚本并执行它：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Check which version is installed:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查已安装的版本：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If it was already present in your system, you can easily upgrade using `pip`
    itself:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它已经存在于你的系统中，你可以很容易地使用`pip`本身进行升级：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, you are ready to proceed with the installation of the ML environment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已准备好进行ML环境的安装。
- en: Installing TensorFlow and other dependencies
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装TensorFlow和其他依赖项
- en: 'OpenCV, the well-known and open source computer vision library ([https://opencv.org/](https://opencv.org/)),
    brings to ROS the capability of image processing. It is used by TensorFlow to
    deal with images that you will obtain from the robot camera. To install it in
    your system, you need the `pip` package manager that we explained earlier:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV，这个知名的开源计算机视觉库（[https://opencv.org/](https://opencv.org/)），为ROS带来了图像处理的能力。它被TensorFlow用来处理从机器人摄像头获取的图像。要在你的系统中安装它，你需要我们之前解释过的`pip`包管理器：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `--user` flag ensures that the package is installed locally to the user
    home folder at `~/.local/lib/python2.7/site-packages`. Otherwise, it should be
    installed system-wide at the `/usr/local/lib/python2.7/dist-packages` path, as
    is the case of `pip` (in such cases, you should perform the installation with `sudo`).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`--user`标志确保包被安装到用户主目录的`~/.local/lib/python2.7/site-packages`下。否则，它应该被安装到系统范围内的`/usr/local/lib/python2.7/dist-packages`路径，就像`pip`一样（在这种情况下，你应该使用`sudo`进行安装）。'
- en: 'The OpenCV ROS bridge ([http://wiki.ros.org/cv_bridge](http://wiki.ros.org/cv_bridge)) ships
    with the full-stack installation of ROS. If, for some reason, the package is missing
    in your environment, you can easily install it with this line:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV ROS桥（[http://wiki.ros.org/cv_bridge](http://wiki.ros.org/cv_bridge)）与ROS的全栈安装一起提供。如果由于某种原因，你的环境中缺少这个包，你可以很容易地使用以下命令安装它：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For the `<ROS_VERSION>` tag, use the `kinetic` value or `melodic` depending
    on the ROS distribution you have.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`<ROS_VERSION>`标签，使用`kinetic`值或`melodic`，具体取决于你拥有的ROS发行版。
- en: 'Finally, install TensorFlow as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按照以下步骤安装TensorFlow：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `--upgrade` flag gives you the advantage to update the package if it is
    already installed. If you are working in Ubuntu 16.04, TensorFlow V2 will throw
    compatibility issues. In such a case, install TensorFlow V1 as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--upgrade`标志，如果你已经安装了该包，你可以更新它。如果你在使用Ubuntu 16.04，TensorFlow V2将会抛出兼容性问题。在这种情况下，按照以下步骤安装TensorFlow
    V1：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In Ubuntu 18.04, you will be ready with the upgraded version of TensorFlow.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 18.04 中，你将准备好升级版的 TensorFlow。
- en: Achieving better performance using the GPU
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GPU 实现更好的性能
- en: Alternatively, you could use the GPU version of TensorFlow to take advantage
    of this hardware on your laptop. The **GPU** (short for **Graphical Processing** **Unit**)
    card of your laptop is primarily used to power the display output on the screen.
    Therefore, it is very good at image processing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用 TensorFlow 的 GPU 版本来利用笔记本电脑上的这种硬件。**GPU**（即**图形处理单元**）卡主要用于为屏幕上的显示输出供电。因此，它在图像处理方面非常出色。
- en: As the kinds of calculations we need to do in ML are very similar (that is,
    floating-point, vector, and matrix operations), you can speed up the training
    and usage of your ML models by using the GPU for calculations instead of the CPU.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在机器学习中需要进行的计算类型非常相似（即，浮点、向量和矩阵运算），你可以通过使用 GPU 而不是 CPU 进行计算来加速你的机器学习模型的训练和使用。
- en: 'By using the GPU, you may achieve at least a factor of 10 in speed calculation
    for using the CPU, even in the case of the cheapest GPU cards. Hence, the choice
    of GPU is worth it. The command to install the corresponding TensorFlow library
    in Ubuntu 18.04 is pretty simple:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 GPU，你可能在速度计算上至少能比使用 CPU 快 10 倍，即使在最便宜的 GPU 卡上也是如此。因此，选择 GPU 是值得的。在 Ubuntu
    18.04 中安装相应 TensorFlow 库的命令相当简单：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As before, if you are working in Ubuntu 16.04, install TensorFlow V1 to avoid
    compatibility issues:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，如果你正在使用 Ubuntu 16.04，请安装 TensorFlow V1 以避免兼容性问题：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With TensorFlow installed, being the normal version or the GPU-performant one,
    you are ready to use ML within ROS.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了 TensorFlow 后，无论是正常版本还是具有 GPU 性能的版本，你就可以在 ROS 中使用机器学习了。
- en: ML comes to robotics
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习进入机器人领域
- en: ML has its roots in statistical science. Remember when you have a cloud of points
    on an x-y frame and try to find the straight line that best fits all of them at
    the same time? This is what we call a linear regression and can be solved with
    a simple analytical formula. **Regression** is the first algorithm that you typically
    study when getting started with ML.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习的根源在于统计学。记得当你有一个在 x-y 坐标系上的点云，并试图找到同时最适合所有这些点的直线吗？这就是我们所说的线性回归，可以用一个简单的解析公式来解决。**回归**
    是你开始学习机器学习时通常学习的第一个算法。
- en: To acquire perspective, be aware that, before 1980, artificial intelligence
    and ML were part of the same corpora of knowledge. Then, artificial intelligence
    researchers focused their efforts on using logical, knowledge-based approaches,
    and ML kept the algorithmic approach, *regression* being the most basic and having
    neural network-based algorithms as its main bundle. Hence, this fact favored that
    ML evolved as a separated discipline.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得视角，请注意，在 1980 年之前，人工智能和机器学习是同一知识体系的一部分。然后，人工智能研究人员将他们的努力集中在使用逻辑、基于知识的途径上，而机器学习保持算法途径，*回归*
    是最基本的方法，其主要的算法包是基于神经网络的。因此，这一事实有利于机器学习作为一个独立的学科发展。
- en: Following path of the traditional research in neural networks in the '60s and
    '70s, ML kept on developing in this field. Then, its first golden age came in
    the '90s.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着 60 年代和 70 年代神经网络传统研究的路径，机器学习在这个领域持续发展。然后，它的第一个黄金时代出现在 90 年代。
- en: However, 25 years ago, the computer resources that a neural network required
    were not within the reach of normal PCs, since a huge amount of data needed to
    be processed to obtain accurate results. It was more than one decade later that
    computing capacity was available to everyone, and then problem-solving based on
    neural network algorithms finally became a commodity.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，25 年前，神经网络所需的计算机资源超出了普通个人电脑的范畴，因为需要处理大量数据才能获得准确的结果。直到十多年后，计算能力才对每个人开放，然后基于神经网络算法的问题解决最终成为了一种商品。
- en: This fact brings us to the present boom of ML, where functionalities such as
    content recommendation (shops, films, and music) and facial/ object recognition
    (camera-based apps) are used ubiquitously in most modern smartphones.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事实将我们带到了当前机器学习（ML）的繁荣时期，在这个时期，内容推荐（如商店、电影和音乐）以及面部/物体识别（基于摄像头的应用程序）等功能在大多数现代智能手机中被广泛使用。
- en: On the other side, robots started their path in the industry by 1950, being at
    the beginning just mechanical devices that performed repetitive motions. As artificial
    intelligence and its accompanying discipline, ML, developed in parallel, practical
    results in these fields could be transferred, since robots were also powered by
    similar CPUs to those with which ML problems were solved. Then, robots gradually
    acquired the capability to better accomplish actions by being aware of their effects
    in the environment. Data came from the robot's camera and sensors provides feedback
    to the *learning system* that allowed it to perform better every time. This learning
    system is just an ML pipeline.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，机器人从1950年开始在工业领域展开其道路，最初只是执行重复动作的机械装置。随着人工智能及其伴随的学科机器学习（ML）的并行发展，这些领域的实际成果可以转移，因为机器人也由与解决机器学习问题相似的CPU供电。然后，机器人逐渐获得了通过意识到它们在环境中的影响来更好地完成动作的能力。来自机器人的摄像头和传感器的数据为*学习系统*提供反馈，使得它每次都能表现得更好。这个学习系统实际上就是一个机器学习流程。
- en: And how different is robot learning from human learning? Well, our brain is
    far more efficient. To recognize for the first time whether an animal is a dog,
    a kid just needs four or five samples, while an ML algorithm needs hundreds to
    be accurate in its answers. This is the underlying reason why ML models used by
    robots need to be pretrained with lots of data so that the robot can respond—both
    **accurately** and in **real time**—with a smart action, that is, by picking an
    object from one location and moving it to another previously marked as the target
    (a typical problem in the logistics industry).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习与人类学习有何不同？嗯，我们的大脑要高效得多。要首次识别一个动物是狗还是孩子，一个小孩只需要四到五个样本，而一个机器学习算法需要数百个样本才能在答案上准确无误。这就是为什么机器人使用的机器学习模型需要用大量数据进行预训练的根本原因，这样机器人就可以通过智能动作——即从一个位置拿起一个物体并将其移动到另一个之前标记为目标的位置（这是物流行业的一个典型问题）——来**准确**和**实时**地做出反应。
- en: This task of identifying objects is what we will do in the practical example
    of this chapter. We will supply the robot with a trained model able to recognize
    different kinds of common objects (balls, mouses, keyboards, and so on) and will
    observe the response when putting it in front of several of these objects. Hence,
    let's keep on explaining the following concepts surrounding this practical example
    regarding the recognition of several kinds of objects.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个识别对象的任务就是我们将在本章的实际例子中要做的。我们将为机器人提供能够识别不同种类常见对象（如球、鼠标、键盘等）的训练模型，并将观察当将其置于这些对象之前时的反应。因此，让我们继续解释围绕这个实际例子中关于识别多种对象的相关概念。
- en: Core concepts in ML
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习中的核心概念
- en: 'Before going into the use case of object recognition in images, let''s take
    a much simpler example, the prediction of the price of a house as a function of
    several independent variables: area, number of rooms, distance to the center of
    the city, population density, and more.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入图像中对象识别的使用案例之前，让我们先来看一个更为简单的例子，即根据几个独立变量（如面积、房间数量、距离市中心距离、人口密度等）预测房价。
- en: 'First, to have a working ML algorithm, we need an underlying model that, when
    fed with input data, can produce a prediction. The data has to be supplied according
    to the features, that is, independent variables, that we have selected for our
    model. Then, establishing the correspondence with our simple example, we can explain
    the several concepts involved in an ML problem:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了有一个可以工作的机器学习算法，我们需要一个基础模型，当输入数据时，它可以产生预测结果。数据必须根据我们为模型选择的特征（即独立变量）提供。然后，通过与我们简单例子的对应，我们可以解释在机器学习问题中涉及的几个概念：
- en: The algorithm is the computation as a whole, specified as a sequence of instructions
    or steps that are to be followed to produce a result. All of the instructions
    have to be unambiguous and the actor that is running the algorithm does not have
    to make any additional decision; all of them are covered by the algorithm, which
    specifies what to do at a certain point if a condition needs to be evaluated.
    Then, you can easily infer that an algorithm is something that can be programmed
    in a computer, no matter which language is used. In the case of the example of
    the prediction of the price of a house, the algorithm consists of applying the
    sequence of instructions given sample data—that is, area, number of rooms, and
    so on—to obtain a prediction of its price.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法是整体计算，指定为一系列要遵循的指令或步骤，以产生一个结果。所有的指令都必须明确无误，执行算法的参与者不需要做出任何额外的决策；所有决策都包含在算法中，算法指定在需要评估条件时在某个特定点要做什么。然后，你可以轻松推断出算法是可以用计算机编程的，无论使用哪种语言。在预测房价的例子中，算法包括将给定的样本数据（即面积、房间数量等）的指令序列应用到数据上，以获得其价格预测。
- en: The model provides an assumption of the analytical function to apply to the
    input data to obtain a prediction. For example, we can say that the model for
    the price of the house is a linear function of the inputs, that is, given an increment
    in the percentage of the area of the house leads to the same percentual increment
    in its predicted price. For the rest of the independent variables, the same reasoning
    would apply because we have assumed a linear dependence. The model is applied
    in some steps of the algorithm.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型提供了一种分析函数的假设，该函数应用于输入数据以获得预测。例如，我们可以说房价模型是输入的线性函数，也就是说，给定房屋面积的百分比增加会导致其预测价格的百分比增加。对于其他独立变量，同样的推理也适用，因为我们假设了线性依赖。模型在算法的一些步骤中应用。
- en: The features are the independent variables of our model, that is to say, the
    available data that you have to predict the price of a house. In our example,
    these are area, number of rooms, distance to the center of the city, and population
    density.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征是我们模型的独立变量，也就是说，你必须用这些可用的数据来预测房价。在我们的例子中，这些是面积、房间数量、距离市中心和人口密度。
- en: The dataset is a structured data collection providing values for each of the
    selected features for a large number of items. In our example, the dataset should
    be a table in which each row contains the available data of a concrete house,
    and each column contains the values of each selected feature, that is, a surface
    column, number of rooms column, distance to the center of the city column, population
    density column, and so on.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据集是一个结构化数据集合，为所选的每个特征提供大量物品的值。在我们的例子中，数据集应该是一个表格，其中每一行包含一个具体房屋的可供数据，每一列包含每个所选特征的值，即面积列、房间数量列、距离市中心列、人口密度列等。
- en: 'When facing a new problem, the data scientist has to decide for all of these
    three elements: the algorithm, the model, and the features. The last topic, feature
    selection, is where there''s the added value that a human provides to solving
    an ML problem; the rest of the tasks are automated and accomplished by a computer.
    The next subsection explains in detail what features are and emphasizes the importance
    of their selection to obtain accurate predictions.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 面对新的问题时，数据科学家必须决定这三个要素：算法、模型和特征。最后一个话题，特征选择，是人为解决机器学习问题提供额外价值的地方；其余任务都是自动化的，由计算机完成。下一个小节将详细解释特征是什么，并强调其选择对于获得准确预测的重要性。
- en: Selecting features in ML
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习中的特征选择
- en: Features in ML constitute a set of characteristics that have to be selected
    by the user, and it is this selection upon which the dataset is built. The expertise
    for making a good feature selection is more a question of experience and insight
    than a structured process. Hence, a good data scientist is one who understands
    the problem and can decompose it in its essential parts to find what the relevant
    features are. These act as the independent variables from which accurate predictions
    can be made.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习中的特征构成一组必须由用户选择的特性，并且数据集的构建是基于这个选择的。做出良好特征选择的专业知识更多的是一个问题，即经验和洞察力，而不是一个结构化的过程。因此，一个好的数据科学家是理解问题并能将其分解为其基本部分以找到相关特征的人。这些特征作为独立变量，可以从它们中做出准确的预测。
- en: 'To solve an ML problem, it is crucial to perform the right feature selection.
    If you do not detect the relevant features, no matter how much data you put in
    the solver, you will never get a good prediction. As shown in the following diagram,
    we will feed the ML algorithm with a data collection to obtain a result, that
    is, a prediction:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决一个机器学习问题，进行正确的特征选择是至关重要的。如果你没有检测到相关的特征，无论你向求解器投入多少数据，你都不会得到一个好的预测。如下所示，我们将数据集输入到机器学习算法中，以获得一个结果，即预测：
- en: '![](img/4835e387-64c0-47ef-b82e-3487f14183ae.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4835e387-64c0-47ef-b82e-3487f14183ae.png)'
- en: Data collection has been built according to the selected features. For example,
    if you decide to build the model for price prediction of the houses in a given
    city based on three features—area, number of rooms, and distance to the center
    of the city—for every new house you want to predict the price of, you will have
    to feed the algorithm with the specific values of such features, for example,
    85 square meters, 4 rooms, and 1.5 kilometers to the center of the city.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 数据收集是根据选定的特征构建的。例如，如果你决定基于三个特征——面积、房间数量和距离市中心——为给定城市的房屋建立价格预测模型，那么对于你想要预测价格的每一座新房屋，你必须向算法提供这些特征的特定值，例如，85平方米、4个房间和距离市中心1.5公里。
- en: Next, it is crucial to understand how the values of these features are combined
    to obtain the prediction.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，理解这些特征值是如何组合起来以获得预测的是至关重要的。
- en: The ML pipeline
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习流程
- en: 'Problem-solving is split into two parts. The first is training the model according
    to the pipeline shown in this diagram:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 问题解决分为两部分。第一部分是根据此图所示的流程训练模型：
- en: '![](img/0e8f3cab-07f2-491d-99e1-16ab3d6c723a.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0e8f3cab-07f2-491d-99e1-16ab3d6c723a.png)'
- en: 'Since we are assuming a simple model where the output depends linearly on the
    values of the features, the goal of training consists of determining the weights
    to be applied to each of them to obtain the prediction. Let''s explain it with
    this mathematical formulation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们假设一个简单的模型，其中输出线性依赖于特征值，因此训练的目标是确定应用于每个特征的权重，以获得预测。让我们用这个数学公式来解释它：
- en: '*Price = W1 * area + W2 * nº rooms + W3 * distance*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*价格 = W1 * 面积 + W2 * 房间数 + W3 * 距离*'
- en: As you may infer, the weights, *W1*, *W2*, and *W3*, are the coefficients that
    multiply each feature. After making the sum of the three products, we obtain the
    predicted price. So, the training phase consists of finding the set of weights
    that best fit the dataset we have available. In the training set, the data contains
    both the features and the actual prices. Hence, by applying the algorithm of least
    square regression ([https://www.statisticshowto.datasciencecentral.com/least-squares-regression-line/](https://www.statisticshowto.datasciencecentral.com/least-squares-regression-line/)),
    we determine the set of values for *W1*, *W2*, and *W3* that best fit all of the
    actual prices supplied. This algorithm guarantees that the resulting equation
    is the one that provides the minimum global error for all of the items used for
    the training.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所推断，权重，*W1*、*W2*和*W3*，是乘以每个特征的系数。在将三个乘积相加后，我们得到预测价格。因此，训练阶段包括找到最适合我们现有数据集的权重集。在训练集中，数据包含特征和实际价格。因此，通过应用最小二乘回归算法（[https://www.statisticshowto.datasciencecentral.com/least-squares-regression-line/](https://www.statisticshowto.datasciencecentral.com/least-squares-regression-line/)），我们确定*W1*、*W2*和*W3*的最佳值，以最适合所有提供的实际价格。此算法保证所得方程是提供所有用于训练的项目最小全局误差的方程。
- en: 'But we do not want to best fit only the supplied data since we already know
    these prices. We wish that the resulting equation also be the best fit for any
    other house for which we do not know the price. So, the way to validate such an
    equation is by using a different dataset, called the test set, from the one we
    used for training. The programmatic way to do this is by splitting the available
    data before performing the training. The typical approach is to make two random
    sets: one containing 70%-90% of the data for training and another with the remaining
    30-10% to perform the validation. This way, the training set provides us with
    the provisional best-fit weights, *W1*, *W2*, and *W3*, and the validation set
    is used to estimate how well our ML model is operationally defined as the least
    square error.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不想仅仅拟合提供的数据，因为我们已经知道这些价格。我们希望得到的方程也能是任何其他未知价格的房子的最佳拟合。因此，验证这种方程的方法是使用一个不同的数据集，称为测试集，而不是我们用于训练的数据集。在执行训练之前，程序化的方法是分割可用的数据。典型的方法是制作两个随机集：一个包含70%-90%的数据用于训练，另一个包含剩余的30%-10%用于验证。这样，训练集为我们提供了暂时的最佳拟合权重W1、W2和W3，而验证集用于估计我们的机器学习模型在操作上定义得有多好，即最小平方误差。
- en: 'The second part corresponds to the prediction itself, that is, when our ML
    algorithm is put in production in a real application. In the prediction (production)
    phase, we have the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分对应于预测本身，即当我们的机器学习算法在实际应用中投入生产时。在预测（生产）阶段，我们有以下内容：
- en: '![](img/57329b5c-ad0c-4a9a-9fb9-8bfdbef7228b.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/57329b5c-ad0c-4a9a-9fb9-8bfdbef7228b.png)'
- en: The process of ML, in reality, is more a circular one than a linear one because,
    as we get more data for training, we can improve the calculation of the weights,
    and then rewrite the equation with the new set of coefficients, *W1*, *W2*, and *W3*.
    This way, ML is an iterative process that can improve the accuracy of predictions
    as more data is available and the model is retrained again and again.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，机器学习的过程更像是循环的，而不是线性的，因为随着我们获得更多的训练数据，我们可以改进权重的计算，然后用新的系数集重新编写方程，即W1、W2和W3。这样，机器学习是一个迭代的过程，随着更多数据的可用性和模型的反复重新训练，可以提高预测的准确性。
- en: From ML to deep learning
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从机器学习到深度学习
- en: In this section, you will understand what deep learning is and how it relates
    to ML. And the most straightforward way to get this insight is by giving a quick
    overview of the most commonly used algorithms. Then, from that perspective, you
    could appreciate why deep learning is the most active area of research nowadays.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解深度学习是什么以及它与机器学习的关系。而获得这种洞察力的最直接方法就是简要概述最常用的算法。然后，从那个角度来看，你可以理解为什么深度学习现在是研究最活跃的领域。
- en: ML algorithms
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习算法
- en: As pointed out in the preceding diagram and explanations, the algorithm is the
    central part of ML problem-solving. A data scientist has also to select which
    one to apply depending on the kind of problem they are facing. So, let's have
    a quick overview of the most commonly used algorithms.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图和解释所指出的，算法是机器学习问题解决的中心部分。数据科学家还必须根据他们面临的问题类型选择应用哪种算法。所以，让我们快速概述一下最常用的算法。
- en: Regression
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回归
- en: 'Regression tries to find the curve that best fits a cloud of points, and it
    has been described in detail with the case of the prediction of house prices.
    In such a case, we have been talking about a linear dependency, but the algorithm
    can be generalized to any kind of curve that can be represented as a sum of dot
    products between coefficients (weights) and independent variables (features),
    that is, a polynomial. A common case is that of a term that is the square of a
    feature. In this case, the curve is a parabola and, mathematically, can be expressed
    as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 回归试图找到最适合点云的曲线，并且已经在预测房价的案例中进行了详细描述。在这种情况下，我们一直在谈论线性依赖，但算法可以推广到任何可以用系数（权重）和自变量（特征）之间的点积之和表示的曲线，即多项式。一个常见的例子是特征的平方项。在这种情况下，曲线是抛物线，从数学上可以表示如下：
- en: '*y = W1 * x + W2 * x² + W3 * 1*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*y = W1 * x + W2 * x² + W3 * 1*'
- en: 'Let''s review this with a real-life example. Given an independent variable,
    the years of experience of a candidate, we wish to predict what their salary will
    be when applying for a job opportunity. You can easily understand that the dependence
    of the salary, at least during the first years of experience, does not follow
    a linear dependence, that is, a candidate with 2 years will not get twice the
    salary with respect to when he/she had one year of experience. Percentual increments
    in salary will be gradually higher as he/she accumulates more experience. This
    kind of relationship can be modeled as a parabola. Then, from the independent
    variable, *x*, and the salary, we define two features: *x* and *x²*.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个现实生活中的例子来回顾一下。给定一个独立变量，即候选人的工作经验年数，我们希望预测他们在申请工作机会时的薪资。您很容易理解，至少在工作经验的前几年，薪资的依赖性并不遵循线性依赖，也就是说，拥有2年工作经验的候选人不会比拥有1年工作经验时获得两倍的薪资。随着他们积累更多经验，薪资的百分比增长将逐渐更高。这种关系可以用抛物线来建模。然后，从独立变量*x*和薪资，我们定义两个特征：*x*和*x²*。
- en: Logistic regression
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑回归
- en: Logistic regression is used in classification problems, a very common type in
    ML. In this case, we try to predict a binary classification such as pass/fail,
    win/lose, alive/dead, or healthy/sick. This algorithm can be understood as a special
    case of regression, where the predicted variable is categorical, that is, it can
    only take a finite set of values (two if it is a binary classification). The underlying
    model is a probability function and, given a value of the independent variable,
    if the resulting probability is greater than 50%, we predict pass, win, alive,
    or healthy, and if lower, the prediction is the other category, that is, fail,
    lose, dead, or sick.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑回归用于分类问题，这是机器学习中非常常见的一种类型。在这种情况下，我们试图预测一个二元分类，例如通过/失败、赢/输、生/死或健康/生病。这个算法可以理解为回归的特殊情况，其中预测变量是分类的，也就是说，它只能取有限集合的值（如果是二元分类，则为两个）。基础模型是一个概率函数，给定一个独立变量的值，如果得到的概率大于50%，我们预测通过、赢、生或健康，如果低于50%，预测就是另一个类别，即失败、输、死或生病。
- en: Product recommendation
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品推荐
- en: Product recommendation is the most used functionality in the consumer sector,
    for example, shopping, watching films, and readings books, taking as input user
    characteristics and well-rated items by other users with similar characteristics.
    There are several algorithms to implement this functionality such as collaborative
    filtering or featurized matrix factorization. If you are interested in this field,
    we provide good introduction references in the *Further reading* section at the
    end of this chapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 产品推荐是消费者领域最常用的功能，例如购物、看电影和阅读书籍，输入用户特征以及具有相似特征的其他用户的高评分项目。实现此功能有多种算法，如协同过滤或特征化矩阵分解。如果您对这个领域感兴趣，我们在本章末尾的*进一步阅读*部分提供了良好的介绍性参考文献。
- en: Clustering
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚类
- en: 'Clusteringis a scenario where we have many items and we want to group them
    by similarity. In this case, items are unlabeled and we ask the algorithm to do
    two things:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类是一种场景，其中我们有许多项目，我们希望根据相似性将它们分组。在这种情况下，项目是无标签的，我们要求算法做两件事：
- en: Make a group of similar items.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将相似的项目组成一组。
- en: Label these groups so that new items are both classified and labeled by the
    algorithm.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '标记这些组，以便新项目既被算法分类又被标记。 '
- en: 'As an example, think of a collection of texts about many topics and you wish
    the algorithm to group similar texts and identify the main topic of each group,
    that is, label them: history, science, literature, philosophy, and so on. One
    of the classical algorithms for this scenario is the nearest neighbor method,
    where you define a metric, calculate it for each pair of items, and group together
    those pairs that are close enough (based on the defined metric). It can be though
    as a distance-like function that is computed between each set of two points.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个关于许多主题的文本集合，您希望算法将相似文本分组并识别每个组的主要主题，即对它们进行标记：历史、科学、文学、哲学等。用于这种场景的经典算法之一是最近邻方法，其中您定义一个度量标准，为每一对项目计算它，并将足够接近的（基于定义的度量标准）对分组在一起。它可以被认为是一种计算在每一对两点之间的距离类似的函数。
- en: 'A **multiclassification scenario**, where there are more than two categories—let''s
    say n—is addressed by solving n logistic regressions where each one performs a
    binary classification for each of the possible categories. For example, if we
    want to detect the dominant color in an image (of four possible categories: red,
    green, blue, or yellow), we can build a classifier consisting of four logistic
    regressions, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在**多分类场景**中，如果有超过两个类别——比如说n个——可以通过解决n个逻辑回归来处理，其中每个逻辑回归对每个可能的类别执行二分类。例如，如果我们想检测图像中的主要颜色（有四种可能的类别：红色、绿色、蓝色或黄色），我们可以构建一个由四个逻辑回归组成的分类器，如下所示：
- en: Red/NOT red
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色/非红色
- en: Green/NOT green
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绿色/非绿色
- en: Blue/NOT blue
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝色/非蓝色
- en: Yellow/NOT yellow
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黄色/非黄色
- en: There could be a fifth category, which we can call *unknown*, for cases in which
    the image is not classified in any of the red, green, blue, or yellow colors.
    Finally, this type of multi-logistic regression applied to images is the entrance
    door to the last algorithm, deep learning, on which we will focus from now until
    the end of this chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在第五个类别，我们可以称之为*未知*，对于图像没有被归类为红色、绿色、蓝色或黄色的情况。最后，这种应用于图像的多逻辑回归类型是进入最后一种算法——深度学习——的大门，我们将从现在开始直到本章结束都聚焦于此。
- en: Deep learning
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度学习
- en: Deep learning is the most active research field in ML nowadays. The underlying
    model of this algorithm is a neural network whose way of working tries to mimic
    what the human brain does. Each neuron in the model performs a regression from
    its input with a special function, called **sigmoid**, that provides a sharp but
    continuous probability distribution of the output event. This function is the
    same as that of the probability function used in **logistic regression,** as described
    earlier. In this particular case of a neuron, if the resulting probability is
    greater than 50%, the neuron is activated and feeds another neuron or neurons
    downstream. If lower than 50%, the neuron is not active and hence it has negligible
    influence downstream.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习现在是机器学习中最活跃的研究领域。该算法的底层模型是一个神经网络，其工作方式试图模仿人脑的工作方式。模型中的每个神经元都使用一个特殊的功能——称为**sigmoid**——从其输入进行回归，该功能提供了一个尖锐但连续的输出事件的概率分布。这个函数与之前描述的**逻辑回归**中使用的概率函数相同。在这种情况下，如果得到的概率大于50%，则神经元被激活并向下传递给另一个或多个神经元。如果低于50%，则神经元不活跃，因此对下游的影响可以忽略不计。
- en: Next, we are going to provide more details about how deep learning works so
    that when you perform the practical exercise with GoPiGo3, you know what it is
    going on under the hood in ROS.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将提供更多关于深度学习工作原理的细节，这样当你使用GoPiGo3进行实际练习时，你就知道在ROS中发生了什么。
- en: Deep learning and neural networks
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度学习和神经网络
- en: 'From now on, we will base our explanations on the practical example of the recognition
    of objects in images, which, in the case of the robot, will be supplied by the
    Raspberry Pi camera. In the following diagram, you can see a representation of
    a neural network that differentiates the three kinds of layers that there can
    be:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将基于图像中物体识别的实际例子来解释我们的说明，对于机器人来说，这些信息将由树莓派摄像头提供。在下面的图中，你可以看到一个表示神经网络的图示，它区分了可能存在的三种层：
- en: The input layer is where we feed the dataset. Remember that such data has to
    be structured according to the selected features, that is, one neuron per feature.
    We will later discuss this particular and very common case of image datasets.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入层是我们提供数据集的地方。记住，这样的数据必须根据所选特征进行结构化，也就是说，每个特征一个神经元。我们稍后将会讨论这种特定且非常常见的图像数据集案例。
- en: The hidden layer(s)—one or more—are the intermediate steps in the deep learning
    pipeline that extract more features so that the algorithm is more capable of discriminating
    between objects. These hidden features are implicit, and the end user does not
    necessarily need to know about them because their extraction is intrinsic (automatic)
    to the network structure itself.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏层（一个或多个）是深度学习管道中的中间步骤，它们提取更多特征，以便算法能够更好地区分对象。这些隐藏特征是隐含的，并且最终用户不一定需要了解它们，因为它们的提取是网络结构本身的内在（自动）属性。
- en: 'The output layer provides the prediction. Each neuron provides a logical 1
    if activated (a probability greater than 50%) or a 0 if not activated (lower than
    50%). So, the resulting probability in the output layer will be the answer with
    a certain probability:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出层提供预测。如果一个神经元被激活（概率大于50%），则每个神经元提供一个逻辑1，如果没有被激活（低于50%），则提供一个0。因此，输出层的最终概率将是带有一定概率的答案：
- en: '![](img/251eae31-f607-45ba-a251-52ce7c9e502e.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/251eae31-f607-45ba-a251-52ce7c9e502e.png)'
- en: License CC-BY-SA-2.5 source: https://commons.wikimedia.org/wiki/File:Neural_Network.gif
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 许可证 CC-BY-SA-2.5 来源：https://commons.wikimedia.org/wiki/File:Neural_Network.gif
- en: Following a sequential approach, let's explain how a neural network works by
    covering what each layer makes on the supplied input data.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 按照顺序方法，让我们通过解释每一层对输入数据的作用来解释神经网络是如何工作的。
- en: The input layer
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入层
- en: 'This is the first step of the deep learning pipeline, and the most common structure
    of this layer is to have as many input neurons (features) as three times the number
    of pixels the image has:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是深度学习管道的第一步，这一层的最常见结构是拥有与图像像素数三倍一样多的输入神经元（特征）：
- en: For images of a size of 256 x 256 pixels, this means 65.536 pixels.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于256 x 256像素大小的图像，这意味着65.536像素。
- en: 'In general, we will deal with color images, so each pixel will have three channels:
    red, blue, and green; each value stands for the intensity ranging from 0 to 255
    for 8 bits of color depth.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，我们将处理彩色图像，因此每个像素将有三个通道：红色、蓝色和绿色；每个值代表从0到255的强度，颜色深度为8位。
- en: Then, the number of features is *65.536 x 3 = 196.608* and the value of each
    feature will be a number between 0 and 255\. Each feature is represented with
    one neuron in the input layer.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，特征的数量是 *65.536 x 3 = 196.608*，每个特征的价值将是一个介于0到255之间的数字。每个特征都由输入层中的一个神经元表示。
- en: 'Afterwards, the neural network is asked to answer this question: is there a
    cat in the picture? And the goal of the next layers is to extract the essential
    aspects of the image to answer that question.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，神经网络被要求回答这个问题：图片中是否有猫？下一层的目的是提取图像的必要方面来回答这个问题。
- en: The hidden layer(s)
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏层（s）
- en: 'For understanding how this layer works, let''s go back to the regression algorithm we
    explain earlier. There, we expressed the predicted variable as a linear combination
    of features—area, number of rooms, and distance to the center multiplied by weights,
    respectively, *W1*, *W2*, and *W3*. Establishing the analogy with our neural network,
    the features would apply to the neurons and the weights to the edges that connect
    each pair of neurons:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一层是如何工作的，让我们回顾一下我们之前解释的回归算法。在那里，我们将预测变量表示为特征的线性组合——面积、房间数量和到中心的距离分别乘以权重，即
    *W1*、*W2* 和 *W3*。将我们的神经网络与之类比，特征将应用于神经元，权重将应用于连接每一对神经元的边：
- en: '![](img/5b9b28ae-5bc2-4294-90c5-a3a1156d488f.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b9b28ae-5bc2-4294-90c5-a3a1156d488f.png)'
- en: 'Source: https://commons.wikimedia.org/wiki/File:Artificial_neural_network_pso.png,
    Cyberbotics Ltd.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：https://commons.wikimedia.org/wiki/File:Artificial_neural_network_pso.png,
    Cyberbotics Ltd.
- en: CC BY-SA 3.0 https://creativecommons.org/licenses/by-sa/3.0
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: CC BY-SA 3.0 https://creativecommons.org/licenses/by-sa/3.0
- en: The value of each feature would be processed with the sigmoid function of its
    neuron (input layer; *j* neurons) to produce a probability value, *Sij*, which
    is then multiplied by the weight, *Wij*, of the edge that connects it to each
    neuron downstream (hidden layer ; *i* neurons). Hence, the feature input to this
    neuron, *i*, in the hidden layer is a sum of products, there being as many terms
    as neurons are connected to it upstream (input layer ; *j* neurons).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每个特征的价值将使用其神经元的sigmoid函数（输入层；*j* 神经元）进行处理，以产生一个概率值，*Sij*，然后乘以连接到每个下游神经元（隐藏层；*i*
    神经元）的边权重 *Wij*。因此，隐藏层中神经元 *i* 的特征输入是一个乘积之和，其项数与上游连接到它的神经元数量（输入层；*j* 神经元）一样多。
- en: Such a result is the sum over *j* of all of the terms, *Sij*, with the index, *j*,
    which is an iterator that ranges over all of the neurons connected to *i* neurons
    in the input layer. The weights *Wij* of the edges connecting pairs of neurons
    are more properly called **hyperparameters**.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的结果是所有 *j* 的项之和，*Sij*，其中索引 *j* 是一个迭代器，它遍历连接到输入层中 *i* 神经元的所有神经元。连接神经元对的边的权重
    *Wij* 更恰当地称为**超参数**。
- en: The neural structure of the hidden layers provides what we call intrinsic features,
    which are inherent properties of the network and do not have to be selected by
    the user (they are established by the designer of the neural network). What the
    user has to do is to train the network to obtain the best set of weights, *Wij*,
    that makes the network to as predictive as possible with the available dataset.
    Here is where the magic of deep learning resides because a well-designed architecture
    of layers can provide a very accurate predictive model. The downside is that you
    need a lot of data to get a well-trained network.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏层的神经网络结构提供了我们所说的内在特征，这些是网络的固有属性，不需要用户选择（它们由神经网络的开发者建立）。用户需要做的是训练网络以获得最佳的一组权重，*Wij*，使网络尽可能准确地预测可用数据集。这就是深度学习的魔力所在，因为精心设计的层架构可以提供非常准确的预测模型。缺点是您需要大量的数据来获得一个训练良好的网络。
- en: 'Recapping from the beginning, given an input image, you can calculate the feature
    input to the neurons of each layer, *Fi*, based on the probabilities from the
    previous layer, *Sij*, and the weights, *Wij*, of the edges connecting to neuron
    *i*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始回顾，给定一个输入图像，您可以根据前一层，*Sij*，和连接到神经元*i*的边的权重，*Wij*，计算每个层神经元的特征输入，*Fi*：
- en: '*Fi = (sum over j) [Sij * Wij]*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*Fi = (对j求和) [Sij * Wij]*'
- en: Proceeding downstream layer by layer, you can finally obtain the probabilities
    of the neurons of the output layer and, therefore, answer with the prediction
    of what the analyzed image contains.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 逐层向下进行，您最终可以获得输出层神经元的概率，因此可以回答分析图像包含的预测。
- en: As was mentioned earlier, and given that complexity of the network structure,
    you may guess that, for training such a model, you would need much more data than
    for traditional ML algorithms such as regression. More specially, what you have
    to calculate are the values of how many hyperparameters as edges connecting pairs
    of neurons there are. Once you achieve this milestone, you get a trained network
    that can be applied to unlabeled images to predict its content.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，鉴于网络结构的复杂性，您可能会猜测，为了训练这样的模型，您可能需要比传统机器学习算法（如回归）更多的数据。更具体地说，您需要计算有多少超参数作为连接成对神经元的边。一旦达到这个里程碑，您就会得到一个训练好的网络，可以应用于未标记的图像以预测其内容。
- en: The output layer
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出层
- en: 'For the question of our example, that is, there is a cat in the picture? yes
    if the image shows a cat, or not if it doesn''t. So we only need a neuron in the
    output layer, as shown in the diagram below. Then, if trained with many photos
    of cats, this network could classify an image to say whether it contains a cat
    (1) or not (0). An important point here is that the model should be able to identify the
    cat whatever position it occupies in the image, center, left, right, top, down,
    and so on:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们示例中的问题，即图片中是否有一只猫？如果是，则图像显示猫，否则不是。所以，我们只需要输出层中的一个神经元，如图所示。然后，如果用许多猫的照片进行训练，这个网络可以分类图像，以判断它是否包含猫（1）或不包含（0）。这里的一个重要点是，模型应该能够识别图像中猫的任何位置，中心、左、右、上、下等：
- en: '![](img/38dc3fe0-59c4-4718-9f10-86034d2c1d88.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/38dc3fe0-59c4-4718-9f10-86034d2c1d88.png)'
- en: Source: https://commons.wikimedia.org/wiki/File:NeuralNetwork.png
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：https://commons.wikimedia.org/wiki/File:NeuralNetwork.png
- en: If we need to classify 10 kinds of objects (several types of pets, for example),
    we would need an output layer with 10 neurons. The result of the computation of
    the network would be a vector with 10 probabilities—each one linked to each neuron,
    and the one that provides the largest value (the closest to 100%) would tell us
    what kind of pet there is in the input image with more probability.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要分类10种对象（例如几种类型的宠物），我们需要一个有10个神经元的输出层。网络的计算结果将是一个包含10个概率的向量——每个概率都与每个神经元相关联，提供最大值（最接近100%）的那个将告诉我们输入图像中更可能有什么类型的宠物。
- en: 'Of course, you can make the network more complex and add more output neurons
    (and possibly more hidden layers) to obtain more details of the images. Consider
    the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以使网络更复杂，添加更多的输出神经元（以及可能的更多隐藏层）以获得图像的更多细节。考虑以下内容：
- en: Identify whether there is one cat or two or more.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别是否有一只猫或两只或更多。
- en: 'Identify characteristics of the face, such as whether the eyes and/or mouth
    are open or closed:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别面部特征，例如眼睛和/或嘴巴是张开还是闭合：
- en: '![](img/58274728-a20d-4abb-bcfd-cb5a5a82d307.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/58274728-a20d-4abb-bcfd-cb5a5a82d307.png)'
- en: 'Source: https://www.flickr.com/photos/55855622@N06/5173363938 by jeici1, License:
    CC BY 2.0'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：https://www.flickr.com/photos/55855622@N06/5173363938 by jeici1，许可：CC BY
    2.0
- en: This is a quite complex topic and beyond of the scope of this introductory chapter,
    whose goal is just to provide a descriptive understanding of what deep learning
    is and how it works. Anyway, the reader is encouraged to delve deeper into the
    topic, and for that, two didactic references are included in the *Further reading*
    section at the end of this chapter: *Intuitive Deep Learning Parts 1 and 2*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当复杂的话题，超出了本介绍章节的范围，其目标只是提供一个对深度学习是什么以及它是如何工作的描述性理解。无论如何，鼓励读者深入研究这个话题，为此，在本章末尾的“进一步阅读”部分包含了两个教学参考：*直观深度学习第1部分和第2部分*。
- en: From this point, we move to the practical part and start by stating a general
    methodology to tackle ML problems in robotics.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个点开始，我们转向实际部分，首先陈述一个处理机器人中机器学习问题的通用方法。
- en: A methodology to programmatically apply ML in robotics
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在机器人中程序化应用机器学习的方法
- en: A specific aspect of ML is that robot responses have to happen in real time,
    without delays, so that the actions taken are effective. For example, if it finds
    an obstacle crossing the path it is following, we expect that it avoids it. To
    do so, obstacle identification has to occur as it appears in the robot's field
    of view. Hence, the subsequent action of avoiding the obstacle has to be taken
    immediately to avoid a crash.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习的一个特定方面是，机器人的响应必须实时发生，没有延迟，这样采取的行动才是有效的。例如，如果它发现一个障碍物横在它正在跟随的路径上，我们期望它能避开它。为此，障碍物识别必须发生在机器人视野中出现时。因此，避免障碍物的后续行动必须立即采取，以避免碰撞。
- en: We will support our methodology description with an end-to-end example that
    covers all that GoPiGo3 can do up to this point. Then, with this example, we expect
    that GoPiGo3 can carry a load on top of its chassis from its current location
    to a target location (a common case in garbage collector robots).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用一个端到端的示例来支持我们的方法描述，这个示例涵盖了GoPiGo3目前能做的所有事情。然后，通过这个示例，我们期望GoPiGo3能够从当前位置携带负载到目标位置（这在垃圾收集机器人中是一个常见的情况）。
- en: A general approach to application programming
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序编程的一般方法
- en: 'The steps involved in solving this challenge are as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个挑战所涉及的步骤如下：
- en: Determine what high-level tasks are involved.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定涉及哪些高级任务。
- en: List the atomic tasks that, put together, are capable of accomplishing the high-level
    tasks. This is the level at which we create our program in ROS, writing node scripts
    and launch files.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出构成高级任务的原子任务。在这个层面上，我们在ROS中创建程序，编写节点脚本和启动文件。
- en: Program the robot application by adapting the algorithms of the high-level tasks
    to the specific situation we are trying to solve.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调整高级任务的算法以适应我们试图解决的特定情况来编程机器人应用。
- en: 'Next, we provide a breakdown of each of these steps so that we can implement
    the functionality in the real robot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对每个步骤进行分解，以便我们可以在真实机器人中实现功能：
- en: 'These are the high-level tasks to be carried out:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些是需要执行的高级任务：
- en: '**SLAM**: This is **Simultaneous Localization and Mapping **(**SLAM**) to build
    a map of the actual environment.'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SLAM**：这是**同时定位与建图**（SLAM）来构建实际环境的地图。'
- en: '**Navigation**: Setting a target pose, GoPiGo3 can move autonomously until
    achieving it.'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航**：设置目标姿态，GoPiGo3可以自主移动，直到达到目标。'
- en: '**Visual recognition**: GoPiGo3 can identify where it has to be placed so that
    the garbage it carries can be collected.'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视觉识别**：GoPiGo3可以识别它需要放置的位置，以便收集它携带的垃圾。'
- en: 'List the atomic tasks that are involved in the example. Let''s say that, to
    be successful, GoPiGo3 has to be able to do the following:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出例子中涉及的原子任务。比如说，为了成功，GoPiGo3必须能够做到以下这些：
- en: Load a map of the environment.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载环境地图。
- en: Calculate an optimum path to achieve the target location given the information
    from the map.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据地图信息计算达到目标位置的优化路径。
- en: Start navigating toward the goal.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始向目标导航。
- en: Avoid obstacles found along the path.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 避开路径上发现的障碍物。
- en: Stop if unexpected conditions are found in the environment that do not let it
    advance anymore. Then, ask for help.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在环境中发现意外条件，阻止它进一步前进，然后寻求帮助。
- en: After receiving help, resume the path to the target location.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在收到帮助后，继续前往目标位置的路。
- en: Recognize the garbage store entrance and stop at the exact position where a
    hoist will hook the loaded garbage.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别垃圾存储入口，并停在吊车将钩住装载垃圾的确切位置。
- en: 'Program the robot application. Each of the preceding atomic tasks will correspond
    to a ROS node script, which can be expressed as a launch file with just one `<node>`
    tag. Then, you have to put these seven nodes on a ROS graph and draw the edges
    that should connect pairs using topics:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程机器人应用程序。前面的每个原子任务将对应一个ROS节点脚本，这可以表示为一个只有一个`<node>`标签的启动文件。然后，你必须将这些七个节点放在ROS图中，并绘制应该使用主题连接成对的边：
- en: For each published topic, you should determine which frequency the topic should
    be published with so that the robot can react quickly enough. For example, since
    the typical speed of GoPiGo3 is 1 m/s, we wish the scan distance to be updated
    10 times every 1 m traveled. This means that the robot will receive a perception
    update every 10 cm(=0.1 m) traveled and will be able to detect the presence of
    obstacles outside of a circumference of 0.1 m radius. The minimum publishing rate
    so that the robot can react to avoid the obstacle is calculated with this simple
    formula: *(1 m/s) /0.1 m = 10 Hz*.
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个发布的主题，你应该确定主题应该以多高的频率发布，以便机器人能够快速反应。例如，由于GoPiGo3的典型速度为1米/秒，我们希望扫描距离每1米更新10次。这意味着机器人每前进10厘米（=0.1米）就会收到一个感知更新，并且能够检测到半径为0.1米的圆周外的障碍物存在。为了使机器人能够反应并避开障碍物，计算机器人可以反应的最小发布速率的简单公式为：*(1
    m/s) / 0.1 m = 10 Hz*。
- en: For each topic a node is subscribed to the code should trigger a robot action
    that allows it to successfully adapt to such conditions in the environment. For
    example, given the topic providing distances around GoPiGo3, when its value is
    below a threshold, 20 cm, for example (you will see now where this number comes
    from), GoPiGo3 recalculates the local path to avoid the obstacle. We should select
    this threshold according to the 10 Hz rate of publishing we decided previously;
    remember that this rate came from the fact that the robot will receive a perception
    update every 10 cm traveling. Taking a safety factor of 2, the threshold is simply
    *10 cm * 2 = 20 cm*, providing room and time so that it avoids the obstacle.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个节点订阅的主题，代码应该触发一个机器人动作，使其能够成功适应环境中的这种条件。例如，给定提供GoPiGo3周围距离的主题，当其值低于一个阈值，例如20厘米（你将看到这个数字的来源），GoPiGo3将重新计算局部路径以避开障碍物。我们应该根据之前决定的10赫兹的发布速率来选择这个阈值；记住，这个速率来自机器人每前进10厘米就会收到一个感知更新的事实。考虑到2的安全系数，阈值简单地为*10厘米
    * 2 = 20厘米*，为避开障碍物提供空间和时间。
- en: There's no need for ML currently now for atomic tasks 1 through 6\. But when
    it comes to aligning with the garbage stop entrance, GoPiGo3 needs to know not
    only its pose but also its relative position to the entrance, so that the hoist
    can successfully hook the loaded garbage.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 目前对于原子任务1到6，不需要机器学习。但是，当涉及到与垃圾停止入口对齐时，GoPiGo3需要知道的不只是它的姿态，还有它相对于入口的位置，这样吊车才能成功地将装载的垃圾钩住。
- en: Integrating an ML task
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成机器学习任务
- en: 'This node of step 7 formulates its functionality as* recognize the garbage
    store entrance and stop at the exact position where a hoist will hook the loaded
    garbage*. Hence, the Pi camera comes to the rescue and image recognition capability
    has to be included in the logic programming of this node. This logic can be briefly
    expressed as publishing the `cmd_vel` messages to robot differential drives that
    allow GoPiGo3 to be put right in place. So, it is a feedback mechanism between
    visual perception, that is, entrance shape alignment in the image or not, and
    a motion command to correct and center:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第7步的这个节点将其功能定义为*识别垃圾存储入口并在吊车将装载的垃圾钩住的精确位置停止*。因此，Pi相机发挥了作用，并且必须在节点的逻辑编程中包含图像识别能力。这个逻辑可以简要地表达为发布`cmd_vel`消息到机器人的差速驱动器，使GoPiGo3能够正好放置在正确的位置。因此，这是一个视觉感知（即图像中入口形状的对齐与否）和运动命令之间的反馈机制，以纠正和居中：
- en: If the entrance is shifted to the left in the image, the robot should rotate
    left.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果图像中的入口向左偏移，机器人应该向左旋转。
- en: And if deviated to the right, it should rotate right an angle proportional to
    the distance from the entrance to the center of the image.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果向右偏离，它应该旋转一个与入口到图像中心的距离成比例的角度。
- en: 'And your very first question should be: how can we integrate such an ML task
    with our robotic application? And the answer comes to enlighten how the ROS publish/subscribe
    mechanism is both powerful and simple at the same time. Its neutral nature allows
    us to integrate any kind of task that can be packaged into a black box by adhering
    to the following two rules:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该首先问的问题应该是：我们如何将这样的机器学习任务与我们的机器人应用集成？答案将阐明ROS发布/订阅机制既强大又简单。其中立性允许我们通过遵守以下两个规则将任何可以封装成黑盒的任务集成进来：
- en: Input is supplied via a subscribed topic.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入通过订阅的主题提供。
- en: Output is delivered using a published topic.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出通过发布的主题传递。
- en: 'In the concrete case of ML applied to center the robot in the entrance door,
    we have the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在将机器学习应用于使机器人定位在入口门的具体案例中，我们有以下内容：
- en: Input to the ML node (subscribed topic) is the image feed from the Pi camera.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习节点（订阅的主题）的输入来自Pi摄像头的图像流。
- en: Output from the ML node (published topic) is the horizontal distance from the
    shape of the door to the center of the image.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习节点（发布的主题）的输出是从门形状到图像中心的水平距离。
- en: 'Then, the GoPiGo3 drive node takes that output topic as the data to determine
    which `cmd_vel` command should be sent to the motors. This establishes a feedback
    loop with the ML node that makes it possible that the robot position converges
    to get finally centered in the entrance door:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，GoPiGo3驱动节点将输出主题作为数据，以确定应该发送到电机的哪个`cmd_vel`命令。这建立了一个与机器学习节点的反馈循环，使得机器人位置收敛，最终在入口门中定位：
- en: '![](img/b1e991b3-3f41-4469-b7b5-6eb06bbf72e2.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b1e991b3-3f41-4469-b7b5-6eb06bbf72e2.png)'
- en: The ML published topic, `object_position`, is an integer that provides the distance
    in pixels from the centroid of the object (entrance door) to the center of the
    image frame.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习发布的主题`object_position`是一个整数，它提供了从对象（入口门）质心到图像帧中心的像素距离。
- en: 'Although it is out of the scope of this chapter, it is good to know at this
    point that ROS provides other interaction mechanisms between nodes, and the programmer''s
    choice about which one to use depends on the specific functionality to be implemented:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这超出了本章的范围，但在此处了解ROS提供节点之间其他交互机制是有好处的，程序员选择使用哪个取决于要实现的具体功能：
- en: A ROS service is the classical implementation of the server/client architecture.
    The client node (*drive node*) makes a request to the server node (*ML node*) and
    this performs the calculation (the distance in pixels from the entrance door to
    the center of the image frame). Then, the response is sent back to the client.
    The key difference with the publish/ subscribe mechanism is that this is not expecting
    to receive requests; it publishes messages at the rate set within the code of
    the node, independently, whether other nodes are listening or not.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS服务是服务器/客户端架构的经典实现。客户端节点（*驱动节点*）向服务器节点（*机器学习节点*）发出请求，并执行计算（从入口门到图像帧中心的像素距离）。然后，将响应发送回客户端。与发布/订阅机制的关键区别在于，它不期望接收请求；节点独立地以代码中设置的速率发布消息，无论其他节点是否在监听。
- en: A ROS action is similar to a ROS service, that is, it provides a response to
    a request from a node, with the difference that, in this case, the client node
    does not block the execution (until it receives the answer). That is to say, it
    keeps executing other code instructions and, when it receives the response, the
    client triggers the programmed action (rotates the robot for alignment). This
    behavior is called asynchronous, unlike a ROS service, which is synchronous in
    nature, that is, it blocks the node execution until the response is received.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS动作类似于ROS服务，即它对节点的请求提供响应，不同之处在于，在这种情况下，客户端节点不会阻塞执行（直到收到答案）。也就是说，它继续执行其他代码指令，当它收到响应时，客户端触发程序化的动作（使机器人旋转以对齐）。这种行为被称为异步，与ROS服务不同，ROS服务本质上是同步的，即它阻塞节点执行直到收到响应。
- en: So, let's dive into how to make GoPiGo3 aware of the objects it has around,
    and we will do this in the final section of this chapter where we will build a
    general ML node that is able to detect a wide range of object types.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们深入了解如何让GoPiGo3意识到它周围的对象，我们将在本章的最后部分完成这项工作，在那里我们将构建一个能够检测广泛对象类型的通用机器学习节点。
- en: Deep learning applied to robotics – computer vision
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用于机器人的深度学习——计算机视觉
- en: 'The practical part of this chapter consists of operationally implementing the
    ML node described earlier. What we represented there as a black box is developed
    now as a ROS package that you may integrate with the functionalities you discovered
    in previous chapters:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的实践部分包括操作性地实现前面描述的ML节点。我们之前将其表示为黑盒，现在作为一个ROS包开发，你可以将其与前面章节中发现的任何功能集成：
- en: The remote control in [Chapter 7](0653ab6b-8710-41e7-9c01-5024865e3e27.xhtml),
    *Robot Control and Simulation**,* for both the virtual robot in Gazebo and the
    physical GoPiGo3
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](0653ab6b-8710-41e7-9c01-5024865e3e27.xhtml)，*机器人控制和仿真*中，对Gazebo中的虚拟机器人和物理GoPiGo3的遥控
- en: Robot navigation for a virtual robot in [Chapter 8](25ac032c-5bfe-47ff-aa5a-f178dbff7c57.xhtml),
    *Virtual SLAM and Navigation Using Gazebo*, and the physical GoPiGo3 in [Chapter
    9](7b6ae4e6-2cd1-44e5-8f11-459b83987f42.xhtml), *SLAM for Robot Navigation*
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](25ac032c-5bfe-47ff-aa5a-f178dbff7c57.xhtml)，*使用Gazebo的虚拟SLAM和导航*中为虚拟机器人进行机器人导航，以及在[第9章](7b6ae4e6-2cd1-44e5-8f11-459b83987f42.xhtml)，*机器人导航的SLAM*中为物理GoPiGo3进行导航。
- en: 'So, we divide this section into two parts:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将本节分为两部分：
- en: The first section, *Object recognition in Gazebo*, provides you with the tools
    to integrate the ML node for image recognition in Gazebo so that, after finishing
    the practice, you may let your creativity fly to combine object recognition with
    any of the drive nodes from **remote control** or **robot navigation** and make
    the virtual robot smarter.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一部分，*Gazebo中的物体识别*，为你提供了集成Gazebo中图像识别ML节点的工具，这样在完成实践后，你可以发挥你的创造力，将物体识别与**遥控**或**机器人导航**中的任何驱动节点结合，使虚拟机器人变得更智能。
- en: The second section, *Object recognition in the real world*, provides the same
    integration with the physical GoPiGo3 and you will discover the ML node black
    box is the same no matter where the images come from, that is, objects in Gazebo
    or the real world. The choice is made by you when linking the ML node subscription
    to images of any of those scenarios.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二部分，*现实世界中的物体识别*，提供了与物理GoPiGo3相同的集成，你将发现无论图像来自哪里，即Gazebo或现实世界，ML节点黑盒都是相同的。当将ML节点订阅链接到任何这些场景的图像时，选择权在你手中。
- en: This procedure also gives an operational way to test a new robot application.
    Start with the validation in Gazebo, where you will mainly check that the developed
    code has no significant bugs and the robot works as expected; then, proceed with
    it to the real world—understand how all of the external variables that are not
    present in Gazebo act on the robot, see how it responds, and then decide which
    code refinements you need to make to get it to work.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程还提供了一种测试新机器人应用的操作方法。从Gazebo中的验证开始，你将主要检查开发的代码没有重大错误，机器人按预期工作；然后，将其带入现实世界——了解所有不在Gazebo中存在的外部变量如何影响机器人，看看它的反应，然后决定你需要对哪些代码进行优化才能使其工作。
- en: Object recognition in Gazebo
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gazebo中的物体识别
- en: 'To get the code, follow the instructions we provided at the beginning of this
    chapter under the section, *Technical requirements*. The exercise in Gazebo is
    going to be pretty simple and very effective at the same time. You will check
    how the virtual GoPiGo3 can recognize a common *tennis ball* from the image feed
    coming from the robot''s camera:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取代码，请按照本章“技术要求”部分开头提供的说明操作。在Gazebo中的练习将会非常简单且非常有效。你将检查虚拟GoPiGo3如何从来自机器人摄像头的图像流中识别一个常见的*网球*：
- en: 'Let''s start by spawning a model of the ball in Gazebo:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先在Gazebo中创建一个球体的模型：
- en: '[PRE12]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, launch a `rqt_image_view` node to watch the subjective view as perceived
    from the robot''s camera:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，启动一个`rqt_image_view`节点来观看从机器人摄像头感知到的主观视角：
- en: '[PRE13]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Click on the top-left empty box, and select ;`/gopigo/camera1/image_raw` topic.
    Then, you will see the subjective view of the robot as acquired by its front camera.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 点击左上角的空白框，选择`;`/gopigo/camera1/image_raw`主题。然后，你将看到机器人通过其前摄像头获取的主观视角。
- en: 'Next, spawn a model of the ball in Gazebo:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在Gazebo中创建一个球体的模型：
- en: '[PRE14]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Bear in mind that the `models_spawn_library` package requires you to execute
    the launch file as superuser. As soon as the ball is spawned in Gazebo, the process
    finishes and `T3` is released.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`models_spawn_library`包要求你以超级用户身份执行启动文件。一旦球体在Gazebo中创建，过程就会结束，`T3`将被释放。
- en: 'Then, launch the remote control node so that you can control GoPiGo with the
    keyboard as usual:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，启动遥控节点，这样你就可以像往常一样用键盘控制GoPiGo：
- en: '[PRE15]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This package was installed in [Chapter 7](0653ab6b-8710-41e7-9c01-5024865e3e27.xhtml),
    *Robot Control and Simulation*. If you did not install it, do so now. The source
    of this ROS package is at [https://github.com/ros-teleop/teleop_tools](https://github.com/ros-teleop/teleop_tools).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此软件包是在[第7章](0653ab6b-8710-41e7-9c01-5024865e3e27.xhtml)中安装的，*机器人控制和模拟*。如果您尚未安装，请现在安装。此ROS软件包的来源在[https://github.com/ros-teleop/teleop_tools](https://github.com/ros-teleop/teleop_tools)。
- en: 'Finally, launch the image recognition node and watch the screen output. Use
    `T3` where you already have `sudo` enabled:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，启动图像识别节点并观察屏幕输出。在您已经启用`sudo`的地方使用`T3`：
- en: '[PRE16]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can get a more condensed feed by subscribing to the `/result` topic, which
    provides just the name of the recognized objects:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过订阅`/result`主题，您可以获取更简洁的流，该主题仅提供识别对象的名称：
- en: '[PRE17]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'See the composition of the following screenshots showing how the tennis ball
    is recognized in the Terminal window (bottom-left side):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下截图的组成，显示如何在终端窗口（左下角）中识别网球：
- en: '![](img/4ac87985-ba8e-41f4-9353-8d06e7198b33.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ac87985-ba8e-41f4-9353-8d06e7198b33.png)'
- en: Is it easy to replicate? We expect so. Now,let's proceed to repeat the process
    with the physical robot.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 是否容易复制？我们希望如此。现在，让我们使用物理机器人重复此过程。
- en: Object recognition in the real world
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实世界中的物体识别
- en: 'First, remember to point the ROS master URI to the robot as usual:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，记得像往常一样将ROS主URI指向机器人：
- en: '[PRE18]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Apply this for every new Terminal in the laptop, or include the line in the
    `.bashrc` file. The physical robot configuration is as shown here, with GoPiGo3
    in front of a small yellow ball:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 将此应用于笔记本电脑上的每个新终端，或将此行包含在`.bashrc`文件中。物理机器人配置如图所示，GoPiGo3位于一个小黄色球的前面：
- en: '![](img/ce2fdd35-516e-4f94-ab6f-48371dbc66bd.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce2fdd35-516e-4f94-ab6f-48371dbc66bd.png)'
- en: 'Run the following two commands in two independent Terminals in the Raspberry
    Pi:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在Raspberry Pi的两个独立终端中运行以下两个命令：
- en: '[PRE19]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The packages you are using in the preceding are the ones in [Chapter 6](0b20bdff-f1dc-42e8-ae83-fc290da31381.xhtml),
    *Programming in ROS- Commands and Tools*. So make sure you did not delete them,
    and if so, get them back. In the laptop is where you run the new packages to perform
    image recognition:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您在前面使用的是[第6章](0b20bdff-f1dc-42e8-ae83-fc290da31381.xhtml)中的软件包，*在ROS中使用ROS-命令和工具进行编程*。所以请确保您没有删除它们，如果已删除，请恢复它们。在笔记本电脑上运行新软件包以执行图像识别：
- en: '[PRE20]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `image_transport-` package (you can find its ROS wiki page at [http://wiki.ros.org/image_transport](http://wiki.ros.org/image_transport))
    is commonly used in ROS to provide transparent support for transmitting images
    in low-bandwidth compressed formats.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`image_transport-`软件包（您可以在[http://wiki.ros.org/image_transport](http://wiki.ros.org/image_transport)找到其ROS维基页面）在ROS中常用，以提供对低带宽压缩格式的图像传输的透明支持。'
- en: 'Then, `T1` makes `raspicam_node/image`—output from `r2`—available in raw format,
    that is, the `/raspicam_node/image_raw` topic, the output of `T1`. This facilitates
    the image feed, which can then be processed later by `start_image_recognition.launch`.
    At this point, it is very useful to look at the ROS graph:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`T1`使`raspicam_node/image`——来自`r2`的输出——以原始格式可用，即`/raspicam_node/image_raw`主题，这是`T1`的输出。这有助于图像流，然后可以通过`start_image_recognition.launch`稍后进行处理。此时，查看ROS图非常有用：
- en: '![](img/3b6c683c-4a22-47ca-afb4-6c0501ae747f.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b6c683c-4a22-47ca-afb4-6c0501ae747f.png)'
- en: 'Remember that this visualization is launched with the `rqt_graph` command in
    another Terminal. Find that the transport operation is carried out by the `image_republisher_157...` node. Then,
    launch a `rqt_image_view` node to watch the subjective view as perceived through
    the Pi camera:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，此可视化是通过另一个终端中的`rqt_graph`命令启动的。找到由`image_republisher_157...`节点执行传输操作。然后，启动一个`rqt_image_view`节点来观察通过Pi相机感知的主观视图：
- en: '[PRE21]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the pop-up window, you have to select the `/raspicam_node/image_raw` topic to
    get the subjective view from the Pi camera.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在弹出窗口中，您必须选择`/raspicam_node/image_raw`主题以从Pi相机获取主观视图。
- en: 'Finally, as we did in simulation, launch the image recognition node and subscribe
    to the `/result` topic:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如我们在模拟中所做的那样，启动图像识别节点并订阅`/result`主题：
- en: '[PRE22]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The only difference for the Gazebo scenario is that you have to remap the topic
    supplied by the Pi camera with `raspicam_node`, to the topic named `rgb_image_topic`,
    which is the one accepted by the image recognition node.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Gazebo场景，唯一的区别是您必须将Pi相机提供的`raspicam_node`主题重映射到名为`rgb_image_topic`的主题，这是图像识别节点接受的主题。
- en: 'We have presented three different objects to the robot successively: the yellow
    ball, the mouse, and the monitor. Find out how the three of them are recognized
    by the robot in real time. Is it surprising?'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们依次向机器人展示了三个不同的物体：黄色的球、鼠标和监控器。找出机器人如何实时识别这三个物体。这令人惊讶吗？
- en: 'The yellow ball can be seen here:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在这里看到黄色的球：
- en: '![](img/c83af262-0045-4c88-8622-397ac4e6c7d3.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c83af262-0045-4c88-8622-397ac4e6c7d3.png)'
- en: 'Then, the mouse can be seen here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，鼠标可以在这里看到：
- en: '![](img/4e7577bb-ef5c-4d6a-81c9-297f98f9988e.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e7577bb-ef5c-4d6a-81c9-297f98f9988e.png)'
- en: 'And, finally, the monitor can be seen here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，监控器可以在这里看到：
- en: '![](img/8e976bec-8aaf-4ae4-b05e-19596bdbc209.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8e976bec-8aaf-4ae4-b05e-19596bdbc209.png)'
- en: If you have arrived at this point, you are in a good position to start creating
    advanced applications in ROS that integrate object recognition as an ability that
    uses GoPiGo3 to execute smart actions.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经到达这个阶段，你就有很好的条件开始创建在ROS中集成对象识别作为使用GoPiGo3执行智能动作的能力的高级应用程序。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided a quick introduction to ML in robotics. We expect you
    to have acquired insight into what ML and deep learning are, qualitatively understood
    how a neural network processes images to recognize objects, and can operationally
    implement the algorithm in a simulated and/or physical robot.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了机器人学中机器学习的快速介绍。我们希望你已经对机器学习和深度学习有了定性理解，了解了神经网络如何处理图像以识别物体，并且能够在模拟和/或物理机器人中操作实现该算法。
- en: ML is a very wide field and you should not expect nor really need to get an
    expert in the field. What you need to assimilate is the knowledge to integrate
    deep learning capabilities in your robots.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习是一个非常广泛的领域，你不应该期望，实际上也不需要成为该领域的专家。你需要吸收的知识是如何将深度学习能力集成到你的机器人中。
- en: As you have seen in the practical case, we have used a pretrained model that
    covers common objects. Then, we have simply used this model and have not needed
    additional training. There are plenty of trained models on the web shared by data
    science companies and open source developers. You should spend time looking for
    these models, and only go to train your own models when the scenario that the
    robot is facing is so specific that general-purpose ML models do not cover it
    with decent accuracy.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在实际案例中看到的，我们使用了一个覆盖常见物体的预训练模型。然后，我们只是简单地使用了这个模型，并且不需要额外的训练。网上有大量由数据科学公司和开源开发者共享的已训练模型。你应该花时间寻找这些模型，只有在机器人面临的场景非常特定，通用机器学习模型无法以足够的准确性覆盖时，才去训练自己的模型。
- en: In the final two chapters, we will focus on reinforcement learning, a task that
    is complementary to the deep learning technique described in this chapter. With
    the latter, the robot gets the perception of the environment, and with the former,
    it chains several actions oriented to a goal.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两章中，我们将重点关注强化学习，这是一个与本章描述的深度学习技术互补的任务。后者使机器人获得环境的感知，而前者则将几个面向目标的动作串联起来。
- en: Questions
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the task for solving ML that requires more experience and insight from
    the data scientist?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决机器学习任务需要更多数据科学家经验和洞察力的任务是什么？
- en: A) The algorithm selection
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: A) 算法选择
- en: B) The feature selection
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: B) 特征选择
- en: C) The model
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: C) 模型
- en: What is the relationship between ML and deep learning?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 机器学习和深度学习之间有什么关系？
- en: A) ML covers many algorithms and deep learning only algorithms to find deep
    features.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: A) 机器学习涵盖了众多算法，而深度学习仅包括用于寻找深度特征的算法。
- en: B) Deep learning is a subset of ML.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: B) 深度学习是机器学习的一个子集。
- en: C) Deep learning deals with all of the ML algorithms except neural networks.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: C) 深度学习处理除了神经网络之外的所有机器学习算法。
- en: How should you integrate an ML task with a ROS application?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该如何将机器学习任务与ROS应用程序集成？
- en: A) You should train the model outside and then provide ROS with a file of results.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: A) 你应该在模型外部进行训练，然后向ROS提供一个结果文件。
- en: B) You have the choice of using publish/subscribe, a ROS service, or an action
    server.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: B) 你可以选择使用发布/订阅、ROS服务或动作服务器。
- en: C) You have to use the specific communication protocol of the ML model.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: C) 你必须使用ML模型的特定通信协议。
- en: What is the main difference between the publish/subscribe mechanism and the
    ROS service mechanism?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布/订阅机制和ROS服务机制的主要区别是什么？
- en: A) ROS service is synchronous while publish/subscribe is asynchronous.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: A) ROS服务是同步的，而发布/订阅是异步的。
- en: B) ROS service is asynchronous while publish/subscribe is synchronous.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: B) ROS服务是异步的，而发布/订阅是同步的。
- en: C) Publish/subscribe does not need to receive requests from other nodes in order
    to publish messages.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: C) 发布/订阅不需要从其他节点接收请求来发布消息。
- en: If the practical example explained in the *Deep learning applied to robotics
    – computer vision* section was carried out with a red ball instead of a yellow
    one, will the prediction with the same model we are using?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在*深度学习应用于机器人——计算机视觉*部分中解释的实用示例是用红球而不是黄球进行的，那么使用相同模型的预测会怎样？
- en: A) Yes, the color is not a feature for object shape recognition.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: A) 是的，颜色不是物体形状识别的特征。
- en: B) Yes, and in addition to identifying a ball, it will also tell that it is
    red.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: B) 是的，除了识别球体，它还会指出它是红色的。
- en: C) It depends on whether the model was trained with balls of different colors.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: C) 这取决于模型是否用不同颜色的球体进行过训练。
- en: Further reading
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To delve deeper into the concepts explained in this chapter, you can check
    out the following references:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解本章中解释的概念，你可以查看以下参考资料：
- en: '*A Brief History of ML:* [https://www.dataversity.net/a-brief-history-of-machine-learning](https://www.dataversity.net/a-brief-history-of-machine-learning)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*机器学习简史:* [https://www.dataversity.net/a-brief-history-of-machine-learning](https://www.dataversity.net/a-brief-history-of-machine-learning)'
- en: '*A Brief History of Robotics Since 1950:* [https://www.encyclopedia.com/science/encyclopedias-almanacs-transcripts-and-maps/brief-history-robotics-1950](https://www.encyclopedia.com/science/encyclopedias-almanacs-transcripts-and-maps/brief-history-robotics-1950)'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自1950年以来的机器人简史:* [https://www.encyclopedia.com/science/encyclopedias-almanacs-transcripts-and-maps/brief-history-robotics-1950](https://www.encyclopedia.com/science/encyclopedias-almanacs-transcripts-and-maps/brief-history-robotics-1950)'
- en: '*ML for Recommender systems -Part 1 (algorithms, evaluation and cold start):* [https://medium.com/recombee-blog/machine-learning-for-recommender-systems-part-1-algorithms-evaluation-and-cold-start-6f696683d0ed](https://medium.com/recombee-blog/machine-learning-for-recommender-systems-part-1-algorithms-evaluation-and-cold-start-6f696683d0ed)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*机器学习在推荐系统中的应用 - 第1部分（算法、评估和冷启动）:* [https://medium.com/recombee-blog/machine-learning-for-recommender-systems-part-1-algorithms-evaluation-and-cold-start-6f696683d0ed](https://medium.com/recombee-blog/machine-learning-for-recommender-systems-part-1-algorithms-evaluation-and-cold-start-6f696683d0ed)'
- en: '*ML for Recommender systems - Part 2 (Deep Recommendation, Sequence Prediction,
    AutoML, and Reinforcement Learning in Recommendation):* [https://medium.com/recombee-blog/machine-learning-for-recommender-systems-part-2-deep-recommendation-sequence-prediction-automl-f134bc79d66b](https://medium.com/recombee-blog/machine-learning-for-recommender-systems-part-2-deep-recommendation-sequence-prediction-automl-f134bc79d66b)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*机器学习在推荐系统中的应用 - 第2部分（深度推荐、序列预测、AutoML和推荐中的强化学习）:* [https://medium.com/recombee-blog/machine-learning-for-recommender-systems-part-2-deep-recommendation-sequence-prediction-automl-f134bc79d66b](https://medium.com/recombee-blog/machine-learning-for-recommender-systems-part-2-deep-recommendation-sequence-prediction-automl-f134bc79d66b)'
- en: '*Intuitive Deep Learning Part 1a: Introduction to Neural Networks:* [https://medium.com/intuitive-deep-learning/intuitive-deep-learning-part-1a-introduction-to-neural-networks-d7b16ebf6b99](https://medium.com/intuitive-deep-learning/intuitive-deep-learning-part-1a-introduction-to-neural-networks-d7b16ebf6b99)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*直观深度学习第1a部分：神经网络简介:* [https://medium.com/intuitive-deep-learning/intuitive-deep-learning-part-1a-introduction-to-neural-networks-d7b16ebf6b99](https://medium.com/intuitive-deep-learning/intuitive-deep-learning-part-1a-introduction-to-neural-networks-d7b16ebf6b99)'
- en: '*Intuitive Deep Learning Part 2: CNNs for Computer Vision:* [https://medium.com/intuitive-deep-learning/intuitive-deep-learning-part-2-cnns-for-computer-vision-24992d050a27](https://medium.com/intuitive-deep-learning/intuitive-deep-learning-part-2-cnns-for-computer-vision-24992d050a27)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*直观深度学习第2部分：计算机视觉中的卷积神经网络:* [https://medium.com/intuitive-deep-learning/intuitive-deep-learning-part-2-cnns-for-computer-vision-24992d050a27](https://medium.com/intuitive-deep-learning/intuitive-deep-learning-part-2-cnns-for-computer-vision-24992d050a27)'
- en: '*Build your first Convolutional Neural Network to recognize images:* [https://medium.com/intuitive-deep-learning/build-your-first-convolutional-neural-network-to-recognize-images-84b9c78fe0ce](https://medium.com/intuitive-deep-learning/build-your-first-convolutional-neural-network-to-recognize-images-84b9c78fe0ce)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建你的第一个卷积神经网络以识别图像:* [https://medium.com/intuitive-deep-learning/build-your-first-convolutional-neural-network-to-recognize-images-84b9c78fe0ce](https://medium.com/intuitive-deep-learning/build-your-first-convolutional-neural-network-to-recognize-images-84b9c78fe0ce)'
