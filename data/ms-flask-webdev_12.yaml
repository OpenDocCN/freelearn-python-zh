- en: Testing Flask Apps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Flask应用程序
- en: Throughout the book, every time that we've made a modification to our application's
    code, we've had to manually load the affected web pages into our browser to test
    if the code was working correctly. As the application grows, this process becomes
    more and more tedious, especially if you change something that is low-level and
    used everywhere, such as SQLAlchemy model code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，每当我们对我们的应用程序代码进行修改时，我们都必须手动将受影响的网页加载到浏览器中，以测试代码是否正确工作。随着应用程序的增长，这个过程变得越来越繁琐，尤其是如果你更改了低级且到处使用的代码，比如SQLAlchemy模型代码。
- en: In order to automate the process of verifying that our code works the way we
    want it to, we will use a built-in feature of Python that allows us to write tests,
    normally named unit tests or integration tests, which are checked against our
    application's code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化验证我们的代码按预期工作的过程，我们将使用Python的一个内置功能来编写测试，通常称为单元测试或集成测试，这些测试将与我们的应用程序代码进行比对。
- en: 'In this chapter, you will learn how to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Writing simple tests with Python's unitest library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python的unittest库编写简单测试
- en: Testing security, and validating logins and role based access
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试安全性，并验证登录和基于角色的访问
- en: Writing a test for a REST API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写REST API的测试
- en: Testing your user interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试用户界面
- en: Measuring test coverage
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量测试覆盖率
- en: What are unit tests?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是单元测试？
- en: Testing a program is very simple. All it involves is developing code that will
    run particular pieces of your program and specifying what you expect the results
    to be, and then comparing it to what the results from the piece of the program
    actually are. If the results are the same, the test passes. If the results are
    different, the test fails. Typically, these tests are run upon Pull Request creation
    on your CI server, so all the reviewers of the PR can immediately check if the
    requested change breaks something or not.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一个程序非常简单。它只涉及开发代码来运行程序中的特定部分，并指定你期望的结果，然后将结果与程序实际运行的结果进行比较。如果结果相同，测试通过。如果结果不同，测试失败。通常，这些测试是在CI服务器上创建Pull
    Request时运行的，这样所有PR的审查者都可以立即检查请求的更改是否破坏了某些内容。
- en: In program testing, there are three main types of tests. **Unit tests** are
    tests that verify the correctness of individual pieces of code, such as functions.
    Second is **integration testing**, which tests the correctness of various units
    of programs working in tandem. The last type of testing is **end-to-end testing**,
    which tests the correctness of the whole system at once, rather than individual
    pieces. Many other types of testing exist, some of which include load tests, security
    tests, and recovery tests.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序测试中，主要有三种类型的测试。**单元测试**是验证单个代码片段（如函数）正确性的测试。其次是**集成测试**，它测试程序中各种单元协同工作的正确性。最后一种测试是**端到端测试**，它一次性测试整个系统的正确性，而不是单个部分。还存在许多其他类型的测试，其中一些包括负载测试、安全测试和恢复测试。
- en: In this chapter, we will be using unit testing and end-to-end testing in order
    to verify that our code is working as planned.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用单元测试和端到端测试来验证我们的代码按计划工作。
- en: 'This brings us to some of the first rules of code testing: make sure your tests
    can actually fail, write simple test functions that test only one thing, and make
    your test code easy to read and write.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们来到了代码测试的一些基本规则：确保你的测试可以真正失败，编写只测试一个东西的简单测试函数，并使测试代码易于阅读和编写。
- en: How does testing work?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试是如何工作的？
- en: 'Let''s start with a very simple Python function for us to test:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的Python函数开始测试：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In order to verify the correctness of this code, we pass a value, and will test
    if the result of the function is what we expect. For example, we could give it
    an input of 5, and would expect the result to be 25.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证代码的正确性，我们传递一个值，并测试函数的结果是否符合预期。例如，我们可以给它一个输入为5，并期望结果为25。
- en: 'To illustrate the concept, we can manually test this function in the command
    line using the `assert` statement. The `assert` statement in Python simply says
    that if the conditional statement after the `assert` keyword returns `False`,
    then it will throw an exception as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个概念，我们可以使用命令行中的`assert`语句手动测试这个函数。Python中的`assert`语句简单地说，如果`assert`关键字后面的条件语句返回`False`，则将抛出异常，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using these `assert` statements, we verified that the square function was working
    as intended.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些`assert`语句，我们验证了平方函数按预期工作。
- en: Unit testing the application
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试应用程序
- en: '**Unit testing** in Python works by combining `assert` statements into their
    own functions inside a class. This *collection of testing functions* inside the
    class is called a **test case**. Each function inside the test case should test
    only one thing, which is the main idea behind unit testing. Testing only one thing
    in your unit tests forces you to verify each piece of code individually, and not
    gloss over any of the functionality of your code. If you write your unit tests
    correctly, you will end up with lots and lots of them. While this may seem overly
    verbose, it will save you from headaches further down the road.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**在Python中是通过将`assert`语句组合成类内部的独立函数来工作的。这个类内部的**测试函数集合**被称为**测试用例**。测试用例内部的每个函数应该只测试一件事情，这是单元测试背后的主要思想。在单元测试中只测试一件事情迫使你必须单独验证每一块代码，而不会忽略你代码的任何功能。如果你正确编写单元测试，你最终会得到很多很多测试。虽然这看起来可能过于冗长，但它会为你节省未来的麻烦。'
- en: 'In this configuration, we will use SQLLite in the memory engine database, which
    allows us to guarantee that the tests will not interfere with our actual database.
    Also, the configuration disables WTForms'' CSRF checks, to allow us to submit
    forms from the tests without the CSRF token:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中，我们将使用内存引擎数据库的SQLite，这使我们能够保证测试不会干扰我们的实际数据库。此外，该配置禁用了WTForms的CSRF检查，以便我们可以在测试中提交表单而不需要CSRF令牌：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Testing the route functions
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试路由函数
- en: Let's build our first test case. In this test case, we will be testing if the
    route functions successfully return a response when we access its URL. In a new
    directory named `tests`, at the root of the project directory, create a new file
    named `test_urls.py`, which will hold all of the unit tests for the routes. Each
    test case should have its own file, and each test case should focus on one area
    of the code that you are testing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建第一个测试用例。在这个测试用例中，我们将测试当访问其URL时，路由函数是否成功返回响应。在项目目录根目录下创建一个名为`tests`的新目录，在该目录中创建一个名为`test_urls.py`的新文件，该文件将包含所有路由的单元测试。每个测试用例应该有自己的文件，每个测试用例应该专注于你正在测试的代码的一个区域。
- en: 'In `test_urls.py`, let''s start creating what the built-in Python `unittest`
    library needs. The code will use the `unittest` library from Python in order to
    run all the tests that we create in the test case:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test_urls.py`中，让我们开始创建内置Python `unittest`库所需的内容。代码将使用Python中的`unittest`库来运行我们在测试用例中创建的所有测试：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s see what happens when this code is run. We will use the `unittest` library''s
    ability to automatically find our test cases to run the tests. The pattern that
    the `unittest` library looks for is `test*.py`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看运行此代码会发生什么。我们将使用`unittest`库自动查找我们的测试用例的能力来运行测试。`unittest`库寻找的模式是`test*.py`：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Because there are no tests in the test case, the test case passed successfully.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因为测试用例中没有测试，所以测试用例成功通过。
- en: The test script was run from the parent directory of the script, and not in
    the test folder itself. This is to allow imports of the application code inside
    the test scripts.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本是从脚本的父目录而不是测试文件夹本身运行的。这是为了允许在测试脚本中导入应用程序代码。
- en: In order to test the URLs, we need to have a way to query the application's
    routes without actually running a server, so our requests are returned. Flask
    provides a way of accessing routes in tests, called the *test client*. The test
    client gives methods to create HTTP requests on our routes, without having to
    actually run the application with `app.run()`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试URL，我们需要一种方法来查询应用程序的路由，而无需实际运行服务器，以便我们的请求得到响应。Flask提供了一个在测试中访问路由的方法，称为**测试客户端**。测试客户端提供了在路由上创建HTTP请求的方法，而无需实际使用`app.run()`运行应用程序。
- en: We will need the test client object for each of the tests in this test case,
    but adding in code to each `unittest` to create the test client doesn't make much
    sense when we have the `setUp` method. The `setUp` method is run before each unit
    test, and can attach variables to itself in order for the test method to access
    them. In our `setUp` method, we need to create the application object with our
    `TestConfig` object and create the test client.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要为这个测试用例中的每个测试使用测试客户端对象，但在`unittest`中添加创建测试客户端的代码在`setUp`方法中并不合理。`setUp`方法在每次单元测试之前运行，并且可以将其变量附加到自身，以便测试方法可以访问它们。在我们的`setUp`方法中，我们需要使用`TestConfig`对象创建应用程序对象并创建测试客户端。
- en: 'Also, there are three bugs that we need to work around. The first two are in
    the Flask Admin and Flask Restful extensions, which do not remove the Blueprint
    objects stored internally when the application object they are applied to is destroyed.
    Third, Flask SQLAlchemy''s initializer doesn''t correctly add the application
    object while outside the `webapp` directory:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有三个我们需要解决的错误。前两个在Flask Admin和Flask Restful扩展中，它们在应用到的应用程序对象被销毁时没有删除内部存储的Blueprint对象。第三，Flask
    SQLAlchemy的初始化器在`webapp`目录外没有正确添加应用程序对象。
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All of the bugs listed here existed at the time of writing, but may no longer
    exist when you read this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的所有错误在编写时都存在，但当你阅读这一章时可能已经不存在了。
- en: 'Along with the `setUp` method, there is also the `tearDown` method, which is
    run every time a unit test ends. The `tearDown` method''s goal is to destroy any
    objects, created in the `setUp` method, that cannot automatically be deleted or
    closed. In our case, we will use the `tearDown` method to close and remove our
    database sessions, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`setUp`方法外，还有一个`tearDown`方法，它在每次单元测试结束时都会运行。`tearDown`方法的目标是销毁在`setUp`方法中创建的任何无法自动删除或关闭的对象。在我们的例子中，我们将使用`tearDown`方法来关闭和删除我们的数据库会话，如下所示：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we can create our first unit test. The first test will test whether accessing
    the root of our application returns a `302 redirect` code to the blog home page,
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建我们的第一个单元测试。第一个测试将检查访问我们应用程序的根是否返回一个`302`重定向代码到博客主页，如下所示：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each unit test must start with the word `test` to tell the `unittest` library
    that the function is a unit test, and not just some utility function inside the
    test case class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单元测试都必须以单词`test`开头，以便告诉`unittest`库该函数是一个单元测试，而不是测试用例类中的某个实用函数。
- en: 'Now, if we run the tests again, we can see its progress and how it passes the
    checks:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次运行测试，我们可以看到它的进度以及它是如何通过检查的：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The best way to write tests is to ask yourself what you are looking for ahead
    of time, write the `assert` statements, and write the code needed to execute those
    asserts. This forces you to ask what you are really testing, before you actually
    start writing the test. It's also the practice to write a Python doc string for
    each unit test, as it will be printed with the name of the test whenever the test
    fails. After you write 50 or more tests, this can be very helpful to know exactly
    what the test is for.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试的最佳方式是在事先弄清楚你想要寻找什么，编写`assert`语句，然后编写执行这些断言所需的代码。这迫使你在实际编写测试之前先弄清楚你真正要测试什么。此外，为每个单元测试编写Python文档字符串也是一个惯例，因为当测试失败时，它将与测试名称一起打印出来。在你编写了50个或更多的测试之后，这将非常有帮助，可以确切地知道测试的目的。
- en: Rather than using the built-in `assert` keyword from Python, we can use some
    of the methods provided by the `unittest` library. These methods provide specialized
    error messages and debug information when the `assert` statements inside these
    functions fail.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不用Python内置的`assert`关键字，而是使用`unittest`库提供的一些方法。当这些函数中的`assert`语句失败时，这些方法提供了专门的错误信息和调试信息。
- en: 'The following is a list of all of the special `assert` statements given by
    the `unittest` library and what they do:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由`unittest`库提供的所有特殊`assert`语句及其功能的列表：
- en: '`assertEqual(x, y)`: Asserts that `x == y`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEqual(x, y)`: 断言`x == y`'
- en: '`assertNotEqual(x, y)`: Asserts that `x != y`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotEqual(x, y)`: 断言`x != y`'
- en: '`assertTrue(x)`: Asserts that `x` is `True`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertTrue(x)`: 断言`x`是`True`'
- en: '`assertFalse(x)`: Asserts that `x` is `False`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFalse(x)`: 断言`x`是`False`'
- en: '`assertIs(x, y)`: Asserts that `x` is `y`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIs(x, y)`: 断言`x`是`y`'
- en: '`assertIsNot(x, y)`: Asserts that `x` is not `y`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIsNot(x, y)`: 断言`x`不是`y`'
- en: '`assertIsNone(x)`: Asserts that `x` is `None`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIsNone(x)`: 断言`x`是`None`'
- en: '`assertIsNotNone(x)`: Asserts that `x` is not `None`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIsNotNone(x)`: 断言`x`不是`None`'
- en: '`assertIn(x, y)`: Asserts that `y` contains `x`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIn(x, y)`: 断言`y`包含`x`'
- en: '`assertNotIn(x, y)`: Asserts that `x` is not in `y`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotIn(x, y)`: 断言`x`不在`y`中'
- en: '`assertIsInstance(x, y)`: Asserts that `isinstance(x, y)`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIsInstance(x, y)`: 断言`isinstance(x, y)`'
- en: '`assertNotIsInstance(x, y)`: Asserts not `isinstance(x, y)`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotIsInstance(x, y)`: 断言不是`isinstance(x, y)`'
- en: 'If we wanted to test the return value of a normal page, the unit test would
    look like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要测试普通页面的返回值，单元测试将看起来像这样：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember that the preceding code only tests if the URLs give returns successfully.
    The content of the return data is not a part of these tests.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，前面的代码只测试了URL是否成功返回。返回数据的内容不是这些测试的一部分。
- en: Testing security
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试安全性
- en: Testing security is obviously very important—if you expose your application
    to the web, you can be sure that your security will be heavily tested, and not
    for the right reasons. All of your secured endpoints will be tested and exploited
    if not correctly secured. First of all, we should test our login and logout processes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 测试安全性显然非常重要——如果你将你的应用程序暴露在网络上，你可以确信你的安全性将会受到严重的测试，而且不是出于正确的理由。如果你的安全措施没有得到正确保护，所有的受保护端点都将被测试和利用。首先，我们应该测试我们的登录和注销过程。
- en: 'If we wanted to test submitting a form, such as the login form, we can use
    the post method of the test client. Let''s create a `test_login` method to see
    if the login form works correctly:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要测试提交表单，例如登录表单，我们可以使用测试客户端的post方法。让我们创建一个`test_login`方法来查看登录表单是否工作正常：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The additional check for the string in the return data exists because the return
    code is not affected by the validity of the entered data. The `post` method will
    work for testing any of the form objects we have created throughout the book.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数据中的字符串额外检查是因为返回代码不受输入数据有效性的影响。`post`方法将适用于测试我们在整本书中创建的任何表单对象。
- en: 'Now, let''s create a failed login attempt:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个失败的登录尝试：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding snippet, we make sure that a login attempt with failed credentials
    does not give the user a successful login, and in the same test, we also make
    sure that a failed login will not give the user sufficient access to add a new
    blog post. This may seem trivial, and it is easy to implement, but as previously
    stated, you should make each test simple, and only test one thing with each test,
    but aim to cover all your features and possibilities.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们确保使用失败的凭证进行的登录尝试不会给用户带来成功的登录，并且在同一测试中，我们还确保失败的登录不会给用户足够的权限来添加新的博客文章。这看起来可能很微不足道，而且很容易实现，但如前所述，你应该使每个测试尽可能简单，并且每个测试只测试一件事情，但目标是覆盖所有功能和可能性。
- en: 'Another example of an important test covers unauthorized access from a logged-in
    user:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要测试的例子是覆盖已登录用户的未授权访问：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we make sure that a low-privileged user does not have access to an high
    privilege area of our application: the admin interface.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们确保低权限用户无法访问我们应用程序中的高权限区域：管理员界面。
- en: Testing the REST API
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试REST API
- en: Still in the context of security, we will now learn how to test our REST API.
    Remember that we have implemented JWT security, so for each request, we need to
    use a previously acquired access token.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在安全性的背景下，我们现在将学习如何测试我们的REST API。记住，我们已经实现了JWT安全性，因此对于每个请求，我们需要使用之前获取的访问令牌。
- en: 'JWT authentication tests should look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: JWT身份验证测试应该看起来像这样：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Some important details to note here include the way we set our HTTP header to
    JSON, and how we pass the JSON payload on the HTTP POST method—this will happen
    on all our REST API tests.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意的一些重要细节包括我们如何设置HTTP头为JSON格式，以及我们如何在HTTP POST方法中传递JSON有效载荷——这将在我们所有的REST
    API测试中发生。
- en: Next, let's see how to develop a test for the new post REST API. `/api/post` is
    the endpoint for blog posts, and the POST HTTP method is the method for adding
    a new post to the Blog application. Revisit [Chapter 8](e6143102-d0e2-4134-a6db-28fb38643ea7.xhtml), *Building
    RESTful APIs* if this is not clear.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何开发一个针对新帖子REST API的测试。`/api/post`是博客文章的端点，POST HTTP方法是向博客应用程序添加新帖子的方法。如果这还不清楚，请回顾[第8章](e6143102-d0e2-4134-a6db-28fb38643ea7.xhtml)，*构建RESTful
    API*。
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once again, this is a simple test to develop—notice the way that we request
    an access token from our authentication JWT API using the `/auth/api` endpoint,
    and how we use it to make the call to `/api/post`. has expected the access token
    is used to construct the HTTP authorization header using the form `Authorization:
    Bearer <ACCESS_TOKEN>`. This can be a bit cumbersome to repeat on each API test,
    so make sure to write a helper function to keep your code "DRY"—that is, "Don''t
    Repeat Yourself".'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '这同样是一个简单的测试来开发——注意我们如何使用`/auth/api`端点从我们的认证JWT API请求访问令牌，以及我们如何使用它来调用`/api/post`。预期的访问令牌被用来构造HTTP授权头，形式为`Authorization:
    Bearer <ACCESS_TOKEN>`。这可能在每个API测试中重复可能有点繁琐，所以确保编写一个辅助函数来保持你的代码“DRY”——即“不要重复自己”。'
- en: Now that you understand the mechanics of unit testing, you can use unit testing
    in order to test all the parts of your application. This can include testing all
    the routes in the application; testing any utility function that we have made,
    such as `sidebar_data`; and testing all possible combinations of roles and access
    protected pages.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了单元测试的机制，您可以使用单元测试来测试您应用程序的所有部分。这可以包括测试应用程序中的所有路由；测试我们制作的任何实用函数，例如`sidebar_data`；以及测试所有可能的角色和受保护页面的组合。
- en: If your application's code has a feature, no matter how small, you should have
    a test for it. Why? Because whatever can go wrong, will go wrong. If the validity
    of your application's code relies entirely on manual testing, then something is
    going to get overlooked as your app grows. When something gets overlooked, then
    broken code is deployed to live servers, which annoys your users.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序代码有一个功能，无论多小，您都应该为它编写一个测试。为什么？因为任何可能出错的事情都会出错。如果您的应用程序代码的有效性完全依赖于手动测试，那么随着您的应用程序的增长，某些东西可能会被忽略。当某些东西被忽略时，损坏的代码就会被部署到生产服务器上，这会令您的用户感到烦恼。
- en: User interface testing
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面测试
- en: In order to test the high level of our application's code and to create system
    tests, we will write tests that work with browsers, and verify that the UI code
    is functioning properly. Using a tool called Selenium, we will create Python code
    that hooks into a browser and controls it purely from code. This works by finding
    elements on the screen, and then performing actions on those elements through
    Selenium. Click on it or input keystrokes. Also, Selenium allows you to perform
    checks on the page content by giving you access to the elements' content, such
    as their attributes and inner text. For more advanced checks, Selenium even has
    an interface which can run arbitrary JavaScript on the page. If the JavaScript
    returns a value, it is automatically converted into a Python type.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们应用程序代码的高级功能并创建系统测试，我们将编写与浏览器一起工作的测试，并验证UI代码是否正常工作。使用一个名为Selenium的工具，我们将创建Python代码，该代码可以连接到浏览器并完全通过代码控制它。这是通过在屏幕上查找元素，然后通过Selenium对这些元素执行操作来实现的。点击它或输入按键。此外，Selenium还允许您通过提供对元素内容的访问来对页面内容进行检查，例如它们的属性和内部文本。对于更高级的检查，Selenium甚至有一个可以运行页面上的任意JavaScript的接口。如果JavaScript返回一个值，它将被自动转换为Python类型。
- en: 'Before we touch the code, Selenium needs to be installed. Make sure you have
    your virtualenv activated, and that Selenium is included in the `requirements.txt` file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们接触代码之前，需要安装Selenium。确保您的虚拟环境已激活，并且Selenium已包含在`requirements.txt`文件中：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To begin with the code, our UI tests need a file of their own in the `tests`
    directory, named `test_ui.py`. Because system tests do not test one specific thing,
    the best way to write user interface tests is to think of the test as going through
    a typical user''s flow. Before you write the test itself, write down the specific
    steps that our fake user is going to simulate:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始编写代码，我们的UI测试需要在`tests`目录中有一个自己的文件，命名为`test_ui.py`。因为系统测试不测试特定的事情，所以编写用户界面测试的最佳方式是将测试视为通过一个典型用户的流程。在您编写测试本身之前，写下我们的假用户将要模拟的具体步骤：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that we know exactly what our test is going to do, let''s start adding
    in the Selenium code. In the `setUp` and `tearDown` methods, we need code to start
    up a web browser that will Selenium control, and then close it when the test is
    over:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们确切地知道我们的测试将要做什么，让我们开始添加Selenium代码。在`setUp`和`tearDown`方法中，我们需要代码来启动一个Selenium将控制的网络浏览器，然后在测试结束时关闭它：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code spawns a new Firefox window with Selenium controlling it. For this
    to work, of course, you need Firefox installed on your computer. Selenium does
    have support for other browsers, but using others requires an extra program in
    order for it to work correctly. Firefox thus has the best support out of all the
    browsers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码通过Selenium控制创建一个新的Firefox窗口。当然，为了使其工作，您需要在您的计算机上安装Firefox。Selenium确实支持其他浏览器，但使用其他浏览器需要额外的程序才能正确工作。因此，Firefox在所有浏览器中具有最好的支持。
- en: 'Before we write the code for the test, let''s explore the Selenium API as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写测试代码之前，让我们按照以下方式探索Selenium API：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These are the main functions from Selenium that we will be using, but there
    are many other ways to find and interact with elements on the web page.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将使用的主要Selenium函数，但还有许多其他方法可以找到和与网页上的元素交互。
- en: For the full list of available features, refer to the Selenium-Python documentation
    at [http://selenium-python.readthedocs.org](http://selenium-python.readthedocs.org).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有可用功能的完整列表，请参阅 Selenium-Python 文档，网址为 [http://selenium-python.readthedocs.org](http://selenium-python.readthedocs.org)。
- en: 'There are two gotchas in Selenium that need to be kept in mind while writing
    your tests, or you will run into very odd bugs that are almost impossible to debug
    from their error messages:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时，有两个需要注意的 Selenium 陷阱，否则你可能会遇到非常奇怪的错误，这些错误几乎不可能从错误消息中调试：
- en: Selenium is designed to work as if there is an actual person controlling the
    browser. This means that, if an element cannot be seen on the page, Selenium cannot
    interact with it. For example, if an element covers another element that you wish
    to click on—say, a modal window is in front of a button—then the button cannot
    be pushed. If the element's CSS has its display set to `none`, or its visibility
    set to `hidden`, the results will be the same.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Selenium 被设计成好像有一个真实的人正在控制浏览器。这意味着，如果页面上的某个元素不可见，Selenium 就无法与之交互。例如，如果某个元素覆盖了你希望点击的另一个元素——比如说，一个模态窗口在按钮前面——那么按钮就无法被按下。如果元素的
    CSS 将其 `display` 设置为 `none`，或者将其 `visibility` 设置为 `hidden`，结果将相同。
- en: All of the variables that point toward elements on the screen are stored as
    pointers to those elements in the browser, meaning they are not stored in Python's
    memory. If the page changes without using the `get` method, such as when a link
    is clicked and a new element pointer is created, then the test will crash. This
    happens because the driver will continuously be looking for the elements on the
    previous page, and not finding them on the new one. The `get` method of the driver
    clears out all those references.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有指向屏幕上元素的变量都存储为浏览器中这些元素的指针，这意味着它们不是存储在 Python 的内存中。如果页面在没有使用 `get` 方法的情况下发生变化，例如当点击链接并创建新的元素指针时，测试将崩溃。这是因为驱动程序将不断寻找前一个页面上的元素，但在新页面上找不到它们。驱动程序的
    `get` 方法清除所有这些引用。
- en: 'In the preceding tests, we used the test client in order to simulate a request
    to the application object. However, because we are now using something that needs
    to directly interface with the application through a web browser, we need an actual
    server to be running. This server needs to be run in a separate Terminal window
    before the user interface tests are run, so that the latter have something to
    request. To do this, we need a separate Python file in order to run the server
    with our test configuration, as well as needing to set up some models for our
    UI tests to use. At the root of the project directory, in a new file named `run_test_server.py`,
    add the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们使用了测试客户端来模拟对应用程序对象的请求。然而，因为我们现在使用的是需要通过浏览器直接与应用程序交互的东西，我们需要一个实际的服务器正在运行。这个服务器需要在运行用户界面测试之前在单独的终端窗口中运行，以便后者有东西可以请求。为此，我们需要一个单独的
    Python 文件来运行服务器，并使用我们的测试配置，还需要为我们的 UI 测试设置一些模型。在项目目录的根目录中，创建一个名为 `run_test_server.py`
    的新文件，并添加以下内容：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that we have both the test server script and some knowledge of Selenium''s
    API, we can finally write the code for our test:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了测试服务器脚本和对 Selenium API 的了解，我们最终可以编写我们的测试代码了：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Most of this test uses the methods that we introduced earlier. However, there
    is a new method in this test, named `switch_to`. The `switch_to` method is the
    context of the driver that allows the selection of elements inside an `iframe`
    element. Normally, it's impossible for the parent window to select any elements
    inside an `iframe` element using JavaScript, but because we are directly interfacing
    with the browser itself, we can access an `iframe` element's contents. We need
    to switch contacts like these, because the WYSIWYG editor inside the post creation
    page uses `iframe` in order to create itself. After we are done with selecting
    elements within the `iframe`, we need to switch back to the parent context using
    the `parent_frame` method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分这个测试使用了我们之前介绍的方法。然而，在这个测试中有一个新的方法，名为 `switch_to`。`switch_to` 方法是驱动程序上下文的一部分，允许选择
    `iframe` 元素内的元素。通常情况下，使用 JavaScript，父窗口无法选择 `iframe` 元素内的任何元素，但因为我们直接与浏览器本身进行交互，我们可以访问
    `iframe` 元素的内部内容。我们需要切换这样的联系人，因为帖子创建页面内的 WYSIWYG 编辑器使用 `iframe` 来创建自身。在完成选择 `iframe`
    内的元素后，我们需要使用 `parent_frame` 方法切换回父上下文。
- en: You now have the tools that you need to completely test both your server code
    and your user interface code. For the rest of the chapter, we will focus on tools
    and methodologies, in order to make your testing even more effective in ensuring
    your application's correctness.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在拥有了完全测试你的服务器代码和用户界面代码所需的工具。在接下来的章节中，我们将重点关注工具和方法，以便使你的测试在确保应用程序正确性方面更加有效。
- en: Test coverage
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试覆盖率
- en: 'Now that our tests have been written, we have to know whether our code is sufficiently
    tested. The concept of **test coverage**, also known as **code coverage**, was
    invented to solve this issue. In any project, the test coverage represents what
    percentage of the code in the project was executed when the tests were run, and
    which lines were never run. This gives an idea of what parts of the project aren''t
    being tested by our unit tests. To add coverage reports to our project, install
    the coverage library with `pip`, and make sure it''s included in the `requirements.txt`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了测试，我们必须知道我们的代码是否得到了充分的测试。**测试覆盖率**（也称为**代码覆盖率**）的概念是为了解决这个问题而发明的。在任何项目中，测试覆盖率表示在运行测试时项目中的代码执行百分比，以及哪些行从未运行。这给出了一个关于哪些项目部分没有被我们的单元测试测试的想法。为了将覆盖率报告添加到我们的项目中，使用
    `pip` 安装覆盖率库，并确保它包含在 `requirements.txt` 中：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The coverage library can be run as a command-line program that will run your
    test suite, and take its measurements while the tests are running:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率库可以作为命令行程序运行，在测试运行时执行你的测试套件并获取其测量结果：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `--source` flag tells `coverage` to only report on the test coverage for
    the files in the `webapp` directory. If that weren't included, the percentages
    for all the libraries used in the app would be included as well. By default, if
    any code in an `if` statement is executed, the entire `if` statement is said to
    have executed. The `--branch` flag tells `coverage` to disable this, and measure
    everything.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`--source` 标志告诉 `coverage` 只报告 `webapp` 目录中文件的测试覆盖率。如果不包括它，所有在应用程序中使用的库的百分比也会包括在内。默认情况下，如果
    `if` 语句中的任何代码被执行，整个 `if` 语句就被说成是执行了。`--branch` 标志告诉 `coverage` 禁用此功能，并测量一切。'
- en: 'After `coverage` runs our tests and takes its measurements, we can see a report
    of its findings in two ways. The first is to see a printout of each file''s coverage
    percentage on the command line:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `coverage` 运行我们的测试并获取其测量结果后，我们可以通过两种方式查看其发现报告。第一种是在命令行上查看每个文件的覆盖率百分比：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The second way to see the report is to use the HTML generating ability of `coverage`
    to see a detailed breakdown of each file in the browser, using the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 查看报告的第二种方式是使用 `coverage` 的 HTML 生成能力，在浏览器中查看每个文件的详细分解，使用以下命令：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding command creates a directory named `htmlcov`. When the `index.html`
    file is opened in the browser, each file name can be clicked on to reveal the
    breakdown of which lines were run, and which were not, during the tests:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令创建了一个名为 `htmlcov` 的目录。当在浏览器中打开 `index.html` 文件时，可以点击每个文件名来查看测试期间哪些行被执行，哪些行没有执行：
- en: '![](img/6e4f6711-c002-4e0a-a7b0-5fbff0adb5a4.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e4f6711-c002-4e0a-a7b0-5fbff0adb5a4.png)'
- en: In the preceding screenshot, the `blog/controllers.py` file was opened, and
    the coverage report clearly shows that the post route was never executed. However,
    this also gives some false negatives. As the user interface tests are not testing
    code that is being run by the coverage program, it doesn't count toward our coverage
    report. In order to fix this, just to make sure that you have tests in your test
    cases for each individual function that would have been tested in the user interface
    tests.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，打开了 `blog/controllers.py` 文件，覆盖率报告清楚地显示帖子路由从未被执行。然而，这也带来了一些错误的否定。由于用户界面测试没有测试由覆盖率程序运行的代码，它不计入我们的覆盖率报告。为了解决这个问题，确保你在测试用例中对每个将被用户界面测试测试的单独函数都有测试。
- en: In most projects, the percentage to aim for is around 90% code coverage. It's
    very rare that a project will have 100% of its code testable, and this possibility
    decreases as the size of the project increases.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数项目中，目标覆盖率百分比约为 90%。很少有项目会有 100% 的代码可测试，并且随着项目规模的增加，这种可能性会降低。
- en: Test-driven development
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: Now that we have our tests written, how can they be integrated into the development
    process? Currently, we are using our tests in order to ensure code correctness
    after we create a feature. But, what if we flipped the order and used tests in
    order to create correct code from the beginning? This is what **test-driven development**
    (**TDD**) advocates.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了测试，如何将它们集成到开发过程中呢？目前，我们使用测试来确保在创建功能后代码的正确性。但是，如果我们颠倒顺序，从一开始就使用测试来创建正确的代码，会怎么样呢？这正是**测试驱动开发**（**TDD**）所倡导的。
- en: 'TDD follows a simple loop to write the code of a new feature in your application:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: TDD遵循一个简单的循环来编写你应用程序中新的功能代码：
- en: '![](img/55a76ee5-c1da-4c76-adc3-4a1af6308ab1.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/55a76ee5-c1da-4c76-adc3-4a1af6308ab1.png)'
- en: In a project that uses TDD, the first thing that you write, before any of the
    code that controls what you are actually building, is the tests. What this forces
    the programmers on the project to do is to plan out the project's scope, design,
    and requirements before writing any code. While designing APIs, it also forces
    the programmer to design the interface (or contract) of the API from a consumer's
    perspective, rather than design the interface after all the backend code has been
    written.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用TDD的项目中，你首先编写的是测试，而不是控制你实际构建的任何代码。这迫使项目中的程序员在编写任何代码之前规划项目的范围、设计和需求。在设计API时，这也迫使程序员从消费者的角度设计API的接口（或合同），而不是在所有后端代码编写完毕后再设计接口。
- en: In TDD, tests are designed to fail the first time that you run them. There is
    a saying in TDD, that if your tests don't fail the first time that you run them,
    you're not really testing anything. What this means is that you are most likely
    testing to the tested unit's function, rather than how it should function while
    writing tests after the fact.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD中，测试被设计成第一次运行时就会失败。在TDD中有一句话，如果你的测试第一次运行时没有失败，那么你实际上并没有真正进行测试。这意味着你很可能是测试了测试单元的功能，而不是在编写测试之后如何应该工作。
- en: After your tests fail the first time, you then continuously write code until
    all the tests pass. This process is repeated for each new feature.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试第一次失败后，你然后会持续编写代码，直到所有测试通过。这个过程会为每个新功能重复进行。
- en: Once all of the original tests pass and the code is refactored, TDD tells you
    to stop writing code. By only writing code until the tests pass, TDD also enforces
    the **You Aren't Going To Need It** (**YAGNI**) philosophy, which states that
    programmers should only implement what they actually need, rather than what they
    perceive they will need. A huge amount of wasted effort is made during development
    when programmers try to preemptively add functionality when no-one needed it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有原始测试通过并且代码重构完成，TDD会告诉你停止编写代码。通过仅在测试通过之前编写代码，TDD还强制执行了**YAGNI（你不会需要它）**哲学，该哲学指出程序员应该只实现他们实际需要的功能，而不是他们认为将来需要的功能。当程序员试图预先添加不需要的功能时，在开发过程中会浪费大量的精力。
- en: TDD also promotes the idea of **Keep It Simple, Stupid** (**KISS**), which dictates
    that simplicity should be a design goal from the beginning. TDD promotes KISS
    because it requires small, testable units of code that can be separated from each
    other and don't rely on a shared global state.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: TDD还提倡**KISS（保持简单，傻瓜）**的理念，这规定从开始设计时，简单性应该是一个设计目标。TDD提倡KISS，因为它要求编写小的、可测试的代码单元，这些单元可以彼此分离，并且不依赖于共享的全局状态。
- en: Also, in projects that follow TDD, there is an always-current documentation
    throughout the tests. One of the axioms of programming is that with any sufficiently
    large program, the documentation will always be out of date. This is because the
    documentation is one of the last things on the mind of the programmer when they
    are changing the code. However, with tests, there are clear examples of each piece
    of functionality in the project (if the project has a large code coverage percentage).
    The tests are updated all the time, and therefore, show good examples of how the
    functions and API of the program should work.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在遵循TDD（测试驱动开发）的项目中，测试过程中始终存在最新的文档。编程的一个公理是，对于任何足够大的程序，文档总是会过时。这是因为当程序员更改代码时，文档往往是他们最后考虑的事情。然而，通过测试，项目中每个功能模块都有明确的示例（如果项目有较高的代码覆盖率）。测试会不断更新，因此，展示了程序功能和API应该如何工作的良好示例。
- en: Now that you understand Flask's functionality and how to write tests for Flask,
    the next project that you create in Flask can be made entirely with TDD.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 Flask 的功能以及如何为 Flask 编写测试，你接下来在 Flask 中创建的项目可以完全使用 TDD（测试驱动开发）方法来完成。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now that you understand testing and what it can do for your application, you
    can create applications that are guaranteed to be less bug-ridden. You will spend
    less time fixing bugs, and more time adding features that are requested by your
    users.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了测试以及它能为你的应用程序带来什么，你可以创建出几乎零缺陷的应用程序。你将花费更少的时间来修复缺陷，更多的时间来添加用户请求的功能。
- en: As a final challenge to the reader, before moving onto the next chapter, try
    to get your code coverage over 95%.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对读者的最终挑战，在进入下一章之前，尝试让你的代码覆盖率超过 95%。
- en: In the next chapter, we will finish the book by going over the ways by which
    you can deploy your application into a production environment on a server.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过介绍你将应用程序部署到服务器上的生产环境的方法来结束本书。
