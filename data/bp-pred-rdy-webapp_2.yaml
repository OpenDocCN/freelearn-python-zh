- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Creating a Reusable Backend with Quart
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Quart 创建可重用的后端
- en: 'In the preceding chapter, we installed the tooling we need to develop our app,
    which means we can start building the backend. The backend runs on the server
    as opposed to the frontend, which runs in the client’s web browser. In our setup,
    the backend will need to be the interface between the database and the frontend,
    providing an API to access and edit the to-dos (see *Figure 2.1*):'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们安装了开发应用程序所需的工具，这意味着我们可以开始构建后端。后端在服务器上运行，而前端在客户端的网页浏览器中运行。在我们的设置中，后端需要成为数据库和前端之间的接口，提供
    API 以访问和编辑待办事项（见图 2.1）：
- en: '![Figure 2.1: A schematic overview of the desired setup ](img/B18727_02_01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1：所需设置的示意图](img/B18727_02_01.jpg)'
- en: 'Figure 2.1: A schematic overview of the desired setup'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：所需设置的示意图
- en: Alongside providing an API, the backend will also need to connect to the database,
    manage user sessions, protect itself against heavy and incorrect usage, and send
    emails to users. In this chapter, we will build a backend with these features.
    At the end of the chapter, we will have built a reusable backend that any API
    can be built with. Alternatively, the features can be taken in parts to add to
    your own app.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供 API，后端还需要连接到数据库，管理用户会话，保护自身免受重负载和不正确使用的影响，并向用户发送电子邮件。在本章中，我们将构建具有这些功能的后端。本章结束时，我们将构建一个可重用的后端，任何
    API 都可以使用它。或者，可以将这些功能分部分添加到您自己的应用程序中。
- en: 'So, in this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Creating a basic Quart app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本的 Quart 应用程序
- en: Including user accounts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含用户账户
- en: Protecting the app
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护应用程序
- en: Connecting to the database
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: Sending emails
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following additional folders are required in this chapter and should be
    created:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下附加文件夹，并应创建它们：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Empty *backend/src/backend/__init__.py*, *backend/src/backend/blueprints/__init__.py*,
    *backend/src/backend/lib/__init__.py*, *backend/tests/__init__.py*, *backend/tests/blueprints/__init__.py*,
    and *backend/tests/lib/__init__.py* files should be created.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 应该创建以下空文件：*backend/src/backend/__init__.py*，*backend/src/backend/blueprints/__init__.py*，*backend/src/backend/lib/__init__.py*，*backend/tests/__init__.py*，*backend/tests/blueprints/__init__.py*，和
    *backend/tests/lib/__init__.py*。
- en: To follow the development in this chapter, use the companion repository at [https://github.com/pgjones/tozo](https://github.com/pgjones/tozo)
    and see the commits between the tags `r1-ch2-start` and `r1-ch2-end`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟踪本章的开发过程，请使用配套仓库[https://github.com/pgjones/tozo](https://github.com/pgjones/tozo)，并查看标签
    `r1-ch2-start` 和 `r1-ch2-end` 之间的提交。
- en: Creating a basic Quart app
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本的 Quart 应用程序
- en: To begin, we can make a basic API that responds to requests with a simple response.
    This is something I like to term a ping-pong route as the request is the ping
    and the response is the pong. To do this, I’ve chosen to use the Quart framework.
    **Quart** is a web microframework with an ecosystem of extensions that we will
    use to add additional functionality.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以创建一个基本的 API，它对请求做出简单的响应。我喜欢将此称为乒乓路由，因为请求是乒乓，响应是pong。为此，我选择使用 Quart 框架。**Quart**
    是一个带有扩展生态系统的小型 Web 框架，我们将使用它来添加额外的功能。
- en: Using Flask as an alternative
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Flask 作为替代方案
- en: Quart is the async version of the very popular Flask framework, which allows
    us to use modern async libraries. However, if you are already familiar with Flask,
    you can adapt the code in this book without too much difficulty; see [https://quart.palletsprojects.com/en/latest/how_to_guides/flask_migration.xhtml](https://quart.palletsprojects.com/en/latest/how_to_guides/flask_migration.xhtml)
    for more information.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Quart 是非常流行的 Flask 框架的异步版本，它允许我们使用现代异步库。然而，如果您已经熟悉 Flask，您可以在本书中轻松地调整代码；有关更多信息，请参阅[https://quart.palletsprojects.com/en/latest/how_to_guides/flask_migration.xhtml](https://quart.palletsprojects.com/en/latest/how_to_guides/flask_migration.xhtml)。
- en: 'To use Quart, we must first add it with `pdm` by running the following command
    in the *backend* directory:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Quart，我们首先需要通过在 *backend* 目录中运行以下命令来使用 `pdm` 添加它：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can now create a Quart app by adding the following code to *backend/src/backend/run.py*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 *backend/src/backend/run.py* 文件中添加以下代码来创建一个 Quart 应用程序：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This allows us to add functions, called route handlers, which are called when
    a request matches the given HTTP method and path and returns the response. For
    our basic app, we want requests to *GET /control/ping/* to be responded to. This
    is achieved by adding the following code to *backend/src/backend/run.py*:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们添加函数，称为路由处理程序，当请求与给定的HTTP方法和路径匹配时，会调用这些函数并返回响应。对于我们的基本应用，我们希望对*GET /control/ping/*的请求做出响应。这是通过将以下代码添加到*backend/src/backend/run.py*中实现的：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that there is code to create the app with a ping route, we should set up
    the tooling so that the server starts locally and serves requests. As with the
    backend tooling, we need to add a new script name to *backend/pyproject.toml*
    as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了创建带有ping路由的应用的代码，我们应该设置工具，以便服务器在本地启动并处理请求。与后端工具一样，我们需要在*backend/pyproject.toml*中添加一个新的脚本名称，如下所示：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code allows the following command to start the backend app when
    it is run in the *backend* directory, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码允许在*backend*目录下运行时启动后端应用，如下所示：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With this command running, we can check whether the ping route works by running
    the following command in any directory:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 命令运行后，我们可以在任何目录中运行以下命令来检查ping路由是否工作：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, you could enter [http://localhost:5050/control/ping/](http://localhost:5050/control/ping/)
    in your browser, as shown in *Figure 2.2*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在浏览器中输入[http://localhost:5050/control/ping/](http://localhost:5050/control/ping/)，如图2.2所示：
- en: '![Figure 2.2: The control ping route when visited in the browser ](img/B18727_02_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2：在浏览器中访问时的控制ping路由](img/B18727_02_02.jpg)'
- en: 'Figure 2.2: The control ping route when visited in the browser'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：在浏览器中访问时的控制ping路由
- en: Using curl
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用curl
- en: '`curl` ([https://curl.se/docs/manpage.xhtml](https://curl.se/docs/manpage.xhtml))
    is an excellent command-line tool to make HTTP requests. `curl` is installed on
    most systems by default, but if you find that you don’t have it, you can use the
    system package manager to install it (`brew install curl` or `scoop install curl`).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl` ([https://curl.se/docs/manpage.xhtml](https://curl.se/docs/manpage.xhtml))
    是一个优秀的命令行工具，用于发送HTTP请求。`curl`默认安装在大多数系统上，但如果你发现你没有它，你可以使用系统包管理器来安装它（`brew install
    curl`或`scoop install curl`）。'
- en: 'Without any options, `curl` makes a `GET` request, and you can switch to a
    `POST` request using the `-X POST` option, or you can send JSON data using the
    `--json ‘{“tool”: “curl”}’` option.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '不带任何选项，`curl`执行一个`GET`请求，你可以使用`-X POST`选项切换到`POST`请求，或者你可以使用`--json ‘{“tool”:
    “curl”}’`选项发送JSON数据。'
- en: This is all that is required for a basic backend; however, we need more functionality
    and more certainty that the code works. We’ll achieve this by adding testing,
    using blueprints, adding configuration, and ensuring a consistent JSON error response.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个基本的后端来说，这已经足够了；然而，我们需要更多的功能，以及代码能够正常工作的更多确定性。我们将通过添加测试、使用蓝图、添加配置和确保一致的JSON错误响应来实现这一点。
- en: Testing the ping route
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试ping路由
- en: 'It is good practice to test whether the route works as expected. To do this,
    we can add the following test to *backend/tests/test_run.py*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 测试路由是否按预期工作是一种良好的实践。为此，我们可以在*backend/tests/test_run.py*中添加以下测试：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With the test code in place, we can run `pdm run test` and see whether it both
    runs and passes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试代码就绪后，我们可以运行`pdm run test`来查看它是否运行并通过。
- en: Warning about a common await error
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 关于常见await错误的警告
- en: 'I’ve found it common to incorrectly await the wrong thing in Python, and it
    seems common with others as well. The issue is often seen with code such as:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现Python中错误地等待错误的事情很常见，而且似乎其他人也有这个问题。这个问题通常在如下代码中看到：
- en: '`await response.get_json()[“ping”]`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`await response.get_json()[“ping”]`。'
- en: 'This will fail with the `couroutine cannot be indexed` error, as the coroutine
    returned by `response.get_json()` must be awaited before it is indexed. This issue
    is fixed by adding parenthesis in the right place, which in this case is as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将因`couroutine cannot be indexed`错误而失败，因为`response.get_json()`返回的协程必须在索引之前等待。这个问题通过在正确的位置添加括号来解决，在这个例子中如下所示：
- en: '`(await response.get_json())[“ping”]`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`(await response.get_json())[“ping”]`。'
- en: Now that we have a working ping-pong route, we need to consider how to add many
    more routes, which, for clarity, is best done using blueprints.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个工作的ping-pong路由，我们需要考虑如何添加更多的路由，为了清晰起见，最好使用蓝图来完成。
- en: Using blueprints for clearer code
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用蓝图使代码更清晰
- en: We added the ping route handler to the same file as the app (*backend/src/backend/run.py*)
    as it is the easiest way to start; however, as we add more route handlers, the
    file will quickly become unclear and difficult to update. Quart provides blueprints
    to help structure code as the app gets bigger. As we will be adding more route
    handlers, we’ll convert what we have so far into blueprints.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将ping路由处理程序添加到与应用程序相同的文件中（*backend/src/backend/run.py*），因为这是最简单的方法来启动；然而，随着我们添加更多的路由处理程序，文件将很快变得不清楚且难以更新。Quart提供了蓝图来帮助随着应用程序变大而结构化代码。由于我们将添加更多的路由处理程序，我们将把到目前为止的内容转换为蓝图。
- en: 'We can now move the ping route handler to a control blueprint by adding the
    following code to *backend/src/backend/blueprints/control.py*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将ping路由处理程序移动到控制蓝图，通过向*backend/src/backend/blueprints/control.py*添加以下代码：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can then register it with the app by changing *backend/src/backend/run.py*
    to the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过将*backend/src/backend/run.py*更改为以下内容来将其注册到应用程序中：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The existing tests will continue to work; however, I think the location of the
    test should shadow the location of the code it is testing. This makes it easier
    to understand where the tests are, and what the tests should be testing. Therefore,
    we need to move *backend/tests/test_run.py* to *backend/tests/blueprints/test_control.py*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的测试将继续工作；然而，我认为测试的位置应该覆盖它所测试的代码的位置。这使得理解测试在哪里以及测试应该测试什么变得更加容易。因此，我们需要将*backend/tests/test_run.py*移动到*backend/tests/blueprints/test_control.py*。
- en: 'You should now have the following backend files and structure:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该有以下后端文件和结构：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’ll use a blueprint for each logical collection of features in our app and
    follow this structure throughout. We can now focus on configuring the app to run
    in the various environments we will use.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为应用程序中每个逻辑功能集合使用一个蓝图，并在整个结构中遵循此结构。我们现在可以专注于配置应用程序以在各种环境中运行。
- en: Configuring the app
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置应用程序
- en: We need to run our app in multiple environments, notably development, testing,
    CI, and production. To do so, we’ll need to change some settings in each; for
    example, the database connection. Configuration allows us to change these settings
    without having to alter the code. It also allows secrets to be managed separately
    from the code, and hence more securely.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在多个环境中运行我们的应用程序，特别是开发、测试、CI和生成环境。为此，我们需要在每个环境中更改一些设置；例如，数据库连接。配置允许我们更改这些设置而不必修改代码。它还允许将秘密与代码分开管理，从而更加安全。
- en: 'I find environment variables to be the best way to provide configuration, with
    each environment having different values for the same variable. We can instruct
    Quart to load the configuration from prefixed environment variables. The prefix
    ensures that only relevant environment variables are considered; by default, the
    prefix is `QUART_`, but we’ll change it to `TOZO_`. To do so, we’ll need to add
    the following change to *backend/src/backend/run.py* so that the config is loaded
    immediately after the app is created:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为环境变量是提供配置的最佳方式，每个环境都有相同变量的不同值。我们可以指示Quart从带前缀的环境变量中加载配置。前缀确保只考虑相关的环境变量；默认前缀是`QUART_`，但我们将将其更改为`TOZO_`。为此，我们需要将以下更改添加到*backend/src/backend/run.py*，以便在创建应用程序后立即加载配置：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The highlighted line of code should already be present.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 应该已经存在高亮显示的代码行。
- en: 'In production, we’ll define the environment variables using a Terraform script,
    whereas locally, we will load environment variables from a file. First, for development,
    we need to add the following to *backend/development.env*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中，我们将使用Terraform脚本来定义环境变量，而在本地，我们将从文件中加载环境变量。首先，对于开发，我们需要将以下内容添加到*backend/development.env*：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Second, for testing, we need to add the following to *backend/testing.env*:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，对于测试，我们需要将以下内容添加到*backend/testing.env*：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that the files exist, we can adapt the PDM scripts to load them when starting
    the app or running tests by making the following change to *backend/pyproject.toml*:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在文件已经存在，我们可以通过将以下更改应用到*backend/pyproject.toml*来调整PDM脚本，以便在启动应用程序或运行测试时加载它们：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These small modifications to the scripts will ensure that the environment is
    automatically loaded when using the `pdm run start` and `pdm run test` commands.
    We’ll now look at an often-overlooked feature, which is consistent error responses.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对脚本的微小修改将确保在执行`pdm run start`和`pdm run test`命令时自动加载环境。现在，我们将查看一个经常被忽视的功能，即一致的错误响应。
- en: Ensuring error responses are JSON
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保错误响应是JSON格式
- en: As we are writing a backend API that serves JSON, it is important that all responses
    use JSON, including error responses. Therefore, rather than using the Quart built-in
    error responses, we will use our own that explicitly result in a JSON response.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在编写一个服务于 JSON 的后端 API，因此所有响应都应使用 JSON，包括错误响应。因此，我们不会使用 Quart 内置的错误响应，而是将使用我们自己的，这些响应会明确地产生
    JSON 响应。
- en: 'Error responses are usually signified by a status code in the 400-500 range.
    However, the status code alone cannot always convey enough information. For example,
    when registering a new member, a status code of 400 is expected for a request
    with an invalid email address and a request with a weak password. Hence, there
    is a need to return an additional code to separate these cases. We can do so by
    adding the following code to *backend/src/backend/lib/api_error.py*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 错误响应通常由 400-500 范围内的状态码表示。然而，仅状态码本身并不能总是传达足够的信息。例如，在注册新成员时，对于无效电子邮件地址的请求和密码强度不足的请求，都期望返回
    400 状态码。因此，需要返回一个额外的代码来区分这些情况。我们可以通过在 *backend/src/backend/lib/api_error.py* 中添加以下代码来实现：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With `APIError` available, we can now inform Quart how to handle it by adding
    the following code to *backend/src/backend/run.py*:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 `APIError` 的可用，我们现在可以通过在 *backend/src/backend/run.py* 中添加以下代码来告知 Quart 如何处理它：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We should also inform Quart how to handle any other unexpected errors, such
    as those that would result in a 500 “Internal Server Error” response, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该告知 Quart 如何处理任何其他意外错误，例如会导致 500 “内部服务器错误”响应的错误，如下所示：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We now have a basic Quart app setup to allow us to add all of the features we
    need for our actual app, starting with the ability to manage user accounts.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经设置了一个基本的 Quart 应用程序，以便我们能够添加我们实际应用程序所需的所有功能，首先是管理用户账户的能力。
- en: Including user accounts
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含用户账户
- en: As we want users to be able to log into our app, we will need to **authenticate**
    that the client is who they claim to be. Thereafter, we need to ensure that each
    user only gets to see their own to-dos. This is typically achieved by the user
    entering a username and password, which are then checked against stored versions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望用户能够登录我们的应用程序，我们需要验证客户端是否是他们声称的那个人。之后，我们需要确保每个用户只能看到他们自己的待办事项。这通常是通过用户输入用户名和密码来实现的，然后这些密码会被与存储的版本进行核对。
- en: We will need to authenticate every request the user makes to the backend; however,
    we ideally only want the user to enter their username and password once (until
    they log out). We can achieve this by saving information to a cookie when the
    user logs in, as the browser will then send us the cookie with every request.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要验证用户对后端发出的每个请求；然而，理想情况下我们只希望用户登录一次（直到他们注销）。我们可以通过在用户登录时将信息保存到 cookie 中来实现这一点，因为浏览器会随后将
    cookie 与每个请求一起发送。
- en: We will need to save a piece of identifying information to the cookie when the
    user logs in and starts the session; for example, their user ID. We can then read
    the cookie on every request and identify which user it is. However, cookies can
    be edited, or faked, by the client so we need to ensure that the information in
    the cookie hasn’t been tampered with.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登录并开始会话时，我们需要将一些识别信息保存到 cookie 中；例如，他们的用户 ID。然后，我们可以在每次请求时读取 cookie 并识别是哪个用户。然而，客户端可以编辑或伪造
    cookie，因此我们需要确保 cookie 中的信息没有被篡改。
- en: We can prevent tampering by signing the information in the cookie. Signing is
    where a cryptographic function is applied to the data using a secret key to create
    a signature. This signature is then stored with the data, allowing the stored
    signature to be checked against a recalculated version.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 cookie 中签名信息来防止篡改。签名是指使用一个密钥对数据进行加密函数处理以创建签名。然后，这个签名会与数据一起存储，允许存储的签名与重新计算版本进行核对。
- en: 'Quart-Auth is a Quart extension that does this for us by managing cookies and
    the data stored in them. Quart-Auth is installed by running the following command
    in the *backend* directory:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Quart-Auth 是一个 Quart 扩展，它会为我们管理 cookie 和存储在其中的数据。在 *backend* 目录中运行以下命令即可安装 Quart-Auth：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, you need to activate `AuthManager` when creating the app in *backend/src/backend/run.py,*
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在创建应用程序时，需要在 *backend/src/backend/run.py* 中激活 `AuthManager`，如下所示：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: While Quart-Auth comes with a sensible set of defaults for securing the cookie,
    our usage allows us to be more secure. Specifically, we can utilize the Strict
    SameSite setting, rather than the Lax setting that Quart-Auth defaults to. This
    is because we only need to authenticate non-navigation requests to the API routes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Quart-Auth 为保护cookie提供了一套合理的默认设置，但我们的使用方式使我们能够更加安全。具体来说，我们可以利用严格的SameSite设置，而不是Quart-Auth默认的宽松设置。这是因为我们只需要对API路由的非导航请求进行身份验证。
- en: SameSite
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: SameSite
- en: 'The SameSite setting ensures that cookie data is only sent with requests that
    originate from the given domain. This prevents other websites from initiating
    requests with the cookie data. To find out more information about SameSite, you
    can follow this link: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: SameSite设置确保cookie数据仅在来自指定域的请求中发送。这防止了其他网站使用cookie数据发起请求。要了解更多关于SameSite的信息，您可以点击以下链接：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)。
- en: 'To add the Strict SameSite setting, add the following to *backend/development.env*
    and *backend/testing.env*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加严格的SameSite设置，请将以下内容添加到 *backend/development.env* 和 *backend/testing.env*
    文件中：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, we will need to disable the secure cookie flag in development as we
    aren’t using HTTPS. This is done by adding the following to *backend/development.env*
    and *backend/testing.env*:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们未使用HTTPS，我们需要在开发环境中禁用安全cookie标志。这可以通过将以下内容添加到 *backend/development.env*
    和 *backend/testing.env* 文件中来实现：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With Quart-Auth managing the session, we now need to store the passwords, ensure
    that they are strong, and allow for passwordless authentication.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Quart-Auth管理会话，我们现在需要存储密码，确保它们足够强大，并允许无密码身份验证。
- en: Securely storing passwords
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全地存储密码
- en: While we can now manage a user’s session, in order to start it, the user needs
    to log in by providing an email and password. While the emails are fine to store
    directly in the database, extra care must be taken with the passwords. This is
    because users often use the same password across many websites/services, and if
    it were to leak from our app, we could have potentially leaked access to many
    other websites as well. Therefore, instead of storing the password directly, we
    will hash the password and store that.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在可以管理用户的会话，但为了开始会话，用户需要通过提供电子邮件和密码来登录。虽然电子邮件可以直接存储在数据库中，但密码需要特别注意。这是因为用户经常在许多网站/服务中使用相同的密码，如果我们的应用程序发生泄露，我们可能会泄露对许多其他网站的访问权限。因此，我们不会直接存储密码，而是将密码哈希并存储。
- en: A **password hash** is the result of applying a hashing operation to the plain-text
    password. A good hashing operation should ensure that the resultant hash cannot
    be turned back into the plain-text password and that each distinct plain-text
    password produces a different hash result.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**密码哈希**是将哈希操作应用于明文密码的结果。一个好的哈希操作应该确保生成的哈希值不能被转换回明文密码，并且每个不同的明文密码都会产生不同的哈希结果。'
- en: 'I like to use `bcrypt` as the hashing operation as it meets both of these requirements
    and is easy to use. `bcrypt` is installed by running the following command in
    the *backend* directory:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢使用`bcrypt`作为哈希操作，因为它同时满足这两个要求并且易于使用。在 *backend* 目录中运行以下命令即可安装`bcrypt`：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With `bcrypt` installed, we can hash passwords with generated salt per password
    as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了`bcrypt`之后，我们可以使用为每个密码生成的盐值来哈希密码，如下所示：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Checking whether a supplied password matches the hashed password is then done
    via the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 检查提供的密码是否与哈希密码匹配是通过以下代码完成的：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We will use `bcrypt` in the login and registration functionality we’ll add in
    [*Chapter 3*](B18727_03.xhtml#_idTextAnchor076)*, Building the API*. Next, we
    need to check whether the passwords are strong enough.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第3章*](B18727_03.xhtml#_idTextAnchor076)*，构建API*中添加的登录和注册功能中使用`bcrypt`。接下来，我们需要检查密码是否足够强大。
- en: Salting the password
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对密码进行加盐处理
- en: When hashing passwords, it is best practice to `salt`) is added to the password
    before the hash is calculated. As the salt is meant to be different for every
    stored password, it ensures that the same password hashed in two different implementations
    has a different hash. Hence, adding salt is an additional security measure that
    we do via the `bcrypt.gensalt` function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在散列密码时，最佳实践是在计算哈希之前向密码中添加`salt`。由于盐的目的是为每个存储的密码不同，因此它确保了在两个不同的实现中散列的相同密码具有不同的哈希。因此，添加盐是一个额外的安全措施，我们通过`bcrypt.gensalt`函数来实现。
- en: Ensuring passwords are strong
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保密码强度
- en: 'Users often choose weak passwords, which leave their account vulnerable. To
    protect against this, we should ensure that our users choose strong passwords.
    To do this, I like to use `zxcvbn` as it gives a score indicating the strength
    of the password. It is installed by running the following command in the *backend*
    directory:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 用户经常选择弱密码，这使得他们的账户容易受到攻击。为了防止这种情况，我们应该确保我们的用户选择强密码。为此，我喜欢使用`zxcvbn`，因为它给出了一个表示密码强度的分数。这是在*后端*目录中运行以下命令安装的：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It is then used to give a score, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它被用来给出分数，如下所示：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The score is a value between 0 and 4, of which I usually consider scores of
    3 or 4 good. Therefore, we will prevent passwords with lower scores from being
    used.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 分数是介于0到4之间的值，我通常认为3或4的分数是好的。因此，我们将阻止使用分数较低的密码。
- en: We will make use of `zxcvbn` when adding registration and change password functionality
    in the following chapter. Next, we need to consider how the user authenticates
    without a password; for example, when they have forgotten it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中添加注册和更改密码功能时，我们将使用`zxcvbn`。接下来，我们需要考虑用户在没有密码的情况下如何进行身份验证；例如，当他们忘记密码时。
- en: Allowing password-less authentication
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 允许无密码身份验证
- en: There are a few circumstances where users are unable to provide a password but
    can prove that they have access to the account’s email address. A prime example
    of this is when a user forgets their password and wishes to reset it. In these
    situations, we need to email the user a token that they can provide back to us,
    thereby authenticating them as the user in charge of the email. For this to work,
    the token must identify the user, and malicious users must not be able to tamper
    with the token or create their own tokens.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种情况下，用户无法提供密码，但可以证明他们有权访问账户的电子邮件地址。一个典型的例子是当用户忘记他们的密码并希望重置它时。在这些情况下，我们需要向用户发送一个令牌，他们可以将其提供给我们，从而验证他们是电子邮件负责的用户。为此，令牌必须能够识别用户，恶意用户必须不能篡改令牌或创建自己的令牌。
- en: 'To create a token, we can sign the user’s ID using a cryptographic `itsdangerous`,
    which is also what Quart-Auth uses for the cookies. `itsdangerous` is installed
    by running the following command in the *backend* directory:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建令牌，我们可以使用加密的`itsdangerous`对用户的ID进行签名，这也是Quart-Auth用于cookie的方法。`itsdangerous`是在*后端*目录中运行以下命令安装的：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As this approach does not encrypt the signed data, it is important to remember
    that users will be able to read anything we place in the token. Therefore, we
    must not put anything sensitive in the token (the user ID is not sensitive).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种方法没有加密签名数据，因此重要的是要记住，用户将能够阅读我们放在令牌中的任何内容。因此，我们不应在令牌中放置任何敏感信息（用户ID不是敏感信息）。
- en: 'We will also add a timestamp to our tokens; this way we can ensure that they
    expire after a specific period of time. In addition, as we want to be able to
    use the token in links, we need to use the `URLSafeTimedSerializer`. We can create
    a token with the user''s ID as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为我们的令牌添加时间戳；这样我们可以确保它们在特定时间段后过期。此外，由于我们希望能够在链接中使用令牌，我们需要使用`URLSafeTimedSerializer`。我们可以按照以下方式创建带有用户ID的令牌：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The token can then be read and checked as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌可以按照以下方式读取和检查：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As we are using timed tokens, we will need to control time when we are testing.
    For example, if we want to test an expired token, we will need to create the token
    at a time whereby it will be expired when checked. To do this, we can use `freezegun`,
    which is installed by running the following command in the *backend* directory:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是定时令牌，因此在测试时我们需要控制时间。例如，如果我们想测试一个已过期的令牌，我们需要在令牌检查时创建它，使其过期。为此，我们可以使用`freezegun`，这是在*后端*目录中运行以下命令安装的：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we can use the following code in our tests to create an old token:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在我们的测试中使用以下代码创建一个旧令牌：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This token can then be used to test how a route handler responds to a token
    that is out of date.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此令牌然后可以用来测试路由处理程序对过期令牌的响应。
- en: We will use `itsdangerous` and `freezegun` in the forgotten password functionality
    we’ll add in the following chapter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将添加忘记密码功能时，将使用`itsdangerous`和`freezegun`。
- en: Next, as there are malicious users that will attempt to attack our app, we’ll
    need to protect it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，由于有恶意用户会尝试攻击我们的应用，我们需要保护它。
- en: Protecting the app
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护应用
- en: Shortly after you deploy your app in production, users will at best, misuse
    it, and at worst, attack it. It is therefore worthwhile being defensive from the
    outset by adding rate limiting and request validation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在您将应用部署到生产环境后不久，用户最多会误用它，最坏的情况会攻击它。因此，从一开始就添加速率限制和请求验证进行防御是值得的。
- en: Rate limiting limits the rate at which a remote client can make requests to
    the app. This prevents a user from overloading the app with their requests, thereby
    preventing other users from using the app.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 速率限制限制了远程客户端向应用发送请求的速率。这防止了用户通过他们的请求过载应用，从而防止其他用户使用应用。
- en: Validation ensures that the JSON data received (or replied) matches an expected
    structure. This is helpful as it means an error message is displayed if the JSON
    data is structurally incorrect. It also mitigates against users sending structures
    that result in errors or issues in the app.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 验证确保接收到的（或回复的）JSON数据与预期的结构匹配。这很有帮助，因为它意味着如果JSON数据结构不正确，将显示错误消息。它还可以减轻用户发送导致错误或应用问题的结构的可能性。
- en: Adding rate limiting
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加速率限制
- en: 'We’ll use the Quart extension called Quart-Rate-Limiter to enforce rate limits,
    which is installed by running the following command in the *backend* directory:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用名为Quart-Rate-Limiter的Quart扩展来强制执行速率限制，该扩展通过在`*backend*`目录中运行以下命令来安装：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can now activate `RateLimiter` by adding the following code to *backend/src/backend/run.py*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过在`*backend/src/backend/run.py*`中添加以下代码来激活`RateLimiter`：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With the `RateLimiter` activated, any route in the app can be given **rate
    limit** protection, for example, to limit to six requests per minute, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当激活`RateLimiter`后，应用中的任何路由都可以获得**速率限制**保护，例如，限制每分钟最多六次请求，如下所示：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As with other errors, it is important to provide a JSON response if the client
    exceeds the rate limit; we can do this by adding the following code to *backend/src/backend/run.py*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他错误一样，如果客户端超过速率限制，提供JSON响应很重要；我们可以在`*backend/src/backend/run.py*`中添加以下代码来实现：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now that we can add rate limits, it is best practice to add them to all of the
    routes. To ensure that we do so, let’s add a test that checks for us.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够添加速率限制，最佳实践是将它们添加到所有路由。为了确保我们这样做，让我们添加一个检查的测试。
- en: Ensuring all routes have rate limits
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保所有路由都有速率限制
- en: 'Malicious attackers often search for paths with missing rate limits as a weakness
    they can then attack. To mitigate against this, I like to check that all routes
    have rate limits or are marked as exempt using the `rate_exempt` decorator. To
    do this, I add the following code to *tests/test_rate_limits.py*:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意攻击者通常会寻找缺少速率限制的路径作为他们可以攻击的弱点。为了减轻这种风险，我喜欢检查所有路由都有速率限制或被标记为豁免，使用`rate_exempt`装饰器。为此，我在`*tests/test_rate_limits.py*`中添加了以下代码：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In a Quart app, the rules are the method-path combinations that the app will
    respond to. Each rule has an endpoint that indicates which function should handle
    the request. The static endpoint is added by Quart, and hence we ignore it in
    this test.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在Quart应用中，规则是应用将响应的方法-路径组合。每个规则都有一个端点，指示哪个函数应该处理请求。静态端点是Quart添加的，因此我们在本次测试中忽略它。
- en: 'This test will check that all of the routes in the app have a rate limit or
    are exempt. This means that we also need to add the `rate_exempt` decorator to
    the control ping endpoint we added when setting up the basic app. This is done
    by adding the highlighted decorator to the ping route handler in *backend/src/backend/blueprints/control.py*
    as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试将检查应用中的所有路由都有速率限制或被豁免。这意味着我们还需要将`rate_exempt`装饰器添加到我们在设置基本应用时添加的控制ping端点。这通过在`*backend/src/backend/blueprints/control.py*`中的ping路由处理程序中添加突出显示的装饰器来完成，如下所示：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Alongside rate limiting routes, we can also protect the routes by validating
    the request and response data.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 除了速率限制路由外，我们还可以通过验证请求和响应数据来保护路由。
- en: Adding request and response validation
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加请求和响应验证
- en: 'Malicious users will often try to send malformed and invalid data in order
    to find mistakes in our code. To mitigate against this, we’ll use the Quart extension
    called Quart-Schema to validate requests and responses. It is installed by running
    the following command in the *backend* directory:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意用户通常会尝试发送格式错误和无效的数据，以寻找我们代码中的错误。为了减轻这种影响，我们将使用名为 Quart-Schema 的 Quart 扩展来验证请求和响应。在
    *backend* 目录中运行以下命令即可安装：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: By convention, JSON (Javascript/TypeScript) and Python use different naming
    conventions, with the former using *camelCase* and the latter *snake_case.* This
    means that we will need to convert between the two when receiving or replying.
    Fortunately, Quart-Schema can do this automatically for us, without any additional
    thought, via the `convert_casing` option.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，JSON（JavaScript/TypeScript）和 Python 使用不同的命名约定，前者使用 *camelCase*，后者 *snake_case*。这意味着在接收或回复时，我们需要在这两种命名约定之间进行转换。幸运的是，Quart-Schema
    可以通过 `convert_casing` 选项自动为我们完成这项工作，无需额外思考。
- en: 'We can activate `QuartSchema`, including setting the `convert_casing` option,
    by adding the following code to *backend/src/backend/run.py*:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向 *backend/src/backend/run.py* 添加以下代码来激活 `QuartSchema`，包括设置 `convert_casing`
    选项：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With this setup, we can use `dataclass` to define and validate the data the
    route expects to receive and to validate that it sends the correct data back,
    as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设置，我们可以使用 `dataclass` 来定义和验证路由期望接收的数据，以及验证它是否发送了正确的数据，如下所示：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As with other errors, it is important to provide a JSON response to the client
    with an informative message if the client sends the wrong data. We can do this
    by adding the following error handler to *backend/src/backend/run.py*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他错误一样，如果客户端发送错误数据，提供包含有用信息的 JSON 响应给客户端非常重要。我们可以通过向 *backend/src/backend/run.py*
    添加以下错误处理器来完成此操作：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Checking the type of `validation_error` allows for useful information to be
    returned in the response, thereby helping correct the issue.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `validation_error` 的类型可以在响应中返回有用的信息，从而帮助纠正问题。
- en: 'As Quart-Schema adds routes to our app that are not rate limited, we will need
    to change the `IGNORED_ENDPOINTS` line in *backend/tests/test_rate_limits.py*
    as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Quart-Schema 为我们的应用添加了不受速率限制的路由，因此我们需要更改 *backend/tests/test_rate_limits.py*
    中的 `IGNORED_ENDPOINTS` 行，如下所示：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As we can validate the structure of the data sent and received by the backend,
    we can now turn to how we store the data in the database. For that, we will need
    to be able to connect to it and execute queries.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以验证后端发送和接收的数据的结构，我们现在可以转向如何将数据存储在数据库中。为此，我们需要能够连接到它并执行查询。
- en: Connecting to the database
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'We have chosen to store the data the app needs in a PostgreSQL database, which
    we will need to connect to. To do this, I like to use the Quart extension called
    Quart-DB, which is a great wrapper around fast lower-level PostgreSQL drivers.
    It is installed by running the following command in the *backend* directory:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择将应用所需的数据存储在 PostgreSQL 数据库中，我们需要连接到该数据库。为此，我喜欢使用名为 Quart-DB 的 Quart 扩展，它是一个围绕快速低级
    PostgreSQL 驱动程序的优秀包装器。在 *backend* 目录中运行以下命令即可安装：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can activate `QuartDB` by adding the following code to *backend/src/backend/run.py*:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向 *backend/src/backend/run.py* 添加以下代码来激活 `QuartDB`：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We also need to configure which database `QuartDB` should connect to. This
    is achieved by adding a `TOZO_QUART_DB_DATABASE_URL` environment variable, the
    value of which is constructed as follows, with the highlighted parts being configurable:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要配置 `QuartDB` 应连接到的数据库。这是通过添加一个 `TOZO_QUART_DB_DATABASE_URL` 环境变量来实现的，其值如下所示，其中高亮部分是可配置的：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We’ll use `tozo` for the username, password, and database name in development
    as they are very obvious and easy to remember. To do this, add the following to
    *backend/development.env*:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发中，我们将使用 `tozo` 作为用户名、密码和数据库名，因为它们非常明显且易于记忆。为此，请向 *backend/development.env*
    添加以下内容：
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When testing, we’ll use `tozo_test` for the username, password, and database
    name so that test and development data are kept separate. To do this, add the
    following to *backend/testing.env*:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试时，我们将使用 `tozo_test` 作为用户名、密码和数据库名，以确保测试和开发数据保持分离。为此，请向 *backend/testing.env*
    添加以下内容：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As we develop, we will need to reset the database to a known state after making
    and testing changes. We’ll also want to reset the database before running the
    tests to ensure the tests don’t fail because the database is in a different state.
    To do this, we’ll start by adding a Quart CLI command to recreate the database
    by adding the following code to *backend/src/backend/run.py*:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发和测试更改后，我们需要将数据库重置到已知状态。在运行测试之前，我们也希望重置数据库以确保测试不会因为数据库处于不同状态而失败。为此，我们首先在`*backend/src/backend/run.py*`中添加以下代码以添加一个Quart
    CLI命令来重新创建数据库：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This command calls out to `psql` using the `call` function. The first two calls
    will drop the database and user if they already exist using the `DROP DATABASE`
    and `DROP USER` SQL commands. After they’ve been dropped, the next calls create
    the user and then the database using the `CREATE USER` and `CREATE DATABASE` SQL
    commands.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令通过`call`函数调用`psql`。前两个调用将使用`DROP DATABASE`和`DROP USER` SQL命令删除已存在的数据库和用户。删除后，接下来的调用将使用`CREATE
    USER`和`CREATE DATABASE` SQL命令创建用户和数据库。
- en: 'We can now utilize this command in the `pdm run test` script and add a new
    `pdm run recreate-db` script to reset the database on demand by making the following
    change to *backend/pyproject.toml*:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以利用此命令在`pdm run test`脚本中，并添加一个新的`pdm run recreate-db`脚本，以便按需重置数据库，通过在*backend/pyproject.toml*中做出以下更改：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The highlighted line indicates that the `test` script has been changed, whereas
    the `recreate-db` and `recreate-db-base` scripts have been added.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行表示`test`脚本已被更改，而`recreate-db`和`recreate-db-base`脚本已被添加。
- en: 'To check whether this works, we can now create the development database by
    running the following command in the *backend* directory:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查它是否工作，我们现在可以在*backend*目录中运行以下命令来创建开发数据库：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, to check that it has worked, we can open a `psql` shell to the database
    with the following command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了检查它是否工作，我们可以使用以下命令打开数据库的`psql` shell：
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The preceding command should give an output similar to that in *Figure 2.3*:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令应该给出类似于*图2.3*的输出：
- en: '![Figure 2.3: The output from psql when running the \dt command to describe
    the empty database ](img/B18727_02_04.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3：运行\dt命令描述空数据库时psql的输出](img/B18727_02_04.jpg)'
- en: 'Figure 2.3: The output from psql when running the \dt command to describe the
    empty database'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：运行\dt命令描述空数据库时psql的输出
- en: PSQL
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: PSQL
- en: PSQL is a command-line tool that can connect to a PostgreSQL database and allows
    queries and other commands to be run. This means you can test SQL queries from
    the command line and inspect the structure of the database. I’d recommend you
    try the `\dt` command that lists all of the tables in the database, and the `\d
    tbl` command that describes the structure of the table called *tbl*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: PSQL是一个命令行工具，可以连接到PostgreSQL数据库，并允许运行查询和其他命令。这意味着您可以从命令行测试SQL查询并检查数据库的结构。我建议您尝试`\dt`命令，该命令列出数据库中的所有表，以及`\d
    tbl`命令，该命令描述名为*tbl*的表的结构。
- en: 'When testing, we’ll need to run our tests in the Quart test app context as
    this ensures that the database connection is established. To do so, we need to
    add the following code to *backend/tests/conftest.py*:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试时，我们需要在Quart测试应用上下文中运行我们的测试，以确保建立了数据库连接。为此，我们需要在`*backend/tests/conftest.py*`中添加以下代码：
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `pytest` fixtures can be injected into tests, which means that we can use
    this fixture in our tests by declaring it as an argument. This means that *backend/tests/blueprints/test_control.py*
    must be rewritten as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest`固定文件可以被注入到测试中，这意味着我们可以通过将其声明为参数来在测试中使用此固定文件。这意味着必须将`*backend/tests/blueprints/test_control.py*`重写如下：'
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Another useful feature would be a direct connection to the database to use
    in the tests. This fixture is provided by adding the following code to *backend/conftest.py*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的功能是直接连接到数据库以在测试中使用。通过在`*backend/conftest.py*`中添加以下代码提供此固定文件：
- en: '[PRE54]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: With this in place, all of our tests can use the app fixture and run tests against
    the testing database.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在此设置完成后，我们所有的测试都可以使用应用固定文件，并对测试数据库运行测试。
- en: Alongside connecting to the database, we will also need the backend to connect
    to an email server to send emails to the users.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 除了连接到数据库外，我们还需要后端连接到邮件服务器以向用户发送邮件。
- en: Sending emails
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送邮件
- en: We will want to send users of our app emails, with the first being a confirmation
    email when they register. Another will be sent if the user forgets their password,
    as we can send them a password reset email. These targeted emails are transactional
    rather than marketing in nature, which is an important distinction as marketing
    emails are rarely sent via the app code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向我们的应用程序用户发送电子邮件，首先是他们在注册时收到的确认邮件。如果用户忘记了密码，我们也会发送一封密码重置邮件。这些有针对性的电子邮件是事务性的，而不是营销性的，这是一个重要的区别，因为营销邮件很少通过应用程序代码发送。
- en: With **transactional emails**, the aim is usually to convey a task to the user
    as clearly as possible. For this reason, the emails are usually text-based with
    minimal imagery. However, we should ensure the email is branded and has space
    for any required legal text. This means that we need to render the emails so that
    the transactional text is clear and surrounded by relevant branding and text.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**事务性电子邮件**，通常的目标是尽可能清晰地传达任务给用户。因此，这些电子邮件通常是基于文本的，图像最少。然而，我们应该确保电子邮件有品牌特色，并留有空间放置任何必需的法律文本。这意味着我们需要渲染电子邮件，使得事务性文本清晰，并围绕相关的品牌和文本。
- en: Rendering emails
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染电子邮件
- en: We will consider an email as consisting of a header where we will place branding
    (such as a logo), content where the specifics of the email (for example, a link
    to our app’s password reset page) are placed, and a footer where any legal information
    is placed. As only the content changes between emails, we can consider rendering
    the header and footer separately to the content.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把一封电子邮件视为由一个头部组成，我们将在这里放置品牌信息（例如，一个标志），内容部分将放置电子邮件的具体信息（例如，指向我们应用程序密码重置页面的链接），以及一个底部，其中放置任何法律信息。由于电子邮件之间只有内容会变化，我们可以考虑将头部和底部与内容分开渲染。
- en: As most email clients support HTML, we can style our emails to make them more
    engaging and pleasant to read. This means that we will need a HTML header/footer
    into which we can render the content of the specific email. This is best done
    using Quart’s built-in `render_template` function, which utilizes Jinja2 to render
    template documents.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数电子邮件客户端支持HTML，我们可以设计我们的电子邮件使其更具吸引力，更易于阅读。这意味着我们需要一个HTML头部/底部，我们可以将特定电子邮件的内容渲染到其中。这最好使用Quart内置的`render_template`函数来完成，该函数利用Jinja2来渲染模板文档。
- en: 'To start with the header and footer, we need to place the following code in
    *backend/src/backend/templates/email.xhtml*:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始设置头部和底部，我们需要在*backend/src/backend/templates/email.xhtml*中放置以下代码：
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As email clients only support limited parts of HTML and CSS, we are using a
    table to lay out the email. The layout we are aiming for is where the content
    is kept within a width of 540 px in the center of the viewport. This should support
    the majority of email clients while still looking good.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于电子邮件客户端只支持HTML和CSS的有限部分，我们使用表格来布局电子邮件。我们追求的布局是内容保持在视口中央的540像素宽度内。这应该支持大多数电子邮件客户端，同时仍然看起来不错。
- en: The highlighted `block` directives show only the contents within them when rendered,
    as shown in *Figure 2.4*. It allows any template that extends this base email
    to replace the contents of the blocks, hence we’ll use this as a base for all
    our emails.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的`block`指令在渲染时仅显示其内的内容，如图2.4所示。它允许任何扩展此基本电子邮件的模板替换块的内容，因此我们将以此作为所有电子邮件的基础。
- en: '![Figure 2.4: The rendered email when viewed in a browser ](img/Figure_2.4_NEW.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4：在浏览器中查看时渲染的电子邮件](img/Figure_2.4_NEW.jpg)'
- en: 'Figure 2.4: The rendered email when viewed in a browser'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：在浏览器中查看时渲染的电子邮件
- en: caniemail.com
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: caniemail.com
- en: The [caniemail.com](http://caniemail.com) website is an invaluable resource
    for checking which HTML and CSS features are supported by the various email clients
    in existence. I would recommend checking this site for any features added to the
    HTML email.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[caniemail.com](http://caniemail.com)网站是一个非常有价值的资源，用于检查现有的各种电子邮件客户端支持哪些HTML和CSS功能。我建议检查这个网站以了解添加到HTML电子邮件中的任何新功能。'
- en: Now that we have nice-looking emails, we can add code to send them to the user’s
    email address.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了漂亮的电子邮件，我们可以添加代码将它们发送到用户的电子邮件地址。
- en: Sending emails
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: While it is possible to send emails directly from the app using a SMTP server,
    I find that it is better practice to use a third-party service such as Postmark
    ([https://postmarkapp.com](https://postmarkapp.com)). This is because Postmark
    will ensure that our emails are sent reliably from a setup that helps ensure a
    low spam score, which is hard to achieve from a new SMTP server.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然直接从应用程序使用 SMTP 服务器发送电子邮件是可能的，但我发现使用像 Postmark ([https://postmarkapp.com](https://postmarkapp.com))
    这样的第三方服务是更好的实践。这是因为 Postmark 将确保我们的电子邮件从有助于确保低垃圾邮件评分的设置中可靠地发送，这是从新的 SMTP 服务器难以实现的。
- en: 'In development and testing, I prefer not to send emails but rather just log
    them out. I find this makes development easier and quicker (no checking any email
    inboxes). We can do this by starting with a `send_email` function that logs the
    email to the console by adding the following code to *backend/src/backend/lib/email.py*:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发和测试中，我更喜欢不发送电子邮件，而是将它们记录下来。我发现这使开发更容易、更快（无需检查任何电子邮件收件箱）。我们可以通过从 `send_email`
    函数开始，该函数通过将以下代码添加到 *backend/src/backend/lib/email.py* 中将电子邮件记录到控制台来实现：
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We’ll also need to configure the logging, which we can do with a basic setup
    by adding the following code to *backend/src/backend/run.py*:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要配置日志记录，这可以通过在 *backend/src/backend/run.py* 中添加以下代码通过基本设置来完成：
- en: '[PRE57]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To send emails with the third-party Postmark, we will need to send HTTP requests
    to their API. To do so, we can use `httpx`, which is installed by running the
    following command in the *backend* directory:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用第三方 Postmark 发送电子邮件，我们需要向他们的 API 发送 HTTP 请求。为此，我们可以在 *backend* 目录中运行以下命令来使用
    `httpx`：
- en: '[PRE58]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can then adjust the `send_email` function to send via Postmark if a token
    is available in the configuration by changing the code in *backend/src/backend/lib/email.py*
    as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以调整 `send_email` 函数，如果配置中可用令牌，通过更改 *backend/src/backend/lib/email.py*
    中的代码通过 Postmark 发送邮件，如下所示：
- en: '[PRE59]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `send_email` function now uses `httpx` to send a post request to Postmark,
    including the required token as a header and the email content in the request
    JSON body. Any errors returned by Postmark are raised as an easily identified
    `PostmarkError`. We can now focus on how we can use emails in the tests.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_email` 函数现在使用 `httpx` 发送 POST 请求到 Postmark，包括作为头部的必需令牌和请求 JSON 主体中的电子邮件内容。Postmark
    返回的任何错误都作为易于识别的 `PostmarkError` 抛出。我们现在可以专注于如何在测试中使用电子邮件。'
- en: Testing that emails are sent
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试电子邮件是否已发送
- en: 'When testing functionality in the backend, we’ll often want to check that an
    email was sent. We can do this by testing the `send_email` function by adding
    the following code to *backend/tests/lib/test_email.py*:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试后端的功能时，我们通常会想要检查是否已发送电子邮件。我们可以通过将以下代码添加到 *backend/tests/lib/test_email.py*
    中来测试 `send_email` 函数：
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`caplog` is a `pytest` fixture that captures everything that is logged during
    the test. This allows us to check that our email was logged by looking for the
    specific text.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`caplog` 是一个 `pytest` 修复程序，它捕获测试期间记录的所有内容。这允许我们通过查找特定文本来检查我们的电子邮件是否已记录。'
- en: 'With the backend now set up, we have everything we need in place to start developing
    our app’s API. The folder structure at this stage is as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经设置了后端，我们已经拥有了开始开发应用程序 API 所需的一切。此阶段的文件夹结构如下：
- en: '[PRE61]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve built a backend app in Quart that we can build our specific
    API on. It can connect to the database, manage user sessions, protect itself against
    heavy and incorrect usage, and send emails to the users.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 Quart 构建了一个后端应用程序，我们可以在其上构建特定的 API。它可以连接到数据库，管理用户会话，保护自己免受重和错误的使用，并向用户发送电子邮件。
- en: The features we’ve built in this chapter are common to many apps, and hence
    they will be useful for the app you are trying to build. In addition, the backend
    built in this chapter is generic and can be adapted for your specific use.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们构建的功能在许多应用中都很常见，因此它们将对你正在尝试构建的应用程序很有用。此外，本章中构建的后端是通用的，可以适应你的特定用途。
- en: In the following chapter, we’ll add an API to manage the users, allow users
    to log in, and support the to-do functionality we are building in this book.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将添加一个 API 来管理用户，允许用户登录，并支持我们在本书中构建的任务功能。
- en: Further reading
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: We’ve chosen to send only HTML emails for simplicity in this book; however,
    it is better practice to send multipart emails with HTML and plain-text parts.
    You can read an advocacy for this at [https://useplaintext.email](https://useplaintext.email).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，为了简化，我们选择只发送 HTML 电子邮件；然而，发送包含 HTML 和纯文本部分的复合电子邮件是更好的实践。你可以在 [https://useplaintext.email](https://useplaintext.email)
    阅读对此的倡导。
