- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Ongoing Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续架构
- en: 'Just as software itself is never truly complete, software architecture is never
    a finished piece of work. There are always changes, adjustments, and tweaks that
    need to be performed in order to improve the system: adding new features; improving
    performance; fixing security problems. While good architecture requires us to
    understand deeply how to design a system, the reality of the ongoing process is
    more about making changes and improvements.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如软件本身永远不会真正完成一样，软件架构也永远不会是一项完成的工作。总会有变化、调整和微调需要执行，以改进系统：添加新功能；提高性能；修复安全问题。虽然良好的架构要求我们深入了解如何设计系统，但持续过程的现实更多是关于进行更改和改进。
- en: We will talk in this chapter about some of those aspects, as well as dealing
    with some of the techniques and ideas around making changes in a real working
    system, keeping in mind that the process can always be improved further by reflecting
    on how the process is performed and following some guidelines to ensure that the
    system can be changed continuously while at the same time maintaining service
    to customers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论这些方面的某些内容，以及处理在实际运行系统中进行变更的一些技术和想法，同时考虑到这个过程可以通过反思执行过程并遵循一些指南来进一步改进，以确保系统可以持续变更，同时同时保持对客户的服务。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Adjusting the architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整架构
- en: Scheduled downtime
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计划停机时间
- en: Incidents
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Load testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压力测试
- en: Versioning
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制
- en: Backward compatibility
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向后兼容性
- en: Feature flags
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能标志
- en: Teamwork aspects of changes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更的团队合作方面
- en: Let's start by taking a look at why to make changes in the architecture of a
    system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看为什么要对系统的架构进行更改。
- en: Adjusting the architecture
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整架构
- en: While for most of this book we've been talking about system design, which is
    the basic function of an architect, it is most likely that the bulk of their day-to-day
    job will be more focused on redesigns.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这本书的大部分内容中，我们一直在谈论系统设计，这是建筑师的基本职能，但很可能他们的大部分日常工作将更多地集中在重新设计上。
- en: 'This is always an endless task, as working software systems are always under
    revision and expansion. Some of the reasons why it may be necessary to adjust
    the architecture of a system are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这总是一项永无止境的任务，因为工作软件系统始终处于修订和扩展中。可能需要调整系统架构的一些原因如下：
- en: To provide certain features or characteristics previously not available – for
    example, adding an event-driven system to run asynchronous tasks, allowing us
    to avoid the request-response pattern that was previously all that was available.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供之前不可用的某些功能或特性——例如，添加一个事件驱动的系统来运行异步任务，使我们能够避免之前可用的请求-响应模式。
- en: Because there are bottlenecks or limitations with the current architecture.
    For example, only a single database is present in the system and there's a limit
    on the number of queries that can run.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为当前架构存在瓶颈或限制。例如，系统中只有一个数据库，并且对可以运行的查询数量有限制。
- en: As systems grow, it may be necessary to divide parts to allow better control
    over them – for example, dividing a monolith into microservices, as we saw in
    *Chapter 8*, *Advanced Event-Driven Structures*.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着系统的发展，可能有必要将部分内容分割，以便更好地控制它们——例如，将单体分割成微服务，正如我们在第8章“高级事件驱动结构”中看到的。
- en: To increase the security of the system – for example, removing or encoding stored
    information that might be sensitive, like emails addresses and other **personally
    identifiable information** (**PII**).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提高系统的安全性——例如，删除或编码可能敏感的存储信息，如电子邮件地址和其他**个人身份信息**（**PII**）。
- en: Big API changes, like introducing a new version of an API either internally
    or externally. For example, adding a new endpoint that works better for other
    internal systems to perform some action, where the calling services should be
    migrated.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型API变更，如引入API的新版本，无论是内部还是外部。例如，添加一个新端点，它更适合其他内部系统执行某些操作，调用服务应迁移。
- en: Changes in the storage system, including all the different ideas that we discussed
    in *Chapter 3*, *Data Modeling* when talking about distributed databases. This
    could also include adding or replacing existing storage systems.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储系统的变化，包括我们在第3章“数据建模”中讨论的关于分布式数据库的所有不同想法。这也可以包括添加或替换现有的存储系统。
- en: To adapt technologies that are obsolete. This can happen in legacy systems that
    have a critical component that is no longer supported, or a fundamental security
    problem. For example, replacing an old module with another that is capable of
    using new security processes because the old one is not maintained anymore and
    relies on old encryption methods.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了适应过时的技术。这可能在具有关键组件不再受支持的遗留系统中发生，或者存在根本的安全问题。例如，用一个能够使用新安全流程的模块替换旧的模块，因为旧的不再维护，并且依赖于旧的加密方法。
- en: Rewrites using new languages or technology. This can be done to consolidate
    technologies if at some point a system was created using a different language,
    and, after a while, it is decided to bring it in line with the most used language
    to allow better maintenance. This scenario is typical in organizations that experienced
    growth, and at some point, a team decided to use their favorite language to create
    a service. After some time, this may cause problems by complicating maintenance
    as expertise in this language may be lacking. This can be even worse if the original
    developer has left the organization. It could be better to adjust or rewrite the
    service by integrating it into an existing one or replace it with an equivalent
    one in the preferred language.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新语言或技术的重写。这可以在某个系统最初是用不同的语言创建的情况下进行，过了一段时间后，决定将其与最常用的语言保持一致，以便更好地维护。这种情况在经历过增长的组织中很典型，某个时候，一个团队决定使用他们最喜欢的语言来创建一个服务。过了一段时间，这可能会因为缺乏这种语言的专长而使维护复杂化。如果原始开发者已经离开组织，情况可能会更糟。最好是调整或重写服务，将其集成到现有的服务中，或者用首选语言中的等效服务替换它。
- en: Other kinds of technical debt – for example, refactors that can clean the code
    and make it more readable, or to allow for changing names of components to be
    more precise, among other things.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他类型的债务——例如，可以清理代码并使其更易读的重构，或者为了更精确地更改组件名称等。
- en: These are just some examples, but the truth is that all systems require constant
    updating and adjusting, as software is rarely a finished task.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是些例子，但事实是，所有系统都需要不断的更新和调整，因为软件很少是完成的工作。
- en: The challenge is not only to design these changes to achieve the expected results,
    but also to move from the starting point to the destination with minimal interruption
    to the system. These days the expectation is that online systems are only very
    rarely interrupted, setting a high bar for any change.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战不仅在于设计这些更改以实现预期的结果，而且还要以最小的系统中断从起点移动到终点。如今，人们期望在线系统很少中断，这对任何更改都设定了很高的标准。
- en: To achieve this, changes need to be taken in small steps, taking extra care
    to ensure that the system is available at all points.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，需要逐步进行更改，并格外小心，确保系统在所有时刻都可用。
- en: Scheduled downtime
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计划中的停机时间
- en: While ideally there should be no interruption in the system as a result of the
    changes made, sometimes it's simply not possible to perform big changes without
    interrupting the system.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，系统在做出更改后不应出现中断，但有时在不中断系统的情况下进行重大更改是不可能的。
- en: When and whether it's sensible to have downtime may depend greatly depending
    on the system. For example, in its first years of operation, the popular website
    Stack Overflow ([https://stackoverflow.com/](https://stackoverflow.com/)) had
    frequent downtime, initially even every day, where the webpage returned a "*down
    for maintenance*" page during the morning hours in Europe. That changed eventually,
    and now it's rare to see that kind of message.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 何时以及是否有必要停机可能很大程度上取决于系统。例如，在运营的前几年，流行的网站Stack Overflow ([https://stackoverflow.com/](https://stackoverflow.com/))
    经常出现停机，最初甚至每天，在欧洲上午时段网页会显示“*维护中*”页面。这种情况最终有所改变，现在很少看到这种信息。
- en: But that was acceptable in the early stages of the project as the bulk of their
    users used the site in line with North American hours and it was (and still is)
    a free website.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但在项目的早期阶段，这是可以接受的，因为大部分用户都按照北美时间使用网站，而且它（现在仍然是）一个免费网站。
- en: Scheduling downtime is always an option, but it's a costly one, so it needs
    to be designed in a way that minimizes the impact on the operations. If the system
    is an established 24x7 service that's critical for customers, or produces income
    for the business while up (like a store, for example), any downtime will have
    a pretty hefty price tag.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 安排停机始终是一个选择，但代价高昂，因此需要以最小化对运营影响的方式进行设计。如果系统是一个对客户至关重要的24x7服务，或在运行时为业务产生收入（例如，商店），任何停机都将有一个相当大的价格标签。
- en: In other cases, like a small new service with very little traffic, customers
    will either be more understanding or there'll even be a good chance that they
    will be unaffected.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，例如一个流量非常小的新服务，客户可能会更加理解，甚至有很大可能不受影响。
- en: Scheduled downtime should be communicated beforehand to affected customers.
    This communication can take multiple forms, and will greatly depend on the kind
    of service. For example, a public web store may announce downtime with a banner
    on their page during the week informing that it won't be available on Sunday morning,
    but scheduling downtime for a banking operation may require months of advance
    notice and negotiation over when is the best time.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 应提前通知受影响的客户计划内停机。这种通知可以采取多种形式，并将很大程度上取决于服务类型。例如，一个公共网络商店可能会在星期内通过页面上的一条横幅宣布停机，告知星期日上午将不可用，但为银行操作安排停机可能需要提前数月通知和协商最佳时间。
- en: If possible, is a good practice to define maintenance windows to properly set
    clear expectations about times when the service will or might have a high risk
    of some sort of interruption.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，定义维护窗口以明确设定服务可能或将有某种中断高风险的时间是一个好习惯。
- en: Maintenance window
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维护窗口
- en: Maintenance windows are periods where it is communicated beforehand that maintenance
    might happen. The idea is to guarantee the stability of the system outside of
    maintenance windows while allocating clear times where maintenance might happen.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 维护窗口是提前通知可能进行维护的时段。其目的是在维护窗口之外保证系统的稳定性，并明确分配可能进行维护的时间。
- en: A maintenance window could perhaps be at weekends or nights in the most active
    timezone for the system. During the busiest hours of activity the service remains
    uninterrupted, and maintenance is only carried over when it can't wait, like when
    preventing or fixing a critical incident.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 维护窗口可能是在系统最活跃时区的周末或夜间。在活动最繁忙的小时内，服务保持不间断，只有在无法等待时，例如防止或修复关键事件时，才会进行维护。
- en: Maintenance windows are different than scheduled downtime. While in some cases
    it will happen, not every maintenance window needs to involve downtime – there
    is simply the possibility that it might happen.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 维护窗口不同于计划内停机。虽然在某些情况下会发生，但并非每个维护窗口都需要涉及停机——只是有可能发生。
- en: Not every maintenance window needs to be defined equally – some may be safer
    than others and capable of doing more extensive maintenance. For example, weekends
    may be reserved for scheduled downtime, but nights during the working week may
    see regular deployments.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个维护窗口都需要同等定义——有些可能比其他更安全，能够进行更广泛的维护。例如，周末可能被预留为计划内停机时间，但工作周中的夜晚可能进行常规部署。
- en: 'It''s important to communicate maintenance windows in advance, for example
    designing a table like the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 提前通知维护窗口非常重要，例如设计如下表格：
- en: '| Days | Time | Type of maintenance window | Risk | Comments |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 日期 | 时间 | 维护窗口类型 | 风险 | 备注 |'
- en: '| Monday to Thursday | 08:00 – 12:00 UTC | Regular maintenance | Low risk |
    Regular deployments considered low risk. No impact to service. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 周一到周四 | 08:00 – 12:00 UTC | 定期维护 | 低风险 | 考虑到常规部署被认为是低风险。对服务无影响。|'
- en: '| Saturday | 08:00 – 18:00 UTC | Serious maintenance | High risk | Adjustments
    considered risky. While the expectation is that the service will be fully available,
    there is a chance that it will be interrupted at some point during the window.
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 星期六 | 08:00 – 18:00 UTC | 严重维护 | 高风险 | 考虑到调整被认为是风险较高的。虽然预期服务将完全可用，但在窗口期间可能会在某些时候中断。|'
- en: '| Saturday | 08:00 – 18:00 UTC | Notified Scheduled downtime | Service unavailable
    | One month''s notice given. Essential maintenance that requires the service to
    be unavailable. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 星期六 | 08:00 – 18:00 UTC | 通知计划内停机 | 服务不可用 | 提前一个月通知。进行需要服务不可用的基本维护。|'
- en: An important detail about maintenance windows is that they should be big enough
    to allow ample time for the maintenance to be done. Be sure to be generous with
    time, as it's better to set expectations with a large maintenance window that
    can be used safely for any eventuality, rather than a short one that often needs
    to be extended.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关于维护窗口的一个重要细节是，它们应该足够大，以便有足够的时间进行维护。请确保时间充足，因为设置一个大的维护窗口，可以安全地应对任何突发情况，比设置一个短的窗口并经常需要延长要好。
- en: While scheduled downtime and maintenance windows will help frame the times where
    the service is active and what times are riskier for the user, it's still possible
    that some problem arises and causes a problem in the system.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然计划中的停机时间和维护窗口有助于界定服务活跃的时间和用户风险较高的时间，但仍然可能出现一些问题，导致系统出现问题。
- en: Incidents
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: Unfortunately, at some point in its life, the system won't behave as it should.
    It will produce an error so important that it needs to be taken care of immediately.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在系统的某个阶段，系统可能不会按预期运行。它将产生一个重要的错误，需要立即处理。
- en: An incident is defined as a problem that disrupts the service so much that it
    requires an emergency response.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 事件被定义为一种足以干扰服务并需要紧急响应的问题。
- en: This doesn't necessarily mean that the full service is totally interrupted –
    it could be a noticeable degradation of the external service, or even a problem
    in one internal service that reduces the quality of service overall. For example,
    if an asynchronous task handler is failing 50% of the time, external customers
    may only see that their tasks take longer, but that is probably important enough
    to take corrective action.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不一定意味着完整的服务完全中断——它可能是外部服务的明显退化，甚至是一个内部服务的问题，导致整体服务质量下降。例如，如果一个异步任务处理器有50%的失败率，外部客户可能只会注意到他们的任务执行时间更长，但这可能已经足够重要，需要采取纠正措施。
- en: During incidents, using all monitoring tools available is critical to find the
    problem as soon as possible and be able to correct it. Reaction times should be
    as fast as possible while keeping the risk of corrective actions as low as possible.
    A balance needs to be struck here, and depending on the nature of the incident,
    riskier actions can be taken, for example when the system is completely down,
    as recovering the system will be more important.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件发生期间，使用所有可用的监控工具至关重要，以便尽快找到问题并能够纠正它。反应时间应尽可能快，同时将纠正措施的风险降到最低。这里需要找到一个平衡点，根据事件性质的不同，可以采取更具风险性的行动，例如当系统完全宕机时，恢复系统将更为重要。
- en: 'Recovery during incidents will normally be limited by two factors:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 事件期间恢复通常会受到两个因素的制约：
- en: How good the monitoring tools are at detecting and understanding problems
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控工具在检测和理解问题方面的好坏
- en: How fast a change can be introduced in the system, related to how quick it is
    to change a parameter or to deploy new code
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中引入变更的速度，与更改参数或部署新代码的速度相关
- en: The first of the above points is the *understand* part and the second is the
    *solve* part (though it may be necessary to make changes to get a better understanding
    of the problem, as we saw in *Chapter 14*, *Profiling*).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述第一点是*理解*部分，第二点是*解决*部分（尽管可能需要做出改变以更好地理解问题，正如我们在*第14章*，*性能分析*中看到的）。
- en: We cover both of these aspects in the book, with the observability tools examined
    in *Chapter 11*, *Package Management*, and *Chapter 12*, *Logging*. We also may
    need to use the techniques described in *Chapter 14*, *Profiling*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在书中涵盖了这两个方面，其中可观测性工具在*第11章*，*包管理*和*第12章*，*日志记录*中进行了考察。我们也可能需要使用*第14章*，*性能分析*中描述的技术。
- en: Introducing changes to the system is tightly related to the **Continuous Integration**
    (**CI**) techniques that we discussed in *Chapter 4*, *The Data Layer*. A fast
    CI pipeline can make a big difference in how long it takes new code to be ready
    to deploy.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 向系统中引入变更与我们在*第4章*，*数据层*中讨论的**持续集成**（**CI**）技术紧密相关。一个快速的CI管道可以显著缩短新代码准备部署的时间。
- en: This is why these two elements, the observability and the time required to make
    a change, are so important. In normal situations, taking a long time to deploy
    or to make a change is normally just a minor annoyance, but in a critical situation,
    it could hinder the fixes that can help the health of the system to recover.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么这两个元素，可观察性和进行更改所需的时间，如此重要的原因。在正常情况下，部署或进行更改需要很长时间通常只是轻微的不便，但在关键情况下，它可能会阻碍有助于系统恢复健康的修复。
- en: The reaction to an incident is a complicated process that requires flexibility
    and improvisation, which improve with experience. But there needs to be as well
    a continuous process of improving the uptime of the system and understanding the
    weakest part of the system, to avoid the problems or minimize them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对事件的反应是一个复杂的过程，需要灵活性和即兴发挥，这些能力会随着经验而提高。但同时也需要有一个持续的过程来提高系统的正常运行时间和理解系统的最薄弱环节，以避免问题或最小化它们。
- en: Postmortem analysis
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事后分析
- en: '*Postmortem analysis*, also called a post-incident review, is an analysis done
    after a problem has impacted the service. Its objective is to understand what
    failed, why, and take corrective measures to ensure that the problem doesn''t
    happen again, or at least that it has a reduced impact.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*事后分析*，也称为事后审查，是在问题影响服务后进行的分析。其目标是了解发生了什么，为什么，并采取纠正措施以确保问题不再发生，或者至少减少其影响。'
- en: Typically, a postmortem starts with the people involved in the correction of
    the problem filling in a template form. Having a template predefined helps to
    shape the discussion and focus on the remediation to carry out.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个事后分析是从参与问题纠正的人员填写模板表单开始的。预先定义模板有助于塑造讨论并专注于要执行的补救措施。
- en: There are plenty of postmortem templates available online that you can search
    through to see if there's a particular one that you like, or just to get ideas.
    As with any other part of the process, it should be improved and refined as it
    goes along. Remember to create and tweak your own template.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在线上有许多事后分析模板可供搜索，你可以看看是否有你喜欢的特定模板，或者只是为了获取灵感。与其他流程部分一样，它应该随着过程的进行而改进和精炼。记住要创建和调整你自己的模板。
- en: 'The basic template should start with all the main details of **what** happened,
    followed by **why** it happened, and finally, the most important part: what are
    the **next actions** to correct the problem?'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 基本模板应该从发生的主要细节开始，包括**发生了什么**，然后是**为什么会发生**，最后是最重要的部分：为了纠正问题，**接下来应该采取哪些行动**？
- en: Remember that a postmortem analysis happens after the incident is over. While
    it could be good to take some notes while is happening, the focus during an incident
    is to fix it first. Focus on the most important thing first.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，事后分析是在事件结束后进行的。虽然可以在事件发生时做一些笔记，但事件发生时的重点是首先解决问题。首先关注最重要的事情。
- en: 'For example, a simple template could be the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个简单的模板可以是以下这样：
- en: Incident report
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 事件报告
- en: '**Summary**. A brief description of what happened.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**摘要**。对发生事件的简要描述。'
- en: '*Example:* The service went down between 08:30 and 9:45 UTC on the 5^(th) of
    November.'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*示例:* 服务在11月5日的08:30至09:45 UTC之间中断。'
- en: '**Impact**. Describe the impact of the problem. What was the external problem?
    How external users were affected?'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**影响**。描述问题的外部影响。外部用户受到了怎样的影响？'
- en: '*Example:* All user requests were returning 500 errors.'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*示例:* 所有用户请求都返回了500错误。'
- en: '**Detection**. A description of how it was detected initially. Could it have
    been detected earlier?'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检测**。描述最初是如何检测到的。是否可以更早地检测到？'
- en: '*Example:* The monitoring system alerted about the problem at 8:35 UTC, after
    5 minutes of 100% error requests.'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*示例:* 监控系统在8:35 UTC时发出警报，这是在100%错误请求持续了5分钟后。'
- en: '**Response**. Actions taken to correct the problem.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**响应**。为纠正问题所采取的行动。'
- en: '*Example:* John cleaned the disk space in the database server and restarted
    the database.'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*示例:* 约翰清理了数据库服务器的磁盘空间并重启了数据库。'
- en: '**Timeline**. A timeline of events to understand how the incident developed
    and how long each phase took.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**时间线**。事件的时间线，以了解事件是如何发展和每个阶段持续了多长时间。'
- en: '*Example:*'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*示例:*'
- en: 8:30 Start of the problem.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 8:30 问题开始。
- en: 8:35 An alert in the monitoring system was triggered. John started looking into
    the problem.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 8:35 监控系统触发了一个警报。约翰开始调查这个问题。
- en: 8:37 It is detected that the database is unresponsive and cannot be restarted.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 8:37 发现数据库无响应且无法重启。
- en: 9:05 After investigation, John discovered that the database disk was full.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 9:05 经过调查，约翰发现数据库磁盘已满。
- en: 9:30 The logs in the database server had filled up the server disk space, causing
    the database server to crash.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 9:30 数据库服务器中的日志已填满服务器磁盘空间，导致数据库服务器崩溃。
- en: 9:40 Old logs are removed from the server, freeing disk space. The database
    is restarted.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 9:40 从服务器中移除旧日志，释放磁盘空间。数据库重启。
- en: 9:45 Service is restored.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 9:45 服务恢复正常。
- en: '**Root cause**. A description of the identified root cause of the problem that,
    if fixed, will completely remove this problem.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**根本原因**。对已识别的根本原因的描述，如果修复，将完全消除这个问题。'
- en: Detecting the root cause is not necessarily easy, as sometimes a chain of events
    will be involved. To help find the root cause, you can use the *five whys* technique.
    Start describing the impact and ask why it happened. Then ask why this happened,
    and so on. Keep iterating until you have asked "why?" five times, and the resulting
    one will be the root cause. Don't take this to mean that you *must* ask "why?"
    exactly five times, but keep going until you can get a solid answer.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检测根本原因并不一定容易，因为有时会涉及一系列事件。为了帮助找到根本原因，可以使用“五问法”。开始描述影响并询问为什么会发生。然后问为什么会这样，依此类推。继续迭代，直到问“为什么？”五次，最终的结果将是根本原因。不要理解为“必须”问“为什么？”正好五次，但要继续进行，直到得到一个明确的答案。
- en: Take into account that the investigation can go further than the steps taken
    to recover the service during the incident, where a quick fix may have been enough
    to get out of the woods.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑到调查可能超出在事件期间恢复服务所采取的步骤，快速修复可能已经足够摆脱困境。
- en: '*Example:*'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*示例*：'
- en: The server returned errors. *Why?*
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 服务器返回错误。*为什么*？
- en: '*Because* the database had crashed. *Why?*'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*因为*数据库崩溃了。*为什么*？'
- en: '*Because* the database server ran out of space. *Why?*'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*因为*数据库服务器空间不足。*为什么*？'
- en: '*Because* the space was fully filled with logs. *Why?*'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*因为*空间已经被木材完全填满。*为什么*？'
- en: '*Because* the log space on the disk was not limited and could grow indefinitely.'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*因为*磁盘上的日志空间没有限制，可以无限增长。'
- en: '**Lessons learned**. Things that could be improved in the process, as well
    as any other element that went well and could be useful to know, like the usage
    of a certain tool or metric that was useful when analyzing the problem.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**经验教训**。在过程中可以改进的事情，以及任何其他做得好的元素，比如在分析问题时使用某些有用的工具或指标。'
- en: '*Example*:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*示例*：'
- en: The amount of disk space that logs use should be limited in all cases.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在所有情况下，都应该限制日志使用的磁盘空间量。
- en: The disk space itself is not being monitored or alerted before it completely
    runs out.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在磁盘空间完全耗尽之前，并没有监控或发出警报。
- en: The alerting system is too slow and requires a high level of errors before alerting.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 警报系统太慢，需要达到较高错误率才会发出警报。
- en: '**Next actions**.The most important part of the process. Describe what actions
    should be performed to eliminate or, if that''s not possible, mitigate the problem.
    Be sure that these actions have clear owners and are followed up.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**下一步行动**。过程最重要的部分。描述应该执行哪些操作来消除问题，如果不可能消除，则减轻问题。确保这些操作有明确的负责人，并得到跟进。'
- en: If there's a ticketing system, these actions should be transformed into tickets
    and be prioritized accordingly to be sure that the proper team implements them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有票务系统，这些操作应转换为票务，并相应地优先处理，以确保适当的团队实施它们。
- en: Not only should the root cause be addressed, but also any possible improvements
    detected in the lessons learned part.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅应该解决根本原因，还应该解决在经验教训部分中发现的任何可能的改进。
- en: '*Example*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例*：'
- en: 'Action: Enable log rotation to limit the amount of space that logs can take
    up in all servers, starting with the database. Assigned to the operations team.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 操作：启用日志轮转，限制所有服务器中日志所占用的空间，从数据库开始。分配给运维团队。
- en: 'Action: Monitor and alert on the disk space to raise an alert if the disk space
    has less than 20% of the total available space, to allow faster reactions. Assigned
    to the operations team.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 操作：监控磁盘空间并发出警报，如果磁盘空间小于总可用空间的20%，以便更快地做出反应。分配给运维团队。
- en: 'Action: Tweak the error alert to change it to alert when there''s only one
    minute of 30% or more requests returning errors. Assigned to the operations team.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 操作：调整错误警报，将其改为当30%或更多请求返回错误时只有一分钟时发出警报。分配给运维团队。
- en: Note that the template doesn't have to be filled out in one go. Typically, the
    template will be filled in as much as possible, and a postmortem meeting will
    be held, when the incident can be analyzed and the template totally filled in,
    including the *Next action* part, which, again, is the most important part of
    the analysis.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，模板不必一次性填写完成。通常，模板会尽可能填写，然后举行一次事后会议，届时可以对事件进行分析，并完全填写模板，包括*下一步行动*部分，这又是分析中最重要的部分。
- en: Keep in mind that it's crucial that postmortem processes are focused on improving
    the system and not on assigning blame for the problem. The objective of the process
    is to detect weak spots and to try to make sure that problems are not repeated.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，事后流程的重点是改进系统，而不是对问题进行归责。流程的目标是发现弱点，并尽量确保问题不会重复。
- en: In recent years, an equivalent process to try to foresee problems has been put
    in place, especially before an important event.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在近年来的重要事件之前，已经实施了一个等效的过程来尝试预见问题。
- en: Premortem analysis
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预死亡分析
- en: The *premortem analysis* is an exercise to try to analyze what could go wrong
    before an important event. The event could be some milestone, launch event, or
    something similar that is expected to significantly change the conditions of the
    system.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*预死亡分析*是一种尝试在重要事件之前分析可能出错的事情的练习。事件可能是某个里程碑、发布活动或类似的事情，预计将显著改变系统的条件。'
- en: The word "*premortem*" is quite a funny neologism that comes from the usage
    of "*postmortem*" as a way to refer to an analysis done after the fact, making
    an analogy with an autopsy. Though hopefully, nothing is dead yet!.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: “*预死亡分析*”这个词是一个相当有趣的术语，它来自“*事后分析*”的使用，作为一种指代事后进行的分析的方式，与尸检进行类比。尽管希望没有什么已经死亡！。
- en: It can also be called a *preparation analysis*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以被称为*准备分析*。
- en: For example, there could be a marketing campaign launch that is expected to
    double or triple the amount of traffic that had previously been normal.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可能会有一个营销活动启动，预计将使流量增加到之前的两倍或三倍。
- en: 'The premortem analysis is the reverse of a postmortem. You set your mindset
    in the future and ask: *What went wrong?* *What is the worst-case scenario?* From
    there, you verify your assumptions about your system and prepare for them.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 预死亡分析是事后分析的相反。你将你的心态设定在将来，并问：*出了什么问题？* *最坏的情况是什么？* 从那里，你验证你对系统的假设，并为它们做好准备。
- en: Consider an analysis for the above example of tripling the amount of traffic
    on the system. Can we simulate the conditions to verify that our system is ready
    for it? Which elements of the system do we think are less robust?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑对上述示例中系统流量增加三倍的分析。我们能否模拟条件以验证我们的系统是否已准备好应对？我们认为系统的哪些部分比较脆弱？
- en: All that can lead to planning for the different scenarios and running tests
    to ensure that the system will be ready for the event.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以导致对不同场景的规划，并运行测试以确保系统为事件做好准备。
- en: When doing any premortem analysis, be sure to have enough time to perform the
    necessary actions and tests to prepare the system. As usual, actions will have
    to be prioritised to be sure that time is well spent. But keep in mind that this
    preparation can be an endless task, and as time will be limited, it needs to be
    focused on the most important or sensitive parts of the system. Be sure to use
    as many data-driven actions as possible and focus the analysis on real data and
    not hunches.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何预死亡分析时，请确保有足够的时间执行必要的行动和测试来准备系统。像往常一样，行动将需要优先排序，以确保时间得到充分利用。但请记住，这种准备可能是一个无休止的任务，而且时间有限，因此需要集中在系统最重要的或最敏感的部分。确保尽可能多地使用数据驱动的行动，并将分析集中在真实数据而不是直觉上。
- en: Load testing
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压力测试
- en: A key element of preparation in these cases is *load testing*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，准备的关键要素是*压力测试*。
- en: Load testing is creating a simulated load that goes to an increased level of
    traffic. It can be done in an explorative way, i.e., let's find out what the limits
    of our system are; or in a confirmative way, i.e., let's double-check that we
    can reach this level of traffic.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 压力测试是指创建一个模拟增加流量的负载。它可以以探索性的方式进行，即让我们找出我们系统的极限；或者以确认性的方式进行，即让我们再次确认我们能否达到这个流量水平。
- en: Load testing is typically done not in production environments, but in staging
    ones, replicating the configuration and hardware in production, though it is normal
    to create a final load test verifying that the configuration in the production
    environment is the correct one.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试通常不在生产环境中进行，而是在预生产环境中进行，复制生产中的配置和硬件，尽管通常需要创建一个最终的负载测试来验证生产环境中的配置是正确的。
- en: An interesting part of load testing analysis in cloud environments is to ensure
    that any autoscaling in the system works correctly, so it provisions more hardware
    automatically when receiving greater load, and deletes it when it's not necessary.
    Caution is required here, as a full load test to the maximum capacity of the cluster
    can be expensive each time it's run.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中进行负载测试分析的一个有趣的部分是确保系统中的任何自动扩展都能正确工作，以便在接收更大负载时自动提供更多硬件，并在不需要时删除它。这里需要谨慎，因为每次运行到集群最大容量时的完全负载测试可能都很昂贵。
- en: The basic element of a load test is to simulate a typical user performing actions
    on the system. For example, a typical user can log in, check a few pages, add
    some information, and then log out. We can replicate this behavior using automated
    tools that work on our external interface.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试的基本元素是模拟典型用户在系统上执行操作。例如，一个典型用户可以登录，查看几个页面，添加一些信息，然后登出。我们可以使用工作在我们外部界面的自动化工具来复制这种行为。
- en: A good way of using these tools is reusing any kind of automated testing that
    can be created, and using it as well as the basis for the simulation. This makes
    the integration or system test framework the unit to enable load testing.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些工具的一个好方法是重用任何可以创建的自动化测试，并将其作为模拟的基础。这使得集成或系统测试框架成为启用负载测试的单位。
- en: Then, we can multiply that unit simulating the behavior for a single user multiple
    times to simulate the effect of `N` users, producing enough load to test our system.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将模拟单个用户行为的单元多次乘以，以模拟`N`个用户的效果，产生足够的负载来测试我们的系统。
- en: For simplicity, it's better to use a single simulation that works as a combination
    of typical behaviors of users instead of trying to generate multiple smaller simulations
    trying to replicate different users.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，最好使用一个单一的模拟，它作为用户典型行为的组合来工作，而不是尝试生成多个更小的模拟来复制不同的用户。
- en: As we said before, the usage of some system test that exercises the main parts
    of the system works very well in these cases, once you double-check that the behavior
    is compatible with the typical case in the system.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，在这些情况下，使用一些系统测试来锻炼系统的主体部分效果非常好，一旦你确认行为与系统中的典型情况兼容。
- en: If necessary, or to perform tweaks, logs can be analyzed to generate an adequate
    profile of the typical interfaces exercised by the users. Remember to relay in
    data when possible. Load tests, though, are sometimes needed when there is no
    solid data, as they are done typically when new features are introduced, so estimations
    have to be used.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有必要，或者要进行微调，可以通过分析日志来生成用户执行的典型接口的适当配置文件。记住，在可能的情况下要依赖数据。然而，当没有可靠数据时，有时需要进行负载测试，因为它们通常在新功能引入时进行，所以必须使用估计值。
- en: Remember to monitor the results of each simulation, and errors in particular.
    This will help detect possible problems. Load tests also exercise the monitoring
    of the system, so it's a good exercise in detecting weak points and improving
    on them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 记得监控每个模拟的结果，特别是错误。这将有助于检测可能的问题。负载测试也锻炼了系统的监控，因此它是检测弱点并改进它们的好练习。
- en: The more intensive load tests are, the more problems they'll be able to capture.
    Then we can avoid those problems once real traffic is in play.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试越密集，它们能捕获的问题就越多。然后我们可以在实际流量中避免这些问题。
- en: Keep in mind that creating the load can also suffer from its own bottlenecks.
    To multiply the simulations, it may be necessary to use multiple servers and ensure
    that the network is capable of supporting the traffic.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，创建负载也可能有自己的瓶颈。为了乘以模拟，可能需要使用多个服务器，并确保网络能够支持流量。
- en: Multiplying the simulation can be done directly by starting the process multiple
    times. This procedure, though simple, is quite effective and can be controlled
    with simple scripts. It also has the flexibility that the simulation can be any
    kind of process, including readjusted system tests using any existing software.
    This speeds up the preparation of the load test and builds trust that the simulation
    is accurate, as it reuses existing software that has been tested previously.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过多次启动进程，可以直接对模拟进行乘法。虽然这个程序很简单，但非常有效，可以用简单的脚本来控制。它还具有灵活性，模拟可以是任何类型的进程，包括使用任何现有软件进行的调整后的系统测试。这加快了负载测试的准备，并建立了对模拟准确性的信任，因为它重用了之前已经测试过的现有软件。
- en: It is also possible to use specific tools aimed at common use cases like HTTP
    interfaces, for example, Locust ([https://locust.io/](https://locust.io/)). This
    tool allows us to create a web session, simulating a user accessing the system.
    The great advantages of Locust are that it already has a reporting system embedded
    and can be scaled with minimal preparation. However, it requires the creation
    of a new session explicitly for the load test and is only capable of working with
    web interfaces.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用针对常见用例（如HTTP接口）的特定工具，例如Locust ([https://locust.io/](https://locust.io/))。这个工具允许我们创建一个网络会话，模拟用户访问系统。Locust的巨大优势在于它已经内置了报告系统，并且可以以最小的准备进行扩展。然而，它需要显式创建一个新的会话来进行负载测试，并且只能与Web接口一起工作。
- en: Load tests should also be aimed at creating some headroom in the production
    cluster so they verify that the load is always under control, even in cases when
    it's growing, instead of finding bottlenecks during regular operations, which
    may produce incidents.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试也应旨在在生产集群中创建一些余量，以便验证负载始终处于控制之下，即使在增长的情况下也是如此，而不是在常规操作中寻找瓶颈，这可能会导致事件发生。
- en: Versioning
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制
- en: When making changes to any service, a system needs to be in place to track the
    different changes. That way, we can understand what gets deployed when and what
    has changed from last week.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当对任何服务进行更改时，需要建立一个系统来跟踪不同的更改。这样，我们就可以了解何时部署了什么，以及与上周相比有什么变化。
- en: This information is really powerful when you're facing an incident. One of the
    riskiest moments in a system is when there's a new deployment, as new code can
    create new problems. It's not unusual that an incident is produced due to the
    release of a new version.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你面临事件时，这些信息非常有用。在系统中，最危险的时刻之一就是有新的部署，因为新代码可能会产生新的问题。由于新版本的发布而产生事件并不罕见。
- en: '*Versioning* means assigning a unique code version to each service or system.
    It makes it easy to understand what software has been deployed and track down
    what has been changed from one version to another.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*版本控制*意味着为每个服务或系统分配一个唯一的代码版本。这使得理解已部署的软件以及追踪从一个版本到另一个版本的变化变得容易。'
- en: Version numbers are normally assigned in the source control system at specific
    points to precisely track the code at that particular point. The point of having
    a defined version is to have a precise definition of the code under that unique
    version number. A version number that is applicable to multiple iterations of
    the code is useless.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 版本号通常在源代码控制系统中在特定点分配，以精确跟踪该特定点的代码。拥有定义明确的版本的目的，是为了对具有唯一版本号的代码有一个精确的定义。适用于代码多个迭代的版本号是无用的。
- en: Version numbers are about communicating the differences in code when talking
    about different snapshots of the same project. Their main objective is to communicate
    and allow us to understand how software evolves, not only within the team, but
    externally as well.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 版本号是在讨论同一项目的不同快照时，关于代码差异的沟通。它们的主要目的是沟通并允许我们了解软件如何演变，不仅是在团队内部，而且在外部也是如此。
- en: Traditionally, versions were highly related to packaged software and different
    versions of the software that were sold in boxes, making them marketing versions.
    When the internal version was required, a *build number* was used, which was a
    consecutive number based on the number of times the software had been compiled.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，版本与打包软件高度相关，并且销售在盒子中的软件的不同版本是营销版本。当需要内部版本时，使用了一个*构建号*，这是一个基于软件编译次数的连续数字。
- en: Versions can not only be applied to whole software, but also to elements of
    it, as API version, library versions, etc. In the same way, different versions
    can be used effectively for the same software, such as for creating an internal
    version for the technical team but an external version for marketing purposes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 版本不仅可以应用于整个软件，还可以应用于其元素，如API版本、库版本等。同样，可以为同一软件使用不同的版本，例如为技术团队创建内部版本，为营销目的创建外部版本。
- en: For example, some software could be sold as Awesome Software `v4`, have an API
    `v2`, and internally be described as build number `v4.356`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，某些软件可能以“Awesome Software `v4`”出售，API为`v2`，而内部描述为构建号`v4.356`。
- en: In modern software, where the releases are frequent and the version needs to
    change often, this simple method is not adequate, and instead different version
    schemas are created. The most common is *semantic versioning*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代软件中，由于发布频繁且版本需要经常更改，这种方法是不够的，因此创建了不同的版本模式。最常见的是*语义版本控制*。
- en: We talked about semantic versioning in *Chapter 2*,*API Design*, but the topic
    is important enough to be repeated. Note that the same concept can be used both
    for APIs and code releases.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第二章*，*API设计*中讨论了语义版本控制，但这个话题很重要，值得重复。请注意，这个概念可以同时用于API和代码发布。
- en: 'Semantic versioning uses two or three numbers, separated by dots. An optional
    `v` prefix can be added to clarify that it refers to a version:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本控制使用两个或三个由点分隔的数字。可以添加可选的`v`前缀来明确它指的是版本：
- en: '[PRE0]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first number (`X`) is called the major version. The second (`Y`) is the
    minor version, and the last number (`Z`) is the patch version. These numbers are
    increased as new versions are generated:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数字（`X`）被称为主版本。第二个（`Y`）是次要版本，最后一个数字（`Z`）是补丁版本。这些数字在新版本生成时增加：
- en: An increase in the major version indicates that the software is not compatible
    with previously existing software.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主版本的增加表示该软件与先前存在的软件不兼容。
- en: An increase in the minor version means that this version contains new features,
    but they don't break compatibility with older versions.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 次要版本的增加意味着这个版本包含新功能，但它们不会破坏与旧版本的兼容性。
- en: Finally, an increase of the patch version only covers bugfixes and other improvements
    like security patches. It fixes problems, but doesn't change the compatibility
    of the system.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，补丁版本的增加仅涵盖错误修复和其他改进，如安全补丁。它修复了问题，但不会改变系统的兼容性。
- en: Keep in mind that increasing a major version number can also mark changes that
    would ordinarily appear in minor version updates, too. A change in the major version
    number will likely bring new features as well as major overhauls.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，增加主版本号也可能标记出通常出现在次要版本更新中的变化。主版本号的变化可能会带来新功能和重大改进。
- en: 'A good example of this kind of versioning is the Python interpreter itself:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种版本控制的一个很好的例子是Python解释器本身：
- en: Python 3 was an increase in the major version, and as such, code from Python
    2 required changes to be run under Python 3
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3是主版本的增加，因此，Python 2的代码需要在Python 3下进行更改才能运行
- en: Python 3.9 introduced new features compared with Python 3.8, for example, the
    new union operators for dictionaries
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.9与Python 3.8相比引入了新功能，例如，字典的新联合操作符
- en: Python 3.9.7 adds bugfixes and improvements over the previous patch version
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.9.7在之前的补丁版本上增加了错误修复和改进
- en: Semantic versioning is very popular and it's particularly useful when dealing
    with APIs and with libraries that are going to be used externally. It provides
    a clear expectation, from just the version number, on what to expect from a new
    change, and allows clarity at the time of adding new features.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本控制非常流行，尤其是在处理API和将要外部使用的库时特别有用。它仅从版本号就能清楚地预期到新变化的内容，并在添加新功能时提供清晰性。
- en: This kind of versioning, though, may be too restrictive for certain projects,
    and in particular, for internal interfaces. As it operates with small iterations
    that maintain compatibility along the way, only deprecating features after they
    are old, it works more like a window that is always evolving. Therefore, it's
    difficult to introduce a meaningful specific version.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这种版本控制方法，尽管如此，可能对某些项目来说过于限制性，尤其是对于内部接口。因为它通过小迭代来保持兼容性，只在它们过时后才废弃功能，所以它更像是一个始终在演变的窗口。因此，引入一个有意义的特定版本是困难的。
- en: 'For example, the Linux kernel decided to move away from semantic versioning
    for this reason, deciding that instead new major versions will be small and not
    change things, and won''t carry any particular meaning: [http://lkml.iu.edu/hypermail/linux/kernel/1804.1/06654.html](http://lkml.iu.edu/hypermail/linux/kernel/1804.1/06654.html).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Linux内核决定由于这个原因放弃使用语义版本控制，决定新的大版本将很小，不会改变事物，并且不会携带任何特定的意义：[http://lkml.iu.edu/hypermail/linux/kernel/1804.1/06654.html](http://lkml.iu.edu/hypermail/linux/kernel/1804.1/06654.html)。
- en: When working with internal APIs, especially with microservices or internal libraries
    that change very often and are consumed by other parts of the organization, it
    is better to relax the rules and, while using something similar to semantic versioning,
    just using it as a general tool to increase version numbers in a consistent manner
    to provide an understanding of how the code changes, but without necessarily having
    to force changes in major or minor versions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当与内部API一起工作时，尤其是与经常更改且被组织其他部分使用的微服务或内部库一起工作时，放宽规则会更好，同时使用类似于语义版本控制的方法，只是将其用作一种通用工具，以一致的方式增加版本号，以提供对代码更改的理解，但不必强制在主版本或次版本中做出更改。
- en: When communicating through external APIs, though, version numbers do not only
    carry a technical meaning, but also a marketing one. Using semantic versioning
    gives a strong assurance of the capacities of the API.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当通过外部API进行通信时，版本号不仅具有技术意义，还具有营销意义。使用语义版本控制可以提供对API能力的强烈保证。
- en: As versioning is so important, a good idea is to allow services to self-report
    their version number via a specific endpoint like `/api/version` or another easily
    accessed way to be sure that it's clear and can be checked by other dependant
    services.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于版本控制非常重要，一个好的想法是允许服务通过特定的端点如`/api/version`或另一种易于访问的方式自行报告其版本号，以确保它清晰且可以被其他依赖服务检查。
- en: Keep in mind that it can be possible to create a general version of a whole
    system, even if internally its different components have their own independent
    versions. In cases like online services, though, that can be tricky or pointless.
    Instead, the focus should be on maintaining backward compatibility.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，即使系统的不同组件具有自己的独立版本，也可以创建整个系统的一般版本。然而，在在线服务的情况下，这可能很棘手或毫无意义。相反，重点应放在保持向后兼容性上。
- en: Backward compatibility
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向后兼容性
- en: The key aspect of changing architecture in a running system is the necessity
    of always keeping backward compatibility in its interfaces and APIs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行系统中更改架构的关键方面是始终在其接口和API中保持向后兼容性的必要性。
- en: We also talked about backward compatibility in regard to databases changes in
    *Chapter 3*, *Data Modeling*. Here we will talk about interfaces, but it follows
    the same ideas.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在*第3章*，*数据建模*中讨论了关于数据库更改的向后兼容性。在这里，我们将讨论接口，但遵循相同的思想。
- en: Backward compatibility means that systems keep their old interfaces working
    as expected, so any calling system won't be affected by the change. This allows
    them to be upgraded at any point, without interrupting the service.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 向后兼容性意味着系统保持其旧接口按预期工作，因此任何调用系统都不会受到更改的影响。这允许它们在任何时候升级，而不会中断服务。
- en: Keep in mind that backward compatibility needs to apply externally, as customers
    rely on a stable working interface, but also internally where multiple services
    interact with each other. If the system is complex and has multiple parts, the
    APIs connecting them should be backward compatible. This is particularly important
    in microservices architectures to allow the independent deployment of microservices.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，向后兼容性需要在外部应用，因为客户依赖于稳定的接口，但同时也需要在内部应用，因为多个服务相互交互。如果系统复杂且具有多个部分，连接它们的API应该是向后兼容的。这在微服务架构中尤为重要，以允许独立部署微服务。
- en: 'This concept is quite simple, but it has implications on how changes need to
    be designed and implemented:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念相当简单，但它对如何设计和实施更改有影响：
- en: Changes should always *be additive*. That means that they *add* options, and
    don't remove them. This makes any existing calls to the system keep using the
    existing features and options and doesn't disrupt them.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更应始终*是累加的*。这意味着它们*添加*选项，而不是删除它们。这使得任何现有的系统调用都能继续使用现有的功能和选项，而不会破坏它们。
- en: Removing options should be done with extreme care, and only after verifying
    that they are not used anymore. To be able to detect that, we need to adjust the
    monitoring so we have real data that can clearly provide solid data to allow us
    to determine this.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除选项应极其谨慎，并且只有在确认它们不再被使用后才能进行。为了能够检测到这一点，我们需要调整监控，以便我们有真实的数据，可以清楚地提供可靠的数据，使我们能够确定这一点。
- en: With external interfaces, it may be almost impossible to remove any option or
    endpoint, especially on APIs. Customers don't want to change their existing systems
    to adjust to any changes unless there's a good reason, and even in that case it
    will take a lot of work to adequately communicate it. We will talk later in this
    chapter about this situation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于外部接口，可能几乎不可能移除任何选项或端点，尤其是在API上。除非有充分的理由，否则客户不想改变现有的系统以适应任何变化，即使在这种情况下，也需要大量的工作来充分沟通。我们将在本章后面讨论这种情况。
- en: Web interfaces allow greater flexibility for changes as they are used manually
    by humans.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 网络界面允许更大的灵活性，因为它们是由人类手动使用的。
- en: Even additive changes in externally accessible APIs are difficult. External
    customers tend to remember the API as it is, so it can be difficult to change
    the format of existing calls, even if it's just adding a new field.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使是在外部可访问的API中进行增量更改也很困难。外部客户倾向于记住API的当前状态，因此更改现有调用的格式可能很困难，即使只是添加一个新字段。
- en: This depends on the format used. Adding a new field in a JSON object is safer
    than changing a SOAP definition, which needs to be defined beforehand. This is
    one of the reasons why JSON is so popular – because it's flexible in the definition
    of the objects returned.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这取决于使用的格式。在JSON对象中添加一个新字段比更改需要事先定义的SOAP定义更安全。这也是JSON如此受欢迎的原因之一——因为它在定义返回的对象方面具有灵活性。
- en: Nonetheless, for external APIs it could be safer to add new endpoints if necessary.
    API changes are normally done in stages, creating a new version of the API and
    trying to encourage customers to change to the new and better API. These migrations
    can be long and arduous, as external users will require clear advantages to be
    persuaded to adopt the change on their end.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管如此，对于外部API，如果必要，添加新的端点可能更安全。API更改通常分阶段进行，创建API的新版本，并试图鼓励客户切换到新的更好的API。这些迁移可能非常漫长和艰巨，因为外部用户将需要明显的优势才能说服他们在自己的端进行改变。
- en: A good example of how painful a change in APIs can be is the migration from
    Python 2 to Python 3\. Python 3 has been available since 2008, but took a long
    time to get any kind of traction, because programs written in Python 2 needed
    to be changed. The migration has been quite lengthy, even to the point that the
    last Python 2 interpreter (Python 2.7) was supported for ten years, from its first
    release in 2010 until 2020\. Even with that long process, there's still code in
    legacy systems working with Python 2\. This shows the difficulty of moving from
    one API to another if no backward compatibility is respected.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是API变化可能有多么痛苦，就是从Python 2迁移到Python 3。Python 3自2008年以来就已经可用，但需要很长时间才能获得任何形式的吸引力，因为用Python
    2编写的程序需要被更改。迁移过程相当漫长，甚至到了最后Python 2解释器（Python 2.7）从2010年的首次发布一直支持到2020年。即使有这样一个漫长的过程，遗留系统中仍然有使用Python
    2的代码。这表明，如果不尊重向后兼容性，从一个API迁移到另一个API是非常困难的。
- en: Existing tests, both unit and integration tests, are the best way to ensure
    that the API is backward compatible. In essence, any new feature should pass the
    tests without a problem, as the old behavior won't change. Good test coverage
    of the API functionality is the best way to maintain compatibility.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的测试，无论是单元测试还是集成测试，都是确保API向后兼容的最佳方式。本质上，任何新功能都应该没有问题地通过测试，因为旧的行为不会改变。对API功能的良好测试覆盖是维护兼容性的最佳方式。
- en: Introducing changes in external interfaces is more complicated and normally
    requires the definition of stricter APIs and a slower pace of change. Internal
    interfaces allow greater flexibility, as their changes can be communicated across
    the organization in an incremental way that will allow adaptation without interrupting
    the service at any point.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部接口中引入变化更为复杂，通常需要定义更严格的API和更慢的变化速度。内部接口允许更大的灵活性，因为它们的变化可以通过增量方式在组织内部进行沟通，从而允许在不中断服务的情况下进行适应。
- en: Incremental changes
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增量变化
- en: Incremental changes to the system, slowing mutating and adjusting the APIs,
    can be released in sequence with multiple services involved. But the changes need
    to be applied in sequence and keep backward compatibility in mind.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对系统的增量更改，缓慢地变异和调整API，可以按顺序与多个服务一起发布。但更改需要按顺序应用，并考虑向后兼容性。
- en: 'For example, let''s say that we have two services: service A generates an interface
    displaying students taking exams, and calls service B to obtain the list of examinees.
    This is done by calling an internal endpoint:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有两个服务：服务A生成一个显示参加考试的学生界面的接口，并调用服务B来获取考生的名单。这是通过调用一个内部端点来完成的：
- en: '[PRE1]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There's a new feature that needs to be introduced in service A that requires
    extra information from the examinees, and requires us to know the number of times
    that each examinee has attempted a particular exam to sort them adequately by
    that parameter. With the current information, that's impossible, but service B
    can be tweaked to return that information.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 服务A需要引入一个新功能，该功能需要从考生那里获取额外信息，并需要我们知道每个考生尝试特定考试的次数，以便根据该参数对他们进行适当的排序。使用当前信息，这是不可能的，但服务B可以被调整以返回该信息。
- en: 'To do so, the API needs to be *extended*, so it returns that information:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，API需要被扩展，以便返回该信息：
- en: '[PRE2]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Only after this change is properly done and deployed can service A use it.
    This process happens in the following stages:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在这次更改得到正确实施并部署后，服务A才能使用它。这个过程发生在以下阶段：
- en: Initial stage.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始阶段。
- en: Deployment of service B with `/examinees (v2)`. Note how service A will just
    ignore the extra field and keep working normally.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`/examinees (v2)`部署服务B。注意服务A将忽略额外的字段并正常工作。
- en: Deployment of service A reading and using the new parameter `exam_tries`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署读取和使用新参数`exam_tries`的服务A。
- en: All of the steps are stable. The service works without a problem throughout
    each one, so there's detachment between the different services.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 所有步骤都是稳定的。在整个过程中，服务没有问题，因此不同服务之间存在分离。
- en: This detachment is important because if there's a problem with a deployment,
    it can be reversed and only affects a single service, quickly reverting to the
    previous stable situation until the issue can be fixed. The worst situation is
    to have two changes in services that need to happen at the same time, as a failure
    in one will affect the other and reversing the situation may not be easy. Even
    worse, the problem could be in the interaction between them, and in that situation
    it won't be clear which one is responsible, because it could be both. It is important
    to keep to small individual steps where each step is solid and reliable.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分离很重要，因为如果部署出现问题，它可以被撤销，并且只影响单个服务，可以快速恢复到之前稳定的状态，直到问题得到解决。最糟糕的情况是同时需要发生两个服务变更，因为一个服务的失败将影响另一个服务，并且撤销情况可能并不容易。更糟糕的是，问题可能存在于它们之间的交互中，在这种情况下，不清楚哪个是责任人，因为可能是两者都有可能。保持小而独立的步骤非常重要，每个步骤都应该是稳固和可靠的。
- en: 'This way of operating allows us to implement greater changes, for example,
    renaming a field. Let''s say that we don''t like the `examinee_id` field and want
    to change it for a more appropriate `student_id`. The process will go like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作方式使我们能够实施更大的更改，例如，重命名字段。假设我们不喜欢`examinee_id`字段，并希望将其更改为更合适的`student_id`。过程将如下所示：
- en: 'Update the returned object to include a new field called `student_id`, replicating
    the previous value in service B:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新返回的对象，包括一个名为`student_id`的新字段，复制服务B中的先前值：
- en: '[PRE3]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Update and deploy service A to use `student_id` instead of `examinee_id`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新并部署服务A以使用`student_id`而不是`examinee_id`。
- en: Do the same in other services that possibly call service B.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在可能调用服务B的其他服务中也进行相同的操作。
- en: Use monitoring tools and logs to verify this!
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用监控工具和日志来验证这一点！
- en: 'Remove the old field from service B and deploy the service:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从服务B中删除旧字段并部署服务：
- en: '[PRE4]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Remove the old field from service B and deploy the service.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从服务B中删除旧字段并部署服务。
- en: This step is technically optional, though it would be good for maintenance reasons
    to remove cruft from the API. But the reality of the day-to-day work means that
    it's likely that it will stay there, just not being accessed anymore. A good balance
    needs to be found between the convenience of leaving it be and maintaining a clean
    and updated API.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步在技术上不是必需的，尽管出于维护原因删除API中的冗余内容会更好。但现实中的日常工作意味着它可能仍然存在，只是不再被访问。需要在保持现状的便利性和维护一个干净、更新的API之间找到良好的平衡。
- en: This illustrates how we can deploy changes without interrupting the service
    in terms of *what* is being deployed. But, how can we ensure that the services
    are always available while deploying a new version?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了我们如何在不停机的情况下部署更改，从部署的*内容*方面来说。但是，我们如何确保在部署新版本时服务始终可用？
- en: Deploying without interruption
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无中断部署
- en: To allow continuous releases without service interruption, we need to take the
    backward-compatible changes and deploy them while the service is still responding.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许在不停机的情况下进行持续发布，我们需要在服务仍然响应时部署向后兼容的更改。
- en: To do so, the best ally is the load balancer.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，最佳盟友是负载均衡器。
- en: We talked about load balancers in *Chapter 5*, *The Twelve-Factor App Methodology*,
    and *Chapter 8*, *Advanced Event-Driven Structures*. They are really useful!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第5章*、*十二要素应用方法学*和*第8章*、*高级事件驱动结构*中讨论了负载均衡器。它们非常有用！
- en: 'The process of a successful smooth deployment requires several instances of
    the service to be updated, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 成功平稳部署的过程需要更新服务的多个实例，如下所示：
- en: We are going to assume that we are using cloud instances or containers that
    can be created and destroyed easily. Keep in mind that you can treat them as workers
    under nginx or any other kind of web server acting as a load balancer inside a
    single server. This is how the `nginx reload` command works.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设我们使用的是可以轻松创建和销毁的云实例或容器。请记住，可以将它们视为在单个服务器内部充当负载均衡器的nginx或其他类型的网络服务器下的工作者。这就是`nginx
    reload`命令的工作方式。
- en: This is the initial stage, where all the instances have version 1 of the service
    to be updated:![Diagram
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是初始阶段，所有实例都使用要更新的服务的版本1：![图
- en: Description automatically generated](img/B17580_16_01.png)
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_16_01.png)
- en: 'Figure 16.1: Starting point'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图16.1：起点
- en: A new instance with service 2 is created. Note that it's not yet been added
    to the load balancer.![Diagram
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个带有服务2的新实例。请注意，它尚未添加到负载均衡器中。![图
- en: Description automatically generated](img/B17580_16_02.png)
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_16_02.png)
- en: 'Figure 16.2: New server created'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图16.2：创建的新服务器
- en: The new version is added to the load balancer. Right now, the requests can be
    directed to version 1 or version 2\. If we followed the principles of backward
    compatibility, though, this should not cause any problems.![Diagram
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新版本已添加到负载均衡器中。目前，请求可以指向版本1或版本2。如果我们遵循向后兼容的原则，则这不应该引起任何问题。![图
- en: Description automatically generated](img/B17580_16_03.png)
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_16_03.png)
- en: 'Figure 16.3: New server included in the load balancer'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图16.3：包含在负载均衡器中的新服务器
- en: To keep the number of instances constant, an old instance needs to be removed.
    A careful approach here means starting by disabling the old instance in the load
    balancer, so no new requests will be addressed. After the service finishes all
    the already-ongoing requests (remember, no new requests will be sent to this instance),
    the instance is effectively disabled and can be removed totally from the load
    balancer.![Diagram
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持实例数量不变，需要移除一个旧实例。谨慎的做法是首先在负载均衡器中禁用旧实例，这样就不会有新的请求被处理。在服务完成所有已进行的请求后（记住，不会向此实例发送新的请求），实例实际上被禁用，可以从负载均衡器中完全移除。![图
- en: Description automatically generated](img/B17580_16_04.png)
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_16_04.png)
- en: 'Figure 16.4: Removal of an old server from the load balancer'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图16.4：从负载均衡器中移除旧服务器
- en: The old instance can be destroyed/recycled.![Diagram
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以销毁/回收旧实例。![图
- en: Description automatically generated](img/B17580_16_05.png)
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_16_05.png)
- en: 'Figure 16.5: Old server has been totally removed'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图16.5：旧服务器已被完全移除
- en: The process can be repeated until all instances are at version 2.![Diagram
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以重复此过程，直到所有实例都达到版本2。![图
- en: Description automatically generated](img/B17580_16_06.png)
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_16_06.png)
- en: 'Figure 16.6: Final stage with all new servers'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6：所有新服务器的最终阶段
- en: There are tools that allow us to do this process automatically. For example,
    Kubernetes will perform this automatically when rolling out changes to containers.
    We also saw that web services like nginx or Apache will do as well. But the same
    process can also be applied manually or through developing custom tools when an
    unusual use case demands it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 有工具可以让我们自动执行此过程。例如，Kubernetes在向容器推出更改时会自动执行此操作。我们还看到，像nginx或Apache这样的网络服务也会这样做。但是，在需要不寻常用例时，也可以手动执行或通过开发自定义工具来执行此过程。
- en: Feature flags
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能标志
- en: The idea of feature flags is to hide functionality that is still not ready to
    be released under a configuration change. Following the principles of small increments
    and quick iteration makes it impossible to create big changes, like a new user
    interface.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 特性标志的想法是在配置更改下隐藏尚未准备好发布的功能。遵循小步增量快速迭代的原理，使得创建像新用户界面这样的大型变更变得不可能。
- en: To complicate things further, these big changes will likely happen in parallel
    with others. There's no chance of delaying the whole release process for 6 months
    or more until the new user interface is working correctly.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步的是，这些大型变更可能会与其他变更并行发生。没有机会推迟整个发布过程6个月或更长时间，直到新用户界面正确工作。
- en: Creating a separate branch that's long-lived is also not a great solution, as
    merging this branch becomes a nightmare. Long-living branches are complex to manage
    and always difficult to work with.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个长期存在的独立分支也不是一个好的解决方案，因为合并这个分支会变成一场噩梦。长期存在的分支难以管理，并且总是难以协作。
- en: A better solution is to create a configuration parameter that activates or deactivates
    this feature. The feature can then be tested in a particular environment, while
    all the development continues at the same pace.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是创建一个配置参数来激活或停用此特性。然后，该特性可以在特定环境中进行测试，而所有开发工作都以相同的速度继续。
- en: That means that other changes, like bug fixes or performance improvements, are
    still happening and being deployed. And the work done on the big new feature is
    merged into the main branch as often as usual. This means that the developed parts
    of the big new feature are also being released to the production environment,
    but they are not active yet.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着其他变更，如错误修复或性能改进，仍在进行中并被部署。对大型新功能的工作也像往常一样频繁地合并到主分支。这意味着大型新功能已开发的部分也被发布到生产环境中，但它们尚未激活。
- en: Tests need to ensure that both options – the feature active and deactivated
    – work correctly, but working in small increments makes this relatively easy.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 测试需要确保两种选项——特性激活和停用——都能正确工作，但以小步增量工作使得这相对容易。
- en: The feature will be then developed in small increments until it's ready for
    release. The final step is to simply enable it through a configuration change.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 特性将会以小步增量开发，直到准备好发布。最后一步就是通过配置更改简单地启用它。
- en: 'Note that the feature may be active for certain users or environments. This
    is how beta features are tested: they rely on some users being able to access
    the feature before it is fully released. The test users could be internal to the
    organization initially, like QA teams, managers, product owners, etc., so they
    can provide feedback on the feature, but using production data.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该特性可能对某些用户或环境是活跃的。这就是测试beta特性的方式：它们依赖于某些用户在完全发布之前能够访问该特性。最初，测试用户可能是组织内部的，如QA团队、经理、产品负责人等，他们可以提供关于特性的反馈，但使用生产数据。
- en: This technique allows us to grow in confidence and release big features without
    sacrificing small incremental approaches to it.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术使我们能够在不牺牲对它的微小增量方法的情况下，增强信心并发布大型特性。
- en: Teamwork aspects of changes
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变更的团队合作方面
- en: Software architecture is not only about technology, but a part of it is highly
    dependent on communication and human aspects.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构不仅关乎技术，其中一部分高度依赖于沟通和人文因素。
- en: The process of implementing changes in a system has some human elements affecting
    teamwork that need to be taken into consideration.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中实施变更的过程有一些影响团队合作的要素，需要考虑。
- en: 'Some examples:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一些例子：
- en: Keep in mind that the work of a software architect typically lies in managing
    communication with multiple teams, which requires care and soft skills in both
    actively listening to teams and explaining or even negotiating design changes.
    Depending on the size of the organization, that could be challenging as different
    teams may have wildly different cultures.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住，软件架构师的工作通常在于与多个团队进行沟通管理，这需要关注和具备在积极倾听团队的同时解释甚至协商设计变更的软技能。根据组织的规模，这可能具有挑战性，因为不同的团队可能有截然不同的文化。
- en: The pace and acceptance of technical changes in an organization are tightly
    related to the organization's culture (or subcultures). Changes in organizations'
    ways of working typically occur much more slowly, although organizations that
    can quickly change technologies tend to be faster in adjusting to organization-wide
    changes.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织中技术变革的步伐和接受程度与组织的文化（或亚文化）紧密相关。组织工作方式的变革通常发生得较慢，尽管能够快速改变技术的组织在调整组织范围内的变革方面往往更快。
- en: In the same way, technology changes require support and training, even if it's
    purely within the organization. When requiring some big technology change, be
    sure to have a point of contact where the team can go to resolve doubts and questions.A
    lot of the questions can be solved by explaining *why* that change is required
    and working from there.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，技术变革需要支持和培训，即使它完全在组织内部进行。在需要一些重大的技术变革时，确保有一个团队可以前往解决疑问和问题的联系人。许多问题可以通过解释为什么需要这种变革，并从这里着手来解决。
- en: Remember when we talked about Conway's Law of software architecture in *Chapter
    1*,*Introduction to software architecture*, about how the communication structure
    and architectural structure are related. A change in one will likely affect the
    other, which means that big enough architectural changes will lead to organizational
    restructuring, which has its own challenges.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记得我们在*第一章，软件架构导论*中讨论康威定律时提到的软件架构的通信结构和架构结构之间的关系吗？一个方面的变化很可能会影响到另一个方面，这意味着足够大的架构变化将导致组织结构的重组，这本身也带来了一些挑战。
- en: At the same time, changes may have *winners* and *losers* in the affected teams.
    One engineer could feel threatened because they won't be able to use their favorite
    programming language. In the same way, their partner will be excited because now
    the opportunity to use their favorite piece of tech is amazing.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时，变革可能会在受影响的团队中产生*赢家*和*输家*。一位工程师可能会感到威胁，因为他们将无法使用他们喜欢的编程语言。同样，他们的合作伙伴可能会感到兴奋，因为现在有机会使用他们喜欢的技术是令人难以置信的。
- en: This problem can be particularly poignant in team shuffling when people are moving
    around or when creating new teams. An important factor in the pace of development
    is to have an efficient team and making changes to teams has an impact on their
    communication and effectiveness. This impact needs to be analyzed and taken into
    consideration.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在人员流动或创建新团队时，这个问题在团队重组时尤其尖锐。影响开发速度的一个重要因素是拥有一个高效的团队，而改变团队会影响他们的沟通和效率。这种影响需要被分析和考虑。
- en: Maintenance needs to be introduced routinely as part of the day-to-day operations
    of the organization. Regular maintenance should include all security updates,
    but also tasks like upgrading OS versions, dependencies, etc.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护需要作为组织日常运营的一部分定期引入。定期的维护应包括所有安全更新，但也包括升级操作系统版本、依赖项等任务。
- en: 'A general plan to deal with this kind of routine maintenance will provide clarity
    and clear expectations. For example*: the OS version will be upgraded within three
    to six months of a new LTS version being released*. This produces predictability,
    gives clear objectives to follow, and produces continuous improvement of the system.In
    the same way, automatic tools that detect security vulnerabilities make it easy
    for the team to know when it''s time to upgrade dependencies either in the code
    or in the underlying system.'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 处理这类常规维护的一般计划将提供清晰性和明确的期望。例如：在新版LTS发布后的三到六个月内将升级操作系统版本。这产生了可预测性，为遵循的明确目标，并使系统持续改进。同样，自动检测安全漏洞的工具使团队能够知道何时是时候升级代码或底层系统中的依赖项。
- en: In the same way, the repayment of technical debt needs to be introduced as a habit
    to be sure that the system is healthy. Technical debt is typically detected by
    the teams themselves, as they'll have the best understanding of it, and is manifested
    with a progressively slower pace of code changes. If technical debt is not addressed,
    it will become more and more complicated to work with, making the development
    process more difficult and risking burnout by developers. Be sure to budget time
    to tackle it before it gets out of control.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，技术债务的偿还需要作为一种习惯来引入，以确保系统健康。技术债务通常由团队自己发现，因为他们对它的理解最好，并且表现为代码变更速度的逐渐减慢。如果不解决技术债务，它将变得越来越复杂，使开发过程更加困难，并可能导致开发者的过度劳累。确保在失控之前留出时间来处理它。
- en: As a general consideration, just keep in mind that changes in architecture need
    to be carried out by members of the team, and that information needs to be communicated
    and executed correctly. As with any other task where communication is an important
    component, this presents its own challenges and problems, as communicating with
    people, especially with several people, is arguably one of the most difficult
    tasks in software development. Any software architecture designer needs to be
    aware of this and allocate enough time to be sure to, on one hand, communicate
    the plan adequately, and on the other, receive feedback and adjust accordingly
    to get the best results.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项一般性考虑，请记住，架构的变更需要由团队成员执行，并且信息需要正确传达和执行。与任何其他以沟通为重要组成部分的任务一样，这也带来了其自身的挑战和问题，因为与人们沟通，尤其是与多个人沟通，可以说是软件开发中最困难的任务之一。任何软件架构设计师都需要意识到这一点，并分配足够的时间以确保一方面能够充分传达计划，另一方面能够接收反馈并相应调整以获得最佳结果。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we described the different aspects and challenges of keeping
    a system running while developing and changing it, including its architecture.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了在开发和更改系统时保持系统运行的不同方面和挑战，包括其架构。
- en: We started by describing different ways that architecture can require adjustments
    and changes. We then moved on to talk about how to manage changes, including the
    option of having some designated time where the system won't be available, and
    introduced the concept of maintenance windows to clearly communicate expectations
    of stability and change.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先描述了架构可能需要调整和改变的不同方式。然后，我们继续讨论如何管理变更，包括在系统不可用的一段时间内进行变更的选项，并引入了维护窗口的概念，以清楚地传达对稳定性和变更的期望。
- en: We next went over the different incidents that can happen when problems arise,
    and the system struggles. We went over the necessary continuous process of improvement
    and reflection after an incident of this kind happens, and also looked at preparation
    processes that can be used before a significant event where the risk increases,
    for example, because of a marketing push expected to increase the load of the
    system.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来讨论了当问题出现，系统出现问题时可能发生的不同情况。我们回顾了在发生此类事件后必要的持续改进和反思过程，并探讨了在风险增加的重大事件之前可以使用的准备流程，例如，由于预期增加系统负载的市场推动。
- en: To deal with this, we next introduced load testing and how it can be used to
    verify the system's capacity for accepting a defined load, making sure that it's
    ready to support the expected traffic. We talked as well about the necessity of
    creating a versioning system that clearly communicates what version of the software
    is currently deployed.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这种情况，我们接下来介绍了负载测试及其如何用于验证系统接受定义负载的能力，确保它准备好支持预期的流量。我们还讨论了创建版本控制系统的重要性，该系统能够清楚地传达当前部署的软件版本。
- en: Next, we talked about the critical aspect of backward compatibility and how
    is crucial in ensuring small, fast increments that are the key to continuous improvement
    and advancement. We also talked about how feature flags can help mix this process
    of releasing bigger features that need to be activated as a whole.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论了向后兼容性的关键方面以及它在确保小而快速的增量中的重要性，这些增量是持续改进和进步的关键。我们还讨论了功能标志如何帮助混合释放更大特征的过程，这些特征需要作为一个整体激活。
- en: Finally, we described different aspects of how changes in a system and architecture
    can affect human collaboration and communication and how that needs to be taken
    into account while performing changes to the system, in particular changes that
    may affect the structure of the teams, which, as we've seen, will tend to replicate
    the structure of the software.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们描述了系统架构变化如何影响人类协作和沟通的不同方面，以及在进行系统变更时需要考虑这些因素，特别是在可能影响团队结构的变化，正如我们所看到的，这些变化往往会复制软件的结构。
