- en: Deploying Mail Ape
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署Mail Ape
- en: In this chapter, we will deploy Mail Ape onto a virtual machine in the **Amazon
    Web Services** (**AWS**) cloud. AWS is composed of many different services. We've
    already discussed using S3 and launching a container into AWS. In this chapter,
    we will use a lot more AWS services. We will use the **Relational Database Service
    (RDS)** for a PostgreSQL database server. We will use the **Simple Queue Service
    (SQS)** for our Celery message queue. We will use **Elastic Computing Cloud (EC2)** to
    run virtual machines in the cloud. Finally, we will use CloudFormation to define
    our infrastructure as code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在**亚马逊网络服务**（**AWS**）云中的虚拟机上部署Mail Ape。AWS由许多不同的服务组成。我们已经讨论过使用S3和在AWS中启动容器。在本章中，我们将使用更多的AWS服务。我们将使用**关系数据库服务（RDS）**来运行PostgreSQL数据库服务器。我们将使用**简单队列服务（SQS）**来运行Celery消息队列。我们将使用**弹性计算云（EC2）**在云中运行虚拟机。最后，我们将使用CloudFormation来定义我们的基础设施为代码。
- en: 'In this chapter, we will do the following things:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Separate production and development settings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离生产和开发设置
- en: Use Packer to create an Amazon Machine Image of our release
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Packer创建我们发布的Amazon Machine Image
- en: Use CloudFormation to define the infrastructure as code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CloudFormation定义基础设施为代码
- en: Launch Mail Ape into AWS using the command line
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行将Mail Ape部署到AWS
- en: Let's start by separating our production development settings.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先分离我们的生产开发设置。
- en: Separating development and production
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离开发和生产
- en: So far, we've kept a single requirements file and a single `settings.py` file.
    This has made development convenient. However, we can't use our development settings
    in production.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们保留了一个需求文件和一个`settings.py`文件。这使得开发很方便。然而，我们不能在生产中使用我们的开发设置。
- en: The current best practice is to have a separate file per environment. Each environment's
    file then imports a common file with shared values. We'll use this pattern for
    our requirements and settings files.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的最佳实践是每个环境使用单独的文件。然后每个环境的文件导入一个具有共享值的通用文件。我们将为我们的需求和设置文件使用这种模式。
- en: Let's start by splitting up our requirements files.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先分离我们的需求文件。
- en: Separating our requirements files
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离我们的需求文件
- en: 'To separate our requirements, we''ll delete the existing `requirements.txt` file
    and replace it with common, development, and production requirements files. After
    we delete `requirements.txt`, let''s create `requirements.common.txt` at the root
    of our project:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分离我们的需求，我们将删除现有的`requirements.txt`文件，并用通用、开发和生产需求文件替换它。在删除`requirements.txt`之后，让我们在项目的根目录下创建`requirements.common.txt`：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, let''s create a requirements file for `requirements.development.txt`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为`requirements.development.txt`创建一个需求文件：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since we only use Redis in our development setup, we'll keep the package in
    our development requirements file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只在开发设置中使用Redis，我们将在开发需求文件中保留该软件包。
- en: 'We''ll put our production requirements in `requirements.production.txt` at
    the root of the project:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的生产需求放在项目的根目录下的`requirements.production.txt`中：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In order for Celery to work with SQS (the AWS message queue service), we will
    need to install the Celery SQS library (`celery[sqs]`). We will also install `boto3`,
    the Python AWS library, and `pycurl`, a Python `curl` implementation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Celery与SQS（AWS消息队列服务）配合工作，我们需要安装Celery SQS库（`celery[sqs]`）。我们还将安装`boto3`，Python
    AWS库，和`pycurl`，Python的`curl`实现。
- en: Next, let's separate our Django settings files.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们分离我们的Django设置文件。
- en: Creating common, development, and production settings
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建通用、开发和生产设置
- en: As in our previous chapters, before we sort our settings into three files, we'll
    create `common_settings.py` by renaming our current `settings.py` then making
    some changes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的章节一样，在我们将设置分成三个文件之前，我们将通过将当前的`settings.py`重命名为`common_settings.py`然后进行一些更改来创建`common_settings.py`。
- en: Let's change `DEBUG = False` so that no new settings file can *accidentally*
    be in debug mode. Then, let's change the secret key to be obtained from an environment
    variable by updating `SECRET_KEY = os.getenv('DJANGO_SECRET_KEY')`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`DEBUG = False`更改为，以便没有新的设置文件可以*意外*处于调试模式。然后，让我们通过更新`SECRET_KEY = os.getenv('DJANGO_SECRET_KEY')`从环境变量中获取密钥。
- en: 'In the database config, we can remove all the credentials but keep the `ENGINE`
    (to make it clear that we intend to use Postgres everywhere):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库配置中，我们可以删除所有凭据，但保留`ENGINE`（以明确表明我们打算在所有地方使用Postgres）：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, let''s create a development settings file in `django/config/development_settings.py`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`django/config/development_settings.py`中创建一个开发设置文件：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Remember that you need to change your `MAILING_LIST_FROM_EMAIL`, `EMAIL_HOST` and
    `EMAIL_HOST_USER` to your correct development values.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 记得你需要将你的`MAILING_LIST_FROM_EMAIL`，`EMAIL_HOST`和`EMAIL_HOST_USER`更改为正确的开发数值。
- en: 'Next, let''s put our production settings in `django/config/production_settings.py`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将我们的生产设置放在`django/config/production_settings.py`中：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our production settings file gets most of its values from environment variables
    so that we don''t check production values into our server. There are three settings
    we need to review, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的生产设置文件大部分数值都来自环境变量，这样我们就不会将生产数值提交到服务器中。有三个设置我们需要审查，如下：
- en: '`MAILING_LIST_LINK_DOMAIN`: This is the domain that links in our emails will
    point to. In our case, in the preceding code snippet, we used the same domain
    that we added to our `ALLOWED_HOSTS` list, ensuring that we''re serving the domain
    that the links point to.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAILING_LIST_LINK_DOMAIN`：这是我们邮件中链接的域。在我们的情况下，在前面的代码片段中，我们使用了与我们添加到`ALLOWED_HOSTS`列表中的相同域，确保我们正在为链接指向的域提供服务。'
- en: '`CELERY_BROKER_TRANSPORT_OPTIONS`: This is a dictionary of options that configure
    Celery to use the correct SQS queue. We will need to set the region to `us-west-2`
    because our entire production deployment will be in that region. By default, Celery
    will want to use a queue called `celery`. However, we don''t want that name to
    collide with other Celery projects we might deploy. To prevent name collisions,
    we will configure Celery to use the `mailape-` prefix.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CELERY_BROKER_TRANSPORT_OPTIONS`：这是一个配置Celery使用正确的SQS队列的选项字典。我们需要将区域设置为`us-west-2`，因为我们整个生产部署将在该区域。默认情况下，Celery将希望使用一个名为`celery`的队列。然而，我们不希望该名称与我们可能部署的其他Celery项目发生冲突。为了防止名称冲突，我们将配置Celery使用`mailape-`前缀。'
- en: '`CELERY_BROKER_URL`: This tells Celery which broker to use. In our case, we''re
    using SQS. We will give our virtual machine access to SQS using AWS''s role-based
    authorization so that we don''t have to provide any credentials.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CELERY_BROKER_URL`：这告诉Celery要使用哪个代理。在我们的情况下，我们使用SQS。我们将使用AWS的基于角色的授权为我们的虚拟机提供对SQS的访问权限，这样我们就不必提供任何凭据。'
- en: Now that we have our production settings created, let's make our infrastructure
    in the AWS Cloud.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的生产设置，让我们在AWS云中创建我们的基础设施。
- en: Creating an infrastructure stack in AWS
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWS中创建基础设施堆栈
- en: 'In order to host an app on AWS, we will need to ensure that we have some infrastructure
    set up. We''ll need to the following things:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在AWS上托管应用程序，我们需要确保我们已经设置了一些基础设施。我们需要以下内容：
- en: A PostgreSQL server
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个PostgreSQL服务器
- en: Security Groups to open network ports so that we can access our database and
    web server
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全组，以打开网络端口，以便我们可以访问我们的数据库和Web服务器
- en: An InstanceProfile to give our deployed VM access to SQS
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个InstanceProfile，为我们部署的虚拟机提供对SQS的访问权限
- en: We could create all that using the AWS web console or using the command-line
    interface. However, over time, it can be hard to track how our infrastructure
    is configured if we rely on runtime tweaks. It would be much nicer if we could
    describe our required infrastructure in files that we could track in version control,
    much like we track our code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用AWS Web控制台或使用命令行界面创建所有这些。然而，随着时间的推移，如果我们依赖运行时调整，很难跟踪我们的基础设施是如何配置的。如果我们能够描述我们需要的基础设施在文件中，就像我们跟踪我们的代码一样，那将会更好。
- en: AWS provides a service called CloudFormation, which lets us treat infrastructure
    as code. We will define our infrastructure in a CloudFormation template using
    YAML (JSON is also available, but we'll use YAML). We'll then execute our CloudFormation
    template to create a CloudFormation stack. The CloudFormation stack will be associated
    with actual resources in the AWS Cloud. If we delete the CloudFormation stack,
    the related resources will also be deleted. This gives us simple control over
    our use of AWS resources.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: AWS提供了一个名为CloudFormation的服务，它让我们可以将基础设施视为代码。我们将使用YAML（也可以使用JSON，但我们将使用YAML）在CloudFormation模板中定义我们的基础设施。然后，我们将执行我们的CloudFormation模板来创建一个CloudFormation堆栈。CloudFormation堆栈将与AWS云中的实际资源相关联。如果我们删除CloudFormation堆栈，相关资源也将被删除。这使我们可以简单地控制我们对AWS资源的使用。
- en: 'Let''s create our CloudFormation template in `cloudformation/infrastructure.yaml`.
    Every CloudFormation template begins with a `Description` and the template format
    version information. Let''s start our file with the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`cloudformation/infrastructure.yaml`中创建我们的CloudFormation模板。每个CloudFormation模板都以`Description`和模板格式版本信息开始。让我们从以下内容开始我们的文件：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our CloudFormation template will have the following three parts:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的CloudFormation模板将包括以下三个部分：
- en: '`Parameters`: This is where we will describe values that we’ll pass in at runtime.
    This block is optional but useful. In our case, we''ll pass in the master database
    password rather than hardcoding it in our template.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Parameters`：这是我们将在运行时传递的值。这个块是可选的，但很有用。在我们的情况下，我们将传递主数据库密码，而不是在我们的模板中硬编码它。'
- en: '`Resources`: This is where we will describe the specific resources that our
    stack will contain. This will describe our database server, SQS queue, security
    groups, and InstanceProfile.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Resources`：这是我们将描述的堆栈中包含的具体资源。这将描述我们的数据库服务器、SQS队列、安全组和InstanceProfile。'
- en: '`Outputs`: This is where we will describe the values to output to make referencing
    the resources we created easier. This block is optional but useful. We will provide
    the address of our database server and the ID of the InstanceProfile we created.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Outputs`：这是我们将描述的值，以便更容易引用我们创建的资源。这个块是可选的，但很有用。我们将提供我们的数据库服务器地址和我们创建的InstanceProfile的ID。'
- en: Let's start by creating the `Parameters` block of our CloudFormation template.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建CloudFormation模板的`Parameters`块开始。
- en: Accepting parameters in a CloudFormation template
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CloudFormation模板中接受参数
- en: To avoid hardcoding values in a CloudFormation template, we can accept parameters.
    This helps us avoid hardcoding sensitive values (such as passwords) in a template.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在CloudFormation模板中硬编码值，我们可以接受参数。这有助于我们避免在模板中硬编码敏感值（如密码）。
- en: 'Let''s add a parameter to accept the password of our database server''s master
    user:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个参数来接受数据库服务器主用户的密码：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This adds a `MasterDBPassword` parameter to our template. We will be able to
    reference this value later on. CloudFormation templates let us add two pieces
    of information for parameters:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们的模板添加了一个`MasterDBPassword`参数。我们以后将能够引用这个值。CloudFormation模板让我们为参数添加两个信息：
- en: '`Description`: This is not used by CloudFormation but is useful for the people
    who have to maintain our infrastructure.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Description`：这不被CloudFormation使用，但对于必须维护我们的基础设施的人来说是有用的。'
- en: '`Type`: CloudFormation uses this to check whether the value we provide is valid
    *before* executing our template. In our case, the password is a `String`.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Type`：CloudFormation在执行我们的模板之前使用这个来检查我们提供的值是否有效。在我们的情况下，密码是一个`String`。'
- en: Next let's add a `Resources` block to define the AWS resources we'll need in
    our infrastructure.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个`Resources`块来定义我们基础设施中需要的AWS资源。
- en: Listing resources in our infrastructure
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出我们基础设施中的资源
- en: 'Next, we will add a `Resources` block to our CloudFormation template in `cloudformation/infrastructure.yaml`.
    Our infrastructure template will define five resources:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`cloudformation/infrastructure.yaml`中的CloudFormation模板中添加一个`Resources`块。我们的基础设施模板将定义五个资源：
- en: Security Groups, which will open network ports, permitting us to access our
    database and web servers
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全组，将打开网络端口，允许我们访问数据库和Web服务器
- en: Our database server
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的数据库服务器
- en: Our SQS queue
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的SQS队列
- en: A Role that allows access to SQS
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许访问SQS的角色
- en: An InstanceProfile, which lets our web servers assume the above Role
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: InstanceProfile，让我们的Web服务器假定上述角色
- en: Let's start by creating the Security Groups, which will open the network ports
    by which we'll access our database and web servers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建安全组，这将打开我们将访问数据库和Web服务器的网络端口。
- en: Adding Security Groups
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加安全组
- en: In AWS, a SecurityGroup defines a set of network access rules much like a network
    firewall. By default, virtual machines launched can *send* data out on any network
    port but not *accept* connections on any network port. That means that we can't
    connect using SSH or HTTP; let's fix that.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS中，SecurityGroup定义了一组网络访问规则，就像网络防火墙一样。默认情况下，启动的虚拟机可以*发送*数据到任何网络端口，但不能在任何网络端口上*接受*连接。这意味着我们无法使用SSH或HTTP进行连接；让我们解决这个问题。
- en: 'Let''s update our CloudFormation template in `cloudformation/infrastructure.yaml`
    with three new Security Groups:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`cloudformation/infrastructure.yaml`中的CloudFormation模板中更新三个新的安全组：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code block, we defined three new SecurityGroups to open ports
    `22` (SSH), `80` (HTTP), and `5432` (default Postgres port).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们定义了三个新的安全组，以打开端口`22`（SSH），`80`（HTTP）和`5432`（默认的Postgres端口）。
- en: Let's take a closer look at the syntax of a CloudFormation resource. Each resource
    block must have a `Type` and `Properties` attributes. The `Type` attribute tells
    CloudFormation what this resource describes. The `Properties` attribute describe
    settings for this particular resources.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下CloudFormation资源的语法。每个资源块必须具有`Type`和`Properties`属性。`Type`属性告诉CloudFormation这个资源描述了什么。`Properties`属性描述了这个特定资源的设置。
- en: 'Our SecurityGroups used the following properties:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下属性的安全组：
- en: '`GroupName`: This gives human-friendly names. This is optional but recommended.
    CloudFormation can generate the names for us instead. SecurityGroup names must
    be unique for a given account (for example, I can''t have two `db-access` groups,
    but you and I can each have a `db-access` group).'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GroupName`：这提供了人性化的名称。这是可选的，但建议使用。 CloudFormation可以为我们生成名称。安全组名称必须对于给定帐户是唯一的（例如，我不能有两个`db-access`组，但您和我每个人都可以有一个`db-access`组）。'
- en: '`GroupDescription`: This is a human-friendly description of the group''s purpose.
    It''s required to be present.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GroupDescription`：这是组用途的人性化描述。它是必需的。'
- en: '`SecurityGroupIngress`: This is a list of ports on which to accept incoming
    connection for VMs in this group.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SecurityGroupIngress`：这是一个端口列表，用于接受此组中虚拟机的传入连接。'
- en: '`FromPort`/`ToPort`: Often, these two settings will have the same value, the
    network port you want to be to be able to connect to. `FromPort` is the port on
    which we will connect. `ToPort` is the VM port on which a service is listening.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FromPort`/`ToPort`：通常，这两个设置将具有相同的值，即您希望能够连接的网络端口。 `FromPort`是我们将连接的端口。 `ToPort`是服务正在监听的VM端口。'
- en: '`CidrIp`: This is an IPv4 range to accept connections from. `0.0.0.0/0` means
    accept all connections.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CidrIp`：这是一个IPv4范围，用于接受连接。 `0.0.0.0/0`表示接受所有连接。'
- en: Next, let's add a database server to our list of resources.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将数据库服务器添加到我们的资源列表中。
- en: Adding a Database Server
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加数据库服务器
- en: AWS offers relational databases servers as a service called **Relational Database
    Service** (**RDS**). To create a database server on AWS, we will create a new
    RDS VM (called an *instance*). One important thing to note is that when we launch
    an RDS instance, we can connect to the PostgreSQL database on the server but we
    do not have shell access. We must run Django on a different VM.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: AWS提供关系数据库服务器作为一种称为**关系数据库服务**（**RDS**）的服务。要在AWS上创建数据库服务器，我们将创建一个新的RDS虚拟机（称为*实例*）。一个重要的事情要注意的是，当我们启动一个RDS实例时，我们可以连接到服务器上的PostgreSQL数据库，但我们没有shell访问权限。我们必须在不同的虚拟机上运行Django。
- en: 'Let''s add an RDS instance to our CloudFormation template in `cloudformation/infrastructure.yaml`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`cloudformation/infrastructure.yaml`中的CloudFormation模板中添加一个RDS实例：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our new RDS instance entry is of the `AWS::RDS::DBInstance` type. Let''s review
    the properties we set:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新RDS实例条目是`AWS::RDS::DBInstance`类型。让我们回顾一下我们设置的属性：
- en: '`DBName`: This is the name of the *server*, not the name of any databases running
    on it.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DBName`：这是*服务器*的名称，而不是其中运行的任何数据库的名称。'
- en: '`DBInstanceClass`: This defines the memory and processing power of the virtual
    machine of the server. At the time of writing this book, `db.t2.micro` is part
    of a free tier for accounts in their first year.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DBInstanceClass`：这定义了服务器虚拟机的内存和处理能力。在撰写本书时，`db.t2.micro`是首年免费套餐的一部分。'
- en: '`MasterUsername`: This is the username of the privileged administrator account
    on the server.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MasterUsername`：这是服务器上特权管理员帐户的用户名。'
- en: '`MasterUserPassword`: This is the password for the privileged administrator
    account'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MasterUserPassword`：这是特权管理员帐户的密码'
- en: '`!Ref MasterDBPassword`: This is the shortcut syntax to reference the `MasterDBPassword`
    parameter. This lets us avoid hardcoding the database server''s administrator
    password.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!Ref MasterDBPassword`：这是引用`MasterDBPassword`参数的快捷语法。这样可以避免硬编码数据库服务器的管理员密码。'
- en: '`Engine`: This is the type of Database server we want; in our case, `postgres`
    will give us a PostgreSQL server.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Engine`：这是我们想要的数据库服务器类型；在我们的情况下，`postgres`将为我们提供一个PostgreSQL服务器。'
- en: '`AllocatedStorage`: This indicates how much storage space the server should
    have, in gigabyte (GB).'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllocatedStorage`：这表示服务器应该具有多少存储空间，以GB为单位。'
- en: '`PubliclyAccessible`: This indicates whether the server can be accessed from
    outside the AWS Cloud.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PubliclyAccessible`：这表示服务器是否可以从AWS云外部访问。'
- en: '`VPCSecurityGroups`: This is a list of SecurityGroups, indicating which ports
    are open and accessible.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VPCSecurityGroups`：这是一个SecurityGroups列表，指示哪些端口是打开和可访问的。'
- en: '`!GetAtt DatabaseSecurityGroup.GroupId`: This returns the `GroupID` attribute
    of the `DatabaseSecurityGroup` security group.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!GetAtt DatabaseSecurityGroup.GroupId`: 这返回`DatabaseSecurityGroup`安全组的`GroupID`属性。'
- en: This block also introduces us to CloudFormation's `Ref` and `GetAtt` functions.
    Both these functions let us reference other parts of our CloudFormation stack
    which is very important. `Ref` lets us use our `MasterDBPassword` parameter as
    the value of our database server's `MasterUserPassword`. `GetAtt` lets us reference
    our AWS generated `GroupId` attribute of `DatabaseSecurityGroup` in our database
    server's list of `VPCSercurityGroups`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个块还向我们介绍了CloudFormation的`Ref`和`GetAtt`函数。这两个函数让我们能够引用我们CloudFormation堆栈的其他部分，这是非常重要的。`Ref`让我们使用我们的`MasterDBPassword`参数作为我们数据库服务器的`MasterUserPassword`的值。`GetAtt`让我们在我们的数据库服务器的`VPCSercurityGroups`列表中引用我们AWS生成的`DatabaseSecurityGroup`的`GroupId`属性。
- en: AWS CloudFormation offers a variety of different functions to make building
    templates easier. They are documented in the AWS documentation online ([https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html)).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CloudFormation提供了各种不同的函数，以使构建模板更容易。它们在AWS在线文档中有记录（[https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html)）。
- en: Next, let's create the SQS Queue that Celery will use.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建Celery将使用的SQS队列。
- en: Adding a Queue for Celery
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Celery添加队列
- en: SQS is the AWS message queue service. Using SQS, we can create a Celery-compatible
    message queue that we don't have to maintain. SQS can quickly scale to handle
    any number of requests we send it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: SQS是AWS消息队列服务。使用SQS，我们可以创建一个与Celery兼容的消息队列，而无需维护。SQS可以快速扩展以处理我们发送的任何请求数量。
- en: 'To define our queue, add it to our `Resources` block in `cloudformation/infrastructure.yaml`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义我们的队列，请将其添加到`cloudformation/infrastructure.yaml`中的`Resources`块中：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our new resource is of the `AWS::SQS::Queue` type and has a single property,
    `QueueName`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新资源是`AWS::SQS::Queue`类型，并且有一个属性`QueueName`。
- en: Next, let's create a role and InstanceProfile to let our production servers
    access our SQS queue.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个角色和InstanceProfile，让我们的生产服务器访问我们的SQS队列。
- en: Creating a Role for Queue access
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为队列访问创建角色
- en: Earlier, in the *Adding Security Groups* section, we discussed creating SecurityGroups
    to open network ports so that we could make a network connection. To manage access
    among AWS resources, we will need to use role-based authorization. In a role-based
    authorization, we define a role, who can be assigned that role (assume that role),
    and what actions that role can perform. In order for our web servers to use that
    role, we will need to create an EC2 instance profile that is associated with that
    role.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，在*添加安全组*部分，我们讨论了创建SecurityGroups以打开网络端口，以便我们可以进行网络连接。为了管理AWS资源之间的访问，我们需要使用基于角色的授权。在基于角色的授权中，我们定义一个角色，可以被分配该角色的人（假定该角色），以及该角色可以执行哪些操作。为了使我们的Web服务器使用该角色，我们需要创建一个与该角色关联的EC2实例配置文件。
- en: 'Let''s start by adding a role to `cloudformation/infrastructure.yaml`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在`cloudformation/infrastructure.yaml`中添加一个角色：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our new block is of the `AWS::IAM::Role` type. IAM is short for AWS Identity
    and Access Management services. Our role is composed of the following two properties:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新块是`AWS::IAM::Role`类型。IAM是AWS身份和访问管理服务的缩写。我们的角色由以下两个属性组成：
- en: '`AssumeRolePolicyDocument`: This defines who may be assigned this role. In
    our case, we''re saying that this role may be assumed by any object in Amazon''s
    EC2 service. Later, we''ll use it in our EC2 instances.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AssumeRolePolicyDocument`：这定义了谁可以被分配这个角色。在我们的情况下，我们说这个角色可以被亚马逊的EC2服务中的任何对象假定。稍后，我们将在我们的EC2实例中使用它。'
- en: '`Policies`: This is a list of allowed (or denied) actions for this role. In
    our case, we''re permitting all SQS operations (`sqs:*`) on our previously defined
    SQS Queue. We reference our queue by getting its `Arn`, **Amazon Resource Name**
    (**ARN**), with the `GetAtt` function. ARNs are Amazon''s way of providing each
    resource on the Amazon cloud with a globally unique ID.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Policies`：这是该角色允许（或拒绝）的操作列表。在我们的情况下，我们允许在我们之前定义的SQS队列上执行所有SQS操作（`sqs:*`）。我们通过使用`GetAtt`函数引用我们的队列来获取其`Arn`，Amazon资源名称（ARN）。ARN是亚马逊为亚马逊云上的每个资源提供全局唯一ID的方式。'
- en: 'Now that we have our role, we can associate it with an `InstanceProfile` resource,
    which can be associated with our web servers:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的角色，我们可以将其与一个`InstanceProfile`资源关联起来，该资源可以与我们的Web服务器关联起来：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our new InstanceProfile is of the `AWS::IAM::InstanceProfile` type and needs
    a list of associated roles. In our case, we simply reference our previously created
    `SQSAccessRole` using the `Ref` function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新InstanceProfile是`AWS::IAM::InstanceProfile`类型，并且需要一个关联角色的列表。在我们的情况下，我们只需使用`Ref`函数引用我们之前创建的`SQSAccessRole`。
- en: Now that we've created our infrastructure resources, let's output the address
    of our database and our ARN of `InstanceProfile` resource.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的基础设施资源，让我们输出我们的数据库的地址和我们的`InstanceProfile`资源的ARN。
- en: Outputting our resource information
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出我们的资源信息
- en: CloudFormation templates can have an output block to make it easier to reference
    the created resources. In our case, we will output the address of our database
    server and the ARN of `InstanceProfile.`
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation模板可以有一个输出块，以便更容易地引用创建的资源。在我们的情况下，我们将输出我们的数据库服务器的地址和`InstanceProfile`的ARN。
- en: 'Let''s update our CloudFormation template in `cloudformation/infrastructure.yaml`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`cloudformation/infrastructure.yaml`中更新我们的CloudFormation模板：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we're using the `GetAtt` function to return the address
    of our `DatabaseServer` resource and the ARN of our `SQSClientInstance` `InstanceProfile` resource.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用`GetAtt`函数返回我们的`DatabaseServer`资源的地址和我们的`SQSClientInstance` `InstanceProfile`资源的ARN。
- en: Executing our template to create our resources
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行我们的模板以创建我们的资源
- en: Now that we've created our `CloudFormation` template, we can create a `CloudFormation`
    stack. When we tell AWS to create our `CloudFormation` stack, it will create all
    the related resources in our template.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的`CloudFormation`模板，我们可以创建一个`CloudFormation`堆栈。当我们告诉AWS创建我们的`CloudFormation`堆栈时，它将在我们的模板中创建所有相关资源。
- en: 'To create our template, we will need the following two things:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的模板，我们需要以下两件事情：
- en: The AWS **command-line interface** (**CLI**)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS命令行界面（CLI）
- en: An AWS access key/secret key pair
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS访问密钥/秘密密钥对
- en: 'We can install the AWS CLI using `pip`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`pip`安装AWS CLI：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To get (or create) your access key/secret key pair, you will need access to
    the Security Credential ([https://console.aws.amazon.com/iam/home?region=us-west-2#/security_credential](https://console.aws.amazon.com/iam/home?region=us-west-2#/security_credential))
    section of your AWS Console.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取（或创建）您的访问密钥/秘密密钥对，您需要访问AWS控制台的安全凭据部分。
- en: 'Then we need to configure the AWS command line tool with our key and region.
    The `aws` command offers an interactive `configure` subcommand to do this. Let’s
    run it on the command line:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要使用我们的密钥和区域配置AWS命令行工具。`aws`命令提供了一个交互式的`configure`子命令来完成这个任务。让我们在命令行上运行它：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `aws configure` command stores the values you entered in a `.aws` directory
    in your home directory.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`aws configure`命令将您输入的值存储在主目录中的`.aws`目录中。'
- en: 'With those setups, we can now create our stack:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些设置，我们现在可以创建我们的堆栈：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Creating a stack can take some time, so the command returns without waiting
    for success. Let''s take a closer look at our `create-stack` command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建堆栈可能需要一些时间，因此该命令在等待成功时返回。让我们更仔细地看看我们的`create-stack`命令：
- en: '`--stack-name`: This is the name of stack we''re creating. Stack names must
    be unique per account.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--stack-name`：这是我们正在创建的堆栈的名称。堆栈名称必须在每个帐户中是唯一的。'
- en: '`--template-body`: This is either the template itself, or, in our case, a `file://`
    URL to the template file. Remember that `file://` URLs require the absolute path
    to the file.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--template-body`：这要么是模板本身，要么是我们的情况下模板文件的`file://` URL。请记住，`file://` URL需要文件的绝对路径。'
- en: '`--capabilities CAPABILITY_NAMED_IAM`: This is required for templates that
    create or affect **Identity and Access Management** (**IAM**) services. This prevents
    accidentally affecting access management services.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--capabilities CAPABILITY_NAMED_IAM`：这对于创建或影响**Identity and Access Management**（**IAM**）服务的模板是必需的。这可以防止意外影响访问管理服务。'
- en: '`--parameters`: This lets us pass in values for a template''s parameters. In
    our case, we set the master password for our database as `password`, which is
    not a safe value.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--parameters`：这允许我们传递模板参数的值。在我们的案例中，我们将数据库的主密码设置为`password`，这不是一个安全的值。'
- en: '`--region`: The AWS Cloud is organized as a collection of regions across the
    world. In our case, we''re using `us-west-2`, which is located in a series of
    data centers around the US state of Oregon.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--region`：AWS云组织为世界各地的一组区域。在我们的案例中，我们使用的是位于美国俄勒冈州一系列数据中心的`us-west-2`。'
- en: Remember that you need to set a secure master password for your database.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您需要为数据库设置一个安全的主密码。
- en: 'To take a look at how stack creation is doing, we can check it using AWS Web
    Console ([https://us-west-2.console.aws.amazon.com/cloudformation/home?region=us-west-2](https://us-west-2.console.aws.amazon.com/cloudformation/home?region=us-west-2))
    or using the command line:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看堆栈创建的进度，我们可以使用AWS Web控制台（[https://us-west-2.console.aws.amazon.com/cloudformation/home?region=us-west-2](https://us-west-2.console.aws.amazon.com/cloudformation/home?region=us-west-2)）或使用命令行进行检查：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When the stack is done creating the related resources, it will return a result
    similar to this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当堆栈完成创建相关资源时，它将返回类似于这样的结果：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Two things to pay particular attention to in the `describe-stack` result are
    as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`describe-stack`结果中特别注意的两件事是：
- en: The object under the `Parameters` key, which will show our master database password
    in plain text
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Parameters`键下的对象将以明文显示我们的主数据库密码'
- en: The object `Outputs` key, which shows the ARN of our `InstanceProfile` resource
    and the address of our database server
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Outputs`对象键显示了我们的`InstanceProfile`资源的ARN和数据库服务器的地址'
- en: In all the previous code, I've replaced values specific to my account with XXX.
    Your output will differ.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有先前的代码中，我已经用XXX替换了特定于我的帐户的值。您的输出将有所不同。
- en: 'If you want to remove the resources associated with your stack, you can just
    delete the stack:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要删除与您的堆栈关联的资源，您可以直接删除该堆栈：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, we'll build an Amazon Machine Image, which we'll use to run Mail Ape in
    AWS.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建一个Amazon Machine Image，用于在AWS中运行Mail Ape。
- en: Building an Amazon Machine Image with Packer
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Packer构建Amazon Machine Image
- en: Now that we have our infrastructure running in AWS, let's build our Mail Ape
    server. In AWS, we could launch an official Ubuntu VM, follow the steps in [Chapter
    9](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml), *Deploying Answerly*, and have
    our Mail Ape running. However, AWS treats EC2 instances as *ephemeral*. If an
    EC2 instance gets terminated, then we will have to launch a new instance and configure
    it all over again. There are a few ways to mitigate this problem. We'll solve
    the problem of ephemeral EC2 instances by building a new **Amazon Machine Image**
    (**AMI**) for our release. Then any time we launch an EC2 instance using that
    AMI, it will be already perfectly configured.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的基础设施在AWS中运行，让我们构建我们的Mail Ape服务器。在AWS中，我们可以启动一个官方的Ubuntu VM，按照[第9章](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml)中的步骤，*部署Answerly*，并让我们的Mail
    Ape运行。但是，AWS将EC2实例视为*临时*。如果EC2实例被终止，那么我们将不得不启动一个新实例并重新配置它。有几种方法可以缓解这个问题。我们将通过为我们的发布构建一个新的**Amazon
    Machine Image**（**AMI**）来解决临时EC2实例的问题。然后，每当我们使用该AMI启动EC2实例时，它将已经完美地配置好。
- en: We will automate building our AMIs using a HashiCorp's Packer tool. Packer gives
    us a way of creating an AMI from a Packer template. A Packer template is a JSON
    file that defines the steps needed to configure our EC2 instance into our desired
    state and save the AMI. For our Packer template to run, we’ll also write a collection
    of shell scripts to configure our AMI. Using a tool like Packer, we can automate
    building a new release AMI.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用HashiCorp的Packer工具自动构建我们的AMI。 Packer为我们提供了一种从Packer模板创建AMI的方法。 Packer模板是一个定义了配置EC2实例到我们期望状态并保存AMI所需步骤的JSON文件。为了运行我们的Packer模板，我们还将编写一系列shell脚本来配置我们的AMI。使用Packer这样的工具，我们可以自动构建一个新的发布AMI。
- en: Let’s start by installing Packer on our machines.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在我们的机器上安装Packer。
- en: Installing Packer
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Packer
- en: Get Packer from the [https://www.packer.io](https://www.packer.io) download
    page. Packer is available for all major platforms.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://www.packer.io](https://www.packer.io)下载页面获取Packer。 Packer适用于所有主要平台。
- en: Next, we’ll create a script to make the directories we’ll rely on in production.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个脚本来创建我们在生产中依赖的目录。
- en: Creating a script to create our directory structure
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个脚本来创建我们的目录结构
- en: 'The first script we will write will create directories for all our code. Let’s
    add the following script to our project in `scripts/make_aws_directories.sh`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写的第一个脚本将为我们的所有代码创建目录。让我们在`scripts/make_aws_directories.sh`中添加以下脚本到我们的项目中：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, we’re using `mkdir` to make the directories. Next, we
    want to make the `ubuntu` user can write to the `/mailape` directories so that
    we recursively `chown` the `/mailape` directory.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用`mkdir`来创建目录。接下来，我们希望让`ubuntu`用户可以写入`/mailape`目录，所以我们递归地`chown`了`/mailape`目录。
- en: So, let's create a script to install the Ubuntu packages we require.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们创建一个脚本来安装我们需要的Ubuntu软件包。
- en: Creating a script to install all our packages
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个脚本来安装我们所有的软件包
- en: 'In our production environment, we will have to install Ubuntu packages as well
    as the Python packages we’ve already listed. First, let’s list all our Ubuntu
    packages in `ubuntu/packages.txt`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的生产环境中，我们将不仅需要安装Ubuntu软件包，还需要安装我们已经列出的Python软件包。首先，让我们在`ubuntu/packages.txt`中列出所有我们的Ubuntu软件包：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, let''s create a script to install all the packages in `scripts/install_all_packages`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个脚本来安装`scripts/install_all_packages`中的所有软件包：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding script, we will install the Ubuntu packages that we listed
    above, then create a `virtualenv` to isolate our Mail Ape Python environment and
    packages. Finally, we give Apache (the `www-data` user) the ownership of some
    directories so that it can write to them. We couldn’t give the `www-data` user
    the ownership because they probably didn’t exist until we installed the `apache2`
    package.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述脚本中，我们将安装我们上面列出的Ubuntu软件包，然后创建一个`virtualenv`来隔离我们的Mail Ape Python环境和软件包。最后，我们将一些目录的所有权交给Apache（`www-data`用户），以便它可以写入这些目录。我们无法给`www-data`用户所有权，因为直到我们安装`apache2`软件包之前，它们可能并不存在。
- en: Next, let’s configure to run Apache2 to run Mail Ape using mod_wsgi.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们配置Apache2使用mod_wsgi来运行Mail Ape。
- en: Configuring Apache
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Apache
- en: Now, we'll add Apache mod_wsgi configuration just like we did in [Chapter 9](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml),
    *Deploying Answerly*. The mod_wsgi configuration isn't the focus of this chapter,
    so refer to [Chap](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml)ter 9, *Deploying
    Answerly*, for details of how this configuration works.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加Apache mod_wsgi配置，就像我们在[第9章](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml)中所做的那样，*部署Answerly*。
    mod_wsgi配置不是本章的重点，所以请参考[第9章](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml)，*部署Answerly*，了解这个配置的工作原理。
- en: 'Let''s create a virtual host configuration file for Mail Ape in `apache/mailape.apache.conf`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为Mail Ape在`apache/mailape.apache.conf`中创建一个虚拟主机配置文件：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we discussed in [Chapter 9](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml),
    *Deploying Answerly*, there isn't a way to pass environment variables to our mod_wsgi
    Python processes, so we will need to update our project's `wsgi.py` just like
    we did in [Chapter 9](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml), *Deploying
    Answerly*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第9章](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml)中所讨论的，*部署Answerly*，我们无法将环境变量传递给我们的mod_wsgi
    Python进程，因此我们需要像在[第9章](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml)中所做的那样更新项目的`wsgi.py`。
- en: 'Here''s our new `django/config/wsgi.py`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的新`django/config/wsgi.py`：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We discussed the preceding script in Chapter 9, *Deploying Answerly*. The only
    difference here is the file we parse, that is, `/etc/mailape/mailape.ini`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第9章*部署Answerly*中讨论了上述脚本。这里唯一的区别是我们解析的文件，即`/etc/mailape/mailape.ini`。
- en: 'Next, we will need to add our virtual host configuration to the Apache `sites-enabled`
    directory. Let''s create a script to do that in `scripts/configure_apache.sh`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将我们的虚拟主机配置添加到Apache的`sites-enabled`目录中。让我们在`scripts/configure_apache.sh`中创建一个脚本来做到这一点：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now that we have a script to configure Apache in a production environment, let's
    configure our Celery workers to start.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个在生产环境中配置Apache的脚本，让我们配置我们的Celery工作进程开始。
- en: Configuring Celery
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Celery
- en: Now that we have Apache running Mail Ape, we will need to configure Celery to
    start and process our SQS queue. To start our Celery workers, we will use Ubuntu's
    systemd process management facility.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让Apache运行Mail Ape，我们需要配置Celery来启动并处理我们的SQS队列。为了启动我们的Celery工作进程，我们将使用Ubuntu的systemd进程管理工具。
- en: 'First, let''s create a Celery service file to tell SystemD how to start Celery.
    We''ll create the service file in `ubuntu/celery.service`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个Celery服务文件，告诉SystemD如何启动Celery。我们将在`ubuntu/celery.service`中创建服务文件：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s take a closer look at some of the options in this file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这个文件中的一些选项：
- en: '`After=network.target`: This means that SystemD should not start this until
    our server has connected to a network.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`After=network.target`：这意味着SystemD在服务器连接到网络之前不会启动这个服务。'
- en: '`Type=forking`: This means that the `ExecStart` command will eventually start
    a new process that continues to run under its own process ID (PID).'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Type=forking`：这意味着`ExecStart`命令最终将启动一个新进程，该进程将继续在自己的进程ID（PID）下运行。'
- en: '`User`: This indicates the user that will own the Celery processes. In our
    case, we''re just going to reuse Apache''s `www-data` user.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User`: 这表示将拥有Celery进程的用户。在我们的情况下，我们将重用Apache的`www-data`用户。'
- en: '`EnvironmentFile`: This lists a file that will be read for environment variables
    and values that will be set for all the `Exec` commands. We list one with our
    Celery configuration (`/mailape/ubuntu/celery.systemd.conf`) and one with our
    Mail Ape configuration (`/etc/mailape/celery.env`).'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnvironmentFile`: 这列出了一个将用于环境变量和所有`Exec`命令设置的值的文件。我们列出了一个与我们的Celery配置（`/mailape/ubuntu/celery.systemd.conf`）和一个与我们的Mail
    Ape配置（`/etc/mailape/celery.env`）的文件。'
- en: '`ExecStart`: This is the command that will be executed to start Celery. In
    our case, we start multiple Celery workers. All our Celery commands will operate
    on our workers based on the process ID files they create. Celery will replace
    `%n` with the worker''s ID.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecStart`: 这是将要执行的命令，用于启动Celery。在我们的情况下，我们启动多个Celery工作者。我们所有的Celery命令将基于它们创建的进程ID文件来操作我们的工作者。Celery将用工作者的ID替换`%n`。'
- en: '`ExecStop`: This is the command that will be executed to stop our Celery workers,
    based on their PID files.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecStop`: 这是将根据它们的PID文件执行的命令，用于停止我们的Celery工作者。'
- en: '`ExecReload`: This is the command that will be executed to restart our Celery
    workers. Celery supports a `restart` command, so we will use that to perform the
    restart. However, this command must receive the same options as our `ExecStart`
    command.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecReload`: 这是将执行的命令，用于重新启动我们的Celery工作者。Celery支持`restart`命令，因此我们将使用它来执行重新启动。但是，此命令必须接收与我们的`ExecStart`命令相同的选项。'
- en: 'We''ll be placing our PID files in `/var/run/celery`, but we will need to make
    sure that the directory is created. `/var/run` is a special directory, which doesn''t
    use a regular filesystem. We''ll need to create a configuration file to tell Ubuntu
    to create `/var/run/celery`. Let''s create this file in `ubuntu/tmpfiles-celery.conf`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的PID文件放在`/var/run/celery`中，但我们需要确保该目录已创建。`/var/run`是一个特殊目录，不使用常规文件系统。我们需要创建一个配置文件，告诉Ubuntu创建`/var/run/celery`。让我们在`ubuntu/tmpfiles-celery.conf`中创建这个文件：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This tells Ubuntu to create a directory, `/run/celery`, owned by the Apache
    user (`www-data`).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Ubuntu创建一个由Apache用户（`www-data`）拥有的目录`/run/celery`。
- en: 'Finally, let''s create a script to put all these files in the right places
    on our server. We''ll name this script `scripts/configure_celery.sh`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个脚本，将所有这些文件放在服务器的正确位置。我们将把这个脚本命名为`scripts/configure_celery.sh`：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that Celery and Apache are configured, let's make sure that they have the
    correct environment configuration to run Mail Ape
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Celery和Apache已配置好，让我们确保它们具有正确的环境配置来运行Mail Ape
- en: Creating the environment configuration files
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建环境配置文件
- en: 'Both our Celery and mod_wsgi Python processes will need to pull configuration
    information out of the environment to connect to the right database, SQS Queue,
    and many other services. These are settings and values we don''t want to check
    into our version control system (for example, passwords). However, we still need
    them to be set in a production environment. To create the files that define the
    environment that our processes will run in, we''ll make the script in `scripts/make_mailape_environment_ini.sh`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Celery和mod_wsgi Python进程都需要从环境中提取配置信息，以连接到正确的数据库、SQS队列和许多其他服务。这些是我们不想在版本控制系统中检查的设置和值（例如密码）。但是，我们仍然需要在生产环境中设置它们。为了创建定义我们的进程将在其中运行的环境的文件，我们将在`scripts/make_mailape_environment_ini.sh`中制作脚本：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Our `make_mailape_environment_ini.sh` script has some values hardcoded but references
    others (for example, passwords) as environment variables. We'll pass the values
    for these variables into Packer at runtime. Packer will then pass these values
    to our script.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`make_mailape_environment_ini.sh`脚本中有一些值是硬编码的，但引用了其他值（例如密码）作为环境变量。我们将在运行时将这些变量的值传递给Packer。然后Packer将这些值传递给我们的脚本。
- en: Next, let's make our Packer template to build our AMI.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们制作Packer模板来构建我们的AMI。
- en: Making a Packer template
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作Packer模板
- en: 'Packer creates an AMI based on the instructions listed in a Packer template
    file. A Packer template is a JSON file made up of three top-level keys:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Packer根据Packer模板文件中列出的指令创建AMI。Packer模板是一个由三个顶级键组成的JSON文件：
- en: '`variables`: This will let us set values (such as passwords) at runtime'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variables`: 这将允许我们在运行时设置值（例如密码）'
- en: '`builders`: This specifies the cloud platform-specific details, such as AWS
    credentials'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`builders`: 这指定了特定于云平台的详细信息，例如AWS凭据'
- en: '`provisioners`: This are the instructions Packer will execute to make our image'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`provisioners`: 这些是Packer将执行的指令，以制作我们的映像'
- en: 'Let''s create our Packer template in `packer/web_worker.json`, starting with
    the `variables` section:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`packer/web_worker.json`中创建我们的Packer模板，从`variables`部分开始：
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Under the `variables` key, we will list all the variables we want our template
    to take as the keys of JSON object. If the variable has a default value, then
    we can provide it as the value for that variable's key.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在`variables`键下，我们将列出我们希望模板作为JSON对象键接受的所有变量。如果变量有默认值，那么我们可以将其作为该变量键的值提供。
- en: 'Next, let''s add a `builders section` to configure Packer to use AWS:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个`builders`部分来配置Packer使用AWS：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'A `builders` is an array because we could use the same template to build a
    machine image on multiple platforms (for example, AWS and Google Cloud). Let''s
    take a look at each option in detail:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`builders`是一个数组，因为我们可以使用相同的模板在多个平台上构建机器映像（例如AWS和Google Cloud）。让我们详细看看每个选项：'
- en: '`"type": "amazon-ebs"`: Tells Packer we''re creating an Amazon Machine Image
    with Elastic Block Storage. This is the preferred configuration due to the flexibility
    it offers.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"type": "amazon-ebs"`: 告诉Packer我们正在创建一个带有弹性块存储的亚马逊机器映像。这是首选配置，因为它提供了灵活性。'
- en: '`"access_key": "{{user aws_access_key }}"`: This is the access key Packer should
    use to authenticate itself with AWS. Packer includes its own template language
    so that values can be generated at runtime. Any value between `{{ }}` is generated
    by the Packer template engine. The template engine offers a `user` function, which
    takes the name of the user-provided variable and returns its value. For example,
    `{{user aws_access_key }}` will be replaced by the value the user provided to
    `aws_access_key` when running Packer.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"access_key": "{{user aws_access_key }}"`: 这是Packer应该使用的访问密钥，用于与AWS进行身份验证。Packer包含自己的模板语言，以便可以在运行时生成值。`{{
    }}`之间的任何值都是由Packer模板引擎生成的。模板引擎提供了一个`user`函数，它接受用户提供的变量的名称并返回其值。例如，当运行Packer时，`{{user
    aws_access_key }}`将被用户提供给`aws_access_key`的值替换。'
- en: '`"secret_key": "{{user aws_secret_key }}"`: This is the same for the AWS Secret
    Key.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"secret_key": "{{user aws_secret_key }}"`: 这与AWS秘钥相同。'
- en: '`"region": "us-west-2"`: This specifies the AWS region. All our work will be
    done in `us-west-2`.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"region": "us-west-2"`: 这指定了AWS区域。我们所有的工作都将在`us-west-2`中完成。'
- en: '`"source_ami": "ami-78b82400"`: This is the image that we''re going to customize
    to make our image. In our case, we''re using an official Ubuntu AMI. Ubuntu offers
    an EC2 AMI locator ([http://cloud-images.ubuntu.com/locator/ec2/](http://cloud-images.ubuntu.com/locator/ec2/))
    to help find their office AMIs.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"source_ami": "ami-78b82400"`: 这是我们要定制的镜像，以制作我们的镜像。在我们的情况下，我们使用官方的Ubuntu AMI。Ubuntu提供了一个EC2
    AMI定位器（[http://cloud-images.ubuntu.com/locator/ec2/](http://cloud-images.ubuntu.com/locator/ec2/)）来帮助找到他们的官方AMI。'
- en: '`"instance_type": "t2.micro"`: This is a small inexpensive instance that, at
    the time of writing this book, falls under the AWS free tier.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"instance_type": "t2.micro"`: 这是一个小型廉价的实例，在撰写本书时，属于AWS免费套餐。'
- en: '`"ssh_username": "ubuntu"`: Packer performs all its operations on the virtual
    machine over SSH. This is the username it should use for authentication. Packer
    will generate its own key pair for authentication, so we don''t have to worry
    about specifying a password or key.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"ssh_username": "ubuntu"`: Packer通过SSH在虚拟机上执行所有操作。这是它应该用于身份验证的用户名。Packer将为身份验证生成自己的密钥对，因此我们不必担心指定密码或密钥。'
- en: '`"ami_name": "mailape-{{timestamp}}"`: The name of the resulting AMI. `{{timestamp}}`
    is a function that returns the UTC time in seconds since the Unix epoch.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"ami_name": "mailape-{{timestamp}}"`: 结果AMI的名称。`{{timestamp}}`是一个返回自Unix纪元以来的UTC时间的函数。'
- en: '`"tags": {...}`: Tagging resources makes it easier to identify resources in
    AWS. This is optional but recommended.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"tags": {...}`: 标记资源可以更容易地在AWS中识别资源。这是可选的，但建议使用。'
- en: Now that we've specified our AWS builder, we will need to specify our provisioners.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经指定了我们的AWS构建器，我们将需要指定我们的配置程序。
- en: 'Packer provisioners are the instructions that customize the server. In our
    case, we will use the following two types of provisioners:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Packer配置程序是定制服务器的指令。在我们的情况下，我们将使用以下两种类型的配置程序：
- en: '`file` provisioners to upload our code to the server'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file`配置程序用于将我们的代码上传到服务器。'
- en: '`shell` provisioners to execute our scripts and commands'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shell`配置程序用于执行我们的脚本和命令'
- en: 'First, let''s add our `make_aws_directories.sh` script, as we''ll need it to
    run first:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加我们的`make_aws_directories.sh`脚本，因为我们需要它首先运行：
- en: '[PRE32]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A `shell` provisioner with a `script` property will upload, execute, and remove
    the script. Packer provides the `{{template_dir}}` function, which returns the
    directory of template directory. This lets us avoid hardcoding absolute paths.
    The first provisioner we execute will execute the `make_aws_directories.sh` script
    we created earlier in this section.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 具有`script`属性的`shell`配置程序将上传，执行和删除脚本。Packer提供了`{{template_dir}}`函数，它返回模板目录的目录。这使我们可以避免硬编码绝对路径。我们执行的第一个配置程序将执行我们在本节前面创建的`make_aws_directories.sh`脚本。
- en: 'Now that our directories exist, let''s copy our code and files over using `file`
    provisioners:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的目录存在了，让我们使用`file`配置程序将我们的代码和文件复制过去：
- en: '[PRE33]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`file` provisioners upload local files or directories defined by `source` to
    the server at `destination`.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`file`配置程序将本地文件或由`source`定义的目录上传到`destination`服务器上。'
- en: 'Since we uploaded our Python code from our working directory, we need to be
    careful of old `.pyc` files hanging around. Let''s make sure that we delete those
    on our production server:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从工作目录上传了Python代码，我们需要小心旧的`.pyc`文件是否还存在。让我们确保在我们的生产服务器上删除这些文件：
- en: '[PRE34]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A `shell` provisioner can receive an `inline` attribute. The provisioner will
    then execute the `inline` command on the server.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`shell`配置程序可以接收`inline`属性。然后，配置程序将在服务器上执行`inline`命令。'
- en: 'Finally, let''s execute the rest of the scripts we created:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们执行我们创建的其余脚本：
- en: '[PRE35]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this case, the `shell` provisioner has received `scripts` and `environment_vars`.
    `scripts` is an array of paths to shell scripts. Each item in the array will be
    uploaded and executed. When executing each script, this `shell` provisioner will
    add the environment variables listed in `environment_vars`. The `environment_vars` parameter is
    optionally available to all `shell` provisioners to provide extra environment
    variables.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`shell`配置程序已收到`scripts`和`environment_vars`。`scripts`是指向shell脚本的路径数组。数组中的每个项目都将被上传和执行。在执行每个脚本时，此`shell`配置程序将添加`environment_vars`中列出的环境变量。`environment_vars`参数可选地提供给所有`shell`配置程序，以提供额外的环境变量。
- en: With our final provisioner added to our file, we've now finished our Packer
    template. Let's use Packer to execute the template and build our Mail Ape production
    server.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的最终配置程序添加到我们的文件中，我们现在已经完成了我们的Packer模板。让我们使用Packer来执行模板并构建我们的Mail Ape生产服务器。
- en: Running Packer to build an Amazon Machine Image
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Packer来构建Amazon Machine Image
- en: With Packer installed and a Mail Ape production server Packer template created,
    we're ready to build our **Amazon Machine Image** (**AMI**).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Packer并创建了Mail Ape生产服务器Packer模板，我们准备构建我们的**Amazon Machine Image** (**AMI**)。
- en: 'Let''s run Packer to build our AMI:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行Packer来构建我们的AMI：
- en: '[PRE36]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Packer will output the AMI ID of our new AMI image. We'll be able to use this
    AMI to launch an EC2 instance in the AWS Cloud.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Packer将输出我们新AMI镜像的AMI ID。我们将能够使用这个AMI在AWS云中启动EC2实例。
- en: If your template fails due to a missing Ubuntu package, retry the build. At
    the time of writing this book, the Ubuntu package repositories do not always update
    successfully.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的模板由于缺少Ubuntu软件包而失败，请重试构建。在撰写本书时，Ubuntu软件包存储库并不总是能够成功更新。
- en: Now that we have our AMI, we can deploy it.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了AMI，我们可以部署它了。
- en: Deploying a scalable self-healing web app on AWS
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWS上部署可扩展的自愈Web应用程序
- en: 'Now that we have our infrastructure and a deployable AMI, we can deploy Mail
    Ape on AWS. Rather than launching a single EC2 instance from our AMI, we will
    deploy our app using CloudFormation. We''ll define a set of resources that will
    let us scale our app up and down as needed. We''ll define the following three
    resources:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基础架构和可部署的AMI，我们可以在AWS上部署Mail Ape。我们将使用CloudFormation定义一组资源，让我们根据需要扩展我们的应用程序。我们将定义以下三个资源：
- en: An Elastic Load Balancer to distribute requests among our EC2 instances
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个弹性负载均衡器来在我们的EC2实例之间分发请求
- en: An AutoScaling Group to launch and terminate EC2 instances
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个AutoScaling Group来启动和终止EC2实例
- en: A LaunchConfig to describe what kind of EC2 instances to launch
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个LaunchConfig来描述要启动的EC2实例的类型
- en: First, let's make sure that we have an SSH key if we need to access any of our
    EC2 instances to troubleshoot any problems after we deploy.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们确保如果需要访问任何EC2实例来排除部署后出现的任何问题，我们有一个SSH密钥。
- en: Creating an SSH key pair
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建SSH密钥对
- en: 'To create an SSH key pair in AWS, we can use the following AWS command line:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要在AWS中创建SSH密钥对，我们可以使用以下AWS命令行：
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Ensure that you copy the `KeyMaterial` value to your SSH client's configuration
    directory (typically, `~/.ssh`)—remember to replace `\n` with actual new lines.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`KeyMaterial`的值复制到您的SSH客户端的配置目录（通常为`~/.ssh`）-记得用实际的新行替换`\n`。
- en: Next, let's start our Mail Ape deployment CloudFormation template.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们开始我们的Mail Ape部署CloudFormation模板。
- en: Creating the web servers CloudFormation template
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Web服务器CloudFormation模板
- en: 'Next, let''s create a CloudFormation template to deploy Mail Ape servers to
    the cloud. We''ll use CloudFormation to tell AWS how to scale our servers and
    relaunch them, should a disaster strike. We''ll tell CloudFormation to create
    the following three resources:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个CloudFormation模板，将Mail Ape服务器部署到云中。我们将使用CloudFormation告诉AWS如何扩展我们的服务器并在灾难发生时重新启动它们。我们将告诉CloudFormation创建以下三个资源：
- en: An **Elastic Load Balancer** (**ELB**), which will be able to distribute requests
    among our servers
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**弹性负载均衡器**（**ELB**），它将能够在我们的服务器之间分发请求
- en: A LaunchConfig, which will describe the AMI, instance type, and other details
    of the EC2 instances we want to use.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个LaunchConfig，它将描述我们想要使用的EC2实例的AMI、实例类型和其他细节。
- en: An AutoScaling Group, which will monitor to ensure that we have the right number
    of healthy EC2 instances.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个自动扩展组，它将监视以确保我们拥有正确数量的健康EC2实例。
- en: These three resources are the core of building any kind of scaling self-healing
    AWS application.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个资源是构建任何类型的可扩展自愈AWS应用程序的核心。
- en: 'Let''s start building our CloudFormation template in `cloudformation/web_worker.yaml`.
    Our new template will have the same three sections as `cloudformation/infrastracture.yaml`:
    `Parameters`, `Resources`, and `Outputs`.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`cloudformation/web_worker.yaml`开始构建我们的CloudFormation模板。我们的新模板将与`cloudformation/infrastracture.yaml`具有相同的三个部分：`Parameters`、`Resources`和`Outputs`。
- en: Lets's start by adding the `Parameters` section.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加`Parameters`部分开始。
- en: Accepting parameters in the web worker CloudFormation template
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在web worker CloudFormation模板中接受参数
- en: Our web worker CloudFormation template will accept the AMI to launch and the
    InstanceProfile to be used as parameters. This means that we won't have to hardcode
    the names of the resources we created with Packer and our infrastructure stack,
    respectively.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的web worker CloudFormation模板将接受AMI和InstanceProfile作为参数进行启动。这意味着我们不必在Packer和基础架构堆栈中分别硬编码我们创建的资源的名称。
- en: 'Let''s create our template in `cloudformation/web_worker.yaml`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`cloudformation/web_worker.yaml`中创建我们的模板：
- en: '[PRE38]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now that we have the AMI and the InstanceProfile for our EC2 instances, let's
    create our CloudFormation stack's resources.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了AMI和InstanceProfile用于我们的EC2实例，让我们创建我们的CloudFormation堆栈的资源。
- en: Creating Resources in our web worker CloudFormation template
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的web worker CloudFormation模板中创建资源
- en: Next, we'll definite the **Elastic Load Balancer** (**ELB**), Launch Config,
    and AutoScaling Group. These three resources are the core of most scalable AWS
    web applications. We'll take a look at how they interact as we build up our template.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义**弹性负载均衡器**（**ELB**）、启动配置和自动扩展组。这三个资源是大多数可扩展的AWS Web应用程序的核心。在构建模板时，我们将看看它们是如何交互的。
- en: 'First, let''s add our Load Balancer:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加我们的负载均衡器：
- en: '[PRE39]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding code, we're adding a new resource called `LoadBalancer` of
    the `AWS::ElasticLoadBalancing::LoadBalancer`  type. An ELB needs a name (`MailApeLB`)
    and a list of `Listeners`. Each `Listeners` entry should define the port our ELB
    is listening on (`LoadBalancerPort`, the instance port the request will be forwarded
    to (`InstancePort`), and the protocol the port will use (in our case, `HTTP`).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们正在添加一个名为`LoadBalancer`的新资源，类型为`AWS::ElasticLoadBalancing::LoadBalancer`。ELB需要一个名称（`MailApeLB`）和一个`Listeners`列表。每个`Listeners`条目应定义我们的ELB正在监听的端口（`LoadBalancerPort`）、请求将被转发到的实例端口（`InstancePort`）以及端口将使用的协议（在我们的情况下是`HTTP`）。
- en: An ELB will be responsible for distributing HTTP requests across however many
    EC2 instances we launch to handle our load.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 一个ELB将负责在我们启动来处理负载的任意数量的EC2实例之间分发HTTP请求。
- en: 'Next, we''ll create a LaunchConfig to tell AWS how to launch a new Mail Ape
    web worker:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个LaunchConfig，告诉AWS如何启动一个新的Mail Ape web worker：
- en: '[PRE40]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'A Launch Config is of the `AWS::AutoScaling::LaunchConfiguration` type and
    describes the configuration of a new EC2 instance that an Auto Scaling Group should
    launch. Let''s go through all the `Properties` to ensure that we understand what
    they mean:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Launch Config是`AWS::AutoScaling::LaunchConfiguration`类型的，描述了自动扩展组应该启动的新EC2实例的配置。让我们逐个查看所有的`Properties`，以确保我们理解它们的含义：
- en: '`ImageId`: This is the ID of the AMI we want the instances to run. In our case,
    we''re using the `Ref` function to get the AMI ID from the `WorkerAMI` parameter.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageId`：这是我们希望实例运行的AMI的ID。在我们的情况下，我们使用`Ref`函数从`WorkerAMI`参数获取AMI ID。'
- en: '`KeyName`: This is the name of the SSH key that will be added to this machine.
    This is useful if we ever need to troubleshoot something live. In our case, we''re
    using the name of the SSH key pair we created earlier in this chapter.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeyName`：这是将添加到此机器的SSH密钥的名称。如果我们需要实时排除故障，这将非常有用。在我们的情况下，我们使用了本章早期创建的SSH密钥对的名称。'
- en: '`SecurityGroups`: This is a list of Security Group names that define what ports
    AWS is to open. In our case, we''re listing the names of the web and SSH groups
    we created in our infrastructure stack.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SecurityGroups`：这是一个定义AWS要打开哪些端口的安全组名称列表。在我们的情况下，我们列出了我们在基础架构堆栈中创建的web和SSH组的名称。'
- en: '`InstanceType`: This indicates the instance type of our EC2 instances. An instance
    type defines the computing and memory resources available to our EC2 instance.
    In our case, we''re using a very small affordable instance that is (at the time
    of writing this book) covered by the AWS Free Tier during the first year.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InstanceType`：这表示我们的EC2实例的实例类型。实例类型定义了可用于我们的EC2实例的计算和内存资源。在我们的情况下，我们使用的是一个非常小的经济实惠的实例，（在撰写本书时）在第一年内由AWS免费使用。'
- en: '`IamInstanceProfile`: This indicates the `InstanceProfile` for our EC2 instances.
    Here, we''re using the `Ref` function to reference the `InstanceProfile` parameter.
    When we create our stack, we''ll use the ARN of the InstanceProfile we created
    earlier that gives our EC2 instances access to SQS.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IamInstanceProfile`：这表示我们的EC2实例的`InstanceProfile`。在这里，我们使用`Ref`函数来引用`InstanceProfile`参数。当我们创建我们的堆栈时，我们将使用我们早期创建的InstanceProfile的ARN，该ARN为我们的EC2实例访问SQS提供了访问权限。'
- en: 'Next, we''ll define the AutoScaling Group that launches the EC2 instances that
    the Launch Config describes to serve requests forwarded by the ELB:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义启动由ELB转发的请求的EC2实例的AutoScaling组：
- en: '[PRE41]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Our new **Auto Scaling Group** (**ASG**) is of the `AWS::AutoScaling::AutoScalingGroup`
     type. Let''s go through its properties:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新**自动扩展组**（**ASG**）是`AWS::AutoScaling::AutoScalingGroup`类型。让我们来看看它的属性：
- en: '`LaunchConfigurationName`: This is the name of the `LaunchConfiguration` this
    ASG should use when launching new instances. In our case, we use the `Ref` function
    to reference `LaunchConfig`, the Launch Configuration we created above.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LaunchConfigurationName`：这是此ASG在启动新实例时应该使用的`LaunchConfiguration`的名称。在我们的情况下，我们使用`Ref`函数来引用我们上面创建的`LaunchConfig`，即启动配置。'
- en: '`MinSize`/`MaxSize`: These are the attributes required that set the maximum
    and minimum number of instances this group may contain. These values protect us
    from accidentally deploying too many instances that may negatively affect either
    our system or our monthly bill. In our case, we make sure that there is at least
    one (`1`) instance but no more than three (`3`).'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MinSize`/`MaxSize`：这些是所需的属性，设置此组可能包含的实例的最大和最小数量。这些值可以保护我们免受意外部署太多实例可能对我们的系统或每月账单产生负面影响。在我们的情况下，我们确保至少有一个（`1`）实例，但不超过三（`3`）个。'
- en: '`DesiredCapacity`: This tells our system how many ASG and how many healthy
    EC2 instances should be running this ASG. If an instance fails and brings the
    number of healthy instances below the `DesiredCapacity` value, then ASG will use
    its Launch Configuration to launch more instances.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DesiredCapacity`：这告诉我们的系统应该运行多少ASG和多少健康的EC2实例。如果一个实例失败并将健康实例的数量降到`DesiredCapacity`值以下，那么ASG将使用其启动配置来启动更多实例。'
- en: '`LoadBalancerNames`: This is a list of ELBs that can route requests to the
    instances launched by this ASG. When a new EC2 instance becomes a part of this
    ASG, it will also be added to the list of instances the named ELBs route requests
    to. In our case, we use the `Ref` function to reference the ELB we defined earlier
    in this template.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadBalancerNames`：这是一个ELB的列表，可以将请求路由到由此ASG启动的实例。当新的EC2实例成为此ASG的一部分时，它也将被添加到命名ELB路由请求的实例列表中。在我们的情况下，我们使用`Ref`函数来引用我们在模板中早期定义的ELB。'
- en: These three tools work together to help us make our Django app scale quickly
    and smoothly. The ASG gives us a way of saying how many Mail Ape EC2 instances
    we want running. The Launch Config describes how to launch a new Mail Ape EC2
    instance. The ELB will then distribute the requests to all the instances that
    the ASG launched.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个工具共同帮助我们快速而顺利地扩展我们的Django应用程序。ASG为我们提供了一种说出我们希望运行多少Mail Ape EC2实例的方法。启动配置描述了如何启动新的Mail
    Ape EC2实例。然后ELB将把请求分发到ASG启动的所有实例。
- en: Now that we have our resources, let's output some of the most relevant data
    to make the rest of our deployment easy.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的资源，让我们输出一些最相关的数据，以使我们的部署其余部分变得容易。
- en: Outputting resource names
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出资源名称
- en: The final section we'll add to our CloudFormation template is `Outputs` to make
    it easier to note the address of our ELB and the name of our ASG. We'll need the
    address of our ELB to add a CNAME record to `mailape.example.com`. We'll need
    the name of our ASG if we need to access our instances (for example, to run our
    migrations).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加到我们的CloudFormation模板的最后一部分是`Outputs`，以便更容易地记录我们的ELB的地址和我们的ASG的名称。我们需要我们ELB的地址来向`mailape.example.com`添加CNAME记录。如果我们需要访问我们的实例（例如，运行我们的迁移），我们将需要我们ASG的名称。
- en: 'Let''s update `cloudformation/web_worker.yaml` with an `Outputs` section:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个`Outputs`部分更新`cloudformation/web_worker.yaml`：
- en: '[PRE42]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The value of `LoadBalancerDNS` will be the DNS name of the ELB we created above.
    The value of `AutoScalingGroupName` will be our ASG, which returns the name of
    the ASG.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadBalancerDNS`的值将是我们上面创建的ELB的DNS名称。`AutoScalingGroupName`的值将是我们的ASG，返回ASG的名称。'
- en: Next, let's create a stack for our Mail Ape 1.0 release.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为我们的Mail Ape 1.0版本创建一个堆栈。
- en: Creating the Mail Ape 1.0 release stack
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Mail Ape 1.0版本堆栈
- en: 'Now that we have our Mail Ape web worker CloudFormation template, we can create
    a CloudFormation stack. When we create the stack, the stack will create its related
    resources such as the ELB, ASG, and Launch Config. We''ll use the AWS CLI to create
    our stack:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的Mail Ape web worker CloudFormation模板，我们可以创建一个CloudFormation堆栈。创建堆栈时，堆栈将创建其相关资源，如ELB、ASG和Launch
    Config。我们将使用AWS CLI来创建我们的堆栈：
- en: '[PRE43]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding command looks very similar to the one we executed to create our
    infrastructure stack, but there are a couple of differences:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令看起来与我们执行创建基础设施堆栈的命令非常相似，但有一些区别：
- en: '`--stack-name`: This is the name of the stack we''re creating.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --stack-name：这是我们正在创建的堆栈的名称。
- en: '`--template-body "file:///path/..."`: This is a `file://` URL with an absolute
    path to our CloudFormation template. Since the path prefix ends with two `/` and
    a Unix path starts with a `/`, we get a weird looking triple `/` here.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --template-body "file:///path/..."：这是一个`file://` URL，其中包含我们的CloudFormation模板的绝对路径。由于路径前缀以两个`/`和Unix路径以`/`开头，因此这里会出现一个奇怪的三重`/`。
- en: '`--parameters`: This template takes two parameters. We can provide them in
    any order, but we must provide both.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --parameters：这个模板需要两个参数。我们可以以任何顺序提供它们，但必须同时提供。
- en: '`"ParameterKey=WorkerAMI, ParameterValue=`: For `WorkerAMI`, we must provide
    the AMI ID that Packer gave us.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"ParameterKey=WorkerAMI, ParameterValue=`：对于`WorkerAMI`，我们必须提供Packer给我们的AMI
    ID。'
- en: '`"ParameterKey=InstanceProfile,ParameterValue`: For InstanceProfile, we must
    provide the Instance Profile ARN that our infrastructure stack output.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"ParameterKey=InstanceProfile,ParameterValue`：对于InstanceProfile，我们必须提供我们的基础设施堆栈输出的Instance
    Profile ARN。'
- en: '`--region us-west-2`: We''re doing all our work in the `us-west-2` region.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --region us-west-2：我们所有的工作都在`us-west-2`地区进行。
- en: 'To take a look at our stack''s outputs, we can use the `describe-stack` command
    from the AWS CLI:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们堆栈的输出，我们可以使用AWS CLI的`describe-stack`命令：
- en: '[PRE44]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The result is a large JSON object; here is a slightly truncated example version:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个大的JSON对象；这里是一个略有缩短的示例版本：
- en: '[PRE45]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Our resources (for example, EC2 instances) won't be ready until `StackStatus`
    is `CREATE_COMPLETE`. It can take a few minutes to create all the relevant resources.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的资源（例如EC2实例）直到`StackStatus`为`CREATE_COMPLETE`时才会准备就绪。创建所有相关资源可能需要几分钟。
- en: 'We''re particularly interested in the objects in the `Outputs` array:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特别关注`Outputs`数组中的对象：
- en: The first value gives us the name of our ASG. With the name of our ASG, we'll
    be able to find the EC2 instances in that ASG in case we need to SSH into one.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个值给出了我们的ASG的名称。有了我们ASG的名称，我们就能够找到该ASG中的EC2实例，以防需要SSH到其中一个。
- en: The second value gives us the DNS name of our ELB. We'll use our ELB's DNS to
    create CNAME record for our production DNS record so that we redirect our traffic
    here (for example, creating a CNAME record for `mailape.example.com` to redirect
    traffic to our ELB).
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个值给出了我们ELB的DNS名称。我们将使用我们ELB的DNS来为我们的生产DNS记录创建CNAME记录，以便将我们的流量重定向到这里（例如，为`mailape.example.com`创建一个CNAME记录，将流量重定向到我们的ELB）。
- en: Let's look at how to SSH into the EC2 instances that our ASG launched.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何SSH到我们的ASG启动的EC2实例。
- en: SSHing into a Mail Ape EC2 Instance
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSH到Mail Ape EC2实例
- en: 'The AWS CLI gives us many ways of getting information about our EC2 Instances.
    Let''s find the address of our launched EC2 instance:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CLI为我们提供了许多获取有关我们EC2实例信息的方法。让我们找到我们启动的EC2实例的地址：
- en: '[PRE46]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `aws ec2 describe-instances` command will return a lot of information about
    all our EC2 instances. We can use the `--filters` command to restrict the EC2
    instances returned. When we create a stack, many of the related resources are
    tagged with the stack name. This lets us filter for only those EC2 instances in
    our `mail_ape_1_0` stack.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`aws ec2 describe-instances`命令将返回关于所有EC2实例的大量信息。我们可以使用`--filters`命令来限制返回的EC2实例。当我们创建一个堆栈时，许多相关资源都带有堆栈名称的标记。这使我们可以仅筛选出我们`mail_ape_1_0`堆栈中的EC2实例。'
- en: 'The following is a (much) shortened version of the output:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出的（大大）缩短版本：
- en: '[PRE47]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the preceding output, note the `PublicDnsName` and the `KeyName`. Since
    we created that key earlier in this chapter, we can SSH into this instance:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，请注意`PublicDnsName`和`KeyName`。由于我们在本章前面创建了该密钥，我们可以SSH到这个实例：
- en: '[PRE48]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Remember that the `XXX` you see in the preceding output will be replaced by
    real values in your system.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您在前面的输出中看到的`XXX`将在您的系统中被实际值替换。
- en: Now that we can SSH into the system, we can create and migrate our database.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以SSH到系统中，我们可以创建和迁移我们的数据库。
- en: Creating and migrating our database
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和迁移我们的数据库
- en: 'For our first release we first need to create our database. To create our database
    we''re going to create a script in `database/make_database.sh`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个发布，我们首先需要创建我们的数据库。为了创建我们的数据库，我们将在`database/make_database.sh`中创建一个脚本：
- en: '[PRE49]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This script uses three variables from its environment:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本使用其环境中的三个变量：
- en: '`$USER`: The Postgres master user username. We defined this as `master` in
    our `cloudformation/infrastructure.yaml`.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: $USER：Postgres主用户用户名。我们在`cloudformation/infrastructure.yaml`中将其定义为`master`。
- en: '`$PASSWORD`: The Postgres master user''s password. We provided this as a parameter
    for when we created the `infrastructure` stack.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: $PASSWORD：Postgres主用户的密码。我们在创建`infrastructure`堆栈时将其作为参数提供。
- en: '`$DJANGO_DB_PASSWORD`: This is the password for the Django database. We provided
    this as a parameter to Packer when creating our AMI.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: $DJANGO_DB_PASSWORD：这是Django数据库的密码。我们在创建AMI时将其作为参数提供给Packer。
- en: 'Next, we''ll execute this script locally by providing the values as variables:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过提供变量来在本地执行此脚本：
- en: '[PRE50]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Our Mail Ape database is now created.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Mail Ape数据库现在已经创建。
- en: 'Next, let''s SSH into our new EC2 instance and run our database migrations:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们SSH到我们的新EC2实例并运行我们的数据库迁移：
- en: '[PRE51]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Our `manage.py migrate` command is very similar to what we've used in previous
    chapters. The main difference here is that we needed to SSH into our production
    EC2 instance first.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`manage.py migrate`命令与我们在以前章节中使用的非常相似。这里的主要区别在于我们需要首先SSH到我们的生产EC2实例。
- en: When `migrate` returns success, our database is ready and we're good to release
    our app.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当`migrate`返回成功时，我们的数据库已经准备好，我们可以发布我们的应用程序了。
- en: Releasing Mail Ape 1.0
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布Mail Ape 1.0
- en: Now that we've migrated our database, we're ready to update the DNS records
    of `mailape.example.com` to point to our ELB's DNS records. Once the DNS records
    propagate, Mail Ape will be live.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经迁移了我们的数据库，我们准备更新`mailape.example.com`的DNS记录，指向我们ELB的DNS记录。一旦DNS记录传播，Mail
    Ape就会上线。
- en: Congratulations!
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！
- en: Scaling up and down with update-stack
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用update-stack进行扩展和缩小
- en: One of the great things about using CloudFormation and Auto Scaling Groups is
    that it's easy to scale our system up and down. In this section, let's update
    our system to use two EC2 instances running Mail Ape.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CloudFormation和Auto Scaling Groups的一个很棒的地方是，很容易扩展我们的系统。在本节中，让我们更新我们的系统，使用两个运行Mail
    Ape的EC2实例。
- en: 'We can update our CloudFormation template in `cloudformation/web_worker.yaml`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`cloudformation/web_worker.yaml`中更新我们的CloudFormation模板：
- en: '[PRE52]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We''ve updated our `DesiredCapacity` from 1 to 2\. Now, instead of creating
    a new stack, let''s update our existing stack:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`DesiredCapacity`从1更新为2。现在，我们不再创建新的堆栈，而是更新现有的堆栈：
- en: '[PRE53]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The preceding command looks much like our `create-stack` command. One convenient
    difference is that we don't need to provide the parameter values again—we can
    simply inform `UsePreviousValue=true` to tell AWS to reuse the same values as
    before.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令看起来很像我们的`create-stack`命令。一个方便的区别是我们不需要再次提供参数值 - 我们可以简单地通知`UsePreviousValue=true`告诉AWS重用之前的相同值。
- en: 'Again, `describe-stack` will tell us when our update is complete:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`describe-stack`会告诉我们更新何时完成：
- en: '[PRE54]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The result is a large JSON object—here is a truncated example version:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个大型的JSON对象 - 这里是一个截断的示例版本：
- en: '[PRE55]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Once our `StackStatus` is `UPDATE_COMPLETE`, our ASG will be updated with a
    new setting. It can take a couple minutes for the ASG to launch the new EC2 instance,
    but we can use our previously created `describe-instances` command to look for
    it:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的`StackStatus`为`UPDATE_COMPLETE`，我们的ASG将使用新的设置进行更新。ASG可能需要几分钟来启动新的EC2实例，但我们可以使用我们之前创建的`describe-instances`命令来查找它：
- en: '[PRE56]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Eventually, it will return two instances. Here''s a highly truncated version
    of what that output will look like:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，它将返回两个实例。以下是输出的高度截断版本：
- en: '[PRE57]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: To scale down to one instance, just update your `web_worker.yaml` template and
    run `update-stack` again.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 要缩小到一个实例，只需更新您的`web_worker.yaml`模板并再次运行`update-stack`。
- en: Congratulations! You now know how to scale Mail Ape up to handle a higher load
    and then scale back down during off peak periods.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您现在知道如何将Mail Ape扩展到处理更高的负载，然后在非高峰时期缩小规模。
- en: Remember that Amazon charges are based on usage. If you scaled up as part of
    working through this book, remember to scale back down or you may be charged more
    than you expect. Ensure that you read up on the limits of the AWS free tier on
    [https://aws.amazon.com/free/](https://aws.amazon.com/free/).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，亚马逊的收费是基于使用情况的。如果您在阅读本书的过程中进行了扩展，请记住要缩小规模，否则您可能会被收取比预期更多的费用。确保您阅读关于AWS免费套餐限制的信息[https://aws.amazon.com/free/](https://aws.amazon.com/free/)。
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've taken our Mail Ape app and launched it into a production
    environment in the AWS Cloud. We've used AWS CloudFormation to declare our AWS
    resources as code, making it as easy to track what we need and what changed as
    in the rest of our code base. We've built the image of our Mail Ape servers run
    using Packer, again giving us the ability to track our server configuration as
    code. Finally, we launched Mail Ape into the cloud and learned how to scale it
    up and down.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将我们的Mail Ape应用程序并在AWS云中的生产环境中启动。我们使用AWS CloudFormation将我们的AWS资源声明为代码，使得跟踪我们需要的内容和发生了什么变化就像在我们的代码库的其余部分一样容易。我们使用Packer构建了我们的Mail
    Ape服务器运行的镜像，再次使我们能够将我们的服务器配置作为代码进行跟踪。最后，我们将Mail Ape启动到云中，并学会了如何进行扩展和缩小。
- en: Now that we've come to the end of our journey learning to build Django web applications,
    let's review some of what we've learned. Over three projects we've seen how Django
    organizes code into models, views, and templates. We've learned how to do input
    validation with Django's form class and with Django Rest Framework's Serializer
    classes. We've examined security best practices, caching, and how to send emails.
    We've seen how to take our code and deploy into Linux servers, Docker containers,
    and the AWS Cloud.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了学习构建Django Web应用程序的旅程，让我们回顾一下我们学到的一些东西。在三个项目中，我们看到了Django如何将代码组织成模型、视图和模板。我们学会了如何使用Django的表单类和Django
    Rest Framework的序列化器类进行输入验证。我们审查了安全最佳实践、缓存以及如何发送电子邮件。我们看到了如何将我们的代码部署到Linux服务器、Docker容器和AWS云中。
- en: You're ready to take your idea and launch it with Django! Go for it!
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经准备好使用Django来实现您的想法了！加油！
