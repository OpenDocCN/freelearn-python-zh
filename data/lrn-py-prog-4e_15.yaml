- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: CLI Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行应用程序
- en: A user interface is like a joke. If you have to explain it, it’s not that good.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用户界面就像一个笑话。如果你不得不解释它，那就不是很好。
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Martin LeBlanc
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: – 马丁·勒布兰
- en: In this chapter, we are going to learn how to create **Command-Line Interface**
    ( **CLI** ) applications, also known as **Command-Line Applications** , in Python.
    A CLI is a user interface where users type commands into a console or terminal.
    Notable examples include the **Bash** and **Zsh** shells on macOS, Linux, and
    other UNIX-based operating systems, and the Windows **Command Prompt** and **PowerShell**
    . A CLI application is an application that is primarily used in such a command-line
    shell environment. One executes a CLI application by typing a command, possibly
    followed by some arguments, into the shell.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何在Python中创建**命令行界面**（**CLI**）应用程序，也称为**命令行应用程序**。CLI是一种用户界面，用户可以在控制台或终端中输入命令。显著的例子包括macOS、Linux和其他基于UNIX操作系统的**Bash**和**Zsh**外壳，以及Windows的**命令提示符**和**PowerShell**。CLI应用程序是在这种命令行外壳环境中主要使用的应用程序。通过在shell中输入一个命令（可能后跟一些参数）来执行CLI应用程序。
- en: Although **Graphical User Interfaces** ( **GUIs** ) and web applications are
    far more popular, CLI applications still have their place. They are especially
    popular among developers, system administrators, network administrators, and other
    technical users. There are several reasons for this popularity. Once you are familiar
    with the required commands, you can often perform a task much faster by typing
    commands into a CLI than by clicking through menus and buttons in a GUI. Most
    shells also allow connecting the output of one command directly to the input of
    another. This is called piping, and it allows users to combine simple commands
    into data processing pipelines to perform more complex tasks. Sequences of commands
    can be saved in scripts, allowing for repeatability and automation. It is also
    easier to document instructions to perform a task by providing exact commands
    to type, rather than explaining how to navigate a GUI or web interface.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然图形用户界面（**GUIs**）和Web应用程序更为流行，但命令行应用程序仍然有其位置。它们在开发者、系统管理员、网络管理员和其他技术用户中特别受欢迎。这种受欢迎的原因有几个。一旦你熟悉了所需的命令，你通常可以通过在CLI中输入命令而不是在GUI的菜单和按钮中点击来更快地完成任务。大多数shell还允许将一个命令的输出直接连接到另一个命令的输入。这被称为管道，它允许用户将简单的命令组合成数据处理管道以执行更复杂的任务。命令序列可以保存在脚本中，从而实现可重复性和自动化。通过提供确切的要输入的命令来执行任务，而不是解释如何导航GUI或Web界面，也更容易记录执行任务的说明。
- en: CLI applications are much faster and easier to develop and maintain than graphical
    or web interfaces. For this reason, development teams sometimes prefer to implement
    tools for internal use as CLI applications. This allows them to reduce the time
    and effort spent on building internal tools and focus more on customer-facing
    features. Learning how to build command-line applications is also an excellent
    stepping stone toward learning how to build more complex software, such as GUI
    applications or distributed applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行应用程序比图形或Web界面更快、更容易开发和维护。因此，开发团队有时更愿意将工具作为命令行应用程序来实现，以便减少构建内部工具的时间和精力，并更多地关注面向客户的功能。学习如何构建命令行应用程序也是学习如何构建更复杂软件（如GUI应用程序或分布式应用程序）的绝佳跳板。
- en: 'In this chapter, we will create a command-line application for interacting
    with the railway API we studied in the previous chapter. We will use this project
    to explore the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个命令行应用程序，用于与我们在上一章中学习的铁路API进行交互。我们将利用这个项目来探讨以下主题：
- en: Parsing command-line arguments
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析命令行参数
- en: Structuring a CLI application by breaking it down into sub-commands
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过分解为子命令来构建CLI应用程序的结构
- en: Securely dealing with passwords
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全处理密码
- en: We will end the chapter with some suggestions for further resources where you
    can learn more about CLI applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章结束时提供一些进一步资源建议，你可以在那里了解更多关于命令行应用程序的信息。
- en: Command-line arguments
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行参数
- en: The primary user interface of a CLI application consists of the arguments that
    can be passed to it on the command line. Before we start exploring the railway
    CLI project, let us take a brief look at command-line arguments and the mechanisms
    Python provides for working with them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行应用程序的主要用户界面由可以传递给它的命令行参数组成。在我们开始探索铁路CLI项目之前，让我们简要地了解一下命令行参数以及Python提供用于处理它们的机制。
- en: Most applications accept various **options** (or **flags** ) as well as **positional
    arguments** . Some applications consist of several **sub-commands** , each of
    which has its own distinct set of options and positional arguments.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序接受各种**选项**（或**标志**）以及**位置参数**。一些应用程序由几个**子命令**组成，每个子命令都有自己的独特选项和位置参数。
- en: Positional arguments
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位置参数
- en: 'Positional arguments represent the main data or objects that the application
    should operate on. They must be provided in a specific order and are usually not
    optional. For example, consider the command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 位置参数表示应用程序应操作的主要数据或对象。它们必须按特定顺序提供，通常不是可选的。例如，考虑以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command will create a copy of the file `original.txt` , named `copy.txt`
    . Both positional arguments ( `original.txt` and `copy.txt` ) are required, and
    changing their order would change the meaning of the command.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建一个名为 `copy.txt` 的 `original.txt` 文件的副本。必须提供两个位置参数（`original.txt` 和 `copy.txt`），改变它们的顺序将改变命令的含义。
- en: Options
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选项
- en: 'Options are used to modify the behavior of an application. They are normally
    optional and typically consist either of a single letter prefixed with a hyphen
    or a word prefixed with two hyphens. Options do not need to appear in any particular
    order or position on the command line. They can even be placed after or between
    the positional arguments. For example, many applications accept a `-v` or `--verbose`
    option to enable verbose output. Some options behave like switches, turning some
    feature on (or off) simply by their presence (or absence). Other options require
    an additional argument as a value. For example, consider the command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 选项用于修改应用程序的行为。它们通常是可选的，通常由一个带有一个连字符的单个字母或带有两个连字符的单词组成。选项不需要出现在命令行的任何特定顺序或位置。它们甚至可以放在位置参数之后或之间。例如，许多应用程序接受
    `-v` 或 `--verbose` 选项以启用详细输出。一些选项的行为类似于开关，仅通过其存在（或不存在）来简单地打开（或关闭）某些功能。其他选项需要额外的参数作为值。例如，考虑以下命令：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will recursively descend into the current directory and search for the
    string `hello` in all files whose names do not end with `.txt` . The `-r` option
    causes grep to recursively search a directory. Without this option, it would exit
    with an error when asked to search a directory instead of a regular file. The
    `--exclude` option requires a filename pattern ( `'*.txt'` ) as an argument and
    causes grep to exclude files matching the pattern from the search.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将递归地进入当前目录，并在所有不以 `.txt` 结尾的文件中搜索字符串 `hello`。`-r` 选项使 grep 递归地搜索目录。如果没有此选项，当被要求搜索目录而不是常规文件时，它会退出并显示错误。`--exclude`
    选项需要一个文件名模式（`'*.txt'`）作为参数，并导致 grep 排除与模式匹配的文件从搜索中。
- en: On Windows, options are traditionally prefixed with a forward-slash character
    ( `/` ) rather than a hyphen. However, many modern and cross-platform applications
    use hyphens for consistency with other operating systems.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，选项传统上以正斜杠字符（`/`）作为前缀，而不是连字符。然而，许多现代和跨平台的应用程序使用连字符以与其他操作系统保持一致性。
- en: Sub-commands
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子命令
- en: Complex applications are often divided into several sub-commands. The **Git**
    revision control system is an excellent example of this. For example, consider
    the commands
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的应用程序通常被分为几个子命令。**Git** 版本控制系统是这一点的绝佳例子。例如，考虑以下命令
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: and
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以及
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `commit` and `ls-files` are sub-commands of the `git` application. The
    `commit` sub-command creates a new commit, using the text passed as an argument
    to the `-m` option ( `"Fix some bugs"` ) as the commit message. The `ls-files`
    command shows information about files in a Git repository. The `-m` option to
    `ls-files` instructs the command to only show files with modifications that have
    not been staged for committing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`commit` 和 `ls-files` 是 `git` 应用程序的子命令。`commit` 子命令创建一个新的提交，使用传递给 `-m` 选项（`"Fix
    some bugs"`）的文本作为提交信息。`ls-files` 命令显示 Git 仓库中文件的信息。`-m` 选项对 `ls-files` 指示命令仅显示尚未提交的修改的文件。
- en: The use of sub-commands helps to structure and organize the application interface,
    making it easier for users to find the features they need. Each sub-command can
    also have its own help messages, which means users can more easily learn how to
    use a feature without needing to read the full documentation for the entire application.
    It also promotes the modularity of the code, which improves maintainability and
    allows adding new commands without modifying existing code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 子命令的使用有助于结构化和组织应用程序界面，使用户更容易找到他们需要的功能。每个子命令也可以有自己的帮助信息，这意味着用户可以更容易地学习如何使用一个功能，而无需阅读整个应用程序的完整文档。它还促进了代码的模块化，这提高了可维护性，并允许在不修改现有代码的情况下添加新命令。
- en: Argument parsing
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数解析
- en: 'Python applications can access the command-line arguments passed to them via
    `sys.argv` . Let us write a simple script that just prints the value of `sys.argv`
    :'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Python应用程序可以通过`sys.argv`访问传递给它们的命令行参数。让我们编写一个简单的脚本，只打印`sys.argv`的值：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we run this without passing any arguments, the output looks as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不传递任何参数运行此脚本时，输出如下所示：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we pass some arguments, we get the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递一些参数，我们会得到以下结果：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, `sys.argv` is a list of strings. The first element is the command
    used to run the application. The remaining elements contain the command-line arguments.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`sys.argv`是一个字符串列表。第一个元素是运行应用程序使用的命令。其余元素包含命令行参数。
- en: Simple applications that do not accept any options can simply extract positional
    arguments directly from `sys.argv` . For applications that do take options, however,
    the argument parsing logic can get complicated. Fortunately, the `argparse` module
    in the Python standard library provides a command-line argument parser that makes
    it easy to parse arguments without needing to write any complicated logic.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 不接受任何选项的简单应用程序可以直接从`sys.argv`中提取位置参数。然而，对于接受选项的应用程序，参数解析逻辑可能会变得复杂。幸运的是，Python标准库中的`argparse`模块提供了一个命令行参数解析器，这使得解析参数变得容易，而无需编写任何复杂的逻辑。
- en: There are several third-party library alternatives to `argparse` . We will not
    cover any of these in this chapter, but we will provide some links for a few of
    the most popular ones at the end.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个第三方库可以作为`argparse`的替代方案。在本章中，我们不会介绍这些库，但我们将提供一些链接到一些最受欢迎的库。
- en: For example, we have written a script that takes `name` and `age` as positional
    arguments and prints out a greeting. Given the name `Heinrich` and age `42` ,
    it should print `"Hi Heinrich. You are 42 years old."` It accepts a custom greeting
    to use instead of `"Hi"` , via the `-g` option. Adding `-r` or `--reverse` to
    the command line results in reversing the message before printing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们编写了一个脚本，它接受`name`和`age`作为位置参数，并打印出问候语。给定名字`Heinrich`和年龄`42`，它应该打印出`"Hi
    Heinrich. You are 42 years old."`。它接受一个自定义的问候语来代替`"Hi"`，通过`-g`选项。在命令行中添加`-r`或`--reverse`会导致在打印之前反转信息。
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let us take a closer look at the `parse_arguments()` function. We start by creating
    an instance of the `ArgumentParser` class. Then, we proceed to define the arguments
    we accept by calling the `add_argument()` method. We start with the `name` and
    `age` positional arguments, providing help strings for each and specifying that
    `age` must be an integer. If no `type` is specified, the arguments will be parsed
    as strings. The next argument is an option, which can be specified on the command
    line as either `-r` or `--reverse` . The last argument is the `"-g"` option, with
    the default value `"` `Hi"` . Finally, we call the `parse_args()` method of the
    parser, to parse the command-line arguments. This will return a `Namespace` object
    containing the argument values parsed from the command line.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看`parse_arguments()`函数。我们首先创建`ArgumentParser`类的实例。然后，我们通过调用`add_argument()`方法来定义我们接受的参数。我们从`name`和`age`位置参数开始，为每个参数提供帮助字符串，并指定`age`必须是一个整数。如果没有指定`type`，则参数将被解析为字符串。下一个参数是一个选项，可以在命令行上指定为`-r`或`--reverse`。最后一个参数是`"-g"`选项，默认值为`"``Hi"`。最后，我们调用解析器的`parse_args()`方法，以解析命令行参数。这将返回一个包含从命令行解析的参数值的`Namespace`对象。
- en: The `action` keyword argument to `add_argument()` defines how the parser should
    process the corresponding command-line argument. The default action, if none is
    specified, is `"store"` , which stores the value provided on the command line
    as an attribute on the object returned when parsing the arguments. The `"store_true"`
    action means that the option will be treated as a switch. If it is present on
    the command line, the parser will store the value `True` ; if it is absent, we
    get `False` . The `dest` keyword argument specifies the name of the attribute
    in which the value will be stored. If `dest` is not specified, the parser defaults
    to using the name of a positional argument, or the first long option string for
    option arguments (with the leading `--` removed). If only a short option string
    is provided, that is used (with the `-` removed).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_argument()` 函数的 `action` 关键字参数定义了解析器应该如何处理相应的命令行参数。如果没有指定，默认的行为是 `"store"`，这意味着将命令行提供的值存储为解析参数时返回的对象的属性。`"store_true"`
    行为意味着该选项将被视为一个开关。如果它在命令行上存在，解析器将存储值 `True`；如果不存在，我们得到 `False`。`dest` 关键字参数指定了将存储值的属性的名称。如果没有指定
    `dest`，解析器默认使用位置参数的名称，或者选项参数的第一个长选项字符串（去除前导 `--`）。如果只提供了一个短选项字符串，则使用该字符串（去除前导
    `-`）。'
- en: Let us see what happens when we run this script.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看运行此脚本会发生什么。
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we provide incorrect arguments, we get a `usage` message indicating what
    the expected arguments are, as well as an error message telling us what we did
    wrong:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供错误的参数，我们会得到一个 `usage` 消息，指示预期的参数是什么，以及一个错误消息告诉我们我们做错了什么：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `usage` message mentions a `-h` option, which we did not add. Let us see
    what it does:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`usage` 消息提到了一个 `-h` 选项，我们没有添加。让我们看看它做了什么：'
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The parser automatically adds a `help` option, which shows detailed usage information,
    including the `help` strings we passed to the `add_argument()` method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器自动添加一个 `help` 选项，它显示了详细的用法信息，包括我们传递给 `add_argument()` 方法的 `help` 字符串。
- en: To help you appreciate the power of `argparse` , we have added a version of
    the greeter script that does not use `argparse` in the source code for this chapter.
    You can find it in the `argument_parsing/greet.argv.py` file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您欣赏 `argparse` 的强大功能，我们在本章的源代码中添加了一个不使用 `argparse` 的问候脚本版本。您可以在 `argument_parsing/greet.argv.py`
    文件中找到它。
- en: We have only scratched the surface of what `argparse` is capable of in this
    section. We will show you a few more advanced features in the next section, as
    we explore the railway CLI application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们只是刚刚触及了 `argparse` 的功能。在下一节中，我们将展示一些更高级的功能，当我们探索铁路CLI应用程序时。
- en: Building a CLI client for the railway API
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为铁路 API 构建CLI客户端
- en: Now that we have covered the basics of command-line argument parsing, we are
    ready to start working on a more complex CLI application. You will find the code
    for the application under the project directory in the source code for this chapter.
    Let us start by taking a look at the contents of the `project` directory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了命令行参数解析的基础，我们可以开始着手构建一个更复杂的 CLI 应用程序了。您可以在本章源代码的项目目录下找到该应用程序的代码。让我们先看看
    `project` 目录的内容。
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `.env.example` file is a template for creating a `.env` configuration file
    for the railway application. The files in the `secrets` directory contain credentials
    needed to authenticate with the railway API as an admin user.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`.env.example` 文件是为创建铁路应用程序的 `.env` 配置文件而创建的模板。`secrets` 目录中的文件包含作为管理员用户与铁路API进行身份验证所需的凭证。'
- en: To successfully run the examples in this section, you need to have the API from
    *Chapter 14, Introduction to API Development* , running. You also need to create
    a copy of the `.env.example` file named `.env` and ensure it contains the correct
    URL for the API.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功运行本节中的示例，您需要运行 *第14章，API开发简介* 中的API。您还需要创建一个名为 `.env` 的 `.env.example` 文件副本，并确保它包含API的正确URL。
- en: The `railway_cli` directory is the Python package for the railway CLI application.
    The `api` sub-package contains the code for interacting with the railway API.
    In the `commands` sub-package, you will find the implementation of the sub-commands
    of the application. The `exceptions.py` module defines exceptions for errors that
    can occur within the application. `config.py` contains code for handling global
    configuration settings. The main function driving the CLI application is in `cli.py`
    . The `__main__.py` module is a special file that makes the package executable.
    When the package is executed with a command like
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`railway_cli` 目录是铁路 CLI 应用的 Python 包。`api` 子包包含与铁路 API 交互的代码。在 `commands` 子包中，你可以找到应用程序子命令的实现。`exceptions.py`
    模块定义了应用程序中可能发生的错误异常。`config.py` 包含处理全局配置设置的代码。驱动 CLI 应用的主函数位于 `cli.py` 中。`__main__.py`
    模块是一个特殊的文件，使得包可执行。当使用类似以下命令执行包时'
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Python will load and execute the `__main__.py` module. Its contents are as
    follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Python 将加载并执行 `__main__.py` 模块。其内容如下：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: All this module does is import the `cli` module and call the `cli.main()` function,
    which is the main entry point for the CLI application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块所做的一切就是导入 `cli` 模块并调用 `cli.main()` 函数，这是 CLI 应用程序的主要入口点。
- en: Interacting with the railway API
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与铁路 API 交互
- en: Before we delve into the command-line interface code, we want to briefly discuss
    the API client code. Instead of looking at the code in detail, we will just give
    you a high-level overview. We leave it as an exercise for you to study the code
    in depth.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究命令行界面代码之前，我们想简要地讨论一下 API 客户端代码。我们不会详细查看代码，而是只提供一个高级概述。我们将深入研究代码作为你的练习。
- en: 'In the `api` sub-package, you will find two modules, `client.py` and `schemas.py`
    :'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `api` 子包中，你可以找到两个模块，`client.py` 和 `schemas.py`：
- en: '`schemas.py` defines `pydantic` models to represent the objects we expect to
    receive from the API (we have only defined models for stations and trains).'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schemas.py` 定义了 `pydantic` 模型来表示我们期望从 API 收到的对象（我们只为车站和火车定义了模型）。'
- en: '`client.py` contains three classes and some helper functions:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client.py` 包含三个类和一些辅助函数：'
- en: '`HTTPClient` is a generic class for making **HTTP** requests. It is a wrapper
    around a `Session` object from the `requests` library. It has methods corresponding
    to the HTTP verbs the API uses ( `get` , `post` , `put` , and `delete` ). This
    class takes care of error handling and extracting data from API responses.'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTPClient` 是一个用于发送 **HTTP** 请求的通用类。它是 `requests` 库中的 `Session` 对象的包装器。它具有与
    API 使用的 HTTP 动词（`get`、`post`、`put` 和 `delete`）相对应的方法。这个类负责错误处理和从 API 响应中提取数据。'
- en: '`StationClient` is a higher-level client for interacting with the API’s station
    endpoints.'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StationClient` 是一个用于与 API 的车站端点交互的更高级客户端。'
- en: '`AdminClient` is a higher-level client for working with the admin endpoints.
    It has a method for authenticating users with the `users/authenticate` endpoint
    and a method for deleting a station via the `admin/stations/{station_id}` endpoint.'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AdminClient` 是一个用于处理管理端点的更高级客户端。它有一个使用 `users/authenticate` 端点进行用户认证的方法，以及一个通过
    `admin/stations/{station_id}` 端点删除车站的方法。'
- en: Creating the command-line interface
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建命令行界面
- en: We will start our exploration of the code with the `cli.py` module. We will
    examine it in chunks, starting with the `main()` function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个名为 `cli.py` 的模块开始探索代码。我们将分块检查它，从 `main()` 函数开始。
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We start by importing the standard library modules `argparse` and `sys` . We
    also import `__version__` , `config` , `commands` , and `exceptions` from the
    current package and the `Command` class from the `commands.base` module.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入标准库模块 `argparse` 和 `sys`。我们还从当前包中导入 `__version__`、`config`、`commands`
    和 `exceptions`，以及从 `commands.base` 模块导入 `Command` 类。
- en: It is a common convention for Python modules and packages to expose their version
    number under the name `__version__` . It is typically a string and is normally
    defined in the top-level `__init__.py` file of a package.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python 模块和包来说，将版本号暴露在 `__version__` 名称下是一个常见的约定。它通常是一个字符串，并且通常定义在包的顶级 `__init__.py`
    文件中。
- en: In the `main()` function, we call `get_arg_parser()` to get an `ArgumentParser`
    instance and call its `parse_args()` method to parse the command-line arguments.
    We expect the returned `Namespace` object to have a `command` attribute, which
    should be a `Command` class. We create an instance of this class, passing it the
    parsed arguments. Finally, we call the command’s `execute()` method.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们调用`get_arg_parser()`来获取一个`ArgumentParser`实例，并调用其`parse_args()`方法来解析命令行参数。我们期望返回的`Namespace`对象具有一个`command`属性，它应该是一个`Command`类。我们创建这个类的实例，并将解析后的参数传递给它。最后，我们调用命令的`execute()`方法。
- en: We handle `APIError` , `CommandError` , and `ConfigurationError` exceptions
    by calling `sys.exit()` to exit with an error message tailored to the type of
    exception that occurred. These are the only exceptions raised in our application
    code. If any other unexpected error happens, Python will terminate the application
    and print a full exception traceback to the user’s console. This may not seem
    very user-friendly, but it will make debugging much easier. Users of CLI applications
    also tend to be more technically adept and so are less likely to be put off by
    exception tracebacks than users of GUI or web applications.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`sys.exit()`来处理`APIError`、`CommandError`和`ConfigurationError`异常，以退出并显示针对发生异常类型的错误消息。这些是我们应用程序代码中抛出的唯一异常。如果发生任何其他意外错误，Python将终止应用程序并向用户的控制台打印完整的异常跟踪信息。这可能看起来不太友好，但它将使调试变得容易得多。CLI应用程序的用户也往往更技术熟练，因此他们不太可能因为异常跟踪信息而感到沮丧，与GUI或Web应用程序的用户相比。
- en: Note that the `main()` function has an optional parameter `cmdline` , which
    we pass to the `parse_args()` method. If `cmdline` is `None` , `parse_args()`
    will default to parsing arguments from `sys.argv` . However, if we pass a list
    of strings, `parse_args()` will parse that instead. Structuring the code like
    this is especially useful for unit testing as it allows us to avoid manipulating
    the global `sys.argv` in our tests.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`main()`函数有一个可选参数`cmdline`，我们将其传递给`parse_args()`方法。如果`cmdline`是`None`，`parse_args()`将默认解析来自`sys.argv`的参数。然而，如果我们传递一个字符串列表，`parse_args()`将解析这个列表。以这种方式结构化代码对于单元测试特别有用，因为它允许我们在测试中避免操作全局的`sys.argv`。
- en: We will look at the `Command` class and how the argument parser is set up to
    return the `Command` class to execute shortly. Let us first turn our attention
    to the `get_arg_parser()` function, though.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快查看`Command`类以及如何设置参数解析器以返回`Command`类来执行。不过，让我们首先关注`get_arg_parser()`函数。
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `get_arg_parser()` function creates and configures an `ArgumentParser` instance
    for the application. The `prog` argument specifies the program name to use in
    help messages. Normally, `argparse` takes this from `sys.argv[0]` ; however, for
    a package executed via `python -m package_name` , that is `__main__.py` , so we
    override it with the name of the package instead. The `description` argument provides
    a brief description of the program to display in the help message. The `formatter_class`
    determines how help messages are formatted ( `ArgumentDefaultsHelpFormatter` adds
    the default values of all options to the help message). We add a `"-V"` or `"--version"`
    option using the `"version"` action, which will print the `version` message and
    exit if this option is encountered on the command line. Finally, we call the `config.configure_arg_parser()`
    and `commands.configure_parsers()` functions to further configure the parser before
    returning it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_arg_parser()`函数为应用程序创建并配置一个`ArgumentParser`实例。`prog`参数指定用于帮助信息的程序名称。通常，`argparse`从`sys.argv[0]`获取这个值；然而，对于通过`python
    -m package_name`执行的包，它是`__main__.py`，所以我们用包的名称覆盖它。`description`参数提供了程序在帮助信息中显示的简要描述。`formatter_class`确定帮助信息的格式化方式（`ArgumentDefaultsHelpFormatter`将所有选项的默认值添加到帮助信息中）。我们使用`"version"`操作添加一个`"-V"`或`"--version"`选项，如果命令行中遇到此选项，将打印版本信息并退出。最后，我们调用`config.configure_arg_parser()`和`commands.configure_parsers()`函数来进一步配置解析器，然后再返回它。'
- en: The Python import system sets the `__package__` attribute of every imported
    module to the name of the package it belongs to.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Python的导入系统将每个导入模块的`__package__`属性设置为它所属的包名。
- en: In the next sections, we will look at the command-line argument configuration
    for the `config` and `commands` modules, starting with `config` .
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将查看`config`和`commands`模块的命令行参数配置，首先是`config`。
- en: Configuration files and secrets
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置文件和秘密
- en: Besides command-line arguments, many CLI applications also read settings from
    configuration files. Configuration files are often used for settings like API
    URLs that do not usually change from one invocation of an application to the next.
    It would be rather tedious for users to provide these on the command line every
    time they run an application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了命令行参数之外，许多CLI应用程序也会从配置文件中读取设置。配置文件通常用于API URL等设置，这些设置通常不会从一个应用程序的调用改变到下一个调用。每次运行应用程序时都要求用户在命令行上提供这些设置会相当繁琐。
- en: Another common use case for configuration files is to supply passwords and other
    secrets. It is not considered good security practice to provide passwords as command-line
    arguments because, on most operating systems, any logged-in user can see the full
    command line of any running application. Most shells also have a command history
    feature, which can potentially expose passwords that are passed as command-line
    arguments. It is much more secure to provide passwords in configuration files
    or dedicated secret files, which are files used to configure a secret, such as
    a password. The filename corresponds to the name of the secret and the content
    of the file is the secret itself.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件的另一个常见用途是提供密码和其他秘密。将密码作为命令行参数提供并不被认为是好的安全实践，因为在大多数操作系统中，任何已登录的用户都可以看到任何正在运行的应用程序的完整命令行。大多数shell也具有命令历史功能，这可能会暴露作为命令行参数传递的密码。在配置文件或专门的秘密文件中提供密码要安全得多，这些文件用于配置秘密，例如密码。文件名对应于秘密的名称，文件内容是秘密本身。
- en: It is very important to remember that it is never safe to store secrets alongside
    our code. Especially if you use a versioning system, like Git or Mercurial, be
    careful never to commit any secret with the source code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要记住，将秘密与我们的代码一起存储永远是不安全的。特别是如果您使用版本控制系统，如Git或Mercurial，请务必小心，不要将任何秘密与源代码一起提交。
- en: In the `railway_cli` application, the `config` module is responsible for handling
    configuration files and secrets. We use the `pydantic-settings` library, which
    we already encountered in *Chapter 14, Introduction to API Development* , to manage
    the configuration. Let us look at the code in chunks.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`railway_cli`应用程序中，`config`模块负责处理配置文件和秘密。我们使用`pydantic-settings`库，我们在*第14章，API开发简介*中已经遇到过的库，来管理配置。让我们分块查看代码。
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After the imports at the top of the file, we have two classes: `Settings` and
    `AdminCredentials` . Both inherit from `pydantic_settings.BaseSettings` . The
    `Settings` class defines the general configuration for the `railway_cli` application:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部的导入之后，我们有两个类：`Settings`和`AdminCredentials`。两者都继承自`pydantic_settings.BaseSettings`。`Settings`类定义了`railway_cli`应用程序的一般配置：
- en: '`url` : is used to configure the railway API URL.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`：用于配置railway API URL。'
- en: '`secrets_dir` : can be used to configure a path to a directory containing secret
    files. The API admin credentials will be loaded from secret files in this directory.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secrets_dir`：可以用来配置包含秘密文件的目录的路径。API管理员凭据将从该目录中的秘密文件中加载。'
- en: 'The `AdminCredentials` class defines the credentials needed to authenticate
    with the API as an admin user. The `env_prefix` argument to the `SettingsConfigDict`
    will be prefixed to the field names when looking up values in the secrets directory.
    For example, the `password` will be looked up in a file named `railway_api_password`
    . The `AdminCredentials` class contains the following fields:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`AdminCredentials`类定义了作为管理员用户进行API身份验证所需的凭据。`SettingsConfigDict`的`env_prefix`参数将在查找秘密目录中的值时添加到字段名称前。例如，`password`将在名为`railway_api_password`的文件中查找。`AdminCredentials`类包含以下字段：'
- en: '`email` : will contain the admin email address to authenticate with. We use
    the `pydantic.EmailStr` type to ensure that it contains a valid email address.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`：将包含用于身份验证的管理员电子邮件地址。我们使用`pydantic.EmailStr`类型来确保它包含有效的电子邮件地址。'
- en: '`password` : will contain the admin password. We use the `pydantic.SecretStr`
    type to ensure that the value will be masked with asterisks when printed (for
    example, in application logs). If no value is provided when the class is instantiated
    (via a secret file or an argument to the class constructor), `pydantic` will call
    the function provided via the `default_factory` argument to the `Field` function.
    We use this to call the standard library `getpass` function to securely prompt
    the user for the admin password.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password`：将包含管理员密码。我们使用 `pydantic.SecretStr` 类型来确保当打印（例如，在应用程序日志中）时，值将被星号屏蔽。如果类实例化时（通过秘密文件或类构造函数的参数）没有提供值，`pydantic`
    将调用通过 `Field` 函数的 `default_factory` 参数提供的函数。我们使用这个来调用标准库中的 `getpass` 函数，以安全地提示用户输入管理员密码。'
- en: 'Below these class definitions, you will find the `configure_arg_parser()` function.
    Let us look at that now:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些类定义下方，你可以找到 `configure_arg_parser()` 函数。现在让我们看看它：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We use the argument parser’s `add_argument_group()` method to create an argument
    group named `"configuration"` and give it a `description` . We add options allowing
    a user to specify a configuration file name and a secrets directory to this group.
    Note that argument groups do not affect how arguments are parsed or returned.
    It only means that these arguments will be grouped together under a common heading
    in the help message.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用参数解析器的 `add_argument_group()` 方法创建一个名为 `"configuration"` 的参数组，并给它一个 `description`
    描述。我们向这个组添加了允许用户指定配置文件名和秘密目录的选项。请注意，参数组不会影响参数的解析或返回方式。它仅仅意味着这些参数将在帮助信息中的公共标题下分组。
- en: For the sake of simplicity, we set the default configuration file path in this
    example to `.env` . It is, however, considered best practice to use the standard
    configuration file locations for the platform your application is running on.
    The `platformdirs` library ( [https://platformdirs.readthedocs.io](https://platformdirs.readthedocs.io)
    ) can be particularly helpful for this.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，我们在这个示例中将默认配置文件路径设置为 `.env`。然而，使用应用程序运行的平台的标准配置文件位置被认为是最佳实践。`platformdirs`
    库（[https://platformdirs.readthedocs.io](https://platformdirs.readthedocs.io)）在这方面特别有帮助。
- en: 'The final part of the `config.py` module consists of helper functions for retrieving
    the settings and admin credentials:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`config.py` 模块的最后一部分包括用于检索设置和管理员凭证的辅助函数：'
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `get_settings()` function creates and returns an instance of the `Settings`
    class. The `_env_file=args.config_file` argument tells `pydantic-settings` to
    load the settings from the file specified via the `--config-file` command-line
    option (which defaults to `.env` ). The `get_admin_credentials()` function creates
    and returns an instance of the `AdminCredentials` class. The `_secrets_dir` argument
    to the class specifies the secrets directory where `pydantic-settings` will look
    for the credentials. If a `--secrets-dir` option was set on the command line,
    we will use that; otherwise, use `settings.secrets_dir` . If that is also `None`
    , no secrets directory will be used.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_settings()` 函数创建并返回 `Settings` 类的一个实例。`_env_file=args.config_file` 参数告诉
    `pydantic-settings` 从通过 `--config-file` 命令行选项指定的文件（默认为 `.env`）中加载设置。`get_admin_credentials()`
    函数创建并返回 `AdminCredentials` 类的一个实例。类中的 `_secrets_dir` 参数指定了 `pydantic-settings`
    将在其中查找凭证的秘密目录。如果命令行上设置了 `--secrets-dir` 选项，我们将使用该选项；否则，使用 `settings.secrets_dir`。如果这也是
    `None`，则不会使用秘密目录。'
- en: Creating sub-commands
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建子命令
- en: 'The railway API has separate endpoints for listing stations, creating stations,
    getting departures, and so on. It makes sense to have a similar structure in our
    application. There are many ways of structuring the code for sub-commands. In
    this application, we have chosen to use an object-oriented approach. Each command
    is implemented as a class, with a method to configure the argument parser with
    the options and arguments it needs, and a method to execute the command. All commands
    are subclasses of the `Command` base class. You will find it in the `commands/base.py`
    module:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 铁路 API 有用于列出车站、创建车站、获取出发时间等单独的端点。在我们的应用程序中拥有类似的架构是有意义的。有许多方法可以组织子命令的代码。在这个应用程序中，我们选择使用面向对象的方法。每个命令都实现为一个类，其中包含一个配置参数解析器的方法，以及一个执行命令的方法。所有命令都是
    `Command` 基类子类。你可以在 `commands/base.py` 模块中找到它：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, the `Command` class is an ordinary class. The `ClassVar` annotation
    on `name` and `help` indicates that these are expected to be class attributes,
    rather than instance attributes. The `__init__()` method takes an `argparse.Namespace`
    object, which it assigns to `self.args` . It calls `get_settings()` to load the
    configuration file. Before returning, it also creates an `HTTPClient` object (from
    `api/client.py` ) and assigns it to `self.api_client` .
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Command` 类是一个普通类。`name` 和 `help` 上的 `ClassVar` 注解表明这些是期望作为类属性，而不是实例属性。`__init__()`
    方法接受一个 `argparse.Namespace` 对象，并将其分配给 `self.args`。它调用 `get_settings()` 来加载配置文件。在返回之前，它还创建了一个
    `HTTPClient` 对象（来自 `api/client.py`）并将其分配给 `self.api_client`。
- en: The `configure_arg_parser()` class method and `execute()` method both raise
    `NotImplementedError` when called, which means that subclasses need to override
    these methods with their own implementations.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure_arg_parser()` 类方法和 `execute()` 方法在调用时都会抛出 `NotImplementedError`，这意味着子类需要用它们自己的实现覆盖这些方法。'
- en: To set up argument parsing for the sub-commands, we need to create a parser
    for each sub-command and configure it by calling the `configure_arg_parser()`
    class method of the `Command` class. The `commands.configure_parsers()` function
    is responsible for this process. Let us take a look at that now.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置子命令的参数解析，我们需要为每个子命令创建一个解析器，并通过调用 `Command` 类的 `configure_arg_parser()` 类方法来配置它。`commands.configure_parsers()`
    函数负责这个过程。现在让我们看看这个。
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `parser.add_subparsers()` method returns an object that can be used to attach
    sub-command parsers to the main parser. The `description` argument is used to
    generate the help text for the sub-commands, and `required=True` ensures that
    the parser will produce an error if a sub-command is not supplied on the command
    line.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`parser.add_subparsers()` 方法返回一个对象，可以用来将子命令解析器附加到主解析器。`description` 参数用于生成子命令的帮助文本，`required=True`
    确保如果命令行上没有提供子命令，解析器将产生错误。'
- en: 'We iterate over the list of `admin_commands` and `station_commands` and create
    a sub-parser for each of them. The `add_parser()` method expects the `name` of
    the sub-command and any arguments that can be passed to the `ArgumentParser` class.
    It returns a new `ArgumentParser` instance, which we pass to the `command.configure_arg_parser()`
    class method. Note that the `command: type[Command]` type annotation indicates
    that we expect all elements of `admin_commands` and `station_commands` to be subclasses
    of `Command` .'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '我们遍历 `admin_commands` 和 `station_commands` 列表，并为每个创建一个子解析器。`add_parser()` 方法期望子命令的
    `name` 和可以传递给 `ArgumentParser` 类的任何参数。它返回一个新的 `ArgumentParser` 实例，我们将其传递给 `command.configure_arg_parser()`
    类方法。请注意，`command: type[Command]` 类型注解表明我们期望 `admin_commands` 和 `station_commands`
    的所有元素都是 `Command` 的子类。'
- en: The `set_defaults()` method allows us to set attributes on the namespace returned
    by the parser, independently of what is on the command line. We use this to set
    the `command` attribute for each sub-parser to the corresponding `Command` subclass.
    The `Namespace` object returned by the `parse_args()` method will only contain
    attributes from exactly one sub-parser (the one corresponding to the sub-command
    provided on the command line). Thus, when we call `args.command(args=args)` in
    the `cli.main()` function, we are guaranteed to get an instance of the command
    class for the command selected by the user.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_defaults()` 方法允许我们独立于命令行上的内容，在解析器返回的命名空间上设置属性。我们使用这个方法将每个子解析器的 `command`
    属性设置为相应的 `Command` 子类。`parse_args()` 方法返回的 `Namespace` 对象将只包含来自恰好一个子解析器的属性（与命令行上提供的子命令相对应）。因此，当我们调用
    `cli.main()` 函数中的 `args.command(args=args)` 时，我们保证会得到用户选择的命令类的实例。'
- en: Now that we have put together all the code to configure the argument parser,
    we can look at the help text that is generated when we run the application with
    the `-h` option.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将配置参数解析器的所有代码组合在一起，我们可以查看当我们使用 `-h` 选项运行应用程序时生成的帮助文本。
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We have trimmed some of the output and removed blank lines, but you can see
    that there is a `usage` summary showing how to use the command, followed by the
    `description` we set when creating the argument parser. This is followed by the
    global `options` section with the `-h` or `--help` option and the `-V` or `--version`
    option. Next, we get a `configuration` section with the description and options
    we configured in the `config.configure_arg_parser()` function. Finally, we have
    a `subcommands` section, with the description we passed to the argument parser’s
    `add_subparsers()` method in `commands.configure_parsers()` and a list of all
    the available sub-commands with the help string we set for each of them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经缩减了一些输出并删除了空白行，但您可以看到有一个`usage`摘要显示了如何使用该命令，然后是我们在创建参数解析器时设置的`description`。接着是全局的`options`部分，包括`-h`或`--help`选项和`-V`或`--version`选项。接下来是`configuration`部分，其中包含了在`config.configure_arg_parser()`函数中配置的描述和选项。最后，我们有一个`subcommands`部分，其中包含了我们在`commands.configure_parsers()`中传递给参数解析器`add_subparsers()`方法的描述，以及所有可用子命令的列表和为每个子命令设置的帮助字符串。
- en: We have seen the base class for sub-commands and the code to configure the argument
    parser to work with sub-commands. Let us now look at the implementation of a sub-command.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了子命令的基类和配置参数解析器以与子命令一起工作的代码。现在让我们看看子命令的实现。
- en: Implementing sub-commands
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现子命令
- en: The sub-command parsers are completely independent, so we can implement sub-commands
    without any risk that their command-line options might conflict with one another.
    We only need to ensure that the command names are unique. This means we can extend
    the application by adding commands without needing to modify any existing code.
    The class-based approach we have chosen for this application makes it easy to
    add commands. We just have to create a new `Command` subclass, define its `name`
    and `help` text, and implement the `configure_arg_parser()` and `execute()` methods.
    As an example, let us look at the code for the `create-station` command.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 子命令解析器是完全独立的，因此我们可以实现子命令而无需担心它们的命令行选项可能会相互冲突。我们只需要确保命令名称是唯一的。这意味着我们可以通过添加命令来扩展应用程序，而无需修改任何现有代码。我们为这个应用程序选择基于类的处理方法，这使得添加命令变得容易。我们只需创建一个新的`Command`子类，定义其`name`和`help`文本，并实现`configure_arg_parser()`和`execute()`方法。作为一个例子，让我们看看`create-station`命令的代码。
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that we have not reproduced the imports from the top of the `commands/stations.py`
    module here. As you can see, the code for the command is quite straightforward.
    The `configure_arg_parser()` class method adds options for the station code, city,
    and country.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有在这里重现`commands/stations.py`模块顶部的导入。如您所见，命令的代码相当简单。`configure_arg_parser()`类方法为站点代码、城市和国家添加了选项。
- en: Note that all three are marked as `required` . The Python `argparse` documentation
    discourages the use of `required` options; however, in some circumstances, it
    can lead to a more user-friendly interface. If a command requires more than two
    arguments with different meanings, it can become difficult for users to remember
    the correct order. Using options instead means that the order does not matter,
    and it is immediately obvious what each of the arguments means.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这三个选项都被标记为`required`。Python的`argparse`文档不鼓励使用`required`选项；然而，在某些情况下，它可以导致更用户友好的界面。如果一个命令需要超过两个具有不同意义的参数，用户可能很难记住正确的顺序。使用选项意味着顺序不重要，并且每个参数的含义立即显而易见。
- en: 'Let us see what happens when we run this command. First, with the `-h` option
    to see the help message:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看运行此命令时会发生什么。首先，使用`-h`选项查看帮助信息：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The help message clearly shows how to use the command. Now we can create a
    station:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助信息清楚地显示了如何使用该命令。现在我们可以创建一个站点：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The output shows that the station was created successfully and assigned the
    `id` `12` .
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示站点已成功创建并分配了`id` `12`。
- en: This brings us to the end of our exploration of the railway CLI application.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们结束了对铁路CLI应用程序的探索。
- en: Other resources and tools
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源和工具
- en: 'We will finish this chapter with some links to resources where you can learn
    more and some useful libraries for developing CLI applications:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章以一些链接结束，这些链接指向您可以了解更多信息和一些用于开发CLI应用程序的有用库：
- en: Although we have tried to make this chapter as comprehensive as we could, the
    `argparse` module has many more features than we could showcase here. The official
    documentation at [https://docs.python.org/3/library/argparse.html](https://docs.python.org/3/library/argparse.html)
    is excellent, though.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管我们已经尽力使本章内容尽可能全面，但 `argparse` 模块的功能远不止我们在这里展示的。不过，官方文档在 [https://docs.python.org/3/library/argparse.html](https://docs.python.org/3/library/argparse.html)
    上非常优秀。
- en: 'If `argparse` is not to your liking, there are several third-party libraries
    available for command-line argument parsing. We suggest that you try them all:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `argparse` 不符合您的喜好，还有几个第三方库可用于命令行参数解析。我们建议您都尝试一下：
- en: '**Click** is by far the most popular third-party CLI library for Python. Besides
    command-line parsing, it also provides features for creating interactive applications
    (such as input prompts) and for producing colorful output. You can learn about
    it at [https://click.palletsprojects.com](https://click.palletsprojects.com) .'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Click** 是迄今为止最受欢迎的第三方 CLI 库。除了命令行解析外，它还提供了创建交互式应用程序（如输入提示）和生成彩色输出的功能。您可以在
    [https://click.palletsprojects.com](https://click.palletsprojects.com) 了解更多信息。'
- en: '**Typer** was created by the same developers as FastAPI. It aims to apply the
    same principles FastAPI applies to API development to CLI development. You can
    read about it at [https://typer.tiangolo.com/](https://typer.tiangolo.com/) .'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Typer** 由与 FastAPI 相同的开发者创建。它的目标是将 FastAPI 应用于 API 开发的相同原则应用于 CLI 开发。您可以在
    [https://typer.tiangolo.com/](https://typer.tiangolo.com/) 了解更多信息。'
- en: '**Pydantic Settings** , which we used for configuration management in this
    chapter and in *Chapter 14, Introduction to API development* , also supports parsing
    command-line arguments. See [https://docs.pydantic.dev/latest/concepts/pydantic_settings/#command-line-support](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#command-line-support)
    to learn more about this.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pydantic Settings**，我们在本章和*第14章，API开发简介*中用于配置管理，也支持解析命令行参数。有关更多信息，请参阅[https://docs.pydantic.dev/latest/concepts/pydantic_settings/#command-line-support](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#command-line-support)。'
- en: Most modern shells support programmable command-line tab completion. Providing
    command-line completion can make your CLI application much easier to use. The
    `argcomplete` library ( [https://kislyuk.github.io/argcomplete/](https://kislyuk.github.io/argcomplete/)
    ) provides command-line completion in the `bash` and `zsh` shells for applications
    that use `argparse` to handle command-line arguments.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数现代 shell 都支持可编程的命令行自动补全。提供命令行补全可以使您的 CLI 应用程序更容易使用。`argcomplete` 库（[https://kislyuk.github.io/argcomplete/](https://kislyuk.github.io/argcomplete/)）为使用
    `argparse` 处理命令行参数的应用程序提供了 `bash` 和 `zsh` shell 的命令行补全功能。
- en: The *Command Line Interface Guidelines* ( [https://clig.dev/](https://clig.dev/)
    ) is a comprehensive open-source resource with excellent advice for designing
    user-friendly command-line interfaces.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*命令行界面指南*》（[https://clig.dev/](https://clig.dev/)）是一个全面的开源资源，提供了设计用户友好的命令行界面的优秀建议。
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about command-line applications by developing a
    CLI client for the railway API that we created in *Chapter 14, Introduction to
    API Development* . We learned how to parse command-line arguments with the standard
    library `argparse` module. We looked at how to structure a CLI application interface
    by using sub-commands and saw how this can help us build modular applications
    that are easy to maintain and extend. We concluded the chapter with some links
    to other libraries for CLI application development in Python and some resources
    where you can learn more.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过为我们在*第14章，API开发简介*中创建的铁路API开发 CLI 客户端来学习命令行应用程序。我们学习了如何使用标准库 `argparse`
    模块解析命令行参数。我们探讨了如何通过使用子命令来构建 CLI 应用程序界面，并看到这如何帮助我们构建易于维护和扩展的模块化应用程序。我们以一些链接到其他用于
    Python CLI 应用程序开发的库以及一些您可以了解更多信息的资源来结束本章。
- en: Working with command-line applications is an excellent way to practice the skills
    you learned throughout this book. We encourage you to study the code for this
    chapter, extend it by adding more commands, and improve it by adding logging and
    tests.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与命令行应用程序一起工作是练习本书所学技能的绝佳方式。我们鼓励您研究本章的代码，通过添加更多命令来扩展它，并通过添加日志和测试来改进它。
- en: In the next chapter, we will learn how to package and publish Python applications.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何打包和发布 Python 应用程序。
- en: Join our community on Discord
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_15.xhtml)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.com/invite/uaKmaz7FEC](Chapter_15.xhtml)'
- en: '![img](img/QR_Code119001106417026468.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/QR_Code119001106417026468.png)'
