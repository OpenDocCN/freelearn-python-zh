- en: Chapter 6. Handling Return Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 处理返回数据
- en: When the Salt Master issues a command to a Minion and the task completes successfully,
    there will always be return data. The `salt` command normally listens for return
    data, and if it is sent back in time, it will be displayed using an outputter.
    But whether or not that happens, the Minion will always send return data back
    to the Master, and any other destinations configured as returners.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当Salt Master向Minion发出命令并且任务成功完成时，总会存在返回数据。`salt`命令通常会监听返回数据，并且如果它及时返回，它将使用输出器显示。但无论是否发生这种情况，Minion总会将返回数据发送回Master，以及任何配置为Returner的其他目的地。
- en: 'This chapter is all about handling that return data, using both returner and
    outputter modules. We''ll talk about:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于处理返回数据，使用Returner和Outputter模块。我们将讨论：
- en: How data is returned to the Master
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据如何返回给Master
- en: Writing returner modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Returner模块
- en: Extending returners to be used as external job caches
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Returners扩展为用作外部作业缓存
- en: Troubleshooting returners
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Returners故障排除
- en: Writing outputter modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Outputter模块
- en: Troubleshooting outputters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Outputters故障排除
- en: Returning data to external destinations
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据返回到外部目的地
- en: The most important type of module to handle return data is called a returner.
    When the Master publishes a task (called a job) to a target, it assigns a job
    ID (or JID) to it. When a Minion finishes that job, it sends the resulting data
    back to the Master, along with the JID that is associated with it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 处理返回数据最重要的模块类型称为Returner。当Master向目标发布任务（称为作业）时，它会为它分配一个作业ID（或JID）。当Minion完成该作业时，它会将结果数据连同与其关联的JID一起发送回Master。
- en: Returning data to the master
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据返回给Master
- en: Salt's architecture is based on the publish-subscribe pattern, known colloquially
    as pub/sub. In this design, one or more clients subscribe to a message queue.
    When a message is published to the queue, any current subscribers receive a copy,
    which they usually process in some way.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Salt的架构基于发布-订阅模式，俗称pub/sub。在这个设计中，一个或多个客户端订阅一个消息队列。当消息发布到队列时，任何当前订阅者都会收到一个副本，他们通常会以某种方式处理它。
- en: Salt in fact makes use of two message queues, both of which are managed by the
    Master. The first is used by the Master to publish commands to its Minions. Each
    Minion can see the messages published to this queue, but they will only react
    to them if the Minions are included in the target. A message targeted to `'*'`
    will be processed by all Minions that are connected, whereas one targeted to `192.168.0.0/16`
    using the `-s` command-line option will only be processed by Minions whose IP
    address starts with `192.168`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Salt使用了两个消息队列，这两个队列都由Master管理。第一个队列由Master用于向其Minions发布命令。每个Minion都可以看到发布到这个队列的消息，但只有当Minions包含在目标中时，它们才会做出反应。针对`'*'`的目标消息将由所有连接的Minions处理，而使用`-s`命令行选项针对`192.168.0.0/16`的目标消息将只会被以`192.168`开头的IP地址的Minions处理。
- en: The second message queue is also hosted by the Master, but messages are published
    to it from Minions, and the Master itself is the subscriber. These messages are
    normally stored in the Master's job cache. Returners can be configured to send
    these messages to other destinations, and some returners can also use those destinations
    as the job cache itself. If the `salt` command is still listening when those messages
    are received, then it will also send the data to an outputter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个消息队列也由Master托管，但消息是由Minions发布的，Master本身是订阅者。这些消息通常存储在Master的作业缓存中。Returners可以被配置为将这些消息发送到其他目的地，并且一些Returners也可以使用这些目的地作为作业缓存本身。如果当收到这些消息时`salt`命令仍在监听，那么它也会将这些数据发送到输出器。
- en: Listening to event data
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听事件数据
- en: Every time a message is published to the queue, an event is also fired along
    Salt's event bus. You can use the `state.event` runner to listen to the event
    bus and display those messages in real time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每次将消息发布到队列时，Salt的事件总线也会触发一个事件。您可以使用`state.event`运行器来监听事件总线并实时显示这些消息。
- en: 'Make sure you have the `salt-master` service running, and the `salt-minion`
    service on at least one machine connected to it. On the Master, run the following
    command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您有`salt-master`服务正在运行，并且至少有一台连接到它的机器上的`salt-minion`服务。在Master上运行以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In another terminal, issue a command to one or more Minions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中，向一个或多个Minions发出命令：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the terminal that is running the event listener, you will see the job go
    out to the Minions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行事件监听器的终端中，您将看到作业发送到Minions：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The information contained in this event is no more than a timestamp indicating
    when the job was created, and a list of Minions that the specified target (in
    our example, all of them) are expected to execute the job and return data from
    it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本事件包含的信息仅限于一个时间戳，表示作业创建的时间，以及一个列表，列出了指定的目标（在我们的例子中，所有目标）应执行作业并从中返回数据的Minions。
- en: 'This is a very small task, so almost immediately you should start seeing return
    data show up from Minions. Because each Minion responds individually, you will
    see one entry per Minion:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常小的任务，所以你几乎可以立即看到来自Minions的返回数据。因为每个Minion都单独响应，所以你会看到每个Minion的条目：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Take note of the tags used for each event. The event that was created when the
    Master created the job has a tag that contains just the JID. Each return event
    contains a tag that is namespaced with `salt/job/<JID>/ret/<Minion ID>`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个事件使用的标签。当Master创建作业时创建的事件有一个只包含JID的标签。每个返回事件都包含一个以`salt/job/<JID>/ret/<Minion
    ID>`命名的命名空间标签。
- en: 'After a few seconds, the salt command will also return, and notify you which
    Minions did and did not finish the job that was assigned to them:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，salt命令也将返回，并通知你哪些Minions完成了分配给它们的作业，哪些没有完成：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In our case, `achatz` was active, and able to return `True` as requested. Unfortunately,
    `trotter` isn't around anymore, and so wasn't able to do what we need.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`achatz`是活跃的，并且能够按照要求返回`True`。不幸的是，`trotter`已经不再存在，所以无法完成我们需要的操作。
- en: When returners listen to Minions
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当返回者监听Minions
- en: Each time the Master receives a response from a Minion, it will call out to
    a returner. If a job targets, say, 400 Minions, then you should expect the returner
    to be executed 400 times, one for each Minion.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每次Master从Minion收到响应时，它将调用返回者。如果一个作业针对的是，比如说，400个Minions，那么你应该预期返回者将被执行400次，每个Minion一次。
- en: This is not normally a problem. If a returner connects to a database, then that
    database is likely to be able to handle 400 responses very quickly. However, if
    you create a returner that sends messages to humans, such as the SMTP returner
    that ships with Salt, then you can expect 400 individual e-mails to be sent; one
    per Minion.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常不是问题。如果一个返回者连接到数据库，那么这个数据库很可能能够快速处理400个响应。然而，如果您创建了一个发送消息给人类的返回者，比如Salt附带的SMTP返回者，那么您可以预期会发送400封单独的电子邮件；每个Minion一封。
- en: 'There is one more thing to keep in mind: returners were originally designed
    to be executed on Minions. The idea behind this was to offload the work to Minions
    so that in a large environment, a Master wouldn''t be required to handle all of
    the work necessary to, say, connect to a database once per Minion per job.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点需要注意：返回者最初是为了在Minions上执行而设计的。背后的想法是将工作卸载到Minions上，这样在一个大型环境中，Master就不需要处理所有必要的工作，比如每个Minion每次作业连接数据库。
- en: Returners can now be run either by a Master or by a Minion, and when writing
    your own returners, you should expect either to be a possibility. We will discuss
    the configuration for this later in the chapter, when we talk about job caches.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 返回者现在可以由Master或Minion运行，当编写自己的返回者时，你应该预期这两种可能性。我们将在本章后面讨论此配置，当我们谈到作业缓存时。
- en: 'Let''s go ahead and see an example of this in action. Connect to one of your
    Minions and stop the `salt-minion` service. Then start it running in the foreground,
    using the `info` log level:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个动作的一个例子。连接到您的其中一个Minion并停止`salt-minion`服务。然后以`info`日志级别在前台启动它：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then connect to the Master and issue a job directly to it:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后连接到Master并直接向其发出作业：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Switch back to the Minion, and you will see some information about the job:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回Minion，你将看到一些关于作业的信息：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now issue the command again, but with the `--return` flag set to `local`. This
    returner will display the return data directly to the local console:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次发出命令，但将`--return`标志设置为`local`。此返回者将直接在本地控制台显示返回数据：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Switch back to the Minion again to check out the return data:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 再次切换回Minion以检查返回数据：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Your first returner
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的第一个返回者
- en: 'Go ahead and open up `salt/returners/local.py`. There''s not much in here,
    but what we''re interested in is the `returner()` function. It''s very, very small:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`salt/returners/local.py`。这里没有多少内容，但我们感兴趣的是`returner()`函数。它非常非常小：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In fact, all it does is accept return data as `ret`, and then print it to the
    console. It doesn't even attempt any sort of pretty printing; it just dumps it
    as is.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它所做的只是接受返回的数据作为`ret`，然后将其打印到控制台。它甚至不尝试进行任何形式的格式化打印；它只是原样输出。
- en: 'This is in fact the bare minimum that a returner needs: a `returner()` function
    that accepts a dictionary, and then does something with it. Let''s go ahead and
    create our own returner, which stores job information locally in JSON format.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个返回器所需的最基本内容：一个接受字典的 `returner()` 函数，然后对其进行处理。让我们创建我们自己的返回器，它以 JSON 格式将作业信息本地存储。
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Save this file, on a Minion, and then issue a job to it. It doesn''t matter
    whether or not you restart the `salt-minion` service; returner modules use `LazyLoader`.
    But we''ll go ahead and use `salt-call` anyway:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Minion 上保存此文件，然后向其发出作业。无论是否重新启动 `salt-minion` 服务，返回器模块都使用 `LazyLoader`。但我们将继续使用
    `salt-call`：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Go ahead and look inside the `/tmp/` directory:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请查看 `/tmp/` 目录：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you take a look inside that file, you will see return data that looks very
    similar to what we received from the local returner, except that it is in JSON
    format:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看该文件，你会看到看起来与从本地返回器接收到的数据非常相似，但它是 JSON 格式：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using job caches
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用作业缓存
- en: In a way, our JSON returner is a job cache, because it caches return data. Unfortunately,
    it doesn't contain any code to do anything with the data once it's saved. By updating
    the logic and adding a few functions, we can extend the functionality.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，我们的 JSON 返回器是一个作业缓存，因为它缓存了返回数据。不幸的是，它不包含任何处理已保存数据的代码。通过更新逻辑并添加一些函数，我们可以扩展其功能。
- en: 'Right now, our returner behaves like little more than a set of log files. Let''s
    change it to behave more like a flat-file database. We''ll use the JID as the
    access key, and format the directory structure based on the dates in the JIDs:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的返回器表现得就像一组日志文件。让我们将其改为更像一个平面文件数据库。我们将使用 JID 作为访问密钥，并根据 JID 中的日期格式化目录结构：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We haven''t changed anything except for the directory structure, and how it''s
    handled. The private function `_job_path()` will standardize the directory structure,
    and can be used by future functions. We''ve also made use of `salt.syspaths` to
    detect where Salt is configured to keep cache files on this machine. When run
    against a Minion called `dufresne`, the path used to store the return data will
    look like:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有改变任何东西，除了目录结构及其处理方式。私有函数 `_job_path()` 将标准化目录结构，并可以被未来的函数使用。我们还使用了 `salt.syspaths`
    来检测 Salt 在这台机器上配置的缓存文件位置。当针对名为 `dufresne` 的 Minion 运行时，用于存储返回数据的路径将看起来像：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We'll also need to store information about the job itself. The `return.json`
    file contains some information about the job, but not all of it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要存储有关作业本身的信息。`return.json` 文件包含一些关于作业的信息，但不是全部。
- en: 'Let''s go ahead and add a function that saves the metadata about the job. This
    metadata is called the load, and contains a `jid`, a dictionary called `clear_load`
    that contains the bulk of the metadata, and a list called `minions`, which will
    contain a list of all of the Minions that were included in the target:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个保存作业元数据的函数。这个元数据被称为负载，包含一个 `jid`，一个名为 `clear_load` 的字典，它包含大部分元数据，以及一个名为
    `minions` 的列表，它将包含所有包含在目标中的 Minions：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once again, we generate the path that the data will be written to. The `clear_load`
    dictionary will be written to `load.json` inside that path. The list of Minions
    is a little trickier, since it may contain an empty list. If it does, we use a
    class inside `salt.utils.minions` called `CkMinions` to generate that list, based
    on the target that was used for the job. Once we have that list, we write it as
    `minions.json`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们生成数据将被写入的路径。`clear_load` 字典将被写入该路径内的 `load.json` 文件。Minions 的列表有点棘手，因为它可能包含一个空列表。如果是这样，我们使用
    `salt.utils.minions` 内的一个名为 `CkMinions` 的类来生成该列表，基于用于作业的目标。一旦我们有了这个列表，我们就将其写入为
    `minions.json`。
- en: Testing this is also a little trickier, because it requires a job that was generated
    from the Master in order to generate all of the metadata that is needed. We also
    need to let the Master know that we're using an external job cache.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这一点也有点棘手，因为它需要一个由 Master 生成的工作来生成所需的所有元数据。我们还需要让 Master 知道我们正在使用外部作业缓存。
- en: 'First, edit the master configuration file and add an `ext_job_cache` line,
    which is set to `local_json`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编辑主配置文件并添加一个 `ext_job_cache` 行，将其设置为 `local_json`：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**External job cache versus Master job cache**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**外部作业缓存与 Master 作业缓存**'
- en: When the Master is set to use an external job cache (with the `ext_job_cache`)
    setting, the returner code will be executed on the Minion. This will relieve load
    on the Master since each Minion will be recording its own job data, instead of
    asking the Master to. However, any credentials necessary to connect to the job
    cache (for instance, if a database was used) will need to be accessible to the
    Minion.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当主节点设置为使用外部工作缓存（使用 `ext_job_cache` 设置）时，返回代码将在从节点上执行。这将减轻主节点的负载，因为每个从节点将记录自己的工作数据，而不是请求主节点。然而，连接到工作缓存（例如，如果使用了数据库）所需的任何凭证都需要从节点可以访问。
- en: When the Master is set to use a Master job cache (with the `master_job_cache`)
    setting, the returner code will be executed on the Master. This will increase
    the workload on the Master, but will save you from having to make credentials
    available to Minions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当主节点设置为使用主节点工作缓存（使用 `master_job_cache` 设置）时，返回代码将在主节点上执行。这将增加主节点的负载，但可以节省您向从节点提供凭证的麻烦。
- en: 'Once you''ve turned on the job cache, let''s go ahead and restart both the
    Master and the Minion, and try things out:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您打开了工作缓存，让我们先重启主节点和从节点，然后尝试一下：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now we have the information being saved, but we don't have any way to retrieve
    it, outside of manually looking inside the files. Let's go ahead and complete
    our returner with some functions that can read the data.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了保存的信息，但我们没有检索它的方法，除了手动查看文件之外。让我们继续完善我们的返回器，添加一些可以读取数据的函数。
- en: 'First, we need a function that just returns information about the job load:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个只返回工作负载信息的函数：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We also need a function that gets the return data from each job. These two
    functions will be used together by the `jobs` runner:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个函数来获取每个工作的工作数据。这两个函数将由 `jobs` 运行者一起使用：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We don''t need to restart the Master to be able to test this, since the jobs
    runner doesn''t require the Master to be running:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要重新启动主节点来测试这个功能，因为工作负载运行者不需要主节点正在运行：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We''ll also need a function that returns a list of JIDs, along with some basic
    information about their associated jobs. This function will make use of another
    import, which we will use to quickly locate the `load.json` files:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个函数，该函数返回一个 JIDs 列表，以及它们相关联的工作的一些基本信息。这个函数将使用另一个导入，我们将使用它来快速定位 `load.json`
    文件：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once again, we test this with the `jobs` runner:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用 `jobs` 运行者测试这个功能：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The final module
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终模块
- en: 'Once we have compiled all of the code together, the final module will look
    like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将所有代码编译在一起，最终的模块将看起来像这样：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Troubleshooting returners
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回器的故障排除
- en: As you have seen, there are a number of different pieces of Salt that use different
    parts of the returner. Some of these require a Master to be running, which makes
    them a little trickier to troubleshoot. Here are some strategies that can help.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，有许多不同的 Salt 组件使用不同的返回器部分。其中一些需要主节点正在运行，这使得它们稍微有点难以调试。以下是一些可以帮助的策略。
- en: Testing with salt-call
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 salt-call 进行测试
- en: The `returner()` function can be tested with the `salt-call` command. When doing
    this, simple `print` statements can be used to display information to your console.
    If there are typos, Python will display error messages. If the problem pertains
    to technically valid, but still buggy code, then `print` statements can be used
    to track down the problem.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `salt-call` 命令测试 `returner()` 函数。在这种情况下，简单的 `print` 语句可以用来向您的控制台显示信息。如果有拼写错误，Python
    将显示错误消息。如果问题涉及技术上有效但仍然有缺陷的代码，那么可以使用 `print` 语句来追踪问题。
- en: Testing with the Master running
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在主节点运行时进行测试
- en: 'The `save_load()` function requires a job to be generated on the Master, to
    one or more Minions. This of course requires both a Master and at least one Minion
    to be running. You can run them in the foreground in separate terminals, in order
    to see the output from `print` statements:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`save_load()` 函数需要在主节点上生成一个工作负载，到一个或多个从节点。这当然需要主节点和至少一个从节点正在运行。您可以在不同的终端中前台运行它们，以便看到
    `print` 语句的输出：'
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you are using `ext_job_cache`, then it is the Minion that you will want to
    be watching. If you are using the `master_job_cache`, then watch the Master.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 `ext_job_cache`，那么您将想要监控的是从节点。如果您使用 `master_job_cache`，那么请监控主节点。
- en: Testing with runners
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用运行者进行测试
- en: The `get_load()`, `get_jid()`, and `get_jids()` functions are all used by the
    `jobs` runner. This runner doesn't require either Master or Minions to be running;
    it only requires that the data store that is being used by the returner is available.
    Again, `print` statements inside these functions will display information when
    the `jobs` runner is used.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_load()`、`get_jid()` 和 `get_jids()` 函数都是由 `jobs` 运行器使用的。这个运行器不需要 Master
    或 Minions 运行；它只要求被返回者使用的数据库可用。再次强调，这些函数内部的 `print` 语句会在使用 `jobs` 运行器时显示信息。'
- en: Writing outputter modules
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写输出器模块
- en: When the `salt` command is used, any return data that is received during the
    wait period will be displayed to the user. Outputter modules are used in this
    case to display that data to the console (or more accurately, to `STDOUT`), usually
    in a format that is somewhat user-friendly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `salt` 命令时，在等待期间接收到的任何返回数据都会显示给用户。在这种情况下，输出器模块用于将数据显示到控制台（或者更准确地说，到 `STDOUT`），通常以某种用户友好的格式。
- en: Pickling our output
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化我们的输出
- en: 'Because Salt already ships with a `json` outputter, we''ll take advantage of
    the fact that output data is technically going to `STDOUT`, and put together an
    `outputter` that uses a serializer (`pickle`) that may dump binary data:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Salt 已经自带了一个 `json` 输出器，我们将利用输出数据实际上会输出到 `STDOUT` 的这一事实，并创建一个使用序列化器（`pickle`）可能输出二进制数据的
    `outputter`：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This `outputter` is about as simple as it gets. The only required function is
    called `output()`, and it accepts a dictionary. It doesn't matter what the dictionary
    is called, so long as the function has one defined.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `outputter` 的实现非常简单。唯一需要的函数叫做 `output()`，它接受一个字典。字典的名称无关紧要，只要函数定义了一个即可。
- en: 'The `pickle` library is built into Python, and as you saw with the `pickle`
    renderer, is very easy to use: we just tell it to dump out the data into a string,
    which is returned to Salt.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle` 库是 Python 内置的，正如你在 `pickle` 渲染器中看到的，它非常容易使用：我们只需告诉它将数据输出到一个字符串，然后返回给
    Salt。'
- en: 'As usual, we can test this `outputter` using `salt-call`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们可以使用 `salt-call` 来测试这个 `outputter`：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you take a look at some of the other outputters that ship with Salt, you'll
    notice that some are just as simple. Even the `json` outputter doesn't do any
    extra work, outside of formatting the output. Most execution modules will make
    use of the `nested` outputter by default. `nested` uses a format based on YAML,
    but with color-coded data. The `state` functions, however, use the `highstate`
    outputter, which builds upon nested to return an aggregated version of the data,
    with statistics about the success of the state run.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看一些 Salt 附带的其它输出器，你会发现它们同样简单。甚至 `json` 输出器也没有做任何额外的工作，除了格式化输出。大多数执行模块默认会使用
    `nested` 输出器。`nested` 使用基于 YAML 的格式，但带有彩色数据。然而，`state` 函数使用的是 `highstate` 输出器，它基于
    `nested` 返回数据的聚合版本，包括关于状态运行成功率的统计信息。
- en: Troubleshooting outputters
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出器的故障排除
- en: Outputters can be one of the easiest types of module to troubleshoot. You should
    be able to test any of them using the `salt-call` command.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 输出器可能是最容易调试的模块之一。你应该能够使用 `salt-call` 命令测试任何输出器。
- en: When testing, start with a simple `test.ping`, just to make sure that you are
    getting some output in the first place. Once you're satisfied that your `output()`
    function is returning simple data that looks correct, take a look at `grains.items`,
    which will make use of both lists and dictionaries.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试时，先从简单的 `test.ping` 开始，以确保首先得到一些输出。一旦你满意你的 `output()` 函数返回的是看起来正确的基本数据，查看
    `grains.items`，它将使用列表和字典。
- en: 'You may find it useful to test your output against another outputter that is
    known to work well. I find that the `pprint` outputter tends to be the most succinct
    at displaying data in a format that is easy to read, but takes the least amount
    of screen real-estate:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现测试你的输出与另一个已知工作良好的输出器很有用。我发现 `pprint` 输出器在以易于阅读的格式显示数据时通常是最简洁的，但占用的屏幕空间最少：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Return data command is always sent to the Master, even after the `salt` command
    has finished listening for it. The event bus picks up those messages and can store
    them in an external job cache. If the `salt` command is still listening, then
    it will be displayed using an `outputter`. But specifying a returner will always
    send return data someplace to be processed, so long as the Master itself is still
    running.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数据命令始终发送到主节点，即使在`salt`命令完成监听之后。事件总线拾取这些消息并将它们存储在外部作业缓存中。如果`salt`命令仍在监听，那么它将通过`outputter`显示。但指定返回者总会将返回数据发送到某个地方进行处理，只要主节点本身仍在运行。
- en: Returners can be specified using the `--return` flag, or can be set to run by
    default on the Minion using the `ext_job_cache` `master` configuration option,
    or on the Master using the `master_job_cache` `master` configuration option.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`--return`标志指定返回者，或者可以通过`ext_job_cache` `master`配置选项在Minion上默认运行，或者在主节点上使用`master_job_cache`
    `master`配置选项来设置。
- en: 'Now that we have ways of handling return data, it''s time to create more intelligent
    processes to execute our commands. Next up: runners.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了处理返回数据的方法，是时候创建更智能的过程来执行我们的命令了。接下来是运行者。
