- en: Chapter 8. Advanced Templates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。高级模板
- en: Although most of your interactions with Django's template language will be in
    the role of template author, you may want to customize and extend the template
    engine-either to make it do something it doesn't already do, or to make your job
    easier in some other way.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你与Django的模板语言的大部分交互将是作为模板作者的角色，但你可能想要自定义和扩展模板引擎-要么使其执行一些它尚未执行的操作，要么以其他方式使你的工作更轻松。
- en: This chapter delves deep into the guts of Django's template system. It covers
    what you need to know if you plan to extend the system or if you're just curious
    about how it works. It also covers the auto-escaping feature, a security measure
    you'll no doubt notice over time as you continue to use Django.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了Django模板系统的内部。它涵盖了如果你计划扩展系统或者只是对它的工作方式感到好奇，你需要了解的内容。它还涵盖了自动转义功能，这是一项安全措施，随着你继续使用Django，你肯定会注意到它。
- en: Template language review
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板语言回顾
- en: 'First, let''s quickly review a number of terms introduced in [Chapter 3](ch03.xhtml
    "Chapter 3. Templates"), *Templates*:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们快速回顾一些在[第3章](ch03.xhtml "第3章。模板")*模板*中引入的术语：
- en: A **template** is a text document, or a normal Python string, that is marked
    up using the Django template language. A template can contain template tags and
    variables.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板**是一个文本文档，或者是一个普通的Python字符串，使用Django模板语言进行标记。模板可以包含模板标签和变量。'
- en: A **template tag** is a symbol within a template that does something. This definition
    is deliberately vague. For example, a template tag can produce content, serve
    as a control structure (an `if` statement or `for` loop), grab content from a
    database, or enable access to other template tags.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板标签**是模板中的一个符号，它执行某些操作。这个定义是故意模糊的。例如，模板标签可以生成内容，充当控制结构（`if`语句或`for`循环），从数据库中获取内容，或者启用对其他模板标签的访问。'
- en: 'Template tags are surrounded by `{%` and `%}`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 模板标签用`{%`和`%}`括起来：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A **variable** is a symbol within a template that outputs a value.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量**是模板中输出值的符号。'
- en: 'Variable tags are surrounded by `{{` and `}}`:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量标签用`{{`和`}}`括起来：
- en: A **context** is a `name->value` mapping (similar to a Python dictionary) that
    is passed to a template.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**是传递给模板的`name->value`映射（类似于Python字典）。'
- en: A template **renders** a context by replacing the variable "holes" with values
    from the context and executing all template tags.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板通过用上下文中的值替换变量“洞”并执行所有模板标签来**渲染**上下文。
- en: For more details about the basics of these terms, refer back to [Chapter 3](ch03.xhtml
    "Chapter 3. Templates"), *Templates*. The rest of this chapter discusses ways
    of extending the template engine. First, though, let's take a quick look at a
    few internals left out of [Chapter 3](ch03.xhtml "Chapter 3. Templates"), *Templates*,
    for simplicity.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些术语的基础知识的更多细节，请参考[第3章](ch03.xhtml "第3章。模板")*模板*。本章的其余部分讨论了扩展模板引擎的方法。不过，首先让我们简要地看一下[第3章](ch03.xhtml
    "第3章。模板")*模板*中省略的一些内部内容，以简化。
- en: Requestcontext and context processors
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RequestContext和上下文处理器
- en: When rendering a template, you need a context. This can be an instance of `django.template.Context`,
    but Django also comes with a subclass, `django.template.RequestContext`, that
    acts slightly differently.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染模板时，你需要一个上下文。这可以是`django.template.Context`的一个实例，但Django也带有一个子类`django.template.RequestContext`，它的行为略有不同。
- en: '`RequestContext` adds a bunch of variables to your template context by default-things
    like the `HttpRequest` object or information about the currently logged-in user.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestContext`默认情况下向您的模板上下文添加了一堆变量-诸如`HttpRequest`对象或有关当前登录用户的信息。'
- en: 'The `render()` shortcut creates a `RequestContext` unless it''s passed a different
    context instance explicitly. For example, consider these two views:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`render()`快捷方式会创建一个`RequestContext`，除非显式传递了不同的上下文实例。例如，考虑这两个视图：'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: (Note that we're deliberately not using the `render()` shortcut in these examples-we're
    manually loading the templates, constructing the context objects and rendering
    the templates. We're spelling out all of the steps for the purpose of clarity.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，在这些示例中，我们故意没有使用`render()`的快捷方式-我们手动加载模板，构建上下文对象并渲染模板。我们为了清晰起见，详细说明了所有步骤。）
- en: Each view passes the same three variables-`app`, `user`, and `ip_address`-o
    its template. Wouldn't it be nice if we could remove that redundancy? `RequestContext`
    and context processors were created to solve this problem. Context processors
    let you specify a number of variables that get set in each context automatically-without
    you having to specify the variables in each `render()` call.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图都传递相同的三个变量-`app`，`user`和`ip_address`-到它的模板。如果我们能够消除这种冗余，那不是很好吗？`RequestContext`和上下文处理器被创建来解决这个问题。上下文处理器允许您指定一些变量，这些变量在每个上下文中自动设置-而无需在每个`render()`调用中指定这些变量。
- en: 'The catch is that you have to use `RequestContext` instead of `Context` when
    you render a template. The most low-level way of using context processors is to
    create some processors and pass them to `RequestContext`. Here''s how the above
    example could be written with context processors:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，当你渲染模板时，你必须使用`RequestContext`而不是`Context`。使用上下文处理器的最低级别方法是创建一些处理器并将它们传递给`RequestContext`。以下是如何使用上下文处理器编写上面的示例：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s step through this code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解这段代码：
- en: First, we define a function `custom_proc`. This is a context processor-it takes
    an `HttpRequest` object and returns a dictionary of variables to use in the template
    context. That's all it does.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个函数`custom_proc`。这是一个上下文处理器-它接受一个`HttpRequest`对象，并返回一个要在模板上下文中使用的变量字典。就是这样。
- en: We've changed the two view functions to use `RequestContext` instead of `Context`.
    There are two differences in how the context is constructed. One, `RequestContext`
    requires the first argument to be an `HttpRequest` object-the one that was passed
    into the view function in the first place (`request`). Two, `RequestContext` takes
    an optional `processors` argument, which is a list or tuple of context processor
    functions to use. Here, we pass in `custom_proc`, the custom processor we defined
    above.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已将两个视图函数更改为使用`RequestContext`而不是`Context`。上下文构造方式有两个不同之处。首先，`RequestContext`要求第一个参数是一个`HttpRequest`对象-首先传递到视图函数中的对象（`request`）。其次，`RequestContext`需要一个可选的`processors`参数，它是要使用的上下文处理器函数的列表或元组。在这里，我们传入`custom_proc`，我们上面定义的自定义处理器。
- en: Each view no longer has to include `app`, `user` or `ip_address` in its context
    construction, because those are provided by `custom_proc`.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个视图不再必须在其上下文构造中包含`app`，`user`或`ip_address`，因为这些由`custom_proc`提供。
- en: Each view still has the flexibility to introduce any custom template variables
    it might need. In this example, the `message` template variable is set differently
    in each view.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个视图仍然具有灵活性，可以引入任何可能需要的自定义模板变量。在此示例中，“message”模板变量在每个视图中设置不同。
- en: In [Chapter 3](ch03.xhtml "Chapter 3. Templates"), *Templates*, I introduced
    the `render()` shortcut, which saves you from having to call `loader.get_template()`,
    then create a `Context`, then call the `render()` method on the template.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.xhtml "第3章。模板")*模板*中，我介绍了`render()`快捷方式，它使您无需调用`loader.get_template()`，然后创建一个`Context`，然后在模板上调用`render()`方法。
- en: 'In order to demonstrate the lower-level workings of context processors, the
    above examples didn''t use `render()`. But it''s possible-and preferable-to use
    context processors with `render()`. Do this with the `context_instance` argument,
    like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示上下文处理器的较低级别工作，上面的示例没有使用`render()`。但是，使用`render()`与上下文处理器是可能的，也是更好的。可以使用`context_instance`参数来实现这一点，如下所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we've trimmed down each view's template rendering code to a single (wrapped)
    line. This is an improvement, but, evaluating the conciseness of this code, we
    have to admit we're now almost overdosing on the other end of the spectrum. We've
    removed redundancy in data (our template variables) at the cost of adding redundancy
    in code (in the `processors` call).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已将每个视图的模板渲染代码简化为单个（包装）行。这是一个改进，但是，评估这段代码的简洁性时，我们必须承认我们现在几乎过度使用了另一端的频谱。我们消除了数据中的冗余（我们的模板变量），但增加了代码中的冗余（在`processors`调用中）。
- en: Using context processors doesn't save you much typing if you have to type `processors`
    all the time. For that reason, Django provides support for global context processors.
    The `context_processors` setting (in your `settings.py`) designates which context
    processors should always be applied to `RequestContext`. This removes the need
    to specify `processors` each time you use `RequestContext`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您必须一直输入`processors`，使用上下文处理器并不能节省太多输入。因此，Django提供了全局上下文处理器的支持。`context_processors`设置（在您的`settings.py`中）指定应始终应用于`RequestContext`的上下文处理器。这样可以避免每次使用`RequestContext`时都需要指定`processors`。
- en: 'By default, `context_processors` is set to the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`context_processors`设置如下：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This setting is a list of callables that use the same interface as our `custom_proc`
    function above-functions that take a request object as their argument and return
    a dictionary of items to be merged into the context. Note that the values in `context_processors`
    are specified as **strings**, which means the processors are required to be somewhere
    on your Python path (so you can refer to them from the setting).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置是一个可调用对象的列表，其接口与上面的`custom_proc`函数相同-接受请求对象作为其参数，并返回要合并到上下文中的项目的字典。请注意，`context_processors`中的值被指定为**字符串**，这意味着处理器必须在Python路径的某个位置（因此您可以从设置中引用它们）。
- en: 'Each processor is applied in order. That is, if one processor adds a variable
    to the context and a second processor adds a variable with the same name, the
    second will override the first. Django provides a number of simple context processors,
    including the ones that are enabled by default:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个处理器都按顺序应用。也就是说，如果一个处理器向上下文添加一个变量，并且第二个处理器使用相同的名称添加一个变量，则第二个处理器将覆盖第一个处理器。Django提供了许多简单的上下文处理器，包括默认启用的处理器：
- en: auth
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: auth
- en: '`django.contrib.auth.context_processors.auth`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`django.contrib.auth.context_processors.auth`'
- en: 'If this processor is enabled, every `RequestContext` will contain these variables:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了此处理器，则每个“RequestContext”都将包含这些变量：
- en: '`user`: An `auth.User` instance representing the currently logged-in user (or
    an `AnonymousUser` instance, if the client isn''t logged in).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`：表示当前登录用户的`auth.User`实例（或`AnonymousUser`实例，如果客户端未登录）。'
- en: '`perms`: An instance of `django.contrib.auth.context_processors.PermWrapper`,
    representing the permissions that the currently logged-in user has.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`perms`：表示当前登录用户具有的权限的`django.contrib.auth.context_processors.PermWrapper`实例。'
- en: DEBUG
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DEBUG
- en: '`django.template.context_processors.debug`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`django.template.context_processors.debug`'
- en: 'If this processor is enabled, every `RequestContext` will contain these two
    variables-but only if your `DEBUG` setting is set to `True` and the request''s
    IP address (`request.META[''REMOTE_ADDR'']`) is in the `INTERNAL_IPS` setting:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了此处理器，则每个“RequestContext”都将包含这两个变量-但仅当您的“DEBUG”设置为“True”并且请求的IP地址（`request.META['REMOTE_ADDR']`）在`INTERNAL_IPS`设置中时：
- en: '`debug`-`True`: You can use this in templates to test whether you''re in `DEBUG`
    mode.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug`-`True`：您可以在模板中使用此选项来测试是否处于“DEBUG”模式。'
- en: '`sql_queries`: A list of `{''sql'': ..., ''time'': ...}` dictionaries, representing
    every SQL query that has happened so far during the request and how long it took.
    The list is in order by query and lazily generated on access.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql_queries`：一个`{''sql'': ..., ''time'': ...}`字典的列表，表示请求期间发生的每个SQL查询及其所花费的时间。列表按查询顺序生成，并在访问时惰性生成。'
- en: i18n
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: i18n
- en: '`django.template.context_processors.i18n`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`django.template.context_processors.i18n`'
- en: 'If this processor is enabled, every `RequestContext` will contain these two
    variables:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了此处理器，则每个“RequestContext”都将包含这两个变量：
- en: '`LANGUAGES`: The value of the `LANGUAGES` setting.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LANGUAGES`：`LANGUAGES`设置的值。'
- en: '`LANGUAGE_CODE`: `request.LANGUAGE_CODE`, if it exists. Otherwise, the value
    of the `LANGUAGE_CODE` setting.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LANGUAGE_CODE`：`request.LANGUAGE_CODE`，如果存在的话。否则，为`LANGUAGE_CODE`设置的值。'
- en: MEDIA
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 媒体
- en: '`django.template.context_processors.media`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`django.template.context_processors.media`'
- en: If this processor is enabled, every `RequestContext` will contain a variable
    `MEDIA_URL`, providing the value of the `MEDIA_URL` setting.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了此处理器，每个`RequestContext`都将包含一个名为`MEDIA_URL`的变量，该变量提供`MEDIA_URL`设置的值。
- en: static
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态
- en: '`django.template.context_processors.static`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`django.template.context_processors.static`'
- en: If this processor is enabled, every `RequestContext` will contain a variable
    `STATIC_URL`, providing the value of the `STATIC_URL` setting.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了此处理器，每个`RequestContext`都将包含一个名为`STATIC_URL`的变量，该变量提供`STATIC_URL`设置的值。
- en: csrf
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: csrf
- en: '`django.template.context_processors.csrf`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`django.template.context_processors.csrf`'
- en: This processor adds a token that is needed by the `csrf_token` template tag
    for protection against cross site request forgeries (see [Chapter 19](ch19.xhtml
    "Chapter 19. Security in Django"), *Security in Django*).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理器添加了一个`csrf_token`模板标记所需的令牌，以防止跨站点请求伪造（请参见[第19章](ch19.xhtml "第19章 Django中的安全性")，“Django中的安全性”）。
- en: Request
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求
- en: '`django.template.context_processors.request`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`django.template.context_processors.request`'
- en: If this processor is enabled, every `RequestContext` will contain a variable
    `request`, which is the current `HttpRequest`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了此处理器，每个`RequestContext`都将包含一个名为`request`的变量，该变量是当前的`HttpRequest`。
- en: messages
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息
- en: '`django.contrib.messages.context_processors.messages`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`django.contrib.messages.context_processors.messages`'
- en: 'If this processor is enabled, every `RequestContext` will contain these two
    variables:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了此处理器，每个`RequestContext`都将包含这两个变量：
- en: '`messages`: A list of messages (as strings) that have been set via the messages
    framework.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`messages`：已通过消息框架设置的消息（作为字符串）的列表。'
- en: '`DEFAULT_MESSAGE_LEVELS`: A mapping of the message level names to their numeric
    value.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEFAULT_MESSAGE_LEVELS`：消息级别名称与其数值的映射。'
- en: Guidelines for writing our own context processors
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自己的上下文处理器指南
- en: 'A context processor has a very simple interface: It''s just a Python function
    that takes one argument, an `HttpRequest` object, and returns a dictionary that
    gets added to the template context. Each context processor must return a dictionary.
    Here are a few tips for rolling your own:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文处理器具有非常简单的接口：它只是一个接受一个`HttpRequest`对象的Python函数，并返回一个添加到模板上下文中的字典。每个上下文处理器必须返回一个字典。以下是一些编写自己上下文处理器的提示：
- en: Make each context processor responsible for the smallest subset of functionality
    possible. It's easy to use multiple processors, so you might as well split functionality
    into logical pieces for future reuse.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使每个上下文处理器负责尽可能小的功能子集。使用多个处理器很容易，因此最好将功能拆分为将来重用的逻辑片段。
- en: Keep in mind that any context processor in `TEMPLATE_CONTEXT_PROCESSORS` will
    be available in every template powered by that settings file, so try to pick variable
    names that are unlikely to conflict with variable names your templates might be
    using independently. As variable names are case-sensitive, it's not a bad idea
    to use all caps for variables that a processor provides.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住，`TEMPLATE_CONTEXT_PROCESSORS`中的任何上下文处理器都将在由该设置文件提供动力的每个模板中可用，因此请尝试选择与模板可能独立使用的变量名不太可能发生冲突的变量名。由于变量名区分大小写，因此最好使用所有大写字母来表示处理器提供的变量。
- en: Custom context processors can live anywhere in your code base. All Django cares
    about is that your custom context processors are pointed to by the `'context_processors'`
    option in your `TEMPLATES` setting-or the `context_processors` argument of `Engine`
    if you're using it directly. With that said, the convention is to save them in
    a file called `context_processors.py` within your app or project.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义上下文处理器可以存在于代码库中的任何位置。Django关心的是您的自定义上下文处理器是否由`TEMPLATES`设置中的`'context_processors'`选项指向，或者如果直接使用`Engine`，则由`Engine`的`context_processors`参数指向。话虽如此，惯例是将它们保存在应用程序或项目中名为`context_processors.py`的文件中。
- en: Automatic HTML escaping
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动HTML转义
- en: 'When generating HTML from templates, there''s always a risk that a variable
    will include characters that affect the resulting HTML. For example, consider
    this template fragment:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在从模板生成HTML时，总是存在一个变量包含影响生成的HTML的字符的风险。例如，考虑这个模板片段：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At first, this seems like a harmless way to display a user''s name, but consider
    what would happen if the user entered his name as this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这似乎是一种无害的显示用户姓名的方式，但请考虑如果用户将他的名字输入为这样会发生什么：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With this name value, the template would be rendered as:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个名称值，模板将被渲染为：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '... which means the browser would pop-up a JavaScript alert box! Similarly,
    what if the name contained a `''<''` symbol, like this?'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ……这意味着浏览器将弹出一个JavaScript警报框！同样，如果名称包含`'<'`符号，会怎么样？
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That would result in a rendered template like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致渲染的模板如下：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '... which, in turn, would result in the remainder of the Web page being bolded!
    Clearly, user-submitted data shouldn''t be trusted blindly and inserted directly
    into your Web pages, because a malicious user could use this kind of hole to do
    potentially bad things.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ……这将导致网页的其余部分变粗！显然，不应盲目信任用户提交的数据并直接插入到您的网页中，因为恶意用户可能利用这种漏洞做出潜在的坏事。
- en: 'This type of security exploit is called a Cross Site Scripting (XSS) attack.
    (For more on security, see [Chapter 19](ch19.xhtml "Chapter 19. Security in Django"),
    *Security in Django*). To avoid this problem, you have two options:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种安全漏洞称为跨站脚本（XSS）攻击。（有关安全性的更多信息，请参见[第19章](ch19.xhtml "第19章 Django中的安全性")，“Django中的安全性”）。为了避免这个问题，您有两个选择：
- en: One, you can make sure to run each untrusted variable through the `escape` filter,
    which converts potentially harmful HTML characters to unharmful ones. This was
    the default solution in Django for its first few years, but the problem is that
    it puts the onus on *you*, the developer / template author, to ensure you're escaping
    everything. It's easy to forget to escape data.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，您可以确保通过`escape`过滤器运行每个不受信任的变量，该过滤器将潜在有害的HTML字符转换为无害的字符。这是Django最初几年的默认解决方案，但问题在于它把责任放在了*您*，开发者/模板作者身上，确保您转义了所有内容。很容易忘记转义数据。
- en: Two, you can take advantage of Django's automatic HTML escaping. The remainder
    of this section describes how auto-escaping works.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，您可以利用Django的自动HTML转义。本节的其余部分将描述自动转义的工作原理。
- en: 'By default in Django, every template automatically escapes the output of every
    variable tag. Specifically, these five characters are escaped:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Django中，默认情况下，每个模板都会自动转义每个变量标签的输出。具体来说，这五个字符会被转义：
- en: '`<` is converted to `&lt;`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<` 被转换为 `&lt;`'
- en: '`>` is converted to `&gt;`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>` 被转换为 `&gt;`'
- en: '`''` (single quote) is converted to `''`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''`（单引号）被转换为`''`'
- en: '`"` (double quote) is converted to `&quot;`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"`（双引号）被转换为`&quot;`'
- en: '`&` is converted to `&amp;`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&` 被转换为 `&amp;`'
- en: Again, we stress that this behavior is on by default. If you're using Django's
    template system, you're protected.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这种行为默认情况下是开启的。如果您使用Django的模板系统，您就受到了保护。
- en: How to turn it off
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何关闭它
- en: If you don't want data to be auto-escaped on a per-site, per-template level
    or per-variable level, you can turn it off in several ways. Why would you want
    to turn it off? Because sometimes, template variables contain data that you intend
    to be rendered as raw HTML, in which case you don't want their contents to be
    escaped.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不希望数据在每个站点、每个模板级别或每个变量级别自动转义，可以通过多种方式关闭它。为什么要关闭它？因为有时模板变量包含您希望呈现为原始HTML的数据，这种情况下您不希望它们的内容被转义。
- en: For example, you might store a blob of trusted HTML in your database and want
    to embed that directly into your template. Or, you might be using Django's template
    system to produce text that is not HTML-like an e-mail message, for instance.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可能会在数据库中存储一大段受信任的HTML，并希望直接将其嵌入到模板中。或者，您可能正在使用Django的模板系统来生成非HTML文本-例如电子邮件消息。
- en: For individual variables
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于单个变量
- en: 'To disable auto-escaping for an individual variable, use the `safe` filter:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要为单个变量禁用自动转义，请使用`safe`过滤器：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Think of *safe* as shorthand for *safe from further escaping* or *can be safely
    interpreted as HTML*. In this example, if `data` contains `<b>`, the output will
    be:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将*safe*视为*免受进一步转义*或*可以安全解释为HTML*的简写。在这个例子中，如果`data`包含`<b>`，输出将是：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For template blocks
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于模板块
- en: 'To control auto-escaping for a template, wrap the template (or just a particular
    section of the template) in the `autoescape` tag, like so:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制模板的自动转义，可以将模板（或模板的特定部分）包装在`autoescape`标签中，如下所示：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `autoescape` tag takes either `on` or `off` as its argument. At times,
    you might want to force auto-escaping when it would otherwise be disabled. Here
    is an example template:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoescape`标签接受`on`或`off`作为参数。有时，您可能希望在本来被禁用自动转义的情况下强制进行自动转义。以下是一个示例模板：'
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The auto-escaping tag passes its effect on to templates that extend the current
    one as well as templates included via the `include` tag, just like all block tags.
    For example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 自动转义标签会将其效果传递给扩展当前模板以及通过`include`标签包含的模板，就像所有块标签一样。例如：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Because auto-escaping is turned off in the base template, it will also be turned
    off in the child template, resulting in the following rendered HTML when the `greeting`
    variable contains the string `<b>Hello!</b>`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因为基础模板中关闭了自动转义，所以在子模板中也会关闭自动转义，当`greeting`变量包含字符串`<b>Hello!</b>`时，将会产生以下渲染的HTML：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Generally, template authors don't need to worry about auto-escaping very much.
    Developers on the Python side (people writing views and custom filters) need to
    think about the cases in which data shouldn't be escaped, and mark data appropriately,
    so things work in the template.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，模板作者不需要太担心自动转义。Python端的开发人员（编写视图和自定义过滤器的人）需要考虑数据不应该被转义的情况，并适当标记数据，以便在模板中正常工作。
- en: If you're creating a template that might be used in situations where you're
    not sure whether auto-escaping is enabled, then add an `escape` filter to any
    variable that needs escaping. When auto-escaping is on, there's no danger of the
    `escape` filter double-escaping data-the `escape` filter does not affect auto-escaped
    variables.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在创建一个可能在您不确定自动转义是否启用的情况下使用的模板，那么请为任何需要转义的变量添加`escape`过滤器。当自动转义开启时，`escape`过滤器不会导致数据双重转义-`escape`过滤器不会影响自动转义的变量。
- en: Automatic escaping of string literals in filter arguments
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在过滤器参数中自动转义字符串文字
- en: 'As we mentioned earlier, filter arguments can be strings:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，过滤器参数可以是字符串：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All string literals are inserted without any automatic escaping into the template-they
    act as if they were all passed through the `safe` filter. The reasoning behind
    this is that the template author is in control of what goes into the string literal,
    so they can make sure the text is correctly escaped when the template is written.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所有字符串文字都会被插入到模板中，而不会进行任何自动转义-它们的行为就好像它们都通过了`safe`过滤器。背后的原因是模板作者控制着字符串文字的内容，因此他们可以确保在编写模板时正确地转义文本。
- en: This means you would write
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您应该这样写
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '... rather than'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '...而不是'
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This doesn't affect what happens to data coming from the variable itself. The
    variable's contents are still automatically escaped, if necessary, because they're
    beyond the control of the template author.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会影响来自变量本身的数据。变量的内容仍然会在必要时自动转义，因为它们超出了模板作者的控制。
- en: Inside Template loading
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板加载内部
- en: Generally, you'll store templates in files on your filesystem rather than using
    the low-level `Template` API yourself. Save templates in a directory specified
    as a template directory. Django searches for template directories in a number
    of places, depending on your template loading settings (see *Loader types* below),
    but the most basic way of specifying template directories is by using the `DIRS`
    option.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会将模板存储在文件系统中，而不是自己使用低级别的`Template` API。将模板保存在指定为模板目录的目录中。 Django根据您的模板加载设置在许多地方搜索模板目录（请参阅下面的*Loader类型*），但指定模板目录的最基本方法是使用`DIRS`选项。
- en: The DIRS option
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DIRS选项
- en: 'Tell Django what your template directories are by using the `DIRS` option in
    the `TEMPLATES` setting in your settings file-or the `dirs` argument of `Engine`.
    This should be set to a list of strings that contain full paths to your template
    directories:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在设置文件中的`TEMPLATES`设置中使用`DIRS`选项或在`Engine`的`dirs`参数中使用`DIRS`选项，告诉Django您的模板目录是什么。这应设置为包含完整路径的字符串列表，以包含模板目录：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Your templates can go anywhere you want, as long as the directories and templates
    are readable by the Web server. They can have any extension you want, such as
    `.html` or `.txt`, or they can have no extension at all. Note that these paths
    should use Unix-style forward slashes, even on Windows.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您的模板可以放在任何您想要的地方，只要目录和模板对Web服务器可读。它们可以具有任何您想要的扩展名，例如`.html`或`.txt`，或者它们可以根本没有扩展名。请注意，这些路径应使用Unix样式的正斜杠，即使在Windows上也是如此。
- en: Loader types
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载程序类型
- en: By default, Django uses a filesystem-based template loader, but Django comes
    with a few other template loaders, which know how to load templates from other
    sources; the most commonly used of them, the apps loader, is described below.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Django使用基于文件系统的模板加载程序，但Django还配备了其他几个模板加载程序，它们知道如何从其他来源加载模板；其中最常用的应用程序加载程序将在下面进行描述。
- en: Filesystem loader
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件系统加载程序
- en: '`filesystem.Loader` Loads templates from the filesystem, according to `DIRS
    <TEMPLATES-DIRS>`. This loader is enabled by default. However, it won''t find
    any templates until you set `DIRS <TEMPLATES-DIRS>` to a non-empty list:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`filesystem.Loader`从文件系统加载模板，根据`DIRS <TEMPLATES-DIRS>`。此加载程序默认启用。但是，直到您将`DIRS
    <TEMPLATES-DIRS>`设置为非空列表之前，它才能找到任何模板：'
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: App directories loader
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序目录加载程序
- en: '`app_directories.Loader` Loads templates from Django apps on the filesystem.
    For each app in `INSTALLED_APPS`, the loader looks for a `templates` subdirectory.
    If the directory exists, Django looks for templates in there. This means you can
    store templates with your individual apps. This also makes it easy to distribute
    Django apps with default templates. For example, for this setting:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`app_directories.Loader`从文件系统加载Django应用程序的模板。对于`INSTALLED_APPS`中的每个应用程序，加载程序都会查找`templates`子目录。如果目录存在，Django将在其中查找模板。这意味着您可以将模板与各个应用程序一起存储。这也使得很容易使用默认模板分发Django应用程序。例如，对于此设置：'
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`get_template(''foo.html'')` will look for `foo.html` in these directories,
    in this order:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_template(''foo.html'')`将按照这些顺序在这些目录中查找`foo.html`：'
- en: '`/path/to/myproject/reviews/templates/`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/path/to/myproject/reviews/templates/`'
- en: '`/path/to/myproject/music/templates/`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/path/to/myproject/music/templates/`'
- en: and will use the one it finds first.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用它找到的第一个。
- en: '**The order of INSTALLED_APPS is significant!**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**INSTALLED_APPS的顺序很重要！**'
- en: For example, if you want to customize the Django admin, you might choose to
    override the standard `admin/base_site.html` template, from `django.contrib.admin`,
    with your own `admin/base_site.html` in `myproject.reviews`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想要自定义Django管理界面，您可能会选择使用自己的`myproject.reviews`中的`admin/base_site.html`覆盖标准的`admin/base_site.html`模板，而不是使用`django.contrib.admin`。
- en: You must then make sure that your `myproject.reviews` comes before `django.contrib.admin`
    in `INSTALLED_APPS`, otherwise `django.contrib.admin`'s will be loaded first and
    yours will be ignored.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您必须确保`myproject.reviews`在`INSTALLED_APPS`中出现在`django.contrib.admin`之前，否则将首先加载`django.contrib.admin`，并且您的将被忽略。
- en: 'Note that the loader performs an optimization when it first runs: it caches
    a list of which `INSTALLED_APPS` packages have a `templates` subdirectory.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，加载程序在首次运行时执行优化：它缓存了具有`templates`子目录的`INSTALLED_APPS`包的列表。
- en: 'You can enable this loader simply by setting `APP_DIRS` to `True`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需将`APP_DIRS`设置为`True`即可启用此加载程序：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Other loaders
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他加载程序
- en: 'The remaining template loaders are:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的模板加载程序是：
- en: '`django.template.loaders.eggs.Loader`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.template.loaders.eggs.Loader`'
- en: '`django.template.loaders.cached.Loader`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.template.loaders.cached.Loader`'
- en: '`django.template.loaders.locmem.Loader`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.template.loaders.locmem.Loader`'
- en: These loaders are disabled by default, but you can activate them by adding a
    `loaders` option to your `DjangoTemplates` backend in the `TEMPLATES` setting
    or passing a `loaders` argument to `Engine`. Details on these advanced loaders,
    as well as building your own custom loader, can be found on the Django Project
    website.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些加载程序默认情况下是禁用的，但是您可以通过在`TEMPLATES`设置中的`DjangoTemplates`后端中添加`loaders`选项或将`loaders`参数传递给`Engine`来激活它们。有关这些高级加载程序的详细信息，以及构建自己的自定义加载程序，可以在Django项目网站上找到。
- en: Extending the template system
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展模板系统
- en: Now that you understand a bit more about the internals of the template system,
    let's look at how to extend the system with custom code. Most template customization
    comes in the form of custom template tags and/or filters. Although the Django
    template language comes with many built-in tags and filters, you'll probably assemble
    your own libraries of tags and filters that fit your own needs. Fortunately, it's
    quite easy to define your own functionality.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对模板系统的内部工作有了更多了解，让我们看看如何使用自定义代码扩展系统。大多数模板定制以自定义模板标签和/或过滤器的形式出现。尽管Django模板语言带有许多内置标签和过滤器，但您可能会组装自己的标签和过滤器库，以满足自己的需求。幸运的是，定义自己的功能非常容易。
- en: Code layout
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码布局
- en: Custom template tags and filters must live inside a Django app. If they relate
    to an existing app it makes sense to bundle them there; otherwise, you should
    create a new app to hold them. The app should contain a `templatetags` directory,
    at the same level as `models.py`, `views.py`, and so on. If this doesn't already
    exist, create it-don't forget the `__init__.py` file to ensure the directory is
    treated as a Python package.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义模板标签和过滤器必须位于Django应用程序中。如果它们与现有应用程序相关，将它们捆绑在那里是有意义的；否则，您应该创建一个新的应用程序来保存它们。该应用程序应该包含一个`templatetags`目录，与`models.py`、`views.py`等文件处于同一级别。如果这个目录还不存在，请创建它-不要忘记`__init__.py`文件，以确保该目录被视为Python包。
- en: After adding this module, you will need to restart your server before you can
    use the tags or filters in templates. Your custom tags and filters will live in
    a module inside the `templatetags` directory.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此模块后，您需要在使用模板中的标签或过滤器之前重新启动服务器。您的自定义标签和过滤器将位于`templatetags`目录中的一个模块中。
- en: The name of the module file is the name you'll use to load the tags later, so
    be careful to pick a name that won't clash with custom tags and filters in another
    app.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 模块文件的名称是您以后将用来加载标签的名称，因此要小心选择一个不会与另一个应用程序中的自定义标签和过滤器冲突的名称。
- en: 'For example, if your custom tags/filters are in a file called `review_extras.py`,
    your app layout might look like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您的自定义标签/过滤器在名为`review_extras.py`的文件中，您的应用程序布局可能如下所示：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And in your template you would use the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的模板中，您将使用以下内容：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The app that contains the custom tags must be in `INSTALLED_APPS` in order for
    the `{% load %}` tag to work.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 包含自定义标签的应用程序必须在`INSTALLED_APPS`中，以便`{% load %}`标签能够工作。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Behind the scenes**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**幕后**'
- en: For a ton of examples, read the source code for Django's default filters and
    tags. They're in `django/template/defaultfilters.py` and `django/template/defaulttags.py`,
    respectively. For more information on the `load` tag, read its documentation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取大量示例，请阅读Django默认过滤器和标签的源代码。它们分别位于`django/template/defaultfilters.py`和`django/template/defaulttags.py`中。有关`load`标签的更多信息，请阅读其文档。
- en: Creating a template library
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模板库
- en: Whether you're writing custom tags or filters, the first thing to do is to create
    a **template library**-a small bit of infrastructure Django can hook into.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是编写自定义标签还是过滤器，首先要做的是创建一个**模板库**-这是Django可以连接到的一小部分基础设施。
- en: 'Creating a template library is a two-step process:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模板库是一个两步过程：
- en: First, decide which Django application should house the template library. If
    you've created an app via `manage.py startapp`, you can put it in there, or you
    can create another app solely for the template library. We'd recommend the latter,
    because your filters might be useful to you in future projects. Whichever route
    you take, make sure to add the app to your `INSTALLED_APPS` setting. I'll explain
    this shortly.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，决定哪个Django应用程序应该包含模板库。如果您通过`manage.py startapp`创建了一个应用程序，您可以将其放在那里，或者您可以创建另一个仅用于模板库的应用程序。我们建议选择后者，因为您的过滤器可能对将来的项目有用。无论您选择哪种路线，请确保将应用程序添加到您的`INSTALLED_APPS`设置中。我马上会解释这一点。
- en: 'Second, create a `templatetags` directory in the appropriate Django application''s
    package. It should be on the same level as `models.py`, `views.py`, and so forth.
    For example:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，在适当的Django应用程序包中创建一个`templatetags`目录。它应该与`models.py`、`views.py`等文件处于同一级别。例如：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create two empty files in the `templatetags` directory: an `__init__.py` file
    (to indicate to Python that this is a package containing Python code) and a file
    that will contain your custom tag/filter definitions. The name of the latter file
    is what you''ll use to load the tags later. For example, if your custom tags/filters
    are in a file called `review_extras.py`, you''d write the following in a template:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`templatetags`目录中创建两个空文件：一个`__init__.py`文件（表示这是一个包含Python代码的包）和一个包含自定义标签/过滤器定义的文件。后者的文件名是您以后将用来加载标签的名称。例如，如果您的自定义标签/过滤器在名为`review_extras.py`的文件中，您可以在模板中写入以下内容：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `{% load %}` tag looks at your `INSTALLED_APPS` setting and only allows
    the loading of template libraries within installed Django applications. This is
    a security feature; it allows you to host Python code for many template libraries
    on a single computer without enabling access to all of them for every Django installation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% load %}`标签查看您的`INSTALLED_APPS`设置，并且只允许加载已安装的Django应用程序中的模板库。这是一个安全功能；它允许您在单台计算机上托管许多模板库的Python代码，而不会为每个Django安装启用对所有模板库的访问。'
- en: If you write a template library that isn't tied to any particular models/views,
    it's valid and quite normal to have a Django application package that contains
    only a `templatetags` package.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编写的模板库与任何特定的模型/视图无关，那么拥有一个仅包含`templatetags`包的Django应用程序包是有效的和非常正常的。
- en: There's no limit on how many modules you put in the `templatetags` package.
    Just keep in mind that a `{% load %}` statement will load tags/filters for the
    given Python module name, not the name of the application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在`templatetags`包中放置多少模块都没有限制。只需记住，`{% load %}`语句将加载给定Python模块名称的标签/过滤器，而不是应用程序的名称。
- en: Once you've created that Python module, you'll just have to write a bit of Python
    code, depending on whether you're writing filters or tags. To be a valid tag library,
    the module must contain a module-level variable named `register` that is an instance
    of `template.Library`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了该Python模块后，您只需根据您是编写过滤器还是标签来编写一些Python代码。要成为有效的标签库，模块必须包含一个名为`register`的模块级变量，它是`template.Library`的实例。
- en: 'This is the data structure in which all the tags and filters are registered.
    So, near the top of your module, insert the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所有标签和过滤器注册的数据结构。因此，在您的模块顶部附近，插入以下内容：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Custom template tags and filters
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义模板标签和过滤器
- en: Django's template language comes with a wide variety of built-in tags and filters
    designed to address the presentation logic needs of your application. Nevertheless,
    you may find yourself needing functionality that is not covered by the core set
    of template primitives.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Django的模板语言配备了各种内置标签和过滤器，旨在满足应用程序的呈现逻辑需求。尽管如此，您可能会发现自己需要的功能不在核心模板原语集中。
- en: You can extend the template engine by defining custom tags and filters using
    Python, and then make them available to your templates using the `{% load %}`
    tag.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用Python定义自定义标签和过滤器来扩展模板引擎，然后使用`{% load %}`标签将其提供给模板。
- en: Writing custom template filters
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写自定义模板过滤器
- en: 'Custom filters are just Python functions that take one or two arguments:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义过滤器只是接受一个或两个参数的Python函数：
- en: The value of the variable (input)-not necessarily a string.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的值（输入）-不一定是一个字符串。
- en: The value of the argument-this can have a default value, or be left out altogether.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数的值-这可以有一个默认值，或者完全省略。
- en: For example, in the filter `{{ var|foo:"bar" }}`, the filter `foo` would be
    passed the variable `var` and the argument `"bar"`. Since the template language
    doesn't provide exception handling, any exception raised from a template filter
    will be exposed as a server error.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在过滤器`{{ var|foo:"bar" }}`中，过滤器`foo`将接收变量`var`和参数`"bar"`。由于模板语言不提供异常处理，从模板过滤器引发的任何异常都将暴露为服务器错误。
- en: 'Thus, filter functions should avoid raising exceptions if there is a reasonable
    fallback value to return. In case of input that represents a clear bug in a template,
    raising an exception may still be better than silent failure which hides the bug.
    Here''s an example filter definition:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果有一个合理的回退值可以返回，过滤函数应该避免引发异常。在模板中表示明显错误的输入情况下，引发异常可能仍然比隐藏错误的静默失败更好。这是一个示例过滤器定义：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And here''s an example of how that filter would be used:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该过滤器的使用示例：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Most filters don''t take arguments. In this case, just leave the argument out
    of your function. Example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数过滤器不带参数。在这种情况下，只需在函数中省略参数。例如：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Registering custom filters
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册自定义过滤器
- en: 'Once you''ve written your filter definition, you need to register it with your
    `Library` instance, to make it available to Django''s template language:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 编写完过滤器定义后，您需要将其注册到您的`Library`实例中，以使其可用于Django的模板语言：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `Library.filter()` method takes two arguments:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Library.filter()`方法接受两个参数：'
- en: The name of the filter-a string.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤器的名称-一个字符串。
- en: The compilation function-a Python function (not the name of the function as
    a string).
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译函数-一个Python函数（而不是函数的名称作为字符串）。
- en: 'You can use `register.filter()` as a decorator instead:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`register.filter()`用作装饰器：
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you leave off the `name` argument, as in the second example above, Django
    will use the function's name as the filter name. Finally, `register.filter()`
    also accepts three keyword arguments, `is_safe`, `needs_autoescape`, and `expects_localtime`.
    These arguments are described in filters and auto-escaping and filters and time
    zones below.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略`name`参数，就像上面的第二个示例一样，Django将使用函数的名称作为过滤器名称。最后，`register.filter()`还接受三个关键字参数，`is_safe`，`needs_autoescape`和`expects_localtime`。这些参数在下面的过滤器和自动转义以及过滤器和时区中进行了描述。
- en: Template filters that expect strings
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 期望字符串的模板过滤器
- en: 'If you''re writing a template filter that only expects a string as the first
    argument, you should use the decorator `stringfilter`. This will convert an object
    to its string value before being passed to your function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在编写一个模板过滤器，只期望第一个参数是字符串，您应该使用装饰器`stringfilter`。这将在将对象传递给您的函数之前将其转换为其字符串值：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This way, you'll be able to pass, say, an integer to this filter, and it won't
    cause an `AttributeError` (because integers don't have `lower()` methods).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您就可以将一个整数传递给这个过滤器，它不会引起`AttributeError`（因为整数没有`lower()`方法）。
- en: Filters and auto-escaping
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤器和自动转义
- en: 'When writing a custom filter, give some thought to how the filter will interact
    with Django''s auto-escaping behavior. Note that three types of strings can be
    passed around inside the template code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写自定义过滤器时，要考虑过滤器将如何与Django的自动转义行为交互。请注意，在模板代码中可以传递三种类型的字符串：
- en: '**Raw strings** are the native Python `str` or `unicode` types. On output,
    they''re escaped if auto-escaping is in effect and presented unchanged, otherwise.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始字符串**是本机Python `str`或`unicode`类型。在输出时，如果自动转义生效，它们会被转义并保持不变，否则。'
- en: '**Safe strings** are strings that have been marked safe from further escaping
    at output time. Any necessary escaping has already been done. They''re commonly
    used for output that contains raw HTML that is intended to be interpreted as-is
    on the client side.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全字符串**是在输出时已标记为免受进一步转义的字符串。任何必要的转义已经完成。它们通常用于包含原始HTML的输出，该HTML旨在在客户端上按原样解释。'
- en: 'Internally, these strings are of type `SafeBytes` or `SafeText`. They share
    a common base class of `SafeData`, so you can test for them using code like:'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内部，这些字符串的类型是`SafeBytes`或`SafeText`。它们共享一个名为`SafeData`的基类，因此您可以使用类似的代码对它们进行测试：
- en: 'if isinstance(value, SafeData):'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`value`是`SafeData`的实例：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Strings marked as "needing escaping"** are always escaped on output, regardless
    of whether they are in an `autoescape` block or not. These strings are only escaped
    once, however, even if auto-escaping applies.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标记为“需要转义”的字符串**在输出时始终会被转义，无论它们是否在`autoescape`块中。但是，这些字符串只会被转义一次，即使自动转义适用。'
- en: Internally, these strings are of type `EscapeBytes` or `EscapeText`. Generally,
    you don't have to worry about these; they exist for the implementation of the
    `escape` filter.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，这些字符串的类型是`EscapeBytes`或`EscapeText`。通常，您不必担心这些问题；它们存在是为了实现`escape`过滤器。
- en: 'Template filter code falls into one of two situations:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 模板过滤器代码分为两种情况：
- en: Your filter does not introduce any HTML-unsafe characters (`<`, `>`, `'`, `"`
    or `&`) into the result that were not already present; or
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的过滤器不会在结果中引入任何HTML不安全的字符（`<`，`>`，`'`，`"`或`&`），这些字符在结果中本来就存在；或
- en: Alternatively, your filter code can manually take care of any necessary escaping.
    This is necessary when you're introducing new HTML mark-up into the result.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您的过滤器代码可以手动处理任何必要的转义。当您将新的HTML标记引入结果时，这是必要的。
- en: 'In this first case, you can let Django take care of all the auto-escaping handling
    for you. All you need to do is set the `is_safe` flag to `True` when you register
    your filter function, like so:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，您可以让Django为您处理所有自动转义处理。您只需要在注册过滤器函数时将`is_safe`标志设置为`True`，如下所示：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This flag tells Django that if a safe string is passed into your filter, the
    result will still be safe and if a non-safe string is passed in, Django will automatically
    escape it, if necessary. You can think of this as meaning "this filter is safe-it
    doesn't introduce any possibility of unsafe HTML."
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标志告诉Django，如果将安全字符串传递到您的过滤器中，则结果仍将是安全的，如果传递了不安全的字符串，则Django将自动转义它（如果需要的话）。您可以将其视为意味着“此过滤器是安全的-它不会引入任何不安全的HTML可能性。”
- en: The reason `is_safe` is necessary is because there are plenty of normal string
    operations that will turn a `SafeData` object back into a normal `str` or `unicode`
    object and, rather than try to catch them all, which would be very difficult,
    Django repairs the damage after the filter has completed.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_safe`之所以必要是因为有很多普通的字符串操作会将`SafeData`对象转换回普通的`str`或`unicode`对象，而不是尝试捕获它们所有，这将非常困难，Django会在过滤器完成后修复损坏。'
- en: 'For example, suppose you have a filter that adds the string `xx` to the end
    of any input. Since this introduces no dangerous HTML characters to the result
    (aside from any that were already present), you should mark your filter with `is_safe`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您有一个过滤器，它将字符串`xx`添加到任何输入的末尾。由于这不会向结果引入危险的HTML字符（除了已经存在的字符），因此应该使用`is_safe`标记过滤器：
- en: '[PRE36]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When this filter is used in a template where auto-escaping is enabled, Django
    will escape the output whenever the input is not already marked as safe. By default,
    `is_safe` is `False`, and you can omit it from any filters where it isn't required.
    Be careful when deciding if your filter really does leave safe strings as safe.
    If you're removing characters, you might inadvertently leave unbalanced HTML tags
    or entities in the result.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当在启用自动转义的模板中使用此过滤器时，Django将在输入未标记为安全时转义输出。默认情况下，`is_safe`为`False`，并且您可以在任何不需要的过滤器中省略它。在决定您的过滤器是否确实将安全字符串保持为安全时要小心。如果您删除字符，可能会无意中在结果中留下不平衡的HTML标记或实体。
- en: For example, removing a `>` from the input might turn `<a>` into `<a`, which
    would need to be escaped on output to avoid causing problems. Similarly, removing
    a semicolon (`;`) can turn `&amp;` into `&amp`, which is no longer a valid entity
    and thus needs further escaping. Most cases won't be nearly this tricky, but keep
    an eye out for any problems like that when reviewing your code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从输入中删除`>`可能会将`<a>`变为`<a`，这需要在输出时进行转义，以避免引起问题。同样，删除分号（`;`）可能会将`&amp;`变为`&amp`，这不再是一个有效的实体，因此需要进一步转义。大多数情况下不会有这么棘手，但是在审查代码时要注意任何类似的问题。
- en: Marking a filter `is_safe` will coerce the filter's return value to a string.
    If your filter should return a Boolean or other non-string value, marking it `is_safe`
    will probably have unintended consequences (such as converting a Boolean `False`
    to the string `False`).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 标记过滤器`is_safe`将强制过滤器的返回值为字符串。如果您的过滤器应返回布尔值或其他非字符串值，则将其标记为`is_safe`可能会产生意想不到的后果（例如将布尔值`False`转换为字符串`False`）。
- en: In the second case, you want to mark the output as safe from further escaping
    so that your HTML mark-up isn't escaped further, so you'll need to handle the
    input yourself. To mark the output as a safe string, use `django.utils.safestring.mark_safe()`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，您希望标记输出为安全，以免进一步转义您的HTML标记，因此您需要自己处理输入。要将输出标记为安全字符串，请使用`django.utils.safestring.mark_safe()`。
- en: Be careful, though. You need to do more than just mark the output as safe. You
    need to ensure it really is safe, and what you do depends on whether auto-escaping
    is in effect.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 不过要小心。您需要做的不仅仅是标记输出为安全。您需要确保它确实是安全的，您的操作取决于自动转义是否生效。
- en: The idea is to write filters that can operate in templates where auto-escaping
    is either on or off in order to make things easier for your template authors.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是编写可以在模板中运行的过滤器，无论自动转义是打开还是关闭，以便为模板作者简化事情。
- en: In order for your filter to know the current auto-escaping state, set the `needs_autoescape`
    flag to `True` when you register your filter function. (If you don't specify this
    flag, it defaults to `False`). This flag tells Django that your filter function
    wants to be passed an extra keyword argument, called `autoescape`, that is `True`
    if auto-escaping is in effect and `False` otherwise.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使您的过滤器知道当前的自动转义状态，请在注册过滤器函数时将`needs_autoescape`标志设置为`True`。（如果您不指定此标志，它将默认为`False`）。这个标志告诉Django，您的过滤器函数希望传递一个额外的关键字参数，称为`autoescape`，如果自动转义生效，则为`True`，否则为`False`。
- en: 'For example, let''s write a filter that emphasizes the first character of a
    string:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们编写一个过滤器，强调字符串的第一个字符：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `needs_autoescape` flag and the `autoescape` keyword argument mean that
    our function will know whether automatic escaping is in effect when the filter
    is called. We use `autoescape` to decide whether the input data needs to be passed
    through `django.utils.html.conditional_escape` or not. (In the latter case, we
    just use the identity function as the "escape" function.)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`needs_autoescape`标志和`autoescape`关键字参数意味着我们的函数将知道在调用过滤器时是否自动转义。我们使用`autoescape`来决定输入数据是否需要通过`django.utils.html.conditional_escape`传递。
    （在后一种情况下，我们只使用身份函数作为“转义”函数。）'
- en: The `conditional_escape()` function is like `escape()` except it only escapes
    input that is **not** a `SafeData` instance. If a `SafeData` instance is passed
    to `conditional_escape()`, the data is returned unchanged.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`conditional_escape()`函数类似于`escape()`，只是它只转义**不是**`SafeData`实例的输入。如果将`SafeData`实例传递给`conditional_escape()`，则数据将保持不变。'
- en: Finally, in the above example, we remember to mark the result as safe so that
    our HTML is inserted directly into the template without further escaping. There's
    no need to worry about the `is_safe` flag in this case (although including it
    wouldn't hurt anything). Whenever you manually handle the auto-escaping issues
    and return a safe string, the `is_safe` flag won't change anything either way.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在上面的例子中，我们记得将结果标记为安全，以便我们的HTML直接插入模板而不需要进一步转义。在这种情况下，不需要担心 `is_safe` 标志（尽管包含它也不会有什么坏处）。每当您手动处理自动转义问题并返回安全字符串时，`is_safe`
    标志也不会改变任何东西。
- en: Filters and time zones
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤器和时区
- en: 'If you write a custom filter that operates on `datetime` objects, you''ll usually
    register it with the `expects_localtime` flag set to `True`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编写一个在 `datetime` 对象上操作的自定义过滤器，通常会将其注册为 `expects_localtime` 标志设置为 `True`：
- en: '[PRE38]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When this flag is set, if the first argument to your filter is a time zone aware
    datetime, Django will convert it to the current time zone before passing it to
    your filter when appropriate, according to rules for time zones conversions in
    templates.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置了此标志时，如果您的过滤器的第一个参数是时区感知的日期时间，则 Django 会根据模板中的时区转换规则在适当时将其转换为当前时区后传递给您的过滤器。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Avoiding XSS vulnerabilities when reusing built-in filters**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**在重用内置过滤器时避免XSS漏洞**'
- en: 'Be careful when reusing Django''s built-in filters. You''ll need to pass `autoescape=True`
    to the filter in order to get the proper autoescaping behavior and avoid a cross-site
    script vulnerability. For example, if you wanted to write a custom filter called
    `urlize_and_linebreaks` that combined the `urlize` and `linebreaksbr` filters,
    the filter would look like:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在重用Django的内置过滤器时要小心。您需要向过滤器传递 `autoescape=True` 以获得正确的自动转义行为，并避免跨站脚本漏洞。例如，如果您想编写一个名为
    `urlize_and_linebreaks` 的自定义过滤器，该过滤器结合了 `urlize` 和 `linebreaksbr` 过滤器，那么过滤器将如下所示：
- en: '`from django.template.defaultfilters import linebreaksbr, urlize` `@register.filter`
    `def urlize_and_linebreaks(text):` `return linebreaksbr(` `urlize(text, autoescape=True),autoescape=True)`
    `Then:` `{{ comment|urlize_and_linebreaks }}` `Would be equivalent to:` `{{ comment|urlize|linebreaksbr
    }}`'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`from django.template.defaultfilters import linebreaksbr, urlize` `@register.filter`
    `def urlize_and_linebreaks(text):` `return linebreaksbr(` `urlize(text, autoescape=True),autoescape=True)`
    `然后：` `{{ comment|urlize_and_linebreaks }}` `等同于：` `{{ comment|urlize|linebreaksbr
    }}`'
- en: Writing custom template tags
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写自定义模板标签
- en: Tags are more complex than filters, because tags can do anything. Django provides
    a number of shortcuts that make writing most types of tags easier. First we'll
    explore those shortcuts, then explain how to write a tag from scratch for those
    cases when the shortcuts aren't powerful enough.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 标签比过滤器更复杂，因为标签可以做任何事情。Django提供了许多快捷方式，使编写大多数类型的标签更容易。首先我们将探讨这些快捷方式，然后解释如何为那些快捷方式不够强大的情况下从头编写标签。
- en: Simple tags
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单标签
- en: Many template tags take a number of arguments-strings or template variables-and
    return a result after doing some processing based solely on the input arguments
    and some external information.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 许多模板标签需要一些参数-字符串或模板变量-并且在仅基于输入参数和一些外部信息进行一些处理后返回结果。
- en: For example, a `current_time` tag might accept a format string and return the
    time as a string formatted accordingly. To ease the creation of these types of
    tags, Django provides a helper function, `simple_tag`. This function, which is
    a method of `django.template.Library`, takes a function that accepts any number
    of arguments, wraps it in a `render` function and the other necessary bits mentioned
    above and registers it with the template system.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`current_time` 标签可能接受一个格式字符串，并根据格式化返回时间字符串。为了简化这些类型的标签的创建，Django提供了一个辅助函数
    `simple_tag`。这个函数是 `django.template.Library` 的一个方法，它接受一个接受任意数量参数的函数，将其包装在一个 `render`
    函数和其他必要的部分中，并将其注册到模板系统中。
- en: 'Our `current_time` function could thus be written like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `current_time` 函数可以这样编写：
- en: '[PRE39]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A few things to note about the `simple_tag` helper function:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `simple_tag` 辅助函数的一些注意事项：
- en: Checking for the required number of arguments, and so on, has already been done
    by the time our function is called, so we don't need to do that.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的函数被调用时，已经检查了所需数量的参数等，所以我们不需要再做这些。
- en: The quotes around the argument (if any) have already been stripped away, so
    we just receive a plain string.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数（如果有）周围的引号已经被剥离，所以我们只收到一个普通字符串。
- en: If the argument was a template variable, our function is passed the current
    value of the variable, not the variable itself.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数是模板变量，则我们的函数会传递变量的当前值，而不是变量本身。
- en: 'If your template tag needs to access the current context, you can use the `takes_context`
    argument when registering your tag:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的模板标签需要访问当前上下文，可以在注册标签时使用 `takes_context` 参数：
- en: '[PRE40]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note that the first argument must be called `context`. For more information
    on how the `takes_context` option works, see the section on inclusion tags. If
    you need to rename your tag, you can provide a custom name for it:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一个参数必须称为 `context`。有关 `takes_context` 选项的工作原理的更多信息，请参阅包含标签部分。如果您需要重命名标签，可以为其提供自定义名称：
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`simple_tag` functions may accept any number of positional or keyword arguments.
    For example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`simple_tag` 函数可以接受任意数量的位置参数或关键字参数。例如：'
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then in the template any number of arguments, separated by spaces, may be passed
    to the template tag. Like in Python, the values for keyword arguments are set
    using the equal sign ("`=`") and must be provided after the positional arguments.
    For example:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在模板中，可以传递任意数量的参数，用空格分隔，到模板标签。就像在Python中一样，关键字参数的值使用等号（“=`”）设置，并且必须在位置参数之后提供。例如：
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Inclusion tags
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包含标签
- en: Another common type of template tag is the type that displays some data by rendering
    another template. For example, Django's admin interface uses custom template tags
    to display the buttons along the bottom of the "add/change" form pages. Those
    buttons always look the same, but the link targets change depending on the object
    being edited-so they're a perfect case for using a small template that is filled
    with details from the current object. (In the admin's case, this is the `submit_row`
    tag.)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的模板标签类型是通过呈现另一个模板来显示一些数据的类型。例如，Django的管理界面使用自定义模板标签来显示“添加/更改”表单页面底部的按钮。这些按钮始终看起来相同，但链接目标会根据正在编辑的对象而变化-因此它们是使用填充了当前对象详细信息的小模板的完美案例。（在管理界面的情况下，这是`submit_row`标签。）
- en: 'These sorts of tags are called inclusion tags. Writing inclusion tags is probably
    best demonstrated by example. Let''s write a tag that produces a list of books
    for a given `Author` object. We''ll use the tag like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的标签被称为包含标签。编写包含标签最好通过示例来演示。让我们编写一个为给定的`Author`对象生成书籍列表的标签。我们将像这样使用该标签：
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The result will be something like this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将会是这样的：
- en: '[PRE45]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'First, we define the function that takes the argument and produces a dictionary
    of data for the result. Notice that we need to return only a dictionary, not anything
    more complex. This will be used as the context for the template fragment:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个接受参数并生成结果数据字典的函数。请注意，我们只需要返回一个字典，而不是更复杂的内容。这将用作模板片段的上下文：
- en: '[PRE46]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we create the template used to render the tag''s output. Following our
    example, the template is very simple:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建用于呈现标签输出的模板。根据我们的示例，模板非常简单：
- en: '[PRE47]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we create and register the inclusion tag by calling the `inclusion_tag()`
    method on a `Library` object. Following our example, if the preceding template
    is in a file called `book_snippet.html` in a directory that''s searched by the
    template loader, we register the tag like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过在`Library`对象上调用`inclusion_tag()`方法来创建和注册包含标签。根据我们的示例，如果前面的模板在模板加载器搜索的目录中的名为`book_snippet.html`的文件中，我们可以像这样注册标签：
- en: '[PRE48]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Alternatively, it is possible to register the inclusion tag using a `django.template.Template`
    instance when first creating the function:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以在首次创建函数时使用`django.template.Template`实例注册包含标签：
- en: '[PRE49]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Sometimes, your inclusion tags might require a large number of arguments, making
    it a pain for template authors to pass in all the arguments and remember their
    order. To solve this, Django provides a `takes_context` option for inclusion tags.
    If you specify `takes_context` in creating an inclusion tag, the tag will have
    no required arguments, and the underlying Python function will have one argument:
    the template context as of when the tag was called. For example, say you''re writing
    an inclusion tag that will always be used in a context that contains `home_link`
    and `home_title` variables that point back to the main page. Here''s what the
    Python function would look like:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你的包含标签可能需要大量的参数，这使得模板作者很难传递所有参数并记住它们的顺序。为了解决这个问题，Django为包含标签提供了一个`takes_context`选项。如果在创建包含标签时指定了`takes_context`，则该标签将不需要必需的参数，而底层的Python函数将有一个参数：调用标签时的模板上下文。例如，假设你正在编写一个包含标签，它将始终在包含`home_link`和`home_title`变量指向主页的上下文中使用。下面是Python函数的样子：
- en: '[PRE50]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '(Note that the first parameter to the function must be called `context`.) The
    template `link.html` might contain the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，函数的第一个参数必须称为`context`。）模板`link.html`可能包含以下内容：
- en: '[PRE51]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, anytime you want to use that custom tag, load its library and call it
    without any arguments, like so:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每当你想要使用该自定义标签时，加载它的库并在没有任何参数的情况下调用它，就像这样：
- en: '[PRE52]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that when you're using `takes_context=True`, there's no need to pass arguments
    to the template tag. It automatically gets access to the context. The `takes_context`
    parameter defaults to `False`. When it's set to `True`, the tag is passed the
    context object, as in this example. That's the only difference between this case
    and the previous `inclusion_tag` example. Like `simple_tag`, `inclusion_tag` functions
    may also accept any number of positional or keyword arguments.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当使用`takes_context=True`时，无需向模板标签传递参数。它会自动访问上下文。`takes_context`参数默认为`False`。当设置为`True`时，标签将传递上下文对象，就像这个例子一样。这是这种情况和之前的`inclusion_tag`示例之间的唯一区别。像`simple_tag`一样，`inclusion_tag`函数也可以接受任意数量的位置或关键字参数。
- en: Assignment tags
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分配标签
- en: 'To ease the creation of tags setting a variable in the context, Django provides
    a helper function, `assignment_tag`. This function works the same way as `simple_tag()`
    except that it stores the tag''s result in a specified context variable instead
    of directly outputting it. Our earlier `current_time` function could thus be written
    like this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化设置上下文变量的标签创建，Django提供了一个辅助函数`assignment_tag`。这个函数的工作方式与`simple_tag()`相同，只是它将标签的结果存储在指定的上下文变量中，而不是直接输出它。因此，我们之前的`current_time`函数可以这样编写：
- en: '[PRE53]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You may then store the result in a template variable using the `as` argument
    followed by the variable name, and output it yourself where you see fit:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用`as`参数将结果存储在模板变量中，并在适当的位置输出它：
- en: '[PRE54]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Advanced custom template tags
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级自定义模板标签
- en: Sometimes the basic features for custom template tag creation aren't enough.
    Don't worry, Django gives you complete access to the internals required to build
    a template tag from the ground up.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，创建自定义模板标签的基本功能不够。别担心，Django让你完全访问所需的内部部分，从头开始构建模板标签。
- en: A quick overview
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速概述
- en: 'The template system works in a two-step process: compiling and rendering. To
    define a custom template tag, you specify how the compilation works and how the
    rendering works. When Django compiles a template, it splits the raw template text
    into nodes. Each node is an instance of `django.template.Node` and has a `render()`
    method. A compiled template is, simply, a list of `Node` objects.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 模板系统以两步过程工作：编译和渲染。要定义自定义模板标签，您需要指定编译如何工作以及渲染如何工作。当Django编译模板时，它将原始模板文本分割为节点。每个节点都是`django.template.Node`的一个实例，并且具有`render()`方法。编译的模板就是`Node`对象的列表。
- en: When you call `render()` on a compiled template object, the template calls `render()`
    on each `Node` in its node list, with the given context. The results are all concatenated
    together to form the output of the template. Thus, to define a custom template
    tag, you specify how the raw template tag is converted into a `Node` (the compilation
    function), and what the node's `render()` method does.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在编译的模板对象上调用`render()`时，模板会在其节点列表中的每个`Node`上调用`render()`，并提供给定的上下文。结果都被连接在一起形成模板的输出。因此，要定义一个自定义模板标签，您需要指定原始模板标签如何转换为`Node`（编译函数），以及节点的`render()`方法的作用。
- en: Writing the compilation function
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写编译函数
- en: 'For each template tag the template parser encounters, it calls a Python function
    with the tag contents and the parser object itself. This function is responsible
    for returning a `Node` instance based on the contents of the tag. For example,
    let''s write a full implementation of our simple template tag, `{% current_time
    %}`, that displays the current date/time, formatted according to a parameter given
    in the tag, in `strftime()` syntax. It''s a good idea to decide the tag syntax
    before anything else. In our case, let''s say the tag should be used like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模板解析器遇到的每个模板标签，它都会调用一个Python函数，该函数具有标签内容和解析器对象本身。此函数负责根据标签的内容返回一个基于`Node`的实例。例如，让我们编写一个我们简单模板标签`{%
    current_time %}`的完整实现，它显示当前日期/时间，根据标签中给定的参数以`strftime()`语法格式化。在任何其他事情之前，决定标签语法是一个好主意。在我们的情况下，让我们说标签应该像这样使用：
- en: '[PRE55]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The parser for this function should grab the parameter and create a `Node`
    object:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的解析器应该抓取参数并创建一个`Node`对象：
- en: '[PRE56]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '**Notes:**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**'
- en: '`parser` is the template parser object. We don''t need it in this example.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parser`是模板解析器对象。在这个例子中我们不需要它。'
- en: '`token.contents` is a string of the raw contents of the tag. In our example,
    it''s `''current_time "%Y-%m-%d %I:%M %p"''`.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`token.contents`是标签的原始内容的字符串。在我们的例子中，它是`''current_time "%Y-%m-%d %I:%M %p"''`。'
- en: The `token.split_contents()` method separates the arguments on spaces while
    keeping quoted strings together. The more straightforward `token.contents.split()`
    wouldn't be as robust, as it would naively split on all spaces, including those
    within quoted strings. It's a good idea to always use `token.split_contents()`.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`token.split_contents()`方法将参数在空格上分开，同时保持引号括起的字符串在一起。更直接的`token.contents.split()`不会那么健壮，因为它会简单地在所有空格上分割，包括引号括起的字符串中的空格。始终使用`token.split_contents()`是一个好主意。'
- en: This function is responsible for raising `django.template.TemplateSyntaxError`,
    with helpful messages, for any syntax error.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此函数负责为任何语法错误引发`django.template.TemplateSyntaxError`，并提供有用的消息。
- en: The `TemplateSyntaxError` exceptions use the `tag_name` variable. Don't hard-code
    the tag's name in your error messages, because that couples the tag's name to
    your function. `token.contents.split()[0]` will always be the name of your tag-even
    when the tag has no arguments.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TemplateSyntaxError`异常使用`tag_name`变量。不要在错误消息中硬编码标签的名称，因为这会将标签的名称与您的函数耦合在一起。`token.contents.split()[0]`将始终是您的标签的名称-即使标签没有参数。'
- en: The function returns a `CurrentTimeNode` with everything the node needs to know
    about this tag. In this case, it just passes the argument-`"%Y-%m-%d %I:%M %p"`.
    The leading and trailing quotes from the template tag are removed in `format_string[1:-1]`.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数返回一个`CurrentTimeNode`，其中包含有关此标签的所有节点需要知道的信息。在这种情况下，它只传递参数`"%Y-%m-%d %I:%M
    %p"`。模板标签中的前导和尾随引号在`format_string[1:-1]`中被移除。
- en: The parsing is very low-level. The Django developers have experimented with
    writing small frameworks on top of this parsing system, using techniques such
    as EBNF grammars, but those experiments made the template engine too slow. It's
    low-level because that's fastest.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析是非常低级的。Django开发人员尝试使用诸如EBNF语法之类的技术在此解析系统之上编写小型框架，但这些实验使模板引擎变得太慢。它是低级的，因为这是最快的。
- en: Writing the renderer
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写渲染器
- en: 'The second step in writing custom tags is to define a `Node` subclass that
    has a `render()` method. Continuing the above example, we need to define `CurrentTimeNode`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 编写自定义标签的第二步是定义一个具有`render()`方法的`Node`子类。继续上面的例子，我们需要定义`CurrentTimeNode`：
- en: '[PRE57]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**Notes:**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**'
- en: '`__init__()` gets the `format_string` from `do_current_time()`. Always pass
    any options/parameters/arguments to a `Node` via its `__init__()`.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()`从`do_current_time()`获取`format_string`。始终通过`__init__()`向`Node`传递任何选项/参数/参数。'
- en: The `render()` method is where the work actually happens.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render()`方法是实际工作发生的地方。'
- en: '`render()` should generally fail silently, particularly in a production environment
    where `DEBUG` and `TEMPLATE_DEBUG` are `False`. In some cases, however, particularly
    if `TEMPLATE_DEBUG` is `True`, this method may raise an exception to make debugging
    easier. For example, several core tags raise `django.template.TemplateSyntaxError`
    if they receive the wrong number or type of arguments.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render()`通常应该在生产环境中静默失败，特别是在`DEBUG`和`TEMPLATE_DEBUG`为`False`的情况下。然而，在某些情况下，特别是如果`TEMPLATE_DEBUG`为`True`，此方法可能会引发异常以便更容易进行调试。例如，如果几个核心标签接收到错误数量或类型的参数，它们会引发`django.template.TemplateSyntaxError`。'
- en: Ultimately, this decoupling of compilation and rendering results in an efficient
    template system, because a template can render multiple contexts without having
    to be parsed multiple times.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，编译和渲染的解耦导致了一个高效的模板系统，因为一个模板可以渲染多个上下文而不必多次解析。
- en: Auto-escaping Considerations
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动转义注意事项
- en: The output from template tags is **not** automatically run through the auto-escaping
    filters. However, there are still a couple of things you should keep in mind when
    writing a template tag. If the `render()` function of your template stores the
    result in a context variable (rather than returning the result in a string), it
    should take care to call `mark_safe()` if appropriate. When the variable is ultimately
    rendered, it will be affected by the auto-escape setting in effect at the time,
    so content that should be safe from further escaping needs to be marked as such.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 模板标签的输出**不会**自动通过自动转义过滤器运行。但是，在编写模板标签时，仍然有一些事项需要牢记。如果模板的`render()`函数将结果存储在上下文变量中（而不是以字符串返回结果），则应在适当时调用`mark_safe()`。最终呈现变量时，它将受到当时生效的自动转义设置的影响，因此需要将应该免受进一步转义的内容标记为这样。
- en: 'Also, if your template tag creates a new context for performing some sub-rendering,
    set the auto-escape attribute to the current context''s value. The `__init__`
    method for the `Context` class takes a parameter called `autoescape` that you
    can use for this purpose. For example:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果模板标签为执行某些子呈现创建新的上下文，请将自动转义属性设置为当前上下文的值。`Context`类的`__init__`方法接受一个名为`autoescape`的参数，您可以用于此目的。例如：
- en: '[PRE58]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This is not a very common situation, but it''s useful if you''re rendering
    a template yourself. For example:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个非常常见的情况，但如果您自己呈现模板，则会很有用。例如：
- en: '[PRE59]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If we had neglected to pass in the current `context.autoescape` value to our
    new `Context` in this example, the results would have *always* been automatically
    escaped, which may not be the desired behavior if the template tag is used inside
    a
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在此示例中忽略了将当前`context.autoescape`值传递给我们的新`Context`，则结果将始终自动转义，这可能不是在模板标签用于内部时所期望的行为。
- en: '`{% autoescape off %}` block.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% autoescape off %}`块。'
- en: Thread-safety Considerations
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全考虑
- en: Once a node is parsed, its `render` method may be called any number of times.
    Since Django is sometimes run in multi-threaded environments, a single node may
    be simultaneously rendering with different contexts in response to two separate
    requests.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解析了节点，就可以调用其`render`方法任意次数。由于Django有时在多线程环境中运行，单个节点可能会同时响应两个独立请求的不同上下文进行呈现。
- en: 'Therefore, it''s important to make sure your template tags are thread safe.
    To make sure your template tags are thread safe, you should never store state
    information on the node itself. For example, Django provides a built-in `cycle`
    template tag that cycles among a list of given strings each time it''s rendered:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，确保模板标签是线程安全的非常重要。为确保模板标签是线程安全的，不应在节点本身上存储状态信息。例如，Django提供了内置的`cycle`模板标签，每次呈现时在给定字符串列表中循环：
- en: '[PRE60]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'A naive implementation of `CycleNode` might look something like this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`CycleNode`的一个天真的实现可能如下所示：'
- en: '[PRE61]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The CycleNode is iterating, but it's iterating globally. As far as Thread 1
    and Thread 2 are concerned, it's always returning the same value. This is obviously
    not what we want!
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: CycleNode正在迭代，但它是全局迭代的。就线程1和线程2而言，它总是返回相同的值。这显然不是我们想要的！
- en: 'To address this problem, Django provides a `render_context` that''s associated
    with the `context` of the template that is currently being rendered. The `render_context`
    behaves like a Python dictionary, and should be used to store `Node` state between
    invocations of the `render` method. Let''s refactor our `CycleNode` implementation
    to use the `render_context`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Django提供了一个`render_context`，它与当前正在呈现的模板的`context`相关联。`render_context`的行为类似于Python字典，并且应该用于在`render`方法的调用之间存储`Node`状态。让我们重构我们的`CycleNode`实现以使用`render_context`：
- en: '[PRE62]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note that it's perfectly safe to store global information that will not change
    throughout the life of the `Node` as an attribute.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将全局信息存储为`Node`生命周期内不会更改的属性是完全安全的。
- en: In the case of `CycleNode`, the `cyclevars` argument doesn't change after the
    `Node` is instantiated, so we don't need to put it in the `render_context`. But
    state information that is specific to the template that is currently being rendered,
    like the current iteration of the `CycleNode`, should be stored in the `render_context`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CycleNode`的情况下，`cyclevars`参数在`Node`实例化后不会改变，因此我们不需要将其放入`render_context`中。但是，特定于当前正在呈现的模板的状态信息，例如`CycleNode`的当前迭代，应存储在`render_context`中。
- en: Registering the tag
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册标签
- en: 'Finally, register the tag with your module''s `Library` instance, as explained
    in "Writing custom template filters" above. Example:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按照上面“编写自定义模板过滤器”的说明，使用模块的`Library`实例注册标签。例如：
- en: '[PRE63]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `tag()` method takes two arguments:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`tag()`方法接受两个参数：'
- en: The name of the template tag-a string. If this is left out, the name of the
    compilation function will be used.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板标签的名称-一个字符串。如果不写，将使用编译函数的名称。
- en: The compilation function-a Python function (not the name of the function as
    a string).
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译函数-一个Python函数（而不是函数的名称作为字符串）。
- en: 'As with filter registration, it is also possible to use this as a decorator:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 与过滤器注册一样，也可以将其用作装饰器：
- en: '[PRE64]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If you leave off the `name` argument, as in the second example above, Django
    will use the function's name as the tag name.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略`name`参数，就像上面的第二个示例一样，Django将使用函数的名称作为标签名称。
- en: Passing template variables to The Tag
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将模板变量传递给标签
- en: Although you can pass any number of arguments to a template tag using `token.split_contents()`,
    the arguments are all unpacked as string literals. A little more work is required
    in order to pass dynamic content (a template variable) to a template tag as an
    argument.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以使用`token.split_contents()`将任意数量的参数传递给模板标签，但这些参数都会被解包为字符串文字。为了将动态内容（模板变量）作为参数传递给模板标签，需要进行更多的工作。
- en: 'While the previous examples have formatted the current time into a string and
    returned the string, suppose you wanted to pass in a `DateTimeField` from an object
    and have the template tag format that date-time:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的示例已将当前时间格式化为字符串并返回字符串，但假设您想要传递来自对象的`DateTimeField`并使模板标签格式化该日期时间：
- en: '[PRE65]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Initially, `token.split_contents()` will return three values:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`token.split_contents()`将返回三个值：
- en: The tag name `format_time`.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标签名称`format_time`。
- en: The string `'blog_entry.date_updated'` (without the surrounding quotes).
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串`'blog_entry.date_updated'`（不包括周围的引号）。
- en: The formatting string `'"%Y-%m-%d %I:%M %p"'`. The return value from `split_contents()`
    will include the leading and trailing quotes for string literals like this.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 格式化字符串`'"%Y-%m-%d %I:%M %p"'`。`split_contents()`的返回值将包括字符串字面量的前导和尾随引号。
- en: 'Now your tag should begin to look like this:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的标签应该开始看起来像这样：
- en: '[PRE66]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You also have to change the renderer to retrieve the actual contents of the
    `date_updated` property of the `blog_entry` object. This can be accomplished by
    using the `Variable()` class in `django.template`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要更改渲染器以检索`blog_entry`对象的`date_updated`属性的实际内容。这可以通过在`django.template`中使用`Variable()`类来实现。
- en: 'To use the `Variable` class, simply instantiate it with the name of the variable
    to be resolved, and then call `variable.resolve(context)`. So, for example:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`Variable`类，只需使用要解析的变量的名称对其进行实例化，然后调用`variable.resolve(context)`。例如：
- en: '[PRE67]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Variable resolution will throw a `VariableDoesNotExist` exception if it cannot
    resolve the string passed to it in the current context of the page.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法在页面的当前上下文中解析传递给它的字符串，变量解析将抛出`VariableDoesNotExist`异常。
- en: Setting a variable in the context
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在上下文中设置一个变量
- en: 'The above examples simply output a value. Generally, it''s more flexible if
    your template tags set template variables instead of outputting values. That way,
    template authors can reuse the values that your template tags create. To set a
    variable in the context, just use dictionary assignment on the context object
    in the `render()` method. Here''s an updated version of `CurrentTimeNode` that
    sets a template variable `current_time` instead of outputting it:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例只是简单地输出一个值。通常，如果您的模板标签设置模板变量而不是输出值，那么它会更灵活。这样，模板作者可以重用模板标签创建的值。要在上下文中设置一个变量，只需在`render()`方法中对上下文对象进行字典赋值。这是一个更新后的`CurrentTimeNode`版本，它设置了一个模板变量`current_time`而不是输出它：
- en: '[PRE68]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Note that `render()` returns the empty string. `render()` should always return
    string output. If all the template tag does is set a variable, `render()` should
    return the empty string. Here''s how you''d use this new version of the tag:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`render()`返回空字符串。`render()`应始终返回字符串输出。如果模板标签所做的只是设置一个变量，`render()`应返回空字符串。以下是如何使用标签的新版本：
- en: '[PRE69]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Variable scope in context
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文中的变量范围
- en: Any variable set in the context will only be available in the same `block` of
    the template in which it was assigned. This behavior is intentional; it provides
    a scope for variables so that they don't conflict with context in other blocks.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文中设置的任何变量只能在分配它的模板的相同`block`中使用。这种行为是有意的；它为变量提供了一个作用域，使它们不会与其他块中的上下文发生冲突。
- en: 'But, there''s a problem with `CurrentTimeNode2`: The variable name `current_time`
    is hard-coded. This means you''ll need to make sure your template doesn''t use'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`CurrentTimeNode2`存在一个问题：变量名`current_time`是硬编码的。这意味着您需要确保您的模板不使用
- en: '`{{ current_time }}` anywhere else, because the `{% current_time %}` will blindly
    overwrite that variable''s value.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{ current_time }}`在其他任何地方，因为`{% current_time %}`将盲目地覆盖该变量的值。'
- en: 'A cleaner solution is to make the template tag specify the name of the output
    variable, like so:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 更清晰的解决方案是让模板标签指定输出变量的名称，如下所示：
- en: '[PRE70]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'To do that, you''ll need to refactor both the compilation function and `Node`
    class, like so:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您需要重构编译函数和`Node`类，如下所示：
- en: '[PRE71]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The difference here is that `do_current_time()` grabs the format string and
    the variable name, passing both to `CurrentTimeNode3`. Finally, if you only need
    to have a simple syntax for your custom context-updating template tag, you might
    want to consider using the assignment tag shortcut we introduced above.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的区别在于`do_current_time()`获取格式字符串和变量名，并将两者都传递给`CurrentTimeNode3`。最后，如果您只需要为自定义上下文更新模板标签使用简单的语法，您可能希望考虑使用我们上面介绍的赋值标签快捷方式。
- en: Parsing until another block tag
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析直到另一个块标签
- en: Template tags can work in tandem. For instance, the standard `{% comment %}`
    tag hides everything until `{% endcomment %}`. To create a template tag such as
    this, use `parser.parse()` in your compilation function. Here's how a simplified
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 模板标签可以协同工作。例如，标准的`{% comment %}`标签隐藏直到`{% endcomment %}`。要创建这样一个模板标签，可以在编译函数中使用`parser.parse()`。以下是一个简化的示例
- en: '`{% comment %}` tag might be implemented:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% comment %}`标签可能被实现：'
- en: '[PRE72]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The actual implementation of `{% comment %}` is slightly different in that it
    allows broken template tags to appear between `{% comment %}` and `{% endcomment
    %}`. It does so by calling `parser.skip_past('endcomment')` instead of `parser.parse(('endcomment',))`
    followed by `parser.delete_first_token()`, thus avoiding the generation of a node
    list.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% comment %}`的实际实现略有不同，它允许在`{% comment %}`和`{% endcomment %}`之间出现损坏的模板标签。它通过调用`parser.skip_past(''endcomment'')`而不是`parser.parse((''endcomment'',))`，然后是`parser.delete_first_token()`来实现这一点，从而避免生成节点列表。'
- en: '`parser.parse()` takes a tuple of names of block tags ''''to parse until''''.
    It returns an instance of `django.template.NodeList`, which is a list of all `Node`
    objects that the parser encountered ''''before'''' it encountered any of the tags
    named in the tuple. In "`nodelist = parser.parse((''endcomment'',))` " in the
    above example, `nodelist` is a list of all nodes between the `{% comment %}` and
    `{% endcomment %}`, not counting'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`parser.parse()`接受一个块标签名称的元组''''直到解析''''。它返回`django.template.NodeList`的一个实例，这是解析器在遇到元组中命名的任何标签之前''''遇到''''的所有`Node`对象的列表。在上面的示例中的"`nodelist
    = parser.parse((''endcomment'',))`"中，`nodelist`是`{% comment %}`和`{% endcomment
    %}`之间的所有节点的列表，不包括'
- en: '`{% comment %}` and `{% endcomment %}` themselves.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% comment %}`和`{% endcomment %}`本身。'
- en: After `parser.parse()` is called, the parser hasn't yet "consumed" the
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`parser.parse()`之后，解析器尚未“消耗”
- en: '`{% endcomment %}` tag, so the code needs to explicitly call `parser.delete_first_token()`.
    `CommentNode.render()` simply returns an empty string. Anything between `{% comment
    %}` and `{% endcomment %}` is ignored.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% endcomment %}`标签，所以代码需要显式调用`parser.delete_first_token()`。`CommentNode.render()`只是返回一个空字符串。`{%
    comment %}`和`{% endcomment %}`之间的任何内容都会被忽略。'
- en: Parsing until another block tag, and saving contents
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析直到另一个块标签，并保存内容
- en: In the previous example, `do_comment()` discarded everything between
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`do_comment()`丢弃了`{% comment %}`和`{% endcomment %}`之间的所有内容
- en: '`{% comment %}` and `{% endcomment %}`. Instead of doing that, it''s possible
    to do something with the code between block tags. For example, here''s a custom
    template tag, `{% upper %}`, that capitalizes everything between itself and'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% comment %}`和`{% endcomment %}`。而不是这样做，可以对块标签之间的代码进行操作。例如，这里有一个自定义模板标签`{%
    upper %}`，它会将其自身和之间的所有内容都大写'
- en: '`{% endupper %}`. Usage:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% endupper %}`。用法：'
- en: '[PRE73]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'As in the previous example, we''ll use `parser.parse()`. But this time, we
    pass the resulting `nodelist` to the `Node`:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子一样，我们将使用`parser.parse()`。但是这次，我们将将结果的`nodelist`传递给`Node`：
- en: '[PRE74]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The only new concept here is the `self.nodelist.render(context)` in `UpperNode.render()`.
    For more examples of complex rendering, see the source code of `{% for %}` in
    `django/template/defaulttags.py` and `{% if %}` in `django/template/smartif.py`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的新概念是`UpperNode.render()`中的`self.nodelist.render(context)`。有关复杂渲染的更多示例，请参阅`django/template/defaulttags.py`中的`{%
    for %}`和`django/template/smartif.py`中的`{% if %}`的源代码。
- en: What's next
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么
- en: Continuing this section's theme of advanced topics, the next chapter covers
    advanced usage of Django models.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 继续本节关于高级主题的主题，下一章涵盖了Django模型的高级用法。
