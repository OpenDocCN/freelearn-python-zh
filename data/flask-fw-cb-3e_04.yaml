- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Working with Views
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与视图一起工作
- en: With any web application, it is very important to control how you interact with
    web requests and the proper responses to cater to these requests. This chapter
    takes us through the various methods of handling requests properly and designing
    them in the best way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何Web应用程序，控制你如何与Web请求交互以及为这些请求提供适当的响应是非常重要的。本章将引导我们通过正确处理请求和以最佳方式设计它们的各种方法。
- en: Flask offers several ways of designing and laying out URL routing for our applications.
    Also, it gives us the flexibility to keep the architecture of our views as just
    functions or to create classes, which can be inherited and modified as required.
    In earlier versions, Flask just had function-based views. Later, however, in Version
    0.7, inspired by Django, Flask introduced the concept of pluggable views, which
    allows us to have classes and then write methods in these classes. This also makes
    the process of building a RESTful API pretty straightforward, with every HTTP
    method being handled by the corresponding class method. Also, we can always go
    a level deeper into the Werkzeug library and use the more flexible, but slightly
    complex, concept of URL maps. In fact, large applications and frameworks prefer
    using URL maps.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Flask为我们提供了几种设计和布局URL路由的方法。它还提供了灵活性，使我们能够保持视图的架构仅为函数，或者创建类，这些类可以根据需要继承和修改。在早期版本中，Flask只有基于函数的视图。然而，后来在0.7版本中，受到Django的启发，Flask引入了可插拔视图的概念，这允许我们拥有类，并在这些类中编写方法。这也使得构建RESTful
    API的过程非常直接，每个HTTP方法都由相应的类方法处理。此外，我们总是可以更深入地了解Werkzeug库，并使用更灵活但稍微复杂的概念——URL映射。实际上，大型应用程序和框架更喜欢使用URL映射。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Writing function-based views and URL routes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写基于函数的视图和URL路由
- en: Writing class-based views
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写基于类的视图
- en: Implementing URL routing and product-based pagination
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现URL路由和基于产品的分页
- en: Rendering to templates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染到模板
- en: Dealing with XHR requests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理XHR请求
- en: Using decorators to handle requests beautifully
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用装饰器优雅地处理请求
- en: Creating custom 4xx and 5xx error handlers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义4xx和5xx错误处理器
- en: Flashing messages for better user feedback
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示消息以提供更好的用户反馈
- en: Implementing SQL-based searching
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现基于SQL的搜索
- en: Writing function-based views and URL routes
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写基于函数的视图和URL路由
- en: This is the simplest way of writing views and URL routes in Flask. We can just
    write a method and decorate it with the endpoint. In this recipe, we will write
    a few URL routes for `GET` and `POST` requests.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是编写Flask中视图和URL路由的最简单方法。我们只需编写一个方法，并用端点装饰它。在这个菜谱中，我们将为`GET`和`POST`请求编写几个URL路由。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To go through this recipe, we can start with any Flask application. The app
    can be a new, empty, or complex app. We just need to understand the methods outlined
    in this recipe.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过这个菜谱，我们可以从任何Flask应用程序开始。该应用程序可以是新的、空的或复杂的。我们只需要理解这个菜谱中概述的方法。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: The following section explains the three most widely used different kinds of
    requests, demonstrated by means of small examples.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分通过小示例解释了三种最广泛使用的不同类型的请求。
- en: A simple GET request
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单的GET请求
- en: 'The following is a simple example of what a `GET` request looks like:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的`GET`请求示例：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we just check whether the URL query has an argument called `foo`. If yes,
    we display this in the response; otherwise, the default is `bar`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是检查URL查询中是否有名为`foo`的参数。如果有，我们在响应中显示它；否则，默认为`bar`。
- en: A simple POST request
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单的POST请求
- en: '`POST` is similar to the `GET` request, but with a few differences:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`请求与`GET`请求类似，但有一些不同：'
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The route now contains an extra argument called `methods`. Also, instead of
    `request.args`, we now use `request.form`, as `POST` assumes that the data is
    submitted in a form.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 路由现在包含一个额外的参数，称为`methods`。此外，我们不再使用`request.args`，而是现在使用`request.form`，因为`POST`假设数据是以表单的形式提交的。
- en: A simple GET/POST request
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单的GET/POST请求
- en: 'An amalgamation of both `GET` and `POST` into a single `view` function can
    be written as shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将`GET`和`POST`合并到一个单独的`view`函数中，可以像下面这样编写：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let’s try to understand how the preceding play of methods works.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解前面方法的这种玩法。
- en: By default, any Flask `view` function supports only `GET` requests. In order
    to support or handle any other kind of request, we have to specifically tell our
    `route()` decorator about the methods we want to support. This is precisely what
    we did in our last two methods for `POST` and `GET/POST`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，任何 Flask `视图` 函数仅支持 `GET` 请求。为了支持或处理任何其他类型的请求，我们必须明确告诉我们的 `route()` 装饰器我们想要支持的方法。这正是我们在上一个
    `POST` 和 `GET/POST` 方法中做的事情。
- en: For `GET` requests, the `request` object will look for `args` – that is, `request.args.get()`
    – and for `POST`, it will look for `form` – that is, `request.form.get()`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `GET` 请求，`request` 对象将寻找 `args`（即 `request.args.get()`），而对于 `POST`，它将寻找 `form`（即
    `request.form.get()`）。
- en: 'Also, if we try to make a `GET` request to a method that supports only `POST`,
    the request will fail with a `405` HTTP error. The same holds true for all the
    methods. Refer to the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们尝试对一个仅支持 `POST` 的方法发起 `GET` 请求，请求将因 `405` HTTP 错误而失败。对所有方法都适用。请参考以下截图：
- en: "![Figure 4.1 – The Method Not Allowed \uFEFFerror page](img/B19111_04_1.jpg)"
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 方法不允许错误页面](img/B19111_04_1.jpg)'
- en: Figure 4.1 – The Method Not Allowed error page
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 方法不允许错误页面
- en: There’s more...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Sometimes, we might want to have a URL map kind of a pattern, where we prefer
    to define all the URL rules with endpoints in a single place, rather than them
    being scattered all around an application. For this, we will need to define our
    methods without the `route()` decorator and define the route on our application
    object, as shown here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能希望有一个类似 URL 映射的模式，我们更愿意在一个地方定义所有 URL 规则，而不是让它们散布在整个应用程序中。为此，我们需要在不使用
    `route()` 装饰器的情况下定义我们的方法，并在我们的应用程序对象上定义路由，如下所示：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Make sure that you give the correct relative path to the method assigned to
    `view_func`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你给出了分配给 `view_func` 的方法的正确相对路径。
- en: Writing class-based views
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写基于类的视图
- en: Flask introduced the concept of pluggable views in *Version 0.7*; this added
    a lot of flexibility to the existing implementation. We can write views in the
    form of classes; these views can be written in a generic fashion and allow for
    easy and understandable inheritance. In this recipe, we will look at how to create
    such class-based views.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 在 *版本 0.7* 中引入了可插拔视图的概念；这为现有的实现增加了许多灵活性。我们可以以类的形式编写视图；这些视图可以以通用方式编写，并允许易于理解和继承。在本例中，我们将探讨如何创建此类基于类的视图。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Refer to the previous recipe, *Writing function-based views and URL routes*,
    to see the basic function-based views first.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考之前的配方，*编写基于函数的视图和 URL 路由*，以首先了解基本的基于函数的视图。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Flask provides a class named `View`, which can be inherited to add our custom
    behavior. The following is an example of a simple `GET` request:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 提供了一个名为 `View` 的类，可以继承以添加我们的自定义行为。以下是一个简单的 `GET` 请求示例：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The name of the view provided in `as_view` (i.e., `get_request`) signifies the
    name that will be used when referring to this endpoint in `url_for()`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `as_view` 中提供的视图名称（即 `get_request`）表示在 `url_for()` 中引用此端点时将使用的名称。
- en: 'To accommodate both the `GET` and `POST` requests, we can write the following
    code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了同时支持 `GET` 和 `POST` 请求，我们可以编写以下代码：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We know that by default, any Flask `view` function supports only `GET` requests.
    The same applies to class-based views. In order to support or handle any other
    kind of request, we have to specifically tell our class, via a class attribute
    called `methods`, about the `HTTP` methods we want to support. This is exactly
    what we did in our last example of `GET/POST` requests.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道默认情况下，任何 Flask `视图` 函数仅支持 `GET` 请求。基于类的视图也是如此。为了支持或处理任何其他类型的请求，我们必须通过一个名为
    `methods` 的类属性，明确告诉我们的类我们想要支持的 `HTTP` 方法。这正是我们在上一个 `GET/POST` 请求示例中所做的。
- en: For `GET` requests, the `request` object will look for `args` – that is, `request.args.get()`
    – and for `POST`, it will look for `form` – that is, `request.form.get()`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `GET` 请求，`request` 对象将寻找 `args`（即 `request.args.get()`），而对于 `POST`，它将寻找 `form`（即
    `request.form.get()`）。
- en: Also, if we try to make a `GET` request to a method that supports only `POST`,
    the request will fail with a `405` HTTP error. The same holds true for all the
    methods.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们尝试对一个仅支持 `POST` 的方法发起 `GET` 请求，请求将因 `405` HTTP 错误而失败。对所有方法都适用。
- en: There’s more...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Now, many of you may be considering whether it would be possible to just declare
    the `GET` and `POST` methods inside a `View` class and let Flask handle the rest
    of the stuff. The answer to this question is `MethodView`. Let’s write our previous
    snippet using `MethodView`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你们中的许多人可能正在考虑是否可以在一个`View`类内部仅声明`GET`和`POST`方法，并让Flask处理其余的事情。这个问题的答案是`MethodView`。让我们用`MethodView`重写之前的代码片段：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: See also
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the previous recipe, *Writing function-based views and URL routes*,
    to understand the contrast between class- and function-based views.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考之前的配方，*基于函数的视图和URL路由的编写*，以了解基于类和基于函数的视图之间的区别。
- en: Implementing URL routing and product-based pagination
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现URL路由和基于产品的分页
- en: At times, we may encounter a problem where there is a need to parse the various
    parts of a URL differently. For example, a URL can have an integer part, a string
    part, a string part of a specific length, and slashes in the URL. We can parse
    all these combinations in our URLs using URL converters. In this recipe, we will
    see how to do this. Also, we will learn how to implement pagination using the
    `Flask-SQLAlchemy` extension.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能会遇到需要以不同方式解析URL各个部分的问题。例如，一个URL可以有一个整数部分，一个字符串部分，一个特定长度的字符串部分，以及URL中的斜杠。我们可以使用URL转换器在我们的URL中解析所有这些组合。在这个配方中，我们将看到如何做到这一点。此外，我们还将学习如何使用`Flask-SQLAlchemy`扩展实现分页。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We have already seen several instances of basic URL converters in this book.
    In this recipe, we will look at some advanced URL converters and learn how to
    use them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本书中看到了几个基本URL转换器的实例。在这个配方中，我们将查看一些高级URL转换器，并学习如何使用它们。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let’s say we have a URL route defined as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个如下定义的URL路由：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, the URL, `http://127.0.0.1:5000/test/Shalabh`, will result in `Shalabh`
    being parsed and passed in the `name` argument of the `get_name` method. This
    is a Unicode or string converter, which is the default one and need not be specified
    explicitly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，URL `http://127.0.0.1:5000/test/Shalabh` 将导致`Shalabh`被解析并传递给`get_name`方法的`name`参数。这是一个Unicode或字符串转换器，它是默认的，不需要明确指定。
- en: 'We can also have strings with specific lengths. Let’s say we want to parse
    a URL that may contain a country code or currency code. Country codes are usually
    two characters long, and currency codes are three characters long. This can be
    done as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以有特定长度的字符串。假设我们想要解析一个可能包含国家代码或货币代码的URL。国家代码通常是两个字符长，货币代码通常是三个字符长。可以这样做：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will match both `US` and `USD` in the URL – that is, `http://127.0.0.1:5000/test/USD`
    and `http://127.0.0.1:5000/test/US` will be treated similarly. We can also match
    the exact length using the `length` parameter instead of `minlength` and `maxlength`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配URL中的`US`和`USD` – 即，`http://127.0.0.1:5000/test/USD` 和 `http://127.0.0.1:5000/test/US`
    将被类似处理。我们也可以使用`length`参数而不是`minlength`和`maxlength`来匹配确切的长度。
- en: 'We can also parse integer values in a similar fashion:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以以类似的方式解析整数值：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can also specify the minimum and maximum values that can be accepted. For
    example, to limit the acceptable age between 18 and 99, the URL can be structured
    as `@app.route('/test/<int(min=18,max=99):age>')`. We can also parse float values
    using `float` in place of `int` in the preceding example.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定可以接受的最小和最大值。例如，为了限制可接受年龄在18到99岁之间，URL可以被结构化为`@app.route('/test/<int(min=18,max=99):age>')`。我们也可以使用`float`代替先前的例子中的`int`来解析浮点值。
- en: Let’s understand the concept of **pagination** next. In the *Creating a basic
    product model* recipe in [*Chapter 3*](B19111_03.xhtml#_idTextAnchor129), *Data
    Modeling in Flask*, we created a handler to list all the products in our database.
    If we have thousands of products, then generating a list of all of these products
    in one go can take a lot of time. Also, if we have to render these products in
    a template, then we would not want to show more than 10–20 products on a page
    in one go. Pagination proves to be a big help in building great applications.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解**分页**的概念。在[*第3章*](B19111_03.xhtml#_idTextAnchor129)的*Flask中的数据建模*配方*创建基本产品模型*中，我们创建了一个处理程序来列出我们数据库中的所有产品。如果我们有数千个产品，那么一次性生成所有这些产品的列表可能会花费很多时间。此外，如果我们需要在模板中渲染这些产品，我们就不想在一次显示10-20个产品。分页在构建优秀应用程序时证明是一个很大的帮助。
- en: 'Let’s modify the `products()` method to list products to support pagination:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`products()`方法以列出产品并支持分页：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding handler, we added a new URL route that adds a `page` parameter
    to the URL. Now, the `http://127.0.0.1:5000/products` URL will be the same as
    `http://127.0.0.1:5000/products/1`, and both will return a list of the first 10
    products from the database. The `http://127.0.0.1:5000/products/2` URL will return
    the next 10 products, and so on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的处理器中，我们添加了一个新的 URL 路由，将 `page` 参数添加到 URL 中。现在，`http://127.0.0.1:5000/products`
    URL 将与 `http://127.0.0.1:5000/products/1` 相同，并且两者都将返回数据库中的前 10 个产品列表。`http://127.0.0.1:5000/products/2`
    URL 将返回下一个 10 个产品，依此类推。
- en: Information
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: 'The `paginate()` method takes four arguments and returns an object of the `Pagination`
    class. These four arguments are as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`paginate()` 方法接受四个参数，并返回一个 `Pagination` 类的对象。这四个参数如下：'
- en: '• `page`: This is the current page to be listed.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '• `page`: 这是将要列出当前页。'
- en: '• `per_page`: This is the number of items to be listed per page.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '• `per_page`: 这是每页要列出的项目数量。'
- en: '• `error_out`: If no items are found for the page, then this aborts with a
    `404` error. To prevent this behavior, set this parameter to `False`, and then
    it will just return an empty list.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '• `error_out`: 如果页面没有找到任何项目，则将使用 `404` 错误终止。为了防止这种行为，将此参数设置为 `False`，然后它将只返回一个空列表。'
- en: '• `max_per_page`: If this value is specified, then `per_page` will be limited
    to the same.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '• `max_per_page`: 如果指定了此值，则 `per_page` 将限制为相同的值。'
- en: See also
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Creating a basic product model* recipe in [*Chapter 3*](B19111_03.xhtml#_idTextAnchor129),
    *Data Modeling in Flask*, to understand the context of this recipe for pagination,
    as this recipe builds on top of it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 参考第 [*3章*](B19111_03.xhtml#_idTextAnchor129)，*Flask 中的数据建模*中的 *创建基本产品模型* 菜谱，以了解此菜谱中分页的上下文，因为此菜谱是在其基础上构建的。
- en: Rendering to templates
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染到模板
- en: After writing the views, we will surely want to render the content in a template
    and get information from the underlying database.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写视图之后，我们当然希望在一个模板中渲染内容，并从底层数据库中获取信息。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To render templates, we will use `Jinja` as the templating language. Refer to
    [*Chapter 2*](B19111_02.xhtml#_idTextAnchor083), *Templating with Jinja2*, to
    understand templating in depth.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染模板，我们将使用 `Jinja` 作为模板语言。请参阅第 [*2章*](B19111_02.xhtml#_idTextAnchor083)，*使用
    Jinja2 进行模板化*，以深入了解模板化。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will again work in reference to our existing catalog application from the
    previous recipe. Let’s modify our views to render templates and then display data
    from the database in these templates.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次参考之前菜谱中的现有目录应用程序。让我们修改我们的视图以渲染模板，并在这些模板中显示数据库中的数据。
- en: The following is the modified `views.py` code and the templates. The complete
    app can be downloaded from the code bundle provided with this book or from the
    GitHub repository.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对 `views.py` 代码和模板的修改。完整的应用程序可以从本书提供的代码包或 GitHub 仓库中下载。
- en: 'We will start by modifying our views – that is, `flask_catalog_template/my_app/catalog/views.py`
    – to render templates on specific handlers:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先修改我们的视图——即 `flask_catalog_template/my_app/catalog/views.py` ——以在特定的处理器上渲染模板：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note the `render_template()` method. This method will render `home.html` when
    the `home` handler is called.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `render_template()` 方法。当调用 `home` 处理器时，此方法将渲染 `home.html`。
- en: 'The following method handles the rendering of `product.html` with the `product`
    object in the template context:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法处理在模板上下文中使用 `product` 对象渲染 `product.html`：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To get the paginated list of all products, see the following method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有产品的分页列表，请参阅以下方法：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the `products.html` template will be rendered with the list of paginated
    `product` objects in the context.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`products.html` 模板将使用上下文中的分页 `product` 对象列表进行渲染。
- en: 'To render the product template on the creation of a new product, the `create_product()`
    method can be modified, as shown here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要在创建新产品时渲染产品模板，可以修改 `create_product()` 方法，如下所示：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This can also be done using `redirect()`, but we will cover this at a later
    stage. Have a look at the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以使用 `redirect()` 来完成，但我们将在稍后阶段介绍。请看以下代码：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All three handlers in the preceding code work in a similar way, as discussed
    earlier when rendering the product-related templates.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中的三个处理器都以类似的方式工作，正如之前在渲染与产品相关的模板时讨论的那样。
- en: The following are all the templates created and rendered as part of the application.
    For more information on how these templates are written and how they work, refer
    to [*Chapter 2*](B19111_02.xhtml#_idTextAnchor083), *Templating* *with Jinja2*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下都是作为应用程序一部分创建和渲染的模板。有关这些模板的编写方式和它们的工作原理的更多信息，请参阅[*第2章*](B19111_02.xhtml#_idTextAnchor083)，*使用Jinja2进行模板化*。
- en: 'The first template file is `flask_catalog_template/my_app/templates/base.html`,
    as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模板文件是 `flask_catalog_template/my_app/templates/base.html`，内容如下：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `flask_catalog_template/my_app/templates/home.html` file appears as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 `flask_catalog_template/my_app/templates/home.html` 的内容如下：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `flask_catalog_template/my_app/templates/product.html` file appears as
    follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 `flask_catalog_template/my_app/templates/product.html` 的内容如下：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `flask_catalog_template/my_app/templates/products.html` file appears as
    follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 `flask_catalog_template/my_app/templates/products.html` 的内容如下：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note how the URL is being created for the `Previous page` and `Next page` links.
    We are using `request.endpoint` so that pagination works for the current URL,
    which will make the template reusable with `search` as well. We will see this
    later in this chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何为 `上一页` 和 `下一页` 链接创建URL。我们使用 `request.endpoint` 以确保分页适用于当前URL，这将使模板与 `search`
    一起可重用。我们将在本章后面看到这一点。
- en: 'The `flask_catalog_template/my_app/templates/category.html` file appears as
    follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 `flask_catalog_template/my_app/templates/category.html` 的内容如下：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `flask_catalog_template/my_app/templates/categories.html` file appears
    as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 `flask_catalog_template/my_app/templates/categories.html` 的内容如下：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Our `view` methods have a `render_template` method call at the end. This means
    that following the successful completion of the method operations, we will render
    a template with some parameters added to the context.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `view` 方法在最后调用了一个 `render_template` 方法。这意味着在方法操作成功完成后，我们将渲染一个模板，并在上下文中添加一些参数。
- en: Information
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Note how pagination has been implemented in the `products.html` file. It can
    be improved further to show the page numbers as well between the two links for
    navigation. You should undertake this on your own.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 `products.html` 文件中如何实现了分页。可以进一步改进，在两个导航链接之间显示页码。你应该自己完成这项工作。
- en: See also
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: Refer to the *Implementing URL routing and product-based pagination* recipe
    to understand pagination and the remainder of the application used in this recipe.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅*实现URL路由和基于产品的分页*食谱，了解分页和本食谱中使用的应用程序的其余部分。
- en: Dealing with XHR requests
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理XHR请求
- en: '**Asynchronous JavaScript**, commonly known as **Ajax**, has become an important
    part of web applications over the last decade or so. The built-in **XMLHttpRequest**
    (**XHR**) object in a browser is used to execute Ajax on web pages. With the advent
    of single-page applications and JavaScript application frameworks such as **Angular**,
    **Vue**, and **React**, this technique of web development has risen exponentially.
    In this recipe, we will implement an Ajax request to facilitate asynchronous communication
    between the backend and the frontend.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步JavaScript**，通常称为**Ajax**，在过去十年左右的时间里已经成为网络应用程序的一个重要部分。浏览器中内置的**XMLHttpRequest**（**XHR**）对象用于在网页上执行Ajax。随着单页应用程序和JavaScript应用程序框架如**Angular**、**Vue**和**React**的出现，这种网络开发技术呈指数级增长。在本食谱中，我们将实现一个Ajax请求，以促进后端和前端之间的异步通信。'
- en: Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this book, I am opting to use Ajax to demonstrate `async` requests because
    it is simpler to understand and demonstrate and keeps the focus of the book on
    Flask. You can choose to use any JavaScript platform/framework. The Flask code
    would remain the same, while the JavaScript code would have to change according
    to the framework that you used.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我选择使用Ajax来演示 `async` 请求，因为它更容易理解和演示，并且使本书的焦点保持在Flask上。你可以选择使用任何JavaScript平台/框架。Flask代码将保持不变，而JavaScript代码将需要根据你使用的框架进行更改。
- en: Getting ready
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Flask provides an easy way to handle the XHR requests in the view handlers.
    We can even have common methods for normal web requests and XHRs. We can just
    check for the `XMLHttpRequest` header in our `request` object to determine the
    type of call and act accordingly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Flask提供了一个简单的方法来处理视图处理程序中的XHR请求。我们甚至可以为正常网络请求和XHR提供通用方法。我们只需检查 `request` 对象中的
    `XMLHttpRequest` 标头，以确定调用类型并相应地操作。
- en: We will update the catalog application from the previous recipe to have a feature
    to demonstrate XHR requests.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新目录应用程序，从之前的食谱中添加一个功能来演示XHR请求。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The Flask `request` object has a provision to check for the headers sent along
    with the request from the browser. We can check the `X-Requested-With` header
    for `XMLHttpRequest`, which tells us whether the request made is an XHR request
    or a simple web request. Usually, when we have an XHR request, the caller expects
    the result to be in the JSON format, which can then be used to render content
    in the correct place on the web page without reloading the page.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 的 `request` 对象提供了一个检查浏览器发送的请求头部的功能。我们可以检查 `X-Requested-With` 头部以确定是否为
    `XMLHttpRequest`，这告诉我们发出的请求是 XHR 请求还是简单的网页请求。通常，当我们有一个 XHR 请求时，调用者期望结果以 JSON 格式返回，这样就可以在网页上正确地渲染内容，而无需重新加载页面。
- en: 'So, let’s say we have an Ajax call to fetch the number of products in the database
    on the home page itself. One way to fetch the products is to send the count of
    products along with the `render_template()` context. Another way is to send this
    information over as a response to an Ajax call. We will implement the latter to
    see how Flask handles XHR:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在主页本身发送一个 Ajax 调用来获取数据库中的产品数量。一种获取产品的方法是发送产品计数与 `render_template()` 上下文一起。另一种方法是作为
    Ajax 调用的响应发送这些信息。我们将实现后者，看看 Flask 如何处理 XHR：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding method, we first checked whether this is an XHR. If it is,
    we return the JSON data; otherwise, we just render `home.html`, as we have done
    hitherto.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们首先检查这是否是一个 XHR。如果是，我们返回 JSON 数据；否则，我们只渲染 `home.html`，就像我们之前所做的那样。
- en: Tip
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: This design of handling XHR and regular requests together in one method can
    become a bit bloated as the application grows in size, and different logic handling
    has to be executed in the case of XHR, compared to regular requests. In such cases,
    these two types of requests can be separated into different methods, where the
    handling of XHR is done separately from regular requests. This can even be extended
    so that we have different blueprints to make URL handling even cleaner.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序规模增长时，这种在一个方法中同时处理 XHR 和常规请求的设计可能会变得有些臃肿，因为在这种情况下，需要执行不同的逻辑处理，与常规请求相比。在这种情况下，这两种类型的请求可以被分离到不同的方法中，其中
    XHR 的处理与常规请求分开。这甚至可以扩展到我们有不同的蓝图来使 URL 处理更加清晰。
- en: 'Next, modify `flask_catalog_template/my_app/templates/base.html` to a block
    for `scripts`. This empty block, which is shown here, can be placed after the
    line where the `Bootstrap.js` script is included:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改 `flask_catalog_template/my_app/templates/base.html`，将其修改为 `scripts` 块。这个空块，如这里所示，可以放在包含
    `Bootstrap.js` 脚本的行之后：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we have `flask_catalog_template/my_app/templates/home.html`, where we
    send an Ajax call to the `home()` handler, which checks whether the request is
    an XHR request. If it is, it fetches the count of products from the database and
    returns it as a JSON object. Check the code inside the `scripts` block:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们查看 `flask_catalog_template/my_app/templates/home.html`，在这里我们向 `home()`
    处理器发送一个 Ajax 调用，该处理器检查请求是否为 XHR 请求。如果是，它从数据库中获取产品计数并将其作为 JSON 对象返回。检查 `scripts`
    块内的代码：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Now, our home page contains a badge, which shows the number of products in the
    database. This badge will load only after the whole page has loaded. The difference
    in the loading of the badge and the other content on the page will be notable
    when the database has a substantially high number of products.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的主页包含一个徽章，显示数据库中的产品数量。这个徽章只有在整个页面加载完毕后才会加载。当数据库中有大量产品时，徽章与其他页面内容的加载差异将非常明显。
- en: 'The following is a screenshot that shows what the home page looks like now:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个截图，展示了当前主页的样子：
- en: "![Figure 4.2 – The home page\uFEFF with the count loaded using AJAX calls](img/B19111_04_2.jpg)"
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 使用 AJAX 调用加载计数的主页](img/B19111_04_2.jpg)'
- en: Figure 4.2 – The home page with the count loaded using AJAX calls
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 使用 AJAX 调用加载计数的主页
- en: Using decorators to handle requests beautifully
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用装饰器优雅地处理请求
- en: Some of you may believe that checking every time whether a request is XHR, as
    shown in the last recipe, kills code readability. To solve this, we have an easy
    solution. In this recipe, we will write a simple decorator that can handle this
    redundant code for us.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能认为，像上一个菜谱中展示的那样，每次都检查请求是否为 XHR 会降低代码的可读性。为了解决这个问题，我们有一个简单的解决方案。在这个菜谱中，我们将编写一个简单的装饰器，可以为我们处理这些冗余代码。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will write a decorator. For some Python beginners, this might
    seem like alien territory. If so, read [http://legacy.python.org/dev/peps/pep-0318/](http://legacy.python.org/dev/peps/pep-0318/)
    for a better understanding of decorators.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将编写一个装饰器。对于一些Python初学者来说，这可能会感觉像是陌生的领域。如果是这样，请阅读[http://legacy.python.org/dev/peps/pep-0318/](http://legacy.python.org/dev/peps/pep-0318/)以更好地理解装饰器。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The following is the decorator method that we have written for this recipe:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们为这个菜谱编写的装饰器方法：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This decorator simply does what we did in the previous recipe to handle XHR
    – that is, check whether our request is XHR and, based on the outcome, either
    render the template or return JSON data.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器只是做了我们在上一个菜谱中处理XHR所做的事情——即检查我们的请求是否为XHR，并根据结果，要么渲染模板，要么返回JSON数据。
- en: 'Now, let’s apply this decorator to our `home()` method, which handled the XHR
    call in the last recipe:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个装饰器应用到我们的`home()`方法上，这个方法在上一个菜谱中处理了XHR调用：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: See also
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: Refer to the *Dealing with XHR requests* recipe to understand how this recipe
    changes the coding pattern. The reference for this recipe comes from [http://justindonato.com/notebook/template-or-json-decorator-for-flask.html](http://justindonato.com/notebook/template-or-json-decorator-for-flask.html).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 参考处理XHR请求的菜谱，了解这个菜谱如何改变编码模式。这个菜谱的参考来源于[http://justindonato.com/notebook/template-or-json-decorator-for-flask.html](http://justindonato.com/notebook/template-or-json-decorator-for-flask.html)。
- en: Creating custom 4xx and 5xx error handlers
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义4xx和5xx错误处理程序
- en: Every application throws errors to users at some point in time. These errors
    can be due to a user typing a non-existent URL (`404`), application overload (`500`),
    or something forbidden for a certain user to access (`403`). A good application
    handles these errors in a user-interactive way instead of showing an ugly white
    page, which makes no sense to most users. Flask provides an easy-to-use decorator
    to handle these errors. In this recipe, we will understand how we can leverage
    this decorator.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序在某个时间点都会向用户抛出错误。这些错误可能是由于用户输入了不存在的URL（`404`）、应用程序过载（`500`）或者某些用户无法访问的内容（`403`）。一个好的应用程序会以用户交互的方式处理这些错误，而不是显示一个丑陋的空白页面，这对大多数用户来说毫无意义。Flask提供了一个易于使用的装饰器来处理这些错误。在这个菜谱中，我们将了解如何利用这个装饰器。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The Flask `app` object has a method called `errorhandler()`, which enables us
    to handle our application’s errors in a much more beautiful and efficient manner.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Flask `app`对象有一个名为`errorhandler()`的方法，它使我们能够以更美观和高效的方式处理我们的应用程序的错误。
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create a method that is decorated with `errorhandler()` and renders the `404.html`
    template whenever the `404 Not Found` error occurs:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个带有`errorhandler()`装饰器的方法，当发生`404 Not Found`错误时，渲染`404.html`模板：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following lines of code represent the `flask_catalog_template/my_app/templates/404.html`
    template, which is rendered if there are any `404` errors:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行表示`flask_catalog_template/my_app/templates/404.html`模板，如果有任何`404`错误，则会渲染：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'So, now, if we open an incorrect URL – for example, `http://127.0.0.1:5000/i-am-
    lost` – then we will get the screen shown in the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，如果我们打开一个错误的URL——例如，`http://127.0.0.1:5000/i-am-lost`——那么我们将得到以下截图所示的屏幕：
- en: '![Figure 4.3 – A custom error handler page](img/B19111_04_3.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 自定义错误处理页面](img/B19111_04_3.jpg)'
- en: Figure 4.3 – A custom error handler page
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 自定义错误处理页面
- en: Similarly, we can add more error handlers for other error codes too.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以为其他错误代码添加更多的错误处理程序。
- en: There’s more...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It is also possible to create custom errors as per application requirements
    and bind them to error codes and custom error screens. This can be done as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用程序需求创建自定义错误，并将它们绑定到错误代码和自定义错误屏幕也是可能的。这可以按照以下方式完成：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Flashing messages for better user feedback
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闪存消息以提供更好的用户反馈
- en: An important aspect of all good web applications is to give users feedback regarding
    various activities. For example, when a user creates a product and is redirected
    to the newly created product, then it is good practice to tell them that the product
    has been created. In this recipe, we will see how flashing messages can be used
    as a good feedback mechanism for users.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所有优秀Web应用程序的一个重要方面是向用户提供关于各种活动的反馈。例如，当用户创建一个产品并被重定向到新创建的产品时，告诉他们产品已经创建是一个好的做法。在这个菜谱中，我们将了解如何使用闪存消息作为用户良好的反馈机制。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start by adding the flash message functionality to our existing catalog
    application. We also have to make sure that we add a secret key to the application
    because the session depends on it, and if it’s absent, the application will error
    out while flashing.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将闪现消息功能添加到现有的目录应用程序中。我们还必须确保向应用程序添加一个密钥，因为会话依赖于它，如果没有密钥，应用程序在闪现时将出错。
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To demonstrate the flashing of messages, we will flash messages upon a product’s
    creation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示消息的闪现，我们将在产品创建时闪现消息。
- en: 'First, we will add a secret key to our app configuration in `flask_catalog_template/my_app``__init__.py`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向`flask_catalog_template/my_app/__init__.py`中的应用配置添加一个密钥：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, we will modify our `create_product()` handler in `flask_catalog_template/my_app/catalog/views.py`
    to flash a message to the user regarding the product’s creation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将修改位于`flask_catalog_template/my_app/catalog/views.py`中的`create_product()`处理器，以便向用户显示有关产品创建的消息。
- en: Also, another change has been made to this handler; now, it is possible to create
    the product from a web interface using a form. This change will make it easier
    to demonstrate how this recipe would work.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对这一处理器也进行了另一项更改；现在，可以通过表单从网络界面创建产品。这一更改将使展示该菜谱的工作方式变得更加容易。
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding method, we first check whether the request type is `POST`.
    If yes, then we proceed to product creation as always, or render the page with
    a form to create a new product. Also, note the `flash` statement, which will alert
    a user in the event of the successful creation of a product. The first argument
    to `flash()` is the message to be displayed, and the second is the category of
    the message. We can use any suitable identifier in the `message` category. This
    can be used later to determine the type of alert message to be shown.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们首先检查请求类型是否为`POST`。如果是，则像往常一样继续产品创建，或者渲染带有表单的新产品创建页面。请注意`flash`语句，它将在产品成功创建时提醒用户。`flash()`的第一个参数是要显示的消息，第二个参数是消息的类别。我们可以在`message`类别中使用任何合适的标识符。这可以用于以后确定要显示的警告消息类型。
- en: 'A new template is added; this holds the code for the product form. The path
    of the template will be `flask_catalog_template/my_app/templates/product-create.html`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个新的模板；该模板包含产品表单的代码。模板的路径将是`flask_catalog_template/my_app/templates/product-create.html`：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will also modify our base template – that is, `flask_catalog_template/my_app/templates/base.html`
    – to accommodate flashed messages. Just add the following lines of code inside
    the `<div>` container before the `container` block:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将修改我们的基本模板 – 即`flask_catalog_template/my_app/templates/base.html` – 以容纳闪现的消息。只需在`container`块之前的`<div>`容器内添加以下代码行：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Information
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Note that in the `<div>` container, we have added a mechanism to show a flashed
    message that fetches the flashed messages in the template, using `get_flashed_messages()`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`<div>`容器中，我们已添加了一个机制来显示闪现的消息，该机制使用`get_flashed_messages()`在模板中检索闪现的消息。
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A form like the one shown in the following screenshot will appear upon moving
    to `http://127.0.0.1:5000/product-create`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问`http://127.0.0.1:5000/product-create`时，将显示如下截图中的表单：
- en: '![Figure 4.4 – Creating a product](img/B19111_04_4.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – 创建产品](img/B19111_04_4.jpg)'
- en: Figure 4.4 – Creating a product
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 创建产品
- en: 'Fill in the form and click on **Submit**. This will lead to the usual product
    page with an alert message at the top:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 填写表单并点击**提交**。这将导致带有顶部警告消息的常规产品页面：
- en: "![Figure 4.5 –\uFEFF The flash message on successful product creation](img/B19111_04_5.jpg)"
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 成功创建产品时的闪现消息](img/B19111_04_5.jpg)'
- en: Figure 4.5 – The flash message on successful product creation
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 成功创建产品时的闪现消息
- en: Implementing SQL-based searching
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基于SQL的搜索
- en: In any web application, it is important to be able to search a database for
    records based on certain criteria. In this recipe, we will go through how to implement
    basic SQL-based searching in SQLAlchemy. The same principle can be used to search
    any other database system.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何Web应用程序中，能够根据某些标准在数据库中搜索记录非常重要。在本菜谱中，我们将介绍如何在SQLAlchemy中实现基于SQL的基本搜索。相同的原理可以用于搜索任何其他数据库系统。
- en: Getting ready
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We have implemented some level of search functionality in our catalog application
    from the beginning. Whenever we show the product page, we search for a specific
    product using its ID. We will now take it to a slightly more advanced level and
    search on the basis of name and category.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从开始就在目录应用程序中实现了一些搜索功能。每次我们显示产品页面时，我们都会使用其ID搜索特定的产品。现在我们将将其提升到一个稍微高级的水平，并基于名称和类别进行搜索。
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following is a method that searches in our catalog application for name,
    price, company, and category. We can search for any one criterion, or multiple
    criteria (except for a search by category, which can only be searched alone).
    Note that we have different expressions for different values. For a float value
    in `price`, we can search for equality, and in the case of a string, we can search
    using `like`. Also, carefully note how `join` is implemented in the case of `category`.
    Place this method in the `views` file – that is, `flask_catalog_template/my_app/catalog/views.py`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一种在目录应用程序中搜索名称、价格、公司和类别的搜索方法。我们可以搜索任何单一标准，或者多个标准（除了类别搜索，它只能单独搜索）。请注意，我们为不同的值有不同的表达式。对于`price`中的浮点值，我们可以进行等值搜索，而对于字符串，我们可以使用`like`进行搜索。此外，请注意`category`情况下`join`的实现。将此方法放在`views`文件中——即`flask_catalog_template/my_app/catalog/views.py`：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We can search for products by entering a URL, something like `http://127.0.0.1:5000/product-search?name=iPhone`.
    This will search for products with the name `iPhone` and list the results on the
    `products.html` template. Similarly, we can search for price and/or company or
    category as required. Try various combinations by yourself to aid your understanding.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过输入一个URL来搜索产品，例如`http://127.0.0.1:5000/product-search?name=iPhone`。这将搜索名为`iPhone`的产品，并在`products.html`模板上列出结果。同样，我们可以根据需要搜索价格和/或公司或类别。尝试各种组合以帮助理解。
- en: Information
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: We have used the same product list page to render our search results. It will
    be interesting to implement the search using Ajax. I will leave this to you to
    implement yourself.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了相同的产品列表页面来渲染我们的搜索结果。使用Ajax实现搜索将很有趣。我将把这个留给你自己来实现。
- en: 'Part 2: Flask Deep Dive'
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：Flask深入探讨
- en: Once the basic Flask web application is built, the next question concerns creating
    beautiful and reusable web forms and authentication. The first two chapters in
    this part focus specifically on these topics.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建了基本的Flask Web应用程序，下一个问题就是创建美观且可重用的Web表单和身份验证。本部分的前两章专门讨论了这些主题。
- en: As a developer, you can always build web forms using plain HTML, but it is usually
    a cumbersome task and difficult to maintain consistent reusable components. This
    is where Jinja helps, with a better definition of forms and super-easy validations
    while being extensible and customizable.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，你可以始终使用纯HTML构建Web表单，但这通常是一个繁琐的任务，并且难以维护一致的、可重用的组件。这就是Jinja发挥作用的地方，它提供了更好的表单定义和超级简单的验证，同时具有可扩展性和可定制性。
- en: Authentication is one of the most important parts of any application, whether
    web, mobile, or desktop. [*Chapter 6*](B19111_06.xhtml#_idTextAnchor328) focuses
    on various techniques of authentication, which range from social to completely
    managed in-house.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是任何应用程序最重要的部分之一，无论是Web、移动还是桌面。[*第六章*](B19111_06.xhtml#_idTextAnchor328)专注于各种认证技术，这些技术从社交到完全内部管理。
- en: The next chapter deals with APIs, which are an integral part of any web application,
    and one of the major strengths of Flask lies in building APIs in a very clear,
    concise, and readable format. This is followed by adding the capability to support
    multiple languages in your Flask application.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论API，它是任何Web应用程序的一个基本组成部分，Flask的主要优势之一就是以非常清晰、简洁和可读的格式构建API。接下来是添加支持多种语言的能力到你的Flask应用程序中。
- en: Flask by default does not come with an admin interface as you would find in
    Django, which is another popular web framework written in Python. However, it
    is possible to create a completely custom admin interface in Flask quickly by
    leveraging some extensions. The last chapter in this part deals with this subject.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Flask默认不包含像Django这样的管理界面，Django是另一种流行的Python编写的Web框架。然而，通过利用一些扩展，可以在Flask中快速创建一个完全定制的管理界面。本部分的最后一章讨论了这个主题。
- en: 'This part of the book comprises the following chapters:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本书本部分包括以下章节：
- en: '[*Chapter 5*](B19111_05.xhtml#_idTextAnchor273)*, Web Forms with WTForms*'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第五章*](B19111_05.xhtml#_idTextAnchor273)*，使用WTForms的Web表单*'
- en: '[*Chapter 6*](B19111_06.xhtml#_idTextAnchor328)*, Authenticating in Flask*'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19111_06.xhtml#_idTextAnchor328)*，在Flask中进行身份验证*'
- en: '[*Chapter 7*](B19111_07.xhtml#_idTextAnchor385)*, RESTful API Building*'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19111_07.xhtml#_idTextAnchor385)*，RESTful API构建*'
- en: '[*Chapter 8*](B19111_08.xhtml#_idTextAnchor414)*, Internationalization and
    Localization*'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19111_08.xhtml#_idTextAnchor414)*，国际化与本地化*'
- en: '[*Chapter 9*](B19111_09.xhtml#_idTextAnchor469)*, Admin Interface for Flask
    Apps*'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19111_09.xhtml#_idTextAnchor469)*，Flask应用的Admin界面*'
