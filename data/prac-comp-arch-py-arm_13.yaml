- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: ARM Addressing Modes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARM寻址模式
- en: Addressing modes are a fundamental part of computer architecture and are concerned
    with how you express the location of an operand. We introduced addressing modes
    in earlier chapters. Now, we will examine the ARM’s rather sophisticated set of
    addressing modes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 寻址模式是计算机体系结构的基本部分，它关注的是你如何表达操作数的位置。我们在前面的章节中介绍了寻址模式。现在，我们将研究ARM相当复杂的寻址模式集。
- en: 'The topics to be discussed are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 将讨论的主题如下：
- en: Literal addressing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字面量寻址
- en: Scaled literals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放字面量
- en: Register indirect addressing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器间接寻址
- en: The use of two-pointer registers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用双指针寄存器
- en: Auto-incrementing pointers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动递增指针
- en: Literal addressing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字面量寻址
- en: 'The easiest addressing mode is *literal addressing*. Instead of saying where
    an operand is in memory, you provide the operand in an instruction (i.e., this
    is literally the value). Other addressing modes require you to specify where an
    operand is in memory. Consider the following Python expression, which has two
    literals, 30 and 12:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的寻址模式是*字面量寻址*。你不需要说操作数在内存中的位置，而是在指令中提供操作数（即这实际上是值）。其他寻址模式要求你指定操作数在内存中的位置。考虑以下Python表达式，它有两个字面量，30和12：
- en: '`if A > 30: B =` `12`'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`if A > 30: B =` `12`'
- en: 'We can express this fragment of Python in ARM assembly language as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将以下Python代码片段表示为ARM汇编语言，如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can simplify this code by using conditional execution, as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用条件执行来简化此代码，如下所示：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Scaled literals
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩放字面量
- en: The ARM implements 12-bit literals in an unusual way, using a technique borrowed
    from the world of floating-point arithmetic. Four of the 12 bits of a literal
    are used to scale an 8-bit constant. That is, the 8-bit constant is rotated right
    by twice the number in the 4-bit scaling field. The four most-significant bits
    of the literal field specify the literal’s alignment within a 32-bit word. If
    the 8-bit immediate value is `N` and the 4-bit alignment is `n`, then the value
    of the literal is given by `N` rotated *right* by *2n* places. For example, if
    the 8-bit literal is `0xAB` and `n` is `4`, the resulting 32-bit literal is `0xAB000000`
    because of the eight-position right rotation (2 x 4). Remember that an eight rotate
    right position is equivalent to a 32 - 8 = 24 bit shift left. *Figure 11**.1*
    demonstrates some 32-bit literals and the 12-bit literal codes that generate them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ARM以非传统方式实现了12位字面量，借鉴了浮点数领域的技巧。字面量的12位中有4位用于缩放一个8位常数。也就是说，8位常数通过4位缩放字段中的数字进行两次右旋转。字面量字段中最显著的4位指定了字面量在32位字中的对齐方式。如果8位立即值是`N`，4位对齐是`n`，则字面量的值由`N`右旋转`2n`位得到。例如，如果8位字面量是`0xAB`且`n`是`4`，则生成的32位字面量是`0xAB000000`，因为进行了八位的右旋转（2
    x 4）。记住，八个右旋转位置相当于32 - 8 = 24位左移。*图11**.1*展示了某些32位字面量和生成它们的12位字面量代码。
- en: '![Figure 11.1 – ARM’s literal operand encoding](img/Figure_11.01_B19624.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – ARM的字面量操作数编码](img/Figure_11.01_B19624.jpg)'
- en: Figure 11.1 – ARM’s literal operand encoding
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – ARM的字面量操作数编码
- en: You might find this rather strange. Why didn’t ARM use the 12-bit literal field
    to provide a number in the range 0 to 4,095, rather than a number in the range
    0 to 255 scaled by the power of 2? The answer is that ARM’s designers determined
    that the scaled literals were more useful in real-world applications than unscaled
    numbers. For example, suppose you wanted to clear all bits of a 32-bit word, except
    bits 8 to 15\. You would need to `AND` it with the literal `0b00000000000000001111111100000000`
    or `0x0000FF00` in hexadecimal. Using the scaling mechanism, we can take 8 bits
    `0x11111111` and shift them left by 8 bits (i.e., right by 24 bits) to get the
    required constant. However, the scaling factor `n` needs twice the number of rotation
    rights to achieve this. That is (32 – 8)/2, which is 12\. Consequently, the literal
    stored in the 12-bit instruction field is 12,255, or CFF in hexadecimal.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得这相当奇怪。为什么ARM没有使用12位字面量字段来提供一个0到4,095范围内的数字，而不是一个0到255范围内通过2的幂缩放的数字？答案是ARM的设计者认为缩放字面量在现实世界的应用中比未缩放数字更有用。例如，假设你想清除32位字中除了8到15位之外的所有位。你需要用字面量`0b00000000000000001111111100000000`或十六进制的`0x0000FF00`进行`AND`操作。使用缩放机制，我们可以取8位`0x11111111`并将它们左移8位（即右移24位）以得到所需的常数。然而，缩放因子`n`需要两倍的旋转次数才能实现这一点。即(32
    – 8)/2，这是12。因此，存储在12位指令字段中的字面量是12,255，或十六进制的CFF。
- en: Fortunately, calculating the scaling factor is something the programmer does
    not always have to worry about. ARM compilers take a constant and automatically
    generate the best instruction(s) necessary to generate it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，计算缩放因子是程序员不必总是担心的事情。ARM 编译器会自动生成生成所需的最佳指令（或指令集）。
- en: Register indirect addressing
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寄存器间接寻址
- en: We have already encountered this addressing mode where the location of an operand
    is held in a register. It is called register *indirect addressing* because the
    instruction specifies the register where a pointer to the actual operand can be
    found. In ARM literature, this addressing mode is called *indexed addressing*.
    Some people call this *base addressing*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遇到了这种寻址模式，其中操作数的位置存储在寄存器中。它被称为寄存器 *间接寻址*，因为指令指定了可以找到指向实际操作数指针的寄存器。在 ARM
    文献中，这种寻址模式被称为 *索引寻址*。有些人称之为 *基址寻址*。
- en: 'Register indirect addressing mode requires three read operations to access
    an operand:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器间接寻址模式需要三个读取操作来访问操作数：
- en: Read the instruction to find the pointer register
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取指令以找到指针寄存器
- en: Read the pointer register to find the operand address
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取指针寄存器以找到操作数地址
- en: Read memory at the operand address to find the operand
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在操作数地址读取内存以找到操作数
- en: Register indirect addressing is important because the contents of the register
    containing the pointer to the actual operand can be modified at runtime, and therefore,
    the address is a variable. Consequently, we can step through data structures such
    as tables by changing the pointer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器间接寻址很重要，因为包含指向实际操作数指针的寄存器的内容可以在运行时修改，因此地址是变量。因此，我们可以通过改变指针来遍历诸如表格之类的数据结构。
- en: '![Figure 11.2 – Register indirect addressing – executing ldr r1,[r0]](img/Figure_11.02_B19624.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 寄存器间接寻址 – 执行 ldr r1,[r0]](img/Figure_11.02_B19624.jpg)'
- en: Figure 11.2 – Register indirect addressing – executing ldr r1,[r0]
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 寄存器间接寻址 – 执行 ldr r1,[r0]
- en: '*Figure 11**.2* illustrates the effect of `ldr` r1,`[r0]`, where `r0` is the
    pointer and contains the value `n`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11.2* 展示了 `ldr r1,[r0]` 的效果，其中 `r0` 是指针，包含值 `n`。'
- en: '`ldr` r1`,[r0]` loads the contents of the memory location pointed at by register
    `r0` into register `r1`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldr r1,[r0]` 将寄存器 `r0` 指向的内存位置的内容加载到寄存器 `r1` 中。'
- en: Executing `add` r0`,r0,#4` increments the contents of the pointer register `r0`
    by 4 to point at the next word location (remember that consecutive word addresses
    differ by 4).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `add r0,r0,#4` 将指针寄存器 `r0` 的内容增加 4，以便指向下一个字位置（记住，连续的字地址相差 4）。
- en: 'Consider the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first instruction loads `r1` with the 32-bit word pointed at by `r0`. The
    second instruction increments `r0` by 4 to point at the next byte in memory. Repeating
    this pair of instructions will allow you to step through a table of values, element
    by element. We will soon see that the ARM includes a mechanism to automatically
    increment or decrement the pointer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令将 `r1` 寄存器加载为 `r0` 指向的 32 位字。第二条指令将 `r0` 寄存器增加 4，以便指向内存中的下一个字节。重复执行这对指令将允许你逐个元素地遍历值表。我们很快就会看到
    ARM 包含一个自动增加或减少指针的机制。
- en: 'The next fragment of code demonstrates how you would add together the elements
    of a table. Suppose that you have a table of daily expenditures you have made
    over four weeks. Each item is stored consecutively in a table with 4 x 7 = 28
    entries:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码片段演示了如何将表格的元素相加。假设你有一个包含四周内每日支出的表格。每个条目都连续存储在包含 4 x 7 = 28 个条目的表格中：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this simple example, we set up a loop and step through elements from the
    first to the last. On each cycle, we read an element and add it to the total.
    The shaded lines are where the action takes place – getting an element and pointing
    to the next one.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，我们设置了一个循环，并从第一个元素遍历到最后一个元素。在每次循环中，我们读取一个元素并将其加到总数中。阴影线表示动作发生的地方——获取一个元素并指向下一个元素。
- en: 'The next example demonstrates both pointer-based indirect addressing and byte
    operations (i.e., operations on an 8-bit value rather than a full word). Suppose
    we want to find a given character within a string. The following code uses a *byte
    load instruction*, `ldrb`, which loads 8 bits into the destination register. We
    increment the pointer by 1 as we step through the string, not 4, because the values
    are on one-byte boundaries:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例演示了基于指针的间接寻址和字节操作（即，对 8 位值而不是整个字的操作）。假设我们想在字符串中找到一个特定的字符。以下代码使用 *字节加载指令*，`ldrb`，它将
    8 位加载到目标寄存器。我们通过遍历字符串时指针增加 1，而不是 4，因为值位于单字节边界上：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Pointer-based addressing with an offset
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带偏移的基于指针的寻址
- en: Suppose someone asks you, *“Where’s the pharmacy?”* You might reply, *“It’s
    two blocks to the left of the bank.”* That’s pointer-based offset addressing in
    everyday life. We point to the bank by giving its location in relation to something
    else.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有人问你，“药店在哪里？”你可能会回答，“它在银行左边两个街区。”这就是日常生活中的基于指针的偏移寻址。我们通过给出相对于其他事物的位置来指向银行。
- en: The ARM allows you to specify an address using a pointer register, plus a 12-bit
    literal that supplies the offset. Note that this is a true 12-bit literal rather
    than the 8-bit scaled value used as a literal operand. The literal can be positive
    or negative (indicating that it’s to be added to or subtracted from the base pointer).
    Consider `ldr` r5`,[r2,#160]`, where the address of the operand loaded into `r5`
    is the contents of `r1` plus 160.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 允许你使用指针寄存器加上一个提供偏移的 12 位立即数来指定地址。请注意，这是一个真正的 12 位立即数，而不是用作立即操作数的 8 位缩放值。立即数可以是正数或负数（表示它是要加到或从基指针中减去的）。考虑
    `ldr` r5`,[r2,#160]`，其中加载到 `r5` 的操作数地址是 `r1` 的内容加上 160。
- en: 'Suppose you wanted to move a block of 24 words to a location that is 128 bytes
    further on in memory. Assume that the address of the block to move is at `0x400`.
    We can write the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要将一个 24 个字的块移动到内存中比当前位置再远 128 字节的地方。假设要移动的块的地址在 `0x400`。我们可以编写以下代码：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Unfortunately, you cannot run this directly on an ARM-based Raspberry Pi as
    we described because you are not allowed to modify memory in a code segment. That
    is an operating system limitation. To avoid this problem, you have to use pointers,
    as we demonstrated in [*Chapter 9*](B19624_09.xhtml#_idTextAnchor159). We will
    return to this point.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你无法直接在如我们描述的基于 ARM 的 Raspberry Pi 上运行此代码，因为你不允许在代码段中修改内存。这是一个操作系统限制。为了避免这个问题，你必须使用指针，正如我们在[*第
    9 章*](B19624_09.xhtml#_idTextAnchor159)中演示的那样。我们将回到这一点。
- en: Two pointers are better than one
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 两个指针比一个好
- en: The register-indirect addressing mode lets you access elements in a linear data
    structure, such as a one-column table. Sometimes, you will have a more complex
    two-dimensional data structure, such as a matrix with rows and columns. In that
    case, two pointers can simplify programming – one pointer for the row and one
    for the column.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器间接寻址模式允许你访问线性数据结构中的元素，例如一列表。有时，你将有一个更复杂的多维数据结构，例如具有行和列的矩阵。在这种情况下，两个指针可以简化编程——一个指针用于行，一个用于列。
- en: 'ARM provides a pointer-based addressing mode that allows you to specify an
    address that is the sum of two pointer registers, such as the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 提供了一种基于指针的寻址模式，允许你指定两个指针寄存器的和的地址，如下所示：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can apply a shift to the second operand, such as the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对第二个操作数应用位移，如下所示：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, register `r1` is scaled by 8\. The scaling factor must be a power
    of 2 (i.e., 2, 4, 8, 16…).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，寄存器 `r1` 被缩放 8 倍。缩放因子必须是 2 的幂（即，2、4、8、16...）。
- en: '*Figure 11**.3* illustrates pointer-based addressing with two index registers.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11**.3* 展示了使用两个索引寄存器的基于指针的寻址。'
- en: '![Figure 11.3 – Indexed addressing with a register offset – ldr r0,[r1,r2]](img/Figure_11.03_B19624.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 使用寄存器偏移的索引寻址 – ldr r0,[r1,r2]](img/Figure_11.03_B19624.jpg)'
- en: Figure 11.3 – Indexed addressing with a register offset – ldr r0,[r1,r2]
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 使用寄存器偏移的索引寻址 – ldr r0,[r1,r2]
- en: This is conceptual because we’ve shown one register pointing at memory (`r1`)
    and one register providing an offset from `r1` (i.e., `r2`). However, since the
    final address is `r1` plus `r2`, we could have drawn it the other way around.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种概念性的表示，因为我们已经展示了其中一个寄存器指向内存（`r1`）和另一个寄存器提供从 `r1` 的偏移（即，`r2`）。然而，由于最终地址是
    `r1` 加 `r2`，我们也可以反过来画。
- en: Automatic indexing of pointer registers
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针寄存器的自动索引
- en: When pointer registers are used, they are frequently used to step through data
    structures and are often incremented or decremented after every memory access.
    It would, therefore, make sense to include this action as part of the instruction.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用指针寄存器时，它们通常用于遍历数据结构，并在每次内存访问后经常增加或减少。因此，将此动作作为指令的一部分是有意义的。
- en: Indeed, CISC processors invariably include automatic indexing. When RISC processors
    arrived with their *one instruction per clock cycle goal*, automatic indexing
    was dropped from the instruction set. However, this mechanism has been incorporated
    into ARM architecture.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，CISC 处理器通常包括自动索引。当 RISC 处理器以每时钟周期一条指令的目标出现时，自动索引被从指令集中删除。然而，这种机制已被纳入 ARM
    架构。
- en: 'ARM’s automatic indexing has four variations. You can do it before using a
    pointer or after using a pointer. You can index up toward higher addresses or
    down toward lower addresses. Consider the following operations involving an index
    register, `r0`, and an increment of 4 (for one word on a byte-addressed machine).
    Each option is composed of a memory access and a pointer adjust action; in the
    first two cases, the pointer is adjusted first (pre-indexing), and in the other
    two cases, memory is accessed first (post-indexing). Memory accesses are given
    in bold:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 的自动索引有四种变体。您可以在使用指针之前或之后执行它。您可以向上索引到更高地址或向下索引到更低地址。考虑以下涉及索引寄存器 `r0` 和增量
    4（在字节寻址机器上为一个字）的操作。每个选项由一个内存访问和一个指针调整动作组成；在前两种情况下，指针首先调整（预索引），在其他两种情况下，首先访问内存（后索引）。内存访问以粗体表示：
- en: '| **Indexing type** | **First action** | **Second action** |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **索引类型** | **第一个动作** | **第二个动作** |'
- en: '| --- | --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Pre-indexed up | `[r1]` `←` `[r1] + 4` | [r0] ← [[r1]] |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 预索引上升 | `[r1]` `←` `[r1] + 4` | [r0] ← [[r1]] |'
- en: '| Pre-indexed down | `[r1]` `←` `[r1] - 4` | [r0] ← [[r1]] |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 预索引下降 | `[r1]` `←` `[r1] - 4` | [r0] ← [[r1]] |'
- en: '| Post-indexed up | [r0] ← [[r1]] | `[r1]` `←` `[r1] + 4` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 后索引上升 | [r0] ← [[r1]] | `[r1]` `←` `[r1] + 4` |'
- en: '| Post-indexed down | [r0] ← [[r1]] | `[r1]` `←` `[r1] – 4` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 后索引下降 | [r0] ← [[r1]] | `[r1]` `←` `[r1] – 4` |'
- en: 'ARM indicates pre-indexing by including the offset within square brackets and
    appending an exclamation mark, such as the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 通过在方括号内包含偏移量并在其后附加感叹号来表示预索引，如下所示：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The value of the pointer `r0` changes *BEFORE* it is used as an offset. Let’s
    suppose we wish to use post-indexing and increment the pointer *AFTER* it is used.
    In this case, the format is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 指针 `r0` 的值在使用之前改变。假设我们希望使用后索引并在使用后增加指针。在这种情况下，格式如下：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the value of the pointer `r0` changes *AFTER* it is used as an offset.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，指针 `r0` 的值在使用作为偏移量之后改变。
- en: '*Figures 11.4* to *11.6* illustrate ARM’s variations on indexed addressing.
    In each case, the base register is `r1`, the offset is `12`, and the destination
    register is `r0`. These figures are summarized here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11.4* 至 *11.6* 展示了 ARM 在索引寻址上的变体。在每种情况下，基址寄存器是 `r1`，偏移量是 `12`，目标寄存器是 `r0`。这些图在此总结：'
- en: '| **Figure** | **Type** | **Format** | **Base** **reg before** | **Base** **reg
    after** | **Operand address** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **图** | **类型** | **格式** | **基址** **前** | **基址** **后** | **操作数地址** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 11.4 | Reg indirect | ldr r0,[r1,#12] | [r1] | [r1] | [r1] + 12 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 11.4 | 寄存器间接 | ldr r0,[r1,#12] | [r1] | [r1] | [r1] + 12 |'
- en: '| 11.5 | Pre-indexed | ldr r0,[r1,#12]! | [r1] | [r1] + 12 | [r1] + 12 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 11.5 | 预索引 | ldr r0,[r1,#12]! | [r1] | [r1] + 12 | [r1] + 12 |'
- en: '| 11.6 | Post-indexing | ldr r0,[r1],#12 | [r1] | [r1] + 12 | [r1] |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 11.6 | 后索引 | ldr r0,[r1],#12 | [r1] | [r1] + 12 | [r1] |'
- en: '![Figure 11.4 – Register indirect addressing with an offset](img/Figure_11.04_B19624.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 带偏移的寄存器间接寻址](img/Figure_11.04_B19624.jpg)'
- en: Figure 11.4 – Register indirect addressing with an offset
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 带偏移的寄存器间接寻址
- en: '![Figure 11.5 – Register indirect addressing with pre-indexing](img/Figure_11.05_B19624.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 带预索引的寄存器间接寻址](img/Figure_11.05_B19624.jpg)'
- en: Figure 11.5 – Register indirect addressing with pre-indexing
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 带预索引的寄存器间接寻址
- en: '![Figure 11.6 – Register indirect addressing with post-indexing](img/Figure_11.06_B19624.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – 带后索引的寄存器间接寻址](img/Figure_11.06_B19624.jpg)'
- en: Figure 11.6 – Register indirect addressing with post-indexing
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 带后索引的寄存器间接寻址
- en: 'Consider the following example where we use post-indexing to move a block of
    data from one memory region to another. In this case, we use post-indexing by
    four because we move 4-byte words:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，我们使用后索引将数据块从一个内存区域移动到另一个内存区域。在这种情况下，我们通过后索引四个字节，因为我们移动的是4字节字：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The two key lines of this program are the load and store instructions (shaded),
    where data is read from the source and copied to the destination. As we have stated,
    you can’t run this code *directly* on Raspberry Pi without modification because
    of the way in which the memory space is allocated to variables. The following
    code demonstrates a runnable version for Raspberry Pi.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的两大关键行是加载和存储指令（阴影部分），其中数据从源读取并复制到目标。正如我们所言，由于变量分配内存空间的方式，你无法在不修改的情况下直接在Raspberry
    Pi上运行此代码。以下代码演示了适用于Raspberry Pi的可运行版本。
- en: 'This is, essentially, the same code. As well as dealing with the memory problem,
    we’ve added assembly directives and dummy data (complete with markers that allow
    you to observe data in memory more easily). There’s also a `nop` instruction.
    Note that some versions of ARM have a true `nop` and some use a pseudo-instruction.
    I added this as a dummy instruction to *“land on”* while testing. Remember that
    the address of the actual data is stored in the program area, and then a pointer
    is loaded with that address:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是相同的代码。除了处理内存问题外，我们还添加了汇编指令和虚拟数据（包括允许你更容易观察内存中数据的标记）。还有一个`nop`指令。请注意，ARM的一些版本有真正的`nop`指令，而另一些则使用伪指令。我在测试时添加了这个虚拟指令以“定位”到某个位置。记住，实际数据的地址存储在程序区域，然后使用该地址加载一个指针：
- en: '![Figure 11.7 – The use of pointers when accessing read/write memory](img/Figure_11.07_B19624.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7 – 访问读写内存时使用指针](img/Figure_11.07_B19624.jpg)'
- en: Figure 11.7 – The use of pointers when accessing read/write memory
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 – 访问读写内存时使用指针
- en: We ran the preceding program using `gbd` as a debugging tool, as the following
    output demonstrates. In order to condense the text, we’ve removed unnecessary
    data from the display – for example, registers that are not accessed or modified.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`gbd`作为调试工具运行了前面的程序，以下输出展示了这一点。为了压缩文本，我们已从显示中删除了不必要的数据——例如，未访问或修改的寄存器。
- en: '![Figure 11.8 – Using gdb to trace the program of Figure 11.7](img/Figure_11.08_B19624.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8 – 使用gdb跟踪图11.7的程序](img/Figure_11.08_B19624.jpg)'
- en: Figure 11.8 – Using gdb to trace the program of Figure 11.7
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – 使用gdb跟踪图11.7的程序
- en: Example of string-copying
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串复制的示例
- en: 'The next example, *Figure 11**.9*, uses post-indexing to copy a string from
    one place to another in reverse order by moving one pointer down and the other
    up. The destination pointer is incremented by `len-1` to point to the end of the
    string, initially. The following code includes assembly language directives, enabling
    it to run on the RPi:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例，*图11.9*，使用后索引将字符串从一处复制到另一处，并按反向顺序移动一个指针向下，另一个指针向上。目标指针通过`len-1`递增，最初指向字符串的末尾。以下代码包括汇编语言指令，使其能够在RPi上运行：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Figure 11.9 – Reversing a string](img/Figure_11.09_B19624.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9 – 反转字符串](img/Figure_11.09_B19624.jpg)'
- en: Figure 11.9 – Reversing a string
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 – 反转字符串
- en: The next section looks at a variation of pointer-based addressing where the
    pointer is the program counter itself. Consequently, all data and programs are
    referenced to the location of the current program.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将探讨一种基于指针寻址的变体，其中指针本身是程序计数器。因此，所有数据和程序都参照当前程序的地址进行引用。
- en: Program counter-relative addressing
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序计数器相对寻址
- en: The ARM is an unusual processor in so many ways. You can use any register (i.e.,
    `r0` to `r15`) as a pointer register. However, `r15` is the ARM’s program counter.
    If you use `r15` as a pointer register with an index, you are saying, *“The operand
    is at this distance from where I am.”* Here the *“where I am”* refers to the instruction
    itself. *Figure 11**.10* illustrates program counter-relative addressing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ARM处理器在许多方面都是不寻常的。你可以使用任何寄存器（即，`r0`到`r15`）作为指针寄存器。然而，`r15`是ARM的程序计数器。如果你使用`r15`作为带索引的指针寄存器，你就是在说，“操作数距离我这里有多远。”这里的“我这里”指的是指令本身。*图11.10*说明了程序计数器相对寻址。
- en: Think about it. You give the address of data with respect to the program that’s
    using it and not an absolute address in memory. If you move the program in memory,
    the data is still the same distance from the instructions that access it, using
    program counter-relative addressing. The introduction of program counter relative
    addressing was one of the major advances in computer architecture. By the way,
    most branch instructions use program counter relative addressing because the destination
    of a branch is specified with respect to the current instruction.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看。你给出的是数据相对于使用它的程序地址，而不是内存中的绝对地址。如果你在内存中移动程序，数据与访问它的指令的距离仍然是相同的，使用程序计数器相对寻址。程序计数器相对寻址的引入是计算机架构中的一个重大进步。顺便说一句，大多数分支指令都使用程序计数器相对寻址，因为分支的目标是相对于当前指令指定的。
- en: The ARM uses program counter relative addressing to load 32-bit constants. Recall
    that you can load only 12-bit constants with the `ldr` instruction. However, the
    assembler can pre-load a 32-bit constant in memory and then use program counter
    relative addressing to access it. In other words, you dump a 32-value in memory
    near (or within) the program and then access it using program counter relative
    addressing. This is the reason for pseudo-instructions. Without pseudo-instructions,
    you’d have to calculate the relative address between the current `pc` and the
    desired operand. Pseudo-instructions do that and make the address invisible to
    the programmer.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ARM使用程序计数器相对寻址来加载32位常量。回想一下，你只能使用`ldr`指令加载12位常量。然而，汇编器可以在内存中预先加载一个32位常量，然后使用程序计数器相对寻址来访问它。换句话说，你将一个32位值存储在程序附近（或其中）的内存中，然后使用程序计数器相对寻址来访问它。这就是伪指令存在的原因。如果没有伪指令，你将不得不计算当前`pc`和所需操作数之间的相对地址。伪指令会这样做，并且使地址对程序员不可见。
- en: Executing `ldr` r0`,[r15,#0x100]` loads a 32-bit operand that is `0x100` bytes
    (0x40 or 64 words) from the contents of register `r15`, the program counter. The
    operand loaded into `r0` is `0x108` bytes from the pc. Why `0x108` and not `0x100`,
    as specified in the instruction? The additional 8 bytes are there because the
    program counter is incremented by 8 bytes after each instruction and, therefore,
    runs 8 bytes ahead of the current address.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`ldr r0`,[r15,#0x100]`指令将一个32位操作数加载到`r0`寄存器中，该操作数位于程序计数器`r15`的内容`0x100`字节（0x40或64个字）处。加载到`r0`的操作数距离程序计数器`pc`为`0x108`字节。为什么是`0x108`而不是指令中指定的`0x100`，这是为什么呢？额外的8个字节存在是因为程序计数器在每条指令执行后增加8个字节，因此它比当前地址领先8个字节。
- en: What about program counter relative store instructions? These cannot be used.
    Store operations using the program counter addressing mode are not supported in
    the ARM. This restriction is probably because (a) a lot of code is in read-only
    memory and can’t be changed, and (b) it would allow the modification of runtime
    programs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 那么程序计数器相对存储指令呢？这些指令不能使用。在ARM中，不支持使用程序计数器寻址模式的存储操作。这种限制可能是因为（a）大量代码位于只读内存中且无法更改，以及（b）它将允许修改运行时程序。
- en: '![Figure 11.10 – Program counter relative addressing](img/Figure_11.10_B19624.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图11.10 – 程序计数器相对寻址](img/Figure_11.10_B19624.jpg)'
- en: Figure 11.10 – Program counter relative addressing
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 – 程序计数器相对寻址
- en: Demonstration of program counter relative addressing
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序计数器相对寻址演示
- en: 'Consider the following text where we use two types of pseudo-instruction, both
    of which are designed to load a 32-bit value into a register. One is `adr` (load
    an address) and the other `ldr` (load a 32-bit literal):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下文本，其中我们使用了两种类型的伪指令，这两种伪指令都是为了将32位值加载到寄存器中。一个是`adr`（加载地址）和另一个`ldr`（加载32位立即数）：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There are three `ldr` instructions. Two load addresses into registers and the
    third, `ldr`, loads a 32-bit literal `0x11111111`. There is an `adr` instruction
    that loads a 32-bit address into register `r2`. What happens when these codes
    are executed?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个`ldr`指令。两个将地址加载到寄存器中，第三个`ldr`指令加载一个32位立即数`0x11111111`。还有一个`adr`指令将32位地址加载到寄存器`r2`中。当这些代码执行时会发生什么？
- en: 'First, let’s look at the source code when viewed in `gdb`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看在`gdb`中查看的源代码：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that these differ from the source code. That’s because the source code
    uses pseudo-instructions that are translated. For example, `ldr r0,=pqr` is translated
    into `ldr r0,[pc,#32]`. The source code cannot specify a 32-bit instruction. However,
    the translated version used a conventional load to specify the location of the
    actual operand 32 bits for the current value of the program counter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些与源代码不同。这是因为源代码使用的是翻译后的伪指令。例如，`ldr r0,=pqr` 被翻译成 `ldr r0,[pc,#32]`。源代码不能指定
    32 位指令。然而，翻译版本使用常规加载来指定实际操作数的 32 位位置，这是程序计数器当前值的 32 位。
- en: '`add r2,pc,#20` is treated differently. Here, the 32-bit literal is generated
    by adding 20 to the value of the current pc, because the address to be located
    is 20 bytes from the current PC value.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`add r2,pc,#20` 的处理方式不同。在这里，32 位立即数是通过将 20 加到当前 pc 的值来生成的，因为要定位的地址距离当前 PC 值
    20 字节。'
- en: 'Let’s look at the registers when the code is executed up to `nop` using `gdb`.
    We will examine both the contents of the registers at the end of the program and
    then look at the memory locations. You can see the data stored in memory and the
    constants accessed by program counter relative addressing:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `gdb` 来查看代码执行到 `nop` 时的寄存器。我们将检查程序结束时的寄存器内容，然后查看内存位置。你可以看到存储在内存中的数据以及通过程序计数器相对寻址访问的常量：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the next chapter, we will continue the theme of addressing, looking at how
    the ARM implements subroutines and how you can use the stack to keep track of
    subroutine return addresses.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探讨寻址的主题，看看 ARM 如何实现子程序，以及你如何使用堆栈来跟踪子程序返回地址。
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Addressing modes comprise all the ways to express the location of an item in
    memory. Addressing modes are simultaneously the easiest and most difficult topic
    in assembly language programming. The concept is simple, but indirect addressing
    modes that use pointers may take some effort to visualize.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 寻址模式包括表示内存中项目位置的所有方式。寻址模式在汇编语言编程中既是最容易的也是最难的主题。概念很简单，但使用指针的间接寻址模式可能需要一些努力来可视化。
- en: In this chapter, we learned about literal or immediate addressing where an operand
    is an actual value (it’s the thing itself and not the location). Literal values
    are used to specify constants – for example, in x + 5, the number 5 is a literal.
    This is the simplest of addressing modes, and no memory location is accessed because
    the data is part of the instruction.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了立即寻址或直接寻址，其中操作数是一个实际值（它是事物本身，而不是位置）。立即值用于指定常量——例如，在 x + 5 中，数字 5 是一个立即值。这是最简单的寻址模式，因为数据是指令的一部分，所以不访问任何内存位置。
- en: We also looked at the ARM’s rather unusual way of specifying literals, by providing
    a value in the range of 0 to 255 and a multiplier that can multiply it by an even
    power of 2\. You can specify 5 and store 5, 20, 80, and so on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了 ARM 指定立即数的一种相当不寻常的方式，即提供一个 0 到 255 范围内的值和一个可以将其乘以 2 的偶数次幂的乘数。你可以指定 5
    并存储 5、20、80 等等。
- en: Much of this chapter was taken up by register indirect addressing, which has
    a lot of other names (indexed and pointer-based). In this case, the address is
    given by the contents of a register. The instruction specifies not the actual
    address of an operand but the register that points to it. Because you can manipulate
    data in a register, you can manipulate addresses and access data structures such
    as arrays and tables.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容都是关于寄存器间接寻址，它有许多其他名称（索引和基于指针的）。在这种情况下，地址由寄存器的内容给出。指令指定的是操作数的实际地址，而不是指向它的寄存器。因为你可以操作寄存器中的数据，所以你可以操作地址并访问数组、表格等数据结构。
- en: The ARM provides RISC-style auto-incrementing and decrementing. That means you
    can use a pointer and increment it or decrement it beforehand (or after it is
    used).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 提供了 RISC 风格的自动增量和减量。这意味着你可以使用指针并在之前（或之后使用）对其进行增减。
- en: We also looked at a special form of register indirect addressing, relative addressing,
    where the pointer is the program counter itself – that is, the address of an operand
    is specified with respect to the instruction that accesses it. This means that
    code using program counter relative addressing can be moved around in memory without
    any addresses being recalculated.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了寄存器间接寻址的一种特殊形式，即相对寻址，其中指针是程序计数器本身——也就是说，操作数的地址是相对于访问它的指令来指定的。这意味着使用程序计数器相对寻址的代码可以在内存中移动，而无需重新计算任何地址。
- en: In the next chapter, we will look at a topic that is fundamental to programming
    – the subroutine and the stack. This topic is also heavily related to addressing
    modes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨编程基础中的一个主题——子程序和栈。这个主题也与寻址模式密切相关。
