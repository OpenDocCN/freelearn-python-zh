- en: Building a Flask Application with Zappa
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Zappa构建Flask应用程序
- en: In the last chapter, we learned about automating the deployment process using
    Zappa, since Zappa helps us to deploy a Python application on the AWS Serverless
    infrastructure. We used this to develop a Python application using some of the
    Python web frameworks. In this chapter, we going to develop a Flask-based application
    as a serverless application on AWS Lambda.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了使用Zappa自动化部署过程的重要性，因为Zappa帮助我们在AWS无服务器基础架构上部署Python应用程序。我们使用它来开发使用一些Python
    Web框架的Python应用程序。在本章中，我们将开发一个基于Flask的应用程序，作为AWS Lambda上的无服务器应用程序。
- en: In the previous chapter, we saw how Zappa is useful for performing serverless
    deployments and how it makes it easy to deploy with a single command. Now, it's
    time to see the larger application deployed by Zappa, since it's really important
    to see how an application is configured and moved to AWS Lambda.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了Zappa如何有助于执行无服务器部署，以及如何通过单个命令轻松部署。现在，是时候看到Zappa部署的更大型应用程序了，因为看到应用程序如何配置并移动到AWS
    Lambda是非常重要的。
- en: 'In this chapter, we''ll be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is Flask?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Flask？
- en: Minimal Flask application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小的Flask应用程序
- en: Configuring with Zappa
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Zappa配置
- en: Building, testing, and deploying on AWS Lambda
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在AWS Lambda上构建，测试和部署
- en: A complete Flask Todo application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个完整的Flask Todo应用程序
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before making headway, let''s understand the technical requirements and configure
    the development environment. This chapter does have a conceptual demonstration
    of an application development. Hence, there are some prerequisites:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们了解技术要求并配置开发环境。本章中有一个应用程序开发的概念演示。因此，有一些先决条件：
- en: Ubuntu 16.04/macOS/Windows
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu 16.04/macOS/Windows
- en: Python 3.6
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.6
- en: Pipenv tool
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pipenv工具
- en: Zappa
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zappa
- en: Flask
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask
- en: Flask Extensions
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask扩展
- en: Once you have configured Python 3.6 and installed the Pipenv tool, you can create
    a virtual environment and install these packages. We are going to explore the
    installation and configuration of this in a later section. Let's move on and understand
    some basic concepts of Python-based frameworks and their related implementation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您配置了Python 3.6并安装了Pipenv工具，您可以创建一个虚拟环境并安装这些软件包。我们将在后面的章节中探索其安装和配置。让我们继续了解一些基于Python框架及其相关实现的基本概念。
- en: What is Flask?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Flask？
- en: Flask is a well-known Python micro web framework in the Python community. It's
    adopted and preferable because of its extensible nature. Flask aims to keep the
    code simple but extensible.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Flask是Python社区中知名的微型Web框架。它因其可扩展的特性而被广泛采用和青睐。Flask旨在保持代码简单但可扩展。
- en: By default, Flask does not include any database abstraction layer, form validation,
    or any other specific functionality. Instead, Flask supports extensions to add
    any well-defined functionality to your application. Numerous extensions are available
    to provide database integration, form validation, file upload handling, authentication,
    and more. The Flask core team reviews extensions and ensures that they won't break
    the future release.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Flask不包括任何数据库抽象层，表单验证或任何其他特定功能。相反，Flask支持扩展以向您的应用程序添加任何明确定义的功能。有许多扩展可用于提供数据库集成，表单验证，文件上传处理，身份验证等。Flask核心团队审查扩展，并确保它们不会破坏未来的发布。
- en: Flask allows you to define the design as per your application needs. You are
    not bound to follow some strict rule by Flask. You can write your application
    code in a single file or in a modular manner. Flask supports built-in development
    servers and fast debuggers, unit testing, RESTful request dispatching, Jinja2
    templating, and secure cookies (for client-side sessions), all of which are WSGI
    1.0-compliant and Unicode-based.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Flask允许您根据应用程序的需要定义设计。您不必遵循Flask的一些严格规则。您可以将应用程序代码编写在单个文件中，也可以以模块化的方式编写。Flask支持内置开发服务器和快速调试器，单元测试，RESTful请求分发，Jinja2模板化和安全的cookies（用于客户端会话），所有这些都符合WSGI
    1.0标准和基于Unicode。
- en: That's why many in the Python community prefer to use the Flask framework as
    their first choice. Let's make headway and explore the Flask-based application
    development process with actual implemention along with a serverless approach.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么许多Python社区的人更喜欢将Flask框架作为他们的首选。让我们继续前进，探索基于Flask的应用程序开发过程，实际实现以及无服务器方法。
- en: Installing Flask
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Flask
- en: Flask mainly depends on two external libraries such as Werkzeug and Jinja2\.
    Werkzeug provides a Python standard **WSGI** (**Web Server Gateway Interface**)
    that enables a Python application to interact with HTTP. Jinja2 is a templating
    engine that enables you to render an HTML template with your own customized context.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Flask主要依赖于两个外部库，即Werkzeug和Jinja2。Werkzeug提供了Python标准的WSGI（Web服务器网关接口），使Python应用程序能够与HTTP交互。Jinja2是一个模板引擎，使您能够使用自定义上下文呈现HTML模板。
- en: Now, let's move on and install Flask. All its dependencies will be automatically
    installed; you don't need to install dependencies manually.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续安装Flask。所有其依赖项将自动安装；您无需手动安装依赖项。
- en: It's recommended that you use `virtualenv` to install Flask, since `virtualenv`
    enables you to install Python packages in parallel for different Python projects.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您使用`virtualenv`来安装Flask，因为`virtualenv`使您能够为不同的Python项目并行安装Python软件包。
- en: 'If you don''t have `virtualenv`, then you can simply install it by using the
    following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有`virtualenv`，那么您可以使用以下代码简单安装它：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once you have installed `virtualenv`, you need to create a new environment
    for your Flask project, as shown in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您安装了`virtualenv`，您需要为您的Flask项目创建一个新的环境，如下面的屏幕截图所示：
- en: '![](img/00032.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00032.jpeg)'
- en: 'We will be using `virtualenv` in the upcoming sections. Now, let''s install
    Flask:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中使用`virtualenv`。现在，让我们安装Flask：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are ready to have fun with Flask. We will be creating a minimal Flask application
    to demonstrate the Flask application workflow.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好开始使用Flask了。我们将创建一个最小的Flask应用程序来演示Flask应用程序的工作流程。
- en: A minimal Flask application
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个最小的Flask应用程序
- en: 'Let''s see what a minimal Flask application looks like:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看最小的Flask应用程序是什么样子的：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That's it, we are done with the minimal Flask application. It's very simple
    to configure and create a microservice with Flask.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，我们完成了最小的Flask应用程序。使用Flask配置和创建微服务非常简单。
- en: 'Let''s discuss what exactly the preceding code is doing and how we would run
    the program:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下前面的代码到底在做什么，以及我们如何运行这个程序：
- en: First, we imported a Flask class.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入了一个Flask类。
- en: Next, we created an instance of the Flask class. This instance will be our WSGI
    application. This first argument will be the name of the module or package. Here,
    we created a single module, hence we used `__name__`. This is needed so that Flask
    knows where to look for templates, static, and other directories.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个Flask类的实例。这个实例将是我们的WSGI应用程序。第一个参数将是模块或包的名称。在这里，我们创建了一个单一的模块，因此我们使用了`__name__`。这是必需的，这样Flask就知道在哪里查找模板、静态和其他目录。
- en: Then, we used `app.route` as a decorator with a URL name as a parameter. This
    will define and map the route with the specified function.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`app.route`作为装饰器，带有URL名称作为参数。这将定义并映射路由到指定的函数。
- en: The function will be invoked to the HTTP request with the URL specified in the
    route decorator.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数将被调用以处理路由装饰器中指定的URL的HTTP请求。
- en: 'To run this program, you can either use the `flask` command or `python -m flask`,
    but before that, you need to set an environment variable as `FLASK_APP` with a
    module file name of where the Flask instance was defined:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个程序，您可以使用`flask`命令或`python -m flask`，但在此之前，您需要设置一个环境变量`FLASK_APP`，并指定Flask实例所在的模块文件名：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This launches a built-in server that is good enough for testing and debugging
    locally. The following is a screenshot of the localhost running in the browser:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这启动了一个内置服务器，足够用于本地测试和调试。以下是浏览器中运行的本地主机的截图：
- en: '![](img/00033.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00033.jpeg)'
- en: Of course, it wouldn't work with production, but Flask provides numerous options
    for deployment. You can have a look at [http://flask.pocoo.org/docs/0.12/deploying/#deployment](http://flask.pocoo.org/docs/0.12/deploying/#deployment)
    for more information, but in our case, we are going to deploy to a serverless
    environment on AWS Lambda and API Gateway using Zappa.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这在生产环境下是行不通的，但Flask提供了许多部署选项。您可以查看[http://flask.pocoo.org/docs/0.12/deploying/#deployment](http://flask.pocoo.org/docs/0.12/deploying/#deployment)获取更多信息，但在我们的情况下，我们将使用Zappa在AWS
    Lambda和API Gateway上部署到无服务器环境。
- en: Configuring with Zappa
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Zappa进行配置
- en: In order to configure Zappa, it's required that you have Zappa installed, as
    mentioned in the previous chapter. Zappa provides the `zappa init` command, which
    enables a user interactive mode initialization so that we can configure the Python
    application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置Zappa，需要安装Zappa，如前一章所述。Zappa提供了`zappa init`命令，它可以启用用户交互模式初始化，以便我们可以配置Python应用程序。
- en: I followed the default configuration settings that were suggested by the `zappa
    init` command. This generates the `zappa_settings.json` file, which is the backbone
    for configuring any Python application with Zappa.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我遵循了`zappa init`命令建议的默认配置设置。这会生成`zappa_settings.json`文件，这是配置任何Python应用程序与Zappa的基础。
- en: 'Here is the content of the `zappa_settings.json` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`zappa_settings.json`文件的内容：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, during initialization, Zappa has the ability to identify the type of your
    Python application and generate the set attributes accordingly. In our case, Zappa
    detected the Python program as a Flask application. Hence, it asked for the Flask
    instance path, which we initialized as `app = Flask(__name__)` in the `hello_world.py`
    file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在初始化期间，Zappa有能力识别您的Python应用程序的类型，并相应地生成设置属性。在我们的情况下，Zappa检测到Python程序是一个Flask应用程序。因此，它要求Flask实例路径，我们在`hello_world.py`文件中初始化为`app
    = Flask(__name__)`。
- en: Now that the Zappa configuration has been completed as per our basic needs,
    it's time to deploy it on AWS Lambda.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Zappa配置已经按照我们的基本需求完成，是时候在AWS Lambda上部署它了。
- en: Building, testing, and deploying on AWS Lambda
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWS Lambda上构建、测试和部署
- en: We described the basic uses of Zappa with some basic commands in the previous
    chapter. Using these commands, we can build the deployment package, deploy the
    application, and perform other basic operations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一章描述了Zappa的基本用法和一些基本命令。使用这些命令，我们可以构建部署包、部署应用程序和执行其他基本操作。
- en: 'Once you have the `zappa_settings.json` file in place with all of the valid
    attributes, you can start the deployment process by using the `zappa deploy <stage_name>`
    command. As per our `zappa_settings.json` file, we have one stage defined as `dev`,
    so, to start the deployment, we can run the `deploy` command, as shown in the
    following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在`zappa_settings.json`文件中设置了所有有效的属性，您就可以使用`zappa deploy <stage_name>`命令开始部署过程。根据我们的`zappa_settings.json`文件，我们定义了一个名为`dev`的阶段，因此，要开始部署，我们可以运行`deploy`命令，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following screenshot describes the deployment flow:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图描述了部署流程：
- en: '![](img/00034.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00034.jpeg)'
- en: Once the Zappa deployment is complete, it generates a random API gateway endpoint.
    Zappa configures AWS Lambda with API Gateway based on the `zappa_settings.json`
    file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Zappa部署完成，它会生成一个随机的API网关端点。Zappa根据`zappa_settings.json`文件配置AWS Lambda与API
    Gateway。
- en: 'Now, the Flask application is available through the previously generated API.
    Let''s test it to see the Hello World! response from the Flask application. You
    can hit the URL in the browser, as shown in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Flask应用程序可以通过先前生成的API访问。让我们测试一下，看看Flask应用程序的Hello World!响应。您可以在浏览器中输入URL，如下面的截图所示：
- en: '![](img/00035.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00035.jpeg)'
- en: Now, let's move on to the next section to see an application development using
    the Flask framework.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一节，看看如何使用Flask框架开发应用程序。
- en: A complete Flask Todo application
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个完整的Flask Todo应用程序
- en: As we have seen how Zappa makes it super easy to deploy the Flask application,
    it's time to see the complete workflow that we may need while developing a Flask-based
    application. We are going to develop a Flask-based modularized application, where
    each functionality will be an independent module, such as authentication, Todo
    application, and so on.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经看到Zappa如何轻松部署Flask应用程序，现在是时候看看在开发基于Flask的应用程序时可能需要的完整工作流程。我们将开发一个基于Flask的模块化应用程序，其中每个功能都将是一个独立的模块，例如认证、待办应用程序等。
- en: The authentication module will be responsible for maintaining the authentication
    and authorization mechanism. It will also include the implementation of the login
    and sign up process.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 认证模块将负责维护认证和授权机制。它还将包括登录和注册过程的实现。
- en: Whereas the `todo` module will have a basic implementation of todo operations,
    this operation flow will be authorized by the authentication module. With the
    help of Flask extensions, we are going to manage and configure these modules.
    Apart from these core modules, we are also going to see the implementation related
    to the user interface, database configuration, and static file integration.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 而`todo`模块将有一个基本的todo操作实现，这个操作流程将由认证模块授权。借助Flask扩展，我们将管理和配置这些模块。除了这些核心模块，我们还将看到与用户界面、数据库配置和静态文件集成相关的实现。
- en: Prerequisite
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先决条件
- en: In order to set up the development environment, we need to perform some configurations
    related to `virtualenv` and the required packages.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置开发环境，我们需要执行一些与`virtualenv`和所需包相关的配置。
- en: Virtualenv
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Virtualenv
- en: 'Before we start working on the project, let''s create a virtual environment
    and enable it, as shown in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始项目工作之前，让我们创建一个虚拟环境并启用它，如下面的截图所示：
- en: '![](img/00036.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00036.jpeg)'
- en: Flask extensions
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask扩展
- en: Flask is a microframework, but it has an extensible nature wherein you can add
    more features as per your needs. To develop a Todo application, we may need some
    basic features such as data persistence and a user authentication mechanism. So,
    while working on a Flask application, we are going to use some Flask extensions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Flask是一个微框架，但它具有可扩展的特性，您可以根据需要添加更多功能。为了开发一个待办应用程序，我们可能需要一些基本功能，如数据持久性和用户认证机制。因此，在开发Flask应用程序时，我们将使用一些Flask扩展。
- en: 'The Flask registry provides numerous extensions, which are standalone packages,
    and you can easily configure them with your Flask application instance. You can
    see the complete list of Flask extensions at: [http://flask.pocoo.org/extensions/](http://flask.pocoo.org/extensions/).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Flask注册表提供了许多扩展，这些扩展是独立的包，您可以轻松地将它们配置到您的Flask应用程序实例中。您可以在[http://flask.pocoo.org/extensions/](http://flask.pocoo.org/extensions/)上看到完整的Flask扩展列表。
- en: 'We are going to use the following Flask and Flask extensions packages:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下Flask和Flask扩展包：
- en: '`Flask==0.12.2`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flask==0.12.2`'
- en: '`Flask-Login==0.4.0`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flask-Login==0.4.0`'
- en: '`Flask-SQLAlchemy==2.3.2`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flask-SQLAlchemy==2.3.2`'
- en: '`Flask-WTF==0.14.2`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flask-WTF==0.14.2`'
- en: '`Flask-Migrate==2.1.1`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flask-Migrate==2.1.1`'
- en: 'I would recommend listing these packages in a separate file named `requirements.txt` and
    then installing them in one go, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议将这些包列在一个名为`requirements.txt`的单独文件中，然后一次性安装它们，如下所示：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will install all of the listed packages with their dependencies.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装所有列出的包及其依赖项。
- en: Scaffolding
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚手架
- en: 'While implementing any project from scratch, you are free to design the scaffolding
    of your project. We are going to follow the scaffolding shown in the following
    screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在从头开始实现任何项目时，您可以自由设计项目的脚手架。我们将遵循以下截图中显示的脚手架：
- en: '![](img/00037.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00037.jpeg)'
- en: 'Let''s look at each directory and its uses in detail:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看每个目录及其用途：
- en: '`.env`: This is our `virtualenv` directory, which has been created by the `virtualenv`
    command.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.env`：这是我们的`virtualenv`目录，是通过`virtualenv`命令创建的。'
- en: '`auth`: We are going to create a standalone generic authentication module using
    the `Flask-Login` and `Flask-SqlAlchemy` extensions.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth`：我们将使用`Flask-Login`和`Flask-SqlAlchemy`扩展创建一个独立的通用认证模块。'
- en: '`config`: Here, we are going to create some configuration and generic database
    models, which may be needed by other modules.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`：在这里，我们将创建一些配置和通用数据库模型，其他模块可能需要这些模型。'
- en: '`static`: It''s Flask standard practice to put the static content under the
    `static` directory. Hence, we will be using this directory for all required static
    content.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static`：将静态内容放在`static`目录下是Flask的标准做法。因此，我们将使用这个目录来存放所有需要的静态内容。'
- en: '`templates`: Flask has built-in support for the Jinja2 template engine and
    follows the standard layout for the template files based on the modules'' names.
    We will see a detailed description of this later, when we actually utilize the
    templates.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templates`：Flask内置支持Jinja2模板引擎，并遵循基于模块名称的模板文件的标准布局。我们将在实际使用模板时详细描述这一点。'
- en: '`todo`: This is a standalone Flask module or package which has the basic to-do
    functionality.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`todo`：这是一个独立的Flask模块或包，具有基本的待办功能。'
- en: '`__init__.py`: This is Python''s standard file that is required under a directory
    to build a Python package. We are going to write code here to configure our application.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__.py`：这是Python的标准文件，必须在目录下构建Python包。我们将在这里编写代码来配置我们的应用程序。'
- en: '`migrations`: This directory is autogenerated by `Flask-Migrate`. In a future
    section, we will see how `Flask-Migrate` works.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`migrations`：这个目录是由`Flask-Migrate`自动生成的。在后面的部分中，我们将看到`Flask-Migrate`的工作原理。'
- en: '`.gitignore`: This contains a list of files and directories that should be
    ignored by Git versioning.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.gitignore`：这个文件包含了应该被Git版本控制忽略的文件和目录列表。'
- en: '`LICENSE`: I have created a Git repository using GitHub and included an MIT
    license for our `flask_todo` repository.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LICENSE`：我使用GitHub创建了一个Git存储库，并为我们的`flask_todo`存储库包含了MIT许可证。'
- en: '`README.md`: This file is used to describe information about the repository
    on GitHub.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README.md`：这个文件用于在GitHub上描述有关存储库的信息。'
- en: '`requirements.txt`: This is the file where we listed all the required packages
    mentioned in the preceding section.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requirements.txt`：这是我们列出了在前面部分提到的所有所需包的文件。'
- en: '`run.py`: Here, we are going to create the final instance of our Flask application.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run.py`：在这里，我们将创建我们的Flask应用的最终实例。'
- en: '`zappa_settings.json`: This file gets generated by Zappa and has Zappa-related
    configurations.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zappa_settings.json`：这个文件是由Zappa生成的，包含了与Zappa相关的配置。'
- en: We will look at a detailed explanation of the code in the upcoming sections.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的部分详细解释代码。
- en: Configuration
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: While implementing any project, we may be required to have some configurations
    that are specific to different environments, such as toggling the debug mode in
    the development environment and monitoring in the production environment.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施任何项目时，我们可能需要一些特定于不同环境的配置，例如在开发环境中切换调试模式和在生产环境中监控。
- en: Flask has a flexible way of overcoming the configuration handling mechanism.
    Flask provides a `config` object on its instance. This `config` object is built
    by extending the Python `dictionary` object but with some additional features
    such as loading the configuration from a file, object, and default built-in configurations.
    You can look at a detailed description of the `config` mechanism at [http://flask.pocoo.org/docs/0.12/config/](http://flask.pocoo.org/docs/0.12/config/).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Flask有一种灵活的方式来克服配置处理机制。Flask在其实例上提供了一个`config`对象。这个`config`对象是通过扩展Python的`dictionary`对象构建的，但具有一些额外的功能，如从文件、对象和默认内置配置加载配置。您可以在[http://flask.pocoo.org/docs/0.12/config/](http://flask.pocoo.org/docs/0.12/config/)上查看`config`机制的详细描述。
- en: 'In order to maintain the configuration based on environments, we are going
    to create a file called `config/config.py` with the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了根据环境维护配置，我们将创建一个名为`config/config.py`的文件，其中包含以下代码：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we created a `Config` object as a base class that has some generic configuration
    and `Flask-SqlAlchemy` configurations. Then, we extended the base `Config` class
    with environment-specific classes. Finally, we created a mapping object, which
    we will use from the aforementioned keys.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`Config`对象作为一个具有一些通用配置和`Flask-SqlAlchemy`配置的基类。然后，我们用特定于环境的类扩展了基本的`Config`类。最后，我们创建了一个映射对象，我们将从上述键中使用。
- en: Base model
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本模型
- en: SQLAlchemy is most famous for its **object-relational mapper** (**ORM**), an
    optional component that provides the data mapper pattern, where classes can be
    mapped to the database in open-ended, multiple ways, allowing the object model
    and database schema to develop in a cleanly decoupled way from the beginning.
    We are using the `Flask-SQLAlchemy` extension here, which extends the support
    of SQLAlchemy. `Flask-SQLAlchemy` enhances the features that may need to be integrated
    with the Flask application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy最著名的是其**对象关系映射器**（**ORM**），这是一个可选组件，提供了数据映射器模式，其中类可以以多种方式映射到数据库中，允许对象模型和数据库模式从一开始就以一种清晰的解耦方式发展。我们在这里使用`Flask-SQLAlchemy`扩展，它扩展了对SQLAlchemy的支持。`Flask-SQLAlchemy`增强了可能需要与Flask应用集成的功能。
- en: We are going to combine the generic SQL operations which are required to interact
    by using `Flask-SQLAlchemy`. Hence, we are going to create a base model class
    and will use this class for other modules' model classes. That's the reason we
    are putting it under the `config` directory. Here is the `models.py` file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将组合使用`Flask-SQLAlchemy`所需的通用SQL操作。因此，我们将创建一个基本模型类，并将使用这个类来创建其他模块的模型类。这就是我们将其放在`config`目录下的原因。这是`models.py`文件。
- en: 'File—`config/models.py`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 文件—`config/models.py`：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see here that we group the database operations that are required by
    all models. The `db` instance was created in the `app/__init__.py` file using
    the `Flask-SQLAlchemy` extension.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到，我们将所有模型都需要的数据库操作分组在一起。`db`实例是在`app/__init__.py`文件中使用`Flask-SQLAlchemy`扩展创建的。
- en: Here, we have implemented the `save` and `delete` methods. `db.Model` defines
    a generic pattern to create a model class that represents the database table.
    In order to save and delete, we need to follow some predefined operations such
    as `db.session.add()`, `db.session.delete()`, and `db.session.commit()`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实现了`save`和`delete`方法。`db.Model`定义了一个通用模式，用于创建代表数据库表的模型类。为了保存和删除，我们需要遇到一些预定义的操作，如`db.session.add()`、`db.session.delete()`和`db.session.commit()`。
- en: So, we grouped the generic operations under the `save` and `delete` methods.
    These methods will be called from a model class that will inherit them. We will
    look at this later when we create a model class by extending `BaseModel`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将通用操作分组在`save`和`delete`方法下。这些方法将从一个模型类中调用，该模型类将继承它们。我们将在稍后创建一个模型类时再详细介绍。
- en: Authentication
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证
- en: In order to develop an authentication module, we are going to use the `Flask-Login`
    extension. The `Flask-Login` extension provides a user session management mechanism.
    It handles the common tasks for managing user sessions such as logging in, logging
    out, and remembering the user.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发一个认证模块，我们将使用`Flask-Login`扩展。`Flask-Login`扩展提供了用户会话管理机制。它处理管理用户会话的常见任务，如登录、注销和记住用户。
- en: 'To integrate `Flask-Login`, you need to create the instance and define some
    default parameters, as described in the following code snippet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要集成`Flask-Login`，您需要创建实例并定义一些默认参数，如下面的代码片段中所述：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are going to create an authentication module as an `auth` package. An `auth`
    package will have basic scaffolding, as shown here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个认证模块作为一个`auth`包。`auth`包将具有基本的脚手架，如下所示：
- en: '![](img/00038.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.jpeg)'
- en: Blueprint
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图
- en: Before diving into a detailed description of each file, let's have a look at
    the instantiation Flask mechanism. As you already know, we are creating a submodule
    as an independent module under the `root` module. Flask introduces the concept
    of blueprint for making the submodule components under a common pattern.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入描述每个文件之前，让我们看一下Flask实例化机制。正如你已经知道的，我们正在创建一个独立模块作为`root`模块下的一个子模块。Flask引入了蓝图的概念，用于将子模块组件放在一个共同的模式下。
- en: The Flask blueprint instance is very similar to a Flask instance, but it's not
    an application object. Instead, it has the ability to construct and extend the
    parent application. With the help of blueprint, you can design a modular application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Flask蓝图实例非常类似于Flask实例，但它不是一个应用程序对象。相反，它具有构建和扩展父应用程序的能力。借助蓝图，您可以设计一个模块化的应用程序。
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, it has very similar characteristics to the `Flask` class and
    follows a similar pattern. Now, we will be using the `auth` instance of the `blueprint`
    in views to register routes. To execute the application, we need to bind the `blueprint`
    object with the Flask application instance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它具有与`Flask`类非常相似的特征，并遵循类似的模式。现在，我们将在视图中使用`blueprint`的`auth`实例来注册路由。要执行应用程序，我们需要将`blueprint`对象与Flask应用程序实例绑定。
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With the help of the `register_blueprint` method, we are registering the `auth`
    module blueprint and we can add the URL prefix as well. We will have the complete
    description of this file after we look at the `todo` module explanation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 借助`register_blueprint`方法，我们正在注册`auth`模块蓝图，我们还可以添加URL前缀。在查看`todo`模块解释之后，我们将对此文件进行完整描述。
- en: Models
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: Let's start by creating the `User` model with basic functionality. The following
    is a code snippet of the user model.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建具有基本功能的`User`模型开始。以下是用户模型的代码片段。
- en: 'File—`auth/models.py`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 文件—`auth/models.py`：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, we have created the `User` model, but how does it relate or map with the
    `Flask-Login` extension? The answer to this is the `load_user` method, which is
    wrapped by the `login_manager.user_loader` decorator. Flask provides this method
    to load the user into the session. This method is called with the `user_id` that's
    present in the session.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了`User`模型，但它如何与`Flask-Login`扩展相关联或映射呢？答案是`load_user`方法，该方法由`login_manager.user_loader`装饰器包装。Flask提供了这个方法来将用户加载到会话中。该方法使用会话中存在的`user_id`进行调用。
- en: We can persist the user's data into the database with the help of the `User`
    model. As a web application, user data needs to enter through a user interface
    such as HTML. As per our requirements, we need two types of HTML forms for login
    and sign up functionality.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`User`模型将用户数据持久化到数据库中。作为一个Web应用程序，用户数据需要通过用户界面（如HTML）输入。根据我们的需求，我们需要两种类型的HTML表单，用于登录和注册功能。
- en: Let's move on to the next section and learn about rendering HTML forms through
    Flask.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一节，学习通过Flask渲染HTML表单。
- en: Forms
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单
- en: '`Flask-WTF` extensions provide the ability to develop forms in Flask and render
    them through Jinja2 templates. `Flask-WTF` extends the `WTForms` library, which
    has standard patterns to design a form.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flask-WTF`扩展提供了在Flask中开发表单并通过Jinja2模板渲染它们的能力。`Flask-WTF`扩展了`WTForms`库，该库具有设计表单的标准模式。'
- en: We need two forms for this, such as `SignupForm` and `LoginForm`. The following
    is the code for creating forms classes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个表单，如`SignupForm`和`LoginForm`。以下是创建表单类的代码。
- en: 'File—`auth/forms.py`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 文件—`auth/forms.py`：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we create the forms with some validations. Now, we are going to use these
    forms in the views section, where we are going to render the templates along with
    the forms context.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一些带有验证的表单。现在，我们将在视图部分中使用这些表单，在那里我们将呈现模板以及表单上下文。
- en: Views
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: Flask implemented the views in a very flexible way, where you can define the
    routes along with them. Flask's generic views implementation is inspired by Django's
    generic views. We will look at a detailed description of method views in a further
    section, but here, we are going to use simple views.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Flask以一种非常灵活的方式实现了视图，您可以在其中定义路由。Flask的通用视图实现受到Django的通用视图的启发。我们将在后面的部分详细描述方法视图，但在这里，我们将使用简单的视图。
- en: The following is the views snippet.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是视图片段。
- en: 'File—`auth/views.py`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 文件—`auth/views.py`：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we created the `/login`, `/signup`, and `/logout` routes, which we invoke
    based on HTTP requests. We are rendering an empty form instance on the HTTP `GET`
    request and processing the data on the `POST` request by using the `Flask-WTF`
    method and the `validate_on_submit()` method. While rendering the template, we
    are passing the form instance and redirect based on required actions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了`/login`、`/signup`和`/logout`路由，我们根据HTTP请求调用它们。我们在HTTP `GET`请求上呈现一个空的表单实例，并在`POST`请求上通过使用`Flask-WTF`方法和`validate_on_submit()`方法处理数据。在呈现模板时，我们传递表单实例并根据需要的操作进行重定向。
- en: Let's have a look at the templates mechanism in the next section.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看一下模板机制。
- en: Templates
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: Flask has built-in support for Jinja2 templating. Jinja2 templating has a standard
    defined pattern for rendering the HTML. We can place dynamic content by passing
    the context argument. Jinja2 gives an ability to render HTML with some expressions
    and conditions, extending and including template features.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Flask内置了对Jinja2模板的支持。Jinja2模板具有用于呈现HTML的标准定义模式。我们可以通过传递上下文参数来放置动态内容。Jinja2提供了使用一些表达式和条件、扩展和包含模板功能来呈现HTML的能力。
- en: 'Flask follows a standard templating scaffolding structure to lay out all template
    files. The following is the scaffolding we followed by creating a `templates`
    directory under the project''s root directory and then creating subdirectories
    based on other module names:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Flask遵循标准的模板搭建结构来布置所有模板文件。以下是我们遵循的搭建结构，通过在项目根目录下创建一个`templates`目录，然后根据其他模块名称创建子目录：
- en: '![](img/00039.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00039.jpeg)'
- en: Here, we have created templates as per the module and put the generic templates
    under the root directory.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据模块创建了模板，并将通用模板放在根目录下。
- en: 'Similarly, we have maintained the static file''s scaffolding:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们保持了静态文件的脚手架：
- en: '![](img/00040.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00040.jpeg)'
- en: We kept the static libraries and modules-related files. With the help of the
    `url_for` method, we can get the relative path of any static files and routes.
    Hence, in the following template, we included all static files using a `url_for`
    method, such as `<link rel="stylesheet" href="{{ url_for('static', filename='bootstrap/css/bootstrap.min.css')}}">`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保留了静态库和模块相关文件。借助`url_for`方法，我们可以获取任何静态文件和路由的相对路径。因此，在以下模板中，我们使用`url_for`方法包含了所有静态文件，例如`<link
    rel="stylesheet" href="{{ url_for('static', filename='bootstrap/css/bootstrap.min.css')}}">`。
- en: In the same way, we are going to include all static files in the base template.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将在基本模板中包含所有静态文件。
- en: 'File—`templates/base.html`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 文件—`templates/base.html`：
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We defined all generic HTML that is required on all other templates. We also
    created a basic bootstrap navbar and kept this in `navbar.html`, which is included
    in the `base.html` template by `{% include 'navbar.html' %}`. As you can see,
    Jinja2 templating makes it super easy to maintain the templates and provide a
    standard pattern.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了所有其他模板所需的通用HTML。我们还创建了一个基本的bootstrap导航栏，并将其保存在`navbar.html`中，通过`{% include
    'navbar.html' %}`包含在`base.html`模板中。正如你所看到的，Jinja2模板使得维护模板和提供标准模式变得非常容易。
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'File—`templates/navbar.html`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 文件—`templates/navbar.html`：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: While designing `navbar.html`**,** we added some conditional statements to display
    the logged-in user's information and logout options when the user is logged in.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计`navbar.html`时，我们添加了一些条件语句，以在用户登录时显示已登录用户的信息和注销选项。
- en: Let's move on to the sign up and login page. The following is the code snippet
    for the sign up page.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行注册和登录页面。以下是注册页面的代码片段。
- en: 'File—`templates/auth/signup.html`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 文件—`templates/auth/signup.html`：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is the output of the Sign Up page:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是注册页面的输出：
- en: '![](img/00041.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00041.jpeg)'
- en: On the HTTP `GET` request on the `auth.signup` view, this will return an empty
    form and render it through the `signup.html` template. We also added code to receive
    the sign up data on the HTTP `POST` request in the sign up view. We persist the
    user data on the sign up process using the `User` model.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在`auth.signup`视图的HTTP `GET`请求中，这将返回一个空表单，并通过`signup.html`模板进行渲染。我们还添加了代码来在注册视图中接收HTTP
    `POST`请求上的注册数据。我们使用`User`模型在注册过程中持久化用户数据。
- en: Here is the login template.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是登录模板。
- en: 'File—`templates/auth/login.html`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 文件—`templates/auth/login.html`：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, the user can proceed and log in to the system, For login, we have created
    the login form and rendered it through the `auth.login` view. The following is
    a screenshot of the Login page:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用户可以继续登录系统。对于登录，我们创建了登录表单，并通过`auth.login`视图进行渲染。以下是登录页面的截图：
- en: '![](img/00042.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00042.jpeg)'
- en: On the HTTP `POST` request, we are processing the user login mechanism using
    the `Flask-Login` extension, which provides a function called `login_user` and
    performs the login process. It creates a session and adds `user_id` into the session
    to remember the user for the further request until we remove the user from the
    session or perform the logout with the `logout_user` method, as mentioned in the
    `auth.logout` view.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP `POST`请求中，我们使用`Flask-Login`扩展来处理用户登录机制，它提供了一个名为`login_user`的函数并执行登录过程。它创建一个会话并将`user_id`添加到会话中，以便在进一步的请求中记住用户，直到我们从会话中移除用户或使用`auth.logout`视图中提到的`logout_user`方法执行注销。
- en: The authentication process completes here, as the user login executes successfully
    and redirects the user to another page or template. Now, it's time to move on
    to the `todo` module.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 认证过程在这里完成，当用户登录成功并重定向到另一个页面或模板时。现在，是时候继续进行`todo`模块了。
- en: Todo
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Todo
- en: The Todo program is considered to be a straightforward and simple application,
    and it is widely used to explain any language or framework after hello world!.
    We follow the same scaffolding structure for the `todo` module as well.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Todo程序被认为是一个简单直接的应用程序，并且在hello world!之后广泛用于解释任何语言或框架。我们也为`todo`模块遵循相同的脚手架结构。
- en: 'The following is a screenshot of the scaffolding for the `todo` module:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`todo`模块的脚手架的截图：
- en: '![](img/00043.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00043.jpeg)'
- en: Let's see the detailed description for each file in the `todo` module.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`todo`模块中每个文件的详细描述。
- en: Blueprint
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图
- en: Flask introduces the concept of blueprint for developing application components
    and command patterns in an application or across multiple applications. It helps
    to comprehend large-scale applications by centralizing the root Flask application
    object. Blueprint acts as a separate Flask application without creating an actual
    Flask application object, and is able to instantiate application objects, initialize
    several extensions, and register a collection. It also provides template filters,
    static files, templates, and other utilities.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Flask引入了蓝图的概念，用于开发应用程序组件和命令模式，可以在应用程序或多个应用程序中使用。它有助于通过将根Flask应用程序对象集中化来理解大型应用程序。蓝图充当一个独立的Flask应用程序，而不创建实际的Flask应用程序对象，并且能够实例化应用程序对象，初始化多个扩展，并注册集合。它还提供模板过滤器、静态文件、模板和其他实用程序。
- en: As explained in the `auth` module, we will also create the `Blueprint` instance
    for the Todo application. This will be configured in the `app.__init__.py` file,
    which is where we created the Flask application instance.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如`auth`模块中所述，我们还将为Todo应用程序创建`Blueprint`实例。这将在`app.__init__.py`文件中配置，这是我们创建Flask应用程序实例的地方。
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'File—`todo/__init__.py`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 文件—`todo/__init__.py`：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once we have created the `blueprint` object of the `todo` module, we can use
    it to add routes in views and register the blueprint with the Flask application
    instance.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了`todo`模块的`blueprint`对象，我们就可以使用它在视图中添加路由，并将blueprint注册到Flask应用程序实例中。
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Model
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: We are going to use `Flask-SQLAlchemy` to create a todo model. It will have
    a relationship with the `User` model with a backward reference, so that we can
    query the `todo` data that's related to the `User` model.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Flask-SQLAlchemy`来创建一个待办事项模型。它将与`User`模型建立关系，并带有一个反向引用，这样我们就可以查询与`User`模型相关的`todo`数据。
- en: The following is the code snippet for the todo model.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是待办事项模型的代码片段。
- en: 'File—`todo/models.py`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 文件-`todo/models.py`：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we created the todo model with basic functionality and validation. Now,
    we will use this model to persist the `todo` data. However, we also need to have
    a UI for users to enter the `todo` data and perform some actions.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用基本功能和验证创建了待办事项模型。现在，我们将使用这个模型来持久化`todo`数据。然而，我们还需要为用户提供一个UI来输入`todo`数据并执行一些操作。
- en: Forms
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单
- en: We will have a simple todo form in which we have a textbox with a Submit button.
    It should also contain the list view to display the todo data.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将拥有一个简单的待办事项表单，其中包含一个带有提交按钮的文本框。它还应该包含列表视图来显示待办事项数据。
- en: The following is a code snippet of the Todo form.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是待办事项表单的代码片段。
- en: 'File—`todo/forms.py`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 文件-`todo/forms.py`：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, our Todo form is straightforward with some basic validation.
    It's time to use this form in views to render them into HTML template.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的待办事项表单非常简单，带有一些基本的验证。现在是时候在视图中使用这个表单来将它们渲染成HTML模板了。
- en: Views
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: We created the instance of a blueprint for todo, and we will use this instance
    to create the routes in views. The following is the code snippet for views.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个待办事项蓝图的实例，并将使用这个实例在视图中创建路由。以下是视图的代码片段。
- en: 'File—`todo/views.py`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 文件-`todo/views.py`：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We defined three routes here. We have already used `todos` as the prefix while
    registering the todo blueprint on the Flask application object. Keeping that in
    mind, we have decided to use the route URLs.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义了三个路由。在注册待办事项蓝图到Flask应用对象时，我们已经使用了`todos`作为前缀。记住这一点，我们决定使用这些路由URL。
- en: To persist the todo data, we need to perform four types of action, which are—create
    a todo item, list todo items, update any specific item, and delete any specific
    todo item. These actions are nothing but a standard form of **CRUD** (**Create**,
    **Retrieve**, **Update**, **Delete**) operations.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了持久化待办事项数据，我们需要执行四种类型的操作，即—创建一个待办事项，列出待办事项，更新任何特定项目，和删除任何特定的待办事项。这些操作无非是标准的**CRUD**（**创建**，**检索**，**更新**，**删除**）操作。
- en: CREATE
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建
- en: For creating an action, we decided to have the URL as `/`, but with the prefix,
    it would become `todos/`. On the HTTP `POST` request, we expect the todo data
    from the user, and based on the submitted data, we will create the todo data using
    the todo model, for example, `Todo(form.description.data, creator=current_user.email).save()`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个操作，我们决定将URL设置为`/`，但是加上前缀后，它将变成`todos/`。在HTTP `POST`请求中，我们期望从用户那里得到待办事项数据，根据提交的数据，我们将使用待办事项模型创建待办事项数据，例如`Todo(form.description.data,
    creator=current_user.email).save()`。
- en: RETRIEVE
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: UPDATE
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新
- en: To update the todo data, we would use the HTTP `PATCH` request for the route
    `todos/<todo_id>`. But, this time, we don't have any form and we are required
    to pass the data, hence we are using jQuery to make an Ajax query for the `PATCH`
    request.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新待办事项数据，我们将使用HTTP `PATCH`请求来访问路由`todos/<todo_id>`。但是，这次我们没有任何表单，需要传递数据，因此我们使用jQuery来进行`PATCH`请求的Ajax查询。
- en: We defined some attributes and methods to mark the todo data as finished, so
    based on the update data, we would use these methods to update the todo record.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一些属性和方法来标记待办事项数据是否完成，因此根据更新的数据，我们将使用这些方法来更新待办事项记录。
- en: DELETE
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除
- en: Similarly to deleting the todo record from the database, we need to use the
    todo model's query methods, such as `Todo.query.filter_by(id=int(todo_id)).delete()`.
    As you can see, the routing views are straightforward. Now, let's have a look
    at templates.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于从数据库中删除待办事项记录，我们需要使用待办事项模型的查询方法，比如`Todo.query.filter_by(id=int(todo_id)).delete()`。正如你所看到的，路由视图非常简单。现在，让我们来看一下模板。
- en: Templates
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: A lot of work needs to be done to accomplish the todo workflow. We defined the
    `templates/todo/list.html` template to display the todo form and a list of todo
    records. In a previous section, we described how we rendered and passed the context
    data.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 需要做很多工作来完成待办事项的工作流。我们定义了`templates/todo/list.html`模板来显示待办事项表单和待办事项记录列表。在前面的部分中，我们描述了如何渲染和传递上下文数据。
- en: The following is the code snippet for the todo list template.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是待办事项列表模板的代码片段。
- en: 'File—`templates/todo/list.html`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 文件-`templates/todo/list.html`：
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We used the context data to display the todo form and list of records. There
    are some operations that we need to write jQuery code for, such as updating the
    todo based on the checkbox action, and removing the todo based on the delete button
    action.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用上下文数据来显示待办事项表单和记录列表。有一些操作我们需要编写jQuery代码，比如根据复选框操作更新待办事项，以及根据删除按钮操作删除待办事项。
- en: The following is the jQuery code snippet.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是jQuery代码片段。
- en: 'File—`static/todo/list.js`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 文件-`static/todo/list.js`：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'While making the Ajax request, we also added support for CSRF. Ajax requests
    are simple and straightforward as these are requests that are being served through
    the previously mentioned todo routes. The following is a screenshot of the todo
    list page:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行Ajax请求时，我们还添加了对CSRF的支持。Ajax请求非常简单直接，因为这些请求是通过前面提到的todo路由来服务的。以下是待办事项列表页面的截图：
- en: '![](img/00044.jpeg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00044.jpeg)'
- en: Now, we are done with the `todo` module, and it's time to configure the todo
    blueprint with a Flask application object.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了`todo`模块，是时候用Flask应用对象配置todo蓝图了。
- en: FLASK_APP
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FLASK_APP
- en: In any Flask project, we create the Flask application object and refer to the
    file path with a value to the `FLASK_APP` argument or environment variable. In
    our case, we created a modular application that has separate modules defined for
    specific operations, but now we need to combine all of these modules in one place.
    We have already seen the `blueprint` objects and their integration. Here, we will
    look at the actual process of combining the blueprint and other required extensions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何Flask项目中，我们创建Flask应用程序对象，并使用`FLASK_APP`参数或环境变量的值引用文件路径。在我们的情况下，我们创建了一个模块化应用程序，为特定操作定义了单独的模块，但现在我们需要将所有这些模块合并到一个地方。我们已经看到了`blueprint`对象及其集成。在这里，我们将看到将`blueprint`和其他所需扩展组合的实际过程。
- en: The following is the code snippet for the Flask application object.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Flask应用程序对象的代码片段。
- en: 'File—`app/__init__.py`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 文件-`app/__init__.py`：
- en: '[PRE32]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we are configuring the extensions and blueprints, but under a method called
    `create_app`. This method needs an argument to set up the environment-specific
    configuration, hence it's really good to have this function and get the Flask
    application instance for a specific configuration.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在配置扩展和蓝图，但是在一个名为`create_app`的方法下。这个方法需要一个参数来设置特定环境的配置，因此最好有这个函数，并为特定配置获取Flask应用程序实例。
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'File—`flask_todo/run.py`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 文件-`flask_todo/run.py`：
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we used the `dev` environment configuration. You can use this file as
    your `FLASK_APP` parameter, for example, `FLASK_APP=run.py flask run`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`dev`环境配置。您可以将此文件用作您的`FLASK_APP`参数，例如`FLASK_APP=run.py flask run`。
- en: We are done with the todo app development, so now it's time to proceed with
    deployment using Zappa.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了todo应用程序的开发，现在是时候使用Zappa进行部署了。
- en: Deployment
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: We are going to initiate the deployment using Zappa. To configure Zappa, you
    need to have Zappa installed and configured with your AWS credentials by using
    AWS CLI. Once we have installed Zappa and dealt with the AWS CLI configuration,
    we can move ahead and deploy the Todo application.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Zappa进行部署。要配置Zappa，您需要安装Zappa并使用AWS CLI配置您的AWS凭据。一旦我们安装了Zappa并处理了AWS CLI配置，我们就可以继续部署Todo应用程序。
- en: 'The following is a screenshot of the `zappa init` command process:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`zappa init`命令过程的截图：
- en: '![](img/00045.jpeg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00045.jpeg)'
- en: When we run the `zappa init` command, Zappa automatically identifies the framework
    type and suggests the required parameters. In our case, we kept the `app_function`
    name as `run.app` because we are initiating the `flask app` object through the
    `create_app` method in `run.py`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`zappa init`命令时，Zappa会自动识别框架类型并建议所需的参数。在我们的情况下，我们将`app_function`名称保持为`run.app`，因为我们是通过`run.py`中的`create_app`方法初始化`flask
    app`对象。
- en: The `zappa init` command creates the `zappa_settings.json` file, which has all
    the configured parameters. You are free to modify it as per your needs.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`zappa init`命令创建了`zappa_settings.json`文件，其中包含了所有配置的参数。您可以根据需要自由修改它。'
- en: Now, it's time to execute the deployment process using the `zappa deploy <stage_name>`
    command. Initially, we would use the `zappa deploy` command. Once our app has
    been deployed, we can't use the **`zappa deploy`** command. Instead, we need to
    use the `zappa update <stage_name>` command.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候使用`zappa deploy <stage_name>`命令执行部署过程了。最初，我们将使用`zappa deploy`命令。一旦我们的应用程序部署完成，我们就不能再使用**`zappa
    deploy`**命令了。相反，我们需要使用`zappa update <stage_name>`命令。
- en: 'The following is the code for the `zappa deploy dev` command:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`zappa deploy dev`命令的代码：
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We are done with deployment and are able to access the Todo application on a
    generated URL, as shown in the following screenshot.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了部署，并且能够访问生成的URL上的Todo应用程序，如下截图所示。
- en: 'Here is the output after visiting the URL ([https://m974nz8zld.execute-api.ap-south-1.amazonaws.com/dev/auth/signup](https://m974nz8zld.execute-api.ap-south-1.amazonaws.com/dev/auth/signup)[)](https://p2wdbhjwd6.execute-api.ap-south-1.amazonaws.com/dev/auth/signup):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 访问URL后的输出如下（[https://m974nz8zld.execute-api.ap-south-1.amazonaws.com/dev/auth/signup](https://m974nz8zld.execute-api.ap-south-1.amazonaws.com/dev/auth/signup)[)](https://p2wdbhjwd6.execute-api.ap-south-1.amazonaws.com/dev/auth/signup)：
- en: '![](img/00046.jpeg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00046.jpeg)'
- en: I am going to keep the `flask_todo` Lambda function live so that you can try
    it anytime. I have created a GitHub repository ([https://github.com/PacktPublishing/Building-Serverless-Python-Web-Services-with-Zappa/tree/master/chapter_3](https://github.com/PacktPublishing/Building-Serverless-Python-Web-Services-with-Zappa/tree/master/chapter_3))
    and pushed all of the code base to it for future reference.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我将保持`flask_todo` Lambda函数处于活动状态，以便您随时尝试。我已经创建了一个GitHub存储库（[https://github.com/PacktPublishing/Building-Serverless-Python-Web-Services-with-Zappa/tree/master/chapter_3](https://github.com/PacktPublishing/Building-Serverless-Python-Web-Services-with-Zappa/tree/master/chapter_3)），并将所有代码库推送到其中以供将来参考。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the workflow of creating a Flask-based application
    and deploying it over a serverless environment using Zappa. With the help of Zappa,
    we moved the application to AWS Lambda and performed operations to maintain the
    deployment. While deploying the application, we don't need to configure the traditional
    server software; instead, we just use a JSON file to configure the deployment
    with multiple environments.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用Zappa在服务器环境上创建基于Flask的应用程序并部署的工作流程。借助Zappa，我们将应用程序移动到AWS Lambda并执行操作以维护部署。在部署应用程序时，我们不需要配置传统的服务器软件；相反，我们只需使用JSON文件来配置具有多个环境的部署。
- en: In the next chapter, we are going to see REST API's implementation.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到REST API的实现。
- en: Questions
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is Amazon API Gateway?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Amazon API Gateway是什么？
- en: What is the use of `function_name` in `zappa_settings.json`?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`zappa_settings.json`中的`function_name`的用途是什么？'
