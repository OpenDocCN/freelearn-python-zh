- en: '*Chapter 5*: Django Forms'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：Django表单'
- en: In programming, a **form** is an object that contains input fields, drop-down
    boxes, radio buttons, checkboxes, and a submit button. The duty of the form is
    to capture information from the user; what is done after that can be anything
    including storing that information in a database, sending an email, or generating
    a reporting document using that data. In this chapter, we discuss as much as we
    can about how forms are used in Django. Form objects are a very complex subject
    to discuss; we only have enough room in this chapter to cover the essentials and
    some advanced topics. Some of the topics in this chapter can be combined with
    other topics covered later in [*Chapter 8*](B17243_08_ePub.xhtml#_idTextAnchor239),
    *Working with the Django REST Framework*, to create form objects on SPA-like pages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，**表单**是一个包含输入字段、下拉框、单选按钮、复选框和提交按钮的对象。表单的职责是从用户那里捕获信息；之后所做的一切都可以是任何事情，包括将信息存储在数据库中、发送电子邮件或使用该数据生成报告文档。在本章中，我们将尽可能多地讨论在Django中如何使用表单。表单对象是一个非常复杂的话题，我们在这章中只有足够的空间来涵盖基本内容和一些高级主题。本章中的一些主题可以与其他在[*第8章*](B17243_08_ePub.xhtml#_idTextAnchor239)中涵盖的主题结合起来，即使用Django
    REST框架工作，以在SPA-like页面上创建表单对象。
- en: In our first form, we will create a class called `ContactForm` and build an
    email field in three different ways. Later, when we render that form in the browser,
    we will observe how its behavior changes using those three different mechanisms.
    We want to watch how validation is performed on each email field and watch how
    the behavior differs among them. This will give us a better understanding of which
    mechanism is needed for the intended behavior that we wish to achieve as the outcome.
    We will even look into writing custom field classes and learn how they can benefit
    us in the long run.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个表单中，我们将创建一个名为`ContactForm`的类，并以三种不同的方式构建一个电子邮件字段。稍后，当我们在浏览器中渲染该表单时，我们将观察其行为如何通过这三种不同的机制发生变化。我们想观察每个电子邮件字段上的验证是如何进行的，以及它们之间的行为差异。这将使我们更好地理解哪种机制是我们希望实现的目标行为所需的。我们甚至会探讨编写自定义字段类，并了解它们如何从长远来看对我们有益。
- en: Depending on your project's needs, validation of your form may require a lot
    of custom JavaScript in order to accomplish your goals. The focus of this book
    is not on JavaScript but rather on the concepts of Django. However, by the end
    of this chapter, we will have provided an example that demonstrates how JavaScript
    can be blended into your project when working with dynamic inline formsets on
    a form object. You can expand upon this to build your own custom JavaScript functions
    that suit your project's needs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您项目的需求，您表单的验证可能需要大量的自定义JavaScript才能实现您的目标。本书的重点不是JavaScript，而是Django的概念。然而，在本章结束时，我们将提供一个示例，演示如何在处理表单对象上的动态内联表单集时将JavaScript融合到您的项目中。您可以根据项目的需求扩展此示例，构建自己的自定义JavaScript函数。
- en: 'In this chapter, we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Types of forms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单类型
- en: Using form fields
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表单字段
- en: Cleaning forms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理表单
- en: Creating custom form fields
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义表单字段
- en: Working with form views
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与表单视图一起工作
- en: Rendering forms in templates
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板中渲染表单
- en: Linking models to a form
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模型链接到表单
- en: Adding inline formsets
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加内联表单集
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To work with the code in this chapter, the following tools will need to be
    installed on your local machine:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要在此章节中与代码一起工作，您需要在本地机器上安装以下工具：
- en: Python version 3.9 – used as the underlying programming language for the project
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python版本3.9 – 作为项目的底层编程语言使用
- en: Django version 4.0 – used as the backend framework of the project
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django版本4.0 – 作为项目的后端框架使用
- en: pip package manager – used to manage third-party Python/Django packages
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pip包管理器 – 用于管理第三方Python/Django包
- en: We will continue to work with the solution created in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037),
    *Project Configuration*. However, it is not necessary to use the Visual Studio
    IDE. The main project itself can be run using another IDE or run independently
    using a terminal or command-line window from within the project root folder. This
    is where the `manage.py` file resides. Whatever editor or IDE you are using, a
    virtual environment will also be needed to work with the Django project. Instructions
    for how to create a project and virtual environment can be found in [*Chapter
    2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*. You will
    need a database to store the data contained in your project. PostgreSQL was chosen
    for the examples in the previous chapter; however, any database type that you
    choose for your project can be used to work with the examples in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用在[*第二章*](B17243_02_ePub.xhtml#_idTextAnchor037)，“项目配置”中创建的解决方案。然而，并不需要使用Visual
    Studio IDE。主要项目本身可以使用其他IDE运行，或者从项目根目录中独立使用终端或命令行窗口运行。这就是`manage.py`文件所在的位置。无论你使用什么编辑器或IDE，都需要一个虚拟环境来与Django项目一起工作。如何创建项目和虚拟环境的说明可以在[*第二章*](B17243_02_ePub.xhtml#_idTextAnchor037)，“项目配置”中找到。你需要一个数据库来存储项目中的数据。在上一章的示例中选择了PostgreSQL；然而，你可以为你的项目选择任何数据库类型来与本章的示例一起工作。
- en: 'We will also be using data that is in the form of a Django fixture, provided
    in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models, Relations, and
    Inheritance*, in the subsection titled *Loading the Chapter_3 data fixture*. Make
    sure the `chapter_3` fixture is loaded into your database; if this has already
    been done, then you may skip the next command. If you have already created the
    tables found in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models,
    Relations, and Inheritance*, and have not loaded that fixture yet, then run the
    following command, after activating your virtual environment:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用以Django fixture形式提供的数据，这些数据在[*第三章*](B17243_03_ePub.xhtml#_idTextAnchor077)，“模型、关系和继承”中提供，在标题为*加载Chapter_3数据fixture*的小节中。确保将`chapter_3`
    fixture加载到你的数据库中；如果这已经完成，那么你可以跳过下一个命令。如果你已经创建了[*第三章*](B17243_03_ePub.xhtml#_idTextAnchor077)，“模型、关系和继承”中提到的表，并且尚未加载该fixture，那么在激活你的虚拟环境后，运行以下命令：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All of the code created in this chapter can be found in the GitHub repository
    for this book: [https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer](https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer).
    The bulk of the code depicted in this chapter can be found in the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_5/`
    directory.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章创建的所有代码都可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer](https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer)。本章中展示的大部分代码可以在`/becoming_a_django_entdev/becoming_a_django_entdev/chapter_5/`目录中找到。
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3xQQ2H3](https://bit.ly/3xQQ2H3).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看*代码的实际应用*：[https://bit.ly/3xQQ2H3](https://bit.ly/3xQQ2H3)。
- en: Preparing for this chapter
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为本章做准备
- en: Start by creating a new app in your project called `chapter_5` by following
    the steps discussed in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project
    Configuration*, in the subsection titled *Creating a Django app*. As discussed
    in that section, don't forget to change the value of the `name =` variable for
    your app class found in the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_5/apps.py`
    file to now point to the path where you installed your app. Be sure to also include
    this app in your `INSTALLED_APPS` variable found in the `settings.py` file. At
    the end of [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116), *URLs, Views,
    and Templates*, we set `DEBUG = False` as part of an exercise. Be sure to set
    this back to `DEBUG = True` for the remainder of this book.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在你的项目中创建一个名为`chapter_5`的新应用，按照[*第二章*](B17243_02_ePub.xhtml#_idTextAnchor037)，“项目配置”中讨论的步骤进行。正如该部分所讨论的，不要忘记将`/becoming_a_django_entdev/becoming_a_django_entdev/chapter_5/apps.py`文件中你的应用类的`name
    =`变量的值更改为指向你安装应用的位置。确保还将此应用包含在`settings.py`文件中的`INSTALLED_APPS`变量中。在[*第四章*](B17243_04_ePub.xhtml#_idTextAnchor116)，“URLs、视图和模板”的末尾，我们将`DEBUG
    = False`作为练习的一部分进行设置。确保将此设置回`DEBUG = True`以继续本书的剩余部分。
- en: 'In the main `urls.py` file of the site, add the following path, which points
    to the URL patterns of this chapter that we will be creating:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在网站的主要`urls.py`文件中，添加以下路径，该路径指向我们将要创建的本章的URL模式：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we've created the app for this chapter, let's begin using the Django
    admin site to manage the models created in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077),
    *Models, Relations, and Inheritance*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为这一章创建了应用程序，让我们开始使用 Django 管理站点来管理在 [*第 3 章*](B17243_03_ePub.xhtml#_idTextAnchor077)
    中创建的模型，*模型、关系和继承*。
- en: Types of forms
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单类型
- en: Django is designed to simplify a great deal of work involved when handling forms.
    It does this by providing ways to render your form object as HTML and process
    data on form submission. There are a lot of different ways to use and work with
    form objects but they all start with a form class. Django provides two different
    classes for us to use, `ModelForm` and `Form`. The differences between the two
    are that one links directly to the tables in a database and the other does not.
    The `ModelForm` class, the one that links to a database, will automatically create
    fields and perform field validation based on the field constraints set within
    that model class, from the database level.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Django 被设计用来简化处理表单时涉及的大量工作。它是通过提供将你的表单对象渲染为 HTML 和处理表单提交上的数据的方式来做到这一点的。有很多人使用和操作表单对象的不同方法，但它们都始于一个表单类。Django
    为我们提供了两个不同的类来使用，`ModelForm` 和 `Form`。这两个之间的区别是，一个直接链接到数据库中的表，而另一个则不。链接到数据库的 `ModelForm`
    类将自动创建字段并根据在该模型类中设置的字段约束进行字段验证，从数据库级别。
- en: Form classes also use a `Meta` subclass, as was used on a model class in [*Chapter
    3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models, Relations, and Inheritance*.
    There are other form classes that Django provides, such as `BaseForm` and `BaseModelForm`,
    which are used to write abstract base form classes, but these form classes are
    beyond the scope of this book. Other classes relate to inline formsets, which
    are basically forms within a form. By the end of this chapter, we will have inserted
    an inline formset onto the page when the form gets rendered and used JavaScript
    to add more of them when the user clicks a button.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 表单类也使用一个 `Meta` 子类，正如在 [*第 3 章*](B17243_03_ePub.xhtml#_idTextAnchor077) 中使用在模型类上一样，*模型、关系和继承*。Django
    还提供了其他表单类，例如 `BaseForm` 和 `BaseModelForm`，用于编写抽象基表单类，但这些表单类超出了本书的范围。其他类与内联表单集相关，这基本上是在表单内的表单。在本章结束时，当表单被渲染时，我们将在页面上插入一个内联表单集，并在用户点击按钮时使用
    JavaScript 添加更多。
- en: Let's discuss importing and using the `Form` and `ModelForm` classes when creating
    a form class first.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论在创建表单类时导入和使用 `Form` 和 `ModelForm` 类。
- en: Form class – Form
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单类 – 表单
- en: The `Form` class is used to create fields that don't link to a database. This
    is used when a form is sending an email or generating a PDF report, just to name
    a few examples.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Form` 类用于创建不链接到数据库的字段。这在表单发送电子邮件或生成 PDF 报告等情况下使用，仅举几个例子。'
- en: 'Follow these steps to create your `Form` class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建你的 `Form` 类：
- en: Create a file called `forms.py` in your `/becoming_a_django_entdev/chapter_5/`
    directory.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/becoming_a_django_entdev/chapter_5/` 目录中创建一个名为 `forms.py` 的文件。
- en: 'Inside this file, include the following code:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件中，包含以下代码：
- en: '[PRE11]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will discuss working with fields in a moment, but let's discuss importing
    the `ModelForm` class next.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论如何处理字段，但接下来让我们讨论如何导入 `ModelForm` 类。
- en: Form class – ModelForm
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单类 – ModelForm
- en: The `ModelForm` class is used when we want to create or modify data directly
    in a database. Each field is linked to a column of the table it represents. Additional
    fields can be created and used in ways that are not linked to your database. For
    instance, you could fire off an email that contains the data from an added field.
    This field could also be a comment, timestamp, or another type of hidden data
    field.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要直接在数据库中创建或修改数据时使用 `ModelForm` 类。每个字段都链接到它所代表的表的列。可以创建并使用不链接到你的数据库的额外字段。例如，你可以发送一个包含添加的字段数据的电子邮件。这个字段也可以是一个注释、时间戳或另一种类型的隐藏数据字段。
- en: 'To create your `ModelForm` class, inside your existing `/chapter_5/forms.py`
    file, include the following class:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建你的 `ModelForm` 类，在你的现有 `/chapter_5/forms.py` 文件中，包含以下类：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Later in this chapter, we will link this class to the `Vehicle` model, created
    in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models, Relations, and
    Inheritance*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将把这个类链接到在 [*第 3 章*](B17243_03_ePub.xhtml#_idTextAnchor077) 中创建的 `Vehicle`
    模型，*模型、关系和继承*。
- en: Next, let's remove these `pass` statements and begin working with field arguments.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们移除这些 `pass` 语句并开始处理字段参数。
- en: Using form fields
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表单字段
- en: Similar to the standard model field classes introduced in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077),
    *Models, Relations, and Inheritance*, Django also provides a number of form field
    classes that are available to use. The difference is that a model field class
    works with the columns of a database and a form field class is used only as an
    input field within an HTML `<form></form>` object in a template.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与在 [*第3章*](B17243_03_ePub.xhtml#_idTextAnchor077) “模型、关系和继承” 中介绍的常规模型字段类类似，Django
    也提供了一些可供使用的表单字段类。区别在于模型字段类与数据库的列一起工作，而表单字段类仅用于模板中 HTML `<form></form>` 对象内的输入字段。
- en: 'The following table can be used as a cheat sheet to reference what fields are
    available when writing your `Form` and/or `ModelForm` classes:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格可以用作速查表，以参考在编写 `Form` 和/或 `ModelForm` 类时可用哪些字段：
- en: '![](img/Table_.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_.jpg)'
- en: Form fields also accept a variety of different field arguments that customize
    the behavior of each field. In the next section, we will use some of the field
    types in the preceding list to write fields on our form classes, discussing the
    different arguments that can be used.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 表单字段也接受各种不同的字段参数，这些参数可以自定义每个字段的行为。在下一节中，我们将使用前面列表中的一些字段类型在我们的表单类中编写字段，并讨论可以使用的不同参数。
- en: 'For a complete breakdown of each of these field types, visit the official Django
    documentation on field classes and arguments, found here: [https://docs.djangoproject.com/en/4.0/ref/forms/fields/](https://docs.djangoproject.com/en/4.0/ref/forms/fields/).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解每个这些字段类型的完整说明，请访问官方 Django 文档中关于字段类和参数的说明，可在以下位置找到：[https://docs.djangoproject.com/en/4.0/ref/forms/fields/](https://docs.djangoproject.com/en/4.0/ref/forms/fields/)。
- en: Common field arguments
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见字段参数
- en: We will begin adding fields to a form class and introduce field arguments in
    this exercise. Field arguments are a way for us to set properties on a field.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本练习中开始向表单类添加字段，并介绍字段参数。字段参数是我们设置字段属性的一种方式。
- en: 'To create your field, in your `/chapter_5/forms.py` file, add the `import`
    statement highlighted in the following code block, and in the same `ContactForm`
    class, add a field called `full_name`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建你的字段，在你的 `/chapter_5/forms.py` 文件中，添加以下代码块中突出显示的 `import` 语句，并在相同的 `ContactForm`
    类中添加一个名为 `full_name` 的字段：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding example, we defined an HTML `<input type="text">` object using
    the `forms.CharField` field class. A `CharField` object's default widget is an
    input `type="text"` field. The `label` argument lets us define the text that would
    render as `<label for="my_field_id">My Form Field Label</label>` of this field.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用 `forms.CharField` 字段类定义了一个 HTML `<input type="text">` 对象。`CharField`
    对象的默认小部件是一个 `type="text"` 输入字段。`label` 参数让我们可以定义将作为此字段 `<label for="my_field_id">My
    Form Field Label</label>` 的文本。
- en: The `help_text` argument will render a `<span class="helptext">{{ your_help_text_message</span>`
    element, right after your input field in the **Document Object Model** (**DOM**).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`help_text` 参数将在 **文档对象模型** (**DOM**) 中的输入字段之后渲染一个 `<span class="helptext">{{
    your_help_text_message</span>` 元素。'
- en: Document Object Model
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 文档对象模型
- en: The DOM is an interface found in all browsers that presents HTML in a tree-like
    structure of nodes. The nodes represent objects in this tree, where the `<span>`
    or `<input>` nodes comprise a single object.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 是所有浏览器中找到的一个接口，它以节点树的形式呈现 HTML。这些节点代表树中的对象，其中 `<span>` 或 `<input>` 节点组成一个单一的对象。
- en: The `min_length` and `max_length` arguments are used among most field types;
    they define the minimum and maximum character count, respectively, allowed in
    the field. The `required` argument will define whether the field must contain
    a value in order to be valid. These will render as attributes of an `<input type="text"
    maxlength="300" minlength="2" required="" />` object.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`min_length` 和 `max_length` 参数在大多数字段类型中都会使用；它们分别定义了字段中允许的最小和最大字符数。`required`
    参数将定义字段是否必须包含一个值才能有效。这些将作为 `<input type="text" maxlength="300" minlength="2" required=""
    />` 对象的属性来渲染。'
- en: Next, let's discuss form validation a little bit more. In the next two subsections,
    we will cover the `widget` and `validator` arguments. For a complete breakdown
    of all the field arguments that are available and not covered, visit [https://docs.djangoproject.com/en/4.0/ref/forms/fields/#core-field-arguments](https://docs.djangoproject.com/en/4.0/ref/forms/fields/#core-field-arguments).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更详细地讨论一下表单验证。在接下来的两个小节中，我们将介绍 `widget` 和 `validator` 参数。要了解所有可用且未涵盖的字段参数的完整说明，请访问[https://docs.djangoproject.com/en/4.0/ref/forms/fields/#core-field-arguments](https://docs.djangoproject.com/en/4.0/ref/forms/fields/#core-field-arguments)。
- en: Field widgets
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段小部件
- en: A field's `widget` argument allows us to define what kind of field to use, such
    as an input object of the date, email, password, or text type. This can also be
    a checkbox, radio button, drop-down select, or text area, to name a few examples.
    We don't have to specify the `widget` argument unless we want to change the default
    widget or override its initial properties.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 字段的`widget`参数允许我们定义要使用哪种类型的字段，例如日期、电子邮件、密码或文本类型的输入对象。这也可以是复选框、单选按钮、下拉选择或文本区域，仅举几个例子。除非我们想要更改默认小部件或覆盖其初始属性，否则我们不需要指定`widget`参数。
- en: 'Follow the next step to override the `full_name` field to render an input with
    the `id`, `class`, and `placeholder` attributes. The rendered output we hope to
    achieve should look like the following dummy code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 按照下一步操作来覆盖`full_name`字段，以渲染带有`id`、`class`和`placeholder`属性的输入。我们希望得到的渲染输出应类似于以下示例代码：
- en: '[PRE35]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In your `/chapter_5/forms.py` file, edit your `full_name` field, as shown:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`/chapter_5/forms.py`文件中，按照以下所示编辑你的`full_name`字段：
- en: '[PRE37]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If we changed the default widget of a field from `forms.TextInput` to something
    else, such as `forms.EmailInput`, that would render as `<input type="email">`.
    Changing `forms.TextInput` to `forms.DateInput` would render as `<input type="date">`.
    Using `forms.TextArea` would render as a `<textarea></textarea>` object instead.
    Of course, these are just some of the many different options that exist. For a
    complete breakdown of all the widgets available and how they can help you construct
    your fields, visit [https://docs.djangoproject.com/en/4.0/ref/forms/widgets/](https://docs.djangoproject.com/en/4.0/ref/forms/widgets/).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将字段的默认小部件从`forms.TextInput`更改为其他，例如`forms.EmailInput`，那么它将渲染为`<input type="email">`。将`forms.TextInput`更改为`forms.DateInput`将渲染为`<input
    type="date">`。使用`forms.TextArea`将渲染为`<textarea></textarea>`对象。当然，这些只是许多不同选项中的一些。要了解所有可用的小部件及其如何帮助您构建字段，请访问[https://docs.djangoproject.com/en/4.0/ref/forms/widgets/](https://docs.djangoproject.com/en/4.0/ref/forms/widgets/)。
- en: Let's discuss using field validators next.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们讨论使用字段验证器。
- en: Field validators
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段验证器
- en: When manually defining widgets, we sometimes have to write specific validation
    rules. For example, let's take a `forms.EmailInput` class; this would require
    adding validation rules that determine whether the value of the string the user
    provided is actually in [example@example.com](mailto:example@example.com) format
    and not some random string, such as `IAmAString`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当手动定义小部件时，我们有时必须编写特定的验证规则。例如，让我们以`forms.EmailInput`类为例；这将需要添加验证规则，以确定用户提供的字符串值是否实际上在[example@example.com](mailto:example@example.com)格式中，而不是像`IAmAString`这样的随机字符串。
- en: 'Follow these steps to create and validate an email field:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建和验证电子邮件字段：
- en: 'In your `/chapter_5/forms.py` file, in the existing `ContactForm`, add the
    `email_1` field shown here:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`/chapter_5/forms.py`文件中，在现有的`ContactForm`中，添加以下所示的`email_1`字段：
- en: '[PRE53]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: While fields can be manipulated using validator arguments in this way, Django
    tries to provide developers with options that minimize or reduce the amount of
    code that they need to write. For example, instead of writing the preceding example
    to enforce an email format on `CharField`, we could just use the `EmailField`
    class instead, which already enforces this rule for us. The `EmailField` class
    includes all of the logic and validation to handle an email field.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用验证器参数以这种方式操作字段，但Django试图为开发者提供选项，以最小化或减少他们需要编写的代码量。例如，我们不必编写前面的示例来在`CharField`上强制执行电子邮件格式，我们可以直接使用`EmailField`类，该类已经为我们强制执行了此规则。`EmailField`类包括处理电子邮件字段的全部逻辑和验证。
- en: 'To practice using the `EmailField` class, we will create an additional field
    to compare and contrast both code approaches. In your `/chapter_5/forms.py` file,
    in the same `ContactForm` class, add the `email_2` field shown here:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了练习使用`EmailField`类，我们将创建一个额外的字段来比较和对比两种代码方法。在你的`/chapter_5/forms.py`文件中，在相同的`ContactForm`类中，添加以下所示的`email_2`字段：
- en: '[PRE54]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The difference between the code found in *step 1* and *step 2* is that we do
    not need to define a widget or validator argument when using an `EmailField` class
    to produce the same behavior as with a `CharField` class. The error message is
    now located in the `error_messages` argument using the `email` key, as shown.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*和*步骤 2*中找到的代码之间的区别是，当使用`EmailField`类来产生与`CharField`类相同的行为时，我们不需要定义小部件或验证器参数。错误信息现在位于使用`email`键的`error_messages`参数中，如下所示。
- en: For a complete breakdown of all of the validator classes and methods available,
    visit [https://docs.djangoproject.com/en/4.0/ref/validators/](https://docs.djangoproject.com/en/4.0/ref/validators/).
    Let's practice cleaning forms next, which is just another way to perform validation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要完整了解所有可用的验证器类和方法，请访问 [https://docs.djangoproject.com/en/4.0/ref/validators/](https://docs.djangoproject.com/en/4.0/ref/validators/)。接下来，让我们练习清理表单，这仅仅是执行验证的另一种方式。
- en: Cleaning forms
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理表单
- en: 'We can perform validation on form fields in other ways as well. Within a form
    class, we can write methods that validate each field individually by writing them
    in this format: `def clean_{{ form_field_name }}()`. When doing this, only the
    value of the field that we are cleaning can be accessed. If we want to access
    other field values found in that form, we have to write a single `def clean()`
    method that will allow us to compare two fields against each other. For example,
    we could use the `def clean()` method to only require a field when another field''s
    value is not empty.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以以其他方式对表单字段进行验证。在表单类中，我们可以编写方法来验证每个字段，格式如下：`def clean_{{ form_field_name
    }}()`。在这样做的时候，只能访问我们正在清理的字段值。如果我们想访问该表单中找到的其他字段值，我们必须编写一个单独的 `def clean()` 方法，这将允许我们比较两个字段。例如，我们可以使用
    `def clean()` 方法，仅在另一个字段的值不为空时要求字段。
- en: The following two subsections break down these two concepts.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个小节将分解这两个概念。
- en: Method – clean_{{ your_field_name }}()
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法 – `clean_{{ your_field_name }}()`
- en: 'To clean an individual form field, follow these steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要清理单个表单字段，请按照以下步骤操作：
- en: 'In your `/chapter_5/forms.py` file, in the same `ContactForm` class, add a
    new field called `email_3`, as shown:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_5/forms.py` 文件中，在相同的 `ContactForm` 类中，添加一个名为 `email_3` 的新字段，如下所示：
- en: '[PRE55]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In that same `ContactForm` class, add the `clean_email_3` method shown here:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的 `ContactForm` 类中，添加以下 `clean_email_3` 方法：
- en: '[PRE56]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the preceding example, we are importing the `validate_email()` method from
    the `django.core.validators` library, to determine whether the string is in email
    format. First, we are using a simple conditional statement to check whether the
    field has a value or not; if not, we are issuing an error message stating `"This
    field is required"`. We are performing a validation check even though the `email_3`
    field has a `required` argument set to `False`. This just illustrates another
    way we can do the same thing. If a value exists, we then wrap the `validate_email()`
    method in a *Try/Except* statement, and if validation fails, we are adding the
    `"The following is not a valid email address: {{ field_value }}"` error message.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的例子中，我们是从 `django.core.validators` 库中导入 `validate_email()` 方法，以确定字符串是否为电子邮件格式。首先，我们使用一个简单的条件语句来检查字段是否有值；如果没有，我们发出一个错误信息，指出
    `"This field is required"`。即使 `email_3` 字段已将 `required` 参数设置为 `False`，我们也会执行验证检查。这仅仅说明了我们可以以另一种方式完成相同的事情。如果存在值，我们将在
    `validate_email()` 方法周围包裹一个 *Try/Except* 语句，如果验证失败，我们将添加 `"The following is not
    a valid email address: {{ field_value }}"` 错误信息。'
- en: 'The `self.add_error()` method provided in the `Form` and `ModelForm` classes
    accepts two arguments: the first argument is the name of the field and the second
    is your custom error message. Instead of using `self.add_error(''email_3'', ''This
    field is required'')` to add error messages to a form, we can use the `raise ValidationError(''This
    field is required'')` class instead. Except, there''s one problem: using this
    class will remove this field from the `cleaned_data` values list. That will work
    if you only use the `clean_email_3()` method by itself. If you wanted to access
    that same cleaned data within the `def clean()` method, you''d need to return
    the value in `def clean_email_3()`, as depicted in the last line of *step 2* previously.
    Django will fire off the individual clean methods on each field before the `clean()`
    method is executed, saving that as the last method in the stack of cleaning methods.
    If your field value is not returned in the clean method specific to that field,
    we will not be able to access it when we need to later on.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Form` 和 `ModelForm` 类中提供的 `self.add_error()` 方法接受两个参数：第一个参数是字段的名称，第二个是你的自定义错误信息。我们不是使用
    `self.add_error(''email_3'', ''This field is required'')` 来向表单添加错误信息，而是可以使用 `raise
    ValidationError(''This field is required'')` 类代替。但是，有一个问题：使用这个类将会从 `cleaned_data`
    值列表中移除该字段。如果你只使用 `clean_email_3()` 方法本身，那么这将有效。如果你想在 `def clean()` 方法中访问相同的清理数据，你需要在
    `def clean_email_3()` 中返回该值，如之前 *步骤 2* 的最后一行所示。Django 会在执行 `clean()` 方法之前，为每个字段触发单独的清理方法，并将其保存为清理方法栈中的最后一个方法。如果你的字段值没有在特定字段的清理方法中返回，那么在需要时我们将无法访问它。'
- en: Let's use the `clean()` method next.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用`clean()`方法。
- en: Method – clean()
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法 – clean()
- en: The `clean()` method is used to access all of the field data within a form,
    upon form submission. It is in this method that you could compare against the
    values of many fields before allowing a successful form submission. This next
    example will allow us to compare two fields against each other and raise one or
    more different field validation messages.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`clean()`方法用于在表单提交时访问表单中的所有字段数据。在这个方法中，你可以在允许成功的表单提交之前比较许多字段的值。接下来的示例将允许我们比较两个字段，并引发一个或多个不同的字段验证消息。'
- en: 'Follow these steps to configure your `clean()` method:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置你的`clean()`方法：
- en: 'In your `/chapter_5/forms.py` file, add another field to your `ContactForm`
    class called `conditional_required`, as shown:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`/chapter_5/forms.py`文件中，向`ContactForm`类添加另一个名为`conditional_required`的字段，如下所示：
- en: '[PRE57]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In that same `ContactForm` class, add the following `clean()` method:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的`ContactForm`类中，添加以下`clean()`方法：
- en: '[PRE58]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this `clean()` method, we are assigning the value of the `email_3` field
    to the variable called `email`. Then, we are assigning the value of the `conditional_required`
    field to the variable called `text_field`. Using a simple conditional statement,
    we then check to see whether `email` has a value present, and if so, check whether
    `text_field` has a value present. If this condition is met, we then add the required
    error to the `conditional_required` field. Since we set the `conditional_required`
    field to use the `required = False` argument, if there is no value in the `email_3`
    field, this field will not be required.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`clean()`方法中，我们将`email_3`字段的值赋给名为`email`的变量。然后，我们将`conditional_required`字段的值赋给名为`text_field`的变量。使用一个简单的条件语句，我们检查`email`是否有值，如果有，检查`text_field`是否有值。如果满足此条件，我们将在`conditional_required`字段中添加所需的错误。由于我们将`conditional_required`字段设置为使用`required
    = False`参数，如果`email_3`字段中没有值，则该字段不是必需的。
- en: Let's move on to creating our own custom form fields next.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建我们自己的自定义表单字段。
- en: Creating custom form fields
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义表单字段
- en: 'Sometimes, the needs of the project outweigh the options that are provided
    to us. If a field class is not available by default, we have two options: create
    our own or use a third-party package where someone else has already written a
    field class for us.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，项目的需求超过了我们提供的选项。如果默认情况下没有可用的字段类，我们有两个选择：创建自己的或使用第三方包，其中其他人已经为我们编写了一个字段类。
- en: Continuing with the same `ContactForm` class, we will demonstrate the differences
    between validation mechanisms by building a `MultipleEmailField`. This will be
    a single field, accepting a single string of emails, all separated by commas.
    Each email item will then be checked independently to see whether it is in a valid
    email string format. We will use the same `validate_email()` function as we did
    before to enforce this constraint.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用相同的`ContactForm`类，我们将通过构建一个`MultipleEmailField`来展示验证机制之间的差异。这将是一个单字段，接受一串用逗号分隔的电子邮件地址。然后，将独立检查每个电子邮件项，看它是否在有效的电子邮件字符串格式中。我们将使用之前使用的相同的`validate_email()`函数来强制执行此约束。
- en: Field class – Field
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段类 – Field
- en: Django provides a class called `Field` found in the `django.forms.fields` library,
    used to construct custom field classes. Any of the options and methods found in
    this class can be overwritten as needed. For example, overriding the `def __init__()`
    method will provide a way to add, change, or remove field arguments, completely
    transforming how you work with these fields later on. We won't actually be overriding
    the `__init__()` method for this exercise; instead, we will be working with the
    `to_python()` and `validate()` methods. These will be the only two methods needed
    to perform the validation that we need on `MultipleEmailField`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了一个名为`Field`的类，位于`django.forms.fields`库中，用于构建自定义字段类。这个类中发现的任何选项和方法都可以根据需要重写。例如，重写`def
    __init__()`方法将提供一种添加、更改或删除字段参数的方法，完全改变你以后与这些字段工作的方式。对于这个练习，我们实际上不会重写`__init__()`方法；相反，我们将使用`to_python()`和`validate()`方法。这些是我们执行`MultipleEmailField`上所需验证的唯一两个方法。
- en: 'Follow these steps to write your `Field` class:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤编写你的`Field`类：
- en: Create a new file called `fields.py` in your `/becoming_a_django_entdev/chapter_5/`
    folder.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`/becoming_a_django_entdev/chapter_5/`文件夹中创建一个名为`fields.py`的新文件。
- en: 'In that file, add the following `MultipleEmailField` class and `import` statements:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个文件中，添加以下`MultipleEmailField`类和`import`语句：
- en: '[PRE59]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If you want to use some of the validators provided by Django, use the `default_validators`
    option shown in the preceding code. This is where you will define what validator
    to use. We are using our own logic found in the `validate` method of the `MultipleEmailField`
    class and will not be using a default validator for what we are trying to achieve.
    You are welcome to use any of the validators that Django provides for your field
    classes, found in the `django.core.validators` library.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要使用 Django 提供的一些验证器，请使用前面代码中显示的 `default_validators` 选项。这是你定义要使用哪个验证器的地方。我们使用在
    `MultipleEmailField` 类的 `validate` 方法中找到的自己的逻辑，并且不会为我们想要实现的目标使用默认验证器。欢迎你使用 Django
    在 `django.core.validators` 库中为你的字段类提供的任何验证器。
- en: 'The `default_error_messages` option is used to define the default messages
    for a field class. In the `default_error_messages` option shown previously, we
    are specifying two keys: `required` and `email`. These two keys will act as the
    default message used when a required field has been submitted without a value
    present and when a value does not meet the email string format. When specifying
    a default error message in the `default_error_messages` option, we no longer have
    to use the `error_messages = {}` argument of a field. It is still possible to
    use the `error_messages` argument on a field-by-field basis if we wanted to.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`default_error_messages` 选项用于定义字段类的默认消息。在前面显示的 `default_error_messages` 选项中，我们指定了两个键：`required`
    和 `email`。这两个键将作为在必填字段提交时没有值存在以及当值不符合电子邮件字符串格式时使用的默认消息。在 `default_error_messages`
    选项中指定默认错误消息后，我们不再需要使用字段的 `error_messages = {}` 参数。如果我们想逐字段使用 `error_messages`
    参数，仍然是有可能的。'
- en: 'In that same `MultipleEmailField` class, add the following `to_python()` method:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的 `MultipleEmailField` 类中，添加以下 `to_python()` 方法：
- en: '[PRE60]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `to_python()` method is used to transform values into Python objects. This
    one in particular is written to transform a string into a list of emails, excluding
    the comma.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`to_python()` 方法用于将值转换为 Python 对象。这个特别的方法是编写来将字符串转换为电子邮件列表，不包括逗号。'
- en: 'In that same `MultipleEmailField` class, add the following `validate()` method:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的 `MultipleEmailField` 类中，添加以下 `validate()` 方法：
- en: '[PRE61]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `validate()` method checks each item in the list of emails to make sure
    it is in email format. We are also overriding the options provided in the `Field`
    class, such as the `widget` option shown in *step 2*. The default widget is `TextInput`.
    Since that is already what we need, we don't actually have to include it; it was
    provided in the preceding example for illustrative purposes. When writing your
    own custom field, you can replace `TextInput` with any of the Django widgets found
    in the `django.forms.widgets` library. If you want to take your field one step
    further, you could even write your own custom widget class, but this is beyond
    the scope of this book.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate()` 方法检查电子邮件列表中的每个项目，以确保其格式正确。我们还在 `Field` 类中覆盖了提供的选项，例如在 *步骤 2* 中显示的
    `widget` 选项。默认小部件是 `TextInput`。由于这已经是我们需要的内容，我们实际上不需要包括它；在先前的示例中提供它是为了说明目的。当你编写自己的自定义字段时，你可以用
    `django.forms.widgets` 库中找到的任何 Django 小部件替换 `TextInput`。如果你想将字段再进一步定制，甚至可以编写自己的自定义小部件类，但这超出了本书的范围。'
- en: Let's work on using our custom field class next.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来使用我们的自定义字段类。
- en: Using a custom field
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义字段
- en: 'To use the `MultipleEmailField` that we created in the previous subsection,
    in your `/chapter_5/forms.py` file, add the following `import` statement and add
    the `multiple_emails` field to `ContactForm`, as shown:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们在前一小节中创建的 `MultipleEmailField`，在你的 `/chapter_5/forms.py` 文件中，添加以下 `import`
    语句并将 `multiple_emails` 字段添加到 `ContactForm` 中，如下所示：
- en: '[PRE62]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In the preceding example, we do not need to include any validation messages
    because we have already defined the messages we want in the `MultipleEmailField`
    class.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的示例中，我们不需要包含任何验证消息，因为我们已经在 `MultipleEmailField` 类中定义了想要的那些消息。
- en: 'The arguments that are available are listed here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的参数如下所示：
- en: '![](img/Table_2.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_2.jpg)'
- en: 'These are the arguments included within the `__init__()` method of the `Field`
    class in the Django library. If we needed to use arguments such as `min_length`
    and `max_length`, as we did for the `full_name` field, we should have constructed
    the `MultipleEmailField` class using the `CharField` class instead of the `Field`
    class like we did in *step 2* of the subsection titled *Field class – Field* of
    this chapter, as depicted here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是Django库中`Field`类的`__init__()`方法中包含的参数。如果我们需要使用类似于`min_length`和`max_length`这样的参数，就像我们在本章标题为“字段类
    – 字段”的子节*step 2*中为`full_name`字段所做的那样，我们应该使用`CharField`类而不是`Field`类来构造`MultipleEmailField`类，如图所示：
- en: '[PRE76]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The reason why we would want to use `CharField` instead of the `Field` class
    is that it extends the `Field` class and adds logic that includes the `min_length`
    and `max_length` arguments. Using this notion, you can extend any other field
    class, making available any of the unique arguments or behaviors of that class
    when writing your own custom class.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以想使用`CharField`而不是`Field`类，是因为它扩展了`Field`类并添加了包括`min_length`和`max_length`参数的逻辑。使用这个概念，你可以扩展任何其他字段类，在编写自己的自定义类时，可以提供该类独特的任何参数或行为。
- en: Next, let's take our contact form and use it with a view class to serve up our
    contact page.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用我们的联系表单并使用视图类来提供我们的联系页面。
- en: Working with form views
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表单视图
- en: A **form view** is just like any other view class, except that a form view class
    is designed to process and handle form objects and form submissions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**表单视图**就像任何其他视图类一样，只不过表单视图类是为处理和处理表单对象和表单提交而设计的。'
- en: 'Django offers four main form view classes, listed here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了四个主要的表单视图类，如下所示：
- en: '`FormView`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormView`'
- en: '`CreateView`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateView`'
- en: '`UpdateView`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateView`'
- en: '`DeleteView`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeleteView`'
- en: These can all be found in the `django.views.generic.edit` library.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都可以在`django.views.generic.edit`库中找到。
- en: 'If we were to create a view to work with the `ContactForm` class that we created
    earlier, which does not relate to any models, we would use a simple `FormView`
    class. The other three classes can be used with forms that relate to models. They
    each serve a different purpose: to create, update, or delete records in a database.
    For example, `CreateView` will render a form containing blank or default values
    intended to create a record that does not exist yet. `UpdateView` uses a form
    that looks up an existing record, displays the values that exist for that record,
    and allows changes to be made. `DeleteView` will display to the user a prompt
    or confirmation page, asking the user whether they actually want to proceed with
    this task, then delete that record.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要创建一个与之前创建的`ContactForm`类一起工作的视图，该类不与任何模型相关联，我们将使用简单的`FormView`类。其他三个类可以与与模型相关的表单一起使用。它们各自有不同的用途：在数据库中创建、更新或删除记录。例如，`CreateView`将渲染一个包含空白或默认值的表单，这些值旨在创建一个尚不存在的记录。`UpdateView`使用一个查找现有记录的表单，显示该记录的现有值，并允许进行更改。`DeleteView`将向用户显示一个提示或确认页面，询问用户他们是否真的想继续执行此任务，然后删除该记录。
- en: Let's use the `FormView` class to begin building a page that displays the `ContactForm`
    class object. We will be working with `CreateView` and `UpdateView` later in this
    chapter. For a complete breakdown of how to use all of these form view classes,
    visit [https://docs.djangoproject.com/en/4.0/ref/class-based-views/generic-editing/](https://docs.djangoproject.com/en/4.0/ref/class-based-views/generic-editing/).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`FormView`类开始构建一个显示`ContactForm`类对象的页面。我们将在本章后面使用`CreateView`和`UpdateView`。有关如何使用所有这些表单视图类的完整说明，请访问[https://docs.djangoproject.com/en/4.0/ref/class-based-views/generic-editing/](https://docs.djangoproject.com/en/4.0/ref/class-based-views/generic-editing/)。
- en: View class – FormView
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图类 – FormView
- en: Let's start by constructing a class called `FormClassView` using Django's `FormView`
    class. This class will have three options that we will define, the first option
    being `template_name`, which is used to define the path of the HTML template that
    we are using. The second option is the `form_class` option, which is used to define
    the name of the form class that this view is going to process, that being the
    `ContactForm` class. The third option is `success_url`, which specifies a relative
    URL path to redirect the user to when the form is successfully submitted.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用Django的`FormView`类构建一个名为`FormClassView`的类。这个类将包含三个选项，第一个选项是`template_name`，它用于定义我们正在使用的HTML模板的路径。第二个选项是`form_class`选项，它用于定义这个视图将要处理的表单类的名称，即`ContactForm`类。第三个选项是`success_url`，它指定了一个相对URL路径，当表单成功提交时，将重定向用户到该路径。
- en: 'Follow these steps to configure your `FormClassView` class:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置你的`FormClassView`类：
- en: Make sure you have a file called `views.py` in your `/becoming_a_django_entdev/chapter_5/`
    folder. This is usually created automatically for you when a new Django app is
    created.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的`/becoming_a_django_entdev/chapter_5/`文件夹中有一个名为`views.py`的文件。这通常是在创建新的Django应用时自动为你创建的。
- en: 'In that same file, add the code shown here:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，添加以下代码：
- en: '[PRE80]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Any of these options can use a callable to gain those values, such as the use
    of the `reverse()` function to specify `success_url`. An example of how this can
    be done is depicted here, but this is not part of the actual exercise:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项中的任何一个都可以使用可调用函数来获取这些值，例如使用`reverse()`函数来指定`success_url`。这里展示了如何做到这一点的一个例子，但这不是实际练习的一部分：
- en: '[PRE81]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We won't actually need the callable shown here to formulate the success URL.
    All we need is the string representation of `'/chapter_5/contact-form-success/'`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上不需要这里显示的可调用函数来制定成功URL。我们需要的只是`'/chapter_5/contact-form-success/'`字符串表示形式。
- en: 'Next, configure the URL pattern for `http://localhost:8000/chapter-5/form-class/`.
    If this file was not automatically created for you, create the `/chapter_5/urls.py`
    file and add the following form page pattern and `import` statement:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，配置`http://localhost:8000/chapter-5/form-class/`的URL模式。如果此文件没有为你自动创建，请创建`/chapter_5/urls.py`文件，并添加以下表单页面模式和`import`语句：
- en: '[PRE82]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In that same file, add the following success pattern:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，添加以下成功模式：
- en: '[PRE83]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In this step, we added a second pattern to serve as the success page at `http://localhost:8000/chapter-5/contact-form-success/`.
    This success page will be used for all exercises in this chapter.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们添加了一个第二个模式，作为`http://localhost:8000/chapter-5/contact-form-success/`的成功页面。这个成功页面将用于本章的所有练习。
- en: Now that we have a view class to work with and some basic options defined, let's
    explore what it takes to work with the different request methods.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个视图类可以与之一起工作，并定义了一些基本选项，让我们来探索一下使用不同请求方法需要什么。
- en: HTTP request methods
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP请求方法
- en: 'Working with the `FormView` class in Django, there are two HTTP request methods:
    the `GET` and `POST` methods. The `GET` method is intended to render a form with
    blank or default values onto a page and wait for the user to fill out the form
    and submit it. Once the form has been submitted, the `POST` method will be executed.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中与`FormView`类一起工作，有两种HTTP请求方法：`GET`方法和`POST`方法。`GET`方法旨在将带有空白或默认值的表单渲染到页面上，并等待用户填写表单并提交。一旦表单被提交，`POST`方法将被执行。
- en: GET
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GET
- en: The `get()` method is just like any other GET method for a view class. It is
    the go-to method when the page first gets loaded.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`方法就像视图类中的任何其他GET方法一样。它是页面首次加载时的首选方法。'
- en: 'Follow these steps to configure your `FormClassView` class''s `get()` method:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置你的`FormClassView`类的`get()`方法：
- en: 'In the `/chapter_5/views.py` file, add the `get()` method to your existing
    `FormClassView` class using the following code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/chapter_5/views.py`文件中，使用以下代码向现有的`FormClassView`类添加`get()`方法：
- en: '[PRE84]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In the preceding `get()` method, we are returning an HTTP response in the form
    of a `TemplateResponse` class, using the value of `self.template_name` as the
    path to the template location. We are providing that template with context unique
    to this page, such as the `title`, `page_id`, `page_class`, `h1_tag`, and `form`
    variables that are depicted in the preceding code block. The value of `self.form_class`
    is used to pass the form object into the template. Initial values can be defined
    on form fields when the page first gets loaded, which is when the form is initialized.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`get()`方法中，我们正在以`TemplateResponse`类的形式返回一个HTTP响应，使用`self.template_name`的值作为模板位置的路径。我们向该模板提供了特定于此页面的上下文，例如`title`、`page_id`、`page_class`、`h1_tag`和`form`变量，如前面的代码块所示。`self.form_class`的值用于将表单对象传递到模板。可以在页面首次加载时在表单字段上定义初始值，这是表单初始化的时候。
- en: 'Add the following `initial` list to your existing `get()` method of the `FormClassView`
    class and pass it into your return context, as highlighted in the following code
    block:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`initial`列表添加到`FormClassView`类的现有`get()`方法中，并将其传递到你的返回上下文中，如下面的代码块所示：
- en: '[PRE85]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In this `get()` method, we added the `initial` variable as a list and then passed
    that list into the `self.form_class(initial)` object, which lets us set the initial
    value on fields, defining field names as the keys shown previously with their
    corresponding values.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`get()`方法中，我们添加了`initial`变量作为列表，然后将该列表传递给`self.form_class(initial)`对象，这使我们能够在字段上设置初始值，定义字段名称为之前显示的键及其相应的值。
- en: POST
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: POST
- en: A `post()` method is used to render the same page when a form has been submitted.
    In this method, we can determine whether the form is valid and if so, we want
    to redirect it to a success URL. If the form is not valid, the page will reload
    with the values that the user entered into the fields and display any error messages
    that may exist. We can also alter or add to the context of a page using a `post()`
    method.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单被提交时，使用 `post()` 方法来渲染相同的页面。在这个方法中，我们可以确定表单是否有效，如果是的话，我们希望将其重定向到成功 URL。如果表单无效，页面将重新加载，显示用户输入到字段中的值，并显示可能存在的任何错误消息。我们还可以使用
    `post()` 方法修改或添加页面上下文。
- en: 'In your `/chapter_5/views.py` file, in the same `FormClassView` class, add
    the `post()` method shown here:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_5/views.py` 文件中，在相同的 `FormClassView` 类中，添加以下 `post()` 方法：
- en: '[PRE86]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Inside the `TemplateResponse` return statement, the highlighted text where the
    context is written represents the context that has changed from the `get()` method
    to the `post()` method. In order to preserve the data that the user has entered
    into the form, `request.POST` must be passed into the form class, where `self.form_class(request.POST)`
    is highlighted in the preceding step. If we didn't pass `request.POST` into `self.form_class()`,
    then we would have rendered a blank form, as if we were using the `get()` method,
    upon first visiting this page.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TemplateResponse` 返回语句中的高亮文本表示从 `get()` 方法到 `post()` 方法已更改的上下文。为了保留用户已输入到表单中的数据，必须将
    `request.POST` 传递到表单类中，如前一步中高亮的 `self.form_class(request.POST)`。如果我们没有将 `request.POST`
    传递到 `self.form_class()`，那么在首次访问此页面时，我们会渲染一个空白表单，就像我们使用 `get()` 方法一样。
- en: Now that we have our view class written, we can work on the template that will
    render our form next.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了视图类，接下来我们可以着手编写将渲染我们的表单的模板。
- en: Rendering forms in templates
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模板中渲染表单
- en: Django offers five main ways to easily and quickly render a form object onto
    a page. The first three are to render a form using a paragraph, table, or list
    structure. The other two include the traditional way of rendering a form, which
    is based on the template in the `django.forms.templates.django.forms` library
    called `default.html`, and then a way to render your own template. New to Django
    4.0 is the `template_name` option on all form classes. This option allows you
    to point to a template file where you can structure your own HTML formatting.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Django 提供了五种主要方式来轻松快速地将表单对象渲染到页面上。前三种是使用段落、表格或列表结构来渲染表单。其他两种包括基于 `django.forms.templates.django.forms`
    库中的 `default.html` 模板的传统渲染表单方式，以及渲染你自己的模板的方式。Django 4.0 的新特性是所有表单类上的 `template_name`
    选项。此选项允许你指向一个模板文件，在那里你可以构建自己的 HTML 格式。
- en: 'Follow these steps to render your form objects:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤渲染你的表单对象：
- en: Copy the `base_template_1.html` file that was created in [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116),
    *URLs, Views, and Templates*, into your `/becoming_a_django_entdev/chapter_5/templates/chapter_5/base/`
    folder. Copy all related partial template files that are added as `{% include
    %}` statements into that file as well.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将在 [*第 4 章*](B17243_04_ePub.xhtml#_idTextAnchor116)，*URLs、视图和模板* 中创建的 `base_template_1.html`
    文件复制到你的 `/becoming_a_django_entdev/chapter_5/templates/chapter_5/base/` 文件夹中。同时将所有作为
    `{% include %}` 语句添加的相关部分模板文件也复制到该文件中。
- en: That `base_template_1.html` file will be repurposed as the base template for
    this chapter's exercise. Adjust any paths to point to the new `chapter_5` folder,
    such as any CSS and JavaScript file paths.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那个 `base_template_1.html` 文件将被重新用作本章练习的基础模板。调整任何路径以指向新的 `chapter_5` 文件夹，例如任何
    CSS 和 JavaScript 文件路径。
- en: Copy all related CSS, JavaScript, and HTML files into your `chapter_5` app as
    well. These are not required to complete this exercise but will prevent 404 errors
    in your console logs.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有相关的 CSS、JavaScript 和 HTML 文件也复制到你的 `chapter_5` 应用中。这些文件不是完成此练习所必需的，但可以防止控制台日志中出现
    404 错误。
- en: 'Create a new file called `form-class.html` inside your `/becoming_a_django_entdev/chapter_5/templates/chapter_5/`
    folder and include the tags we can see in the following code block:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/becoming_a_django_entdev/chapter_5/templates/chapter_5/` 文件夹中创建一个名为 `form-class.html`
    的新文件，并包含以下代码块中可以看到的标签：
- en: '[PRE116]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Inside your `/chapter_5/form-class.html` file, add the following code inside
    the `body_content` block, to render a form in the simplest way possible:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_5/form-class.html` 文件中，在 `body_content` 块内添加以下代码，以尽可能简单的方式渲染表单：
- en: '[PRE117]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Here, we need to at least write the `<form>` element and define an attribute
    of `method="post"` telling the browser how to handle a form submission. The `{{
    form }}` tag renders any fields that exist for this form, using the `django.forms.templates.django.forms.default.html`
    library template. `{% csrf_token %}` is a cross-site request forgery token that
    is used for security measures and is required on all Django forms. `<input type="submit">`
    specifies the button that is used to trigger the form's submit action.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们至少需要写出 `<form>` 元素并定义一个 `method="post"` 属性，告诉浏览器如何处理表单提交。`{{ form }}`
    标签使用 `django.forms.templates.django.forms.default.html` 库模板渲染此表单存在的任何字段。`{% csrf_token
    %}` 是一个跨站请求伪造令牌，用于安全措施，并且所有 Django 表单都需要它。`<input type="submit">` 指定了用于触发表单提交动作的按钮。
- en: Let's dive into the remaining four mechanisms and how they are used.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解剩余的四种机制及其使用方法。
- en: Render form – as_p
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染表单 – as_p
- en: This option will render each field wrapped in a paragraph, `<p></p>`, element.
    The label will be stacked above the input field with the help text below it. If
    errors are present, each field will have its own list object rendered above the
    paragraph objects, listing all the errors relating to that field.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项将每个字段包裹在段落 `<p></p>` 元素中。标签将堆叠在输入字段上方，帮助文本位于其下方。如果存在错误，每个字段将渲染自己的列表对象，位于段落对象上方，列出与该字段相关的所有错误。
- en: To render your form with `as_p`, in your `/chapter_5/form-class.html` file,
    change the `{{ form }}` tag to `{{ form.as_p }}`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要以 `as_p` 形式渲染你的表单，在你的 `/chapter_5/form-class.html` 文件中，将 `{{ form }}` 标签更改为
    `{{ form.as_p }}`。
- en: 'This should render each field to look like the demo code depicted here:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会渲染每个字段，看起来像这里展示的示例代码：
- en: '[PRE118]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Let's render the form formatted as a table next.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们以表格形式渲染表单。
- en: Render form – as_table
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染表单 – as_table
- en: 'This option takes each field and wraps it in a `<tr></tr>` element. The label
    of this field is wrapped in a `<th></th>` element and the field itself is wrapped
    in a `<td></td>` element. The label will be stacked to the left with the input
    object and help text and error message displayed to the right, as shown:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项将每个字段包裹在 `<tr></tr>` 元素中。此字段的标签被包裹在 `<th></th>` 元素中，而字段本身被包裹在 `<td></td>`
    元素中。标签将堆叠在左侧，输入对象和帮助文本以及错误消息显示在右侧，如下所示：
- en: '![Figure 5.1 – Render form – as_table'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – 渲染表单 – as_table'
- en: '](img/Figure_5.1_B17243.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B17243.jpg)'
- en: Figure 5.1 – Render form – as_table
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 渲染表单 – 以表格形式
- en: To use this option, we still have to wrap the form tag in a `<table></table>`
    element because only the inner contents of a table are rendered.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此选项，我们仍然需要将表单标签包裹在 `<table></table>` 元素中，因为只有表格的内部内容会被渲染。
- en: 'To render your form as a table, in your `/chapter_5/form-class.html` file,
    change your `{{ form }}` tag to `{{ form.as_table }}` and wrap it in the `<table>`
    tag, as shown:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要以表格形式渲染你的表单，在你的 `/chapter_5/form-class.html` 文件中，将你的 `{{ form }}` 标签更改为 `{{
    form.as_table }}` 并将其包裹在 `<table>` 标签中，如下所示：
- en: '[PRE127]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Let's render the form formatted as a list next.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们以列表形式渲染表单。
- en: Render form – as_ul
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染表单 – as_ul
- en: 'This option will render your form as a list with each field wrapped in a `<li></li>`
    element. Inside that element, the label will come first, then the input field,
    and the help text last. If an error occurs, it gets injected as its own list item
    above that field, as shown:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项将渲染你的表单为一个列表，每个字段都被 `<li></li>` 元素包裹。在该元素内部，标签首先出现，然后是输入字段，最后是帮助文本。如果发生错误，它将作为自己的列表项注入到该字段上方，如下所示：
- en: '![Figure 5.2 – Render form – As a list'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2 – 渲染表单 – 以列表形式'
- en: '](img/Figure_5.2_B17243.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.2_B17243.jpg)'
- en: Figure 5.2 – Render form – As a list
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 渲染表单 – As a list
- en: 'We also have to wrap the form in an element with the `<ul></ul>` list element.
    To render your form as a list, in your `/chapter_5/form-class.html` file, change
    the `{{ form }}` tag to `{{ form.as_ul }}` and wrap it in the `<ul>` tag, as shown:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须将表单包裹在一个带有 `<ul></ul>` 列表元素的元素中。要在你的 `/chapter_5/form-class.html` 文件中以列表形式渲染表单，将
    `{{ form }}` 标签更改为 `{{ form.as_ul }}` 并将其包裹在 `<ul>` 标签中，如下所示：
- en: '[PRE133]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Let's use a new approach that was introduced in Django 4.0 next.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 Django 4.0 中引入的新方法。
- en: Render form – using template_name
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染表单 – 使用 template_name
- en: New to Django 4.0 is the `template_name` feature. This feature is used to render
    a form in the style written within a custom template. It gives developers the
    ability to structure their own HTML when fields are rendered. Developers can create
    many different template styles and use them as needed. Fields are accessed via
    the `{{ fields }}` tag inside that custom template.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Django 4.0 的新特性是 `template_name` 功能。此功能用于在自定义模板中渲染表单。它为开发者提供了在字段渲染时结构化自己的 HTML
    的能力。开发者可以创建许多不同的模板样式，并根据需要使用它们。字段通过自定义模板内的 `{{ fields }}` 标签访问。
- en: 'Follow these steps to configure your custom form template:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置您的自定义表单模板：
- en: 'In your `/chapter_5/forms.py` file, add the `template_name` option to the existing
    `ContactForm` class, as highlighted:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `/chapter_5/forms.py` 文件中，将 `template_name` 选项添加到现有的 `ContactForm` 类中，如高亮所示：
- en: '[PRE139]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Next, create the `custom-form.html` file in your `/chapter_5/templates/chapter_5/forms/`
    folder. We will not be adding an `{% extends %}` tag to this file; instead, we
    will treat it as if we are using an `{% include %}` tag, where it is just a snippet
    and not an entire page of HTML.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在您的 `/chapter_5/templates/chapter_5/forms/` 文件夹中创建 `custom-form.html` 文件。我们不会向此文件添加
    `{% extends %}` 标签；相反，我们将它视为使用 `{% include %}` 标签，其中它只是一个片段，而不是一个完整的 HTML 页面。
- en: 'Inside your `/chapter_5/custom-forms.html` file, add the following code:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `/chapter_5/custom-forms.html` 文件中，添加以下代码：
- en: '[PRE140]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Here, we are looping through all of the fields with the `{% for field, errors
    in fields %}` tag shown in the preceding code block. We've added our own HTML
    structure using the `<div>`, `<label>`, and `<span>` elements. The field itself
    is rendered using the `{{ field }}` tag. Other information, such as the help text,
    is used in conjunction with the `safe` filter in `{{ field.help_text|safe }}`.
    The `safe` filter is used to make sure that any HTML contained in the string gets
    rendered as HTML objects and not printed as the string representation of that
    object.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过 `{% for field, errors in fields %}` 标签循环遍历所有字段，如前一个代码块所示。我们使用 `<div>`、`<label>`
    和 `<span>` 元素添加了自己的 HTML 结构。字段本身是通过 `{{ field }}` 标签渲染的。其他信息，如帮助文本，与 `safe` 过滤器结合使用在
    `{{ field.help_text|safe }}` 中。`safe` 过滤器用于确保字符串中的任何 HTML 都被渲染为 HTML 对象，而不是打印为该对象的字符串表示。
- en: Let's demonstrate all of these form renderings in action next.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来演示所有这些表单渲染的实际操作。
- en: Render demo
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染演示
- en: 'By now, we should have a working form. In your browser, visit the URL `http://localhost:8000/chapter-5/form-class/`,
    and you should see your form rendered onto the page. Through all of the examples
    provided using the `ContactForm` class, we should see six fields on this page.
    Here, we can see how an email field can behave differently as we interact with
    the form. For example, if we set the required argument in the `email_1` field
    to equal `False`, we can submit the form with nothing entered into this field
    and it will succeed. In the field named `email_2`, we specified the `required`
    argument as equal to `True`. This added the `required` attribute to that input
    field, preventing the user from submitting that form. This means the user will
    never see the error message that we provided in the Django code. This route would
    require the use of JavaScript, such as the jQuery Validate library, to handle
    the error state and display an error message for us. Doing nothing would result
    in the browser handling the error state for us, and in Chrome, that would look
    as in the following screenshot:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该有一个可以工作的表单。在您的浏览器中，访问 URL `http://localhost:8000/chapter-5/form-class/`，您应该看到表单被渲染到页面上。通过使用
    `ContactForm` 类提供的所有示例，我们应该在这个页面上看到六个字段。在这里，我们可以看到电子邮件字段如何在与表单交互时表现出不同的行为。例如，如果我们将
    `email_1` 字段的 `required` 参数设置为 `False`，我们可以不在此字段中输入任何内容就提交表单，并且它会成功。在名为 `email_2`
    的字段中，我们指定了 `required` 参数为 `True`。这给该输入字段添加了 `required` 属性，防止用户提交该表单。这意味着用户将永远不会看到我们在
    Django 代码中提供的错误消息。此路由需要使用 JavaScript，例如 jQuery Validate 库，来处理错误状态并为我们显示错误消息。不采取任何行动会导致浏览器为我们处理错误状态，在
    Chrome 中，它看起来如下截图所示：
- en: '![Figure 5.3 – ContactForm email_2 field'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3 – ContactForm email_2 字段'
- en: '](img/Figure_5.3_B17243.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.3_B17243.jpg)'
- en: Figure 5.3 – ContactForm email_2 field
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – ContactForm email_2 字段
- en: 'However, on the field named `email_3`, we set the required argument to equal
    `False`, and in the clean method, we are performing the validation that checks
    whether the field has a value or not. This lets us submit the form and see the
    error message that was provided on postback, as shown:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在名为 `email_3` 的字段上，我们将必需参数设置为等于 `False`，并在清理方法中执行验证，检查该字段是否有值。这使得我们可以提交表单并看到在回发时提供的错误消息，如下所示：
- en: '![Figure 5.4 – ContactForm email_3 field'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – ContactForm email_3 字段'
- en: '](img/Figure_5.4_B17243.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 5.4](img/Figure_5.4_B17243.jpg)'
- en: Figure 5.4 – ContactForm email_3 field
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – ContactForm email_3 字段
- en: Next, let's take Django forms a step further and start working with the models
    in a form class. We created a placeholder class for this, called `VehicleForm`,
    in the section titled *Form class – ModelForm*.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将 Django 表单进一步向前推进，并开始在一个表单类中处理模型。我们在标题为 *表单类 – ModelForm* 的部分创建了一个占位符类，称为
    `VehicleForm`。
- en: Linking a model to a form
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将模型链接到表单
- en: Linking a model to a form without needing any special field rendering is fairly
    easy.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要任何特殊字段渲染即可将模型链接到表单相当简单。
- en: 'In your `/chapter_5/forms.py` file, add the following code to the existing
    `VehicleForm` class (remember to remove the `pass` statement that was added to
    this class earlier):'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 `/chapter_5/forms.py` 文件中，向现有的 `VehicleForm` 类添加以下代码（请记住删除之前添加到该类中的 `pass`
    语句）：
- en: '[PRE141]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: In the preceding example, we don't have to create fields for this form. Django
    will automatically use the form field type associated with the model field type
    that we wrote for the `Vehicle` model, created in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077),
    *Models, Relations, and Inheritance*. If any field behavior needed modifying,
    we would write form fields the same way we did for `ContactForm` and then customize
    them as we see fit. The `Meta` subclass used here defines what model class we
    are using and the `fields` option specifies what fields of that model we want
    to include and in what order they should be included.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们不需要为这个表单创建字段。Django 将自动使用与我们在 *第 3 章* 中为 `Vehicle` 模型编写的模型字段类型关联的表单字段类型，该章名为
    *模型、关系和继承*。如果需要修改任何字段行为，我们将以与 `ContactForm` 相同的方式编写表单字段，然后根据需要对其进行定制。这里使用的 `Meta`
    子类定义了我们使用的模型类，而 `fields` 选项指定了我们想要包含哪些模型字段以及它们的包含顺序。
- en: Note
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Using `fields = '__all__'` will include all fields that exist for that model
    in the order that they were written for that model.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `fields = '__all__'` 将会包含该模型中存在的所有字段，并且按照模型中定义的顺序排列。
- en: Let's work with the `CreateView` class next.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来处理 `CreateView` 类。
- en: View class – CreateView
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图类 – CreateView
- en: Using the `VehicleForm` class that we now have wired up to the `Vehicle` model,
    let's create a view that will render a form with no or default field values using
    the `CreateView` class. It will let us create a new vehicle record in the database
    when that form is successfully submitted.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们现在已经连接到 `Vehicle` 模型的 `VehicleForm` 类，让我们创建一个视图，该视图将使用 `CreateView` 类渲染一个没有或默认字段值的表单。当表单成功提交时，它将允许我们在数据库中创建一个新的车辆记录。
- en: 'Follow these steps to configure your `CreateView` class:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置您的 `CreateView` 类：
- en: 'In your `/chapter_5/views.py` file, add the following `import` statements and
    create the `ModelFormClassCreateView` class, as follows:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `/chapter_5/views.py` 文件中，添加以下 `import` 语句并创建 `ModelFormClassCreateView`
    类，如下所示：
- en: '[PRE158]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'In that same `ModelFormClassCreateView` class, add the following `get()` method:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的 `ModelFormClassCreateView` 类中，添加以下 `get()` 方法：
- en: '[PRE159]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'In that same `ModelFormClassCreateView` class, add the following `post()` method:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的 `ModelFormClassCreateView` 类中，添加以下 `post()` 方法：
- en: '[PRE160]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: In this example, we gave this class the same two methods that we used earlier—`get()`
    and `post()`. These two methods work the same way as when used in a class constructed
    with the `FormView` class. In the `get()` method, we are passing just a blank
    form into the template as context using `self.form_class()`. In the `post()` method,
    we are once again passing `request` into the form to get the data that was submitted
    by the user, using `form = self.form_class(request.POST)`. In that `post()` method,
    validation is performed using `if form.is_valid():` and it will either redirect
    to a success page or refresh, serving up the form with the correct error messages.
    If the form is validated successfully, just before we perform the redirect, we
    are saving the form using `vehicle.save()`, the same way we did when we added
    data using the Django shell in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077),
    *Models, Relations, and Inheritance*.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们给了这个类之前使用的两个相同的方法——`get()`和`post()`。这两个方法与使用`FormView`类构造的类中的用法相同。在`get()`方法中，我们通过`self.form_class()`将一个空表单作为上下文传递给模板。在`post()`方法中，我们再次将`request`传递给表单以获取用户提交的数据，使用`form
    = self.form_class(request.POST)`。在那个`post()`方法中，使用`if form.is_valid():`进行验证，它将重定向到成功页面或刷新，显示带有正确错误信息的表单。如果表单验证成功，在执行重定向之前，我们使用`vehicle.save()`保存表单，就像我们在[*第3章*](B17243_03_ePub.xhtml#_idTextAnchor077)“模型、关系和继承”中使用Django
    shell添加数据时做的那样。
- en: 'Create a URL pattern using the `ModelFormClassCreateView` class, add the following
    path to your `/chapter_5/urls.py` file, and include the following `import` statements:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ModelFormClassCreateView`类创建一个URL模式，将以下路径添加到你的`/chapter_5/urls.py`文件中，并包含以下`import`语句：
- en: '[PRE161]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'In that same `/chapter_5/urls.py` file, add the following success URL pattern:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的`/chapter_5/urls.py`文件中，添加以下成功URL模式：
- en: '[PRE162]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: We added the success URL pattern for a vehicle form at `http://localhost:8000/chapter-5/vehicle-form-success/`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`http://localhost:8000/chapter-5/vehicle-form-success/`添加了车辆表单的成功URL模式。
- en: Next, construct your `/chapter_5/model-form-class.html` file the same way that
    we created the `/chapter_5/form-class.html` file.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，以创建`/chapter_5/form-class.html`文件相同的方式构建你的`/chapter_5/model-form-class.html`文件。
- en: 'Now, visit the URL `http://localhost:8000/chapter-5/model-form-class/`, and
    if you are rendering your form using the standard `{{ form }}` tag, you should
    see the page looking as in the following screenshot:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，访问URL `http://localhost:8000/chapter-5/model-form-class/`，如果你使用标准的`{{ form
    }}`标签渲染表单，你应该会看到页面看起来如图下所示：
- en: '![Figure 5.5 – VehicleForm using ModelFormClassCreateView'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.5 – 使用ModelFormClassCreateView的VehicleForm'
- en: '](img/Figure_5.5_B17243.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.5_B17243.jpg)'
- en: Figure 5.5 – VehicleForm using ModelFormClassCreateView
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 使用ModelFormClassCreateView的VehicleForm
- en: Of course, this example is in its simplest form. If you wanted to use another
    format or a template of your own, you would follow the steps under the *Rendering
    forms in templates* section of this chapter.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个例子是最简单的形式。如果你想要使用其他格式或你自己的模板，你将遵循本章“在模板中渲染表单”部分下的步骤。
- en: View class – UpdateView
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图类 – UpdateView
- en: In this example, we need to create a URL pattern using a path converter to capture
    the ID of the vehicle record that is being looked up.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们需要使用路径转换器创建一个URL模式，以捕获正在查找的车辆记录的ID。
- en: 'Follow these steps to configure your `UpdateView` class:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置你的`UpdateView`类：
- en: 'In your `/chapter_5/urls.py` file, add the path shown here:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`/chapter_5/urls.py`文件中，添加以下路径：
- en: '[PRE163]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: This pattern will allow us to access a `Vehicle` record by ID, also known as
    a primary key, in a database. We specify the ID of the `Vehicle` that we want
    to look up in the URL itself, as in `http://localhost:8000/chapter-5/model-form-class/2/`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式将允许我们通过ID访问数据库中的“Vehicle”记录，也称为主键。我们在URL本身中指定我们想要查找的“Vehicle”的ID，例如`http://localhost:8000/chapter-5/model-form-class/2/`。
- en: 'In your `/chapter_5/views.py` file, add the `ModelFormClassUpdateView` class
    and `import` statements shown here:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`/chapter_5/views.py`文件中，添加显示的`ModelFormClassUpdateView`类和`import`语句：
- en: '[PRE164]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'In that same `ModelFormClassUpdateView` class, add the `get()` and `post()`
    methods shown here:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的`ModelFormClassUpdateView`类中，添加显示的`get()`和`post()`方法：
- en: '[PRE165]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Now, navigate to the URL `http://localhost:8000/chapter-5/model-form-class/2/`,
    and you should see the form preloaded with the values found in the database for
    that Vehicle, as depicted in the following screenshot:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，导航到URL `http://localhost:8000/chapter-5/model-form-class/2/`，你应该会看到预先加载了数据库中该车辆的值的表单，如图下所示：
- en: '![Figure 5.6 – VehicleForm using ModelFormClassUpdateView'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6 – 使用ModelFormClassUpdateView的VehicleForm'
- en: '](img/Figure_5.6_B17243.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6](img/Figure_5.6_B17243.jpg)'
- en: Figure 5.6 – VehicleForm using ModelFormClassUpdateView
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 使用 ModelFormClassUpdateView 的 VehicleForm
- en: We once again use the same two `get()` and `post()` methods. One minor difference
    in how we are writing the `get()` method here is that we are performing the `Vehicle`
    query. We use a `try/except` statement to determine whether the object exists
    in the database using `vehicle = Vehicle.objects.get(pk=id)`. If it does not exist,
    we create the form object as a blank form using `form = self.form_class()`. If
    the `Vehicle` object is found, then we pass that instance into the form that we
    are initializing, using `form = self.form_class(instance=vehicle)`. The `post()`
    method is written the same as what we wrote for `ModelFormClassCreateView`, except
    that we updated the context string variables to reflect this class name.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用相同的两个 `get()` 和 `post()` 方法。在这里编写 `get()` 方法的一个细微差别是我们正在执行 `Vehicle` 查询。我们使用
    `try/except` 语句来确定对象是否存在于数据库中，使用 `vehicle = Vehicle.objects.get(pk=id)`。如果不存在，我们使用
    `form = self.form_class()` 创建一个空白表单对象。如果找到 `Vehicle` 对象，则将此实例传递给我们要初始化的表单，使用 `form
    = self.form_class(instance=vehicle)`。`post()` 方法的编写与为 `ModelFormClassCreateView`
    编写的方法相同，只是我们更新了上下文字符串变量以反映此类名称。
- en: Note
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When working with fields that have an attribute of `unique = True` and saving
    that object in a form using the `UpdateView` class, you may get a postback error
    message telling you that the object already exists. To get around this, try removing
    the `unique` attribute on your model and implementing your own `clean()` method
    to enforce that uniqueness. There are also several other approaches to solve this
    while keeping the `unique` attribute; all are rather difficult to implement and
    go beyond the scope of this chapter. Practice building a form to update the `Engine`
    class on your own that does not contain a `unique` field.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 当与具有 `unique = True` 属性的字段一起工作并使用 `UpdateView` 类保存该对象时，你可能会收到一个回发错误消息，告诉你该对象已存在。为了解决这个问题，尝试从你的模型中移除
    `unique` 属性并实现你自己的 `clean()` 方法来强制执行唯一性。还有其他几种方法可以在保持 `unique` 属性的同时解决这个问题；所有这些方法都相当难以实现，并且超出了本章的范围。请尝试自己构建一个不包含
    `unique` 字段的表单来更新 `Engine` 类。
- en: Let's add inline formsets next.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加内联表单集。
- en: Adding inline formsets
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加内联表单集
- en: An inline formset is a form within a form. It's a way to provide dynamic fields,
    for example, for additional personnel, comments, or objects. They are commonly
    used in combination with JavaScript code on the frontend to create or remove sets
    of fields as desired by the user. In the next exercise, we will expand upon the
    `ModelFormClassCreateView` class to add our inline formset. This formset will
    capture prospective buyer information, to capture the first and last name of that
    lead. We will create an **Add Another** button for the user to add as many prospective
    buyers as they would like to. JavaScript is used to control creating and/or deleting
    the new DOM objects. It will also update the Django management form data in the
    process. You can build upon this concept to make your form more robust with added
    fields and controls for the user to manipulate inline formsets.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 内联表单集是在表单内的表单。这是一种提供动态字段的方式，例如，用于额外的人员、评论或对象。它们通常与前端上的 JavaScript 代码结合使用，以根据用户的需求创建或删除字段集。在下一个练习中，我们将扩展
    `ModelFormClassCreateView` 类以添加我们的内联表单集。此表单集将捕获潜在买家的信息，以捕获该潜在买家的姓名和姓氏。我们将为用户创建一个
    **添加另一个** 按钮，以便他们可以添加他们想要的任何数量的潜在买家。JavaScript 用于控制创建和/或删除新的 DOM 对象。它还将在此过程中更新
    Django 管理表单数据。你可以在此基础上添加字段和控件来使你的表单更健壮，并允许用户操作内联表单集。
- en: Follow the steps in the following sections to get started with inline formsets.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下章节中的步骤开始使用内联表单集。
- en: Formset function – formset_factory
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Formset 函数 – formset_factory
- en: A **formset factory** is a controller that we use to register inline formsets.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**表单集工厂** 是我们用来注册内联表单集的控制器。'
- en: 'Follow these steps to create your formset factory:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建你的表单集工厂：
- en: 'In the `/chapter_5/forms.py` file, add the following `ProspectiveBuyerForm`
    class, which will act as the inline form, capturing the first and last name of
    the prospective buyer:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/chapter_5/forms.py` 文件中，添加以下 `ProspectiveBuyerForm` 类，它将作为内联表单，捕获潜在买家的姓名和姓氏：
- en: '[PRE166]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: We are doing nothing different in the `ProspectiveBuyerForm` class in the preceding
    code compared to what we did in `ContactForm` before. The same concepts and validation
    measures apply to the fields within an inline formset. Adjust the logic as necessary
    for your fields.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在 `ProspectiveBuyerForm` 类中与在之前的 `ContactForm` 中所做的不同之处在于没有进行任何不同的操作。相同的概念和验证措施适用于内联表单集中的字段。根据您的字段需要调整逻辑。
- en: 'In the same `/chapter_5/forms.py` file, register that form as `formset_factory`
    using the following example. Make sure to place the `ProspectiveBuyerFormSet`
    class below the `ProspectiveBuyerForm` class in this file:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的 `/chapter_5/forms.py` 文件中，使用以下示例将表单注册为 `formset_factory`。确保在这个文件中将 `ProspectiveBuyerFormSet`
    类放在 `ProspectiveBuyerForm` 类下方：
- en: '[PRE167]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'In the preceding example, we registered the `ProspectiveBuyerForm` class in
    a formset factory called `ProspectiveBuyerFormset`, which we will use next in
    our view class. The `extra = 1` argument is used to include only one instance
    of this formset when this `formset_factory` is first initialized. There are many
    other options available, and they are all explained in detail here: [https://docs.djangoproject.com/en/4.0/topics/forms/formsets/](https://docs.djangoproject.com/en/4.0/topics/forms/formsets/).'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们在一个名为 `ProspectiveBuyerFormset` 的表单集工厂中注册了 `ProspectiveBuyerForm`
    类，我们将在视图类中使用它。`extra = 1` 参数用于在首次初始化 `formset_factory` 时只包含该表单集的一个实例。这里有许多其他选项，它们都在这里进行了详细解释：[https://docs.djangoproject.com/en/4.0/topics/forms/formsets/](https://docs.djangoproject.com/en/4.0/topics/forms/formsets/).
- en: Note
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, we are using a standard `formset_factory` for a form with fields
    that are not linked to a model. Formsets that do link to models would use the
    `modelformset_factory()` method to link form fields to a model in your database.
    When using that method, data is saved in the view class the same way as when we
    saved the `VehicleForm` data.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用标准的 `formset_factory` 为一个没有与模型链接的字段表单。与模型链接的表单集将使用 `modelformset_factory()`
    方法将表单字段链接到数据库中的模型。当使用该方法时，数据在视图类中的保存方式与保存 `VehicleForm` 数据的方式相同。
- en: Let's use this inline formset in a view class next.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在视图类中使用这个内联表单集。
- en: Using inline formsets in the view class
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在视图类中使用内联表单集
- en: 'Follow these steps to use your newly created inline formset in a view class:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在视图类中使用您新创建的内联表单集：
- en: 'In your `/chapter_5/views.py` file, in the existing `ModelFormClassCreateView`
    class, add a few minor adjustments to the existing `get()` method, as highlighted
    in the following code:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `/chapter_5/views.py` 文件中，在现有的 `ModelFormClassCreateView` 类中，对现有的 `get()`
    方法进行一些小的调整，如下所示：
- en: '[PRE168]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'In the same `ModelFormClassCreateView` class, add a few minor adjustments to
    the existing `post()` method, as highlighted in the following code:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的 `ModelFormClassCreateView` 类中，对现有的 `post()` 方法进行一些小的调整，如下所示：
- en: '[PRE169]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: In the preceding steps, we are passing the inline `ProspectiveBuyerFormset`
    formset into the template as an additional context variable called `buyer_formset`.
    This and the form object should always be thought of as entirely separate objects.
    The form and the formset can also be related if they are using `ForeignKey`, `ManyToMany`,
    or `OneToOne` model relations.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，我们将内联 `ProspectiveBuyerFormset` 表单集作为名为 `buyer_formset` 的额外上下文变量传递到模板中。这个表单和表单集应该始终被视为完全独立的对象。如果它们使用
    `ForeignKey`、`ManyToMany` 或 `OneToOne` 模型关系，表单和表单集也可以相关联。
- en: Let's render these inline formsets into a template next.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些内联表单集渲染到模板中。
- en: Rendering inline formsets in the template
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模板中渲染内联表单集
- en: 'To render your newly created inline formsets into a template file, in your
    `/chapter_5/model-form-class.html` file, include all of the nodes, class names,
    and IDs that exist, as shown in the following code:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 要将您新创建的内联表单集渲染到模板文件中，在您的 `/chapter_5/model-form-class.html` 文件中，包括所有存在的节点、类名和
    ID，如下所示：
- en: '[PRE170]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: The JavaScript we will soon write will depend on this structure, and as your
    structure changes, be sure to change your JavaScript as well. In the preceding
    code, the important parts of the form include the ID attribute of the form itself,
    called `id="form"`. We will use that to target the form as a whole in the JavaScript
    we are going to write. A conditional is used to check whether the `buyer_formset`
    variable exists before we do anything with it. For example, if you wanted to serve
    up an instance of this page that has no formsets at all, then this conditional
    will prevent breakage.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将编写的JavaScript将依赖于这个结构，并且当你的结构发生变化时，请确保也更改你的JavaScript。在前面代码中，表单的重要部分包括表单本身的ID属性，称为`id="form"`。我们将使用它来在即将编写的JavaScript中作为整体定位表单。使用条件检查在对其进行任何操作之前`buyer_formset`变量是否存在。例如，如果你想提供一个没有任何表单集的页面实例，那么这个条件将防止破坏。
- en: An important feature to never forget to include is the management form data,
    which is added using the `{{ buyer_formset.management_form }}` tag. This will
    include important data that Django needs to process your inline formsets. We then
    loop through each form in the `buyer_formset` object using `{% for form in buyer_formset
    %}`. For each form that does exist, we wrap all of the internal HTML in a node
    called `<div class="formset-container"></div>`. This class is important as it
    will differentiate between each inline form when we work with JavaScript. Inside,
    you can structure your fields however you like. Lastly, outside of the loop, just
    before the submit button, we need to add a new `<button>` of `type="button"` to
    prevent accidentally submitting the form. Give that button an attribute of `id="add-formset"`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的特性是永远不要忘记包括管理表单数据，这是通过使用`{{ buyer_formset.management_form }}`标签添加的。这将包括Django处理你的内联表单集所需的重要数据。然后我们使用`{%
    for form in buyer_formset %}`遍历`buyer_formset`对象中的每个表单。对于每个存在的表单，我们将所有内部HTML包裹在一个名为`<div
    class="formset-container"></div>`的节点中。这个类很重要，因为它将在我们使用JavaScript处理每个内联表单时区分它们。在内部，你可以按你喜欢的方式结构化你的字段。最后，在循环外部，就在提交按钮之前，我们需要添加一个`type="button"`的新`<button>`，以防止意外提交表单。给这个按钮一个属性`id="add-formset"`。
- en: 'Now, visit the same URL that we went to before, to add a new vehicle at `http://localhost:8000/chapter-5/model-form-class/`.
    You should see a form resembling the following:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，访问我们之前访问的相同URL，在`http://localhost:8000/chapter-5/model-form-class/`添加一个新的车辆。你应该看到一个类似于以下表单的界面：
- en: '![Figure 5.7 – VehicleForm inline formset'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.7 – VehicleForm内联表单集](img/Figure_5.7_B17243.jpg)'
- en: '](img/Figure_5.7_B17243.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.7 – VehicleForm inline formset](img/Figure_5.7_B17243.jpg)'
- en: Figure 5.7 – VehicleForm inline formset
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – VehicleForm内联表单集
- en: There will only be one instance of the prospective buyer for now. Next, we will
    add the JavaScript controls that let us add more instances to this form.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 目前只有一个潜在买家的实例。接下来，我们将添加JavaScript控件，使我们能够向此表单添加更多实例。
- en: Dynamic inline formsets
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态内联表单集
- en: 'Follow these steps to configure the JavaScript needed to let the user add more
    instances of an inline formset:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置JavaScript，以便用户可以添加更多内联表单集的实例：
- en: 'In your `/chapter_5/base/base_template_1.html` file, there is already a reference
    to a JavaScript file in the `<head>` of that document. Make sure the following
    script is included in your `<head>` of that document:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`/chapter_5/base/base_template_1.html`文件中，`<head>`部分已经引用了一个JavaScript文件。确保以下脚本包含在该文档的`<head>`中：
- en: '[PRE199]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: This will load a single JavaScript file that is used to make a form interactive
    and lets the user add another instance of the inline `ProspectiveBuyerFormset`
    formset.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载一个用于使表单交互并允许用户添加另一个`ProspectiveBuyerFormset`内联表单集实例的单个JavaScript文件。
- en: 'If you didn''t already copy the JavaScript files when copying the `base_template_1.html`
    file earlier in preparation for a previous exercise, then go ahead and create
    the `/chapter_5/static/chapter_5/` and `/chapter_5/static/chapter_5/js/` folders
    and the `site-js.js` file using your IDE, File Explorer, or the following commands:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你之前在准备之前的练习时没有复制JavaScript文件，那么现在请创建`/chapter_5/static/chapter_5/`和`/chapter_5/static/chapter_5/js/`文件夹以及`site-js.js`文件，使用你的IDE、文件资源管理器或以下命令：
- en: '[PRE200]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Inside your `/chapter_5/js/site-js.js` file, include the following variables:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`/chapter_5/js/site-js.js`文件中，包括以下变量：
- en: '[PRE201]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Add the following event listener to that same JavaScript file:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下事件监听器添加到同一个JavaScript文件中：
- en: '[PRE202]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Add the following function to that same JavaScript file:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数添加到同一个JavaScript文件中：
- en: '[PRE203]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: What we are doing is adding an event listener that listens for the click event
    of the `<div class="formset-container"></div>` and insert that cloned node just
    before the `<button id="add-formset"></button>` node. Since Django also requires
    the precise management of form data, we need to be sure that we update the relevant
    data every time an inline formset is added or removed. This is why we are finding
    the number of inline formsets that exist before we perform the clone action as
    the `formsetNum` variable. Then, we increment this number, which starts at index
    0, using a regular expression method to search all the inner HTML nodes of the
    node with the `formset-container` CSS class. That incremented number is used to
    update all node attributes to the proper index of the new node that we inserted.
    We also update the value of the form object with `id="id_form-TOTAL_FORMS"` to
    the new total of inline formsets that exist.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是添加一个事件监听器，监听`<div class="formset-container"></div>`的点击事件，并在`<button id="add-formset"></button>`节点之前插入克隆的节点。由于Django也需要精确管理表单数据，我们需要确保每次添加或删除内联表单集时都更新相关数据。这就是为什么我们在执行克隆操作之前找到存在的内联表单集数量作为`formsetNum`变量。然后，我们使用正则表达式方法搜索具有`formset-container`
    CSS类的节点的所有内部HTML节点，来增加这个数字，它从索引0开始。这个增加的数字用于更新所有节点属性到新插入的节点正确的索引。我们还更新了表单对象的值，将`id="id_form-TOTAL_FORMS"`更新为新存在的内联表单集总数。
- en: 'If successful, when we click the **Add Another Prospective Buyer** button,
    we should see additional inline formsets added, just like the following:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，当我们点击**添加另一个潜在买家**按钮时，我们应该看到添加了额外的内联表单集，就像以下这样：
- en: '![Figure 5.8 – VehicleForm adding another inline formset'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.8 – VehicleForm 添加另一个内联表单集'
- en: '](img/Figure_5.8_B17243.jpg)'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 5.8 - VehicleForm 添加另一个内联表单集](img/Figure_5.8_B17243.jpg)'
- en: Figure 5.8 – VehicleForm adding another inline formset
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – VehicleForm 添加另一个内联表单集
- en: Summary
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: By now, we have completed two major forms, one to act as the contact form and
    another to handle the vehicle object, created in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077),
    *Models, Relations, and Inheritance*. We added a variety of fields and discussed
    the differences between those field types. Using the email example over and over
    again as we did, we witnessed how validation works in many different ways. Depending
    on the requirements gathered for a project, we can then decide on several different
    writing patterns to align with those requirements. For example, if we wanted to
    completely eliminate the need for JavaScript validation, such as using my favorite
    library jQuery Validate, we could just write clean methods in form classes to
    perform all of the validation on the backend. This would use the power of Django
    to serve up the error messages. However, if we did use JavaScript-based validation
    on the frontend, we could write fields that create the node attributes for us,
    such as the `<input>` field attribute of `required=""`, which would prevent a
    form from submitting if it had no value.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了两个主要表单，一个用作联系表单，另一个用于处理在[*第3章*](B17243_03_ePub.xhtml#_idTextAnchor077)中创建的车辆对象，*模型、关系和继承*。我们添加了各种字段，并讨论了这些字段类型之间的差异。通过反复使用电子邮件示例，我们见证了验证以多种不同的方式工作。根据为项目收集的需求，我们可以决定采用几种不同的编写模式来满足这些需求。例如，如果我们想完全消除JavaScript验证的需求，比如使用我最喜欢的库jQuery
    Validate，我们可以在表单类中编写干净的方法来在后端执行所有验证。这将利用Django来提供错误消息。然而，如果我们确实在前端使用了基于JavaScript的验证，我们可以编写创建为我们创建节点属性的字段，例如`<input>`字段的`required=""`属性，这将防止表单在没有值的情况下提交。
- en: No matter the requirements of a project, we also discovered a really easy way
    to create our own field classes. Custom field classes let us preformat fields
    that support a **Don't Repeat Yourself** (**DRY**) style of writing. We explored
    the differences in view classes, form classes, and field classes, and then discussed
    ways to render those forms in a template.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 无论项目的需求如何，我们也发现了一种非常简单的方法来创建我们自己的字段类。自定义字段类让我们可以预先格式化支持**不要重复自己**（**DRY**）风格的字段。我们探讨了视图类、表单类和字段类的差异，然后讨论了在模板中渲染这些表单的方法。
- en: In the next chapter, we will explore a user interface specifically tailored
    for the rapid development of forms that lets users update, create, and delete
    model objects on their own. This is called the Django admin site, which is basically
    a glorified way to render forms related to model management.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一个专门针对快速开发表单的用户界面，允许用户自行更新、创建和删除模型对象。这被称为Django管理站点，基本上是一种美化了的渲染与模型管理相关表单的方式。
