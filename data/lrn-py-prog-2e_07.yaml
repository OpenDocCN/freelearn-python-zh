- en: Files and Data Persistence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件和数据持久化
- en: '"Persistence is the key to the adventure we call life." – Torsten Alexander
    Lange'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '"持久是我们称之为生活的冒险的关键。" - Torsten Alexander Lange'
- en: In the previous chapters, we have explored several different aspects of Python.
    As the examples have a didactic purpose, we've run them in a simple Python shell,
    or in the form of a Python module. They ran, maybe printed something on the console,
    and then they terminated, leaving no trace of their brief existence.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们已经探讨了Python的几个不同方面。由于示例具有教学目的，我们在简单的Python shell中运行它们，或者以Python模块的形式运行。它们运行，可能在控制台上打印一些内容，然后终止，不留下它们短暂存在的痕迹。
- en: Real-world applications though are generally much different. Naturally, they
    still run in memory, but they interact with networks, disks, and databases. They
    also exchange information with other applications and devices, using formats that
    are suitable for the situation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界的应用通常大不相同。当然，它们仍然在内存中运行，但它们与网络、磁盘和数据库进行交互。它们还使用适合情况的格式与其他应用程序和设备交换信息。
- en: 'In this chapter, we are going to start closing in to the real world by exploring
    the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始接近真实世界，探索以下内容：
- en: Files and directories
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件和目录
- en: Compression
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩
- en: Networks and streams
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络和流
- en: The JSON data-interchange format
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON数据交换格式
- en: Data persistence with pickle and shelve, from the standard library
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pickle和shelve进行数据持久化，来自标准库
- en: Data persistence with SQLAlchemy
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SQLAlchemy进行数据持久化
- en: As usual, I will try to balance breadth and depth, so that by the end of the
    chapter, you will have a solid grasp of the fundamentals and will know how to
    fetch further information on the web.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我会努力平衡广度和深度，以便在本章结束时，您将对基本原理有扎实的理解，并且将知道如何在网络上获取更多信息。
- en: Working with files and directories
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件和目录
- en: When it comes to files and directories, Python offers plenty of useful tools.
    In particular, in the following examples, we will leverage the `os` and `shutil` modules.
    As we'll be reading and writing on the disk, I will be using a file, `fear.txt`,
    which contains an excerpt from *Fear*, by Thich Nhat Hanh, as a guinea pig for
    some of our examples.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理文件和目录时，Python提供了许多有用的工具。特别是在以下示例中，我们将利用`os`和`shutil`模块。由于我们将在磁盘上读写，我将使用一个名为`fear.txt`的文件，其中包含了《恐惧》（Thich
    Nhat Hanh著）的摘录，作为我们的一些示例的试验品。
- en: Opening files
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开文件
- en: 'Opening a file in Python is very simple and intuitive. In fact, we just need
    to use the `open` function. Let''s see a quick example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中打开文件非常简单和直观。实际上，我们只需要使用`open`函数。让我们看一个快速的例子：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The previous code is very simple. We call `open`, passing the filename, and
    telling `open` that we want to read it in text mode. There is no path information
    before the filename; therefore, `open` will assume the file is in the same folder
    the script is run from. This means that if we run this script from outside the
    `files` folder, then `fear.txt` won't be found.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码非常简单。我们调用`open`，传递文件名，并告诉`open`我们要以文本模式读取它。文件名之前没有路径信息；因此，`open`将假定文件在运行脚本的同一文件夹中。这意味着如果我们从`files`文件夹外部运行此脚本，那么`fear.txt`将找不到。
- en: Once the file has been opened, we obtain a file object back, `fh`, which we
    can use to work on the content of the file. In this case, we use the `readlines()`
    method to iterate over all the lines in the file, and print them. We call `strip()`
    on each line to get rid of any extra spaces around the content, including the
    line termination character at the end, since `print` will already add one for
    us. This is a quick and dirty solution that works in this example, but should
    the content of the file contain meaningful spaces that need to be preserved, you
    will have to be slightly more careful in how you sanitize the data. At the end
    of the script, we flush and close the stream.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件被打开，我们就会得到一个文件对象`fh`，我们可以用它来处理文件的内容。在这种情况下，我们使用`readlines()`方法来迭代文件中的所有行，并打印它们。我们对每一行调用`strip()`来去除内容周围的任何额外空格，包括末尾的行终止字符，因为`print`会为我们添加一个。这是一个快速而粗糙的解决方案，在这个例子中有效，但是如果文件的内容包含需要保留的有意义的空格，那么您将需要在清理数据时稍微小心。在脚本的结尾，我们刷新并关闭流。
- en: 'Closing a file is very important, as we don''t want to risk failing to release
    the handle we have on it. Therefore, we need to apply some precaution, and wrap
    the previous logic in a `try`/`finally` block. This has the effect that, whatever
    error might occur while we try to open and read the file, we can rest assured
    that `close()` will be called:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭文件非常重要，因为我们不希望冒着无法释放对文件的控制的风险。因此，我们需要采取一些预防措施，并将前面的逻辑包装在`try`/`finally`块中。这样做的效果是，无论我们尝试打开和读取文件时可能发生什么错误，我们都可以放心地确保`close()`会被调用：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The logic is exactly the same, but now it is also safe.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑完全相同，但现在也是安全的。
- en: Don't worry if you don't understand `try`/`finally` for now. We will explore
    how to deal with exceptions in the next chapter. For now, suffice to say that
    putting code within the body of a `try` block adds a mechanism around that code
    that allows us to detect errors (which are called *exceptions*) and decide what
    to do if they happen. In this case, we don't really do anything in case of errors,
    but by closing the file within the `finally` block, we make sure that line is
    executed whether or not any error has happened.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在不理解`try`/`finally`，不要担心。我们将在下一章中探讨如何处理异常。现在，可以说在`try`块的主体中放置代码会为该代码添加一个机制，允许我们检测错误（称为*异常*）并决定发生错误时该怎么办。在这种情况下，如果发生错误，我们实际上不做任何事情，但是通过在`finally`块中关闭文件，我们确保该行无论是否发生错误都会被执行。
- en: 'We can simplify the previous example this way:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式简化前面的示例：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, `rt` is the default mode for opening files, so we don't need
    to specify it. Moreover, we can simply iterate on `fh`, without explicitly calling `readlines()`
    on it. Python is very nice and gives us shorthands to make our code shorter and
    simpler to read.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`rt`是打开文件的默认模式，因此我们不需要指定它。此外，我们可以直接在`fh`上进行迭代，而不需要显式调用`readlines()`。Python非常友好，为我们提供了简写，使我们的代码更短，更容易阅读。
- en: 'All the previous examples produce a print of the file on the console (check
    out the source code to read the whole content):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的示例都会在控制台上打印文件的内容（查看源代码以阅读整个内容）：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using a context manager to open a file
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文管理器打开文件
- en: 'Let''s admit it: the prospect of having to disseminate our code with `try`/`finally`
    blocks is not one of the best. As usual, Python gives us a much nicer way to open
    a file in a secure fashion: by using a c*ontext manager*. Let''s see the code
    first:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们承认吧：不得不使用`try`/`finally`块来传播我们的代码并不是最好的选择。通常情况下，Python给我们提供了一种更好的方式以安全的方式打开文件：使用上下文管理器。让我们先看看代码：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The previous example is equivalent to the one before it, but reads so much better.
    The `with` statement supports the concept of a runtime context defined by a context
    manager. This is implemented using a pair of methods, `__enter__` and `__exit__`,
    that allow user-defined classes to define a runtime context that is entered before
    the statement body is executed and exited when the statement ends. The `open`
    function is capable of producing a file object when invoked by a context manager,
    but the true beauty of it lies in the fact that `fh.close()` will be called automatically
    for us, even in case of errors.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例等同于前面的一个示例，但读起来更好。`with`语句支持由上下文管理器定义的运行时上下文的概念。这是使用一对方法`__enter__`和`__exit__`实现的，允许用户定义的类定义在执行语句体之前进入的运行时上下文，并在语句结束时退出。`open`函数在由上下文管理器调用时能够产生一个文件对象，但它真正的美妙之处在于`fh.close()`将会自动为我们调用，即使在出现错误的情况下也是如此。
- en: Context managers are used in several different scenarios, such as thread synchronization,
    closure of files or other objects, and management of network and database connections.
    You can find information about them in the `contextlib` documentation page ([https://docs.python.org/3.7/library/contextlib.html](https://docs.python.org/3.7/library/contextlib.html)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器在多种不同的场景中使用，比如线程同步、文件或其他对象的关闭，以及网络和数据库连接的管理。你可以在`contextlib`文档页面中找到关于它们的信息（[https://docs.python.org/3.7/library/contextlib.html](https://docs.python.org/3.7/library/contextlib.html)）。
- en: Reading and writing to a file
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读写文件
- en: 'Now that we know how to open a file, let''s see a couple of different ways
    that we have to read and write to it:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何打开文件了，让我们看看我们有几种不同的方式可以读写文件：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A first approach uses the `print` function, which you've seen plenty of times
    in the previous chapters. After obtaining a file object, this time specifying
    that we intend to write to it ("`w`"), we can tell the call to `print` to direct
    its effects on the file, instead of the default `sys.stdout`, which, when executed
    on a console, is mapped to it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法使用了`print`函数，你在前几章中已经见过很多次。在获取文件对象之后，这次指定我们打算向其写入（"`w`"），我们可以告诉`print`调用将其效果定向到文件，而不是默认的`sys.stdout`，当在控制台上执行时，它会映射到它。
- en: The previous code has the effect of creating the `print_example.txt` file if
    it doesn't exist, or truncate it in case it does, and writes the line `Hey I am
    printing into a file!!!` to it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码的效果是，如果`print_example.txt`文件不存在，则创建它，或者如果存在，则将其截断，并将行`Hey I am printing
    into a file!!!`写入其中。
- en: 'This is all nice and easy, but not what we typically do when we want to write
    to a file. Let''s see a much more common approach:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单易懂，但并不是我们通常写文件时所做的。让我们看一个更常见的方法：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the previous example, we first open `fear.txt` and collect its content into
    a list, line by line. Notice that this time, I'm calling a more precise method, `rstrip()`,
    as an example, to make sure I only strip the whitespace on the right-hand side
    of every line.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们首先打开`fear.txt`并逐行将其内容收集到一个列表中。请注意，这次我调用了一个更精确的方法`rstrip()`，作为一个例子，以确保我只去掉每行右侧的空白。
- en: In the second part of the snippet, we create a new file, `fear_copy.txt`, and
    we write to it all the lines from the original file, joined by a newline, `\n`.
    Python is gracious and works by default with *universal newlines*, which means
    that even though the original file might have a newline that is different than `\n`,
    it will be translated automatically for us before the line is returned. This behavior
    is, of course, customizable, but normally it is exactly what you want. Speaking
    of newlines, can you think of one of them that might be missing in the copy?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段的第二部分中，我们创建了一个新文件`fear_copy.txt`，并将原始文件中的所有行写入其中，用换行符`\n`连接起来。Python很慷慨，并且默认使用*通用换行符*，这意味着即使原始文件的换行符可能与`\n`不同，它也会在返回行之前自动转换为我们。当然，这种行为是可以自定义的，但通常它正是你想要的。说到换行符，你能想到副本中可能缺少的换行符吗？
- en: Reading and writing in binary mode
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读写二进制模式
- en: Notice that by opening a file passing `t` in the options (or omitting it, as
    it is the default), we're opening the file in text mode. This means that the content
    of the file is treated and interpreted as text. If you wish to write bytes to
    a file, you can open it in binary mode. This is a common requirement when you
    deal with files that don't just contain raw text, such as images, audio/video,
    and, in general, any other proprietary format.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过在选项中传递`t`来打开文件（或者省略它，因为它是默认值），我们是以文本模式打开文件。这意味着文件的内容被视为文本进行处理和解释。如果你希望向文件写入字节，可以以二进制模式打开它。当你处理不仅包含原始文本的文件时，这是一个常见的要求，比如图像、音频/视频以及一般的任何其他专有格式。
- en: 'In order to handle files in binary mode, simply specify the `b` flag when opening
    them, as in the following example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理二进制模式的文件，只需在打开它们时指定`b`标志，就像以下示例中所示：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, I'm still using text as binary data, but it could be anything
    you want. You can see it's treated as a binary by the fact that you get the `b'This
    ...'` prefix in the output.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我仍然使用文本作为二进制数据，但它可以是任何你想要的。你可以看到它被视为二进制数据的事实，因为在输出中你会得到`b'This ...'`前缀。
- en: Protecting against overriding an existing file
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止覆盖现有文件
- en: 'Python gives us the ability to open files for writing. By using the `w` flag,
    we open a file and truncate its content. This means the file is overwritten with
    an empty file, and the original content is lost. If you wish to only open a file
    for writing in case it doesn''t exist, you can use the `x` flag instead, in the
    following example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许我们打开文件进行写入。通过使用`w`标志，我们打开一个文件并截断其内容。这意味着文件被覆盖为一个空文件，原始内容丢失。如果您希望仅在文件不存在时打开文件进行写入，可以在下面的示例中使用`x`标志：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you run the previous snippet, you will find a file called `write_x.txt`
    in your directory, containing only one line of text. The second part of the snippet,
    in fact, fails to execute. This is the output I get on my console:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行前面的片段，您将在目录中找到一个名为`write_x.txt`的文件，其中只包含一行文本。事实上，片段的第二部分未能执行。这是我在控制台上得到的输出：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Checking for file and directory existence
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查文件和目录的存在
- en: 'If you want to make sure a file or directory exists (or it doesn''t), the `os.path`
    module is what you need. Let''s see a small example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想确保文件或目录存在（或不存在），则需要使用`os.path`模块。让我们看一个小例子：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding snippet is quite interesting. After declaring the filename with
    a relative reference (in that it is missing the path information), we use `abspath`
    to calculate the full, absolute path of the file. Then, we get the path information
    (by removing the filename at the end) by calling `dirname` on it. The result,
    as you can see, is printed on the last line. Notice also how we check for existence,
    both for a file and a directory, by calling `isfile` and `isdir`. In the `os.path`
    module, you find all the functions you need to work with pathnames.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段非常有趣。在使用相对引用声明文件名之后（因为缺少路径信息），我们使用`abspath`来计算文件的完整绝对路径。然后，我们通过调用`dirname`来获取路径信息（删除末尾的文件名）。正如您所看到的，结果在最后一行打印出来。还要注意我们如何通过调用`isfile`和`isdir`来检查文件和目录的存在。在`os.path`模块中，您可以找到处理路径名所需的所有函数。
- en: Should you ever need to work with paths in a different way, you can check out `pathlib`.
    While `os.path` works with strings, `pathlib` offers classes representing filesystem
    paths with semantics appropriate for different operating systems. It is beyond
    the scope of this chapter, but if you're interested, check out PEP428 ([https://www.python.org/dev/peps/pep-0428/](https://www.python.org/dev/peps/pep-0428/)),
    and its page in the standard library.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要以不同的方式处理路径，可以查看`pathlib`。虽然`os.path`使用字符串，但`pathlib`提供了表示适合不同操作系统语义的文件系统路径的类。这超出了本章的范围，但如果您感兴趣，请查看PEP428（[https://www.python.org/dev/peps/pep-0428/](https://www.python.org/dev/peps/pep-0428/)）以及标准库中的页面。
- en: Manipulating files and directories
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作文件和目录
- en: 'Let''s see a couple of quick examples on how to manipulate files and directories.
    The first example manipulates the content:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看几个快速示例，演示如何操作文件和目录。第一个示例操作内容：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The previous example defines two functions: `sanitize` and `reverse`. They are
    simple functions whose purpose is to remove anything that is not a letter or space
    from a string, and produce the reversed copy of a string, respectively.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例定义了两个函数：`sanitize`和`reverse`。它们是简单的函数，其目的是从字符串中删除任何不是字母或空格的内容，并分别生成字符串的反向副本。
- en: 'We open `fear.txt` and we read its content into a list. Then we create a new
    file, `raef.txt`, which will contain the horizontally-mirrored version of the
    original one. We write all the content of `lines` with a single operation, using `join`
    on a new line character. Maybe more interesting, is the bit in the end. First,
    we reassign `lines` to a sanitized version of itself, by means of list comprehension.
    Then we put them together in the `whole` string, and finally, we pass the result
    to `Counter`. Notice that we split the string and put it in lowercase. This way,
    each word will be counted correctly, regardless of its case, and, thanks to `split`,
    we don''t need to worry about extra spaces anywhere. When we print the three most
    common words, we realize that truly Thich Nhat Hanh''s focus is on others, as
    `we` is the most common word in the text:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开`fear.txt`并将其内容读入列表。然后我们创建一个新文件`raef.txt`，其中包含原始文件的水平镜像版本。我们使用`join`在新行字符上写入`lines`的所有内容。也许更有趣的是最后的部分。首先，我们通过列表推导将`lines`重新分配为其经过清理的版本。然后我们将它们放在`whole`字符串中，最后将结果传递给`Counter`。请注意，我们拆分字符串并将其转换为小写。这样，每个单词都将被正确计数，而不管其大小写如何，并且由于`split`，我们不需要担心任何额外的空格。当我们打印出最常见的三个单词时，我们意识到真正的Thich
    Nhat Hanh的重点在于其他人，因为`we`是文本中最常见的单词：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s now see an example of manipulation more oriented to disk operations,
    in which we put the `shutil` module to use:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个更加面向磁盘操作的操作示例，其中我们使用`shutil`模块：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previous code, we start by declaring a base path, which will safely contain
    all the files and folders we're going to create. We then use `makedirs` to create
    two directories: `ops_example/A/B` and `ops_example/A/C`. (Can you think of a
    way of creating the two directories by using `map`?).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先声明一个基本路径，该路径将安全地包含我们将要创建的所有文件和文件夹。然后我们使用`makedirs`创建两个目录：`ops_example/A/B`和`ops_example/A/C`。（您能想到使用`map`来创建这两个目录的方法吗？）。
- en: We use `os.path.join` to concatenate directory names, as using `/` would specialize
    the code to run on a platform where the directory separator is `/`, but then the
    code would fail on platforms with a different separator. Let's delegate to `join`
    the task to figure out which is the appropriate separator.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`os.path.join`来连接目录名称，因为使用`/`会使代码专门运行在目录分隔符为`/`的平台上，但是代码将在具有不同分隔符的平台上失败。让我们委托给`join`来确定适当的分隔符。
- en: 'After creating the directories, within a simple `for` loop, we put some code
    that creates three files in directory `B`. Then, we move the folder `B` and its
    content to a different name: `D`. And finally, we rename `ex1.txt` to `ex1d.txt`.
    If you open that file, you''ll see it still contains the original text from the `for`
    loop. Calling `tree` on the result produces the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 创建目录后，在一个简单的`for`循环中，我们放入一些代码，创建目录`B`中的三个文件。然后，我们将文件夹`B`及其内容移动到另一个名称：`D`。最后，我们将`ex1.txt`重命名为`ex1d.txt`。如果您打开该文件，您会看到它仍然包含来自`for`循环的原始文本。对结果调用`tree`会产生以下结果：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Manipulating pathnames
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作路径名
- en: 'Let''s explore a little more the abilities of `os.path` by means of a simple
    example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来更多地探索`os.path`的能力：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Reading the result is probably a good enough explanation for this simple example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读结果可能是对这个简单例子的足够好的解释：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Temporary files and directories
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 临时文件和目录
- en: 'Sometimes, it''s very useful to be able to create a temporary directory or
    file when running some code. For example, when writing tests that affect the disk,
    you can use temporary files and directories to run your logic and assert that
    it''s correct, and to be sure that at the end of the test run, the test folder
    has no leftovers. Let''s see how you do it in Python:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在运行一些代码时，能够创建临时目录或文件非常有用。例如，在编写影响磁盘的测试时，您可以使用临时文件和目录来运行您的逻辑并断言它是正确的，并确保在测试运行结束时，测试文件夹中没有剩余物品。让我们看看在Python中如何做到这一点：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding example is quite straightforward: we create a temporary directory
    in the current one ("`.`"), and we create a named temporary file in it. We print
    the filename, as well as its full path:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子非常简单：我们在当前目录（“.”）中创建一个临时目录，并在其中创建一个命名临时文件。我们打印文件名以及其完整路径：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Running this script will produce a different result every time. After all, it's
    a temporary random name we're creating here, right?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本将每次产生不同的结果。毕竟，这里我们创建的是一个临时随机名称，对吧？
- en: Directory content
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录内容
- en: 'With Python, you can also inspect the content of a directory. I''ll show you
    two ways of doing this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python，您还可以检查目录的内容。我将向您展示两种方法：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This snippet uses `os.scandir`, called on the current directory. We iterate
    on the results, each of which is an instance of `os.DirEntry`, a nice class that
    exposes useful properties and methods. In the code, we access a subset of those:
    `name`, `path`, and `is_file()`. Running the code yields the following (I omitted
    a few results for brevity):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此片段使用`os.scandir`，在当前目录上调用。我们对结果进行迭代，每个结果都是`os.DirEntry`的一个实例，这是一个暴露有用属性和方法的好类。在代码中，我们访问了其中的一部分：`name`、`path`和`is_file()`。运行代码会产生以下结果（为简洁起见，我省略了一些结果）：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A more powerful way to scan a directory tree is given to us by `os.walk`. Let''s
    see an example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描目录树的更强大的方法是由`os.walk`给我们的。让我们看一个例子：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Running the preceding snippet will produce a list of all files and directories
    in the current one, and it will do the same for each sub-directory.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的片段将产生当前目录中所有文件和目录的列表，并且对每个子目录都会执行相同的操作。
- en: File and directory compression
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件和目录压缩
- en: 'Before we leave this section, let me give you an example of how to create a
    compressed file. In the source code of the book, I have two examples: one creates
    a ZIP file, while the other one creates a `tar.gz` file. Python allows you to
    create compressed files in several different ways and formats. Here, I am going
    to show you how to create the most common one, ZIP:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开这一部分之前，让我给你举个创建压缩文件的例子。在书的源代码中，我有两个例子：一个创建一个ZIP文件，而另一个创建一个`tar.gz`文件。Python允许您以几种不同的方式和格式创建压缩文件。在这里，我将向您展示如何创建最常见的一种，ZIP：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, we import `ZipFile`, and then, within a context manager,
    we write into it four dummy context files (two of which are in a sub-folder, to
    show ZIP preserves the full path). Afterwards, as an example, we open the compressed
    file and extract a couple of files from it, into the `extract_zip` directory.
    If you are interested in learning more about data compression, make sure you check
    out the *Data Compression and Archiving* section on the standard library ([https://docs.python.org/3.7/library/archiving.html](https://docs.python.org/3.7/library/archiving.html)),
    where you'll be able to learn all about this topic.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们导入`ZipFile`，然后在上下文管理器中，我们向其中写入四个虚拟上下文文件（其中两个在子文件夹中，以显示ZIP保留了完整路径）。之后，作为示例，我们打开压缩文件并从中提取了一些文件，放入`extract_zip`目录中。如果您有兴趣了解更多关于数据压缩的信息，请确保查看标准库中的*数据压缩和存档*部分（[https://docs.python.org/3.7/library/archiving.html](https://docs.python.org/3.7/library/archiving.html)），在那里您将能够学习有关此主题的所有内容。
- en: Data interchange formats
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据交换格式
- en: Modern software architecture tends to split an application into several components.
    Whether you embrace the service-oriented architecture paradigm, or you push it
    even further into the microservices realm, these components will have to exchange
    data. But even if you are coding a monolithic application, whose code base is
    contained in one project, chances are that you have to still exchange data with
    APIs, other programs, or simply handle the data flow between the frontend and
    the backend part of your website, which very likely won't speak the same language.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现代软件架构倾向于将应用程序拆分为几个组件。无论您是否采用面向服务的架构范例，或者将其推进到微服务领域，这些组件都必须交换数据。但即使您正在编写一个单体应用程序，其代码库包含在一个项目中，也有可能您必须与API、其他程序交换数据，或者简单地处理网站前端和后端部分之间的数据流，这些部分很可能不会使用相同的语言。
- en: Choosing the right format in which to exchange information is crucial. A language-specific
    format has the advantage that the language itself is very likely to provide you
    with all the tools to make serialization and deserialization a breeze. However,
    you will lose the ability to talk to other components that have been written in
    different versions of the same language, or in different languages altogether.
    Regardless of what the future looks like, going with a language-specific format
    should only be done if it is the only possible choice for the given situation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的格式来交换信息至关重要。特定于语言的格式的优势在于，语言本身很可能会为您提供使序列化和反序列化变得轻而易举的所有工具。但是，您将失去与使用不同版本的相同语言或完全不同语言编写的其他组件进行通信的能力。无论未来看起来如何，只有在给定情况下这是唯一可能的选择时，才应选择特定于语言的格式。
- en: A much better approach is to choose a format that is language agnostic, and
    can be spoken by all (or at least most) languages. In the team I lead, we have
    people from England, Poland, South Africa, Spain, Greece, India, Italy, to mention
    just a few. We all speak English, so regardless of our native tongue, we can all
    understand each other (well... mostly!).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是选择一种语言无关的格式，可以被所有（或至少大多数）语言使用。在我领导的团队中，我们有来自英格兰、波兰、南非、西班牙、希腊、印度、意大利等国家的人。我们都说英语，所以无论我们的母语是什么，我们都可以理解彼此（嗯...大多数情况下！）。
- en: In the software world, some popular formats have become the de facto standard
    over recent years. The most famous ones probably are XML, YAML, and JSON. The
    Python standard library features the `xml` and `json` modules, and, on PyPI ([https://docs.python.org/3.7/library/archiving.html](https://docs.python.org/3.7/library/archiving.html)),
    you can find a few different packages to work with YAML.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件世界中，一些流行的格式在最近几年已经成为事实上的标准。最著名的可能是XML、YAML和JSON。Python标准库包括`xml`和`json`模块，而在PyPI（[https://docs.python.org/3.7/library/archiving.html](https://docs.python.org/3.7/library/archiving.html)）上，您可以找到一些不同的包来处理YAML。
- en: In the Python environment, JSON is probably the most commonly used one. It wins
    over the other two because of being part of the standard library, and for its
    simplicity. If you have ever worked with XML, you know what a nightmare it can
    be.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python环境中，JSON可能是最常用的格式。它胜过其他两种格式，因为它是标准库的一部分，而且它很简单。如果您曾经使用过XML，您就知道它可能是多么可怕。
- en: Working with JSON
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理JSON
- en: '**JSON** is the acronym of **JavaScript Object Notation**, and it is a subset
    of the JavaScript language. It has been there for almost two decades now, so it
    is well known and widely adopted by basically all languages, even though it is
    actually language independent. You can read all about it on its website ([https://www.json.org/](https://www.json.org/)),
    but I''m going to give you a quick introduction to it now.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**是**JavaScript对象表示法**的缩写，它是JavaScript语言的一个子集。它已经存在了将近二十年，因此它是众所周知的，并且被基本上所有语言广泛采用，尽管它实际上是与语言无关的。您可以在其网站上阅读有关它的所有信息（[https://www.json.org/](https://www.json.org/)），但我现在要给您一个快速介绍。'
- en: 'JSON is based on two structures: a collection of name/value pairs, and an ordered
    list of values. You will immediately realize that these two objects map to the
    dictionary and list data types in Python, respectively. As data types, it offers
    strings, numbers, objects, and values, such as true, false, and null. Let''s see
    a quick example to get us started:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: JSON基于两种结构：一组名称/值对和一个有序值列表。您会立即意识到，这两个对象分别映射到Python中的字典和列表数据类型。作为数据类型，它提供字符串、数字、对象和值，如true、false和null。让我们看一个快速的例子来开始：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We begin by importing the `sys` and `json` modules. Then we create a simple
    dictionary with some numbers inside and a list. I wanted to test serializing and
    deserializing using very big numbers, both `int` and `float`, so I put *2^(3141)*
    and whatever is the biggest floating point number my system can handle.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`sys`和`json`模块。然后我们创建一个包含一些数字和一个列表的简单字典。我想测试使用非常大的数字进行序列化和反序列化，所以我放了*2^(3141)*和我的系统可以处理的最大浮点数。
- en: 'We serialize with `json.dumps`, which takes data and converts it into a JSON
    formatted string. That data is then fed into `json.loads`, which does the opposite:
    from a JSON formatted string, it reconstructs the data into Python. On the last
    line, we make sure that the original data and the result of the serialization/deserialization
    through JSON match.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`json.dumps`进行序列化，它将数据转换为JSON格式的字符串。然后将该数据输入`json.loads`，它执行相反的操作：从JSON格式的字符串中，将数据重构为Python。在最后一行，我们确保原始数据和通过JSON进行序列化/反序列化的结果匹配。
- en: 'Let''s see, in the next example, what JSON data would look like if we printed
    it:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一个例子中，如果我们打印JSON数据会是什么样子：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, we create a dictionary with Sherlock Holmes' data in it. If,
    like me, you're a fan of Sherlock Holmes, and are in London, you'll find his museum
    at that address (which I recommend visiting, it's small but very nice).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个包含福尔摩斯数据的字典。如果您像我一样是福尔摩斯的粉丝，并且在伦敦，您会在那个地址找到他的博物馆（我建议您去参观，它虽小但非常好）。
- en: 'Notice how we call `json.dumps`, though. We have told it to indent with two
    spaces, and sort keys alphabetically. The result is this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何调用`json.dumps`。我们已经告诉它用两个空格缩进，并按字母顺序排序键。结果是这样的：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The similarity with Python is huge. The one difference is that if you place
    a comma on the last element in a dictionary, like I've done in Python (as it is
    customary), JSON will complain.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python的相似性非常大。唯一的区别是，如果您在字典的最后一个元素上放置逗号，就像我在Python中所做的那样（因为这是习惯的做法），JSON会抱怨。
- en: 'Let me show you something interesting:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给您展示一些有趣的东西：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, we have put a tuple, instead of a list. The interesting bit
    is that, conceptually, a tuple is also an ordered list of items. It doesn't have
    the flexibility of a list, but still, it is considered the same from the perspective
    of JSON. Therefore, as you can see by the first `print`, in JSON a tuple is transformed
    into a list. Naturally then, the information that it was a tuple is lost, and
    when deserialization happens, what we have in `data_out`, `a_tuple` is actually
    a list. It is important that you keep this in mind when dealing with data, as
    going through a transformation process that involves a format that only comprises
    a subset of the data structures you can use implies there will be information
    loss. In this case, we lost the information about the type (tuple versus list).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们放了一个元组，而不是一个列表。有趣的是，从概念上讲，元组也是一个有序的项目列表。它没有列表的灵活性，但从JSON的角度来看，它仍然被视为相同的。因此，正如您可以从第一个`print`中看到的那样，在JSON中，元组被转换为列表。因此，它是一个元组的信息丢失了，当进行反序列化时，`data_out`中的`a_tuple`实际上是一个列表。在处理数据时，重要的是要记住这一点，因为经历一个涉及仅包括您可以使用的数据结构子集的格式的转换过程意味着会有信息丢失。在这种情况下，我们丢失了类型（元组与列表）的信息。
- en: This is actually a common problem. For example, you can't serialize all Python
    objects to JSON, as it is not clear if JSON should revert that (or how). Think
    about `datetime`, for example. An instance of that class is a Python object that
    JSON won't allow serializing. If we transform it into a string such as `2018-03-04T12:00:30Z`,
    which is the ISO 8601 representation of a date with time and time zone information,
    what should JSON do when deserializing? Should it say *this is actually deserializable
    into a datetime object, so I'd better do it*, or should it simply consider it
    as a string and leave it as it is? What about data types that can be interpreted
    in more than one way?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个常见的问题。例如，您不能将所有Python对象序列化为JSON，因为不清楚JSON是否应该还原它（或者如何还原）。想想`datetime`，例如。该类的实例是JSON不允许序列化的Python对象。如果我们将其转换为字符串，比如`2018-03-04T12:00:30Z`，这是带有日期、时间和时区信息的ISO
    8601表示，当进行反序列化时，JSON应该怎么做？它应该说*这实际上可以反序列化为一个datetime对象，所以最好这样做*，还是应该简单地将其视为字符串并保留它？那些可以以多种方式解释的数据类型又该怎么办？
- en: The answer is that when dealing with data interchange, we often need to transform
    our objects into a simpler format prior to serializing them with JSON. This way,
    we will know how to reconstruct them correctly when we deserialize them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，在处理数据交换时，我们经常需要在将对象序列化为JSON之前将其转换为更简单的格式。这样，当我们对其进行反序列化时，我们将知道如何正确地重建它们。
- en: 'In some cases, though, and mostly for internal use, it is useful to be able
    to serialize custom objects, so, just for fun, I''m going to show you how with
    two examples: complex numbers (because I love math) and *datetime* objects.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，主要是为了内部使用，能够序列化自定义对象是很有用的，因此，只是为了好玩，我将向您展示两个例子：复数（因为我喜欢数学）和*datetime*对象。
- en: Custom encoding/decoding with JSON
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义编码/解码与JSON
- en: 'In the JSON world, we can consider terms like encoding/decoding as synonyms
    to serializing/deserializing. They basically all mean transforming to and back
    from JSON. In the following example, I''m going to show you how to encode complex
    numbers:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSON世界中，我们可以将编码/解码这样的术语视为序列化/反序列化的同义词。它们基本上都意味着转换为JSON，然后再从JSON转换回来。在下面的例子中，我将向您展示如何编码复数：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We start by defining a `ComplexEncoder` class, which needs to implement the `default`
    method. This method is passed to all the objects that have to be serialized, one
    at a time, in the `obj` variable. At some point, `obj` will be our complex number, *3+4j*.
    When that is true, we return a dictionary with some custom meta information, and
    a list that contains both the real and the imaginary part of the number. That
    is all we need to do to avoid losing information for a complex number.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个`ComplexEncoder`类，它需要实现`default`方法。这个方法被传递给所有需要被序列化的对象，一个接一个地，在`obj`变量中。在某个时候，`obj`将是我们的复数*3+4j*。当这种情况发生时，我们返回一个带有一些自定义元信息的字典，以及一个包含实部和虚部的列表。这就是我们需要做的，以避免丢失复数的信息。
- en: 'We then call `json.dumps`, but this time we use the `cls` argument to specify
    our custom encoder. The result is printed:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用`json.dumps`，但这次我们使用`cls`参数来指定我们的自定义编码器。结果被打印出来：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Half the job is done. For the deserialization part, we could have written another
    class that would inherit from `JSONDecoder`, but, just for fun, I've used a different
    technique that is simpler and uses a small function: `object_hook`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一半的工作已经完成。对于反序列化部分，我们本可以编写另一个从`JSONDecoder`继承的类，但是，只是为了好玩，我使用了一种更简单的技术，使用了一个小函数：`object_hook`。
- en: Within the body of `object_hook`, we find another `try` block, but don't worry
    about it for now. I'll explain it in detail in the next chapter. The important
    part is the two lines within the body of the `try` block itself. The function
    receives an object (notice, the function is only called when `obj` is a dictionary),
    and if the metadata matches our convention for complex numbers, we pass the real
    and imaginary parts to the `complex` function. The `try`/`except` block is there
    only to prevent malformed JSON from ruining the party (and if that happens, we
    simply return the object as it is).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`object_hook`的主体中，我们找到另一个`try`块，但现在不要担心它。我将在下一章节中详细解释它。重要的是`try`块本身的主体中的两行。该函数接收一个对象（请注意，只有当`obj`是一个字典时才调用该函数），如果元数据与我们的复数约定匹配，我们将实部和虚部传递给`complex`函数。`try`/`except`块只是为了防止格式不正确的JSON破坏整个过程（如果发生这种情况，我们只需返回对象本身）。
- en: 'The last print returns:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的打印返回：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can see that `a_complex` has been correctly deserialized.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`a_complex`已经被正确反序列化。
- en: 'Let''s see a slightly more complex (no pun intended) example now: dealing with
    `datetime` objects. I''m going to split the code into two blocks, the serializing
    part, and the deserializing afterwards:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个稍微更复杂（没有刻意的双关语）的例子：处理`datetime`对象。我将把代码分成两个部分，序列化部分和之后的反序列化部分：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The reason why this example is slightly more complex lies in the fact that `datetime`
    objects in Python can be time zone aware or not; therefore, we need to be more
    careful. The flow is basically the same as before, only it is dealing with a different
    data type. We start by getting the current date and time information, and we do
    it both without (`now`) and with (`now_tz`) time zone awareness, just to make
    sure our script works. We then proceed to define a custom encoder as before, and
    we implement once again the `default` method. The important bits in that method
    are how we get the time zone offset (`off`) information, in seconds, and how we
    structure the dictionary that returns the data. This time, the metadata says it's
    a *datetime* information, and then we save the first six items in the time tuple
    (year, month, day, hour, minute, and second), plus the microseconds in the `data`
    key, and the offset after that. Could you tell that the value of `data` is a concatenation
    of tuples? Good job if you could!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子稍微复杂的原因在于Python中的`datetime`对象可以是时区感知的或者不是；因此，我们需要更加小心。流程基本上和之前一样，只是处理不同的数据类型。我们首先获取当前的日期和时间信息，我们既不带（`now`）也带（`now_tz`）时区感知，只是为了确保我们的脚本工作。然后我们继续像之前一样定义一个自定义编码器，并再次实现`default`方法。在该方法中重要的部分是我们如何获取时间偏移（`off`）信息，以秒为单位，并且我们如何构造返回数据的字典。这一次，元数据表示它是*datetime*信息，然后我们保存时间元组的前六个项目（年、月、日、小时、分钟和秒），加上`data`键中的微秒，然后是偏移。你能看出`data`的值是元组的连接吗？如果你能，干得好！
- en: 'When we have our custom encoder, we proceed to create some data, and then we
    serialize. The `print` statement returns (after I''ve done some prettifying):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有了自定义编码器后，我们继续创建一些数据，然后进行序列化。`print`语句返回（在我进行了一些美化之后）：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Interestingly, we find out that `None` is translated to `null`, its JavaScript
    equivalent. Moreover, we can see our data seems to have been encoded properly.
    Let''s proceed to the second part of the script:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们发现`None`被翻译为`null`，它的JavaScript等价物。此外，我们可以看到我们的数据似乎已经被正确编码。让我们继续进行脚本的第二部分：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once again, we first verify that the metadata is telling us it''s a `datetime`,
    and then we proceed to fetch the time zone information. Once we have that, we
    pass the 7-tuple (using `*` to unpack its values in the call) and the time zone
    information to the `datetime` call, getting back our original object. Let''s verify
    it by printing `data_out`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们首先验证元数据告诉我们它是一个`datetime`，然后我们继续获取时区信息。一旦我们有了时区信息，我们将7元组（使用`*`来解包其值）和时区信息传递给`datetime`调用，得到我们的原始对象。让我们通过打印`data_out`来验证它：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, we got everything back correctly. As an exercise, I'd like to
    challenge you to write the same logic, but for a `date` object, which should be
    simpler.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们正确地得到了一切。作为一个练习，我想挑战你写相同的逻辑，但是对于一个`date`对象，这应该更简单。
- en: Before we move on to the next topic, a word of caution. Perhaps it is counter-intuitive,
    but working with `datetime` objects can be one of the trickiest things to do,
    so, although I'm pretty sure this code is doing what it is supposed to do, I want
    to stress that I only tested it very lightly. So if you intend to grab it and
    use it, please do test it thoroughly. Test for different time zones, test for
    daylight saving time being on and off, test for dates before the epoch, and so
    on. You might find that the code in this section then would need some modifications
    to suit your cases.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一个主题之前，我想提个小心。也许这是违反直觉的，但是处理`datetime`对象可能是最棘手的事情之一，所以，虽然我很确定这段代码正在做它应该做的事情，我想强调我只是轻微地测试了它。所以如果你打算使用它，请彻底测试它。测试不同的时区，测试夏令时的开启和关闭，测试纪元前的日期等等。你可能会发现这一部分的代码需要一些修改来适应你的情况。
- en: Let's now move to the next topic, IO.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到下一个主题，IO。
- en: IO, streams, and requests
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IO、流和请求
- en: '**IO** stands for **input**/**output**, and it broadly refers to the communication
    between a computer and the outside world. There are several different types of
    IO, and it is outside the scope of this chapter to explain all of them, but I
    still want to offer you a couple of examples.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**IO**代表**输入**/**输出**，它广泛地指的是计算机与外部世界之间的通信。有几种不同类型的IO，这超出了本章的范围来解释所有这些，但我仍然想给你举几个例子。'
- en: Using an in-memory stream
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内存流
- en: 'The first will show you the `io.StringIO` class, which is an in-memory stream
    for text IO. The second one instead will escape the locality of our computer,
    and show you how to perform an HTTP request. Let''s see the first example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个将向你展示`io.StringIO`类，它是用于文本IO的内存流。而第二个则会逃离我们计算机的局限，并向你展示如何执行HTTP请求。让我们看看第一个例子：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code snippet, we import the `io` module from the standard library.
    This is a very interesting module that features many tools related to streams
    and IO. One of them is `StringIO`, which is an in-memory buffer in which we're
    going to write two sentences, using two different methods, as we did with files
    in the first examples of this chapter. We can both call `StringIO.write` or we
    can use `print`, and tell it to direct the data to our stream.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们从标准库中导入了`io`模块。这是一个非常有趣的模块，其中包含许多与流和IO相关的工具。其中之一是`StringIO`，它是一个内存缓冲区，我们将使用两种不同的方法在其中写入两个句子，就像我们在本章的第一个例子中使用文件一样。我们既可以调用`StringIO.write`，也可以使用`print`，并告诉它将数据定向到我们的流中。
- en: By calling `getvalue`, we can get the content of the stream (and print it),
    and finally we close it. The call to `close` causes the text buffer to be immediately
    discarded.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`getvalue`，我们可以获取流的内容（并打印它），最后我们关闭它。调用`close`会导致文本缓冲立即被丢弃。
- en: 'There is a more elegant way to write the previous code (can you guess it, before
    you look?):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更优雅的方法来编写前面的代码（在你看之前，你能猜到吗？）：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Yes, it is again a context manager. Like `open`, `io.StringIO` works well within
    a context manager block. Notice the similarity with `open`: in this case too,
    we don''t need to manually close the stream.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这又是一个上下文管理器。像`open`一样，`io.StringIO`在上下文管理器块内工作得很好。注意与`open`的相似之处：在这种情况下，我们也不需要手动关闭流。
- en: In-memory objects can be useful in a multitude of situations. Memory is much
    faster than a disk and, for small amounts of data, can be the perfect choice.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 内存对象在许多情况下都很有用。内存比磁盘快得多，对于少量数据来说，可能是完美的选择。
- en: 'When running the script, the output is:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本时，输出为：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Making HTTP requests
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行HTTP请求
- en: 'Let''s now explore a couple of examples on HTTP requests. I will use the `requests`
    library for these examples, which you can install with `pip`. We''re going to
    perform HTTP requests against the [httpbin.org](http://httpbin.org/) API, which,
    interestingly, was developed by Kenneth Reitz, the creator of the `requests` library
    itself. This library is amongst the most widely adopted all over the world:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们探索一些关于HTTP请求的例子。我将在这些例子中使用`requests`库，你可以使用`pip`安装它。我们将对[httpbin.org](http://httpbin.org/)
    API执行HTTP请求，有趣的是，这个API是由`requests`库的创建者Kenneth Reitz开发的。这个库在全世界范围内被广泛采用：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding snippet should be simple to understand. I declare a dictionary
    of URLs against which I want to perform `requests`. I have encapsulated the code
    that performs the request into a tiny function: `get_content`. As you can see,
    very simply, we perform a GET request (by using `requests.get`), and we print
    the title and the JSON decoded version of the body of the response. Let me spend
    a word about this last bit.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段应该很容易理解。我声明了一个URL字典，对这些URL我想执行`requests`。我将执行请求的代码封装到一个小函数`get_content`中：如你所见，我们很简单地执行了一个GET请求（通过使用`requests.get`），并打印了响应的标题和JSON解码版本的响应体。让我多说一句关于最后一点。
- en: When we perform a request to a website, or API, we get back a response object,
    which is, very simply, what was returned by the server we performed the request
    against. The body of all responses from [httpbin.org](https://httpbin.org/) happens
    to be JSON encoded, so instead of getting the body as it is (by getting `resp.text`)
    and manually decoding it, calling `json.loads` on it, we simply combine the two
    by leveraging the `json` method on the response object. There are plenty of reasons
    why the `requests` package has become so widely adopted, and one of them is definitely
    its ease of use.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对网站或API执行请求时，我们会得到一个响应对象，这个对象很简单，就是服务器返回的内容。所有来自[httpbin.org](https://httpbin.org/)的响应体都是JSON编码的，所以我们不是通过`resp.text`获取响应体本身，然后手动解码它，而是通过在响应对象上利用`json`方法将两者结合起来。`requests`包变得如此广泛被采用有很多原因，其中一个绝对是它的易用性。
- en: Now, when you perform a request in your application, you will want to have a
    much more robust approach in dealing with errors and so on, but for this chapter,
    a simple example will do. Don't worry, I will give you a more comprehensive introduction
    to HTTP requests in [Chapter 14](part0341.html#A56FQ0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Web Development*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你在应用程序中执行请求时，你会希望有一个更加健壮的方法来处理错误等等，但是在本章中，一个简单的例子就足够了。别担心，我会在[第14章](part0341.html#A56FQ0-2ddb708647cc4530a187c2c6c0e9acfe)
    *Web Development*中给你一个更全面的HTTP请求介绍。
- en: 'Going back to our code, in the end, we run a `for` loop and get all the URLs.
    When you run it, you will see the result of each call printed on your console,
    like this (prettified and trimmed for brevity):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的代码，最后，我们运行一个`for`循环并获取所有的URL。当你运行它时，你会在控制台上看到每次调用的结果，就像这样（经过美化和简化）：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Notice that you might get a slightly different output in terms of version numbers
    and IPs, which is fine. Now, GET is only one of the HTTP verbs, and it is definitely
    the most commonly used. The second one is the ubiquitous POST, which is the type
    of request you make when you need to send data to the server. Every time you submit
    a form on the web, you''re basically making a POST request. So, let''s try to
    make one programmatically:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，版本号和IP方面的输出可能会有些不同，这没关系。现在，GET只是HTTP动词中的一个，它绝对是最常用的。第二个是无处不在的POST，当你需要向服务器发送数据时，就会发起这种类型的请求。每当你在网上提交表单时，你基本上就是在发起一个POST请求。所以，让我们尝试以编程方式进行一个：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The previous code is very similar to the one we saw before, only this time we
    don't call `get`, but `post`, and because we want to send some data, we specify
    that in the call. The `requests` library offers much, much more than this, and
    it has been praised by the community for the beautiful API it exposes. It is a
    project that I encourage you to check out and explore, as you will end up using
    it all the time, anyway.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码与之前看到的代码非常相似，只是这一次我们不调用`get`，而是调用`post`，因为我们想发送一些数据，我们在调用中指定了这一点。`requests`库提供的远不止这些，它因其美丽的API而受到社区的赞扬。这是一个我鼓励你去了解和探索的项目，因为无论如何你最终都会一直使用它。
- en: 'Running the previous script (and applying some prettifying magic to the output)
    yields the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的脚本（并对输出进行一些美化处理）会产生以下结果：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice how the headers are now different, and we find the data we sent in the `form`
    key/value pair of the response body.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在头部不同了，我们在响应体的`form`键值对中找到了发送的数据。
- en: I hope these short examples are enough to get you started, especially with requests.
    The web changes every day, so it's worth learning the basics and then brush up
    every now and then.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这些简短的例子足以让你开始，特别是对于请求。网络每天都在变化，所以值得学习基础知识，然后不时地进行复习。
- en: 'Let''s now move on to the last topic of this chapter: persisting data on disk
    in different formats.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向本章的最后一个主题：以不同格式在磁盘上持久化数据。
- en: Persisting data on disk
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在磁盘上持久化数据
- en: In the last section of this chapter, we're exploring how to persist data on
    disk in three different formats. We will explore `pickle`, `shelve`, and a short
    example that will involve accessing a database using SQLAlchemy, the most widely
    adopted ORM library in the Python ecosystem.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一节中，我们将探讨如何以三种不同的格式将数据持久化到磁盘。我们将探索`pickle`、`shelve`，以及一个涉及使用SQLAlchemy访问数据库的简短示例，SQLAlchemy是Python生态系统中最广泛采用的ORM库。
- en: Serializing data with pickle
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pickle序列化数据
- en: The `pickle` module, from the Python standard library, offers tools to convert
    Python objects into byte streams, and vice versa. Even though there is a partial
    overlap in the API that `pickle` and `json` expose, the two are quite different.
    As we have seen previously in this chapter, JSON is a text format, human readable,
    language independent, and supports only a restricted subset of Python data types.
    The `pickle` module, on the other hand, is not human readable, translates to bytes,
    is Python specific, and, thanks to the wonderful Python introspection capabilities,
    it supports an extremely large amount of data types.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库中的`pickle`模块提供了将Python对象转换为字节流以及反之的工具。尽管`pickle`和`json`公开的API存在部分重叠，但两者是完全不同的。正如我们在本章前面看到的，JSON是一种文本格式，人类可读，语言无关，并且仅支持Python数据类型的受限子集。另一方面，`pickle`模块不是人类可读的，转换为字节，是特定于Python的，并且由于Python的精彩内省能力，它支持大量的数据类型。
- en: Regardless of these differences, though, which you should know when you consider
    whether to use one or the other, I think that the most important concern regarding `pickle`
    lies in the security threats you are exposed to when you use it. *Unpickling*
    erroneous or malicious data from an untrusted source can be very dangerous, so
    if you decide to adopt it in your application, you need to be extra careful.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些差异，当你考虑使用其中一个时，你应该知道这些差异，我认为关于`pickle`最重要的关注点在于当你使用它时所面临的安全威胁。从不受信任的来源*unpickling*错误或恶意数据可能非常危险，因此如果你决定在你的应用程序中采用它，你需要格外小心。
- en: 'That said, let''s see it in action, by means of a simple example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们通过一个简单的例子来看它的运作方式：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the previous example, we create a `Person` class using the `dataclass` decorator,
    which we have seen in [Chapter 6](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe),
    *OOP, Decorators, and Iterators*. The only reason I wrote this example with a
    data class is to show you how effortlessly `pickle` deals with it, with no need
    for us to do anything we wouldn't do for a simpler data type.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用`dataclass`装饰器创建了一个`Person`类，我们在[第6章](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe)中已经见过，*OOP，Decorators和Iterators*。我之所以用数据类写这个例子，只是为了向你展示`pickle`如何毫不费力地处理它，而不需要我们为了更简单的数据类型而做任何事情。
- en: The class has three attributes: `first_name`, `last_name`, and `id`. It also
    exposes a `greet` method, which simply prints a hello message with the data.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 该类有三个属性：`first_name`、`last_name`和`id`。它还公开了一个`greet`方法，简单地打印出带有数据的hello消息。
- en: 'We create a list of instances, and then we save it to a file. In order to do
    so, we use `pickle.dump`, to which we feed the content to be *pickled*, and the
    stream to which we want to write. Immediately after that, we read from that same
    file, and by using `pickle.load`, we convert back into Python the whole content
    of that stream. Just to make sure that the objects have been converted correctly,
    we call the `greet` method on both of them. The result is the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个实例列表，然后将其保存到文件中。为了这样做，我们使用`pickle.dump`，将要*pickled*的内容和要写入的流传递给它。在那之后，我们立即从同一个文件中读取，并通过使用`pickle.load`，将该流的整个内容转换回Python。为了确保对象已经被正确转换，我们在两个对象上都调用了`greet`方法。结果如下：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `pickle` module also allows you to convert to (and from) byte objects, by
    means of the `dumps` and `loads` functions (note the `s` at the end of both names).
    In day-to-day applications, `pickle` is usually used when we need to persist Python
    data that is not supposed to be exchanged with another application. One example
    I stumbled upon recently was the session management in a `flask` plugin, which pickles
    the session object before sending it to Redis. In practice, though, you are unlikely
    to have to deal with this library very often.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle`模块还允许你通过`dumps`和`loads`函数（注意这两个名称末尾的`s`）将数据转换为（和从）字节对象。在日常应用中，当我们需要持久化不应该与另一个应用程序交换的Python数据时，通常会使用`pickle`。我最近遇到的一个例子是`flask`插件中的会话管理，它在将会话对象发送到Redis之前对其进行`pickle`。不过，在实践中，你不太可能经常使用这个库。'
- en: Another tool that is possibly used even less, but that proves to be very useful
    when you are short of resources, is `shelve`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能使用得更少，但在资源短缺时非常有用的工具是`shelve`。
- en: Saving data with shelve
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用shelve保存数据
- en: 'A `shelf`, is a persistent dictionary-like object. The beauty of it is that
    the values you save into a `shelf` can be any object you can `pickle`, so you''re
    not restricted like you would be if you were using a database. Albeit interesting
    and useful, the `shelve` module is used quite rarely in practice. Just for completeness,
    let''s see a quick example of how it works:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelf`是一个持久的类似字典的对象。它的美妙之处在于，你保存到`shelf`中的值可以是任何你可以`pickle`的对象，因此你不像使用数据库时那样受限制。尽管有趣且有用，但`shelve`模块在实践中很少使用。为了完整起见，让我们快速看一下它是如何工作的：'
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Apart from the wiring and the boilerplate around it, the previous example resembles
    an exercise with dictionaries. We create a simple `Person` class and then we open
    a `shelve` file within a context manager. As you can see, we use the dictionary
    syntax to store four objects: two `Person` instances, a list, and a string. If
    we print the `keys,` we get a list containing the four keys we used. Immediately
    after printing it, we delete the (aptly named) `delete_me` key/value pair from shelf.
    Printing the `keys` again shows the deletion has succeeded. We then test a couple
    of keys for membership, and finally, we append number `7` to `a_list`. Notice
    how we have to extract the list from the shelf, modify it, and save it again.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 除了接线和围绕它的样板之外，前面的例子类似于使用字典进行练习。我们创建一个简单的“Person”类，然后在上下文管理器中打开一个“shelve”文件。正如你所看到的，我们使用字典语法来存储四个对象：两个“Person”实例，一个列表和一个字符串。如果我们打印“keys”，我们会得到一个包含我们使用的四个键的列表。打印完后，我们立即从架子上删除了（恰如其名的）“delete_me”键/值对。再次打印“keys”显示删除已成功。然后我们测试了一对键的成员资格，最后，我们将数字“7”附加到“a_list”上。请注意，我们必须从架子上提取列表，修改它，然后再次保存它。
- en: 'In case this behavior is undesired, there is something we can do:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种行为是不希望的，我们可以做一些事情：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: By opening the shelf with `writeback=True`, we enable the `writeback` feature,
    which allows us to simply append to `a_list` as if it actually was a value within
    a regular dictionary. The reason why this feature is not active by default is
    that it comes with a price that you pay in terms of memory consumption and slower
    closing of the shelf.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以“writeback=True”打开架子，我们启用了“writeback”功能，这使我们可以简单地将“a_list”附加到其中，就好像它实际上是常规字典中的一个值。这个功能之所以不是默认激活的原因是，它会以内存消耗和更慢的关闭架子的方式付出代价。
- en: Now that we have paid homage to the standard library modules related to data
    persistence, let's take a look at the most widely adopted ORM in the Python ecosystem: *SQLAlchemy*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经向与数据持久性相关的标准库模块致敬，让我们来看看Python生态系统中最广泛采用的ORM：*SQLAlchemy*。
- en: Saving data to a database
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据保存到数据库
- en: For this example, we are going to work with an in-memory database, which will
    make things simpler for us. In the source code of the book, I have left a couple
    of comments to show you how to generate a SQLite file, so I hope you'll explore
    that option as well.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用内存数据库，这将使事情对我们来说更简单。在书的源代码中，我留下了一些注释，以向您展示如何生成一个SQLite文件，所以我希望您也会探索这个选项。
- en: You can find a free database browser for SQLite at [sqlitebrowser.org](http://sqlitebrowser.org/).
    If you are not satisfied with it, you will be able to find a wide range of tools,
    some free, some not free, that you can use to access and manipulate a database
    file.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[sqlitebrowser.org](http://sqlitebrowser.org/)找到一个免费的SQLite数据库浏览器。如果您对此不满意，您将能够找到各种工具，有些是免费的，有些不是免费的，您可以用来访问和操作数据库文件。
- en: Before we dive into the code, allow me to briefly introduce the concept of a
    relational database.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，让我简要介绍一下关系数据库的概念。
- en: 'A relational database is a database that allows you to save data following
    the **relational model**, invented in 1969 by Edgar F. Codd. In this model, data
    is stored in one or more tables. Each table has rows (also known as **records**,
    or **tuples**), each of which represents an entry in the table. Tables also have
    columns (also known as **attributes**), each of which represents an attribute
    of the records. Each record is identified through a unique key, more commonly
    known as the **primary key**, which is the union of one or more columns in the
    table. To give you an example: imagine a table called `Users`, with columns `id`,
    `username`, `password`, `name`, and `surname`. Such a table would be perfect to
    contain users of our system. Each row would represent a different user. For example,
    a row with the values `3`, `gianchub`, `my_wonderful_pwd`, `Fabrizio`, and `Romano`,
    would represent my user in the system.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库是一种允许您按照1969年由Edgar F. Codd发明的**关系模型**保存数据的数据库。在这个模型中，数据存储在一个或多个表中。每个表都有行（也称为**记录**或**元组**），每个行代表表中的一个条目。表还有列（也称为**属性**），每个列代表记录的一个属性。每个记录通过一个唯一键来标识，更常见的是**主键**，它是表中一个或多个列的联合。举个例子：想象一个名为“Users”的表，有列“id”、“username”、“password”、“name”和“surname”。这样的表非常适合包含我们系统的用户。每一行代表一个不同的用户。例如，具有值“3”、“gianchub”、“my_wonderful_pwd”、“Fabrizio”和“Romano”的行将代表我在系统中的用户。
- en: The reason why the model is called **relational** is because you can establish
    relations between tables. For example, if you added a table called `PhoneNumbers`
    to our fictitious database, you could insert phone numbers into it, and then,
    through a relation, establish which phone number belongs to which user.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 模型被称为**关系型**的原因是因为您可以在表之间建立关系。例如，如果您向我们虚构的数据库添加一个名为“PhoneNumbers”的表，您可以向其中插入电话号码，然后通过关系建立哪个电话号码属于哪个用户。
- en: In order to query a relational database, we need a special language. The main
    standard is called **SQL**, which stands for **Structured Query Language**. It
    is born out of something called **relational algebra**, which is a very nice family
    of algebras used to model data stored according to the relational model, and performing
    queries on it. The most common operations you can perform usually involve filtering
    on the rows or columns, joining tables, aggregating the results according to some
    criteria, and so on. To give you an example in English, a query on our imaginary
    database could be: *Fetch all users (username, name, surname) whose username starts
    with "m", who have at most one phone number*. In this query, we are asking for
    a subset of the columns in the `User` table. We are filtering on users by taking
    only those whose username starts with the letter *m*, and even further, only those
    who have at most one phone number.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查询关系数据库，我们需要一种特殊的语言。主要标准称为**SQL**，代表**结构化查询语言**。它源自一种称为**关系代数**的东西，这是一组用于模拟按照关系模型存储的数据并对其进行查询的非常好的代数。你通常可以执行的最常见操作包括对行或列进行过滤、连接表、根据某些标准对结果进行聚合等。举个英文例子，对我们想象中的数据库的查询可能是：*获取所有用户名以“m”开头，最多有一个电话号码的用户（用户名、名字、姓氏）*。在这个查询中，我们要求获取`User`表中的一部分列。我们通过筛选用户，只选择用户名以字母“m”开头的用户，甚至进一步，只选择最多有一个电话号码的用户。
- en: Back in the days when I was a student in Padova, I spent a whole semester learning
    both the relational algebra semantics, and the standard SQL (amongst other things).
    If it wasn't for a major bicycle accident I had the day of the exam, I would say
    that this was one of the most fun exams I ever had to prepare.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我在帕多瓦大学上学的时候，我花了一个学期的时间学习关系代数语义和标准SQL（还有其他东西）。如果不是因为我在考试当天遭遇了一次严重的自行车事故，我会说这是我准备过的最有趣的考试之一。
- en: Now, each database comes with its own *flavor* of SQL. They all respect the
    standard to some extent, but none fully does, and they are all different from
    one another in some respects. This poses an issue in modern software development.
    If our application contains SQL code, it is quite likely that if we decided to
    use a different database engine, or maybe a different version of the same engine,
    we would find our SQL code needs amending.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个数据库都有自己的SQL“口味”。它们都在一定程度上遵守标准，但没有一个完全遵守，并且它们在某些方面彼此不同。这在现代软件开发中构成了一个问题。如果我们的应用程序包含SQL代码，那么如果我们决定使用不同的数据库引擎，或者可能是同一引擎的不同版本，很可能会发现我们的SQL代码需要修改。
- en: This can be quite painful, especially since SQL queries can become very, very
    complicated quite quickly. In order to alleviate this pain a little, computer
    scientists (*bless them*) have created code that maps objects of a particular
    language to tables of a relational database. Unsurprisingly, the name of such
    tools is **Object-Relational Mapping** (**ORM**s).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会很痛苦，特别是因为SQL查询很快就会变得非常复杂。为了稍微减轻这种痛苦，计算机科学家们（感谢他们）创建了将特定语言的对象映射到关系数据库表的代码。毫不奇怪，这种工具的名称是**对象关系映射**（ORM）。
- en: In modern application development, you would normally start interacting with
    a database by using an ORM, and should you find yourself in a situation where
    you can't perform a query you need to perform, through the ORM, you would then
    resort to using SQL directly. This is a good compromise between having no SQL
    at all, and using no ORM, which ultimately means specializing the code that interacts
    with the database, with the aforementioned disadvantages.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代应用程序开发中，通常会通过使用ORM来开始与数据库交互，如果你发现自己无法通过ORM执行需要执行的查询，那么你会转而直接使用SQL。这是在完全没有SQL和不使用ORM之间的一个很好的折衷，这最终意味着专门化与数据库交互的代码，带来了前面提到的缺点。
- en: In this section, I'd like to show an example that leverages SQLAlchemy, the
    most popular Python ORM. We are going to define two models (`Person` and `Address`)
    which map to a table each, and then we're going to populate the database and perform
    a few queries on it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我想展示一个利用SQLAlchemy的例子，这是最流行的Python ORM。我们将定义两个模型（`Person`和`Address`），它们分别映射到一个表，然后我们将填充数据库并对其执行一些查询。
- en: 'Let''s start with the model declarations:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从模型声明开始：
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'At the beginning, we import some functions and types. The first thing we need
    to do then is to create an engine. This engine tells SQLAlchemy about the type
    of database we have chosen for our example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们导入一些函数和类型。然后，我们需要创建一个引擎。这个引擎告诉SQLAlchemy我们选择的数据库类型是什么。
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Each model then inherits from the `Base` table, which in this example consists
    of the mere default, returned by `declarative_base()`. We define `Person`, which
    maps to a table called `person`, and exposes the attributes `id`, `name`, and `age`.
    We also declare a relationship with the `Address` model, by stating that accessing
    the `addresses` attribute will fetch all the entries in the `address` table that
    are related to the particular `Person` instance we're dealing with. The `cascade`
    option affects how creation and deletion work, but it is a more advanced concept,
    so I'd suggest you glide on it for now and maybe investigate more later on.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个模型都继承自`Base`表，在这个例子中，它由`declarative_base()`返回的默认值组成。我们定义了`Person`，它映射到一个名为`person`的表，并公开`id`、`name`和`age`属性。我们还声明了与`Address`模型的关系，通过声明访问`addresses`属性将获取与我们正在处理的特定`Person`实例相关的`address`表中的所有条目。`cascade`选项影响创建和删除的工作方式，但这是一个更高级的概念，所以我建议你现在先略过它，以后可能再进行更深入的调查。
- en: The last thing we declare is the `__repr__` method, which provides us with the official string
    representation of an object. This is supposed to be a representation that can
    be used to completely reconstruct the object, but in this example, I simply use
    it to provide something in output. Python redirects `repr(obj)` to a call to `obj.__repr__()`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明的最后一件事是`__repr__`方法，它为我们提供了对象的官方字符串表示。这应该是一个可以用来完全重建对象的表示，但在这个例子中，我只是用它来提供输出。Python将`repr(obj)`重定向到对`obj.__repr__()`的调用。
- en: We also declare the `Address` model, which will contain email addresses, and
    a reference to the person they belong to. You can see the `person_id` and `person` attributes are
    both about setting a relation between the `Address` and `Person` instances. Note
    how I declared the `__str__` method on `Address`, and then assigned an alias to
    it, called `__repr__`. This means that calling both `repr` and `str` on `Address`
    objects will ultimately result in calling the `__str__` method. This is quite
    a common technique in Python, so I took the opportunity to show it to you here.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还声明了`Address`模型，它将包含电子邮件地址，以及它们所属的人的引用。你可以看到`person_id`和`person`属性都是关于设置`Address`和`Person`实例之间的关系。注意我在`Address`上声明了`__str__`方法，然后给它分配了一个别名，叫做`__repr__`。这意味着在`Address`对象上调用`repr`和`str`最终都会调用`__str__`方法。这在Python中是一种常见的技术，所以我在这里有机会向你展示。
- en: On the last line, we tell the engine to create tables in the database according
    to our models.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，我们告诉引擎根据我们的模型在数据库中创建表。
- en: A deeper understanding of this code would require much more space than I can
    afford, so I encourage you to read up on **database management systems** (**DBMS**),
    SQL, Relational Algebra, and SQLAlchemy.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对这段代码的更深理解需要比我能提供的空间更多，所以我鼓励你阅读**数据库管理系统**（**DBMS**）、SQL、关系代数和SQLAlchemy。
- en: Now that we have our models, let's use them to persist some data!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的模型，让我们使用它们来保存一些数据！
- en: 'Let''s take a look at the following example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的例子：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'First we create session, which is the object we use to manage the database.
    Next, we proceed by creating two people:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们创建会话，这是我们用来管理数据库的对象。接下来，我们创建了两个人：
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We then add email addresses to both of them, using two different techniques.
    One assigns them to a list, and the other one simply appends them:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们为他们都添加电子邮件地址，使用了两种不同的技术。一种将它们分配给一个列表，另一种只是简单地将它们附加到列表中：
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We haven''t touched the database yet. It''s only when we use the session object
    that something actually happens in it:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有触及数据库。只有当我们使用会话对象时，它才会发生实际的变化：
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Adding the two `Person` instances is enough to also add their addresses (this
    is thanks to the cascading effect). Calling `commit` is what actually tells SQLAlchemy
    to commit the transaction and save the data in the database. A transaction is
    an operation that provides something like a sandbox, but in a database context.
    As long as the transaction hasn't been committed, we can roll back any modification
    we have done to the database, and by so doing, revert to the state we were before
    starting the transaction itself. SQLAlchemy offers more complex and granular ways
    to deal with transactions, which you can study in its official documentation,
    as it is quite an advanced topic. We now query for all the people whose name starts
    with `Obi` by using `like`, which hooks to the `LIKE` operator in SQL*:*
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这两个`Person`实例足以添加它们的地址（这要归功于级联效应）。调用`commit`实际上告诉SQLAlchemy提交事务并将数据保存到数据库中。事务是在数据库上下文中提供类似沙盒的操作。只要事务没有提交，我们就可以回滚对数据库所做的任何修改，从而恢复到事务开始之前的状态。SQLAlchemy提供了更复杂和细粒度的处理事务的方式，你可以在它的官方文档中学习，因为这是一个非常高级的话题。现在我们通过使用`like`查询所有以`Obi`开头的人的名字，这将连接到SQL中的`LIKE`操作符：
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We take the first result of that query (we know we only have Obi-Wan anyway),
    and print it. We then fetch `anakin`, by using an exact match on his name (just
    to show you a different way of filtering):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取该查询的第一个结果（我们知道我们只有Obi-Wan），然后打印出来。然后我们通过使用他的名字进行精确匹配来获取`anakin`（只是为了向你展示另一种过滤的方式）：
- en: '[PRE55]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We then capture Anakin''s ID, and delete the `anakin` object from the global
    frame:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们捕获了Anakin的ID，并从全局框架中删除了`anakin`对象：
- en: '[PRE56]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The reason we do this is because I want to show you how to fetch an object
    by its ID. Before we do that, we write the `display_info` function, which we will
    use to display the full content of the database (fetched starting from the addresses,
    in order to demonstrate how to fetch objects by using a relation attribute in SQLAlchemy):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为我想向你展示如何通过ID获取对象。在我们这样做之前，我们编写了`display_info`函数，我们将使用它来显示数据库的全部内容（从地址开始获取，以演示如何通过使用SQLAlchemy中的关系属性来获取对象）：
- en: '[PRE57]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `display_info` function prints all the addresses, along with the respective
    person''s name, and, at the end, produces a final piece of information regarding
    the number of objects in the database. We call the function, then we fetch and
    delete `anakin` (think about *Darth Vader* and you won''t be sad about deleting
    him), and then we display the info again, to verify he''s actually disappeared
    from the database:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`display_info`函数打印出所有的地址，以及相应的人的名字，并且最后产生了关于数据库中对象数量的最终信息。我们调用这个函数，然后获取并删除`anakin`（想想*Darth
    Vader*，你就不会因为删除他而难过），然后再次显示信息，以验证他确实已经从数据库中消失了：'
- en: '[PRE58]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The output of all these snippets run together is the following (for your convenience,
    I have separated the output into four blocks, to reflect the four blocks of code
    that actually produce that output):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些片段一起运行的输出如下（为了方便起见，我已经将输出分成四个块，以反映实际产生该输出的四个代码块）：
- en: '[PRE59]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see from the last two blocks, deleting `anakin` has deleted one `Person`
    object, and the three addresses associated with it. Again, this is due to the
    fact that cascading took place when we deleted `anakin`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从最后两个代码块可以看出，删除`anakin`已经删除了一个`Person`对象和与之相关的三个地址。再次强调，这是因为在删除`anakin`时发生了级联。
- en: This concludes our brief introduction to data persistence. It is a vast and,
    at times, complex domain, which I encourage you to explore learning as much theory
    as possible. Lack of knowledge or proper understanding, when it comes to database
    systems, can really bite.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对数据持久性的简要介绍。这是一个广阔且有时复杂的领域，我鼓励您尽可能多地学习理论。在涉及数据库系统时，缺乏知识或适当的理解可能会带来真正的麻烦。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have explored working with files and directories. We have
    learned how to open files for reading and writing and how to do that more elegantly
    by using context managers. We also explored directories: how to list their content,
    both recursively and not. We also learned about pathnames, which are the gateway
    to accessing both files and directories.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何处理文件和目录。我们学会了如何打开文件进行读写，以及如何通过使用上下文管理器更加优雅地进行操作。我们还探讨了目录：如何递归和非递归地列出它们的内容。我们还学习了路径名，这是访问文件和目录的入口。
- en: We then briefly saw how to create a ZIP archive, and extract its content. The
    source code of the book also contains an example with a different compression
    format: `tar.gz`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后简要介绍了如何创建ZIP存档，并提取其内容。该书的源代码还包含了一个不同压缩格式的示例：`tar.gz`。
- en: We talked about data interchange formats, and have explored JSON in some depth.
    We had some fun writing custom encoders and decoders for specific Python data
    types.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈到了数据交换格式，并深入探讨了JSON。我们在为特定的Python数据类型编写自定义编码器和解码器时玩得很开心。
- en: Then we explored IO, both with in-memory streams and HTTP requests.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了IO，包括内存流和HTTP请求。
- en: And finally, we saw how to persist data using `pickle`, `shelve`, and the SQLAlchemy
    ORM library.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了如何使用`pickle`、`shelve`和SQLAlchemy ORM库来持久化数据。
- en: You should now have a pretty good idea of how to deal with files and data persistence,
    and I hope you will take the time to explore these topics in much more depth by
    yourself.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该对如何处理文件和数据持久性有了相当好的了解，我希望您会花时间自己更深入地探索这些主题。
- en: The next chapter will look at testing, profiling, and dealing with exceptions.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论测试、性能分析和处理异常。
