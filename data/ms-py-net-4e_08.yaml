- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Network Monitoring with Python – Part 2
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行网络监控 – 第2部分
- en: In *Chapter 7*, *Network Monitoring with Python – Part 1*, we used SNMP to query
    information from network devices. We did this using an SNMP manager to query the
    SNMP agent residing on the network device. The SNMP information is structured
    in a hierarchy format with a specific object ID as a way to represent the value
    of the object. Most of the time, the value we care about is a number, such as
    CPU load, memory usage, or interface traffic. We can graph this data against time
    to give us a sense of how the value has changed over time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第7章*，*使用Python进行网络监控 – 第1部分*中，我们使用SNMP从网络设备查询信息。我们这样做是通过使用SNMP管理器查询网络设备上驻留的SNMP代理来完成的。SNMP信息以层次格式结构化，使用特定的对象ID作为表示对象值的方式。大多数时候，我们关心的值是一个数字，比如CPU负载、内存使用或接口流量。我们可以将此数据与时间对比，以了解值随时间的变化情况。
- en: We can typically classify the SNMP approach as a `pull` method as we constantly
    ask the device for a particular answer. This method adds a burden to the device
    because it needs to spend a CPU cycle on the control plane to find answers from
    the subsystem, package the answer in an SNMP packet, and transport the answer
    back to the poller. If you have ever been to a family reunion where you have that
    one family member who keeps asking you the same questions repeatedly, that would
    be analogous to the SNMP manager polling the managed node.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将SNMP方法分类为一种`拉`方法，因为我们不断地要求设备提供特定的答案。这种方法给设备增加了负担，因为它需要在控制平面花费CPU周期来从子系统找到答案，将答案打包成SNMP数据包，并将答案传输回轮询器。如果你曾经参加过那种有一个家庭成员总是反复问你同样问题的家庭聚会，那么这就像是SNMP管理器轮询受管节点。
- en: Over time, if we have multiple SNMP pollers querying the same device every 30
    seconds (you would be surprised how often this happens), the management overhead
    will become substantial. In the same family reunion example we have given, instead
    of one family member, imagine many people interrupting you every 30 seconds to
    ask you a question. I don’t know about you, but I know I would be very annoyed
    even if it was a simple question (or worse, if all of them were asking the same
    question).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，如果我们有多个SNMP轮询器每隔30秒查询同一设备（你会惊讶这有多么频繁），管理开销将变得很大。在我们给出的同一个家庭聚会的例子中，不是只有一个家庭成员，想象一下每隔30秒就有很多人打断你问问题。我不知道你怎么样，但我知道即使是一个简单的问题（或者更糟糕的是，如果他们都问同样的问题），我也会非常烦恼。
- en: Another way we can provide more efficient network monitoring is to reverse the
    relationship between the management station from a *pull* to a *push* model. In
    other words, the information can be pushed from the device toward the management
    station in an agreed-upon format. This concept is what flow-based monitoring is
    based on. In a flow-based model, the network device streams the traffic information,
    called flow, to the management station. The format can be the Cisco proprietary
    NetFlow (version 5 or 9), the industry-standard IPFIX, or the open source sFlow
    format. In this chapter, we will spend some time looking into NetFlow, IPFIX,
    and sFlow with Python.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供更高效的网络监控的另一种方法是，将管理站与设备之间的关系从*拉*模式改为*推*模式。换句话说，信息可以按照约定的格式从设备推送到管理站。这个概念就是基于流量的监控所依据的。在基于流量的模型中，网络设备将流量信息，称为流，流式传输到管理站。格式可以是思科的专有NetFlow（版本5或9），行业标准IPFIX，或者开源的sFlow格式。在本章中，我们将花一些时间探讨使用Python来研究NetFlow、IPFIX和sFlow。
- en: Not all monitoring comes in the form of time series data. You can represent
    information such as network topology and Syslog in a time series format if you
    want to, but this is not ideal. We can use Python to check network topology information
    and see whether the topology has changed over time. We can use tools, such as
    Graphviz, with a Python wrapper to illustrate the topology. As already seen in
    *Chapter 6*, *Network Security with Python*, Syslog contains security information.
    Later in this book, we will look at using the Elastic Stack (Elasticsearch, Logstash,
    Kibana, and Beat) as an efficient way to collect and index network security and
    log information.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的监控都是以时间序列数据的形式出现。如果你愿意，你可以将诸如网络拓扑和Syslog等信息表示为时间序列格式，但这并不理想。我们可以使用Python来检查网络拓扑信息，并查看拓扑是否随时间发生变化。我们可以使用工具，如Graphviz，以及Python包装器来展示拓扑。如已在*第6章*，*使用Python进行网络安全*中看到，Syslog包含安全信息。在本书的后续部分，我们将探讨使用Elastic
    Stack（Elasticsearch、Logstash、Kibana和Beat）作为收集和索引网络安全和日志信息的有效方式。
- en: 'Specifically, in this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，我们将涵盖以下主题：
- en: Graphviz, which is an open source graph visualization software that can help
    us quickly and efficiently graph our network
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Graphviz，这是一款开源的图形可视化软件，可以帮助我们快速高效地绘制我们的网络图
- en: Flow-based monitoring, such as NetFlow, IPFIX, and sFlow
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于流的监控，例如 NetFlow、IPFIX 和 sFlow
- en: Using ntop to visualize the flow of information
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ntop 可视化信息流
- en: Let’s start by looking at how to use Graphviz to monitor network topology changes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何使用 Graphviz 监控网络拓扑变化。
- en: Graphviz
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Graphviz
- en: 'Graphviz is an open source graph visualization software. Imagine we have to
    describe our network topology to a colleague without the benefit of a picture.
    We might say our network consists of three layers: core, distribution, and access.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Graphviz 是一款开源的图形可视化软件。想象一下，如果我们需要向同事描述我们的网络拓扑，而没有图片的帮助。我们可能会说，我们的网络由三层组成：核心层、分发层和接入层。
- en: The core layer comprises two routers for redundancy, and both of the routers
    are full-meshed toward the four distribution routers; the distribution routers
    are also full-meshed toward the access routers. The internal routing protocol
    is OSPF, and externally, we use BGP for peering with our service provider. While
    this description lacks some details, it is probably enough for your colleague
    to paint a pretty good high-level picture of your network.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 核心层由两个路由器组成，用于冗余，这两个路由器都向四个分发路由器全连接；分发路由器也向接入路由器全连接。内部路由协议是 OSPF，外部我们使用 BGP
    与我们的服务提供商对等。虽然这个描述缺少一些细节，但可能足以让您的同事为您描绘一个相当不错的高级网络图。
- en: Graphviz works similarly to the process by describing the graph in a text format
    that Graphviz can understand in a text file. We can then feed the file to the
    Graphviz program to construct the graph. Here, the graph is described in a text
    format called DOT ([https://en.wikipedia.org/wiki/DOT_(graph_description_language)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)))
    and Graphviz renders the graph based on the description. Of course, because the
    computer lacks human imagination, the language has to be very precise and detailed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Graphviz 的工作原理与描述文本格式的图，Graphviz 可以在文本文件中理解的过程相似。然后我们可以将文件输入到 Graphviz 程序中，构建图。在这里，图是以称为
    DOT 的文本格式描述的（[https://en.wikipedia.org/wiki/DOT_(graph_description_language)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)))，Graphviz
    根据描述渲染图。当然，因为计算机缺乏人类的想象力，语言必须非常精确和详细。
- en: For Graphviz-specific DOT grammar definitions, take a look at [http://www.graphviz.org/doc/info/lang.html](http://www.graphviz.org/doc/info/lang.html).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Graphviz 特定的 DOT 语法定义，请参阅 [http://www.graphviz.org/doc/info/lang.html](http://www.graphviz.org/doc/info/lang.html)。
- en: In this section, we will use the **Link Layer Discovery Protocol** (**LLDP**)
    to query the device neighbors and create a network topology graph via Graphviz.
    Upon completing this extensive example, we will see how we can take something
    new, such as Graphviz, and combine it with things we have already learned (network
    LLDP) to solve interesting problems (automatically graph the current network topology).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 **链路层发现协议**（**LLDP**）来查询设备邻居，并通过 Graphviz 创建网络拓扑图。完成这个广泛的示例后，我们将看到如何将一些新事物，如
    Graphviz，与我们已经学过的（网络 LLDP）结合起来，以解决有趣的问题（自动绘制当前网络拓扑）。
- en: Let’s start by looking over the lab we will be using.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们将要使用的实验室。
- en: Lab setup
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验室设置
- en: We will use the same lab topology as the last chapter. To recap, we have a three-tier
    topology, with r6 being the external facing edge device and r5 the top-of-rack
    router connecting to the server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与上一章相同的实验室拓扑。为了回顾，我们有一个三层拓扑，其中 r6 是面向外部的边缘设备，r5 是连接服务器的机架顶部路由器。
- en: '![Diagram  Description automatically generated](img/B18403_08_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B18403_08_01.png)'
- en: 'Figure 8.1: Lab topology'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：实验室拓扑
- en: 'The devices are vIOS devices to save on lab resources and simplify configuration:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 设备是 vIOS 设备，以节省实验室资源并简化配置：
- en: Nodes virtualized by NX-OS and IOS-XR are much more memory-intensive than IOS.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 NX-OS 和 IOS-XR 虚拟化的节点比 IOS 节点内存密集得多。
- en: If you wish to use NX-OS, consider using NX-API or other API calls that will
    return structured data.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你希望使用 NX-OS，考虑使用 NX-API 或其他返回结构化数据的 API 调用。
- en: 'The devices have the following information:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 设备有以下信息：
- en: '| **Device** | **Management IP** | **Loopback IP** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **设备** | **管理 IP** | **环回 IP** |'
- en: '| r1 | `192.168.2.218` | `192.168.0.1` |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| r1 | `192.168.2.218` | `192.168.0.1` |'
- en: '| r2 | `192.168.2.219` | `192.168.0.2` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| r2 | `192.168.2.219` | `192.168.0.2` |'
- en: '| r3 | `192.168.2.220` | `192.168.0.3` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| r3 | `192.168.2.220` | `192.168.0.3` |'
- en: '| r5 | `192.168.2.221` | `192.168.0.4` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| r5 | `192.168.2.221` | `192.168.0.4` |'
- en: '| r6 | `192.168.2.222` | `192.168.0.5` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| r6 | `192.168.2.222` | `192.168.0.5` |'
- en: 'The Ubuntu host’s information is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu主机的信息如下：
- en: '| **Device Name** | **External Link Eth0** | **Internal IP Eth1** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **设备名称** | **外部链路Eth0** | **内部IP Eth1** |'
- en: '| Client | `192.168.2.211` | `10.0.0.9` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 客户端 | `192.168.2.211` | `10.0.0.9` |'
- en: '| Server | `192.168.2.212` | `10.0.0.5` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 服务器 | `192.168.2.212` | `10.0.0.5` |'
- en: For our example, we will use LLDP ([https://en.wikipedia.org/wiki/Link_Layer_Discovery_Protocol](https://en.wikipedia.org/wiki/Link_Layer_Discovery_Protocol)).
    It is a vendor-neutral link-layer neighbor discovery protocol. Let us proceed
    to install the necessary software packages.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将使用LLDP（[https://en.wikipedia.org/wiki/Link_Layer_Discovery_Protocol](https://en.wikipedia.org/wiki/Link_Layer_Discovery_Protocol)）。它是一个厂商中立的链路层邻居发现协议。让我们继续安装必要的软件包。
- en: Installation
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: 'Graphviz can be obtained via `apt`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`apt`获取Graphviz：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After the installation is complete, note that verification is performed by
    using the `dot` command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，请注意，验证是通过使用`dot`命令来完成的：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will use the Python wrapper for Graphviz, so let’s install it now while
    we are at it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Graphviz的Python包装器，所以现在就让我们安装它：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s take a look at how we can use the software.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用这个软件。
- en: Graphviz examples
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Graphviz示例
- en: Like most popular open source projects, the documentation of Graphviz ([https://www.graphviz.org/documentation/](https://www.graphviz.org/documentation/))
    is extensive. The challenge for someone new to the software is often the starting
    point, going from zero to one. For our purpose, we will focus on the dot graph,
    which draws directed graphs as hierarchies (not to be confused with the DOT language,
    which is a graph description language).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就像大多数流行的开源项目一样，Graphviz（[https://www.graphviz.org/documentation/](https://www.graphviz.org/documentation/)）的文档非常全面。对于软件的新手来说，挑战通常是从零到一的起点。对于我们的目的，我们将专注于dot图，它以层次结构的形式绘制有向图（不要与DOT语言混淆，DOT是一种图形描述语言）。
- en: 'Let’s start with some of the basic concepts:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些基本概念开始：
- en: Nodes represent our network entities, such as routers, switches, and servers
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点代表我们的网络实体，例如路由器、交换机和服务器
- en: The edges represent the links between the network entities
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边代表网络实体之间的链接
- en: The graph, nodes, and edges each have attributes ([https://www.graphviz.org/doc/info/attrs.html](https://www.graphviz.org/doc/info/attrs.html))
    that can be tweaked
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图、节点和边都有属性（[https://www.graphviz.org/doc/info/attrs.html](https://www.graphviz.org/doc/info/attrs.html)），可以进行调整
- en: After describing the network, we can output the network graph ([https://www.graphviz.org/doc/info/output.html](https://www.graphviz.org/doc/info/output.html))
    in either PNG, JPEG, or PDF format
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在描述网络后，我们可以将网络图输出为PNG、JPEG或PDF格式（[https://www.graphviz.org/doc/info/output.html](https://www.graphviz.org/doc/info/output.html)）
- en: 'Our first example, `chapter8_gv_1.gv`, is an undirected dot graph consisting
    of four nodes (`core`, `distribution`, `access1`, and `access2`). The edges, represented
    by the dash (`-`) sign, join the core node to the distribution node, as well as
    the distribution node to both of the access nodes:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个例子，`chapter8_gv_1.gv`，是一个由四个节点（`core`、`distribution`、`access1`和`access2`）组成的无向点图。边由破折号（`-`）表示，将核心节点与分布节点连接起来，以及将分布节点与两个访问节点连接起来：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The graph can be output in the `dot -T<format> source -o <output file>` command
    line:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图可以通过`dot -T<格式> source -o <输出文件>`命令行输出：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The resultant graph can be viewed from the following output folder:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图可以在以下输出文件夹中查看：
- en: '![](img/B18403_08_02.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18403_08_02.png)'
- en: 'Figure 8.2: Graphviz undirected dot graph example'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：Graphviz无向点图示例
- en: Just like *Chapter 7*, *Network Monitoring with Python – Part 1*, it might be
    easier to work in the Linux desktop window while working with these graphs so
    you can see the graphs right away.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就像*第7章*，*使用Python进行网络监控 – 第1部分*，在处理这些图时在Linux桌面窗口中工作可能更容易一些，这样你就可以立即看到图。
- en: 'Note that we can use a directional graph by specifying the graph as a digraph
    and using the arrow (`->`) sign to represent the edges. There are several attributes
    we can modify in the case of nodes and edges, such as the node shape, edge labels,
    etc. The same graph can be modified as follows in `chapter8_gv_2.gv`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以通过指定图为一个digraph并使用箭头（`->`）符号来表示边来使用有向图。在节点和边的情况下，我们可以修改几个属性，例如节点形状、边标签等。相同的图可以在`chapter8_gv_2.gv`中按以下方式修改：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will output the file in PDF this time:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这次将输出PDF文件：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Take a look at the directional arrows in the new graph:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 查看新图中的方向箭头：
- en: '![](img/B18403_08_03.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18403_08_03.png)'
- en: 'Figure 8.3: Network graph with directional arrows and line descriptions'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3：带有方向箭头和行描述的网络图
- en: Now let’s take a look at the Python wrapper around Graphviz.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看围绕 Graphviz 的 Python 封装。
- en: Python with Graphviz examples
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 与 Graphviz 示例
- en: 'We can reproduce the same topology graph as before using the Python Graphviz
    package and construct the same three-layer network topology:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Python Graphviz 包重现之前相同的拓扑图并构建相同的三层网络拓扑：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code produces what you would normally write in the DOT language but in
    a more Pythonic way. You can view the source of the graph before the graph generation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 代码产生的结果与您通常在 DOT 语言中编写的相同，但方式更 Pythonic。您可以在生成图之前查看图的源代码：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The graph can be rendered by the `render()` method. By default, the output
    format is PDF:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图可以通过 `render()` 方法进行渲染。默认输出格式是 PDF：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Python package wrapper closely mimics all the API options of Graphviz. You
    can find documentation about the options on the Graphviz Read the Docs website
    ([http://graphviz.readthedocs.io/en/latest/index.html](http://graphviz.readthedocs.io/en/latest/index.html)).
    You can also refer to the source code on GitHub for more information ([https://github.com/xflr6/graphviz](https://github.com/xflr6/graphviz)).
    We are now ready to use the tool to map out our network.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Python 包封装紧密地模仿了 Graphviz 的所有 API 选项。您可以在 Graphviz Read The Docs 网站上找到有关选项的文档（[http://graphviz.readthedocs.io/en/latest/index.html](http://graphviz.readthedocs.io/en/latest/index.html)）。您还可以参考
    GitHub 上的源代码以获取更多信息（[https://github.com/xflr6/graphviz](https://github.com/xflr6/graphviz)）。我们现在可以使用该工具绘制我们的网络。
- en: LLDP neighbor graphing
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LLDP 邻居绘图
- en: 'In this section, we will use the example of mapping out LLDP neighbors to illustrate
    a problem-solving pattern that has helped me over the years:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用绘制 LLDP 邻居的例子来说明一种多年来帮助我的问题解决模式：
- en: Modularize each task into smaller pieces, if possible. In our example, we can
    combine a few steps, but if we break them into smaller pieces, we will be able
    to reuse and improve them more easily.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可能，将每个任务模块化成更小的部分。在我们的例子中，我们可以合并几个步骤，但如果我们将它们分解成更小的部分，我们将能够更容易地重用和改进它们。
- en: Use an automation tool to interact with the network devices, but keep the more
    complex logic aside at the management station. For example, the router has provided
    an LLDP neighbor output that is a bit messy. In this case, we will stick with
    the working command and the output and use a Python script at the management station
    to parse out the output we need.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自动化工具与网络设备交互，但在管理站保留更复杂的逻辑。例如，路由器提供了一个有点杂乱的 LLDP 邻居输出。在这种情况下，我们将坚持使用有效的命令和输出，并在管理站使用
    Python 脚本来解析我们需要的输出。
- en: When given choices for the same task, pick the one that can be reused. In our
    example, we can use low-level Pexpect, Paramiko, or Ansible playbooks to query
    the routers. In my opinion, Ansible is a more reusable option, so that is what
    I have picked.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当对同一任务有选择时，选择可重用的一个。在我们的例子中，我们可以使用低级 Pexpect、Paramiko 或 Ansible playbooks 来查询路由器。在我看来，Ansible
    是一个更可重用的选项，所以我选择了它。
- en: 'To get started, since LLDP is not enabled on the routers by default, we will
    need to configure them on the devices first. By now, we know we have a number
    of options to choose from; in this case, I chose the Ansible playbook with the
    `ios_config` module for the task. The `hosts` file consists of five routers:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，由于默认情况下路由器上未启用 LLDP，我们首先需要在设备上配置它们。到目前为止，我们知道我们有多个选项可供选择；在这种情况下，我选择了带有 `ios_config`
    模块的 Ansible playbook 来完成任务。`hosts` 文件包含五个路由器：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Each host contains the corresponding names in the `host_vars` folder. We are
    showing `r1` as an example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主机都包含 `host_vars` 文件夹中的对应名称。我们以 `r1` 为例：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `cisco_config_lldp.yml` playbook consists of one play with the `ios_lldp`
    module:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`cisco_config_lldp.yml` playbook 包含一个带有 `ios_lldp` 模块的 play：'
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `ios_lldp` Ansible module is new in version 2.5 and later. Use the `ios_config`
    module if you are using an older version of Ansible.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`ios_lldp` Ansible 模块是从版本 2.5 及以后版本中引入的。如果您使用的是较旧版本的 Ansible，请使用 `ios_config`
    模块。'
- en: 'Run the playbook to turn on `lldp`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '运行 playbook 以开启 `lldp`:'
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since the default `lldp` advertise timer is 30 seconds, we should wait a bit
    for `lldp` advertisements to be exchanged between the devices. We can verify that
    LLDP is indeed active on the routers and the neighbors it has discovered:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认的 `lldp` 广告定时器为 30 秒，我们应该等待一段时间，以便设备之间交换 `lldp` 广告。我们可以验证 LLDP 是否确实在路由器和它发现的邻居上激活：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In older versions of CML, e.g. VIRL, or other lab software, you might see LLDP
    neighbors on the `G0/0` MGMT interfaces. What we really care about are the `G0/1`
    and `G0/2` interfaces that are directly connected to other peers. This information
    will come in handy as we prepare to parse the output and construct our topology
    graph.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在CML的旧版本中，例如VIRL或其他实验室软件中，你可能会在`G0/0`管理接口上看到LLDP邻居。我们真正关心的是直接连接到其他对等体的`G0/1`和`G0/2`接口。当准备解析输出和构建我们的拓扑图时，这些信息将非常有用。
- en: Information retrieval
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信息检索
- en: We can now use another Ansible playbook, namely `cisco_discover_lldp.yml`, to
    execute the LLDP command on the device and copy the output of each device to a
    `tmp` directory.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用另一个Ansible剧本，即`cisco_discover_lldp.yml`，在设备上执行LLDP命令，并将每个设备的输出复制到`tmp`目录。
- en: 'Let’s create the `tmp` directory:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`tmp`目录：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The playbook will have three tasks. The first task will execute the `show lldp`
    neighbor command on each of the devices, the second task will display the output,
    and the third task will copy the output to a text file in the output directory:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该剧本将包含三个任务。第一个任务将在每个设备上执行`show lldp`邻居命令，第二个任务将显示输出，第三个任务将输出目录中的输出复制到文本文件：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After execution, the `./tmp` directory now contains all the routers’ output
    (showing LLDP neighbors) in its own file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，`./tmp`目录现在包含所有路由器的输出（显示LLDP邻居）在其自己的文件中：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`r1_lldp_output.txt`, as with the rest of the output files, contains the `output.stdout_lines`
    variable from the Ansible playbook for each device:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`r1_lldp_output.txt`，与其他输出文件一样，包含来自Ansible剧本的每个设备的`output.stdout_lines`变量：'
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So far, we have worked on retrieving information from network devices. Now we
    are ready to tie everything together with a Python script.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经从网络设备中检索信息。现在我们准备使用Python脚本来整合所有内容。
- en: Python parser script
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python解析脚本
- en: We can now use a Python script to parse the LLDP neighbor output from each device
    and construct a network topology graph from the results. The purpose is to automatically
    check the device to see whether any LLDP neighbors have disappeared due to link
    failure or other issues. Let’s look at the `cisco_graph_lldp.py` file and see
    how that is done.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用Python脚本来解析每个设备的LLDP邻居输出，并从结果中构建网络拓扑图。目的是自动检查设备，看是否有任何LLDP邻居因链路故障或其他问题而消失。让我们看看`cisco_graph_lldp.py`文件，看看它是如何完成的。
- en: 'We start with the necessary imports of the packages: an empty list that we
    will populate with tuples of node relationships. We also know that `Gi0/0` on
    the devices is connected to the management network; therefore, we are only searching
    for `Gi0/[1234]` as our regular expression pattern in the `show LLDP neighbors`
    output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从必要的包导入开始：一个空列表，我们将用表示节点关系的元组填充它。我们还知道设备上的`Gi0/0`连接到管理网络；因此，我们在`show LLDP
    neighbors`输出中只搜索`Gi0/[1234]`作为我们的正则表达式模式：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will use the `glob.glob()` method to traverse the `./tmp` directory of all
    the files, parse out the device name, and find the neighbors that the device is
    connected to. There are some embedded print statements in the script that we can
    comment out for the final version; if the statements are uncommented, we can see
    the parsed result:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`glob.glob()`方法遍历`./tmp`目录下的所有文件，解析出设备名称，并找到设备连接到的邻居。脚本中包含一些嵌入的打印语句，我们可以在最终版本中将其注释掉；如果取消注释这些语句，我们可以看到解析结果：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The fully populated edge list contains tuples that consist of the device and
    its neighbors:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的边缘列表包含由设备和其邻居组成的元组：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can now construct the network topology graph using the Graphviz package.
    The most important part is the unpacking of the tuples that represent the edge
    relationship:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用Graphviz包构建网络拓扑图。最重要的是解包表示边关系的元组：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we were to print out the resulting source dot file, it would be an accurate
    representation of our network:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印出结果源dot文件，它将是我们网络的准确表示：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Sometimes, it is confusing to see the same link twice; for example, the `r2`
    to `r5-tor` link appeared twice in the previous diagram for each of the directions
    of the link. As network engineers, we understand that sometimes a fault in the
    physical link will result in a unidirectional link, which we don’t want to see.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，看到相同的链路两次可能会令人困惑；例如，在之前的图中，`r2`到`r5-tor`链路在每个链路方向上出现了两次。作为网络工程师，我们知道有时物理链路的故障会导致单向链路，这是我们不想看到的。
- en: 'If we were to graph the diagram as is, the placement of the nodes would be
    a bit funky. The placement of the nodes is auto-rendered. The following diagram
    illustrates the rendering in a default layout as well as the `neato` layout, namely,
    a digraph (`My_Network`, `engine=''neato''`):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按照原样绘制图表，节点的放置可能会有些奇怪。节点的放置是自动渲染的。以下图表展示了默认布局以及`neato`布局（即有向图`My_Network`，`engine='neato'`）的渲染：
- en: '![](img/B18403_08_04.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18403_08_04.png)'
- en: 'Figure 8.4: Topology graph 1'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：拓扑图1
- en: 'The `neato` layout represents an attempt to draw undirected graphs with even
    less hierarchy:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`neato`布局代表了一种尝试用更少的层次结构绘制无向图的方法：'
- en: '![](img/B18403_08_05.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18403_08_05.png)'
- en: 'Figure 8.5: Topology graph 2'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：拓扑图2
- en: 'Sometimes, the default layout presented by the tool is just fine, especially
    if your goal is to detect faults instead of making them visually appealing. However,
    in this case, let’s see how we can insert raw DOT language knobs into the source
    file. From research, we know that we can use the `rank` command to specify the
    level where some nodes can stay on the same level. However, there is no option
    presented in the Graphviz Python API. Luckily, the dot source file is just a string,
    which we can insert as raw dot comments using the `replace()` method with the
    following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，工具提供的默认布局就足够好了，特别是如果你的目标是检测故障而不是使其视觉效果吸引人。然而，在这种情况下，让我们看看我们如何可以将原始DOT语言控件插入到源文件中。从研究中我们知道，我们可以使用`rank`命令来指定某些节点可以保持在同一级别的层级。然而，Graphviz
    Python API中没有提供这样的选项。幸运的是，DOT源文件只是一个字符串，我们可以使用`replace()`方法将其作为原始DOT注释插入，如下所示：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The end result is a new source that we can render the final topology graph
    from:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是我们可以从中渲染最终拓扑图的新的源：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The graph is now good to go with the correct hierarchy:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在图形已经准备好，具有正确的层次结构：
- en: '![](img/B18403_08_06.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18403_08_06.png)'
- en: 'Figure 8.6: Topology graph 3'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：拓扑图3
- en: We have used the Python script to automatically retrieve network information
    from the devices and automatically graph the topology. It is quite a bit of work,
    but the reward is the consistency and the assurance that the graph always represents
    the latest state of the actual network. Let’s follow up with some verification
    that our script can detect the latest state change of the network with the necessary
    graph.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用Python脚本来自动从设备中检索网络信息，并自动绘制拓扑图。这是一项相当多的工作，但回报是确保图形始终代表实际网络的最新状态。让我们通过一些验证来确保我们的脚本可以通过必要的图形检测到网络的最新状态变化。
- en: Testing the playbook
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试剧本
- en: We are now ready to incorporate a test to check whether the playbook can accurately
    depict the topology change when a link change happens.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好添加一个测试来检查剧本是否能够准确描述当链路发生变化时拓扑结构的变化。
- en: 'We can test this by shutting down the `Gi0/1` and `Go0/2` interfaces on `r6-edge`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过关闭`r6-edge`上的`Gi0/1`和`Go0/2`接口来测试这一点：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When the LLDP neighbor passes the hold timer, they will disappear from the
    LLDP table on `r6-edge`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当LLDP邻居通过保持计时器后，它们将从`r6-edge`上的LLDP表中消失：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we execute the playbook and the Python script, the graph will automatically
    show `r6-edge` only connects to `r3` and we can start to troubleshoot why that
    is the case:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行剧本和Python脚本，图形将自动显示`r6-edge`仅连接到`r3`，我们可以开始排查为什么会出现这种情况：
- en: '![](img/B18403_08_07.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18403_08_07.png)'
- en: 'Figure 8.7: Topology graph 4'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：拓扑图4
- en: This is a relatively long example demonstrating multiple tools working together
    to solve a problem. We used the tools we have learned – Ansible and Python – to
    modularize and break tasks into reusable pieces.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对较长的示例，展示了多个工具协同工作以解决问题。我们使用了我们所学到的工具——Ansible和Python——来模块化并将任务分解成可重用的部分。
- en: We then used a new tool, namely, Graphviz, to help monitor the network for non-time
    series data, such as network topology relationships.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用了一个新的工具，即Graphviz，来帮助监控网络，例如网络拓扑关系等非时间序列数据。
- en: In the next section, we will change direction a bit and look into monitoring
    our network with network flows collected by our network equipment.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将稍微改变方向，探讨使用我们网络设备收集的网络流来监控我们的网络。
- en: Flow-based monitoring
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于流的监控
- en: As mentioned in the chapter introduction, besides polling technology, such as
    SNMP, we can also use a push strategy, which allows the device to push network
    information toward the management station. NetFlow and its closely associated
    cousins, IPFIX and sFlow, are examples of such information pushed from the direction
    of the network device toward the management station. We can argue that the `push`
    method is more sustainable since the network device is inherently in charge of
    allocating the necessary resources to push the information. If the device CPU
    is busy, for example, it can skip the flow export process in favor of a more critical
    task such as routing packets.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如章节介绍中提到的，除了轮询技术，如SNMP，我们还可以使用推送策略，允许设备将网络信息推送到管理站。NetFlow及其紧密相关的IPFIX和sFlow就是从网络设备向管理站推送信息的例子。我们可以认为推送方法更可持续，因为网络设备本质上负责分配推送信息所需的资源。例如，如果设备CPU忙碌，它可以跳过流导出过程，转而执行更关键的任务，如路由数据包。
- en: A flow, as defined by IETF ([https://www.ietf.org/proceedings/39/slides/int/ip1394-background/tsld004.htm](https://www.ietf.org/proceedings/39/slides/int/ip1394-background/tsld004.htm)),
    is a sequence of packets moving from an application sending something to the application
    receiving it. If we refer back to the OSI model, a flow is what constitutes a
    single unit of communication between two applications. Each flow comprises some
    packets; some flows have more packets (such as a video stream), while some have
    just a few (such as an HTTP request). If you think about flows for a minute, you’ll
    notice that routers and switches might care about packets and frames, but the
    application and user usually care more about the network flows.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 流，正如IETF定义的（[https://www.ietf.org/proceedings/39/slides/int/ip1394-background/tsld004.htm](https://www.ietf.org/proceedings/39/slides/int/ip1394-background/tsld004.htm)），是指从发送应用向接收应用移动的数据包序列。如果我们回顾OSI模型，流就是构成两个应用之间单一通信单元的东西。每个流包含一些数据包；有些流包含更多的数据包（例如视频流），而有些则只有少数几个（例如HTTP请求）。如果你花一分钟思考流，你会注意到路由器和交换机可能更关心数据包和帧，但应用和用户通常更关心网络流。
- en: 'Flow-based monitoring usually refers to NetFlow, IPFIX, and sFlow:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 基于流的监控通常指的是NetFlow、IPFIX和sFlow：
- en: '**NetFlow**: NetFlow v5 is a technology where the network device caches flow
    entries and aggregates packets by matching the set of tuples (source interface,
    source IP/port, destination IP/port, and so on). Once a flow is completed, the
    network device exports the flow characteristics, including total bytes and packet
    counts, to the management station.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NetFlow**：NetFlow v5是一种技术，网络设备缓存流条目并通过匹配一系列元组（源接口、源IP/端口、目的IP/端口等）来聚合数据包。一旦流完成，网络设备将流特征导出到管理站，包括总字节数和包计数。'
- en: '**IPFIX**: IPFIX is the proposed standard for structured streaming and is similar
    to NetFlow v9, also known as Flexible NetFlow. Essentially, it is a definable
    flow export, which allows the user to export nearly anything that the network
    device knows about. The flexibility often comes at the expense of simplicity compared
    to NetFlow v5\. The configuration of IPFIX is more complex than the traditional
    NetFlow v5\. Additional complexity makes it less ideal for introductory learning.
    However, once you are familiar with NetFlow v5, you can parse IPFIX as long as
    you match the template definition.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IPFIX**：IPFIX是结构化流式传输的提议标准，类似于NetFlow v9，也称为灵活NetFlow。本质上，它是一个可定义的流导出，允许用户导出网络设备所知的几乎所有内容。与NetFlow
    v5相比，灵活性通常以简单性为代价。IPFIX的配置比传统的NetFlow v5更复杂。额外的复杂性使其不太适合入门学习。然而，一旦你熟悉了NetFlow
    v5，你就可以解析IPFIX，只要匹配模板定义即可。'
- en: '**sFlow**: sFlow has no notion of a flow or packet aggregation by itself. It
    performs two types of sampling of packets. It randomly samples one out of “n”
    packets/applications and has a time-based sampling counter. It sends the information
    to the management station, and the station derives the network flow information
    by referring to the type of packet sample received along with the counters. As
    it doesn’t perform any aggregation on the network device, you can argue that sFlow
    is more scalable than NetFlow and IPFIX.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sFlow**：sFlow本身没有关于流或数据包聚合的概念。它执行两种类型的数据包采样。它随机从“n”个数据包/应用中采样一个，并有一个基于时间的采样计数器。它将信息发送到管理站，该站通过参考接收到的数据包样本类型和计数器来推导网络流信息。由于它不对网络设备执行任何聚合操作，你可以认为sFlow比NetFlow和IPFIX更可扩展。'
- en: The best way to learn about each one of these is probably to dive right into
    examples. Let’s get into some of the flow-based examples in the following section.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 了解每一个的最佳方式可能是直接通过示例进行学习。让我们在下一节中查看一些基于流的示例。
- en: NetFlow parsing with Python
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 进行 NetFlow 解析
- en: We can use Python to parse the NetFlow datagram transported on the wire. This
    allows us to look at the NetFlow packet in detail and troubleshoot any NetFlow
    issues that are not working as expected.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Python 解析在网络上传输的 NetFlow 数据报。这允许我们详细查看 NetFlow 数据包，并排除任何不符合预期的 NetFlow
    问题。
- en: 'First, let’s generate traffic between the client and server across the lab
    network. We can use the built-in HTTP server module from Python to quickly launch
    a simple HTTP server on the VIRL host acting as the server. Open a new Terminal
    window to the server host and start the HTTP server; let’s keep the window open:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在实验室网络中生成客户端和服务器之间的流量。我们可以使用 Python 内置的 HTTP 服务器模块在充当服务器的 VIRL 主机上快速启动一个简单的
    HTTP 服务器。打开一个新的终端窗口到服务器主机并启动 HTTP 服务器；让我们保持窗口开启：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For Python 2, the module is named `SimpleHTTPServer`, for example, `python2
    -m SimpleHTTPServer`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python 2，该模块名为 `SimpleHTTPServer`，例如，`python2 -m SimpleHTTPServer`。
- en: 'In a separate Terminal window, `ssh` to the client. We can create a short `while`
    loop in a Python script to continuously send `HTTP GET` to the web server:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个单独的终端窗口中，使用 `ssh` 连接到客户端。我们可以在 Python 脚本中创建一个短的 `while` 循环来持续向 Web 服务器发送
    `HTTP GET`：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The client should get a very plain HTML page every 5 seconds:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应该每 5 秒收到一个非常简单的 HTML 页面：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we look back to the server Terminal window, we should also see the requests
    continuously coming in from the client every 5 seconds:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾服务器的终端窗口，我们还应该看到客户端每 5 秒连续发送的请求：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The traffic from the client to the server traverses through the network devices,
    and we can export NetFlow from any of the devices in between. Since `r6-edge`
    is the first hop for the client host, we will have this router export NetFlow
    to the management host at port `9995`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端到服务器的流量穿过网络设备，我们可以从中间的任何设备导出 NetFlow。由于 `r6-edge` 是客户端主机的第一个跳点，我们将让这个路由器将
    NetFlow 导出到管理主机的 `9995` 端口。
- en: In this example, we use only one device for demonstration; therefore, we manually
    configure it with the necessary commands. In the next section, when we enable
    NetFlow on all the devices, we will use an Ansible playbook to configure all the
    routers at once.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只使用一个设备进行演示；因此，我们手动使用必要的命令进行配置。在下一节中，当我们启用所有设备的 NetFlow 时，我们将使用 Ansible
    playbook 一次性配置所有路由器。
- en: 'The following configurations are necessary for exporting NetFlow on Cisco IOS
    devices:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cisco IOS 设备上导出 NetFlow 需要以下配置：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Next, let’s look at the Python parser script that helps us separate the different
    network flow fields we received from network devices.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 Python 解析脚本，它帮助我们分离从网络设备接收到的不同网络流字段。
- en: Python Socket and Struct
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python Socket 和 Struct
- en: The script, `netFlow_v5_parser.py`, was modified from Brian Rak’s blog post
    at [http://blog.devicenull.org/2013/09/04/python-netflow-v5-parser.html](http://blog.devicenull.org/2013/09/04/python-netflow-v5-parser.html).
    The modification was mainly for Python 3 compatibility and parsing additional
    NetFlow version 5 fields. The reason we chose NetFlow v5 instead of NetFlow v9
    is that v9 is more complex and uses templates to map out the fields, making it
    more difficult to learn in an introductory session. However, since NetFlow version
    9 is an extended format of the original NetFlow version 5, all the concepts we
    introduced in this section apply to it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本 `netFlow_v5_parser.py` 是从 Brian Rak 的博客文章 [http://blog.devicenull.org/2013/09/04/python-netflow-v5-parser.html](http://blog.devicenull.org/2013/09/04/python-netflow-v5-parser.html)
    中修改而来的。修改主要是为了 Python 3 兼容性和解析额外的 NetFlow 版本 5 字段。我们选择 NetFlow v5 而不是 NetFlow
    v9 的原因是 v9 更复杂，并使用模板来映射字段，这使得在入门课程中学习更加困难。然而，由于 NetFlow 版本 9 是原始 NetFlow 版本 5
    的扩展格式，本节中介绍的所有概念都适用于它。
- en: Because NetFlow packets are represented in bytes over the wire, we will use
    the Python struct module included in the standard library to convert bytes into
    native Python data types.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 NetFlow 数据包在网络上以字节形式表示，我们将使用标准库中包含的 Python struct 模块将字节转换为原生 Python 数据类型。
- en: You can find more information about the two modules at [https://docs.python.org/3.10/library/socket.html](https://docs.python.org/3.10/library/socket.html)
    and [https://docs.python.org/3.10/library/struct.html](https://docs.python.org/3.10/library/struct.html).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.python.org/3.10/library/socket.html](https://docs.python.org/3.10/library/socket.html)和[https://docs.python.org/3.10/library/struct.html](https://docs.python.org/3.10/library/struct.html)找到更多关于这两个模块的信息。
- en: 'In the script, we will start by using the `socket` module to bind and listen
    for the UDP datagrams. With `socket.AF_INET`, we intend on listening to the IPv4
    address sockets; with `socket.SOCK_DGRAM`, we specify that we’ll see the UDP datagram:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，我们将首先使用`socket`模块来绑定并监听UDP数据报。使用`socket.AF_INET`，我们打算监听IPv4地址套接字；使用`socket.SOCK_DGRAM`，我们指定我们将看到UDP数据报：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will start a loop and retrieve information off the wire 1,500 bytes at a
    time:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启动一个循环，每次从线路上检索1,500字节的信息：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following line is where we begin to deconstruct or unpack the packet. The
    first argument of `!HH` specifies the network’s big-endian byte order with the
    exclamation point (big-endian) as well as the format of the C type (`H = 2` byte
    unsigned short integer):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行是我们开始分解或解包数据包的地方。`!HH`的第一个参数指定了网络的大端字节序（感叹号表示大端）以及C类型的格式（`H = 2`字节无符号短整数）：
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The first 4 bytes include the version and the number of flows exported in this
    packet. If you do not remember the NetFlow version 5 header off the top of your
    head (that was a joke, by the way; I only read the header when I want to fall
    asleep quickly), here is a glance:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个字节包括版本和在此数据包中导出的流数量。如果你不记得NetFlow版本5的头部（顺便说一句，那是一个笑话；我只在想要快速入睡时才阅读头部），这里是一个快速浏览：
- en: '![](img/B18403_08_08.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18403_08_08.png)'
- en: 'Figure 8.8: NetFlow v5 header (source: http://www.cisco.com/c/en/us/td/docs/net_mgmt/netﬂow_collection_engine/3-6/user/guide/format.html#wp1006108)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：NetFlow v5头部（来源：http://www.cisco.com/c/en/us/td/docs/net_mgmt/netﬂow_collection_engine/3-6/user/guide/format.html#wp1006108）
- en: 'The rest of the header can be parsed accordingly, depending on the byte location
    and data type. Python allows us to unpack several header items in a single line:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 根据字节位置和数据类型，可以相应地解析其余的头部。Python允许我们在一行中解包多个头部项：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `while` loop that follows will fill the `nfdata` dictionary with the flow
    record that unpacks the source address and port, destination address and port,
    packet count, and byte count and print the information out on the screen:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`while`循环将填充`nfdata`字典，其中包含解包源地址和端口、目标地址和端口、数据包计数和字节计数的流记录，并将信息打印到屏幕上：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output of the script allows you to visualize the header as well as the
    flow content at a glance. In the following output, we can see both BGP control
    packets (TCP port `179`) as well as HTTP traffic (TCP port `8000`) on `r6-edge`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的输出允许您一目了然地可视化头部以及流内容。在以下输出中，我们可以看到`r6-edge`上的BGP控制包（TCP端口`179`）以及HTTP流量（TCP端口`8000`）：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that, in NetFlow version 5, the record size is fixed at 48 bytes; therefore,
    the loop and script are relatively straightforward.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在NetFlow版本5中，记录大小固定为48字节；因此，循环和脚本相对简单。
- en: However, in the case of NetFlow version 9 or IPFIX, after the header, there
    is a template FlowSet ([http://www.cisco.com/en/US/technologies/tk648/tk362/technologies_white_paper09186a00800a3db9.html](http://www.cisco.com/en/US/technologies/tk648/tk362/technologies_white_paper09186a00800a3db9.html))
    that specifies the field count, field type, and field length. This allows the
    collector to parse the data without knowing the data format in advance. We will
    need to build additional logic in the Python script for NetFlow version 9.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在NetFlow版本9或IPFIX的情况下，在头部之后，有一个模板FlowSet（[http://www.cisco.com/en/US/technologies/tk648/tk362/technologies_white_paper09186a00800a3db9.html](http://www.cisco.com/en/US/technologies/tk648/tk362/technologies_white_paper09186a00800a3db9.html)），它指定了字段计数、字段类型和字段长度。这使得收集器可以在不知道数据格式的情况下解析数据。我们需要在Python脚本中为NetFlow版本9构建额外的逻辑。
- en: By parsing the NetFlow data in a script, we gained a solid understanding of
    the fields, but this is very tedious and hard to scale. As you may have guessed,
    other tools save us the problem of parsing NetFlow records one by one. Let’s look
    at one such tool, called **ntop**, in the coming section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在脚本中解析NetFlow数据，我们深入理解了字段，但这非常繁琐且难以扩展。正如你可能猜到的，其他工具解决了逐个解析NetFlow记录的问题。让我们在下一节中看看这样一个工具，称为**ntop**。
- en: ntop traffic monitoring
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ntop流量监控
- en: Like the PySNMP script in *Chapter 7*, *Network Monitoring with Python – Part
    1**,* and the NetFlow parser script in this chapter, we can use Python scripts
    to handle low-level tasks on the wire. However, there are tools such as Cacti,
    which is an all-in-one open source package that includes data collection (pollers),
    data storage (RRDs), and a web frontend for visualization. These tools can save
    you a lot of work by packing the frequently used features and software in one
    package.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与*第7章*中的PySNMP脚本和本章中的NetFlow解析器脚本一样，我们可以使用Python脚本来处理线上的低级任务。然而，有一些工具，如Cacti，这是一个包含数据收集（轮询器）、数据存储（RRDs）和用于可视化的Web前端的一站式开源包。这些工具可以通过在一个包中打包常用的功能和软件来节省你大量的工作。
- en: In the case of NetFlow, there are several open source and commercial NetFlow
    collectors we can choose from. If we do a quick search for the top N open source
    NetFlow analyzers, we will see several comparison studies for different tools.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在NetFlow的情况下，我们有几个开源和商业NetFlow收集器可供选择。如果我们快速搜索前N个开源NetFlow分析器，我们将看到针对不同工具的几个比较研究。
- en: Each one has its strengths and weaknesses; which one to use is a matter of preference,
    platform, and appetite for customization. I would recommend choosing a tool that
    would support both v5 and v9, and potentially sFlow. A secondary consideration
    would be whether the tool is written in a language that we can understand; I would
    imagine having Python extensibility would be a nice thing.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 每个都有自己的优点和缺点；使用哪个取决于个人喜好、平台和对定制的需求。我建议选择一个支持v5和v9，以及可能sFlow的工具。次要考虑因素是工具是否是用我们能够理解的语言编写的；我想象拥有Python的可扩展性将是一件好事。
- en: Two of the open source NetFlow tools I like and have used before are NfSen (with
    NFDUMP as the backend collector) and `ntop` (or `ntopng`). Between the two of
    them, `ntop` is the better-known traffic analyzer; it runs on both Windows and
    Linux platforms and integrates well with Python. Therefore, let’s use `ntop` as
    an example in this section.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢并之前使用过的两个开源NetFlow工具是NfSen（后端收集器为NFDUMP）和`ntop`（或`ntopng`）。在这两者之间，`ntop`是更知名的流量分析器；它运行在Windows和Linux平台上，并且与Python集成良好。因此，让我们在本节中使用`ntop`作为示例。
- en: Similar to Cacti, ntop is an all-in-one tool. I recommend installing ntop on
    a separate host than the management station in production or a container on the
    management station.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与Cacti类似，ntop是一个一站式工具。我建议在生产环境中在管理站之外安装ntop，或者在管理站上安装容器。
- en: 'The installation of our Ubuntu host is straightforward:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Ubuntu主机的安装过程很简单：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The installation process will prompt for the necessary interface for listening
    and setting the administrator password. By default, the `ntop` web interface listens
    on port `3000`, while the probe listens on UDP port `5556`. On the network device,
    we need to specify the location of the NetFlow exporter:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程将提示必要的监听接口和设置管理员密码。默认情况下，`ntop`的Web界面监听端口`3000`，而探针监听UDP端口`5556`。在网络设备上，我们需要指定NetFlow导出器的位置：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: By default, IOSv creates a VRF called `Mgmt-intf` and places `Gi0/0` under VRF.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，IOSv创建一个名为`Mgmt-intf`的VRF，并将`Gi0/0`置于VRF下。
- en: 'We will also need to specify the direction of traffic exports, such as `ingress`
    or `egress`, under the interface configuration:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在接口配置下指定流量导出的方向，例如`ingress`或`egress`：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: For your reference, I have included the Ansible playbook, `cisco_config_netflow.yml`,
    to configure the lab device for the NetFlow export.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了供你参考，我包括了Ansible playbook，`cisco_config_netflow.yml`，用于配置实验室设备的NetFlow导出。
- en: '`r5-tor` and `r6-edge` have two more interfaces than `r1`, `r2`, and `r3`;
    therefore, there is an additional playbook to enable the additional interfaces
    for them.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`r5-tor`和`r6-edge`比`r1`、`r2`和`r3`多两个接口；因此，有一个额外的playbook来为它们启用额外的接口。'
- en: 'Execute the playbook and make sure the changes were applied properly on the
    devices:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 执行playbook并确保设备上正确应用了更改：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It is always a good idea to verify the device configuration after the playbook
    is run, so let’s spot-check on `r2`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在playbook运行后验证设备配置总是一个好主意，所以让我们对`r2`进行抽查：
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once everything is set up, you can check the **ntop** web interface for local
    IP traffic:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一切设置完成后，你可以检查**ntop**的Web界面以查看本地IP流量：
- en: '![](img/B18403_08_09.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18403_08_09.png)'
- en: 'Figure 8.9: ntop local IP traffic'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：ntop本地IP流量
- en: 'One of the most often used features of ntop is using it to look at the Top
    Talkers graph:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ntop最常使用的功能之一是使用它查看Top Talkers图：
- en: '![Table  Description automatically generated](img/B18403_08_10.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![表格  自动生成的描述](img/B18403_08_10.png)'
- en: 'Figure 8.10: ntop top talkers'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：ntop主要通信者
- en: The ntop reporting engine is written in C; it is fast and efficient, but the
    need to have adequate knowledge of C to do something as simple as changing the
    web frontend does not fit the modern agile development mindset.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ntop报告引擎是用C编写的；它快速高效，但需要对C有足够的了解才能进行像更改Web前端这样简单的操作，这与现代敏捷开发思维不符。
- en: After a few false starts with Perl in the mid-2000s, the good folks at ntop
    finally settled on embedding Python as an extensible scripting engine. Let’s take
    a look.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年代中期尝试使用Perl失败几次后，ntop的好人们最终决定嵌入Python作为可扩展的脚本引擎。让我们看看。
- en: Python extension for ntop
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ntop的Python扩展
- en: 'We can use Python to extend ntop through the ntop web server. The ntop web
    server can execute Python scripts. At a high level, the scripts will involve the
    following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Python通过ntop Web服务器扩展ntop。ntop Web服务器可以执行Python脚本。从高层次来看，脚本将涉及以下内容：
- en: Methods to access the state of ntop
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问ntop状态的几种方法
- en: The Python CGI module to process forms and URL parameters
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python CGI模块用于处理表单和URL参数
- en: Making templates that generate dynamic HTML pages
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作生成动态HTML页面的模板
- en: Each Python script can read from `stdin` and print out `stdout/stderr`. The
    `stdout` script is the returned HTTP page.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个Python脚本都可以从`stdin`读取并输出`stdout/stderr`。`stdout`脚本即为返回的HTTP页面。
- en: 'Several resources come in handy with Python integration. Under the web interface,
    you can click on **About | Show Configuration** to see the Python interpreter
    version as well as the directory for your Python script:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Python集成提供了几个有用的资源。在Web界面下，您可以点击**关于 | 显示配置**来查看Python解释器版本以及您的Python脚本目录：
- en: '![A picture containing table  Description automatically generated](img/B18403_08_11.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![包含表格的图片  自动生成的描述](img/B18403_08_11.png)'
- en: 'Figure 8.11: Python version'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：Python版本
- en: 'You can also check the various directories where the Python script should reside:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以检查Python脚本应驻留的各个目录：
- en: '![Table  Description automatically generated](img/B18403_08_12.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![表格  自动生成的描述](img/B18403_08_12.png)'
- en: 'Figure 8.12: Plugin directories'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：插件目录
- en: 'Under **About | Online Documentation | Python ntop Engine**, there are links
    for the Python API as well as the tutorial:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在**关于 | 在线文档 | Python ntop引擎**下，有Python API和教程的链接：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18403_08_13.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序  自动生成的描述](img/B18403_08_13.png)'
- en: 'Figure 8.13: Python ntop documentation'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：Python ntop文档
- en: 'As mentioned, the `ntop` web server directly executes the Python script placed
    under the designated directory:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`ntop` Web服务器直接执行放置在指定目录下的Python脚本：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We will place our first script, namely, `chapter8_ntop_1.py`, in the directory.
    The Python `CGI` module processes forms and parses URL parameters:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的第一个脚本，即`chapter8_ntop_1.py`，放置在目录中。Python `CGI`模块处理表单并解析URL参数：
- en: '[PRE45]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`ntop` implements three Python modules; each one of them has a specific purpose:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`ntop`实现了三个Python模块；每个模块都有特定的用途：'
- en: '**ntop**: This module interacts with the `ntop` engine.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ntop**: 本模块与`ntop`引擎交互。'
- en: '**Host**: This module drills down into a specific host’s information.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主持人**: 本模块深入解析特定主机的信息。'
- en: '**Interfaces**: This module represents the information about the localhost
    interfaces.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口**: 本模块表示本地主机接口的信息。'
- en: 'In our script, we will use the `ntop` module to retrieve the `ntop` engine
    information as well as using the `sendString()` method to send the HTML body text:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的脚本中，我们将使用`ntop`模块检索`ntop`引擎信息，并使用`sendString()`方法发送HTML正文：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We will execute the Python script using `http://<ip>:3000/python/<script name>`.
    Here is the result of our `chapter8_ntop_1.py` script:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`http://<ip>:3000/python/<script name>`执行Python脚本。以下是我们的`chapter8_ntop_1.py`脚本的执行结果：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18403_08_14.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序、电子邮件  自动生成的描述](img/B18403_08_14.png)'
- en: 'Figure 8.14: ntop script result'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：ntop脚本结果
- en: 'We can look at another example that interacts with the interface module, `chapter8_ntop_2.py`.
    We will use the API to iterate through the interfaces:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看另一个与接口模块交互的示例，即`chapter8_ntop_2.py`。我们将使用API遍历接口：
- en: '[PRE47]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The resulting page will display the `ntop` interfaces:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的页面将显示`ntop`接口：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18403_08_15.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件  自动生成的描述](img/B18403_08_15.png)'
- en: 'Figure 8.15: ntop interface information'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15：ntop界面信息
- en: Besides the community version, ntop also offers a few commercial products that
    you can choose from. With the active open source community, commercial backing,
    and Python extensibility, ntop is a good choice for your NetFlow monitoring needs.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 除了社区版之外，ntop还提供了一些商业产品，您可以选择。凭借活跃的开源社区、商业支持以及Python可扩展性，ntop是满足您的NetFlow监控需求的好选择。
- en: 'Next, let’s take a look at NetFlow’s cousin: sFlow.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看NetFlow的表亲：sFlow。
- en: sFlow
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sFlow
- en: sFlow, which stands for sampled flow, was originally developed by InMon ([http://www.inmon.com](http://www.inmon.com))
    and later standardized by way of RFC. The current version is v5\. Many in the
    industry believe the primary advantage of sFlow is its scalability.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: sFlow，代表采样流，最初由InMon([http://www.inmon.com](http://www.inmon.com))开发，后来通过RFC标准化。当前版本是v5。行业中有许多人认为sFlow的主要优势是其可扩展性。
- en: sFlow uses random [one in `n` ] packet flow samples along with the polling interval
    of counter samples to estimate the traffic; this is less CPU-intensive than NetFlow
    for network devices. sFlow’s statistical sampling is integrated with the hardware
    and provides real-time, raw exports.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: sFlow使用随机的[在`n`中的`一个`]数据包流样本以及计数器样本的轮询间隔来估计流量；这比NetFlow对网络设备的CPU密集度更低。sFlow的统计采样与硬件集成，并提供实时原始导出。
- en: For scalability and competitive reasons, sFlow is generally preferred over NetFlow
    for newer vendors, such as Arista Networks, Vyatta, and A10 Networks. While Cisco
    supports sFlow on its Nexus line of products, sFlow is generally “not” supported
    on Cisco platforms.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可扩展性和竞争原因，对于像Arista Networks、Vyatta和A10 Networks这样的新供应商，通常更倾向于使用sFlow而不是NetFlow。虽然思科在其Nexus产品线支持sFlow，但sFlow通常“不支持”在思科平台上。
- en: SFlowtool and sFlow-RT with Python
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SFlowtool和sFlow-RT与Python
- en: Unfortunately, at this point, sFlow is something our CML lab devices do not
    support (not even with the NX-OSv virtual switches). You can use a Cisco Nexus
    3000 switch or other vendor switches, such as Arista, that support sFlow. Another
    good option for the lab is to use an Arista vEOS virtual instance. I have access
    to a Cisco Nexus 3048 switch running 7.0 (3), which I will use for this section
    as the sFlow exporter.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，到目前为止，sFlow是我们CML实验室设备不支持的东西（甚至不包括NX-OSv虚拟交换机）。您可以使用支持sFlow的思科Nexus 3000交换机或其他供应商的交换机，例如Arista。对于实验室来说，另一个好选择是使用Arista
    vEOS虚拟实例。我有一个运行7.0（3）的思科Nexus 3048交换机的访问权限，我将在此部分中使用它作为sFlow导出器。
- en: 'The configuration of Cisco Nexus 3000 for sFlow is straightforward:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 配置思科Nexus 3000的sFlow很简单：
- en: '[PRE48]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The easiest way to ingest sFlow is to use `sflowtool`. For installation instructions,
    refer to the documentation at [http://blog.sflow.com/2011/12/sflowtool.html](http://blog.sflow.com/2011/12/sflowtool.html):'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sflowtool`是摄取sFlow的最简单方法。有关安装说明，请参阅[http://blog.sflow.com/2011/12/sflowtool.html](http://blog.sflow.com/2011/12/sflowtool.html)上的文档：
- en: '[PRE49]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: I am using an older version of `sFlowtool` in the lab. The newer versions work
    the same.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我在实验室中使用的是较旧的`sFlowtool`版本。新版本的工作方式相同。
- en: 'After the installation, you can launch `sflowtool` and look at the datagram
    Nexus 3048 is sending on the standard output:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以启动`sflowtool`并查看Nexus 3048在标准输出上发送的数据报：
- en: '[PRE50]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'There are a number of good usage examples on the sflowtool GitHub repository
    ([https://github.com/sflow/sflowtool)](https://github.com/sflow/sflowtool)); one
    of them is to use a script to receive the `sflowtool` input and parse the output.
    We can use a Python script for this purpose. In the `chapter8_sflowtool_1.py`
    example, we will use `sys.stdin.readline` to receive the input and use a regular
    expression search to print out only the lines containing the word agent when we
    see the sFlow packets:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: sflowtool GitHub仓库([https://github.com/sflow/sflowtool](https://github.com/sflow/sflowtool))中有许多良好的使用示例；其中之一是使用脚本接收`sflowtool`输入并解析输出。我们可以为此目的使用Python脚本。在`chapter8_sflowtool_1.py`示例中，我们将使用`sys.stdin.readline`接收输入，并使用正则表达式搜索来打印出包含单词agent的行，当我们看到sFlow数据包时：
- en: '[PRE51]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The script can be piped to `sflowtool`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将脚本管道化到`sflowtool`：
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: There are a number of other useful output examples, such as `tcpdump`, output
    as NetFlow version 5 records, and a compact line-by-line output. This makes `sflowtool`
    flexible for different monitoring environments.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他有用的输出示例，例如以NetFlow版本5记录输出的`tcpdump`，以及紧凑的逐行输出。这使得`sflowtool`适用于不同的监控环境。
- en: 'ntop supports sFlow, which means you can directly export your sFlow to the
    ntop collector. If your collector is only NetFlow-aware, you can use the `-c`
    option for the `sflowtool` output in the NetFlow version 5 format:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ntop支持sFlow，这意味着您可以直接将sFlow导出到ntop收集器。如果您的收集器仅支持NetFlow，您可以使用`-c`选项在NetFlow版本5格式中为`sflowtool`输出：
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Alternatively, you can also use InMon’s sFlow-RT ([http://www.sflow-rt.com/index.php](http://www.sflow-rt.com/index.php))
    as your sFlow analytics engine. What sets sFlow-RT apart from an operator perspective
    is its vast RESTful API, which can be customized to support your use cases. You
    can also easily retrieve the metrics from the API. You can take a look at its
    extensive API reference at: [http://www.sflow-rt.com/reference.php](http://www.sflow-rt.com/reference.php).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以使用InMon的sFlow-RT（[http://www.sflow-rt.com/index.php](http://www.sflow-rt.com/index.php)）作为您的sFlow分析引擎。从操作员的角度来看，sFlow-RT与众不同的地方是其庞大的RESTful
    API，可以根据您的用例进行定制。您也可以轻松地从API中检索指标。您可以在[http://www.sflow-rt.com/reference.php](http://www.sflow-rt.com/reference.php)查看其广泛的API参考。
- en: 'Note that sFlow-RT requires Java to run the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，sFlow-RT需要Java来运行以下操作：
- en: '[PRE54]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Once installed, downloading and running sFlow-RT is straightforward ([https://sflow-rt.com/download.php](https://sflow-rt.com/download.php)):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，下载和运行sFlow-RT非常简单（[https://sflow-rt.com/download.php](https://sflow-rt.com/download.php)）：
- en: '[PRE55]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can point the web browser to HTTP port `8008` and verify the installation:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将网络浏览器指向HTTP端口`8008`并验证安装：
- en: '![Graphical user interface, application  Description automatically generated](img/B18403_08_16.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序  自动生成的描述](img/B18403_08_16.png)'
- en: 'Figure 8.16: sFlow-RT version'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16：sFlow-RT版本
- en: 'As soon as sFlow-RT receives any sFlow packets, the agents and other metrics
    will appear:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦sFlow-RT收到任何sFlow数据包，代理和其他指标将出现：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18403_08_17.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B18403_08_17.png)'
- en: 'Figure 8.17: sFlow-RT agent IP'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17：sFlow-RT代理IP
- en: 'Here are two examples of using Python requests to retrieve information from
    sFlow-RT’s REST API:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个使用Python requests从sFlow-RT的REST API检索信息的示例：
- en: '[PRE56]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Consult the reference documentation for additional REST endpoints available
    for your needs.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请查阅参考文档，了解适用于您需求的额外REST端点。
- en: In this section, we looked at sFlow-based monitoring examples both as a standalone
    tool as well as part of the integration with `ntop`. sFlow is one of the newer
    flow formats that intends to address scalability issues faced with traditional
    `netflow` formats, and it’s worth us spending some time to see whether it is the
    right tool for the network monitoring tasks at hand. We are close to the end of
    this chapter, so let’s look at what we have covered.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了基于sFlow的监控示例，既作为独立工具，也作为与`ntop`集成的部分。sFlow是旨在解决传统`netflow`格式所面临的可扩展性问题的新流格式之一，值得我们花些时间看看它是否是手头网络监控任务的正确工具。我们接近本章的结尾，让我们看看我们涵盖了哪些内容。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at additional ways in which we can utilize Python
    to enhance our network monitoring efforts. We began using Python’s Graphviz package
    to create network topology graphs with real-time LLDP information reported by
    the network devices. This allows us to effortlessly show the current network topology,
    as well as to easily notice any link failures.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了我们可以利用Python的额外方式来增强我们的网络监控工作。我们开始使用Python的Graphviz包，利用网络设备报告的实时LLDP信息创建网络拓扑图。这使得我们能够轻松地显示当前网络拓扑，以及轻松地注意到任何链路故障。
- en: Next, we used Python to parse NetFlow version 5 packets to enhance our understanding
    and troubleshooting of NetFlow. We also looked at how to use ntop and Python to
    extend ntop for NetFlow monitoring. sFlow is an alternative packet sampling technology.
    We used `sflowtool` and sFlow-RT to interpret sFlow results.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用Python解析NetFlow版本5数据包，以增强我们对NetFlow的理解和故障排除。我们还探讨了如何使用ntop和Python扩展ntop以进行NetFlow监控。sFlow是一种替代的包采样技术。我们使用`sflowtool`和sFlow-RT来解释sFlow结果。
- en: In *Chapter 9*, *Building Network Web Services with Python*, we will explore
    how to use the Python web framework Flask to build network web services.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第9章*，*使用Python构建网络Web服务*中，我们将探讨如何使用Python Web框架Flask来构建网络Web服务。
- en: Join our book community
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的书籍社区
- en: 'To join our community for this book – where you can share feedback, ask questions
    to the author, and learn about new releases – follow the QR code below:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的社区——在那里您可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
- en: '![](img/QR_Code2903617220506617062.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2903617220506617062.png)'
