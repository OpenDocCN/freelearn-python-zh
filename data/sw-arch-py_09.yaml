- en: Chapter 9. Deploying Python Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。部署Python应用程序
- en: Pushing code to production is often the last step in taking an application from
    development to the customer. Though this is an important activity, it often gets
    overlooked in the scheme of importance in a software architect's checklist.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码推送到生产环境通常是将应用程序从开发环境带给客户的最后一步。尽管这是一项重要的活动，但在软件架构师的检查表中往往被忽视。
- en: It is a pretty common and fatal mistake to assume that if a system works in
    the development environment, it will work dutifully in production also. For one
    thing, the configuration of a production system is often very different from that
    of a development environment. Many optimizations and debugging that are available
    and taken for granted in a developer's box, are often not available in the production
    setup.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 假设如果系统在开发环境中运行良好，它也会在生产环境中忠实地运行是一个非常常见且致命的错误。首先，生产系统的配置通常与开发环境大不相同。在开发人员的环境中可以使用和理所当然的许多优化和调试，在生产设置中通常是不可用的。
- en: Deployment to production is an art rather than an exact science. The complexity
    of deployment of a system depends on a number of factors, such as the language
    the system is developed in, its runtime portability and performance, the number
    of configuration parameters, whether the system is deployed in a homogeneous or
    heterogeneous environment, binary dependencies, geographic distribution of the
    deployments, deployment automation tooling, and a host of other factors.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 部署到生产环境是一门艺术，而不是一门精确的科学。系统部署的复杂性取决于许多因素，例如系统开发的语言、运行时可移植性和性能、配置参数的数量、系统是在同质环境还是异质环境中部署、二进制依赖关系、部署的地理分布、部署自动化工具等等。
- en: In recent years, Python, as an open-source language, has matured in the level
    of automation and support it provides for deploying packages to production systems.
    With its rich availability of built-in and third-party support tools, the pain
    and hassle for production deployments and maintaining deployment systems up to
    date has decreased.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，作为一种开源语言，Python在为生产系统部署软件包提供的自动化和支持水平上已经成熟。凭借其丰富的内置和第三方支持工具，生产部署和保持部署系统最新的痛苦和麻烦已经减少。
- en: In this chapter, we will discuss, briefly, about deployable systems and the
    concept of deployability. We'll spend some time to understand the deployment of
    Python applications, and the tools and processes that the architect can add to
    his repertoire in order to ease the deploying and maintenance of his production
    systems' running applications, written using Python. We will also look at techniques
    and best practices that an architect can adopt to keep his production systems
    chugging along healthily and securely, without frequent downtimes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要讨论可部署系统和可部署性的概念。我们将花一些时间了解Python应用程序的部署，以及架构师可以添加到其工具库中的工具和流程，以便轻松部署和维护使用Python编写的生产系统运行的应用程序。我们还将探讨架构师可以采用的技术和最佳实践，以使其生产系统在没有频繁停机的情况下健康安全地运行。
- en: Here are the list of topics we would be talking about in this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论的主题列表如下。
- en: Deployability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可部署性
- en: Factors affecting Deployability
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响可部署性的因素
- en: Tiers of software deployment architecture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件部署架构的层次
- en: Software Deployment in Python
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的软件部署
- en: Packaging Python Code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包Python代码
- en: Pip
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Pip
- en: Virtualenv
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Virtualenv
- en: Virtualenv and Pip
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Virtualenv和Pip
- en: PyPI – The Python Package Index
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: PyPI- Python软件包索引
- en: Packaging and submission of an application
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的打包和提交
- en: PyPA
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: PyPA
- en: Remote deployments using Fabric
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Fabric进行远程部署
- en: Remote deployments using Ansible
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible进行远程部署
- en: Managing remote daemons using Supervisor
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Supervisor管理远程守护程序
- en: Deployment – Patterns & Best Practices
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署-模式和最佳实践
- en: Deployability
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可部署性
- en: The deployability of a software system is the ease with which it can be taken
    from development to production. It can be measured in terms of the effort–in terms
    of man-hours, or complexity–in terms of the number of disparate steps required
    for deploying code from a development to production environment.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 软件系统的可部署性是指将其从开发环境部署到生产环境的便捷程度。它可以根据部署代码所需的工作量（以人时计）或部署代码所需的不同步骤的数量来衡量其复杂性。
- en: It is a common mistake to assume that a code that runs well in a development
    or staging system would behave in a similar way in a production system. It is
    not often the case due to the vastly dissimilar requirements that a production
    system has when compared to a development one.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的错误是假设在开发或暂存系统中运行良好的代码在生产系统中会以类似的方式运行。由于生产系统与开发系统相比具有截然不同的要求，这种情况并不经常发生。
- en: Factors affecting Deployability
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影响可部署性的因素
- en: 'Here is a brief look at some of the factors that differentiate a production
    system from a development one, which can often give rise to unexpected issues
    in deployment leading to *Production Gotchas*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些区分生产系统和开发系统的因素的简要介绍，这些因素通常会导致部署中出现意外问题，从而导致*生产陷阱*：
- en: '**Optimizations and debugging**: It is very common for development systems
    to turn off optimizations in code.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化和调试**：在开发系统中关闭代码优化是非常常见的。'
- en: If your code is running in an interpreted runtime like Python, it is common
    to turn on debug configurations, which allows the programmer to generate generous
    tracebacks when an exception occurs. Also any Python interpreter optimizations
    are usually turned off.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的代码在像Python这样的解释运行时中运行，通常会打开调试配置，这允许程序员在发生异常时生成大量的回溯。此外，通常会关闭任何Python解释器优化。
- en: On the other hand, in production systems, the reverse is true – as optimizations
    are turned on and debugging is turned off. This usually requires additional configuration
    to be enabled for the code to work in a similar way. It is also possible (though
    rare) that the program gives a different behavior upon optimization under certain
    circumstances than it does when running unoptimized.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在生产系统中，情况正好相反 - 优化被打开，调试被关闭。这通常需要额外的配置才能使代码以类似的方式工作。也有可能（虽然很少）在某些情况下，程序在优化后的行为与在未经优化时运行时的行为不同。
- en: '**Dependencies and versions**: A development environment, usually, has a rich
    installation of development and support libraries for running multiple applications
    that a developer may be working on. Quite often, these may be dependencies which
    are themselves not stale, since developers often work on bleeding edge code.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项和版本**：开发环境通常具有丰富的开发和支持库的安装，用于运行开发人员可能正在开发的多个应用程序。这些通常是开发人员经常使用的最新代码的依赖项。'
- en: Production systems, on the other hand, need to be carefully prepared using a
    precompiled list of dependencies and their versions. It is quite common to specify
    only mature or stable versions for deployment on production systems. Hence if
    a developer had relied on a feature or bug-fix which was available on an unstable
    (alpha, beta or release-candidate) version of a downstream dependency, one may
    find – too late – that the feature doesn't work in production as intended.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 生产系统，另一方面，需要使用预先编译的依赖项及其版本的列表进行精心准备。通常只指定成熟或稳定的版本用于在生产系统上部署是非常常见的。因此，如果开发人员依赖于下游依赖项的不稳定（alpha、beta或发布候选）版本上可用的功能或错误修复，可能会发现
    - 太迟了 - 该功能在生产中无法按预期工作。
- en: Another common problem is undocumented dependencies or dependencies that need
    to be compiled from source code—this is often a problem with first-time deployments.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的问题是未记录的依赖项或需要从源代码编译的依赖项 - 这通常是首次部署时的问题。
- en: '**Resource configuration and access privileges**: Development systems and production
    systems often differ in level, privilege, and details of access of resources locally
    and in the network. A development system may have a local database, whereas, production
    systems tend to use separate hosting for application and database systems. A development
    system may use a standard configuration file, while in production, the configuration
    may have to be generated specifically for a host or an environment using specific
    scripts. Similarly, in production, the application may be required to run with
    lesser privileges as a specific user/group, whereas, in development, it may be
    common to run the program as the root or superuser. Such disparities in user privileges
    and configuration may affect resource access and might cause software to fail
    in production, when it runs fine on the development environment.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源配置和访问权限**：开发系统和生产系统在本地和网络资源的级别、权限和访问细节上通常有所不同。开发系统可能有一个本地数据库，而生产系统往往会为应用程序和数据库系统使用单独的托管。开发系统可能使用标准配置文件，而在生产中，配置可能需要使用特定脚本专门为主机或环境生成。同样，在生产中，可能需要以较低的权限作为特定用户/组运行应用程序，而在开发中，通常会以root或超级用户身份运行程序。用户权限和配置上的差异可能影响资源访问，并可能导致软件在生产中失败，而在开发环境中正常运行。'
- en: '**Heterogeneous production environments**: Code is usually developed in development
    environments, which are usually homogeneous. But it may often be required to be
    deployed on heterogeneous systems in production. For example, software may be
    developed on Linux, but there may be a requirement for a customer deployment on
    Windows.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异构的生产环境**：代码通常是在通常是同质的开发环境中开发的。但通常需要在生产中部署到异构系统上。例如，软件可能在Linux上开发，但可能需要在Windows上进行客户部署。'
- en: The complexity of deployments increases proportionally to heterogeneity in environments.
    Well-managed staging and testing environments are required before such code is
    taken to production. Also, heterogeneous systems make dependency management more
    complex, as a separate list of dependencies needs to be maintained for each target
    system architecture.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 部署的复杂性与环境的异质性成正比增加。在将此类代码带入生产之前，需要良好管理的分级和测试环境。此外，异构系统使依赖管理变得更加复杂，因为需要为每个目标系统架构维护一个单独的依赖项列表。
- en: '**Security**: In development and testing environments, it is somewhat common
    to give a wide berth to security aspects to save time and to reduce the configuration
    complexity for testing. For example, in a web application, routes which need logins
    may be disabled by using special development environment flags to facilitate quick
    programming and testing.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：在开发和测试环境中，通常会对安全性方面给予宽容以节省时间并减少测试的配置复杂性。例如，在Web应用程序中，需要登录的路由可能会使用特殊的开发环境标志来禁用，以便快速编程和测试。'
- en: Similarly, systems used in development environments may often use easy-to-guess
    passwords, such as database systems, web application logins, and others, to make
    routine recall and usage easy. Also, role-based authorization may be ignored to
    facilitate testing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在开发环境中使用的系统可能经常使用易于猜测的密码，例如数据库系统、Web应用程序登录等，以便轻松进行常规回忆和使用。此外，可能会忽略基于角色的授权以便进行测试。
- en: However, security is critical in production, so these aspects require the opposite
    treatment. Routes which need logins should be enforced as such. Strong passwords
    should be used. Role-based authentication requires to be enforced. These can often
    cause subtle bugs in production where a feature which works in the development
    environment fails in production.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在生产中安全性至关重要，因此这些方面需要相反的处理。需要强制执行需要登录的路由。应该使用强密码。需要强制执行基于角色的身份验证。这些通常会在生产中引起微妙的错误，即在开发环境中正常工作的功能在生产中失败。
- en: Since these and other similar problems are the bane of deploying code in production,
    standard practices have been defined to make the life of the devops practitioner
    a bit easy. Most companies follow the practice of using isolated environments
    to develop, test, and validate code and applications before pushing them to production.
    Let us take a look at this.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些以及其他类似的问题是在生产中部署代码的困扰，已经定义了标准的实践方法，以使运维从业者的生活变得稍微容易一些。大多数公司都遵循使用隔离环境来开发、测试和验证代码和应用程序，然后再将它们推送到生产的做法。让我们来看一下。
- en: Tiers of software deployment architecture
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件部署架构的层
- en: To avoid complexities in taking the code from development to testing, and further
    to production, it is common to use a multitiered architecture for each stage of
    the life cycle of the application before deployment to production.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在从开发到测试，再到生产的过程中出现复杂性，通常在应用程序部署到生产之前的每个阶段使用多层架构是很常见的。
- en: 'Let''s take a look at some of the following common deployment tiers:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下以下一些常见的部署层：
- en: '**Development/Test/Stage/Production**: This is the traditional four-tiered
    architecture.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发/测试/阶段/生产**：这是传统的四层架构。'
- en: The developers push their code to a development environment, where unit tests
    and developer tests are run. This environment will always be on the latest trunk
    or bleeding edge of the code. Many times this environment is skipped and replaced
    with the local setup on developer's laptops.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员将他们的代码推送到开发环境，进行单元测试和开发人员测试。这个环境总是处于最新的代码状态。很多时候这个环境会被跳过，用开发人员的笔记本电脑上的本地设置替代。
- en: The software is then tested by QA or testing engineers on a test environment
    using black-box techniques. They may also run performance tests on this environment.
    This environment is always behind the development environment in terms of code
    updates. Usually, internal releases, tags, or **code dumps** are used to sync
    the QA environment from the development environment.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，软件由测试工程师在测试环境中使用黑盒技术进行测试。他们也可能在这个环境上运行性能测试。这个环境在代码更新方面总是落后于开发环境。通常，内部发布、标签或**代码转储**用于将QA环境与开发环境同步。
- en: The staging environment tries to mirror the production environment as closely
    as possible. It is the *pre-production* stage, where the software is tested on
    an environment as close as possible to the deployment one to find out issues that
    may occur in production in advance. This is the environment where usually stress
    or load tests are run. It also allows the devops engineer to test out his deployment
    automation scripts, cron jobs, and verify system configuration.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阶段环境试图尽可能地模拟生产环境。这是*预生产*阶段，在这个环境中，软件在尽可能接近部署环境的环境中进行测试，以提前发现可能在生产中出现的问题。这个环境通常用于运行压力测试或负载测试。它还允许运维工程师测试他的部署自动化脚本、定时作业，并验证系统配置。
- en: Production is, of course, the final tier where software that is tested from
    staging is pushed and deployed. A number of deployments often use identical staging/production
    tiers, and simply switch from one to the other.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产环境当然是最终的阶段，经过阶段测试的软件被推送和部署。许多部署通常使用相同的阶段/生产阶段，并且只是从一个切换到另一个。
- en: '**Development and Test/Stage/Production**: This is a variation of the previous
    tier, where the development environment also performs the double duty of a testing
    environment. This system is used in companies with agile software development
    practices, where code is pushed at least once a week to production, and there
    is no space or time to keep and manage a separate testing environment. When there
    is no separate development environment – that is when developers use their laptops
    for programming – the testing environment is also a local one.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发和测试/阶段/生产**：这是前一个层的变体，其中开发环境也兼具测试环境的双重职责。这种系统用于采用敏捷软件开发实践的公司，其中代码至少每周推送一次到生产环境，没有空间或时间来保留和管理一个单独的测试环境。当没有单独的开发环境时——即开发人员使用他们的笔记本电脑进行编程时——测试环境也是一个本地环境。'
- en: '**Development and Test/ Stage and Production**: In this setup, staging and
    production environments are exactly the same with multiple servers used. Once
    a system is tested and verified in staging, it is *pushed* to production by simply
    switching the hosts—the current production system switches to staging, and staging
    switches to production.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发和测试/阶段和生产**：在这种设置中，阶段和生产环境完全相同，使用多个服务器。一旦系统在阶段中经过测试和验证，它就会通过简单地切换主机被推送到生产环境——当前的生产系统切换到阶段，阶段切换到生产。'
- en: Apart from these, it is possible to have more elaborate architectures where
    a separate **Integration** environment is used for integration testing, a **Sandbox**
    environment for testing experimental features, and so on.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还可以有更复杂的架构，其中使用一个单独的**集成**环境进行集成测试，一个**沙盒**环境用于测试实验性功能，等等。
- en: Using a staging system is important to ensure that software is well tested and
    orchestrated in a production-like environment, before pushing the code to production.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分阶段系统对确保软件在类生产环境中经过充分测试和协调后再推送代码到生产环境是很重要的。
- en: Software deployment in Python
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的软件部署
- en: As mentioned earlier, Python developers are richly blessed in the various tools
    offered by Python, and its third-party ecosystem in easing and automating the
    deployment of applications and code written using Python.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，Python开发人员在Python提供的各种工具以及第三方生态系统中，可以轻松自动化地部署使用Python编写的应用程序和代码。
- en: In this section, we will briefly take a look at some of these tools.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将简要地看一下其中一些工具。
- en: Packaging Python code
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包Python代码
- en: Python comes with built in support for packaging applications for a variety
    of distributions—source, binary, and specific OS-level packaging.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Python内置支持为各种分发打包应用程序——源代码、二进制和特定的操作系统级打包。
- en: The primary way of packaging source code in Python is to write a `setup.py`
    file. The source can then be packaged with the help of the in-built `distutils`
    library, or the more sophisticated and rich `setuptools` framework.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中打包源代码的主要方式是编写一个`setup.py`文件。然后可以借助内置的`distutils`库或更复杂、丰富的`setuptools`框架来打包源代码。
- en: Before we get introduced to the guts of Python packaging, let us get familiar
    with a couple of closely related tools, namely, `pip` and `virtualenv`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始了解Python打包的内部机制之前，让我们先熟悉一下几个相关的工具，即`pip`和`virtualenv`。
- en: Pip
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pip
- en: Pip stands for the recursive acronym **Pip installs packages**. Pip is the standard
    and suggested tool to install packages in Python.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Pip是**Pip installs packages**的递归缩写。Pip是Python中安装软件包的标准和建议工具。
- en: We've seen pip in action throughout this book, but so far, we've never seen
    pip itself getting installed, have we?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中我们一直看到pip在工作，但到目前为止，我们从未看到pip本身被安装过，对吧？
- en: 'Let''s see this in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下截图中看到这一点：
- en: '![Pip](../Images/image00507.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![Pip](../Images/image00507.jpeg)'
- en: Downloading and installing pip for Python3
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并安装Python3的pip
- en: The pip installation script is available at [https://bootstrap.pypa.io/get-pip.py](https://bootstrap.pypa.io/get-pip.py).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: pip安装脚本可在[https://bootstrap.pypa.io/get-pip.py](https://bootstrap.pypa.io/get-pip.py)找到。
- en: The steps should be self-explanatory.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤应该是不言自明的。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In this preceding example, there was already a pip version, so the action upgraded
    the existing version instead of doing a fresh install. We can see the version
    details by trying the program with the `–version` option, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，已经有一个pip版本，所以这个操作是升级现有版本，而不是进行全新安装。我们可以通过使用`–version`选项来尝试程序来查看版本详细信息，如下所示：
- en: 'Take a look at the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下截图：
- en: '![Pip](../Images/image00508.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Pip](../Images/image00508.jpeg)'
- en: Printing the current version of pip (pip3)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 打印当前pip版本（pip3）
- en: See how pip clearly prints its version number along with the directory location
    of the installation, plus the Python version for which it is installed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 看到pip清楚地打印出其版本号以及安装的目录位置，以及其所安装的Python版本。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To distinguish between pip for the Python2 and Python3 versions, remember that
    the version installed for Python3 is always named `pip3`. The Python2 version
    is `pip2`, or just `pip`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要区分Python2和Python3版本的pip，记住为Python3安装的版本始终命名为`pip3`。Python2版本是`pip2`，或者只是`pip`。
- en: 'To install a package using pip, simply provide the package name via the command
    `install`. For example, the following screenshot shows installing the `numpy`
    package using `pip`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pip安装软件包，只需通过`install`命令提供软件包名称即可。例如，以下截图显示了使用`pip`安装`numpy`软件包：
- en: '![Pip](../Images/image00509.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Pip](../Images/image00509.jpeg)'
- en: We will not go into further details of using pip here. Instead, let's take a
    look at another tool that works closely with pip in installing the Python software.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里进一步讨论使用pip的细节。相反，让我们来看看另一个与pip密切相关的工具，它用于安装Python软件。
- en: Virtualenv
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Virtualenv
- en: Virtualenv is a tool that allows developers to create sand-boxed Python environments
    for local development. Let's say that you want to maintain two different versions
    of a particular library or framework for two different applications you are developing
    side by side.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Virtualenv是一个允许开发人员为本地开发创建沙盒式Python环境的工具。假设您想要为同时开发的两个不同应用程序维护特定库或框架的两个不同版本。
- en: If you are going to install everything to the system Python, then you can keep
    only one version at a given time. The other option is to create different system
    Python installations in different root folders—say, `/opt` instead of `/usr`.
    However, this creates additional overhead and management headaches of paths. Also,
    it wouldn't be possible to get write permission to these folders if you want the
    version dependency to be maintained on a shared host where you don't have superuser
    permissions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将所有内容安装到系统Python中，那么您一次只能保留一个版本。另一个选项是在不同的根文件夹中创建不同的系统Python安装——比如`/opt`而不是`/usr`。然而，这会带来额外的开销和路径管理方面的麻烦。而且，如果您希望在没有超级用户权限的共享主机上维护版本依赖关系，那么您将无法获得对这些文件夹的写入权限。
- en: Virtualenv solves the problems of permissions and versions in one go. It creates
    a local installation directory with its own Python executable standard library
    and installer (defaults to pip).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Virtualenv解决了权限和版本问题。它创建一个带有自己的Python可执行标准库和安装程序（默认为pip）的本地安装目录。
- en: Once the developer has activated the virtual environment thus created, any further
    installations goes to this environment instead of the system Python environment.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开发人员激活了这样创建的虚拟环境，任何进一步的安装都会进入这个环境，而不是系统Python环境。
- en: Virtualenv can be installed using pip.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用pip来安装Virtualenv。
- en: The following screenshot shows creating a virtualenv named `appvenv` using the
    `virtualenv` command, and activating the environment along with installing a package
    to the environment.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了使用`virtualenv`命令创建名为`appvenv`的虚拟环境，并激活该环境以及在环境中安装软件包。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The installation also installs pip, setuptools, and other dependencies.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 安装还会安装pip、setuptools和其他依赖项。
- en: '![Virtualenv](../Images/image00510.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Virtualenv](../Images/image00510.jpeg)'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: See how the `python` and `pip` commands point to the ones inside the virtual
    environment. The `pip –version` command clearly shows the path of `pip` inside
    the virtual environment folder.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 看到`python`和`pip`命令指向虚拟环境内部的命令。`pip –version`命令清楚地显示了虚拟环境文件夹内`pip`的路径。
- en: From Python 3.3 onwards, support for virtual environments is built into the
    Python installation via the new `venv` library.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.3开始，对虚拟环境的支持已经内置到Python安装中，通过新的`venv`库。
- en: 'The following screenshot shows installing a virtual environment in Python 3.5
    using this library, and installing some packages into it. As usual, take a look
    at Python and pip executable paths:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在Python 3.5中使用该库安装虚拟环境，并在其中安装一些软件包。像往常一样，查看Python和pip可执行文件的路径：
- en: '![Virtualenv](../Images/image00511.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![Virtualenv](../Images/image00511.jpeg)'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding screenshot also shows how to upgrade pip itself via the `pip`
    command.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上述屏幕截图还显示了如何通过`pip`命令升级pip本身。
- en: Virtualenv and pip
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Virtualenv和pip
- en: 'Once you''ve set up a virtual environment for your application(s) and installed
    the required packages, it is a good idea to generate the dependencies and their
    versions. This can be easily done via the following command using pip:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为您的应用程序设置了虚拟环境并安装了所需的软件包，最好生成依赖项及其版本。可以通过以下命令轻松完成：
- en: '[PRE0]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command asks pip to output a list of all the installed Python packages
    along with their versions. This can be saved to a requirements file, and the setup
    duplicated on the server for mirroring deployments:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令要求pip输出所有已安装的Python软件包及其版本的列表。这可以保存到一个requirements文件中，并在服务器上进行镜像部署时进行设置复制：
- en: '![Virtualenv and pip](../Images/image00512.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![Virtualenv and pip](../Images/image00512.jpeg)'
- en: 'The following screenshot shows recreating the same setup in another virtual
    environment via the `-r` option of the pip install command, which accepts such
    a file as input:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了通过pip install命令的`-r`选项在另一个虚拟环境中重新创建相同的设置，该选项接受此类文件作为输入：
- en: '![Virtualenv and pip](../Images/image00513.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![Virtualenv和pip](../Images/image00513.jpeg)'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Our source virtual environment was in Python2, and the target was in Python3\.
    However, pip was able to install the dependencies from the `requirements.txt`
    file without any issues whatsoever.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的源虚拟环境是Python2，目标是Python3。但是，pip能够无任何问题地从`requirements.txt`文件中安装依赖项。
- en: Relocatable virtual environments
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可重定位的虚拟环境
- en: The suggested way to copy package dependencies from one virtual environment
    to another is to perform a freeze, and install via pip as illustrated in the previous
    section. For example, this is the most common way to freeze Python package requirements
    from a development environment, and recreate it successfully on a production server.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个虚拟环境复制软件包依赖项到另一个虚拟环境的建议方法是执行冻结，并按照前一节中所示通过pip进行安装。例如，这是从开发环境中冻结Python软件包要求并成功地在生产服务器上重新创建的最常见方法。
- en: One can also try and make a virtual environment relocatable so that it can be
    archived and moved to a compatible system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以尝试使虚拟环境可重定位，以便可以将其存档并移动到兼容的系统。
- en: '![Relocatable virtual environments](../Images/image00514.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![可重定位的虚拟环境](../Images/image00514.jpeg)'
- en: Creating a relocatable virtual environment
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建可重定位的虚拟环境
- en: 'Here is how it works:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的：
- en: First, the virtual environment is created as usual.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通常创建虚拟环境。
- en: It is then made relocatable by running `virtualenv –relocatable lenv` on it.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后通过运行`virtualenv –relocatable lenv`来使其可重定位。
- en: This changes some of the paths used by setuptools as relative paths, and sets
    up the system to be relocatable.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会将setuptools使用的一些路径更改为相对路径，并设置系统可重定位。
- en: Such a virtual environment is relocatable to another folder in the same machine,
    or to a folder in a *remote and similar machine*.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样的虚拟环境可以重定位到同一台机器上的另一个文件夹，或者重定位到*远程和相似的机器*上的文件夹。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A relocatable virtual environment doesn't guarantee that it will work if the
    remote environment differs from the machine environment. For example, if your
    remote machine is a different architecture, or even uses a different Linux distribution
    with another type of packaging, the relocation will fail to work. This is what
    is meant by the words *similar machine*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可重定位的虚拟环境并不保证在远程环境与机器环境不同时能正常工作。例如，如果您的远程机器是不同的架构，甚至使用另一种类型的Linux发行版进行打包，重定位将无法正常工作。这就是所谓的*相似的机器*。
- en: PyPI
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyPI
- en: We learned that Pip is the standardized tool to do package installations in
    Python. It is able to pick up any package by name as long as it exists. It is
    also able to install packages by version, as we saw with the example of the requirements
    file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到Pip是Python中进行软件包安装的标准化工具。只要存在，它就能够按名称选择任何软件包。正如我们在requirements文件的示例中看到的，它也能够按版本安装软件包。
- en: But where does Pip fetch its packages from?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 但是pip从哪里获取软件包呢？
- en: To answer this, we turn to the Python Package Index, more commonly known as
    PyPI.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答这个问题，我们转向Python软件包索引，更常被称为PyPI。
- en: '**Python Package Index (PyPI)** is the official repository for hosting metadata
    for third-party Python packages on the Web. As the name implies, it is an index
    to the Python packages on the Web whose metadata is published and indexed on a
    server. PyPI is hosted at the URL [http://pypi.python.org](http://pypi.python.org).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python软件包索引（PyPI）**是官方的第三方Python软件包在Web上托管元数据的存储库。顾名思义，它是Web上Python软件包的索引，其元数据发布并在服务器上进行索引。PyPI托管在URL
    [http://pypi.python.org](http://pypi.python.org)。'
- en: PyPI hosts close to a million packages at present. The packages are submitted
    to PyPI using Python's packaging and distribution tools, distutils, and setuptools,
    which have hooks for publishing package metadata to PyPI. A number of packages
    also host the actual package data in PyPI, although PyPI can be used to point
    to package data sitting in a URL on another server.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: PyPI目前托管了接近一百万个软件包。这些软件包是使用Python的打包和分发工具distutils和setuptools提交到PyPI的，这些工具具有用于将软件包元数据发布到PyPI的钩子。许多软件包还在PyPI中托管实际软件包数据，尽管PyPI可以用于指向位于另一台服务器上URL的软件包数据。
- en: When you install a package using pip, it actually performs the search for the
    package on PyPI, and downloads the metadata. It uses the metadata to find out
    the package's download URL and other information, such as further downstream dependencies,
    which it uses to fetch and install the package for you.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用pip安装软件包时，实际上是在PyPI上搜索软件包，并下载元数据。它使用元数据来查找软件包的下载URL和其他信息，例如进一步的下游依赖项，这些信息用于为您获取和安装软件包。
- en: 'Here is a screenshot of PyPI, which shows the actual count of the packages
    at the time of writing this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是PyPI的屏幕截图，显示了此时软件包的实际数量：
- en: '![PyPI](../Images/image00515.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![PyPI](../Images/image00515.jpeg)'
- en: 'A developer can do quite a few things directly on the PyPI site:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以在PyPI网站上直接执行许多操作：
- en: Register using e-mail address and log in to the site.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用电子邮件地址注册并登录网站。
- en: After logging in, submit your package directly on the site.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，直接在网站上提交您的软件包。
- en: Search for packages via keywords.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过关键字搜索软件包。
- en: Browse for packages via a number of top-level *trove* classifiers, such as Topics,
    Platforms/Operating Systems, Development Status, Licenses, and so on.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过一些顶级*trove*分类器浏览软件包，例如主题、平台/操作系统、开发状态、许可证等。
- en: Now that we are familiar with the suite of all Python packaging and installation
    tools and their relationships, let us try out a small example of packaging a trivial
    Python module and submitting it to PyPI.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了所有Python打包和安装工具及其关系，让我们尝试一个小例子，将一个简单的Python模块打包并提交到PyPI。
- en: Packaging and submission of an application
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件包的打包和提交
- en: Remember that we had developed a mandelbrot program, which uses pymp to scale,
    in [Chapter 5](part0040.xhtml#aid-164MG1 "Chapter 5. Writing Applications That
    Scale"), *Writing Applications that Scale*. We will use it as an example of a
    program to develop a package, and a setup.py file, which we will use to submit
    the application to PyPI.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们曾经开发过一个mandelbrot程序，它使用pymp进行缩放，在[第5章](part0040.xhtml#aid-164MG1 "第5章。编写可扩展的应用程序")中，*编写可扩展的应用程序*。我们将以此作为一个开发软件包的示例程序，并使用`setup.py`文件将该应用程序提交到PyPI。
- en: 'We will package the mandelbrot application in a main package consisting of
    two sub-packages as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将mandelbrot应用程序打包成一个主包，其中包含两个子包，如下所示：
- en: '`mandelbrot.simple`: The sub-package (sub-module) consisting of the basic implementation
    of mandelbrot'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mandelbrot.simple`：包含mandelbrot基本实现的子包（子模块）'
- en: '`mandelbrot`.mp: The sub package (sub-module) having the PyMP implementation
    of mandelbrot'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mandelbrot`.mp：包含mandelbrot的PyMP实现的子包（子模块）'
- en: 'Here is our folder structure for the package:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们软件包的文件夹结构：
- en: '![Packaging and submission of an application](../Images/image00516.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![软件包的打包和提交](../Images/image00516.jpeg)'
- en: Folder layout of the mandelbrot package
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: mandelbrot软件包的文件夹布局
- en: 'Let us quickly analyze the folder structure of the application which we will
    be packaging:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速分析一下我们将要打包的应用程序的文件夹结构：
- en: The top directory is named `mandelbrot`. It has an `__init__.py`, a `README`,
    and a `setup.py` file.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶级目录名为`mandelbrot`。它有一个`__init__.py`，一个`README`和一个`setup.py`文件。
- en: This directory has two sub directories—`mp` and `simple`.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该目录有两个子目录——`mp`和`simple`。
- en: Each of these subfolders consists of two files, namely, `__init__.py` and `mandelbrot.py`.
    These subfolders will form our sub-modules, each containing the respective implementation
    of the mandelbrot set.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个子文件夹都包括两个文件，即`__init__.py`和`mandelbrot.py`。这些子文件夹将形成我们的子模块，每个子模块包含mandelbrot集的相应实现。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the purpose of installing the mandelbrot modules as executable scripts,
    the code has been changed to add a `main` method to each of our `mandelbrot.py`
    modules.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将mandelbrot模块安装为可执行脚本，代码已更改以向我们的每个`mandelbrot.py`模块添加`main`方法。
- en: The __init__.py files
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`__init__.py`文件'
- en: 'The `__init__.py` files allow to convert a folder inside a Python application
    as a package. Our folder structure has three of them: the first one is for the
    top-level package `mandelbrot`, and the rest two for each of the sub-packages,
    namely, `mandelbrot.simple` and `mandelbrot.mp`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__.py`文件允许将Python应用程序中的文件夹转换为软件包。我们的文件夹结构有三个：第一个是顶级软件包`mandelbrot`，其余两个分别是每个子包`mandelbrot.simple`和`mandelbrot.mp`。'
- en: 'The top-level `__init__.py` is empty. The other two have the following single
    line:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级`__init__.py`为空。其他两个有以下单行：
- en: '[PRE1]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The relative imports are to make sure that the sub-packages are importing the
    local `mandelbrot.py` module instead of the top-level `mandelbrot` package.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 相对导入是为了确保子包导入本地的`mandelbrot.py`模块，而不是顶级`mandelbrot`软件包。
- en: The setup.py file
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`setup.py`文件'
- en: 'The `setup.py` file is the central point of the entire package. Let us take
    a look at it:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.py`文件是整个软件包的中心点。让我们来看一下：'
- en: '[PRE2]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A full discussion of the `setup.py` file is outside the scope of this chapter,
    but do note these few key points:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.py`文件的全面讨论超出了本章的范围，但请注意以下几个关键点：'
- en: The `setup.py` file allows the author to create a lot of package metadata such
    as name, author name, e-mail, package keywords, and others. These are useful in
    creating the package meta information, which helps people to search for the package
    in PyPI once it's submitted.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup.py`文件允许作者创建许多软件包元数据，例如名称、作者名称、电子邮件、软件包关键字等。这些对于创建软件包元信息非常有用，一旦提交到PyPI，就可以帮助人们搜索软件包。'
- en: One of the main fields in this file is packages, which is the list of packages
    (and sub-packages) that is created by this `setup.py` file. We make use of the
    `find_packages` helper function provided by the setuptools module to do this.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该文件中的一个主要字段是`packages`，它是由此`setup.py`文件创建的软件包（和子软件包）的列表。我们使用setuptools模块提供的`find_packages`辅助函数来实现这一点。
- en: We provide the installment requirements in the `install-requires` key, which
    lists the dependencies one by one in a PIP-like format.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`install-requires`键中提供了安装要求，以PIP格式逐个列出依赖项。
- en: 'The `entry_points` key is used to configure the console scripts (executable
    programs) that this package installs. Let us look at one of them:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry_points`键用于配置此软件包安装的控制台脚本（可执行程序）。让我们看其中一个：'
- en: '[PRE3]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This tells the package resource loader to load the module named `mandelbrot.simple.mandelbrot`,
    and execute its function `main` when the script `mandelbrot` is invoked.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉包资源加载器加载名为`mandelbrot.simple.mandelbrot`的模块，并在调用脚本`mandelbrot`时执行其函数`main`。
- en: Installing the package
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装软件包
- en: 'The package can be now installed using this command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用以下命令安装软件包：
- en: '[PRE4]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following screenshot of the installation shows a few of the initial steps:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 安装的以下截图显示了一些初始步骤：
- en: '![Installing the package](../Images/image00517.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![安装软件包](../Images/image00517.jpeg)'
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have installed this package to a virtual environment named `env3`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将此软件包安装到名为`env3`的虚拟环境中。
- en: Submitting the package to PyPI
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将软件包提交到PyPI
- en: The `setup.py` file plus setuptools/distutils ecosystem in Python is useful
    not just to install and package code, but also to submit code to the Python package
    index.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`setup.py`文件加上setuptools/distutils生态系统不仅可以用于安装和打包代码，还可以用于将代码提交到Python软件包索引。
- en: 'It is very easy to register your package to PyPI. There are just the following
    two requirements:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将软件包注册到PyPI非常容易。只有以下两个要求：
- en: A package with a proper setup.py file.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有适当`setup.py`文件的软件包。
- en: An account on the PyPI website.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyPI网站上的一个帐户。
- en: 'We will now submit our new mandelbrot package to PyPI by performing the following
    steps:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过以下步骤将我们的新mandelbrot软件包提交到PyPI：
- en: First, one needs to create a `.pypirc` file in one's home directory containing
    some details—mainly the authentication details for the PyPI account.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，需要在家目录中创建一个名为`.pypirc`的文件，其中包含一些细节，主要是PyPI帐户的身份验证细节。
- en: 'Here is the author''s `.pypirc` file with the password obscured:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是作者的`.pypirc`文件，其中密码被隐藏：
- en: '![Submitting the package to PyPI](../Images/image00518.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![将软件包提交到PyPI](../Images/image00518.jpeg)'
- en: 'Once this is done, registration is as simple as running `setup.py` with the
    `register` command:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，注册就像运行`setup.py`并使用`register`命令一样简单：
- en: '[PRE5]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next screenshot shows the actual command in action on the console:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张截图显示了控制台上实际命令的执行情况：
- en: '![Submitting the package to PyPI](../Images/image00519.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![将软件包提交到PyPI](../Images/image00519.jpeg)'
- en: However, this last step has only registered the package by submitting its metadata.
    No package data, as in the source code data, has been submitted as part of this
    step.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这最后一步只是通过提交其元数据注册了软件包。在此步骤中并未提交软件包数据，如源代码数据。
- en: 'To submit the source code also to PyPI, the following command should be run:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将源代码提交到PyPI，应运行以下命令：
- en: '[PRE6]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Submitting the package to PyPI](../Images/image00520.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![将软件包提交到PyPI](../Images/image00520.jpeg)'
- en: 'Here''s a view of our new package on the PyPI server:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在PyPI服务器上的新软件包的视图：
- en: '![Submitting the package to PyPI](../Images/image00521.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![将软件包提交到PyPI](../Images/image00521.jpeg)'
- en: 'Now the package is installable via pip, completing the cycle of software development:
    that is first packaging, deployment and then installation.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过pip安装软件包，完成了软件开发的循环：首先是打包、部署，然后是安装。
- en: PyPA
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyPA
- en: '**Python Packaging Authority** (**PyPA**) is a working group of Python developers
    who maintain the standards and the relevant applications related to packaging
    in Python.yPA has their website at [https://www.pypa.io/](https://www.pypa.io/),
    and they maintain the application on GitHub at [https://github.com/pypa/](https://github.com/pypa/).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python Packaging Authority**（**PyPA**）是一群维护Python打包标准和相关应用程序的Python开发人员的工作组。PyPA在[https://www.pypa.io/](https://www.pypa.io/)上有他们的网站，并在GitHub上维护应用程序[https://github.com/pypa/](https://github.com/pypa/)。'
- en: 'The following table lists the projects that are maintained by PyPA. You''ve
    already seen some of these, such as pip, virtualenv, and setuptools; others may
    be new:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了由PyPA维护的项目。您已经看到了其中一些，比如pip、virtualenv和setuptools；其他可能是新的：
- en: '| Project | Description |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 项目 | 描述 |'
- en: '| --- | --- |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| setuptools | A collection of enhancements to Python distutils |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| setuptools | 对Python distutils的增强集合 |'
- en: '| virtualenv | A tool for creating sandbox Python environments |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| virtualenv | 用于创建沙盒Python环境的工具 |'
- en: '| pip | A tool for installing Python packages |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| pip | 用于安装Python软件包的工具 |'
- en: '| packaging | Core Python utilities for packaging used by pip and setuptools
    |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| packaging | pip和setuptools使用的核心Python打包实用程序 |'
- en: '| wheel | An extension to setuptools for creating wheel distributions, which
    are an alternative to Python eggs (ZIP files) and specified in PEP 427 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| wheel | 用于创建wheel分发的setuptools扩展，它是Python eggs（ZIP文件）的替代方案，并在PEP 427中指定 |'
- en: '| twine | A secure replacement for `setup.py` upload |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| twine | 用于创建wheel分发的`setup.py`上传的安全替代品 |'
- en: '| warehouse | The new PyPI application, which can be seen at [https://pypi.org](https://pypi.org)
    |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| warehouse | 新的PyPI应用程序，可以在[https://pypi.org](https://pypi.org)上查看 |'
- en: '| distlib | A low-level library implementing functions relating to packaging
    and distribution of Python code |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| distlib | 一个实现与Python代码打包和分发相关功能的低级库 |'
- en: '| bandersnatch | A PyPI mirroring client to mirror the contents of PyPI |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| bandersnatch | 用于镜像PyPI内容的PyPI镜像客户端 |'
- en: Interested developers can go visit the PyPA site and sign up for one of the
    projects - and contribute to them in terms of testing, submitting patches and
    so on by visiting the github repository of PyPA.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有兴趣的开发人员可以访问PyPA网站，并注册其中一个项目，并通过访问PyPA的github存储库，以进行测试、提交补丁等方面的贡献。
- en: Remote deployments using Fabric
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Fabric进行远程部署
- en: Fabric is a command-line tool and library written in Python, which helps to
    automate remote deployments on servers via a set of well-defined wrappers over
    the SSH protocol. It uses the `ssh-wrapper` library, `paramiko`, behind the scenes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric是一个用Python编写的命令行工具和库，它通过一组对SSH协议的良好定义的包装器来自动化服务器上的远程部署。它在幕后使用`ssh-wrapper`库`paramiko`。
- en: Fabric works with Python 2.x versions only. However, there is a fork Fabric3
    which works for both, the Python 2.x and 3.x versions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric仅适用于Python 2.x版本。但是，有一个名为Fabric3的分支，可以同时适用于Python 2.x和3.x版本。
- en: When using fabric, a devops user usually deploys his remote system administrator
    commands as Python functions in a `fabfile` named as `fabfile.py`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用fabric时，devops用户通常将远程系统管理员命令部署为名为`fabfile.py`的Python函数。
- en: Fabric works best when the remote systems are already configured with the ssh
    public keys of the user's machine from where he performs deployments, so there
    is no need to supply a username and password.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当远程系统已经配置了用户机器的ssh公钥时，Fabric的工作效果最佳，因此无需提供用户名和密码。
- en: Here is an example of remote deployment on a server. In this case, we are installing
    our mandelbrot application on a remote server.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在服务器上进行远程部署的示例。在这种情况下，我们正在将我们的mandelbrot应用程序安装到远程服务器上。
- en: 'The fabfile looks as follows. See that it is written for Python3:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: fabfile如下所示。请注意，它是为Python3编写的：
- en: '[PRE7]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is an example of running this, installing it on a remote server:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个在远程服务器上安装并运行的示例：
- en: '![Remote deployments using Fabric](../Images/image00522.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![使用Fabric进行远程部署](../Images/image00522.jpeg)'
- en: Devops engineers and system administrators can use a predefined set of fabfiles
    for automating different system and application deployment tasks across multiple
    servers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Devops工程师和系统管理员可以使用预定义的fabfiles集合来自动化不同的系统和应用程序部署任务，跨多个服务器。
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Though it is written in Python, Fabric can be used to automate deployment of
    any kind of remote server administration and configuration tasks.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Fabric是用Python编写的，但可以用于自动化任何类型的远程服务器管理和配置任务。
- en: Remote deployments using Ansible
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ansible进行远程部署
- en: Ansible is a configuration management and deployment tool written in Python.
    Ansible can be thought of as a wrapper over SSH with scripts with support for
    orchestration via tasks which can be assembled in easy to manage units called
    *playbooks* which map a group of hosts to a set of roles.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是用Python编写的配置管理和部署工具。Ansible可以被视为在SSH上使用脚本的包装器，支持通过易于管理的单元（称为*playbooks*）组装的任务进行编排，将一组主机映射到一组角色。
- en: Ansible uses "facts" which are system and environment information it gathers
    before it runs tasks. It uses the facts to check if there is any need to change
    any state before running a task to get the desired outcome.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible使用“facts”，这是它在运行任务之前收集的系统和环境信息。它使用这些facts来检查是否有任何需要在运行任务之前改变任何状态的情况。
- en: This makes it safe for Ansible tasks to be run on a server in a repeated fashion.
    Well written ansible tasks are *idempotent* in that they have zero to few side
    effects on the remote system.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得Ansible任务可以安全地在服务器上以重复的方式运行。良好编写的ansible任务是*幂等*的，对远程系统几乎没有副作用。
- en: Ansible is written in Python and can be installed using pip.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是用Python编写的，可以使用pip安装。
- en: It uses its own hosts file namely `/etc/ansible/hosts` to keep the host information
    against which it runs its task.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用自己的主机文件，即`/etc/ansible/hosts`，来保存其运行任务的主机信息。
- en: A typical ansible host file may look like,
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的ansible主机文件可能如下所示，
- en: '[PRE8]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The following is a snippet from an Ansible playbook named `dependencies.yaml`
    which installs a few Python packages via pip on a remote host named *webkaffe.*
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个名为`dependencies.yaml`的Ansible playbook的片段，它在名为*webkaffe*的远程主机上通过pip安装了一些Python包。
- en: '[PRE9]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here is an image of running this playbook on the command line using ansible-playbook.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在使用ansible-playbook命令行运行此playbook的图像。
- en: '![Remote deployments using Ansible](../Images/image00520.jpeg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![使用Ansible进行远程部署](../Images/image00520.jpeg)'
- en: Ansible is an easy and efficient way of managing remote dependencies and due
    to its idempotent playbooks, is much better than Fabric at the task.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是管理远程依赖项的一种简单有效的方式，由于其幂等playbooks，比Fabric更适合执行任务。
- en: Managing remote daemons using Supervisor
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Supervisor管理远程守护进程
- en: Supervisor is a client/server system, which is useful to control processes on
    Unix and Unix-like systems. It consists mainly of a server daemon process named
    **supervisord** and a command-line client, which interacts with the server named
    **supervisorctl**.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Supervisor是一个客户端/服务器系统，对于控制Unix和类Unix系统上的进程非常有用。它主要由一个名为**supervisord**的服务器守护进程和一个与服务器交互的命令行客户端**supervisorctl**组成。
- en: Supervisor also comes with a basic webserver, which can be accessed via port
    9001\. It is possible to view the state of running processes, and also to start/stop
    them via this interface. Supervisor doesn't run on any version of Windows.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Supervisor还带有一个基本的Web服务器，可以通过端口9001访问。可以通过此界面查看运行进程的状态，并通过此界面启动/停止它们。Supervisor不在任何版本的Windows上运行。
- en: Supervisor is an application written using Python, and hence, is installable
    via pip. It runs only on Python 2.x versions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Supervisor是一个使用Python编写的应用程序，因此可以通过pip安装。它仅在Python 2.x版本上运行。
- en: Applications to be managed via supervisor should be configured via the supervisor
    daemons configuration file. By default, such files sit in the `/etc/supervisor.d/conf`
    folder.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通过supervisor管理的应用程序应该通过supervisor守护程序的配置文件进行配置。默认情况下，这些文件位于`/etc/supervisor.d/conf`文件夹中。
- en: However, it is possible to run Supervisor locally by installing it to a virtual
    environment, and keeping the configuration local to the virtual environment. In
    fact, this is a common way to run multiple supervisor daemons, each managing processes
    specific to the virtual environment.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也可以通过将其安装到虚拟环境中并将配置保留在虚拟环境中来在本地运行Supervisor。事实上，这是运行多个管理特定于虚拟环境的进程的常见方式。
- en: 'We won''t go into details or examples of using Supervisor, but here are some
    benefits of using Supervisor vs a traditional approach like system `rc.d` scripts:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍或举例使用Supervisor，但以下是使用Supervisor与传统方法（如系统`rc.d`脚本）相比的一些好处：
- en: Decoupling process creation/management and process control by using a client/server
    system. The `supervisor.d` file manages the processes via subprocesses. The user
    can get the process state information via supervisorctl, the client. Also, whereas
    most traditional rc.d processes require root or sudo access, supervisor processes
    can be controlled by normal users of the system via the client or through the
    Web UI.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用客户端/服务器系统来解耦进程创建/管理和进程控制。`supervisor.d`文件通过子进程管理进程。用户可以通过客户端supervisorctl获取进程状态信息。此外，大多数传统的rc.d进程需要root或sudo访问权限，而supervisor进程可以通过系统的普通用户通过客户端或Web
    UI进行控制。
- en: Since supervisord starts processes via subprocesses, they can be configured
    to automatically restart upon crash. It is also easier to get a more accurate
    status of the subprocesses rather than relying on PID files.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于supervisord通过子进程启动进程，可以配置它们在崩溃时自动重新启动。相比依赖PID文件，更容易获得子进程的更准确状态。
- en: Supervisor supports process groups allowing users to define processes in a priority
    order. Processes can be started and stopped in a specific order as a group. This
    allows to implement fine-grained process control when there is a temporal dependency
    between creation of processes in an application. (Process B requires A to be running,
    C requires B to be running, and the like.)
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监管者支持进程组，允许用户按优先级顺序定义进程。进程可以作为一组按特定顺序启动和停止。当应用程序中的进程之间存在时间依赖性时，这允许实现精细的进程控制。（进程B需要A正在运行，C需要B正在运行，依此类推。）
- en: We will complete the discussion in this chapter with an overview of the common
    deployment patterns, which an architect can choose from to solve common issues
    with deployability.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中完成讨论，概述常见的部署模式，架构师可以选择以解决可部署性的常见问题。
- en: Deployment – patterns and best practices
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署-模式和最佳实践
- en: There are different deployment approaches or patterns that can be used to address
    issues like down-times, reduce risks with deployment, and for a seamless development
    and deployment of software.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的部署方法或模式可用于解决停机时间、减少部署风险以及无缝开发和部署软件的问题。
- en: '**Continuous deployment**: Continuous deployment is a deployment model where
    software is ready to go live at any time. Continuous delivery is possible only
    if tiers, including development, testing, and staging, are integrated continuously.
    In a continuous deployment model, multiple production deployments can occur in
    a day, and automatically, via a deployment pipeline. Since one is constantly deploying
    incremental changes, the continuous deployment mode minimizes deployment risks.
    In agile software development houses, it also helps the customer to track progress
    directly by seeing live code in production almost as soon as it leaves development
    and testing. There is also the added advantage of getting user feedback faster
    allowing faster iterations to the code and features.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续部署：持续部署是一种部署模型，其中软件随时可以准备上线。只有在包括开发、测试和暂存在内的各个层次不断集成的情况下，才能实现持续交付。在持续部署模型中，一天内可以发生多次生产部署，并且可以通过部署管道自动完成。由于不断部署增量更改，持续部署模式最小化了部署风险。在敏捷软件开发公司，这也有助于客户通过几乎在开发和测试结束后立即在生产中看到实时代码来直接跟踪进展。还有一个额外的优势，即更快地获得用户反馈，从而允许更快地对代码和功能进行迭代。
- en: '**BlueGreen deployment**: We already discussed this in [Chapter 5](part0040.xhtml#aid-164MG1
    "Chapter 5. Writing Applications That Scale") ob scalability. Blue green deployments
    keep two production environments, closely identical to each other. At a given
    instance, one environment is live (Blue). You prepare your new deployment changes
    to the other environment (Green), and once tested and ready to go live, switch
    your systems—Green becomes active and Blue becomes the backup. BlueGreen deployments
    reduce deployment risks considerably, since for anything that goes wrong with
    the new deployment, you just need to switch your router or load-balancer to the
    new environment. Usually, in typical BlueGreen systems, one system is the production
    (live) and other the staging, and you switch the roles between them.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝绿部署：我们已经在[第5章](part0040.xhtml#aid-164MG1 "第5章。编写可扩展的应用程序")中讨论过这个问题。蓝绿部署保持两个生产环境，彼此非常相似。在某个时刻，一个环境是活跃的（蓝色）。您将新的部署更改准备到另一个环境（绿色），一旦测试并准备好上线，切换系统——绿色变为活跃，蓝色变为备份。蓝绿部署大大降低了部署风险，因为对于新部署出现的任何问题，您只需要切换路由器或负载均衡器到新环境。通常，在典型的蓝绿系统中，一个系统是生产（活跃）的，另一个是暂存的，您可以在它们之间切换角色。
- en: '**Canary releases**: If you want to test the changes in your software on a
    subset of users before deploying it for the entire audience of your customers,
    you can use this approach. In canary release, the changes are rolled out to a
    small subset of users first. A simple approach is dogfooding, where the changes
    are rolled out internally to the employees first. Another approach is beta-testing,
    where a select group of audience is invited to test out your early features. Other
    involved approaches include selecting users based on their geographic location,
    demographics, and profiles. Canary releases, apart from insulating the company
    from sudden user reaction to badly managed features, also allows to manage load
    and capacity scaling in an incremental way. For example, if a particular feature
    becomes popular, and starts driving, say, 100X users to your servers than before,
    a traditional deployment may cause server failures and availability issues as
    opposed to a gradual deployment using a Canary release. Geographical routing is
    a technique that can be used to select a subset of users if you don''t want to
    do complex user profiling and analysis. This is where the load is sent more to
    nodes deployed in a particular geography or data center as opposed to other nodes.
    Canary release is also related to the concept of increment rollout or phased rollout.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金丝雀发布：如果您想在将软件更改部署给所有客户的整个受众之前，先在用户的子集上测试这些更改，您可以使用这种方法。在金丝雀发布中，更改首先针对一小部分用户进行推出。一个简单的方法是狗食，首先将更改内部推出给员工。另一种方法是测试版，邀请一组特定的受众来测试您的早期功能。其他涉及的方法包括根据地理位置、人口统计和个人资料选择用户。金丝雀发布除了使公司免受对糟糕管理的功能的突然用户反应之外，还可以以递增方式管理负载和容量扩展。例如，如果某个特定功能变得受欢迎，并且开始将比以前多100倍的用户驱动到您的服务器，传统的部署可能会导致服务器故障和可用性问题，而不是使用金丝雀发布进行逐步部署。地理路由是一种技术，可以用来选择用户的子集，如果您不想进行复杂的用户分析和分析。这是将负载发送到部署在特定地理位置或数据中心的节点，而不是其他节点。金丝雀发布也与增量部署或分阶段部署的概念相关。
- en: '**Bucket testing (A/B testing)**: This is the technique of deploying two dissimilar
    versions of an application or a webpage to production to test out which version
    is more popular and/or has more engagement. In production, a subset of your audience
    sees the A version of the app (or page)—the control or basic version—and the other
    subset sees the B version or the modified (variant) version. Usually, this is
    a 50-50 split, though as with Canary releases, user profiles, geo locations, or
    other complex models can be used. User experience and engagement is collected
    using an analytics dashboard, and then it is determined whether the change had
    a positive, negative, or neutral response.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桶测试（A/B测试）**：这是一种在生产中部署两个不同版本的应用程序或网页来测试哪个版本更受欢迎和/或更具吸引力的技术。在生产中，你的一部分受众看到应用程序（或页面）的A版本——控制或基本版本——另一部分看到B版本或修改（变体）版本。通常，这是一个50-50的分割，尽管与金丝雀发布一样，用户配置文件、地理位置或其他复杂模型可以被使用。用户体验和参与度是通过分析仪表板收集的，然后确定更改是否有积极、消极或中性的响应。'
- en: '**Induced chaos**: This is a technique of purposely introducing errors or disabling
    part of a production deployment system to test its resilience to failures and/or
    level of availability.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**诱发混乱**：这是一种故意引入错误或禁用生产部署系统的一部分来测试其对故障的弹性和/或可用性的技术。'
- en: Production servers have the problem of drift—unless you use continuous deployment
    or similar approaches for sync, production servers, usually, tend to drift away
    from the standard configuration. One way to test your system is to go and intentionally
    disable part of the production system—this can be done, for example, by disabling
    a random 50% of the nodes in a load-balancer configuration, and see how the rest
    of the system performs.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 生产服务器存在漂移问题——除非你使用持续部署或类似的方法进行同步，否则，生产服务器通常会偏离标准配置。测试系统的一种方法是去故意禁用生产系统的一部分——例如，通过禁用负载均衡器配置中随机50%的节点，然后观察系统的其余部分的表现。
- en: A similar approach in finding out and weeding unused parts of code is to go
    and inject random secrets in parts of the configuration using, say, an API that
    you suspect is redundant and no longer required. You then observe how the application
    performs in production. Since a random secret will fail the API, if there is an
    active part of the application which still uses the dependent code, it will fail
    in production. Otherwise, it is an indication that the code can be safely removed.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找和清除未使用代码的类似方法是去注入随机的秘密部分配置，使用一个你怀疑是多余且不再需要的API。然后观察应用在生产环境中的表现。如果一个随机的秘密会导致API失败，那么如果应用的某个部分仍然使用依赖的代码，它将在生产中失败。否则，这表明代码可以安全地移除。
- en: Netflix has a tool called **Chaos Monkey**, which automatically injects failures
    in production systems, and then measures the impact.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix有一个名为**混沌猴**的工具，它会自动在生产系统中引入故障，然后衡量影响。
- en: Induced Chaos allows the devops engineer and architect to understand weak points
    in the system, learn about systems which are undergoing configuration drift, and
    find and weed out unnecessary or unused parts of an application.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 诱发混乱允许DevOps工程师和架构师了解系统的弱点，了解正在经历配置漂移的系统，并找到并清除应用程序中不必要或未使用的部分。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was about deploying your Python code to production. We looked at
    the different factors that affect the deployability of a system. We went on to
    discuss the tiers in deployment architecture, such as the traditional four-tiered
    and the three- and two- tiered architectures including combinations of development,
    testing, staging/QA, and production tiers.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是关于将你的Python代码部署到生产环境。我们看了影响系统可部署性的不同因素。我们继续讨论了部署架构中的层次，比如传统的四层和三层、两层架构，包括开发、测试、暂存/QA和生产层的组合。
- en: We then went on to discuss the details of packaging Python code. We discussed
    the tools of pip and virtualenv in detail. We looked at how pip and virtualenv
    can work together, and how to install a set of requirements using pip, and set
    up similar virtual environments using it. We also took a quick look at relocatable
    virtual environments.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们讨论了打包Python代码的细节。我们详细讨论了pip和virtualenv这两个工具。我们看了pip和virtualenv如何一起工作，以及如何使用pip安装一组要求，并使用它设置类似的虚拟环境。我们还简要介绍了可重定位的虚拟环境。
- en: We then went to discuss PyPI—the Python Package Index which hosts Python third-party
    packages on the web. We then went through a detailed example of setting up a Python
    package using setuptools and the `setup.py` file. We used the mandelbrot application
    as an example in this case.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们讨论了PyPI——Python包索引，它在网络上托管Python第三方包。然后我们通过一个详细的例子讨论了如何使用setuptools和`setup.py`文件设置Python包。在这种情况下，我们使用mandelbrot应用程序作为例子。
- en: We ended that discussion by showing how to register the package to PyPI using
    its metadata, and also how to upload the package data including its code. We also
    took a brief look at PyPA, the Python Packaging Authority and their projects.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过展示如何使用元数据将包注册到PyPI，并且如何上传包括代码在内的包数据来结束了这次讨论。我们还简要介绍了PyPA，即Python Packaging
    Authority及其项目。
- en: After that, two tools—both developed in Python—were discussed– Fabric for remote
    automated deployments, and Supervisor for remote management of processes on Unix
    systems. We finished the chapter with an overview of the common deployment patterns,
    which one can use to solve deployment problems.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们讨论了两个工具——都是用Python开发的——Fabric用于远程自动部署，Supervisor用于Unix系统上的远程进程管理。我们以概述常见的部署模式结束了这一章，这些模式可以用来解决部署问题。
- en: In the final chapter of this book, we talk about a variety of techniques of
    Debugging your code to find out potential issues.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章中，我们讨论了一系列调试代码的技术，以找出潜在的问题。
