- en: Making a Pet Feeding Robot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作宠物喂食机器人
- en: In this chapter, we will take a step further in terms of integrating the sensors
    to make a robot that feeds your pet whenever you have programmed it to. It is
    fairly simple to build; you might need some DIY skills and a few old cardboards
    to prepare this project. Keep scissors and adhesives handy, as they might be needed
    here.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将进一步整合传感器，制作一个机器人，在你编程它时，它会随时喂你的宠物。这相当简单，你可能需要一些DIY技能和一些旧纸箱来准备这个项目。准备好剪刀和胶水，因为这里可能需要它们。
- en: There are times when you are not at home throughout the day and your pet keeps
    waiting for you to feed him. For such a situation, this robot would be of great
    help; it will feed your pet at specific times and also make sure that your pet
    gets the right quantity of food every single time. This can even be helpful on
    a daily basis. As it will never forget to feed your pet, no matter what.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你一整天都不在家，你的宠物一直在等你喂它。对于这种情况，这个机器人会非常有帮助；它会在特定时间喂你的宠物，并确保你的宠物每次都能得到正确的食物量。这甚至可以在日常生活中有所帮助。因为它永远不会忘记喂你的宠物，无论发生什么。
- en: Force measurement
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 力测量
- en: Force is one of the fundamental units that is applied to objects, either due
    to gravity or some external factors. Force measurements can give us a lot of insight
    about the environment or the object. If you have an electronic weight scale, then
    every time you step on to the weight scale, the weight being told to you happens
    because of a force sensor. This happens because your body has a mass. Due to the
    mass, the gravity pulls the object toward the center of the earth. The force being
    applied by the gravity to any physical object is referred to as the weight of
    the object. Hence, with the force sensor, we are basically sensing how much force
    gravity is applying to a body.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 力是作用于物体上的基本单位之一，无论是由于重力还是某些外部因素。力的测量可以给我们关于环境或物体的很多洞察。如果你有一个电子秤，那么每次你踏上秤时，你得到的重量是因为力传感器。这是因为你的身体有质量。由于质量，重力将物体拉向地球的中心。重力对任何物理物体施加的力被称为物体的重量。因此，通过力传感器，我们基本上是在感知重力对物体施加的力有多大。
- en: Now when we talk about force measurements, it can be done using multiple ways.
    There are various types of complex load cells that can precisely tell us how many
    milligrams of weight have changed. There are also much simpler sensors that can
    simply give us a rough estimate of how much force is being applied. From this
    data, we can calculate the relative weight of the object. You must be asking why
    are we not using the load cell. The reason is that it can be slightly complicated
    for the present scenario, and it's always good to start with basics.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈力测量，它可以采用多种方式。有各种类型的复杂负载传感器，可以精确地告诉我们重量变化了多少毫克。也有更简单的传感器，可以简单地给我们一个粗略的估计，即施加了多少力。从这些数据中，我们可以计算出物体的相对重量。你可能想知道为什么我们不使用负载传感器。原因是它对于当前场景可能稍微复杂一些，而且从基础开始总是好的。
- en: So, let's see what we have. The load sensor we are talking about is a resistive
    force sensor. The way it works is very simple. It consists of polymer whose resistance
    changes with the change of force applied to it. In general, the more force you
    apply, the lower would be the resistance. Hence, due to change in this resistance,
    we can simply calculate the resultant voltage. This resultant voltage would be
    directly proportional to the weight being put on the force sensor.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们看看我们有什么。我们正在谈论的负载传感器是一个电阻式力传感器。它的工作方式非常简单。它由聚合物组成，其电阻随着施加的力的变化而变化。一般来说，你施加的力越大，电阻就越低。因此，由于这种电阻的变化，我们可以简单地计算出结果电压。这个结果电压将与施加在力传感器上的重量成正比。
- en: Constructing the robot
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器人构建
- en: 'Now, to make this robot, we would need a few cardboard cartons. We need to
    make two parts of it:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了制作这个机器人，我们需要一些纸箱。我们需要制作它的两部分：
- en: A food dispenser
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 食物分配器
- en: A collecting bowl with a force sensor
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有力传感器的收集碗
- en: 'First, let''s see how the dispenser has to be made. You need to follow these
    steps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看分配器应该如何制作。你需要遵循以下步骤：
- en: Take a medium-sized carton that can carry up to about four and a half pounds
    of pet food.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取一个中等大小的纸箱，可以携带大约四磅半的宠物食品。
- en: Then, go ahead and make a small cutout.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，继续制作一个小开口。
- en: This cutout should be big enough to dispense food but not so big that a lot
    of food comes out of it at once.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个开口应该足够大，以便分配食物，但不能太大，以至于一次有太多食物从里面出来。
- en: Now, once that is done, you need to make a lid that covers that through-hole.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，一旦完成这个步骤，你需要制作一个覆盖通孔的盖子。
- en: This lid should be slightly bigger than the through-hole itself.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个盖子应该比本身略大。
- en: Install the lid over the shaft of the motor.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将盖子安装在电机的轴上。
- en: Fix the motor on to the cardboard, as shown in the following diagram. Make sure
    that the position of the motor should be such that the lid covers the entire through-hole
    on the cardboard.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下图示将电机固定在纸板上。确保电机的位置要使得盖子能够覆盖纸板上的整个通孔。
- en: Finally, install ends-stops. These are simple pieces of cardboard that will
    restrict the movement of the lid in either direction.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，安装限位器。这些是简单的纸板片，将限制盖子向任一方向的移动。
- en: The first end-stop should be at a position that it should stop the lid exactly
    where it covers the entire through-hole.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个限位器应该位于一个位置，使得盖子正好覆盖整个通孔时停止。
- en: The second should be at a position where the lid is entirely opened, and there
    is no obstruction when the food comes down from the container.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个应该位于盖子完全打开的位置，当食物从容器中落下时没有阻碍。
- en: 'To help you with the construction, refer to the following diagram; you can
    devise other ways to control the opening or closing as well if you want:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您进行构造，请参考以下图示；如果您想的话，也可以设计其他控制开启或关闭的方法：
- en: '![](img/4d8071ec-b20a-4e4f-93df-a7f245c651f0.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4d8071ec-b20a-4e4f-93df-a7f245c651f0.png)'
- en: Now, the second part is the bowl. This part is pretty straightforward. You simply
    need to paste the force sensor using a mild adhesive onto the bottom of the bowl,
    where it makes contact with the ground. Once this is done, add another layer of
    adhesive and attach it exactly below the dispenser.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第二部分是碗。这部分相当直接。你只需要将力传感器使用温和的粘合剂粘贴在碗底，使其与地面接触。完成这个步骤后，添加另一层粘合剂并将其精确地粘贴在分配器下方。
- en: 'Once this constitution is done, go ahead and wire it up, as shown here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这个构造，请按照以下图示进行布线：
- en: '![](img/8a4a6b59-6c83-411c-921b-4dcf1c997f21.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8a4a6b59-6c83-411c-921b-4dcf1c997f21.png)'
- en: 'Perfect! Now we are ready to upload our code and make this thing work. So,
    go ahead and upload the following code; then I will tell you what exactly is happening:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在我们准备好上传代码并让这个装置工作。所以，请上传以下代码；然后我会告诉你具体发生了什么：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, once you upload this code, you will start to get the raw reading of the
    force sensors. How? Let''s see:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦你上传了这个代码，你将开始得到力传感器的原始读数。如何？让我们看看：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we are sporting the library for `ADS1x15` using the command `import Adafruit_ADS1x115`;
    this will help us read the value from the ADC:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用命令`import Adafruit_ADS1x115`来使用`ADS1x15`库；这将帮助我们读取ADC的值：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should know what this line does; however if you are not sure, refer to
    [Chapter 2](ef81f30f-708e-4228-a92d-0f343f5928d3.xhtml), *Using GPIOs as Input*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该知道这一行的作用；然而，如果你不确定，请参考[第2章](ef81f30f-708e-4228-a92d-0f343f5928d3.xhtml)，*使用GPIO作为输入*：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this line, the raw reading that has been received by the ADC will be shown
    to you.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行，将显示ADC接收到的原始读数。
- en: You must be wondering why we are doing this. Till now, you must have been feeding
    your pet based on visual quantity, instead of a specific weight. Hence, what we
    are doing here is printing the value of the force sensor. Once this value is printed,
    then you can correct quantity of the food in the container and measure the reading.
    This reading will act as a threshold. That is, this is the quantity that would
    be dispensed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我们为什么要这样做。到目前为止，你可能一直根据视觉数量而不是具体重量来喂养你的宠物。因此，我们在这里做的是打印力传感器的值。一旦这个值被打印出来，然后你可以调整容器中食物的数量并测量读数。这个读数将作为阈值。也就是说，这是将要分配的数量。
- en: 'Now, once you have noted this reading, we will change the code slightly. Let''s
    see what it is:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦你记下了这个读数，我们将稍微修改一下代码。让我们看看是什么：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now let's see what we have done!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们做了什么！
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we are declaring the pins connected for the motor, buzzer, and **Force
    Sensitive Resistor** (**FSR**). Also, we are assigning the value to a variable
    named `THRESHOLD`; this will determine the amount of food that will be dispensed.
    Here, we have kept an arbitrary value as `1000`. In your code, you must put the
    value that you have calculated in the previous code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了连接到电机、蜂鸣器和**力敏电阻**（**FSR**）的引脚。我们还为名为`THRESHOLD`的变量赋值；这将确定将要分配的食物量。在这里，我们随意地使用了`1000`。在你的代码中，你必须放入之前代码中计算出的值。
- en: 'Now that most of the code is easily understandable, let''s jump to the part
    where the main show is happening:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大多数代码都很容易理解，让我们跳到主要表演的部分：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the first line using the function `datetime.dateime.now().strftime(''%H'')`,we
    are deriving the value of hours at that moment, and using the function `M = datetime.datetime.now().strftime(''%M'')`,
    we are deriving the minutes. Once this is done, then using the condition `if (H
    == 12 or H ==20) && M == 00`, we are checking whether the time is  12 noon or
    20:00 hours in the evening. Once any of these condition are true, then the value
    of `M` is also getting checked. If `M == 00`, then the value of ADC would be checked
    using the function `adc.get_last_result()`. The function stores the value in a
    variable named `value`. Once the value is checked, it is checked by `while value<
    THRESHOLD:`. If the condition is true, then `BUZZER` and `MOTOR1a` are set to
    high. This means that the buzzer will ring and the motor will turn in one direction. As
    we have an end-stop at both directions, the motor will stop whenever it reaches
    that position:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，使用函数`datetime.datetime.now().strftime('%H')`，我们得到当时的小时值，并使用函数`M = datetime.datetime.now().strftime('%M')`得到分钟值。一旦完成，然后使用条件`if
    (H == 12 or H == 20) && M == 00`检查时间是否为中午12点或晚上20:00。一旦这些条件中的任何一个成立，那么也会检查`M`的值。如果`M
    == 00`，则使用函数`adc.get_last_result()`检查ADC的值。该函数将值存储在名为`value`的变量中。一旦检查了值，它将通过`while
    value < THRESHOLD:`进行检查。如果条件成立，则`BUZZER`和`MOTOR1a`被设置为高。这意味着蜂鸣器会响，电机将朝一个方向转动。由于我们有两个方向的限位器，电机会在达到那个位置时停止：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once the preceding condition is false, then the rest of code will come into
    action, which basically will turn the motor to the closing side and it will stop
    the buzzer from buzzing. The motor will try to retract to its closed position
    for `5` seconds, as after the condition `time.sleep(5)`, the motor will get a
    command `GPIO.output(MOTOR1b,0)`, which will stop the motor from turning.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦前面的条件不成立，其余的代码就会开始执行，这基本上会将电机转向关闭一侧，并停止蜂鸣器响声。电机将尝试在`5`秒内收回至关闭位置，因为`time.sleep(5)`条件之后，电机将接收到`GPIO.output(MOTOR1b,0)`命令，这将停止电机转动。
- en: Hence, in summary, the robot will dispense the food at certain times and in
    a very specific quantity that you decide.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结来说，机器人将在你决定的时间以非常具体的数量分发食物。
- en: Making the robot detect pets
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使机器人检测宠物
- en: The preceding code is good, and I'm sure it would be dispensing the food at
    set times. However, there can be a problem, as the robot would not be effective
    if the pet does not know whether the food had been fetched. Hence, we need to
    have an alarm that should inform the pets that the food is ready to be eaten.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是好的，我相信它会在设定的时间分发食物。然而，可能会有问题，因为如果宠物不知道食物是否已经被取走，那么机器人将不会有效。因此，我们需要有一个警报，通知宠物食物已经准备好可以吃了。
- en: Even in the previous program, we have used a buzzer that will inform the pet
    when the food is being dispensed, but, that was only for a very short period of
    time. However, what we are talking about here is an alarm system that will keep
    on ringing till the time the pet does not come and eat the food. To do this, connect
    the system as follows and mount the ultrasonic sensor in such a way that it notes
    the distance of the pet while he is eating the food.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在之前的程序中，我们也使用了一个蜂鸣器来通知宠物食物正在分发，但那只是很短的时间。然而，我们现在讨论的是一个警报系统，它将持续响直到宠物来吃食物。为此，按照以下方式连接系统，并将超声波传感器以记录宠物吃食物时的距离的方式安装。
- en: '![](img/9a02b251-9ebb-4f6d-9a99-8a6017acc744.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a02b251-9ebb-4f6d-9a99-8a6017acc744.png)'
- en: 'Now, to do that, you will need to upload the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了做到这一点，你需要上传以下代码：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, most of the code is almost identical; however, there is an
    added feature that will keep ringing the buzzer till the time the pet does not
    come and eat the food. To do this, we input the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，大部分代码几乎完全相同；然而，增加了一个功能，它将一直让蜂鸣器响，直到宠物来吃食物。为此，我们输入以下内容：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have defined a function that notes down the distance taken from the ultrasonic
    sensor. You may recollect this code form the previous chapters. So, now, whenever
    this function is called, the distance will be noted down:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个记录超声波传感器距离的函数。您可能还记得之前的章节中的这段代码。所以现在，每次调用这个函数时，都会记录下距离：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, the buzzer is getting switched on in the while loop just like
    last time; however, after `5` in the previous code after 5 second of wait the
    buzzer was switched off.  However, in this code, we are not doing so. Hence, the
    buzzer will stay active till the time some part of our code does not turn it off. Now,
    to turn on the buzzer, we are calculating the distance at the end of the code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你们所看到的，蜂鸣器在while循环中就像上次一样被打开；然而，在之前的代码中，在等待了5秒之后蜂鸣器被关闭。然而，在这段代码中，我们并没有这样做。因此，蜂鸣器将会保持活跃，直到我们的代码中某个部分将其关闭。现在，为了打开蜂鸣器，我们在代码的末尾计算距离：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This part of code is checking whether distance is less than `2` centimeters
    and the weight value of the food container is less than `50`. This means the pet
    approaches the food container and eats at least half of the food. If he does not
    eat the food properly, then the buzzer will keep on buzzing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码正在检查距离是否小于`2`厘米，以及食物容器的重量值是否小于`50`。这意味着宠物接近食物容器并至少吃掉了一半的食物。如果他没有正确地吃食物，那么蜂鸣器将会持续鸣响。
- en: Summary
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So readers, I think you understood the basics of motor integration with logic
    of time and force sensor to make a robot that does some of your work on a daily
    basis. These kinds of robots are available on the market for hundreds of dollars,
    but see how easily and at such low cost you made one for yourself. Moving forward,
    in the next chapter, we will be building a Bluetooth controlled robotic car.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，读者们，我想你们已经理解了使用时间和力传感器逻辑进行电机集成的基础知识，以此来制作一个能帮你日常做些工作的机器人。这类机器人在市场上只需几百美元就能买到，但看看你们是如何如此容易且低成本地为自己制作了一个。向前看，在下一章中，我们将构建一个蓝牙控制的机器人汽车。
