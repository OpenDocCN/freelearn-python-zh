- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Flask Unit Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask 单元测试
- en: '**Unit testing** is an essential phase in software development that guarantees
    the proper functioning of each component of an application. In [*Chapter 7*](B18554_07.xhtml#_idTextAnchor142),
    *React Unit Testing*, we discussed unit testing as it relates to React components
    in building reliable user interfaces for the frontend part of a web application.
    With backend development, the principles of unit testing are similar, except that
    you are using a different programming language – or better, still working with
    a backend tech stack.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**是软件开发的一个关键阶段，它保证了应用程序每个组件的正确运行。在[*第 7 章*](B18554_07.xhtml#_idTextAnchor142)“React
    单元测试”中，我们讨论了与 React 组件相关的单元测试，这是构建可靠用户界面以构建网络应用程序前端部分的过程。在后台开发中，单元测试的原则相似，只是你使用的是不同的编程语言——或者更确切地说，你仍然在与后台技术栈一起工作。'
- en: Unit testing ensures that each component or module of a software application
    is working correctly in isolation from the rest of the application. By testing
    each unit separately and thoroughly, developers can identify and fix issues early
    in the development cycle, which can save time and effort in the long run.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试确保软件应用程序的每个组件或模块在与其他应用程序部分隔离的情况下正确工作。通过单独和彻底地测试每个单元，开发人员可以在开发周期的早期识别和修复问题，这可以从长远来看节省时间和精力。
- en: Unit testing helps catch defects early and provides a safety net for refactoring
    code, making it easier to maintain and evolve the application over time. Ultimately,
    the goal of unit testing is to produce high-quality software that meets the requirements
    and expectations of end users.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试有助于早期发现缺陷，并为重构代码提供安全网，使得随着时间的推移维护和演进应用程序变得更加容易。最终，单元测试的目标是产生符合用户需求和期望的高质量软件。
- en: In this chapter, we will discuss briefly the importance of unit testing in Flask
    and explore the benefits of using pytest as a testing framework for Flask applications.
    We will also cover the installation and setup process for pytest, as well as the
    fundamentals of **test-driven** **development** (**TDD**).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要讨论单元测试在 Flask 中的重要性，并探讨使用 pytest 作为 Flask 应用程序的测试框架的好处。我们还将涵盖 pytest
    的安装和设置过程，以及测试驱动开发（TDD）的基本原理。
- en: Additionally, we will delve into writing basic tests and assertions and handling
    exceptions. At the end of this chapter, you will be able to understand the importance
    of unit testing in Flask applications, describe what pytest is and how it differs
    from other testing frameworks, and how pytest can be integrated into your existing
    project.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将深入探讨编写基本测试和断言以及处理异常。在本章结束时，你将能够理解单元测试在 Flask 应用程序中的重要性，描述 pytest 是什么以及它与其他测试框架的区别，以及如何将
    pytest 集成到现有的项目中。
- en: You will have also learned how to test JSON APIs using pytest and understand
    how to make requests to the API endpoints and validate the response data. Finally,
    you will be able to apply TDD principles to write tests before writing the actual
    code and use the tests to guide the development process.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习如何使用 pytest 测试 JSON API，了解如何向 API 端点发送请求并验证响应数据。最后，你将能够应用测试驱动开发（TDD）原则，在编写实际代码之前编写测试，并使用测试来指导开发过程。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Unit testing in Flask applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask 应用程序中的单元测试
- en: Introducing pytest
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 pytest
- en: Setting up of pytest
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pytest 的设置
- en: Basic syntax, structures, and features of pytest
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pytest 的基本语法、结构和功能
- en: Writing unit tests
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: Testing JSON APIs
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 JSON API
- en: Test-driven development with Flask
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Flask 进行测试驱动开发
- en: Handling exceptions
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异常
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter15](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter15)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在 GitHub 上找到：[https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter15](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter15)
- en: Unit testing in Flask applications
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask 应用程序中的单元测试
- en: '**Flask** is like a chef’s knife for web developers – it’s a versatile tool
    that can help you cook up scalable and flexible applications in no time. However,
    as the complexity of Flask applications grows, it becomes increasingly difficult
    to ensure that all the components of the application are working correctly together.
    This is where unit testing comes in.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**Flask**就像厨师的刀一样，对于网络开发者来说——它是一个多才多艺的工具，可以帮助你迅速制作出可扩展和灵活的应用程序。然而，随着Flask应用程序复杂性的增加，确保应用程序的所有组件正确协同工作变得越来越困难。这就是单元测试发挥作用的地方。'
- en: Unit testing is a software testing technique that involves testing each component
    or module of an application in isolation from the rest of the application. By
    testing each unit separately and thoroughly, developers can identify and fix issues
    at the outset of the development process. The practice of unit testing can assist
    in spotting defects quickly and serve as a safeguard when making changes or modifying
    code, thus making it easier to maintain and evolve the application over time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一种软件测试技术，它涉及在隔离于应用程序其余部分的情况下测试应用程序的每个组件或模块。通过单独和彻底地测试每个单元，开发人员可以在开发过程的早期阶段识别和修复问题。单元测试的实践有助于快速发现缺陷，并在进行更改或修改代码时提供保障，从而使得随着时间的推移维护和演进应用程序变得更加容易。
- en: With Flask applications, unit testing helps ensure that all the routes, views,
    and other components are working as expected. Unit testing can also help catch
    issues with database interactions, external API calls, and other external dependencies.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Flask应用程序，单元测试有助于确保所有路由、视图和其他组件按预期工作。单元测试还可以帮助捕捉与数据库交互、外部API调用和其他外部依赖项的问题。
- en: 'The testing heuristics or principles are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 测试启发式方法或原则如下：
- en: '**FIRST**: Fast, Independent, Repeatable, Self-Validating, and Timely'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**首次**：快速、独立、可重复、自我验证和及时'
- en: '**RITE**: Readable, Isolated, Thorough, and Explicit'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RITE**：可读性、隔离性、全面性和明确性'
- en: '**3A**: Arrange, Act, Assert'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3A**：安排、行动、断言'
- en: These principles can be utilized by developers as guidelines and best practices
    to ensure the effectiveness of their unit testing efforts. These testing principles
    can enhance the quality of code, minimize bugs and defects, and ultimately deliver
    superior software products to application users. By adhering to these principles,
    developers and testers can improve the overall reliability and maintainability
    of the code base.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则可以作为开发者的指南和最佳实践，确保他们的单元测试工作有效。这些测试原则可以提高代码质量，最小化错误和缺陷，并最终向应用程序用户提供更优质的软件产品。通过遵守这些原则，开发人员和测试人员可以提高代码库的整体可靠性和可维护性。
- en: Let’s briefly examine these testing principles to understand how they can guide
    you in writing excellent unit tests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地审视这些测试原则，以了解它们如何指导你编写出色的单元测试。
- en: FIRST
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FIRST
- en: 'FIRST emphasizes the importance of unit tests being quick to run, not dependent
    on external factors, able to be run repeatedly without side effects, self-checking,
    and written promptly:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: FIRST强调单元测试运行快速、不依赖于外部因素、可重复运行而不产生副作用、自我检查和及时编写的重要性：
- en: '`pytest_mock` plugin.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest_mock`插件。'
- en: '**Independent**: Unit tests should be designed to run independently of each
    other so that the failure of one test does not affect the execution of other tests.
    In Flask, we can achieve independence between tests by resetting the application
    state before each test using the Flask test client.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立**：单元测试应该设计为相互独立运行，以便一个测试的失败不会影响其他测试的执行。在Flask中，我们可以通过在每个测试之前使用Flask测试客户端重置应用程序状态来实现测试之间的独立性。'
- en: '**Repeatable**: Unit tests should be designed to produce the same result every
    time they are run, regardless of the environment in which they are executed. This
    means that the unit under test should not rely on external factors, such as system
    time or random number generators, that can introduce variability in the test results.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重复**：单元测试应该设计为每次运行时都能产生相同的结果，无论它们在哪个环境中执行。这意味着正在测试的单元不应该依赖于外部因素，如系统时间或随机数生成器，这些因素可能会引入测试结果的可变性。'
- en: '**Self-checking**: Unit tests should be designed to check their results and
    report failures without requiring human intervention. This means that the unit
    test should include assertions that compare the expected results with the actual
    results of the test. In Flask, we can use the built-in assert statement to check
    the test results.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自检性**：单元测试应该设计成能够检查其结果并报告失败，而不需要人工干预。这意味着单元测试应该包含断言，比较预期的结果与测试的实际结果。在Flask中，我们可以使用内置的断言语句来检查测试结果。'
- en: '**Timely**: Unit tests should be designed to be written promptly, ideally before
    the code they are testing is written. This means that they should be part of the
    development process and not an afterthought. In Flask, we can follow the TDD approach
    to ensure that tests are written before the code.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**及时性**：单元测试应该设计成能够及时编写，理想情况下在它们所测试的代码编写之前。这意味着它们应该是开发过程的一部分，而不是事后考虑。在Flask中，我们可以遵循
    TDD（测试驱动开发）方法来确保测试在代码编写之前完成。'
- en: Next, we will explore RITE (Reproducible, Isolated, Thorough and Extensible),
    a testing principle that can enhance the effectiveness of unit tests and enhance
    code quality.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨 RITE（可重复、隔离、全面和可扩展）这一测试原则，它可以提高单元测试的有效性并提升代码质量。
- en: RITE
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RITE
- en: 'RITE emphasizes the importance of unit tests being easy to read and understand,
    isolated from other components, covering all possible scenarios, and explicit
    in their assertions:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: RITE 强调单元测试易于阅读和理解的重要性，它们应该与其它组件隔离，覆盖所有可能的场景，并且在断言中明确：
- en: '**Reproducible**: Tests should be able to be reproduced on different systems
    and environments. This means that tests should not rely on external factors such
    as network connectivity, time, or other system resources. By ensuring that tests
    can be run consistently across different environments, developers can be confident
    that their code works as intended.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重复性**：测试应该能够在不同的系统和环境中重复。这意味着测试不应该依赖于外部因素，如网络连接、时间或其他系统资源。通过确保测试可以在不同的环境中一致运行，开发者可以确信他们的代码按预期工作。'
- en: '**Isolated**: Tests should be independent of each other and not share any state.
    This means that each test should start with a clean slate and not rely on any
    previous test results or global state. By isolating tests, developers can ensure
    that each test is testing a specific piece of functionality and is not affected
    by other parts of the system.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：测试应该相互独立，不共享任何状态。这意味着每个测试都应该从一个干净的状态开始，不依赖于任何之前的测试结果或全局状态。通过隔离测试，开发者可以确保每个测试都在测试特定的功能部分，并且不受系统其他部分的影响。'
- en: '**Thorough**: Tests should test all aspects of the system, including edge cases
    and error conditions. This means that developers should strive to create tests
    that cover as much of the code base as possible, including all possible inputs
    and outputs.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全面性**：测试应该测试系统的所有方面，包括边缘情况和错误条件。这意味着开发者应该努力创建尽可能覆盖代码库的测试，包括所有可能的输入和输出。'
- en: '**Extensible**: Tests should be easy to extend and maintain as the system evolves.
    This means that tests should be designed to accommodate changes in the code base,
    such as new features or changes in the system architecture.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：测试应该易于扩展和维护，随着系统的演变而发展。这意味着测试应该设计成能够适应代码库的变化，例如新功能或系统架构的变化。'
- en: In a nutshell, the RITE principles are beneficial because they can help you
    to improve the quality, reliability, and maintainability of your code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，RITE 原则是有益的，因为它们可以帮助你提高代码的质量、可靠性和可维护性。
- en: Moving forward, we will explore 3A (Arrange, Act, and Assert), a unit test approach
    that can make your unit tests more readable and maintainable.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前进的过程中，我们将探讨 3A（安排、行动和断言）这一单元测试方法，它可以使你的单元测试更易于阅读和维护。
- en: 3A
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3A
- en: '3A is a simple guideline for structuring a unit test and consists of three
    steps – Arrange, Act, and Assert. The Arrange phase sets up the test scenario,
    the Act phase performs the action being tested, and the Assert phase checks the
    expected outcome. The 3A principle is the best practice for designing and writing
    effective unit tests:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 3A 是一个简单的单元测试结构指南，包括三个步骤——安排（Arrange）、行动（Act）和断言（Assert）。安排阶段设置测试场景，行动阶段执行被测试的操作，断言阶段检查预期的结果。3A
    原则是设计和编写有效单元测试的最佳实践：
- en: '**Arrange**: In this step, you set up the conditions for the test by initializing
    objects, setting variables, and other necessary actions. This ensures that the
    test environment is properly configured and that the system under test is in the
    expected state.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安排（Arrange）**：在这个步骤中，你通过初始化对象、设置变量和其他必要操作来设置测试的条件。这确保了测试环境得到正确配置，并且被测试的系统处于预期的状态。'
- en: '**Act**: In this step, you perform the action or method call that is being
    tested. This may involve passing arguments to a function, invoking a method on
    an object, or making a request to an API endpoint. The key is to ensure that the
    action being taken is specific and targeted at the functionality being tested.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行动（Act）**：在这个步骤中，你执行被测试的动作或方法调用。这可能包括向函数传递参数、在对象上调用方法或向API端点发出请求。关键是确保所采取的行动是具体且针对被测试的功能的。'
- en: '**Assert**: In this step, you verify that the outcome of the action matches
    the expected result. This often involves checking the value returned by a function,
    comparing the state of an object before and after a method call, or ensuring that
    an API endpoint returns the correct response status code and data.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言（Assert）**：在这个步骤中，你验证动作的结果是否与预期结果相符。这通常涉及到检查函数返回的值、比较方法调用前后对象的状态，或者确保API端点返回正确的响应状态码和数据。'
- en: Next, we will explore Pytest as a widely used testing framework that seamlessly
    integrates with Flask. Pytest is empowering developers to efficiently create and
    execute unit tests, integration tests, and more, ensuring the robustness and reliability
    of Flask web applications.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨Pytest作为一个广泛使用的测试框架，它能够无缝地与Flask集成。Pytest赋予开发者高效创建和执行单元测试、集成测试等能力，确保Flask
    Web应用的健壮性和可靠性。
- en: Introducing Pytest
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Pytest
- en: '**Pytest** is an open source testing framework for Python that simplifies the
    process of writing and executing concise and readable tests. Pytest provides a
    simple and flexible way to write tests and supports a wide range of testing options
    out of the box, including functional tests, unit tests, and integration tests.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pytest**是一个开源的Python测试框架，它简化了编写和执行简洁、易读测试的过程。Pytest提供了一种简单灵活的方式来编写测试，并自带广泛的支持测试选项，包括功能测试、单元测试和集成测试。'
- en: Pytest is widely used among Python developers due to its ease of use, powerful
    fixture system, and integration with other Python testing tools. Pytest can automatically
    find and run all the tests in a project with the `-test` discovery ability. Pytest
    generates detailed reports that provide developers with valuable insights into
    the test results.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其易用性、强大的固定系统以及与其他Python测试工具的集成，Pytest在Python开发者中得到了广泛的应用。Pytest具有自动发现并运行项目中所有测试的`-test`发现能力。Pytest生成详细的报告，为开发者提供了对测试结果的宝贵见解。
- en: These reports include information on the number of tests executed, the time
    taken to run each test, and any failures or errors that occurred. This information
    can help developers pinpoint and address issues promptly, improving the overall
    quality of the code base. Pytest has an amazing large community of users and contributors
    who actively develop and maintain plugins that extend Pytest functionalities.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些报告包括关于执行测试的数量、每个测试的运行时间以及发生的任何失败或错误的信息。这些信息可以帮助开发者迅速定位并解决问题，从而提高代码库的整体质量。Pytest拥有一个庞大的用户和贡献者社区，他们积极开发和维护扩展Pytest功能的插件。
- en: Interestingly, Pytest differs from other testing frameworks such as `unittest`,
    `nose`, `doctest`, `tox`, `hypothesis library`, and `robot framework` with its
    simplicity and power, versatility, and community support, providing easy-to-use
    testing capabilities with detailed reporting. Pytest is undoubtedly a popular
    choice among Python developers for unit testing and other testing needs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Pytest与其他测试框架（如`unittest`、`nose`、`doctest`、`tox`、`hypothesis library`和`robot
    framework`）相比，以其简洁和强大、多功能性和社区支持而不同，提供了易于使用的测试功能以及详细的报告。Pytest无疑是Python开发者进行单元测试和其他测试需求的热门选择。
- en: Next, we’ll walk through the steps of setting up Pytest and creating our first
    test.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将逐步介绍如何设置Pytest并创建我们的第一个测试。
- en: Setting up Pytest
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Pytest
- en: Testing your Python code is an essential part of the development process, and
    Pytest is a powerful tool for actualizing a robust testing environment. In this
    section, we’ll walk you through the steps of setting up Pytest and transforming
    your Python code testing experience from amateur into pro, providing advanced
    features and capabilities that make testing faster, easier, and more effective.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 测试Python代码是开发过程中的一个重要部分，Pytest是实现强大测试环境的有力工具。在本节中，我们将向您介绍设置Pytest的步骤，并将您的Python代码测试体验从业余水平提升到专业水平，提供高级功能和能力，使测试更快、更简单、更有效。
- en: 'To set up Pytest, you can follow these steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置Pytest，您可以按照以下步骤操作：
- en: '`pip`, the package installer for Python. Open your Terminal or command prompt
    in the `bizza/backend/` project directory and run the following command:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pip`是Python的包安装器。在`bizza/backend/`项目目录中打开您的终端或命令提示符，并运行以下命令：'
- en: '[PRE0]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding line installs Pytest and all its dependencies.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前一行安装了Pytest及其所有依赖项。
- en: '`test_addition.py` in your project directory – that is, `bizza/backend/tests/test_addition.py`.
    This is a simple example test file to warm up with.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目目录中的`test_addition.py` – 即`bizza/backend/tests/test_addition.py`。这是一个简单的示例测试文件，用于热身。
- en: '`test_addition.py`, write a simple test function using the following format:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test_addition.py`中，使用以下格式编写一个简单的测试函数：
- en: '[PRE1]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s discuss the preceding short format snippet:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们讨论前面的简短格式片段：
- en: '`test_function_name` represents the test function’s name'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_function_name`代表测试函数的名称。'
- en: '`expression` represents the code you want to test'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expression`代表您想要测试的代码。'
- en: The `assert` statement checks whether the expression is true and raises an error
    if the expression is false
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert`语句检查表达式是否为真，如果表达式为假，则引发错误。'
- en: Note
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Pytest, test functions are identified by their name and should start with
    the `test_` prefix. With this naming convention, Pytest can recognize your functions
    as tests and run them automatically. When you run Pytest in the Terminal, Pytest
    searches your code base for any functions that begin `test_`. Then, Pytest executes
    those functions and reports the results of the tests.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pytest中，测试函数通过其名称识别，并且应该以`test_`前缀开头。使用这种命名约定，Pytest可以识别您的函数作为测试并自动运行它们。当您在终端中运行Pytest时，Pytest会在您的代码库中搜索任何以`test_`开头的函数。然后，Pytest执行这些函数并报告测试结果。
- en: 'Now, let’s describe a test function that tests whether adding two numbers produces
    the expected result:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们描述一个测试函数，该函数测试添加两个数是否产生预期的结果：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code shows a simple Pytest test function that tests the addition
    of two numbers. The function’s name starts with `test_`, which tells Pytest that
    it is a test function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示了一个简单的Pytest测试函数，该函数测试两个数的相加。函数的名称以`test_`开头，这告诉Pytest它是一个测试函数。
- en: The body of the function contains an assertion that checks whether `1 + 1` equals
    `2`. If the assertion is `true`, then the test passes. If the assertion is `false`,
    then the test fails and Pytest reports an error.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体包含一个断言，检查`1 + 1`是否等于`2`。如果断言为`true`，则测试通过。如果断言为`false`，则测试失败，Pytest会报告错误。
- en: '`bizza/backend/`. Run the following command to run your tests:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bizza/backend/`。运行以下命令以运行您的测试：
- en: '[PRE3]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s take a look at the preceding output:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看一下前面的输出：
- en: The first line in the preceding code shows some information about the platform
    and versions of Python, Pytest, and other related plugins.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一段代码的第一行显示了有关平台和Python、Pytest以及其他相关插件的版本信息。
- en: The second line indicates the root directory for the tests. In this case, it
    is `C:\bizza\backend`.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二行指示测试的根目录。在这种情况下，它是`C:\bizza\backend`。
- en: The third line shows that Pytest has collected one test item, which is stored
    in the `tests\test_addition.py` file.
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三行显示Pytest已收集一个测试项，该测试项存储在`tests\test_addition.py`文件中。
- en: 'The fourth line shows the result of the test: a single dot indicates that the
    test passed. If the test had failed, this would have been indicated by `"F"`.'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四行显示了测试结果：一个单独的点表示测试通过。如果测试失败，这将显示为`"F"`。
- en: The fifth line shows some summary information, including the number of tests
    that passed, and the time taken to run the tests.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第五行显示了一些摘要信息，包括通过测试的数量和运行测试所需的时间。
- en: Finally, the command prompt returns, indicating that the test has finished running.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，命令提示符返回，表示测试已运行完成。
- en: 'Let’s assume the `test_addition.py` function’s output has changed to `5` instead
    of `2`. Should we expect the test to fail? Of course, yes! The test should fail.
    The following is the output of the failed test:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`test_addition.py`函数的输出已更改为`5`而不是`2`。我们应该期待测试失败吗？当然，是的！测试应该失败。以下为失败的测试输出：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding output indicates that the test named `test_addition.py` has failed.
    The assertion asserts `1 + 1 == 5` is failing because the actual result of 1 +
    1 is 2, not 5.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出表明名为`test_addition.py`的测试失败了。断言`1 + 1 == 5`失败，因为1 + 1的实际结果是2，而不是5。
- en: Ready for the next step? Let’s examine the basic syntax and structure of Pytest.
    Then, we will dive deeper into unit testing with Pytest.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好下一步了吗？让我们来检查Pytest的基本语法和结构。然后，我们将深入探讨使用Pytest进行单元测试。
- en: Basic syntax, structures, and features of Pytest
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pytest的基本语法、结构和功能
- en: 'The basic syntax and structure of a Pytest test function can be represented
    as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest测试函数的基本语法和结构可以表示如下：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`test_function_name` should be a descriptive name that conveys the purpose
    of the test:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_function_name`应该是一个描述性的名称，传达测试的目的：'
- en: The `Arrange` section sets up the necessary test data or environment, such as
    initializing objects or connecting to a database
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Arrange`部分设置必要的测试数据或环境，例如初始化对象或连接到数据库'
- en: The `Act` section executes the code being tested, such as calling a function
    or performing a specific action
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Act`部分执行被测试的代码，例如调用一个函数或执行特定的操作'
- en: The `Assert` section checks that the expected behavior is observed, using assertions
    to verify that the output or behavior of the code matches what was expected
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert`部分检查是否观察到了预期的行为，使用断言来验证代码的输出或行为是否符合预期'
- en: Pytest supports a wide range of assertions, including `assert x == y, assert
    x != y, assert x in y,` and many more. Pytest also supports the use of fixtures,
    which can be used to manage test dependencies and set up test data and environments.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest支持广泛的断言，包括`assert x == y, assert x != y, assert x in y,`等等。Pytest还支持使用fixtures，可以用来管理测试依赖关系和设置测试数据和环境。
- en: The basic syntax and structure of a Pytest test function are designed to make
    it easy to write clear, concise tests that verify that your code works as expected.
    With Pytest’s structure and the use of fixtures, you can write tests that are
    reliable, repeatable, and easy to maintain.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest测试函数的基本语法和结构旨在使编写清晰、简洁的测试变得容易，以验证代码按预期工作。使用Pytest的结构和fixtures的使用，你可以编写可靠、可重复且易于维护的测试。
- en: 'Next, we will look at one of the key Pytest features: **fixtures**.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨Pytest的一个关键特性：** fixtures**。
- en: Using fixtures
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用fixtures
- en: In software testing, a **fixture** is a defined state or set of data that is
    needed for a test to run. Essentially, fixtures are functions that help in managing
    and providing consistent resources, such as data, configuration, or objects, to
    different test cases within a test suite. Fixtures enable you to establish a stable
    and controlled environment for testing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件测试中，**fixture**是为测试运行所需定义的状态或数据集。本质上，fixtures是帮助管理和提供一致资源（如数据、配置或对象）的函数，这些资源用于测试套件中的不同测试用例。Fixtures使你能够为测试建立稳定且受控的环境。
- en: They ensure that each test case has access to the required resources without
    duplicating setup and teardown methods across multiple tests. You are probably
    wondering what setup and teardown methods are. Let’s pause for a minute and shed
    more light on this duo in testing Flask applications.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它们确保每个测试用例都能访问所需的资源，而不会在多个测试中重复设置和清理方法。你可能想知道设置和清理方法是什么。让我们暂停一下，更详细地了解一下测试Flask应用程序中的这对组合。
- en: In unit testing, the concepts of setup and teardown methods are pivotal techniques
    that are used to prepare and clean up the testing environment before and after
    the execution of each test case. Before delving into test cases, the setup procedure
    comes into play. The setup method is executed before each test case, and its purpose
    is to establish the required conditions for testing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，设置和清理方法的概念是准备和清理测试环境的关键技术，用于在每个测试用例执行前后。在深入测试用例之前，设置过程开始发挥作用。设置方法在每个测试用例之前执行，其目的是建立测试所需的条件。
- en: For instance, let’s consider a Flask unit test scenario; the setup method could
    be designed to mimic a Flask application instance and configure a testing client,
    thereby providing the necessary infrastructure to simulate HTTP requests and responses
    for testing purposes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑一个Flask单元测试场景；设置方法可以被设计成模拟Flask应用程序实例并配置测试客户端，从而为模拟HTTP请求和响应提供必要的测试基础设施。
- en: On the flip side, there is the teardown phase. The teardown procedure takes
    place post-execution of every test case and involves cleaning up resources that
    were initially established during the setup operation. Back to the Flask unit
    test illustration, the teardown method might be programmed to gracefully terminate
    the testing client and shut down the Flask application instance. This ensures
    that no lingering resources remain active that can disrupt subsequent tests.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，还有拆卸阶段。拆卸过程在每个测试用例执行后进行，涉及清理在设置操作期间最初建立的资源。回到Flask单元测试的例子，拆卸方法可能被编程为优雅地终止测试客户端并关闭Flask应用程序实例。这确保了没有残留的资源保持活跃，可能会干扰后续的测试。
- en: 'This duo of setup and teardown is typically located within the confines of
    a class encapsulating the suite of test cases. To understand it better, consider
    the following code snippet, which illustrates a class incorporating setup and
    teardown methods to validate a Flask application:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这对设置和拆卸通常位于封装测试用例套件的类的范围内。为了更好地理解，考虑以下代码片段，它展示了如何将设置和拆卸方法结合到一个类中，以验证Flask应用程序：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, the setup method creates a Flask application instance
    and a test client. On the other hand, the teardown method gracefully concludes
    the test client and disposes of the Flask application instance. The outcome is
    a neat and orderly closure of resources once a test concludes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，设置方法创建了一个Flask应用程序实例和一个测试客户端。另一方面，拆卸方法优雅地结束测试客户端并处理Flask应用程序实例。结果是，一旦测试结束，资源就得到了整洁有序的关闭。
- en: However, in pytest, the setup and teardown paradigms can be emulated using fixtures.
    Fixtures serve as functions designated to furnish shared resources to multiple
    test cases. Fixtures allow you to define and manage test dependencies. This is
    how fixtures work in pytest. You define a fixture with the `@pytest.fixture` decorator.
    This function can then be used as a parameter in test functions, which allows
    the test function to access the fixture’s data or environment.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在pytest中，可以使用固定装置来模拟设置和拆卸范式。固定装置充当为多个测试用例提供共享资源的函数。固定装置允许你定义和管理测试依赖项。这就是pytest中固定装置的工作方式。你使用`@pytest.fixture`装饰器定义一个固定装置。然后，这个函数可以作为测试函数的参数使用，允许测试函数访问固定装置的数据或环境。
- en: When a test function is run, pytest automatically detects any fixtures that
    are defined as parameters and runs those fixture functions first, passing their
    return values as arguments to the test function. This ensures that the test function
    has access to the data or environment it needs to run correctly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行测试函数时，pytest会自动检测任何定义为参数的固定装置，并首先运行这些固定装置函数，将它们的返回值作为参数传递给测试函数。这确保了测试函数可以访问它运行正确所需的数据或环境。
- en: 'The following code snippet showcases a fixture that can be used to produce
    a Flask application instance and a test client:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了可以用来生成Flask应用程序实例和测试客户端的固定装置：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code shows that the `app` fixture creates a Flask application
    instance and the client fixture creates a test client. These fixtures can then
    be used by test cases within the test suite to get access to the Flask application
    and the test client.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示，`app`固定装置创建了一个Flask应用程序实例，而`client`固定装置创建了一个测试客户端。这些固定装置然后可以在测试套件中的测试用例中使用，以获取对Flask应用程序和测试客户端的访问。
- en: It is noteworthy to say one clear advantage of adopting fixtures for setup and
    teardown is their potential for reusability. By using fixtures, the setup and
    teardown logic can be efficiently shared across multiple test cases. This will
    invariably ensure that the testing code is more maintainable, and by extension,
    enhance the reusability of test cases.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，采用固定装置进行设置和拆卸的一个明显优势是它们的可重用性。通过使用固定装置，设置和拆卸逻辑可以高效地在多个测试用例之间共享。这无疑将确保测试代码更加易于维护，并且通过扩展，提高测试用例的重用性。
- en: 'Fixtures in your tests can provide clear benefits, including the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 测试中的固定装置可以提供以下明确的好处：
- en: '**Reusability**: You can define a fixture once and use it in multiple tests.
    This can save time and reduce duplication.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：你可以定义一个fixture一次，并在多个测试中使用它。这可以节省时间并减少重复。'
- en: '**Readability**: By separating the setup code into a fixture function, your
    test functions can be more focused and easier to read.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性**：通过将设置代码分离到fixture函数中，你的测试函数可以更加专注且易于阅读。'
- en: '**Maintainability**: Fixtures ensure that your tests are consistent and repeatable,
    even as your code base evolves.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：Fixtures确保即使你的代码库在演变过程中，你的测试也是一致的和可重复的。'
- en: Fixtures in pytest provide a powerful and flexible mechanism for managing test
    dependencies and simplifying your testing workflow.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: pytest中的Fixtures提供了一个强大且灵活的机制来管理测试依赖关系并简化你的测试工作流程。
- en: Now, let’s delve into parameterizing in pytest. Using parameterized tests in
    pytest allows you to test your code more thoroughly with less code duplication.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨pytest中的参数化。使用pytest中的参数化测试可以让你用更少的代码重复来更彻底地测试你的代码。
- en: Parameterizing in pytest
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pytest中的参数化
- en: '**Parameterizing** tests in pytest is a feature that enables you to write a
    single test function that can be executed with different sets of input parameters.
    This is useful when you want to test a function or method with a variety of inputs
    or configurations.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在pytest中**参数化**测试是一个功能，它允许你编写一个可以执行不同输入参数集的单个测试函数。当你想用各种输入或配置测试一个函数或方法时，这非常有用。
- en: 'To parameterize a test function in pytest, you can use the `@pytest.mark.parametrize`
    decorator. This decorator takes two arguments: the name of the parameter and a
    list of values or tuples representing the different parameter sets to test.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要在pytest中参数化一个测试函数，你可以使用`@pytest.mark.parametrize`装饰器。这个装饰器接受两个参数：参数的名称和表示要测试的不同参数集的值或元组列表。
- en: 'Let’s explore a parameterized test function in pytest:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索pytest中的参数化测试函数：
- en: '[PRE8]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code is a demonstration of parameterized tests in pytest to test
    a function with multiple input values.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是pytest中参数化测试的演示，用于测试具有多个输入值的函数。
- en: The function being tested is `add(a, b)`, which takes two arguments, `a` and
    `b`, and returns their sum. The `@pytest.mark.parametrize` decorator is used to
    provide a list of input values and their corresponding expected results.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 被测试的函数是`add(a, b)`，它接受两个参数`a`和`b`，并返回它们的和。`@pytest.mark.parametrize`装饰器用于提供输入值列表及其对应的预期结果。
- en: 'The decorator takes three arguments:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器接受三个参数：
- en: A comma-separated string of parameter names – in this case, `"a,` `b, expected_result"`.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个以逗号分隔的参数名称字符串——在本例中为`"a, b, expected_result"`。
- en: 'A list of tuples representing the parameter sets and their expected results.
    In this example, we have four parameter sets: `(1, 2, 3)`, `(10, 20, 30)`, `(0,
    0, 0)`, and `(-1,` `1, 0)`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示参数集及其预期结果的元组列表。在本例中，我们有四个参数集：`(1, 2, 3)`、`(10, 20, 30)`、`(0, 0, 0)`和`(-1,
    1, 0)`。
- en: An optional `ids` argument, which provides custom names for the test cases.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`ids`参数，它为测试用例提供自定义名称。
- en: For each parameter set in the list, pytest will execute the `test_addition()`
    function with the corresponding `a`, `b`, and `expected_result` values. The `assert`
    statement in the test function checks that the actual result of `add(a, b)` matches
    the expected result.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表中的每个参数集，pytest将使用相应的`a`、`b`和`expected_result`值执行`test_addition()`函数。测试函数中的`assert`语句检查`add(a,
    b)`的实际结果是否与预期结果匹配。
- en: 'When the test function is executed, pytest will generate a separate report
    for each parameter set, so you can see exactly which cases passed and which ones
    failed:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试函数执行时，pytest将为每个参数集生成一个单独的报告，这样你可以确切地看到哪些案例通过了，哪些失败了：
- en: The first parameter set, `(1, 2, 3)`, tests whether the `add()` function correctly
    adds `1` and `2`, resulting in `3`
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数集`(1, 2, 3)`测试`add()`函数是否正确地将`1`和`2`相加，结果为`3`
- en: The second parameter set, `(10, 20, 30)`, tests whether `add()` correctly adds
    `10` and `20`, resulting in `30`
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数集`(10, 20, 30)`测试`add()`是否正确地将`10`和`20`相加，结果为`30`
- en: The third parameter set, `(0, 0, 0)`, tests whether `add()` correctly adds two
    zeros, resulting in `0`
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数集`(0, 0, 0)`测试`add()`是否正确地将两个零相加，结果为`0`
- en: The fourth parameter set, `(-1, 1, 0)`, tests whether `add()` correctly adds
    `-1` and `1`, resulting in `0`
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个参数集`(-1, 1, 0)`测试`add()`是否正确地将`-1`和`1`相加，结果为`0`
- en: Parameterizing tests can help you write more concise and effective test code
    by reducing the amount of duplication in your test functions and making it easier
    to test a wide range of inputs and configurations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化测试可以通过减少测试函数中的重复代码量以及更容易测试广泛的输入和配置，帮助你编写更简洁和有效的测试代码。
- en: And that’s not all in terms of pytest’s features. Next, we’ll explore mocking
    external dependencies in pytest.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是 pytest 功能的全部。接下来，我们将探索 pytest 中的外部依赖模拟。
- en: Mocking external dependencies in pytest
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pytest 中的外部依赖模拟
- en: '**Mocking external dependencies** is a testing technique that involves creating
    simulated versions of external dependencies, such as APIs or databases, to isolate
    your code under test from these dependencies. When you’re writing unit tests,
    you typically want to test only the code within the scope of the test, not any
    external services or libraries that it relies on.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟外部依赖**是一种测试技术，它涉及创建外部依赖的模拟版本，如 API 或数据库，以隔离你的测试代码从这些依赖中。当你编写单元测试时，你通常只想测试测试范围内的代码，而不是它所依赖的任何外部服务或库。'
- en: This practice helps you keep your tests focused and fast, as well as avoid false
    positives or false negatives that can result from relying on external dependencies
    that may not be available or may behave unpredictably.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法有助于保持你的测试集中且快速，同时避免由于依赖可能不可用或行为不可预测的外部依赖而产生的不正确或错误的测试结果。
- en: To create a mock object, you must use a mocking framework, such as `unittest.mock`
    or `pytest-mock`, to create a fake object that mimics the behavior of the real
    object. You can then use this mocked object in your tests instead of the real
    object, which allows you to test your code in a controlled environment.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个模拟对象，你必须使用一个模拟框架，例如 `unittest.mock` 或 `pytest-mock`，来创建一个模仿真实对象行为的假对象。然后，你可以使用这个模拟对象在你的测试中代替真实对象，这允许你在受控环境中测试你的代码。
- en: For instance, let’s say you are testing a function that retrieves data from
    an external API. You can use a mocking framework to create a mock object that
    mimics the behavior of the API, and then use this mocked object in your tests
    instead of making actual API calls. This allows you to test your function’s behavior
    in a controlled environment, without you having to worry about network connectivity
    or the behavior of the external API.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在测试一个从外部 API 获取数据的函数。你可以使用模拟框架来创建一个模仿 API 行为的模拟对象，然后在测试中使用这个模拟对象而不是实际调用
    API。这允许你在受控环境中测试你的函数行为，而不必担心网络连接或外部 API 的行为。
- en: Using a mocking strategy in your tests can also help you write more comprehensive
    tests as it allows you to simulate error conditions or edge cases that might be
    difficult or impossible to replicate with a real external dependency. For example,
    you can use a mocked object to simulate a network timeout or a database error,
    and then verify that your code under test handles these conditions correctly.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试中使用模拟策略可以帮助你编写更全面的测试，因为它允许你模拟错误条件或难以或无法通过真实外部依赖复制的边缘情况。例如，你可以使用模拟对象来模拟网络超时或数据库错误，然后验证你的测试代码是否正确处理了这些条件。
- en: Let’s say we have a `Speaker` class in our project that depends on an external
    `email_service` module to send email notifications to speakers. We want to write
    a test for the `Speaker` class that verifies that the `Speaker` class sends the
    expected email notifications when a new speaker is added. To achieve this, we
    can use the `pytest-mock` plugin to mock the `email_service` module and check
    that the expected calls are made.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在我们的项目中有一个 `Speaker` 类，它依赖于外部的 `email_service` 模块来向演讲者发送电子邮件通知。我们想要为 `Speaker`
    类编写一个测试，以验证当添加新演讲者时，`Speaker` 类会发送预期的电子邮件通知。为了实现这一点，我们可以使用 `pytest-mock` 插件来模拟
    `email_service` 模块并检查是否执行了预期的调用。
- en: Let’s dive into a code implementation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入到代码实现中。
- en: 'In the `bizza/backend/tests` directory, add the `test_speaker.py` file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `bizza/backend/tests` 目录下添加 `test_speaker.py` 文件：
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we created a mocked object for the `email_service.send_email`
    function using `mocker.patch`. Then, we created a new `Speaker` object and called
    the `Speaker` object’s `register()` method, which should trigger an email notification
    to be sent.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `mocker.patch` 为 `email_service.send_email` 函数创建了一个模拟对象。然后，我们创建了一个新的
    `Speaker` 对象并调用了 `Speaker` 对象的 `register()` 方法，这应该会触发发送电子邮件通知。
- en: Then, we used the `assert_called_once_with` method of the mocked object to check
    that the expected email was sent with the correct arguments. If the `send_email`
    function is called with different arguments, the test will fail.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用了模拟对象的`assert_called_once_with`方法来检查预期的电子邮件是否以正确的参数发送。如果`send_email`函数以不同的参数被调用，测试将失败。
- en: By using `pytest-mock` to mock the external dependency, we can isolate our test
    from any potential network issues or other dependencies of the `email_service`
    module. This makes our test more reliable and easier to maintain over time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`pytest-mock`来模拟外部依赖项，我们可以将我们的测试从任何潜在的网络问题或其他`email_service`模块的依赖项中隔离出来。这使得我们的测试更加可靠，并且随着时间的推移更容易维护。
- en: Mocking external dependencies is a powerful technique for isolating your code
    under test from external services or libraries, and for creating controlled environments
    that allow you to write comprehensive, reliable tests.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟外部依赖项是一种强大的技术，可以将测试代码从外部服务或库中隔离出来，并创建受控环境，允许你编写全面、可靠的测试。
- en: Writing unit tests
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: Writing tests with pytest involves creating test functions that verify the functionality
    of your code. These test functions are executed by pytest and can be organized
    into test modules and test packages. In addition to test functions, pytest provides
    other testing features such as fixtures, parameterization, and mocking, which
    can help you write more robust and efficient tests.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pytest编写测试涉及创建验证代码功能的测试函数。这些测试函数由pytest执行，可以组织成测试模块和测试包。除了测试函数之外，pytest还提供了其他测试功能，如
    fixtures、参数化和模拟，这些可以帮助你编写更健壮和高效的测试。
- en: In this section, we will cover the basics of writing tests with pytest, including
    creating test functions, using assertions to check for expected behavior, and
    organizing tests into test suites.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍使用pytest编写测试的基础知识，包括创建测试函数，使用断言来检查预期行为，以及将测试组织成测试套件。
- en: Now, let’s laser-focus on writing unit tests for a user registration component
    of an application.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们集中精力编写一个应用程序用户注册组件的单元测试。
- en: Unit-testing user registration
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试用户注册
- en: Unit testing is a crucial part of the software development process. Unit testing
    unarguably allows developers to verify that their code works correctly and reliably,
    as stated earlier. One area where unit testing is particularly important is user
    registration, which is a critical part of many applications.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是软件开发过程中的关键部分。正如之前所述，单元测试无疑允许开发者验证他们的代码是否正确且可靠地工作。单元测试特别重要的一个领域是用户注册，这是许多应用的一个关键部分。
- en: A user registration feature typically involves collecting user input, validating
    the input, storing it in a database, and sending a confirmation email to the user.
    Testing these features thoroughly is important to ensure that it works as intended
    and that users can register successfully and securely.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 用户注册功能通常涉及收集用户输入，验证输入，将其存储在数据库中，并向用户发送确认电子邮件。彻底测试这些功能对于确保其按预期工作以及用户可以成功且安全地注册非常重要。
- en: In this context, unit tests can be used to verify that the registration feature
    handles various scenarios correctly, such as valid and invalid inputs, duplicate
    usernames, and email confirmation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，单元测试可以用来验证注册功能是否正确处理各种场景，例如有效和无效的输入、重复的用户名和电子邮件确认。
- en: Let’s examine a unit test implementation for user registration.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一个用户注册的单元测试实现。
- en: User creation unit test
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户创建单元测试
- en: 'Let’s test that new users can be created and saved to the database. In the
    `tests` directory, create `test_user_login_creation.py`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试新用户是否可以被创建并保存到数据库中。在`tests`目录下创建`test_user_login_creation.py`：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding test snippet, we created a new user with a specific `username`,
    `password`, and `email address`. Then, we added the user to the database and commited
    the changes. Finally, we retrieved the user from the database using a query and
    asserted that the retrieved user matches the original user in all fields. This
    test ensures that new users can be successfully created and saved to the database.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试片段中，我们创建了一个具有特定`username`、`password`和`email address`的新用户。然后，我们将用户添加到数据库中并提交更改。最后，我们使用查询从数据库中检索用户，并断言检索到的用户在所有字段上与原始用户匹配。这个测试确保新用户可以成功创建并保存到数据库中。
- en: Input validation unit test
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入验证单元测试
- en: 'Let’s test that the registration form validates user input correctly and returns
    appropriate error messages for invalid input:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试注册表单是否正确验证用户输入并返回适当的错误消息：
- en: '[PRE11]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding test, we simulated attempts to register a new user with various
    invalid inputs, such as an invalid `username`, `email address`, or `password`
    properties that are too short. We sent `POST` requests to the `'/register'` endpoint
    with this invalid input data and asserted that the response status code was `200
    OK`, indicating that the registration form was submitted successfully, but with
    errors.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们模拟了使用各种无效输入尝试注册新用户的情况，例如无效的`username`、`email address`或`password`属性过短。我们使用无效输入数据向`'/register'`端点发送`POST`请求，并断言响应状态码为`200
    OK`，表示注册表单已成功提交，但存在错误。
- en: Then, we asserted that the appropriate error messages were displayed on the
    page for each invalid input. This test ensures that the registration form correctly
    validates the user input and returns appropriate error messages for invalid input.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们断言页面为每个无效输入显示了适当的错误消息。这个测试确保注册表单正确验证用户输入，并为无效输入返回适当的错误消息。
- en: Next, we will examine unit testing the `login` component.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查`login`组件的单元测试。
- en: Unit-testing user login
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试用户登录
- en: Unit testing user login involves testing the functionality of the code responsible
    for authenticating a user who attempts to log into an application. This typically
    involves verifying that user credentials are correct and that the appropriate
    response is returned based on whether the authentication was successful or not.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试用户登录涉及测试负责验证尝试登录应用程序的用户代码的功能。这通常涉及验证用户凭证是否正确，并根据认证是否成功返回适当的响应。
- en: Unit testing in this context can help ensure that the login process is reliable
    and secure, with appropriate error handling for invalid login attempts. Additionally,
    unit testing can help identify potential vulnerabilities in the login process,
    such as injection attacks or password-guessing attempts.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，单元测试可以帮助确保登录过程可靠且安全，对无效登录尝试进行适当的错误处理。此外，单元测试还可以帮助识别登录过程中的潜在漏洞，例如注入攻击或密码猜测尝试。
- en: User with valid credentials unit test
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有效凭证用户单元测试
- en: 'Let’s test that a user with valid credentials can successfully log in and access
    the application:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一个使用有效凭证的用户可以成功登录并访问应用程序：
- en: '[PRE12]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding test, we’re using the client fixture to simulate a user logging
    in by sending a `POST` request to the login endpoint with valid credentials. We’re
    also using the user fixture to create a test user with valid credentials. After
    sending the login request, we check that the response status code is `200 OK`
    and that the user is redirected to the home page, which indicates that the login
    was successful.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们使用客户端固定值模拟用户通过向登录端点发送带有有效凭证的`POST`请求来登录。我们还使用用户固定值创建一个具有有效凭证的测试用户。在发送登录请求后，我们检查响应状态码是否为`200
    OK`，以及用户是否被重定向到主页，这表明登录成功。
- en: User with invalid credentials unit test
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无效凭证用户单元测试
- en: 'Let’s test that a user with invalid credentials cannot log in and receives
    an appropriate error message:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一个使用无效凭证的用户无法登录，并收到适当的错误信息：
- en: '[PRE13]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding test, we are trying to log in with a username and password
    that are not valid, and we expect the server to respond with a `401 Unauthorized`
    status code and an error message indicating that the credentials were invalid.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们尝试使用无效的用户名和密码登录，并期望服务器响应`401 Unauthorized`状态码和指示凭证无效的错误消息。
- en: Testing SQL injection attacks
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试SQL注入攻击
- en: 'Let’s test that the code is properly validating user input to prevent SQL injection
    attacks:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试代码是否正确验证用户输入以防止SQL注入攻击：
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding test, we are attempting to use SQL injection attack code as
    the `username` input in the login form. The test checks that the response status
    code is `401 Unauthorized`, indicating that the attack was not successful, and
    the user was not logged in.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们尝试使用SQL注入攻击代码作为登录表单中的`username`输入。测试检查响应状态码是否为`401 Unauthorized`，这表明攻击未成功，用户未登录。
- en: It also checks that the `current_user.is_authenticated` attribute is `False`,
    confirming that the user is not authenticated. This test helps ensure that the
    code is properly validating user input to prevent SQL injection attacks.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 它还检查`current_user.is_authenticated`属性是否为`False`，确认用户未认证。这个测试有助于确保代码正确验证用户输入，以防止SQL注入攻击。
- en: Testing for password strength
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试密码强度
- en: 'Let’s test that the code is properly validating user passwords to ensure they
    meet the minimum complexity requirements (for example, a minimum length, the requirement
    of special characters, and so on):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试代码是否正确验证用户密码以确保它们满足最小复杂度要求（例如，最小长度、特殊字符的要求等）：
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding test, `check_password_strength()` is a function that takes
    a password string as input and returns `True` if it meets the minimum complexity
    requirements and `False` otherwise. This unit test verifies that the function
    works as expected by testing various scenarios.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，`check_password_strength()` 是一个接受密码字符串作为输入的函数，如果它满足最小复杂度要求则返回 `True`，否则返回
    `False`。这个单元测试通过测试各种场景来验证该函数按预期工作。
- en: With the use of a testing framework, Pytest, and writing effective unit tests,
    developers can catch bugs and defects early on, reducing the risk of errors in
    production and improving the overall quality and reliability of their code base.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用测试框架 Pytest 和编写有效的单元测试，开发者可以尽早捕捉到错误和缺陷，降低生产中的错误风险，并提高代码库的整体质量和可靠性。
- en: Note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding tests assumed that you have a Flask application set up with routes
    for user registration and login, as well as a `SQLAlchemy` database with a user
    model. We also assume that you have a test client configured with Pytest’s Flask
    test client fixture (client).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试假设你已经设置了一个 Flask 应用程序，其中包含用户注册和登录的路由，以及一个带有用户模型的 `SQLAlchemy` 数据库。我们还假设你已经配置了一个带有
    Pytest 的 Flask 测试客户端固定装置（client）的测试客户端。
- en: Next, we will look at testing JSON APIs to make sure that the API endpoints
    work as expected.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看测试 JSON API 以确保 API 端点按预期工作。
- en: Testing JSON APIs
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 JSON API
- en: Testing JSON APIs is an essential part of developing any web application that
    communicates with external clients. APIs provide a simple and flexible way to
    exchange data between the server and the client. APIs are critical to ensure that
    the APIs work as expected before they are exposed to external users.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 JSON API 是开发任何与外部客户端通信的 Web 应用程序的重要部分。API 提供了一种简单灵活的方式在服务器和客户端之间交换数据。在将 API
    暴露给外部用户之前，确保 API 按预期工作至关重要。
- en: Unit-testing JSON APIs involves verifying that the API endpoints return the
    expected results for different types of input data and handling error cases. Additionally,
    it’s essential to ensure that the API follows industry-standard protocols and
    is secure against common web vulnerabilities. In this way, developers can ensure
    the reliability and security of the web application and minimize the risk of errors
    or security breaches.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试 JSON API 涉及验证 API 端点对于不同类型的输入数据返回预期的结果，并处理错误情况。此外，确保 API 遵循行业标准协议并对常见 Web
    漏洞具有安全性也是至关重要的。这样，开发者可以确保 Web 应用程序的可靠性和安全性，并最大限度地减少错误或安全漏洞的风险。
- en: 'Let’s go through a test suite with four tests – `test_get_all_speakers`, `test_create_speaker`,
    `test_update_speaker`, and `test_delete_speaker`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个包含四个测试的测试套件来过一遍——`test_get_all_speakers`、`test_create_speaker`、`test_update_speaker`
    和 `test_delete_speaker`：
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding test, `test_get_all_speakers`, sends a `GET` request to the speakers
    API to retrieve all speakers and then checks that the response has a status code
    of `200 OK` and contains a JSON object with a list of speakers.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试，`test_get_all_speakers`，向演讲者 API 发送一个 `GET` 请求检索所有演讲者，然后检查响应状态码为 `200
    OK` 并包含一个包含演讲者列表的 JSON 对象。
- en: Testing speaker data creation
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试创建演讲者数据
- en: 'The following test, `test_create_speaker`, defines a speaker data object to
    be created, sends a `POST` request to the Speakers API to create a new speaker
    using this data, and then checks that the response has a status code of `201 CREATED`
    and contains a JSON object with the newly created speaker data:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试，`test_create_speaker`，定义了一个要创建的演讲者数据对象，向演讲者 API 发送一个 `POST` 请求使用这些数据创建一个新的演讲者，然后检查响应状态码为
    `201 CREATED` 并包含一个包含新创建的演讲者数据的 JSON 对象：
- en: '[PRE17]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Updating the speaker data object
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新演讲者数据对象
- en: 'The following test code, `test_update_speaker`, defines a speaker data object
    to be updated, sends a `PUT` request to the Speakers API to update the speaker
    with `id 1` using this data, and then checks that the response has a status code
    of `200` for a successful update:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试代码，`test_update_speaker`，定义了一个要更新的演讲者数据对象，向演讲者 API 发送一个 `PUT` 请求使用这些数据更新
    `id 1` 的演讲者，然后检查响应状态码为 `200` 表示更新成功：
- en: '[PRE18]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Testing the deletion of the speaker data object
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试删除演讲者数据对象
- en: 'The following code snippet sends a `DELETE` request to the Speakers API to
    delete the speaker with `ID 1`. The test function checks that the response has
    a status code of `204 NO CONTENT`. If the speaker with `ID 1` is successfully
    deleted from the API, the response from the API should have a status code of `204
    NO CONTENT`. If the speaker is not found or if there is an error in the delete
    request, the response status code will be different, and the test will fail:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段向Speakers API发送一个`DELETE`请求来删除`ID 1`的演讲者。测试函数检查响应的状态码为`204 NO CONTENT`。如果成功从API中删除了`ID
    1`的演讲者，API的响应应该有状态码`204 NO CONTENT`。如果找不到演讲者或删除请求中存在错误，响应状态码将不同，测试将失败：
- en: '[PRE19]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At this point, you might be wondering, why do we need to invest time and resources
    into rectifying bugs once they’ve emerged in our application when it’s entirely
    possible to proactively forestall their occurrence from the outset?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能想知道，为什么在我们应用程序中一旦出现错误，我们就需要投入时间和资源来纠正它们，而完全有可能从一开始就主动预防它们的发生？
- en: Next, we will discuss TDD using Flask as a significant proactive approach to
    software development!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论使用Flask作为软件开发的重要主动方法！
- en: Test-driven development with Flask
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发与Flask
- en: TDD is a software development approach where you write automated tests before
    writing the actual code. The process involves writing a test case for a specific
    feature or functionality and then writing the minimum amount of code necessary
    to make the test pass. Once the test passes, you write additional tests to cover
    different edge cases and functionality until you have fully implemented the desired
    feature.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是一种软件开发方法，你需要在编写实际代码之前编写自动化测试。这个过程包括为特定的功能或功能编写测试用例，然后编写必要的最少代码以使测试通过。一旦测试通过，你将编写额外的测试来覆盖不同的边缘情况和功能，直到你完全实现了所需的功能。
- en: 'Using Flask with an attendee endpoint as a case study, the TDD process might
    look like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以使用Flask的参与者端点作为案例研究，TDD过程可能看起来是这样的：
- en: '**Define the feature**: The first step is to define the feature you want to
    implement. In this case, the feature is an endpoint that allows users to view
    a list of attendees for an event.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义功能**：第一步是定义你想要实现的功能。在这种情况下，功能是一个允许用户查看活动参与者列表的端点。'
- en: '**Write a test case**: Next, you must write a test case that defines the expected
    behavior of the endpoint. For example, you might write a test that checks that
    the endpoint returns a JSON response with a list of attendees.'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写测试用例**：接下来，你必须编写一个测试用例来定义端点的预期行为。例如，你可能编写一个测试来检查端点返回包含参与者列表的JSON响应。'
- en: '**Run the test**: You then run the test, which will fail since you haven’t
    implemented the endpoint yet.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行测试**：然后你运行测试，由于你还没有实现端点，所以测试将失败。'
- en: '**Write the minimum amount of code**: You write the minimum amount of code
    necessary to make the test pass. In this case, you would write the code for the
    attendee endpoint.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写最少代码**：你编写必要的最少代码以使测试通过。在这种情况下，你会编写参与者端点的代码。'
- en: '**Run the test again**: Then, you must run the test again, which should now
    pass since you’ve implemented the endpoint.'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**再次运行测试**：然后，你必须再次运行测试，这次应该会通过，因为你已经实现了端点。'
- en: '`404` error if the event doesn’t exist.'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果活动不存在，将出现`404`错误。
- en: Now, let’s implement the attendee’s endpoint using the TDD approach, starting
    with a failed test case since we haven’t implemented the endpoint yet.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用TDD方法实现参与者端点，从编写失败的测试用例开始，因为我们还没有实现端点。
- en: Defining the feature
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义功能
- en: The first step is to define the feature you want to implement. In this case,
    the feature is an endpoint that allows users to view a list of attendees for an
    event.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是定义你想要实现的功能。在这种情况下，功能是一个允许用户查看活动参与者列表的端点。
- en: Writing a failed test case
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写失败的测试用例
- en: The next step is to write a test case that checks that the attendee endpoint
    returns the expected data. This test should fail initially since we haven’t implemented
    the endpoint yet.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是编写一个测试用例，检查参与者端点是否返回预期的数据。这个测试最初应该会失败，因为我们还没有实现端点。
- en: 'Create `test_attendees.py` inside the `tests` directory and add the following
    code to `bizza/backend/tests/test_attendees.py`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tests`目录内创建`test_attendees.py`，并将以下代码添加到`bizza/backend/tests/test_attendees.py`中：
- en: '[PRE20]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Implementing the minimal amount of code to pass the test
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现通过测试的最少代码
- en: 'Now, we can implement the attendee endpoint function to return the hardcoded
    data. This is the minimal amount of code necessary to make the test pass:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现参会者端点函数以返回硬编码的数据。这是使测试通过所需的最小代码量：
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Running the test and ensuring it passes
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试并确保其通过
- en: 'Run the test again to ensure that it now passes:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试以确保它现在可以通过：
- en: '[PRE22]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Refactoring the code
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码重构
- en: Now that we have a passing test, we can refactor the code to make it more maintainable,
    efficient, and readable. For example, we could replace the hardcoded data with
    data retrieved from a database or external API.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了通过测试，我们可以重构代码以提高其可维护性、效率和可读性。例如，我们可以用从数据库或外部API检索的数据替换硬编码的数据。
- en: Writing additional tests
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写额外的测试用例
- en: Finally, we can write additional test cases to ensure that the endpoint behaves
    correctly in different scenarios. For example, we might write tests to ensure
    that the endpoint handles invalid input correctly, or that it returns an empty
    list if no attendees are found for a given event.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以编写额外的测试用例以确保端点在不同场景下的行为正确。例如，我们可能会编写测试以确保端点正确处理无效输入，或者在没有找到给定活动的参会者时返回空列表。
- en: With the TDD process, you can ensure that your code is thoroughly tested and
    that you’ve implemented all the desired functionalities. This approach can help
    you catch bugs early in the development process and make it easier to maintain
    and refactor your code in the future.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TDD（测试驱动开发）流程，你可以确保你的代码经过彻底测试，并且你已经实现了所有期望的功能。这种方法可以帮助你在开发早期阶段捕捉到错误，并使未来维护和重构代码变得更加容易。
- en: So far, we have discussed TDD as a software development approach where tests
    are created before the actual code implementation. This approach encourages developers
    to write tests that define the expected behavior of their code and then write
    the code itself to make the tests pass. Next, we will delve into the realm of
    exception handling in a test suite in Flask.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了TDD作为一种软件开发方法，其中测试是在实际代码实现之前创建的。这种方法鼓励开发者编写定义代码预期行为的测试，然后编写代码本身以使测试通过。接下来，我们将深入探讨Flask测试套件中的异常处理。
- en: Handling exceptions
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常
- en: Handling exceptions with unit testing is a software development technique that
    involves testing how a piece of code handles different types of exceptions that
    may occur during runtime. Exceptions can be triggered by a variety of factors,
    such as invalid input, unexpected input, or issues with the environment in which
    the code is running.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单元测试处理异常是一种软件开发技术，它涉及测试代码在运行时可能遇到的不同类型的异常的处理方式。异常可能由各种因素触发，例如无效输入、意外输入或代码运行环境中的问题。
- en: Unit testing is the practice of writing small, automated tests to ensure that
    individual units of code are working as expected. When it comes to handling exceptions,
    unit tests can help ensure that the code responds appropriately to various error
    conditions. As a developer, you need to test that your code can handle exceptions
    gracefully. You can simulate these error conditions in a controlled environment
    so that you have more confidence in your code’s ability to handle exceptions that
    may occur.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是编写小型、自动化的测试以确保单个代码单元按预期工作的实践。在处理异常方面，单元测试可以帮助确保代码能够适当地响应各种错误条件。作为开发者，你需要测试你的代码能够优雅地处理异常。你可以在受控环境中模拟这些错误条件，以便你对代码处理可能发生的异常的能力更有信心。
- en: For instance, in the case of a Flask application with an `attendees` endpoint,
    you may want to test how the application handles requests for events with no attendees.
    By writing a unit test that sends a request to the endpoint with an event that
    has no attendees, we can ensure that the application returns the appropriate error
    response code and message, rather than crashing or providing an inaccurate response.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个具有`attendees`端点的Flask应用程序中，你可能想测试应用程序如何处理没有参会者的活动请求。通过编写一个单元测试，向端点发送一个没有参会者的活动的请求，我们可以确保应用程序返回适当的错误响应代码和消息，而不是崩溃或提供不准确响应。
- en: 'Let’s dive into a code implementation of how you can handle exceptions for
    attendees’ endpoints:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨如何处理参会者端点的异常的代码实现：
- en: '[PRE23]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding implementation, we’ve added a custom exception to the `Event`
    class called `Exception("No attendees found for event")`. In the `get_attendees`
    method, if there are no attendees, we raise this exception. In the Flask endpoint
    function, we wrap the `Event` instantiation and the `get_attendees` call in a
    `try/except` block.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的实现中，我们向`Event`类添加了一个自定义异常，名为`Exception("No attendees found for event")`。在`get_attendees`方法中，如果没有参与者，我们将抛出此异常。在Flask端点函数中，我们将`Event`实例化和`get_attendees`调用包裹在`try/except`块中。
- en: If an exception is raised, we return a JSON response with the error message
    and a `404` status code to indicate that the requested resource was not found.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出异常，我们将返回一个包含错误信息和`404`状态码的JSON响应，以指示请求的资源未找到。
- en: 'Let’s examine the test function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查测试函数：
- en: '[PRE24]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the first test function, `test_get_attendees_empty()`, we expect the endpoint
    to return a `404` status code and an error message JSON response because there
    are no attendees for the event. In the second test, `test_get_attendees()`, we
    add an attendee to the event and expect the endpoint to return a `200` status
    code and a JSON response containing the attendee’s name.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个测试函数`test_get_attendees_empty()`中，我们期望端点返回`404`状态码和错误信息JSON响应，因为没有参与者参加该活动。在第二个测试`test_get_attendees()`中，我们向活动添加一个参与者，并期望端点返回`200`状态码和包含参与者姓名的JSON响应。
- en: When you test for expected exceptions and handle them gracefully in your code,
    you can ensure that your application behaves as expected and provides helpful
    error messages to users when needed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在代码中对预期的异常进行测试并优雅地处理它们时，你可以确保你的应用程序按预期行为，并在需要时向用户提供有用的错误信息。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Unit testing, as a crucial aspect of Flask application development, ensures
    the reliability and functionality of application software. In this chapter, we
    learned how to structure and implement effective unit tests for various components
    of a Flask application. We explored how Pytest simplifies testing processes and
    enhances the productivity of developers.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试作为Flask应用程序开发的关键方面，确保了应用软件的可靠性和功能性。在本章中，我们学习了如何为Flask应用程序的各个组件构建和实施有效的单元测试。我们探讨了Pytest如何简化测试过程并提高开发者的生产力。
- en: This chapter covered the fundamentals of Pytest, including its introduction,
    setup process, basic syntax, and features. We discovered the importance of the
    setup and teardown methods, which help create a controlled testing environment
    and ensure the proper disposal of resources after each test case.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了Pytest的基础知识，包括其介绍、设置过程、基本语法和功能。我们发现了设置和清理方法的重要性，这些方法有助于创建受控的测试环境，并在每个测试用例之后确保资源的适当处置。
- en: By applying these techniques, we were able to create more robust and isolated
    unit tests that mirror real-world scenarios. Furthermore, we provided guidelines
    on how to write unit tests, test JSON APIs, apply TDD, and handle exceptions in
    Flask applications. With the adoption of these practices, developers can improve
    the overall quality of their Flask applications and minimize the risk of errors
    and bugs.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用这些技术，我们能够创建更健壮和隔离的单元测试，这些测试反映了现实世界的场景。此外，我们提供了如何编写单元测试、测试JSON API、应用TDD以及处理Flask应用程序中的异常的指南。通过采用这些实践，开发者可以提高其Flask应用程序的整体质量，并最大限度地减少错误和缺陷的风险。
- en: As we move forward and wrap up our journey of building robust and scalable Flask
    applications, the next chapter will dive into the world of containerization and
    deployment. We will explore how to containerize Flask applications, allowing us
    to replicate development environments and effortlessly deploy our applications
    to various platforms.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进并结束构建健壮且可扩展的Flask应用程序的旅程，下一章将深入探讨容器化和部署的世界。我们将探讨如何容器化Flask应用程序，使我们能够复制开发环境，并轻松地将我们的应用程序部署到各种平台。
- en: We will also delve into deploying Flask applications to cloud services, harnessing
    the power of platforms such as Docker and AWS for efficient and scalable deployment.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将深入研究将Flask应用程序部署到云服务，利用Docker和AWS等平台的力量进行高效和可扩展的部署。
