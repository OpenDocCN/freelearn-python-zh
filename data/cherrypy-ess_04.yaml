- en: Chapter 4. CherryPy in Depth
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。CherryPy 深入
- en: '[Chapter 3](ch03.html "Chapter 3. Overview of CherryPy") introduced the common
    aspects of CherryPy without going into too much detail. In this chapter, we will
    dive into what makes CherryPy such a powerful library for the web developer by
    explaining key features, such as how to run multiple HTTP servers, use additional
    URI dispatchers, use the built-in tools and develop new ones, serve static contents,
    and finally how CherryPy and WSGI interact. This chapter will be dense but will
    be a good base to allow you to be more at ease and efficient with the product.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 3 章](ch03.html "第 3 章。CherryPy 概述")介绍了 CherryPy 的常见方面，而没有过多深入细节。在本章中，我们将通过解释关键特性，如如何运行多个
    HTTP 服务器、使用额外的 URI 分派器、使用内置工具并开发新的工具、提供静态内容以及最后如何 CherryPy 和 WSGI 交互，深入探讨使 CherryPy
    成为网络开发者如此强大的库的原因。本章内容密集，但将为您提供一个良好的基础，让您在使用产品时更加轻松高效。'
- en: HTTP Compliance
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 兼容性
- en: 'CherryPy has been evolving slowly but surely to comply as much as it can with
    the HTTP specifications—firstly by supporting the old HTTP/1.0 and then moving
    gradually towards fully supporting HTTP/1.1, as defined in RFC 2616\. CherryPy
    is said to be conditionally compliant with HTTP/1.1 as it implements all the *must*
    and *required* levels but not all the *should* levels of the specification. Therefore,
    CherryPy supports the following features of HTTP/1.1:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: CherryPy 正在稳步发展，尽可能地遵守 HTTP 规范——首先支持旧的 HTTP/1.0，然后逐渐过渡到完全支持 RFC 2616 中定义的 HTTP/1.1。据说
    CherryPy 对 HTTP/1.1 的兼容性是有条件的，因为它实现了规范中的所有 *必须* 和 *要求* 级别，但没有实现所有 *应该* 级别。因此，CherryPy
    支持以下 HTTP/1.1 的特性：
- en: If a client claims to support HTTP/1.1, it must send a `Host` header field in
    any request made with that protocol version. If it is not done, CherryPy will
    immediately stop the request processing with a `400` error code message (section
    14.23 of RFC 2616).
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果客户端声称支持 HTTP/1.1，则必须在任何使用该协议版本的请求中发送 `Host` 头字段。如果没有这样做，CherryPy 将立即停止请求处理，并返回
    `400` 错误代码消息（RFC 2616 的第 14.23 节）。
- en: CherryPy generates a `Date` header field in all the configurations (section
    14.18 of RFC 2616).
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CherryPy 在所有配置中生成 `Date` 头字段（RFC 2616 的第 14.18 节）。
- en: CherryPy does handle the `Continue` response status code (`100`) on clients
    supporting it.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CherryPy 可以处理客户端支持的 `Continue` 响应状态码（`100`）。
- en: 'CherryPy''s built-in HTTP server supports persistent connections that are the
    default in HTTP/1.1, through the use of the `Connection: Keep-Alive` header. Be
    aware that changing the HTTP server (for more details refer to[Chapter 10](ch10.html
    "Chapter 10. Deployment")) may break this compatibility, if the chosen server
    does not support such a feature.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'CherryPy 内置的 HTTP 服务器支持 HTTP/1.1 中的默认持久连接，通过使用 `Connection: Keep-Alive` 头部。请注意，如果选择的
    HTTP 服务器不支持此功能，更改 HTTP 服务器（更多详情请参阅[第 10 章](ch10.html "第 10 章。部署"）可能会破坏这种兼容性。'
- en: CherryPy handles correctly chunked requests and responses.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CherryPy 正确处理分块请求和响应。
- en: CherryPy supports requests set with `If-Modified-Since` and `If-Unmodified-Since`
    headers and responds accordingly to each of them.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CherryPy 支持设置 `If-Modified-Since` 和 `If-Unmodified-Since` 头部的请求，并相应地响应每个请求。
- en: CherryPy allows any HTTP methods.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CherryPy 允许使用任何 HTTP 方法。
- en: CherryPy handles all the combinations of HTTP versions between the client and
    the setting set for the server.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CherryPy 处理客户端和服务器设置的 HTTP 版本之间的所有组合。
- en: '| Request Protocol | Server Protocol | Written Response Protocol | Response
    Feature Set |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 请求协议 | 服务器协议 | 编写的响应协议 | 响应功能集 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1.0 | 1.0 | 1.0 | 1.0 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 1.0 | 1.0 | 1.0 | 1.0 |'
- en: '| 1.0 | 1.1 | 1.1 | 1.0 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 1.0 | 1.1 | 1.1 | 1.0 |'
- en: '| 1.1 | 1.0 | 1.0 | 1.0 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 1.1 | 1.0 | 1.0 | 1.0 |'
- en: '| 1.1 | 1.1 | 1.1 | 1.1 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 1.1 | 1.1 | 1.1 | 1.1 |'
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The server protocol can be modified via the `server.protocol_version` key.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器协议可以通过 `server.protocol_version` 键进行修改。
- en: The written response protocol is the version returned in the HTTP response to
    inform the user-agent what protocol the server is supporting.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 编写的响应协议是 HTTP 响应中返回的版本，用于通知用户代理服务器支持哪种协议。
- en: The response feature set protocol version is the one used internally by CherryPy
    during the response processing. In the second case, CherryPy only limits what
    it does to the response to HTTP/1.0.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 响应功能集协议版本是 CherryPy 在响应处理过程中内部使用的版本。在第二种情况下，CherryPy 只限制对 HTTP/1.0 的响应。
- en: All in all CherryPy 3 offers a wide range of capabilities, thanks to its good
    support of HTTP/1.1, and therefore can be safely used in a large set of scenarios.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，CherryPy 3 提供了广泛的功能，这得益于其对 HTTP/1.1 的良好支持，因此可以在大量场景中安全使用。
- en: Multiple HTTP Servers
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个HTTP服务器
- en: 'By default, CherryPy starts a single instance of its own built-in HTTP server.
    However, it may happen that:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CherryPy启动其内置HTTP服务器的单个实例。然而，可能会发生以下情况：
- en: You are required to have a different HTTP server. This will be covered extensively
    in[Chapter 10](ch10.html "Chapter 10. Deployment").
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要有一个不同的HTTP服务器。这将在第10章（[Chapter 10](ch10.html "第10章。部署"））中详细说明。
- en: You are required to run your application on different network interfaces in
    one single Python process. CherryPy provides an API to run different HTTP server
    instances in one single process.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要在单个Python进程中运行您的应用程序在不同的网络接口上。CherryPy提供了一个API来在一个进程中运行不同的HTTP服务器实例。
- en: 'First let us see how the CherryPy server is usually started:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看CherryPy服务器通常是怎样启动的：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we call the `quickstart()` method of the server object, which
    will instantiate the built-in HTTP server and start it in its own thread.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们调用了服务器对象的 `quickstart()` 方法，这将实例化内置HTTP服务器并在其自己的线程中启动它。
- en: 'Now imagine we have one application that we wish to run on different network
    interfaces; we should do as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们有一个希望在多个网络接口上运行的应用程序；我们应该这样做：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, we first create two instances of the built-in HTTP server and
    for each we set the binding address on which the socket should be listening for
    incoming requests.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们首先创建了内置HTTP服务器的两个实例，并为每个实例设置了套接字应该监听传入请求的绑定地址。
- en: Then we attach those servers to the CherryPy pool of HTTP servers and call the
    `start()` method, which will start each one on its interface.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这些服务器附加到CherryPy的HTTP服务器池中，并调用 `start()` 方法，这将使每个服务器在其接口上启动。
- en: 'Notice that we do not call `cherrypy.config.update`, because it would update
    the global configuration settings shared by all the servers. However, this is
    not really an issue because each instance of the built-in server has the attributes
    matching the configuration keys. Thus:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们并没有调用 `cherrypy.config.update`，因为这将会更新所有服务器共享的全局配置设置。然而，这实际上并不是一个问题，因为内置服务器的每个实例都有与配置键匹配的属性。因此：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, you can directly set the server instance settings and avoid
    using the global configuration. This technique also allows for an application
    to be served via HTTP and HTTPS at the same time as we will see in[Chapter 10](ch10.html
    "Chapter 10. Deployment").
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可以直接设置服务器实例的设置，避免使用全局配置。这种技术还允许应用程序同时通过HTTP和HTTPS提供服务，正如我们将在第10章（[Chapter
    10](ch10.html "第10章。部署"））中看到的。
- en: Multi-Threaded Application Server
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程应用程序服务器
- en: CherryPy is designed around the threaded pattern. Although it is transparent
    to the developer, each time the application gets or sets a value into the CherryPy
    namespace, (`cherrypy.request` and `cherrypy.response` objects mainly) it does
    so in a multi-threaded environment. Both `cherrypy.request` and `cherrypy.response`
    are thread-data containers, which imply that your application calls them independently
    by knowing which request is proxied through them at run time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: CherryPy的设计基于线程模式。尽管这对开发者来说是透明的，但每次应用程序在CherryPy命名空间中获取或设置一个值（主要是 `cherrypy.request`
    和 `cherrypy.response` 对象）时，它都是在多线程环境中进行的。`cherrypy.request` 和 `cherrypy.response`
    都是线程数据容器，这意味着您的应用程序通过知道在运行时通过它们代理了哪个请求来独立调用它们。
- en: When using the built-in CherryPy server, a pool of threads is created to handle
    incoming requests. The size of the pool is configured via the `server.thread_pool`
    key, which defaults to `10`. Although it could sound like a good idea to create
    a larger pool of threads to improve the performance of the server, it is not always
    the case.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用内置的CherryPy服务器时，会创建一个线程池来处理传入的请求。线程池的大小通过 `server.thread_pool` 键进行配置，默认为
    `10`。虽然创建一个更大的线程池以提高服务器性能听起来是个好主意，但这并不总是如此。
- en: This value must be tuned as per application requirements. In fact if your application
    has a very short average request processing time, then it is likely that each
    thread will not be busy for a very long period of time. If you create a large
    pool of threads, it is more likely that most of them will just sit there, consuming
    your memory for very little benefit. It is therefore advisable to run performance
    testing against your application in different configurations in order to determine
    the best number of threads that should be created for your requirements.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值必须根据应用程序需求进行调整。事实上，如果你的应用程序的平均请求处理时间非常短，那么每个线程可能不会忙碌很长时间。如果你创建了一个大型的线程池，那么大多数线程可能只是在那里坐着，几乎没有带来任何好处，消耗你的内存。因此，建议在不同的配置下对你的应用程序进行性能测试，以确定应该为你的需求创建的最佳线程数。
- en: 'Application servers using the threaded pattern are not always highly regarded
    because the use of threads is seen as increasing the likelihood of problems due
    to synchronization requirements. Alternatives exist, such as:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程模式的程序服务器并不总是受到高度评价，因为线程的使用被视为增加了由于同步需求而导致问题的可能性。存在其他替代方案，例如：
- en: 'Multi-processes pattern: In this case, each request is handled by its own Python
    process. It is arguable that synchronization is easier but in some specific cases
    the performance and stability of the server can be better.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多进程模式：在这种情况下，每个请求由其自己的Python进程处理。虽然同步可能更容易，但在某些特定情况下，服务器的性能和稳定性可能更好。
- en: 'Asynchronous pattern: In this configuration, the operation of accepting new
    connections and sending back data to the client is done asynchronously from the
    request processing itself. This can be achieved, thanks to the capabilities of
    underlying operating systems allowing it. This technique has proven to be very
    efficient speed-wise. However, it requires a fairly different application development
    approach that can perturb some developers.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步模式：在这个配置中，接受新连接和向客户端发送数据的操作是相对于请求处理本身异步执行的。这可以通过底层操作系统的功能实现。这种技术在速度方面已被证明非常有效。然而，它需要一种相当不同的应用程序开发方法，可能会让一些开发者感到困扰。
- en: All in all, which solution is the best can be debated ad infinitum and such
    questions will never really be answered. In fact, each scenario requires a different
    approach.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，哪种解决方案最好可以无休止地争论，这样的问题永远不会真正得到解答。事实上，每种场景都需要不同的方法。
- en: URI Dispatching
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URI调度
- en: As we have seen in the[Chapter 3](ch03.html "Chapter 3. Overview of CherryPy"),
    by default CherryPy maps URIs to Python callables that have an `exposed` attribute
    set to `True`. Over time, it has appeared that the CherryPy community wants to
    be more flexible and that other dispatchers' solutions would be appreciated. That's
    why CherryPy 3 provides three other built-in dispatchers and offers a simple way
    to write and use your own dispatchers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第3章](ch03.html "第3章。CherryPy概述")中看到的，默认情况下，CherryPy将URI映射到具有`exposed`属性设置为`True`的Python可调用对象。随着时间的推移，CherryPy社区希望更加灵活，并且会欣赏其他调度器的解决方案。这就是为什么CherryPy
    3提供了另外三个内置调度器，并提供了编写和使用您自己的调度器的一种简单方法。
- en: One is set to allow applications to be developed per HTTP methods. (GET, POST,
    PUT, etc.)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一个是设置为允许按HTTP方法开发应用程序。（GET、POST、PUT等。）
- en: The second is based on a popular third-party package named Routes and developed
    by Ben Bangert from the original Ruby implementation for Ruby on Rails.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是基于一个流行的第三方包Routes，由Ben Bangert从Ruby on Rails的原始Ruby实现中开发而来。
- en: The third dispatcher is a Virtual Host one, which allows dispatching based on
    the domain requested rather than the URI path.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个调度器是一个虚拟主机调度器，它允许根据请求的域名而不是URI路径进行调度。
- en: HTTP Method Dispatcher
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP方法调度器
- en: 'In some applications, URIs are independent of the action to be performed by
    the server on the resource. For example, look at the following URI:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用中，URI与服务器在资源上执行的操作是独立的。例如，看看下面的URI：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, the URI contains the operation the client wishes to carry out.
    With the default CherryPy dispatcher this would map to something like:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，URI包含了客户端希望执行的操作。使用默认的CherryPy调度器，这会映射到类似以下的内容：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Although it''s fine, you may wish to remove that operation from the URI itself
    and make it more independent, so that it would look like:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做是可以的，但你可能希望从URI本身中移除该操作，使其更加独立，这样它看起来就会像：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You may wonder immediately how the server is supposed to know which operation
    to perform. This information is carried by the HTTP request itself, thanks to
    the HTTP method:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会立即想知道服务器应该如何知道要执行哪个操作。这个信息由HTTP请求本身携带，多亏了HTTP方法：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The page handler handling such a request would look like the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 处理此类请求的页面处理器看起来如下：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When using the HTTP method dispatcher, the page handler called would be `album.DELETE(12)`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用HTTP方法分配器时，被调用的页面处理器将是`album.DELETE(12)`。
- en: If you look at the previous class definition, you will see that the methods
    do not carry the `exposed` attribute but instead the class itself is set with
    that attribute. The reason for this comes from the way the dispatcher is implemented.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看之前的类定义，你会看到方法没有携带`exposed`属性，而是类本身设置了该属性。这个原因来自于分配器实现的方式。
- en: When a request reaches the server, CherryPy looks for the best matching page
    handler. When using the HTTP method dispatcher, the handler is in fact the conceptual
    representation of the resource targeted by the URI, in our example the instance
    of the `album` class. Then the dispatcher checks if the class has a method matching
    the name of the HTTP method used for the request. If so, the dispatcher calls
    it with the remaining parameters. Otherwise, it sends back immediately an HTTP
    error code `405 Method Not Allowed` to inform the client that it cannot use the
    HTTP method and thus cannot perform that operation on that particular resource.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个请求到达服务器时，CherryPy会寻找最佳匹配的页面处理器。当使用HTTP方法分配器时，处理器实际上是URI所指向的资源的概念性表示，在我们的例子中是`album`类的实例。然后分配器检查该类是否有与请求使用的HTTP方法名称匹配的方法。如果有，分配器会使用剩余的参数调用它。否则，它会立即发送HTTP错误代码`405
    方法不允许`来通知客户端它不能使用HTTP方法，因此不能在该特定资源上执行该操作。
- en: For example, if we did not have a definition for `DELETE` in the `Album` class,
    such an error code would be returned upon the request we have used so far.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们没有在`Album`类中对`DELETE`进行定义，那么在之前使用的请求中会返回这样的错误代码。
- en: In any case, however, CherryPy will automatically add the `Allow` HTTP header
    to the response to inform the client which methods it can use against the resource.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无论如何，CherryPy都会自动将`Allow` HTTP头添加到响应中，以通知客户端它可以对资源使用哪些方法。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that in this case CherryPy does not look for `index` or `default` page
    handlers as it would with the URI-to-object dispatcher. This comes from a fundamental
    difference between dispatching based on the URI solely as compared to the URI+HTPP
    method.[Chapter 6](ch06.html "Chapter 6. Web Services") will review this in more
    detail.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，CherryPy不会像使用URI到对象分配器那样寻找`index`或`default`页面处理器。这来自于仅基于URI分配与URI+HTTP方法分配之间的基本区别。[第6章](ch06.html
    "第6章 Web服务")将更详细地讨论这一点。
- en: To enable the HTTP method dispatcher, you must set the `request.dispatch` key
    to an instance of that dispatcher for the targeted path.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用HTTP方法分配器，你必须将`request.dispatch`键设置为针对目标路径的该分配器的实例。
- en: 'For example, if our whole application was built using that technique, we would
    use:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们整个应用程序都是使用那种技术构建的，我们会使用：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The HTTP method dispatcher is often used in applications following REST principles,
    as we will see in[Chapter 6.](ch06.html "Chapter 6. Web Services")
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP方法分配器通常用于遵循REST原则的应用程序中，我们将在[第6章](ch06.html "第6章 Web服务")中看到。
- en: Routes Dispatcher
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Routes分配器
- en: Whether in the URI-to-object or HTTP-method dispatcher, we have not explicitly
    declared the URI associated with a page handler; instead we have left the responsibility
    of finding the best correspondence to the CherryPy engine. Many developers prefer
    the explicit approach and decide how URIs should map to page handlers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是在URI到对象或HTTP方法分配器中，我们都没有明确声明与页面处理器关联的URI；相反，我们将找到最佳对应的责任留给了CherryPy引擎。许多开发者更喜欢明确的方法，并决定URI应该如何映射到页面处理器。
- en: Therefore, when using the Routes dispatcher you must connect a pattern that
    matches URIs and associates a specific page handler.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当使用Routes分配器时，你必须连接一个匹配URI并关联特定页面处理器的模式。
- en: 'Let''s review an example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个例子：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When using the Routes dispatcher handlers, you need not have an `exposed` attribute.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Routes分配器处理器时，你不需要有`exposed`属性。
- en: 'The `connect` method of the Routes dispatcher is defined as:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 路由分配器的`connect`方法定义为：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here are the parameters for the `connect` method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`connect`方法的参数：
- en: The `name` parameter is the unique name for the route to connect.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 参数是连接到路由的唯一名称。'
- en: The `route` is the pattern to match URIs.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route` 是匹配 URI 的模式。'
- en: The `controller` is the instance containing page handlers.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controller` 是包含页面处理程序的实例。'
- en: '`**kwargs` allows you to pass on extra valid parameters for a route.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**kwargs` 允许你为路由传递额外的有效参数。'
- en: Please refer to the official Routes documentation to understand how the package
    works.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅官方 Routes 文档以了解该包的工作方式。
- en: By default, the CherryPy Routes dispatcher does not pass on the `action` and
    `controller` values returned by the Routes mapper when matching a URI against
    any of the route. These are not necessarily useful in a CherryPy application.
    However, if you need them you can set the `fetch_result` parameter of the Routes
    dispatcher constructor to `True`. Then both values will be passed on to page handlers
    but in this case you will have to add `controller` and `action` parameters to
    all your page handlers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CherryPy 路由调度器不会将 Routes 映射返回的 `action` 和 `controller` 值传递给与任何路由匹配的 URI。这些在
    CherryPy 应用程序中不一定有用。然而，如果你需要它们，你可以将 Routes 调度器构造函数的 `fetch_result` 参数设置为 `True`。然后这两个值都将传递给页面处理程序，但在此情况下，你必须将
    `controller` 和 `action` 参数添加到所有页面处理程序中。
- en: Virtual Host Dispatcher
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟主机调度器
- en: 'It may happen that you need to host different web applications within one CherryPy
    server with each application serving one given domain name. CherryPy provides
    an easy way to do this, as in the following example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会发生这样的情况，你需要在单个 CherryPy 服务器内托管不同的网络应用程序，每个应用程序服务一个特定的域名。CherryPy 提供了一种简单的方法来实现这一点，如下面的示例所示：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, as you can see, we simply create a tree of applications. Next, we define
    the `hostmap` dictionary, which will inform the `VirtualHost` dispatcher how to
    serve a request based on its domain. Thus the requests coming from [www.mymusic.com](http://www.mymusic.com)
    will be served by the application mounted at the `/music` prefix. Next, we tell
    CherryPy that we will be using the `VirtualHost` dispatcher and we finally mount
    the site application and start the server as usual.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，正如你所看到的，我们只是创建了一个应用程序树。接下来，我们定义 `hostmap` 字典，它将通知 `VirtualHost` 调度器如何根据域名来服务请求。因此，来自
    [www.mymusic.com](http://www.mymusic.com) 的请求将由位于 `/music` 前缀的应用程序提供服务。接下来，我们告诉
    CherryPy 我们将使用 `VirtualHost` 调度器，我们最后像往常一样挂载网站应用程序并启动服务器。
- en: 'Note that this example will require that you edit your `hosts` file on your
    machine to add the following two domains:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此示例需要你编辑你机器上的 `hosts` 文件以添加以下两个域名：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It will automatically redirect requests to those domains to your local server
    instead of looking for them on the Internet. Once you have finished with this
    example, you ought to remove these lines from the `hosts` file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 它将自动将请求重定向到这些域名，而不是在互联网上查找它们。完成此示例后，你应该从 `hosts` 文件中删除这些行。
- en: Hook into CherryPy's Core Engine
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将钩子插入到 CherryPy 的核心引擎
- en: One of the most powerful aspects of CherryPy is how its core lets you modify
    its normal behavior with a very fine granularity. Indeed, CherryPy offers a mechanism
    called hooking to customize the core engine.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: CherryPy 最强大的方面之一是其核心如何以非常精细的粒度让你修改其正常行为。实际上，CherryPy 提供了一种称为钩子的机制来定制核心引擎。
- en: 'A **hook** is an entry point for Python callables to be applied at specific
    points during the request processing. CherryPy provides the following entry points:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**钩子**是 Python 可调用项在请求处理过程中的特定点应用的入口点。CherryPy 提供以下入口点：'
- en: '| Hook Point | Description |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 插入点 | 描述 |'
- en: '| --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `on_start_resource` | Called at the beginning of the process. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `on_start_resource` | 在进程开始时调用。 |'
- en: '| `before_request_body` | Called before CherryPy tries to read the request
    body. It allows a tool to inform CherryPy whether this action should be performed
    by setting the `process_request_body` attribute to `False` within the tool. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `before_request_body` | 在 CherryPy 尝试读取请求体之前调用。它允许一个工具通过在工具中将 `process_request_body`
    属性设置为 `False` 来通知 CherryPy 是否应该执行此操作。 |'
- en: '| `before_handler` | Called before the page handler is invoked. A tool could
    for instance set the handler to `None` to inform CherryPy that it should not process
    the page handler. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `before_handler` | 在页面处理程序被调用之前调用。例如，一个工具可以将处理程序设置为 `None` 来通知 CherryPy 它不应该处理页面处理程序。
    |'
- en: '| `before_finalize` | Called whether or not the page handler has been called
    and before CherryPy starts processing the response. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `before_finalize` | 无论页面处理程序是否被调用，在 CherryPy 开始处理响应之前调用。 |'
- en: '| `on_end_resource` | Called when the resource processing is terminated. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `on_end_resource` | 当资源处理结束时调用。|'
- en: '| `before_error_response after_error_response` | Called when an error is trapped
    by the CherryPy engine to allow the application to recover and decide what to
    do next. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `before_error_response after_error_response` | 当CherryPy引擎捕获到错误时调用，以便应用程序恢复并决定下一步操作。|'
- en: '| `on_end_request` | Called at the end of the overall processing, right after
    the link with the client has been closed. This allows you to free resources. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `on_end_request` | 在整体处理结束时调用，在客户端连接关闭后立即调用。这允许您释放资源。|'
- en: The following figure shows the global process followed by CherryPy when handling
    a request. The black lines and arrows show the normal flow while the gray ones
    indicate the path when an error occurs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了CherryPy在处理请求时遵循的全局流程。黑色线条和箭头表示正常流程，而灰色线条表示发生错误时的路径。
- en: '![Hook into CherryPy''s Core Engine](img/1848_04_01.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Hook into CherryPy''s Core Engine](img/1848_04_01.jpg)'
- en: 'Attaching a callback at one of these hook points is done via a call to:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些钩子点之一附加回调是通过调用以下内容完成的：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first parameter is the name of the hook point as shown in the previous table.
    The second parameter is the Python callable that will be applied. The third parameter
    indicates to CherryPy that even if another callback may fail during the processing
    of this hook point, CherryPy must run this callable. The last parameter must be
    a value between 0 and 100 to indicate the weight of each callback and provide
    a way to order them. Lower values will be run first.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是钩子点的名称，如前表所示。第二个参数是将被应用的Python可调用对象。第三个参数指示CherryPy，即使另一个回调在处理此钩子点时可能失败，CherryPy也必须运行此可调用对象。最后一个参数必须是一个介于0到100之间的值，以指示每个回调的权重并提供一种对它们进行排序的方法。较低的值将首先运行。
- en: The `failsafe` argument is quite helpful as it offers a way for an application
    to be flexible and recover from problems that may occur. Indeed some callbacks
    may fail without impacting the whole chain of the request processing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`failsafe` 参数非常有用，因为它为应用程序提供了一种灵活地恢复可能发生的问题的方法。确实，一些回调可能会失败，但不会影响请求处理链的整个流程。'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that you can obviously attach as many callbacks as required at a given
    hook point. Callbacks can be hooked on the fly while the application is running
    as well. However, the more callbacks you attach, the slower the processing of
    that hook point will become.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可以在给定的钩子点上附加所需的任何数量的回调。回调可以在应用程序运行时即时附加。然而，附加的回调越多，该钩子点的处理速度就会越慢。
- en: The hooking mechanism is fairly close to what used to be called filters in CherryPy
    2\. However, it was observed over time that they were too low level and were making
    users uncomfortable most of the time. That's why it is still rare for developers
    to use them directly as is. Instead they are applied through a higher-level interface
    named tools.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子机制相当接近CherryPy 2中曾经被称为过滤器的东西。然而，随着时间的推移，人们观察到它们过于底层，并且大多数时候让用户感到不舒服。这就是为什么开发者直接使用它们的频率仍然很低。相反，它们通过一个名为tools的更高层接口来应用。
- en: CherryPy Toolbox
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CherryPy工具箱
- en: The tool interface has been designed by Robert Brewer while refactoring CherryPy.
    The goal was to offer ready-to-employ tools achieving common tasks with a friendly
    and flexible API. Within CherryPy, built-in tools offer a single interface to
    call the CherryPy library that we have reviewed in[Chapter 3](ch03.html "Chapter 3. Overview
    of CherryPy") using the hooking mechanism.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 工具接口是由Robert Brewer在重构CherryPy时设计的。目标是提供一套现成的工具，通过友好且灵活的API实现常见任务。在CherryPy中，内置工具提供了一个单一接口，用于通过钩子机制调用我们在[第3章](ch03.html
    "第3章。CherryPy概述")中审查的CherryPy库。
- en: 'As we have seen in[Chapter 3](ch03.html "Chapter 3. Overview of CherryPy")
    tools can be used in three different ways:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第3章](ch03.html "第3章。CherryPy概述")中看到的，工具可以以三种不同的方式使用：
- en: From the configuration settings
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从配置设置
- en: As a Python decorator or via the special `_cp_config` attribute of a page handler
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Python装饰器或通过页面处理器的特殊`_cp_config`属性
- en: As a Python callable that can be applied from within any function
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为可以在任何函数内部应用的Python可调用对象
- en: Thanks to this flexibility, a tool can be set either globally to a path and
    its subset or to a particular page handler. Let's now review the built-in tools
    provided by CherryPy.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种灵活性，工具可以设置为全局路径及其子集，或者设置为特定的页面处理器。现在让我们回顾CherryPy提供的内置工具。
- en: Basic Authentication Tool
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本身份验证工具
- en: '**Purpose:** The purpose of this tool is to provide basic authentication (RFC
    2617) to your application.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**目的：** 此工具的目的是为您的应用程序提供基本认证（RFC 2617）。'
- en: '**Arguments:**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数：**'
- en: '| Name | Default | Description |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 默认 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `realm` | N/A ( N/A in this case means the parameter must be provided by
    the developer as it has no default.) | String defining the realm value. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `realm` | N/A (在此情况下，N/A 表示参数必须由开发者提供，因为它没有默认值。) | 定义领域值的字符串。 |'
- en: '| `users` | N/A | Dictionary of the form username:password or a Python callable
    returning such a dictionary. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `users` | N/A | 形式为username:password的字典或返回此类字典的Python可调用对象。 |'
- en: '| `encrypt` | None | Python callable used to encrypt the password returned
    by the client and compare it with the encrypted password provided in the users
    dictionary. If None it uses an MD5 hash. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `encrypt` | None | 用于加密客户端返回的密码并与用户字典中提供的加密密码进行比较的Python可调用对象。如果为None，则使用MD5散列。
    |'
- en: '**Example:**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `get_users` function returns a hard-coded dictionary but it could also fetch
    the values from a database or anywhere else. Keep in mind that the basic authentication
    scheme is not really secure as the password is only encoded and can be decoded
    on the fly if someone captures it. This scheme is, however, often used over SSL
    because it is the easiest to put in place while the Secure Socket Layer encrypts
    the enclosed data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_users`函数返回一个硬编码的字典，但它也可以从数据库或其他地方获取值。请注意，基本认证方案实际上并不安全，因为密码只是编码的，如果有人捕获它，可以即时解码。然而，由于安全套接字层加密了包含的数据，这种方案通常在SSL上使用，因为它是最容易实施的。'
- en: Caching Tool
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存工具
- en: '**Purpose:** The purpose of this tool is to provide basic in-memory caching
    of CherryPy generated content.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**目的：** 此工具的目的是提供CherryPy生成内容的内存缓存。'
- en: '**Arguments:**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数：**'
- en: '| Name | Default | Description |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 默认 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `invalid_methods` | ("POST", "PUT", "DELETE") | Tuples of strings of HTTP
    methods not to be cached. These methods will also invalidate (delete) any cached
    copy of the resource. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `invalid_methods` | ("POST", "PUT", "DELETE") | 不应缓存的HTTP方法字符串元组。这些方法还将使任何缓存的资源副本失效（删除）。
    |'
- en: '| `cache_class` | MemoryCache | Class object to be used for caching. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `cache_class` | MemoryCache | 用于缓存的类对象。 |'
- en: A comprehensive example would be out of the scope of this book but if you are
    interested in this tool you should first look at the CherryPy test suite as well
    as visit the CherryPy users' mailing-list.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个全面的示例超出了本书的范围，但如果您对这个工具感兴趣，您应该首先查看CherryPy测试套件，并访问CherryPy用户邮件列表。
- en: Decoding Tool
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解码工具
- en: '**Purpose:** The purpose of this tool is to decode the incoming request parameters.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**目的：** 此工具的目的是解码传入的请求参数。'
- en: '**Arguments:**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数：**'
- en: '| Name | Default | Description |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 默认 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `encoding` | None | What encoding is to be used to decode the incoming content?
    If None it looks for the `Content-Type` header and if it cannot find a suitable
    charset it uses `default_encoding`. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `encoding` | None | 应使用什么编码来解码传入的内容？如果为None，则查找`Content-Type`头，如果找不到合适的字符集，则使用`default_encoding`。
    |'
- en: '| `default_encoding` | "UTF-8" | Default encoding to be used when none is provided
    or found. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `default_encoding` | "UTF-8" | 默认编码，当未提供或找到时将使用此编码。 |'
- en: '**Example:**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this case when the HTML form is sent to the server, CherryPy tries to decode
    the incoming data using the encoding we have set. If you look at the type of the
    `name` parameter you will see that when using the decoding tool it is *Unicode*
    whereas without the tool it is a *string*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，当HTML表单发送到服务器时，CherryPy会尝试使用我们设置的编码来解码传入的数据。如果您查看`name`参数的类型，您会看到当使用解码工具时它是*Unicode*，而没有工具时它是一个*字符串*。
- en: Digest Authentication Tool
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要认证工具
- en: '**Purpose:** The purpose of this tool is to provide digest authentication as
    defined in RFC 2617.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**目的：** 此工具的目的是提供RFC 2617中定义的摘要认证。'
- en: '**Arguments:**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数：**'
- en: '| Name | Default | Description |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 默认 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `realm` | N/A | String defining the realm value. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `realm` | N/A | 定义领域值的字符串。 |'
- en: '| `users` | N/A | Dictionary of the form—username:password or a Python callable
    returning such a dictionary. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `users` | N/A | 形式为—username:password的字典或返回此类字典的Python可调用对象。 |'
- en: '**Example:**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that the digest tool does not provide a way to pass an encrypted password.
    The reason for this is that the digest scheme is defined not to send the password
    across the wire as clear text. The way it works is as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，摘要工具不提供传递加密密码的方法。这是因为摘要方案定义了不将密码以明文形式发送到网络上。它的工作方式如下：
- en: 1\. The client requests to access the resource. The server returns a `401` error
    code indicating it uses the digest scheme. The server provides a token for this
    exchange.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 客户端请求访问资源。服务器返回`401`错误代码，表示它使用摘要方案。服务器为此交换提供令牌。
- en: 2\. The client creates a new message based on the token, the username, and the
    password and generates a hash via the MD5 algorithm.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 客户端根据令牌、用户名和密码创建一条新消息，并通过MD5算法生成哈希值。
- en: 3\. Upon receiving the new message from the client, the server tries to generate
    the same values. If they all match, the authentication is allowed.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 当服务器收到来自客户端的新消息时，它尝试生成相同的值。如果它们都匹配，则允许认证。
- en: As you can see, the password never transits as clear text on the wire. Discussions
    have taken place to decide how the digest tool can be evolved in order to avoid
    the need to store passwords as clear text. One way would be to store one of the
    intermediate steps of the digest token (step 1) and compare this value with what
    has been sent by the client. This is beyond the scope of this book but you can
    get more information from the CherryPy mailing lists.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，密码永远不会以明文形式在网络上传输。已经进行了讨论，以决定如何使摘要工具进化，以避免需要以明文形式存储密码。一种方法是将摘要令牌的中间步骤之一（步骤1）存储起来，并将此值与客户端发送的值进行比较。这超出了本书的范围，但你可以在CherryPy邮件列表中获取更多信息。
- en: Encode Tool
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码工具
- en: '**Purpose:** The purpose of this tool is to encode the response content in
    a defined encoding.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**目的：** 此工具的目的是以定义的编码编码响应内容。'
- en: '**Arguments:**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数：**'
- en: '| Name | Default | Description |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 默认值 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `encoding` | None | What encoding is to be used to encode the response? If
    None, it looks for the `Content-Type` header and sets a suitable charset if it
    can. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `encoding` | None | 要使用什么编码来编码响应？如果为None，它将查找`Content-Type`头，并在可能的情况下设置合适的字符集。
    |'
- en: '| `errors` | "strict" | Defines how the tool must react when it fails to encode
    a character. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `errors` | "strict" | 定义工具在无法编码字符时必须如何反应。 |'
- en: '**Example:**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Error Redirect Tool
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误重定向工具
- en: '**Purpose:** The purpose of this tool is to modify the default CherryPy error
    handler.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**目的：** 此工具的目的是修改CherryPy默认错误处理器。'
- en: '**Arguments:**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数：**'
- en: '| Name | Default | Description |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 默认值 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `url` | '''' | The URL to which it should be redirected. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `url` | '''' | 应重定向到的URL。 |'
- en: '| `internal` | `True` | When `True`, the redirection is hidden from the client
    and happens only within the context of this request. If `False`, CherryPy informs
    the client that a redirection should be issued by the client itself to the URL
    provided. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `internal` | `True` | 当`True`时，重定向对客户端是隐藏的，并且仅在请求的上下文中发生。如果`False`，CherryPy会通知客户端客户端应自行向提供的URL发出重定向。
    |'
- en: Etag Tool
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Etag工具
- en: '**Purpose:** The purpose of this tool is to validate an **Entity Tag** (**Etag**)
    sent by a user agent and generate the response accordingly as defined by RFC 2616
    section 14.24\. Etags are one of the ways to cache HTTP responses and thus diminish
    the burden on any parties involved.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**目的：** 此工具的目的是验证用户代理发送的**实体标签（Etag**），并根据RFC 2616第14.24节定义生成相应的响应。Etags是缓存HTTP响应并减轻任何相关方负担的一种方式。'
- en: '**Argument:**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数：**'
- en: '| Name | Default | Description |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 默认值 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `autotags` | False | When `True` the tool will generate an `etag` value based
    on the response body set. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `autotags` | False | 当`True`时，工具将根据响应体设置生成一个`etag`值。 |'
- en: '**Example:**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: '[PRE18]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the previous example, we set the `etags` tool for the whole application.
    On the first request to the `index` page handler, the tool will generate an `etag`
    value and insert it in the response headers. On the next request to that URI,
    the client will include the last received `etag`. The tool will compare it with
    the current one and if they match the response will be `304 Not Modified` informing
    the client that it can safely use its copy of the resource.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们为整个应用程序设置了`etags`工具。在第一次请求`index`页面处理器时，该工具将生成一个`etag`值并将其插入到响应头中。在下一次请求该URI时，客户端将包含最后接收到的`etag`。工具将比较它们，如果它们匹配，则响应将为`304
    Not Modified`，通知客户端它可以安全地使用其资源副本。
- en: Note that if you need the `etag` value to be computed in a different fashion,
    the best way is to set the `autotags` parameter to `False`, the default, and then
    from within your page handler add the `Etag` header yourself to the response headers.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您需要以不同的方式计算`etag`值，最佳做法是将`autotags`参数设置为`False`，这是默认值，然后从您的页面处理器中自行添加`Etag`头到响应头中。
- en: Gzip Tool
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gzip 工具
- en: '**Purpose:** The purpose of this tool is to perform content encoding on the
    response body.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**目的：** 此工具的目的是对响应体进行内容编码。'
- en: '**Arguments:**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数：**'
- en: '| Name | Default | Description |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 默认值 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `compress_level` | `10` | Level of compression to be achieved. The lower
    it is, the faster it will be. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `compress_level` | `10` | 要达到的压缩级别。越低，速度越快。 |'
- en: '| `mime_types` | `[''text/html'', ''text/plain'']` | List of MIME types that
    can be compressed. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `mime_types` | `[''text/html'', ''text/plain'']` | 可以压缩的MIME类型列表。 |'
- en: '**Example:**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: '[PRE19]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that the `gzip` tool should not be used when the response is streamed via
    its `stream` attribute. Indeed in this case CherryPy starts sending the body as
    soon as it has something to send, for instance when the page handler yields the
    content, instead of returning it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当响应通过其`stream`属性流式传输时不应使用`gzip`工具。实际上，在这种情况下，CherryPy在有任何内容要发送时就开始发送主体，例如页面处理器产生内容时，而不是返回它。
- en: Ignore Headers Tool
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 忽略头工具
- en: '**Purpose:** The purpose of this tool is to remove the specified headers from
    the HTTP request before they are processed by CherryPy.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**目的：** 此工具的目的是在CherryPy处理之前从HTTP请求中删除指定的头。'
- en: '**Argument:**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数：**'
- en: '| Name | Default | Description |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 默认值 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ignore_headers` | `headers=(''Range'',)` | Tuple of header names to be disregarded.
    |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `ignore_headers` | `headers=(''Range'',)` | 要忽略的头名称元组。 |'
- en: '**Example:**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: '[PRE20]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you access [http://localhost:8080/](http://localhost:8080/), you will get
    the following message whether or not the client has indeed set that header:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您访问[http://localhost:8080/](http://localhost:8080/)，无论客户端是否确实设置了该头，您都将得到以下信息：
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you navigate to [http://localhost:8080/other](http://localhost:8080/other)
    you will get the following message:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您导航到[http://localhost:8080/other](http://localhost:8080/other)，您将得到以下信息：
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Log Headers Tool
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志头工具
- en: '**Purpose:** The purpose of this tool is to dump request headers into the error
    log file when an error occurs on the server. This tool is disabled by default.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**目的：** 此工具的目的是在服务器上发生错误时将请求头输出到错误日志文件。此工具默认禁用。'
- en: '**Argument:** None'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数：** 无'
- en: '**Example:**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When you access [http://localhost:8080](http://localhost:8080), the error will
    be raised and the error log will show the request headers. Note that in this case
    this tool is set at the web-server level via the `cherrypy.config.update()` method
    but it can be applied on a per path basis as well.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当您访问[http://localhost:8080](http://localhost:8080)时，将引发错误，错误日志将显示请求头。请注意，在这种情况下，此工具是通过`cherrypy.config.update()`方法在Web服务器级别设置的，但它也可以按路径级别应用。
- en: Log Tracebacks Tool
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志堆栈跟踪工具
- en: '**Purpose:** The purpose of this tool is to dump the error''s traceback into
    the error log file when an exception is raised. This tool is enabled by default.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**目的：** 此工具的目的是在发生异常时将错误的堆栈跟踪输出到错误日志文件。此工具默认启用。'
- en: '**Argument:** None'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数：** 无'
- en: '**Example:**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Proxy Tool
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理工具
- en: '**Purpose:** The purpose of this tool is to change the base URL of the requests.
    This is especially helpful when running the application behind another server
    such as Apache.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**目的：** 此工具的目的是更改请求的基本URL。当在Apache等服务器后面运行应用程序时，这特别有用。'
- en: '**Arguments:**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数：**'
- en: '| Name | Default | Description |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 默认值 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `base` | None | If set and `local` is none, this will be the new base URL
    available from `cherrypy.request.base`. |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `base` | None | 如果设置且`local`为空，这将是从`cherrypy.request.base`可用的新的基本URL。 |'
- en: '| `local` | ''X-Forwarded-Host'' | Which header to look at for the local hosts
    set for instance by the front-end web server. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `local` | ''X-Forwarded-Host'' | 查找本地主机设置的头部，例如前端Web服务器设置的。 |'
- en: '| `remote` | ''X-Forwarded-For'' | Header to look for the IP address of the
    originating client. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `remote` | ''X-Forwarded-For'' | 查找原始客户端IP地址的头部。 |'
- en: '| `scheme` | ''X-Forwarded-Proto'' | Header to look for the original scheme
    used: *http* or *https* for instance. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `scheme` | ''X-Forwarded-Proto'' | 查找原始方案使用的头部：例如*http*或*https*。 |'
- en: When the base is not set, the tool will build the new base URI from the values
    fetched from the request headers based on the other parameters.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当未设置基本URL时，该工具将从请求头部获取的值构建新的基本URI，基于其他参数。
- en: '**Example:**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: '[PRE25]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When navigating to [http://localhost:8080](http://localhost:8080) you will
    see the following message:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当导航到[http://localhost:8080](http://localhost:8080)时，你会看到以下消息：
- en: '[PRE26]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you navigate to [http://localhost:8080/other](http://localhost:8080/other),
    you will be redirected to [http://someapp.net/blog/](http://someapp.net/blog/),
    which shows that the proxy tools ensure in a transparent manner that the CherryPy
    library stays coherent in behavior in accordance with the settings you provide.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导航到[http://localhost:8080/other](http://localhost:8080/other)，你将被重定向到[http://someapp.net/blog/](http://someapp.net/blog/)，这表明代理工具以透明的方式确保CherryPy库的行为与您提供的设置保持一致。
- en: For more examples on using this tool behind another server please see[Chapter
    10](ch10.html "Chapter 10. Deployment").
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在此工具后面使用另一个服务器使用示例，请参阅[第10章](ch10.html "第10章。部署")。
- en: Referer Tool
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Referer工具
- en: '**Purpose:** The purpose of this tool is to allow the filtering of requests
    based on a pattern. Requests can be rejected or accepted after matching the pattern.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**目的：** 此工具的目的是允许根据模式过滤请求。在匹配模式后，可以拒绝或接受请求。'
- en: '**Arguments:**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数：**'
- en: '| Name | Default | Description |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 默认值 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `pattern` | N/A | Regular expression pattern. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `pattern` | N/A | 正则表达式模式。 |'
- en: '| `accept` | True | If `True` any matching referer will allow the request to
    proceed. Otherwise, any matching referer will cause the request to be rejected.
    |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `accept` | True | 如果为`True`，任何匹配的引用将允许请求继续。否则，任何匹配的引用将导致请求被拒绝。 |'
- en: '| `accept_missing` | False | Whether requests with no referer can be allowed
    or not. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `accept_missing` | False | 是否允许没有引用的请求。 |'
- en: '| `error` | 403 | HTTP error code to be returned to the user agent upon refusal.
    |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `error` | 403 | 拒绝时返回给用户的HTTP错误代码。 |'
- en: '| `message` | ''Forbidden Referer header.'' | Message to be returned to the
    user agent upon refusal. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `message` | ''Forbidden Referer header.'' | 拒绝时返回给用户的消息。 |'
- en: '**Example:**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: '[PRE27]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, we will reject all requests coming from the `dodgy.com` domain
    and sub-domains.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将拒绝所有来自`dodgy.com`域名及其子域的请求。
- en: Response Headers Tool
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应头部工具
- en: '**Purpose:** The purpose of this tool is to allow some common headers to be
    set for all or many page handlers at once.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**目的：** 此工具的目的是允许一次性为所有或许多页面处理器设置一些常见的头部信息。'
- en: '**Argument:**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数：**'
- en: '| Name | Default | Description |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 默认值 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `headers` | None | List of tuples: header, value |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `headers` | None | 列表：元组（头部，值） |'
- en: '**Example:**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, the tool sets `Content-Type` to `text/plain` for all page handlers.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，该工具为所有页面处理器设置`Content-Type`为`text/plain`。
- en: Trailing Slash Tool
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾部斜杠工具
- en: '**Purpose:** The purpose of this tool is to provide a flexible way to deal
    with the trailing slash of requests. This tool is enabled by default.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**目的：** 此工具的目的是提供一种灵活的方式来处理请求的尾部斜杠。此工具默认启用。'
- en: '**Arguments:**'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数：**'
- en: '| Name | Default | Description |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 默认值 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `missing` | True | If the page handler is the index, if the `missing` parameter
    is `True`, and if the request missed a trailing slash, CherryPy will automatically
    issue a redirection towards the URI with the additional slash at the end. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `missing` | True | 如果页面处理器是索引，如果`missing`参数为`True`，并且请求遗漏了尾部斜杠，CherryPy将自动向带有尾部斜杠的URI发出重定向。
    |'
- en: '| `extra` | False | If the page handler is not the index, if the `extra` parameter
    is set to `True`, and if the URI has a trailing slash, CherryPy will issue a redirection
    towards the URI without the trailing slash. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `extra` | False | 如果页面处理器不是索引，如果 `extra` 参数设置为 `True`，并且 URI 有尾部斜杠，CherryPy
    将向没有尾部斜杠的 URI 发出重定向。|'
- en: '**Example:**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: '[PRE29]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To understand this tool, navigate to the following URLs:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这个工具，请导航到以下 URL：
- en: '[http://localhost:8080](http://localhost:8080)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://localhost:8080](http://localhost:8080)'
- en: '[http://localhost:8080/nothing](http://localhost:8080/nothing)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://localhost:8080/nothing](http://localhost:8080/nothing)'
- en: '[http://localhost:8080/nothing/](http://localhost:8080/nothing/)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://localhost:8080/nothing/](http://localhost:8080/nothing/)'
- en: '[http://localhost:8080/extra/](http://localhost:8080/extra/)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://localhost:8080/extra/](http://localhost:8080/extra/)'
- en: XML-RPC Tool
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML-RPC 工具
- en: '**Purpose:** The purpose of this tool is to transform CherryPy into an XML-RPC
    server and make page handlers XML-RPC callables.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**目的：** 这个工具的目的是将 CherryPy 转换为 XML-RPC 服务器，并使页面处理器成为 XML-RPC 可调用对象。'
- en: '**Argument:** None'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数：** 无'
- en: '**Example:**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: '[PRE30]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `XMLRPCController` is a helper class that should be used instead of the
    XML-RPC tool directly.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLRPCController` 是一个辅助类，应该用来代替直接使用 XML-RPC 工具。'
- en: 'You can then test your XML-RPC handler as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下方式测试你的 XML-RPC 处理器：
- en: '[PRE31]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Toolbox
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具箱
- en: 'CherryPy tools must belong to a toolbox that is to be managed by the CherryPy
    engine. Toolboxes have their own namespace to avoid name collision. Although nothing
    prevents you from using the default toolbox you can create one of your own as
    follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: CherryPy 工具必须属于一个由 CherryPy 引擎管理的工具箱。工具箱有自己的命名空间，以避免名称冲突。尽管没有阻止你使用默认的工具箱，但你也可以创建自己的工具箱，如下所示：
- en: '[PRE32]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Creating a Tool
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个工具
- en: 'Now that we have reviewed the toolbox shipped with CherryPy, we will explain
    how to write a tool. Before deciding to create a tool you should ask yourself
    a few questions such as:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经审查了 CherryPy 一起提供的工具箱，我们将解释如何编写一个工具。在决定创建一个工具之前，你应该问自己一些问题，例如：
- en: Should the added feature be handled at the CherryPy level?
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该在 CherryPy 级别处理添加的功能吗？
- en: At which level of the request processing should this be applied?
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在请求处理的哪个级别应该应用这个功能？
- en: Will you modify CherryPy's default behavior?
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否会修改 CherryPy 的默认行为？
- en: These questions simply allow you to make sure that the feature you want to add
    is at the right level. Tools can sometimes look like a pattern on their own, upon
    which you can design your application.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题只是确保你想要添加的功能处于正确的级别。工具有时看起来像是一个模式，你可以在此基础上设计你的应用程序。
- en: We will create a tool that will read and parse XML contained in a request body
    into a page handler parameter. To do so, we will be using the ElementTree library.
    (ElementTree is maintained by Fredrik Lundh and Amara by Uche Ogbuji.)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个工具，该工具将读取并解析请求体中包含的 XML，并将其解析为页面处理器参数。为此，我们将使用 ElementTree 库。（ElementTree
    由 Fredrik Lundh 维护，Amara 由 Uche Ogbuji 维护。）
- en: A tool is created either by sub-classing the `Tool` class or via an instance
    of that class as shown in the following example. Instantiating the `Tool` class
    is the most common case to consider and it is the one we will be discussing.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 工具可以通过继承 `Tool` 类或通过该类的实例来创建，如下面的示例所示。实例化 `Tool` 类是最常见的情况，也是我们将要讨论的情况。
- en: 'The class constructor declaration is as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造函数声明如下：
- en: '[PRE33]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `point` parameter is a string indicating to which hook point this tool should
    be attached.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`point` 参数是一个字符串，指示此工具应附加到哪个钩点。'
- en: The `callable` parameter is a Python callable that will be applied.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callable` 参数是一个 Python 可调用对象，将被应用。'
- en: The `name` parameter defines what the name of the tool will be within the toolbox.
    When it is not provided, it uses the name of the attribute holding the instance
    of the tool within the toolbox (refer to our example).
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 参数定义了工具在工具箱中的名称。如果没有提供，它将使用在工具箱中持有工具实例的属性的名称（参考我们的示例）。'
- en: The `priority` sets the order of the tools when several tools are attached at
    the same hook point.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`priority` 设置了当多个工具附加到相同的钩点时，工具的顺序。'
- en: 'Once an instance of the tool is created, you can attach it to the built-in
    toolbox as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了工具的实例，你可以按照以下方式将其附加到内置工具箱：
- en: '[PRE34]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This tool will be available like any other built-in tools to your application.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具将像任何其他内置工具一样，对您的应用程序可用。
- en: 'When creating a tool, you can provide two attributes to your callable that
    will be used when initializing the tool. They are as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建工具时，你可以为你的可调用对象提供两个属性，这些属性将在初始化工具时使用。它们如下所示：
- en: '`failsafe:` If `True`, it means the tool will run even when an error is raised
    before the tool''s turn. It defaults to `False`.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failsafe:` 如果`True`，则表示即使在工具轮到之前发生错误，工具也会运行。默认为`False`。'
- en: '`priority:` Relative order of this tool in regards to others at the same hook
    point. It defaults to `50`.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`priority:` 此工具相对于同一钩点上的其他工具的相对顺序。默认为`50`。'
- en: 'Thus you could write:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以这样写：
- en: '[PRE35]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: CherryPy provides a shortcut for tools that will be applied at the `before_handler`
    hook point, in other words just before the page handler is called. This should
    be one of the most common cases for non-built-in tools.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: CherryPy为将在`before_handler`钩点处应用的工具提供了一个快捷方式，换句话说，就是在页面处理器被调用之前。这应该是非内置工具最常见的用例之一。
- en: '[PRE36]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is equivalent to the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于以下内容：
- en: '[PRE37]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `HandlerTool` class provides one additional feature as it allows your callable
    to be applied as a page handler itself through the `handler(*args, **kwargs)`
    method of the `HandlerTool` class. Thus:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandlerTool`类提供了一个额外的功能，它允许你的可调用对象通过`HandlerTool`类的`handler(*args, **kwargs)`方法本身作为一个页面处理器应用。因此：'
- en: '[PRE38]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This can be useful to provide the same handler in different areas of your application
    without duplicating code.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在不重复代码的情况下，为应用程序的不同区域提供相同的处理器。
- en: 'Let''s now see a more elaborate example:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个更详细的示例：
- en: '[PRE39]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order to test the tool, you will need ElementTree or Amara or both. You can
    install both via the `easy_install` command.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个工具，你需要ElementTree或Amara，或者两者都需要。你可以通过`easy_install`命令安装它们。
- en: Our XML tool will read the HTTP body content and parse it via the specified
    XML toolkit. Then it will inject back the parsed document into the request parameters
    so that the new document instance is passed on to the page handler as a regular
    parameter.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的XML工具将读取HTTP正文内容，并通过指定的XML工具包进行解析。然后，它将解析的文档注入到请求参数中，以便新的文档实例作为常规参数传递给页面处理器。
- en: 'Launch the previous example and then run in a Python interpreter:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 启动前面的示例，然后在Python解释器中运行：
- en: '[PRE40]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see the tool interface provided by CherryPy 3 is powerful, flexible,
    and yet quite intuitive and easy to reuse. However, always be careful to ponder
    over your requirements before using tools. They should be used for low-level operations
    that fit into the HTTP request/response model.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，CherryPy 3提供的工具界面功能强大、灵活，同时非常直观且易于重用。然而，在使用工具之前，始终要仔细思考你的需求。它们应该用于适合HTTP请求/响应模型的底层操作。
- en: Static Resource Serving
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态资源服务
- en: CherryPy provides two simple tools to serve either a single file or an entire
    directory. In either case CherryPy takes care of the HTTP caching aspect of your
    static resource by automatically checking the presence of the `If-Modified-Since`
    and `If-Unmodified-Since` headers in the request and returning directly the `304
    Not Modified` response, if that's the case.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: CherryPy提供了两个简单的工具来服务单个文件或整个目录。在任一情况下，CherryPy都会通过自动检查请求中的`If-Modified-Since`和`If-Unmodified-Since`头来处理你的静态资源的HTTP缓存方面，如果存在，则直接返回`304
    Not Modified`响应。
- en: Using the Staticfile Tool to Serve a Single File
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Staticfile工具服务单个文件
- en: The `staticfile` tool can be used to serve a single file.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`staticfile`工具可以用来服务单个文件。'
- en: '**Arguments:**'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数：**'
- en: '| Name | Default | Description |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 默认值 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `filename` | N/A | Absolute or relative path to the physical file. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| `filename` | N/A | 物理文件的绝对或相对路径。 |'
- en: '| `root` | None | If filename is relative you must provide the root directory
    of the file. |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| `root` | None | 如果文件名是相对的，你必须提供文件的根目录。 |'
- en: '| `match` | "" | Regular expression to check that the URI path matches a certain
    pattern. |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `match` | "" | 用于检查URI路径是否匹配特定模式的正则表达式。 |'
- en: '| `content_types` | None | Dictionary of the form `ext: mime type`. |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| `content_types` | None | 形如`ext: mime type`的字典。 |'
- en: '**Example:**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: 'For this purpose let''s imagine we have the following directory layout:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，让我们假设我们有以下目录结构：
- en: '[PRE41]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`design1.css` is set as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`design1.css`设置如下：'
- en: '[PRE42]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `myapp.py` module will be defined like this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`myapp.py`模块将定义如下：'
- en: '[PRE43]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Several points must be taken into consideration:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 必须考虑以下几点：
- en: The root directory can be set globally for the entire application so that you
    don't have to define it for each URI path.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根目录可以全局设置整个应用程序，这样你就不必为每个URI路径定义它。
- en: When using the `staticfile` tool the URI and the physical resource need not
    have the same name. In fact they can be entirely unrelated in their naming as
    in the previous example.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 `staticfile` 工具时，URI 和物理资源不需要有相同的名称。实际上，它们在命名上可以完全不相关，就像前面的示例一样。
- en: 'Note also that even though the application is mounted on the `/my` prefix,
    meaning that requests to the CSS file will be `/my/css/style.css` (note that this
    is the case because the path provided in the `href` attribute of the link element
    is relative and not absolute: it does not start with a `/)`, our configuration
    settings do not include the prefix. As we have seen in Chapter 3, this is because
    the configuration settings are independent from where the application is mounted.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，尽管应用程序挂载在 `/my` 前缀上，这意味着对 CSS 文件的请求将是 `/my/css/style.css`（注意这是这种情况，因为链接元素中提供的路径是在
    `href` 属性中的相对路径，而不是绝对路径：它不以 `/` 开头），我们的配置设置不包括该前缀。正如我们在第 3 章中看到的，这是因为配置设置与应用程序挂载的位置无关。
- en: Using the Staticdir Tool to Serve a Complete Directory
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Using the Staticdir Tool to Serve a Complete Directory
- en: The `staticdir` tool can be used to serve a complete directory.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`staticdir` 工具可以用来服务一个完整的目录。'
- en: '**Arguments:**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数：**'
- en: '| Name | Default | Description |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| Name | Default | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `dir` | N/A | Absolute or relative path to the physical directory. |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `dir` | N/A | 物理目录的绝对或相对路径。|'
- en: '| `root` | None | If `dir` is relative you must provide the root directory
    of the file. |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `root` | None | 如果 `dir` 是相对路径，你必须提供文件的根目录。|'
- en: '| `match` | "" | Regular expression pattern to match files. |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `match` | "" | 匹配文件的正则表达式模式。|'
- en: '| `content_types` | None | Dictionary of the form ext: mime type. |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `content_types` | None | 形式为 ext: mime type 的字典。|'
- en: '| `index` | "" | If the URI is not directed at a file but at a directory, you
    can specify the name of the physical index file to be served. |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `index` | "" | 如果 URI 指向的不是文件而是目录，你可以指定要服务的物理索引文件名。|'
- en: '**Example:**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: Consider the new directory layout.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑新的目录布局。
- en: '[PRE44]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Handling that structure via the static directory tool would be similar to:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 通过静态目录工具处理该结构将类似于：
- en: '[PRE45]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this example, you will note that the URI paths for the CSS and the JavaScript
    files match exactly their physical counterparts. Also take a close look at how
    we define the appropriate `Content-Type` for the resource based on the file extension.
    This is useful when CherryPy cannot determine the proper MIME type to be used
    on its own. Finally, see how we mix the static directory tool with the `gzip`
    one so that our static content is compressed before being served.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你会注意到 CSS 和 JavaScript 文件的 URI 路径与其物理对应物完全匹配。同时仔细看看我们是如何根据文件扩展名定义资源的适当
    `Content-Type` 的。当 CherryPy 无法自行确定要使用的正确 MIME 类型时，这很有用。最后，看看我们是如何将静态目录工具与 `gzip`
    工具混合使用，以便在服务之前压缩我们的静态内容。
- en: Note
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may find it limitating that CherryPy requires absolute paths to work with
    the different static tools. But consider the fact that CherryPy cannot control
    how an application will be deployed and where it will live. Therefore, it is up
    to the deployers to provide that information. Remember, however, that the absolute
    path can be provided via the `root` attribute or directly within the `filename`
    or `dir` ones.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得 CherryPy 需要绝对路径来与不同的静态工具一起工作有些限制。但考虑到 CherryPy 无法控制应用程序的部署方式和它将驻留的位置。因此，提供这些信息的责任在于部署者。然而，请记住，绝对路径可以通过
    `root` 属性或直接在 `filename` 或 `dir` 中提供。
- en: Bypassing Static Tools to Serve Static Content
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bypassing Static Tools to Serve Static Content
- en: 'Sometimes you may want to reuse CherryPy''s internal functionalities for serving
    content but without using the static tools directly. This is possible by calling
    the `serve_file` function from your page handler. This function is actually the
    one called by the built-in tools as well. Consider the following example:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能想重用 CherryPy 的内部功能来服务内容，但又不直接使用静态工具。这可以通过从你的页面处理程序中调用 `serve_file` 函数来实现。实际上，这个函数也是由内置工具调用的。考虑以下示例：
- en: '[PRE46]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here we define a feed page handler that, when called, will check what is the
    preferred representation of the feed of the user-agent—it maybe RSS or Atom.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个页面处理程序，当被调用时，将检查用户代理首选的源内容表示形式——可能是 RSS 或 Atom。
- en: WSGI Support
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WSGI 支持
- en: '**Web Server Gateway Interface** (**WSGI**) is defined in a **Python Enhancement
    Proposal** (**PEP-333**) written by Phillip J. Eby to provide a loosely-coupled
    bridge between the web server and web applications.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web服务器网关接口**（**WSGI**）由Phillip J. Eby编写的**Python增强提案**（**PEP-333**）定义，旨在在Web服务器和Web应用程序之间提供一个松散耦合的桥梁。'
- en: 'WSGI defines the following three components:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI定义了以下三个组件：
- en: Server or gateway
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器或网关
- en: Middleware
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件
- en: Application or framework
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序或框架
- en: 'The following figure shows WSGI along with its layers:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了WSGI及其层：
- en: '![WSGI Support](img/1848_04_02.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![WSGI支持](img/1848_04_02.jpg)'
- en: The goal of WSGI is to allow components to be plugged and played at will, with
    the minimum API overhead possible. This allows code reuse of common functionalities
    such as session, authentication, URL dispatching, logging, etc. In fact, because
    the API is minimal and unobtrusive, frameworks or libraries supporting the WSGI
    specification will be able to handle these components.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI的目标是允许组件能够以尽可能少的API开销随意插入和运行。这允许代码重用常见的功能，如会话、身份验证、URL分发、记录等。事实上，由于API最小化和不干扰，支持WSGI规范的框架或库将能够处理这些组件。
- en: Until CherryPy 3.0, the support of WSGI within CherryPy was not welcome due
    to the internal design of CherryPy and also the belief that WSGI would not necessarily
    make the product a better one. When Robert Brewer undertook the refactoring of
    the project, he improved the WSGI support based on the work achieved by Christian
    Wyglendowski to the point of making it a first class citizen within CherryPy and
    therefore fulfilling expectations from the community.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 直到CherryPy 3.0，由于CherryPy的内部设计和认为WSGI不一定能提高产品的质量，CherryPy对WSGI的支持并不受欢迎。当Robert
    Brewer承担项目的重构工作时，他基于Christian Wyglendowski所做的工作改进了WSGI支持，使其成为CherryPy中的第一公民，并因此满足了社区的需求。
- en: Note
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that CherryPy tools and WSGI middlewares are different by design but not
    by capability. They aim at providing the same functionalities in a distinct way.
    CherryPy tools are mainly meaningful within CherryPy and are therefore optimized
    in that context. CherryPy tools and WSGI middlewares can coexist in a single application.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，CherryPy工具和WSGI中间件在设计上不同，但在功能上没有区别。它们旨在以不同的方式提供相同的功能。CherryPy工具主要在CherryPy中有意义，因此在该环境中进行了优化。CherryPy工具和WSGI中间件可以在单个应用程序中共存。
- en: '**Hosting a WSGI Application within the CherryPy WSGI Server**'
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**在CherryPy WSGI服务器中托管WSGI应用程序**'
- en: 'Let''s see an example on how to use CherryPy in a WSGI environment:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在WSGI环境中使用CherryPy的例子：
- en: '[PRE47]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s explain what we have done:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下我们做了什么：
- en: 1\. First we create a WSGI application respecting the WSGI specification, hence
    a Python callable respecting the WSGI application signature. The `environ` parameter
    contains values to be propagated orthogonally across the processing from the server
    to the application. Middlewares can alter this dictionary by adding new values
    or transforming existing values. The `start_response` parameter is a Python callable
    provided by the outer layer (a middleware or ultimately the WSGI server) to perform
    the response processing. Our WSGI application then returns an iterable, which
    will be consumed by the outer layers.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 首先，我们创建一个遵守WSGI规范的WSGI应用程序，因此是一个遵守WSGI应用程序签名的Python可调用对象。`environ`参数包含从服务器到应用程序处理过程中正交传播的值。中间件可以通过添加新值或转换现有值来修改此字典。`start_response`参数是由外部层（一个中间件或最终是WSGI服务器）提供的Python可调用对象，用于执行响应处理。然后，我们的WSGI应用程序返回一个可迭代对象，它将被外部层消费。
- en: 2\. Then, we encapsulate the application into a middleware provided by the paste
    package. Paste is a suite of common WSGI middlewares created and maintained by
    Ian Bicking. In our example, we use the `TransLogger` middleware to enable logging
    of incoming requests. WSGI defines middlewares to act like a server for encapsulated
    WSGI applications and as an application for the hosting WSGI server.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 然后，我们将应用程序封装到paste包提供的中间件中。Paste是由Ian Bicking创建和维护的一套常见的WSGI中间件。在我们的例子中，我们使用`TransLogger`中间件来启用对传入请求的记录。WSGI定义了中间件，使其能够像服务器一样封装WSGI应用程序，并作为托管WSGI服务器的应用程序。
- en: 3\. Finally, we graft the WSGI application into the CherryPy tree through the
    `cherrypy.tree.graft()` method and we start the CherryPy server and engine.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 最后，我们通过`cherrypy.tree.graft()`方法将WSGI应用程序嫁接到CherryPy树中，并启动CherryPy服务器和引擎。
- en: 'As the built-in CherryPy server is a WSGI server, it can handle the WSGI application
    without any trouble. Bear in mind, however, that many aspects of CherryPy such
    as tools and configuration settings will not be applied to the hosted WSGI application.
    You will need to use middlewares to perform operations such as the `paste.transLogger`.
    Alternatively, you can use the `wsgiapp` tool as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内置的CherryPy服务器是一个WSGI服务器，它可以无障碍地处理WSGI应用程序。然而，请注意，CherryPy的许多方面，如工具和配置设置，将不会应用于托管WSGI应用程序。你需要使用中间件来执行如`paste.transLogger`之类的操作。或者，你可以像以下这样使用`wsgiapp`工具：
- en: '[PRE48]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this example, we wrap the WSGI application using the `wsgiapp` tool. Notice
    that we can apply tools on the WSGI application as if it was a regular page handler.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`wsgiapp`工具封装WSGI应用程序。请注意，我们可以像对待常规页面处理器一样对WSGI应用程序应用工具。
- en: '**Hosting a CherryPy WSGI Application within a Third-Party WSGI Server**'
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**在第三方WSGI服务器中托管CherryPy WSGI应用程序**'
- en: In this example, we will write a CherryPy application as we traditionally do
    and host it in a WSGI server different from the built-in one. Indeed, we will
    be using the default WSGI server provided by the `wsgiref` package.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将像传统那样编写CherryPy应用程序，并在一个不同于内置的WSGI服务器中托管它。实际上，我们将使用`wsgiref`包提供的默认WSGI服务器。
- en: Note
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `wsgiref` package is a set of WSGI helpers that has become part of the Python
    standard library as of Python 2.5\. Otherwise, you can get it via `easy_install
    wsgiref`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`wsgiref`包是一组WSGI辅助工具，自Python 2.5起已成为Python标准库的一部分。否则，你可以通过`easy_install wsgiref`来获取它。'
- en: '[PRE49]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s explain this example:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释这个例子：
- en: 1\. First we create a regular CherryPy application. Note how we can still safely
    use CherryPy tools in this context.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 首先，我们创建一个常规的CherryPy应用程序。注意我们在这个上下文中仍然可以安全地使用CherryPy工具。
- en: 2\. Then we make a WSGI application from it through the `cherrypy.Application`
    helper. This returns a WSGI-valid callable made of the CherryPy application.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 然后，我们通过`cherrypy.Application`辅助工具从它创建一个WSGI应用程序。这返回一个由CherryPy应用程序组成的WSGI有效的可调用对象。
- en: 3\. Next we start the CherryPy engine in a non-blocking mode as we still need
    CherryPy to handle the request and dispatch to the correct page handler.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 接下来，我们以非阻塞模式启动CherryPy引擎，因为我们仍然需要CherryPy来处理请求并将请求调度到正确的页面处理器。
- en: 4\. Then we create a WSGI server instance hosting our WSGI application, which
    is encapsulated in the gzip middleware, which compresses the response body. This
    middleware is provided by the `flup` package, which is another WSGI set of middlewares.
    (Flup is maintained by Allan Saddi.)
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 然后，我们创建一个WSGI服务器实例，托管我们的WSGI应用程序，该应用程序被gzip中间件封装，该中间件压缩响应体。这个中间件由`flup`包提供，它是另一个WSGI中间件集。
    (Flup由Allan Saddi维护。)
- en: To conclude, the level of support for WSGI within CherryPy 3 is excellent, while
    being flexible enough so that you can use the best of both designs when need be.
    CherryPy can be seen as a comprehensive and coherent WSGI implementation. Moreover,
    CherryPy has the most comprehensive and fastest WSGI server currently available
    and you have no reason to believe you should drop the library if you want WSGI
    support. You can get more information about WSGI at [http://wsgi.org](http://wsgi.org).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，CherryPy 3对WSGI的支持水平非常出色，同时足够灵活，以便在需要时你可以使用两种设计中的最佳方案。CherryPy可以被视为一个全面且一致的WSGI实现。此外，CherryPy拥有目前最全面和最快的WSGI服务器，如果你需要WSGI支持，没有理由相信你应该放弃这个库。你可以在[http://wsgi.org](http://wsgi.org)获取更多关于WSGI的信息。
- en: Summary
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have reviewed key points of the CherryPy library, which
    will hopefully open your mind on how to make the most of its capabilities. While
    being a small package CherryPy offers an extended and yet coherent set of features
    all geared towards making your life easier. Some aspects of CherryPy have been
    left out, however, as they go beyond the scope of this book and the best place
    to gather more detailed information is by visiting the user and developer public
    mailing lists.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了CherryPy库的关键点，希望这能打开你的思路，了解如何充分利用其功能。虽然CherryPy是一个小型的包，但它提供了一套扩展且一致的特性集，旨在使你的生活更轻松。然而，CherryPy的一些方面超出了本书的范围，获取更详细信息的最佳方式是访问用户和开发者公开邮件列表。
- en: Now that you have acquired a good background with the library, we will move
    on to using it by developing a simple photoblog application.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对库有了良好的背景知识，我们将继续通过开发一个简单的照片博客应用程序来使用它。
