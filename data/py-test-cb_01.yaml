- en: Using Unittest to Develop Basic Tests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Unittest开发基本测试
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Asserting the basics
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言基础知识
- en: Setting up and tearing down a test harness
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和拆卸测试工具
- en: Running test cases from the command line
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行运行测试用例
- en: Running a subset of test case methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行一部分测试用例方法
- en: Chaining together a suite of tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接一系列测试
- en: Defining test suites inside the test module
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试模块内定义测试套件
- en: Retooling old test code to run inside unittest
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新调整旧的测试代码以在unittest中运行
- en: Breaking down obscure tests into simple ones
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将复杂的测试分解为简单的测试
- en: Testing the edges
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试边缘
- en: Testing corner cases by iteration
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过迭代测试角落情况
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Testing has always been a part of software development. However, the world was
    introduced to a new concept called **automated testing** when Kent Beck and Erich
    Gamma introduced JUnit for Java development ([http://junit.org](http://junit.org)).
    It was based on Kent's earlier work with Smalltalk and automated testing[.](http://www.xprogramming.com/testfram.htm))
    Currently, automated testing has become a well-accepted concept in the software
    industry.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一直是软件开发的一部分。然而，当Kent Beck和Erich Gamma为Java开发引入了JUnit（[http://junit.org](http://junit.org)）时，世界被介绍了一个称为**自动化测试**的新概念。它基于Kent早期与Smalltalk和自动化测试的工作。目前，自动化测试已成为软件行业中一个被广泛接受的概念。
- en: A Python version, originally dubbed **PyUnit**, was created in 1999 and added
    to Python's standard set of libraries later in 2001 in Python 2.1\. Currently,
    the PyUnit library is available for both versions of Python, that is, 2.7 ([https://docs.python.org/2.7/library/unittest.html](https://docs.python.org/2.7/library/unittest.html))
    and 3.x ([https://docs.python.org/3.6/library/unittest.html](https://docs.python.org/3.6/library/unittest.html)).
    Since then, the Python community has referred to it as **unittest**, the name
    of the library imported into the test code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本最初被称为**PyUnit**，于1999年创建，并在2001年后添加到Python的标准库中，即Python 2.1。目前，PyUnit库适用于Python的两个版本，即2.7（[https://docs.python.org/2.7/library/unittest.html](https://docs.python.org/2.7/library/unittest.html)）和3.x（[https://docs.python.org/3.6/library/unittest.html](https://docs.python.org/3.6/library/unittest.html)）。从那时起，Python社区将其称为**unittest**，这是导入测试代码的库的名称。
- en: Unittest is the foundation of automated testing in the Python world. In this
    chapter, we will explore the basics of testing and asserting code functionality,
    building suites of tests, test situations to avoid, and finally testing edges
    and corner cases.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Unittest是Python世界中自动化测试的基础。在本章中，我们将探讨测试和断言代码功能的基础知识，构建测试套件，避免测试情况，最后测试边缘和角落情况。
- en: 'For all the recipes in this chapter, we will use `virtualenv` ([https://pypi.python.org/pypi/virtualenv](https://pypi.python.org/pypi/virtualenv))
    to create a controlled Python runtime environment. Unittest is part of the standard
    library, which requires no extra installation steps. But in later chapters, using
    `virtualenv` will allow us to conveniently install other test tools, without cluttering
    up our default Python installation. The steps to install `virtualenv` are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的所有食谱中，我们将使用`virtualenv`（[https://pypi.python.org/pypi/virtualenv](https://pypi.python.org/pypi/virtualenv)）来创建一个受控的Python运行环境。Unittest是标准库的一部分，不需要额外的安装步骤。但在后面的章节中，使用`virtualenv`将允许我们方便地安装其他测试工具，而不会使我们的默认Python安装变得混乱。安装`virtualenv`的步骤如下：
- en: 'To install `virtualenv`, either download it from the site mentioned previously
    or if you have Easy Install, just type: `easy_install virtualenv`. You can also
    use `pip install virtualenv` as well.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装`virtualenv`，可以从前面提到的网站下载，或者如果您有Easy Install，只需输入：`easy_install virtualenv`。您也可以使用`pip
    install virtualenv`。
- en: For some systems, you may need to install it either as `root` or by using `sudo`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些系统，您可能需要以`root`身份安装它，或者使用`sudo`。
- en: After installing `virtualenv`, use it to create a clean environment named `ptc` (an
    abbreviation used for *Python Testing Cookbook*) by using `--no-site-packages`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`virtualenv`后，使用它创建一个名为`ptc`（*Python Testing Cookbook*的缩写）的干净环境，使用`--no-site-packages`。
- en: Activate the virtual Python environment. This can vary, depending on which shell
    you are using. Take a look at this screenshot:![](../images/00005.jpeg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活虚拟Python环境。这可能会有所不同，取决于您使用的shell。看一下这个截图：![](../images/00005.jpeg)
- en: For the Windows platform, you can either select the folder where you want to
    create the `ptc` folder or you can directly get it created in your desired drive.
    Look at this screenshot:![](../images/00006.jpeg)
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Windows平台，您可以选择要创建`ptc`文件夹的文件夹，或者直接在所需的驱动器中创建它。看一下这个截图：![](../images/00006.jpeg)
- en: Finally, verify that the environment is active by checking the path of `pip`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过检查`pip`的路径来验证环境是否处于活动状态。
- en: For more information on the usage and benefits of `virtualenv`, please read [http://iamzed.com/2009/05/07/a-primer-on-virtualenv](http://iamzed.com/2009/05/07/a-primer-on-virtualenv).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`virtualenv`的用法和好处的更多信息，请阅读[http://iamzed.com/2009/05/07/a-primer-on-virtualenv](http://iamzed.com/2009/05/07/a-primer-on-virtualenv)。
- en: Asserting the basics
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言基础知识
- en: 'The basic concept of an automated unittest test case is to instantiate part
    of our code, subject it to operations, and verify certain results using assertions:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化unittest测试用例的基本概念是实例化我们代码的一部分，对其进行操作，并使用断言验证某些结果：
- en: If the results are as expected, unittest counts it as a test success
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果结果符合预期，unittest将计为测试成功
- en: If the results don't match, an exception is thrown, and unittest counts it as
    a test failure
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果结果不匹配，将引发异常，并且unittest将计为测试失败
- en: Getting ready
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Unittest was added to Python's standard batteries included library suite and
    doesn't require any extra installation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Unittest已添加到Python的标准库套件中，不需要任何额外的安装。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With these steps, we will code a simple program and then write some automated
    tests using unittest:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们将编写一个简单的程序，然后使用unittest编写一些自动化测试：
- en: 'Create a new file called `recipe1.py` for this recipe''s code. Pick a class
    to test. This is known as the **class under test**. For this recipe, we''ll pick
    a class that uses a simplistic Roman numeral converter:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个配方的代码创建一个名为`recipe1.py`的新文件。选择一个要测试的类。这被称为**被测试的类**。对于这个配方，我们将选择一个使用简单的罗马数字转换器的类：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This Roman numeral converter applies the simple rules of addition, but it doesn't
    have the special subtraction patterns such as `XL` mapping to `40`. The purpose
    is not to have the best Roman numeral converter, but to observe the various test
    assertions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个罗马数字转换器应用了简单的加法规则，但它没有特殊的减法模式，比如`XL`映射到`40`。目的不是要有最好的罗马数字转换器，而是观察各种测试断言。
- en: 'Write a new class and give it the same name with `Test` appended to the end,
    subclassing `unittest.TestCase`. Appending a test class with `Test` is a common
    convention, but not a requirement. Extending `unittest.TestCase` is a requirement
    needed to hook into unittest''s standard test runner:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个新的类，并给它加上`Test`，继承`unittest.TestCase`。在测试类后面加上`Test`是一种常见的约定，但不是必需的。扩展`unittest.TestCase`是需要的，以便连接到unittest的标准测试运行器：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create several methods with names starting with `test`, so they are automatically
    picked up by the test number of unittest:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建几个以`test`开头的方法，这样它们就会被unittest的测试用例自动捕捉到：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Make the entire script runnable and then use unittest''s test runner:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使整个脚本可运行，然后使用unittest的测试运行器：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the file from the command line, as shown in this screenshot:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行运行文件，如下截图所示：
- en: '![](../images/00007.jpeg)`self.assertEquals()` has been deprecated in Python
    3.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00007.jpeg)`self.assertEquals()`在Python 3中已被弃用。'
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the first step, we picked a class to test. Next, we created a separate class
    to test. By naming the test class as `[class under test]Test`, it is easy to tell
    which class is under test. Each test method name must start with `test`, so that
    unittest will automatically pick it up and run it. To add more tests, just define
    more `test` methods. Each of these tests utilizes various assertions:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们选择了一个要测试的类。接下来，我们创建了一个单独的测试类。通过将测试类命名为`[class under test]Test`，很容易知道哪个类正在被测试。每个测试方法的名称必须以`test`开头，这样unittest会自动捕捉并运行它。要添加更多的测试，只需定义更多的`test`方法。这些测试利用了各种断言：
- en: '`assertEqual(first, second[, msg])`: Compares first and second expressions
    and fails if they don''t have the same value. We can optionally print a special
    message if there is a failure.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEqual(first, second[, msg])`: 比较第一个和第二个表达式，如果它们的值不相同则失败。如果失败，我们可以选择打印特殊消息。'
- en: '`assertTrue(expression[, msg])`: Tests the expression and fails if it is false.
    We can optionally print a special message if there is a failure.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertTrue(expression[, msg])`: 测试表达式，如果为假则失败。如果失败，我们可以选择打印特殊消息。'
- en: '`assertFalse(expression[, msg])`: Tests the expression and fails if it is true.
    We can optionally print a special message if there is a failure.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFalse(expression[, msg])`: 测试表达式，如果为真则失败。如果失败，我们可以选择打印特殊消息。'
- en: '`assertRaises(exception, callable, ...)`: Runs the callable with any arguments,
    for the callable listed afterwards, and fails if it doesn''t raise the exception.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertRaises(exception, callable, ...)`: 用任何参数运行callable，对于之后列出的callable，如果它没有引发异常，则失败。'
- en: There's more...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Unittest provides many options for asserting, failing, and other convenient
    options. The following sections show some recommendations on how to pick and choose
    from these options.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Unittest提供了许多断言、失败和其他方便的选项。以下部分展示了如何从这些选项中进行选择和挑选的一些建议。
- en: assertEquals is preferred over assertTrue and assertFalse
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: assertEquals优于assertTrue和assertFalse
- en: When an `assertEquals` assertion fails, the first and second values are printed
    in the error report, giving a better feedback of what went wrong, whereas `assertTrue`
    and `assertFalse` simply report failure. Not all testable results fit this, but,
    if possible, use `assertEquals`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当`assertEquals`断言失败时，错误报告中会打印第一个和第二个值，从而更好地反馈出了问题所在，而`assertTrue`和`assertFalse`只会报告失败。并非所有可测试的结果都适用于这种情况，但如果可能的话，使用`assertEquals`。
- en: It's important to understand the concept of equality. When comparing integers,
    strings, and other scalars, it's very simple. It doesn't work as well with collections
    such as dictionaries, lists, and sets. Complex, custom-defined objects may carry
    custom definitions of equality. These complex objects may require more fine-grained
    assertions. That is why it's probably a good idea to also include some test methods
    that directly target equality and inequality when working with custom objects.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 理解相等的概念很重要。当比较整数、字符串和其他标量时，这很简单。但是对于诸如字典、列表和集合之类的集合，情况就不那么理想了。复杂的、自定义的对象可能具有自定义的相等定义。这些复杂的对象可能需要更精细的断言。因此，当使用自定义对象时，最好也包括一些直接针对相等性和不相等性的测试方法。
- en: self.fail([msg]) can usually be rewritten with assertions
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: self.fail([msg])通常可以用断言重写
- en: Unittest has a `self.fail([msg])` operation that unconditionally causes the
    test to fail, along with an optional message. This was not shown earlier because
    it is not recommended for use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Unittest有一个`self.fail([msg])`操作，可以无条件地导致测试失败，并附带一个可选的消息。之前没有展示这个操作，因为不建议使用。
- en: 'The `fail` method is often used to detect certain situations such as exceptions.
    A common idiom is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`fail`方法通常用于检测异常等特定情况。一个常见的习惯用法如下：'
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This tests the same behavior as the earlier `test_no_roman_numeral`. The problem
    with this approach is that when the code is working properly the fail method is
    never executed. Code not executed regularly is at risk of becoming out of date
    and invalid. This will also interfere with coverage reports. Instead, it is better
    to use `assertRaises` as we used in the earlier examples. For other situations
    look at rewriting the test using the other assertions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这测试了与之前的`test_no_roman_numeral`相同的行为。这种方法的问题在于当代码正常工作时，fail方法永远不会被执行。定期不执行的代码有可能变得过时和无效。这也会干扰覆盖率报告。因此，最好使用像我们在前面的例子中使用的`assertRaises`。对于其他情况，考虑使用其他断言重写测试。
- en: Our version of Python can impact our options
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的Python版本可能会影响我们的选项
- en: Python's official documentation on unittest shows many other assertions; however,
    they depend on the version of Python we are using. Some have been deprecated;
    others are only available in later versions, such as Python 3.6.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Python官方关于unittest的文档显示了许多其他断言；然而，它们取决于我们使用的Python版本。有些已经被弃用；其他一些只在以后的版本中可用，比如Python
    3.6。
- en: If our code must support multiple versions of Python then we must use the lowest
    common denominator. This recipe shows core assertions available in all versions
    since Python 3.6.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的代码必须支持多个版本的Python，那么我们必须使用最低公共分母。这个配方展示了自Python 3.6以来所有版本都可用的核心断言。
- en: Setting up and tearing down a test harness
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和拆卸测试工具
- en: Unittest provides an easy mechanism to configure the state of the system when
    a piece of code is put through a test. It also allows us to clean things up afterward,
    if needed. This is commonly needed when a particular test case has repetitive
    steps used in every test method.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Unittest提供了一种简单的机制来配置系统的状态，当一段代码经过测试时。如果需要，它还允许我们在之后清理事物。当一个特定的测试用例在每个测试方法中使用重复步骤时，通常会需要这样做。
- en: Barring any references to external variables or resources that carry state from
    one test method to the next, each test method starts from the same state.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 除了引用从一个测试方法到下一个测试方法传递状态的外部变量或资源，每个测试方法都从相同的状态开始。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With the following steps, we will set up and teardown a test harness for each
    test method:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，我们将为每个测试方法设置和拆卸测试工具：
- en: Create a new file called `recipe2.py` for the code in this recipe.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个配方的代码创建一个名为`recipe2.py`的新文件。
- en: 'Pick a class to test. In this case, we will use a slightly altered version
    of our Roman numeral converter, where the function, not the constructor, provides
    the input value to convert:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个要测试的类。在这种情况下，我们将使用我们的罗马数字转换器的一个稍微改变的版本，其中函数而不是构造函数提供要转换的输入值：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a class to test using the same name as the class under test with `Test`
    appended to the end:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与被测试类相同的名称创建一个测试类，在末尾添加`Test`：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a `setUp` method that creates an instance of the class under test:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`setUp`方法，用于创建被测试类的实例：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a `tearDown` method that destroys the instance of the class under test:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`tearDown`方法，用于销毁被测试类的实例：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create all the test methods using `self.converter`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`self.converter`创建所有测试方法：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Make the entire script runnable and then use the test runner of unittest:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使整个脚本可运行，然后使用unittest的测试运行程序：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the file from the command line, as shown in this screenshot:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行运行文件，如下截图所示：
- en: '![](../images/00008.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00008.jpeg)'
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the first step, we picked a class to test. Next, we created a separate test
    class. By naming the test class `[class under test]Test`, it is easy to tell which
    class is under test.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们选择了一个要测试的类。接下来，我们创建了一个单独的测试类。通过将测试类命名为`[class under test]Test`，很容易知道哪个类正在被测试。
- en: Then, we defined a `setUp` method that unittest runs before every `Test` method.
    Next, we created a `tearDown` method that unittest runs after every `Test` method.
    In this case, we added a print statement in each of them to demonstrate unittest
    rerunning these two methods for every test method. In reality, it would probably
    add too much noise to our testing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了一个`setUp`方法，unittest在每个`Test`方法之前运行。接下来，我们创建了一个`tearDown`方法，unittest在每个`Test`方法之后运行。在这种情况下，我们在每个方法中添加了一个打印语句，以演示unittest重新运行这两个方法以进行每个测试方法。实际上，这可能会给我们的测试添加太多噪音。
- en: One deficiency of unittest is the lack of `setUpClass`/`tearDownClass` and `setUpModule`/`tearDownModule`,
    providing the opportunity to run code in greater scopes than at the test method
    level. This has been added to `unittest2`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: unittest的一个不足之处是缺少`setUpClass`/`tearDownClass`和`setUpModule`/`tearDownModule`，这提供了在比测试方法级别更大的范围内运行代码的机会。这已经添加到`unittest2`中。
- en: '**Each test case can have one setUp and one tearDown method: **Our `RomanNumeralConverter`
    is pretty simple and fits easily into a single test class. But the test class
    allows only one `setUp` method and one `tearDown` method. If different combinations
    of `setUp`/`tearDown` methods are needed for various test scenarios, then this
    is a cue to code more test classes. Just because we write a `setUp` method, doesn''t
    mean we need a `tearDown` method. In our case, we could have skipped destroying
    the `RomanNumeralConverter`, because a new instance would be replacing it for
    every test method. It was really for demonstration purposes only. What are the
    other uses of those cases that need a `tearDown` method? Using a library that
    requires some sort of close operation is a ripe candidate for writing a `tearDown`
    method.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个测试用例可以有一个setUp和一个tearDown方法：**我们的`RomanNumeralConverter`非常简单，很容易适应一个单独的测试类。但是测试类只允许一个`setUp`方法和一个`tearDown`方法。如果需要不同组合的`setUp`/`tearDown`方法来进行各种测试场景，那么这就是编写更多测试类的线索。仅仅因为我们编写了一个`setUp`方法，并不意味着我们需要一个`tearDown`方法。在我们的情况下，我们可以跳过销毁`RomanNumeralConverter`，因为一个新实例将替换它用于每个测试方法。这只是为了演示目的。那些需要`tearDown`方法的其他用例有哪些其他用途？使用需要某种关闭操作的库是编写`tearDown`方法的一个很好的候选者。'
- en: Running test cases from the command line
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从命令行运行测试用例
- en: It is easy to adjust the test runner to print out every test method as it is
    run.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易调整测试运行程序，以便在运行时打印出每个测试方法。
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the following steps, we will run test cases with more detailed output, giving
    us better insight into how things run:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将以更详细的输出运行测试用例，以便更好地了解事物的运行情况：
- en: Create a new file called `recipe3.py` for this recipe's code.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个配方的代码创建一个名为`recipe3.py`的新文件。
- en: 'Pick a class to test. In this case, we will use our Roman numeral converter:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个要测试的类。在这种情况下，我们将使用我们的罗马数字转换器：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a test class using the same name as the class under test with `Test`
    appended to the end:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与被测试类相同的名称创建一个测试类，在末尾添加`Test`：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create several test methods. For this recipe, the second test have been deliberately
    coded to fail:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建几个测试方法。对于这个配方，第二个测试故意编码失败：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Define a test suite that automatically loads all the test methods, and then
    runs them with the higher level of verbosity:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个测试套件，它自动加载所有测试方法，然后以更高级别的详细程度运行它们：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the file from the command line. Notice how, in this screenshot the test
    method that fails, prints out its Python docstring:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行运行文件。请注意，在这个截图中，失败的测试方法打印出其Python文档字符串：
- en: '![](../images/00009.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00009.jpeg)'
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: A key part of automated testing is organizing the tests. The base units are
    called **test cases**. These can be combined together into **test suites**. Python's
    unittest module provides `TestLoader().loadTestsFromTestCase` to fetch all the
    `test*` methods automatically into a test suite. This test suite is then run through
    unittest's `TextTestRunner` with an increased level of verbosity.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试的关键部分是组织测试。基本单元称为**测试用例**。这些可以组合成**测试套件**。Python的unittest模块提供了`TestLoader().loadTestsFromTestCase`，可以自动将所有`test*`方法加载到一个测试套件中。然后通过unittest的`TextTestRunner`以更高级别的详细程度运行这个测试套件。
- en: '`TextTestRunner` is unittest''s only test runner. Later in this book, we will
    look at other test tools that have different runners, including the one that plugs
    in a different unittest test runner.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextTestRunner`是unittest的唯一测试运行器。在本书的后面，我们将看到其他具有不同运行器的测试工具，包括插入不同unittest测试运行器的运行器。'
- en: The previous screenshot shows each method along with its module and class name,
    as well as success/failure.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了每个方法以及其模块和类名，以及成功/失败。
- en: There's more...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe not only demonstrates how to turn up the verbosity of running tests,
    but also shows what happens when a test case fails. It renames the `test` method
    with the document string embedded in the `test` method, and prints the details
    later after all the test methods have been reported.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方不仅演示了如何提高运行测试的详细程度，还展示了当测试用例失败时会发生什么。它将`test`方法重命名为嵌入在`test`方法中的文档字符串，并在所有测试方法报告后打印详细信息。
- en: Running a subset of test case methods
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试用例方法的子集
- en: Sometimes, it's convenient to run only a subset of test methods in a given test
    case. This recipe will show how to run either the whole test case, or pick a subset
    from the command line.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，只运行给定测试用例中的一部分测试方法很方便。这个配方将展示如何从命令行运行整个测试用例，或者选择一个子集。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps show how to code a command-line script to run subsets of
    tests:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤显示了如何编写一个命令行脚本来运行测试的子集：
- en: Create a new file named `recipe4.py` to put all the code for this recipe.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe4.py`的新文件，放置这个配方的所有代码。
- en: 'Pick a class to test. In this case, we will use our Roman numeral converter:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个要测试的类。在这种情况下，我们将使用我们的罗马数字转换器：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a test class using the same name as the class under test with `Test`
    appended to the end:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与要测试的类相同的名称创建一个测试类，并在末尾添加`Test`：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create several `test` methods:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建几个`test`方法：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Write a main runner that either runs the entire test case or accepts a variable
    number of test methods:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个主运行程序，要么运行整个测试用例，要么接受可变数量的测试方法：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the recipe with no extra command-line arguments and see it run all the
    tests, as shown in this screenshot:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不带额外命令行参数运行该配方，并查看它运行所有测试，如此截图所示：
- en: '![](../images/00010.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00010.jpeg)'
- en: How it works...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: For this test case, we coded a couple of test methods. But instead of simply
    running all the tests, or defining a fixed list, we used Python's `sys` library
    to parse the command-line arguments. If there are no extra arguments, it runs
    the entire test case. If there are extra arguments, then they are assumed to be
    test method names. It uses unittest's inbuilt ability to specify test method names
    when instantiating `RomanNumeralConverterTest`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测试用例，我们编写了几个测试方法。但是，我们没有简单地运行所有测试，或者定义一个固定的列表，而是使用Python的`sys`库来解析命令行参数。如果没有额外的参数，它将运行整个测试用例。如果有额外的参数，那么它们被假定为测试方法名称。它使用unittest的内置能力在实例化`RomanNumeralConverterTest`时指定测试方法名称。
- en: Chaining together a suite of tests
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一系列测试链接在一起
- en: Unittest makes it easy to chain together test cases into a `TestSuite`. A `TestSuite`
    can be run just like a `TestCase`, but it also provides additional functionality
    to add a single/multiple tests, and count them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Unittest使得将测试用例链接成`TestSuite`变得很容易。`TestSuite`可以像`TestCase`一样运行，但它还提供了额外的功能来添加单个/多个测试，并对其进行计数。
- en: Why do we need this? Chaining together tests into a suite gives us the ability
    to pull together more than one module of test cases for a test run, as well as
    picking and choosing a subset of test cases. Up until now, we have generally run
    all the test methods from a single class. `TestSuite` gives us an alternative
    means to define a block of testing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要这个？将测试链接成一个套件使我们能够将多个测试用例模块汇集到一个测试运行中，以及挑选和选择测试用例的子集。到目前为止，我们通常运行单个类中的所有测试方法。`TestSuite`给我们提供了一个替代方法来定义一个测试块。
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the following steps, we will code multiple test case classes, and then load
    their test methods into suites so we can run them:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将编写多个测试用例类，然后将它们的测试方法加载到套件中，以便我们可以运行它们：
- en: Create a new file named `recipe5.py` to put our sample application and test
    cases.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe5.py`的新文件，放置我们的示例应用程序和测试用例。
- en: 'Pick a class to test. In this case, we will use our Roman numeral converter:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个要测试的类。在这种情况下，我们将使用我们的罗马数字转换器：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create two test classes with various test methods spread between them:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个测试类，它们之间分布着各种测试方法：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a test runner in a separate file named `recipe5_runner.py` that pulls
    in both test cases:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个名为`recipe5_runner.py`的单独文件中创建一个测试运行器，它引入了两个测试用例：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Execute the test runner, and observe from this screenshot how tests are pulled
    in from both test cases.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行测试运行器，并从这个截图中观察到测试是如何从两个测试用例中提取出来的。
- en: '![](../images/00011.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00011.jpeg)'
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The unittest module provides a convenient way to find all the test methods in
    a `TestClass` and bundle them together as a suite using its `loadTestsFromTestCase`.
    To further the usage of test suites, we are able to combine these two suites together
    as a single suite using `unittest.TestSuite([list...])`. The `TestSuite` class
    is designed to act as a `TestCase` class does, even though it doesn't subclass
    `TestClass`, allowing us to run it using `TextTestRunner`. This recipe shows the
    verbosity turned up, allowing us to see exactly what test methods were run, and
    from what test case they came from.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: unittest模块提供了一种方便的方法，可以找到`TestClass`中的所有测试方法，并使用其`loadTestsFromTestCase`将它们捆绑在一起作为一个套件。为了进一步使用测试套件，我们能够将这两个套件组合成一个单一的套件，使用`unittest.TestSuite([list...])`。`TestSuite`类被设计为像`TestCase`类一样运行，尽管它不是`TestClass`的子类，但允许我们使用`TextTestRunner`来运行它。这个配方显示了详细程度的提高，让我们能够看到确切运行了哪些测试方法，以及它们来自哪个测试用例。
- en: There's more...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we ran the tests from a different file than where the test cases
    are defined. This is different than the previous recipes where the runnable code
    and the test case were contained in the same file. Since the runner is defining
    the tests we run, we can easily create more runners that combine different suites
    of tests.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们从一个不同的文件中运行了测试，而不是测试用例被定义的文件。这与以前的配方不同，以前的配方中可运行的代码和测试用例都包含在同一个文件中。由于运行器定义了我们要运行的测试，我们可以轻松地创建更多的运行器，结合不同的测试套件。
- en: The name of the test case should be significant
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试用例的名称应该有意义
- en: In the previous recipes, it has been advised to name the test case as `[class
    under test]Test`. This is to make it apparent to the reader that the class under
    test and the related test share an important relationship. Now that we are introducing
    another test case, we need to pick a different name. The name should explain clearly
    why these particular test methods are split out into a separate class. For this
    recipe, the methods are split out to show more complex combinations of Roman numerals.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的配方中，建议将测试用例命名为`[要测试的类]Test`。这是为了让读者明白，被测试的类和相关的测试之间有重要的关系。现在我们引入了另一个测试用例，我们需要选择一个不同的名称。名称应该清楚地解释为什么这些特定的测试方法被拆分到一个单独的类中。对于这个配方，这些方法被拆分出来以展示更复杂的罗马数字组合。
- en: Defining test suites inside the test module
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在测试模块内定义测试套件
- en: Each test module can provide one or more methods that define a different test
    suite. One method can exercise all the tests in a given module, another method
    can define a particular subset.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试模块可以提供一个或多个方法，定义不同的测试套件。一个方法可以在给定模块中执行所有测试，另一个方法可以定义一个特定的子集。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With the following steps, we will create some methods that define test suites
    using different means:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，我们将创建一些方法，使用不同的方式定义测试套件：
- en: Create a new file called `recipe6.py` to put our code for this recipe.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe6.py`的新文件，以放置我们这个配方的代码。
- en: 'Pick a class to test. In this case, we will use our Roman numeral converter:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个要测试的类。在这种情况下，我们将使用我们的罗马数字转换器：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a test class using the same name as the class under test with `Test`
    appended to the end:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与要测试的类相同的名称创建一个测试类，并在末尾添加`Test`：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Write a series of test methods, including a `setUp` method that creates a new
    instance of the `RomanNumeralConverter` for each test method:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一系列测试方法，包括一个`setUp`方法，为每个测试方法创建一个`RomanNumeralConverter`的新实例：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create some methods in the recipe''s module (but not in the test case) that
    define different test suites:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配方模块中创建一些方法（但不在测试用例中），定义不同的测试套件：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a runner that will iterate over each of these test suites and run them
    through unittest''s `TextTestRunner`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个运行器，它将遍历每个测试套件并通过unittest的`TextTestRunner`运行它们：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the combination of test suites, and see the results. Take a look at this
    screenshot:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试套件的组合，并查看结果。看一下这个截图：
- en: '![](../images/00012.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00012.jpeg)'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We pick a class to test and define a number of test methods that check things
    out. Then we define a few module-level methods such as, `high_and_low`, `combos`,
    and `all`, to define test suites. Two of them contain fixed subsets of methods
    while `all` dynamically loads the `test*` methods from the class. Finally, the
    main part of our module iterates over a listing of all these functions that generate
    suites to smoothly create and run them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择一个要测试的类，并定义一些测试方法来检查事情。然后我们定义一些模块级别的方法，比如`high_and_low`，`combos`和`all`，来定义测试套件。其中两个包含固定的方法子集，而`all`动态加载类中的`test*`方法。最后，我们的模块的主要部分遍历所有这些生成套件的函数的列表，以顺利地创建和运行它们。
- en: There's more...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: All of our test suites were run from the recipe's main runner. But this probably
    wouldn't be the case for a real project. Instead, the idea is to define different
    suites, and code a mechanism to pick which suite to run. Each suite is geared
    towards a different purpose, and it is necessary to allow the developer to pick
    which suite to run. This can be done by coding a command-line script using Python's
    optparse module to define command-line flags to pick one of these suites.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的测试套件都是从配方的主运行器中运行的。但这可能不适用于一个真正的项目。相反，想法是定义不同的套件，并编写一个机制来选择要运行的套件。每个套件都针对不同的目的，有必要允许开发人员选择要运行的套件。这可以通过使用Python的optparse模块编写一个命令行脚本来完成，以定义命令行标志来选择其中一个套件。
- en: Test suite methods must be outside of the test class
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试套件方法必须在测试类之外
- en: If we make these suite-defining methods members of the test class, we would
    have to instantiate the test class. Classes that extend `unittest.TestCase` have
    a specialized `init` method that doesn't work well with an instance that is created
    just to call a non-test method. That is why the methods are outside the test class.
    While these methods can be in other modules, it is very convenient to define them
    inside the module containing the test code, to keep things in proximity.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些定义套件的方法作为测试类的成员，我们将不得不实例化测试类。扩展`unittest.TestCase`的类具有一个专门的`init`方法，它与仅用于调用非测试方法的实例不兼容。这就是为什么这些方法在测试类之外的原因。虽然这些方法可以在其他模块中，但在包含测试代码的模块内定义它们非常方便，以保持它们的接近性。
- en: Why have different suites?
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么有不同的测试套件？
- en: 'What if we started our project off by running all tests? Sounds like a good
    idea, right? But what if the time to run the entire test suite grew to over an
    hour? There is a certain threshold after which developers tend to stop running
    tests, and *nothing is worse than an un-run test**suite*. By defining subsets
    of tests, it is easy to run alternate suites during the day, and then perhaps
    run the comprehensive test suite once a day. Bear in mind the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们一开始就运行所有测试项目会怎样？听起来是个好主意，对吧？但是如果运行整个测试套件的时间增长到一个小时以上怎么办？在一定的阈值之后，开发人员往往会停止运行测试，*没有比未运行的测试套件更糟糕的了*。通过定义测试的子集，可以轻松地在白天运行备用套件，然后也许每天运行一次全面的测试套件。请记住以下几点：
- en: '`all` is the comprehensive suite'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all`是全面的测试套件'
- en: '`high_and_low` is an example of testing the edges'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`high_and_low`是测试边缘情况的一个例子'
- en: '`combos` is a random sampling of values used to show that things are generally
    working'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`combos`是用于显示事物通常工作的值的随机抽样'
- en: Defining our test suites is a judgment call. It's also worth re-evaluating each
    test suite every so often. If one test suite is getting too costly to run, consider
    moving some of its more expensive tests to another suite.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 定义我们的测试套件是一个判断。每隔一段时间重新评估每个测试套件也是值得的。如果一个测试套件运行成本太高，考虑将一些更昂贵的测试移到另一个套件中。
- en: optparse is being phased out and replaced by argparse
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: optparse正在被淘汰，并被argparse替代
- en: While `optparse` is a convenient way to add command-line flags to Python scripts,
    it won't be available forever. Python 2.7 has deprecated this module and is continuing
    this development in `argparse`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`optparse`是向Python脚本添加命令行标志的一种方便方式，但它不会永远可用。Python 2.7已经弃用了这个模块，并在`argparse`中继续开发。
- en: Retooling old test code to run inside unittest
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新调整旧的测试代码以在unittest中运行
- en: Sometimes, we may have developed demo code to exercise our system. We don't
    have to rewrite it to run it inside unittest. Instead, it is easy to hook it up
    to the test framework and run it with some small changes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能已经开发了演示代码来测试我们的系统。我们不必重写它以在unittest中运行。相反，将它连接到测试框架并进行一些小的更改即可轻松运行。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With these steps, we will dive into capturing the test code that was written
    without using unittest, and repurposing it with minimal effort to run inside unittest:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们将深入捕获那些没有使用unittest编写的测试代码，并以最小的努力重新用途化它们以在unittest中运行：
- en: Create a file named `recipe7.py` to put our application code that we will be
    testing.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe7.py`的文件，用于放置我们将要测试的应用程序代码。
- en: 'Pick a class to test. In this case, we will use our Roman numeral converter:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个要测试的类。在这种情况下，我们将使用我们的罗马数字转换器：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Create a new file named `recipe7_legacy.py` to contain test code that doesn't
    use the unittest module.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe7_legacy.py`的新文件，其中包含不使用unittest模块的测试代码。
- en: 'Create a set of legacy tests that are coded, based on Python''s `assert` function,
    not with unittest, along with a runner:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一组遗留测试，根据Python的`assert`函数编码，而不是使用unittest，以及一个运行器：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This set of legacy tests is meant to represent legacy test code that our team
    has developed to exercise things before unittest was an option.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这组遗留测试旨在代表我们团队在unittest成为一个选择之前开发的遗留测试代码。
- en: 'Run the legacy tests. What is wrong with this situation? Did all the test methods
    run? Have we caught all the bugs? Take a look at this screenshot:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行遗留测试。这种情况有什么问题？所有测试方法都运行了吗？我们有没有捕捉到所有的bug？看一下这个截图：
- en: '![](../images/00013.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00013.jpeg)'
- en: Create a new file called `recipe7_pyunit.py`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe7_pyunit.py`的新文件。
- en: 'Create a unittest set of tests, wrapping each legacy test method inside unittest''s
    `FunctionTestCase`:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个unittest测试集，将每个遗留测试方法包装在unittest的`FunctionTestCase`中：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the unittest test. Did all the tests run this time? Which test failed?
    Where is the bug? Look at this screenshot:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行unittest测试。这次所有测试都运行了吗？哪个测试失败了？bug在哪里？看一下这个截图：
- en: '![](../images/00014.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00014.jpeg)'
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Python provides a convenient assert statement that tests a condition. When true,
    the code continues. When false, it raises an `AssertionError`. In the first test
    runner, we have several tests that check results using a mixture of `assert` statements
    or raising an `AssertionError`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一个方便的断言语句来测试条件。当条件为真时，代码继续执行。当条件为假时，它会引发`AssertionError`。在第一个测试运行器中，我们有几个测试，使用`assert`语句或引发`AssertionError`来检查结果。
- en: unittest provides a convenient class, `unittest.FunctionTestCase`, that wraps
    a bound function as a unittest test case. If an `AssertionError` is thrown, `FunctionTestCase`
    catches it, flags it as a test *failure*, and proceeds to the next test case.
    If any other type of exception is thrown, it will be flagged as a test error.
    In the second test runner, we wrap each of these legacy test methods with `FunctionTestCase`,
    and chain them together in a suite for unittest to run.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: unittest提供了一个方便的类，`unittest.FunctionTestCase`，它将绑定的函数包装为unittest测试用例。如果抛出`AssertionError`，`FunctionTestCase`会捕获它，将其标记为测试*失败*，然后继续下一个测试用例。如果抛出任何其他类型的异常，它将被标记为测试错误。在第二个测试运行器中，我们使用`FunctionTestCase`包装每个这些遗留测试方法，并将它们链接在一起，以便unittest运行。
- en: As seen by running the second test run, there is a bug lurking in the third
    test method. We were not aware of it because the test suite was prematurely interrupted.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行第二个测试运行，可以看到第三个测试方法中隐藏着一个bug。我们之前并不知道这个bug，因为测试套件被过早中断了。
- en: Another deficiency of Python's assert statement is shown by the first failure,
    as seen in the previous screenshot. When an assert fails, there is little to no
    information about the values that were compared. All we have is the line of code
    where it failed. The second assert in that screenshot was more useful, because
    we coded a custom checker that threw a custom `AssertionError`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`assert`语句的另一个不足之处可以从前面的截图中的第一个失败中看出。当断言失败时，几乎没有关于被比较的值的信息。我们只有它失败的代码行。截图中的第二个断言更有用，因为我们编写了一个自定义检查器，它抛出了一个自定义的`AssertionError`。
- en: There's more...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Unittest does more than just run tests. It has a built-in mechanism to trap
    errors and failures, and then it continues running as much of our test suite as
    possible. This helps, because we can shake out more errors and fix more things
    within a given test run. This is especially important when a test suite grows
    to the point of taking minutes or hours to run.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Unittest不仅仅是运行测试。它有一个内置的机制来捕获错误和失败，然后尽可能多地继续运行我们的测试套件。这有助于我们在给定的测试运行中摆脱更多的错误并修复更多的问题。当测试套件增长到需要花费几分钟甚至几小时才能运行时，这一点尤为重要。
- en: Where are the bugs?
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误在哪里？
- en: 'They exist in the test methods, and fundamentally were made by making slight
    alterations to the Roman numeral being converted, as shown in the code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 它们存在于测试方法中，并且基本上是通过对被转换的罗马数字进行轻微修改而产生的，如代码所示：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `combo_test1` test method prints out that it is converting `MMX`, but actually
    tries to convert `MMXX`. The `combo_test2` test method prints out that it is converting
    `MMMMDCLXVIII`, but actually tries to convert `MMMMDCLXVII`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`combo_test1`测试方法打印出正在转换`MMX`，但实际上尝试转换`MMXX`。`combo_test2`测试方法打印出正在转换`MMMMDCLXVIII`，但实际上尝试转换`MMMMDCLXVII`。'
- en: This is a contrived example, but have you ever run into bugs just as small that
    drove you mad trying to track them down? The point is, showing how easy or hard
    it can be to track them down is based on how the values are checked. Python's
    `assert` statement isn't very effective at telling us what values are compared
    where. The customized `check` method is much better at pinpointing the problem
    with `combo_test2`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个刻意的例子，但你是否曾经遇到过同样小的错误，让你疯狂地试图追踪它们？关键是，显示追踪它们有多容易或多困难取决于如何检查值。Python的`assert`语句在告诉我们在哪里比较值方面并不是很有效。自定义的`check`方法在指出`combo_test2`的问题方面要好得多。
- en: This highlights the problem with having comments or print statements trying
    to reflect what the asserts do. They can easily get out of sync and the developer
    may face some problems trying to track down bugs. Avoiding this situation is known
    as the **DRY** principle (**Don't Repeat Yourself**).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这突显了使用注释或打印语句来反映断言所做的事情的问题。它们很容易失去同步，开发人员可能会在追踪错误时遇到一些问题。避免这种情况被称为**DRY**原则（**不要重复自己**）。
- en: FunctionTestCase is a temporary measure
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FunctionTestCase是一个临时措施
- en: '`FunctionTestCase` is a test case that provides an easy way to quickly migrate
    tests based on Python''s `assert` statement, so they can be run with unittest.
    But things shouldn''t stop there. If we take the time to convert `RomanNumeralTester`
    into a unittest `TestCase`, then we gain access to other useful features such
    as the various `assert*` methods that come with `TestCase`. It''s a good investment.
    The `FunctionTestCase` just lowers the bar to migrate to unittest.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`FunctionTestCase`是一个测试用例，它提供了一种快速迁移基于Python的`assert`语句的测试的简单方法，因此它们可以与unittest一起运行。但事情不应该止步于此。如果我们花时间将`RomanNumeralTester`转换为unittest的`TestCase`，那么我们就可以使用`TestCase`提供的其他有用功能，比如各种`assert*`方法。这是一个很好的投资。`FunctionTestCase`只是降低了迁移到unittest的门槛。'
- en: Breaking down obscure tests into simple ones
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将模糊测试拆分为简单测试
- en: Unittest provides the means to test the code through a series of assertions.
    I have often felt the temptation to exercise many aspects of a particular piece
    of code within a single test method. If any part fails, it becomes obscured as
    to which part failed. It is preferable to split things up into several smaller
    test methods, so that when some part of the code under test fails, it is obvious.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Unittest提供了通过一系列断言来测试代码的手段。我经常感到诱惑，想在单个测试方法中测试代码的许多方面。如果任何部分失败，哪一部分失败就变得模糊了。最好将事情分解成几个较小的测试方法，这样当被测试的代码的某些部分失败时，就很明显了。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'With these steps, we will investigate what happens when we put too much into
    a single test method:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们将调查将太多内容放入单个测试方法时会发生什么：
- en: Create a new file named `recipe8.py` to put out application code in for this
    recipe.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe8.py`的新文件，用于放置此配方的应用代码。
- en: 'Pick a class to test. In this case, we will use an alternative version of the
    Roman numeral converter, which converts both ways:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个要测试的类。在这种情况下，我们将使用罗马数字转换器的另一种版本，它可以双向转换：
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Create a new file called `recipe8_obscure.py` to put some longer test methods.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe8_obscure.py`的新文件，以放置一些更长的测试方法。
- en: 'Create some test methods that combine several test assertions:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一些结合了几个测试断言的测试方法：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Run the obscure tests. Why did it fail? Where is the bug? It reports that `II`
    is not equal to `I`, so something appears to be off. Is this the only bug? Create
    another file called `recipe8_clear.py` to create a more fine-grained set of test
    methods. Take a look at this screenshot:![](../images/00015.jpeg)
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行模糊测试。为什么会失败？错误在哪里？报告说`II`不等于`I`，所以似乎有些问题。这是唯一的错误吗？创建另一个名为`recipe8_clear.py`的文件，以创建一组更精细的测试方法。看一下这个截图：![](../images/00015.jpeg)
- en: 'Split up the assertions into separate test methods to give a higher fidelity
    of output:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将断言拆分为单独的测试方法，以提供更高的输出保真度：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the clearer test suite. Is it a bit clearer where the bug is? What did
    we trade in to get this higher degree of test failure? Was it worth the effort?
    Refer to this screenshot:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行更清晰的测试套件。现在错误的位置更清晰了吗？为了获得更高程度的测试失败，我们做出了什么样的交易？这样做值得吗？参考这个截图：
- en: '![](../images/00016.jpeg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00016.jpeg)'
- en: How it works...
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this case, we created a modified Roman numeral converter that converts both
    ways. We then started creating test methods to exercise things. Since each of
    these tests were a simple, one line assertion, it was convenient to put them all
    in the same test method.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们创建了一个修改后的罗马数字转换器，可以双向转换。然后我们开始创建测试方法来练习这些事情。由于这些测试都是简单的一行断言，将它们放在同一个测试方法中非常方便。
- en: In the second test case, we put each assertion into a separate test method.
    Running it exposes the fact that there are multiple bugs in this Roman numeral
    converter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个测试用例中，我们将每个断言放入一个单独的测试方法中。运行它会暴露出这个罗马数字转换器中存在多个错误。
- en: There's more...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When we started off writing tests, it was very convenient to bundle all these
    assertions into a single test method. After all, if everything is working, there
    is no harm, right? But what if everything does *not* work; what do we have to
    deal with? An obscure error report!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始编写测试时，将所有这些断言捆绑到一个测试方法中非常方便。毕竟，如果一切正常，那就没有坏处，对吧？但是如果一切都*不*正常呢；我们要如何处理？一个晦涩的错误报告！
- en: Where is the bug?
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误在哪里？
- en: The obscured test runner may not be clear. All we have to go on is `II != I` which
    isn't much. The clue is that it is only off by one. The clear test runner gives
    more clues. We see that `V != IIII, XII != XI`, and some more. Each of these failures
    shows things being off by one.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 晦涩的测试运行器可能不够清晰。我们只能依靠`II != I`这并不多。线索是它只差一个。清晰的测试运行器提供更多线索。我们看到`V != IIII, XII
    != XI`，还有更多。这些失败显示了每个都差一个。
- en: 'The bug involves the various Boolean conditions in the while checks:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 错误涉及while检查中的各种布尔条件：
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Instead of testing greater than, it should test for *greater than* or *equal
    to*. This causes it to skip out of each Roman numeral before counting the last
    one.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该测试*大于*或*等于*，而不是测试大于。这会导致它在计算最后一个罗马数字之前跳出。
- en: What is the right size for a test method?
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试方法的合适大小是多少？
- en: In this recipe, we broke things down to a single assertion per test. But I wouldn't
    advise thinking along these lines.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将事物分解为每个测试一个断言。但我不建议沿着这样的思路思考。
- en: If we look a little closer, each test method also involves a single usage of
    the Roman numeral API. For the converter, there is only one result to examine
    when exercising the code. For other systems, the output may be more complex. It
    is completely warranted to use several assertions in the same test method to check
    the outcome by making that single call.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再仔细看一些，每个测试方法还涉及对罗马数字API的单一使用。对于转换器，在练习代码时只有一个结果需要检查。对于其他系统，输出可能更复杂。在同一个测试方法中使用多个断言来检查通过进行单次调用的结果是完全合理的。
- en: When we proceed to make more calls to the Roman numeral API, it should signal
    us to consider splitting it off into a new test method.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们继续对罗马数字API进行更多调用时，它应该提示我们考虑将其拆分为一个新的测试方法。
- en: 'This raises the question: *What is a unit of code?* There has been much debate
    over what defines a unit of code, and what makes a good unit test. There are many
    opinions. Hopefully, reading this chapter and weighing it against the other test
    tactics covered throughout this book will help you enhance your own opinion and
    ultimately improve your own testing talent.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一个问题：*什么是代码单元？*关于代码单元的定义以及什么样的单元测试才算是好的，一直存在着很多争论。有很多不同的观点。希望阅读本章并将其与本书中涵盖的其他测试策略进行权衡，将有助于您加强自己的观点，最终提高自己的测试技能。
- en: Unittests versus integration tests
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试与集成测试
- en: Unittest can easily help us write both unittests as well as integration tests.
    Unittests exercise smaller blocks of code. When writing unittests, it is best
    to keep the testing as small and fine-grained as possible. Breaking testing up
    into lots of smaller tests is often a better approach to detecting and pinpointing
    bugs.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Unittest可以轻松帮助我们编写单元测试和集成测试。单元测试可以测试较小的代码块。在编写单元测试时，最好将测试保持尽可能小和细粒度。将测试分解为许多较小的测试通常是检测和定位错误的更好方法。
- en: When we move up to a higher level (such as integration testing), it makes sense
    to test multiple steps in a single test method. But this is only recommended if
    there are adequate low-level unit tests. This will shed some light on whether
    it is broken at the unit level, or there exists a sequence of steps that causes
    the error.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提升到更高级别（如集成测试）时，有意义的是在一个测试方法中测试多个步骤。但只有在有足够的低级单元测试时才建议这样做。这将为我们提供一些线索，表明它是在单元级别出现了问题，还是存在一系列步骤导致了错误。
- en: Integration tests often extend to things such as external systems. For example,
    many argue that unit testing should never connect to a database, talk to an LDAP
    server, or interact with other systems.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试通常扩展到诸如外部系统之类的事物。例如，许多人认为单元测试不应该连接到数据库，与LDAP服务器通信或与其他系统交互。
- en: Just because we are using unittest doesn't mean the tests we are writing are
    unit tests. Later in this book, we will visit the concept that unittest can be
    used to write many types of tests including integration tests, smoke tests, and
    other types as well.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为我们使用了unittest并不意味着我们正在编写的测试就是单元测试。在本书的后面，我们将讨论unittest可以用来编写许多类型的测试，包括集成测试、冒烟测试以及其他类型的测试。
- en: Testing the edges
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试边缘情况
- en: When we write automated tests, we pick the inputs and assert the expected outputs.
    It is important to test the limits of the inputs to make sure our code can handle
    good and bad inputs. This is also known as **testing corner cases**.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写自动化测试时，我们选择输入并断言预期的输出。测试输入的极限是很重要的，以确保我们的代码可以处理好和坏的输入。这也被称为**测试边界情况**。
- en: How to do it...
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'As we dig into this recipe, we will look for good boundaries to test against:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们深入研究这个示例时，我们将寻找好的边界进行测试：
- en: Create a new file named `recipe9.py` for the code in this recipe.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个示例创建一个名为`recipe9.py`的新文件。
- en: 'Pick a class to test. In this recipe, we''ll use another variation of our Roman
    numeral converter. This one doesn''t process values greater than `4000`:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个要测试的类。在这个示例中，我们将使用我们的罗马数字转换器的另一个变体。这个变体不处理大于`4000`的值：
- en: '[PRE35]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a test case that sets up an instance of the Roman numeral converter:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试用例，设置罗马数字转换器的实例：
- en: '[PRE36]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add several test methods that exercise the edges of converting to Roman numeral
    notation:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加几个测试方法，以测试转换为罗马数字表示法的边缘情况：
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add several test methods that exercise the edges of converting to decimal notation:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加几个测试方法，以便测试转换为十进制表示法的边缘情况：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add some tests that exercise the tiers of converting decimals to Roman numerals:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些测试，以测试将十进制数转换为罗马数字的层次：
- en: '[PRE39]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add some tests that input unexpected values to the Roman numeral converter:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些测试，输入意外值到罗马数字转换器：
- en: '[PRE40]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add a unit test runner:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个单元测试运行器：
- en: '[PRE41]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Run the test case. Take a look at this screenshot:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试用例。看一下这个屏幕截图：
- en: '![](../images/00017.jpeg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00017.jpeg)'
- en: How it works...
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We have a specialized Roman numeral converter that only converts values up
    to `MMMM` or `4000`. We have written several test methods to exercise it. The
    immediate edges we write tests for are `1` and `4000`. We also write some tests
    for one step past that: `0` and `4001`. To make things complete, we also test
    against `-1`.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个专门的罗马数字转换器，只能转换到`MMMM`或`4000`的值。我们编写了几个测试方法来测试它。我们立即测试的边缘是`1`和`4000`。我们还为这之后的一步编写了一些测试：`0`和`4001`。为了使事情完整，我们还测试了`-1`。
- en: There's more...
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A key part of the algorithm involves handling the various tiers of Roman numerals
    (5, 10, 50, 100, 500, and 1000). These could be considered *mini-edges*, so we
    wrote tests to check that the code handled those as well. Do you think we should
    test one past the mini-edges?
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的一个关键部分涉及处理各种层次的罗马数字（5、10、50、100、500和1000）。这些可以被认为是*微边缘*，所以我们编写了测试来检查代码是否也处理了这些情况。你认为我们应该测试一下微边缘之外的情况吗？
- en: It's recommended we should. Many bugs erupt due to coding *greater than*, when
    it should be *greater than or equal* (or vice versa), and so on. Testing one past
    the boundary, in both directions, is the perfect way to make sure that things
    are working exactly as expected. We also need to check bad inputs, so we tried
    converting `None` and a `float`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 建议我们应该。许多错误是由于编码*大于*而不是*大于或等于*（或反之）等等而引发的。在边界之外进行测试，向两个方向进行测试，是确保事情正如预期的完美方式。我们还需要检查错误的输入，所以我们尝试转换`None`和`float`。
- en: 'That previous statement raises an important question: *How many invalid types
    should* *we test against*? Because Python is dynamic, we can expect a lot of input
    types. So, what is reasonable? If our code hinges on a dictionary lookup, such
    as certain parts of our Roman numeral API does, then confirming that we correctly
    handle a `KeyError` would probably be adequate. We don''t need to input lots of
    different types if they all result in a `KeyError`.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的陈述提出了一个重要的问题：*我们应该测试多少种无效类型*？因为Python是动态的，我们可以期望许多输入类型。那么，什么是合理的呢？如果我们的代码依赖于字典查找，比如我们的罗马数字API的某些部分，那么确认我们正确处理`KeyError`可能就足够了。如果所有不同类型的输入都导致`KeyError`，那么我们就不需要输入很多不同类型。
- en: Identifying the edges is important
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别边缘很重要
- en: It's important to identify the edges of our system, because we need to know
    our software can handle these boundaries. We also need to know it can handle both
    sides of these boundaries that are good values and bad values. That is why we
    need to check `4000` and `4001` as well as `0` and `1`. This is a common place
    where software breaks.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 识别系统的边缘很重要，因为我们需要知道我们的软件能够处理这些边界。我们还需要知道它能够处理这些边界的两侧，即好值和坏值。这就是为什么我们需要检查`4000`和`4001`以及`0`和`1`。这是软件经常出错的地方。
- en: Testing for unexpected conditions
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试意外条件
- en: Does this sound a little awkward? Expect the unexpected? Our code involves converting
    integers and strings back and forth. By unexpected, we mean types of inputs passed
    in when someone uses our library that doesn't understand the edges, or wires it
    to receive inputs that are wider ranging types than we expected to receive.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来有点别扭吗？预料之外的情况？我们的代码涉及将整数和字符串来回转换。所谓的意外情况，是指当有人使用我们的库时传递了我们没有预料到的边界或将其连接到接收比我们预期的更广泛类型的输入时传递的输入类型。
- en: A common occurrence of misuse is when a user of our API is working against a
    collection, such as a list, and accidentally passes the entire list instead of
    a single value by iteration. Another, often seen situation is when a user of our
    API passes in `None` due to some other bug in their code. It's good to know that
    our API is resilient enough to handle this.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的误用情况是当我们的API的用户针对一个集合（如列表）进行操作，并意外地传递整个列表，而不是通过迭代传递单个值。另一个经常出现的情况是当我们的API的用户由于其代码中的某些其他错误而传递`None`。知道我们的API足够强大，能够处理这些情况是很好的。
- en: Testing corner cases by iteration
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过迭代测试边界情况
- en: While developing code, new corner-case inputs are often discovered. Being able
    to capture these inputs in an iterable array makes it easy to add related test
    methods.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发代码时，通常会发现新的边界情况输入。能够将这些输入捕获在可迭代的数组中，使得添加相关的测试方法变得容易。
- en: How to do it...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will look at a different way to test corner cases:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看一种不同的测试边界情况的方法：
- en: Create a new file called `recipe10.py` for our code in this recipe.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们在这个示例中的代码创建一个名为`recipe10.py`的新文件。
- en: 'Pick a class to test. In this recipe, we''ll use another variation of our Roman
    numeral converter. This one doesn''t process values greater than `4000`:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个类进行测试。在这个示例中，我们将使用我们的罗马数字转换器的另一个变体。这个变体不处理大于`4000`的值：
- en: '[PRE42]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a test class to exercise the Roman numeral converter:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试类来测试罗马数字转换器：
- en: '[PRE43]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Write a test method that exercises the edges of the Roman numeral converter:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个测试方法，测试罗马数字转换器的边缘情况：
- en: '[PRE44]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create a test method that exercises the tiers converting from decimal to Roman
    numerals:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试方法，测试从十进制到罗马数字的转换层次：
- en: '[PRE45]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create a test method that exercises a set of invalid inputs:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试方法，测试一组无效输入：
- en: '[PRE46]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Code a utility method that iterates over the edge cases and runs different
    assertions based on each edge:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个实用方法，迭代边缘情况并根据每个边缘运行不同的断言：
- en: '[PRE47]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Make the script runnable by loading the test case into `TextTestRunner`:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将测试用例加载到`TextTestRunner`中使脚本可运行。
- en: '[PRE48]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Run the test case, as shown in this screenshot:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试用例，如此截图所示：
- en: '![](../images/00018.jpeg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00018.jpeg)'
- en: How it works...
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We have a specialized Roman numeral converter that only converts values up
    to `MMMM` or `4000`. The immediate edges we write tests for are `1` and `4000`.
    We also write some tests for one step past that: `0` and `4001`. To make things
    complete, we also test against `-1`.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个专门的罗马数字转换器，只能转换值到`MMMM`或`4000`。我们写测试的即时边缘是`1`和`4000`。我们还为这之后的一步写了一些测试：`0`和`4001`。为了使事情完整，我们还对`-1`进行了测试。
- en: But we've written the tests a little differently. Instead of writing each test
    input/output combination as a separate test method, we capture the input and output
    values in a tuple that is embedded in a list. We then feed it to our test iterator,
    `checkout_edge`. Because we need both `assertEqual` and `assertRaise` calls, the
    tuple also includes either equals or raises to flag which assertion to use.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们以稍有不同的方式编写了测试。我们不是将每个测试输入/输出组合作为单独的测试方法来编写，而是将输入和输出值捕捉在嵌入列表中的元组中。然后我们将其提供给我们的测试迭代器`checkout_edge`。因为我们需要`assertEqual`和`assertRaise`调用，所以元组还包括等于或引发以标记使用哪种断言。
- en: Finally, to make it flexibly handle the conversion of both Roman numerals and
    decimals, the handles on the `convert_to_roman` and `convert_to_decimal` functions
    of our Roman numeral API are embedded in each tuple as well.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了灵活处理罗马数字和十进制的转换，我们还将我们的罗马数字API的`convert_to_roman`和`convert_to_decimal`函数的句柄嵌入到每个元组中。
- en: 'As shown in the following highlighted parts, we grab a handle on `convert_to_roman` and
    store it in `r`. Then we embed it in the third element of the highlighted tuple,
    allowing the `checkout_edge` function to call it when needed:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，我们抓住了`convert_to_roman`并将其存储在`r`中。然后我们将其嵌入到突出显示的元组的第三个元素中，允许`checkout_edge`函数在需要时调用它：
- en: '[PRE49]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: There's more...
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A key part of the algorithm involves handling the various tiers of Roman numerals
    (5, 10, 50, 100, 500, and 1000). These could be considered *mini-edges*, so we
    wrote a separate test method that has a list of input/output values to check those
    out as well. In the *Testing the edges* recipe, we didn't include testing before
    and after these mini-edges, for example, `4` and `6` for `5`. Now that it only
    takes one line of data to capture this test, we have it in this recipe. The same
    was done for all the others (except 1000).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的一个关键部分涉及处理罗马数字的各个层次（5、10、50、100、500和1000）。这些可以被视为*迷你边缘*，因此我们编写了一个单独的测试方法，其中包含要检查的输入/输出值的列表。在*测试边缘*配方中，我们没有包括这些迷你边缘之前和之后的测试，例如`5`的`4`和`6`。现在只需要一行数据来捕捉这个测试，我们在这个配方中有了它。其他所有的都是这样做的（除了1000）。
- en: Finally, we need to check bad inputs, so we created one more test method where
    we try to convert `None` and a `float` to and from a Roman numeral.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要检查错误的输入，因此我们创建了另一种测试方法，尝试将`None`和`float`转换为罗马数字并从中转换。
- en: Does this defy the recipe – breaking down obscure tests into simple ones?
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这是否违背了配方-将模糊测试分解为简单测试？
- en: In a way, it does. If something goes wrong in one of the test data entries,
    then that entire test method will have failed. That is one reason why this recipe
    split things up into three test methods instead of one big test method to cover
    them all. This is a judgment call about when it makes sense to view inputs and
    outputs as more data than test method. If you find the same sequence of test steps
    occurring repeatedly, consider if it makes sense to capture the values in some
    sort of table structure, such as a list used in this recipe.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上是这样的。如果测试数据条目中的某个地方出现问题，那么整个测试方法将失败。这就是为什么这个配方将事物分解成了三个测试方法而不是一个大的测试方法来覆盖它们所有的原因之一。这是一个关于何时将输入和输出视为更多数据而不是测试方法的判断。如果你发现相同的测试步骤序列重复出现，考虑一下是否有意义将这些值捕捉在某种表结构中，比如在这个配方中使用的列表中。
- en: How does this compare with the recipe – testing the edges?
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这与配方相比如何-测试边缘？
- en: In case it wasn't obvious, these are the exact same tests used in the *Testing
    the edges* recipe. The question is, which version do you find more readable? Both
    are perfectly acceptable. Breaking things up into separate methods makes it more
    fine-grained and easier to spot if something goes wrong. Collecting things together
    into a data structure, the way we did in this recipe, makes it more succinct and
    could spur us on to write more test combinations as we did for the conversion
    tiers.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不明显的话，这些是在*测试边缘*配方中使用的完全相同的测试。问题是，你觉得哪个版本更可读？两者都是完全可以接受的。将事物分解为单独的方法使其更精细化，更容易发现问题。将事物收集到数据结构中，就像我们在这个配方中所做的那样，使其更简洁，并可能会激励我们编写更多的测试组合，就像我们为转换层所做的那样。
- en: In my own opinion, when testing algorithmic functions that have simple inputs
    and outputs, it's more suitable to use this recipe's mechanism to code an entire
    battery of test inputs in this concise format. For example, a mathematical function,
    a sorting algorithm, or perhaps a transform function.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在我自己的观点中，当测试具有简单输入和输出的算法函数时，更适合使用这种方法来以简洁的格式编写整个测试输入的电池。例如，数学函数，排序算法或者转换函数。
- en: When testing functions that are more logical and imperative, the other recipe
    may be more useful. For example, functions that interact with a database, cause
    changes in the state of the system, or other types of side effects that aren't
    encapsulated in the return value would be hard to capture using this recipe.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试更逻辑和命令式的函数时，另一种方法可能更有用。例如，与数据库交互，导致系统状态发生变化或其他类型的副作用的函数，这些副作用没有封装在返回值中，将很难使用这种方法捕捉。
- en: See also
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Breaking down obscure tests into simple ones*'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将模糊测试分解为简单测试*'
- en: '*Testing the edges*'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试边缘*'
