- en: Chapter 2. Writing Your First Modular Program
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。编写您的第一个模块化程序
- en: 'In this chapter, we will use modular programming techniques to implement a
    non-trivial program. Along the way, we will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用模块化编程技术来实现一个非平凡的程序。在此过程中，我们将：
- en: Learn about the *divide and conquer* approach to program design
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解程序设计的“分而治之”方法
- en: Examine the tasks our program needs to perform
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查我们的程序需要执行的任务
- en: Look at the information our program will need to store
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看我们的程序需要存储的信息
- en: Apply modular techniques to break our program down into individual parts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用模块化技术，将我们的程序分解为各个部分
- en: Figure out how each part can be implemented as a separate Python module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弄清楚每个部分如何可以作为单独的Python模块实现
- en: See how the various modules work together to implement our program's functionality
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看各个模块如何协同工作以实现我们程序的功能
- en: Follow this process to implement a simple but complete inventory control system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照这个过程实现一个简单但完整的库存控制系统
- en: See how modular techniques allow you to add functionality to your program while
    minimizing the changes that need to be made
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解模块化技术如何允许您向程序添加功能，同时最小化需要进行的更改
- en: The inventory control system
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库存控制系统
- en: 'Imagine that you have been asked to write a program that allows the user to
    keep track of the company''s inventory—that is, the various items the company
    has available for sale. For each inventory item, you have been asked to keep track
    of the product code and the item''s current location. New items will be added
    as they are received, and existing items will be removed once they have been sold.
    Your program will also need to generate two types of reports: a report listing
    the company''s current inventory, including how many of each type of item there
    are in each location, and a report that is used to re-order inventory items once
    they have been sold.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您被要求编写一个程序，允许用户跟踪公司的库存，即公司可供销售的各种物品。对于每个库存物品，您被要求跟踪产品代码和物品当前的位置。新物品将在收到时添加，已售出的物品将在售出后移除。您的程序还需要生成两种类型的报告：列出公司当前库存的报告，包括每种物品在每个位置的数量，以及用于在物品售出后重新订购库存物品的报告。
- en: 'Looking at these requirements, it is clear that there are three different types
    of information that we will need to store:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这些要求，很明显我们需要存储三种不同类型的信息：
- en: A list of the different types of **products** that the company has for sale.
    For each product type, we will need to know the **product code** (sometimes called
    an SKU number), a **description**, and the **desired number of items** that the
    company should have in its inventory for that type of product.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公司出售的不同类型的产品清单。对于每种产品类型，我们需要知道产品代码（有时称为SKU编号）、描述以及公司应该在库存中拥有的该产品类型的所需数量。
- en: A list of the **locations** where inventory items can be held. These locations
    might be individual shops, warehouses, or storerooms. Alternatively, a location
    might identify a particular shelf or aisle within a shop. For each location, we
    need to have a **location code** and a **description** identifying that location.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 库存物品可以存放的位置清单。这些位置可能是单独的商店、仓库或储藏室。或者，位置可能标识商店内的特定货架或过道。对于每个位置，我们需要有位置代码和标识该位置的描述。
- en: Finally, a list of the **inventory items** that the company currently holds.
    Each inventory item has a **product code** and a **location code**; these identify
    the type of product and where the item is currently held.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，公司当前持有的库存物品清单。每个库存物品都有产品代码和位置代码；这些标识产品类型以及物品当前所在的位置。
- en: 'When running the program, the end user should be able to perform the following
    actions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序时，最终用户应能执行以下操作：
- en: Add a new item to the inventory
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向库存中添加新物品
- en: Remove an item from the inventory
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从库存中移除物品
- en: Generate a report of the current inventory items
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成当前库存物品的报告
- en: Generate a report of the inventory items that need to be re-ordered
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成需要重新订购的库存物品的报告
- en: Quit the program
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出程序
- en: While this program is not too complicated, there are enough features here to
    benefit from a modular design, while still keeping our discussion relatively brief.
    Now that we have taken a look at what our program needs to do and the information
    we need to store, let's start applying modular programming techniques to the design
    of our system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个程序并不太复杂，但这里有足够的功能可以从模块化设计中受益，同时保持我们的讨论相对简洁。既然我们已经看了我们的程序需要做什么以及我们需要存储的信息，让我们开始应用模块化编程技术来设计我们的系统。
- en: Designing the inventory control system
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计库存控制系统
- en: 'If you step back and review our inventory control program''s functionality,
    you can see that there are three fundamental types of activity that this program
    needs to support:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您退后一步，审查我们的库存控制程序的功能，您会发现这个程序需要支持三种基本类型的活动：
- en: Storing information
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储信息
- en: Interacting with the user
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与用户交互
- en: Generating reports
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成报告
- en: While this is very general, this breakdown is helpful because it suggests a
    possible way of organizing our program code. For example, the part of the system
    responsible for storing information could store the lists of products, locations,
    and inventory items and make this information available as required. Similarly,
    the part of the system responsible for interacting with the user could prompt
    the user to choose an action to perform, ask them to select a product code, and
    so on. Finally, the area of the system responsible for generating reports would
    be able to generate each of the desired types of report.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很笼统，但这种分解很有帮助，因为它提出了组织程序代码的可能方式。例如，负责存储信息的系统部分可以存储产品、位置和库存物品的列表，并在需要时提供这些信息。同样，负责与用户交互的系统部分可以提示用户选择要执行的操作，要求他们选择产品代码等。最后，负责生成报告的系统部分将能够生成所需类型的报告。
- en: 'Thinking about the system in this way, it becomes clear that each of these
    three *parts* of the system could be implemented as a separate module:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式思考系统，很明显，系统的这三个*部分*可以分别实现为单独的模块：
- en: The part of the system responsible for storing information could be called the
    **data storage** module
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责存储信息的系统部分可以称为**数据存储**模块
- en: The part of the system responsible for interacting with the user could be called
    the **user interface** module
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责与用户交互的系统部分可以称为**用户界面**模块
- en: The part of the system responsible for generating reports could be called the
    **report generator** module
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责生成报告的系统部分可以称为**报告生成器**模块
- en: 'As the names suggest, each of these modules perform a particular purpose. In
    addition to these special-purpose modules, we are going to need one more part
    to our system: a Python source file that the user executes to start up and run
    the inventory control system. Because this is the part the user actually runs,
    we will call this the **main program**, which is often stored in a Python source
    file named `main.py`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，每个模块都有特定的目的。除了这些专用模块，我们还需要系统的另一个部分：一个Python源文件，用户执行以启动和运行库存控制系统。因为这是用户实际运行的部分，我们将称其为**主程序**，通常存储在名为`main.py`的Python源文件中。
- en: 'We now have four parts to our system: three modules plus a main program. Each
    of these parts will have a particular job to do, and the various parts will often
    interact to perform a particular function. For example, the report generator module
    will need to obtain a list of the available product codes from the data storage
    module. These various interactions are represented by arrows in the following
    diagram:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的系统有四个部分：三个模块加上一个主程序。每个部分都将有特定的工作要做，各个部分通常会相互交互以执行特定的功能。例如，报告生成器模块将需要从数据存储模块获取可用产品代码的列表。这些各种交互在下图中用箭头表示：
- en: '![Designing the inventory control system](graphics/B05012_2_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![设计库存控制系统](graphics/B05012_2_01.jpg)'
- en: Now that we have an idea of the overall structure for our program, let's take
    a closer look at each of these four parts to see how they will work.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对程序的整体结构有了一个概念，让我们更仔细地看看这四个部分中的每一个是如何工作的。
- en: The data storage module
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据存储模块
- en: 'This module will be responsible for storing all of our program''s data. We
    already know that we''ll need to store three types of information: a list of **products**,
    a list of **locations**, and a list of **inventory items**.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块将负责存储我们程序的所有数据。我们已经知道我们需要存储三种类型的信息：**产品**列表，**位置**列表和**库存项目**列表。
- en: 'To keep our program as simple as possible, we will make two major design decisions
    regarding the data storage module:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的程序尽可能简单，我们将就数据存储模块做出两个重要的设计决定：
- en: The lists of products and locations will be hardwired into our program
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品和位置列表将被硬编码到我们的程序中
- en: We will hold the list of inventory items in memory and save it to disk whenever
    the list changes
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在内存中保存库存项目列表，并在列表更改时将其保存到磁盘上
- en: A more sophisticated implementation of our inventory control system would store
    this information in a database and allow the user to view and edit the lists of
    product codes and locations. In our case, however, we are more interested in the
    overall structure of our program, so we want to keep the implementation as simple
    as possible.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的库存控制系统的更复杂的实现会将这些信息存储在数据库中，并允许用户查看和编辑产品代码和位置列表。然而，在我们的情况下，我们更关心程序的整体结构，所以我们希望尽可能简单地实现。
- en: 'While the list of product codes will be hardwired, we don''t necessarily want
    to build this list into the data storage module itself. The data storage module
    is responsible for storing and retrieving information—it isn''t the data storage
    module''s job to define the list of product codes. Because of this, we are going
    to need a function within the data storage module that can be called to set the
    list of product codes. This function will look like the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然产品代码列表将被硬编码，但我们不一定希望将此列表构建到数据存储模块本身中。数据存储模块负责存储和检索信息，而不是定义产品代码列表的工作。因此，我们需要在数据存储模块中添加一个函数，用于设置产品代码列表。此函数将如下所示：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ve already decided that for each product, we want to store the **product
    code**, a **description**, and the **desired number of items** that the user wants
    to keep in their inventory for that type of product. To support this, we''re going
    to define the list of products (as supplied in the `products` parameter to our
    `set_products()` function) as a list of `(code, description, desired_number)`
    tuples. For example, our list of products might look something like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经决定，对于每种产品，我们希望存储**产品代码**，**描述**和用户希望保留的**物品数量**。为了支持这一点，我们将定义产品列表（作为我们`set_products()`函数中的`products`参数提供）为`(code,
    description, desired_number)`元组的列表。例如，我们的产品列表可能如下所示：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the list of products have been defined, we can provide a function to return
    this list as needed:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦产品列表被定义，我们可以提供一个函数根据需要返回此列表：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This would simply return the list of products, allowing your code to work with
    this list as needed. For example, you can scan through the list of products using
    the following Python code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将简单地返回产品列表，允许您的代码根据需要使用此列表。例如，您可以使用以下Python代码扫描产品列表：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These two functions allow us to define the (hardwired) list of products and
    retrieve this list whenever we need it. Let's now define the equivalent two functions
    for the list of locations.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数允许我们定义（硬编码）产品列表，并在需要时检索此列表。现在让我们为位置列表定义相应的两个函数。
- en: 'First, we need a function to set the hardwired list of locations:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个函数来设置硬编码的位置列表：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each item in the `locations` list will be a `(code, description)` tuple, where
    `code` is the code for a location and `description` is a string describing the
    location so that the user knows where it is.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`locations`列表中的每个项目将是一个`(code, description)`元组，其中`code`是位置的代码，`description`是描述位置的字符串，以便用户知道它在哪里。'
- en: 'We then need a function to retrieve this list of locations as needed:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要一个函数根据需要检索位置列表：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once again, this returns the list of locations, allowing us to work with these
    locations as required.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 再次返回位置列表，允许我们根据需要处理这些位置。
- en: We now need to decide on how the data storage module will allow the user to
    store and retrieve the list of inventory items. An inventory item is defined as
    a product code plus a location code. In other words, an inventory item is a particular
    type of product at a particular location.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要决定数据存储模块将如何允许用户存储和检索库存项目列表。库存项目被定义为产品代码加上位置代码。换句话说，库存项目是特定类型的产品在特定位置。
- en: 'To retrieve the list of inventory items, we''ll use the following function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索库存项目列表，我们将使用以下函数：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Following the design we used for the `products()` and `locations()` functions,
    the `items()` function will return a list of the inventory items, where each inventory
    item is a `(product_code, location_code)` tuple.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循我们为`products()`和`locations()`函数使用的设计，`items()`函数将返回一个库存项目列表，其中每个库存项目都是一个`(product_code,
    location_code)`元组。
- en: 'Unlike the lists of products and locations, however, the list of inventory
    items will not be hardwired: the user will be able to add and remove inventory
    items. To support this, we''re going to need two more functions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与产品和位置列表不同，库存项目列表不会被硬编码：用户可以添加和删除库存项目。为了支持这一点，我们需要两个额外的函数：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There is only one more part of our data storage module that we need to design:
    since we know that we''ll be storing the list of inventory items in memory and
    saving them to disk as required, we''re going to need some way of loading the
    inventory items from disk into memory when the program starts. To support this,
    we''re going to define an **initialization function** for our module:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设计数据存储模块的最后一个部分：因为我们将在内存中存储库存项目列表，并根据需要将它们保存到磁盘，所以当程序启动时，我们需要一种方式将库存项目从磁盘加载到内存中。为了支持这一点，我们将为我们的模块定义一个**初始化函数**：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ve now decided on a total of eight functions for the data storage module.
    These eight functions make up the **public interface** for our module. In other
    words, the other parts of the system will *only* interact with our module using
    these eight functions:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经决定了数据存储模块的总共八个函数。这八个函数构成了我们模块的**公共接口**。换句话说，系统的其他部分将*只能*使用这八个函数与我们的模块进行交互：
- en: '![The data storage module](graphics/B05012_2_02.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![数据存储模块](graphics/B05012_2_02.jpg)'
- en: 'Notice the process we went through here: we started by looking at what our
    module needed to do (in this case, storing and retrieving information) and then
    designed the module''s public interface based on those requirements. For the first
    seven functions, we used our business requirements to help us design the interface,
    while for the final function, `init()`, we used our knowledge of how the module
    will work internally to change the interface so that the module can do its job.
    This is a common way of working: both the business requirements and the technical
    requirements will help shape the module''s interface and how it interacts with
    the rest of the system.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在这里经历的过程：我们首先看了我们的模块需要做什么（在这种情况下，存储和检索信息），然后根据这些要求设计了模块的公共接口。对于前七个函数，我们使用业务需求来帮助我们设计接口，而对于最后一个函数`init()`，我们使用了我们对模块内部工作方式的知识来改变接口，以便模块能够完成其工作。这是一种常见的工作方式：业务需求和技术需求都将帮助塑造模块的接口以及它如何与系统的其他部分交互。
- en: Now that we've designed our data storage module, let's repeat the process for
    the other modules in our system.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设计了我们的数据存储模块，让我们为系统中的其他模块重复这个过程。
- en: The user interface module
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户界面模块
- en: The user interface module will be responsible for interacting with the user.
    This includes asking the user for information, as well as displaying information
    on the screen. To keep things simple, we will use a simple text-based interface
    for our inventory control system, using `print()` statements to display information
    and `input()` to ask the user to enter something.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面模块将负责与用户进行交互。这包括向用户询问信息，以及在屏幕上显示信息。为了保持简单，我们将为我们的库存控制系统使用一个简单的基于文本的界面，使用`print()`语句来显示信息，使用`input()`来要求用户输入内容。
- en: A more sophisticated implementation of our inventory control system would use
    a graphical user interface with windows, menus, and dialog boxes. Doing this would
    make the inventory control system much more complicated and is well beyond the
    scope of what we are trying to achieve here. However, because of the modular design
    of the system, if we were to rewrite the user interface to use menus, windows,
    and the like, we would only be changing this one module—the rest of the system
    would be unaffected.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的库存控制系统的更复杂的实现将使用带有窗口、菜单和对话框的图形用户界面。这样做会使库存控制系统变得更加复杂，远远超出了我们在这里尝试实现的范围。然而，由于系统的模块化设计，如果我们重新编写用户界面以使用菜单、窗口等，我们只需要更改这一个模块，而系统的其他部分将不受影响。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is actually a slight oversimplification. Replacing a text-based interface
    with a GUI requires many changes to the system, and would probably require us
    to change the module's public functions slightly, just like we had to add an `init()`
    function to the data storage module to allow for the way it worked internally.
    However, because of the modular way we're designing our system, the other modules
    would not be affected if we rewrote the user interface module to use a GUI.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个轻微的过度简化。用GUI替换基于文本的界面需要对系统进行许多更改，并且可能需要我们稍微更改模块的公共函数，就像我们不得不向数据存储模块添加`init()`函数以允许其内部工作方式一样。但是，由于我们正在设计系统的模块化方式，如果我们重写用户界面模块以使用GUI，其他模块将不受影响。
- en: 'Let''s think about the various tasks our inventory control system needs to
    perform from the point of view of the user''s interaction with the system:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从用户与系统交互的角度来考虑库存控制系统需要执行的各种任务：
- en: The user needs to be able to select an action to perform.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户需要能够选择要执行的操作。
- en: When the user wants to add a new inventory item, we need to prompt the user
    for the details of the new item.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户想要添加新的库存项目时，我们需要提示用户输入新项目的详细信息。
- en: When the user wants to remove an inventory item, we need to prompt the user
    for the details of the inventory item to remove.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户想要移除库存项目时，我们需要提示用户输入要移除的库存项目的详细信息。
- en: When the user wishes to generate a report, we need to be able to display the
    contents of the report to the user.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户希望生成报告时，我们需要能够向用户显示报告的内容。
- en: 'Let''s work through these interactions one at a time:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个解决这些交互：
- en: 'To select an action to perform, we''ll have a `prompt_for_action()` function
    which returns a string identifying the action that the user wishes to perform.
    Let''s define the codes that this function can return for the various actions
    the user can perform:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要选择要执行的操作，我们将有一个`prompt_for_action()`函数，它返回一个标识用户希望执行的操作的字符串。让我们定义此函数可以返回的代码，以执行用户可以执行的各种操作：
- en: '| Action | Action code |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 操作代码 |'
- en: '| --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Add an inventory item | `ADD` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 添加库存项目 | `ADD` |'
- en: '| Remove an inventory item | `REMOVE` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 移除库存项目 | `REMOVE` |'
- en: '| Generate a report of the current inventory items | `INVENTORY_REPORT` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 生成当前库存项目的报告 | `INVENTORY_REPORT` |'
- en: '| Generate a report of the inventory items that need to be re-ordered | `REORDER_REPORT`
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 生成需要重新订购的库存项目报告 | `REORDER_REPORT` |'
- en: '| Quit the program | `QUIT` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 退出程序 | `QUIT` |'
- en: 'To add an inventory item, the user will need to be prompted for the details
    of the new item. Because an inventory item is defined as a given product at a
    given location, we actually need to prompt the user to choose both the product
    and the location for the new item. To prompt the user to select a product, we
    will use the following function:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加库存项目，用户需要提示输入新项目的详细信息。因为库存项目被定义为给定位置的给定产品，实际上我们需要提示用户选择新项目的产品和位置。为了提示用户选择产品，我们将使用以下函数：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The user will be shown a list of the available products and then choose an item
    from the list. If they cancel, `prompt_for_product()` will return `None`. Otherwise,
    it will return the product code for the selected product.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将看到可用产品的列表，然后从列表中选择一个项目。如果他们取消，`prompt_for_product()`将返回`None`。否则，它将返回所选产品的产品代码。
- en: 'Similarly, to prompt the user to select a location, we will define the following
    function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '同样，为了提示用户选择位置，我们将定义以下函数： '
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once again, this displays a list of the available locations, and the user can
    choose a location from the list. If they cancel, we return `None`. Otherwise,
    we return the location code for the selected location.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这显示了可用位置的列表，用户可以从列表中选择一个位置。如果他们取消，我们返回`None`。否则，我们返回所选位置的位置代码。
- en: Using these two functions, we can ask the user to identify a new inventory item,
    and then we use the data storage module's `add_item()` function to add it to the
    list.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个函数，我们可以要求用户标识新的库存项目，然后我们使用数据存储模块的`add_item()`函数将其添加到列表中。
- en: 'Because we are implementing this as a simple text-based system, the process
    of removing an inventory item is almost identical to the process used to add an
    item: the user will be prompted for the product and location, and the inventory
    item at that location will be removed. Because of this, we won''t need any additional
    functions to implement this feature.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们正在实现这个简单的基于文本的系统，删除库存项目的过程几乎与添加项目的过程相同：用户将被提示输入产品和位置，然后将删除该位置的库存项目。因此，我们不需要任何额外的函数来实现这个功能。
- en: 'To generate a report, we will simply call the report generator module to do
    the work, and then we display the resulting report to the user. To keep things
    simple, our reports won''t take any parameters, and the resulting report will
    be displayed in plain-text format. Because of this, the only user interface function
    that we will need is a function to display the plain-text contents of the report:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要生成报告，我们将简单地调用报告生成器模块来完成工作，然后将生成的报告显示给用户。为了保持简单，我们的报告不会带任何参数，并且生成的报告将以纯文本格式显示。因此，我们唯一需要的用户界面函数是一个函数，用于显示报告的纯文本内容：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `report` parameter will simply be a list of strings containing the generated
    report. All the `show_report()` function needs to do is print out these strings,
    one at a time, to show the contents of the report to the user.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`report`参数将简单地是一个包含生成报告的字符串的列表。`show_report()`函数需要做的就是逐个打印这些字符串，以向用户显示报告的内容。'
- en: This completes our design for the user interface module. There are a total of
    four public functions which we will need to implement for this module.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对用户界面模块的设计。我们需要为此模块实现四个公共函数。
- en: The report generator module
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 报告生成器模块
- en: 'The report generator module is responsible for generating reports. Since there
    are two types of report that we need to be able to generate, we are simply going
    to have two public functions in the report generator module, one for each type
    of report:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 报告生成器模块负责生成报告。由于我们需要能够生成两种类型的报告，所以我们只需在报告生成器模块中有两个公共函数，每种报告一个：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Each of these functions will generate a report of the given type, returning
    the report's contents as a list of strings. Note that there are no parameters
    to these functions; because we are keeping things as simple as possible, the reports
    won't use any parameters to control how they are to be generated.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数中的每一个都将生成给定类型的报告，将报告内容作为字符串列表返回。请注意，这些函数没有参数；因为我们尽可能保持简单，报告不会使用任何参数来控制它们的生成方式。
- en: The main program
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主程序
- en: The main program isn't a module. Instead, it is a standard Python source file
    that the user runs to start the system. The main program will import the various
    modules it needs, and call the functions we have defined to do all the work. In
    a sense, our main program is the glue that binds together all the other parts
    of the system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序不是一个模块。相反，它是一个标准的Python源文件，用户运行以启动系统。主程序将导入它需要的各种模块，并调用我们定义的函数来完成所有工作。在某种意义上，我们的主程序是将系统的所有其他部分粘合在一起的胶水。
- en: 'In Python, when a source file is intended to be run (as opposed to being imported
    and used by other modules or from the Python command line), it is common to use
    the following structure for the source file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，当一个源文件打算被运行（而不是被其他模块导入和使用，或者从Python命令行使用）时，通常使用以下结构的源文件：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: All of the program's logic is written inside the `main()` function, which is
    then called by the final two lines in the file. The `if __name__ == "__main__"`
    line is a piece of Python magic that basically means *if this program is being
    run*. In other words, if the user is running this program, call the `main()` function
    to do all the work.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 所有程序逻辑都写在`main()`函数内部，然后由文件中的最后两行调用。`if __name__ == "__main__"`行是Python的一个魔术，基本上意味着*如果正在运行这个程序*。换句话说，如果用户正在运行这个程序，调用`main()`函数来完成所有工作。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We could put all the program's logic beneath the `if __name__ == "__main__"`
    statement, but there are some advantages to putting our program's logic in a separate
    function. By using a separate function, we can simply return from this function
    when we want to exit. It also makes error handling easier, and the code is better
    organized because our main program code is separate from the code that checks
    whether we are actually running the program.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将所有程序逻辑放在`if __name__ == "__main__"`语句下面，但将程序逻辑放在一个单独的函数中有一些优点。通过使用单独的函数，我们可以在想要退出时简单地从这个函数返回。这也使得错误处理更容易，代码组织得更好，因为我们的主程序代码与检查我们是否实际运行程序的代码是分开的。
- en: We are going to use this design for our main program, putting all the actual
    functionality within a single function called `main()`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个设计作为我们的主程序，将所有实际功能放在一个名为`main()`的函数中。
- en: 'Our `main()` function is going to do the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`main()`函数将执行以下操作：
- en: Call the `init()` function for the various modules which need to be initialized.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用需要初始化的各个模块的`init()`函数。
- en: Provide the hardwired lists of products and locations.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供产品和位置的硬连线列表。
- en: Ask the user interface module to prompt the user for a command.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要求用户界面模块提示用户输入命令。
- en: Respond to the command entered by the user.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应用户输入的命令。
- en: Steps 3 and 4 will be repeated indefinitely until the user quits.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤3和4将无限重复，直到用户退出。
- en: Implementing the inventory control system
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施库存控制系统
- en: Now that we have a good idea of the overall structure for our system, what our
    various modules will be, and what functionality they will provide, it's time for
    us to start implementing the system. Let's start with the data storage module.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对系统的整体结构有了一个很好的想法，我们的各种模块将是什么，它们将提供什么功能，是时候开始实施系统了。让我们从数据存储模块开始。
- en: Implementing the data storage module
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施数据存储模块
- en: Create a directory somewhere convenient where you can store the source code
    for the inventory control system. You might want to call this directory `inventoryControl`
    or something similar.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个方便的地方创建一个目录，可以在其中存储库存控制系统的源代码。您可能想将此目录命名为`inventoryControl`或类似的名称。
- en: Inside this directory, we will place our various modules and files. Start by
    creating a new, empty Python source file named `datastorage.py`. This Python source
    file will hold our data storage module.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个目录中，我们将放置各种模块和文件。首先创建一个名为`datastorage.py`的新的空Python源文件。这个Python源文件将保存我们的数据存储模块。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When selecting the name for our modules, we are following the Python convention
    of using all lowercase letters. You might find this a bit awkward at first, but
    it soon becomes easy to read. Please refer to [https://www.python.org/dev/peps/pep-0008/#package-and-module-names](https://www.python.org/dev/peps/pep-0008/#package-and-module-names)
    for more information about these naming conventions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的模块选择名称时，我们遵循Python使用所有小写字母的惯例。起初你可能会觉得有点笨拙，但很快就会变得容易阅读。有关这些命名约定的更多信息，请参阅[https://www.python.org/dev/peps/pep-0008/#package-and-module-names](https://www.python.org/dev/peps/pep-0008/#package-and-module-names)。
- en: 'We already know that we are going to need eight different functions to make
    up the public interface to this module, so go ahead and add the following Python
    code to this module:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道我们将需要八个不同的函数来构成这个模块的公共接口，所以继续添加以下Python代码到这个模块中：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `pass` statements allow us to leave the functions empty—these are just placeholders
    for the code we are going to write.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`pass`语句允许我们将函数留空-这些只是我们将要编写的代码的占位符。'
- en: Let's now implement the `init()` function. This initializes the data storage
    module when the system is run. Because we are holding the list of inventory items
    in memory and saving them to disk when they change, our `init()` function is going
    to have to load the inventory items from a file on disk back into memory so that
    they will be available when we need them. To do this, we'll define a private function,
    which we'll call `_load_items()`, and call this from our `init()` function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现`init()`函数。这在系统运行时初始化数据存储模块。因为我们将库存物品列表保存在内存中，并在更改时将其保存到磁盘上，我们的`init()`函数将需要从磁盘上的文件中加载库存物品到内存中，以便在需要时可用。为此，我们将定义一个名为`_load_items()`的私有函数，并从我们的`init()`函数中调用它。
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that a leading underscore means that something is private. This means
    that the `_load_items()` function won't be part of the public interface for our
    module.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，前导下划线表示某些内容是私有的。这意味着`_load_items()`函数不会成为我们模块的公共接口的一部分。
- en: 'Change your definition of the `init()` function to look like the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将`init()`函数的定义更改为以下内容：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `_load_items()` function is going to load the list of inventory items from
    a file on disk into a private global variable, which we''ll call `_items`. Let''s
    go ahead and implement this function now, by adding the following to the end of
    the module:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`_load_items()`函数将从磁盘上的文件加载库存物品列表到一个名为`_items`的私有全局变量中。让我们继续实现这个函数，通过将以下内容添加到模块的末尾：'
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that we store the list of inventory items in a file named `items.json`,
    and that we are using the `json` module to convert the `_items` list from a text
    file into a Python list.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将库存物品列表存储在名为`items.json`的文件中，并且我们正在使用`json`模块将`_items`列表从文本文件转换为Python列表。
- en: Tip
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: JSON is an excellent way of saving and loading Python data structures, and the
    resulting text file is easy to read. Since the `json` module is built into the
    Python Standard Library, we might as well make use of it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是保存和加载Python数据结构的绝佳方式，生成的文本文件易于阅读。由于`json`模块内置在Python标准库中，我们不妨利用它。
- en: 'Because we are now using some modules from the Python Standard Library, you''ll
    need to add the following `import` statements to the top of your module:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们现在正在使用Python标准库中的一些模块，您需要将以下`import`语句添加到模块的顶部：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'While we''re at it, let''s write a function to save the list of inventory items
    to disk. Add the following to the end of your module:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 趁热打铁，让我们编写一个函数将库存物品列表保存到磁盘上。将以下内容添加到模块的末尾：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Since we have loaded the list of inventory items into a private global variable
    named `_items`, we can now implement the `items()` function to make this data
    available. Edit your definition of the `items()` function to look like the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已将库存物品列表加载到名为`_items`的私有全局变量中，我们现在可以实现`items()`函数以使这些数据可用。编辑`items()`函数的定义，使其看起来像下面这样：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s now implement the `add_item()` and `remove_item()` functions to let
    the rest of the system manipulate our list of inventory items. Edit these functions
    so they look like the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现`add_item()`和`remove_item()`函数，让系统的其余部分操作我们的库存物品列表。编辑这些函数，使其看起来像下面这样：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that the `remove_item()` function returns `True` if the item was successfully
    removed and `False` otherwise; this tells the rest of the system if an attempt
    to remove an inventory item was successful or not.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`remove_item()`函数如果成功移除该物品则返回`True`，否则返回`False`；这告诉系统的其余部分尝试移除库存物品是否成功。
- en: We've now implemented all the functions within the `datastorage` module that
    relate to inventory items. Next, we'll implement the product-related functions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经实现了`datastorage`模块中与库存物品相关的所有函数。接下来，我们将实现与产品相关的函数。
- en: 'Since we know we''re going to hardwire the list of products, the `set_products()`
    function is going to be trivial:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道我们将硬编码产品列表，`set_products()`函数将是微不足道的：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We simply store the list of products in a private global variable named `_products`.
    We can then make this list available via the `products()` function:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将产品列表存储在名为`_products`的私有全局变量中。然后，我们可以通过`products()`函数使这个列表可用：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Similarly, we can now implement the `set_locations()` function to set the hardwired
    list of locations:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们现在可以实现`set_locations()`函数来设置硬编码的位置列表：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we can implement the `locations()` function to make this information
    available:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以实现`locations()`函数以使这些信息可用：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This completes our implementation of the `datastorage` module.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对`datastorage`模块的实现。
- en: Implementing the user interface module
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现用户界面模块
- en: As mentioned earlier, the user interface module is going to be kept as simple
    as possible, using `print()` and `input()` statements to interact with the user.
    In a more comprehensive implementation of this system, we would use a graphical
    user interface (GUI) to display and ask the user for information, but we want
    to keep our code as simple as we can.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，用户界面模块将尽可能保持简单，使用`print()`和`input()`语句与用户交互。在这个系统的更全面的实现中，我们将使用图形用户界面（GUI）来显示并询问用户信息，但我们希望尽可能保持我们的代码简单。
- en: 'With this in mind, let''s go ahead and implement the first of our user interface
    module functions. Create a new Python source file named `userinterface.py` to
    hold our user interface module, and add the following to this file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，让我们继续实现我们的用户界面模块函数中的第一个。创建一个名为`userinterface.py`的新Python源文件来保存我们的用户界面模块，并将以下内容添加到此文件中：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, we prompt the user to type a letter corresponding to each action,
    displaying the list of available actions and returning a string which identifies
    the action the user selected. This is not a great way of implementing a user interface,
    but it works.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们提示用户输入与每个操作对应的字母，显示可用操作列表，并返回一个标识用户选择的操作的字符串。这不是实现用户界面的好方法，但它有效。
- en: 'The next function we want to implement is `prompt_for_product()`, which asks
    the user to select a product from the list of available product codes. To do this,
    we are going to have to ask the data storage module for the list of products.
    Add the following code to the end of your `userinterface.py` module:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要实现的函数是`prompt_for_product()`，它要求用户从可用产品代码列表中选择一个产品。为此，我们将不得不要求数据存储模块提供产品列表。将以下代码添加到你的`userinterface.py`模块的末尾：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this function, we display a list of the products along with a number beside
    each product. The user then enters the number for the desired product, and we
    return the product code to the caller. If the user didn't enter anything, we return
    `None`—this lets the user press the *Enter* key without entering anything if they
    don't want to proceed.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们显示产品列表，并在每个产品旁边显示一个数字。然后用户输入所需产品的数字，我们将产品代码返回给调用者。如果用户没有输入任何内容，我们返回`None`——这样用户可以在不想继续的情况下按下*Enter*键而不输入任何内容。
- en: 'While we''re at it, let''s implement the equivalent function which asks the
    user to identify a location:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 趁热打铁，让我们实现一个相应的函数，要求用户确定一个位置：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once again, this function displays a number beside each location and asks the
    user to enter the number for the desired location. We then return the location
    code for the selected location, or `None` if the user cancelled.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这个函数显示每个位置旁边的数字，并要求用户输入所需位置的数字。然后我们返回所选位置的位置代码，如果用户取消，则返回`None`。
- en: 'Since these two functions make use of the data storage module, we''re going
    to have to add the following `import` statement to the top of our module:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个函数使用了数据存储模块，我们需要在我们的模块顶部添加以下`import`语句：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There is only one more function we need to implement: the `show_report()` function.
    Let''s do this now:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要实现一个函数：`show_report()`函数。让我们现在这样做：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since we are implementing this using a text interface, this function is almost
    ludicrously simple. It does serve an important purpose though: by implementing
    the process of showing a report as a separate function, we can re-implement this
    function to show the report in a more useful way (for example, displaying it in
    a window within a GUI) without affecting the rest of the system.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用文本界面来实现这个功能，这个函数几乎是荒谬地简单。不过它确实有一个重要的目的：通过将显示报告的过程作为一个单独的函数来实现，我们可以重新实现这个函数，以更有用的方式显示报告（例如，在GUI中的窗口中显示），而不会影响系统的其余部分。
- en: Implementing the report generator module
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现报告生成器模块
- en: 'The report generator module is going to have two public functions, one to generate
    each type of report. Without further ado, let''s implement this module, which
    we will store in a Python source file named `reportgenerator.py`. Create this
    file, and enter the following into it:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 报告生成器模块将有两个公共函数，一个用于生成每种类型的报告。话不多说，让我们实现这个模块，我们将把它存储在一个名为`reportgenerator.py`的Python源文件中。创建这个文件，并输入以下内容：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Don't worry too much about the details of these functions. As you can see, we
    take the list of inventory items, the list of products, and the list of locations
    from the data storage module, and generate a simple text-based report based on
    the contents of these lists.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 不要太担心这些函数的细节。正如你所看到的，我们从数据存储模块获取库存项目列表、产品列表和位置列表，并根据这些列表的内容生成一个简单的基于文本的报告。
- en: Implementing the main program
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现主程序
- en: 'The final part of the system we need to implement is our main program. Create
    another Python source file named `main.py`, and enter the following into this
    file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的系统的最后一部分是我们的主程序。创建另一个名为`main.py`的Python源文件，并将以下内容输入到这个文件中：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is just the overall template for our main program: we import the various
    modules we created, define a `main()` function where all the work will be done,
    and call it when the program is run. We now need to write our `main()` function.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们主程序的总体模板：我们导入我们创建的各种模块，定义一个`main()`函数，所有的工作都将在这里完成，并在程序运行时调用它。现在我们需要编写我们的`main()`函数。
- en: 'Our first task is to initialize the other modules and define the hardwired
    lists of products and locations. Let''s do this now, by rewriting our `main()`
    function to look like the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个任务是初始化其他模块并定义产品和位置的硬编码列表。让我们现在这样做，通过重写我们的`main()`函数，使其看起来像下面这样：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we need to ask the user for the action they wish to perform, and then
    respond appropriately. We''ll start by asking the user for the action, using a
    `while` statement so that this can be done repeatedly:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要询问用户他们希望执行的操作，然后做出适当的响应。我们将从询问用户操作开始，使用`while`语句，以便可以重复执行这个操作：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We next need to respond to the action that the user selected. Obviously, we
    need to do this for each possible action. Let''s start with the `QUIT` action:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要响应用户选择的操作。显然，我们需要针对每种可能的操作进行这样的操作。让我们从“退出”操作开始：
- en: The `break` statement will exit the `while True` statement, which has the effect
    of leaving the `main()` function and shutting down the program.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`语句将退出`while True`语句，这样就会离开`main()`函数并关闭程序。'
- en: 'Next, we want to implement the `ADD` action:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要实现“添加”操作：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice that we call the user interface functions to prompt the user for a product
    and then a location code, only proceeding if the function didn't return `None`.
    This means we only prompt for a location or add the item if the user didn't cancel.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们调用用户界面函数提示用户输入产品，然后输入位置代码，只有在函数没有返回`None`的情况下才继续。这意味着我们只有在用户没有取消的情况下才提示位置或添加项目。
- en: 'We can now implement the equivalent function for the `REMOVE` action:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现“删除”操作的等效函数了：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is almost identical to the logic for adding an item, with one exception:
    the `datastorage.remove_item()` function can fail (by returning `False`) if there
    is no inventory item for that product and location code. As the comment beside
    the `pass` statement suggests, we are going to have to do something when this
    happens.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与添加项目的逻辑完全相同，只有一个例外：`datastorage.remove_item()`函数可能会失败（返回`False`），如果该产品和位置代码没有库存项目。正如`pass`语句旁边的注释所建议的那样，当这种情况发生时，我们将不得不做一些事情。
- en: 'We have now reached a very common point in the modular programming process:
    we designed all the functionality that we thought we needed, but then discovered
    that we missed something. When the user attempts to remove a non-existent inventory
    item, we will want to display an error message so the user knows what went wrong.
    Because all user interaction takes place within the `userinterface.py` module,
    we will want to add this functionality to that module.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经达到了模块化编程过程中非常常见的一个点：我们设计了所有我们认为需要的功能，但后来发现漏掉了一些东西。当用户尝试移除一个不存在的库存项目时，我们希望显示一个错误消息，以便用户知道出了什么问题。因为所有用户交互都发生在`userinterface.py`模块中，我们希望将这个功能添加到该模块中。
- en: 'Let''s do that now. Go back and edit the `userinterface.py` module, and add
    the following function to the end:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们这样做。回到编辑`userinterface.py`模块，并在末尾添加以下函数：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once again, this is an embarrassingly simple function, but it lets us keep
    all user interaction within the `userinterface` module (and allows for the possibility
    of rewriting our program later on to use a GUI). Let''s now replace that `pass`
    statement within our `main.py` program with some appropriate error-handling code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是一个令人尴尬的简单函数，但它让我们可以将所有用户交互保持在`userinterface`模块中（并且允许以后重写我们的程序以使用GUI）。现在让我们用适当的错误处理代码替换`main.py`程序中的`pass`语句：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Having to go back and change the functionality for a module is extremely common.
    Fortunately, modular programming makes this process much more self-contained,
    so you're less likely to get side-effects and other errors when you do this.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 不得不回去更改模块的功能是非常常见的。幸运的是，模块化编程使这个过程更加自包含，因此在这样做时，您不太可能出现副作用和其他错误。
- en: 'Now that the user can add and remove inventory items, there are just two more
    actions we need to implement: the `INVENTORY_REPORT` action, and the `REORDER_REPORT`
    action. For both of these actions, all we need to do is call the appropriate report
    generator function to generate the report, followed by the user interface module''s
    `show_report()` function to display the results. Let''s do this now, by adding
    the following code to the end of our `main()` function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户可以添加和移除库存项目，我们只需要实现另外两个操作：`INVENTORY_REPORT`操作和`REORDER_REPORT`操作。对于这两个操作，我们只需要调用适当的报告生成器函数来生成报告，然后调用用户界面模块的`show_report()`函数来显示结果。现在让我们通过将以下代码添加到我们的`main()`函数的末尾来实现这一点：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This completes the implementation of our `main()` function, and indeed the implementation
    of our entire inventory control system. Go ahead and run it. Try entering a few
    inventory items, removing an inventory item or two, and generating both types
    of report. If you have entered the code as presented in this book or downloaded
    the example code for this chapter, the program should work, giving you a simple
    but complete inventory control system—but more importantly, showing you how to
    implement a program using modular programming techniques.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们`main()`函数的实现，实际上也完成了我们整个库存控制系统的实现。继续运行它。尝试输入一些库存项目，移除一两个库存项目，并生成两种类型的报告。如果您按照本书中提供的代码输入或下载了本章的示例代码，程序应该可以正常工作，为您提供一个简单但完整的库存控制系统，更重要的是，向您展示如何使用模块化编程技术实现程序。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we designed and implemented a non-trivial program to keep track
    of a company's inventory. Using the divide-and-conquer approach, we split the
    program into individual modules and then looked at the functionality that each
    module would need to provide. This led us to a more detailed design of the functions
    within each module, and we were then able to implement the overall system one
    step at a time. We discovered that some functionality had been overlooked and
    had to be added after the design was complete, and saw how modular programming
    makes it less likely for these types of changes to break your system. Finally,
    we had a quick play with the inventory control system to make sure it works.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设计并实现了一个非平凡的程序来跟踪公司的库存。使用分而治之的方法，我们将程序分成单独的模块，然后查看每个模块需要提供的功能。这使我们更详细地设计了每个模块内的函数，并且我们随后能够一步一步地实现整个系统。我们发现一些功能被忽视了，需要在设计完成后添加，并且看到模块化编程如何使这些类型的更改不太可能破坏您的系统。最后，我们快速测试了库存控制系统，确保它可以正常工作。
- en: In the next chapter, we will learn more about the nuts and bolts of how modules
    and packages work within Python.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更多地了解Python中模块和包的工作原理。
