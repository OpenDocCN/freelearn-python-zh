- en: Chapter 2. Responding to Events
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 响应事件
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Handling events
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理事件
- en: Understanding event propagation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解事件传播
- en: Handling Key events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理键事件
- en: Using UpdateUI events
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用UpdateUI事件
- en: Playing with the mouse
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操纵鼠标
- en: Creating custom event classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义事件类
- en: Managing event handlers with EventStack
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 EventStack 管理事件处理器
- en: Validating input with validators
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用验证器验证输入
- en: Handling Apple events
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 Apple 事件
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In an event-driven system, events are used to connect actions within the framework
    to callback functions that are linked to those events. Applications that are built
    upon an event-driven framework make use of these events in order to know when
    to respond to actions that are initiated by the user or the system. In a user
    interface, events are the way to know when a button is clicked, when a menu has
    been selected, or any other one of a wide variety of actions that a user could
    take while interacting with the applications interface.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动系统中，事件被用来将框架内的动作与那些事件相关联的回调函数连接起来。基于事件驱动框架构建的应用程序利用这些事件来确定何时响应由用户或系统发起的动作。在用户界面中，事件是了解何时点击了按钮、选择了菜单或用户在与应用程序界面交互时可能采取的广泛多样的其他动作的方式。
- en: As you can see, knowing how to respond to events that occur during the life
    of an application is a crucial part of creating a functional application. So let's
    dive into the event-driven world of wxPython.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，了解如何应对应用生命周期中发生的事件是创建一个功能应用的关键部分。因此，让我们深入wxPython的事件驱动世界吧。
- en: Handling events
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理事件
- en: wxPython is an event-driven system. The usage of this system is pretty straightforward
    and regular across the framework. The basic patterns of working with events are
    the same regardless of the type of control or event that your application will
    interact with. This recipe will introduce the basics of working in wxPython's
    event system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython是一个事件驱动系统。该系统的使用方法在框架中非常直接且规范。无论你的应用程序将交互的控制或事件类型如何，处理事件的基模式都是相同的。本食谱将介绍在wxPython事件系统中的基本操作方法。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s create a simple `Frame` with two buttons in it to show how to work with
    events:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的`Frame`，其中包含两个按钮，以展示如何处理事件：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The lines of code to take notice of in this recipe are the two `Bind` calls.
    The `Bind` method is used to associate an event handler function with an event
    that may be sent to a control. Events always propagate up the window hierarchy
    and never down. In this example, we bound the button event to the `Frame`, but
    the events will originate from the `Button` objects that are children of the `Panel`.
    The `Frame` object is at the top of the hierarchy containing the `Panel`, which
    in turn contains the two `Buttons`. Because of this, since the event callback
    is not handled by the `Button` or the `Panel`, it will propagate to the `Frame`
    where our `OnButton` handler will be called.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中需要注意的代码行是两个 `Bind` 调用。`Bind` 方法用于将事件处理函数与可能发送到控件的事件关联起来。事件总是沿着窗口层次结构向上传播，而不会向下传播。在这个例子中，我们将按钮事件绑定到了
    `Frame`，但事件将起源于 `Panel` 的子 `Button` 对象。`Frame` 对象位于包含 `Panel` 的层次结构的顶部，而 `Panel`
    又包含两个 `Buttons`。正因为如此，由于事件回调既没有被 `Button` 也没有被 `Panel` 处理，它将传播到 `Frame`，在那里我们的
    `OnButton` 处理程序将被调用。
- en: 'The `Bind` method takes two required parameters:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bind` 方法需要两个必填参数：'
- en: The event binder object (`EVT_FOO`)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件绑定对象 (`EVT_FOO`)
- en: A callable object that takes an event object as its first parameter. This is
    the event handler function that will be called when the event occurs.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接受事件对象作为其第一个参数的可调用对象。这是当事件发生时将被调用的事件处理函数。
- en: The optional parameters are for specifying the originating control to bind the
    event handler to. We bound one handler for each of our buttons in this example
    by specifying the `Button` objects as the third parameter to `Bind`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数用于指定绑定事件处理器的源控件。在这个示例中，我们通过将`Button`对象指定为`Bind`函数的第三个参数，为每个按钮绑定了一个处理器。
- en: '`EVT_BUTTON` is the event binder for when a `Button` is clicked by the user
    of the application. When the first button is clicked, the event handler `OnButton`
    will be called to notify our program that this action occurred. The event object
    will be passed to the handler function as its first parameter. The event object
    has a number of methods that can be used to get information about the event and
    what control it came from. Each event may have different data available, depending
    on the type of event that is related to the type of control it originated from.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`EVT_BUTTON` 是当应用程序用户点击 `Button` 时的事件绑定器。当第一个按钮被点击时，事件处理器 `OnButton` 将被调用以通知我们的程序这一动作已发生。事件对象将作为其第一个参数传递给处理器函数。事件对象有多个方法可以用来获取有关事件及其来源控件的信息。每个事件可能都有不同的数据可用，这取决于与事件来源的控件类型相关的事件类型。'
- en: For our second `Button`, we used a `lambda` function as a shorthand way of creating
    an event-handler function without needing to define a new function. This is a
    handy way of handling events that only need to perform simple actions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第二个`按钮`，我们使用了`lambda`函数作为创建事件处理函数的简写方式，无需定义新的函数。这是一种处理只需执行简单操作的事件的便捷方法。
- en: See also
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Application object* recipe in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with wxPython"), *Getting Started with wxPython* talks about the MainLoop,
    which is at the core of the event system.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. 使用wxPython入门")中的 *应用程序对象* 菜单，*使用wxPython入门* 讲述了主循环，这是事件系统的核心。'
- en: The *Understanding the window hierarchy* recipe in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with wxPython"), *Getting Started with wxPython* describes the window
    containment hierarchy.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. 使用wxPython入门")中的*理解窗口层次结构*配方描述了窗口包含层次结构。'
- en: The *Creating Stock Buttons* recipe in [Chapter 3](ch03.html "Chapter 3. Basic
    Building Blocks of a User Interface"), *Basic Building Blocks of a User Interface*
    explains Buttons in detail.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。用户界面基本构建块")中的 *创建股票按钮* 菜单，*用户界面基本构建块* 详细解释了按钮。'
- en: The *Using a BoxSizer* recipe in [Chapter 7](ch07.html "Chapter 7. Window Layout
    and Design"), *Window Layout and Design* explains how to use the `BoxSizer` class
    to lay out controls.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章。窗口布局与设计")中的*使用BoxSizer布局*配方，*窗口布局与设计*解释了如何使用`BoxSizer`类来布局控件。'
- en: Understanding event propagation
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解事件传播
- en: 'There are two main types of Event Objects in wxPython, each with its own distinct
    behavior:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在wxPython中，主要有两种事件对象，每种都有其独特的行为：
- en: Events
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Command Events
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令事件
- en: Basic `Events` are events that do not propagate upwards in the window hierarchy.
    Instead, they stay local to the window that they were sent to or originated in.
    The second type, `CommandEvents`, are the more common type of events, and differ
    from regular events in that they propagate up the window parental hierarchy until
    they are handled or reach the end of the line at the application object. This
    recipe will explore how to work with, understand, and control the propagation
    of events.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 基本事件（`Events`）是指不会在窗口层次结构中向上传播的事件。相反，它们保持在它们被发送到的或起源的窗口的本地。第二种类型，`CommandEvents`，是更常见的事件类型，它们与常规事件的不同之处在于，它们会沿着窗口父级层次结构向上传播，直到被处理或到达应用程序对象的末尾。本食谱将探讨如何处理、理解和控制事件的传播。
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To explore how events propagate, lets create another simple application:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索事件如何传播，让我们创建另一个简单的应用程序：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Running this will create an application with two buttons on it. Click each of
    the buttons to see how the events propagate differently.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序将创建一个带有两个按钮的应用程序。点击每个按钮以查看事件如何不同地传播。
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The chain of event handlers that will be called starts at the object that the
    event originates from. In this case, it will be one of our two buttons. Each level
    in the window hierarchy of this application has a general event handler bound
    to it, that will receive any button events.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序链的调用将从事件起源的对象开始。在这种情况下，它将是我们的两个按钮之一。此应用程序窗口层次结构的每个级别都绑定了一个通用事件处理程序，它将接收任何按钮事件。
- en: Clicking the first button will show that all of the event handlers get called.
    This is because for the first button we called the event's `Skip` method. Calling
    `Skip` on an event will tell it to continue propagating to the next level of event
    handlers in the hierarchy. This will be apparent, as three statements will be
    printed to the console. On the other hand, clicking the second button will result
    in only one event handler being called, because `Skip` is not called.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 点击第一个按钮将显示所有的事件处理程序都被调用。这是因为对于第一个按钮，我们调用了事件的`Skip`方法。在事件上调用`Skip`将告诉它继续传播到事件处理程序层次结构中的下一级。这将是显而易见的，因为控制台将打印出三条语句。另一方面，点击第二个按钮将只调用一个事件处理程序，因为未调用`Skip`。
- en: See also
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Handling events* recipe in this chapter explains how event handlers work.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*处理事件*菜谱解释了事件处理器是如何工作的。
- en: The *Understanding the window hierarchy* recipe in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with wxPython"), *Getting Started with wxPython* describes the window
    hierarchy that events propagate through.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. 使用wxPython入门")中的*理解窗口层次结构*配方，*使用wxPython入门*描述了事件传播通过的窗口层次结构。'
- en: Handling Key events
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理关键事件
- en: '`KeyEvents` are events that are associated with keyboard actions. Many controls
    can accept keyboard events. Each time that a key is pressed on the keyboard, there
    will be two or three events sent to the control that has the keyboard focus, depending
    on what key was pressed. This recipe will create a simple text editor window,
    in order to demonstrate how to use `KeyEvents` to filter text that is added to
    a `TextCtrl`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyEvents`是与键盘操作相关的事件。许多控件可以接受键盘事件。每次在键盘上按下键时，都会向具有键盘焦点的控件发送两个或三个事件，具体取决于按下了哪个键。本食谱将创建一个简单的文本编辑窗口，以演示如何使用`KeyEvents`来过滤添加到`TextCtrl`中的文本。'
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To see some `KeyEvents` in action, let''s make a simple window that has a `TextCtrl`
    on it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看一些`KeyEvents`的实际应用，让我们创建一个简单的窗口，该窗口上有一个`TextCtrl`：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When typing in this window, it will not allow text to be entered when the *Shift*
    key is pressed and it will turn all vowels into question marks.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当在这个窗口中输入时，按下*Shift*键将不允许输入文本，并且会将所有元音字母转换成问号。
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `KeyEvents` are sent by the system in the following order:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyEvents` 是按照以下顺序由系统发送的：'
- en: '`EVT_KEY_DOWN`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EVT_KEY_DOWN`'
- en: '`EVT_CHAR` (only for keys that have a character associated with them)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EVT_CHAR`（仅适用于与字符相关联的键）'
- en: '`EVT_KEY_UP`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EVT_KEY_UP`'
- en: It's important to notice that we called `Bind` on our `TextCtrl` and not the
    `Frame`. This is necessary because the `KeyEvents` will only be sent to the control
    that has the keyboard focus, which in this window will be `TextCtrl`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们在 `TextCtrl` 上调用了 `Bind` 而不是 `Frame`。这是必要的，因为 `KeyEvents` 只会发送到具有键盘焦点的控件，在这个窗口中将是
    `TextCtrl`。
- en: Each `KeyEvent` has a number of attributes attached to it in order to specify
    what key was pressed and what other modifier keys were held down during the event,
    such as the *Shift, Alt*, and *Ctrl* keys.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `KeyEvent` 都附带有一些属性，用于指定在事件中按下了哪个键以及在此事件期间按下了哪些其他修饰键，例如 *Shift, Alt* 和 *Ctrl*
    键。
- en: Calling `Skip` on the event allows the control to process it and for the next
    handler in the chain to be called. For example, not skipping the event in the
    `EVT_KEY_DOWN` handler will block the `EVT_CHAR` and `EVT_KEY_UP` handlers from
    being called.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件上调用 `Skip` 允许控制处理它，并调用链中的下一个处理器。例如，不在 `EVT_KEY_DOWN` 处理器中跳过事件将阻止 `EVT_CHAR`
    和 `EVT_KEY_UP` 处理器被调用。
- en: In this sample, when a key on the keyboard is pressed, our `OnKeyDown` handler
    will be called first. All we do there is `print` a message to `stdout` and display
    some information about the event in the `StatusBar`, before calling `Skip`. Then,
    in our `OnChar` handler, we do some simple filtering of uppercase letters by checking
    to see if the *Shift key* is in the event's modifiers mask. If it is, we beep
    at the user and don't call `Skip` on the event, in order to prevent the character
    from appearing in the `TextCtrl`. Also, as an example of modifying what the event
    does, we perform a check for vowels by converting the raw key code into a character
    string and if the key was for a vowel, we simply insert a question mark into the
    `TextCtrl` instead. Finally, if the event was skipped in the `OnChar` handler,
    our `OnKeyUp` handler will be called, where we simply print a message to `stdout`
    to show it was called.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，当键盘上的一个键被按下时，我们的`OnKeyDown`处理程序首先被调用。我们在那里的所有操作只是将一条消息`print`到`stdout`，并在`StatusBar`中显示一些关于事件的详细信息，然后调用`Skip`。然后，在我们的`OnChar`处理程序中，我们通过检查事件修改器掩码中是否包含*Shift键*来对大写字母进行一些简单的过滤。如果是，我们向用户发出蜂鸣声，并且不调用事件上的`Skip`，以防止字符出现在`TextCtrl`中。此外，作为一个修改事件行为的示例，我们将原始键码转换为字符字符串，并检查该键是否为元音。如果是元音键，我们只需在`TextCtrl`中插入一个问号。最后，如果事件在`OnChar`处理程序中被跳过，我们的`OnKeyUp`处理程序将被调用，在那里我们简单地打印一条消息到`stdout`以显示它已被调用。
- en: There's more...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Some controls require the `wx.WANTS_CHARS` style flag to be specified in their
    constructor in order to receive character events. The `Panel` class is the most
    common example that requires this special style flag in order to receive `EVT_CHAR`
    events. Often, this is used to perform special processing when creating a new
    custom control type that is derived from a `Panel`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一些控件需要在它们的构造函数中指定`wx.WANTS_CHARS`样式标志，以便接收字符事件。`Panel`类是要求使用这种特殊样式标志以接收`EVT_CHAR`事件的常见示例。通常，这用于在创建一个从`Panel`派生的自定义控件类型时执行特殊处理。
- en: See also
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Validating input with validators* recipe in this chapter uses `KeyEvents`
    to perform input validation.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于*使用验证器验证输入*的配方使用`KeyEvents`来执行输入验证。
- en: Using UpdateUI events
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 UpdateUI 事件
- en: '`UpdateUIEvents` are events that are sent by the framework on a regular basis
    in order to allow an application to update the state of its controls. These are
    useful for performing tasks such as changing when a control is enabled or disabled,
    based on the application''s business logic. This recipe will show how to use `UpdateUIEvents`
    to update the state of menu items, depending on the current context of the UI.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateUIEvents` 是框架定期发送的事件，以便允许应用程序更新其控件的状态。这些事件对于执行诸如根据应用程序的业务逻辑更改控件启用或禁用时间等任务非常有用。本食谱将展示如何使用
    `UpdateUIEvents` 根据UI的当前上下文更新菜单项的状态。'
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In this example, we create a simple window with an `Edit Menu` and a `TextCtrl`.
    The `Edit Menu` has three items in it that will be enabled or disabled based on
    the current selection status in the `TextCtrl` by using `UpdateUIEvents`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们创建了一个简单的窗口，其中包含一个`编辑菜单`和一个`文本控件`。`编辑菜单`中有三个项目，这些项目将根据`文本控件`当前的选中状态通过使用`UpdateUIEvents`来启用或禁用。
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`UpdateUIEvents` are sent periodically by the framework during idle time to
    allow the application to check if the state of a control needs to be updated.
    Our `TextFrame` class has three menu items in its Edit Menu that will be managed
    by our `OnUpdateUI` event handler. In `OnUpdateUI`, we check the event''s ID to
    see which object the event is being sent for, and then call the appropriate `UpdateUIEvent`
    method on the event to change the state of the control. The states of each of
    our menu items are dependent upon whether there is a selection in the `TextCtrl`
    or not. Calling the `GetSelection` method of `TextCtrl` will return a tuple with
    the start and end positions of the selection. When the two positions differ, there
    is a selection in the control and we will `Enable` the `Copy` and `Cut` items,
    or in the case of our `Selection Made` item we will set the check mark. If there
    is no selection, then the items will become disabled or un-checked.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateUIEvents` 是在空闲时间由框架定期发送的，以便应用程序检查控件的状态是否需要更新。我们的 `TextFrame` 类在其编辑菜单中有三个菜单项，这些菜单项将由我们的
    `OnUpdateUI` 事件处理器管理。在 `OnUpdateUI` 中，我们检查事件的 ID 以确定事件是为哪个对象发送的，然后调用事件上的适当 `UpdateUIEvent`
    方法来更改控件的状态。我们每个菜单项的状态取决于 `TextCtrl` 中是否有选择。调用 `TextCtrl` 的 `GetSelection` 方法将返回一个包含选择开始和结束位置的元组。当两个位置不同时，控件中有选择，我们将
    `Enable` `Copy` 和 `Cut` 项目，或者在我们的 `Selection Made` 项目中设置勾选标记。如果没有选择，则项目将变为禁用或未勾选。'
- en: It's important to call the method on the event object to update the control
    and not the method on the control itself, as it will allow for it to be updated
    far more efficiently. See the wxPython API documentation for `UpdateUIEvent` to
    see the full listing of what methods are available.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件对象上调用该方法以更新控件，而不是在控件本身上调用该方法，这是非常重要的，因为它将允许更高效地更新。请参阅wxPython API文档中的`UpdateUIEvent`，以查看可用的所有方法列表。
- en: There's more...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are some static methods available in the `UpdateUIEvent` class that allow
    applications to change the behavior of how the events are delivered. Most notable
    are the following two methods:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateUIEvent` 类中提供了一些静态方法，这些方法允许应用程序更改事件传递的行为。其中最显著的两个方法如下：'
- en: '`wx.UpdateUIEvent.SetUpdateInterval`'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`wx.UpdateUIEvent.SetUpdateInterval`'
- en: '`wx.UpdateUIEvent.SetMode`'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`wx.UpdateUIEvent.SetMode`'
- en: '`SetUpdateInterval` can be used to configure how often the `UpdateUIEvents`
    are sent. It takes a number of milliseconds as an argument. This is useful if
    you find that there is a noticeable amount of overhead in handling `UpdateUIEvents`
    in your application. You can use this to slow down the rate at which these events
    are sent.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetUpdateInterval` 可以用来配置 `UpdateUIEvents` 发送频率。它接受一个表示毫秒数的参数。如果你发现在你的应用程序中处理
    `UpdateUIEvents` 存在明显的开销，这将非常有用。你可以使用这个方法来降低这些事件发送的速率。'
- en: '`SetMode` can be used configure the behavior of what windows will receive the
    events, by setting one of the following modes:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetMode` 可以用来配置哪些窗口将接收事件的行为，通过设置以下模式之一：'
- en: '| Mode | Description |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 描述 |'
- en: '| --- | --- |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wx.UPDATE_UI_PROCESS_ALL` | Process `UpdateUI` events for all windows |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `wx.UPDATE_UI_PROCESS_ALL` | 处理所有窗口的 `UpdateUI` 事件 |'
- en: '| `wx.UPDATE_UI_PROCESS_SPECIFIED` | Only process `UpdateUI` events for the
    windows that have the `WS_EX_PROCESS_UI_UPDATES` extra style flag set. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `wx.UPDATE_UI_PROCESS_SPECIFIED` | 仅处理设置了 `WS_EX_PROCESS_UI_UPDATES` 额外样式标志的窗口的
    `UpdateUI` 事件。 |'
- en: See also
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Managing event handlers with EventStack* recipe in this chapter shows a
    way to manage `UpdateUI` events in a centralized way.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *使用 EventStack 管理事件处理器* 菜谱展示了如何集中管理 `UpdateUI` 事件。
- en: Playing with the mouse
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操纵鼠标
- en: '`MouseEvents` can be used to interact with the mouse-position changes and mouse-button
    clicks that a user makes within a window. This recipe will provide a quick crash
    course on some of the common mouse events that are available for use in a program.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`MouseEvents` 可以用来与用户在窗口内进行的鼠标位置变化和鼠标按钮点击进行交互。本教程将快速介绍一些在程序中可用的常见鼠标事件。'
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Here as an example, we will create a simple Frame class that has a `Panel` and
    a Button to see how to interact with `MouseEvents`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们以一个示例来创建一个简单的`Frame`类，其中包含一个`Panel`和一个按钮，以了解如何与`MouseEvents`进行交互。
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we made use of the events for when the mouse cursor enters the
    `Panel` and for when the left mouse button is clicked on the `Panel`, to modify
    our `Button`. When the mouse cursor enters a window's area, an `EVT_ENTER_WINDOW`
    event will be sent to it; conversely, it will receive an `EVT_LEAVE_WINDOW` event
    when the cursor leaves the window. When the mouse enters or leaves the Panel's
    area, we update the Button's label to show what happened. When our `Panel` receives
    a left click event, we move the `Button` to where the click took place.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们利用了鼠标光标进入`Panel`和左键点击`Panel`的事件来修改我们的`Button`。当鼠标光标进入窗口区域时，会向其发送一个`EVT_ENTER_WINDOW`事件；相反，当光标离开窗口时，它会收到一个`EVT_LEAVE_WINDOW`事件。当鼠标进入或离开`Panel`的区域时，我们更新按钮的标签以显示发生了什么。当我们的`Panel`接收到左键点击事件时，我们将`Button`移动到点击发生的位置。
- en: The important thing to notice is that we called `Bind` on the `Panel` directly
    and not on the `Frame`. This is important because `MouseEvents` are not `CommandEvents`
    so they will only be sent to the window they originated from, and will not propagate
    up the containment hierarchy.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们直接在 `Panel` 上调用了 `Bind` 而不是在 `Frame` 上。这很重要，因为 `MouseEvents` 不是 `CommandEvents`，所以它们只会被发送到它们起源的窗口，而不会在包含层次结构中传播。
- en: There's more...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are a large number of `MouseEvents` that can be used to interact with
    other mouse actions. The following table contains a quick reference to each of
    them:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量可以用来与其他鼠标操作交互的 `MouseEvents`。以下表格包含了对每个事件的快速参考：
- en: '| MouseEvents | Description |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 鼠标事件 | 描述 |'
- en: '| --- | --- |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wx.EVT_MOUSEWHEEL` | Sent for mouse wheel scroll events. See the `GetWheelRotation`
    and `GetWheelDelta` methods that belong to the `MouseEvent` class for working
    with this event. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `wx.EVT_MOUSEWHEEL` | 发送鼠标滚轮滚动事件。请参阅属于 `MouseEvent` 类的 `GetWheelRotation`
    和 `GetWheelDelta` 方法，了解如何处理此事件。 |'
- en: '| `wx.EVT_LEFT_DCLICK` | Sent for left mouse button double-clicks. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `wx.EVT_LEFT_DCLICK` | 发送用于左鼠标按钮双击的事件。 |'
- en: '| `wx.EVT_RIGHT_DOWN` | Sent when the right mouse button is pressed down. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `wx.EVT_RIGHT_DOWN` | 当鼠标右键被按下时发送。 |'
- en: '| `wx.EVT_RIGHT_UP` | Sent when the right mouse button is released. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `wx.EVT_RIGHT_UP` | 当鼠标右键被释放时发送。 |'
- en: '| `wx.EVT_RIGHT_DCLICK` | Sent for right mouse button double-clicks. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `wx.EVT_RIGHT_DCLICK` | 发送用于右键鼠标双击的事件。 |'
- en: '| `wx.EVT_MIDDLE_DOWN` | Sent when the middle mouse button is pressed down.
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `wx.EVT_MIDDLE_DOWN` | 当鼠标中键被按下时发送。 |'
- en: '| `wx.EVT_MIDDLE_UP` | Sent when the middle mouse button is released. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `wx.EVT_MIDDLE_UP` | 当鼠标中键被释放时发送。 |'
- en: '| `wx.EVT_MIDDLE_DCLICK` | Sent for middle mouse button double-clicks. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `wx.EVT_MIDDLE_DCLICK` | 发送于鼠标中键双击事件。 |'
- en: '| `wx.EVT_MOTION` | Sent every time the mouse cursor moves within the window.
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `wx.EVT_MOTION` | 每当鼠标光标在窗口内移动时发送。 |'
- en: '| `wx.EVT_MOUSE_EVENTS` | This event binder can be used to get notifications
    for all mouse related events. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `wx.EVT_MOUSE_EVENTS` | 此事件绑定器可用于获取所有鼠标相关事件的通告。 |'
- en: See also
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Understanding event propagation* recipe in this chapter discusses how different
    types of events propagate.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于*理解事件传播*的配方讨论了不同类型的事件是如何传播的。
- en: Creating custom event classes
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义事件类
- en: Sometimes it is necessary to define your own event types to signal custom actions
    and/or transport data from one place in the application to another. This recipe
    will show two ways of creating your own custom event class.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有时有必要定义自己的事件类型来表示自定义操作，以及从应用的一个地方传输数据到另一个地方。本食谱将展示创建自定义事件类的两种方法。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this little snippet, we define two new event types using two different methods:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短片段中，我们使用两种不同的方法定义了两种新的事件类型：
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first example shows the easiest way to create a custom event class. The
    `NewCommandEvent` function from the wx.lib.newevent module will return a tuple
    that contains a new event class and an event binder for that class. The class
    definition that is returned can be used to construct an event object. This method
    of creating a new event type is of most use when you just want a new event type
    and don't need to send any custom data with the event.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例展示了创建自定义事件类的最简单方法。来自 wx.lib.newevent 模块的 `NewCommandEvent` 函数将返回一个包含新事件类及其事件绑定器的元组。返回的类定义可以用来构建事件对象。当你只需要一个新的事件类型而不需要随事件发送任何自定义数据时，这种方法创建新事件类型最为有用。
- en: 'In order to make use of an event object, the object needs to be sent for processing
    by the event loop. There are two ways to do this, one of which is the `PostEvent`
    function. `PostEvent` takes two arguments: the first is the window that should
    receive the event, and the second is the event itself. For example, the following
    two lines of code could be used to create and send an instance of our custom `MyEvent`
    to a `Frame:`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用事件对象，该对象需要通过事件循环进行处理。这里有两种方法可以实现，其中之一是`PostEvent`函数。`PostEvent`函数接受两个参数：第一个是需要接收事件的窗口，第二个是事件本身。例如，以下两行代码可以用来创建并发送我们的自定义`MyEvent`实例到`Frame:`：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The second way to send an event for processing is to use a window''s `ProcessEvent`
    method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 发送事件进行处理的第二种方式是使用窗口的`ProcessEvent`方法：
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The difference between the two is that `PostEvent` will put the event into the
    application's event queue to have it processed on the next iteration of the `MainLoop`,
    whereas `ProcessEvent` will cause the event to be processed right then.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者的区别在于，`PostEvent`会将事件放入应用程序的事件队列中，以便在`MainLoop`的下一个迭代中处理，而`ProcessEvent`则会导致事件立即被处理。
- en: The second approach shows how to derive a new event type from the `PyCommandEvent`
    base class. In order to create an event in this way, there are three things that
    need to be done.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法展示了如何从`PyCommandEvent`基类派生出一个新的事件类型。为了以这种方式创建一个事件，需要完成以下三个步骤。
- en: Define a new event type using the `NewEventType` function.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `NewEventType` 函数定义一个新的事件类型。
- en: Create the event binder object for binding event handlers with the `PyEventBinder`
    class. This object takes the event type as its first argument.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`PyEventBinder`类创建事件绑定对象，该对象将事件类型作为其第一个参数。
- en: Define the event class that is used for creating the event object.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义用于创建事件对象的的事件类。
- en: This `MyTimeEvent` class can hold a custom value that we are using to send a
    formatted time string. It is necessary to derive this from `PyCommandEvent` so
    that the custom Python data and methods that we are attaching to this object will
    pass through the event system.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`MyTimeEvent`类可以保存一个自定义值，我们使用它来发送格式化的时间字符串。必须从`PyCommandEvent`派生这个类，这样我们附加到这个对象上的自定义Python数据和方法才能通过事件系统传递。
- en: These events can now be sent to any event handler object, by using the `PostEvent`
    function or the windows `ProcessEvent` method. Either of these methods will cause
    the event to be dispatched to the event handler(s) that has been associated with
    the event by calling `Bind`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件现在可以通过使用`PostEvent`函数或Windows的`ProcessEvent`方法发送到任何事件处理对象。这两种方法中的任何一种都会导致事件被分发到通过调用`Bind`与之关联的事件处理程序。
- en: See also
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Understanding inheritance limitations* recipe in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with wxPython"), *Getting Started with wxPython* explains
    the need for the Py versions of some classes.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. wxPython入门")中的*理解继承限制*配方，*wxPython入门*解释了为什么需要某些类的Py版本。'
- en: The *Handling events* recipe in this chapter discusses the use of event handlers.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的*处理事件*配方讨论了事件处理器的使用。
- en: Managing event handlers with EventStack
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 EventStack 管理事件处理器
- en: '`EventStack` is a module in `wx.lib` that provides a mix in class for the wx
    application object that can be used to help manage event handlers for `Menu` and
    `UpdateUI` events. It can be useful in programs that have multiple top-level windows
    or that need to switch the context of which handlers are called depending on the
    control that has the focus. This recipe will present a simple framework for managing
    events in `Frame-based` applications that make use of the `AppEventHandlerMixin`
    class. A full working example, showing how to use this recipe''s classes, is included
    in the example code that accompanies this recipe.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventStack` 是 `wx.lib` 模块中的一个模块，它提供了一个用于 wx 应用对象混合类，可用于帮助管理 `Menu` 和 `UpdateUI`
    事件的处理器。在具有多个顶级窗口或需要根据具有焦点的控件切换调用处理器的上下文的应用程序中，这可能很有用。本食谱将展示一个用于管理基于 `Frame` 的应用程序中事件的简单框架，这些应用程序使用了
    `AppEventHandlerMixin` 类。本食谱附带的一个完整的工作示例展示了如何使用本食谱中的类。'
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: With this code, we define two classes that work together. First we define an
    `App` base class that uses the `AppEventHandlerMixin`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，我们定义了两个相互协作的类。首先，我们定义了一个使用`AppEventHandlerMixin`的`App`基类。
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `EventMgrApp` class is just a base class for creating an application object
    that uses `AppEventHandlerMixin`. This `mixin` provides methods for adding and
    removing event handlers for the `MenuEvent` and `UpdateUIEvent` handlers.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventMgrApp` 类只是一个用于创建使用 `AppEventHandlerMixin` 的应用程序对象的基类。这个 `mixin` 提供了添加和删除
    `MenuEvent` 和 `UpdateUIEvent` 处理程序的事件处理程序的方法。'
- en: The `EventMgrFrame` class is a base class for frames to derive from. This class
    will handle adding, removing, and binding event handlers that are registered using
    either its `RegisterMenuHandler` or `RegisterUpdateUIHandler` methods. These methods
    take care of adding the event handlers to the stack that will be pushed or popped
    as the `Frame` is activated or deactivated. The `AppEventHandlerMixin` will internally
    manage Binding and Unbinding of these handlers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventMgrFrame` 类是用于派生的框架的基类。此类将处理使用其 `RegisterMenuHandler` 或 `RegisterUpdateUIHandler`
    方法注册的事件处理器的添加、移除和绑定。这些方法负责将事件处理器添加到堆栈中，当 `Frame` 被激活或停用时，这些处理器将被推入或弹出。`AppEventHandlerMixin`
    将内部管理这些处理器的绑定和解绑。'
- en: See also
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using UpdateUI events* recipe in this chapter discusses `UpdateUI` events
    in detail.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于*使用UpdateUI事件*的配方详细讨论了`UpdateUI`事件。
- en: Validating input with validators
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用验证器验证输入
- en: '`Validators` are a general type of helper class for validating data and filtering
    events that are input to a control. Most controls that accept user input can dynamically
    have a `Validator` associated with them. This recipe will show how to create a
    `Validator` that checks if the data that has been entered into a window is an
    integer that is within a given range of values.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`验证器` 是一种用于验证数据和过滤输入到控制器的事件的通用辅助类。大多数接受用户输入的控制都可以动态地与一个 `Validator` 关联。本食谱将展示如何创建一个
    `Validator`，该 `Validator` 检查输入到窗口中的数据是否是一个在给定值范围内的整数。'
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Here we will define a Validator for a `TextCtrl` that can be used to validate
    that the value input is an integer and between a given range.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将定义一个用于`TextCtrl`的验证器，它可以用来验证输入的值是否为整数，并且是否在给定的范围内。
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`Validator` classes have a number of virtual methods that need to be overridden
    in order for them to function properly. Hence, it is important to derive a subclass
    from the `PyValidator` class, instead of `Validator`, in order to get access to
    the virtual method aware version of the class.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`Validator` 类包含多个需要重写以使其正常工作的虚拟方法。因此，为了访问类的虚拟方法感知版本，重要的是从 `PyValidator` 类而不是从
    `Validator` 类派生一个子类。'
- en: All `Validator` subclasses must override the `Clone` method. This method simply
    needs to return a copy of the `Validator`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `Validator` 子类都必须重写 `Clone` 方法。这个方法只需简单地返回 `Validator` 的一个副本。
- en: The `Validate` method is called to check if the value is valid or not. This
    method will be called if the control is the child of a modal dialog, prior to
    calling `EndModal` for an `Ok` button. This is a good time to notify the user
    of any issues with the input.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `Validate` 方法来检查值是否有效。如果控件是模态对话框的子控件，在调用 `EndModal` 方法为“确定”按钮之前，将会调用此方法。这是通知用户任何输入问题的好时机。
- en: '`Validators` can also bind to any events that their window may bind to and
    can be used to filter the events. The events will be sent to the `OnChar` method
    of the `Validator` before they are sent to the window, allowing the `Validator`
    to filter which events are allowed to get to the control.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`校验器`也可以绑定到它们窗口可能绑定的任何事件，并且可以用来过滤事件。在事件被发送到窗口之前，这些事件将被发送到`校验器`的`OnChar`方法，允许`校验器`过滤哪些事件被允许到达控件。'
- en: The `TransferToWindow` and `TransferFromWindow` methods can be overridden if
    you wish to only do the validation in a `Dialog` at the time when the `Dialog`
    is being shown or closed. `TransferToWindow` will be called when a `Dialog` is
    shown, and `TransferFromWIndow` will be called when the `Dialog` is closed. Returning
    `True` from either of the methods indicates that the data is valid, and returning
    `False` will indicate that there is invalid data.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在`Dialog`显示或关闭时仅进行验证，则可以重写`TransferToWindow`和`TransferFromWindow`方法。当`Dialog`显示时，将调用`TransferToWindow`，而当`Dialog`关闭时，将调用`TransferFromWIndow`。从任一方法返回`True`表示数据有效，而返回`False`则表示存在无效数据。
- en: See also
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Understanding inheritance limitations* recipe in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with wxPython"), *Getting Started with wxPython* discusses
    the use of the Py versions of classes and overriding virtual methods.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. wxPython入门")中的*理解继承限制*配方讨论了类和重写虚拟方法使用Python版本的情况。'
- en: The *Handling Key events* recipe in this chapter discusses `KeyEvents` in detail.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于*处理关键事件*的配方详细讨论了`KeyEvents`。
- en: Handling Apple events
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理苹果事件
- en: AppleEvents are high-level system events used by the Macintosh operating system
    to pass information between processes. For an application to handle things such
    as opening files that are dropped on the application icon, it is necessary to
    handle these events. The wxPython application object has some built-in support
    for some of the most common events, by way of virtual overrides in the application
    object. This recipe will show how to create an application object that can make
    use of the built-in and somewhat hidden-event callback functions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: AppleEvents 是 Macintosh 操作系统使用的高级系统事件，用于在进程之间传递信息。为了处理诸如打开拖放到应用程序图标上的文件等操作，应用程序必须处理这些事件。wxPython
    应用程序对象通过在应用程序对象中实现虚拟覆盖，提供了一些对最常见事件的内置支持。本食谱将展示如何创建一个可以利用内置的并且相对隐藏的事件回调函数的应用程序对象。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: This is an OS X specific recipe, and will have will have no effect on other
    platforms.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个针对 OS X 的特定配方，对其他平台将没有任何影响。
- en: How to do it...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: This little sample application shows all of the built-in callback methods available
    in the `App` for handling some of the commonly needed `AppleEvents`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小示例应用程序展示了在`App`中可用的所有内置回调方法，用于处理一些常见的`AppleEvents`。
- en: '[PRE10]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are five built-in handler methods for some of the common `AppleEvents`.
    All that needs to be done to use them in your application is to override them
    in your application object, as previously shown. Since what an application does
    in response to these events is highly application-specific, this recipe does not
    do much, other than report to the frame's status bar when the method is called.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些常见的 `AppleEvents`，有五种内置的处理方法。要在您的应用程序中使用它们，只需在应用程序对象中覆盖它们，如前所述。由于应用程序对这些事件的响应非常特定于应用程序本身，这个方法除了在调用方法时向框架的状态栏报告之外，并没有做太多的事情。
- en: The two most-common events that should be implemented are the `MacOpenFile`
    and `MacReopenApp` methods, as these are necessary to get standard expected behavior
    in an application on OS X. `MacOpenFile` is called when a user drops a file on
    an application's Dock icon. When this happens, it will be passed the path of the
    file as an argument. `MacReopenApp` is called when a user left-clicks on the Dock
    icon of a running application. As shown in the recipe, this is used to bring an
    application to the front and/or raise it from a minimized state in the Dock.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 应该实现的最常见的两个事件是 `MacOpenFile` 和 `MacReopenApp` 方法，因为这些是实现在 OS X 上应用程序中标准预期行为所必需的。当用户将文件拖放到应用程序的
    Dock 图标上时，会调用 `MacOpenFile`。在这种情况下，它将作为参数传递文件的路径。当用户左键单击正在运行的应用程序的 Dock 图标时，会调用
    `MacReopenApp`。如配方中所示，这用于将应用程序带到前台，或者从 Dock 中的最小化状态中恢复出来。
- en: There's more...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is possible to add support for more `AppleEvents` to a wxPython application,
    although it is not a particularly easy task as it requires writing a native extension
    module to catch the event, block the wx `EventLoop`, and then restore the Python
    interpreter's state back to wx after handling the event. There is a pretty good
    example that can be used as a starting point in the wxPython Wiki (see [http://wiki.wxpython.org/Catching%20AppleEvents%20in%20wxMAC)](http://wiki.wxpython.org/Catching%20AppleEvents%20in%20wxMAC)),
    if you find yourself needing to venture down this route.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 wxPython 应用程序中添加对更多 `AppleEvents` 的支持是可能的，尽管这不是一项特别容易的任务，因为它需要编写一个本地扩展模块来捕获事件，阻塞
    wx 的 `EventLoop`，然后在处理事件后将 Python 解释器的状态恢复到 wx。wxPython Wiki 中有一个相当不错的示例可以作为起点（见
    [http://wiki.wxpython.org/Catching%20AppleEvents%20in%20wxMAC](http://wiki.wxpython.org/Catching%20AppleEvents%20in%20wxMAC)），如果你发现自己需要走这条路的话。
- en: See also
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Understanding inheritance limitations* recipe in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with wxPython"), *Getting Started with wxPython* includes
    more information on overriding virtual methods.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. 使用wxPython入门")中的*理解继承限制*配方，*使用wxPython入门*包含了更多关于重写虚方法的信息。'
- en: The *Optimizing for OS X* recipe in [Chapter 12](ch12.html "Chapter 12. Building
    and Managing Applications for Distribution"), *Application Infrastructure* includes
    more information on making wxPython applications work well on OS X.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第12章](ch12.html "第12章。构建和管理应用程序以进行分发")中的*针对OS X优化*配方，在*应用程序基础设施*部分包含了更多关于使wxPython应用程序在OS
    X上运行良好的信息。'
