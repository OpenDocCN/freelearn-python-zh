- en: The SOLID Principles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID原则
- en: 'In this chapter, we will continue to explore concepts of clean design applied
    to Python. In particular, we will review the so-called **SOLID** principles, and
    how to implement them in a Pythonic way. These principles entail a series of good
    practices to achieve better-quality software. In case some of us aren''t aware
    of what SOLID stands for, here it is:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续探讨应用于Python的清晰设计概念。特别是，我们将回顾所谓的**SOLID**原则，以及如何以Pythonic的方式实现它们。这些原则包括一系列实践，以实现更高质量的软件。如果我们中有人不知道SOLID代表什么，这里是解释：
- en: '**S**: Single responsibility principle'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：单一责任原则'
- en: '**O**: Open/closed principle'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**：开闭原则'
- en: '**L**: Liskov''s substitution principle'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：里氏替换原则'
- en: '**I**: Interface segregation principle'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**：接口隔离原则'
- en: '**D**: Dependency inversion principle'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：依赖反转原则'
- en: 'The goals of this chapter are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标如下：
- en: To become acquainted with SOLID principles for software design
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉软件设计的SOLID原则
- en: To design software components that follow the single responsibility principle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计遵循单一责任原则的软件组件
- en: To achieve more maintainable code through the open/closed principle
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过开闭原则实现更易维护的代码
- en: To implement proper class hierarchies in object-oriented design, by complying
    with Liskov's substitution principle
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过遵守里氏替换原则，在面向对象设计中实现适当的类层次结构
- en: To design with interface segregation and dependency inversion
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过接口隔离和依赖反转进行设计
- en: Single responsibility principle
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一责任原则
- en: The **single responsibility principle** (**SRP**) states that a software component
    (in general, a class) must have only one responsibility. The fact that the class
    has a sole responsibility means that it is in charge of doing just one concrete
    thing, and as a consequence of that, we can conclude that it must have only one
    reason to change.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**单一责任原则**（**SRP**）规定软件组件（通常是一个类）必须只有一个责任。类只有一个责任意味着它只负责做一件具体的事情，因此我们可以得出结论，它只有一个变化的原因。'
- en: Only if one thing on the domain problem changes will the class have to be updated.
    If we have to make modifications to a class, for different reasons, it means the
    abstraction is incorrect, and that the class has too many responsibilities.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在领域问题上有一件事情改变时，类才需要更新。如果我们不得不因为不同的原因对一个类进行修改，那意味着抽象不正确，类承担了太多责任。
- en: As introduced in [Chapter 2](c6a1dd9e-e567-4254-b5cf-1033b8b89c3d.xhtml), *Pythonic
    Code*, this design principle helps us build more cohesive abstractions; objects
    that do one thing, and just one thing, well, following the Unix philosophy. What
    we want to avoid in all cases is having objects with multiple responsibilities
    (often called **god-objects**, because they know too much, or more than they should).
    These objects group different (mostly unrelated) behaviors, thus making them harder
    to maintain.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第2章](c6a1dd9e-e567-4254-b5cf-1033b8b89c3d.xhtml)中介绍的*Pythonic Code*，这个设计原则帮助我们构建更具凝聚力的抽象；对象只做一件事情，而且做得很好，遵循Unix哲学。我们要避免的情况是拥有承担多个责任的对象（通常称为**god-objects**），因为它们知道得太多，或者比它们应该知道的更多。这些对象组合了不同（大多数是不相关的）行为，因此使它们更难以维护。
- en: Again, the smaller the class, the better.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，类越小越好。
- en: The SRP is closely related to the idea of cohesion in software design, which
    we already explored in [Chapter 3](0aec97c9-5777-4cd5-8c76-134440c49402.xhtml),
    *General Traits of Good Code*, when we discussed separation of concerns in software.
    What we strive to achieve here is that classes are designed in such a way that
    most of their properties and their attributes are used by its methods, most of
    the time. When this happens, we know they are related concepts, and therefore
    it makes sense to group them under the same abstraction.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: SRP与软件设计中的内聚概念密切相关，我们在[第3章](0aec97c9-5777-4cd5-8c76-134440c49402.xhtml)中已经探讨过这一点，当时我们讨论了软件中的关注点分离。我们努力实现的目标是，类被设计成大部分时间内它们的属性和方法被使用。当这种情况发生时，我们知道它们是相关的概念，因此将它们分组到同一个抽象下是有意义的。
- en: In a way, this idea is somehow similar to the concept of normalization on relational
    database design. When we detect that there are partitions on the attributes or
    methods of the interface of an object, they might as well be moved somewhere else—it
    is a sign that they are two or more different abstractions mixed into one.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，这个想法与关系数据库设计中的规范化概念有些相似。当我们发现对象的接口的属性或方法有分区时，它们可能被移动到其他地方——这表明它们是两个或更多不同的抽象混合在一起。
- en: There is another way of looking at this principle. If, when looking at a class,
    we find methods that are mutually exclusive and do not relate to each other, they
    are the different responsibilities that have to be broken down into smaller classes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种看待这个原则的方式。如果在查看一个类时，我们发现方法是相互独立的，彼此之间没有关联，那么它们就是需要分解成更小的类的不同责任。
- en: A class with too many responsibilities
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个类承担太多责任
- en: In this example, we are going to create the case for an application that is
    in charge of reading information about events from a source (this could be log
    files, a database, or many more sources), and identifying the actions corresponding
    to each particular log.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个应用程序，负责从源头（可以是日志文件、数据库或其他许多来源）读取有关事件的信息，并识别与每个特定日志对应的动作。
- en: 'A design that fails to conform to the SRP would look like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不符合SRP的设计如下所示：
- en: '![](assets/a2877df2-39ec-4056-b127-b0162883a1a4.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a2877df2-39ec-4056-b127-b0162883a1a4.png)'
- en: 'Without considering the implementation, the code for the class might look in
    the following listing:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不考虑实现，该类的代码可能如下所示：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The problem with this class is that it defines an interface with a set of methods
    that correspond to actions that are orthogonal: each one can be done independently
    of the rest.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的问题在于它定义了一个接口，其中包含一组与彼此正交的动作对应的方法：每个动作都可以独立于其他动作完成。
- en: This design flaw makes the class rigid, inflexible, and error-prone because
    it is hard to maintain. In this example, each method represents a responsibility
    of the class. Each responsibility entails a reason why the class might need to
    be modified. In this case, each method represents one of the various reasons why
    the class will have to be modified.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计缺陷使得类变得僵化、不灵活、容易出错，因为很难维护。在这个例子中，每个方法代表了类的一个责任。每个责任都意味着类可能需要被修改的原因。在这种情况下，每个方法代表了类将被修改的各种原因之一。
- en: Consider the loader method, which retrieves the information from a particular
    source. Regardless of how this is done (we can abstract the implementation details
    here), it is clear that it will have its own sequence of steps, for instance connecting
    to the data source, loading the data, parsing it into the expected format, and
    so on. If any of this changes (for example, we want to change the data structure
    used for holding the data), the `SystemMonitor` class will need to change. Ask
    yourself whether this makes sense. Does a system monitor object have to change
    because we changed the representation of the data? No.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑加载器方法，它从特定来源检索信息。无论这是如何完成的（我们可以在这里抽象实现细节），很明显它将有自己的一系列步骤，例如连接到数据源，加载数据，将其解析为预期格式等。如果其中任何一项发生变化（例如，我们想要更改用于保存数据的数据结构），`SystemMonitor`类将需要更改。问问自己这是否有意义。系统监视器对象是否必须因为我们改变了数据的表示而改变？不。
- en: The same reasoning applies to the other two methods. If we change how we fingerprint
    events, or how we deliver them to another data source, we will end up making changes
    to the same class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的推理也适用于其他两种方法。如果我们改变了指纹事件的方式，或者我们如何将它们传递到另一个数据源，我们最终会对同一个类进行修改。
- en: It should be clear by now that this class is rather fragile, and not very maintainable.
    There are lots of different reasons that will impact on changes in this class.
    Instead, we want external factors to impact our code as little as possible. The
    solution, again, is to create smaller and more cohesive abstractions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该很清楚，这个类相当脆弱，而且不太容易维护。有很多不同的原因会影响这个类的变化。相反，我们希望外部因素对我们的代码的影响尽可能小。解决方案是再次创建更小、更具凝聚力的抽象。
- en: Distributing responsibilities
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配责任
- en: 'To make the solution more maintainable, we separate every method into a different
    class. This way, each class will have a single responsibility:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使解决方案更易于维护，我们将每个方法分离到不同的类中。这样，每个类都将有一个单一的责任：
- en: '![](assets/cdac0d5f-a04e-4839-990d-03d6753720b0.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cdac0d5f-a04e-4839-990d-03d6753720b0.png)'
- en: The same behavior is achieved by using an object that will interact with instances
    of these new classes, using those objects as collaborators, but the idea remains
    that each class encapsulates a specific set of methods that are independent of
    the rest. The idea now is that changes on any of these classes do not impact the
    rest, and all of them have a clear and specific meaning. If we need to change
    something on how we load events from the data sources, the alert system is not
    even aware of these changes, so we do not have to modify anything on the system
    monitor (as long as the contract is still preserved), and the data target is also
    unmodified.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用一个对象来实现相同的行为，该对象将与这些新类的实例进行交互，使用这些对象作为协作者，但是这个想法仍然是每个类封装了一组独立于其他类的特定方法。现在的想法是，对这些类的任何更改都不会影响其他类，它们都有一个明确而具体的含义。如果我们需要改变如何从数据源加载事件，警报系统甚至不知道这些变化，因此我们不需要修改系统监视器上的任何内容（只要合同仍然得到保留），数据目标也没有被修改。
- en: Changes are now local, the impact is minimal, and each class is easier to maintain.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在变化是局部的，影响是最小的，每个类更容易维护。
- en: The new classes define interfaces that are not only more maintainable but also
    reusable. Imagine that now, in another part of the application, we also need to
    read the activity from the logs, but for different purposes. With this design,
    we can simply use objects of type `ActivityReader` (which would actually be an
    interface, but for the purposes of this section, that detail is not relevant and
    will be explained later for the next principles). This would make sense, whereas
    it would not have made sense in the previous design, because attempts to reuse
    the only class we had defined would have also carried extra methods (such as `identify_events()`,
    or `stream_events()`) that were not needed at all.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 新的类定义了接口，不仅更易于维护，而且更可重用。想象一下，现在在应用程序的另一个部分，我们还需要从日志中读取活动，但是为了不同的目的。有了这个设计，我们可以简单地使用`ActivityReader`类型的对象（实际上应该是一个接口，但是在本节的目的上，这个细节并不重要，将在下一个原则中解释）。这是有意义的，而在以前的设计中是没有意义的，因为尝试重用我们定义的唯一类也会带有不需要的额外方法（比如`identify_events()`或`stream_events()`）。
- en: One important clarification is that the principle does not mean at all that
    each class must have a single method. Any of the new classes might have extra
    methods, as long as they correspond to the same logic that that class is in charge
    of handling.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的澄清是，这个原则并不意味着每个类必须只有一个方法。任何新类都可能有额外的方法，只要它们对应于该类负责处理的相同逻辑。
- en: The open/closed principle
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开闭原则
- en: The **open/closed principle** (**OCP**) states that a module should be both
    open and closed (but with respect to different aspects).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**开闭原则**（OCP）规定一个模块应该是开放的和封闭的（但是针对不同的方面）。'
- en: When designing a class, for instance, we should carefully encapsulate the logic
    so that it has good maintenance, meaning that we will want it to be **open to
    extension but closed for modification.**
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在设计一个类时，我们应该仔细地封装逻辑，使其具有良好的维护性，这意味着我们希望它对扩展是**开放的，但对修改是封闭的。**
- en: What this means in simple terms is that, of course, we want our code to be extensible,
    to adapt to new requirements, or changes in the domain problem. This means that,
    when something new appears on the domain problem, we only want to add new things
    to our model, not change anything existing that is closed to modification.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，这意味着当领域问题出现新情况时，我们当然希望我们的代码是可扩展的，能够适应新的要求或领域问题的变化。这意味着当领域问题出现新情况时，我们只想向我们的模型添加新的东西，而不是更改任何已经关闭修改的现有内容。
- en: If, for some reason, when something new has to be added, we found ourselves
    modifying the code, then that logic is probably poorly designed. Ideally, when
    requirements change, we want to just have to extend the module with the new required
    behavior in order to comply with the new requirements, but without having to modify
    the code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，当需要添加新内容时，我们发现自己修改了代码，那么这个逻辑可能设计得很糟糕。理想情况下，当需求发生变化时，我们只需扩展模块以满足新需求，而无需修改代码。
- en: This principle applies to several software abstractions. It could be a class
    or even a module. In the following two subsections, we will see examples of each
    one, respectively.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则适用于多个软件抽象。它可以是一个类，甚至是一个模块。在接下来的两个小节中，我们将分别看到每个示例。
- en: Example of maintainability perils for not following the open/closed principle
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不遵循开闭原则的可维护性问题示例
- en: Let's begin with an example of a system that is designed in such a way that
    does not follow the open/closed principle, in order to see the maintainability
    problems this carries, and the inflexibility of such a design.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个系统的示例开始，该系统设计方式不符合开闭原则，以便看到这种设计的可维护性问题以及这种设计的不灵活性。
- en: The idea is that we have a part of the system that is in charge of identifying
    events as they occur in another system, which is being monitored. At each point,
    we want this component to identify the type of event, correctly, according to
    the values of the data that was previously gathered (for simplicity, we will assume
    it is packaged into a dictionary, and was previously retrieved through another
    means such as logs, queries, and many more). We have a class that, based on this
    data, will retrieve the event, which is another type with its own hierarchy.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的想法是，系统的一部分负责在另一个正在被监视的系统中发生事件时识别这些事件。在每个点上，我们希望这个组件根据先前收集的数据的值（为简单起见，我们将假设它被打包到一个字典中，并且先前是通过日志、查询等其他方式检索的）正确地识别事件类型。我们有一个类，根据这些数据，将检索事件，这是另一种具有自己层次结构的类型。
- en: 'A first attempt to solve this problem might look like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的第一次尝试可能看起来像这样：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the expected behavior of the preceding code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述代码的预期行为：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can clearly notice the hierarchy of event types, and some business logic
    to construct them. For instance, when there was no previous flag for a session,
    but there is now, we identify that record as a login event. Conversely, when the
    opposite happens, it means that it was a logout event. If it was not possible
    to identify an event, an event of type unknown is returned. This is to preserve
    polymorphism by following the null object pattern (instead of returning `None`,
    it retrieves an object of the corresponding type with some default logic). The
    null object pattern is described in [Chapter 9](dee5b4ed-34cd-4077-a5b4-83d4853e6e56.xhtml), *Common
    Design Patterns*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地注意到事件类型的层次结构，以及一些构造它们的业务逻辑。例如，当会话之前没有标志，但现在有了，我们将该记录标识为登录事件。相反，当相反情况发生时，这意味着它是一个注销事件。如果无法识别事件，则返回类型未知的事件。这是为了通过遵循空对象模式（而不是返回`None`，它检索具有一些默认逻辑的相应类型的对象）来保持多态性。空对象模式在[第9章](dee5b4ed-34cd-4077-a5b4-83d4853e6e56.xhtml)中有描述，*常见设计模式*。
- en: This design has some problems. The first issue is that the logic for determining
    the types of events is centralized inside a monolithic method. As the number of
    events we want to support grows, this method will as well, and it could end up
    being a very long method, which is bad because, as we have already discussed,
    it will not be doing just one thing and one thing well.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计存在一些问题。第一个问题是确定事件类型的逻辑集中在一个庞大的方法中。随着我们想要支持的事件数量增加，这个方法也会增长，最终可能会变成一个非常长的方法，这是不好的，因为正如我们已经讨论过的，它不会只做一件事情并且做得很好。
- en: On the same line, we can see that this method is not closed for modification.
    Every time we want to add a new type of event to the system, we will have to change
    something in this method (not to mention, that the chain of `elif` statements
    will be a nightmare to read!).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一行上，我们可以看到这种方法不适合修改。每当我们想要向系统添加新类型的事件时，我们都必须更改这种方法中的某些内容（更不用说`elif`语句的链将是一场噩梦！）。
- en: We want to be able to add new types of event without having to change this method
    (closed for modification). We also want to be able to support new types of event
    (open for extension) so that when a new event is added, we only have to add code,
    not change the code that already exists.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够添加新类型的事件，而无需更改这种方法（关闭修改）。我们还希望能够支持新类型的事件（扩展开放），这样当添加新事件时，我们只需添加代码，而不是更改已经存在的代码。
- en: Refactoring the events system for extensibility
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构事件系统以实现可扩展性
- en: The problem with the previous example was that the `SystemMonitor` class was
    interacting directly with the concrete classes it was going to retrieve.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例的问题在于`SystemMonitor`类直接与它将要检索的具体类进行交互。
- en: In order to achieve a design that honors the open/closed principle, we have
    to design toward abstractions*.*
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现符合开闭原则的设计，我们必须朝着抽象设计。
- en: 'A possible alternative would be to think of this class as it collaborates with
    the events, and then we delegate the logic for each particular type of event to
    its corresponding class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的替代方案是将这个类视为与事件协作，然后将每种特定类型的事件的逻辑委托给其相应的类：
- en: '![](assets/cc55531b-bccd-4441-86a5-c3de785e5243.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cc55531b-bccd-4441-86a5-c3de785e5243.png)'
- en: Then we have to add a new (polymorphic) method to each type of event with the
    single responsibility of determining if it corresponds to the data being passed
    or not, and we also have to change the logic to go through all events, finding
    the right one.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须为每种类型的事件添加一个新的（多态的）方法，其单一责任是确定它是否与传递的数据相对应，我们还必须改变逻辑以遍历所有事件，找到正确的事件。
- en: 'The new code should look like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码应该如下所示：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice how the interaction is now oriented toward an abstraction (in this case,
    it would be the generic base class `Event`, which might even be an abstract base
    class or an interface, but for the purposes of this example it is enough to have
    a concrete base class). The method no longer works with specific types of event,
    but just with generic events that follow a common interface—they are all polymorphic
    with respect to the `meets_condition` method.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在交互是针对抽象的（在这种情况下，它将是通用基类`Event`，甚至可能是一个抽象基类或接口，但对于这个例子来说，拥有一个具体的基类就足够了）。该方法不再使用特定类型的事件，而只是使用遵循通用接口的通用事件
    - 它们在`meets_condition`方法方面都是多态的。
- en: Notice how events are discovered through the `__subclasses__()` method. Supporting
    new types of event is now just about creating a new class for that event that
    has to inherit from `Event` and implement its own `meets_condition()` method,
    according to its specific business logic.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，事件是通过`__subclasses__()`方法发现的。支持新类型的事件现在只是创建一个新的事件类，该类必须继承自`Event`并根据其特定的业务逻辑实现自己的`meets_condition()`方法。
- en: Extending the events system
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展事件系统
- en: Now, let's prove that this design is actually as extensible as we wanted it
    to be. Imagine that a new requirement arises, and we have to also support events
    that correspond to transactions that the user executed on the monitored system.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们证明这个设计实际上是我们想要的那样具有可扩展性。想象一下，出现了一个新的需求，我们还必须支持与用户在监视系统上执行的交易相对应的事件。
- en: 'The class diagram for the design has to include such a new event type, as in
    the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 设计的类图必须包括这样一种新的事件类型，如下所示：
- en: '![](assets/870dd0e2-4e1f-416e-b4b6-415b4e0c1df1.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/870dd0e2-4e1f-416e-b4b6-415b4e0c1df1.png)'
- en: 'Only by adding the code to this new class does the logic keep working as expected:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 只需添加到这个新类的代码，逻辑就能按预期工作：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can verify that the previous cases work as before and that the new event
    is also correctly identified:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证以前的情况仍然像以前一样工作，并且新事件也被正确识别：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the `SystemMonitor.identify_event()` method did not change at all
    when we added the new event type. We, therefore, say that this method is closed with
    respect to new types of event.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们添加新的事件类型时，`SystemMonitor.identify_event()`方法根本没有改变。因此，我们说这个方法对于新类型的事件是封闭的。
- en: Conversely, the `Event` class allowed us to add a new type of event when we
    were required to do so. We then say that events are open for an extension with
    respect to new types.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`Event`类允许我们在需要时添加新类型的事件。然后我们说，事件对于新类型是开放的。
- en: This is the true essence of this principle—when something new appears on the
    domain problem, we only want to add new code, not modify existing code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这个原则的真正本质 - 当领域问题出现新的东西时，我们只想添加新的代码，而不是修改现有的代码。
- en: Final thoughts about the OCP
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于OCP的最终想法
- en: As you might have noticed, this principle is closely related to effective use
    of polymorphism. We want to design toward abstractions that respect a polymorphic
    contract that the client can use, to a structure that is generic enough that extending
    the model is possible, as long as the polymorphic relationship is preserved.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，这个原则与多态的有效使用密切相关。我们希望设计符合客户端可以使用的多态合同的抽象，以及足够通用以便扩展模型是可能的，只要多态关系得到保留。
- en: 'This principle tackles an important problem in software engineering: maintainability
    .The perils of not following the OCP are ripple effects and problems in the software
    where a single change triggers changes all over the code base, or risks breaking
    other parts of the code.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则解决了软件工程中的一个重要问题：可维护性。不遵循OCP的危险是连锁效应和软件中的问题，其中单个更改触发整个代码库的更改，或者有风险破坏代码的其他部分。
- en: One important final note is that, in order to achieve this design in which we
    do not change the code to extend behavior, we need to be able to create proper
    closure against the abstractions we want to protect (in this example, new types
    of event). This is not always possible in all programs, as some abstractions might
    collide (for example, we might have a proper abstraction that provides closure
    against a requirement, but does not work for other types of requirements). In
    these cases, we need to be selective and apply a strategy that provides the best
    closure for the types of requirement that require to be the most extensible.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的最终说明是，为了实现这种设计，我们需要能够对我们想要保护的抽象（在这个例子中是新类型的事件）进行适当的封闭。这在所有程序中并不总是可能的，因为一些抽象可能会发生冲突（例如，我们可能有一个适当的抽象，它提供了对一个需求的封闭，但对其他类型的需求却不起作用）。在这些情况下，我们需要有选择地应用一种策略，为需要最具可扩展性的需求提供最佳的封闭。
- en: Liskov's substitution principle
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Liskov的替换原则
- en: '**Liskov''s substitution principle** (**LSP**) states that there is a series
    of properties that an object type must hold to preserve reliability on its design.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**Liskov的替换原则**（**LSP**）规定了对象类型必须具有的一系列属性，以保持其设计的可靠性。'
- en: The main idea behind LSP is that, for any class, a client should be able to
    use any of its subtypes indistinguishably, without even noticing, and therefore
    without compromising the expected behavior at runtime. This means that clients
    are completely isolated and unaware of changes in the class hierarchy.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: LSP背后的主要思想是，对于任何类，客户端应该能够无法区分地使用其任何子类型，甚至在运行时也不会影响预期的行为。这意味着客户端完全与类层次结构的变化隔离和不知情。
- en: 'More formally, this is the original definition (LISKOV 01) of Liskov''s substitution
    principle: if *S* is a subtype of *T*, then objects of type *T* may be replaced
    by objects of type *S*, without breaking the program.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地说，这是Liskov替换原则的原始定义（LISKOV 01）：如果*S*是*T*的子类型，那么类型为*T*的对象可以被类型为*S*的对象替换，而不会破坏程序。
- en: This can be understood with the help of a generic diagram such as the following
    one. Imagine that there is some client class that requires (includes) objects
    of another type. Generally speaking, we will want this client to interact with
    objects of some type, namely, it will work through an interface.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过一个通用的图表来理解，比如下面的图表。想象一下，有一个客户类需要（包括）另一种类型的对象。一般来说，我们希望这个客户与某种类型的对象进行交互，换句话说，它将通过一个接口来工作。
- en: 'Now, this type might as well be just a generic interface definition, an abstract
    class or an interface, not a class with the behavior itself. There may be several
    subclasses extending this type (described in the diagram with the name **Subtype**,
    up to **N**). The idea behind this principle is that, if the hierarchy is correctly
    implemented, the client class has to be able to work with instances of any of
    the subclasses without even noticing. These objects should be interchangeable,
    as shown here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这种类型可能只是一个通用的接口定义，一个抽象类或一个接口，而不是具有行为本身的类。可能有几个子类扩展了这种类型（在图表中用名称**子类型**描述，最多**N**）。这个原则背后的想法是，如果层次结构被正确实现，客户类必须能够使用任何子类的实例而不会注意到。这些对象应该是可互换的，如下所示：
- en: '![](assets/2f7cb18f-e8c5-489c-aa5b-274ce34faf97.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2f7cb18f-e8c5-489c-aa5b-274ce34faf97.png)'
- en: This is related to other design principles we have already visited, like designing
    to interfaces. A good class must define a clear and concise interface, and as
    long as subclasses honor that interface, the program will remain correct.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们已经讨论过的其他设计原则相关，比如按接口设计。一个好的类必须定义一个清晰简洁的接口，只要子类遵守该接口，程序就会保持正确。
- en: As a consequence of this, the principle also relates to the ideas behind designing
    by contract. There is a contract between a given type and a client. By following
    the rules of LSP, the design will make sure that subclasses respect the contracts
    as they are defined by parent classes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一原则的结果，它也与按合同设计的思想相关。给定类型和客户之间有一个合同。通过遵循LSP的规则，设计将确保子类遵守由父类定义的合同。
- en: Detecting LSP issues with tools
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工具检测LSP问题
- en: There are some scenarios so notoriously wrong with respect to the LSP that they
    can be easily identified by the tools we have learned to configure in [Chapter
    1](bba62a64-dfe9-478f-9b33-6c3240d75f59.xhtml), *Introduction, Code Formatting,
    and Tools* (mainly Mypy and Pylint).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些与LSP相关的情景是如此明显错误，以至于我们学会配置的工具（主要是Mypy和Pylint）可以轻松识别。
- en: Detecting incorrect datatypes in method signatures with Mypy
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mypy检测方法签名中的不正确数据类型
- en: By using type annotations (as recommended previously in [Chapter 1](bba62a64-dfe9-478f-9b33-6c3240d75f59.xhtml),
    *Introduction, Code Formatting, and Tools*), throughout our code, and configuring
    Mypy, we can quickly detect some basic errors early, and check basic compliance
    with LSP for free.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在整个代码中使用类型注释（如之前在[第1章](bba62a64-dfe9-478f-9b33-6c3240d75f59.xhtml)中推荐的，*介绍、代码格式和工具*），并配置Mypy，我们可以快速检测到一些基本错误，并免费检查LSP的基本合规性。
- en: 'If one of the subclasses of the `Event` class were to override a method in
    an incompatible fashion, Mypy would notice this by inspecting the annotations:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Event`类的一个子类以不兼容的方式覆盖了一个方法，Mypy会通过检查注释来注意到这一点：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we run Mypy on this file, we will get an error message saying the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这个文件上运行Mypy时，将会得到一个错误消息，内容如下：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The violation to LSP is clear—since the derived class is using a type for the
    `event_data` parameter which is different from the one defined on the base class,
    we cannot expect them to work equally. Remember that, according to this principle,
    any caller of this hierarchy has to be able to work with `Event` or `LoginEvent`
    transparently, without noticing any difference. Interchanging objects of these
    two types should not make the application fail. Failure to do so would break the
    polymorphism on the hierarchy.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: LSP的违反是明显的——因为派生类使用了与基类定义的类型不同的`event_data`参数类型，我们不能指望它们能够同样工作。请记住，根据这个原则，这个层次结构的任何调用者都必须能够透明地使用`Event`或`LoginEvent`，而不会注意到任何差异。这两种类型的对象可以互换，不应该使应用程序失败。如果不能做到这一点，将会破坏层次结构上的多态性。
- en: The same error would have occurred if the return type was changed for something
    other than a Boolean value. The rationale is that clients of this code are expecting
    a Boolean value to work with. If one of the derived classes changes this return
    type, it would be breaking the contract, and again, we cannot expect the program
    to continue working normally.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回类型被更改为布尔值之外的其他值，同样的错误也会发生。其理由是这段代码的客户端期望使用布尔值。如果派生类中的一个更改了这个返回类型，它将违反合同，再次，我们不能指望程序会继续正常工作。
- en: 'A quick note about types that are not the same but share a common interface:
    even though this is just a simple example to demonstrate the error, it is still
    true that both dictionaries and lists have something in common; they are both
    iterables. This means that in some cases, it might be valid to have a method that
    expects a dictionary and another one expecting to receive a list, as long as both
    treat the parameters through the iterable interface. In this case, the problem
    would not lie in the logic itself (LSP might still apply), but in the definition
    of the types of the signature, which should read neither `list` nor `dict`, but
    a union of both. Regardless of the case, something has to be modified, whether
    it is the code of the method, the entire design, or just the type annotations,
    but in no case should we silence the warning and ignore the error given by Mypy.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 关于类型不同但共享公共接口的快速说明：尽管这只是一个简单的例子来演示错误，但事实上字典和列表都有一些共同之处；它们都是可迭代的。这意味着在某些情况下，可能会有一个方法期望接收一个字典，另一个方法期望接收一个列表，只要两者都通过可迭代接口处理参数，这可能是有效的。在这种情况下，问题不在于逻辑本身（LSP可能仍然适用），而在于签名类型的定义，它们既不应该是`list`也不应该是`dict`，而是两者的并集。无论如何，都必须修改一些东西，无论是方法的代码、整个设计，还是类型注释，但在任何情况下，我们都不应该消除警告并忽略Mypy给出的错误。
- en: 'Do not ignore errors such as this by using `# type: ignore` or something similar.
    Refactor or change the code to solve the real problem. The tools are reporting
    an actual design flaw for a valid reason.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '不要通过`# type: ignore`或类似的方式忽略这样的错误。重构或更改代码以解决真正的问题。工具之所以报告实际的设计缺陷是有充分理由的。'
- en: Detecting incompatible signatures with Pylint
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pylint检测不兼容的签名
- en: Another strong violation of LSP is when, instead of varying the types of the
    parameters on the hierarchy, the signatures of the methods differ completely.
    This might seem like quite a blunder, but detecting it would not always be so
    easy to remember; Python is interpreted, so there is no compiler to detect these
    type of error early on, and therefore they will not be caught until runtime. Luckily,
    we have static code analyzers such as Mypy and Pylint to catch errors such as
    this one early on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: LSP的另一个严重违规是，与其在层次结构中变化参数的类型，方法的签名完全不同。这可能看起来像一个大错误，但要检测它并不总是那么容易记住；Python是解释性语言，所以没有编译器能够及早检测到这种类型的错误，因此它们直到运行时才会被捕获。幸运的是，我们有静态代码分析器，如Mypy和Pylint，可以及早捕获这类错误。
- en: While Mypy will also catch these type of error, it is not bad to also run Pylint
    to gain more insight.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Mypy也会捕捉到这种类型的错误，但同时运行Pylint以获得更多的见解也不是坏事。
- en: 'In the presence of a class that breaks the compatibility defined by the hierarchy
    (for example, by changing the signature of the method, adding an extra parameter,
    and so on) shown as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在存在一个违反层次结构定义的类的情况下（例如，通过更改方法的签名，添加额外参数等），如下所示：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Pylint will detect it, printing an informative error:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Pylint将检测到它，并打印出一个信息性的错误：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once again, like in the previous case, do not suppress these errors. Pay attention
    to the warnings and errors the tools give and adapt the code accordingly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，就像在先前的情况下一样，不要压制这些错误。注意工具给出的警告和错误，并相应地调整代码。
- en: More subtle cases of LSP violations
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更微妙的LSP违规案例
- en: In other cases, however, the way LSP is broken is not so clear or obvious that
    a tool can automatically identify it for us, and we have to rely upon careful
    code inspection when doing a code review.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在其他情况下，LSP被破坏的方式并不那么清晰或明显，工具无法自动识别，我们必须依靠仔细的代码检查进行代码审查。
- en: Cases where contracts are modified are particularly harder to detect automatically.
    Given that the entire idea of LSP is that subclasses can be used by clients just
    like their parent class, it must also be true that contracts are correctly preserved
    on the hierarchy.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 修改合同的情况特别难以自动检测。鉴于LSP的整个理念是子类可以像其父类一样被客户使用，这也意味着合同在层次结构上必须得到正确保留。
- en: Remember from [Chapter 3,](0aec97c9-5777-4cd5-8c76-134440c49402.xhtml) *General
    Traits of Good Code*, that, when designing by contract, the contract between the
    client and supplier sets some rules—the client must provide the preconditions
    to the method, which the supplier might validate, and it returns some result to
    the client that it will check in the form of postconditions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住[第3章](0aec97c9-5777-4cd5-8c76-134440c49402.xhtml)中提到的*良好代码的一般特征*，即在按合同设计时，客户和供应商之间的合同设定了一些规则——客户必须提供方法的前置条件，供应商可能会验证，然后以后置条件的形式返回一些结果给客户进行检查。
- en: 'The parent class defines a contract with its clients. Subclasses of this one
    must respect such a contract. This means that, for example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 父类与其客户定义了一个合同。这个类的子类必须尊重这样的合同。这意味着，例如：
- en: A subclass can never make preconditions stricter than they are defined on the
    parent class
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类永远不能使前置条件比父类中定义的更严格
- en: A subclass can never make postconditions weaker than they are defined on the
    parent class
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类永远不能使后置条件比父类中定义的更弱
- en: Consider the example of the events hierarchy defined in the previous section,
    but now with a change to illustrate the relationship between LSP and DbC.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前一节中定义的事件层次结构的例子，但现在通过一个变化来说明LSP和DbC之间的关系。
- en: This time, we are going to assume a precondition for the method that checks
    the criteria based on the data, that the provided parameter must be a dictionary
    that contains both keys `"before"` and `"after"`, and that their values are also
    nested dictionaries. This allows us to encapsulate even further, because now the
    client does not need to catch the `KeyError` exception, but instead just calls
    the precondition method (assuming that is acceptable to fail if the system is
    operating under the wrong assumptions). As a side note, it is good that we can
    remove this from the client, as now, `SystemMonitor` does not require to know
    which types of exceptions the methods of the collaborator class might raise (remember
    that exception weaken encapsulation, as they require the caller to know something
    extra about the object they are calling).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们假设了一个方法的前提条件，根据数据检查标准，提供的参数必须是一个包含`"before"`和`"after"`两个键的字典，并且它们的值也是嵌套字典。这使我们能够进一步封装，因为现在客户端不需要捕获`KeyError`异常，而只需调用前提条件方法（假设如果系统在错误的假设下运行是可以失败的）。顺便说一句，很好的是我们可以从客户端中删除这个，因为现在，`SystemMonitor`不需要知道协作者类的方法可能引发哪些类型的异常（请记住，异常会削弱封装，因为它们要求调用者对其所调用的对象有额外的了解）。
- en: 'Such a design might be represented with the following changes in the code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计可以通过代码中的以下更改来表示：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And now the code that tries to detect the correct event type just checks the
    precondition once, and proceeds to find the right type of event:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试检测正确事件类型的代码只检查前提条件一次，然后继续找到正确类型的事件：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The contract only states that the top-level keys `"before"` and `"after"` are
    mandatory and that their values should also be dictionaries. Any attempt in the
    subclasses to demand a more restrictive parameter will fail.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 合同只规定顶层键`"before"`和`"after"`是必须的，它们的值也应该是字典。在子类中试图要求更严格的参数将会失败。
- en: 'The class for the transaction event was originally correctly designed. Look
    at how the code does not impose a restriction on the internal key named `"transaction"`;
    it only uses its value if it is there, but this is not mandatory:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 交易事件的类最初设计是正确的。看看代码如何不对内部名为`"transaction"`的键施加限制；它只在那里使用它的值，但这不是强制性的：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, the original two methods are not correct, because they demand the presence
    of a key named `"session"`, which is not part of the original contract. This breaks
    the contract, and now the client cannot use these classes in the same way it uses
    the rest of them because it will raise `KeyError`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，原始的两个方法是不正确的，因为它们要求存在一个名为`"session"`的键，这不是原始合同的一部分。这违反了合同，现在客户端无法像使用其他类一样使用这些类，因为它会引发`KeyError`。
- en: 'After fixing this (changing the square brackets for the `.get()` method), the
    order on the LSP has been reestablished, and polymorphism prevails:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复这个问题之后（更改了`.get()`方法的方括号），LSP的顺序已经恢复，多态性占优势：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It is unreasonable to expect automated tools (regardless of how good and helpful
    they are), will detect cases such as this one. We have to be careful when designing
    classes that we do not accidentally change the input or output of the methods
    in a way that would be incompatible with what the clients are originally expecting.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 期望自动化工具（无论它们有多好和有用）能够检测到这种情况是不合理的。在设计类时，我们必须小心，不要意外地改变方法的输入或输出，以使其与客户端最初期望的不兼容。
- en: Remarks on the LSP
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LSP的备注
- en: The LSP is fundamental to a good object-oriented software design because it
    emphasizes one of its core traits—polymorphism. It is about creating correct hierarchies
    so that classes derived from a base one are polymorphic along the parent one,
    with respect to the methods on their interface.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: LSP对于良好的面向对象软件设计是至关重要的，因为它强调了其核心特性之一——多态性。它是关于创建正确的层次结构，使得从基类派生的类在其接口的方法方面对父类具有多态性。
- en: It is also interesting to notice how this principle relates to the previous
    one—if we attempt to extend a class with a new one that is incompatible, it will
    fail, the contract with the client will be broken, and as a result such an extension
    will not be possible (or, to make it possible, we would have to break the other
    end of the principle and modify code in the client that should be closed for modification,
    which is completely undesirable and unacceptable).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是注意到这个原则如何与前一个原则相关联——如果我们尝试用一个不兼容的新类扩展一个类，它将失败，与客户端的合同将被打破，因此这样的扩展将不可能（或者，为了使其可能，我们将不得不打破原则的另一端，并修改应该对修改封闭的客户端代码，这是完全不可取和不可接受的）。
- en: Carefully thinking about new classes in the way that LSP suggests helps us to
    extend the hierarchy correctly. We could then say that LSP contributes to the
    OCP.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细思考LSP建议的新类的方式有助于我们正确地扩展层次结构。然后我们可以说LSP有助于OCP。
- en: Interface segregation
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口隔离
- en: 'The **interface segregation principle** (**ISP**) provides some guidelines
    over an idea that we have revisited quite repeatedly already: that interfaces
    should be small.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口隔离原则**（ISP）提供了一些关于我们已经反复讨论过的想法的指导：接口应该是小的。'
- en: In object-oriented terms, an **interface** is represented by the set of methods
    an object exposes. This is to say that all the messages that an object is able
    to receive or interpret constitute its interface, and this is what other clients
    can request. The interface separates the definition of the exposed behavior for
    a class from its implementation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的术语中，**接口**由对象公开的方法集表示。这就是说，对象能够接收或解释的所有消息构成了它的接口，这是其他客户端可以请求的内容。接口将类的公开行为的定义与其实现分离开来。
- en: In Python, interfaces are implicitly defined by a class according to its methods.
    This is because Python follows the so-called **duck typing** principle.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，接口是根据类的方法隐式定义的。这是因为Python遵循所谓的**鸭子类型**原则。
- en: Traditionally, the idea behind duck typing was that any object is really represented
    by the methods it has, and by what it is capable of doing. This means that, regardless
    of the type of the class, its name, its docstring, class attributes, or instance
    attributes, what ultimately defines the essence of the object are the methods
    it has. The methods defined on a class (what it knows how to do) are what determines
    what that object will actually be. It was called duck typing because of the idea
    that "If it walks like a duck, and quacks like a duck, it must be a duck."
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，鸭子类型的理念是任何对象实际上是由它所拥有的方法和它能够做什么来表示的。这意味着，无论类的类型、名称、文档字符串、类属性或实例属性如何，最终定义对象本质的是它所拥有的方法。类上定义的方法（它知道如何做）决定了对象实际上是什么。它被称为鸭子类型，是因为“如果它走起来像鸭子，叫起来像鸭子，那它一定是鸭子”。
- en: For a long time, duck typing was the sole way interfaces were defined in Python.
    Later on, Python 3 (PEP-3119) introduced the concept of abstract base classes
    as a way to define interfaces in a different way. The basic idea of abstract base
    classes is that they define a basic behavior or interface that some derived classes
    are responsible for implementing. This is useful in situations where we want to
    make sure that certain critical methods are actually overridden, and it also works
    as a mechanism for overriding or extending the functionality of methods such as
    `isinstance()`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间以来，鸭子类型是Python中定义接口的唯一方式。后来，Python 3（PEP-3119）引入了抽象基类的概念，作为一种以不同方式定义接口的方法。抽象基类的基本思想是它定义了一种基本行为或接口，一些派生类负责实现。这在我们想要确保某些关键方法实际上被覆盖时非常有用，它还可以作为覆盖或扩展诸如`isinstance()`之类方法功能的机制。
- en: This module also contains a way of registering some types as part of a hierarchy,
    in what is called a **virtual subclass**. The idea is that this extends the concept
    of duck typing a little bit further by adding a new criterion—walks like a duck,
    quacks like a duck, or... it says it is a duck.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块还包含一种将某些类型注册为层次结构的一部分的方法，称为**虚拟子类**。其想法是通过添加一个新的标准——走起来像鸭子，叫起来像鸭子，或者...它说它是鸭子，将鸭子类型的概念扩展得更远一些。
- en: These notions of how Python interprets interfaces are important for understanding
    this principle and the next one.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Python解释接口的这些概念对于理解这个原则和下一个原则非常重要。
- en: In abstract terms, this means that the ISP states that, when we define an interface
    that provides multiple methods, it is better to instead break it down into multiple
    ones, each one containing fewer methods (preferably just one), with a very specific
    and accurate scope. By separating interfaces into the smallest possible units,
    to favor code reusability, each class that wants to implement one of these interfaces
    will most likely be highly cohesive given that it has a quite definite behavior
    and set of responsibilities.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象地说，这意味着ISP规定，当我们定义一个提供多个方法的接口时，最好将其分解为多个接口，每个接口包含较少的方法（最好只有一个），具有非常具体和准确的范围。通过将接口分离为尽可能小的单元，以促进代码的可重用性，想要实现这些接口之一的每个类很可能会具有高度的内聚性，因为它具有相当明确的行为和一组责任。
- en: An interface that provides too much
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供太多方法的接口
- en: 'Now, we want to be able to parse an event from several data sources, in different
    formats (XML and JSON, for instance). Following good practice, we decide to target
    an interface as our dependency instead of a concrete class, and something like
    the following is devised:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望能够从不同格式的多个数据源中解析事件（例如XML和JSON）。遵循良好的实践，我们决定将接口作为我们的依赖目标，而不是具体的类，设计如下：
- en: '![](assets/751713a3-59f5-476d-8481-80da4896f722.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/751713a3-59f5-476d-8481-80da4896f722.png)'
- en: In order to create this as an interface in Python, we would use an abstract
    base class and define the methods (`from_xml()` and `from_json()`) as abstract,
    to force derived classes to implement them. Events that derive from this abstract
    base class and implement these methods would be able to work with their corresponding
    types.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Python中将其创建为接口，我们将使用抽象基类，并将方法（`from_xml()`和`from_json()`）定义为抽象的，以强制派生类实现它们。从这个抽象基类派生并实现这些方法的事件将能够处理它们对应的类型。
- en: But what if a particular class does not need the XML method, and can only be
    constructed from a JSON? It would still carry the `from_xml()` method from the
    interface, and since it does not need it, it will have to pass. This is not very
    flexible as it creates coupling and forces clients of the interface to work with
    methods that they do not need.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果特定的类不需要XML方法，只能从JSON构建，它仍然会携带接口的`from_xml()`方法，因为它不需要它，它将不得不通过。这不太灵活，因为它会创建耦合，并迫使接口的客户端使用它们不需要的方法。
- en: The smaller the interface, the better
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口越小，越好。
- en: 'It would be better to separate this into two different interfaces, one for
    each method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将其分成两个不同的接口，每个接口对应一个方法：
- en: '![](assets/979e5d6b-abc5-48da-9353-5bce32fea19f.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/979e5d6b-abc5-48da-9353-5bce32fea19f.png)'
- en: With this design, objects that derive from `XMLEventParser` and implement the
    `from_xml()` method will know how to be constructed from an XML, and the same
    for a JSON file, but most importantly, we maintain the orthogonality of two independent
    functions, and preserve the flexibility of the system without losing any functionality
    that can still be achieved by composing new smaller objects.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种设计，从`XMLEventParser`派生并实现`from_xml()`方法的对象将知道如何从XML构建，从JSON文件构建也是一样，但更重要的是，我们保持了两个独立函数的正交性，并保留了系统的灵活性，而不会失去可以通过组合新的较小对象实现的任何功能。
- en: There is some resemblance to the SRP, but the main difference is that here we
    are talking about interfaces, so it is an abstract definition of behavior. There
    is no reason to change because there is nothing there until the interface is actually
    implemented. However, failure to comply with this principle will create an interface
    that will be coupled with orthogonal functionality, and this derived class will
    also fail to comply with the SRP (it will have more than one reason to change).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与SRP有些相似，但主要区别在于这里我们谈论的是接口，因此它是行为的抽象定义。没有理由改变，因为在接口实际实现之前什么都没有。然而，不遵守这个原则将创建一个与正交功能耦合的接口，这个派生类也将无法遵守SRP（它将有多个改变的原因）。
- en: How small should an interface be?
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口应该有多小？
- en: The point made in the previous section is valid, but it also needs a warning—avoid
    a dangerous path if it's misunderstood or taken to the extreme.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节提出的观点是有效的，但也需要警告——如果被误解或被过分解读，要避免走上危险的道路。
- en: A base class (abstract or not) defines an interface for all the other classes
    to extend it. The fact that this should be as small as possible has to be understood
    in terms of cohesion—it should do one thing. That doesn't mean it must necessarily
    have one method. In the previous example, it was by coincidence that both methods
    were doing totally disjoint things, hence it made sense to separate them into
    different classes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 基类（抽象或非抽象）为所有其他类定义了一个接口来扩展它。这应该尽可能小的事实必须以内聚性的方式理解——它应该只做一件事。这并不意味着它一定必须有一个方法。在前面的例子中，巧合的是两种方法完全不同，因此将它们分开成不同的类是有意义的。
- en: 'But it could be the case that more than one method rightfully belongs to the
    same class. Imagine that you want to provide a mixin class that abstracts certain
    logic in a context manager so that all classes derived from that mixin gain that
    context manager logic for free. As we already know, a context manager entails
    two methods: `__enter__` and `__exit__`. They must go together, or the outcome
    will not be a valid context manager at all!'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 但也可能有多个方法合理地属于同一个类。想象一下，您想提供一个混合类，它在上下文管理器中抽象出某些逻辑，以便所有从该混合类派生的类都可以免费获得该上下文管理器逻辑。正如我们已经知道的那样，上下文管理器包括两种方法：`__enter__`和`__exit__`。它们必须一起使用，否则结果将根本不是有效的上下文管理器！
- en: Failure to place both methods in the same class will result in a broken component
    that is not only useless, but also misleadingly dangerous. Hopefully, this exaggerated
    example works as a counter-balance to the one in the previous section, and together
    the reader can get a more accurate picture about designing interfaces.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不将两种方法放在同一个类中，将导致一个破损的组件，不仅毫无用处，而且具有误导性的危险。希望这个夸张的例子能够对前一节中的例子起到平衡作用，读者可以更准确地了解设计接口。
- en: Dependency inversion
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖反转
- en: This is a really powerful idea that will come up again later when we explore
    some design patterns in [Chapter 9](dee5b4ed-34cd-4077-a5b4-83d4853e6e56.xhtml), *Common
    Design Patterns*,and [Chapter 10](87530c54-bf97-48c2-a557-de448cd690d4.xhtml), *Clean
    Architecture*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常强大的想法，当我们在[第9章](dee5b4ed-34cd-4077-a5b4-83d4853e6e56.xhtml)中探索一些设计模式时，它将再次出现，以及[第10章](87530c54-bf97-48c2-a557-de448cd690d4.xhtml)中的*清晰架构*。
- en: 'The **dependency inversion principle** (**DIP**) proposes an interesting design
    principle by which we protect our code by making it independent of things that
    are fragile, volatile, or out of our control. The idea of inverting dependencies
    is that our code should not adapt to details or concrete implementations, but
    rather the other way around: we want to force whatever implementation or detail
    to adapt to our code via a sort of API.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖反转原则**（DIP）提出了一个有趣的设计原则，通过它我们可以保护我们的代码，使其不依赖于脆弱、易变或超出我们控制范围的东西。反转依赖的想法是，我们的代码不应该适应细节或具体实现，而是相反的：我们希望通过一种API强制任何实现或细节适应我们的代码。'
- en: Abstractions have to be organized in such a way that they do not depend on details,
    but rather the other way around—the details (concrete implementations) should
    depend on abstractions.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象必须以不依赖于细节的方式组织，而是相反的方式——细节（具体实现）应该依赖于抽象。
- en: 'Imagine that two objects in our design need to collaborate, `A` and `B`. `A`
    works with an instance of `B`, but as it turns out, our module doesn''t control
    `B` directly (it might be an external library, or a module maintained by another
    team, and so on). If our code heavily depends on `B`, when this changes the code
    will break. To prevent this, we have to invert the dependency: make `B` have to
    adapt to `A`. This is done by presenting an interface and forcing our code not
    to depend on the concrete implementation of `B`, but rather on the interface we
    have defined. It is then `B`''s responsibility to comply with that interface.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们设计中的两个对象需要合作，`A`和`B`。`A`与`B`的实例一起工作，但事实证明，我们的模块并不直接控制`B`（它可能是外部库，或者是由另一个团队维护的模块等）。如果我们的代码严重依赖于`B`，当这种情况发生变化时，代码将会崩溃。为了防止这种情况，我们必须反转依赖：使`B`必须适应`A`。这是通过提供一个接口并强制我们的代码不依赖于`B`的具体实现，而是依赖于我们定义的接口来完成的。然后，`B`有责任遵守该接口。
- en: In line with the concepts explored in previous sections, abstractions also come
    in the form of interfaces (or abstract base classes in Python).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几节探讨的概念一致，抽象也以接口的形式出现（或者在Python中是抽象基类）。
- en: In general, we could expect concrete implementations to change much more frequently
    than abstract components. It is for this reason that we place abstractions (interfaces)
    as flexibility points where we expect our system to change, be modified, or extended
    without the abstraction itself having to be changed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们可以期望具体实现的变化频率要比抽象组件高得多。正因为如此，我们将抽象（接口）放在我们期望系统发生变化、被修改或扩展的灵活性点上，而不必更改抽象本身。
- en: A case of rigid dependencies
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚性依赖的情况
- en: 'The last part of our event''s monitoring system is to deliver the identified
    events to a data collector to be further analyzed. A naive implementation of such
    an idea would consist of having an event streamer class that interacts with a
    data destination, for example, `Syslog`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们事件监控系统的最后一部分是将识别的事件传递给数据收集器进行进一步分析。这样一个想法的天真实现将包括一个与数据目标交互的事件流类，例如`Syslog`：
- en: '![](assets/27118de7-913e-4957-94b4-f3b2394f2006.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/27118de7-913e-4957-94b4-f3b2394f2006.png)'
- en: However, this design is not very good, because we have a high-level class (`EventStreamer`)
    depending on a low-level one (`Syslog` is an implementation detail). If something
    changes in the way we want to send data to `Syslog`, `EventStreamer` will have
    to be modified. If we want to change the data destination for a different one
    or add new ones at runtime, we are also in trouble because we will find ourselves
    constantly modifying the `stream()` method to adapt it to these requirements.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种设计并不是很好，因为我们有一个高级类（`EventStreamer`）依赖于一个低级类（`Syslog`是一个实现细节）。如果我们想要以不同的方式发送数据到`Syslog`，`EventStreamer`将不得不进行修改。如果我们想要在运行时更改数据目标为另一个目标或添加新目标，我们也会遇到麻烦，因为我们将不断修改`stream()`方法以适应这些要求。
- en: Inverting the dependencies
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 倒置依赖关系
- en: 'The solution to these problems is to make `EventStreamer` work with an interface,
    rather than a concrete class. This way, implementing this interface is up to the
    low-level classes that contain the implementation details:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题的方法是使`EventStreamer`使用接口而不是具体类。这样，实现这个接口取决于包含实现细节的低级类：
- en: '![](assets/530270e6-552a-4c55-b49f-777b4ec37080.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/530270e6-552a-4c55-b49f-777b4ec37080.png)'
- en: Now there is an interface that represents a generic data target where data is
    going to be sent to. Notice how the dependencies have now been inverted since `EventStreamer`
    does not depend on a concrete implementation of a particular data target, it does
    not have to change in line with changes on this one, and it is up to every particular
    data target; to implement the interface correctly and adapt to changes if necessary.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个表示通用数据目标的接口，数据将被发送到该接口。请注意，依赖关系已经被倒置，因为`EventStreamer`不依赖于特定数据目标的具体实现，它不必随着此数据目标的更改而更改，而是由每个特定的数据目标来正确实现接口并根据需要进行调整。
- en: In other words, the original `EventStreamer` of the first implementation only
    worked with objects of type `Syslog`, which was not very flexible. Then we realized
    that it could work with any object that could respond to a `.send()` message,
    and identified this method as the interface that it needed to comply with. Now,
    in this version, `Syslog` is actually extending the abstract base class named
    `DataTargetClient`, which defines the `send()` method. From now on, it is up to
    every new type of data target (email, for instance) to extend this abstract base
    class and implement the `send()` method.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，第一个实现的原始`EventStreamer`只能与类型为`Syslog`的对象一起工作，这并不太灵活。然后我们意识到它可以与任何能够响应`.send()`消息的对象一起工作，并确定这个方法是它需要遵守的接口。现在，在这个版本中，`Syslog`实际上是扩展了名为`DataTargetClient`的抽象基类，该类定义了`send()`方法。从现在开始，每种新类型的数据目标（例如电子邮件）都要扩展这个抽象基类并实现`send()`方法。
- en: 'We can even modify this property at runtime for any other object that implements
    a `send()` method, and it will still work. This is the reason why it is often
    called **dependency injection**: because the dependency can be provided dynamically.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在运行时修改此属性以适用于实现`send()`方法的任何其他对象，它仍然可以工作。这就是为什么它经常被称为**依赖注入**的原因：因为依赖关系可以动态提供。
- en: 'The avid reader might be wondering why this is actually necessary. Python is
    flexible enough (sometimes too flexible), and will allow us to provide an object
    like `EventStreamer` with any particular data target object, without this one
    having to comply with any interface because it is dynamically typed. The question
    is this: why do we need to define the abstract base class (interface) at all when
    we can simply pass an object with a `send()` method to it?'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 热心的读者可能会想知道为什么这是必要的。Python足够灵活（有时太灵活了），并且允许我们向`EventStreamer`提供任何特定数据目标对象，而无需该对象遵守任何接口，因为它是动态类型的。问题是：当我们可以简单地向其传递具有`send()`方法的对象时，为什么我们需要定义抽象基类（接口）呢？
- en: In all fairness, this is true; there is actually no need to do that, and the
    program will work just the same. After all, polymorphism does not mean (or require)
    inheritance to work. However, defining the abstract base class is a good practice
    that comes with some advantages, the first one being duck typing. Together with
    as duck typing, we can mention the fact that the models become more readable—remember
    that inheritance follows the rule of **is a**, so by declaring the abstract base
    class and extending from it, we are saying that, for instance, `Syslog` is `DataTargetClient`,
    which is something users of your code can read and understand (again, this is
    duck typing).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，这是真的；实际上并不需要这样做，程序仍然可以正常工作。毕竟，多态性并不意味着（或要求）继承才能工作。然而，定义抽象基类是一种良好的实践，带来了一些优势，第一个优势是鸭子类型。除了鸭子类型，我们还可以提到模型变得更易读的事实——请记住，继承遵循**是一个**规则，因此通过声明抽象基类并从中扩展，我们在说，例如，`Syslog`是`DataTargetClient`，这是您的代码用户可以阅读和理解的内容（再次强调，这是鸭子类型）。
- en: All in all, it is not mandatory to define the abstract base class, but it is
    desirable in order to achieve a cleaner design. This is one of the things this
    book is for—to help programmers avoid easy-to-make mistakes, just because Python
    is too flexible and we can get away with it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，定义抽象基类并不是强制性的，但为了实现更清晰的设计是值得的。这本书的目的之一就是帮助程序员避免犯易犯的错误，因为Python太灵活了，我们可以逃避这些错误。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The SOLID principles are key guidelines for good object-oriented software design.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则是良好的面向对象软件设计的关键指导原则。
- en: Building software is an incredibly hard task—the logic of the code is complex,
    its behavior at runtime is hard (if even possible, sometimes) to predict, requirements
    change constantly as well as the environment, and there are multiple things that
    can go wrong.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 构建软件是一项非常艰巨的任务——代码的逻辑是复杂的，它在运行时的行为很难（有时甚至是不可能）预测，要求不断变化，环境也在不断变化，还有很多事情可能会出错。
- en: In addition, there are multiple ways of constructing software with different
    techniques, paradigms, and a lot of different designs, which can work together
    to solve a particular problem in a specific manner. However, not all of these
    approaches will prove to be correct as time passes, and requirements change or
    evolve. However, by this time, it will already be too late to do something about
    an incorrect design, as it is rigid, inflexible, and therefore hard to change
    a refactor into the proper solution.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有多种构建软件的方式，不同的技术、范式和许多不同的设计可以共同解决特定问题。然而，并非所有这些方法随着时间的推移都会被证明是正确的，要求也会变化或演变。然而，到那时，要对不正确的设计做出改变已经为时已晚，因为它是僵化的、不灵活的，因此很难将其重构为正确的解决方案。
- en: This means that, if we get the design wrong, it will costs us a lot in the future.
    How can we then achieve a good design that will eventually pay off? The answer
    is that we do not know for sure. We are dealing with the future, and the future
    is uncertain—there is no way to determine if our design will be correct and if
    our software will be flexible and adaptable in years to come. It is precisely
    for that reason that we have to stick to principles.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果我们设计错误，将会在未来付出很大的代价。那么我们如何才能实现最终会有回报的良好设计呢？答案是我们并不确定。我们正在处理未来，而未来是不确定的——我们无法确定我们的设计是否正确，我们的软件是否在未来几年内灵活和适应。正是因为这个原因，我们必须坚持原则。
- en: This is where the SOLID principles come into play. They are not a magic rule
    (after all, there are no silver bullets in software engineering), but they provide
    good guidelines to follow that have been proven to work in past projects and will
    make our software much more likely to succeed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是SOLID原则发挥作用的地方。它们并不是魔法规则（毕竟，在软件工程中没有银弹），但它们提供了良好的指导方针，这些指导方针在过去的项目中已被证明有效，并且会使我们的软件更有可能成功。
- en: In this chapter, we have explored the SOLID principles with the goal of understanding
    clean design. In the following chapters, we will continue to explore details of
    the language, and see in some cases how these tools and features can be used with
    these principles.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了SOLID原则，目的是理解清晰的设计。在接下来的章节中，我们将继续探讨语言的细节，并在某些情况下看到这些工具和特性如何与这些原则一起使用。
- en: References
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Here is a list of information you may refer to:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以参考的信息列表：
- en: '*SRP 01*: The Single Responsibility Principle ([https://8thlight.com/blog/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html](https://8thlight.com/blog/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html))'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SRP 01*：单一责任原则（[https://8thlight.com/blog/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html](https://8thlight.com/blog/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html)）'
- en: '*PEP-3119*: Introducing Abstract Base Classes ([https://www.python.org/dev/peps/pep-3119/](https://www.python.org/dev/peps/pep-3119/))'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-3119*：引入抽象基类（[https://www.python.org/dev/peps/pep-3119/](https://www.python.org/dev/peps/pep-3119/)）'
- en: '*LISKOV 01*: A paper written by Barbara Liskov named *Data Abstraction and
    Hierarchy*'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*LISKOV 01*：由Barbara Liskov撰写的一篇名为*数据抽象和层次结构*的论文。'
