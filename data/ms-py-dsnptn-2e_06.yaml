- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Architectural Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构设计模式
- en: In the previous chapter, we covered **behavioral patterns**, patterns that help
    with object interconnection and algorithms. The next category of design patterns
    is **architectural design patterns**. These patterns provide a template for solving
    common architectural problems, facilitating the development of scalable, maintainable,
    and reusable systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了 **行为模式**，这些模式有助于对象交互和算法。下一个设计模式类别是 **架构设计模式**。这些模式提供了解决常见架构问题的模板，促进了可扩展、可维护和可重用系统的开发。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: The **Model-View-Controller** (**MVC**) pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器** （**MVC**） 模式'
- en: The **Microservices** pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务** 模式'
- en: The **Serverless** pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无服务器** 模式'
- en: The **Event** **Sourcing** pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件** **溯源** 模式'
- en: Other architectural design patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他架构设计模式
- en: At the end of this chapter, you will understand how to build robust and flexible
    software using popular architectural design patterns.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将了解如何使用流行的架构设计模式构建健壮且灵活的软件。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术需求
- en: 'See the requirements presented in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017).
    The additional technical requirements for the code discussed in this chapter are
    the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [第 1 章](B21896_01.xhtml#_idTextAnchor017) 中提出的需求。本章讨论的代码的附加技术需求如下：
- en: 'For the *Microservices pattern* section, install the following:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 *微服务模式* 部分，请安装以下内容：
- en: '`python -m pip` `install grpcio`'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令：`python -m pip install grpcio`
- en: '`python -m pip` `install grpcio-tools`'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`python -m pip install grpcio-tools`'
- en: '`python -m pip install "lanarky[openai]"==0.8.6 uvicorn==0.29.0` (Note that
    this is not compatible with Python 3.12, at the time of writing. In this case,
    you may reproduce the related example using Python 3.11 instead.)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`python -m pip install "lanarky[openai]"==0.8.6 uvicorn==0.29.0` （注意，在撰写本文时，这可能与
    Python 3.12 不兼容。在这种情况下，您可以使用 Python 3.11 来重现相关示例。）'
- en: 'For the *Serverless pattern* section, install the following:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 *无服务器模式* 部分，请安装以下内容：
- en: '`python –m pip install localstack` (Note that this is not compatible with Python
    3.12, at the time of writing. You may use Python 3.11 instead for this case.)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令：`python –m pip install localstack` （注意，在撰写本文时，这可能与 Python 3.12 不兼容。您可以使用
    Python 3.11 来替代。）
- en: '`python -m pip` `install awscli-local`'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令：`python -m pip install awscli-local`
- en: '`awscli`, using the command: `python -m pip` `install awscli`'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令：`python -m pip install awscli`
- en: 'For the *Event Sourcing* section, install the following:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 *事件溯源* 部分，请安装以下内容：
- en: '`eventsourcing`, using the command: `python –m pip` `install eventsourcing`'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令：`python –m pip install eventsourcing`
- en: The MVC pattern
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC 模式
- en: 'The MVC pattern is another application of the **loose coupling** principle.
    The name of the pattern comes from the three main components used to split a software
    application: the model, the view, and the controller.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 模式是 **松耦合** 原则的另一种应用。该模式的名字来源于用于分割软件应用的三个主要组件：模型、视图和控制器。
- en: Even if we will never have to implement it from scratch, we need to be familiar
    with it because all common frameworks use MVC or a slightly different version
    of it (more on this later).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们永远不需要从头开始实现它，我们也需要熟悉它，因为所有常见的框架都使用 MVC 或其略有不同的版本（关于这一点稍后还会详细介绍）。
- en: The model is the core component. It represents knowledge. It contains and manages
    the (business) logic, data, state, and rules of an application. The view is a
    visual representation of the model. Examples of views are a computer GUI, the
    text output of a computer terminal, a smartphone’s application GUI, a PDF document,
    a pie chart, a bar chart, and so forth. The view only displays the data; it doesn’t
    handle it. The controller is the link/glue between the model and the view. All
    communication between the model and the view happens through a controller.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是核心组件。它代表知识。它包含并管理应用的（业务）逻辑、数据、状态和规则。视图是模型的视觉表示。视图的例子包括计算机 GUI、计算机终端的文本输出、智能手机的应用
    GUI、PDF 文档、饼图、柱状图等等。视图只显示数据；它不处理数据。控制器是模型和视图之间的链接/粘合剂。模型和视图之间的所有通信都通过控制器进行。
- en: 'A typical use of an application that uses MVC, after the initial screen is
    rendered to the user, is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MVC 的应用程序的典型用法，在初始屏幕渲染给用户后，如下所示：
- en: The user triggers a view by clicking (typing, touching, and so on) a button.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户通过点击（输入、触摸等）按钮来触发视图。
- en: The view informs the controller of the user’s action.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图会通知控制器用户的行为。
- en: The controller processes user input and interacts with the model.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器处理用户输入并与模型交互。
- en: The model performs all the necessary validation and state changes and informs
    the controller about what should be done.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该模型执行所有必要的验证和状态更改，并通知控制器应该做什么。
- en: The controller instructs the view to update and display the output appropriately,
    following the model’s instructions.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器根据模型的指示指导视图更新并适当地显示输出。
- en: '![Figure 6.1 – The MVC pattern](img/B21896_06_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – MVC模式](img/B21896_06_01.jpg)'
- en: Figure 6.1 – The MVC pattern
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – MVC模式
- en: 'But is the controller part necessary? Can’t we just skip it? We could, but
    then we would lose a big benefit that MVC provides: the ability to use more than
    one view (even at the same time, if that’s what we want) without modifying the
    model. To achieve decoupling between the model and its representation, every view
    typically needs its own controller. If the model communicated directly with a
    specific view, we wouldn’t be able to use multiple views (or, at least, not in
    a clean and modular way).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但是控制器部分是必要的吗？我们能不能跳过它？我们可以，但那样我们就会失去MVC提供的一个大优势：能够在不修改模型的情况下使用多个视图（甚至同时使用，如果我们想这样做）。为了在模型及其表示之间实现解耦，每个视图通常都需要自己的控制器。如果模型直接与特定的视图通信，我们就无法使用多个视图（或者至少不能以干净和模块化的方式使用）。
- en: Real-world examples
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界中的例子
- en: MVC is an application of the **separation of concern** principle. Separation
    of concern is used a lot in real life. For example, if you build a new house,
    you usually assign different professionals to 1) install the plumbing and electricity;
    and, 2) paint the house.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: MVC是**关注点分离**原则的应用。在现实生活中，关注点分离被大量使用。例如，如果你建造一栋新房子，你通常会指派不同的专业人士来做以下工作：1）安装管道和电线；以及2）粉刷房子。
- en: Another example is a restaurant. In a restaurant, the waiters receive orders
    and serve dishes to the customers, but the meals are cooked by the chefs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是餐厅。在餐厅里，服务员接收订单并为顾客上菜，但饭菜是由厨师烹制的。
- en: 'In web development, several frameworks use the MVC idea, for example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发中，多个框架使用MVC（模型-视图-控制器）理念，例如：
- en: The **Web2py framework** is a lightweight Python framework that embraces the
    MVC pattern. There are many examples that demonstrate how MVC can be used in Web2py
    on the project’s site ([http://web2py.com/](http://web2py.com/)) and in the GitHub
    repository.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web2py框架**是一个轻量级的Python框架，它采用了MVC模式。项目网站上有很多示例演示了如何在Web2py中使用MVC（[http://web2py.com/](http://web2py.com/））以及在GitHub仓库中。'
- en: '**Django** ([https://www.djangoproject.com/](https://www.djangoproject.com/))
    is also an MVC framework, although it uses different naming conventions. The controller
    is called *view*, and the view is called *template*. Django uses the name **Model-View
    Template** (**MVT**). According to the designers of Django, the view describes
    what data is seen by the user, and therefore, it uses the name view as the Python
    callback function for a particular URL. The term “template” in Django is used
    to separate content from representation. It describes how the data is seen by
    the user, not which data is seen.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Django**（[https://www.djangoproject.com/](https://www.djangoproject.com/））也是一个MVC框架，尽管它使用了不同的命名约定。控制器被称为*视图*，视图被称为*模板*。Django使用**模型-视图-模板**（MVT）的名称。根据Django的设计师，视图描述了用户看到的数据，因此它使用视图作为特定URL的Python回调函数。在Django中，“模板”一词用于将内容与表示分离。它描述了用户看到数据的方式，而不是看到哪些数据。'
- en: Use cases for the MVC pattern
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC模式的使用案例
- en: 'MVC is a very generic and useful design pattern. In fact, all popular web frameworks
    (Django, Rails, Symfony, and Yii) and application frameworks (iPhone SDK, Android,
    and QT) make use of MVC or a variation of it (**model-view-adapter** (**MVA**),
    **model-view-presenter** (**MVP**), or **MVT**, for example). However, even if
    we don’t use any of these frameworks, it makes sense to implement the pattern
    on our own because of the benefits it provides, which are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: MVC是一个非常通用且有用的设计模式。实际上，所有流行的Web框架（Django、Rails、Symfony和Yii）以及应用程序框架（iPhone SDK、Android和QT）都使用了MVC或其变体（例如**模型-视图-适配器**（MVA）、**模型-视图-表示器**（MVP）或**MVT**）。然而，即使我们不使用这些框架，由于它提供的优势，自己实现这个模式也是有意义的，这些优势如下：
- en: The separation between the view and model allows graphics designers to focus
    on the **user interface** (**UI**) part and programmers to focus on development,
    without interfering with each other.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图和模型之间的分离使得图形设计师可以专注于**用户界面**（UI）部分，程序员可以专注于开发，而不会相互干扰。
- en: Because of the loose coupling between the view and model, each part can be modified/extended
    without affecting the other. For example, adding a new view is trivial. Just implement
    a new controller for it.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于视图和模型之间的松散耦合，每个部分都可以在不影响其他部分的情况下进行修改/扩展。例如，添加一个新的视图是微不足道的。只需为它实现一个新的控制器即可。
- en: Maintaining each part is easier because the responsibilities are clear.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护每个部分更容易，因为责任是清晰的。
- en: When implementing MVC from scratch, be sure that you create smart models, thin
    controllers, and dumb views.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当从头开始实现MVC时，确保你创建智能模型、瘦控制器和愚视图。
- en: 'A model is considered smart because it does the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模型被认为是智能的，因为它执行以下操作：
- en: It contains all the validation/business rules/logic
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含所有验证/业务规则/逻辑
- en: It handles the state of the application
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它处理应用程序的状态
- en: It has access to application data (database, cloud, and so on)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以访问应用程序数据（数据库、云等）
- en: It does not depend on the UI
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不依赖于UI
- en: 'A controller is considered thin because it does the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个控制器被认为是瘦的，因为它执行以下操作：
- en: It updates the model when the user interacts with the view
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户与视图交互时，它更新模型
- en: It updates the view when the model changes
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当模型更改时，它更新视图
- en: It processes the data before delivering it to the model/view, if necessary
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，在将数据交付给模型/视图之前处理数据
- en: It does not display the data
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不显示数据
- en: It does not access the application data directly
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不直接访问应用程序数据
- en: It does not contain validation/business rules/logic
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不包含验证/业务规则/逻辑
- en: 'A view is considered dumb because it does the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个视图被认为是愚的，因为它执行以下操作：
- en: It displays the data
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它显示数据
- en: It allows the user to interact with it
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许用户与之交互
- en: It does only minimal processing, usually provided by a template language (for
    example, using simple variables and loop controls)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只进行最小处理，通常由模板语言提供（例如，使用简单的变量和循环控制）
- en: It does not store any data
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不存储任何数据
- en: It does not access the application data directly
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不直接访问应用程序数据
- en: It does not contain validation/business rules/logic
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不包含验证/业务规则/逻辑
- en: 'If you are implementing MVC from scratch and want to find out whether you did
    it right, you can try answering some key questions:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从头开始实现MVC并且想知道你是否做得正确，你可以尝试回答一些关键问题：
- en: If your application has a GUI, is it skinnable? How easily can you change the
    skin/look and feel of it? Can you give the user the ability to change the skin
    of your application during runtime? If this is not simple, it means that something
    is going wrong with your MVC implementation.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的应用程序有一个GUI，它是可定制的吗？你有多容易改变它的皮肤/外观和感觉？你能否在运行时给用户改变应用程序皮肤的能力？如果这并不简单，这意味着你的MVC实现出了问题。
- en: If your application has no GUI (for instance, if it’s a terminal application),
    how hard is it to add GUI support? Or, if adding a GUI is irrelevant, is it easy
    to add views to display the results in a chart (pie chart, bar chart, and so on)
    or a document (PDF, spreadsheet, and so on)? If these changes are not trivial
    (a matter of creating a new controller with a view attached to it, without modifying
    the model), MVC is not implemented properly.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的应用程序没有GUI（例如，如果它是一个终端应用程序），添加GUI支持有多难？或者，如果添加GUI是不相关的，添加视图以在图表（饼图、条形图等）或文档（PDF、电子表格等）中显示结果是否容易？如果这些更改不是微不足道的（只需创建一个新的控制器并将其附加到视图上，而不修改模型），则MVC没有正确实现。
- en: If you make sure that these conditions are satisfied, your application will
    be more flexible and maintainable compared to an application that does not use
    MVC.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你确保这些条件得到满足，与不使用MVC的应用程序相比，你的应用程序将更加灵活和易于维护。
- en: Implementing the MVC pattern
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现MVC模式
- en: 'I could use any of the common frameworks to demonstrate how to use MVC, but
    I feel that the picture will be incomplete. So, I decided to show you how to implement
    MVC from scratch, using a very simple example: a quote printer. The idea is extremely
    simple. The user enters a number and sees the quote related to that number. The
    quotes are stored in a `quotes` tuple. This is the data that normally exists in
    a database, file, and so on, and only the model has direct access to it.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用任何常见的框架来演示如何使用MVC，但我感觉这样会不完整。所以，我决定向你展示如何从头开始实现MVC，使用一个非常简单的例子：一个引言打印机。这个想法极其简单。用户输入一个数字，看到与该数字相关的引言。引言存储在`quotes`元组中。这是通常存在于数据库、文件等中的数据，并且只有模型可以直接访问它。
- en: 'Let’s consider this example for the `quotes` tuple:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑这个`quotes`元组的例子：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The model is minimalistic; it only has a `get_quote()` method that returns
    the quote (string) of the `quotes` tuple based on its index, `n`. The model class
    is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是最简化的；它只有一个`get_quote()`方法，该方法根据索引`n`从`quotes`元组返回引语（字符串）。模型类如下所示：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The view has three methods: `show()`, which is used to print a quote (or the
    `Not found!` message) on the screen; `error()`, which is used to print an error
    message on the screen; and `select_quote()`, which reads the user’s selection.
    This can be seen in the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 视图有三个方法：`show()`，用于在屏幕上打印引语（或`Not found!`消息）；`error()`，用于在屏幕上打印错误消息；以及`select_quote()`，用于读取用户的选项。这可以在下面的代码中看到：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The controller does the coordination. The `__init__()` method initializes the
    model and view. The `run()` method validates the quoted index given by the user,
    gets the quote from the model, and passes it back to the view to be displayed,
    as shown in the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器负责协调。`__init__()`方法初始化模型和视图。`run()`方法验证用户给出的引用索引，从模型中获取引语，并将其传递回视图以显示，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, the `main()` function initializes and fires the controller, as shown
    in the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main()`函数初始化并启动控制器，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is a recap of our example (the full code is in `ch06/mvc.py` file):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们例子的总结（完整代码在`ch06/mvc.py`文件中）：
- en: We start by defining a variable for the list of quotes.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义了一个用于引语列表的变量。
- en: We define the model class, `QuoteModel`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了模型类，`QuoteModel`。
- en: We define the view class, `QuoteTerminalView`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了视图类，`QuoteTerminalView`。
- en: We define the controller class, `QuoteTerminalController`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了控制器类，`QuoteTerminalController`。
- en: Finally, we add the `main()` function to test the different classes, followed
    by the usual trick to call it.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加了`main()`函数来测试不同的类，然后是通常的技巧来调用它。
- en: 'A sample execution of the `python ch06/mvc.py` command shows how the program
    prints quotes to the user:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`python ch06/mvc.py`命令的示例显示了程序如何将引语打印给用户：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Microservices pattern
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务模式
- en: Traditionally, developers working on building a server-side application have
    been using a single code base and implementing all or most functionalities right
    there, using common development practices such as functions and classes, and design
    patterns such as the ones we have covered in this book so far.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，从事构建服务器端应用程序的开发人员一直使用单个代码库，并在那里实现所有或大多数功能，使用常见的开发实践，如函数和类，以及我们在本书中迄今为止涵盖的设计模式。
- en: However, with the evolution of the IT industry, economic factors, and pressure
    for fast times to market and returns on investment, there is a constant need to
    improve the practices of engineering teams and ensure more reactivity and scalability
    with servers, service delivery, and operations. We need to learn about other useful
    patterns, not only object-oriented programming ones.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着IT行业的演变、经济因素以及快速上市和投资回报的压力，我们需要不断改进工程团队的做法，并确保服务器、服务交付和运营具有更高的反应性和可扩展性。我们需要了解其他有用的模式，而不仅仅是面向对象的编程模式。
- en: '![Figure 6.2 – The Microservices pattern](img/B21896_06_02.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 微服务模式](img/B21896_06_02.jpg)'
- en: Figure 6.2 – The Microservices pattern
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 微服务模式
- en: One of the main additions to the catalog of patterns for engineers in recent
    years has been the **Microservice Architecture** pattern or **Microservices**.
    The idea is that we can build an application as a set of loosely coupled, collaborating
    services. In this architectural style, an application might consist of services
    such as the order management service, the customer management service, and so
    on. These services are loosely coupled, independently deployable, and communicate
    via well-defined APIs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，工程师模式目录的主要新增内容是**微服务架构**模式或**微服务**。其理念是我们可以将应用程序构建为一组松散耦合、协作的服务。在这种架构风格中，一个应用程序可能包括订单管理服务、客户管理服务等这样的服务。这些服务是松散耦合的、独立部署的，并通过定义良好的API进行通信。
- en: Real-world examples
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界中的例子
- en: 'We can cite several examples, such as the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以引用几个例子，如下所示：
- en: '**Netflix**: One of the pioneers in adopting microservices to handle millions
    of content streams simultaneously'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Netflix**：采用微服务处理数百万内容流的先驱之一'
- en: '**Uber**: The company uses microservices to handle different aspects such as
    billing, notifications, and ride tracking'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Uber**：该公司使用微服务来处理不同的方面，如计费、通知和行程跟踪'
- en: '**Amazon**: They transitioned from a monolithic architecture to microservices
    to support their ever-growing scale'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**亚马逊**：他们从单体架构过渡到微服务架构，以支持其不断增长的规模'
- en: Use cases for the Microservices pattern
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务模式的用例
- en: 'We can think of several use cases where Microservices offer a clever answer.
    We can use a Microservices architecture-based design every time we are building
    an application that has at least one of the following characteristics:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想到几个用例，在这些用例中，微服务提供了巧妙的解决方案。每次我们构建一个具有以下至少一个特征的应用程序时，我们都可以使用基于微服务架构的设计：
- en: There is a requirement to support different clients, including desktop and mobile
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要支持不同的客户端，包括桌面和移动设备
- en: There is an API for third parties to consume
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个API供第三方消费
- en: We must communicate with other applications using messaging
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须使用消息传递与其他应用程序进行通信
- en: We serve requests by accessing a database, communicating with other systems,
    and returning the right type of response (JSON, XML, HTML, or even PDF)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过访问数据库、与其他系统通信并返回正确的响应类型（JSON、XML、HTML或甚至是PDF）来处理请求
- en: There are logical components corresponding to different functional areas of
    the application
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的不同功能区域对应着逻辑组件
- en: Implementing the microservices pattern – a payment service using gRPC
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现微服务模式——使用gRPC的支付服务
- en: Let’s briefly talk about software installation and application deployment in
    the Microservices world. Switching from deploying a single application to deploying
    many small services means that the number of things that need to be handled increases
    exponentially. While you might have been fine with a single application server
    and a few runtime dependencies, when moving to Microservices, the number of dependencies
    will increase drastically. For example, one service could benefit from the relational
    database while the other would need **ElasticSearch**. You may need a service
    that uses **MySQL** and another one that uses the **Redis** server. So, using
    the Microservices approach also means you will need to use **containers**.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地谈谈在微服务世界中软件安装和应用部署。从部署单个应用程序转变为部署许多小型服务意味着需要处理的事物数量呈指数级增长。虽然你可能对单个应用程序服务器和一些运行时依赖项感到满意，但当迁移到微服务时，依赖项的数量将急剧增加。例如，一个服务可能受益于关系型数据库，而另一个则可能需要**ElasticSearch**。你可能需要一个使用**MySQL**的服务，另一个则可能使用**Redis**服务器。因此，采用微服务方法也意味着你需要使用**容器**。
- en: Thanks to Docker, things have become easier, since we can run those services
    as containers. The idea is that your application server, dependencies and runtime
    libraries, compiled code, configurations, and so on, are inside those containers.
    Then, all you must do is run services packed as containers and make sure that
    they can communicate with each other.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Docker，事情变得更容易，因为我们可以将这些服务作为容器运行。想法是，你的应用程序服务器、依赖项和运行时库、编译后的代码、配置等等，都包含在这些容器中。然后，你所要做的就是运行打包成容器的服务，并确保它们可以相互通信。
- en: You can implement the Microservices pattern, for a web app or an API, by directly
    using Django, Flask, or FastAPI. However, to quickly show a working example, we
    are going to use gRPC, a high-performance universal RPC framework that uses **Protocol
    Buffers** (**protobuf**) as its interface description language, making it an ideal
    candidate for microservices communication due to its efficiency and cross-language
    support.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接使用Django、Flask或FastAPI来实现微服务模式，用于Web应用程序或API。然而，为了快速展示一个工作示例，我们将使用gRPC，这是一个高性能的通用RPC框架，它使用**Protocol
    Buffers**（**protobuf**）作为其接口描述语言，由于其效率和跨语言支持，使其成为微服务通信的理想选择。
- en: Imagine a scenario where your application architecture includes a microservice
    dedicated to handling payment processing. This microservice (let’s call it `PaymentService`),
    is responsible for processing payments and interacts with other services such
    as `OrderService` and `AccountService`. We are going to focus on the implementation
    of such a service using gRPC.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，其中你的应用程序架构包括一个专门处理支付处理的微服务。这个微服务（让我们称它为`PaymentService`），负责处理支付并与`OrderService`和`AccountService`等其他服务交互。我们将专注于使用gRPC实现此类服务的实现。
- en: 'First, we define the service and its methods using protobuf, in the `ch06/microservices/grpc/payment.proto`
    file. This includes specifying request and response message formats:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`ch06/microservices/grpc/payment.proto`文件中定义服务和其方法，使用protobuf。这包括指定请求和响应消息格式：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then, you must compile the `payment.proto` file into Python code using the protobuf
    compiler (`protoc`). For that, you need to use a specific command line that invokes
    `protoc` with the appropriate plugins and options for Python.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您必须使用protobuf编译器（`protoc`）将`payment.proto`文件编译成Python代码。为此，您需要使用特定的命令行，该命令行调用`protoc`并带有适用于Python的适当插件和选项。
- en: 'Here is the general form of the command line for compiling `.proto` files for
    use with gRPC in Python:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用于在Python中使用gRPC编译`.proto`文件的命令行的一般形式：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: payment_pb2.py and payment_pb2_grpc.py. Those files are not to be manually edited.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: payment_pb2.py和payment_pb2_grpc.py。这些文件不应手动编辑。
- en: 'Next, we provide, in a `payment_service.py` file, the service logic for the
    payment processing, extending what has been provided in the generated `.py` files.
    In the module, we define the `PaymentServiceImpl` class, inheriting from the `payment_pb2_grpc.PaymentServiceServicer`
    class, and we override the `ProcessPayment()` method that will do what is needed
    to process the payment (e.g., calling external APIs, doing database updates, etc.)
    Note that here, we have a simplified example, but you would have more complex
    logic. The code is as follows:'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们在`payment_service.py`文件中提供支付处理的服务逻辑，扩展了在生成的`.py`文件中提供的内容。在该模块中，我们定义了`PaymentServiceImpl`类，继承自`payment_pb2_grpc.PaymentServiceServicer`类，并重写了`ProcessPayment()`方法，该方法将执行处理支付所需的工作（例如，调用外部API，执行数据库更新等）。请注意，这里是一个简化的示例，但您会有更复杂的逻辑。代码如下：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we have the `main()` function, with the code needed to start the processing
    service, created by calling `grpc.server(ThreadPoolExecutor(max_workers=10))`.
    The code of the function is as follows:'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们有`main()`函数，其中包含启动处理服务的代码，通过调用`grpc.server(ThreadPoolExecutor(max_workers=10))`创建。函数的代码如下：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With that, the service is done and ready to be tested. We need a client to
    be able to test it. We can write a test client with code that calls the service
    using gRPC, with the following code (in the `ch06/microservices/grpc/client.py`
    file):'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样，服务就完成了，并准备好进行测试。我们需要一个客户端来测试它。我们可以编写一个测试客户端，使用gRPC调用服务的代码（在`ch06/microservices/grpc/client.py`文件中）：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To start the service (in the `ch06/microservices/grpc/payment_service.py` file),
    you can run the following command:'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要启动服务（在`ch06/microservices/grpc/payment_service.py`文件中），您可以运行以下命令：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will get the following output, showing that the service has started as
    expected:'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将得到以下输出，显示服务已按预期启动：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: python ch06/microservices/grpc/client.py
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: python ch06/microservices/grpc/client.py
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Payment Service responded.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 支付服务响应。
- en: 'Response status: SUCCESS'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 响应状态：成功
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: import os
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 导入os
- en: import uvicorn
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 导入uvicorn
- en: from lanarky import Lanarky
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从lanarky导入Lanarky
- en: from lanarky.adapters.openai.resources import ChatCompletionResource
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从lanarky.adapters.openai.resources导入ChatCompletionResource
- en: from lanarky.adapters.openai.routing import OpenAIAPIRouter
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从lanarky.adapters.openai.routing导入OpenAIAPIRouter
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: os.environ["OPENAI_API_KEY"] = "Your OpenAI API key here"
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: os.environ["OPENAI_API_KEY"] = "在此处输入您的OpenAI API密钥"
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: app = Lanarky()
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: app = Lanarky()
- en: router = OpenAIAPIRouter()
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: router = OpenAIAPIRouter()
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '@router.post("/chat")'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '@router.post("/chat")'
- en: 'def chat(stream: bool = True) -> ChatCompletionResource:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 'def chat(stream: bool = True) -> ChatCompletionResource:'
- en: system = "Here is your assistant"
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: system = "这里是您的助手"
- en: return ChatCompletionResource(stream=stream, system=system)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: return ChatCompletionResource(stream=stream, system=system)
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'if __name__ == "__main__":'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: app.include_router(router)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: app.include_router(router)
- en: uvicorn.run(app)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: uvicorn.run(app)
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: import click
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 导入click
- en: import sys
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 导入sys模块
- en: from lanarky.clients import StreamingClient
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从lanarky.clients导入StreamingClient
- en: args = sys.argv[1:]
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: args = sys.argv[1:]
- en: 'if len(args) == 1:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 'if len(args) == 1:'
- en: message = args[0]
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: message = args[0]
- en: client = StreamingClient()
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: client = StreamingClient()
- en: for event in client.stream_response(
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: for event in client.stream_response(
- en: '"POST",'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '"POST",'
- en: '"/chat",'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '"/chat",'
- en: 'params={"stream": "false"},'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'params={"stream": "false"},'
- en: 'json={"messages": [dict(role="user", content=message)]},'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 'json={"messages": [dict(role="user", content=message)]},'
- en: '):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '):'
- en: 'print(f"{event.event}: {event.data}")'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(f"{event.event}: {event.data}")'
- en: 'else:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("You need to pass a message!")
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: print("您需要传递一条消息！")
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: python ch06/microservices/lanarky/llm_service.py
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: python ch06/microservices/lanarky/llm_service.py
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: INFO:   Started server process [18617]
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: INFO：启动服务器进程[18617]
- en: INFO:   Waiting for application startup.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: INFO：等待应用程序启动。
- en: INFO:   Application startup complete.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: INFO：应用程序启动完成。
- en: INFO:   Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: INFO：Uvicorn正在运行于http://127.0.0.1:8000（按CTRL+C退出）
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: python ch06/microservices/lanarky/client.py "Hello"
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: python ch06/microservices/lanarky/client.py "Hello"
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'completion: Hello! How can I assist you today?'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 'completion: Hello! How can I assist you today?'
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: python ch06/microservices/lanarky/client.py "What is the capital of Switzerland?"
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: python ch06/microservices/lanarky/client.py "瑞士的首都是什么？"
- en: 'completion: The capital of Switzerland is Bern.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 完成：瑞士的首都是伯尔尼。
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: import json
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: import json
- en: 'def lambda_handler(event, context):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'def lambda_handler(event, context):'
- en: number = event["number"]
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: number = event["number"]
- en: squared = number * number
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: squared = number * number
- en: return f"The square of {number} is {squared}."
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: return f"{number} 的平方是 {squared}。"
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'ch06/lambda_function_square.py) to a ZIP file, for example, by using the ZIP
    program as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ch06/lambda_function_square.py) 打包成一个 ZIP 文件，例如，可以使用 ZIP 程序如下：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: awslocal lambda create-function \
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: awslocal lambda create-function \
- en: --function-name lambda_function_square \
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: --function-name lambda_function_square \
- en: --runtime python3.11 \
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: --runtime python3.11 \
- en: --zip-file fileb://lambda.zip \
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: --zip-file fileb://lambda.zip \
- en: --handler lambda_function_square.lambda_handler \
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: --handler lambda_function_square.lambda_handler \
- en: --role arn:aws:iam::000000000000:role/lambda-role
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: --role arn:aws:iam::000000000000:role/lambda-role
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: awslocal lambda invoke --function-name lambda_function_square \
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: awslocal lambda invoke --function-name lambda_function_square \
- en: 'output.txt file’s content. You should see the text:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: output.txt 文件的内容。你应该看到以下文本：
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: awslocal lambda create-function-url-config \
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: awslocal lambda create-function-url-config \
- en: --function-name lambda_function_square \
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: --function-name lambda_function_square \
- en: http://<XXXXXXXX>.lambda-url.us-east-1.localhost.localstack.cloud:4566 format.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: http://<XXXXXXXX>.lambda-url.us-east-1.localhost.localstack.cloud:4566 格式。
- en: 'Now, for example, we can trigger the Lambda function URL using `cUrl`:'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，例如，我们可以使用 `cUrl` 触发 Lambda 函数 URL：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For up-to-date and detailed guides related to AWS Lambda, consult the documentation
    at [https://docs.aws.amazon.com/lambda/](https://docs.aws.amazon.com/lambda/).
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关 AWS Lambda 的最新和详细指南，请参阅[https://docs.aws.amazon.com/lambda/](https://docs.aws.amazon.com/lambda/)文档。
- en: This was a minimal example. Another example of a serverless application could
    be a function that generates PDF receipts for a business. This would allow the
    business to not worry about server management and only pay for the computing time
    that is consumed.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个最小示例。另一个无服务器应用程序的例子可能是一个为业务生成 PDF 发票的功能。这将使业务无需担心服务器管理，只需为消耗的计算时间付费。
- en: The Event Sourcing pattern
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事件溯源模式
- en: The Event Sourcing pattern stores state changes as a sequence of events, allowing
    the reconstruction of past states and providing an audit trail. This pattern is
    particularly useful in systems where the state is complex and the business rules
    for transitions are complex.
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事件溯源模式将状态更改存储为一系列事件，允许重建过去的状态并提供审计跟踪。这种模式在状态复杂且转换的业务规则复杂的系统中特别有用。
- en: As we will see in implementation examples later, the Event Sourcing pattern
    emphasizes the importance of capturing all changes to an application state as
    a sequence of events. An outcome of this is that the application state can be
    reconstructed at any point in time by replaying these events.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如我们将在后面的实现示例中看到的那样，事件溯源模式强调捕获应用程序状态的所有更改作为一系列事件的必要性。其结果之一是，应用程序状态可以通过重新播放这些事件在任何时间点重建。
- en: Real-world examples
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现实世界例子
- en: 'There are several real-world examples in the software category:'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在软件类别中存在几个现实世界的例子：
- en: '**Audit trails**: Keeping a record of all changes made to a database for compliance'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审计跟踪**：为了符合规定，记录对数据库所做的所有更改'
- en: '**Collaborative editing**: Allowing multiple users to edit a document simultaneously'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作编辑**：允许多个用户同时编辑一个文档'
- en: '**Undo/redo features**: Providing the ability to undo or redo actions in an
    application'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**撤销/重做功能**：提供在应用程序中撤销或重做操作的能力'
- en: Use cases for the Event Sourcing pattern
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事件溯源模式的使用案例
- en: 'There are several use cases for the Event Sourcing pattern. Let’s consider
    the following three:'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事件溯源模式有几个使用案例。让我们考虑以下三个：
- en: '**Financial transactions**: Event Sourcing can be used to record every change
    to an account’s balance as a chronological series of immutable events. This method
    ensures that every deposit, withdrawal, or transfer is captured as a distinct
    event. This way, we can provide a transparent, auditable, and secure ledger of
    all financial activities.'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金融交易**：事件溯源可用于记录账户余额的每次更改作为一个不可变事件的时序序列。这种方法确保每次存款、取款或转账都被捕获为一个独立的事件。这样，我们可以提供一个透明、可审计和安全的财务活动账本。'
- en: '**Inventory management**: Within inventory management contexts, Event Sourcing
    helps in tracking each item’s life cycle by logging all changes as events. This
    enables businesses to maintain accurate and up-to-date records of stock levels,
    identify patterns in item usage or sales, and predict future inventory needs.
    It also facilitates tracing the history of any item, aiding in recall processes
    or quality assurance investigations.'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**库存管理**：在库存管理背景下，事件源通过记录所有更改作为事件来帮助跟踪每个项目的生命周期。这使得企业能够保持库存水平的准确和最新记录，识别项目使用或销售中的模式，并预测未来的库存需求。它还便于追溯任何项目的历史，有助于召回过程或质量保证调查。'
- en: '**Customer behavior tracking**: Event Sourcing plays a critical role in capturing
    and storing every interaction a customer has with a platform, from browsing history
    and cart modifications to purchases and returns. This wealth of data, structured
    as a series of events, becomes a valuable resource for analyzing customer behavior,
    personalizing marketing strategies, enhancing user experience, and improving product
    recommendations.'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户行为跟踪**：事件源在捕获和存储客户与平台互动的每一个交互中扮演着关键角色，从浏览历史和购物车修改到购买和退货。这些丰富的数据，以一系列事件的形式结构化，成为分析客户行为、个性化营销策略、提升用户体验和改进产品推荐的有价值资源。'
- en: Let’s now see how we can implement this pattern.
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何实现这个模式。
- en: Implementing the event sourcing pattern – the manual way
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现事件源模式 - 手动方式
- en: 'Let’s start with some definitions. The components of the Event Sourcing pattern
    implementation are as follows:'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们从一些定义开始。事件源模式实现的组成部分如下：
- en: '**Event**: A representation of a state change, typically containing the type
    of event and the data associated with that event. Once an event is created and
    applied, it cannot be changed.'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：状态变化的表示，通常包含事件类型和与该事件相关联的数据。一旦创建并应用了事件，就不能再更改。'
- en: '**Aggregate**: An object (or group of objects) that represents a single unit
    of business logic or data. It keeps track of things, and every time something
    changes (an event), it makes a record of it.'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合**：表示单个业务逻辑或数据单元的对象（或对象组）。它跟踪事物，每次有事物发生变化（一个事件）时，它都会记录下来。'
- en: '**Event store**: A collection of all the events that have occurred.'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件存储**：所有已发生事件的集合。'
- en: By handling state changes through events, the business logic becomes more flexible
    and easier to extend. For example, adding new types of events or modifying the
    handling of existing events can be done with minimal impact on the rest of the
    system.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过通过事件处理状态变化，业务逻辑变得更加灵活且易于扩展。例如，添加新类型的事件或修改现有事件的处理方式可以以最小的系统影响完成。
- en: In this first example, for the bank account use case, we will see how to implement
    the event sourcing pattern in a manual way. In such an implementation, you would
    typically define your event classes and manually write the logic to apply these
    events to your aggregates. Let’s see that.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个第一个例子中，对于银行账户用例，我们将看到如何以手动方式实现事件源模式。在这种实现中，你通常会定义你的事件类并手动编写将这些事件应用到聚合上的逻辑。让我们看看。
- en: We start by defining an `Account` class representing a bank account with a balance
    and a list of events attached to it, for the operations on the account. This class
    acts as the aggregate. Its `events` attribute represents the event store. Here,
    an event will be represented by a dictionary containing the type of operation
    (“deposited” or “withdrawn”) and the amount value.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先定义一个`Account`类，它代表一个具有余额和附加到账户操作的事件列表的银行账户。这个类作为聚合。它的`events`属性代表事件存储。在这里，一个事件将由一个包含操作类型（“存入”或“取出”）和金额值的字典表示。
- en: 'We then add the `apply_event()` method taking an event as the input. Depending
    on `event["type"]`, we increment or decrement the account balance by the event’s
    amount, and we add the event to the `events` list, effectively storing the event:'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们添加了一个接受事件作为输入的`apply_event()`方法。根据`event["type"]`，我们根据事件的数量增加或减少账户余额，并将事件添加到`events`列表中，从而有效地存储事件：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we add a `deposit()` method and a `withdraw()` method, which both call
    the `apply_event()` method, as follows:'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们添加一个`deposit()`方法和一个`withdraw()`方法，这两个方法都调用`apply_event()`方法，如下所示：
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we add the `main()` function, as follows:'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们添加了`main()`函数，如下所示：
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Running the code, using the `python ch06/ event_sourcing/bankaccount.py` command,
    gives the following output:'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码，使用`python ch06/ event_sourcing/bankaccount.py`命令，得到以下输出：
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This example provided a first understanding of Event Sourcing through a simple,
    manual implementation. For more complex systems, frameworks and libraries designed
    for Event Sourcing can help manage some of this complexity, providing utilities
    for event storage, querying, and processing. We will test such a library next.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本例通过一个简单的手动实现，为我们提供了对事件源（Event Sourcing）的第一理解。对于更复杂的系统，专门为事件源设计的框架和库可以帮助管理一些复杂性，提供事件存储、查询和处理的实用工具。我们将接下来测试这样一个库。
- en: Implementing the Event Sourcing pattern – using a library
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用库实现事件源模式
- en: In this second example, we will use the `eventsourcing` library to implement
    the Event Sourcing pattern. Let’s consider an inventory management system where
    we track the quantity of items.
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个第二个例子中，我们将使用`eventsourcing`库来实现事件源模式。让我们考虑一个库存管理系统，其中我们跟踪物品的数量。
- en: 'We start by importing what we need, as follows:'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先导入所需的模块，如下所示：
- en: '[PRE35]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we define the class for the aggregate object, `InventoryItem`, by inheriting
    from the `Aggregate` class. The class has an `increase_quantity()` and a `decrease_quantity`
    method, each decorated with the `@event` decorator. The code for this class is
    as follows:'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们通过继承`Aggregate`类来定义聚合对象的类`InventoryItem`。该类有一个`increase_quantity()`和`decrease_quantity`方法，每个方法都装饰了`@event`装饰器。这个类的代码如下所示：
- en: '[PRE36]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we create our inventory application’s class, `InventoryApp`, inheriting
    from the `eventsourcing` library’s `Application` class. The first method handles
    the creation of an item, taking an instance of the `InventoryItem` class (`item`)
    and calling the `save()` method on the `InventoryApp` object using the item. But
    what exactly does the `save()` method do? It collects pending events from given
    aggregates and puts them in the application’s event store. The definition of the
    class starts as follows:'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的库存应用程序类`InventoryApp`，它继承自`eventsourcing`库的`Application`类。第一个方法处理创建一个项目，接受`InventoryItem`类的实例（`item`），并使用该项目在`InventoryApp`对象上调用`save()`方法。但`save()`方法究竟做了什么？它从给定的聚合中收集挂起的事件，并将它们放入应用的事件存储中。类的定义如下所示：
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, similarly to what we did in the previous example, we add an `increase_item_quantity()`
    method, which handles the increase of the item’s quantity (for the aggregate object)
    and then saves the aggregate object on the application, followed by the corresponding
    `decrease_item_quantity()` method, for the decreasing action, as follows:'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，类似于我们在上一个例子中所做的，我们添加了一个`increase_item_quantity()`方法，它处理项目数量的增加（对于聚合对象），然后在该应用上保存聚合对象，随后是相应的`decrease_item_quantity()`方法，用于减少操作，如下所示：
- en: '[PRE38]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, we add the `main()` function, with some code to test our design, as
    follows:'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们添加了`main()`函数，其中包含一些测试我们设计的代码，如下所示：
- en: '[PRE39]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Running the code, using the `python ch06/ event_sourcing/inventory.py` command,
    gives the following output:'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码，使用`python ch06/event_sourcing/inventory.py`命令，得到以下输出：
- en: '[PRE40]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
