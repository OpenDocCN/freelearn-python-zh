- en: Building a Server from Scratch
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头开始构建服务器
- en: 'In this chapter, we will analyze a more advanced application of concurrent
    programming: building a working non-blocking server from scratch. We will cover
    complex uses of the `socket` module, such as isolating the user business logic
    from callbacks and writing the callback logic with inline generators, both instances
    designed to run concurrently. We will also discuss the use of the `await` and
    `yield` keywords, using an example.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将分析并发编程的更高级应用：从头开始构建一个工作的非阻塞服务器。我们将涵盖`socket`模块的复杂用法，例如将用户业务逻辑与回调隔离，并使用内联生成器编写回调逻辑，这两个实例都设计为并发运行。我们还将讨论使用`await`和`yield`关键字，使用一个示例。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using a comprehensive API from the `socket` module to build a server from scratch
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`socket`模块的全面API从头开始构建服务器
- en: Basic information on Python generators and asynchronous generators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Python生成器和异步生成器的基本信息
- en: How to use inline generators with the `await` and `yield` keywords to convert
    a blocking server to a non-blocking one
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`await`和`yield`关键字与内联生成器将阻塞服务器转换为非阻塞服务器
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following is a list of prerequisites for this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章的先决条件列表：
- en: Ensure that you have Python 3 installed on your computer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的计算机上安装了Python 3
- en: Ensure that you have `telnet` installed on your computer
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的计算机上安装了`telnet`
- en: Download the GitHub repository at [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)下载GitHub存储库
- en: During this chapter, we will be working with the subfolder named `Chapter18`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用名为`Chapter18`的子文件夹
- en: Check out the following video to see the Code in Action: [http://bit.ly/2KrgWwh](http://bit.ly/2KrgWwh)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[http://bit.ly/2KrgWwh](http://bit.ly/2KrgWwh)
- en: Low-level network programming via the socket module
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过socket模块进行低级网络编程
- en: In this chapter, we will be using the `socket` module, which is a built-in library
    in Python, to build our working server. The `socket` module is one of the modules
    that are most frequently used to implement low-level communication protocols,
    while providing intuitive options to control those protocols. In this section,
    we will introduce the process of implementing the underlying low-level architecture
    of a server, as well as the key methods and functionalities of the module that
    will be used in our examples later on.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Python中的内置库`socket`模块来构建我们的工作服务器。`socket`模块是最常用于实现低级通信协议的模块之一，同时提供直观的选项来控制这些协议。在本节中，我们将介绍实现服务器的底层架构的过程，以及模块中将在后面的示例中使用的关键方法和功能。
- en: Note that in order to successfully follow the examples in this chapter, you
    will need to install the telnet program on your system. Telnet is a program that
    provides terminal commands that facilitate protocols for bidirectional, interactive,
    text-based communication. We covered the installation of telnet in [Chapter 11](38f53fa5-cf84-4e0c-897a-bd42fb74e657.xhtml),* Building
    Communication Channels with asyncio*; if you do not already have Telnet installed
    on your system, simply navigate to (and follow the directions in) that chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了成功地跟随本章中的示例，您需要在系统上安装telnet程序。Telnet是一个提供终端命令以促进双向交互式基于文本的通信协议的程序。我们在[第11章](38f53fa5-cf84-4e0c-897a-bd42fb74e657.xhtml)中介绍了telnet的安装，*使用asyncio构建通信通道*；如果您的系统上尚未安装Telnet，请简单地转到（并按照）该章节中的说明。
- en: Note that macOS systems have a preinstalled alternative to Telnet, called Netcat.
    If you do not want Telnet installed on your macOS computer, simply use the command `nc` instead
    of `telnet` in the following examples, and you will achieve the same effect.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，macOS系统有一个名为Netcat的预安装替代Telnet的程序。如果您不想在macOS计算机上安装Telnet，请在以下示例中使用命令`nc`而不是`telnet`，您将获得相同的效果。
- en: The theory of server-side communication
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端通信理论
- en: In [Chapter 11](38f53fa5-cf84-4e0c-897a-bd42fb74e657.xhtml), *Building Communication
    Channels with asyncio**,* you encountered brief examples of implementing asynchronous
    communication channels at a higher level, using the `aiohttp` module. In this
    section, we will dive deeper into the programming structure of a server-side communication
    channel, and how it can interact with its clients in an efficient way.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](38f53fa5-cf84-4e0c-897a-bd42fb74e657.xhtml)中，*使用asyncio构建通信通道*，您遇到了使用`aiohttp`模块在更高级别实现异步通信通道的简要示例。在本节中，我们将深入探讨服务器端通信通道的编程结构，以及它如何以高效的方式与其客户端进行交互。
- en: In the field of network programming, a **socket** is defined as a theoretical
    endpoint within a node of a specific computer network. The socket is responsible
    for receiving or sending data from the node that it is in. The fact that the socket
    is unique to the node that owns it means that other nodes in the same computer
    network are theoretically unable to interact with the socket. In other words,
    the socket is only available to its corresponding node.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络编程领域，**套接字**被定义为特定计算机网络节点内的理论端点。套接字负责从其所在的节点接收或发送数据。套接字仅对拥有它的节点可用的事实意味着同一计算机网络中的其他节点在理论上无法与套接字交互。换句话说，套接字仅对其对应的节点可用。
- en: To open a communication channel from the server-side, a network programmer must
    first create a socket and bind it to a specific address. This address is typically
    a pair of values, containing information about the host and a port for the server.
    Then, through the socket, the server begins to listen to any potential communication
    request created by its clients in the network. Any request from a client to connect
    to the server will thus need to be through the created socket.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要从服务器端打开通信通道，网络程序员必须首先创建一个套接字并将其绑定到特定地址。该地址通常是一对值，包含有关主机和服务器端口的信息。然后，通过套接字，服务器开始监听网络中由其客户端创建的任何潜在通信请求。因此，客户端对服务器的任何连接请求都需要通过创建的套接字。
- en: Upon receiving a request to connect from a potential client, the server can
    decide whether to accept that request. A connection will then be established between
    the two systems in the network, which means that they can start to communicate
    and share data with each other. As the client sends a message to the server via
    the communication channel, the server then processes the message and eventually
    sends a response back to the client through the same channel; this process continues
    until the connection between them ends, either through one of them quitting the
    connection channel or through some external factors.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到潜在客户端的连接请求后，服务器可以决定是否接受该请求。然后两个系统之间将建立连接，这意味着它们可以开始通信并共享数据。当客户端通过通信通道向服务器发送消息时，服务器会处理消息，最终通过相同的通道向客户端发送响应；这个过程会持续，直到它们之间的连接结束，要么是其中一个退出连接通道，要么是通过一些外部因素。
- en: 'The preceding is the basic process of creating a server and establishing connections
    with potential clients. There are multiple security measures implemented at each
    stage of the process, though they are not our concern and will not be discussed
    here. The following diagram also maps out the process that was just described:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上述是创建服务器并与潜在客户端建立连接的基本过程。在整个过程的每个阶段都实施了多种安全措施，尽管它们不是我们关心的内容，也不会在这里讨论。下面的图表也描述了刚刚描述的过程：
- en: '![](assets/ce7cc28e-53e8-4f2d-bf59-3d8220b2b9c0.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ce7cc28e-53e8-4f2d-bf59-3d8220b2b9c0.png)'
- en: Network programming with sockets
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用套接字进行网络编程
- en: Note that in order to create a request to connect to the server, a potential
    client also has to initialize its own socket for the communication channel (as
    shown in the preceding diagram). Again, we are only interested in the server-side
    theory of this process, and thus, we are not discussing client-side elements here.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了创建连接到服务器的请求，潜在客户端还必须初始化自己的通信通道套接字（如前面的图表所示）。再次强调，我们只关注这个过程的服务器端理论，因此在这里不讨论客户端方面的元素。
- en: The API of the socket module
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字模块的API
- en: In this section, we will explore the key API provided by the `socket` module
    to achieve the same functionalities in the process described previously. As we
    have mentioned, the `socket` module comes built-in in any Python 3 distribution,
    so we can simply import the module into our program without having to run installation
    commands.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨`socket`模块提供的关键API，以实现先前描述过程中的相同功能。正如我们已经提到的，`socket`模块内置在任何Python
    3发行版中，因此我们可以简单地将模块导入到我们的程序中，而无需运行安装命令。
- en: 'To create a socket, we will use the `socket.socket()` method, which returns
    a socket object. This object is what we will be working with during most of the
    process of implementing various communication protocols. Additionally, socket
    methods have the following methods that help us control the communication protocols:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建套接字，我们将使用`socket.socket()`方法，该方法返回一个套接字对象。这个对象是我们在实现各种通信协议的过程中将要使用的。此外，套接字方法还具有以下方法，帮助我们控制通信协议：
- en: '`socket.bind()`: This method binds the calling socket to the address that is
    passed to the method. In our examples, we will be passing in a tuple containing
    the address of the host and the port for the communication channel.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.bind()`: 此方法将调用套接字绑定到传递给方法的地址。在我们的示例中，我们将传递一个包含主机地址和通信通道端口的元组。'
- en: '`socket.listen()`: This method allows the server that we create to accept connections
    from potential clients. Another optional positive-integer parameter can be passed
    to the method, to specify the number of allowed unaccepted connections before
    the server refuses new connections. We will be using `5` as an arbitrary number
    for this method in our later examples.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.listen()`: 此方法允许我们创建的服务器接受潜在客户端的连接。还可以传递另一个可选的正整数参数给方法，以指定服务器拒绝新连接之前允许的未接受连接的数量。在我们后面的示例中，我们将使用`5`作为此方法的任意数量。'
- en: '`socket.accept()`: This method, as the name suggests, accepts a specific connection
    that the calling socket object has. This calling object has to first be bound
    to an address and listening for connections to call this method. In other words,
    this method is to be called after the two preceding methods. The method also returns
    a pair of values, `(conn, address)`, with `conn` being the new socket object that
    has accepted the connection and is able to send and receive data, and `address`
    being the address on the other end of the connection (the client address).'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.accept()`: 此方法如其名称所示，接受调用套接字对象的特定连接。首先，调用对象必须绑定到地址并监听连接，才能调用此方法。换句话说，这个方法要在前两个方法之后调用。该方法还返回一对值`(conn,
    address)`，其中`conn`是已接受连接的新套接字对象，能够发送和接收数据，`address`是连接另一端的地址（客户端地址）。'
- en: '`socket.makefile()`: This method returns a `file` object that is associated
    with the calling `socket` object. We will be using this method to create a file
    that contains the data sent from the accepted clients of our server. This `file`
    object will also need to be closed appropriately, using the `close()` method.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.makefile()`: 此方法返回与调用`socket`对象关联的`file`对象。我们将使用此方法创建一个包含来自服务器接受的客户端数据的文件。这个`file`对象也需要适当地关闭，使用`close()`方法。'
- en: '`socket.sendall()`: This method sends the data passed as a parameter to the
    calling `socket` object. We will use this method to send data back to the clients
    connected to our server. Note that this method takes in data in bytes, so we will
    be passing byte strings to this method in our examples.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.sendall()`: 这个方法将传递给调用`socket`对象的数据发送出去。我们将使用这个方法将数据发送回连接到我们服务器的客户端。请注意，这个方法接收字节数据，所以在我们的示例中将向这个方法传递字节字符串。'
- en: '`socket.close()`: This method marks the calling `socket` object as closed.
    After this point, all operations applied on the `socket` object will fail. This
    is to be used when we terminate our server.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.close()`: 这个方法将调用`socket`对象标记为关闭。在此之后，对`socket`对象的所有操作都将失败。这在我们终止服务器时使用。'
- en: Building a simple echo server
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个简单的回显服务器
- en: The best way to truly understand the use of the methods and functions described
    previously is to see them in action in a sample program. In this section, we will
    build an echo server as our starting example. This server, as the term suggests,
    sends whatever it received from each client back to the client. Through this example,
    you will learn how to set up a functional server, as well as how to handle client
    connections and data from it, and we will build more complex servers in later
    sections.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 真正理解先前描述的方法和函数的使用方式的最佳方法是在示例程序中看到它们的运行。在本节中，我们将构建一个回显服务器作为我们的起始示例。这个服务器，正如术语所示，会将从每个客户端接收到的内容发送回客户端。通过这个示例，您将学习如何设置一个功能齐全的服务器，以及如何处理来自客户端的连接和数据，并且我们将在后面的部分构建更复杂的服务器。
- en: Before we jump into the code, however, let's discuss the structure of the program
    that will implement the communication logic for this server. First, we will have
    what is called the **reactor**, which sets up the server itself and provides the
    logic whenever a new connection is requested from potential clients. Specifically,
    once the server has been set up, this reactor will go through an infinite loop
    and handle all connection requests that the server receives.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们进入代码之前，让我们讨论一下将为该服务器实现通信逻辑的程序结构。首先，我们将有所谓的**反应器**，它设置服务器本身并在潜在客户端请求新连接时提供逻辑。具体来说，一旦服务器设置好，这个反应器将进入一个无限循环，并处理服务器接收到的所有连接请求。
- en: 'If you have read the previous chapters on asynchronous programming, it is also
    possible to think of this reactor as an event loop. This event loop goes through
    all of the events that are to be processed (in this case, they are requests),
    and handles them one by one, using an event handler. The following diagram further
    illustrates this process:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经阅读了关于异步编程的前几章，也可以将这个反应器看作是一个事件循环。这个事件循环会处理所有要处理的事件（在这种情况下，它们是请求），并使用事件处理程序逐个处理它们。以下图表进一步说明了这个过程：
- en: '![](assets/0bee377e-3e65-4b5a-bc8e-acf4e81269b6.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0bee377e-3e65-4b5a-bc8e-acf4e81269b6.png)'
- en: An event loop in network programming
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 网络编程中的事件循环
- en: 'The second part of our program, then, is the event handler in the event loop
    analogy, which contains the user business logic: how to process the data received
    from clients, and what to send back to each of them. For our current example,
    since it is an echo server, we are only sending back whatever each client sent
    to our server (if the data is valid).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们程序的第二部分是事件循环类比中的事件处理程序，其中包含用户业务逻辑：如何处理从客户端接收的数据，以及向每个客户端发送什么。对于我们当前的示例，由于它是一个回显服务器，我们只会将每个客户端发送到服务器的任何内容发送回去（如果数据有效）。
- en: 'With that structure in mind, let''s move on to the actual implementation of
    this server. Download the code for this chapter from the GitHub page, then go
    ahead and navigate to the `Chapter18` folder. The script that we are interested
    in is in the `Chapter18/example1.py` file, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个结构，让我们继续实现这个服务器。从GitHub页面下载本章的代码，然后转到`Chapter18`文件夹。我们感兴趣的脚本在`Chapter18/example1.py`文件中，如下所示：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The program is structured in the same way that we discussed previously: a reactor
    and a user business logic handler (the `process_request()` function). First, the
    reactor sets up the server (by creating a socket, binding it to the parametric
    host and port address, and calling the `listen()` method). It then goes into an
    infinite loop and facilitates any potential connection with a client, first accepting
    the connection by calling the `accept()` method on the `socket` object, and then
    calling the `process_request()` function. The reactor is also responsible for
    closing the `socket` object if an error occurs during the preceding process.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的结构与我们之前讨论的方式相同：一个反应器和一个用户业务逻辑处理程序（`process_request()`函数）。首先，反应器设置服务器（通过创建套接字，将其绑定到参数主机和端口地址，并调用`listen()`方法）。然后进入一个无限循环，并促进与客户端的任何潜在连接，首先通过在`socket`对象上调用`accept()`方法接受连接，然后调用`process_request()`函数。如果在前面的过程中发生错误，反应器还负责关闭`socket`对象。
- en: The `process_request()` function, on the other hand, will first create a `file`
    object associated with the socket that is passed to it. Again, this `file` object
    is used by our server to read data from its client that is connected via that
    specific socket. Specifically, after making the `file` object, the function will
    go into another infinite loop that keeps reading from the `file` object, using
    the `readline()` function. If the data read from the file is valid, we will send
    back the same data, using the `sendall()` method.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`process_request()`函数将首先创建一个与传递给它的套接字相关联的`file`对象。同样，这个`file`对象被我们的服务器用来从通过该特定套接字连接的客户端读取数据。具体来说，在制作了`file`对象之后，该函数将进入另一个无限循环，不断从`file`对象中读取数据，使用`readline()`函数。如果从文件中读取的数据是有效的，我们将使用`sendall()`方法将相同的数据发送回去。
- en: We are also printing out what the server receives from each of its clients as
    the server output, by including the line `print(f'{cli_address} --> {line}')`.
    One more specification is that, if the data read from the file is equal to the
    string `quit`, then we will close the connection with that specific client. After
    a connection is closed, we will need to carefully handle the `socket` object itself,
    and the `file` object associated with it, using the `close()` method for both.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还打印出服务器从每个客户端接收到的内容作为服务器输出，包括`print(f'{cli_address} --> {line}')`这一行。另一个规定是，如果从文件中读取的数据等于字符串`quit`，那么我们将关闭与该特定客户端的连接。连接关闭后，我们需要仔细处理`socket`对象本身以及与其关联的`file`对象，使用`close()`方法关闭两者。
- en: 'Finally, at the end of our program, we simply call the `reactor()` function
    and pass it information about our server. In this case, we simply use the loopback
    interface of our server, at port `8080`. Now, we will execute the script to initialize
    our local server. Your output should be similar to the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的程序末尾，我们只需调用`reactor()`函数并向其传递有关我们服务器的信息。在这种情况下，我们只是使用服务器的回环接口，端口为`8080`。现在，我们将执行脚本以初始化我们的本地服务器。您的输出应该类似于以下内容：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At this point, our server is up and running (as indicated in the output). Now,
    we would like to create some clients for this server. To do this, open another
    Terminal window and use the Telnet program to connect to the running server, by
    running `telnet localhost 8080`. Your output should be similar to the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的服务器已经启动并运行（如输出所示）。现在，我们想为这个服务器创建一些客户端。为此，打开另一个终端窗口，并使用Telnet程序连接到运行中的服务器，运行`telnet
    localhost 8080`。您的输出应该类似于以下内容：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This output means that the Telnet client has successfully connected to the server
    that we created. Now, we can test whether the server can handle its requests the
    way that we intended it to. Specifically, enter some data and hit *return* or
    *Enter* to send it to the server, and you will see that the client will receive
    an echoed message from the server, in the way that we implemented in the preceding `process_request()`
    function. Again, a client can stop its connection to this server by sending the
    string `quit` to the server.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出意味着Telnet客户端已成功连接到我们创建的服务器。现在，我们可以测试服务器是否可以按照我们的意图处理其请求。具体来说，输入一些数据并按*return*或*Enter*发送到服务器，您将看到客户端将从服务器接收到一个回显消息，就像我们在前面的`process_request()`函数中实现的那样。同样，客户端可以通过向服务器发送字符串`quit`来停止与该服务器的连接。
- en: 'The following code shows my output when entering a few different phrases:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入几个不同的短语时，以下代码显示了我的输出：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Looking at the output of our server, you can also see what was happening during
    this connection:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们服务器的输出，您还可以看到在此连接期间发生了什么：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The server, as mentioned, is designed to run forever in the reactor as an event
    loop, which can be stopped by a `KeyboardInterrupt` exception.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，服务器被设计为在反应器中作为事件循环永远运行，可以通过`KeyboardInterrupt`异常停止。
- en: We have successfully implemented our first echo server, using low-level methods
    provided by the `socket` module. In the next section, we will implement a more
    advanced functionality for our server and analyze the process of converting it
    to a non-blocking server that can handle multiple clients at the same time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功实现了我们的第一个回显服务器，使用了`socket`模块提供的低级方法。在下一节中，我们将为我们的服务器实现更高级的功能，并分析将其转换为可以同时处理多个客户端的非阻塞服务器的过程。
- en: Building a calculator server with the socket module
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用socket模块构建一个计算器服务器
- en: The functionality that we are trying to implement is to have a simple request
    handler that calculates either the sum or the product of a list of integers, and
    that is included in the data sent from the clients. Specifically, if a client
    sends the string `1`, `2` ,`4` to our server, then the server should send back
    `7` if it is to calculate sums, or `8` if it is to calculate products.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图实现的功能是具有一个简单的请求处理程序，用于计算整数列表的和或乘积，并将其包含在从客户端发送的数据中。具体来说，如果客户端向我们的服务器发送字符串`1`，`2`，`4`，那么服务器应该返回`7`（如果要计算总和）或`8`（如果要计算乘积）。
- en: Every server implements some form of data processing, in addition to handling
    requests coming in from clients and sending the results of that data processing
    task to those clients. This prototype will therefore serve as a first building
    block for more extensive servers, with further complex functionalities.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务器都实现了某种形式的数据处理，除了处理来自客户端的请求并将数据处理任务的结果发送给这些客户端。因此，这个原型将作为更复杂功能的更广泛服务器的第一个构建块。
- en: The underlying calculation logic
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 底层计算逻辑
- en: We will be using the `split()` method for Python strings to extract elements
    that are separated by a specific character in a string. Therefore, we will require
    all data coming from clients to be formatted this way (integers separated by commas),
    and, if a client sends in something that is not in this format, we will simply
    send back an error message and require them to make a new message.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python字符串的`split()`方法来提取由字符串中的特定字符分隔的元素。因此，我们要求来自客户端的所有数据都以这种方式格式化（用逗号分隔的整数），如果客户端发送的内容不符合这种格式，我们将简单地发送回一个错误消息，并要求他们发送一个新的消息。
- en: 'The basic calculation logic is included in the `Chapter18/example2.py` file,
    as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的计算逻辑包含在`Chapter18/example2.py`文件中，如下所示：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Again, we are using the `split()` method, with the `','` argument, to extract
    out the individual numbers in a specific string. The `sum()` function is used
    to calculate, evidently, the sum of the parametric list of numbers. To calculate
    the aggregated product, we need to import the `mul()` method (for multiplication)
    from the `operator` module, as well as the `reduce()` method from the `functools`
    module, to apply the multiplication on each of the elements in the list of numbers
    under consideration.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们使用`split()`方法，带有`,`参数，来提取特定字符串中的各个数字。`sum()`函数用于计算参数列表中数字的和。要计算聚合乘积，我们需要从`operator`模块导入`mul()`方法（用于乘法），以及从`functools`模块导入`reduce()`方法，以在考虑的数字列表中的每个元素上应用乘法。
- en: As a side note, the third argument passed to the `reduce()` method (the number
    `1`) is the starting value for the reduction process. To learn more about reduction
    operations, read through [Chapter 7](57411004-b747-47de-9337-79f53d675a7d.xhtml), *Reduction
    Operators in **Processes,* if you have not done so already.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，传递给`reduce()`方法的第三个参数（数字`1`）是减少过程的起始值。如果您还没有这样做，可以阅读[第7章](57411004-b747-47de-9337-79f53d675a7d.xhtml)，*进程中的减少运算符*，以了解更多关于减少操作的信息。
- en: As for our actual server, we will also keep track of the **mode of calculation**.
    The mode of calculation, whose default is to execute summation, dictates whether
    the server should perform summation and multiplication on the input list of numbers.
    The mode is also unique to each client connection, and can be switched around
    by that client. Specifically, if the data sent by a specific client is the string
    `sum`, then we will switch the mode of calculation to summation, and the same
    goes for the string `product`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 至于我们的实际服务器，我们还将跟踪**计算模式**。计算模式的默认值是执行求和，它决定服务器是否应对输入数字列表执行求和和乘法。该模式也是每个客户端连接的唯一模式，并且可以由该客户端切换。具体来说，如果特定客户端发送的数据是字符串`sum`，那么我们将切换计算模式为求和，对于字符串`product`也是一样。
- en: Implementing the calculator server
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现计算器服务器
- en: 'Now, let''s take a look at the full implementation of this server in the `Chapter18/example3.py`
    file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`Chapter18/example3.py`文件中这个服务器的完整实现：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The reactor component of our server remains the same as our previous example,
    since the event loop handles the same type of logic. In our user business logic
    part (the `process_request()` function), we are still using `file` objects returned
    from the `makefile()` method to obtain data sent by the clients of the server.
    If a client sends in the string `quit`, the connection between that client and
    the server will still be stopped.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们服务器的反应器组件与之前的示例相同，因为事件循环处理相同类型的逻辑。在我们的用户业务逻辑部分（`process_request()`函数）中，我们仍然使用从`makefile()`方法返回的`file`对象来获取服务器客户端发送的数据。如果客户端发送字符串`quit`，则该客户端与服务器之间的连接仍将被停止。
- en: 'The first new thing in this program is the local variable `mode` in the `process_request()`
    function. This variable specifies the mode of calculation that we discussed earlier,
    and has the default value of the string `sum`. As you can see, at the very end
    of the `try` block in the `process_request()` function, this variable decides
    what kind of data is to be sent back to the current client:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序中的第一个新事物是`process_request()`函数中的本地变量`mode`。该变量指定了我们之前讨论过的计算模式，并且默认值为字符串`sum`。正如你所看到的，在`process_request()`函数的`try`块的最后，该变量决定了要发送回当前客户端的数据类型：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Additionally, if data sent from a client is equal to the string `sum`, then
    the `mode` variable will be set to `sum`, and the same applies for the string
    `product`. The client will also receive a message announcing that the mode of
    calculation has been changed. This logic is included in the following portion
    of the code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果从客户端发送的数据等于字符串`sum`，那么`mode`变量将被设置为`sum`，对于字符串`product`也是一样。客户端还将收到一条消息，宣布计算模式已更改。这一逻辑包含在以下代码部分中：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s look at how this server performs in a real experiment. Execute
    the program to run the server, and you will see output similar to that of the
    previous example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个服务器在实际实验中的表现。执行程序运行服务器，你会看到类似于之前示例的输出：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Again, we will be using Telnet to create clients for this server. As you are
    connected to the server through a Telnet client, try to enter some data to test
    out the server logic that we implemented. The following code shows what I obtained
    with various types of input:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用Telnet来为该服务器创建客户端。当你通过Telnet客户端连接到服务器时，请尝试输入一些数据来测试我们实现的服务器逻辑。以下代码显示了我使用各种类型的输入所获得的结果：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can see that our server can handle the requests as we intended. Specifically,
    it can compute both the sum and the product of a given correctly formatted input
    string; it can appropriately switch the mode of calculation; and it can send error
    messages to its clients if the input strings are not correctly formatted. Again,
    this ever-running server can be stopped with a `KeyboardInterrupt` exception.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们的服务器可以按我们的意图处理请求。具体来说，它可以计算给定正确格式的输入字符串的和和乘积；它可以适当地切换计算模式；如果输入字符串格式不正确，它可以向客户端发送错误消息。同样，这个长时间运行的服务器可以通过`KeyboardInterrupt`异常停止。
- en: Building a non-blocking server
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建非阻塞服务器
- en: One thing that we will discover is that the server that we currently have is
    not non-blocking. In other words, it cannot handle multiple clients simultaneously.
    In this section, you will learn how to build on the current server to make it
    non-blocking, using Python keywords that facilitate concurrent programming, in
    addition to low-level functionalities from the `socket` module.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发现的一件事是，我们当前的服务器是阻塞的。换句话说，它无法同时处理多个客户端。在本节中，您将学习如何在当前服务器的基础上构建非阻塞服务器，使用Python关键字来促进并发编程，以及`socket`模块的低级功能。
- en: Analyzing the concurrency of the server
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析服务器的并发性
- en: 'We will now illustrate that the server that we currently have cannot have multiple
    clients at the same time. First, execute the `Chapter18/example3.py` file to run
    the server again, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将说明我们目前的服务器无法同时处理多个客户端。首先，执行`Chapter18/example3.py`文件再次运行服务器，如下所示：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Similar to what we did in the previous examples, let''s now open another Terminal
    and use Telnet into the running server:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例类似，现在让我们打开另一个终端并使用Telnet连接到正在运行的服务器：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To create the second client for this server, open another Terminal and type
    in the same `telnet` command, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要为此服务器创建第二个客户端，请打开另一个终端并输入相同的`telnet`命令，如下所示：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we can already see that the server is not handling this second client
    correctly: it is not sending back the welcome message (`<welcome: starting in
    sum mode>`) to this client. If we look at the output of our server, we can also
    see that it is only registering one client—specifically, the first of the two:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们已经看到服务器没有正确处理这第二个客户端：它没有将欢迎消息(`<welcome: starting in sum mode>`)发送给这个客户端。如果我们查看服务器的输出，我们还可以看到它只注册了一个客户端，具体来说，是两个客户端中的第一个：'
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we will try to enter input from each of the clients. We will see that
    the server is only successfully handling requests from the first client. Specifically,
    the following is my output from the first client, with various types of input:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试从每个客户端输入。我们会发现服务器只成功处理来自第一个客户端的请求。具体来说，以下是来自第一个客户端的输出，包括各种类型的输入：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, with the first client still maintaining the connection with the server,
    switch to the Terminal of the second client and try to enter its own input. You
    will see that unlike the first client, this client is not receiving any message
    back from the server:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第一个客户端仍然与服务器保持连接，切换到第二个客户端的终端并尝试输入自己的输入。你会发现，与第一个客户端不同，这个客户端没有从服务器那里收到任何消息：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we look at the server output, we will see that the server is only handling
    requests from the first client:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看服务器的输出，我们会发现服务器只处理来自第一个客户端的请求：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The only way for the second client to be able to interact with the server is
    if the first client disconnects from the server—in other words, when we stop the
    connection between the first client and the server, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个客户端能够与服务器交互的唯一方法是第一个客户端断开与服务器的连接，换句话说，当我们停止第一个客户端与服务器之间的连接时：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, if you switch to the Terminal of the second client, you will see that
    the client will be flushed with messages from the server that it should have been
    receiving earlier:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你切换到第二个客户端的终端，你会发现客户端将被服务器之前应该接收的消息刷屏：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'All of the appropriate replies from the server are now present, but they were
    sent all at once, and not after each of the input messages. The same surge of
    information is also illustrated in the output from our server Terminal, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的所有适当回复现在都存在，但它们一次性发送，而不是在每个输入消息之后。相同的信息激增也在我们服务器终端的输出中得到了体现：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This output makes it seem as if the server only received the connection from
    the second client after the first client had quit, when in reality, we created
    the two clients and had them communicate with the server at the same time. This
    is because our current server is only able to handle one client at a time, and
    only after the current client has quit can it move on to the next client that
    has requested a communication channel. We call this a blocking server.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出让人觉得服务器只在第一个客户端退出后才收到了来自第二个客户端的连接，但实际上，我们创建了两个客户端，并让它们同时与服务器通信。这是因为我们目前的服务器只能一次处理一个客户端，只有在当前客户端退出后，它才能继续处理请求通信通道的下一个客户端。我们称之为阻塞服务器。
- en: Generators in Python
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的生成器
- en: In the next section, we will discuss how to convert the blocking server that
    we currently have to a non-blocking one, while keeping the calculating functionalities.
    In order to do that, we will first need to look into another concept in Python
    programming, called **generators**. Chances are you have already worked with Python
    generators, but to recap, we will go over the key features of generators in this
    section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何将我们目前拥有的阻塞服务器转换为非阻塞服务器，同时保留计算功能。为了做到这一点，我们首先需要了解Python编程中的另一个概念，称为**生成器**。你可能已经使用过Python生成器，但为了复习，我们将在本节中介绍生成器的关键特性。
- en: Generators are functions that return iterators and can be paused and resumed
    dynamically. Return values from generators are often compared to list objects,
    because generator iterators are **lazy** ([https://en.wikipedia.org/wiki/Lazy_evaluation](https://en.wikipedia.org/wiki/Lazy_evaluation))
    and only produce results when explicitly asked. For this reason, generator iterators
    are more efficient in terms of memory management, and are therefore often preferred
    over lists when large amounts of data are involved.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是返回迭代器并可以动态暂停和恢复的函数。生成器的返回值通常与列表对象进行比较，因为生成器迭代器是**惰性**的，只有在明确要求时才会产生结果。因此，当涉及大量数据时，生成器迭代器在内存管理方面更有效，因此通常比列表更受青睐。
- en: 'Each generator is defined as a function, but instead of using the keyword `return`
    inside the function block, we use `yield`, which is to indicate that the return
    value is only temporary and the whole generator itself can still be resumed after
    the return value is obtained. Let''s look at how Python generators work in an
    example, included in the `Chapter18/example4.py` file, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每个生成器都被定义为一个函数，但是在函数块内部不使用关键字`return`，而是使用`yield`，这是为了表示返回值只是临时的，整个生成器本身在获得返回值后仍然可以恢复。让我们看看Python生成器在`Chapter18/example4.py`文件中的示例：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we have a generator named `read_data()`, which returns multiples of 2,
    from 0 to 8, in a lazy manner. This is done with the keyword `yield`, which is
    placed in front of what would be the return value in an otherwise normal function:
    `i * 2`. Note that the `yield` keyword is placed in front of the **individual**
    elements in the iterator that should be sent back, which facilitates the lazy
    generation.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个名为`read_data()`的生成器，它以懒惰的方式返回从0到8的2的倍数。这是通过关键字`yield`来实现的，该关键字放在否则正常函数中的返回值`i
    * 2`的前面。请注意，`yield`关键字放在迭代器中应该发送回的**单个**元素的前面，这有助于懒惰生成。
- en: 'Now, in our main program, we are obtaining the whole iterator and storing it
    in the variable `result`. Then, we loop through that iterator six times, using
    the `next()` function (which, evidently, returns the next element in the iterator
    passed in). After executing the code, your output should be similar to the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的主程序中，我们正在获取整个迭代器并将其存储在变量`result`中。然后，我们使用`next()`函数循环遍历该迭代器六次（显然，返回传入的迭代器中的下一个元素）。执行代码后，您的输出应该类似于以下内容：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see that, even though the iterator was generated and returned from the
    `read_data()` generator before we looped through it, the actual instructions inside
    the generator were only executed as we tried to obtain more items from the iterator.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，即使在我们循环遍历迭代器之前，迭代器是从`read_data()`生成器中生成并返回的，但是生成器内部的实际指令只有在我们尝试从迭代器中获取更多项目时才会执行。
- en: 'This is illustrated by the fact that the print statements in the output were
    alternatively placed with each other (one print statement from the outer `for`
    loop and one from the inner `for` loop, alternatively): the execution flow goes
    into the outer `for` loop first, tries to access the next item in the iterator,
    goes into the generator, and goes into its own `for` loop. As soon as the execution
    flow reaches the `yield` keyword, it goes back out to the main program. This process
    continues until one of the `for` loops terminates; in our case, the `for` loop
    in the generator stopped first, and we therefore encountered a `StopIteration`
    error at the end.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过输出中的打印语句交替放置来说明（来自外部`for`循环和内部`for`循环的一个打印语句交替出现）：执行流程首先进入外部`for`循环，尝试访问迭代器中的下一个项目，进入生成器，然后进入自己的`for`循环。一旦执行流程到达`yield`关键字，它就会回到主程序。这个过程会一直持续，直到其中一个`for`循环终止；在我们的例子中，生成器中的`for`循环首先停止，因此在最后遇到了`StopIteration`错误。
- en: The laziness in the generation of the iterator comes from the fact that the
    generator stops executing when it reaches the `yield` keyword, and only continues
    its execution when asked by outside instructions (in this case, by the `next()`
    function). Again, this form of data generation is significantly more efficient
    in memory management than simply generating everything that might need to be iterated
    over (such as a list).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器的生成懒惰性来自于生成器在到达`yield`关键字时停止执行，并且只在外部指令要求时（在这种情况下是通过`next()`函数）才继续执行。再次强调，这种形式的数据生成在内存管理方面比简单生成可能需要迭代的所有内容（如列表）要高效得多。
- en: Asynchronous generators and the send method
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步生成器和发送方法
- en: How are generators relevant to our purposes of building an asynchronous server?
    The reason our current server cannot handle multiple clients is because the `readline()`
    function that we are using in the user business logic part, in order to obtain
    client data, is a blocking function that prevents the execution flow from going
    to other potential clients, as long as the current `file` object is still open.
    That is why, when the current client stops its connection with the server, the
    next client immediately receives the surge of information that we saw earlier.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器与我们构建异步服务器的目的有何关联？我们当前的服务器无法处理多个客户端的原因是，我们在用户业务逻辑部分使用的`readline()`函数是一个阻塞函数，只要当前的`file`对象仍然打开，就会阻止执行流程转向其他潜在的客户端。这就是为什么当当前客户端与服务器断开连接时，下一个客户端立即收到我们之前看到的大量信息的原因。
- en: If we could rewrite this function into an asynchronous one that allowed the
    execution flow to switch between different clients while those clients were all
    connecting to the server, that server would then become non-blocking. We will
    do this by using asynchronous generators to concurrently generate data from potentially
    multiple clients at the same time for our server.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够将这个函数重写为一个异步函数，允许执行流程在所有连接到服务器的不同客户端之间切换，那么该服务器将变成非阻塞的。我们将使用异步生成器来同时从潜在的多个客户端并发生成数据，以供我们的服务器使用。
- en: 'To see the underlying structure of the asynchronous generator that we will
    use for our server, let''s first consider the `Chapter18/example5.py` file, as
    follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到我们将用于服务器的异步生成器的基本结构，让我们首先考虑`Chapter18/example5.py`文件，如下所示：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We are still considering the task of printing out multiples of 2, between 0
    and 8\. The `process()` function is our asynchronous generator in this example.
    You can see that there is, in fact, no `yield` keyword inside the generator; this
    is because we are using the `await` keyword, instead. This asynchronous generator
    is responsible for printing out the multiples of 2, computed by another generator, `read_data()`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍在考虑打印出0到8之间的2的倍数的任务。在这个例子中，`process()`函数是我们的异步生成器。您可以看到，实际上在生成器内部没有`yield`关键字；这是因为我们使用了`await`关键字。这个异步生成器负责打印出由另一个生成器`read_data()`计算的2的倍数。
- en: The `@types.coroutine` decorator is used to convert the generator `read_data()`
    into a coroutine function that returns a generator-based coroutine, which can
    still be used as a regular generator but can also be awaited. This generator-based
    coroutine is the key to converting our blocking server to a non-blocking one.
    The coroutine performs the computation with the `send()` method, which is a way
    to provide a generator with input (in this case, we are providing the `process()`
    generator with multiples of 2).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`@types.coroutine`装饰器用于将生成器`read_data()`转换为一个返回基于生成器的协程的协程函数，这个协程函数仍然可以像常规生成器一样使用，但也可以被等待。这个基于生成器的协程是将我们的阻塞服务器转换为非阻塞服务器的关键。协程使用`send()`方法进行计算，这是一种向生成器提供输入的方法（在这种情况下，我们向`process()`生成器提供2的倍数）。'
- en: This coroutine returns a callback, which can be called by our main program later.
    This is why, before looping through `range(5)` in the main program, we need to
    keep track of the `process()` generator itself (stored in the variable `gen`)
    and the callback that is returned (stored in the variable `callback`). The callback,
    specifically, is the return value of `gen.send(None)`, which is used to start
    the execution of the `process()` generator. Finally, we simply loop over the aforementioned
    `range` object and call the `callback` object with the appropriate input.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个协程返回一个回调函数，稍后可以被我们的主程序调用。这就是为什么在主程序中循环`range(5)`之前，我们需要跟踪`process()`生成器本身（存储在变量`gen`中）和返回的回调（存储在变量`callback`中）。具体来说，回调是`gen.send(None)`的返回值，用于启动`process()`生成器的执行。最后，我们简单地循环遍历上述的`range`对象，并使用适当的输入调用`callback`对象。
- en: 'A lot has been said about the theory behind this method of using asynchronous
    generators. Now, let''s see it in action. Execute the program, and you should
    get the following output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用异步生成器的理论已经有很多讨论。现在，让我们看看它的实际应用。执行程序，你应该会得到以下输出：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the output (specifically, the print statements), we can still observe the
    task switching events that are quintessential for both the asynchronous programming
    that was discussed in earlier chapters and the generators that produce output
    lazily. Essentially, we have achieved the same goal as the previous example (printing
    multiples of 2), but here, we used asynchronous generators (with the `async` and
    `await` keywords) to facilitate task switching events, and we were also able to
    pass specific arguments to generators by using a callback. These techniques, when
    combined, form the basic structure that will be applied to our currently blocking
    server.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中（具体来说，是打印语句），我们仍然可以观察到任务切换事件，这对于之前章节中讨论的异步编程和产生输出的生成器来说是至关重要的。基本上，我们实现了与之前示例相同的目标（打印2的倍数），但在这里，我们使用了异步生成器（使用`async`和`await`关键字）来促进任务切换事件，并且我们还能够通过使用回调向生成器传递特定参数。这些技术的结合形成了将应用于我们当前阻塞服务器的基本结构。
- en: Making the server non-blocking
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使服务器非阻塞
- en: 'Finally, we will consider the problem of implementing a non-blocking server
    again. Here, we are applying the asynchronous generators discussed previously
    to facilitate the asynchronous reading and handling of data received from clients
    of the server. The actual code for the server is included in the `Chapter18/example6.py`
    file; we will be going through various parts of it, as it is a relatively long
    program. Let''s turn our attention to the global variables that we will have in
    this program, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将再次考虑实现非阻塞服务器的问题。在这里，我们将之前讨论过的异步生成器应用于服务器的客户端接收数据的异步读取和处理。服务器的实际代码包含在`Chapter18/example6.py`文件中；我们将逐步介绍其中的各个部分，因为这是一个相对较长的程序。让我们先关注一下这个程序中将会有的全局变量：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To be able to successfully facilitate services for multiple clients at the same
    time, we will allow the server to have multiple sessions (one for each client)
    at the same time, and therefore, we will need to keep track of multiple dictionaries,
    each of which will hold one specific piece of information about the current session.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功地为多个客户端同时提供服务，我们将允许服务器同时拥有多个会话（每个客户端一个），因此，我们需要跟踪多个字典，每个字典将保存关于当前会话的特定信息。
- en: Specifically, the `sessions` dictionary maps a client socket connection to a
    `Session` object, which is a Python `namedtuple` object that contains the address
    of the client and the `file` object associated with that client connection. The
    `callback` dictionary maps a client socket connection to a callback that is the
    return value of the asynchronous generator that we will implement later; each
    of these callbacks takes in its corresponding client socket connection and data
    read from that client as arguments. Finally, the `generators` dictionary maps
    a client socket connection to its corresponding asynchronous generator.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，`sessions`字典将客户端套接字连接映射到一个`Session`对象，这是一个Python的`namedtuple`对象，其中包含客户端的地址和与该客户端连接关联的`file`对象。`callback`字典将客户端套接字连接映射到一个回调函数，这个回调函数是我们稍后将实现的异步生成器的返回值；每个这样的回调函数都以其对应的客户端套接字连接和从该客户端读取的数据作为参数。最后，`generators`字典将客户端套接字连接映射到其对应的异步生成器。
- en: 'Now, let''s take a look at the `reactor` function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`reactor`函数：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Aside from what we already had from our previous blocking server, we are adding
    in a number of instructions: we use the `setblocking()` method from the `socket`
    module to potentially make our server asynchronous, or non-blocking; as we are
    starting a server, we also register that specific socket to the `sessions` dictionary,
    with a `None` value for now.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前阻塞服务器中已经有的内容，我们还添加了一些指令：我们使用`socket`模块中的`setblocking()`方法来潜在地使我们的服务器异步或非阻塞；因为我们正在启动一个服务器，我们还将特定的套接字注册到`sessions`字典中，暂时使用`None`值。
- en: Inside our infinite `while` loop (the event loop) is part of the new non-blocking
    feature that we are trying to implement. First, we use the `select()` method from
    the `select` module to single out the sockets from the `sessions` dictionary that
    are ready to be read (in other words, the sockets that have available data). Since
    the first argument of the method is for the data to be read, the second is for
    the data to be written, and the third is for exception data, we are only passing
    in the `sessions` dictionary in the first argument. The fourth argument specifies
    the timeout period for the method (in seconds); if unspecified, the method will
    block infinitely, until at least one item in `sessions` becomes available, which
    is not suitable for our non-blocking server.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的无限`while`循环（事件循环）中是我们试图实现的新的非阻塞特性的一部分。首先，我们使用`select`模块的`select()`方法来单独选择`sessions`字典中准备好被读取的套接字（换句话说，具有可用数据的套接字）。由于该方法的第一个参数是要读取的数据，第二个是要写入的数据，第三个是异常数据，我们只在第一个参数中传入`sessions`字典。第四个参数指定了方法的超时时间（以秒为单位）；如果未指定，该方法将无限期地阻塞，直到`sessions`中至少有一项可用，这对于我们的非阻塞服务器来说是不合适的。
- en: Next, for every client socket connection that is ready to be read, if the connection
    corresponds to our original server socket, we will accept that connection and
    call the `connect()` function (which we will look at soon). In this `for` loop,
    we will also handle the callback methodologies. Specifically, we will access the
    `file` attribute of the session of the current socket connection (recall that
    each session has an `address` attribute and a `file` attribute) and will read
    data from it using the `readline()` method. Now, if what we read is valid data,
    then we will pass it (along with the current client connection) to the corresponding
    callback; otherwise, we will end the connection.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于每个准备被读取的客户端套接字连接，如果连接对应于我们原始的服务器套接字，我们将接受该连接并调用`connect()`函数（我们将很快看到）。在这个`for`循环中，我们还将处理回调方法。具体来说，我们将访问当前套接字连接的会话的`file`属性（回想一下，每个会话都有一个`address`属性和一个`file`属性），并将使用`readline()`方法从中读取数据。现在，如果我们读到的是有效数据，那么我们将把它（连同当前客户端连接）传递给相应的回调；否则，我们将结束连接。
- en: Note that even though our server is made asynchronous by the socket being set
    to non-blocking, the preceding `readline()` method is still a blocking function.
    The `readline()` function returns when it gets to a carriage return in its input
    data (the `'\r'` character in ASCII). This means that if the data sent by a client
    somehow does not contain a carriage return, then the `readline()` function will
    fail to return. However, since the server is still non-blocking, an error exception
    will be raised so that other clients will not be blocked.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管我们的服务器通过将套接字设置为非阻塞而变成了异步的，但前面的`readline()`方法仍然是一个阻塞函数。`readline()`函数在输入数据中遇到回车符（ASCII中的`'\r'`字符）时返回。这意味着，如果客户端发送的数据不包含回车符，那么`readline()`函数将无法返回。然而，由于服务器仍然是非阻塞的，将会引发错误异常，以便其他客户端不会被阻塞。
- en: 'Now, let''s look at our new helper functions:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看我们的新辅助函数：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `connect()` function, which is to be called when a client connection has
    data that is ready to read, will initiate starting instructions at the beginning
    of a valid connection with a client. First, it initializes the `namedtuple` object
    associated with that specific client connection (we are still using the `makefile()`
    method to create the `file` objects here). The rest of the function is what we
    saw in the usage pattern of asynchronous generators, which we discussed earlier:
    we pass the client connection to `process_request()`, which is now an asynchronous
    generator; register it in the `generators` dictionary; have it call `send(None)`
    to initiate the generator; and store the return value to the `callback` dictionary,
    so that it can be called later (specifically, in the last part of the event loop
    in the reactor that we just saw).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect()`函数在客户端连接有准备好被读取的数据时将被调用，它将在与客户端的有效连接开始时启动指令。首先，它初始化与该特定客户端连接相关联的`namedtuple`对象（我们仍然在这里使用`makefile()`方法来创建`file`对象）。函数的其余部分是我们之前讨论过的异步生成器的用法模式：我们将客户端连接传递给现在是异步生成器的`process_request()`，将其注册到`generators`字典中；让它调用`send(None)`来启动生成器；并将返回值存储到`callback`字典中，以便稍后调用（具体来说，在我们刚刚看到的反应器中的事件循环的最后部分）。'
- en: The `disconnect()` function, on the other hand, facilitates various cleaning
    instructions when a connection with a client stops. It removes the generator associated
    with the client connection from the `generators` dictionary and closes the generator,
    the `file` object stored in the `sessions` dictionary, as well as the client connection
    itself. Finally, it deletes the keys that correspond to the client connection
    from the remaining dictionaries.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`disconnect()`函数在与客户端的连接停止时提供各种清理指令。它从`generators`字典中移除与客户端连接相关联的生成器，并关闭`sessions`字典中存储的`file`对象以及客户端连接本身。最后，它从剩余的字典中删除与客户端连接对应的键。
- en: 'Let''s turn our attention to the new `process_request()` function, which is
    now an asynchronous generator:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把注意力转向现在是异步生成器的新`process_request()`函数：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The logic that handles client data and performs the computation remains the
    same, and the only differences with this new function are the `async` keyword
    (placed in front of the `def` keyword) and the `await` keyword used with the new
    `readline()` function. These differences, in essence, convert our `process_request()`
    function into a non-blocking one, with the condition that the new `readline()`
    function is also non-blocking:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 处理客户端数据并执行计算的逻辑保持不变，这个新函数的唯一区别是`async`关键字（放在`def`关键字前面）和与新的`readline()`函数一起使用的`await`关键字。这些区别本质上将我们的`process_request()`函数转换为一个非阻塞函数，条件是新的`readline()`函数也是非阻塞的。
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Similar to what we saw in the previous example, we are importing the `types`
    module from Python and using the `@types.coroutine` decorator to make the `readline()`
    function a generator-based coroutine, which is non-blocking. Each time a callback
    (which takes in a client connection and a line of data) is called, the execution
    flow will go into the `inner()` function inside this coroutine and execute the
    instructions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们在前面的例子中看到的，我们从Python中导入`types`模块，并使用`@types.coroutine`装饰器将`readline()`函数变成基于生成器的协程，这是非阻塞的。每次调用回调函数（接受客户端连接和一行数据）时，执行流程将进入这个协程内部的`inner()`函数并执行指令。
- en: Specifically, it sends the line of data to the generator, which will enable
    the instructions in `process_request()` to handle it asynchronously and store
    the return value to the appropriate callback—unless the end of the generator has
    been reached, in which case the `disconnect()` function will be called.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，它将数据行发送到生成器，生成器将使`process_request()`中的指令异步处理并将返回值存储到适当的回调中，除非已经到达生成器的末尾，在这种情况下将调用`disconnect()`函数。
- en: 'Our last task is to test whether this server is actually capable of handling
    multiple clients at the same time. To do this, execute the following script first:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个任务是测试这个服务器是否真的能够同时处理多个客户端。为此，首先执行以下脚本：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Similar to what you saw earlier, open two additional Terminals and use Telnet
    into this running server with both:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于您之前看到的，打开两个额外的终端并使用Telnet连接到正在运行的服务器：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you can see, both clients are being handled correctly: both are able to
    connect, and both receive the welcome message. This is also illustrated by the
    server output, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，两个客户端都被正确处理：两者都能够连接，并且都收到了欢迎消息。这也可以通过服务器输出来说明，如下所示：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Further tests could involve sending messages to the server at the same time,
    which it can still handle. The server can also keep track of individual modes
    of calculation that are unique to individual clients (in other words, assuming
    each client has a separate mode of calculation). We have successfully built a
    non-blocking, concurrent server from scratch.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步的测试可能涉及同时向服务器发送消息，它仍然可以处理。服务器还可以跟踪独立于各个客户端的独特计算模式（换句话说，假设每个客户端都有一个单独的计算模式）。我们已经成功地从头开始构建了一个非阻塞的并发服务器。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: More often than not, low-level network programming involves the manipulation
    and handling of sockets (defined as theoretical endpoints within the nodes of
    a specific computer network, responsible for receiving or sending data from the
    nodes that they are in). The architecture of server-side communication consists
    of multiple steps involving socket handling, such as bind, listen, accept, read,
    and write. The `socket` module provides an intuitive API that facilitates these
    steps.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 往往，低级网络编程涉及套接字的操作和处理（在特定计算机网络的节点内定义为理论端点，负责从它们所在的节点接收或发送数据）。服务器端通信的架构包括多个涉及套接字处理的步骤，如绑定、监听、接受、读取和写入。`socket`模块提供了一个直观的API，便于进行这些步骤。
- en: To create a non-blocking server with the `socket` module, asynchronous generators
    need to be implemented, in order for the execution flow to switch between tasks
    and data. This process also involves using callbacks that can be run by the execution
    flow at a later time. These two elements allow for the server to read and handle
    the data coming in from multiple clients at the same time, allowing the server
    to become non-blocking.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`socket`模块创建非阻塞服务器，需要实现异步生成器，以便执行流程在任务和数据之间切换。这个过程还涉及使用回调，可以在以后执行流程运行。这两个元素允许服务器同时读取和处理来自多个客户端的数据，使服务器成为非阻塞。
- en: We will conclude our book with the next chapter, with practical techniques for
    designing and implementing concurrent programs. Specifically, we will discuss
    how to test, debug, and schedule concurrent applications, methodically and effectively.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中结束我们的书，介绍设计和实现并发程序的实用技术。具体来说，我们将讨论如何系统地和有效地测试、调试和安排并发应用程序。
- en: Questions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a socket? How is it relevant to network programming?
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是套接字？它与网络编程有什么关系？
- en: What is the procedure for server-side communication when a potential client
    makes a request to connect?
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当潜在客户端请求连接时，服务器端通信的程序是什么？
- en: What are some methods provided by the `socket` module to facilitate low-level
    network programming on the server-side?
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket`模块提供了哪些方法来便于服务器端的低级网络编程？'
- en: What are generators? What is their advantage over Python lists?
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是生成器？它们相对于Python列表的优势是什么？
- en: What are asynchronous generators? How can they be applied to build a non-blocking
    server?
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是异步生成器？它们如何应用于构建非阻塞服务器？
- en: Further reading
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, you can refer to the following links:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取更多信息，您可以参考以下链接：
- en: '*Keynote on Concurrency*, PyBay 2017, Raymond Hettinger ([https://pybay.com/site_media/slides/raymond2017-keynote/async_examples.html](https://pybay.com/site_media/slides/raymond2017-keynote/async_examples.html))
    [](https://pybay.com/site_media/slides/raymond2017-keynote/async_examples.html)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*并发演讲*，PyBay 2017，Raymond Hettinger ([https://pybay.com/site_media/slides/raymond2017-keynote/async_examples.html](https://pybay.com/site_media/slides/raymond2017-keynote/async_examples.html))
    [](https://pybay.com/site_media/slides/raymond2017-keynote/async_examples.html)'
- en: '*A simple Python webserver*, Stephen C. Phillips ([blog.scphillips.com/posts/2012/12/a-simple-python-webserver/](http://blog.scphillips.com/posts/2012/12/a-simple-python-webserver/))'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个简单的Python Web服务器*，Stephen C. Phillips ([blog.scphillips.com/posts/2012/12/a-simple-python-webserver/](http://blog.scphillips.com/posts/2012/12/a-simple-python-webserver/))'
- en: '*How to Work with TCP Sockets in Python*, Alexander Stepanov ([steelkiwi.com/blog/working-tcp-sockets/](https://steelkiwi.com/blog/working-tcp-sockets/))'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何在Python中使用TCP套接字*，Alexander Stepanov ([steelkiwi.com/blog/working-tcp-sockets/](https://steelkiwi.com/blog/working-tcp-sockets/))'
- en: '*Socket Programming in Python*, Nathan Jennings ([realpython.com/python-sockets/#multi-connection-client-and-server](https://realpython.com/python-sockets/#multi-connection-client-and-server))'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的套接字编程，Nathan Jennings（realpython.com/python-sockets/#multi-connection-client-and-server）
- en: '*Introduction to Python Generators* ([realpython.com/introduction-to-python-generators/](https://realpython.com/introduction-to-python-generators/))'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python生成器简介（realpython.com/introduction-to-python-generators/）
