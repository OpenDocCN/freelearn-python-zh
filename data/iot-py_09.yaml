- en: Chapter 9. Working with the Cloud
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。与云一起工作
- en: 'In this chapter, we will take advantage of many cloud services to publish and
    visualize data collected for sensors and to establish bi-directional communications
    between Internet-connected things. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将利用许多云服务来发布和可视化收集的传感器数据，并在互联网连接的事物之间建立双向通信。我们将涵盖以下主题：
- en: Publishing data to the cloud with dweepy and `dweet.io`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 dweepy 和 `dweet.io` 将数据发布到云
- en: Building a web-based dashboard with freeboard.io
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 freeboard.io 构建基于网页的仪表板
- en: Sending and receiving data in real time through Internet with PubNub
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 PubNub 在互联网上实时发送和接收数据
- en: Publishing messages with commands through the PubNub cloud
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 PubNub 云发布带有命令的消息
- en: Working with bi-directional communications between IoT devices and other devices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在物联网设备与其他设备之间进行双向通信
- en: Publishing messages to the cloud with a Python PubNub client
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python PubNub 客户端将消息发布到云
- en: Using the MQTT protocol with Mosquitto and Eclipse Paho
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Mosquitto 和 Eclipse Paho 的 MQTT 协议
- en: Publishing messages to a Mosquitto broker with a Python client
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 客户端将消息发布到 Mosquitto 代理
- en: Publishing data to the cloud with dweepy
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 dweepy 将数据发布到云
- en: 'In [Chapter 8](ch08.html "Chapter 8. Displaying Information and Performing
    Actions"), *Displaying Information and Performing Actions*, we worked with a digital
    temperature and humidity sensor combined with displays and a servo. Now, we want
    to take advantage of two cloud services to build a real time and interactive web-based
    dashboard that allows us to watch gauges with the following information in a web
    browser:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](ch08.html "第 8 章。显示信息和执行操作")中，我们使用数字温度和湿度传感器与显示屏和伺服机构一起工作。现在，我们想利用两个云服务来构建一个实时交互式的基于网页的仪表板，使我们能够在网页浏览器中查看以下信息的仪表盘：
- en: Ambient temperature measured in degrees Fahrenheit (ºF)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境温度以华氏度（ºF）为单位测量
- en: Ambient temperature measured in degrees Celsius (ºC)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境温度以摄氏度（ºC）为单位测量
- en: Ambient humidity level expressed in percentage (%)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境湿度水平以百分比（%）表示
- en: 'First, we will take advantage of `dweet.io` to publish the data retrieved from
    the sensors and make it available to different computers and devices all over
    the world. The `dweet.io` data sharing utility allows us to easily publish data
    or messages and alerts from IoT devices and then use other devices to subscribe
    to this data. The `dweet.io` data sharing utility defines itself as something
    similar to Twitter for social machines. You can read more about `dweet.io` in
    its Webpage: [http://dweet.io](http://dweet.io).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将利用 `dweet.io` 发布从传感器获取的数据，并使其可供全球的计算机和设备使用。`dweet.io` 数据共享工具使我们能够轻松发布来自物联网设备的数据或消息和警报，然后使用其他设备订阅这些数据。`dweet.io`
    数据共享工具将自己定义为类似于为社交机器提供的 Twitter。您可以在其网页上了解更多关于 `dweet.io` 的信息：[http://dweet.io](http://dweet.io)。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In our example, we will take advantage of the free services offered by `dweet.io`
    and we won't use some advanced features that provide privacy for our data but
    also require a paid subscription. Our data will be available to anyone that can
    access the `dweet.io` web page because we are not working with locked dweets.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将利用 `dweet.io` 提供的免费服务，而不会使用一些提供数据隐私但需要付费订阅的高级功能。由于我们不使用锁定的 dweets，我们的数据将对任何可以访问
    `dweet.io` 网页的人开放。
- en: The `dweet.io` data sharing utility provides a Web api that we can send data
    from our IoT device, known as *thing* in `dweet.io` documentation. First, we have
    to chose a unique name for our thing. It is convenient to combine a string with
    a **GUID** (short for **Global Unique Identifier**). Another option is to click
    on the **Try It Now** button on the main `dweet.io` web page and grab the name
    that the web page chooses for our thing. This way, we are sure that the name is
    unique and nobody else is using this name for another thing to publish data with
    `dweet.io`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`dweet.io` 数据共享工具提供了一个 Web API，我们可以从我们的物联网设备（在 `dweet.io` 文档中称为 *thing*）发送数据。首先，我们必须为我们的
    thing 选择一个独特的名称。将字符串与 **GUID**（即 **全球唯一标识符**）组合是方便的。另一种选择是点击主 `dweet.io` 网页上的
    **立即尝试** 按钮，并获取网页为我们的 thing 选择的名字。这样，我们可以确保名字是唯一的，并且没有人使用这个名字为另一个 thing 发布数据到
    `dweet.io`。'
- en: 'Once we have chosen a unique name for our thing, we can start publishing data,
    a process known as `dweeting`. We just need to compose a POST HTTP verb with the
    desired JSON data in the body and with the following request URL: `https://dweet.io/dweet/for/my-thing-name`.
    We must replace `my-thing-name` with the name we have chosen for our thing. In
    our examples, we will use `iot_python_chapter_09_01_gaston_hillar` to name our
    IoT device that will publish temperature and humidity values, that is, the thing
    that will dweet. Thus, we have to compose a POST HTTP verb with the desired JSON
    data in the body and with the following request URL: `https://dweet.io/dweet/for/iot_python_chapter_09_01_gaston_hillar`.
    Make sure you replace the name with the name you have chosen for your thing.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为我们的设备选择了一个独特的名称，我们就可以开始发布数据，这个过程被称为 `dweeting`。我们只需要在请求 URL `https://dweet.io/dweet/for/my-thing-name`
    中组合一个 POST HTTP 动词，并在正文中包含所需的 JSON 数据。我们必须将 `my-thing-name` 替换为我们为设备选择的名称。在我们的示例中，我们将使用
    `iot_python_chapter_09_01_gaston_hillar` 来命名我们的 IoT 设备，该设备将发布温度和湿度值，即将要 dweet
    的设备。因此，我们必须在请求 URL `https://dweet.io/dweet/for/iot_python_chapter_09_01_gaston_hillar`
    中组合一个 POST HTTP 动词，并在正文中包含所需的 JSON 数据。确保将名称替换为您为设备选择的名称。
- en: 'Dweepy is a simple Python client for `dweet.io` that allows us to easily publish
    data to `dweet.io` with Python. Instead of manually building and sending an HTTP
    request to a specific URL with Python, we can use the methods provided by this
    useful module. The following is the Web page for the Dweepy module: [https://pypi.python.org/pypi/dweepy/0.2.0](https://pypi.python.org/pypi/dweepy/0.2.0).
    Under the hoods, Dweepy uses the popular features provided by the popular `requests`
    module to build and send the HTTP requests.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Dweepy 是一个简单的 Python 客户端，用于 `dweet.io`，它允许我们使用 Python 容易地发布数据到 `dweet.io`。我们不需要手动使用
    Python 构建并发送一个特定的 URL 的 HTTP 请求，而是可以使用这个有用模块提供的方法。以下是为 Dweepy 模块提供的网页：[https://pypi.python.org/pypi/dweepy/0.2.0](https://pypi.python.org/pypi/dweepy/0.2.0)。在内部，Dweepy
    使用流行的 `requests` 模块提供的流行功能来构建和发送 HTTP 请求。
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: One of the nice things of working with Python as our main programming language
    for IoT is that there is always a package that makes things easy for us in Python.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在物联网中作为我们的主要编程语言使用 Python 的一个好处是，总有软件包让事情变得简单。
- en: 'In [Chapter 2](ch02.html "Chapter 2. Working with Python on Intel Galileo Gen
    2"), *Working with Python on Intel Galileo Gen 2*, we installed `pip` installer
    to easily install additional Python 2.7.3 packages in the Yocto Linux that we
    are running on the board. Now, we will use `pip` installer to install Dweepy 0.2.0\.
    We just need to run the following command in the SSH terminal to install the package:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](ch02.html "第 2 章。在英特尔 Galileo Gen 2 上使用 Python")，*在英特尔 Galileo Gen
    2 上使用 Python* 中，我们安装了 `pip` 安装程序，以便在板上的 Yocto Linux 中轻松安装额外的 Python 2.7.3 软件包。现在，我们将使用
    `pip` 安装程序安装 Dweepy 0.2.0。我们只需要在 SSH 终端中运行以下命令来安装软件包：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The last lines for the output will indicate that the `dweepy` package has been
    successfully installed. Don''t worry about the error messages related to building
    wheel and the insecure platform warning:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示 `dweepy` 软件包已成功安装。不要担心与构建 wheel 相关的错误消息和不安全平台警告：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will take the code we wrote in the previous chapter when we read temperature
    and humidity values from the sensor and we will use this code as a baseline to
    add the new features. The code file for the sample was `iot_python_chapter_08_03.py`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从传感器读取温度和湿度值时，我们将使用上一章编写的代码，并将此代码作为添加新功能的基线。示例代码文件为 `iot_python_chapter_08_03.py`。
- en: We will use the recently installed `dweepy` module to publish data to `dweet.io`
    and make it available as a data source for another cloud service that will allow
    us to build a web-based dashboard. We will add the necessary lines to our loop
    and it will publish the measured values every 10 seconds. The code file for the
    sample is `iot_python_chapter_09_01.py`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用最近安装的 `dweepy` 模块将数据发布到 `dweet.io`，并使其作为另一个云服务的数据源，该云服务将允许我们构建基于 Web 的仪表板。我们将在循环中添加必要的行，并且它将每
    10 秒发布一次测量的值。示例代码文件为 `iot_python_chapter_09_01.py`。
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The highlighted lines show the changes made to the `__main__` method compared
    with the previous version. The first highlighted line creates a local variable
    named `thing_name` that saves a string with the name we have chosen for our thing
    to use with `dweet.io`. Remember that you have to replace the string with the
    name you have chosen for your thing before running the sample code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮行显示了与上一个版本相比对`__main__`方法所做的更改。第一条高亮行创建了一个名为`thing_name`的局部变量，该变量保存了一个字符串，其中包含我们为我们的设备选择的名字，以便与`dweet.io`一起使用。记住，在运行示例代码之前，你必须将字符串替换为你为设备选择的名字。
- en: 'Then, the code runs a loop forever and the first highlighted line creates a
    dictionary and saves it in the `dweet` local variable. The dictionary defines
    the key-value pairs that we want to send as JSON data to `dweet.io` for our thing.
    The following are the keys the code will send:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将无限循环运行，第一条高亮行创建一个字典并将其保存在`dweet`局部变量中。该字典定义了我们想要作为JSON数据发送到`dweet.io`的键值对。以下是要发送的键：
- en: '`temperature_celsius`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`temperature_celsius`'
- en: '`temperature_fahrenheit`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`temperature_fahrenheit`'
- en: '`humidity_level_percentage`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`humidity_level_percentage`'
- en: 'The values for the previously enumerated keys are the values retrieved by the
    sensor converted to strings. Once the dictionary with the desired JSON data is
    built, the code calls the `dweepy.dweet_for` method with `thing_name` and `dweet`
    as arguments, that is, the thing name and the JSON data we want to publish for
    the specified thing name. Under the hoods, the `dweepy.dweet_for` method uses
    the `requests` module to compose a POST HTTP verb with the `dweet` dictionary
    as the desired JSON data in the body and with the following request URL: `https://dweet.io/dweet/for/`
    followed by the thing name specified in the `thing_name` local variable. This
    way, the code dweets the temperature and humidity values retrieved from the sensor
    in different units.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 之前列举的键的值是由传感器获取的值转换为字符串。一旦构建了包含所需JSON数据的字典，代码将调用`dweepy.dweet_for`方法，并将`thing_name`和`dweet`作为参数，即设备名称和我们要为指定设备名称发布的JSON数据。在幕后，`dweepy.dweet_for`方法使用`requests`模块来组合一个POST
    HTTP动词，将`dweet`字典作为正文中的所需JSON数据，并且以下请求URL：`https://dweet.io/dweet/for/`后跟在`thing_name`局部变量中指定的设备名称。这样，代码将传感器获取的温度和湿度值以不同的单位dweet。
- en: The following line will start the example.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将开始示例。
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After you run the example, turn on an air conditioner or a heating system, to
    generate a change in the ambient temperature and humidity. This way, we will notice
    changes in the data that is being published every 10 seconds.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行示例后，打开空调或加热系统，以产生环境温度和湿度的变化。这样，我们将注意到每10秒发布的数据中的变化。
- en: 'Wait around 20 seconds and open the following URL in any Web browser: `http://dweet.io/follow/iot_python_chapter_09_01_gaston_hillar`.
    Don''t forget to replace `iot_python_chapter_09_01_gaston_hillar` with the name
    you have chosen for your thing. In this case, we can enter the URL in any device
    connected to the Internet. We don''t need the device to be in the same LAN than
    the board because the values are published with `dweet.io` and they are available
    everywhere.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 等待大约20秒，然后在任何网络浏览器中打开以下URL：`http://dweet.io/follow/iot_python_chapter_09_01_gaston_hillar`。别忘了将`iot_python_chapter_09_01_gaston_hillar`替换为你为你的设备选择的名字。在这种情况下，我们可以在任何连接到互联网的设备上输入此URL。我们不需要设备与板子处于同一局域网中，因为值是通过`dweet.io`发布的，并且可以在任何地方访问。
- en: 'The **Visual** view will display a line graph with the humidity level and the
    temperature values as they were changing over time. The right-hand side will display
    the latest value that was published. The view will be refreshed automatically
    when the Python code dweets new values. The following picture shows a screenshot
    with the **Visual** view:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**视觉**视图将显示一条线形图，显示湿度水平和温度值随时间的变化。右侧将显示最新发布的值。当Python代码dweets新值时，视图将自动刷新。以下图片显示了带有**视觉**视图的屏幕截图：'
- en: '![Publishing data to the cloud with dweepy](img/B05042_09_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![使用dweepy将数据发布到云中](img/B05042_09_01.jpg)'
- en: 'Click on the **Raw** view and the page will display the latest JSON data that
    the Python code running on the board has published and received by `dweet.io`
    for our thing. The following lines show an example of the latest JSON data that
    was received and that was shown in the previous picture:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**原始**视图，页面将显示板子上运行的Python代码通过`dweet.io`为我们的设备发布的最新JSON数据。以下行显示了之前图片中显示的接收到的最新JSON数据示例：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In [Chapter 4](ch04.html "Chapter 4. Working with a RESTful API and Pulse Width
    Modulation"), *Working with a RESTful API and Pulse Width Modulation*, we installed
    HTTPie, a command-line HTTP client written in Python that makes is easy to send
    HTTP requests and uses a syntax that is easier than curl (also known as cURL).
    We can run the following HTTPie command in any computer or device to retrieve
    the latest dweet made for our thing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](ch04.html "第 4 章。使用 RESTful API 和脉冲宽度调制") 中，*使用 RESTful API 和脉冲宽度调制*，我们安装了
    HTTPie，这是一个用 Python 编写的命令行 HTTP 客户端，它使得发送 HTTP 请求变得容易，并且使用的语法比 curl（也称为 cURL）更容易。我们可以在任何计算机或设备上运行以下
    HTTPie 命令来检索为我们的事物创建的最新 dweet。
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The previous command will compose and send the following HTTP request: `GET
    https://dweet.io:443/get/latest/dweet/for/iot_python_chapter_09_01_gaston_hillar`.
    The `dweet.io` API will return the latest dweet for the specified thing. The following
    lines show a sample response from `dweet.io`. The JSON data is included in the
    value for the `content` key.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组成并发送以下 HTTP 请求：`GET https://dweet.io:443/get/latest/dweet/for/iot_python_chapter_09_01_gaston_hillar`。`dweet.io`
    API 将返回指定事物的最新 dweet。以下几行显示了 `dweet.io` 的一个示例响应。JSON 数据包含在 `content` 键的值中。
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can run the following HTTPie command in any computer or device to retrieve
    all of the saved dweets for our thing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何计算机或设备上运行以下 HTTPie 命令来检索我们事物的所有已保存 dweets。
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The previous command will compose and send the following HTTP request: `GET
    https://dweet.io:443/get/ dweets/for/iot_python_chapter_09_01_gaston_hillar`.
    The `dweet.io` API will return the saved dweets from its long term storage for
    the specified thing. The following lines show a sample response from `dweet.io`.
    Notice that there are limitations in the number of dweets stored in the long term
    storage and in the returned values.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组成并发送以下 HTTP 请求：`GET https://dweet.io:443/get/dweets/for/iot_python_chapter_09_01_gaston_hillar`。`dweet.io`
    API 将返回指定事物的长期存储中保存的 dweets。以下几行显示了 `dweet.io` 的一个示例响应。请注意，长期存储中存储的 dweets 数量和返回的值都有限制。
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Building a web-based dashboard with Freeboard
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Freeboard 构建 Web 仪表板
- en: 'The `dweet.io` data sharing utility allowed us to easily publish data to the
    cloud with just a few lines of code. Now, we are ready to use `dweet.io` and our
    thing name as a data source to build a real-time web-based dashboard. We will
    take advantage of freeboard.io to visualize the data collected with the sensor
    and published to `dweet.io` in many gauges and make the dashboard available to
    different computers and devices all over the world. Freeboard.io allows us to
    build a dashboard by selecting data sources and dragging and dropping customizable
    widgets. Freeboard.io defines itself as a cloud-based service that allows us to
    visualize the Internet of Things. You can read more about freeboard.io in its
    Webpage: [http://freeboard.io](http://freeboard.io).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`dweet.io` 数据共享工具使我们能够仅用几行代码轻松地将数据发布到云端。现在，我们准备使用 `dweet.io` 和我们的设备名称作为数据源来构建一个实时基于网页的仪表板。我们将利用
    freeboard.io 来可视化通过传感器收集并发布到 `dweet.io` 的数据，并在许多仪表中展示仪表板，使其可供世界各地的不同计算机和设备使用。Freeboard.io
    将自己定义为一种基于云的服务，允许我们可视化物联网。您可以在其网页上了解更多关于 freeboard.io 的信息：[http://freeboard.io](http://freeboard.io)。'
- en: Tip
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In our example, we will take advantage of the free services offered by freeboard.io
    and we won't use some advanced features that provide privacy for our dashboards
    but also require a paid subscription. Our dashboard will be available to anyone
    that has the unique URL for it because we are not working with private dashboards.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将利用 freeboard.io 提供的免费服务，而不会使用一些提供隐私但需要付费订阅的高级功能。由于我们不处理私有仪表板，因此任何拥有其唯一
    URL 的人都可以访问我们的仪表板。
- en: Freeboard requires us to sign up and create an account with a valid e-mail and
    a password before we can build a web-based dashboard. We aren't required to enter
    any credit card or payment information. If you already have an account at freeboard.io,
    you can skip the next step.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Freeboard 要求我们在构建基于网页的仪表板之前注册并使用有效的电子邮件地址和密码创建一个账户。我们不需要输入任何信用卡或支付信息。如果您已经在
    freeboard.io 上有账户，您可以跳过下一步。
- en: Go to [http://freeboard.io](http://freeboard.io) in your Web browser and click
    **Start Now**. You can achieve the same goal by visiting [https://freeboard.io/signup](https://freeboard.io/signup).
    Enter your desired user name in **Pick a Username**, your e-mail in **Enter Your
    Email** and the desired password in **Create a Password**. Once you have filled
    up all the fields, click **Create My Account**.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中访问[http://freeboard.io](http://freeboard.io)并点击**立即开始**。您也可以通过访问[https://freeboard.io/signup](https://freeboard.io/signup)达到相同的目的。在**选择用户名**中输入您想要的用户名，在**输入您的电子邮件**中输入您的电子邮件，在**创建密码**中输入您想要的密码。一旦填写完所有字段，点击**创建我的账户**。
- en: Once you created your account, you can go to [http://freeboard.io](http://freeboard.io)
    in your Web browser and click **Login**. You can achieve the same goal by visiting
    [https://freeboard.io/login](https://freeboard.io/login). Then, enter your user
    name or e-mail and password, and click **Sign In**. Freeboard will display your
    freeboards, also known as dashboards.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 创建账户后，您可以在网络浏览器中访问[http://freeboard.io](http://freeboard.io)并点击**登录**。您也可以通过访问[https://freeboard.io/login](https://freeboard.io/login)达到相同的目的。然后，输入您的用户名或电子邮件和密码，并点击**登录**。Freeboard将显示您的免费板，也称为仪表板。
- en: Enter `Ambient temperature and humidity` in the **enter a name** textbox at
    the left hand side of the **Create New** button and then click on this button.
    Freeboard.io will display an empty dashboard with many buttons that allow us to
    add panes and data sources, among other things. The following picture shows a
    screenshot with the empty dashboard.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在**创建新**按钮左侧的**输入名称**文本框中输入`环境温度和湿度`，然后点击此按钮。Freeboard.io将显示一个空白的仪表板，其中包含许多按钮，允许我们添加面板和数据源等。以下图片显示了空白的仪表板截图。
- en: '![Building a web-based dashboard with Freeboard](img/B05042_09_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![使用Freeboard构建基于Web的仪表板](img/B05042_09_02.jpg)'
- en: Click on **Add** below **Datasources** and the Website will open the **Datasource**
    dialog box. Select **Dweet.io** in the **Type** dropdown and the dialog box will
    display the fields required to define a `dweet.io` datasource.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**数据源**下方的**添加**，网站将打开**数据源**对话框。在**类型**下拉菜单中选择**Dweet.io**，对话框将显示定义`dweet.io`数据源所需的字段。
- en: Enter `Ambient temperature and humidity` in **Name** and the thing name we have
    been using for `dweet.io` in **Thing Name**. Remember that we were using `iot_python_chapter_09_01_gaston_hillar`
    to name our IoT device but you had replaced it with a different name. If the name
    you enter doesn't match the name you used when working with `dweet.io`, the datasource
    won't have the appropriate data. The following picture shows a screenshot with
    the configuration for the `dweet.io` datasource that uses the sample thing name.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在**名称**中输入`环境温度和湿度`，在**设备名称**中输入我们之前用于`dweet.io`的设备名称。请记住，我们曾使用`iot_python_chapter_09_01_gaston_hillar`来命名我们的物联网设备，但您已将其替换为不同的名称。如果您输入的名称与您在处理`dweet.io`时使用的名称不匹配，数据源将不会显示适当的数据。以下图片显示了使用示例设备名称的`dweet.io`数据源配置的截图。
- en: '![Building a web-based dashboard with Freeboard](img/B05042_09_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![使用Freeboard构建基于Web的仪表板](img/B05042_09_03.jpg)'
- en: Click **Save** and the datasource will appear listed below **Datasources**.
    As the board is running the Python code that is dweeting, the time shown below
    **Last Updated** will change every 10 seconds. If the time doesn't change every
    10 seconds, it means that the datasource has a wrong configuration or that the
    board is not running the Python code that is dweeting anymore.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**保存**，数据源将出现在**数据源**下方的列表中。由于仪表板正在运行dweeting的Python代码，因此**最后更新**下显示的时间将每10秒更改一次。如果时间每10秒不更改，则意味着数据源配置错误或仪表板不再运行dweeting的Python代码。
- en: Click on **Add pane** to add a new empty pane to the dashboard. Then, click
    on the plus sign (**+**) at the upper right corner of the new empty pane and Freeboard
    will display the **Widget** dialog box.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**添加面板**以向仪表板添加一个新的空白面板。然后，点击新空白面板右上角的加号（**+**），Freeboard将显示**小部件**对话框。
- en: Select **Gauge** in the **Type** dropdown and the dialog box will display the
    fields required to add a gauge widget to the pane within the dashboard. Enter
    `Temperature in degrees Fahrenheit` in **Title**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在**类型**下拉菜单中选择**量规**，对话框将显示添加量规小部件到仪表板面板中所需的字段。在**标题**中输入`华氏温度`。
- en: 'Click **+ Datasource** at the right-hand side of the **Value** textbox, select
    **Ambient Temperature and humidity** and then select **temperature_fahrenheit**.
    After you make the selections the following text will appear in the **Value**
    textbox: `datasources ["Ambient temperature and humidity"] ["temperature_fahrenheit"]`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在**值**文本框的右侧点击**+ 数据源**，选择**环境温度和湿度**，然后选择**temperature_fahrenheit**。在您做出选择后，以下文本将出现在**值**文本框中：`datasources
    ["Ambient temperature and humidity"] ["temperature_fahrenheit"]`。
- en: Enter `ºF` in **Units**, `-30` in **Minimum** and `130` in **Maximum**. Then,
    click **Save** and Freeboard will close the dialog box and add the new gauge to
    the previously created pane within the dashboard. The gauge will display the latest
    value that the code running in the board dweeted for the ambient temperature in
    degrees Fahrenheit, that is, the value for the `temperature_fahrenheit` key in
    the JSON data that the code has published for the last time to `dweet.io`. The
    following picture shows the **Ambient temperature and humidity** datasource displaying
    the last updated time and the gauge showing the latest value for the ambient temperature
    measured in degrees Fahrenheit.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在**单位**中输入`ºF`，在**最小值**中输入`-30`，在**最大值**中输入`130`。然后，点击**保存**，Freeboard将关闭对话框并将新的仪表添加到之前创建的仪表板窗格中。仪表将显示代码在板上最后一次dweet的环境温度的最新值，即代码最后发布到`dweet.io`的JSON数据中`temperature_fahrenheit`键的值。以下图片显示了**环境温度和湿度**数据源显示的最后更新时间和显示华氏度测量的环境温度的最新值的仪表。
- en: '![Building a web-based dashboard with Freeboard](img/B05042_09_04.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![使用Freeboard构建基于Web的仪表板](img/B05042_09_04.jpg)'
- en: Click on **Add pane** to add another new empty pane to the dashboard. Then,
    click on the plus sign (**+**) at the upper right corner of the new empty pane
    and Freeboard will display the **Widget** dialog box.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**添加窗格**以向仪表板添加另一个新的空窗格。然后，点击新空窗格右上角的加号（**+**），Freeboard将显示**小部件**对话框。
- en: Select **Gauge** in the **Type** dropdown and the dialog box will display the
    fields required to add a gauge widget to the pane within the dashboard. Enter
    `Humidity level in percentage` in **Title**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在**类型**下拉菜单中选择**仪表**，对话框将显示添加仪表小部件到仪表板窗格所需的字段。在**标题**中输入`Humidity level in percentage`。
- en: 'Click **+ Datasource** at the right-hand side of the **Value** textbox, select
    **Ambient Temperature and humidity** and then select **humidity_level_percentage**.
    After you make the selections the following text will appear in the **Value**
    textbox: `datasources ["Ambient temperature and humidity"] ["humidity_level_percentage"]`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在**值**文本框的右侧点击**+ 数据源**，选择**环境温度和湿度**，然后选择**humidity_level_percentage**。在您做出选择后，以下文本将出现在**值**文本框中：`datasources
    ["Ambient temperature and humidity"] ["humidity_level_percentage"]`。
- en: Enter `%` in **Units**, `0` in **Minimum** and `100` in **Maximum**. Then, click
    **Save** and Freeboard will close the dialog box and add the new gauge to the
    previously created pane within the dashboard. The gauge will display the latest
    value that the code running in the board dweeted for the ambient humidity level
    in percentage, that is, the value for the `humidity_level_percentage` key in the
    JSON data that the code has published for the last time to `dweet.io`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在**单位**中输入`%`，在**最小值**中输入`0`，在**最大值**中输入`100`。然后，点击**保存**，Freeboard将关闭对话框并将新的仪表添加到之前创建的仪表板窗格中。仪表将显示代码在板上最后一次dweet的周围湿度水平的最新值，即代码最后发布到`dweet.io`的JSON数据中`humidity_level_percentage`键的值。以下图片显示了**环境温度和湿度**数据源显示的最后更新时间和显示华氏度测量的环境温度的最新值的仪表。
- en: Now, click on the plus sign (**+**) at the upper right corner of the pane that
    is displaying the temperature in degrees Fahrenheit and Freeboard will display
    the **Widget** dialog box.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击显示华氏度和Freeboard的窗格右上角的加号（**+**），Freeboard将显示**小部件**对话框。
- en: Select **Gauge** in the **Type** dropdown and the dialog box will display the
    fields required to add a gauge widget to the pane within the dashboard. Enter
    `Temperature in degrees Celsius` in **Title**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在**类型**下拉菜单中选择**仪表**，对话框将显示添加仪表小部件到仪表板窗格所需的字段。在**标题**中输入`Temperature in degrees
    Celsius`。
- en: 'Click **+ Datasource** at the right-hand side of the **Value** textbox, select
    **Ambient Temperature and humidity** and then select **temperature_celsius**.
    After you make the selections the following text will appear in the **Value**
    textbox: `datasources ["Ambient temperature and humidity"] ["temperature_celsius"]`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**值**文本框右侧的**+ Datasource**，选择**环境温度和湿度**，然后选择**temperature_celsius**。在做出选择后，以下文本将出现在**值**文本框中：`datasources
    ["Ambient temperature and humidity"] ["temperature_celsius"]`。
- en: Enter `ºC` in **Units**, `-40` in **Minimum** and `55` in **Maximum**. Then,
    click **Save** and Freeboard will close the dialog box and add the new gauge to
    the previously existing pane within the dashboard. This way, the pane will display
    two gauges, with the temperature expressed in two different units. The new gauge
    will display the latest value that the code running in the board dweeted for the
    ambient temperature in degrees Celsius, that is, the value for the `temperature_celsius`
    key in the JSON data that the code has published for the last time to `dweet.io`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在**单位**中输入`ºC`，在**最小值**中输入`-40`，在**最大值**中输入`55`。然后，点击**保存**，Freeboard 将关闭对话框并将新的仪表添加到仪表板中之前存在的窗格内。这样，窗格将显示两个仪表，温度以两种不同的单位表示。新的仪表将显示代码在板上
    dweeted 的最新值，即环境温度的值，即代码在最后一次发布到 `dweet.io` 的 JSON 数据中的 `temperature_celsius`
    键的值。
- en: Now, click on the configuration icon at the right-hand side of the **+** button
    of the pane that displays both temperatures. Freeboard will display the **Pane**
    dialog box. Enter `Temperature` in **Title** and click **Save**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击显示两个温度的窗格右侧的**+**按钮旁边的配置图标。Freeboard 将显示**窗格**对话框。在**标题**中输入`Temperature`，然后点击**保存**。
- en: Click on the configuration icon at the right-hand side of the **+** button of
    the pane that displays the humidity level. Freeboard will display the **Pane**
    dialog box. Enter `Humidity` in **Title** and click **Save**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 点击显示湿度水平的窗格右侧的**+**按钮旁边的配置图标。Freeboard 将显示**窗格**对话框。在**标题**中输入`Humidity`，然后点击**保存**。
- en: Drag and drop the panes to locate the **Humidity** pane at the left-hand side
    of the **Temperature** pane. The following picture shows the dashboard we built,
    with two panes and three gauges that refresh the data automatically when the code
    running on the Intel Galileo Gen 2 board dweets new data.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将窗格拖放到位置，将**湿度**窗格放置在**温度**窗格的左侧。以下图片显示了我们所构建的仪表板，其中包含两个窗格和三个仪表，当在英特尔 Galileo
    Gen 2 板上运行的代码 dweets 新数据时，这些仪表会自动刷新数据。
- en: '![Building a web-based dashboard with Freeboard](img/B05042_09_05.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Freeboard 构建基于网页的仪表板](img/B05042_09_05.jpg)'
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We can access the recently built dashboard in any device by entering the URL
    that our Web browser is displaying at the time we are working with the dashboard.
    The URL is composed of the `https://freeboard.io/board/` prefix followed by letters
    and numbers. For example, in case the URL is `https://freeboard.io/board/EXAMPLE`,
    we just need to enter it in any Web browser running on any device or computer
    connected to the Internet and we can watch the gauges and they will be refreshed
    as new data is being publishes from our Intel Galileo Gen 2 board to `dweet.io`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过输入我们在与仪表板一起工作时网页浏览器显示的 URL 来在任何设备上访问最近构建的仪表板。URL 由 `https://freeboard.io/board/`
    前缀后跟字母和数字组成。例如，如果 URL 是 `https://freeboard.io/board/EXAMPLE`，我们只需将其输入到任何设备或计算机上运行的任何网页浏览器中，我们就可以查看仪表，并且当从我们的英特尔
    Galileo Gen 2 板向 `dweet.io` 发布新数据时，它们会刷新。
- en: The combination of `dweet.io` as our datasource and freeboard.io as our web-based
    dashboard made it easy for us to monitor the data retrieved from the sensor wired
    to our Intel Galileo Gen 2 board with any device that provides a Web browser.
    The combination of these two cloud-based services for IoT is just one example
    of how we can easily combine different services. There is an increase in the number
    of IoT cloud-based services, which can be used in our solutions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `dweet.io` 作为我们的数据源和 freeboard.io 作为我们的基于网页的仪表板结合起来，使我们能够轻松地使用任何提供网页浏览器的设备来监控连接到我们的英特尔
    Galileo Gen 2 板的传感器获取的数据。这两个基于云的物联网服务的结合只是我们如何轻松结合不同服务的一个例子。物联网云服务的数量正在增加，这些服务可以用于我们的解决方案中。
- en: Sending and receiving data in real-time through Internet with PubNub
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 PubNub 在互联网上实时发送和接收数据
- en: In [Chapter 4](ch04.html "Chapter 4. Working with a RESTful API and Pulse Width
    Modulation"), *Working with a RESTful API and Pulse Width Modulation*, we developed
    and consumed a RETful API that allows us to control electronic components connected
    to our Intel Galileo Gen 2 board through HTTP requests. Now, we want to send and
    receive data in real-time through the Internet and a RESTful API is not the most
    appropriate option to do this. Instead, we will work with a publish/subscribe
    model based on a protocol that is lighter than the HTTP protocol. Specifically,
    we will use a service based on the **MQTT** (short for **MQ Telemetry Transport**)
    protocol.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。使用RESTful API和脉冲宽度调制")中，*使用RESTful API和脉冲宽度调制*，我们开发和使用了RETful
    API，它允许我们通过HTTP请求控制连接到我们的Intel Galileo Gen 2板上的电子组件。现在，我们希望通过互联网实时发送和接收数据，而RESTful
    API并不是做这件事的最合适选项。相反，我们将使用基于比HTTP协议更轻量级的协议的发布/订阅模型。具体来说，我们将使用基于**MQTT**（即**MQ Telemetry
    Transport**）协议的服务。
- en: 'The MQTT protocol is a **machine-to-machine** (short for **M2M**) and Internet
    of Things connectivity protocol. MQTT is a lightweight messaging protocol that
    runs on top of the TCP/IP protocol and works with a publish-subscribe mechanism.
    It is possible for any device to subscribe to a specific channel (also known as
    topic) and it will receive all the messages published to this channel. In addition,
    the device can publish message to this or other channel. The protocol is becoming
    very popular in IoT and M2M projects. You can read more about the MQTT protocol
    in the following Webpage: [http://mqtt.org](http://mqtt.org).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT协议是一种**机器到机器**（简称**M2M**）和物联网连接协议。MQTT是一个轻量级消息协议，它运行在TCP/IP协议之上，并使用发布/订阅机制。任何设备都可以订阅特定的频道（也称为主题），并会接收到发布到该频道的所有消息。此外，设备可以向该频道或其他频道发布消息。该协议在物联网和M2M项目中变得越来越受欢迎。你可以在以下网页上了解更多关于MQTT协议的信息：[http://mqtt.org](http://mqtt.org)。
- en: 'PubNub provides many cloud-based services and one of them allows us to easily
    stream data and signal any device in real-time, working with the MQTT protocol
    under the hoods. We will take advantage of this PubNub service to send and receive
    data in real-time through Internet and make it easy to control our Intel Galileo
    Gen 2 board through the Internet. As PubNub provides a Python API with high quality
    documentation and examples, it is extremely easy to use the service in Python.
    PubNub defines itself as the global data stream network for IoT, Mobile and Web
    applications. You can read more about PubNub in its Webpage: [http://www.pubnub.com](http://www.pubnub.com).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: PubNub提供了许多基于云的服务，其中之一允许我们轻松地实时流数据和向任何设备发送信号，在底层使用MQTT协议。我们将利用这个PubNub服务通过互联网实时发送和接收数据，并使通过互联网控制我们的Intel
    Galileo Gen 2板变得容易。由于PubNub提供了一个具有高质量文档和示例的Python API，因此使用Python来使用该服务非常简单。PubNub将自己定义为物联网、移动和Web应用的全球数据流网络。你可以在其网页上了解更多关于PubNub的信息：[http://www.pubnub.com](http://www.pubnub.com)。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In our example, we will take advantage of the free services offered by PubNub
    and we won't use some advanced features and additional services that might empower
    our IoT project connectivity requirements but also require a paid subscription.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将利用PubNub提供的免费服务，而不会使用一些可能增强我们的物联网项目连接需求但需要付费订阅的高级功能和附加服务。
- en: PubNub requires us to sign up and create an account with a valid e-mail and
    a password before we can create an application within PubNub that allows us to
    start using their free services. We aren't required to enter any credit card or
    payment information. If you already have an account at PubNub, you can skip the
    next step.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: PubNub要求我们在创建应用程序之前先注册并使用有效的电子邮件和密码创建一个账户，该应用程序允许我们开始使用他们的免费服务。我们不需要输入任何信用卡或支付信息。如果你已经在PubNub有账户，你可以跳过下一步。
- en: 'Once you created your account PubNub will redirect you to the **Admin Portal**
    that lists your PubNub applications. It is necessary to generate your PubNub publish
    and subscribe keys in order to send and receive messages in the network. A new
    pane will represent the application in the Admin portal. The following screenshot
    shows the Temperature Control application pane in the PubNub Admin portal:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了账户，PubNub将把你重定向到**管理门户**，该门户列出了你的PubNub应用程序。为了在网络上发送和接收消息，你需要生成你的PubNub发布和订阅密钥。管理门户中的一个新面板将代表应用程序。以下截图显示了PubNub管理门户中的温度控制应用程序面板：
- en: '![Sending and receiving data in real-time through Internet with PubNub](img/B05042_09_06.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![通过 PubNub 在互联网上实时发送和接收数据](img/B05042_09_06.jpg)'
- en: 'Click on the **Temperature Control** pane and PubNub will display the **Demo
    Keyset** pane that has been automatically generated for the application. Click
    on this pane and PubNub will display the publish, subscribe, and secret keys.
    We must copy and paste each of these keys to use them in our code that will publish
    messages and subscribe to them. The following screenshot shows the prefixes for
    the keys and the remaining characters have been erased in the image:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 单击**温度控制**面板，PubNub 将显示为应用程序自动生成的**演示密钥集**面板。单击此面板，PubNub 将显示发布、订阅和密钥。我们必须复制并粘贴这些密钥中的每一个，以便在我们的代码中使用它们来发布消息并订阅它们。以下截图显示了密钥的前缀和图像中已擦除的剩余字符：
- en: '![Sending and receiving data in real-time through Internet with PubNub](img/B05042_09_07.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![通过 PubNub 在互联网上实时发送和接收数据](img/B05042_09_07.jpg)'
- en: In order to copy the secret key, you must click on the eye icon at the right-hand
    side of the key and PubNub will make all the characters visible.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了复制密钥，您必须单击密钥右侧的眼睛图标，PubNub 将使所有字符可见。
- en: In [Chapter 2](ch02.html "Chapter 2. Working with Python on Intel Galileo Gen
    2"), *Working with Python on Intel Galileo Gen 2*, we installed `pip` installer
    to easily install additional Python 2.7.3 packages in the Yocto Linux that we
    are running on the board. Now, we will use `pip` installer to install PubNub Python
    SDK 3.7.6\. We just need to run the following command in the SSH terminal to install
    the package. Notice that it can take a few minutes to complete the installation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 2 章](ch02.html "第 2 章。在英特尔 Galileo Gen 2 上使用 Python")，*在英特尔 Galileo Gen
    2 上使用 Python*中，我们安装了`pip`安装程序，以便在板子上运行的 Yocto Linux 中轻松安装额外的 Python 2.7.3 软件包。现在，我们将使用`pip`安装程序安装
    PubNub Python SDK 3.7.6。我们只需在 SSH 终端中运行以下命令即可安装该软件包。请注意，安装可能需要几分钟时间。
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The last lines for the output will indicate that the `pubnub` package has been
    successfully installed. Don't worry about the error messages related to building
    wheel and the insecure platform warning.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示`pubnub`软件包已成功安装。不要担心与构建 wheel 相关的错误消息和不安全平台警告。
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will take the code we wrote in the previous chapter when we read temperature
    and humidity values from the sensor, we printed the values in an OLED matrix and
    rotated a servo''s shaft to display the measured temperature expressed in degrees
    Fahrenheit with the shaft. The code file for the sample was `iot_python_chapter_08_03.py`.
    We will use this code as a baseline to add new features that will allow us to
    perform the following actions with PubNub messages sent to a specific channel
    from any device that has a Web browser:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在上一章中编写的代码，当时我们从传感器读取温度和湿度值，我们在 OLED 矩阵中打印了这些值，并通过旋转伺服电机的轴来显示以华氏度表示的测量温度。示例代码文件为`iot_python_chapter_08_03.py`。我们将以此代码为基础，添加新功能，使我们能够执行以下操作，使用
    PubNub 消息发送到特定通道的任何具有网络浏览器的设备：
- en: Rotate the servo's shaft to display a temperature value in degrees Fahrenheit
    received as part of the message.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过旋转伺服电机的轴来显示作为消息一部分接收到的华氏温度值。
- en: Display a line of text received as part of the message at the bottom of the
    OLED matrix.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OLED 矩阵的底部显示作为消息一部分接收到的文本行。
- en: We will use the recently installed `pubnub` module to subscribe to a specific
    channel and run code when we receive messages in the channel. We will create a
    `MessageChannel` class to represent the communications channel, configure the
    PubNub subscription and declare the code for the callbacks that are going to be
    executed when certain events are fired. The code file for the sample is `iot_python_chapter_09_02.py`.
    Remember that we use the code file `iot_python_chapter_08_03.py` as a baseline,
    and therefore, we will add the class to the existing code in this file and we
    will create a new Python file. Don't forget to replace the strings assigned to
    the `publish_key` and `subscribe_key` local variables in the `__init__` method
    with the values you have retrieved from the previously explained PubNub key generation
    process.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用最近安装的 `pubnub` 模块来订阅特定频道，并在接收到该频道上的消息时运行代码。我们将创建一个 `MessageChannel` 类来表示通信通道，配置
    PubNub 订阅并声明当某些事件被触发时要执行的回调代码。示例代码文件为 `iot_python_chapter_09_02.py`。请记住，我们使用代码文件
    `iot_python_chapter_08_03.py` 作为基线，因此，我们将把类添加到现有代码文件中，并创建一个新的 Python 文件。不要忘记将
    `__init__` 方法中分配给 `publish_key` 和 `subscribe_key` 局部变量的字符串替换为从之前解释的 PubNub 密钥生成过程中检索到的值。
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `MessageChannel` class declares the `command_key` class attribute that defines
    the key string that defines what the code will understand as the command. Whenever
    we receive a message that includes the specified key string, we know that the
    value associated to this key in the dictionary will indicate the command that
    the message wants the code running in the board to be processed. Each command
    requires additional key-value pairs that provide the necessary information to
    execute the command.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageChannel` 类声明了 `command_key` 类属性，它定义了代码将理解为何种命令的关键字符串。每当收到包含指定关键字符串的消息时，我们知道与该键关联的字典中的值将指示消息希望代码在板上处理的命令。每个命令都需要额外的键值对，以提供执行命令所需的信息。'
- en: We have to specify the PubNub channel name, the `TemperatureServo` instance
    the `Oled` instance in the `channel`, `temperature_servo`, and `oled` required
    arguments. The constructor, that is, the `__init__` method, saves the received
    arguments in three attributes with the same names. The `channel` argument specifies
    the PubNub channel to which we are going to subscribe to listen to the messages
    that other devices send to this channel. We will also publish messages to this
    channel, and therefore, we will be both a subscriber and a publisher for this
    channel.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须指定 PubNub 频道名称，`channel` 中的 `TemperatureServo` 实例，`Oled` 实例所需的 `temperature_servo`
    和 `oled` 参数。构造函数，即 `__init__` 方法，将接收到的参数保存在具有相同名称的三个属性中。`channel` 参数指定了我们将订阅以监听发送到该频道的消息的
    PubNub 频道。我们还将向该频道发布消息，因此，我们将成为该频道的订阅者和发布者。
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In this case, we will only subscribe to one channel. However, it is very important
    to know that we are not limited to subscribe to a single channel, we might subscribe
    to many channels.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只会订阅一个频道。然而，非常重要的一点是，我们并不仅限于订阅单个频道，我们可能订阅多个频道。
- en: 'Then, the constructor declares two local variables: `publish_key` and `subscribe_key`.
    These local variables save the publish and subscribe keys that we had generated
    with the PubNub Admin portal. Then, the code creates a new `Pubnub` instance with
    `publish_key` and `subscribe_key` as the arguments, and saves the reference for
    the new instance in the `pubnub` attribute. Finally, the code calls the `subscribe`
    method for the new instance to subscribe to data on the channel saved in the `channel`
    attribute. Under the hoods, the `subscribe` method makes the client create an
    open TCP socket to the PubNub network that includes an MQTT broker and starts
    listening to messages on the specified channel. The call to this method specifies
    many methods declared in the `MessageChannel` class for the following named arguments:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，构造函数声明了两个局部变量：`publish_key` 和 `subscribe_key`。这些局部变量保存了我们使用 PubNub 管理门户生成的发布和订阅密钥。然后，代码使用
    `publish_key` 和 `subscribe_key` 作为参数创建一个新的 `Pubnub` 实例，并将新实例的引用保存在 `pubnub` 属性中。最后，代码调用新实例的
    `subscribe` 方法来订阅保存在 `channel` 属性中的频道上的数据。在底层，`subscribe` 方法使客户端创建一个到包含 MQTT 代理的
    PubNub 网络的开放 TCP 套接字，并开始监听指定频道上的消息。对这个方法的调用指定了在 `MessageChannel` 类中声明的许多方法，以下为命名参数：
- en: '`callback`: Specifies the function that will be called when there is a new
    message received from the channel'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback`：指定在从通道接收到新消息时将被调用的函数'
- en: '`error`: Specifies the function that will be called on an error event'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`：指定在错误事件上将被调用的函数'
- en: '`connect`: Specifies the function that will be called when a successful connection
    is established with the PubNub cloud'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect`：指定当与PubNub云成功建立连接时将被调用的函数'
- en: '`reconnect`: Specifies the function that will be called when a successful re-connection
    is completed with the PubNub cloud'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reconnect`：指定当与PubNub云成功重新连接完成后将被调用的函数'
- en: '`disconnect`: Specifies the function that will be called when the client disconnects
    from the PubNub cloud'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disconnect`：指定当客户端从PubNub云断开连接时将被调用的函数'
- en: 'This way, whenever one of the previously enumerated events occur, the specified
    method will be executed. The `callback` method receives two arguments: `message`
    and `channel`. First, the method checks whether the received `channel` matches
    the value in the `channel` attribute. In this case, whenever the `callback` method
    is executed, the value in the `channel` argument will always match the value in
    the `channel` attribute because we just subscribed to one channel. However, in
    case we subscribe to more than one channel, is is always necessary to check which
    is the channel in which the message was sent and in which we are receiving the
    message.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每当之前列举的事件之一发生时，指定的方法将被执行。`callback`方法接收两个参数：`message`和`channel`。首先，该方法检查接收到的`channel`是否与`channel`属性中的值匹配。在这种情况下，每当`callback`方法执行时，`channel`参数中的值将始终与`channel`属性中的值匹配，因为我们刚刚订阅了一个通道。然而，如果我们订阅了多个通道，则始终有必要检查消息是在哪个通道中发送的，以及我们在哪个通道接收消息。
- en: 'Then, the code checks whether the `command_key` class attribute is included
    in the `message` dictionary. If the expression evaluates to `True`, it means that
    the message includes a command that we have to process. However, before we can
    process the command, we have to check which is the command, and therefore, it
    is necessary to retrieve the value associated with the key equivalent to the `command_key`
    class attribute. The code is capable of running code when the value is any of
    the following two commands:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码检查`command_key`类属性是否包含在`message`字典中。如果表达式评估为`True`，则表示消息包含我们必须处理的命令。然而，在我们能够处理该命令之前，我们必须检查是哪个命令，因此，有必要检索与`command_key`类属性等效的键的值。当值是以下两个命令中的任何一个时，代码能够执行代码：
- en: '`print_temperature_fahrenheit`: The command must specify the temperature value
    expressed in degrees Fahrenheit in the value of the `temperature_fahrenheit` key.
    The code calls the `self.temperature_servo.print_temperature` method with the
    temperature value retrieved from the dictionary as an argument. This way, the
    code moves the servo''s shaft based on the specified temperature value in the
    message that includes the command.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_temperature_fahrenheit`：该命令必须在`temperature_fahrenheit`键的值中指定以华氏度表示的温度值。代码使用从字典中检索到的温度值作为参数调用`self.temperature_servo.print_temperature`方法。这样，代码就根据消息中包含该命令指定的温度值移动伺服电机的轴。'
- en: '`print_information_message`: The command must specify the line of text that
    has to be displayed at the bottom of the OLED matrix in the value of the `print_information_message`
    key. The code calls the `self.oled.print_line` method with `11` and the text value
    retrieved from the dictionary as arguments. This way, the code displays the text
    received in the message that includes the command at the bottom of the OLED matrix.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_information_message`：该命令必须在`print_information_message`键的值中指定要在OLED矩阵底部显示的文本行。代码使用`self.oled.print_line`方法，并带有`11`和从字典中检索到的文本值作为参数调用。这样，代码就在OLED矩阵的底部显示了包含该命令的消息中接收到的文本。'
- en: No matter whether the message included a valid command or not, the method prints
    the raw message that it received in the console output.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 无论消息是否包含有效的命令，该方法都会在控制台输出中打印它接收到的原始消息。
- en: 'The `connect` method prints a message indicating that a connection has been
    established with the channel. Then, the method prints the results of calling the
    `self.pubnub.publish` method that publishes a message in the channel name saved
    in `self.channel` with the following message: `"Listening to messages in the Intel
    Galileo Gen 2 board"`. In this case, the call to this method runs with a synchronous
    execution. We will work with asynchronous execution for this method in our next
    example.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect` 方法打印一条消息，表明已与通道建立了连接。然后，该方法打印调用 `self.pubnub.publish` 方法的结果，该方法在
    `self.channel` 保存的通道名称中发布消息：`"Listening to messages in the Intel Galileo Gen 2
    board"`。在这种情况下，对该方法的调用是同步执行的。我们将在下一个示例中为此方法使用异步执行。'
- en: At this time, we are already subscribed to this channel, and therefore, we will
    receive the previously published message and the callback method will be executed
    with this message as an argument. However, as the message doesn't include the
    key that identifies a command, the code in the callback method will just display
    the received message and it won't process any of the previously analyzed commands.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，我们已订阅此通道，因此，我们将接收到之前发布的消息，并且回调方法将使用此消息作为参数执行。然而，由于消息不包含标识命令的密钥，回调方法中的代码将仅显示接收到的消息，而不会处理之前分析过的任何命令。
- en: The other methods declared in the `MessageChannel` class just display information
    to the console output about the event that has occurred.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MessageChannel` 类中声明的其他方法只是将事件发生的信息显示到控制台输出。
- en: Now, we will use the previously coded `MessageChannel` class to create a new
    version of the `__main__` method that uses the PubNub cloud to receive and process
    commands. The new version doesn't rotate the servo's shaft when the ambient temperature
    changes, instead, it will do this when it receives the appropriate command from
    any device connected to PubNub cloud. The following lines show the new version
    of the `__main__` method. The code file for the sample is `iot_python_chapter_09_02.py`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用之前编写的 `MessageChannel` 类来创建一个新版本的 `__main__` 方法，该方法使用 PubNub 云接收和处理命令。新版本在环境温度变化时不会旋转伺服电机的轴，相反，它将在接收到来自连接到
    PubNub 云的任何设备的适当命令时执行此操作。以下行显示了 `__main__` 方法的新版本。示例的代码文件为 `iot_python_chapter_09_02.py`。
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The highlighted line creates an instance of the previously coded `MessageChannel`
    class with `"temperature"`, `temperature_servo`, and `oled` as the arguments.
    The constructor will subscribe to the `temperature` channel in the PubNub cloud,
    and therefore, we must send the messages to this channel in order to send the
    commands that the code will process with an asynchronous execution. The loop will
    read the values from the sensor and print the values to the console as in the
    previous version of the code, and therefore, we will have code running in the
    loop and we will also have code listening to the messages in the `temperature`
    channel in the PubNub cloud. We will start the example later because we want to
    subscribe to the channel in the PubNub debug console before we run the code in
    the board.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行创建了一个之前编写的 `MessageChannel` 类的实例，参数为 `"temperature"`、`temperature_servo`
    和 `oled`。构造函数将订阅 PubNub 云中的 `temperature` 通道，因此，我们必须向此通道发送消息，以便发送代码将异步执行的命令。循环将读取传感器的值并将值打印到控制台，就像代码的先前版本一样，因此，我们将在循环中运行代码，同时我们也将有代码在
    PubNub 云的 `temperature` 通道中监听消息。我们将在稍后开始示例，因为我们想在板上运行代码之前，在 PubNub 调试控制台中订阅通道。
- en: Publishing messages with commands through the PubNub cloud
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 PubNub 云发布带有命令的消息
- en: Now, we will take advantage of the PubNub console to send messages with commands
    to the `temperature` channel and make the Python code running on the board process
    these commands. In case you have logged out of PubNub, login again and click on
    the **Temperature Control** pane in the **Admin Portal**. PubNub will display
    the **Demo Keyset** pane.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将利用 PubNub 控制台向 `temperature` 通道发送带有命令的消息，并使板上的 Python 代码处理这些命令。如果你已经从
    PubNub 登出，请重新登录并点击 **Admin Portal** 中的 **Temperature Control** 面板。PubNub 将显示 **Demo
    Keyset** 面板。
- en: Click on the **Demo Keyset** pane and PubNub will display the publish, subscribe,
    and secret keys. This way, we select the keyset that we want to use for our PubNub
    application.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **Demo Keyset** 面板，PubNub 将显示发布、订阅和密钥。这样，我们选择我们想要用于我们的 PubNub 应用的密钥集。
- en: Click on **Debug Console** on the sidebar located the left-hand side of the
    screen. PubNub will create a client for a default channel and subscribe to this
    channel using the secret keys we have selected in the previous step. We want to
    subscribe to the `temperature` channel, and therefore, enter `temperature` in
    the **Default Channel** textbox within a pane that includes the **Add client**
    button at the bottom. Then, click on **Add client** and PubNub will add a new
    pane with a random client name as a title and the channel name, `temperature`,
    in the second line. PubNub makes the client subscribe to this channel and we will
    be able to receive messages published to this channel and send messages to this
    channel. The following picture shows the pane for the generated client named **Client-ot7pi**,
    subscribed to the `temperature` channel. Notice that the client name will be different
    when you follow the explained steps.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 点击屏幕左侧侧边栏上的 **调试控制台**。PubNub 将为默认通道创建一个客户端，并使用我们在上一步中选择的密钥订阅此通道。我们想订阅 `temperature`
    通道，因此，在包含 **添加客户端** 按钮的面板中的 **默认通道** 文本框中输入 `temperature`。然后，点击 **添加客户端**，PubNub
    将添加一个带有随机客户端名称的新的面板，第二行是通道名称 `temperature`。PubNub 使客户端订阅此通道，我们就能接收发布到此通道的消息，并向此通道发送消息。以下图片显示了名为
    **Client-ot7pi** 的生成客户端的面板，已订阅 `temperature` 通道。注意，当您按照解释的步骤操作时，客户端名称将不同。
- en: '![Publishing messages with commands through the PubNub cloud](img/B05042_09_08.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![通过 PubNub 云使用命令发布消息](img/B05042_09_08.jpg)'
- en: The client pane displays the output generated when PubNub subscribed the client
    to the channel. PubNub returns a formatted response for each command. In this
    case, it indicates that the status is equal to `Subscribed` and the channel name
    is `temperature`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端面板显示了 PubNub 订阅客户端到通道时生成的输出。PubNub 为每个命令返回一个格式化的响应。在这种情况下，它表示状态等于 `Subscribed`，通道名称为
    `temperature`。
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, it is time to start running the example in the Intel Galileo Gen 2 board.
    The following line will start the example in the SSH console:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候在英特尔 Galileo Gen 2 板上运行示例了。以下行将在 SSH 控制台中启动示例：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After you run the example, go to the Web browser in which you are working with
    the PubNub debug console. You will see the following message listed in the previously
    created client:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例后，转到您正在使用 PubNub 调试控制台的 Web 浏览器。您将看到以下消息在之前创建的客户端中列出：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The Python code running in the board published this message, specifically, the
    `connect` method in the `MessageChannel` class sent this message after the application
    established a connection with the PubNub cloud. The following picture shows the
    message listed in the previously created client. Notice that the icon at the left-hand
    side of the text indicates it is a message. The other message was a debug message
    with the results of subscribing to the channel.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在板上运行的 Python 代码发布了这条消息，具体来说，是 `MessageChannel` 类中的 `connect` 方法在应用程序与 PubNub
    云建立连接后发送了这条消息。下面的图片显示了之前创建的客户端中列出的消息。注意，文本左侧的图标表示这是一条消息。另一条消息是一个调试消息，包含了订阅通道的结果。
- en: '![Publishing messages with commands through the PubNub cloud](img/B05042_09_09.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![通过 PubNub 云使用命令发布消息](img/B05042_09_09.jpg)'
- en: 'At the bottom of the client pane, you will see the following text and the **Send**
    button at the right-hand side:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端面板的底部，您将看到以下文本和位于右侧的 **发送** 按钮：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we will replace the previously shown text with a message. Enter the following
    JSON code and click **Send**:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将用一条消息替换之前显示的文本。输入以下 JSON 代码并点击 **发送**：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The text editor where you enter the message has some issues in certain browsers.
    Thus, it is convenient to use your favorite text editor to enter the JSON code,
    copy it and then past it to replace the text that is included by default in the
    text for the message to be sent.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中输入消息的文本编辑器在某些浏览器中存在一些问题。因此，使用您喜欢的文本编辑器输入 JSON 代码，复制它，然后将其粘贴以替换消息文本中默认包含的文本是方便的。
- en: After you click **Send**, the following lines will appear in the client log.
    The first line is a debug message with the results of publishing the message and
    indicates that the message has been sent. The formatted response includes a number
    (`1` message), the status (`Sent`) and a time token. The second line is the message
    that arrives to the channel because we are subscribed to the `temperature` channel,
    that is, we also receive the message we sent.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**发送**后，客户端日志中会出现以下几行。第一行是一个包含发布消息结果的调试消息，并表明消息已被发送。格式化响应包括一个数字（`1`条消息）、状态（`Sent`）和时间戳。第二行是到达通道的消息，因为我们订阅了`temperature`通道，也就是说，我们也收到了我们发送的消息。
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following picture shows the messages and debug messages log for the PubNub
    client after we clicked the **Send** button:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片展示了点击**发送**按钮后 PubNub 客户端的消息和调试消息日志：
- en: '![Publishing messages with commands through the PubNub cloud](img/B05042_09_10.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![通过 PubNub 云使用命令发布消息](img/B05042_09_10.jpg)'
- en: After you publish the previous message, you will see the following output in
    the SSH console for the Intel Galileo Gen 2 board. You will notice the servo's
    shaft rotates to 50 degrees.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布上一条消息后，你将在 Intel Galileo Gen 2 板的 SSH 控制台中看到以下输出。你会注意到伺服电机的轴旋转到 50 度。
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, enter the following JSON code and click **Send**:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入以下 JSON 代码并点击**发送**：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After you click **Send**, the following lines will appear in the client log.
    The first line is a debug message with the previously explained formatted response
    with the results of publishing the message and indicates that the message has
    been sent. The second line is the message that arrives to the channel because
    we are subscribed to the `temperature` channel, that is, we also receive the message
    we sent.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**发送**后，客户端日志中会出现以下几行。第一行是一个调试消息，包含之前解释过的格式化响应，显示了发布消息的结果，并表明消息已被发送。格式化响应包括一个数字（`1`条消息）、状态（`Sent`）和时间戳。第二行是到达通道的消息，因为我们订阅了`temperature`通道，也就是说，我们也收到了我们发送的消息。
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The following picture shows the messages and debug messages log for the PubNub
    client after we clicked the **Send** button.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片展示了点击**发送**按钮后 PubNub 客户端的消息和调试消息日志。
- en: '![Publishing messages with commands through the PubNub cloud](img/B05042_09_11.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![通过 PubNub 云使用命令发布消息](img/B05042_09_11.jpg)'
- en: 'After you publish the previous message, you will see the following output in
    the SSH console for the Intel Galileo Gen 2 board. You will see the following
    text displayed at the bottom of the OLED matrix: `Client ready`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 发布上一条消息后，你将在 Intel Galileo Gen 2 板的 SSH 控制台中看到以下输出。你将在 OLED 矩阵的底部看到以下文本：`Client
    ready`。
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When we published the two messages with the commands, we have definitely noticed
    a problem. We don't know whether the command was processed or not in the code
    that is running on the IoT device, that is, in the Intel Galileo Gen 2 board.
    We know that the board started listening messages in the temperature channel,
    but we don't receive any kind of response from the IoT device after the command
    has been processed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用命令发布了两条消息时，我们肯定注意到了一个问题。我们不知道在运行在物联网设备上的代码（即 Intel Galileo Gen 2 板）中，命令是否被处理。我们知道板子已经开始监听温度通道的消息，但在命令处理完毕后，我们没有从物联网设备收到任何类型的响应。
- en: Working with bi-directional communications
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理双向通信
- en: We can easily add a few lines of code to publish a message to the same channel
    in which we are receiving messages to indicate that the command has been successfully
    processed. We will use our previous example as a baseline and we will create a
    new version of the `MessageChannel` class. The code file was `iot_python_chapter_09_02.py`.
    Don't forget to replace the strings assigned to the `publish_key` and `subscribe_key`
    local variables in the `__init__` method with the values you have retrieved from
    the previously explained PubNub key generation process. The following lines show
    the new version of the `MessageChannel` class that publishes a message after a
    command has been successfully processed. The code file for the sample is `iot_python_chapter_09_03.py`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地添加几行代码，在接收消息的同一条通道上发布消息，以指示命令已成功处理。我们将使用之前的示例作为基准，并创建`MessageChannel`类的新版本。代码文件是`iot_python_chapter_09_02.py`。别忘了在`__init__`方法中将分配给`publish_key`和`subscribe_key`局部变量的字符串替换为之前解释过的
    PubNub 密钥生成过程中检索到的值。以下几行展示了发布消息后命令已成功处理的`MessageChannel`类的新版本。示例代码文件是`iot_python_chapter_09_03.py`。
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The highlighted lines in the previous code for the new version of the `MessageChannel`
    class show the changes we made in the code. First, the code declares the `successfully_processed_command_key`
    class attribute that defines the key string that defines what the code will use
    as a successfully processed command key in a response message published to the
    channel. Whenever we publish a message that includes the specified key string,
    we know that the value associated to this key in the dictionary will indicate
    the command that the board has successfully processed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码中突出显示的`MessageChannel`类新版本的代码行显示了我们对代码所做的更改。首先，代码声明了`successfully_processed_command_key`类属性，该属性定义了代码将在发布到通道的响应消息中使用的关键字符串，作为成功处理的命令键。每次我们发布包含指定键字符串的消息时，我们知道与该键关联的字典中的值将指示板已成功处理的命令。
- en: 'The code declares the following three new methods:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了以下三个新方法：
- en: '`callback_response_message`: This method will be used as the callback that
    will be executed when a successfully processed command response message is published
    to the channel. The method just prints the formatted response that PubNub returns
    when a message has been successfully published in the channel. In this case, the
    `message` argument doesn''t hold the original message that has been published,
    it holds the formatted response. We use `message` for the argument name to keep
    consistency with the PubNub API.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback_response_message`：此方法将用作在成功处理的命令响应消息发布到通道时执行的回调。该方法仅打印PubNub在通道中成功发布消息时返回的格式化响应。在这种情况下，`message`参数不包含已发布的原始消息，而是包含格式化响应。我们使用`message`作为参数名称以保持与PubNub
    API的一致性。'
- en: '`error_response_message`: This method will be used as the callback that will
    be executed when an error occurs when trying to publish a successfully processed
    command response message to the channel. The method just prints the error message
    that PubNub returns when a message hasn''t been successfully published in the
    channel.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error_response_message`：此方法将用作在尝试将成功处理的命令响应消息发布到通道时发生错误时执行的回调。该方法仅打印PubNub在通道中未成功发布消息时返回的错误消息。'
- en: '`publish_response_message`: This method receives the message with the command
    that was successfully processed in the `message` argument. The code creates a
    `response_message` dictionary with the `successfully_processed_command_key` class
    attribute as the key and the value of the key specified in the `command_key` class
    attribute for the message dictionary as the value. Then, the code calls the `self.pubnub.publish`
    method to publish the `response_message` dictionary to the channel saved in the
    `channel` attribute. The call to this method specifies `self.callback_response_message`
    as the callback to be executed when the message is successfully published and
    `self.error_response_message` as the callback to be executed when an error occurred
    during the publishing process. When we specify a callback, the publish method
    works with an asynchronous execution, and therefore, the execution is non-blocking.
    The publication of the message and the callbacks that are specified will run in
    a different thread.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publish_response_message`：此方法接收包含在`message`参数中成功处理的命令的消息。代码创建一个`response_message`字典，其中`successfully_processed_command_key`类属性作为键，消息字典中`command_key`类属性指定的键的值作为值。然后，代码调用`self.pubnub.publish`方法将`response_message`字典发布到存储在`channel`属性中的通道。对此方法的调用指定`self.callback_response_message`作为在消息成功发布时执行的回调，以及`self.error_response_message`作为在发布过程中发生错误时执行的回调。当我们指定回调时，发布方法以异步执行方式工作，因此执行是非阻塞的。消息的发布和指定的回调将在不同的线程中运行。'
- en: Now, the `callback` method defined in the `MessageChannel` class adds a call
    to the `publish_response_message` method with the message that included the command
    that has been successfully processed (`message`) as an argument. As previously
    explained, the `publish_response_message` method is non-blocking and will return
    immediately while the successfully processed message is published in another thread.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`MessageChannel`类中定义的`callback`方法向`publish_response_message`方法添加了一个调用，该调用以包含已成功处理命令的消息（`message`）作为参数。正如之前解释的那样，`publish_response_message`方法是非阻塞的，并且将在另一个线程中发布成功处理的消息时立即返回。
- en: 'Now, it is time to start running the example in the Intel Galileo Gen 2 board.
    The following line will start the example in the SSH console:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候在 Intel Galileo Gen 2 板上运行示例了。以下行将在 SSH 控制台中启动示例：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After you run the example, go to the Web browser in which you are working with
    the PubNub debug console. You will see the following message listed in the previously
    created client:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例后，转到您与 PubNub 调试控制台一起工作的 Web 浏览器。您将在之前创建的客户中看到以下消息：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Enter the following JSON code and click **Send**:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下 JSON 代码并点击**发送**：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After you click **Send**, the following lines will appear in the client log.
    The last message has been published by the board to the channel and indicates
    that the `print_temperature_fahrenheit` command has been successfully processed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**发送**后，客户端日志中会出现以下行。最后一条消息是由板发布到频道的，表示 `print_temperature_fahrenheit` 命令已成功处理。
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following picture shows the messages and debug messages log for the PubNub
    client after we clicked the **Send** button:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片展示了点击**发送**按钮后 PubNub 客户端的消息和调试消息日志：
- en: '![Working with bi-directional communications](img/B05042_09_12.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![处理双向通信](img/B05042_09_12.jpg)'
- en: After you publish the previous message, you will see the following output in
    the SSH console for the Intel Galileo Gen 2 board. You will notice the servo's
    shaft rotates to 90 degrees. The board also receives the successfully processed
    command message because it is subscribed to the channel in which the message has
    been published.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 发布之前的消息后，您将在 Intel Galileo Gen 2 板的 SSH 控制台中看到以下输出。您会注意到伺服电机的轴旋转到 90 度。该板还接收到了成功处理的命令消息，因为它订阅了发布消息的频道。
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, enter the following JSON code and click **Send**:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入以下 JSON 代码并点击**发送**：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After you click **Send**, the following lines will appear in the client log.
    The last message has been published by the board to the channel and indicates
    that the `print_information_message` command has been successfully processed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**发送**后，客户端日志中会出现以下行。最后一条消息是由板发布到频道的，表示 `print_information_message` 命令已成功处理。
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The following picture shows the messages and debug messages log for the PubNub
    client after we clicked the **Send** button.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片展示了点击**发送**按钮后 PubNub 客户端的消息和调试消息日志。
- en: '![Working with bi-directional communications](img/B05042_09_13.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![处理双向通信](img/B05042_09_13.jpg)'
- en: 'After you publish the previous message, you will see the following output in
    the SSH console for the Intel Galileo Gen 2 board. You will see the following
    text displayed at the bottom of the OLED matrix: `2nd message`. The board also
    receives the successfully processed command message because it is subscribed to
    the channel in which the message has been published.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 发布之前的消息后，您将在 Intel Galileo Gen 2 板的 SSH 控制台中看到以下输出。您将在 OLED 矩阵的底部看到以下文本：`2nd
    message`。该板还接收到了成功处理的命令消息，因为它订阅了发布消息的频道。
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can work with the different SDKs provided by PubNub to subscribe and publish
    to a channel. We can also make different IoT devices talk to themselves by publishing
    messages to channels and processing them. In this case, we just created a few
    commands and we didn't add detailed information about the device that has to process
    the command or the device that has generated a specific message. A more complex
    API would require commands that include more information and security.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 PubNub 提供的不同 SDK 订阅和发布到频道。我们还可以通过向频道发布消息并处理它们，使不同的 IoT 设备相互通信。在这种情况下，我们只创建了一些命令，并没有添加关于必须处理命令的设备或生成特定消息的设备的详细信息。更复杂的
    API 需要包含更多信息和安全性的命令。
- en: Publishing messages to the cloud with a Python PubNub client
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python PubNub 客户端向云端发布消息
- en: So far, we have been using the PubNub debug console to publish messages to the
    `temperature` channel and make the Python code running in the Intel Galileo Gen
    2 board process them. Now, we are going to code a Python client that will publish
    messages to the `temperature` channel. This way, we will be able to design applications
    that can talk to IoT devices with Python code in the publisher and in the subscriber
    devices.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用 PubNub 调试控制台向 `temperature` 频道发布消息，并让 Intel Galileo Gen 2 板上的
    Python 代码处理它们。现在，我们将编写一个 Python 客户端，它将向 `temperature` 频道发布消息。这样，我们将能够设计能够与 IoT
    设备通信的应用程序，发布者端和订阅者设备端都使用 Python 代码。
- en: We can run the Python client on another Intel Galileo Gen 2 board or in any
    device that has Python 2.7.x installed. In addition, the code will run with Python
    3.x. For example, we can run the Python client in our computer. We just need to
    make sure that we install the `pubnub` module we have previously installed with
    pip in the Python version that is running in the Yocto Linux for the board.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在另一个 Intel Galileo Gen 2 板上或在安装了 Python 2.7.x 的任何设备上运行 Python 客户端。此外，代码将以
    Python 3.x 运行。例如，我们可以在我们的计算机上运行 Python 客户端。我们只需确保在板上的 Yocto Linux 运行的 Python 版本中安装了之前用
    pip 安装的 `pubnub` 模块。
- en: 'We will create a `Client` class to represent a PubNub client, configure the
    PubNub subscription, make it easy to publish a message with a command and the
    required values for the command and declare the code for the callbacks that are
    going to be executed when certain events are fired. The code file for the sample
    is `iot_python_chapter_09_04.py`. Don''t forget to replace the strings assigned
    to the `publish_key` and `subscribe_key` local variables in the `__init__` method
    with the values you have retrieved from the previously explained PubNub key generation
    process. The following lines show the code for the `Client` class:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 `Client` 类来表示 PubNub 客户端，配置 PubNub 订阅，使其能够轻松发布带有命令和所需值的消息，并声明当某些事件触发时要执行的回调代码。示例代码文件为
    `iot_python_chapter_09_04.py`。不要忘记将 `__init__` 方法中分配给 `publish_key` 和 `subscribe_key`
    局部变量的字符串替换为从之前解释的 PubNub 密钥生成过程中检索到的值。以下行显示了 `Client` 类的代码：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `Client` class declares the `command_key` class attribute that defines the
    key string that defines what the code understands as a command in the messages.
    Our main goal is to build and publish command messages to a specified channel.
    We have to specify the PubNub channel name in the `channel` required argument.
    The constructor, that is, the `__init__` method, saves the received argument in
    an attribute with the same name. We will be both a subscriber and a publisher
    for this channel.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client` 类声明了 `command_key` 类属性，该属性定义了代码在消息中理解为何种命令的键字符串。我们的主要目标是构建并发布到指定频道的命令消息。我们必须在
    `channel` 所需参数中指定 PubNub 频道名称。构造函数，即 `__init__` 方法，将接收到的参数保存在具有相同名称的属性中。我们将成为此频道的订阅者和发布者。'
- en: 'Then, the constructor declares two local variables: `publish_key` and `subscribe_key`.
    These local variables save the publish and subscribe keys we had generated with
    the PubNub Admin portal. Then, the code creates a new `Pubnub` instance with `publish_key`
    and `subscribe_key` as the arguments, and saves the reference for the new instance
    in the `pubnub` attribute. Finally, the code calls the `subscribe` method for
    the new instance to subscribe to data on the channel saved in the `channel` attribute.
    The call to this method specifies many methods declared in the `Client` class
    as we did for our previous examples.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，构造函数声明了两个局部变量：`publish_key` 和 `subscribe_key`。这些局部变量保存了我们使用 PubNub 管理门户生成的发布和订阅密钥。然后，代码使用
    `publish_key` 和 `subscribe_key` 作为参数创建一个新的 `Pubnub` 实例，并将新实例的引用保存在 `pubnub` 属性中。最后，代码调用新实例的
    `subscribe` 方法来订阅保存在 `channel` 属性中的频道上的数据。对这个方法的调用指定了许多在 `Client` 类中声明的函数，就像我们在之前的示例中所做的那样。
- en: The `publish_command` method receives a command name, the key and the value
    that provide the necessary information to execute the command in the `command_name`,
    `key` and `value` required arguments. In this case, we don't target the command
    to a specific IoT device and all the devices that subscribe to the channel and
    run the code in our previous example will process the commands that we publish.
    We can use the code as a baseline to work with more complex examples in which
    we have to generate commands that target specific IoT devices. Obviously, it is
    also necessary to improve the security.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish_command` 方法接收一个命令名称、键和值，这些键和值提供了执行 `command_name`、`key` 和 `value`
    所需的必要信息。在这种情况下，我们没有将命令针对特定的物联网设备，而是所有订阅该频道并在我们之前的示例中运行代码的设备都将处理我们发布的命令。我们可以使用此代码作为基准，以处理更复杂的示例，在这些示例中，我们必须生成针对特定物联网设备的命令。显然，提高安全性也是必要的。'
- en: The method creates a dictionary and saves it in the `command_message` local
    variable. The `command_key` class attribute is the first key for the dictionary
    and the `command_name` received as an argument, the value that composes the first
    key-value pair. Then, the code calls the `self.pubnub.publish` method to publish
    the `command_message` dictionary to the channel saved in the `channel` attribute.
    The call to this method specifies `self.callback_command_message` as the callback
    to be executed when the message is successfully published and `self.error_command_message`
    as the callback to be executed when an error occurred during the publishing process.
    As happened in our previous example, when we specify a callback, the `publish`
    method works with an asynchronous execution.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法创建一个字典，并将其保存在`command_message`局部变量中。`command_key`类属性是字典的第一个键，而`command_name`作为参数接收的值，是构成第一个键值对的值。然后，代码调用`self.pubnub.publish`方法，将`command_message`字典发布到保存在`channel`属性中的频道。对这个方法的调用指定了`self.callback_command_message`作为在消息成功发布时执行的回调，以及`self.error_command_message`作为在发布过程中发生错误时执行的回调。正如我们之前的例子中发生的那样，当我们指定回调时，`publish`方法将以异步执行的方式工作。
- en: Now, we will use the previously coded `Client` class to write a `__main__` method
    that uses the PubNub cloud to publish two commands that our board will process.
    The following lines show the code for the `__main__` method. The code file for
    the sample is `iot_python_chapter_09_04.py`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用之前编写的`Client`类来编写一个`__main__`方法，该方法使用PubNub云发布两个命令，我们的板子将处理这些命令。以下行显示了`__main__`方法的代码。示例的代码文件是`iot_python_chapter_09_04.py`。
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The code in the `__main__` method is very easy to understand. The code creates
    an instance of the `Client` class with `"temperature"` as an argument to become
    both a subscriber and a publisher for this channel in the PubNub cloud. The code
    saves the new instances in the `client` local variable.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`__main__`方法中的代码非常容易理解。代码使用`"temperature"`作为参数创建`Client`类的一个实例，使其成为PubNub云中该频道的订阅者和发布者。代码将新实例保存在`client`局部变量中。'
- en: The code calls the `publish_command` method with the necessary arguments to
    build and publish the `print_temperature_fahrenheit` command with a temperature
    value of `45`. The method will publish the command with an asynchronous execution.
    Then, the code calls the `publish_command` method again with the necessary arguments
    to build and publish the `print_information_message` command with a text value
    of `"Python IoT"`. The method will publish the second command with an asynchronous
    execution.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 代码调用`publish_command`方法，并传入必要的参数来构建和发布`print_temperature_fahrenheit`命令，该命令的温度值为`45`。该方法将以异步执行的方式发布命令。然后，代码再次调用`publish_command`方法，并传入必要的参数来构建和发布`print_information_message`命令，该命令的文本值为`"Python
    IoT"`。该方法将以异步执行的方式发布第二个命令。
- en: Finally, the code sleeps for 1 minute (60 seconds) in order to make it possible
    for the asynchronous executions to successfully publish the commands. The different
    callbacks defined in the `Client` class will be executed as the different events
    fire. As we are also subscribed to the channel, we will also receive the messages
    we publish in the `temperature` channel.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码暂停1分钟（60秒），以便异步执行成功发布命令。在`Client`类中定义的不同回调将在不同事件触发时执行。由于我们也订阅了该频道，我们还将收到在`temperature`频道发布的消息。
- en: Keep the Python code we have executed in our previous example running on the
    board. We want the board to process our commands. In addition, keep the Web browser
    in which you are working with the PubNub debug console opened because we also
    want to see all the messages in the log.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 保持我们在之前的例子中执行的Python代码在板上运行。我们希望板子处理我们的命令。此外，保持您正在使用的Web浏览器和PubNub调试控制台打开，因为我们还希望看到日志中的所有消息。
- en: The following line will start the example for the Python client in any computer
    or device that you want to use as a client. It is possible to run the code in
    another SSH terminal in case you want to use the same board as a client.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将在任何您想要用作客户端的计算机或设备上启动Python客户端的示例。如果您想使用同一块板作为客户端，可以在另一个SSH终端中运行代码。
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After you run the example, you will see the following output in the Python console
    that runs the Python client, that is, the `iot_python_chapter_09_04.py` Python
    script.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例后，您将在运行Python客户端的Python控制台中看到以下输出，即`iot_python_chapter_09_04.py` Python脚本。
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The code used the PubNub Python SDK to build and publish the following two
    command messages in the `temperature` channel:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用了 PubNub Python SDK 构建，并在 `temperature` 通道中发布了以下两个命令消息：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we are also subscribed to the temperature channel, we receive the messages
    we sent with an asynchronous execution. Then, we received the successfully processed
    command messages for the two command messages. The board has processed the commands
    and published the messages to the `temperature` channel.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们也订阅了温度通道，我们以异步方式接收我们发送的消息。然后，我们收到了成功处理的两个命令消息。板子已经处理了命令，并将消息发布到了 `temperature`
    通道。
- en: 'After you run the example, go to the Web browser in which you are working with
    the PubNub debug console. You will see the following messages listed in the previously
    created client:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行示例后，转到您正在使用 PubNub 调试控制台工作的网络浏览器。您将看到以下消息列在之前创建的客户端中：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following picture shows the last messages displayed in the log for the
    PubNub client after we run the previous example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了在运行上一个示例后 PubNub 客户端日志中显示的最后一条消息：
- en: '![Publishing messages to the cloud with a Python PubNub client](img/B05042_09_14.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Python PubNub 客户端向云端发布消息](img/B05042_09_14.jpg)'
- en: 'You will see the following text displayed at the bottom of the OLED matrix:
    `Python IoT`. In addition, the servo''s shaft will rotate to 45 degrees.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在 OLED 矩阵的底部看到以下文本：`Python IoT`。此外，伺服电机的轴将旋转到 45 度。
- en: Tip
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We can use the PubNub SDKs available in different programming languages to create
    applications and apps that publish and receive messages in the PubNub cloud and
    interact with IoT devices. In this case, we worked with the Python SDK to create
    a client that publishes commands. It is possible to create mobile apps that publish
    commands and easily build an app that can interact with our IoT device.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用不同编程语言中可用的 PubNub SDK 来创建应用程序和应用程序，这些应用程序可以在 PubNub 云中发布和接收消息，并与物联网设备交互。在这种情况下，我们与
    Python SDK 合作创建了一个发布命令的客户端。可以创建发布命令的移动应用程序，并轻松构建一个可以与我们的物联网设备交互的应用程序。
- en: Using MQTT with Mosquitto and Eclipse Paho
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mosquitto 和 Eclipse Paho 的 MQTT
- en: 'Mosquitto is an open source message broker that implements the versions 3.1
    and 3.1.1 of the MQTT protocol, and therefore, allows us to work with messages
    using the publish/subscribe model. Mosquitto is an iot.eclipse.org project and
    is provided with the Eclipse Public Project (EPL)/EDL license. The following is
    the Web page for Mosquitto: [http://mosquitto.org](http://mosquitto.org).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Mosquitto 是一个开源的消息代理，实现了 MQTT 协议的 3.1 和 3.1.1 版本，因此，允许我们使用发布/订阅模型来处理消息。Mosquitto
    是 iot.eclipse.org 项目，并提供了 Eclipse 公共项目 (EPL)/EDL 许可证。以下是为 Mosquitto 提供的网页：[http://mosquitto.org](http://mosquitto.org)。
- en: 'The Eclipse Paho project provides an open source client implementation of MQTT.
    The project includes a Python client, also known as the Paho Python Client or
    Eclipse Paho MQTT Python client library. This Python client has been contributed
    from the Mosquitto project and was originally the Mosquitto Python Client. The
    following is the Web page for the Eclipse Paho project: [http://www.eclipse.org/paho](http://www.eclipse.org/paho).
    The following is the Web page for the Eclipse Paho MQTT Python client library,
    that is, the paho-mqtt module: [https://pypi.python.org/pypi/paho-mqtt/1.1](https://pypi.python.org/pypi/paho-mqtt/1.1).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Paho 项目提供了一个开源的 MQTT 客户端实现。该项目包括一个 Python 客户端，也称为 Paho Python 客户端或 Eclipse
    Paho MQTT Python 客户端库。这个 Python 客户端是由 Mosquitto 项目贡献的，最初是 Mosquitto Python 客户端。以下是为
    Eclipse Paho 项目提供的网页：[http://www.eclipse.org/paho](http://www.eclipse.org/paho)。以下是为
    Eclipse Paho MQTT Python 客户端库提供的网页，即 paho-mqtt 模块：[https://pypi.python.org/pypi/paho-mqtt/1.1](https://pypi.python.org/pypi/paho-mqtt/1.1)。
- en: In [Chapter 2](ch02.html "Chapter 2. Working with Python on Intel Galileo Gen
    2"), *Working* *with Python on Intel Galileo Gen 2*, we installed `pip` installer
    to easily install additional Python 2.7.3 packages in the Yocto Linux that we
    are running on the board. Now, we will use `pip` installer to install paho-mqtt
    1.1\. We just need to run the following command in the SSH terminal to install
    the package.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](ch02.html "第 2 章。在英特尔 Galileo Gen 2 上使用 Python")，*在英特尔 Galileo Gen
    2 上使用 Python*，我们安装了 `pip` 安装程序，以便在板子上运行的 Yocto Linux 中轻松安装额外的 Python 2.7.3 软件包。现在，我们将使用
    `pip` 安装程序安装 paho-mqtt 1.1。我们只需要在 SSH 终端中运行以下命令来安装该软件包。
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The last lines for the output will indicate that the `paho-mqtt` package has
    been successfully installed. Don't worry about the error messages related to building
    wheel and the insecure platform warning.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示 `paho-mqtt` 包已成功安装。不要担心与构建 wheel 相关的错误消息和不安全平台警告。
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Tip
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Eclipse allows us to use a publically accessible sandbox server for the Eclipse
    IoT projects at [iot.eclipse.org](http://iot.eclipse.org), port 1883\. In the
    following examples, we will use this sandbox server as our Mosquitto message broker.
    This way, we don't have to setup a Mosquitto message broker to test the examples
    and learn how to work with the Paho Python Client. However, in a real-life application,
    we should setup a Mosquitto message broker and use it for our project.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse 允许我们使用一个公开可访问的沙盒服务器来运行 Eclipse IoT 项目，该服务器位于 [iot.eclipse.org](http://iot.eclipse.org)，端口号为
    1883。在接下来的示例中，我们将使用这个沙盒服务器作为我们的 Mosquitto 消息代理。这样，我们就不需要设置一个 Mosquitto 消息代理来测试示例并学习如何使用
    Paho Python 客户端。然而，在实际应用中，我们应该设置一个 Mosquitto 消息代理并用于我们的项目。
- en: 'We will take the code we wrote in the previous chapter when we read temperature
    and humidity values from the sensor, we printed the values in an OLED matrix and
    rotated a servo''s shaft to display the measured temperature expressed in degrees
    Fahrenheit with the shaft. The code file for the sample was `iot_python_chapter_08_03.py`.
    We will use this code as a baseline to add the same features that we added when
    we worked with the PubNub cloud. However, in this case, we will use the Paho Python
    Client and the publically accessible sandbox server that provides us with a Mosquitto
    message broker. We will be able to perform the following actions with MQTT messages
    sent to a specific topic from any device that can publish MQTT messages in the
    topic to which we are subscribed:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从传感器读取温度和湿度值时，我们在上一章中编写的代码，我们将值打印在 OLED 矩阵上，并旋转伺服电机的轴来显示以华氏度表示的测量温度。该示例的代码文件为
    `iot_python_chapter_08_03.py`。我们将使用此代码作为基准，添加我们在与 PubNub 云一起工作时添加的相同功能。然而，在这种情况下，我们将使用
    Paho Python 客户端和公开可访问的沙盒服务器，该服务器为我们提供了一个 Mosquitto 消息代理。我们将能够执行以下操作，通过将 MQTT 消息发送到特定主题，从任何可以发布
    MQTT 消息到我们订阅的主题的设备：
- en: Rotate the servo's shaft to display a temperature value in degrees Fahrenheit
    received as part of the message
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转伺服电机的轴以显示作为消息一部分接收到的华氏度温度值
- en: Display a line of text received as part of the message at the bottom of the
    OLED matrix
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OLED 矩阵的底部显示作为消息一部分接收到的文本行
- en: Tip
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The Paho Python Client uses the topic name instead of channel. You can think
    of a topic as a channel.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Paho Python 客户端使用主题名称而不是通道。你可以将主题视为一个通道。
- en: We will use the recently installed `paho-mqtt` module to subscribe to a specific
    topic and run code when we receive messages in the topic. We will create a `MessageTopic`
    class to represent the communications topic, configure the MQTT client, the subscription
    to the client and declare the code for the callbacks that are going to be executed
    when certain events are fired. The code file for the sample is `iot_python_chapter_09_05.py`.
    Remember that we use the code file `iot_python_chapter_08_03.py` as a baseline,
    and therefore, we will add the class to the existing code in this file and we
    will create a new Python file. Don't forget to replace the strings assigned to
    the `topic` class attribute with your unique topic name. As the Mosquitto broker
    we are using is public, you should use a unique topic to make sure you only receive
    the messages you publish.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用最近安装的 `paho-mqtt` 模块来订阅特定主题，并在接收到主题中的消息时运行代码。我们将创建一个 `MessageTopic` 类来表示通信主题，配置
    MQTT 客户端、客户端的订阅以及声明当某些事件触发时要执行的回调代码。该示例的代码文件为 `iot_python_chapter_09_05.py`。请记住，我们使用代码文件
    `iot_python_chapter_08_03.py` 作为基准，因此，我们将向该文件中现有的代码添加类，并创建一个新的 Python 文件。不要忘记将分配给
    `topic` 类属性的字符串替换为你的唯一主题名称。由于我们使用的 Mosquitto 代理是公开的，你应该使用一个唯一主题，以确保你只接收你发布的消息。
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `MessageTopic` class declares the `command_key` class attribute that defines
    the key string that defines what the code will understand as the command. Whenever
    we receive a message that includes the specified key string, we know that the
    value associated to this key in the dictionary will indicate the command that
    the message wants the code running in the board to be processed. In this case,
    we don't receive messages as dictionaries, and therefore, it is necessary to convert
    them from strings to dictionaries when they are not just a string.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageTopic`类声明了`command_key`类属性，该属性定义了键字符串，该字符串定义了代码将理解为什么命令。每当收到包含指定键字符串的消息时，我们知道与该键关联的字典中的值将指示消息希望代码在板子上处理的命令。在这种情况下，我们不会以字典的形式接收消息，因此当它们不是字符串时，有必要将它们从字符串转换为字典。'
- en: The code declares the `successfully_processed_command_key` class attribute that
    defines the key string that defines what the code will use as a successfully processed
    command key in a response message published to the topic. Whenever we publish
    a message that includes the specified key string, we know that the value associated
    to this key in the dictionary will indicate the command that the board has successfully
    processed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了`successfully_processed_command_key`类属性，该属性定义了键字符串，该字符串定义了代码将在发布到主题的消息中使用什么作为成功处理的命令键。每当发布包含指定键字符串的消息时，我们知道与该键关联的字典中的值将指示板已成功处理的命令。
- en: We have to specify the `TemperatureServo` instance and the `Oled` instance in
    the `temperature_servo` and `oled` required arguments. The constructor, that is,
    the `__init__` method, saves the received arguments in two attributes with the
    same names. The `topic` class attribute argument specifies the Mosquitto topic
    to which we are going to subscribe to listen to the messages that other devices
    send to this topic. We will also publish messages to this topic, and therefore,
    we will be both a subscriber and a publisher for this channel.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在`temperature_servo`和`oled`必需参数中指定`TemperatureServo`实例和`Oled`实例。构造函数，即`__init__`方法，将接收到的参数保存到具有相同名称的两个属性中。`topic`类属性参数指定了我们将订阅以监听其他设备发送到该主题的消息的Mosquitto主题。我们还将向该主题发布消息，因此我们将成为该通道的订阅者和发布者。
- en: Then, the constructor creates an instance of the `mqtt.Client` class that represents
    an MQTT client and we will use to communicate with an MQTT broker. As we create
    the instance with the default parameters, we will create an instance of `paho.mqtt.client.MQTTv31`
    and we will work with MQTT version 3.1.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，构造函数创建了一个`mqtt.Client`类的实例，该实例代表一个MQTT客户端，我们将用它与MQTT代理进行通信。由于我们使用默认参数创建实例，我们将创建一个`paho.mqtt.client.MQTTv31`实例，我们将使用MQTT版本3.1。
- en: The code also saves a reference to this instance in the `active_instance` class
    attribute because we have to access the instance in static methods that we will
    be specified as callbacks for the different events that the MQTT client fires.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 代码还保存了这个实例在`active_instance`类属性中的引用，因为我们必须在静态方法中访问该实例，我们将指定为不同事件触发的MQTT客户端的回调。
- en: Then, the code assigns the `self.client.on_connect` attribute to the `on_connect`
    static method and the `self.client.on_message` attribute to the `on_message` static
    method. Static methods do not receive either `self` of `cls` as the first argument,
    and therefore, we can use them as callbacks with the required number of arguments.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将`self.client.on_connect`属性分配给`on_connect`静态方法，将`self.client.on_message`属性分配给`on_message`静态方法。静态方法不接收`self`或`cls`作为第一个参数，因此我们可以使用它们作为具有所需参数数量的回调。
- en: Finally, the constructor calls the `self.client.connect` method and specifies
    the publically accessible sandbox server for the Eclipse IoT projects at iot.eclipse.org,
    port 1883, in the arguments. This way, the code asks the MQTT client to establish
    a connection to the specified MQTT broker. In case you decide to use your own
    Mosquitto broker, you just need to change the values for the `host` and `port`
    arguments, according to the configuration for the Mosquitto broker. The `connect`
    method runs with an asynchronous execution, and therefore, it is a non-blocking
    call.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，构造函数调用`self.client.connect`方法，并在参数中指定了公开可访问的Eclipse IoT项目在iot.eclipse.org的沙盒服务器，端口1883。这样，代码要求MQTT客户端建立与指定MQTT代理的连接。如果您决定使用自己的Mosquitto代理，只需根据Mosquitto代理的配置更改`host`和`port`参数的值。`connect`方法以异步执行方式运行，因此它是一个非阻塞调用。
- en: After a connection has been successfully established with the MQTT broker, the
    specified callback in the `self.client.on_connect` attribute will be executed,
    that is, the `on_connect` static method (marked with the `@staticmethod` decorator).
    This static method receives the `mqtt.Client` instance that established the connection
    with the MQTT broker in the `client` argument. The code calls the `client.subscribe`
    method with `MessageTopic.topic` as an argument to subscribe to the topic specified
    in the `topic` class attribute.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功连接到 MQTT 代理后，`self.client.on_connect` 属性中指定的回调函数将被执行，即标记为 `@staticmethod`
    装饰器的 `on_connect` 静态方法。这个静态方法接收 `client` 参数中的 `mqtt.Client` 实例，该实例与 MQTT 代理建立了连接。代码使用
    `MessageTopic.topic` 作为参数调用 `client.subscribe` 方法，以订阅由 `topic` 类属性指定的主题。
- en: Tip
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In this case, we will only subscribe to one topic. However, it is very important
    to know that we are not limited to subscribe to a single topic, we might subscribe
    to many topics with a single call to the `subscribe` method.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只会订阅一个主题。然而，了解我们不仅限于订阅单个主题，我们可能通过一次调用 `subscribe` 方法订阅多个主题，这一点非常重要。
- en: Finally, the code calls the `client.publish` method with `MessageTopic.topic`
    as the `topic` argument and a message string in the `payload` argument. This way,
    we publish a string message that says `"Listening to messages in the Intel Galileo
    Gen 2 board"` to the topic specified in the `topic` class attribute.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码使用 `MessageTopic.topic` 作为 `topic` 参数，以及一个消息字符串作为 `payload` 参数调用 `client.publish`
    方法。这样，我们将一个字符串消息 `"Listening to messages in the Intel Galileo Gen 2 board"` 发布到由
    `topic` 类属性指定的主题。
- en: Whenever there is a new message received in the topic to which we have subscribed,
    the specified callback in the `self.client.on_messsage` attribute will be executed,
    that is, the `on_message` static method (marked with the `@staticmethod` decorator).
    This static method receives the `mqtt.Client` instance that established the connection
    with the MQTT broker in the `client` argument and an `mqtt.MQTTMessage` instance
    in the `msg` argument. The `mqtt.MQTTMessage` class describes an incoming message.
    First, the static method checks whether the `msg.topic` attribute, that indicates
    the topic in which the message has been received, matches the value in the `topic`
    class attribute. In this case, whenever the `on_message` method is executed, the
    value in `msg.topic` will always match the value in the `topic` class attribute
    because we just subscribed to one topic. However, in case we subscribe to more
    than one topic, is is always necessary to check which is the topic in which the
    message was sent and in which we are receiving the message.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们订阅的主题中收到新消息时，`self.client.on_message` 属性中指定的回调函数将被执行，即标记为 `@staticmethod`
    装饰器的 `on_message` 静态方法。这个静态方法接收 `client` 参数中的 `mqtt.Client` 实例，该实例与 MQTT 代理建立了连接，以及
    `msg` 参数中的 `mqtt.MQTTMessage` 实例。`mqtt.MQTTMessage` 类描述了一个传入的消息。首先，静态方法检查 `msg.topic`
    属性，该属性指示接收消息的主题，是否与 `topic` 类属性中的值匹配。在这种情况下，每当 `on_message` 方法执行时，`msg.topic`
    中的值将始终与 `topic` 类属性中的值匹配，因为我们只订阅了一个主题。然而，如果我们订阅了多个主题，则始终有必要检查消息发送的主题以及我们接收消息的主题。
- en: The code prints the message that has been received, that is, the `msg.payload`
    attribute. Then, the code assigns the result of the `json.loads` function to deserialize
    `msg.payload` to a Python object and assigns the results to the `message_dictionary`
    local variable. In case the contents of `msg.payload` are not JSON, a `ValueError`
    exception will be captured and no more code will be executed in the method. In
    case the contents of `msg.payload` are JSON, we will have a dictionary in the
    `message_dictionary` local variable.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 代码打印接收到的消息，即 `msg.payload` 属性。然后，代码将 `json.loads` 函数的结果反序列化 `msg.payload` 到一个
    Python 对象，并将结果赋值给 `message_dictionary` 本地变量。如果 `msg.payload` 的内容不是 JSON，将捕获 `ValueError`
    异常，并且方法中不再执行更多代码。如果 `msg.payload` 的内容是 JSON，我们将在 `message_dictionary` 本地变量中有一个字典。
- en: Then, the code checks whether the `command_key` class attribute is included
    in the `message_dictionary` dictionary. If the expression evaluates to `True`,
    it means that the JSON message converted to a dictionary includes a command that
    we have to process. However, before we can process the command, we have to check
    which is the command, and therefore, it is necessary to retrieve the value associated
    with the key equivalent to the `command_key` class attribute. The code is capable
    of running specific code when the value is any of the two commands that we used
    in our previous example when we worked with the PubNub cloud.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码检查 `command_key` 类属性是否包含在 `message_dictionary` 字典中。如果表达式评估为 `True`，则表示将
    JSON 消息转换为字典时包含了一个我们必须处理的命令。然而，在我们能够处理命令之前，我们必须检查是哪个命令，因此有必要检索与 `command_key`
    类属性等效的键关联的值。代码能够在值是我们在之前示例中与 PubNub 云一起工作时使用的两个命令中的任何一个时运行特定的代码。
- en: The code uses the `active_instance` class attribute that has a reference to
    the active `MessageTopic` instance to call the necessary methods for either the
    `temperature_servo` or the `oled` attribute based on the command that has to be
    processed. We had to declare the callbacks as static methods, and therefore, we
    use this class attribute to access the active instance.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用了具有对活动 `MessageTopic` 实例引用的 `active_instance` 类属性来根据要处理的命令调用 `temperature_servo`
    或 `oled` 属性所需的必要方法。我们不得不将回调声明为静态方法，因此我们使用这个类属性来访问活动实例。
- en: Once the command has been successfully processed, the code calls the `publish_response_message`
    for the `MessageTopic` instance saved in the `active_instance` class attribute.
    This method receives the message dictionary that has been received with the command
    in the `message` argument. The method calls the `json.dumps` function to serialize
    a dictionary to a JSON formatted string with the response message that indicates
    the command has been successfully processed. Finally, the code calls the `client.publish`
    method with the `topic` class attribute as the `topic` argument and the JSON formatted
    string (`response_message`) in the `payload` argument.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令被成功处理，代码就会调用存储在 `active_instance` 类属性中的 `MessageTopic` 实例的 `publish_response_message`
    方法。该方法接收包含在 `message` 参数中的带有命令接收到的消息字典。该方法调用 `json.dumps` 函数将字典序列化为一个带有响应消息的 JSON
    格式化字符串，该消息指示命令已成功处理。最后，代码使用 `topic` 类属性作为 `topic` 参数和 JSON 格式化字符串（`response_message`）在
    `payload` 参数中调用 `client.publish` 方法。
- en: Tip
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In this case, we are not evaluating the response from the `publish` method.
    In addition, we are using the default value for the `qos` argument that specifies
    the desired quality of service. In more advanced scenarios, we should add code
    to check the results of the method and probably adding code on the `on_publish`
    callback that is fired when a message is successfully published.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不是评估 `publish` 方法的响应。此外，我们正在使用 `qos` 参数的默认值，该参数指定了所需的服务质量。在更高级的场景中，我们应该添加代码来检查方法的结果，并可能在成功发布消息时触发的
    `on_publish` 回调中添加代码。
- en: Now, we will use the previously coded `MessageTopic` class to create a new version
    of the `__main__` method that uses the Mosquitto broker and the MQTT client to
    receive and process commands. The new version doesn't rotate the servo's shaft
    when the ambient temperature changes, instead, it will do this when it receives
    the appropriate command from any device connected to the Mosquitto broker. The
    following lines show the new version of the `__main__` method. The code file for
    the sample is `iot_python_chapter_09_05.py`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用之前编写的 `MessageTopic` 类来创建一个新的 `__main__` 方法版本，该方法使用 Mosquitto 代理和 MQTT
    客户端接收和处理命令。新版本在环境温度变化时不会旋转伺服电机的轴，相反，它将在接收到连接到 Mosquitto 代理的任何设备的适当命令时执行此操作。以下行显示了
    `__main__` 方法的新版本。示例代码文件为 `iot_python_chapter_09_05.py`。
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The highlighted line creates an instance of the previously coded `MessageTopic`
    class with `temperature_servo` and `oled` as the arguments. The constructor will
    subscribe to the `"iot-python-gaston-hillar/temperature"` topic in the Mosquitto
    broker, and therefore, we must publish messages to this topic in order to send
    the commands that the code will process. The loop will read the values from the
    sensor and print the values to the console as in the previous version of the code,
    and therefore, we will have code running in the loop and we will also have code
    listening to the messages in the `"iot-python-gaston-hillar/temperature"` topic
    in the Mosquitto broker. The last lines of the loop call the `message_channel.loop`
    method 10 times and sleep 1 second each time between the calls. The `loop` method
    calls the loop method for the MQTT client to and ensures communication with the
    broker is carried out. Think about the call to the loop method as synchronizing
    your mailbox. Any pending messages to the published in the outgoing box will be
    sent and any incoming messages will arrive to the inbox and the events that we
    have previously analyzed will be fired.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行创建了一个之前编写的`MessageTopic`类的实例，其中`temperature_servo`和`oled`作为参数。构造函数将订阅Mosquitto代理中的`"iot-python-gaston-hillar/temperature"`主题，因此，我们必须向这个主题发布消息，以便发送代码将处理的命令。循环将读取传感器的值并将值打印到控制台，就像代码的先前的版本一样，因此，我们将在循环中运行代码，我们也将有代码在Mosquitto代理的`"iot-python-gaston-hillar/temperature"`主题上监听消息。循环的最后几行调用`message_channel.loop`方法10次，每次调用之间暂停1秒。`loop`方法调用MQTT客户端的循环方法，并确保与代理的通信得到执行。将调用`loop`方法视为同步您的邮箱。任何待发送的消息将发送到发件箱，任何传入的消息将到达收件箱，我们之前分析的事件将被触发。
- en: Tip
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There is also a threaded interface that we can run by calling the `loop_start`
    method for the MQTT client. This way, we can avoid multiple calls to the `loop`
    method.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以通过调用MQTT客户端的`loop_start`方法来运行一个线程接口。这样，我们可以避免多次调用`loop`方法。
- en: The following line will start the example.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将启动示例。
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Keep the code running in the board. We will start receiving messages later because
    we have to write the code that will publish messages to this topic and send the
    commands to be processed.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在板上保持代码运行。稍后我们将开始接收消息，因为我们必须编写将消息发布到这个主题并发送要处理的命令的代码。
- en: Publishing messages to a Mosquitto broker with a Python client
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python客户端向Mosquitto代理发布消息
- en: We have the code that is going to be running in the Intel Galileo Gen 2 board
    to process the command messages received from the Mosquitto message broker. Now,
    we are going to code a Python client that will publish messages to the `"iot-python-gaston-hillar/temperature"`
    channel. This way, we will be able to design applications that can talk to IoT
    devices with MQTT messages. Specifically, the applications will be able to communicate
    through a Mosquitto message broker with Python code in the publisher and in the
    subscriber devices.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有在Intel Galileo Gen 2板上运行的代码，用于处理从Mosquitto消息代理接收到的命令消息。现在，我们将编写一个Python客户端，该客户端将向`"iot-python-gaston-hillar/temperature"`通道发布消息。这样，我们将能够设计能够通过MQTT消息与物联网设备通信的应用程序。具体来说，应用程序将通过Mosquitto消息代理与发布器和订阅设备中的Python代码进行通信。
- en: We can run the Python client on another Intel Galileo Gen 2 board or in any
    device that has Python 2.7.x installed. In addition, the code will run with Python
    3.x. For example, we can run the Python client in our computer. We just need to
    make sure that we install the `pubnub` module we have previously installed with
    pip in the Python version that is running in the Yocto Linux for the board.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在另一个Intel Galileo Gen 2板上或在安装了Python 2.7.x的任何设备上运行Python客户端。此外，代码将以Python
    3.x运行。例如，我们可以在我们的计算机上运行Python客户端。我们只需确保在板上的Yocto Linux中运行的Python版本中安装了我们之前用pip安装的`pubnub`模块。
- en: 'We will create many functions that we will assign as the callbacks to the events
    in the MQTT client. In addition, we will declare variables and a helper function
    to make it easy to publish a message with a command and the required values for
    the command. The code file for the sample is `iot_python_chapter_09_06.py`. Don''t
    forget to replace the string assigned to the `topic` variable with the topic name
    you have specified in the previous code. The following lines show the code that
    defines the variables and the functions:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建许多函数，并将它们作为回调函数分配给 MQTT 客户端的各个事件。此外，我们还将声明变量和一个辅助函数，以便能够轻松地使用命令和所需的值发布消息。示例的代码文件是
    `iot_python_chapter_09_06.py`。别忘了将分配给 `topic` 变量的字符串替换为你之前代码中指定的主题名称。以下行显示了定义变量和函数的代码：
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The code declares the `command_key` variable that defines the key string that
    indicates what the code understands as a command in the messages. Our main goal
    is to build and publish command messages to the topic specified in the `topic`
    variable. We will be both a subscriber and a publisher for this topic.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了 `command_key` 变量，它定义了指示代码在消息中理解为何种命令的关键字符串。我们的主要目标是构建并发布指定在 `topic` 变量中的主题的命令消息。我们将同时作为该主题的订阅者和发布者。
- en: 'The `on_connect` function is the callback that will be executed once a successful
    connection has been established with the Mosquitto MQTT broker. The code calls
    the `subscribe` method for the MQTT client received in the `client` argument and
    then calls the `publish` method to send the following string message to the topic:
    `"Listening to messages in the Paho Python Client"`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_connect` 函数是在与 Mosquitto MQTT 代理成功建立连接后执行的回调函数。代码调用 `client` 参数中接收到的 MQTT
    客户端的 `subscribe` 方法，然后调用 `publish` 方法向主题发送以下字符串消息："Listening to messages in the
    Paho Python Client"'
- en: The code calls the `publish_command` function with the necessary arguments to
    build and publish the `print_temperature_fahrenheit` command with a temperature
    value of 45\. Finally, the code calls the `publish_command` function again with
    the necessary arguments to build and publish the `print_information_message` command
    with a text value of `"Python IoT"`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用必要的参数调用 `publish_command` 函数，构建并发布具有 45 度温度值的 `print_temperature_fahrenheit`
    命令。最后，代码再次调用 `publish_command` 函数，使用必要的参数构建并发布具有文本值 `"Python IoT"` 的 `print_information_message`
    命令。
- en: The `publish_command` function receives the MQTT client, the topic, the command
    name, the key and the value that provide the necessary information to execute
    the command in the `client`, `topic`, `command_name`, `key` and `value` required
    arguments. In this case, we don't target the command to a specific IoT device
    and all the devices that subscribe to the topic and run the code in our previous
    example will process the commands that we publish. We can use the code as a baseline
    to work with more complex examples in which we have to generate commands that
    target specific IoT devices. As happened in our previous examples, it is also
    necessary to improve the security.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish_command` 函数接收 MQTT 客户端、主题、命令名称、键和值，这些参数提供了在 `client`、`topic`、`command_name`、`key`
    和 `value` 中执行命令所必需的信息。在这种情况下，我们不针对特定 IoT 设备的命令，而是所有订阅该主题并运行我们之前示例中的代码的设备都将处理我们发布的命令。我们可以将此代码作为基准，用于处理更复杂的示例，在这些示例中，我们必须生成针对特定
    IoT 设备的命令。正如我们之前的示例中发生的那样，提高安全性也是必要的。'
- en: The function creates a dictionary and saves the results of serializing the dictionary
    to a JSON formatted string in the `command_message` local variable. The `command_key`
    variable is the first key for the dictionary and the `command_name` received as
    an argument, the value that composes the first key-value pair. Then, the code
    calls the `client.publish` method to publish the `command_message` JSON formatted
    string to the topic received as an argument.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数创建一个字典，并将将字典序列化为 JSON 格式字符串的结果保存到 `command_message` 本地变量中。`command_key` 变量是字典的第一个键，`command_name`
    作为参数接收，它构成了第一个键值对。然后，代码调用 `client.publish` 方法将 `command_message` JSON 格式字符串发布到作为参数接收的主题。
- en: The `on_message` function will be executed each time a new message arrives to
    the topic to which we have subscribed. The function just prints the raw string
    with the payload of the received message.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_message` 函数将在每次有新消息到达我们订阅的主题时执行。该函数只是打印带有接收消息有效载荷的原始字符串。'
- en: Now, we will use the previously coded `functions` to write a `__main__` method
    that publishes the two commands included in MQTT messages that our board will
    process. The following lines show the code for the `__main__` method. The code
    file for the sample is `iot_python_chapter_09_06.py`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用之前编写的`functions`来编写一个`__main__`方法，该方法发布MQTT消息中包含的两个命令，我们的板子将处理这些命令。以下行显示了`__main__`方法的代码。示例的代码文件是`iot_python_chapter_09_06.py`。
- en: '[PRE44]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The code in the `__main__` method is very easy to understand. The code creates
    an instance of the `mqtt.Client` class that represents an MQTT client and we will
    use it to communicate with an MQTT broker. As we create the instance with the
    default parameters, we will create an instance of `paho.mqtt.client.MQTTv31` and
    we will work with MQTT version 3.1.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`__main__`方法中的代码非常容易理解。代码创建了一个`mqtt.Client`类的实例，代表一个MQTT客户端，我们将使用它来与MQTT代理通信。由于我们使用默认参数创建实例，我们将创建一个`paho.mqtt.client.MQTTv31`的实例，我们将使用MQTT版本3.1。'
- en: Then, the code assigns the `client.on_connect` attribute to the previously coded
    `on_connect` function and the `client.on_message` attribute to the `on_message`
    function. The code calls the `client.connect` method and specifies the publically
    accessible sandbox server for the Eclipse IoT projects at iot.eclipse.org, port
    1883, in the arguments. This way, the code asks the MQTT client to establish a
    connection to the specified MQTT broker. In case you decide to use your own Mosquitto
    broker, you just need to change the values for the `host` and `port` arguments,
    according to the configuration for the Mosquitto broker. Remember that the `connect`
    method runs with an asynchronous execution, and therefore, it is a non-blocking
    call.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将`client.on_connect`属性分配给之前编写的`on_connect`函数，将`client.on_message`属性分配给`on_message`函数。代码调用`client.connect`方法，并在参数中指定了Eclipse
    IoT项目在iot.eclipse.org上的公开可访问的沙盒服务器，端口为1883。这样，代码请求MQTT客户端与指定的MQTT代理建立连接。如果你决定使用自己的Mosquitto代理，你只需根据Mosquitto代理的配置更改`host`和`port`参数的值。请记住，`connect`方法以异步执行方式运行，因此它是一个非阻塞调用。
- en: After a connection has been successfully established with the MQTT broker, the
    specified callback in the `client.on_connect` attribute will be executed, that
    is, the `on_connect` function. The function receives the `mqtt.Client` instance
    that established the connection with the MQTT broker in the `client` argument.
    As previously explained, the function subscribes to a topic and schedules the
    publication of three messages to it.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在与MQTT代理成功建立连接后，`client.on_connect`属性中指定的回调函数将被执行，即`on_connect`函数。该函数接收在`client`参数中与MQTT代理建立连接的`mqtt.Client`实例。正如之前解释的那样，该函数订阅了一个主题，并安排向其发布三条消息。
- en: Finally, the code calls the `client.loop_forever` method that calls the loop
    method for us in an infinite blocking loop. At this point, we only want to run
    the MQTT client loop in our program. The scheduled messages will be published
    and we will receive the messages with the successfully executed command details
    after the board processes the commands.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码调用`client.loop_forever`方法，该方法以无限阻塞循环的方式为我们调用循环方法。在此阶段，我们只想在我们的程序中运行MQTT客户端循环。计划的消息将被发布，并且在我们将命令发送到板子后，我们将收到成功执行命令详情的消息。
- en: Keep the Python code we have executed in our previous example running on the
    board. We want the board to process our commands. The following line will start
    the example for the Python client in any computer or device that you want to use
    as a client. It is possible to run the code in another SSH terminal in case you
    want to use the same board as a client.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 保持我们在之前的示例中在板上运行的Python代码。我们希望板子处理我们的命令。以下行将在任何你想要用作客户端的计算机或设备上启动Python客户端的示例。如果你想在同一个板上使用相同的板子作为客户端，可以在另一个SSH终端中运行代码。
- en: '[PRE45]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: After you run the example, you will see the following output in the Python console
    that runs the Python client, that is, the `iot_python_chapter_09_06.py` Python
    script.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例后，你将在运行Python客户端的Python控制台中看到以下输出，即`iot_python_chapter_09_06.py` Python脚本。
- en: '[PRE46]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The code used the Eclipse Paho MQTT Python client library to build and publish
    the following two command messages in the `"iot-python-gaston-hillar/temperature"`
    topic in the Mosquitto broker:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用了Eclipse Paho MQTT Python客户端库，在Mosquitto代理的`"iot-python-gaston-hillar/temperature"`主题中构建并发布了以下两条命令消息：
- en: '[PRE47]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As we are also subscribed to the `"iot-python-gaston-hillar/temperature"` topic,
    we receive the messages we sent. Then, we received the successfully processed
    command messages for the two command messages. The board has processed the commands
    and published the messages to the `"iot-python-gaston-hillar/temperature"` topic.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们也订阅了 `"iot-python-gaston-hillar/temperature"` 主题，我们收到了我们发送的消息。然后，我们收到了两个命令消息的成功处理命令消息。板已处理命令并将消息发布到
    `"iot-python-gaston-hillar/temperature"` 主题。
- en: 'You will see the following messages in the output for the SSH terminal that
    is running the code for the board that processes the commands, that is, the `iot_python_chapter_09_05.py`
    Python script:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在运行处理命令的板（即 `iot_python_chapter_09_05.py` Python 脚本）的 SSH 终端输出中看到以下消息：
- en: '[PRE48]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You will see the following text displayed at the bottom of the OLED matrix:
    `Python IoT`. In addition, the servo''s shaft will rotate to 45 degrees.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 OLED 矩阵的底部看到以下文本显示：`Python IoT`。此外，伺服电机的轴将旋转到 45 度。
- en: Test your knowledge
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'MQTT is:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MQTT 是：
- en: A heavyweight messaging protocol that runs on top of the TCP/IP protocol and
    works with a publish-subscribe mechanism.
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 TCP/IP 协议之上运行的重量级消息协议，并使用发布/订阅机制。
- en: A lightweight messaging protocol that runs on top of the TCP/IP protocol and
    works with a publish-subscribe mechanism.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 TCP/IP 协议之上运行的轻量级消息协议，并使用发布/订阅机制。
- en: An equivalent to HTTP.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP 的等价物。
- en: 'Mosquitto is:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mosquitto 是：
- en: An open source message broker that implements the versions 3.1 and 3.1.1 of
    the MQTT protocol.
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 MQTT 协议版本 3.1 和 3.1.1 的开源消息代理。
- en: A closed source message broker that implements the versions 3.1 and 3.1.1 of
    the MQTT protocol.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 MQTT 协议版本 3.1 和 3.1.1 的闭源消息代理。
- en: An open source message broker that implements a RESTful API.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 RESTful API 的开源消息代理。
- en: 'The Eclipse Paho project provides:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Eclipse Paho 项目提供：
- en: An open source client implementation of HTTP.
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP 的开源客户端实现。
- en: An open source client implementation of `dweet.io`.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dweet.io` 的开源客户端实现。'
- en: An open source client implementation of MQTT.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: MQTT 的开源客户端实现。
- en: Which of the following Python modules is the Paho Python Client?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个 Python 模块是 Paho Python 客户端？
- en: paho-client-pip.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: paho-client-pip。
- en: paho-mqtt.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: paho-mqtt。
- en: paho-http.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: paho-http。
- en: 'Dweepy is:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dweepy 是：
- en: A simple Python client for `dweet.io` that allows us to easily publish data
    to `dweet.io` with Python.
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个简单的 `dweet.io` Python 客户端，允许我们使用 Python 轻松发布数据到 `dweet.io`。
- en: A simple Python client for Mosquitto that allows us to easily publish messages
    to a Mosquitto message broker.
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个简单的 Mosquitto Python 客户端，允许我们轻松地将消息发布到 Mosquitto 消息代理。
- en: A simple Python client for PubNub cloud that allows us to easily publish messages
    to the PubNub cloud.
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个简单的 PubNub 云 Python 客户端，允许我们轻松地将消息发布到 PubNub 云。
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we combined many cloud-based services that allowed us to easily
    publish data collected from sensors and visualize it in a web-based dashboard.
    We realized that there is always a Python API, and therefore, it is easy to write
    Python code that interacts with popular cloud-based services.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们结合了许多基于云的服务，使我们能够轻松发布从传感器收集的数据，并在基于网页的仪表板上可视化它。我们意识到总有一个 Python API，因此，编写与流行的基于云服务交互的
    Python 代码很容易。
- en: We worked with the MQTT protocol and its publish/subscribe model to process
    commands in our board and indicate when the commands were successfully processed
    through messages. First, we worked with the PubNub cloud that works with the MQTT
    protocol under the hoods. Then, we developed the same example with Mosquitto and
    Eclipse Paho. Now, we know how we can write applications that can establish bi-directional
    communications with our IoT devices. In addition, we know how we can make IoT
    devices communicate with other IoT devices.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与 MQTT 协议及其发布/订阅模型合作，处理板上的命令，并通过消息指示命令是否成功处理。首先，我们与使用 MQTT 协议的 PubNub 云合作。然后，我们用
    Mosquitto 和 Eclipse Paho 开发了相同的示例。现在，我们知道如何编写可以与我们的物联网设备建立双向通信的应用程序。此外，我们还知道如何使物联网设备与其他物联网设备通信。
- en: Now that we are able to take advantage of many cloud services and we worked
    with the MQTT protocol, we will learn how to analyze huge amounts of data, which
    is the topic of the next chapter.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们能够利用许多云服务，并且我们已经与 MQTT 协议合作，我们将学习如何分析大量数据，这是下一章的主题。
