- en: Chapter 8. Ajax
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。Ajax
- en: In the previous chapter, we built the photoblog web interface through the use
    of HTML, DOM, and JavaScript. We have shown how a web page could be modified dynamically
    from the browser itself. However, we have not detailed the nature of this dynamism,
    neither have we explained how to retrieve data from a web application server without
    refreshing the entire web page itself. The one who can do this for us is Ajax.
    So, the goal of this chapter is to introduce the concept of Ajax.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过使用HTML、DOM和JavaScript构建了照片博客的Web界面。我们展示了如何从浏览器本身动态修改网页。然而，我们没有详细说明这种动态的本质，也没有解释如何在不刷新整个网页的情况下从Web应用服务器检索数据。能够为我们做到这一点的是Ajax。因此，本章的目标是介绍Ajax的概念。
- en: Rise of the Rich-Client Applications
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 富客户端应用的兴起
- en: Until the year 2005, the most common pattern found in web applications was one
    HTTP request per page. In other words, navigation through a website was done through
    links that triggered the retrieval through an HTTP request of the linked resource.
    This pattern is still widely used but competes now with the pattern where we have
    several HTTP requests per page. The distinction might look anecdotal, but by allowing
    the browser to issue several HTTP requests to fetch more data from one web page
    at one given URI, it offers a different yet powerful path to the web developer
    desirous of creating a more interactive application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 直到2005年，在Web应用中最常见的模式是每页一个HTTP请求。换句话说，通过触发HTTP请求来检索链接资源，通过链接在网站上导航。这种模式现在仍然被广泛使用，但与每页多个HTTP请求的模式竞争。这种区别可能看起来微不足道，但通过允许浏览器向一个给定的URI发出多个HTTP请求以获取更多数据，它为希望创建更互动应用的Web开发者提供了一条不同但强大的路径。
- en: For example, let's imagine a web application that shows a list of results by
    paging them instead of displaying them all at once. In traditional web applications,
    each time the end user went forward or backward, a new HTTP request would be sent
    to the server for the entire page to be reconstructed. In that case, the URL displayed
    in the browser address bar would also change, based on the current page viewed.
    On the other hand, imagine that instead of fetching the entire web page, only
    the new set of data to be displayed was fetched. We would still have one request
    made each time the customer moves from his or her current position, but it would
    be done without the replacement of the entire web page. The end user would have
    a lesser feeling of being governed by web pages, which could improve the overall
    experience of navigating through the set of data as well as reducing the bandwidth
    consumption.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们想象一个通过分页显示结果而不是一次性显示所有结果的Web应用。在传统的Web应用中，每次最终用户向前或向后移动时，都会向服务器发送一个新的HTTP请求来重建整个页面。在这种情况下，浏览器地址栏中显示的URL也会根据当前查看的页面而改变。另一方面，想象一下，如果不是获取整个网页，而是只获取要显示的新数据集。我们仍然会在客户从当前位置移动时发出一个请求，但不会替换整个网页。最终用户会有较少的感觉是被网页所控制，这可能会改善通过数据集导航的整体体验，同时减少带宽消耗。
- en: This simplistic example is in fact a seed for all kind of enhancements for modern
    web applications that have led to the rise of rich-client applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子实际上是一切现代Web应用增强的种子，这些增强导致了富客户端应用的兴起。
- en: Ajax
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ajax
- en: In the year 2005, Jesse James Garrett ([http://www.adaptivepath.com/publications/essays/archives/000385.php](http://www.adaptivepath.com/publications/essays/archives/000385.php))
    coined the term Ajax to designate a set of technology that he was about to present
    to one of his clients. It has since then left its original author's hands and
    is today the referenced term for what we introduced in the previous section about
    making web applications look more dynamic and interactive.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在2005年，杰西·詹姆斯·加雷特（[http://www.adaptivepath.com/publications/essays/archives/000385.php](http://www.adaptivepath.com/publications/essays/archives/000385.php)）创造了Ajax这个术语，用来指代他即将向一位客户展示的一套技术。从那时起，它已经脱离了原作者的手笔，如今成为了我们在上一节中介绍的内容——使网络应用看起来更加动态和交互的术语。
- en: '**Ajax** stands for **Asynchronous JavaScript and XML**, and covers a set of
    technologies applied to a web environment. Let''s review each part of the acronym:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ajax**代表**异步JavaScript和XML**，它涵盖了一组应用于网络环境的技术。让我们回顾一下这个缩写的每个部分：'
- en: '**Asynchronous:** In a client-server environment, there are two grand principles;
    either your operation is running synchronously to the rest of the program or not.
    If it is, then the program pauses until the operation terminates, and if it is
    not, then the operation returns immediately and lets the program continue. Once
    the operation is finished, it informs its main program through a callback function.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步：** 在客户端-服务器环境中，有两个基本原则；要么你的操作与整个程序同步运行，要么不同步。如果是，则程序暂停直到操作终止；如果不是，则操作立即返回并让程序继续。一旦操作完成，它通过回调函数通知其主要程序。'
- en: In the context of a web application, the whole purpose of Ajax is to bring more
    interactivity to the end user, which is why it broadly relies on asynchronous
    operations. Now, nothing prevents a developer from running specific operations
    synchronously to the rest of the application. This, however, can lead to the freezing
    of the entire browser, if the operation is not almost instantaneous.
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Web应用程序的背景下，Ajax的整个目的就是为最终用户提供更多的交互性，这就是为什么它广泛依赖于异步操作。现在，没有任何东西阻止开发者将特定操作同步到应用程序的其余部分。然而，如果操作不是几乎瞬时的，这可能会导致整个浏览器的冻结。
- en: '**JavaScript:** In a traditional approach where each action from the end user
    leads to a new HTTP request, this request is generated by the browser itself,
    which also consumes the HTTP response. With Ajax, the HTTP request is handled
    by a JavaScript call to an underlying HTTP API that we will review later on. Therefore,
    the web developer is in charge of creating a valid request, being able to handle
    its response, and eventually updating the end-user view of the web page.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript：** 在传统方法中，每个来自最终用户的行为都会导致一个新的HTTP请求，这个请求由浏览器本身生成，同时也消耗了HTTP响应。在Ajax中，HTTP请求由对底层HTTP
    API的JavaScript调用处理，我们将在稍后进行回顾。因此，Web开发者负责创建一个有效的请求，能够处理其响应，并最终更新最终用户的网页视图。'
- en: '**XML:** The main purpose of Ajax is to perform actions on the Document Object
    Model to either insert new content or remove parts of a web page from the end-user
    view. Ajax is based on the exchange of XML documents through HTTP. Those documents
    contain all the information and data necessary to perform the requested operation.
    Therefore, other formats of information can be used and XML is not compulsory.
    The most widespread format is JSON, which we will introduce later on.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XML：** Ajax的主要目的是在文档对象模型上执行操作，以向最终用户视图插入新内容或从网页中删除部分内容。Ajax基于通过HTTP交换XML文档。这些文档包含执行请求操作所需的所有信息和数据。因此，可以使用其他信息格式，XML不是必需的。最广泛使用的格式是JSON，我们将在稍后介绍。'
- en: Ajax—Advantages and Drawbacks
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ajax—优点和缺点
- en: 'At first sight, the concepts carried by Ajax seem really promising and they
    certainly are. Nonetheless, the technologies required can lead to unexpected issues.
    First of all, let''s review some of the advantages of Ajax:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，Ajax所承载的概念似乎非常有前途，它们确实如此。然而，所需的技术可能导致意外的问题。首先，让我们回顾一下Ajax的一些优点：
- en: 'Server and bandwidth usage reduction: In a traditional web application, where
    each page is requested in its entirety from the server, there is a resource waste
    from both the server and the network. This is because the server may have to recompute
    the page and more data is carried on the wire. In both cases, however, the sensible
    use of caching would decrease that effect.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器和带宽使用减少：在传统的Web应用程序中，每个页面都是从服务器完整请求的，这既浪费了服务器资源，也浪费了网络资源。这是因为服务器可能需要重新计算页面，并且更多的数据通过电线传输。然而，在两种情况下，合理地使用缓存都会减少这种影响。
- en: When using Ajax principles, only the needed data is fetched from the server.
    In that case, the server and intermediates could cache it. In any case, Ajax can
    reduce the load occurring on servers, as part of the processing is moved to the
    client itself.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用Ajax原则时，只需从服务器获取所需的数据。在这种情况下，服务器和中间件可以缓存它。在任何情况下，Ajax都可以减少服务器上的负载，因为部分处理被移动到客户端本身。
- en: 'General improvement of the end-user experience: Since the web page view is
    updated locally on the client side following the user''s actions, he or she may
    feel that the web application is more interactive and more responsive.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户体验的总体提升：由于网页视图是在客户端根据用户的行为本地更新的，因此用户可能会感觉到Web应用程序更加交互和响应。
- en: 'Separation of concerns enforced: Since the web developer is in charge of the
    construction of the HTTP request to be sent, he or she can decide to actually
    call different web services based on the current context of the application.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制关注点分离：由于Web开发者负责构建要发送的HTTP请求，他或她可以根据应用程序的当前上下文决定实际调用不同的Web服务。
- en: For instance, in a traditional web application an HTML form would be posted
    to the web server, which would return an HTML page. Ajax lets the developer decide
    which service will handle the user input. Therefore, the developer can call an
    Atom Publishing Protocol service that would return an Atom document that the developer
    would then handle manually. Ajax web applications can distribute their tasks among
    different specific services.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，在一个传统的Web应用中，一个HTML表单会被提交到Web服务器，服务器会返回一个HTML页面。Ajax让开发者决定哪个服务将处理用户输入。因此，开发者可以调用一个Atom发布协议服务，该服务会返回一个Atom文档，开发者随后会手动处理。Ajax
    Web应用可以在不同的特定服务之间分配其任务。
- en: 'Now let''s review the drawbacks associated with Ajax:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来回顾一下与Ajax相关的一些缺点：
- en: One of the biggest issues for web applications, based on the principles of Ajax,
    is that they by-pass the browser machinery and, therefore, the standard behavior
    of the backward and forward buttons is not assured anymore. In a more general
    way, Ajax breaks an end-user habit that has become the standard way of navigating
    the Web. For instance, the page-to-page pattern is a clear sign that the end-user
    action has triggered an operation resulting in a modification of the current state
    of the web page, whereas a web application that will modify only a part of the
    viewed page can confuse some users.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Ajax原则的Web应用最大的问题之一是它们绕过了浏览器机制，因此，后退和前进按钮的标准行为不再得到保证。从更广泛的角度来看，Ajax打破了用户已经习惯成为标准Web导航方式的习惯。例如，页面到页面的模式是用户操作触发操作并导致网页当前状态发生修改的明显标志，而只修改查看页面一部分的Web应用可能会让一些用户感到困惑。
- en: Ajax sometimes prevents users from bookmarking the pages.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ajax有时会阻止用户收藏页面。
- en: Some have raised concerns about the possible security holes brought by Ajax
    and JavaScript. However, those claims are usually made against applications that
    had a weak point, not because of JavaScript but because of the way they have designed
    a functionality. In any case, you should always weigh the potential security risks
    for your own requirements when using Ajax. For instance, never trust client-side
    form validation only; make sure you validate any incoming data on the server side
    and keep client-side validation to minimize round-trip HTTP exchanges.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些人对Ajax和JavaScript可能带来的安全漏洞表示担忧。然而，这些说法通常是对那些有弱点但并非由于JavaScript而是由于设计功能的方式的应用程序提出的。无论如何，在使用Ajax时，你应该始终权衡你自己的需求可能带来的潜在安全风险。例如，永远不要仅信任客户端表单验证；确保在服务器端验证任何传入的数据，并将客户端验证保持在最低限度以减少往返HTTP交换。
- en: Generally, the pitfall regarding the use of Ajax in a web application is its
    overuse. Although this is a fairly subjective topic, the abuse of Ajax is frowned
    upon when it does not improve the end-user experience as compared to a more traditional
    approach. Our photoblog application will use Ajax fairly heavily.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Web应用中使用Ajax的陷阱是其过度使用。尽管这是一个相当主观的话题，但当Ajax的使用没有比更传统的方法改善最终用户体验时，滥用Ajax是不被看好的。我们的相册应用将相当多地使用Ajax。
- en: 'Behind the Scene: XMLHttpRequest'
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背后场景：`XMLHttpRequest`
- en: As we have seen, Ajax is based on the idea of sending HTTP requests using JavaScript;
    more specifically Ajax relies on the `XMLHttpRequest` object and its API to perform
    those operations. This object was first designed and implemented by Microsoft
    engineers as an ActiveX control available to Outlook Express and Internet Explorer,
    but it was not heavily used before the rise of Ajax and rich web applications.
    XMLHttpRequest is now part of every modern browser and is so widely used that
    the W3C has notably set up a working group to specify the boundaries of this object
    to provide the minimum interoperability requirements across implementations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Ajax基于使用JavaScript发送HTTP请求的理念；更具体地说，Ajax依赖于`XMLHttpRequest`对象及其API来执行这些操作。这个对象最初是由微软工程师设计和实现的，作为一个ActiveX控件，可供Outlook
    Express和Internet Explorer使用，但在Ajax和丰富Web应用兴起之前，它并没有被广泛使用。现在，`XMLHttpRequest`是每个现代浏览器的一部分，其使用如此广泛，以至于W3C特别成立了一个工作组来指定这个对象的范围，以提供跨实现的最小互操作性要求。
- en: 'Let''s review the XMLHttpRequest interface specified by W3C, as it provides
    the most common attributes and functions implemented by browser vendors:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下W3C指定的XMLHttpRequest接口，因为它提供了浏览器厂商实现的最常见的属性和函数：
- en: '| Attributes | Description |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `readyState` | Read-only attribute carrying the current status of the object:`0:`
    Uninitialized`1:` Open`2:` Sent`3:` Receiving`4:` Loaded |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `readyState` | 只读属性，表示对象当前的状态：`0:` 未初始化`1:` 打开`2:` 已发送`3:` 接收`4:` 已加载|'
- en: '| `onreadystatechange` | An EventListener is called when the `readyState` attribute
    changes. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `onreadystatechange` | 当 `readyState` 属性改变时，会调用一个 EventListener。|'
- en: '| `responseText` | Contains the received bytes so far from the server as a
    string |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `responseText` | 包含从服务器接收到的字节，以字符串形式表示|'
- en: '| `responseXML` | If the `content-type` of the response was one associated
    with XML (`text/xml, application/xml`, or `+xml)`, this contains an instance of
    the received document. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `responseXML` | 如果响应的 `content-type` 是与XML相关联的类型（`text/xml, application/xml`
    或 `+xml`），则包含接收到的文档的实例。|'
- en: '| `status` | The HTTP response code |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `status` | HTTP响应代码|'
- en: '| `statusText` | The HTTP response text |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `statusText` | HTTP响应文本|'
- en: '| Methods | Description |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `abort()` | Cancels the underlying network connection with the server. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `abort()` | 取消与服务器的基本网络连接。|'
- en: '| `getAllReponseHeaders()` | Returns a string of all HTTP response headers
    separated by a new line. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `getAllReponseHeaders()` | 返回一个由换行符分隔的所有HTTP响应头的字符串。|'
- en: '| `getResponseHeader(header)` | Returns the value of the header if present
    in the response. An empty string otherwise. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `getResponseHeader(header)` | 如果响应中存在该头，则返回其值。否则返回空字符串。|'
- en: '| `setRequestHeader(header, value)` | Sets an HTTP header for the underlying
    request. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `setRequestHeader(header, value)` | 为基本请求设置HTTP头。|'
- en: '| `open(method, uri, async, user, password)` | Initializes the object:`method:`
    the HTTP method to be used for the request`uri:` the URI on which the request
    is applied`async:` a Boolean indicating whether this request must be synchronous
    with the rest of the program or not`username` and `password:` provide the credentials
    to access the resource |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `open(method, uri, async, user, password)` | 初始化对象：`method:` 请求要使用的HTTP方法`uri:`
    请求应用的URI`async:` 一个布尔值，指示此请求是否必须与程序的其余部分同步`username` 和 `password:` 提供访问资源的凭据|'
- en: '| `send(data)` | Realizes the HTTP connection and sets the request body with
    data if provided. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `send(data)` | 实现HTTP连接，如果提供了数据，则设置请求体。|'
- en: The API is fairly straightforward and simple. Let's go through various examples
    using the MochiKit Async module.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: API相当直接和简单。让我们通过使用MochiKit Async模块的各个示例来了解。
- en: Performing a GET Request
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行GET请求
- en: 'The `GET` request is as shown:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`请求如下所示：'
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we will see what we have actually done:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到我们实际上做了什么：
- en: 1\. As each browser has its own API for the developer who wishes to instantiate
    an XMLHttpRequest, Mochikit provides the `getXMLHttpRequest()` function that will
    return the correct object by checking which browser the end user is using.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 由于每个浏览器都有自己的API供开发者实例化XMLHttpRequest，Mochikit提供了`getXMLHttpRequest()`函数，该函数将根据检查最终用户使用的浏览器返回正确的对象。
- en: 2\. We then initialize the object with required values. In this case, we want
    to perform a `GET` request against the "/" URI of the current host in an asynchronous
    fashion.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 然后我们使用所需值初始化对象。在这种情况下，我们想要以异步方式对当前主机的"/" URI执行`GET`请求。
- en: 3\. Then we inform the server that it must close the connection as soon as it
    finishes with our request and has sent us its response.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 然后我们通知服务器，它必须在完成我们的请求并发送我们的响应后关闭连接。
- en: 4\. Then we use the Mochikit `sendXMLHttpRequest()` function that returns a
    deferred object. This object offers the developer a clean API to handle the different
    states that an `XMLHttpRequest` object can take during the processing.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 然后我们使用Mochikit的`sendXMLHttpRequest()`函数，该函数返回一个延迟对象。此对象为开发者提供了一个干净的API来处理`XMLHttpRequest`对象在处理过程中可能采取的不同状态。
- en: a. We add a callback that will be applied if the response status code indicates
    a success (typically in the 2xx and 3xx ranges of HTTP).
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 如果响应状态码指示成功（通常在HTTP的2xx和3xx范围内），则添加一个回调。
- en: b. We also associate an error callback that will be applied when the response
    indicates an error (typically in the 4xx and 5xx ranges of HTTP).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 我们还关联了一个错误回调，当响应指示错误时（通常在HTTP的4xx和5xx范围内）将应用此回调。
- en: 5\. The `data` parameter that each callback must take is the entity body included
    in the response, which can then be processed by the callback.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5. 每个回调必须接受的 `data` 参数是响应中包含的实体主体，然后可以由回调处理。
- en: Performing a Content-Negotiated GET Request
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行内容协商 GET 请求
- en: 'This `GET` request is as shown:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `GET` 请求如下所示：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this request, we inform the server that we are willing to accept content
    that is represented using the Atom format and which uses the French language.
    A server that is unable to handle this request could respond with `406 Not Acceptable`,
    and therefore the error callback would be applied.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个请求中，我们通知服务器我们愿意接受使用 Atom 格式表示并使用法语表示的内容。无法处理此请求的服务器可能会以 `406 Not Acceptable`
    响应，因此将应用错误回调。
- en: Performing a POST Request
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行 POST 请求
- en: 'The `POST` request is as shown:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `POST` 请求如下所示：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we will see what we have actually done:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到我们实际上做了什么：
- en: '1\. We post some data in the form of an encoded query string. The `queryString(data)`
    function takes an associative array of key values and returns an encoded string
    of the form: `key1=value1?key2=value2`.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 我们以编码查询字符串的形式发布一些数据。`queryString(data)` 函数接受一个键值对的关联数组，并返回一个形式为 `key1=value1?key2=value2`
    的编码字符串。
- en: 2\. We initialize the `XMLHttpRequest` object.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 我们初始化 `XMLHttpRequest` 对象。
- en: '3\. We specify the content-type of our request entity body: `application/x-www-form-urlencoded`'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 我们指定请求实体主体的内容类型：`application/x-www-form-urlencoded`
- en: 4\. Then we request a deferred object from `sendXMLHttpRequest`, but as you
    can see we also pass the data we wish to send.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 然后，我们从 `sendXMLHttpRequest` 请求一个延迟对象，但如您所见，我们还传递了我们希望发送的数据。
- en: Let's POST an XML Document
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 让我们发布一个 XML 文档
- en: 'This is how we will do it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将如何做的：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Performing PUT, HEAD, or DELETE Requests
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行 PUT、HEAD 或 DELETE 请求
- en: Unlike HTML forms, XMLHttpRequest is not limited in terms of supported HTTP
    methods that it recognizes. In fact, XMLHttpRequest does not pay attention to
    the method that you use and does not interpret it. The method you use is sent
    as it is to the server. This is extremely important in web services based on REST
    or the Atom Publishing Protocol, as we have seen in the previous chapters.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与 HTML 表单不同，XMLHttpRequest 在支持的 HTTP 方法方面没有限制。实际上，XMLHttpRequest 不关注您使用的方法，也不对其进行解释。您使用的方法会原样发送到服务器。这在基于
    REST 或 Atom 发布协议的 Web 服务中非常重要，正如我们在前面的章节中看到的。
- en: Cookies
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cookies
- en: Cookies are sent along with the request, automatically by the user agent hosting
    XMLHttpRequest; therefore, there is no specific action for the developer to take.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Cookies 会自动与请求一起发送，由托管 XMLHttpRequest 的用户代理完成；因此，开发者无需采取任何特定操作。
- en: Authentication using Digest or Basic Schemes
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用摘要或基本方案进行身份验证
- en: 'The `open()` method of XMLHttpRequest can take `username` and `password` parameters
    to be sent along with the request. The authentication schemes supported by XMLHttpRequest
    are defined in RFC 2617, namely *basic* and *digest*. These two schemes are as
    follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: XMLHttpRequest 的 `open()` 方法可以接受 `username` 和 `password` 参数，这些参数将与请求一起发送。XMLHttpRequest
    支持的身份验证方案由 RFC 2617 定义，即 *基本* 和 *摘要*。这两个方案如下：
- en: 'Basic scheme: The basic scheme is simply the transfer of the username and password
    encoded using the base64 algorithm. The issue with this is that, if a third-party
    fetches the encoded value, nothing can be done to prevent it from being decoded.
    This is why the basic is often referred as sending the password in clear text,
    because the applied encoding can be decoded very easily. It is therefore not a
    secure authentication scheme unless it is used on a secured protocol such as HTTPS.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本方案：基本方案只是使用 base64 算法对用户名和密码进行编码的传输。问题是，如果第三方获取了编码值，就无法阻止它被解码。这就是为什么基本方案通常被称为明文发送密码，因为应用的编码可以非常容易地被解码。因此，除非在
    HTTPS 等安全协议上使用，否则这不是一个安全的身份验证方案。
- en: 'Digest scheme: The digest scheme, on the other hand, does not send the password
    as it is across the wire. Instead, both the parties apply the same algorithm using
    the password and other seeds to compute a digest value of those. The server also
    sends the seed value on the first request to *tag* that request. The client sends
    back the computation of the digest algorithm to the server, which compares it
    with its own computation. If the two match, the request is allowed. This scheme
    is safer than the basic one, as the password is actually never sent onto the wire
    in a form that can be decrypted in a reasonable amount of time.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摘要方案：另一方面，摘要方案不会将密码作为明文发送。相反，双方使用密码和其他种子应用相同的算法来计算这些值的摘要。服务器也会在第一次请求时发送种子值来
    *标记* 该请求。客户端将摘要算法的计算结果发送回服务器，服务器将其与自己的计算结果进行比较。如果两者匹配，则允许请求。这个方案比基本方案更安全，因为密码实际上从未以可以被合理时间内解密的形式发送到线上。
- en: 'By default, when using those schemes, a browser would open a pop-up window
    asking for a username and a password. In the context of request issued by a JavaScript
    call to XMLHttpRequest, it is possible to avoid that pop up by providing the user
    credentials directly to the `open()` method. Obviously, it is out of question
    to hardcode them into the JavaScript code. Instead, it is fairly easy to integrate
    an HTML form into the web application and to dynamically pass the input values
    to the JavaScript call, as the following example demonstrates:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当使用这些方案时，浏览器会弹出一个窗口请求用户名和密码。在由 JavaScript 调用 XMLHttpRequest 发出的请求的上下文中，可以通过直接将用户凭据提供给
    `open()` 方法来避免该弹出窗口。显然，将它们硬编码到 JavaScript 代码中是不合适的。相反，将 HTML 表单集成到网络应用程序中并将输入值动态传递给
    JavaScript 调用相当简单，以下示例将演示这一点：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The CherryPy script that would serve the previous page could look like:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 CherryPy 脚本示例，它将提供前面的页面：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When you access [http://localhost:8080/](http://localhost:8080/), you should
    get the following page:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你访问 [http://localhost:8080/](http://localhost:8080/) 时，你应该看到以下页面：
- en: '![Authentication using Digest or Basic Schemes](img/1848_08_01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![使用摘要或基本方案进行身份验证](img/1848_08_01.jpg)'
- en: 'If you enter the username `test` and password `test`, you will get the following
    view on your screen:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入用户名 `test` 和密码 `test`，你将在屏幕上看到以下视图：
- en: '![Authentication using Digest or Basic Schemes](img/1848_08_02.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![使用摘要或基本方案进行身份验证](img/1848_08_02.jpg)'
- en: 'On the other hand, if you provide wrong values, you would get a screen like
    this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你提供错误值，你将看到如下屏幕：
- en: '![Authentication using Digest or Basic Schemes](img/1848_08_03.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![使用摘要或基本方案进行身份验证](img/1848_08_03.jpg)'
- en: Unfortunately, the browser receives the message from the server about the authentication
    failure with `401 HTTP error code` and handles it itself. As of today, there is
    no cross-browser way to avoid that issue so that the pop up does not appear. If
    you hit the **Cancel** button of the pop up, the browser then goes back to your
    JavaScript code and the error callback is applied.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，浏览器从服务器接收关于身份验证失败的 `401 HTTP 错误代码` 的消息，并自行处理。截至目前，没有跨浏览器的解决方案可以避免这个问题，使得弹出窗口不会出现。如果你点击弹出窗口的
    **取消** 按钮，浏览器随后将返回到你的 JavaScript 代码，并应用错误回调。
- en: Moreover, since you cannot access the underlying session through the `XMLHttpRequest`
    object as it is handled by the browser, you cannot force a logout by suppressing
    the session credentials. The user has to close down the browser to disconnect
    from the application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于你不能通过 `XMLHttpRequest` 对象访问底层会话（因为它由浏览器处理），你不能通过抑制会话凭据来强制注销。用户必须关闭浏览器才能与应用程序断开连接。
- en: Consequently, although XMLHttpRequest allows you to provide a fancier way to
    enable basic and digest authentication in your web application, there are still
    some pitfalls that need to be acknowledged.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管 XMLHttpRequest 允许你在网络应用程序中提供一种更花哨的方式来启用基本和摘要身份验证，但仍然有一些陷阱需要承认。
- en: JSON
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON
- en: As we have already seen in this chapter, in spite of carrying XML in its name,
    Ajax does not prevent other formats being carried. For instance, one extremely
    common format that you will see is **JSON** (**JavaScript Object Notation**).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中已经看到的，尽管 Ajax 的名字中带有 XML，但它并不阻止传输其他格式。例如，你将看到的一个极其常见的格式是 **JSON**（**JavaScript
    对象表示法**）。
- en: In a nutshell, JSON is a way to carry serialized JavaScript objects so that
    a JavaScript application can evaluate them and transform them into JavaScript
    objects that the application can manipulate.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，JSON 是一种携带序列化 JavaScript 对象的方式，以便 JavaScript 应用程序可以评估它们并将它们转换为应用程序可以操作的对象。
- en: 'For instance, when the user requests the server for an `album` object formatted
    with the JSON format, the server would return the following content:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当用户请求以 JSON 格式格式化的 `album` 对象时，服务器将返回以下内容：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We then use the `evalJSONRequest()` function from Mochikit, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用 Mochikit 中的 `evalJSONRequest()` 函数，如下所示：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now the data is a JavaScript associative array and the description field can
    be accessed via:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据是一个 JavaScript 关联数组，描述字段可以通过以下方式访问：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: JSON is widely deployed because it is simple, easy to use, and efficient to
    construct or evaluate. It does support all the common basic types such as numbers,
    Booleans, arrays, strings, or the null object. More complex objects are translated
    into associative arrays, where object attribute names serve as keys to access
    their associated value.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 得到广泛应用，因为它简单、易用且构建或评估效率高。它支持所有常见的基类型，如数字、布尔值、数组、字符串或空对象。更复杂的对象被转换为关联数组，其中对象属性名作为键来访问其关联的值。
- en: The photoblog application will mainly use the JSON format in its operations.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: photoblog 应用程序在其操作中主要使用 JSON 格式。
- en: When your CherryPy application relies heavily on JSON, it may be interesting
    to write a tool to automatically perform the JSON serialization and deserialization.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的 CherryPy 应用程序大量依赖 JSON 时，编写一个自动执行 JSON 序列化和反序列化的工具可能很有趣。
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We create two tools using the simple JSON module to perform the conversion.
    The first one deserializes the request body from JSON only on POST and PUT requests
    that have the `application/json` content-type set. The tool loads the request
    body and transforms it into a dictionary, which is thereafter injected in the
    `params` attribute of the `cherrypy.request` object allowing CherryPy page handlers
    to expect keys of the JSON dictionary as regular parameters, as you can see in
    the process page handler. Note that we must encode those keys into Python strings
    from Unicode because CherryPy page handlers expect strings.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用简单的 JSON 模块创建了两个工具来执行转换。第一个工具仅在设置了 `application/json` 内容类型的 POST 和 PUT 请求上从
    JSON 反序列化请求体。该工具加载请求体并将其转换为字典，然后将其注入到 `cherrypy.request` 对象的 `params` 属性中，使得 CherryPy
    页面处理程序可以期望 JSON 字典的键作为常规参数，正如你在过程页面处理程序中看到的那样。请注意，我们必须将这些键从 Unicode 编码为 Python
    字符串，因为 CherryPy 页面处理程序期望字符串。
- en: The second tool takes the dictionary returned by a page handler and serializes
    it into JSON.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个工具将页面处理程序返回的字典序列化为 JSON。
- en: Applying Ajax to our Application
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Ajax 应用于我们的应用程序
- en: Our photoblog application will use Ajax fairly extensively, and to explain this
    we will review how to handle the albums of the photoblog.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 photoblog 应用程序将广泛使用 Ajax，为了解释这一点，我们将回顾如何处理 photoblog 的相册。
- en: Defining the Required Namespaces
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义所需的命名空间
- en: Our first step will be to define the JavaScript namespaces that will allow us
    to reuse common function names in different contexts while avoiding name collision.
    Using the term namespace is slightly unexpected because JavaScript does not have
    that notion per se, but it is possible to emulate this feature in a number of
    ways. In the case of this application, we will be using JavaScript inheritance
    that is simple enough to implement our requirement.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步将是定义 JavaScript 命名空间，这将允许我们在不同的上下文中重用常见的函数名，同时避免命名冲突。使用“命名空间”这个术语稍微有些出乎意料，因为
    JavaScript 本身并没有这个概念，但可以通过多种方式来模拟这个功能。在本应用的情况下，我们将使用足够简单的 JavaScript 继承来实现我们的需求。
- en: 'The two namespaces that the photoblog application will use are: `ui` and `services`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: photoblog 应用程序将使用的两个命名空间是：`ui` 和 `services`。
- en: The `ui` namespace will cover the different interactions with the end user,
    while the `services` namespace will take care of exchanging data with the server.
    The `ui` namespace classes and functions will therefore call the `services` ones
    to perform operations requested by the end user.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`ui` 命名空间将涵盖与最终用户的各种交互，而 `services` 命名空间将负责与服务器交换数据。因此，`ui` 命名空间中的类和函数将调用 `services`
    中的函数来执行最终用户请求的操作。'
- en: 'To implement these two namespaces, we will simply define two empty JavaScript
    functions as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这两个命名空间，我们只需定义两个空 JavaScript 函数，如下所示：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Implementing Namespaces
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现命名空间
- en: 'We now have our functions and we can add attributes to them. Here we have the
    album class declaration that will handle all aspects of the album entity from
    a client-side point of view:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的函数，我们可以给它们添加属性。这里我们有专辑类的声明，它将处理从客户端视角的专辑实体的所有方面：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we first create a regular JavaScript function that is used as the constructor
    of an `album` class. We also declare a few attributes attached to that object
    via the JavaScript keyword `this`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先创建一个常规JavaScript函数，用作`album`类的构造函数。我们还通过JavaScript关键字`this`声明了一些附加到该对象上的属性。
- en: Then we add an `albums` instance as an attribute of the `ui` function object
    prototype and we finally create the unique instance of the `ui` class that we
    will use throughout the life of the application within the session of the user.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将`albums`实例作为`ui`函数对象原型的属性，并最终在用户会话中创建我们将在整个应用程序生命周期中使用的`ui`类的唯一实例。
- en: 'From now on we can use the `albums` instance to call its `edit` method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，我们可以使用`albums`实例来调用它的`edit`方法：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We then define similarly the `album` class within the `services` namespace.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`services`命名空间内类似地定义`album`类。
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Adding Methods to the Classes
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向类中添加方法
- en: 'The first method that we will add to our classes will be the one that toggles
    the visibility state of our albums container. This container will display information
    about existing albums and will fade in or fade out when the user clicks on the
    associated link. Let''s see how to add methods:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要添加到我们的类中的第一个方法将是切换我们专辑容器可见状态的方法。这个容器将显示现有专辑的信息，并在用户点击相关链接时淡入或淡出。让我们看看如何添加方法：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This method first toggles the visibility of the content panel that contains
    the current photograph. Then if the toggle means to open the `albums` panel, we
    set its visibility to `true` and we call the `forward` method. Otherwise, we set
    the visibility to `false` and we delete any elements attached to that container
    so that they don''t waste memory. Finally, we request Mochikit to change the visibility
    state of the `albums` panel. We then connect that method to the `onclick` signal
    of the associated link as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法首先切换包含当前照片的内容面板的可见性。然后如果切换意味着打开`albums`面板，我们将它的可见性设置为`true`并调用`forward`方法。否则，我们将可见性设置为`false`并删除附加到该容器的任何元素，这样它们就不会浪费内存。最后，我们请求Mochikit更改`albums`面板的可见状态。然后我们将该方法连接到相关链接的`onclick`信号，如下所示：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `forward` method is defined as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`forward`方法定义如下：'
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The method first defines the range of albums we will need to fetch from the
    server. Then we call the `fetch_range()` method of the `services.albums` object,
    and we finally set the new starting position for the next call to that method.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法首先定义了我们将从服务器获取的专辑范围。然后我们调用`services.albums`对象的`fetch_range()`方法，并最终设置下一次调用该方法的起始位置。
- en: 'Let''s now review the `services.albums` object itself:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来回顾一下`services.albums`对象本身：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You may notice that this method takes an extra parameter named `src`, which
    is the calling object so that our callbacks can apply methods on that object when
    receiving a response from the server.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到这个方法接受一个额外的参数，名为`src`，它是调用对象，这样我们的回调就可以在从服务器收到响应时在该对象上应用方法。
- en: The requested URI `albumsBaseUri.concat(start, "-", end). albumsBaseUri`, is
    a global string variable containing the base URI for performing requests against
    collections of albums.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的URI `albumsBaseUri.concat(start, "-", end). albumsBaseUri`是一个全局字符串变量，包含执行针对专辑集合的请求的基本URI。
- en: We specify that we would prefer the server to send us back a JSON content, as
    this is what we will be using to populate the retrieved albums.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定我们希望服务器发送给我们JSON内容，因为这是我们用来填充检索到的专辑的内容。
- en: 'The request issued would look like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 发出的请求看起来像这样：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And its response would be:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 其响应将是：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The returned content would be then evaluated by the MochiKit function `evalJSONRequest()`
    to return an instance of JavaScript objects; in this case an array of associative
    arrays. Once we have received and evaluated the content, we call the `populate()`
    method of the `ui.album` class to display the retrieved albums. This method is
    defined as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的内容将由MochiKit函数`evalJSONRequest()`评估，以返回一个JavaScript对象实例；在这种情况下是一个关联数组的数组。一旦我们收到并评估了内容，我们就调用`ui.album`类的`populate()`方法来显示检索到的专辑。该方法定义如下：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Method to Create a New Album
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新专辑的方法
- en: Now that we can display albums, we will review how to create a new album. To
    do so, we first need a form to gather the user input. Let's explain the `ui.albums.blank()`
    method that is in charge of displaying the form by dynamically inserting it into
    the DOM tree.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够显示相册了，我们将回顾如何创建一个新的相册。要做到这一点，我们首先需要一个表单来收集用户输入。让我们解释一下负责通过动态将其插入DOM树来显示表单的`ui.albums.blank()`方法。
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The creation of the form block requires further explanation. In order to provide
    a fancier panel carrying the form, we use the technique deployed in scripts such
    as *Lightbox* or *Thickbox*. Both rely on the overlay capabilities of CSS applied
    to the DOM to display elements on top of others. Overlays allow displaying elements
    not in a sequential fashion but as a pile. This feature associated with a sensible
    use of HTML blocks as `DIVs` and appropriate colors can provide an attractive
    way to display the content, as the following screenshot demonstrates:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表单块的创建需要进一步解释。为了提供一个带有表单的更华丽的面板，我们使用了在*Lightbox*或*Thickbox*等脚本中部署的技术。两者都依赖于CSS应用于DOM的覆盖能力来显示在其它元素之上的元素。覆盖允许以非顺序方式显示元素，而不是堆叠。这个功能结合了合理使用HTML块作为`DIV`和适当的颜色，可以提供一种吸引人的内容展示方式，如下面的截图所示：
- en: '![Method to Create a New Album](img/1848_08_04.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![创建新相册的方法](img/1848_08_04.jpg)'
- en: 'If you do not fill the required fields and submit the form, you will end up
    with a screen as displayed in the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不填写必填字段并提交表单，您将看到以下截图所示的屏幕：
- en: '![Method to Create a New Album](img/1848_08_05.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![创建新相册的方法](img/1848_08_05.jpg)'
- en: 'If you fill the required fields and submit the form, you would get a screen
    as shown:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您填写了必填字段并提交了表单，您将看到以下截图所示的屏幕：
- en: '![Method to Create a New Album](img/1848_08_06.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![创建新相册的方法](img/1848_08_06.jpg)'
- en: In order to avoid the situation where the user tries to re-submit the form,
    we remove the **Submit** link and the user can now safely close this screen.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免用户尝试重新提交表单的情况，我们移除了**提交**链接，现在用户可以安全地关闭这个屏幕。
- en: 'The HTTP exchange will look like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP交换将看起来像这样：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that the response gives us the URI to directly access the newly created
    album.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，响应给出了直接访问新创建相册的URI。
- en: 'The method to handle the previous HTTP exchange is `services.album.create()`,
    as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 处理之前HTTP交换的方法是`services.album.create()`，如下所示：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `data` parameter is a JavaScript associative array of the form fields.
    The `src` parameter is the `ui.albums` instance, which is extended with the following
    methods:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`参数是表单字段的JavaScript关联数组。`src`参数是`ui.albums`实例，它扩展了以下方法：'
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Method to Update an Existing Album
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新现有相册的方法
- en: This follows the same principles as we have seen in the previous section, except
    that we provide an `album` object to fill the form automatically with its values.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循了我们之前章节中看到的相同原则，只不过我们提供了一个`album`对象来自动填充表单的值。
- en: Method to Delete an Existing Album
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除现有相册的方法
- en: 'Finally, we need a method to delete an album:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个方法来删除一个相册：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The HTTP exchange would look like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP交换看起来将是这样：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have explained the basic methods to manipulate albums of the photoblog application.
    The same principles will be applied for the other entities of the application:
    film and photo.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解释了如何操作照片博客应用中的相册的基本方法。相同的原理将应用于应用的其他实体：电影和照片。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has introduced you to Ajax and more generally to the basics of
    client-side programming using JavaScript. The possibilities are almost endless
    and the near future should see extremely interesting and powerful web applications
    that will slowly take the place of their rich-client counterparts.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了Ajax，以及更广泛地介绍了使用JavaScript进行客户端编程的基础。可能性几乎是无限的，并且不久的将来应该会看到非常有趣和强大的网络应用，它们将逐渐取代它们的富客户端对应物。
