- en: Trees
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树
- en: A tree is a hierarchical form of data structure. When we dealt with lists, queues,
    and stacks, items followed each other. But in a tree, there is a *parent-child*
    relationship between items.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 树是一种层次化的数据结构。当我们处理列表、队列和栈时，项目是依次跟随的。但在树中，项目之间存在 *父子* 关系。
- en: To visualize what trees look like, imagine a tree growing up from the ground.
    Now remove that image from your mind. Trees are normally drawn downward, so you
    would be better off imagining the root structure of the tree growing downward.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要可视化树的外观，想象一棵从地面生长起来的树。现在从你的脑海中移除那个图像。树通常向下绘制，所以你最好想象树的根结构向下生长。
- en: At the top of every tree is the so-called *root node*. This is the ancestor
    of all other nodes in the tree.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每棵树的顶部都有所谓的 *根节点*。这是树中所有其他节点的祖先。
- en: Trees are used for a number of things, such as parsing expressions, and searches.
    Certain document types, such as XML and HTML, can also be represented in a tree
    form. We shall look at some of the uses of trees in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 树被用于许多事情，例如解析表达式和搜索。某些文档类型，如 XML 和 HTML，也可以以树的形式表示。在本章中，我们将探讨树的一些用途。
- en: 'In this chapter, we will cover the following areas:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Terms and definitions of trees
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树的术语和定义
- en: Binary trees and binary search trees
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉树和二叉搜索树
- en: Tree traversal
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树遍历
- en: Terminology
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 术语
- en: Let's consider some terms associated with trees.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些与树相关的术语。
- en: To understand trees, we need to first understand the basic ideas on which they
    rest. The following figure contains a typical tree consisting of character nodes
    lettered **A** through to **M**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解树，我们首先需要理解它们所基于的基本概念。以下图包含一个典型的树，由字母节点 **A** 到 **M** 组成。
- en: '![](img/CH_06_01.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/CH_06_01.png)'
- en: 'Here is a list of terms associated with a Tree:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个与树相关的术语列表：
- en: '**Node**: Each circled alphabet represents a node. A node is any structure
    that holds data.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**：每个圆圈中的字母代表一个节点。节点是任何包含数据的结构。'
- en: '**Root node**: The root node is the only node from which all other nodes come.
    A tree with an undistinguishable root node cannot be considered as a tree. The
    root node in our tree is the node A.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根节点**：根节点是从中产生所有其他节点的唯一节点。如果一个树没有可区分的根节点，则不能将其视为树。我们树中的根节点是节点 A。'
- en: '**Sub-tree**: A sub-tree of a tree is a tree with its nodes being a descendant
    of some other tree. Nodes F, K, and L form a sub-tree of the original tree consisting
    of all the nodes.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子树**：树的子树是具有其节点为其他树的后代的一些树的树。节点 F、K 和 L 形成了原始树（包含所有节点）的子树。'
- en: '**Degree**: The number of sub-trees of a given node. A tree consisting of only
    one node has a degree of 0\. This one tree node is also considered as a tree by
    all standards. The degree of node A is 2.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**度**：给定节点的子树数量。仅由一个节点组成的树具有度为 0。这个单一树节点在所有标准下也被认为是树。节点 A 的度数为 2。'
- en: '**Leaf node**: This is a node with a degree of 0\. Nodes J, E, K, L, H, M,
    and I are all leaf nodes.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**叶节点**：这是一个度为 0 的节点。节点 J、E、K、L、H、M 和 I 都是叶节点。'
- en: '**Edge**: The connection between two nodes. An edge can sometimes connect a
    node to itself, making the edge appear as a loop.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边**：两个节点之间的连接。有时边可以连接一个节点到自身，使边看起来像是一个环。'
- en: '**Parent**: A node in the tree with other connecting nodes is the parent of
    those nodes. Node B is the parent of nodes D, E, and F.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父节点**：树中带有其他连接节点的节点是这些节点的父节点。节点 B 是节点 D、E 和 F 的父节点。'
- en: '**Child**: This is a node connected to its parent. Nodes B and C are children
    of node A, the parent and root node.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子节点**：这是连接到其父节点的节点。节点 B 和 C 是节点 A（父节点和根节点）的子节点。'
- en: '**Sibling**: All nodes with the same parent are siblings. This makes the nodes
    B and C siblings.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兄弟节点**：所有具有相同父节点的节点都是兄弟节点。这使得节点 B 和 C 成为兄弟节点。'
- en: '**Level**: The level of a node is the number of connections from the root node.
    The root node is at level 0\. Nodes B and C are at level 1.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**级别**：节点的级别是从根节点到该节点的连接数量。根节点位于级别 0。节点 B 和 C 位于级别 1。'
- en: '**Height of a tree**: This is the number of levels in a tree. Our tree has
    a height of 4.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**树的高度**：这是树中的层数。我们的树的高度为 4。'
- en: '**Depth**: The depth of a node is the number of edges from the root of the
    tree to that node. The depth of node H is 2.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度**：节点的深度是从树的根到该节点的边的数量。节点 H 的深度为 2。'
- en: We shall begin our treatment of trees by considering the node in a tree and
    abstracting a class.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过对树中的节点进行考虑并抽象出一个类来开始我们对树的讨论。
- en: Tree nodes
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树节点
- en: Just as was the case with other data structures that we encountered, such as
    lists and stacks, trees are built up of nodes. But the nodes that make up a tree
    need to contain data about the parent-child relationship that we mentioned earlier.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前遇到的其他数据结构一样，例如列表和栈，树是由节点组成的。但构成树的节点需要包含我们之前提到的父子关系的数据。
- en: 'Let us now look at how to build a binary tree `node` class in Python:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看如何在 Python 中构建一个二叉树 `node` 类：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Just like in our previous implementations, a node is a container for data and
    holds references to other nodes. Being a binary tree node, these references are
    to the left and the right children.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前的实现一样，节点是数据的容器，并持有对其他节点的引用。作为一个二叉树节点，这些引用是对左子节点和右子节点的引用。
- en: 'To test this class out, we first create a few nodes:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个类，我们首先创建几个节点：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we connect the nodes to each other. We let `n1` be the root node with
    `n2` and `n3` as its children. Finally, we hook `n4` as the left child to `n2`,
    so that we get a few iterations when we traverse the left sub-tree:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将节点连接起来。我们让 `n1` 作为根节点，`n2` 和 `n3` 作为其子节点。最后，我们将 `n4` 作为 `n2` 的左子节点连接起来，这样当我们遍历左子树时就会得到几个迭代：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once we have our tree structure set up, we are ready to traverse it. As mentioned
    previously, we shall traverse the left sub-tree. We print out the node and move
    down the tree to the next left node. We keep doing this until we have reached
    the end of the left sub-tree:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了树结构，我们就可以遍历它了。如前所述，我们将遍历左子树。我们打印出节点，并沿着树向下移动到下一个左节点。我们一直这样做，直到我们到达左子树的末尾：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you will probably have noticed, this requires quite a bit of work in the
    client code, as you have to manually build up the tree structure.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这需要在客户端代码中做相当多的工作，因为你必须手动构建树结构。
- en: Binary trees
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉树
- en: A binary tree is one in which each node has a maximum of two children. Binary
    trees are very common and we shall use them to build up a BST implementation in
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树是一种每个节点最多有两个子节点的树。二叉树非常常见，我们将使用它们来构建 BST 的实现。
- en: Python.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Python.
- en: 'The following figure is an example of a binary tree with 5 being the root node:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个以 5 为根节点的二叉树的示例：
- en: '![](img/image_06_001.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_001.jpg)'
- en: Each child is identified as being the right or left child of its parent. Since
    the parent node is also a node by itself, each node will hold a reference to a
    right and left node even if the nodes do not exist.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子节点都被标识为其父节点的右子节点或左子节点。由于父节点本身也是一个节点，每个节点都将持有对右节点和左节点的引用，即使这些节点不存在。
- en: A regular binary tree has no rules as to how elements are arranged in the tree.
    It only satisfies the condition that each node should have a maximum of two children.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常规的二叉树没有关于元素如何排列在树中的规则。它只满足每个节点最多有两个子节点的条件。
- en: Binary search trees
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: A **binary search tree** (**BST**) is a special kind of a binary tree. That
    is, it is a tree that is structurally a binary tree. Functionally, it is a tree
    that stores its nodes in such a way to be able to search through the tree efficiently.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**二叉搜索树**（**BST**）是一种特殊的二叉树。也就是说，它是一个结构上是二叉树的树。功能上，它是一个以能够高效搜索树的方式存储其节点。'
- en: 'There is a structure to a BST. For a given node with a value, all the nodes
    in the left sub-tree are less than or equal to the value of that node. Also, all
    the nodes in the right sub-tree of this node are greater than that of the parent
    node. As an example, consider the following tree:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: BST 有一种结构。对于给定值的节点，左子树中的所有节点都小于或等于该节点的值。同样，该节点的右子树中的所有节点都大于其父节点的值。作为一个例子，考虑以下树：
- en: '![](img/CH_06_02.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/CH_06_02.png)'
- en: 'This is an example of a BST. Testing our tree for the properties of a BST,
    you realize that all the nodes in the left sub-tree of the root node have a value
    less than 5\. Likewise, all the nodes in the right sub-tree have a value that
    is greater than 5\. This property applies to all the nodes in a BST, with no exceptions:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 BST 的例子。测试我们的树以检查 BST 的属性，你会发现根节点的左子树中的所有节点值都小于 5。同样，右子树中的所有节点值都大于 5。这个属性适用于
    BST 中的所有节点，没有例外：
- en: '![](img/CH_06_03.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/CH_06_03.png)'
- en: Despite the fact that the preceding figure looks similar to the previous figure,
    it does not qualify as a BST. Node 7 is greater than the root node 5; however,
    it is located to the left of the root node. Node 4 is to the right sub-tree of
    its parent node 7, which is incorrect.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的图看起来与前面的图相似，但它并不符合二叉搜索树（BST）的定义。节点7大于根节点5；然而，它位于根节点的左侧。节点4是其父节点7的右子树，这是不正确的。
- en: Binary search tree implementation
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树实现
- en: 'Let us begin our implementation of a BST. We will want the tree to hold a reference
    to its own root node:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现BST。我们希望树能持有其自己的根节点的引用：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That's all that is needed to maintain the state of a tree. Let's examine the
    main operations on the tree in the next section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是维护树状态所需的所有内容。让我们在下一节中检查树上的主要操作。
- en: Binary search tree operations
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树操作
- en: There are essentially two operations that are needful for having a usable BST.
    These are the `insert` and `remove` operations. These operations must occur with
    the one rule that they must maintain the principle that gives the BST its structure.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上需要两种操作来拥有一个可用的BST。这些是`insert`和`remove`操作。这些操作必须遵循一个规则，即它们必须维护BST结构的原理。
- en: Before we tackle the insertion and removal of nodes, let's discuss some equally
    important operations that will help us better understand the `insert` and `remove`
    operations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们处理节点的插入和删除之前，让我们讨论一些同样重要的操作，这些操作将帮助我们更好地理解`insert`和`remove`操作。
- en: Finding the minimum and maximum nodes
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找最小和最大节点
- en: The structure of the BST makes looking for the node with the maximum and minimum
    values very easy.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: BST的结构使得寻找最大和最小值节点非常容易。
- en: 'To find the node with smallest value, we start our traversal from the root
    of the tree and visit the left node each time we reach a sub-tree. We do the opposite
    to find the node with the biggest value in the tree:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到具有最小值的节点，我们从树的根节点开始遍历，每次到达子树时都访问左节点。为了在树中找到具有最大值的节点，我们做相反的操作：
- en: '![](img/CH_06_09.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/CH_06_09.png)'
- en: We move down from node 6 to 3 to 1 to get to the node with smallest value. Likewise,
    we go down 6, 8 to node 10, which is the node with the largest value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从节点6移动到3，再到1，以到达具有最小值的节点。同样，我们向下移动6，8到节点10，这是具有最大值的节点。
- en: This same means of finding the minimum and maximum nodes applies to sub-trees
    too. The minimum node in the sub-tree with root node 8 is 7\. The node within
    that sub-tree with the maximum value is 10.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种寻找最小和最大节点的方法同样适用于子树。具有根节点8的子树中的最小节点是7。该子树中具有最大值的节点是10。
- en: 'The method that returns the minimum node is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 返回最小节点的方如下：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `while` loop continues to get the left node and visits it until the last
    left node points to `None`. It is a very simple method. The method to return the
    maximum node does the opposite, where `current.left_child` now becomes `current.right_child`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环继续获取左节点并访问它，直到最后一个左节点指向`None`。这是一个非常简单的方法。返回最大节点的方法相反，其中`current.left_child`现在变为`current.right_child`。'
- en: It takes **O**(*h*) to find the minimum or maximum value in a BST, where *h*
    is the height of the tree.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在BST中找到最小或最大值需要**O**(*h*)时间，其中*h*是树的高度。
- en: Inserting nodes
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入节点
- en: One of the operations on a BST is the need to insert data as nodes. Whereas
    in our first implementation, we had to insert the nodes ourselves, here we are
    going to let the tree be in charge of storing its data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: BST上的一个操作是需要将数据作为节点插入。在我们的第一次实现中，我们必须自己插入节点，而在这里我们将让树负责存储其数据。
- en: In order to make a search possible, the nodes must be stored in a specific way.
    For each given node, its left child node will hold data that is less than its
    own value, as already discussed. That node's right child node will hold data greater
    than that of its parent node.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使搜索成为可能，节点必须以特定的方式存储。对于每个给定的节点，其左子节点将持有小于其自身值的数据，如前所述。该节点的右子节点将持有大于其父节点值的数据。
- en: We are going to create a new BST of integers by starting with the data 5\. To
    do this, we will create a node with its data attribute set to 5.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过从数据5开始来创建一个新的整数BST。为此，我们将创建一个节点，其数据属性设置为5。
- en: 'Now, to add the second node with value 3, 3 is compared with 5, the root node:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了添加第二个具有值3的节点，3与根节点5进行比较：
- en: '![](img/image_06_002.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_06_002.jpg)'
- en: 'Since 5 is greater than 3, it will be put in the left sub-tree of node 5\.
    Our BST will look as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于5大于3，它将被放入节点5的左子树中。我们的BST将如下所示：
- en: '![](img/image_06_003.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_003.jpg)'
- en: The tree satisfies the BST rule, where all the nodes in the left sub-tree are
    less than its parent.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 树满足BST规则，其中所有左子树中的节点都小于其父节点。
- en: 'To add another node of value 7 to the tree, we start from the root node with
    value 5 and do a comparison:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要将另一个值为7的节点添加到树中，我们从值为5的根节点开始并进行比较：
- en: '![](img/image_06_004.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_004.jpg)'
- en: Since 7 is greater than 5, the node with value 7 is situated to the right of
    this root.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于7大于5，值为7的节点位于这个根的右侧。
- en: What happens when we want to add a node that is equal to an existing node? We
    will simply add it as a left node and maintain this rule throughout the structure.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要添加一个等于现有节点的节点时会发生什么？我们将简单地将其作为左节点添加，并在整个结构中保持此规则。
- en: If a node already has a child in the place where the new node goes, then we
    have to move down the tree and attach it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个节点已经在新节点要插入的位置有一个子节点，那么我们必须向下移动树并附加它。
- en: 'Let''s add another node with value 1\. Starting from the root of the tree,
    we do a comparison between 1 and 5:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加另一个值为1的节点。从树的根开始，我们在1和5之间进行比较：
- en: '![](img/image_06_005.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_005.jpg)'
- en: 'The comparison reveals that 1 is less than 5, so we move our attention to the
    left node of 5, which is the node with value 3:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 比较显示1小于5，因此我们将注意力转移到5的左节点，即值为3的节点：
- en: '![](img/CH_06_05.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/CH_06_05.png)'
- en: 'We compare 1 with 3 and since 1 is less than 3, we move a level below node
    3 and to its left. But there is no node there. Therefore, we create a node with
    the value 1 and associate it with the left pointer of node 3 to obtain the following
    structure:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将1与3进行比较，由于1小于3，我们向下移动到节点3的下一级并移动到其左侧。但那里没有节点。因此，我们创建一个值为1的节点并将其与节点3的左指针关联，以获得以下结构：
- en: '![](img/image_06_006.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_006.jpg)'
- en: So far, we have been dealing only with nodes that contain only integers or numbers.
    For numbers, the idea of greater than and lesser than are clearly defined. Strings
    would be compared alphabetically, so there are no major problems there either.
    But if you want to store your own custom data types inside a BST, you would have
    to make sure that your class supports ordering.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只处理包含整数或数字的节点。对于数字，大于和小于的概念是明确定义的。字符串将按字母顺序比较，所以那里也没有大问题。但如果你想在BST中存储自己的自定义数据类型，你必须确保你的类支持排序。
- en: 'Let''s now create a function that enables us to add data as nodes to the BST.
    We begin with a function declaration:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个函数，使我们能够将数据作为节点添加到BST中。我们从函数声明开始：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'By now, you will be used to the fact that we encapsulate the data in a node.
    This way, we hide away the `node` class from the client code, who only needs to
    deal with the tree:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你将习惯于将数据封装在节点中。这样，我们就隐藏了`node`类，客户端代码只需要处理树：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A first check will be to find out whether we have a root node. If we don''t,
    the new node becomes the root node (we cannot have a tree without a root node):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查我们将有一个根节点。如果没有，新节点将成为根节点（没有根节点的树是不可能的）：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we walk down the tree, we need to keep track of the current node we are
    working on, as well as its parent. The variable `current` is always used for this
    purpose:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向下移动树的过程中，我们需要跟踪我们正在处理的当前节点以及其父节点。变量`current`始终用于此目的：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here we must perform a comparison. If the data held in the new node is less
    than the data held in the current node, then we check whether the current node
    has a left child node. If it doesn''t, this is where we insert the new node. Otherwise,
    we keep traversing:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们必须进行一次比较。如果新节点中持有的数据小于当前节点中持有的数据，那么我们检查当前节点是否有左子节点。如果没有，这就是我们插入新节点的位置。否则，我们继续遍历：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we take care of the greater than or equal case. If the current node doesn''t
    have a right child node, then the new node is inserted as the right child node.
    Otherwise, we move down and continue looking for an insertion point:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来处理大于或等于的情况。如果当前节点没有右子节点，那么新节点将被插入为右子节点。否则，我们向下移动并继续寻找插入点：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Insertion of a node in a BST takes **O**(*h*), where h is the height of the
    tree.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在BST中插入节点的时间复杂度为**O**(*h*)，其中h是树的高度。
- en: Deleting nodes
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除节点
- en: 'Another important operation on a BST is the `deletion` or `removal` of nodes.
    There are three scenarios that we need to cater for during this process. The node
    that we want to remove might have the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: BST上的另一个重要操作是节点的`删除`或`移除`。在这个过程中，我们需要处理三种情况。我们想要删除的节点可能有以下几种情况：
- en: No children
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有子节点
- en: One child
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个子节点
- en: Two children
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个子节点
- en: 'The first scenario is the easiest to handle. If the node about to be removed
    has no children, we simply detach it from its parent:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况是最容易处理的。如果即将被删除的节点没有子节点，我们只需将其从其父节点中分离出来：
- en: '![](img/CH_06_06.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/CH_06_06.png)'
- en: Because node A has no children, we will simply dissociate it from its parent,
    node Z.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因为节点A没有子节点，我们将简单地将其与其父节点Z断开联系。
- en: 'On the other hand, when the node we want to remove has one child, the parent
    of that node is made to point to the child of that particular node:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们要删除的节点有一个子节点时，该节点的父节点被设置为指向该特定节点的子节点：
- en: '![](img/CH_06_07.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/CH_06_07.png)'
- en: In order to remove node 6, which has as its only child, node 5, we point the
    left pointer of node 9 to node 5\. The relationship between the parent node and
    child has to be preserved. That is why we need to take note of how the child node
    is connected to its parent (which is the node about to be deleted). The child
    node of the deleted node is stored. Then we connect the parent of the deleted
    node to that child node.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除只有一个子节点5的节点6，我们将节点9的左指针指向节点5。父节点和子节点之间的关系必须被保留。这就是为什么我们需要注意子节点是如何连接到其父节点（即即将被删除的节点）的。被删除节点的子节点被存储起来。然后我们将被删除节点的父节点连接到那个子节点。
- en: 'A more complex scenario arises when the node we want to delete has two children:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要删除的节点有两个子节点时，会出现一个更复杂的情况：
- en: '![](img/CH_06_08.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/CH_06_08.png)'
- en: We cannot simply replace node 9 with either node 6 or 13\. What we need to do
    is to find the next biggest descendant of node 9\. This is node 12\. To get to
    node 12, we move to the right node of node 9\. And then move left to find the
    leftmost node. Node 12 is called the in-order successor of node 9\. The second
    step resembles the move to find the maximum node in a sub-tree.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地将节点9替换为节点6或13。我们需要做的是找到节点9的下一个最大的后裔。这是节点12。要到达节点12，我们移动到节点9的右节点。然后向左移动以找到最左边的节点。节点12被称为节点9的中序后继。第二步类似于寻找子树中的最大节点。
- en: We replace the value of node 9 with the value 12 and remove node 12\. In removing
    node 12, we end up with a simpler form of node removal that has been addressed
    previously. Node 12 has no children, so we apply the rule for removing nodes without
    children accordingly.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将节点9的值替换为12，并删除节点12。在删除节点12时，我们最终得到一个更简单的节点删除形式，这之前已经讨论过。节点12没有子节点，因此我们相应地应用删除无子节点节点的规则。
- en: 'Our `node` class does not have reference to a parent. As such, we need to use
    a helper method to search for and return the node with its parent node. This method
    is similar to the `search` method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`node`类没有父节点的引用。因此，我们需要使用一个辅助方法来搜索并返回带有父节点的节点。这种方法与`search`方法类似：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The only difference is that before we update the current variable inside the
    loop, we store its parent with `parent = current`. The method to do the actual
    removal of a node begins with this search:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是在我们更新循环中的当前变量之前，我们使用`parent = current`存储其父节点。实际删除节点的操作方法从以下搜索开始：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We pass the parent and the found node to `parent` and `node` respectively with
    the line `parent, node = self.get_node_with_parent(data)`. It is helpful to know
    the number of children that the node we want to delete has. That is the purpose
    of the `if` statement.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`parent, node = self.get_node_with_parent(data)`这一行将父节点和找到的节点分别传递给`parent`和`node`。了解我们想要删除的节点有多少个子节点是有帮助的。这就是`if`语句的目的。
- en: 'After this, we need to begin handling the various conditions under which a
    node can be deleted. The first part of the `if` statement handles the case where
    the node has no children:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们需要开始处理节点可以删除的各种条件。`if`语句的第一部分处理节点没有子节点的情况：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`if parent:` is used to handle cases where there is a BST that has only one
    node in the whole of the three.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`if parent:`用于处理整个三个节点中只有一个节点的BST的情况。'
- en: 'In the case where the node about to be deleted has only one child, the `elif`
    part of the `if` statement does the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将被删除的节点只有一个子节点的情况下，`elif`部分的`if`语句执行以下操作：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`next_node` is used to keep track of where the single node pointed to by the
    node we want to delete is. We then connect `parent.left_child` or `parent.right_child`
    to `next_node`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`next_node`用于跟踪我们想要删除的节点所指向的单个节点所在的位置。然后我们将`parent.left_child`或`parent.right_child`连接到`next_node`。'
- en: 'Lastly, we handle the condition where the node we want to delete has two children:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们处理要删除的节点有两个子节点的情况：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In finding the in-order successor, we move to the right node with `leftmost_node
    = node.right_child`. As long as there exists a left node, `leftmost_node.left_child`
    will evaluate to `True` and the `while` loop will run. When we get to the leftmost
    node, it will either be a leaf node (meaning that it will have no child node)
    or have a right child.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找中序后继时，我们移动到右节点，其中`leftmost_node = node.right_child`。只要存在左节点，`leftmost_node.left_child`将评估为`True`，`while`循环将运行。当我们到达最左边的节点时，它将要么是一个叶子节点（意味着它将没有子节点）或者有一个右子节点。
- en: 'We update the node about to be removed with the value of the in-order successor
    with `node.data = leftmost_node.data`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`node.data = leftmost_node.data`将即将被删除的节点更新为中序后继的值：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding statement allows us to properly attach the parent of the leftmost
    node with any child node. Observe how the right-hand side of the equals sign stays
    unchanged. That is because the in-order successor can only have a right child
    as its only child.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句允许我们正确地将最左节点的父节点与任何子节点关联。观察等号右侧保持不变。这是因为中序后继只能有一个右子节点作为其唯一的子节点。
- en: The `remove` operation takes **O**(*h*), where h is the height of the tree.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`操作的时间复杂度为**O**(*h*)，其中h是树的高度。'
- en: Searching the tree
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树搜索
- en: 'Since the `insert` method organizes data in a specific way, we will follow
    the same procedure to find the data. In this implementation, we will simply return
    the data if it was found or `None` if the data wasn''t found:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`insert`方法以特定的方式组织数据，我们将遵循相同的程序来查找数据。在这个实现中，如果找到了数据，我们将简单地返回数据；如果没有找到，则返回`None`：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We need to start searching at the very top, that is, at the root node:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从最顶层开始搜索，即根节点：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We may have passed a leaf node, in which case the data doesn''t exist in the
    tree and we return `None` to the client code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能已经通过了一个叶子节点，在这种情况下，数据在树中不存在，我们将返回`None`给客户端代码：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We might also have found the data, in which case we return it:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能也找到了数据，在这种情况下，我们将返回它：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As per the rules for how data is stored in the BST, if the data we are searching
    for is less than that of the current node, we need to go down the tree to the
    left:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 根据BST中数据存储的规则，如果我们正在搜索的数据小于当前节点的数据，我们需要沿着树向左下：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we only have one option left: the data we are looking for is greater than
    the data held in the current node, which means we go down the tree to the right:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只剩下一个选择：我们要找的数据大于当前节点中的数据，这意味着我们沿着树向右下：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we can write some client code to test how the BST works. We create
    a tree and insert a few numbers between 1 and 10\. Then we search for all the
    numbers in that range. The ones that exist in the tree get printed:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以编写一些客户端代码来测试BST的工作方式。我们创建一个树，并在1到10之间插入几个数字。然后我们搜索该范围内的所有数字。存在于树中的数字将被打印出来：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tree traversal
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树遍历
- en: Visiting all the nodes in a tree can be done depth first or breadth first. These
    modes of traversal are not peculiar to only binary search trees but trees in general.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在树中访问所有节点可以是深度优先或广度优先。这些遍历模式不仅限于二叉搜索树，也适用于一般树。
- en: Depth-first traversal
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度优先遍历
- en: In this traversal mode, we follow a branch (or edge) to its limit before recoiling
    upwards to continue traversal. We will be using the recursive approach for the
    traversal. There are three forms of depth-first traversal, namely `in-order`,
    `pre-order`, and `post-order`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种遍历模式中，我们在回溯之前会沿着一个分支（或边）走到尽头，然后向上继续遍历。我们将使用递归方法进行遍历。深度优先遍历有三种形式，即`中序`、`先序`和`后序`。
- en: In-order traversal and infix notation
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按序遍历和中缀表示法
- en: 'Most of us are probably used to this way of representing an arithmetic expression,
    since this is the way we are normally taught in schools. The operator is inserted
    (infixed) between the operands, as in `3 + 4`. When necessary, parentheses can
    be used to build a more complex expression: `(4 + 5) * (5 - 3)`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数人可能习惯于这种表示算术表达式的方式，因为这是我们通常在学校里被教授的方式。运算符被插入（中缀）在操作数之间，如`3 + 4`。必要时，可以使用括号来构建更复杂的表达式：（4
    + 5）*（5 - 3）。
- en: In this mode of traversal, you would visit the left sub-tree, the parent node,
    and finally the right sub-tree.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种遍历模式中，你会访问左子树，父节点，最后是右子树。
- en: 'The recursive function to return an in-order listing of nodes in a tree is
    as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 返回树中节点中序列表的递归函数如下：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We visit the node by printing the node and making two recursive calls with `current.left_child`
    and `current.right_child`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过打印节点并使用`current.left_child`和`current.right_child`进行两次递归调用来访问节点。
- en: Pre-order traversal and prefix notation
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先序遍历和前缀表示法
- en: 'Prefix notation is commonly referred to as Polish notation. Here, the operator
    comes before its operands, as in `+ 3 4`. Since there is no ambiguity of precedence,
    parentheses are not required: `* + 4 5 - 5 3`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀表示法通常被称为波兰表示法。在这里，操作符在其操作数之前，例如`+ 3 4`。由于没有优先级的不确定性，不需要括号：`* + 4 5 - 5 3`。
- en: To traverse a tree in pre-order mode, you would visit the node, the left sub-tree,
    and the right sub-tree node, in that order.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要以先序模式遍历树，你会按照顺序访问节点、左子树和右子树节点。
- en: Prefix notation is well known to LISP programmers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀表示法对LISP程序员来说很熟悉。
- en: 'The recursive function for this traversal is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这种遍历的递归函数如下：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note the order in which the recursive call is made.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意递归调用的顺序。
- en: Post-order traversal and postfix notation.
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后序遍历和后缀表示法。
- en: 'Postfix or **reverse Polish notation** (**RPN**) places the operator after
    its operands, as in `3 4 +`. As is the case with Polish notation, there is never
    any confusion over the precedence of operators, so parentheses are never needed:
    `4 5 + 5 3 - *`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀或**逆波兰表示法**（**RPN**）将操作符放在其操作数之后，例如`3 4 +`。与波兰表示法一样，操作符的优先级永远不会产生混淆，因此不需要括号：`4
    5 + 5 3 - *`。
- en: In this mode of traversal, you would visit the left sub-tree, the right sub-tree,
    and lastly the root node.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种遍历模式中，你会先访问左子树，然后是右子树，最后是根节点。
- en: 'The `post-order` method is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 后序遍历的方法如下：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Breadth-first traversal
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广度优先遍历
- en: 'This kind of traversal starts from the root of a tree and visits the node from
    one level of the tree to the other:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种遍历从树的根节点开始，从树的某一层访问节点到另一层：
- en: '![](img/CH_06_10.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/CH_06_10.png)'
- en: The node at level 1 is node 4\. We visit this node by printing out its value.
    Next, we move to level 2 and visit the nodes on that level, which are nodes 2
    and 8\. On the last level, level 3, we visit nodes 1, 3, 5, and 10.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第1层的节点是节点4。我们通过打印其值来访问这个节点。接下来，我们移动到第2层并访问该层的节点，即节点2和8。在最后一层，第3层，我们访问节点1, 3,
    5和10。
- en: The complete output of such a traversal is 4, 2, 8, 1, 3, 5, and 10.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种遍历的完整输出是4, 2, 8, 1, 3, 5和10。
- en: This mode of traversal is made possible by using a queue data structure. Starting
    with the root node, we push it into a queue. The node at the front of the queue
    is accessed (dequeued) and either printed and stored for later use. The left node
    is added to the queue followed by the right node. Since the queue is not empty,
    we repeat the process.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种遍历模式是通过使用队列数据结构实现的。从根节点开始，我们将其推入队列。队列前面的节点被访问（出队）并打印出来以供以后使用。左节点被添加到队列中，然后是右节点。由于队列不为空，我们重复这个过程。
- en: A dry run of the algorithm will enqueue the root node 4, dequeue, and access,
    or visit the node. Nodes 2 and 8 are enqueued as they are the left and right nodes
    respectively. Node 2 is dequeued in order to be visited. Its left and right nodes,
    1 and 3, are enqueued. At this point, the node at the front of the queue is 8\.
    We dequeue and visit node 8, after which we enqueue its left and right nodes.
    So the process continues until the queue is empty.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的预演将把根节点4入队，然后出队并访问或访问该节点。节点2和8作为左节点和右节点分别入队。为了访问，节点2被出队。它的左节点和右节点，1和3，被入队。此时，队列前面的节点是8。我们出队并访问节点8，之后将其左节点和右节点入队。因此，这个过程一直持续到队列为空。
- en: 'The algorithm is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 算法如下：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We enqueue the root node and keep a list of the visited nodes in the `list_of_nodes`
    list. The `dequeue` class is used to maintain a queue:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根节点入队，并在`list_of_nodes`列表中保持已访问节点的列表。使用`dequeue`类来维护队列：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If the number of elements in the `traversal_queue` is greater than zero, the
    body of the loop is executed. The node at the front of the queue is popped off
    and appended to the `list_of_nodes` list. The first `if` statement will `enqueue`
    the left child node of the `node` provided a left node exists. The second `if`
    statement does the same for the right child node.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`traversal_queue`中的元素数量大于零，则执行循环体。队列前面的节点被弹出并附加到`list_of_nodes`列表中。第一个`if`语句将在存在左节点的情况下将`node`的左子节点入队。第二个`if`语句对右子节点做同样的操作。
- en: The `list_of_nodes` is returned in the last statement.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一条语句中返回`list_of_nodes`。
- en: Benefits of a binary search tree
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树的好处
- en: 'We shall now briefly look at what makes a BST a better idea than using a list
    for data that needs to be searched. Let us assume that we have the following dataset:
    5, 3, 7, 1, 4, 6, and 9\. Using a list, the worst-case scenario would require
    you to search through the entire list of seven elements before finding the search
    term:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在简要地看看是什么使得二叉搜索树（BST）在需要搜索的数据方面比使用列表更好。让我们假设我们有以下数据集：5, 3, 7, 1, 4, 6, 和
    9。使用列表，最坏的情况需要你搜索整个包含七个元素的列表才能找到搜索项：
- en: '![](img/image_06_007.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_007.jpg)'
- en: Searching for 9 requires six jumps.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索9需要六次跳跃。
- en: 'With a tree, the worst-case scenario is three comparisons:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用树，最坏的情况是三次比较：
- en: '![](img/image_06_008.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_008.jpg)'
- en: Searching for 9 requires two steps.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索9需要两步。
- en: 'Notice, however, that if you insert the elements into the tree in the order
    1, 2, 3, 5, 6, 7, 9, then the tree would not be more efficient than the list.
    We would have to balance the tree first:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，然而，如果你按顺序1, 2, 3, 5, 6, 7, 9将元素插入到树中，那么树可能不会比列表更有效率。我们首先需要平衡树：
- en: '![](img/image_06_009.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_009.jpg)'
- en: So not only is it important to use a BST but choosing a self-balancing tree
    helps to improve the `search` operation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不仅使用BST很重要，选择一个自平衡树也有助于提高`搜索`操作。
- en: Expression trees
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式树
- en: 'The tree structure is also used to parse arithmetic and Boolean expressions.
    For example, the expression tree for `3 + 4` would look as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 树结构也用于解析算术和布尔表达式。例如，`3 + 4`的表达式树如下所示：
- en: '![](img/image_06_010.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_010.jpg)'
- en: 'For a slightly more complex expression, `(4 + 5) * (5-3)`, we would get the
    following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个稍微复杂一些的表达式，`(4 + 5) * (5-3)`，我们会得到以下结果：
- en: '![](img/image_06_011.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_011.jpg)'
- en: Parsing a reverse Polish expression
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析逆波兰表达式
- en: 'Now we are going to build up a tree for an expression written in postfix notation.
    Then we will calculate the result. We will use a simple tree implementation. To
    keep it really simple, since we are going to grow the tree by merging smaller
    trees, we only need a tree node implementation:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将构建一个后缀表示法写成的表达式的树。然后我们将计算结果。我们将使用一个简单的树实现。为了使其尽可能简单，因为我们将通过合并较小的树来增长树，我们只需要一个树节点实现：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In order to build the tree, we are going to enlist the help of a stack. You
    will see why soon. But for the time being, let us just create an arithmetic expression
    and set up our stack:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建树，我们将求助于栈。你很快就会看到原因。但在此期间，让我们先创建一个算术表达式并设置我们的栈：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Since Python is a language that tries hard to have sensible defaults, its `split()`
    method splits on whitespace by default. (If you think about it, this is most likely
    what you would expect as well.) The result is going to be that expr is a list
    with the values 4, 5, +, 5, 3, - and *.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python是一种努力拥有合理默认值的语言，其`split()`方法默认按空白字符分割。（如果你想想，这也可能是你期望的。）结果是expr将是一个包含值4,
    5, +, 5, 3, - 和 * 的列表。
- en: Each element of the expr list is going to be either an operator or an operand.
    If we get an operand then we embed it in a tree node and push it onto the stack.
    If we get an operator, on the other hand, then we embed the operator into a tree
    node and pop its two operands into the node's left and right children. Here we
    have to take care to ensure that the first pop goes into the right child, otherwise
    we will have problems with subtraction and division.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: expr列表中的每个元素都将是一个运算符或操作数。如果我们得到一个操作数，那么我们将其嵌入到一个树节点中并将其推入栈中。另一方面，如果我们得到一个运算符，那么我们将运算符嵌入到一个树节点中，并将其两个操作数弹出并放入节点的左右子节点中。在这里，我们必须注意确保第一次弹出的元素进入右子节点，否则我们将在减法和除法中遇到问题。
- en: 'Here is the code to build the tree:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建树的代码：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice that we perform a conversion from string to int in the case of an operand.
    You could use `float()` instead, if you wanted to support floating point operands.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在操作数的情况下，我们执行从字符串到整数的转换。如果你想支持浮点操作数，可以使用`float()`。
- en: At the end of this operation, we should have one single element in the stack,
    and that holds the full tree.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个操作结束时，我们应该在栈中有一个单独的元素，它包含了完整的树。
- en: 'We may now want to be able to evaluate the expression. We build the following
    little function to help us:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可能想要能够评估表达式。我们构建以下小函数来帮助我们：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This function is very simple. We pass in a node. If the node contains an operand,
    then we simply return that value. If we get an operator, however, then we perform
    the operation that the operator represents, on the node's two children. However,
    since one or more of the children could also contain either operators or operands,
    we call the `calc()` function recursively on the two child nodes (bearing in mind
    that all the children of every node are also nodes).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常简单。我们传入一个节点。如果节点包含一个操作数，那么我们只需返回该值。然而，如果我们得到一个运算符，那么我们就执行该运算符所表示的操作，在节点的两个子节点上。然而，由于一个或多个子节点也可能包含运算符或操作数，我们在两个子节点上递归调用
    `calc()` 函数（记住，每个节点的所有子节点也都是节点）。
- en: 'Now we just need to pop the root node off the stack and pass it into the `calc()`
    function and we should have the result of the calculation:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要从栈中弹出根节点，并将其传递到 `calc()` 函数中，我们应该得到计算结果：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Running this program should yield the result 18, which is the result of `(4
    + 5) * (5 - 3)`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序应该得到结果 18，这是 `(4 + 5) * (5 - 3)` 的结果。
- en: Balancing trees
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平衡树
- en: Earlier, we mentioned that if nodes are inserted into the tree in a sequential
    order, then the tree behaves more or less like a list, that is, each node has
    exactly one child node. We normally would like to reduce the height of the tree
    as much as possible, by filling up each row in the tree. This process is called
    balancing the tree.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到，如果节点按照顺序插入到树中，那么树的行为或多或少就像一个列表，也就是说，每个节点恰好有一个子节点。我们通常希望尽可能降低树的高度，通过填充树的每一行来实现。这个过程被称为平衡树。
- en: There are a number of types of self-balancing trees, such as red-black trees,
    AA trees, and scapegoat trees. These balance the tree during each operation that
    modifies the tree, such as insert or delete.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多种自平衡树，如红黑树、AA 树和替罪羊树。这些树在每次修改树的操作（如插入或删除）期间都会平衡树。
- en: There are also external algorithms that balance a tree. The benefit of these
    is that you wouldn't need to balance the tree on every single operation, but could
    rather leave balancing to the point when you need it.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 也有外部算法可以平衡树。这些算法的好处是，你不需要在每次操作时都平衡树，而可以留到你需要的时候再进行平衡。
- en: Heaps
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆
- en: At this point, we shall briefly introduce the heap data structure. A heap is
    a specialization of a tree in which the nodes are ordered in a specific way. Heaps
    are divided into max and min heaps. In a max heap, each parent node must always
    be greater than or equal to its children. It follows that the root node must be
    the greatest value in the tree. A min heap is the opposite. Each parent node must
    be less than or equal to both its children. As a consequence, the root node holds
    the lowest value.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将简要介绍堆数据结构。堆是树的一种特殊化，其中节点以特定的方式排序。堆分为最大堆和最小堆。在最大堆中，每个父节点必须始终大于或等于其子节点。因此，根节点必须是树中的最大值。最小堆则相反。每个父节点必须小于或等于其两个子节点。因此，根节点持有最小值。
- en: Heaps are used for a number of different things. For one, they are used to implement
    priority queues. There is also a very efficient sorting algorithm, called heap
    sort, that uses heaps. We are going to study these in depth in subsequent chapters.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 堆被用于许多不同的事情。一方面，它们用于实现优先队列。还有一个非常高效的排序算法，称为堆排序，它使用堆。我们将在后续章节中深入研究这些内容。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have looked at tree structures and some example uses of
    them. We studied binary trees in particular, which is a subtype of trees where
    each node has at most two children.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了树结构及其一些示例用法。我们特别研究了二叉树，它是树的一个子类型，其中每个节点最多有两个子节点。
- en: We looked at how a binary tree can be used as a searchable data structure with
    a BST. We saw that, in most cases, finding data in a BST is faster than in a linked
    list, although this is not the case if the data is inserted sequentially, unless
    of course the tree is balanced.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何将二叉树用作带有 BST 的可搜索数据结构。我们看到，在大多数情况下，在 BST 中查找数据比在链表中更快，尽管如果数据是顺序插入的，情况并非如此，除非当然树是平衡的。
- en: The breadth- and depth-first search traversal modes were also implemented using
    queue recursion.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度和深度优先搜索遍历模式也使用队列递归实现。
- en: We also looked at how a binary tree can be used to represent an arithmetic or
    a Boolean expression. We built up an expression tree to represent an arithmetic
    expression. We showed how to use a stack to parse an expression written in RPN,
    build up the expression tree, and finally traverse it to get the result of the
    arithmetic expression.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了如何使用二叉树来表示算术或布尔表达式。我们构建了一个表达式树来表示算术表达式。我们展示了如何使用栈来解析逆波兰表示法（RPN）书写的表达式，构建表达式树，并最终遍历它以获取算术表达式的结果。
- en: Finally, we mentioned heaps, a specialization of a tree structure. We have tried
    to at least lay down the theoretical foundation for the heap in this chapter,
    so that we can go on to implement heaps for different purposes in upcoming chapters.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提到了堆，这是树结构的一种特殊化。我们试图至少在本章中为堆奠定理论基础，以便我们可以在接下来的章节中为不同的目的实现堆。
