- en: Good Test Habits for New and Legacy Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新系统和旧系统的良好测试习惯
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Something is better than nothing
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有总比没有好
- en: Coverage isn't everything
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖率并不是一切
- en: Be willing to invest in text fixtures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 愿意投资于文本夹具
- en: If you aren't convinced about the value of testing, your team won't be either
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你对测试的价值不太确信，你的团队也不会确信
- en: Harvesting metrics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集指标
- en: Capturing a bug in an automated test
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自动化测试中捕获错误
- en: Separating algorithms from concurrency
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将算法与并发分开
- en: Pausing to refactor when a test suite takes too long to run
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当测试套件运行时间过长时，暂停重构。
- en: Cashing in on your confidence
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 充分利用你的信心
- en: Be willing to throw away an entire day's changes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 愿意放弃一整天的更改
- en: Instead of shooting for 100 percent coverage, try to have steady growth
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其追求100%的覆盖率，不如试图实现稳定的增长
- en: Randomly breaking up your application can lead to better code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机地打破你的应用程序可能会导致更好的代码
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'I hope you have enjoyed the previous chapters of this book. Up to this point,
    we have explored a lot of areas of automated testing, such as:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你喜欢本书的前几章。到目前为止，我们已经探讨了许多自动化测试领域，比如：
- en: Unit testing
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Nose testing
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nose测试
- en: Doctest testing
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Doctest测试
- en: Behavior-driven development
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为驱动开发
- en: Acceptance testing
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验收测试
- en: Continuous integration
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成
- en: Smoke and load testing
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒烟和负载测试
- en: In this chapter, we will do something different. Instead of providing lots of
    code samples for various tips and tricks, I want to share some ideas I have picked
    up in my career as a software engineer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做一些不同的事情。与其为各种技巧提供大量代码示例，我更想分享一些我作为软件工程师在职业生涯中学到的想法。
- en: All of the previous recipes in this book had very detailed steps on how to write
    the code, run it, and review its results. Hopefully, you have taken those ideas,
    expanded on them, improvised them, and, ultimately, applied them to help solve
    your own software problems.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中以前的所有示例都非常详细地介绍了如何编写代码、运行代码并审查其结果。希望你已经接受了这些想法，对其进行了扩展、改进，并最终应用到解决自己的软件问题中。
- en: In this chapter, let's explore some of the bigger ideas behind testing and how
    they can empower our development of quality systems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，让我们探讨一些关于测试的更大的想法，以及它们如何增强我们开发质量系统的能力。
- en: Something is better than nothing
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有总比没有好
- en: Don't get caught up in the purity of total isolation or worry about obscure
    test methods. The first thing to do is to start testing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不要陷入纯粹的隔离或担心晦涩的测试方法。首先要做的是开始测试。
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You have just been handed an application that was developed by others who are
    no longer with your company. Been there before? We all have, and probably on several
    occasions. Can we predict some of the common symptoms? Well, they could be similar
    to these:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚接手了一个由其他人开发的应用程序，而这些人已经不在你公司了。以前有过这种经历吗？我们都有过，可能不止一次。我们能预测一些常见的症状吗？嗯，它们可能类似于这些：
- en: There are few (if any) automated tests.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎没有（如果有的话）自动化测试。
- en: There is little documentation.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎没有文档。
- en: There are chunks of code that have been commented out.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些代码块已经被注释掉了。
- en: There are either no comments in the code, or there are comments that were written
    ages ago and are no longer correct.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码中要么没有注释，要么有些注释是很久以前写的，现在已经不正确了。
- en: And here is the fun part—we don't know about all of these issues up front. We
    are basically told where to check the source tree, and to get cracking. For example,
    it's only when we run into an issue and seek  documentation that we discover what
    does (or does not) exist.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 而这就是有趣的部分——我们一开始并不知道所有这些问题。我们基本上是被告知在源代码树中检查，并开始工作。例如，只有当我们遇到问题并寻求文档时，我们才会发现存在（或不存在）什么。
- en: Maybe I didn't catch everything you have encountered in that list, but I bet
    you've experienced a lot of those things. I don't want to sound like an embittered
    software developer, because I'm not. Not every project is like this. But I'm sure
    we have all had to deal with this at one time or another. So, what do we do? We
    start testing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我没有捕捉到你在列表中遇到的所有问题，但我敢打赌你经历了其中很多。我不想听起来像一个怨恨的软件开发者，因为我不是。并非每个项目都是这样。但我相信我们都曾经不得不处理这种情况。那么，我们该怎么办？我们开始测试。
- en: But the devil is in the details. Do we write a unit test? What about a thread
    test or an integration test? You know what? It doesn't matter what type of test
    we write. In fact, it doesn't even matter whether we use the right name.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但魔鬼在细节中。我们写单元测试吗？线程测试呢？还是集成测试？你知道吗？其实，我们写什么类型的测试并不重要。事实上，使用正确的名称也并不重要。
- en: When it's just you and the code sitting in a cubicle, terminology doesn't matter.
    Writing a test is what matters. If you can pick out one small unit of code and
    write a test, then go for it! But what if you picked up a jumbled piece of spaghetti
    code that doesn't come with nicely isolated units?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你独自一人坐在小隔间里和代码对峙时，术语并不重要。重要的是编写测试。如果你能挑出一个小的代码单元并编写一个测试，那就去做吧！但如果你拿到了一堆混乱的代码，而这些代码并没有很好地隔离单元，怎么办呢？
- en: 'Consider a system where the smallest unit you can get hold of is a module that
    parses an electronic file and then stores the parsed results in a database. The
    parsed results aren''t handed back through the API. They just silently, mysteriously
    end up in the database. How do we automate that? Well, we can do the following
    things:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个系统，最小的单元是一个模块，用于解析电子文件，然后将解析结果存储在数据库中。解析结果不会通过API返回。它们只是悄悄地、神秘地出现在数据库中。我们如何自动化呢？嗯，我们可以做以下几件事：
- en: Write a test that starts by emptying all the tables relevant to the application.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个测试，首先清空与应用程序相关的所有表。
- en: Find one of your users who has one of these files and get a copy of it.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个用户拥有这些文件之一，并获取一份副本。
- en: Add code to the test that invokes the top-level API to ingest the file.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向测试中添加调用顶层API来摄取文件的代码。
- en: Add some more code that pulls data out of the database and checks the results.
    (You may have to grab that user to make sure the code is working correctly.)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些从数据库中提取数据并检查结果的代码。（你可能需要获取那个用户，以确保代码正常工作。）
- en: Congratulations! You just wrote an automated test! It probably didn't qualify
    as a unit test. In fact, it may look kind of ugly to you, but so what? Maybe it
    took five minutes to run, but isn't that better than no test at all?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚编写了一个自动化测试！它可能不符合单元测试的标准。事实上，它可能对你来说看起来有点丑陋，但又怎样呢？也许它需要五分钟才能运行，但这难道不比没有测试好吗？
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Since the database is the place where we can assert results, we need to have
    a cleaned-out version before every run of our test. This will definitely require
    coordination if other developers are using some of the same tables. We may need
    our own schema allocated to us so that we can empty tables at will.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据库是我们可以断言结果的地方，我们需要在每次运行测试之前清理出一个经过清理的版本。如果其他开发人员正在使用相同的表，这肯定需要协调。我们可能需要分配给我们自己的模式，这样我们就可以随意清空表格。
- en: The modules probably suffer from a lack of cohesion and too much tight coupling.
    While we can try to identify why the code is bad, it doesn't advance our cause
    of building automated tests.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可能受到缺乏凝聚力和过于紧密耦合的影响。虽然我们可以尝试确定代码为什么不好，但这并不会推动我们构建自动化测试的事业。
- en: Instead, we must recognize that if we try to jump immediately into the unit
    level test, we will have to refactor the modules to support us. With little or
    no safety net, the risk is incredibly high, and we can feel it! If we tried to
    stick to a textbook unit test, then we would probably give up and consider automated
    testing an impossibility.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们必须认识到，如果我们试图立即跳入单元级别的测试，我们将不得不重构模块以支持我们。没有或很少的安全网，风险是非常高的，我们可以感受到！如果我们试图坚持教科书上的单元测试，那么我们可能会放弃，并认为自动化测试是不可能的。
- en: So, we have to take the first step and write an expensive, end-to-end, automated
    test to build the first link of the chain. That test may take a long time to run
    and may not be very comprehensive in what we can assert, but it's a start, and
    that is what's important. Hopefully, after making steady progress writing more
    tests like this, we will build up a safety net that will prevent us from having
    to go back and refactor this code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须迈出第一步，编写一个昂贵的、端到端的自动化测试来构建链条的第一环。这个测试可能需要很长时间才能运行，而且可能在我们可以断言的内容上并不是非常全面，但这是一个开始，这才是重要的。希望在稳步取得进展编写更多这样的测试之后，我们将建立一个安全网，这将防止我们不得不回头重构这段代码。
- en: That can't be everything!
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这还不是全部！
- en: Does *just write the test* sound a little too simple? Well, the concept is simple,
    but the work is going to be hard—very hard.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*只是编写测试*听起来有点太简单了吗？嗯，概念很简单，但工作会很艰难——非常艰难。'
- en: You will be forced to crawl through lots of APIs and find out exactly how they
    work. And, guess what? You probably won't be handed lots of intermediate results
    to assert. Understanding the API is just so that you can track down where the
    data travels to.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被迫爬行通过大量的API，并确切地找出它们是如何工作的。而且，猜猜看？你可能不会得到很多中间结果来断言。理解API只是为了让你追踪数据的流向。
- en: When I described the data of our situation as *mysteriously ending up in the
    database*, I was referring to the likelihood that the APIs you have probably weren't
    designed with lots of return values aimed at testability.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我描述我们的情况的数据*神秘地最终出现在数据库中*时，我指的是你可能的API并不是为了可测试性而设计的大量返回值。
- en: Just don't let anyone tell you that you are wasting your time building a long-running
    test case. An automated test suite that takes an hour to run and is exercised
    at least once a day probably instills more confidence than clicking through the
    screens manually. Something is better than nothing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 只是不要让任何人告诉你，你在构建长时间运行的测试用例上浪费时间。一个需要一个小时才能运行一次，并且每天至少运行一次的自动化测试套件，可能比手动点击屏幕更能增强信心。有总比没有好。
- en: See also
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Cash in on your confidence* recipe
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*充分利用你的信心*的配方'
- en: Coverage isn't everything
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖率并不是一切
- en: You've figured out how to run coverage reports. However, don't assume that more
    coverage is automatically better. Sacrificing test quality in the name of coverage
    is a recipe for failure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何运行覆盖率报告了。然而，不要认为覆盖率越高就越好。以覆盖率为名牺牲测试质量是失败的开始。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到…
- en: '**Coverage reports** provide good feedback. They tell us what is getting exercised
    and what is not. But, just because a line of code is exercised, that doesn''t
    mean it is doing everything it is meant to do.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**覆盖率报告**提供了很好的反馈。它们告诉我们哪些被执行了，哪些没有。但是，仅仅因为一行代码被执行，并不意味着它做了它应该做的一切。'
- en: Are you ever tempted to brag about coverage percentage scores in the break room?
    Taking pride in good coverage isn't unwarranted, but when it leads to comparing
    different projects using these statistics, we are wandering into risky territory.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经想要在休息室里吹嘘覆盖率得分？为良好的覆盖率感到自豪并不是没有根据的，但当它导致使用这些统计数据来比较不同的项目时，我们就会涉足风险领域。
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Coverage reports are meant to be read in the context of the code they were run
    against. The reports show us what was covered and what was not, but this isn't
    where things stop. Instead, it's where they begin. We need to look at what was
    covered and analyze how well the tests exercised the system.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率报告是要在运行的代码的上下文中阅读的。报告告诉我们什么被覆盖了，什么没有被覆盖，但这并不是结束的地方。相反，这才是开始的地方。我们需要看看什么被覆盖了，并分析测试对系统的执行程度。
- en: It's obvious that 0% coverage of a module indicates we have work to do. But
    what does it mean when we have 70% coverage? Do we need to code tests that go
    after the other 30%? Sure we do! But there are two different schools of thought
    on how to approach this. One is right, and one is wrong.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，模块的覆盖率为0%表示我们有工作要做。但是当我们的覆盖率达到70%时，这意味着什么呢？我们需要编写测试来覆盖其他30%吗？当然需要！但是对于如何解决这个问题，有两种不同的思路。一种是正确的，一种是错误的。
- en: The first approach is to write the new tests specifically targeting the uncovered
    parts while trying to avoid overlapping the original 70%. Redundantly testing
    code already covered in another test is an inefficient use of resources.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法是编写新的测试，专门针对未覆盖的部分，同时尽量避免重叠原始70%。对已经在另一个测试中覆盖的代码进行冗余测试是资源的低效使用。
- en: The second approach is to write the new tests so that they target scenarios
    the code is expected to handle, but that we haven't tackled yet. What was not
    covered should give us a hint about which scenarios haven't been tested yet.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法是编写新的测试，以便它们针对代码预期处理的场景，但我们尚未解决。未被覆盖的部分应该给我们一个提示，表明哪些场景尚未被测试。
- en: The right approach is the second one. OK, I admit I wrote that in a leading
    fashion. But the point is that it's very easy to look at what wasn't hit and write
    a test that aims to close the gap as fast as possible.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的方法是第二种。好吧，我承认我以引导的方式写了这个。但关键是很容易看到未被覆盖的部分，并编写一个旨在尽快弥补差距的测试。
- en: There's more...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Python gives us incredible power to monkey patch, inject alternate methods,
    and do other tricks to exercise the uncovered code. But doesn''t this sound a
    little suspicious? Here are some of the risks we are setting ourselves up for:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Python给了我们令人难以置信的能力来进行monkey patch，注入替代方法，以及其他技巧来执行未覆盖的代码。但这听起来不是有点可疑吗？以下是我们为自己设置的一些风险：
- en: The new tests may be more brittle when they aren't based on sound scenarios.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当新的测试不基于合理的场景时，可能会更加脆弱。
- en: A major change to our algorithms may require us to totally rewrite these tests.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对我们的算法进行重大更改可能需要我们完全重写这些测试。
- en: Ever written mock-based tests? It's possible to mock the target system out of
    existence and end up just testing the mocks.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 曾经写过基于模拟的测试吗？可能会将目标系统模拟得无影无踪，最终只是测试模拟。
- en: Even though some (or even most) of our tests may have good quality, the low-quality
    ones will cast our entire test suite as low quality.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使我们的一些（甚至大多数）测试质量很好，低质量的测试也会使整个测试套件的质量变低。
- en: The coverage tool may not let us *get away* with some of these tactics if we
    do things that interfere with line counting mechanisms. But whether or not the
    coverage tool counts the code should not be the gauge by which we determine the
    quality of tests.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们做一些干扰行计数机制的事情，覆盖工具可能不会让我们逃脱一些策略。但无论覆盖工具是否计算代码，都不应该是我们确定测试质量的标准。
- en: Instead, we need to look at our tests and see whether they are trying to exercise
    real-use cases we should be handling. When we are merely looking for ways to get
    more coverage percentage, we stop thinking about how our code is meant to operate,
    and that is not good.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们需要查看我们的测试，看看它们是否试图执行我们应该处理的真实用例。当我们仅仅寻求获得更高的覆盖率百分比时，我们停止了思考我们的代码应该如何运行，这是不好的。
- en: Are we not supposed to increase coverage?
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们不应该增加覆盖率吗？
- en: We are supposed to increase coverage by improving our tests, covering more scenarios,
    and removing code that's no longer supported. These things all lead us toward
    overall better quality. Increasing coverage for the sake of coverage doesn't lend
    itself to improving the quality of our system.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该通过改进我们的测试、覆盖更多的场景和删除不再支持的代码来增加覆盖率。这些都将使我们朝着整体更好的质量迈进。仅仅为了覆盖率而增加覆盖率并不能提高我们系统的质量。
- en: But I want to brag about the coverage of my system!
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 但我想要夸耀一下我的系统覆盖率！
- en: I think it's all right to celebrate good coverage. Sharing a coverage report
    with your manager is all right. But don't let it consume you.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为庆祝良好的覆盖率是可以的。与经理分享覆盖率报告是可以的。但不要让它消耗你。
- en: If you start to post weekly coverage reports, double check your motives. The
    same goes if your manager requests postings as well.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始每周发布覆盖率报告，请仔细检查你的动机。如果你的经理也要求发布报告，也是一样。
- en: If you find yourself comparing the coverage of your system to another system,
    then watch out! Unless you are familiar with the code of both systems, and really
    know more than the bottom line of the reports, you will probably wander into risky
    territory. You may be headed into the faulty competition that could drive your
    team to write brittle tests.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己在比较你的系统覆盖率和另一个系统的覆盖率，那就要小心了！除非你熟悉两个系统的代码，并且真正了解报告的底线以上的内容，否则你可能会陷入风险区域。你可能会陷入可能导致团队编写脆弱测试的错误竞争中。
- en: Be willing to invest in test fixtures
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 愿意投资于测试装置
- en: Spend time working on some test fixtures. You may not get a lot of tests written
    at first, but this investment will pay off.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 花时间研究一些测试装置。起初可能写不了很多测试，但这项投资将会有回报。
- en: How to do it....
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做....
- en: When we start building a new greenfield project, it's a lot easier to write
    test-oriented modules, but when dealing with legacy systems, it may take more
    time to build a working test fixture. This may be tough to go through, but it's
    a valuable investment.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始构建一个新的绿地项目时，编写面向测试的模块会更容易，但在处理遗留系统时，构建一个有效的测试装置可能需要更多的时间。这可能会很艰难，但这是一项有价值的投资。
- en: 'As an example, in the section *Something is better than nothing*, we talked
    about a system that scanned electronic files and put the parsed results into database
    tables. What steps would our test fixture require? Perhaps we should consider
    the following issues:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在“有总比没有好”的部分，我们谈到了一个扫描电子文件并将解析结果放入数据库表的系统。我们的测试装置需要哪些步骤？也许我们应该考虑以下问题：
- en: Set up steps to clean out the appropriate tables.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置步骤来清理适当的表格。
- en: Quite possibly, we may need to use code or a script to create a new database
    schema to avoid collisions with other developers.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很可能，我们可能需要使用代码或脚本来创建一个新的数据库模式，以避免与其他开发人员发生冲突。
- en: It may be necessary to place the file in a certain location so the parser can
    find it.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能需要将文件放在特定位置，以便解析器能够找到它。
- en: These are all steps that take time to build a working test case. More complex
    legacy systems may require even more steps to gear up for a test run.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是需要时间来构建一个有效的测试用例的步骤。更复杂的遗留系统可能需要更多的步骤来准备进行测试。
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All of this can become intimidating and may push us to drop automated testing
    and just continue with clicking through the screens to verify things. But taking
    the time to invest in coding this fixture will begin to pay off as we write more
    test cases that use our fixture.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些可能会让我们感到害怕，并可能推动我们放弃自动化测试，只是继续通过屏幕点击来验证事物。但是，花时间投资编写这个测试装置将在我们编写更多使用我们的测试装置的测试用例时开始产生回报。
- en: Have you ever built a test fixture and had to alter it for certain scenarios?
    After having developed enough test cases using our fixture, we will probably encounter
    another use case we need to test that exceeds the limits of our fixture. Since
    we are now familiar with it, it is probably easier to create another fixture.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有建立过一个测试装置，然后不得不为特定情况进行修改？在使用我们的测试装置开发足够的测试用例之后，我们可能会遇到另一个需要测试的用例，超出了我们测试装置的限制。由于我们现在对它很熟悉，创建另一个测试装置可能会更容易。
- en: This is another way that coding the first fixture pays off. Future fixtures
    have a good chance of being easier to code. However, this isn't a cut-and-dried
    guarantee of improvement. Often, the first variation of our test fixture is a
    simple one.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是编写第一个测试装置的另一种回报方式。未来的测试装置很有可能更容易编写。然而，这并不是改进的一种明确保证。通常，我们的测试装置的第一个变体是一个简单的。
- en: There's more...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We will probably run into a situation where we need another test fixture that
    is totally different than what we've built. At this point, investing in the first
    test fixture doesn't have the same payoff. But, by this time, we will have become
    more seasoned test writers and have a better handle on what works and what doesn't
    when it comes to testing the system.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会遇到需要另一个与我们构建的完全不同的测试装置的情况。在这一点上，对第一个测试装置的投资并没有同样的回报。但是，到那时，我们将成为更有经验的测试编写者，并且对于测试系统时什么有效、什么无效有更好的把握。
- en: All the work done up to this point will have sharpened our skill set and that,
    in and of itself, is a great payoff for investing in the test fixture.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止所做的所有工作都将锻炼我们的技能，并且这本身就是对测试装置投资的巨大回报。
- en: Is this just about setting up a database?
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这只是关于设置数据库吗？
- en: This is not just about setting up a database. If our system interacts extensively
    with an LDAP server, we may need to code a fixture that cleans out the directory
    structure and loads it up with test data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是关于设置数据库。如果我们的系统与LDAP服务器有广泛的交互，我们可能需要编写一个清理目录结构并加载测试数据的测试装置。
- en: If the legacy system is flexible enough, we can put this whole test structure
    into a sub node in the hierarchy. But it's just as likely that it expects the
    data to exist at a certain location. In that situation, we may have to develop
    a script that spins up a separate, empty LDAP server, and then shuts it down after
    the test is complete.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传统系统足够灵活，我们可以将整个测试结构放入层次结构中的一个子节点。但同样可能的是，它期望数据存在于特定位置。在这种情况下，我们可能需要开发一个脚本，启动一个单独的空的LDAP服务器，然后在测试完成后关闭它。
- en: Setting up and tearing down an LDAP server may not be the fastest, nor the most
    efficient test fixture. But if we invest time into building this fixture to empower
    ourselves to write automated tests, we will eventually be able to refactor the
    original system to decouple it from a live LDAP server. And this whole process
    will sharpen our skill set. That is why creating the original test fixture truly
    is an investment.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和关闭LDAP服务器可能不是最快、也不是最有效的测试装置。但是，如果我们投入时间来构建这个测试装置，以便自己编写自动化测试，最终我们将能够重构原始系统，使其与实时LDAP服务器解耦。整个过程将锻炼我们的技能。这就是为什么创建原始测试装置真的是一种投资。
- en: If you aren't convinced about the value of testing, your team won't be either
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果你对测试的价值不太确信，你的团队也不会。
- en: Test-bitten developers exhibit zeal; they are excited to run their test suite
    and see things
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 受测试影响的开发人员表现出热情；他们很高兴运行他们的测试套件并看到结果。
- en: complete with 100% success. This sort of emotion and pride tends to rub off
    on their fellow developers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 完全成功。这种情感和自豪感往往会感染其他开发人员。
- en: But the reverse is also true. If you aren't excited by all this and don't spread
    the word, none of your teammates will either. The idea of adding automated tests
    to your system will die a sad death.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但反之亦然。如果你对这一切不感到兴奋，也不传播这个想法，你的队友也不会。向你的系统添加自动化测试的想法将会悲惨地消失。
- en: This isn't just confined to my own personal experience. At the 2010 DevLink
    conference, I attended an open-space discussion about testing, and saw this sort
    of reaction among a dozen other developers I don't work with (`pythontestingcookbook.posterous.com`/
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅局限于我的个人经验。在2010年的DevLink大会上，我参加了一个关于测试的开放空间讨论，并在其他十几个我不认识的开发人员中看到了这种反应（`pythontestingcookbook.posterous.com`/）。
- en: '`greetings-programs`). The testers showed a certain type of excitement as they
    relayed'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 问候程序）。测试人员在传达他们的经验时表现出一种特定类型的兴奋。
- en: their experiences with testing. The ones that were on the fence about embracing
    automated testing were listening with glee, drinking it in. Those not interested
    simply weren't there for the discussion.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 他们对测试的经验。那些对于接受自动化测试持保留态度的人听起来很高兴，津津有味。那些对此不感兴趣的人根本就不会参与讨论。
- en: 'If you are reading this book (which of course you are), there is a fair chance
    you are the only person on your team seriously interested in automated testing.
    Your teammates may have heard of it, but aren''t as bitten by the idea as you.
    To add it to your system will require a lot of investment by you, but don''t confine
    yourself to just sharing the code; consider the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这本书（当然你是），你很有可能是你的团队中唯一一个真正对自动化测试感兴趣的人。你的队友可能听说过它，但对这个想法没有你那么感兴趣。将其添加到你的系统将需要你大量的投资，但不要仅仅局限于分享代码；考虑以下内容：
- en: Demonstrate the excitement you feel as you make progress, and tackle thorny
    issues.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示你在取得进展时的兴奋，并解决棘手的问题。
- en: Share your test results by posting them on your walls, where others can see
    them.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在墙上张贴测试结果来分享它们，让其他人看到。
- en: Talk about your accomplishments while chatting with co-workers in the break
    room.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在休息室与同事聊天时谈论您的成就。
- en: Testing isn't a cold, mechanical process; it's an exciting, fiery area of development.
    Test-bitten developers can't wait to share it with others. If you look for ways
    to spread the fire of automated testing, eventually others will warm up to it,
    and you will find yourself talking about new testing techniques with them.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 测试不是一个冷冰冷的机械过程；它是一个令人兴奋的、火热的开发领域。沉迷于测试的开发人员迫不及待地想与他人分享。如果您寻找传播自动化测试之火的方法，最终其他人会对此感兴趣，您会发现自己与他们讨论新的测试技术。
- en: Harvesting metrics
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集指标
- en: Start a spreadsheet that shows lines, code, a number of tests, the total test
    execution time, and the number of bugs, and track this with every release. The
    numbers will defend your investment.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个电子表格，显示行数、代码、测试数量、总测试执行时间和错误数量，并在每次发布时进行跟踪。这些数字将捍卫您的投资。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'These high-level steps show how to capture metrics over time:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些高层次的步骤展示了如何随着时间的推移捕获指标：
- en: Create a spreadsheet to track the number of test cases, the time taken to run
    the test suite, the date of the test run, any bugs, and the average time per test.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个电子表格来跟踪测试用例的数量，运行测试套件所需的时间，测试运行的日期，任何错误以及每个测试的平均时间。
- en: Check the spreadsheet into your code base as another controlled artifact.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电子表格作为另一个受控制的工件添加到您的代码库中。
- en: Add some graphs to show the curve of the test time versus the test quantity.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些图表，显示测试时间与测试数量的曲线。
- en: Add a new row of data at least each time you do a release. If you can capture
    data more often, such as once a week or even once a day, that is better.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次发布时至少添加一行新数据。如果您可以更频繁地捕获数据，比如每周一次甚至每天一次，那就更好了。
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you write more tests, the test suite will take longer to run. But you will
    also find that the number of bugs tends to decrease. The more testing you do,
    and the more often you do it, the better your code will be. Capturing the metrics
    of your testing can act as hard evidence that the time spent writing and running
    tests is a well-placed investment.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您编写更多的测试，测试套件的运行时间会变长。但您还会发现错误的数量往往会减少。您进行的测试越多，频率越高，您的代码就会越好。捕获您的测试指标可以作为时间花在编写和运行测试上的硬证据，这是一个明智的投资。
- en: There's more...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Why do I need this document? Don't I already know that testing works? Think
    of it as a backup for your assertion of quality. Months down the road, you may
    be challenged by management to speed things up. Maybe they need something faster,
    and they think you are simply spending too much time on this *testing stuff*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我需要这个文档？难道我不知道测试有效吗？把它看作是对质量断言的备份。几个月后，管理层可能会要求您加快速度。也许他们需要更快的东西，他们认为您只是在*测试这些东西*上花费了太多时间。
- en: If you can pull out your spreadsheet and show how bugs decreased with testing
    effort, they will have little to argue with. But if you don't have this, and simply
    argue that *testing makes things better*, you may lose the argument.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以拿出您的电子表格，并展示随着测试工作的减少而减少的错误，他们将无从辩驳。但如果您没有这个，只是争辩说*测试会让事情变得更好*，您可能会输掉争论。
- en: Metrics aren't just for defending yourself to management
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 度量标准不仅仅是为了向管理层辩护
- en: I personally enjoyed seeing the tests grow and the bugs decline. It was a personal
    way to track myself and keep a handle on how much progress was made. And, to be
    honest, my last manager gave me full support for automated testing. He had his
    own metrics of success, so I never had to pull out mine.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人很享受看到测试增加而错误减少。这是一种追踪自己并掌握进展情况的个人方式。而且，说实话，我的上一个经理完全支持自动化测试。他有自己的成功指标，所以我从未拿出过我的。
- en: Capturing a bug in an automated test
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在自动化测试中捕获错误
- en: Before you fix that one-line bug you spotted, write an automated test instead,
    and make sure it's repeatable. This helps to build up insulation from our system,
    regressing back into failures we fixed in the past.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复您发现的一行错误之前，先编写一个自动化测试，并确保它是可重复的。这有助于建立我们的系统免受回归到过去修复的故障的影响。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: These high-level steps capture the workflow of capturing bugs in automated tests
    before
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些高层次的步骤捕获了在自动化测试中捕获错误之前的工作流程：
- en: 'we fix them:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修复它们：
- en: When a new bug is discovered, write a test case that recreates it. It doesn't
    matter if the test case is long-running, complex, or integrates with lots of components.
    The critical thing is to reproduce the bug.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发现新错误时，编写一个重现它的测试用例。测试用例是否运行时间长、复杂或与许多组件集成并不重要。关键的是要重现错误。
- en: Add the bug to your suite of tests.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将错误添加到您的测试套件中。
- en: Fix the bug.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复错误。
- en: Verify that the test suite passes before checking your changes.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查更改之前，确保测试套件通过。
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The simplest way to introduce automated testing to an application that never
    had it before is to test one bug at a time. This method ensures that newly discovered
    bugs won't sneak back into the system later on.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 向从未进行过自动化测试的应用程序引入自动化测试的最简单方法是一次测试一个错误。这种方法确保新发现的错误不会在以后悄悄地重新进入系统。
- en: The tests may have a loose-knit feel instead of a comprehensive one, but that
    doesn't matter. What does matter is that, over time, you will slowly develop a
    solid safety net of test cases that verify that the system performs as expected.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可能会给人一种松散的感觉，而不是全面的感觉，但这并不重要。重要的是，随着时间的推移，您将慢慢建立一个可靠的测试用例安全网，验证系统的预期性能。
- en: There's more...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: I didn't say this would be easy. Writing an automated test for software that
    wasn't built with testability in mind is hard work. As mentioned in the recipe
    *Something is better than nothing*, the first test case is probably the hardest.
    But, over time, as you develop more tests, you will gain the confidence to go
    back and refactor things. You will definitely feel empowered by knowing that you
    can't break things without realizing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我并没有说这会很容易。为没有考虑可测试性的软件编写自动化测试是一项艰苦的工作。正如在配方*有总比没有好*中提到的，第一个测试用例可能是最难的。但随着时间的推移，随着你编写更多的测试，你将获得信心回头重构事物。你一定会感到有能力，因为你知道你不会不知不觉地破坏事物。
- en: When the time comes to add a completely new module, you will be ready for it
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当需要添加一个全新的模块时，你将为此做好准备。
- en: This approach of capturing a bug with a test case is useful, but slow. But that's
    OK, because slowly adding testing will give you time to grow your testing skills
    at a comfortable pace.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 用这种方法通过测试用例捕获错误是有用的，但速度慢。但没关系，因为慢慢添加测试会让你有时间以舒适的步伐提高你的测试技能。
- en: 'Where does this pay off? Well, eventually, you will need to add a new module
    to your system. Doesn''t this always happen? By that time, your investment in
    testing and test fixtures should already be paying dividends in the improvement
    of the quality of existing code, but you will also have a head start on testing
    the new module. Consider the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这会有什么好处呢？嗯，最终，你将需要向你的系统添加一个新模块。这总是会发生的吧？到那时，你在测试和测试装置上的投资应该已经在提高现有代码质量方面产生了回报，但你也将在测试新模块上有一个先发优势。考虑以下：
- en: You will not just know, but *really understand*, the meaning of *test-oriented
    code.*
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不仅会知道，而且*真正理解*“面向测试的代码”的含义。
- en: You will be able to write both the code and its tests at the same time in a
    very effective way.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将能够以非常有效的方式同时编写代码和测试。
- en: The new module will have a head start of higher quality and will not require
    as much effort to *catch up* as the legacy parts of your system did.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新模块将有更高质量的先发优势，不需要像系统的传统部分那样需要太多的努力来*赶上*。
- en: Don't give into the temptation to skip testing
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要屈服于跳过测试的诱惑。
- en: As I stated earlier, the first test case will be very hard to write. And the
    next few after that won't be much easier. This makes it very tempting to throw
    up your hands and skip automated testing. But, if you stick with it and write
    something that works, you can continue building on that successful bit of effort.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，第一个测试用例将非常难写。接下来的几个也不会容易。这让人很容易举手投降，跳过自动化测试。但是，如果你坚持下去，写出一些有效的东西，你就可以继续在这个成功的努力上建立。
- en: This may sound like a cliché, but if you stick with it for about a month, you
    will start to see some results from your work. This is also a great time to start
    **harvesting metrics**. Capturing your progress and being able to reflect on it
    can provide positive encouragement.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来像陈词滥调，但如果你坚持大约一个月，你将开始从你的工作中看到一些结果。这也是开始**收集指标**的好时机。记录你的进展并能够反思它可以提供积极的鼓励。
- en: Separating algorithms from concurrency
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将算法与并发分离
- en: Concurrency is very hard to test, but most algorithms are not when decoupled.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 并发性很难测试，但大多数算法在解耦后并不难。
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Herb Sutter wrote an article in 2005 entitled *The Free Lunch Is Over*, where
    he pointed out how microprocessors are approaching a physical limitation in serial
    processing, which will be forcing developers to turn towards concurrent solutions
    ([http://www.gotw.ca/publications/concurrency-ddj.htm](http://www.gotw.ca/publications/concurrency-ddj.htm)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Herb Sutter在2005年写了一篇文章，题为*免费午餐结束了*，他指出微处理器正在接近串行处理的物理极限，这将迫使开发人员转向并发解决方案（[http://www.gotw.ca/publications/concurrency-ddj.htm](http://www.gotw.ca/publications/concurrency-ddj.htm)）。
- en: Newer processors come with multiple cores. To build scalable applications, we
    can no longer just wait for a faster chip. Instead, we must use alternate, concurrent
    techniques. This issue is being played out in a whole host of languages. Erlang
    was one of the first languages on the scene that allowed a telecommunications
    system to be built with nine 9's of availability, which means about one second
    of downtime every 30 years.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 新的处理器配备了多个核心。为了构建可扩展的应用程序，我们不能再只等待更快的芯片。相反，我们必须使用替代的并发技术。这个问题正在许多语言中得到解决。 Erlang
    是第一种允许用于构建可用性为九个9的电信系统的语言之一，这意味着每30年大约有一秒的停机时间。
- en: One of its key features is the use of immutable data sent between actors. This
    provides nice isolation and allows multiple units to run across the CPU cores.
    Python has libraries that provide a similar style of decoupled, asynchronous message
    passing. The two most common ones are Twisted and Kamaelia.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个关键特点是在actor之间发送不可变数据。这提供了良好的隔离，并允许多个单元在CPU核心上运行。Python有提供类似解耦的异步消息传递风格的库。最常见的两个是Twisted和Kamaelia。
- en: 'But, before you dive into using either of these frameworks, there is something
    important to keep in mind: it''s very hard to test concurrency while also testing
    algorithms. To use these libraries, you will register code that issues messages
    and also registers handlers to process messages.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在你开始使用这些框架之前，有一件重要的事情要记住：很难在测试并发性的同时测试算法。要使用这些库，你需要注册发出消息的代码，还需要注册处理消息的处理程序。
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It's important to decouple the algorithms from the machinery of whatever concurrency library
    you pick. This will make it much easier to test the algorithms, but it doesn't
    mean that you shouldn't conduct load tests or try to overload your system with
    live data playback scenarios.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将算法与所选择的并发库的机制解耦是很重要的。这将使测试算法变得更容易，但这并不意味着你不应该进行负载测试或尝试用实时数据回放场景来过载你的系统。
- en: What it does mean is that starting with large volume test scenarios is the wrong
    priority. Your system needs to correctly handle one event in an automated test
    case before it can handle a thousand events.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 它的意思是，从大量测试场景开始是错误的优先级。在能够处理一次事件的自动化测试用例之前，你的系统需要正确处理一个事件。
- en: Research test options provided by your concurrency frameworks
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 研究并发框架提供的测试选项
- en: A good concurrency library should provide sound testing options. Seek them out
    and try to use them to their fullest. But don't forget to verify that your custom
    algorithms work in simple, serial fashion as well. Testing both sides will give
    you great confidence that the system is performing as expected under light and
    heavy loads.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的并发库应该提供可靠的测试选项。寻找它们并尽量使用。但不要忘记验证你的自定义算法在简单的串行方式下也能工作。测试两边将给你很大的信心，系统在轻载和重载下都能如预期地运行。
- en: Pause to refactor when a test suite takes too long to run
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当测试套件运行时间太长时，暂停重构
- en: As you start to build a test suite, you may notice the runtime getting quite
    long. If it's so long that you aren't willing to run it at least once a day, you
    need to stop coding and focus on speeding up the tests, whether it involves the
    tests themselves or the code being tested.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始构建测试套件时，你可能会注意到运行时间变得相当长。如果它太长，以至于你不愿意每天至少运行一次，你需要停止编码并专注于加快测试的速度，无论是测试本身还是被测试的代码。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'This assumes you have started to build a test suite using some of the following
    practices:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设你已经开始使用以下一些实践来构建测试套件：
- en: Something is better than nothing
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有总比没有好
- en: Be willing to invest in test fixtures
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 愿意投资测试装置
- en: Capturing a bug in an automated test
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自动化测试中捕捉错误
- en: These are slow-starting steps to start adding tests to a system that was originally
    built without any automated testing. One of the trade-offs to get moving on automated
    testing involves writing relatively expensive tests. For instance, if one of your
    key algorithms is not adequately decoupled from the database, you will be forced
    to write a test case that involves setting up some tables, processing the input
    data, and then making queries against the state of the database afterward.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是缓慢开始的步骤，用于在最初没有任何自动化测试的系统中开始添加测试。进行自动化测试的一个权衡是编写相对昂贵的测试。例如，如果你的关键算法与数据库没有足够解耦，你将被迫编写一个涉及设置一些表、处理输入数据，然后针对数据库状态进行查询的测试用例。
- en: As you write more tests, the time to run the test suite will certainly grow.
    At some point, you will feel less inclined to spend the time waiting for your
    test suite to run. Since a test suite is only good when used, you must pause development
    and pursue refactoring either the code or the test cases themselves to speed things
    up.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你编写更多的测试，运行测试套件的时间肯定会增加。在某个时候，你会感到不太愿意花时间等待测试套件运行的时间。由于测试套件只有在使用时才有效，你必须暂停开发并追求重构代码或测试用例本身，以加快速度。
- en: 'Here is a problem I ran into: my test suite initially took about 15 minutes
    to run. It eventually grew to take one-and-a-half hours to run all the tests.
    I reached a point where I would only run it once a day, and even skipped some
    days. One day, I tried to do a massive code edit. When most of the test cases
    failed, I realized that I had not run the test suite often enough to detect which
    step broke things. I was forced to throw away all the code edits and start over.
    Before proceeding further, I spent a few days refactoring the code as well as
    the tests, bringing the run time of the test suite back down to a tolerable 30
    minutes.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我遇到的一个问题：我的测试套件最初需要大约15分钟才能运行。最终它增长到需要一个半小时来运行所有的测试。我达到了一个只能每天运行一次，甚至跳过一些天的地步。有一天，我试图进行大规模的代码编辑。当大部分测试用例失败时，我意识到我没有经常运行测试套件来检测哪一步出了问题。我被迫放弃所有的代码编辑并重新开始。在继续之前，我花了几天时间重构代码和测试，将测试套件的运行时间降低到可以接受的30分钟。
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'That is the key measurement: when you feel hesitant to run the test suite more
    than *once **a day*, this may be a sign that things need to be cleaned up. Test
    suites are meant to be run multiple times a day.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关键的衡量标准：当你对每天运行测试套件感到犹豫不决时，这可能是需要清理的迹象。测试套件应该被多次运行一天。
- en: 'This is because we have competing interests: *writing code* and *running tests*.
    It''s important to recognize these things:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们有竞争的利益：*编写代码*和*运行测试*。重要的是要认识到这些事情：
- en: To run tests, we must suspend our coding efforts
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要运行测试，我们必须暂停编码工作
- en: To write more code, we must suspend testing efforts
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要编写更多的代码，我们必须暂停测试工作
- en: When testing takes a big chunk of our daily schedule, we must start choosing
    which is more important. We tend to migrate toward writing more code, and this
    is probably the key reason people abandon automated testing and consider it unsuitable
    for their situation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试占据我们日常时间表的大部分时，我们必须开始选择哪个更重要。我们倾向于更多地写代码，这可能是人们放弃自动化测试并认为它不适合他们情况的关键原因。
- en: It's tough, but if we can resist taking the easy way out, and instead do some
    refactoring of either the code or our tests, we will be encouraged to run the
    tests more often.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这很困难，但如果我们能抵制走捷径的诱惑，而是对代码或测试进行一些重构，我们将更有动力更频繁地运行测试。
- en: There's more...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'It''s less science and more voodoo when it comes to what to refactor. It''s
    important to seek out opportunities that give us a good yield. It''s important
    to understand that this can be either our test code, our production code, or a
    combination of both that needs to be refactored. Consider the following points:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构方面，这更少是科学而更多是巫术。重要的是要寻找能够给我们带来良好收益的机会。重要的是要理解，这可以是我们的测试代码，我们的生产代码，或者两者的组合都需要重构。考虑以下几点：
- en: Performance analysis can show us where the hotspots are. Refactoring or rewriting
    these chunks can improve tests.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析可以告诉我们热点在哪里。重构或重写这些部分可以改进测试。
- en: Tight coupling often forces us to put in more parts of the system than we want,
    such as database usage. If we can look for ways to decouple the code from the
    database and replace it with mocks or stubs, that sets us up to update the relevant
    tests to come up with a faster running test suite.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧耦合通常会迫使我们放入比我们想要的更多的系统部分，比如数据库使用。如果我们可以寻找方法将代码与数据库解耦，并用模拟或存根替换它，那么我们就可以更新相关的测试，以获得更快的测试套件运行。
- en: Coverage obtained from tests can help. All of these approaches have positive
    consequences for our code's quality. More efficient algorithms lead to better
    performance, and looser coupling helps to keep our long-term maintenance costs
    down.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试中获得的覆盖率可以帮助。所有这些方法对我们代码的质量都有积极的影响。更高效的算法会带来更好的性能，更松散的耦合有助于降低我们的长期维护成本。
- en: See also
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Be willing to throw away an entire day''s changes*'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*愿意放弃一整天的更改*'
- en: Cash in on your confidence
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用你的信心
- en: After building up enough tests, you will feel confident enough to rewrite a
    big chunk of code or conduct shotgun surgery that touches almost every file. Go
    for it!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 建立足够的测试后，你会有足够的信心重写大部分代码或进行几乎触及每个文件的大规模修改。去做吧！
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: As you build more tests and run them several times a day, you will start to
    get a feel for what you know and don't know about the system. Even more so, when
    you've written enough expensive, long-running tests about a particular part of
    the system, you will feel a strong desire to rewrite that module.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你构建更多的测试并每天运行多次，你会开始对系统的了解和不了解有所感觉。尤其是当你为系统的特定部分编写了足够昂贵、运行时间长的测试后，你会有强烈的愿望重写该模块。
- en: What are you waiting for? This is the point of building a runnable safety net
    of tests. Understanding the ins and outs of a module gives you the knowledge to
    attack it. You may rewrite it, be able to better decouple its parts, or whatever
    else is needed to make it work better, as well as being able to better support
    tests.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你还在等什么？这就是构建可运行的测试安全网的关键。了解模块的各个方面可以让你攻克它。你可以重写它，更好地解耦它的部分，或者进行其他必要的改进，同时也能更好地支持测试。
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: While you may feel a strong desire to attack the code, there may be an equal
    and opposing feeling to resist making such changes. This is risk aversion, and
    we all have to deal with it. We want to avoid diving in head first to a situation
    that could have drastic consequences.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能会有强烈的愿望攻击代码，但可能会有同样强烈的反对感。这是风险规避，我们都必须处理。我们希望避免头等跳进可能产生严重后果的情况。
- en: Assuming we have built an adequate safety net, it's time to engage the code
    and start cleaning it up. If we run the test suite frequently while making these
    changes, we can safely move through the changes we need to make. This will improve
    the quality of the code and will possibly speed up the runtime of the test suite.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经建立了足够的安全网，现在是时候着手处理代码并开始清理它了。如果我们在进行这些更改时频繁运行测试套件，我们可以安全地进行所需的更改。这将提高代码的质量，并可能加快测试套件的运行时间。
- en: '**While making changes, we don''t have to go all in**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**在进行更改时，我们不必全力以赴**'
- en: Cashing in on our confidence means we move in and make changes to the code base,
    but it doesn't mean we go into areas of code where the tests are shallow and inadequate.
    There may be several areas we want to clean up, but we should only go after the
    parts we are most confident about. There will be future opportunities to get the
    other parts as we add more tests in the future.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们的信心意味着我们可以进入并对代码进行更改，但这并不意味着我们可以进入测试不充分、不足的代码区域。我们可能想要清理几个区域，但我们应该只处理我们最有信心的部分。随着我们在未来添加更多的测试，将有机会处理其他部分。
- en: Be willing to throw away an entire day's changes
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 愿意放弃一整天的更改
- en: Have you ever worked for a whole day making changes, only to discover that half
    the tests failed because you forgot to run the test suite more often? Be ready
    to throw away the changes. This is what automated testing lets us do… back up
    to when everything ran perfectly. It will hurt, but next time you will remember
    to run the test suite more often.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有曾经整天进行更改，只发现一半的测试失败，因为你忘记经常运行测试套件？准备好放弃这些更改。这就是自动化测试让我们能够做到的……回到一切都运行完美的时候。这会很痛苦，但下次你会记得更经常运行测试套件。
- en: How to do it...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: This recipe assumes you are using version control and are making regular commits.
    This idea is no good if you haven't made a commit for two weeks.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法假设你正在使用版本控制并进行定期提交。如果你两周没有提交，这个想法就不适用。
- en: If you run your test suite at least once a day, and when it passes, you commit
    the changes you have made, then it becomes easy to back up to some previous point,
    such as the beginning of the day.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你每天至少运行一次测试套件，并且在通过后提交你所做的更改，那么回到某个之前的时间点，比如一天的开始，就会变得容易。
- en: I have done this many times. The first time was the hardest. It was a new idea
    to me, but I realized the real value of software was now resting on my automated
    test suite. In the middle of the afternoon, I ran the test suite for the first
    time that day after having edited half the system. Over half of the tests failed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我做过很多次。第一次是最困难的。对我来说，这是一个新的想法，但我意识到软件的真正价值现在依赖于我的自动化测试套件。在下午的中途，我第一次运行了当天编辑了一半系统的测试套件。超过一半的测试失败了。
- en: I tried to dig in and fix the issue. The trouble was, I couldn't figure out
    where the issue stemmed from. I spent a couple of hours trying to track it down.
    It began to dawn on me that I wasn't going to figure it out without wasting loads
    of time.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我试图深入挖掘并修复问题。问题在于，我无法弄清楚问题的根源。我花了几个小时试图追踪它。我开始意识到，如果不浪费大量时间，我是无法弄清楚的。
- en: But I remembered that everything had passed with flying colors the previous
    day. I finally decided to throw away my changes, run the test suite, verifying
    everything passed, and then grudgingly go home for the day.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 但我记得前一天一切都通过了。最终，我决定放弃我的更改，运行测试套件，验证一切都通过了，然后勉强回家。
- en: The next day, I attacked the problem again. Only, this time, I ran the tests
    more often. I was able to get it coded successfully. Looking back at the situation,
    I realize that this issue only cost me one lost day. If I had tried to ride it
    out, I could have spent a week and *still* probably ended up throwing things away.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 第二天，我再次攻击了这个问题。只是，这一次，我更频繁地运行测试。我成功地编写了它。回顾这种情况，我意识到这个问题只花了我一天的时间。如果我试图坚持下去，我可能会花费一周的时间，*最终*可能还是要扔掉一切。
- en: How it works...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Depending on how your organization manages source control, you may have to
    do the following things:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的组织如何管理源代码，你可能需要做以下事情：
- en: Simply do it yourself by deleting a branch or canceling your checkouts
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过删除分支或取消你的检出来自己做
- en: Contact your CM team to delete the branch or the commits you made for the day
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系你的CM团队删除当天的分支或提交
- en: This isn't really a technical issue. The source control system makes it easy
    to do this regardless of who is in charge of branch management. The hard part
    is making the decision to throw away the changes. We often feel the desire to
    fix what is broken. The more our efforts cause it to break further, the more we
    want to fix it. At some point, we must realize that it is more costly to move
    forward rather than to back up and start again.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上不是一个技术问题。无论谁负责分支管理，源代码控制系统都很容易做到这一点。困难的部分是做出放弃更改的决定。我们经常感到修复问题的愿望。我们的努力导致问题进一步恶化，我们就越想解决它。在某个时候，我们必须意识到前进的成本更高，而不是倒退重新开始。
- en: There is an axis of agility that stretches from classic waterfall software production
    to heavily agile processes. Agile teams tend to work in smaller sprints and commit
    in smaller chunks. This makes it more palatable to throw away a day of work. The
    bigger the task and the longer the release cycle, the greater the odds are that
    your changes haven't been checked since you started a task two weeks ago.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷性的轴从经典的瀑布式软件生产延伸到高度敏捷的流程。敏捷团队倾向于在较小的冲刺中工作，并以较小的块提交。这使得抛弃一天的工作更容易接受。任务越大，发布周期越长，你的更改自两周前开始任务以来就没有被检查的可能性就越大。
- en: Believe me, throwing away two weeks' work is totally different than throwing
    away one day's worth. I would never advocate throwing out two weeks' work.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 相信我，放弃两周的工作完全不同于放弃一天的工作。我绝不会主张放弃两周的工作。
- en: The core idea is to *not* go home without your test suite passing. If that means
    you have to throw things away to make it happen, then that is what you must do.
    It really drives the point home of *code a little/test a little* until a new feature
    is ready for release.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 核心思想是*不要*在测试套件未通过的情况下回家。如果这意味着你必须放弃一些东西才能实现这一点，那就是你必须做的。这真的强调了*编写一点/测试一点*的重点，直到新功能准备好发布。
- en: There's more...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We also need to reflect on why didn't we run the test suite often enough. It
    may be because the test suite is taking too long to run, and you are hesitating
    to use up that time. It may be time to *pause to refactor when the test suite
    takes too long to run*. The time I really learned this lesson was when my test
    suite took one-and-a-half hours to run. After I got through this whole issue,
    I realized that I needed to speed things up and spent probably a week or two cutting
    it down to a tolerable 30 minutes.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要反思为什么我们没有经常运行测试套件。这可能是因为测试套件运行时间太长，你在犹豫是否要花费那么长的时间。也许是时候*暂停重构当测试套件运行时间太长*了。我真正学到这个教训的时候是当我的测试套件运行了一个半小时。在解决了整个问题之后，我意识到我需要加快速度，花了大概一两个星期将其缩短到可以接受的30分钟。
- en: How does this mesh with "Something is better than nothing"
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这与“有总比没有好”如何契合
- en: Earlier in this chapter, we talked about writing a test case that may be quite
    expensive to run to get automated testing in action. What if our testing becomes
    so expensive that it is time prohibitive? After all, couldn't what we just said
    lead to the situation we are dealing with?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们谈到了编写一个可能非常昂贵的测试用例来启动自动化测试。如果我们的测试变得如此昂贵以至于时间上不可行呢？毕竟，我们刚才说的不是会导致我们正在处理的情况吗？
- en: '*Code a little/test a little* may seem to be a very slow way to proceed. This
    is probably the reason many legacy systems never embrace automated testing. The
    hill we must climb is steep. But if we can hang in there, start building the tests,
    make sure they run at the end of the day, and then eventually pause to refactor
    our code and tests, we can eventually reach a happy balance of better code quality
    and system confidence.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*编写一点代码/测试一点*可能看起来是一个非常缓慢的进行方式。这可能是许多传统系统从未采用自动化测试的原因。我们必须攀登的山是陡峭的。但是，如果我们能坚持下去，开始构建测试，确保它们在一天结束时运行，然后最终暂停重构我们的代码和测试，我们最终可以达到更好的代码质量和系统信心的愉快平衡。'
- en: See also
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: Something is better than nothing
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有总比没有好
- en: Pause to refactor when a test suite takes too long
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当测试套件运行时间太长时，暂停重构
- en: Instead of shooting for 100 percent coverage, try to have a steady growth
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 而不是追求100%的覆盖率，试着保持稳定的增长
- en: You won't know how you're doing without coverage analysis. However, don't aim
    too high. Instead, focus on a gradual increase. You will find that your code gets
    better over time—maybe even drops in volume—while the quality and coverage steadily
    improve.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 没有覆盖分析，你不会知道自己的情况。但不要追求太高。相反，专注于逐渐增加。你会发现随着时间的推移，你的代码变得更好——甚至可能减少了量——而质量和覆盖率稳步提高。
- en: How to do it...
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: If you start with a system that has no tests, don't get focused on a ridiculously
    high number. I worked on a system that had 16% coverage when I picked it up. A
    year later, I had worked it up to 65%. This was nowhere near 100%, but the quality
    of the system had grown in leaps and bounds due to capturing a bug in an automated
    test and harvesting metrics.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从一个没有测试的系统开始，不要过分关注一个荒谬的高数字。我曾经在一个系统上工作，当我接手它时，覆盖率为16%。一年后，我把它提高到了65%。这离100%还差得远，但由于捕获了自动化测试中的一个错误和收集了指标，系统的质量得到了飞跃式的提高。
- en: At one time, I was discussing the quality of my code with my manager, and he
    showed me a report he had developed. He had run a code-counting tool on every
    release of every application he was overseeing. He said my code counts had a unique
    shape. All the
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有一次，我和我的经理讨论了我的代码质量，他给我展示了他开发的一份报告。他对他监督的每个应用程序的每个版本运行了一个代码计数工具。他说我的代码计数有一个独特的形状。所有的
- en: other tools had a constant increase in lines of code. Mine had grown, peaked,
    and then started to decrease and were still on the decline.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 其他工具的代码行数不断增加。我的代码增长，达到顶峰，然后开始减少，仍然在下降。
- en: This happened despite the fact that my software did more than ever. It's because
    I started throwing away unused features, bad code, and clearing out cruft during
    refactorings.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我的软件做的比以往任何时候都多，但这种情况发生了。这是因为我开始丢弃未使用的功能、糟糕的代码，并在重构过程中清理垃圾。
- en: How it works...
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By slowly building an automated test suite, you will gradually cover more of
    your code. By keeping a focus on building quality code with corresponding tests,
    the coverage will grow naturally. When we shift to focusing on coverage reports,
    the numbers may grow more quickly, but it will tend to be more artificial.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逐渐构建一个自动化的测试套件，你将逐渐覆盖更多的代码。通过专注于构建具有相应测试的高质量代码，覆盖率将自然增长。当我们开始关注覆盖率报告时，数字可能会增长得更快，但往往会更加人为。
- en: From time to time, as you cash in on your confidence and rewrite chunks, you
    should feel empowered to throw away old junk. This will also grow your coverage
    metrics in a healthy way.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 不时地，当你充分利用你的信心并重写大块内容时，你应该感到有能力丢弃旧的垃圾。这也会以健康的方式增加你的覆盖度指标。
- en: All of these factors will lead to increased quality and efficiency. While your
    code may eventually peak and then decrease, it isn't unrealistic for it to eventually
    grow again due to new features.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些因素将导致质量和效率的提高。虽然你的代码可能最终会达到顶峰，然后下降，但由于新功能的增加，它最终会再次增长并不是不切实际的。
- en: By that time, the coverage will probably be much higher, because you will be
    building completely new features, hand in hand with tests, instead of just maintaining
    legacy parts.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 到那时，覆盖率可能会更高，因为你将与测试一起构建全新的功能，而不仅仅是维护传统的部分。
- en: Randomly breaking up your app can lead to better code
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机地打破你的应用程序可能会导致更好的代码
- en: '"*The best way to avoid failure is to fail constantly.*"– Netflix'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '"*避免失败的最好方法是不断地失败。*" - Netflix'
- en: How to do it...
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Netflix has built a tool they call **Chaos Monkey**. Its job is to randomly
    kill instances and services. This forces developers to make sure their system
    can fail smoothly and safely. To build our own version of this, some of the things
    we would need it to do are the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix建立了一个他们称之为**混沌猴**的工具。它的工作是随机杀死实例和服务。这迫使开发人员确保他们的系统可以平稳和安全地失败。为了建立我们自己的版本，我们需要它做以下事情：
- en: Randomly kill processes
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机杀死进程
- en: Inject faulty data at interface points
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接口点注入错误数据
- en: Shut down network interfaces between distributed systems
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭分布式系统之间的网络接口
- en: Issue shutdown commands to subsystems
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向子系统发出关闭命令。
- en: Create denial-of-service attacks by overloading interface points with too much
    data
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过向接口点过载太多数据来创建拒绝服务攻击
- en: This is a starting point. The idea is to inject errors wherever you can imagine
    them happening. This may require writing scripts, Cron jobs, or any means necessary
    to cause these errors to happen.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个起点。这个想法是在你能想象到的任何地方注入错误。这可能需要编写脚本、Cron作业或任何必要的手段来引发这些错误。
- en: How it works...
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Given that there is a chance of a remote system being unavailable in production,
    we should introduce ways for this to happen in our development environment. This
    will encourage us to code higher fault tolerance into our system.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到远程系统在生产中可能不可用的可能性，我们应该在开发环境中引入这种情况。这将鼓励我们在系统中编写更高的容错性。
- en: Before we introduce a random-running Chaos Monkey such as Netflix has, we need
    to ensure that our system can handle these situations manually. For example, if
    our system includes communication between two servers, a fair test is unplugging
    the network cable to one box, simulating network failure. When we verify that
    our system can continue working with acceptable means, then we can add scripts
    to do this automatically and, eventually, randomly.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们引入像Netflix那样的随机运行混沌猴之前，我们需要确保我们的系统可以手动处理这些情况。例如，如果我们的系统包括两个服务器之间的通信，一个公平的测试是拔掉一个盒子的网络电缆，模拟网络故障。当我们验证我们的系统可以继续工作并且采取了可接受的手段时，我们可以添加脚本来自动执行这些操作，最终是随机的。
- en: Audit logs are valuable tools to verify that our system is handling these random
    events. If we can read a log entry showing a forced network shutdown and then
    see log entries of similar timestamps, we can easily evaluate whether the system
    handled the situation.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 审计日志是验证我们的系统是否处理这些随机事件的有价值的工具。如果我们可以读取一个显示强制网络关闭的日志条目，然后看到类似时间戳的日志条目，我们可以轻松地评估系统是否处理了这种情况。
- en: After building that in, we can work on the next error to randomly introduce
    into the system. By following this cycle, we can build up the robustness of our
    system.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建好之后，我们可以开始处理系统中随机引入的下一个错误。通过遵循这个循环，我们可以提高系统的健壮性。
- en: There's more...
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This doesn't exactly fit into the realm of automated testing. This is also very
    high level. It's hard to go into much more detail, because the type of faulty
    data to inject requires an intimate understanding of the actual system.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不完全符合自动化测试的范畴。这也是非常高层次的。很难进一步详细说明，因为要注入的错误数据类型需要对实际系统有深入的了解。
- en: How does this compare to fuzz testing?
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这与模糊测试有什么区别？
- en: '**Fuzz testing** is a style of testing where invalid, unexpected, and random
    data is injected into input points of our software ([http://en.wikipedia.org/wiki/Fuzz_testing](http://en.wikipedia.org/wiki/Fuzz_testing)).
    If the application fails, this is considered a failure. If it doesn''t, then it
    has passed. This type of testing goes in a similar direction, but the blog article
    written by Netflix appears to go much further than simply injecting different
    data. It talks about killing instances and interrupting distributed communications.
    Basically, anything you can think of that could happen in production, we should
    try to replicate in a test bed. **Fusil** ([https://bitbucket.org/haypo/fusil](https://bitbucket.org/haypo/fusil))
    is a Python tool that aims to provide fuzz testing. You may want to investigate
    whether it is useful for your project needs.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**模糊测试**是一种测试方式，其中无效的、意外的和随机的数据被注入到软件的输入点中（[http://en.wikipedia.org/wiki/Fuzz_testing](http://en.wikipedia.org/wiki/Fuzz_testing)）。如果应用程序失败，这被认为是一个失败。如果没有失败，那么它就通过了。这种测试方式走的方向类似，但Netflix撰写的博客文章似乎比简单地注入不同的数据要深入得多。它谈到了杀死实例和中断分布式通信。基本上，任何你能想到的在生产中可能发生的事情，我们都应该在测试环境中尝试复制。**Fusil**（[https://bitbucket.org/haypo/fusil](https://bitbucket.org/haypo/fusil)）是一个旨在提供模糊测试的Python工具。你可能想调查一下它是否适合你的项目需求。'
- en: Are there any tools to help with this?
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有没有工具可以帮助这个？
- en: '**Jester** (for Java), **Pester** (for Python), and **Nester** (for C#) are
    used to conduct mutation testing ([http://jester.sourceforge.net/](http://jester.sourceforge.net/)).
    These tools find out what code is not covered by test cases, alter the source
    code, and rerun the test suites. Finally, they give a report on what was changed,
    what passed, and what didn''t pass. It can illuminate what is and is not covered
    by our test suites in ways coverage tools can''t.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jester**（用于Java），**Pester**（用于Python）和**Nester**（用于C#）用于进行突变测试（[http://jester.sourceforge.net/](http://jester.sourceforge.net/)）。这些工具找出了测试用例未覆盖的代码，改变源代码，然后重新运行测试套件。最后，它们会提供一个报告，报告了什么被改变了，什么通过了，什么没有通过。它可以揭示测试套件覆盖和未覆盖的内容，这是覆盖工具无法做到的。'
- en: This isn't a complete Chaos Monkey, but it provides one area of assistance by
    trying to *break the system* and force us to improve our test regime. To really
    build a full-blown system probably wouldn't fit inside a test project, because
    it requires writing custom scripts based on the environment it's meant to run
    in.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个完整的混沌猴，但它通过试图*破坏系统*提供了一种帮助，迫使我们改进我们的测试制度。要真正构建一个完整的系统可能不适合在一个测试项目中，因为它需要根据它所要运行的环境编写自定义脚本。
