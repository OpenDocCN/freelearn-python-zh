- en: Chapter 1. Choosing Your Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 选择你的工具
- en: In this chapter, we look at the many aspects of designing web applications.
    The idea is to provide you with an overview that may help you recognize components
    in subsequent chapters and give you some insight into the arguments used to decide
    which tool or library to use.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨设计Web应用程序的许多方面。目的是为你提供一个概述，这可能有助于你在后续章节中识别组件，并对你了解用于决定使用哪个工具或库的论据有所启发。
- en: Also, as this book covers more than just developing example applications, we
    illustrate some issues that are relevant when designing an application that does
    not deal with coding directly, like security or usability.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此外，由于本书不仅涵盖开发示例应用程序，我们还展示了在设计不直接涉及编码的应用程序时相关的一些问题，如安全或可用性。
- en: 'In this chapter, we will be:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Indentifying the components that a web application consists of
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别构成Web应用程序的组件
- en: Choosing suitable tools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的工具
- en: Considering what designing for maintainability and usability implies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到为可维护性和可用性设计意味着什么
- en: There is a lot of ground to cover, so let's get started.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多内容需要覆盖，所以让我们开始吧。
- en: Identifying the components of a web application
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别Web应用程序的组件
- en: A web application is not a monolithic object. In designing such an application,
    it might help focus if you look at an application as a collection of related objects,
    each with its well-defined purpose. This can be done with multiple levels of detail
    and even the mile high view may already give some valuable insights.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Web应用程序不是一个单一的对象。在设计这样的应用程序时，如果你将应用程序视为一系列相关对象，每个对象都有其明确的目的，这可能会帮助你集中注意力。这可以通过多个级别的细节来完成，甚至从高空俯瞰也可能已经提供了一些有价值的见解。
- en: Time for action getting an overview of a web application
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采取行动，了解Web应用程序概述
- en: From the following picture shown, it should be clear that a web application
    is not a singular thing. It consists of parts that reside on a server and parts
    that run on the computer of the user. Both halves are just as important; although
    the server may hold the application data and implement the logic to modify that
    data following requests from the user, the data is displayed by the part of the
    web application running in the browser on the client computer and the user signals
    his/her request by interacting with the user interface components in the browser,
    for example, by clicking on an "OK" button.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下图片中可以看出，Web应用程序不是一个单一的事物。它由位于服务器上的部分和运行在用户计算机上的部分组成。这两部分同样重要；尽管服务器可能持有应用程序数据并实现根据用户请求修改数据的逻辑，但数据是由运行在客户端计算机浏览器上的Web应用程序部分显示的，用户通过与浏览器中的用户界面组件交互来表示其请求，例如，通过点击“确定”按钮。
- en: '![Time for action getting an overview of a web application](img/3746OS_01_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![采取行动，了解Web应用程序概述](img/3746OS_01_01.jpg)'
- en: Think about your application and consider both server and client-side. The advantage
    of looking at the individual halves is that we might make choices that are optimal
    for the specific half.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思考你的应用程序，并考虑服务器端和客户端。查看单个部分的优势在于我们可能会做出对特定部分最优的选择。
- en: Look at the general requirements for the client half. For example, because we
    want to offer the user a sophisticated user interface, we opt for the jQuery UI
    library. This decision does not touch the overall design decision on the server,
    because apart from delivering the files that the jQuery UI library consists of,
    the choice of user interface library has no impact on the choice of the database
    engine or the server operating system for example.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看客户端的一般要求。例如，因为我们希望为用户提供一个复杂的用户界面，所以我们选择了jQuery UI库。这个决定并没有触及到服务器端的整体设计决策，因为除了提供jQuery
    UI库所包含的文件外，用户界面库的选择对数据库引擎或服务器操作系统的选择等没有影响。
- en: Look at the requirements for the server half. For example, consider which implementation
    language to use. We select Python as the language to implement the server-side
    code but if we had compelling arguments to switch to C#, we could do so without
    the need to change anything on the client.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看服务器端的要求。例如，考虑使用哪种实现语言。我们选择Python作为实现服务器端代码的语言，但如果我们有充分的理由切换到C#，我们可以在不改变客户端任何内容的情况下做到这一点。
- en: If we zoom in on our web application, an image emerges of many interacting layers,
    each encapsulating a well defined piece of functionality. Everywhere two layers
    touch, information flows through a well defined interface (API). This helps in
    the separation of concepts (our application is only talking to the database layer
    to store and retrieve persistent data and only to the web server to return data
    upon request) but in practice, the separation between these layers isn't completely
    clear in all circumstances. For example, the server-side part of our application
    is actually an integral part of the web server.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进一步观察我们的网络应用，会出现许多相互作用的层，每一层都封装了明确的功能部分。每当两层接触时，信息都会通过一个定义良好的接口（API）流动。这有助于概念上的分离（我们的应用只与数据库层通信以存储和检索持久数据，并且只与网络服务器通信以在请求时返回数据），但在实践中，这些层之间的分离在所有情况下并不总是完全清晰。例如，我们应用的客户端部分实际上是网络服务器的一个组成部分。
- en: This simple schematic of a web application is virtually identical to a regular
    client-server architecture. However, when we look more closely at the implementation
    of the client and the interaction between client and server, differences will
    emerge as we will see in the next section where we zoom in a bit closer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网络应用的基本架构图几乎与常规的客户端-服务器架构完全相同。然而，当我们更仔细地观察客户端的实现以及客户端与服务器之间的交互时，我们会发现一些差异，正如我们将在下一节中更近距离观察到的。
- en: What just happened?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: With both halves of the application identified, we can now zoom in on each individual
    half.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了应用的两部分之后，我们现在可以更深入地观察每一部分。
- en: This will enable us to get a more detailed image, that will help us to make
    informed decisions regarding the smaller components that make up our application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够获得更详细的图像，这将帮助我们就构成我们应用的小组件做出明智的决定。
- en: 'The main components are easy to identify:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 主要组件很容易识别：
- en: The data store holds data on the server (it is often a database engine, sometimes
    just files on the filesystem).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储在服务器上保存数据（通常是一个数据库引擎，有时只是文件系统上的文件）。
- en: The server-side application services requests that are passed through from the
    web server.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端应用处理从网络服务器传递过来的请求。
- en: The web server forwards those responses to the client again and may serve static
    files as well.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络服务器将这些响应再次转发给客户端，并且可能还会提供静态文件。
- en: 'The web browser takes care of running the client side of the application, but
    within the browser, we can identify several layers of activities. These consist
    of:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器负责运行应用的客户端部分，但在浏览器内部，我们可以识别出几个活动层。这些包括：
- en: Fetching the content to structure the data (often HTML files)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取内容以结构化数据（通常是HTML文件）
- en: Running JavaScript code to enhance the presentation of the data
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行JavaScript代码以增强数据的展示效果
- en: Allowing interaction with the user
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许与用户交互
- en: '![What just happened?](img/3746OS_01_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/3746OS_01_02.jpg)'
- en: Of course we could zoom in even further to reveal additional detail like the
    operating system on the client and the server, or even the hardware and the network
    components and although occasionally useful, this would generally be overkill.
    With the main components clearly identified, we can take the next step and choose
    suitable tools to implement these components.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以进一步放大以揭示更多细节，比如客户端和服务器上的操作系统，甚至硬件和网络组件，尽管偶尔有用，但通常会过度。在主要组件明确识别后，我们可以采取下一步，选择合适的工具来实现这些组件。
- en: Choosing suitable tools
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择合适的工具
- en: 'If you want to develop quality applications, you need suitable tools. Tools,
    of course, do not guarantee quality, but they can make life a lot easier. When
    developing web applications, there are two kinds of tools you need to consider:
    the ones you use to design, build, test, and deploy your application, like editors,
    version management systems, test frameworks, and maybe a package tool, and the
    tools that deliver your application to the end user. That last set of tools consists
    of a whole chain of components, from server operating system, web server, and
    database engine, all the way to the web browser and the JavaScript libraries used
    to display and interact with the application.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要开发高质量的应用，你需要合适的工具。当然，工具并不能保证质量，但它们可以使生活变得更加容易。在开发网络应用时，你需要考虑两种类型的工具：用于设计、构建、测试和部署应用的工具，如编辑器、版本管理系统、测试框架，可能还有打包工具，以及将应用交付给最终用户的工具。最后一组工具包括从服务器操作系统、网络服务器、数据库引擎，一直到网络浏览器和用于显示和与应用交互的JavaScript库的整个组件链。
- en: When we start a project, we have to know which tools we need and have to understand
    the capabilities and limitations of the many variations of these tools. There
    are, for example, quite a few JavaScript libraries that may be used to provide
    cross-browser compatible user interaction.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始一个项目时，我们必须知道我们需要哪些工具，并理解这些工具众多变体的功能和限制。例如，有相当多的JavaScript库可以用来提供跨浏览器的用户交互兼容性。
- en: The trick is to make an informed choice. These choices are not necessarily limited
    to open source tools. If budget permits, it might be worthwhile to have the benefit
    of the special features many commercial development tools and libraries offer,
    but in this book, we limit ourselves to open source and/or free resources. This
    makes sense as the cost of tooling and licenses in small projects can make a significant
    dent in a budget.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于做出明智的选择。这些选择不一定局限于开源工具。如果预算允许，利用许多商业开发工具和库提供的特殊功能可能是有益的，但在这本书中，我们限制自己使用开源和/或免费资源。这在小型项目中是有意义的，因为工具和许可证的成本可能会在预算中造成重大缺口。
- en: The opportunity to use free tools might not exist for the deployment environment.
    You may well develop your application on your own Linux box, but test and deploy
    it on a Windows server. The latter needs a license that will not be free, but
    even open source options are not always free. Many companies nowadays shift to
    deploying their applications to the cloud and even though these machines might
    be running an open source operating system, you pay not only for CPU power and
    bandwidth but also for support, the latter being crucial in applications that
    will lose you money if they are not running. However, using open source tools
    in general gives you a much wider choice because many tools run equally well on
    any platform.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署环境中，可能不存在使用免费工具的机会。你很可能在自己的Linux服务器上开发应用程序，但测试和部署它却在Windows服务器上。后者需要许可证，而这不会是免费的，即使是开源选项也不总是免费的。如今，许多公司转向将他们的应用程序部署到云端，尽管这些机器可能运行的是开源操作系统，但你不仅需要为CPU功率和带宽付费，还需要为支持付费，这在应用程序运行不正常时会损失金钱。然而，使用开源工具通常能给你提供更广泛的选择，因为许多工具在任何平台上都能运行得同样好。
- en: In the following sections, we will look at the many components that make up
    the tool chain and will try to show what arguments were used for the choices made
    for developing the applications in this book and what (if any) viable alternatives
    are there. Note that some arguments are quite subjective and the choice finally
    made does not necessarily indicate that the alternative is bad; we certainly are
    not attempting to start flame wars over which tool is better. We simply list requirements
    for application development as we see it and try to find the tools suitable for
    the task. In some situations, another tool might be better, but for this book,
    we try to find a matching toolset that can be used for all sample applications
    that are free (as in beer) and easy to learn and use.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨构成工具链的许多组件，并尝试展示在本书开发应用程序时使用的论据，以及（如果有的话）有哪些可行的替代方案。请注意，有些论据相当主观，最终做出的选择并不一定意味着替代方案不好；我们当然不是试图就哪个工具更好而引发争论。我们只是按照我们的看法列出应用程序开发的要求，并尝试找到适合任务的工具。在某些情况下，另一个工具可能更好，但为了这本书，我们试图找到可以用于所有示例应用程序的匹配的工具集，这些工具是免费的（就像啤酒一样），并且易于学习和使用。
- en: Time for action choosing a delivery framework, also known as web server
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择交付框架的时间，也称为Web服务器
- en: 'In the first section of this chapter, we showed that a web application lives
    in two realms at the same time, namely, on the server and on the client. In order
    to deliver information to the client and receive a response in return, our web
    application needs two important items at the server: a delivery framework and
    an application to compose content and respond to the request.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一节中，我们展示了Web应用程序同时存在于两个领域，即在服务器和客户端。为了向客户端提供信息并接收相应的响应，我们的Web应用程序需要在服务器上具备两个重要元素：一个交付框架和一个用于组合内容并响应请求的应用程序。
- en: The delivery framework might be a full-fledged general purpose web server such
    as Apache or Microsoft Information Server, but although these are very versatile
    and come with many options to tune the web server to your specific needs, they
    certainly take quite some time to get acquainted with and it takes extra attention
    to integrate the dynamic content of your application with these servers. If performance
    is crucial or the requirements for your project include that your application
    has to be deployed as part of these servers, you may not have a choice, but otherwise
    its worth looking at the alternatives that are simpler to use or offer integration
    advantages.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 交付框架可能是一个功能齐全的通用Web服务器，如Apache或Microsoft Information Server，尽管这些服务器非常灵活，提供了许多选项来调整Web服务器以满足您的特定需求，但它们确实需要相当长的时间来熟悉，并且需要额外的关注来将这些服务器与您应用程序的动态内容集成。如果性能至关重要或您的项目要求您的应用程序必须作为这些服务器的一部分部署，您可能别无选择，但否则，值得考虑使用更简单或提供集成优势的替代方案。
- en: So what do we need?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们需要什么？
- en: A fairly lightweight web server that is easy to configure and maintain
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个相当轻量级的Web服务器，易于配置和维护
- en: That allows for smooth integration of static and dynamic content
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得静态和动态内容的平滑集成成为可能
- en: That comes with reusable components that ease the development process
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它附带可重用组件，简化了开发过程
- en: That is actively maintained and developed
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是积极维护和开发的
- en: Given these requirements, our choice for delivery framework is CherryPy.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些要求，我们选择的交付框架是CherryPy。
- en: What just happened?
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'CherryPy fits the bill nicely. Its main advantages are:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: CherryPy非常适合。其主要优势包括：
- en: CherryPy is written in Python and components that deliver dynamic content are
    written as Python classes that are tightly integrated with CherryPy's core.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CherryPy是用Python编写的，提供动态内容的组件作为与CherryPy核心紧密集成的Python类编写。
- en: CherryPy comes with a whole host of **tools**; reusable components that can
    be used to implement anything from custom error pages to session management.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CherryPy附带了一系列**工具**；可重用的组件，可用于实现从自定义错误页面到会话管理的一切。
- en: CherryPy has a proven track record as the core web server of the larger TurboGears
    network.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CherryPy作为更大TurboGears网络的核心Web服务器，有着可靠的记录。
- en: And finally, CherryPy is actively developed and enjoys a large user community.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，CherryPy正在积极开发中，并拥有庞大的用户群体。
- en: The disadvantage of being written in Python is that performance might not be
    top notch, but we will look into that in the next section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python编写的缺点是性能可能不是最佳，但我们在下一节中会探讨这个问题。
- en: Time for action choosing a server-side scripting language
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择服务器端脚本语言的时间到了
- en: When developing web applications, you have a virtually unlimited choice of programming
    languages you can use, so we have to consider what is important for us in our
    project and make a tradeoff if necessary.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发Web应用程序时，您几乎可以选择使用任何编程语言，因此我们必须考虑我们项目中的重要因素，并在必要时做出权衡。
- en: Consider how important development time is compared to performance. Compiled
    languages like C# or C++ might be used if CPU power is scarce or if you do not
    want to distribute the source code in a readable format. But when development
    time is at a premium, using scripting languages often saves time as they make
    it easier to develop applications in an incremental way, even to the point where
    you can type in commands interactively to see what is possible and later incorporate
    these trials in your code.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到开发时间与性能相比的重要性。如果CPU资源稀缺或您不想以可读的格式分发源代码，可以使用C#或C++等编译型语言。但当开发时间非常宝贵时，使用脚本语言通常可以节省时间，因为它们使得以增量方式开发应用程序变得更容易，甚至可以交互式地输入命令以查看可能的结果，并将这些试验后来整合到代码中。
- en: Performance is generally not an issue, especially when using scripting languages
    that are compiled to intermediate byte code, as is the case for languages like
    Python and Perl, for example. And while it is true that scripted languages are
    compiled each time they are run, this has a negligible effect when the program
    is a long running web application.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 性能通常不是问题，尤其是在使用编译成中间字节码的脚本语言时，例如Python和Perl等语言。虽然脚本语言每次运行时都会被编译，但当程序是一个长期运行的Web应用时，这种影响微乎其微。
- en: Weigh the importance of debugging. Interpreted languages are often simpler to
    debug as compiled languages, both because the debugger has access to more information
    that you may explore interactively if something breaks and because you can try
    out any modules you have written by interactively calling functions to see what
    happens.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑调试的重要性。解释型语言通常比编译型语言更容易调试，因为调试器可以访问更多可能交互式探索的信息，如果出现问题，并且你可以通过交互式调用函数来尝试你编写的任何模块，以查看会发生什么。
- en: Think beyond the project. Once implemented and deployed, your application might
    have a long and happy life, but that inevitably means that there will be requests
    for smaller or larger changes and choosing a suitable language can help to reduce
    the maintenance effort. Compared to compiled languages that in general have quite
    low-level instructions and language constructs, interpreted languages have (very)
    high level constructs that make for condensed code that packs a lot of meaning
    in a few statements. That is not only easier to read but also faster to interpret
    and in the end these high level constructs, once interpreted, run at (almost)
    compiled speed making the performance difference sometimes hard to spot. More
    meaning and less code do make for easier reading and this is a huge benefit when
    maintaining code.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超越项目本身。一旦实施并部署，你的应用程序可能会拥有漫长而快乐的生命，但这不可避免地意味着会有对较小或较大更改的请求，选择合适的语言可以帮助减少维护工作量。与通常具有相当低级指令和语言结构的编译型语言相比，解释型语言具有（非常）高级的结构，这使得代码紧凑，能在少量语句中包含大量意义。这不仅更容易阅读，而且也更快地被解释，最终这些高级结构一旦被解释，将以（几乎）编译的速度运行，使得性能差异有时难以察觉。更多的意义和更少的代码确实使得阅读更容易，这在维护代码时是一个巨大的好处。
- en: In the end, the choice for the language to implement the web application is
    at least in part a matter of taste, but in this book we opt for Python as it offers
    an optimal tradeoff between the different considerations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，选择用于实现Web应用程序的语言至少部分是一个口味问题，但在这本书中，我们选择Python，因为它在考虑不同因素之间提供了最佳权衡。
- en: What just happened?
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'Now that we have chosen Python as our server-side scripting language, let''s
    have a good look at the arguments:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经选择了Python作为我们的服务器端脚本语言，让我们好好看看这些论点：
- en: Python is easy to read and therefore easy to learn and maintain. Although Python
    is relatively unique among programming languages in treating whitespace as meaningful
    in many places, this does enhance readability quite a lot.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python易于阅读，因此易于学习和维护。尽管Python在许多地方将空白视为有意义的，这在编程语言中相对独特，但这确实大大增强了可读性。
- en: Python is a very high level language, incorporating concepts like list comprehension
    and functional programming. This allows for compact programs that pack a lot of
    functionality in little code, enhancing readability and reducing maintenance.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python是一种非常高级的语言，包含了诸如列表推导和函数式编程等概念。这允许编写紧凑的程序，在少量代码中包含大量功能，增强了可读性并减少了维护工作量。
- en: Python comes "batteries included". Python is distributed with a vast amount
    of well designed and well maintained libraries (modules) that provide anything
    from access to `.csv` files and parsing XML, to building an HTTP server with a
    handful of code and these modules are at least as well documented as the language
    itself. This all means we can cut down on development time as in many cases we
    do not have to reinvent the wheel ourselves.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python“自带电池”。Python附带大量精心设计和维护良好的库（模块），提供从访问`.csv`文件和解析XML到使用少量代码构建HTTP服务器的功能，这些模块至少与语言本身一样有良好的文档。这意味着我们可以减少开发时间，因为在许多情况下，我们不必自己重新发明轮子。
- en: Python has many third party modules. Even if a module is not included with the
    distribution, chances are somebody has written just the module you are looking
    for.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python有许多第三方模块。即使某个模块没有包含在发行版中，也有可能有人已经编写了你正在寻找的模块。
- en: Python is an object-oriented language. This is widely regarded as a good thing
    as it aids in data abstraction but its main attraction to people developing database-driven
    applications is that it allows for a natural way of mapping tables to types (classes).
    Records in a table of cars can be mapped to a 'Car' class and instances of this
    class can then be manipulated in much the same way as native classes like strings
    or lists. This again makes it easier to read the code and therefore maintain the
    code.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python是一种面向对象的语言。这通常被认为是一件好事，因为它有助于数据抽象，但它对开发数据库驱动应用程序的人们的吸引力主要在于它允许以自然的方式将表映射到类型（类）。汽车表中的记录可以映射到‘Car’类，然后可以像处理字符串或列表等本地类一样操作这个类的实例。这又使得阅读代码和因此维护代码变得更加容易。
- en: Python is available on many cloud platforms. To run a Python program on the
    server, you need Python deployed on that server. If you have full access, this
    might not be an issue and indeed hosting companies provide (virtual) machines
    with Python already installed but for very lightweight cloud platforms like Google
    Gears, your choice of available languages might be limited. However, Python (together
    with Java) is fully supported by Google Gears and although this is not a consideration
    for the example applications in this book, it might be for your applications.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python可在许多云平台上使用。要在服务器上运行Python程序，你需要在那个服务器上部署Python。如果你有完全的访问权限，这可能不是问题，实际上，托管公司提供（虚拟）机器，这些机器已经安装了Python，但对于像Google
    Gears这样的非常轻量级的云平台，你的可用语言选择可能有限。然而，Python（与Java一起）在Google Gears中得到完全支持，尽管这并不是本书中示例应用程序的考虑因素，但它可能对你的应用程序是。
- en: The version of Python we use in this book is version 3 (version 3.2 at the time
    of writing). Although not all third party modules are (yet) ported to this new
    version, it is the best version to use if you want to develop in a future proof
    way.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用的Python版本是3版（写作时为3.2版）。尽管并非所有第三方模块都已（尚未）移植到这个新版本，但如果你想要以未来证明的方式开发，这是最好的版本。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Python's multi-threading capabilities at the moment do not allow for optimal
    usage of multi-core processors. Most implementations of Python do not allow running
    separate threads truly in parallel. This is by far not as bad as you may think
    though, as this restriction is mainly valid for interpreted python code, not necessarily
    for code running in, for example, the OS kernel. And because in a web server a
    lot of time is spent waiting for packets to be sent or received over the network,
    this mostly does not affect the performance of your Python code. In the future,
    the multi-threading implementation of Python may change, but this is a hotly debated
    subject. More on this subject can be found by searching for "Python 3 GIL".
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 目前Python的多线程能力并不允许最优地使用多核处理器。大多数Python的实现并不允许真正并行地运行独立的线程。然而，这远没有你想象的那么糟糕，因为这个限制主要适用于解释型Python代码，并不一定适用于在例如操作系统内核中运行的代码。而且，由于在Web服务器中，大量时间被花费在等待网络上的数据包发送或接收，这通常不会影响你的Python代码的性能。在将来，Python的多线程实现可能会改变，但这是一个激烈争论的话题。更多关于这个话题的信息可以通过搜索“Python
    3 GIL”来找到。
- en: Time for action choosing a database engine
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择数据库引擎的时间
- en: One of the key requirements of any web-application is that is has access to
    some sort of persistent storage. This might be used to store core data like a
    catalog of car parts, but a password file also needs a form of persistent storage.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Web应用程序的关键要求之一是它必须能够访问某种形式的持久存储。这可能用于存储核心数据，如汽车零部件目录，但密码文件也需要某种形式的持久存储。
- en: Often it is possible to store the information in files on the filesystem and
    indeed some of the applications we develop in this book do just that, but if you
    have a lot of structured data or you find that many people want to access this
    data at the same time, it is usually a better choice to store this data in a database
    and access this data through a database engine.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在文件系统中存储信息是可能的，实际上，我们在这本书中开发的一些应用程序就是这样做的，但如果你有大量的结构化数据或者你发现很多人同时想要访问这些数据，通常将数据存储在数据库中并通过数据库引擎访问这些数据是一个更好的选择。
- en: 'When choosing a database engine, you should consider the following points:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择数据库引擎时，你应该考虑以下因素：
- en: Does it offer the functionality you need? Database engines are sophisticated
    pieces of software and in general offer a lot of functionality, often more than
    you need. Although this may sound like an advantage, all these features must be
    learned by a developer to take advantage of them and may complicate your code
    which may increase the effort to maintain an application.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否提供了您需要的功能？数据库引擎是复杂的软件组件，通常提供很多功能，通常比您需要的还要多。虽然这听起来可能是一个优点，但所有这些功能都必须由开发者学习才能利用它们，并且可能会使您的代码复杂化，从而增加维护应用程序的努力。
- en: Is it easy to install and maintain? Database engines often run as separate applications
    that are accessed over a network. This means that they have to be installed, tested,
    and maintained separately. This may add significantly to the effort needed to
    deploy your application. And installation isn't even everything; you will have
    to consider operational issues as well, for example, how much effort it is to
    set up a suitable backup scheme or how to monitor the availability of the database.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否易于安装和维护？数据库引擎通常作为独立的应用程序运行，通过网络进行访问。这意味着它们必须单独安装、测试和维护。这可能会显著增加部署应用程序所需的努力。而且，安装甚至不是全部；您还必须考虑运营问题，例如，设置合适的备份方案需要多少努力，或者如何监控数据库的可用性。
- en: Does it offer an API that is simple to use from your chosen programming language
    and does this API provide access to all necessary functionality?
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否提供了一个易于从您选择的编程语言使用的API，并且这个API是否提供了访问所有必要功能的能力？
- en: And finally, does it perform well enough to respond swiftly to the requests
    of your application, even during peaks?
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它是否足够高效，能够迅速响应当前应用程序的需求，即使在高峰期也是如此？
- en: 'Python offers a standardized API to access many available database engines,
    including MySQL and PostgreSQL. Fully in line with its ''batteries included''
    philosophy, Python also comes included with a database engine and a module to
    access it. This database is called SQLite and is a so called embedded database:
    it doesn''t run as a standalone process that can be accessed through some means
    of inter-process communication, but the database engine is an integral part of
    the program that uses it. Its only external part is a single file containing the
    data in the database itself and that may be shared by other programs that include
    the SQLite engine. As it fits our requirements, SQLite will be the database engine
    we will use for the applications we develop in this book.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一个标准化的API来访问许多可用的数据库引擎，包括MySQL和PostgreSQL。完全符合其“内置电池”的哲学，Python还内置了一个数据库引擎和一个模块来访问它。这个数据库被称为SQLite，是一种所谓的嵌入式数据库：它不是作为一个可以通过某种进程间通信方式访问的独立进程运行，而是作为使用它的程序的组成部分。它的唯一外部部分是包含数据库本身数据的单个文件，并且可能被包含SQLite引擎的其他程序共享。由于它符合我们的要求，SQLite将成为我们在本书中开发的应用程序所使用的数据库引擎。
- en: What just happened?
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'Our choice for SQLite as the database for many of our applications is easily
    justified:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择SQLite作为许多应用程序的数据库是很容易得到解释的：
- en: Although not as feature-rich as, for example, MySQL, it does provide the functionality
    we need.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然它不像MySQL那样功能丰富，但它确实提供了我们需要的功能。
- en: Installation is practically a no brainer as SQLite comes included with Python.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于SQLite随Python一起提供，安装实际上是一个不费脑力的过程。
- en: The API offered by the `sqlite3` module gives access to all functionality.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3`模块提供的API可以访问所有功能。'
- en: It performs well enough for our needs (although statements about performance
    are very difficult to make in advance).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的性能足以满足我们的需求（尽管在事先很难做出关于性能的声明）。
- en: The main arguments supporting the use of SQLite in our applications are not
    its speed, small memory footprint, or reliability (although these are certainly
    not drawbacks as SQLite's reputation as database engine of choice for mobile telephone
    appliances proves) but the fact that because it is embedded in your program, it
    obviates the need for a separately configured and maintained database engine.
    This cuts down on maintenance in a serious manner as database engines are demanding
    beasts that take a lot of care and feeding. Also, because it is included in Python,
    it reduces the number of external dependencies when deploying an application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 支持在我们的应用程序中使用 SQLite 的主要论据不是它的速度、小内存占用或可靠性（尽管这些当然不是缺点，因为 SQLite 作为移动电话设备的数据库引擎的选择证明了这一点），而是因为它嵌入到你的程序中，从而消除了需要单独配置和维护数据库引擎的需求。这大大减少了维护工作，因为数据库引擎是需求苛刻的生物，需要大量的照顾和喂养。此外，因为它包含在
    Python 中，所以在部署应用程序时减少了外部依赖的数量。
- en: A final argument is its type system that closely resembles Python's type system;
    in contrast to many other database engines, SQLite allows you to store any value
    in a column no matter how this column was typed when it was created, just like
    you can store a string in a Python variable that was first used to store an integer
    value. This close correspondence of types allows for an intuitive mapping of Python
    values to values stored in the database, an advantage that we will study closely
    when we encounter our first application that uses SQLite.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个论据是它的类型系统与 Python 的类型系统非常相似；与许多其他数据库引擎相比，SQLite 允许你在列中存储任何值，无论在创建该列时如何对其进行类型化，就像你可以在最初用于存储整数值的
    Python 变量中存储字符串一样。这种类型之间的紧密对应关系使得将 Python 值直观地映射到数据库中存储的值成为可能，这是我们将在遇到第一个使用 SQLite
    的应用程序时密切研究的优势。
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The integration with Python is so close that it is possible to use Python functions
    within the SQL expressions used to query SQLite. The native set of functions in
    SQLite is quite small compared to other database engines but the ability to use
    Python functions removes this limitation completely. It is, for example, straightforward
    to add a hash function from Python's `hashlib` module, that is very convenient
    when implementing a password database.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的集成非常紧密，以至于可以在用于查询 SQLite 的 SQL 表达式中使用 Python 函数。与其它数据库引擎相比，SQLite 的原生函数集相当小，但使用
    Python 函数的能力完全消除了这一限制。例如，添加来自 Python 的 `hashlib` 模块的哈希函数非常简单，这在实现密码数据库时非常方便。
- en: Time for action deciding on object relational mappers
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：决定对象关系映射器
- en: Relational database engines like SQLite use tables consisting of rows and columns
    as their primary data abstraction model. Object-oriented languages like Python
    define classes to instantiate objects that have attributes. There is a fair amount
    of correspondence between these concepts as class definitions mimic table definitions
    where object instances with attributes relate to records with columns but maintaining
    the integrity of that relation is not so straightforward.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库引擎，如 SQLite，使用由行和列组成的表作为它们的主要数据抽象模型。面向对象的语言，如 Python，定义类以实例化具有属性的对象。这些概念之间存在相当多的对应关系，因为类定义模仿表定义，其中具有属性的实例对象与具有列的记录相关联，但维护这种关系的完整性并不那么简单。
- en: The problem not only lies in the different languages used to define tables and
    classes. The main issue in relational databases is maintaining referential integrity.
    If you have, for example, a record representing a car part that references a record
    in a different table that represents a car type, then a relational database lets
    you define explicit actions to execute if, for example, the record representing
    the car type is deleted. These constraints are of course possible to implement
    in Python data structures as well, but it does take serious effort to implement.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 问题不仅在于定义表和类的不同语言。关系型数据库中的主要问题是维护引用完整性。例如，如果你有一个表示汽车零件的记录，它引用了另一个表示汽车类型的记录，那么关系型数据库允许你定义在例如汽车类型记录被删除时执行显式操作的明确操作。当然，这些约束也可以在
    Python 数据结构中实现，但这需要付出相当大的努力。
- en: Finally, most database engines require fixed data types for each column whereas
    Python variables and attributes may refer to any kind of data type. This restriction
    is not present in SQLite but even SQLite cannot store everything without conversion.
    A Python variable, for example, may refer to a list of objects, something that
    cannot be stored in a single column of a relational database.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，大多数数据库引擎要求每个列都有固定的数据类型，而Python变量和属性可以引用任何类型的数据。这种限制在SQLite中不存在，但即使是SQLite也无法在不进行转换的情况下存储一切。例如，一个Python变量可能引用一个对象列表，这是无法存储在关系数据库的单个列中的。
- en: Still, we would very much like to have a way to store object instances in a
    relational database or at least the data contained in those object instances,
    and have the means to define the relation between classes and tables in a maintainable
    way. To this end, many people have designed solutions in the form of object relational
    mappers. For Python, quite a few exist that are both mature and robust tools (like
    SQLAlchemy).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们非常希望有一种方法可以存储对象实例在关系数据库中，或者至少存储这些对象实例中的数据，并且有定义类与表之间关系的方式，以便进行维护。为此，许多人已经设计了以对象关系映射器形式存在的解决方案。对于Python来说，存在许多既成熟又健壮的工具（如SQLAlchemy）。
- en: 'When deciding which tool to use, you should at least consider the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定使用哪个工具时，你应该至少考虑以下因素：
- en: How much time it will cost to learn to use it. Those tools are usually very
    versatile and quite often require a considerable amount of effort to learn.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用它将花费多少时间。这些工具通常非常灵活，而且通常需要相当多的努力来学习。
- en: How will it affect development and maintenance? Complex tools may help to solve
    the challenge of creating an effective and efficient mapping between classes and
    tables, but may require an idiom that detracts from a clear overview of your implementation.
    This may well be worth it, if your data model consists of many classes and performance
    is an important consideration, but for smaller projects the added complexity might
    be too great of a disadvantage when it impacts significantly on the development
    time.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将如何影响开发和维护？复杂的工具可能有助于解决创建一个有效的和高效的类与表之间的映射的挑战，但可能需要一种会削弱你对实现清晰概述的成语。如果你的数据模型由许多类组成，并且性能是一个重要的考虑因素，那么这可能是值得的，但对于较小的项目来说，增加的复杂性可能会在显著影响开发时间时成为一个很大的缺点。
- en: Because the focus in this book is on understanding the choices in implementing
    web applications and persistent storage, using a complex tool like an object relational
    mapper may hide all kinds of aspects necessary to gain understanding.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这本书的重点在于理解实现Web应用程序和持久存储的选择，使用像对象关系映射器这样的复杂工具可能会隐藏所有必要的方面，这些方面对于获得理解是必要的。
- en: Therefore, we will not use a third party object relational mapper in the examples
    in this book but implement increasingly versatile storage solutions in each chapter,
    tackling specific requirements as we encounter them. We will see that in many
    situations an object relational mapper is superfluous, but in the final chapters,
    we will build a simple framework ourselves to give us not only a tool but an insight
    into the intricacies of mapping complex assemblies of classes to tables in a database
    as well.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不会在本书的示例中使用第三方对象关系映射器，而是在每一章中实现越来越通用的存储解决方案，在遇到具体要求时解决它们。我们将看到，在许多情况下，对象关系映射器是多余的，但在最后几章中，我们将自己构建一个简单的框架，不仅提供一个工具，而且还能深入了解将复杂的类集合映射到数据库表中的复杂性。
- en: Time for action choosing a presentation framework
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择演示框架的行动时间
- en: Web applications might be all about accessing and manipulating data from within
    a web browser but the way the application looks and feels to the user is just
    as important. A user interface that is non-intuitive, sluggish, or fails to work
    on some mainstream browser will not invite users to use your application again.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序可能完全关于在Web浏览器中访问和操作数据，但应用程序的外观和感觉对用户来说同样重要。一个非直观、反应迟缓或在某些主流浏览器上无法工作的用户界面不会鼓励用户再次使用你的应用程序。
- en: 'HTML, the markup language commonly used to display content, does allow for
    some interaction through the use of`<form>` elements and the way a page is presented
    can be styled with cascading style sheets, but its use has some major drawbacks:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: HTML，这种常用于显示内容的标记语言，确实允许通过使用`<form>`元素以及使用层叠样式表来呈现页面样式，但它的使用有一些主要的缺点：
- en: It is quite difficult to create user interface components from basic building
    blocks that resemble commonly used applications.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从基本构建块创建类似于常用应用程序的用户界面组件相当困难。
- en: The use of HTML feels sluggish because each form, when submitted, fetches a
    completely new page.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTML感觉迟缓，因为每个表单在提交时都会获取一个全新的页面。
- en: Fortunately, all major browsers support JavaScript and that language can be
    used to add a whole new level of interactivity. However, in order to smooth out
    all inconsistencies between browsers, you can save a lot of development time when
    you use a JavaScript library that takes care of those inconsistencies and adds
    cross browser compatible user interface components (widgets).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，所有主流浏览器都支持JavaScript，并且可以使用该语言添加全新的交互级别。然而，为了消除浏览器之间所有不一致性，当您使用一个处理这些不一致性并添加跨浏览器兼容的用户界面组件（控件）的JavaScript库时，您可以节省大量的开发时间。
- en: Although such libraries are used client side, HTML pages can be composed in
    a way that instructs the browser to fetch these libraries from a central source,
    for example, the same server that serves the web application. This way, the use
    of these libraries imposes no extra requirements on the browser.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些库在客户端使用，但HTML页面可以以这种方式组成，指示浏览器从中央源获取这些库，例如，为Web应用程序提供服务的同一服务器。这样，使用这些库对浏览器没有额外的要求。
- en: 'Some points to consider when choosing a suitable library are:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的库时需要考虑的一些要点是：
- en: Is it really cross browser compatible? Not all libraries support each and every
    browser. This might be important if your application still needs to work with
    a fairly old browser.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它真的具有跨浏览器兼容性吗？并非所有库都支持每个浏览器。如果您的应用程序仍然需要与相当旧的浏览器一起工作，这可能会很重要。
- en: Does it offer the graphical components and functionality you need?
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否提供了您需要的图形组件和功能？
- en: Is it well designed and documented, extensible, and consistently implemented?
    After all, such a library should be fairly easy to learn and as no library can
    offer everything, extensibility and especially how easy it is to extend it are
    important considerations.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否设计良好、文档齐全、可扩展且实施一致？毕竟，这样的库应该相对容易学习，而且没有任何库可以提供一切，可扩展性以及扩展它的难易程度都是重要的考虑因素。
- en: Does it have an active user community? All the more important here because such
    a community may not only provide answers to your questions, but may be a good
    source of reusable components.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否拥有活跃的用户社区？在这里这一点尤为重要，因为这样的社区不仅可能回答您的问题，还可能是一个可重用组件的良好来源。
- en: 'Based on these considerations, we choose to use two intimately connected JavaScript
    libraries: jQuery and jQuery UI.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些考虑，我们选择使用两个紧密相连的JavaScript库：jQuery和jQuery UI。
- en: What just happened?
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Let's have a look at why jQuery and jQuery UI are such a good choice.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看为什么jQuery和jQuery UI是如此好的选择。
- en: 'jQuery provides the functionality to select and manipulate HTML elements on
    a page and jQuery UI provides a number of sophisticated widgets and effects. Together,
    they offer many advantages:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery提供了在页面上选择和操作HTML元素的功能，而jQuery UI提供了一系列复杂的控件和效果。共同使用，它们提供了许多优势：
- en: jQuery not only hides browser inconsistencies, but its methods take CSS3 compatible
    selectors even on browsers that do not support CSS3 in the style sheet they accept.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQuery不仅隐藏了浏览器的不一致性，而且其方法在即使不支持CSS3样式的浏览器上也使用CSS3兼容的选择器。
- en: Both libraries are widely used, actively maintained, free, and are distributed
    as small files. The latter is important when you consider that these files need
    to be transferred from server to client so any bandwidth saved is good.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两个库都得到了广泛的使用，积极维护，免费，并且以小型文件的形式分发。后者很重要，因为您需要考虑这些文件需要从服务器传输到客户端，所以任何节省的带宽都是好的。
- en: jQuery UI offers a rich set of well designed and professional looking graphical
    components and effects.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQuery UI提供了一套设计精良、外观专业的图形组件和效果。
- en: Other advantages of the wide adoption of these libraries are that there are
    many resources available to get you started and that many people have written
    plugins that extend the usability of these libraries even more. As we will see
    on many occasions, the essence of developing a good application efficiently is
    often choosing the right plugin for the job.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库广泛采用的其他优点包括，有许多资源可以帮助你入门，以及许多人编写了插件来进一步扩展这些库的可用性。正如我们将在许多场合看到的那样，高效开发良好应用程序的本质通常就是选择适合这项工作的正确插件。
- en: Designing for maintainability and usability
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计以维护性和可用性为导向
- en: It is one thing to come up with a great idea on how to implement some web application
    but yet another to design an application in such a way that it will be easy to
    maintain and use. Designing with these considerations in mind will make all the
    difference between a professional application and a mediocre one.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 想出如何实现某些Web应用程序的伟大想法是一回事，但以使其易于维护和使用的方式设计应用程序则是另一回事。考虑到这些因素进行设计，将使专业应用程序和一般应用程序之间产生巨大的差异。
- en: Testing
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: Everybody will agree that it makes sense to test an application before it is
    deployed but thorough testing requires some serious effort. Testing is also often
    considered as boring or even detracting from the 'real' development work and shares
    this aura with writing documentation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都会同意在部署应用程序之前对其进行测试是有意义的，但彻底的测试需要一些严肃的努力。测试通常被认为很无聊，甚至可能分散对“真正”开发工作的注意力，这与编写文档有着相似的气息。
- en: However, testing gives you a better feel for the quality of the application
    you deliver and a test framework, however simple, is always better than none,
    especially for the kind of small to medium web applications we look at in this
    book, as these tend to be written by very small teams that quickly prototype and
    often change the code as insight progresses and customer requirements change.
    Having a test suite at hand ensures that at least the parts of the code that don't
    change keep on performing as expected.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，测试能让你更好地了解你交付的应用程序的质量，而无论测试框架多么简单，总比没有要好，尤其是在我们这本书中探讨的小到中等规模的Web应用程序中，因为这些应用程序往往由非常小的团队快速原型设计，并且随着洞察力的进步和客户需求的变化，经常更改代码。拥有一个测试套件可以确保至少代码中不改变的部分能够按预期执行。
- en: Of course, not everything can be tested and the tools needed to test part of
    your code should be simple to use, otherwise there is no incentive to keep on
    using them. We will look at **unit tests** for a number of modules we develop
    in Python. Unit testing is an approach where we try to define the behavior of
    an isolated piece of code (for example, a single method) and check whether this
    code produces the expected results. If the implementation of the code changes
    but the tests still show no failure, we know that the new implementation can be
    used safely.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，不是所有东西都可以测试，测试你代码一部分所需的工具应该易于使用，否则就没有继续使用它们的动力。我们将查看我们开发的Python模块中的**单元测试**。单元测试是一种尝试定义独立代码片段（例如，单个方法）的行为，并检查此代码是否产生预期结果的方法。如果代码的实现发生变化，但测试仍然没有显示失败，我们知道新的实现可以安全使用。
- en: Time for action choosing a test framework
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择测试框架的行动时间
- en: 'When choosing a test framework, ask yourself the following questions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择测试框架时，请自问以下问题：
- en: What do I want to test? You cannot test everything and developing tests takes
    time.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想测试什么？你不能测试一切，开发测试需要时间。
- en: How easy is it to write and maintain the tests? This question is just as relevant
    for developing tests as it is for developing code in general.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和维护测试有多容易？这个问题对于开发测试和一般代码开发同样相关。
- en: How much effort is needed to perform the tests? If it is easy to automate the
    tests, they can, for example, be run as part of the deployment as an extra check.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行测试需要多少努力？如果测试容易自动化，它们可以作为额外的检查作为部署的一部分运行。
- en: Just for Python alone there are quite a few testing frameworks available, but
    we will choose the `unittest` module distributed with Python. Note that although
    we choose to write only automated test for the Python parts of the applications,
    this doesn't mean we have not tested the JavaScript parts, but user interactions
    tend to lend themselves less to an automated way of testing so we do not address
    that in this book.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 仅就Python而言，就有相当多的测试框架可用，但我们将选择与Python一起分发的`unittest`模块。请注意，尽管我们选择只为应用程序的Python部分编写自动化测试，但这并不意味着我们没有测试JavaScript部分，但用户交互往往不太适合自动化测试，所以我们在这本书中不涉及这一点。
- en: What just happened?
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'For the Python unit tests, we restrict ourselves to the `unittest` module that
    is distributed with Python, as this will not introduce any new dependencies on
    external tools but also because:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python单元测试，我们限制自己使用与Python一起分发的`unittest`模块，因为这不会引入任何对外部工具的新依赖，而且也因为：
- en: It is fairly simple to learn and use.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的学习和使用相对简单。
- en: It produces clear messages if a test fails.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果测试失败，它会产生清晰的错误信息。
- en: It is easy to automate and may easily be integrated with, for example, a setup
    script.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它易于自动化，并且可以轻松集成，例如，与设置脚本集成。
- en: Version management
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本管理
- en: A version management tool is normally not part of a web application and not
    strictly required to develop one. However, when you want to keep track of changes
    in your code, especially when the number of files keeps on growing, a version
    management tool is invaluable.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 版本管理工具通常不是网络应用程序的一部分，也不是开发网络应用程序的严格要求。然而，当你想要跟踪代码的变化，尤其是当文件数量持续增长时，版本管理工具是无价的。
- en: Most come with integrated functionality to show the differences between versions
    and all have the possibility to annotate a version or revision in order to clearly
    mark it. Widely used open source solutions are **git** and **svn**.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数版本控制工具都集成了显示版本差异的功能，并且所有工具都有注释版本或修订的功能，以便清晰地标记它们。广泛使用的开源解决方案包括 **git** 和
    **svn**。
- en: Both may operate as a server that can be accessed through a web browser but
    command-line tools are available as well and svn even has a very user-friendly
    integration within Windows' file explorer. Both have their strengths and weaknesses
    and it is hard to declare a clear winner. This book and its accompanying examples
    were all maintained in svn, primarily because of the ease of use of the Windows
    client.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都可以作为服务器运行，并通过网页浏览器访问，但同时也提供了命令行工具，而svn甚至还在Windows文件资源管理器中提供了非常用户友好的集成。它们各有优缺点，很难明确地说出哪个是赢家。这本书及其伴随的示例都是使用svn维护的，主要是因为Windows客户端的使用简便性。
- en: Usability
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用性
- en: Web applications are built for end users, not for developers. It is not always
    easy to design an interface that is easy to use. In fact, designing really good
    interfaces is difficult and takes considerable skill and knowledge. However, this
    does not mean that there aren't any rules of thumb that can help you prevent usability
    disasters. We look at some of them in the following sections.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序是为最终用户构建的，而不是为开发者。设计一个易于使用的界面并不总是容易。实际上，设计真正优秀的界面是困难的，需要相当多的技能和知识。然而，这并不意味着没有一些可以帮你避免可用性灾难的经验法则。我们将在以下章节中探讨一些这些法则。
- en: Good looking adhering to common GUI paradigms
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 符合常见GUI范式的美观设计
- en: Applications are easier to use if the interface components are already familiar.
    Therefore, it is generally a good idea to look at applications that are successful
    and used by many people.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果界面组件已经熟悉，应用程序的使用就会更加容易。因此，通常查看那些成功并被许多人使用的应用程序是个好主意。
- en: 'A common concern in many applications is the need to present a lot of information
    in a small amount of space. It is therefore no wonder that many modern applications
    use accordion menus and/or a tabbed interface to structure that data, such as
    the following screenshots:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用程序中，一个常见的担忧是需要在小空间内展示大量信息。因此，许多现代应用程序使用手风琴菜单和/或标签页界面来组织数据，如下面的截图所示：
- en: '![Good looking adhering to common GUI paradigms](img/3746_1_006.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![符合常见GUI范式的美观设计](img/3746_1_006.jpg)'
- en: 'An accordion menu is great for displaying a fair amount of information in a
    side bar but even more information can be presented in tabs:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 手风琴菜单非常适合在侧边栏中显示大量信息，但还可以通过标签页展示更多信息：
- en: '![Good looking adhering to common GUI paradigms](img/3746_1_005.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![符合常见GUI范式的美观设计](img/3746_1_005.jpg)'
- en: Examples are found in all recent editions of common office productivity software,
    web browser, and CRM applications. Having a good look at the ones you like working
    with yourself might be a good start. In the larger applications developed in this
    book, we will certainly refer to some key applications that may be used as an
    inspiration.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在常见的办公生产力软件、网络浏览器和CRM应用程序的最新版本中都可以找到这些例子。仔细查看你喜欢的应用程序可能是一个好的开始。在这本书中开发的大型应用程序中，我们肯定会参考一些可能作为灵感的键应用程序。
- en: Themable
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可定制的
- en: Choosing a consistent and pleasing color scheme and font makes an application
    more coherent and therefore more pleasurable to use. An overload of information
    can baffle people and using a wild color scheme or many different fonts will not
    help in getting an overview of the data that is presented.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个一致且令人愉悦的色彩方案和字体可以使应用程序更加协调，因此使用起来更加愉悦。信息过载可能会让人感到困惑，而使用混乱的色彩方案或多种不同的字体也不会有助于对展示的数据有一个全面的了解。
- en: But whether your user interface supports the concept of a theme that is easy
    to change plays an important role in other areas as well. You probably want your
    web application to blend in well with the rest of your website or to convey some
    sort of company or brand identity. Using a consistent color scheme will help.
    It might even be desirable to offer a choice of themes to the end user, for example,
    to provide people with visual impairments with high contrast themes for better
    legibility. The library fully supports the use of themes and makes it simple to
    extend this themability to widgets we design ourselves.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，无论你的用户界面是否支持易于更改的主题概念，这在其他领域也起着重要作用。你可能希望你的Web应用程序能够很好地融入你的网站的其他部分，或者传达某种公司或品牌身份。使用一致的色彩方案会有所帮助。甚至可能希望向最终用户提供主题选择，例如，为视力受损的人提供高对比度主题以改善可读性。该库完全支持主题的使用，并使得将这种可定制性扩展到我们自行设计的widget变得简单。
- en: Cross-browser compatible
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨浏览器兼容
- en: Web applications are often geared to a specific audience, so it might be possible
    that the requirements specify only a single browser, but in general, we don't
    want to deny the user his/her favorite browser. jQuery takes away most of the
    pain in supporting more than one browser. Our apps are designed for Internet Explorer
    8, Firefox 3.x, and Google Chrome, but probably will run on most other browsers
    as well. Note that 'probably' might not be good enough and it is always a good
    idea to test your application specifically on any required platform!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序通常针对特定的受众，因此，可能只有单一浏览器被指定为需求，但通常，我们不希望拒绝用户使用他们/她们的 favorite 浏览器。jQuery消除了支持多个浏览器的大部分痛苦。我们的应用程序是为Internet
    Explorer 8、Firefox 3.x和Google Chrome设计的，但可能也会在大多数其他浏览器上运行。请注意，“可能”可能不够好，并且始终在所需平台上具体测试你的应用程序是一个好主意！
- en: Cross-platform compatible
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨平台兼容
- en: Client-side, the web browser is the key component in our chain to watch out
    for and therefore, the operating system it is running on will quite likely not
    be a source of problems.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，Web浏览器是我们需要关注的链中的关键组件，因此，它所运行的操作系统很可能不会成为问题来源。
- en: Server-side, we want to keep our options open as well. Fortunately, Python is
    a cross platform solution, so any Python program that runs on Windows will normally
    run on GNU/Linux as well and vice versa.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们也希望保持我们的选择开放。幸运的是，Python是一个跨平台解决方案，因此，任何在Windows上运行的Python程序通常也可以在GNU/Linux上运行，反之亦然。
- en: We should be careful though when using modules that are not distributed with
    Python and are not pure Python. These might be available on every platform but
    it is better to check beforehand. The applications in this book use only modules
    provided in the standard Python distribution, with the exception of CherryPy,
    which is a pure Python module and should run on every platform.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们使用不随Python一起分发且不是纯Python的模块时，我们应该小心。这些模块可能在每个平台上都可用，但最好事先进行检查。本书中的应用程序仅使用标准Python分发中的模块，除了CherryPy，它是一个纯Python模块，应该能在每个平台上运行。
- en: Maintainability
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可维护性
- en: Writing code is hard work, maintaining it can be even harder. We briefly touched
    upon this subject earlier when we discussed the use of a testing framework, but
    maintaining code is more than being able to test it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码是一项艰苦的工作，维护它可能更加困难。我们之前在讨论测试框架的使用时简要提到了这个问题，但维护代码不仅仅是能够测试它。
- en: Standards compliant
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遵循标准
- en: An important concept in creating code that is easy to maintain is being standards
    compliant. Adhering to standards means that other people stand a greater chance
    in understanding your code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 创建易于维护的代码的一个重要概念是遵循标准。遵循标准意味着其他人有更大的机会理解你的代码。
- en: SQL, for example, is a query language that most database engines understand.
    Therefore, it is less relevant which engine we use for people maintaining the
    code as they do not have to learn an obscure query language.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，SQL是一种大多数数据库引擎都理解的查询语言。因此，对于维护代码的人来说，我们使用哪种引擎不太相关，因为他们不必学习一种晦涩的查询语言。
- en: Another example is communication between client and server. We can devise our
    own protocol to construct requests in JavaScript and respond to those requests
    in Python, but it is a lot less error prone to use documented standards like AJAX
    to communicate and JSON to encode data. It also saves on documentation as people
    can be referred to any number of books, if they want to learn more about those
    standards.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是客户端和服务器之间的通信。我们可以自己设计协议，在JavaScript中构建请求，并在Python中响应这些请求，但使用像AJAX这样的文档化标准来通信以及JSON来编码数据要少出错得多。这也节省了文档，因为人们可以参考任何数量的书籍，如果他们想了解更多关于这些标准的信息。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Standard does not necessarily mean 'approved by some independent organization'.
    Many standards are informal but work because everybody uses them and writes about
    them. Both AJAX and JSON are examples of that. Also the Python programming language
    is a de facto standard but JavaScript enjoys a formal standard (which doesn't
    mean all implementations adhere to the standard).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 标准并不一定意味着“由某个独立组织批准”。许多标准是非正式的，但它们因为每个人都使用并撰写它们而工作。AJAX和JSON就是这样的例子。此外，Python编程语言是一个事实上的标准，而JavaScript享有正式标准（这并不意味着所有实现都遵循标准）。
- en: Security
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: Security is often regarded as an obscure or arcane subject, but security covers
    many practical issues that play a role in even the smallest web application. We
    wouldn't want anyone to access a paid-for web application, for example. However,
    security is more than just access control and we touch briefly on some aspects
    of security in the next sections.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性通常被认为是一个晦涩或神秘的主题，但安全性涵盖了众多实际的问题，这些问题甚至在最小的Web应用中也发挥着作用。我们不想任何人访问付费的Web应用，例如。然而，安全性不仅仅是访问控制，我们将在下一节简要介绍一些安全性的方面。
- en: Reliable
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可靠的
- en: A web application should be reliable in its use. Nothing is more annoying than
    being presented with a server-side error halfway in the process of filling in
    a mortgage application, for example. As a developer and tester, you take care
    of testing the software thoroughly in the hope of catching any bugs but before
    implementing the application, the reliability of the software and libraries it
    uses should be taken into consideration.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用在使用上应该是可靠的。没有什么比在填写抵押贷款申请过程中遇到服务器端错误更令人烦恼的了。作为开发人员和测试人员，你应该彻底测试软件，希望捕捉到任何错误，但在实施应用之前，应该考虑软件及其使用的库的可靠性。
- en: You should especially be wary of using the latest and greatest nifty feature
    of some library in production software. This might be fun when whipping up some
    mock up or concept application, but do ask yourself if your customer really needs
    this bleeding edge feature and if he's/she's not better off with a tried and tested
    version.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该特别小心在生产软件中使用某个库的最新和最酷的功能。当快速制作一些原型或概念应用时，这可能会很有趣，但请问问自己，你的客户是否真的需要这个前沿功能，他们是否不如使用经过验证和测试的版本更好。
- en: Many open source projects (including Python) develop and maintain both a so
    called stable branch and a development branch to show off new features. The former
    you should use in production applications and the latter should be tried elsewhere.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开源项目（包括Python）开发和维护所谓的稳定分支和开发分支，以展示新功能。你应该在生产应用中使用前者，而后者应该在别处尝试。
- en: Robust
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强健的
- en: Applications should not only be as bug-free as possible, but should also perform
    nicely under stress as well. The performance should be as high as possible under
    load, but just as important you should know what to expect when the load reaches
    some threshold.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序不仅应该尽可能无错误，而且在压力下也应该表现良好。在负载下，性能应该尽可能高，但同样重要的是，你应该知道当负载达到某个阈值时，你期待的是什么。
- en: Unfortunately, tuning for performance is one of the trickiest jobs imaginable
    because all components in the chain may play a role. Server-side considerations
    are the performance of the database engine used, the scripting language, and the
    web server.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，性能调优是想象中最棘手的工作之一，因为链中的所有组件都可能发挥作用。服务器端考虑的是使用的数据库引擎的性能、脚本语言和Web服务器。
- en: Client-side, the quality of the presentation framework and the overall performance
    of the web browser are important and in between the server and client is the great
    unknown of the characteristics of the underlying network.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，展示框架的质量和Web浏览器的整体性能很重要，而在服务器和客户端之间是底层网络特性的未知领域。
- en: With so many variables, it is not easy to design an optimal solution in advance.
    However, we can test the performance of individual components and see if the component
    is a bottle neck. For example, if it takes three seconds to refresh a page provided
    by a web application you can rule out the database engine as a bottleneck if you
    can time the database access independently. The knowledge gained creating unit
    tests can be reused here because we already know how to isolate some functionality,
    and adding a timer and asserting that the response for a query is fast enough
    can be made a test itself.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有这么多变量，提前设计一个最优解并不容易。然而，我们可以测试单个组件的性能，看看该组件是否是瓶颈。例如，如果刷新一个由Web应用提供的页面需要三秒钟，如果你可以独立计时数据库访问，那么你可以排除数据库引擎作为瓶颈。在创建单元测试时获得的知识可以在这里重用，因为我们已经知道如何隔离某些功能，添加一个计时器并断言查询的响应足够快可以成为一个测试本身。
- en: It is also quite feasible to separately measure the time it takes to fetch a
    web component and to render it in the browser with a tool like Firebug and get
    an idea whether the client or the server is the bottleneck. (Firebug is a Firefox
    extension and can be found at [http://getfirebug.com/)](http://getfirebug.com/)).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像Firebug这样的工具单独测量获取Web组件所需的时间和在浏览器中渲染它的时间是完全可行的，并可以了解客户端或服务器是否是瓶颈。（Firebug是Firefox的一个扩展，可以在[http://getfirebug.com/](http://getfirebug.com/)找到）。
- en: Access control and authentication
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问控制和身份验证
- en: In almost every application that we develop in this book, we implement some
    sort of authentication scheme. Most of the time, we will use a simple username/password
    combination to verify that the user is who he/she claims to be. Once the user
    is authenticated, we can then decide to serve only certain information, for example,
    just a list of the tasks belonging to him/her, but no tasks of any other user.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中我们开发的几乎每个应用中，我们都实现了一些形式的身份验证方案。大多数时候，我们将使用简单的用户名/密码组合来验证用户是否是他/她声称的人。一旦用户经过验证，我们就可以决定只提供某些信息，例如，只提供他/她所属的任务列表，而不提供任何其他用户的任务。
- en: However, whether access to information is allowed, isn't always that basic.
    Even in simple applications, there might be a user who should be allowed more
    than others, for example, adding new users or resetting passwords. If the number
    of different things a user is allowed to do is small, this is straightforward
    to implement, but if the situation is more complex, it is not that easy to implement,
    let alone to maintain.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，是否允许访问信息并不总是那么基本。即使在简单的应用中，也可能存在一些用户应该比其他人有更多的权限，例如添加新用户或重置密码。如果用户被允许执行的不同事情的数量很少，这很容易实现，但如果情况更复杂，那么实现起来就不那么容易，更不用说维护了。
- en: 'In the more elaborate applications featured in the later chapters of this book,
    we will therefore adopt the concept of role based access. The idea is to define
    roles that describe which actions are allowed when assuming a role. In a customer
    relations management application, for example, there might be three roles: a sales
    person, who is only allowed to access information for his customers, the sales
    manager who may access all information, and an administrator who may not access
    any information, but is allowed to back up and restore information, for example.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本书的后续章节中介绍的更复杂的应用中，我们将采用基于角色的访问控制的概念。其思想是定义角色，描述在承担某个角色时允许执行哪些操作。例如，在客户关系管理应用中，可能有三个角色：销售人员，他只能访问其客户的资料；销售经理，可以访问所有信息；管理员，可能无法访问任何信息，但允许备份和恢复信息，例如。
- en: Once the rights of these roles are clear, we can associate any or all of these
    roles with specific persons. A small organization, for example, may have a technically
    savvy sales person who can also assume the admin role, yet still be unable to
    access information about customers other than his own this way.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些角色的权限明确，我们就可以将这些角色中的任何一个或所有与特定人员关联。例如，一个小的组织可能有一个技术熟练的销售人员，他也可以承担管理员角色，但仍然无法以这种方式访问除他自己的客户以外的任何客户信息。
- en: If rights associated with a certain role are changed, we do not have to repeat
    this information for each and every person that may assume that role, thus making
    administration that much simpler.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与某个角色关联的权限发生变化，我们不必为可能承担该角色的每个人重复此信息，从而使管理变得更加简单。
- en: Confidentiality
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保密性
- en: In some applications, we may want to make sure no one is listening in on the
    data transferred between the browser and web server. After all, in general you
    do not know which path your data takes, as it is routed across the Internet and
    at any point there might be someone who can intercept your data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用程序中，我们可能想确保没有人正在监听浏览器和Web服务器之间传输的数据。毕竟，通常你不知道你的数据走的是哪条路，因为它通过互联网路由，在任何时候都可能有人可以拦截你的数据。
- en: The easiest way to ensure confidentiality is to use connection level encryption
    and the HTTPS protocol does just that. The web server we use, CherryPy, is certainly
    capable of serving requests over HTTPS and configuring it to do so is quite simple
    but it involves creating signed certificates which is a bit out of the scope of
    this book. Refer to [http://www.cherrypy.org/wiki/ServerObject](http://www.cherrypy.org/wiki/ServerObject)
    for more information.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 确保机密性的最简单方法是使用连接级加密，HTTPS协议正是这样做的。我们使用的Web服务器CherryPy当然能够通过HTTPS提供服务，配置它这样做相当简单，但它涉及到创建签名证书，这超出了这本书的范围。有关更多信息，请参阅[http://www.cherrypy.org/wiki/ServerObject](http://www.cherrypy.org/wiki/ServerObject)。
- en: Integrity
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完整性
- en: The last aspect of security we talk about in this context is data integrity.
    Corruption of data may not always be prevented, but wholesale destruction may
    be guarded against with proper backup and restore protocols.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，我们讨论的最后一个安全方面是数据完整性。数据的损坏可能并不总是可以防止的，但通过适当的备份和恢复协议，可以防止大规模的破坏。
- en: However, data corruption lurks in very small corners too. One of the trickiest
    things that can happen is the possibility of inserting data that is wrong. For
    example, if it is possible to input a date with a month outside the range 1-12,
    very strange things might happen if the application relies elsewhere on dates
    having the correct format.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数据损坏也潜伏在非常小的角落里。最棘手的事情之一是插入错误数据的可能性。例如，如果可以输入月份范围在1-12之外的日期，如果应用程序在其他地方依赖于日期具有正确的格式，那么可能会发生非常奇怪的事情。
- en: 'It is, therefore, important to prevent the user entering wrong data by building
    in some sort of client-side validation. An excellent example is jQuery UI''s `datepicker`
    widget that we will encounter in [Chapter 3](ch03.html "Chapter 3. Tasklist I:
    Persistence"), *Tasklist I: Persistence*. If a text input field is adorned with
    a `datepicker`, the user can only enter dates by selecting dates from the `datepicker`.
    This is a great aid to the end-user, but we should never rely on client-side validation
    because our client-side validation might be inadequate (because it contains a
    bug or doesn''t check all cases) and certainly cannot prevent malicious users
    from connecting to the server and actively inserting wrong data. We do need server-side
    input validation as well to prevent this and we will encounter some examples of
    it.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过在客户端构建某种形式的验证来防止用户输入错误数据是很重要的。一个很好的例子是jQuery UI的`datepicker`小部件，我们将在[第3章](ch03.html
    "第3章。任务列表I：持久性")中遇到，*任务列表I：持久性*。如果一个文本输入字段被`datepicker`装饰，用户只能通过选择`datepicker`中的日期来输入日期。这对最终用户来说是一个很大的帮助，但我们永远不应该依赖于客户端验证，因为我们的客户端验证可能不足（因为它包含错误或没有检查所有情况），而且绝对不能防止恶意用户连接到服务器并主动插入错误数据。我们确实需要服务器端输入验证来防止这种情况，我们将在其中遇到一些例子。
- en: 'The key thing is to provide both: server-side validation as a last resort and
    client-side as an aid to the user.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于提供两个方面：作为最后手段的服务器端验证和作为用户辅助的客户端验证。
- en: A final word on security
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于安全的最后一点
- en: Security is complex and tricky and details may be overlooked easily. You might
    know you have a front door made of 10 centimeter oak with state of the art steel
    locks, but if you forget to lock the backdoor all that oak and steel serves no
    purpose. Of all the subjects touched upon in this book, security is the one that
    you should always talk over with an expert. Even an expert cannot give you guarantees
    but taking a fresh look at the security requirements might keep you out of trouble.
    Make sure that you run the sample applications provided in this book in a secure
    environment behind a well managed firewall.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是复杂且棘手的，细节很容易被忽视。你可能知道你有一扇由10厘米橡木制成的门，配有最先进的钢锁，但如果你忘记锁上后门，所有这些橡木和钢都没有作用。在这本书提到的所有主题中，安全是你应该总是与专家讨论的一个主题。即使是专家也不能给你保证，但重新审视安全需求可能会让你避免麻烦。确保你在安全的环境中运行这本书提供的示例应用程序，并有一个管理良好的防火墙。
- en: Help, I am confused!
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帮助，我感到困惑！
- en: Reading this chapter, you may get the feeling that developing web applications
    is horribly complex, even if you use the right tools. So many things may play
    a role! Do not despair though.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，你可能会有这样的感觉：即使使用正确的工具，开发Web应用也是极其复杂的！可能有那么多因素在起作用！不过，不要气馁。
- en: Time for action maintaining overview
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：保持概览
- en: If you take a close look, you will see that none of it is rocket science, the
    most it takes is common sense and attention for detail, and in every chapter,
    we highlight the relevant issues in a straightforward language where it is relevant.
    Remember that this is a practical book, there will be many working examples that
    are examined in close detail and we won't inundate you with theory, but give you
    just enough to get things done.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会发现这并不是什么火箭科学，最多只需要常识和对细节的关注，在每一章中，我们都会用直接的语言突出相关的问题，当它相关时。记住，这是一本实用的书，会有许多详细检查的工作示例，我们不会让你淹没在理论中，而是只给你足够的信息来完成工作。
- en: At every step in the development process, ask yourself the following questions?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程的每一步，都要问自己以下问题？
- en: What needs to be done? There is no need to work on all things at the same time,
    indeed this is practically impossible. Allow yourself to form a high level idea
    first and identify the components in the next level down. Don't get bogged down
    with details when the outline is not clear yet.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要做什么？没有必要同时处理所有事情，实际上这是不可能的。首先形成一个高级的想法，然后在下一级识别组件。当大纲还不清晰时，不要被细节所困扰。
- en: Which components of the application are involved? Identify the specific components
    involved when you develop a piece of functionality. The whole idea of identifying
    layers and components is to be able concentrate on a limited part of the application
    when developing.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序涉及哪些组件？在开发某个功能时，确定涉及的具体组件。识别层和组件的整体想法是为了在开发时能够专注于应用程序的有限部分。
- en: This might not always work perfectly, but it certainly helps in maintaining
    focus. For example, when developing parts of the presentation layer, you may find
    that additional content is needed that should be provided by the delivery layer.
    Instead of immediately switching focus to that delivery layer, it's often simpler
    to define what is needed and complete the part of the presentation layer you are
    working on.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可能并不总是完美无缺，但它确实有助于保持专注。例如，当开发表示层的一部分时，你可能会发现需要额外的内容，这些内容应由交付层提供。与其立即将注意力转向那个交付层，通常更简单的是定义所需的内容，并完成你正在工作的表示层部分。
- en: What are the requirements? There is no need to implement stuff that is not needed.
    This may sound obvious, but many developers nevertheless fall into this trap.
    It is tempting of course to design your code to be as flexible as possible but
    it takes a lot of time, and as requirements change, it is unlikely that it'll
    prove flexible enough. Instead, the effort is better spent on writing code that
    is easy to understand so that the inevitable changes in requirements take less
    time to process.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求是什么？没有必要实现不需要的功能。这听起来可能很显然，但许多开发者仍然会陷入这个陷阱。当然，设计尽可能灵活的代码很有吸引力，但这需要花费大量时间，而且随着需求的变化，它可能不足以证明足够灵活。相反，更好的做法是编写易于理解的代码，这样在需求不可避免地发生变化时，处理这些变化所需的时间会更少。
- en: What just happened?
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'When asking those questions and given the choices we made in this chapter,
    it might be helpful to draw a new picture that illustrates the technologies we
    will use:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当提出这些问题并考虑到本章中我们做出的选择时，绘制一幅新图来展示我们将使用的技术可能会有所帮助：
- en: '![What just happened?](img/3746OS_01_03.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/3746OS_01_03.jpg)'
- en: 'The different components between the server and client that together make up
    the web application can be pictured as a layered stack. For each layer, we have
    chosen one or a few technologies, as illustrated in the following diagram:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 构成Web应用的服务器和客户端的不同组件可以想象成一个分层堆栈。对于每一层，我们都选择了一种或几种技术，如下面的图所示：
- en: '![What just happened?](img/3746OS_01_04.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/3746OS_01_04.jpg)'
- en: Each application we encounter will be based on this model, so it might help
    to refer to this diagram once in a while if you feel you have lost track.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的每个应用都将基于这个模型，所以如果你觉得你失去了方向，偶尔参考这个图可能会有所帮助。
- en: After reading this book, you will be left with the feeling that writing good,
    useable web applications is maybe a little bit more involved than you might have
    thought at first, but that is certainly within the reach of even the smallest
    of teams. Armed with all the fresh knowledge and practical experience, you will
    not have to compromise on quality, not even in the smallest project.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这本书之后，你可能会感到编写好的、可用的网络应用程序可能比你最初想象的要复杂一些，但这对即使是规模最小的团队来说也是可以达到的。凭借所有的新知识和实践经验，你甚至不需要在最小的项目中妥协质量。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter gave us a head start in providing an overview of the components
    and techniques involved in creating a quality web application. Specifically, we
    looked at:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为我们提供了对创建高质量网络应用程序所涉及的组件和技术的概述的先导。具体来说，我们探讨了：
- en: The components that make up a web application.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构成网络应用程序的组件。
- en: The technologies we choose to implement these components.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们选择实现这些组件的技术。
- en: Which other issues play a role in the design, like security and usability.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些其他问题在设计过程中发挥作用，比如安全和可用性。
- en: With this extra knowledge, nothing can hold us back from writing our first web
    application in Python and that is exactly what we will do in the next chapter.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些额外的知识，没有什么可以阻止我们用Python编写我们的第一个网络应用程序，这正是我们在下一章将要做的。
