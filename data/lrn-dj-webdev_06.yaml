- en: Chapter 6. Enhancing the User Interface with AJAX
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。使用AJAX增强用户界面
- en: The coming of **AJAX** was an important landmark in the history of Web 2.0\.
    AJAX is a group of technologies that enables developers to build interactive,
    feature-rich Web applications. Most of these technologies were available many
    years before AJAX itself. However, the advent of AJAX represents the transition
    of the Web from static pages that needed to be refreshed whenever data was exchanged
    to dynamic, responsive, and interactive user interfaces.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**AJAX**的到来是Web 2.0历史上的一个重要里程碑。AJAX是一组技术，使开发人员能够构建交互式、功能丰富的Web应用程序。在AJAX本身出现之前，这些技术多年前就已经存在。然而，AJAX的出现代表了Web从需要在数据交换时刷新的静态页面向动态、响应迅速和交互式用户界面的转变。'
- en: Since our project is a Web 2.0 application, it should be heavily focused on
    user experience. The success of our application depends on getting users to post
    and share content on it. Therefore, the user interface of our application is one
    of our major concerns. This chapter will improve the interface of our application
    by introducing AJAX features, making it more user-friendly and interactive.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的项目是一个Web 2.0应用程序，它应该更加注重用户体验。我们的应用程序的成功取决于用户在上面发布和分享内容。因此，我们的应用程序的用户界面是我们的主要关注点之一。本章将通过引入AJAX功能来改进我们的应用程序界面，使其更加用户友好和交互性。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: AJAX and its advantages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AJAX及其优势
- en: Using AJAX in Django
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Django中使用AJAX
- en: How to use the open source jQuery framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用开源jQuery框架
- en: Implementing the searching of tweets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现推文的搜索
- en: Editing a tweet in place without loading a separate page
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不加载单独页面的情况下编辑推文
- en: Auto completion of hashtags while submitting a tweet
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交推文时自动完成标签
- en: AJAX and its advantages
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AJAX及其优势
- en: 'AJAX, which stands for **Asynchronous JavaScript and XML**, consists of the
    following technologies:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX代表**异步JavaScript和XML**，包括以下技术：
- en: HTML and CSS to structure and style information
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于结构化和样式信息的HTML和CSS
- en: JavaScript to access and manipulate information dynamically
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript用于动态访问和操作信息
- en: An `XMLHttpRequest` object, which is an object provided by modern browsers to
    exchange data with the server without reloading the current web page
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个由现代浏览器提供的对象，用于在不重新加载当前网页的情况下与服务器交换数据
- en: A format to transfer data between the client and server
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端和服务器之间传输数据的格式
- en: XML is used sometimes, but it could be in the HTML, plain text, or JavaScript-based
    format called JSON.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会使用XML，但它可以是HTML、纯文本或基于JavaScript的格式JSON。
- en: AJAX technologies let you code the client-side exchange data with the server
    behind the scenes, without reloading the entire page each time the user makes
    a request. By using AJAX, Web developers are able to increase the interactivity
    and usability of Web pages.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX技术使您能够在不重新加载整个页面的情况下在客户端和服务器之间交换数据。通过使用AJAX，Web开发人员能够增加Web页面的交互性和可用性。
- en: 'AJAX offers the following advantages when implemented in the right places:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确的地方实现AJAX时，它提供了以下优势：
- en: '**Better user experience**: With AJAX, the user can do a lot without refreshing
    the page, which brings Web applications closer to the regular desktop applications'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的用户体验**：通过AJAX，用户可以在不刷新页面的情况下完成很多操作，这使得Web应用程序更接近常规桌面应用程序'
- en: '**Better performance**: By exchanging only the required data with the server,
    AJAX saves the bandwidth and increases the application''s speed'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的性能**：通过与服务器交换所需的数据，AJAX节省了带宽并提高了应用程序的速度'
- en: There are numerous examples of Web applications that use AJAX. Google Maps and
    Gmail are perhaps two of the most prominent examples. In fact, these two applications
    played an important role in spreading the use of AJAX because of the success that
    they enjoyed. What sets Gmail apart from other webmail services is its user interface,
    which enables users to manage their e-mails interactively without waiting for
    a page to reload after every action. This creates a better user experience and
    makes Gmail feel like a responsive and feature-rich application rather than a
    simple website.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多使用AJAX的Web应用程序的例子。谷歌地图和Gmail可能是最突出的两个例子。事实上，这两个应用程序在推广AJAX的使用方面起到了重要作用，因为它们取得了成功。Gmail与其他网络邮件服务的区别在于其用户界面，它使用户能够在不等待页面在每个操作后重新加载的情况下交互式地管理他们的电子邮件。这创造了更好的用户体验，使Gmail感觉更像是一个响应迅速且功能丰富的应用程序，而不是一个简单的网站。
- en: This chapter explains how to use AJAX with Django, so as to make our application
    more responsive and user-friendly. We are going to implement three of the most
    common AJAX features found in web applications today. However, before that, we
    will learn about the benefits of using an AJAX framework, as opposed to working
    with raw JavaScript functions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释如何在Django中使用AJAX，以使我们的应用程序更具响应性和用户友好性。我们将实现当今Web应用程序中发现的三种最常见的AJAX功能。但在此之前，我们将了解使用AJAX框架的好处，而不是使用原始JavaScript函数。
- en: Using an AJAX framework in Django
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Django中使用AJAX框架
- en: As we have already used Bootstrap in our project, we need not configure it separately
    for AJAX and jQuery.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在项目中使用了Bootstrap，因此我们无需为AJAX和jQuery单独配置它。
- en: 'There are many advantages of using an AJAX framework:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AJAX框架的许多优点：
- en: JavaScript implementations vary from browser to browser. Some browsers provide
    more complete and feature-rich implementations, whereas others contain implementations
    that are incomplete or don't adhere to standards.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript的实现因浏览器而异。一些浏览器提供更完整和功能丰富的实现，而其他浏览器包含不完整或不符合标准的实现。
- en: Without an AJAX framework, developers must keep track of browser support for
    the JavaScript features that they are using and must work around the limitations
    that are present in some browsers for the implementation of JavaScript.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 没有AJAX框架，开发人员必须跟踪浏览器对他们使用的JavaScript功能的支持，并必须解决一些浏览器对JavaScript实现的限制。
- en: On the other hand, when using an AJAX framework, the framework takes care of
    this for us; it abstracts access to the JavaScript implementation and deals with
    the differences and quirks of JavaScript across browsers. This way, we can concentrate
    on developing features instead of worrying about browser differences and limitations.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当使用AJAX框架时，框架会为我们处理这一点；它抽象了对JavaScript实现的访问，并处理了不同浏览器之间的差异和怪癖。这样，我们可以专注于开发功能，而不必担心浏览器的差异和限制。
- en: The standard set of JavaScript functions and classes is a bit lacking for full-fledged
    web application development. Various common tasks require many lines of code even
    though they could be wrapped in simple functions.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准的JavaScript函数和类集合对于完整的Web应用程序开发有些不足。各种常见任务需要许多行代码，即使它们可以包装在简单的函数中。
- en: Therefore, even if you decide not to use an AJAX framework, you will find yourself
    writing a library of functions that encapsulates JavaScript facilities and makes
    them more usable. However, why reinvent the wheel when there are many excellent
    open source libraries already available?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使您决定不使用AJAX框架，您也会发现自己在编写一个函数库，该函数库封装了JavaScript功能并使其更易于使用。然而，既然已经有许多优秀的开源库可用，为什么要重新发明轮子呢？
- en: AJAX frameworks available in the market today range from comprehensive solutions
    that provide server-side and client-side components to light-weight client-side
    libraries that simplify working with JavaScript. Given that we are already using
    Django on the server side, we only want a client-side framework. In addition to
    this, the framework should be easy to integrate with Django without requiring
    any additional dependencies. Finally, it is preferable to pick a light and fast
    framework. There are many excellent frameworks that fulfill our requirements,
    such as **Prototype**, the **Yahoo! UI Library**, and **jQuery**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 今天市场上可用的AJAX框架范围从提供服务器端和客户端组件的综合解决方案到简化使用JavaScript的轻量级客户端库。鉴于我们已经在服务器端使用Django，我们只需要一个客户端框架。除此之外，该框架应该易于与Django集成，而不需要任何额外的依赖。最后，最好选择一个轻量级和快速的框架。有许多优秀的框架符合我们的要求，例如**Prototype**，**Yahoo!
    UI Library**和**jQuery**。
- en: However, for our application, I'm going to pick jQuery because it's the lightest
    of the three. It also enjoys a very active development community and a wide range
    of plugins. If you already have experience with another framework, you can continue
    using it during this chapter. It is true that you will have to adapt the JavaScript
    code in this chapter to your framework, but Django code on the server side will
    remain the same no matter which framework you choose.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于我们的应用程序，我将选择jQuery，因为它是这三种框架中最轻量级的。它还拥有一个非常活跃的开发社区和广泛的插件范围。如果您已经有其他框架的经验，可以在本章中继续使用它。的确，您将不得不将本章中的JavaScript代码适应到您的框架中，但是无论您选择哪种框架，服务器端的Django代码都将保持不变。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You need to import Bootstrap and jQuery as well. Thus, no specific installation
    or import is needed to use the AJAX feature in our Django project.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要导入Bootstrap和jQuery。因此，在我们的Django项目中使用AJAX功能不需要特定的安装或导入。
- en: Using the open source jQuery framework
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用开源的jQuery框架
- en: Before we start implementing AJAX enhancements in our project, let's go through
    a quick introduction to the jQuery framework.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始在项目中实现AJAX增强功能之前，让我们快速介绍一下jQuery框架。
- en: The jQuery JavaScript framework
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery JavaScript框架
- en: jQuery is a library of JavaScript functions that facilitates interaction with
    HTML documents and manipulates them. The library is designed to reduce the time
    and effort spent on writing code and achieving cross-browser compatibility, while
    at the same time it takes full advantage of what JavaScript offers to build interactive
    and responsive web applications.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery是一个JavaScript函数库，它简化了与HTML文档的交互并对其进行操作。该库旨在减少编写代码和实现跨浏览器兼容性所需的时间和精力，同时充分利用JavaScript提供的功能来构建交互式和响应式的Web应用程序。
- en: 'The general workflow of using jQuery consists of the following two steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用jQuery的一般工作流程包括以下两个步骤：
- en: Selecting an HTML element or a group of elements to work on.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择要处理的HTML元素或一组元素。
- en: Applying a jQuery method to the selected group.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将jQuery方法应用于所选组。
- en: Element selectors
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元素选择器
- en: 'jQuery provides a simple approach to select elements: it works by passing a
    CSS selector string to a function called `$()`. Here are some examples that illustrate
    the usage of this function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery提供了一种简单的选择元素的方法：通过将CSS选择器字符串传递给名为`$()`的函数。以下是一些示例，说明了此函数的用法：
- en: If you want to select all anchor (`<a>`) elements on a page, you can use the
    `$("a")` function call
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想选择页面上的所有锚（`<a>`）元素，可以使用`$("a")`函数调用
- en: If you want to select anchor elements that have the `.title` CSS class, use
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想选择具有`.title` CSS类的锚元素，请使用
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To select an element whose ID is `#nav`, you can use `$("#nav")`
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要选择ID为`#nav`的元素，可以使用`$("#nav")`
- en: To select all the list item (`<li>`) elements inside `#nav`, use `$("#nav li")`
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要选择`#nav`内部的所有列表项（`<li>`）元素，请使用`$("#nav li")`
- en: The `$()` function constructs and returns a jQuery object. After that, you can
    call methods on this object to interact with the selected HTML elements.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`$()`函数构造并返回一个jQuery对象。之后，您可以在此对象上调用方法以与所选的HTML元素交互。'
- en: jQuery methods
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jQuery方法
- en: jQuery offers a variety of methods to manipulate HTML documents. You can hide
    or show elements, attach event handlers to events, modify CSS properties, manipulate
    the page structure, and, most importantly, perform AJAX requests.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery提供了各种方法来操作HTML文档。您可以隐藏或显示元素，将事件处理程序附加到事件，修改CSS属性，操作页面结构，最重要的是执行AJAX请求。
- en: To debug, we are choosing the Chrome browser as the browser of our choice. Chrome
    is one of the most advanced JavaScript debugger in the form of its Chrome developer's
    tools. To launch it, press *Ctrl*+*Shift*+*J* on the keyboard.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试，我们选择Chrome浏览器作为我们的首选浏览器。 Chrome是最先进的JavaScript调试器之一，以其Chrome开发者工具的形式。要启动它，请在键盘上按下*Ctrl*+*Shift*+*J*。
- en: To experiment with the methods outlined in this section, launch the development
    server and navigate to the user profile page (`http://127.0.0.1:8000/user/ratan/`).
    Open the Chrome developer tool (by pressing *Ctrl*+*Shift*+*J* on your keyboard)
    console by pressing *F12*, and try selecting the elements and manipulating them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试本节中概述的方法，请启动开发服务器并导航到用户配置文件页面（`http://127.0.0.1:8000/user/ratan/`）。通过按下键盘上的*Ctrl*+*Shift*+*J*打开Chrome开发者工具（按*F12*），并尝试选择元素并操作它们。
- en: Hiding and showing elements
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐藏和显示元素
- en: 'Let''s start with something simple. To hide an element on the page, call the
    `hide()` method on it. To show it again, call the `show()` method. For example,
    try this on the navigation menu called `navbar` in Bootstrap of your application:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的事情开始。要在页面上隐藏一个元素，请在其上调用`hide()`方法。要再次显示它，请调用`show()`方法。例如，尝试在您的应用程序的Bootstrap中称为`navbar`的导航菜单上尝试这个：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can also animate the element while hiding and showing it. Try the `fadeOut()`,
    `fadeIn()`, `slideUp()`, or `slideDown()` methods to see two of these animated
    effects.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在隐藏和显示元素时对元素进行动画处理。尝试使用`fadeOut()`、`fadeIn()`、`slideUp()`或`slideDown()`方法来查看这两种动画效果中的两种。
- en: 'Of course, these methods (like all other jQuery methods) also work if you select
    more than one element at once. For example, if you open a user profile and enter
    the following method call into the Chrome developers tools console, all of the
    tweets will disappear:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果一次选择多个元素，这些方法（就像所有其他jQuery方法一样）也会起作用。例如，如果打开用户配置文件并在Chrome开发人员工具控制台中输入以下方法调用，则所有推文都将消失：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Accessing CSS properties and HTML attributes
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问CSS属性和HTML属性
- en: 'Next, we will learn how to change the CSS properties of elements. jQuery offers
    a method called `css()` to perform CSS operations. If you call this method with
    a CSS property name passed as a string, it returns the value of this property:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何更改元素的CSS属性。jQuery提供了一个名为`css()`的方法来执行CSS操作。如果您以字符串形式传递CSS属性名称调用此方法，它将返回此属性的值：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result of this is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的结果如下：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you pass a second argument to this method, it sets the specified CSS property
    of the selected element to the additional argument:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向此方法传递第二个参数，它将将所选元素的指定CSS属性设置为附加参数：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The result of this is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的结果如下：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In fact, you can manipulate any HTML attribute and not just CSS properties.
    To do so, use the `attr()` method, which works in a similar way as the `css()`
    method. Calling it with an attribute name returns the attribute value, whereas
    calling it with an attribute name or value pair sets the attribute to the passed
    value:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您可以操纵任何HTML属性，而不仅仅是CSS属性。要这样做，请使用`attr()`方法，它的工作方式与`css()`方法类似。使用属性名称调用它会返回属性值，而使用属性名称或值对调用它会将属性设置为传递的值：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This results in the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下结果：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will change the size of all the input elements on the page at once to `48`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将一次性将页面上所有输入元素的大小更改为`48`。
- en: In addition to this, there are shortcut methods to get and set commonly used
    attributes, such as `val()`, which returns the value of an input field when called
    without arguments and sets this value to an argument if you pass one. There is
    also the `html()` method that controls the HTML code inside an element.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还有一些快捷方法可以获取和设置常用的属性，例如`val()`，当不带参数调用时返回输入字段的值，并在传递一个参数时将该值设置为参数。还有控制元素内部HTML代码的`html()`方法。
- en: 'Finally, there are two methods that can be used to attach or detach a CSS class
    to an element: they are the `addClass()` and `removeClass()` methods. A third
    method is provided to toggle a CSS class and it is called as the `toggleClass()`
    method. All of these class methods take the name of the class to be changed as
    a parameter.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有两种方法可以用来附加或分离CSS类到一个元素：它们是`addClass()`和`removeClass()`方法。还提供了第三种方法来切换CSS类，称为`toggleClass()`方法。所有这些类方法都将要更改的类的名称作为参数。
- en: Manipulating HTML documents
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作HTML文档
- en: Now that you are comfortable with manipulating HTML elements, let's see how
    to add new elements or remove the existing elements. To insert HTML code before
    an element, use the `before()` method, and to insert code after an element, use
    the `after()` method. Note how jQuery methods are well named and very easy to
    remember!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了如何操作HTML元素，让我们看看如何添加新元素或删除现有元素。要在元素之前插入HTML代码，请使用`before()`方法，要在元素之后插入代码，请使用`after()`方法。请注意jQuery方法的命名方式非常直观，易于记忆！
- en: Let's test these methods by inserting parentheses around tag lists on the user
    page.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在用户页面上的标签列表周围插入括号来测试这些方法。
- en: 'Open your user page and enter the following in the Chrome developer tools console:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的用户页面，并在Chrome开发者工具控制台中输入以下内容：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can pass any string you want to, the `before()` or `after()` methods. The
    string may contain plain text, one HTML element, or more. These methods offer
    a very flexible way to dynamically add HTML elements to an HTML document.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向`before()`或`after()`方法传递任何您想要的字符串。该字符串可以包含纯文本、一个HTML元素或更多。这些方法提供了一种非常灵活的方式来动态添加HTML元素到HTML文档中。
- en: 'If you want to remove an element, use the `remove()` method. For example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要删除一个元素，请使用`remove()`方法。例如：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Not only does this method hide the element, it also removes it completely from
    the document tree. If you try to select the element again after using the `remove()`
    method, you will get an empty set:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不仅隐藏了元素，还将其从文档树中完全删除。如果在使用`remove()`方法后尝试重新选择元素，您将得到一个空集：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result of this is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的结果如下：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Of course, this only removes the elements from the current instance of the page.
    If you reload the page, the elements will appear again.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是从当前页面实例中删除元素。如果重新加载页面，元素将再次出现。
- en: Traversing the document tree
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历文档树
- en: Although CSS selectors offer a very powerful way to select elements, there are
    times when you want to traverse the document tree starting from a particular element.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管CSS选择器提供了一种非常强大的选择元素的方式，但有时您希望从特定元素开始遍历文档树。
- en: For this, jQuery provides several methods. The `parent()` method returns the
    parent of the currently selected element. The `children()` method returns all
    the immediate children of the selected element. Finally, the `find()` method returns
    all the descendants of the currently selected element. All of these methods take
    an optional CSS selector string to limit the result to elements that match the
    selector. For example, `$(".column").find("span")` returns all the `<span>` descendants
    of a class column.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对此，jQuery提供了几种方法。`parent()`方法返回当前选定元素的父元素。`children()`方法返回所选元素的所有直接子元素。最后，`find()`方法返回当前选定元素的所有后代元素。所有这些方法都接受一个可选的CSS选择器字符串，以限制结果为与选择器匹配的元素。例如，`$(".column").find("span")`返回类column的所有`<span>`后代。
- en: If you want to access an individual element of a group, use the `get()` method,
    which takes the index of the element as a parameter. The `$("span").get(0)` method,
    for example, returns the first `<span>` element out of the selected group.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要访问一组中的单个元素，请使用`get()`方法，该方法将元素的索引作为参数。例如，`$("span").get(0)`方法返回所选组中的第一个`<span>`元素。
- en: Handling events
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理事件
- en: Next we will learn about event handlers. An event handler is a JavaScript function
    that is invoked when a particular event happens, for example, when a button is
    clicked or a form is submitted. jQuery provides a large set of methods to attach
    handlers to events; events of particular interest in our application are mouse
    clicks and form submissions. To handle the event of clicking on an element, we
    select this element and call the `click()` method on it. This method takes an
    event handler function as a parameter. Let's try this in our Chrome developer
    console.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将学习事件处理程序。事件处理程序是在特定事件发生时调用的JavaScript函数，例如，当单击按钮或提交表单时。jQuery提供了一系列方法来将处理程序附加到事件上；在我们的应用程序中特别感兴趣的事件是鼠标点击和表单提交。要处理单击元素的事件，我们选择该元素并在其上调用`click()`方法。该方法将事件处理程序函数作为参数。让我们在Chrome开发者控制台中尝试一下。
- en: 'Open the user profile page of the application and insert a button after the
    tweet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 打开应用程序的用户个人资料页面，并在推文后插入一个按钮：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we had to escape the quotations in the strings passed to the `after()`
    method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须转义传递给`after()`方法的字符串中的引号。
- en: 'If you try to click on this button, nothing will happen, so let''s attach an
    event handler to it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试单击此按钮，将不会发生任何事情，因此让我们为其附加一个事件处理程序：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, when you click on the button, a message box will appear. How did this work?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您点击按钮时，将出现一个消息框。这是如何工作的？
- en: 'The argument that we passed to the `click()` method may look a bit complicated,
    so let''s examine it again:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`click()`方法的参数可能看起来有点复杂，因此让我们再次检查一下：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This appears to be a function declaration, but without a function name. Indeed,
    this construct creates what is called an anonymous function in JavaScript terminology
    and it is used when you need to create a function on the fly and pass it as an
    argument to another function. We could have avoided using anonymous functions
    and declared the event handler as a regular function:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是一个函数声明，但没有函数名。事实上，这个构造在JavaScript术语中创建了所谓的匿名函数，当您需要即时创建一个函数并将其作为参数传递给另一个函数时使用。我们本可以避免使用匿名函数，并将事件处理程序声明为常规函数：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code achieves the same effect, but the first one is more concise
    and compact. I highly recommend you to get used to anonymous functions in JavaScript
    (if you are not already), as I'm sure you will appreciate this construct and find
    it more readable after using it for a while.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码实现了相同的效果，但第一个更简洁、紧凑。我强烈建议您熟悉JavaScript中的匿名函数（如果您还没有），因为我相信您在使用一段时间后会欣赏这种构造并发现它更易读。
- en: Handling form submissions is very similar to handling mouse clicks. First you
    select the form, then you call the `submit()` method on it, and then you pass
    the handler as an argument. We will use this method many times while adding AJAX
    features to our project in later sections.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 处理表单提交与处理鼠标点击非常相似。首先选择表单，然后在其上调用`submit()`方法，然后将处理程序作为参数传递。在后面的部分中，我们将在项目中添加AJAX功能时多次使用这种方法。
- en: Sending AJAX requests
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送AJAX请求
- en: Before we finish this section, let's talk about AJAX requests. jQuery provides
    many ways to send AJAX requests to the server. There is, for example, the `load()`
    method that takes a URL and loads the page at this URL into the selected element.
    There are also methods to send the GET or POST requests and to receive the results.
    We will examine these methods in more depth while implementing AJAX features in
    our project.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本节之前，让我们谈一下AJAX请求。jQuery提供了许多发送AJAX请求到服务器的方法。例如，`load()`方法接受一个URL，并将该URL的页面加载到所选元素中。还有发送GET或POST请求以及接收结果的方法。在实现项目中的AJAX功能时，我们将更深入地研究这些方法。
- en: What next?
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接下来呢？
- en: This wraps up our quick introduction to jQuery. The information provided in
    this section will be enough to continue with this chapter, and once you finish
    this chapter, you will be able to implement many interesting AJAX features on
    your own. However, please keep in mind that this jQuery introduction is only the
    tip of the iceberg. If you want a comprehensive treatment of the jQuery framework,
    I highly recommend you read *Learning jQuery* from Packt Publishing, as it covers
    jQuery in much more detail. You can find out more about this book at [http://www.packtpub.com/jQuery](http://www.packtpub.com/jQuery).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对jQuery的快速介绍。本节提供的信息足以继续本章，一旦您完成本章，您将能够自己实现许多有趣的AJAX功能。但是，请记住，这个jQuery介绍只是冰山一角。如果您想全面了解jQuery框架，我强烈建议您阅读Packt
    Publishing的*Learning jQuery*，因为它更详细地介绍了jQuery。您可以在[http://www.packtpub.com/jQuery](http://www.packtpub.com/jQuery)了解更多关于这本书的信息。
- en: Implementing the searching of tweets
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现推文搜索
- en: 'We will start introducing AJAX in our application by implementing live searches.
    The idea behind this feature is simple: when the user types a few keywords into
    a text field and clicks on search, a script works behind the scenes to fetch the
    search results and presents them on the same page. The search page does not reload,
    thus saving bandwidth, and provides a better and more responsive user experience.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过实现实时搜索来引入AJAX到我们的应用程序中。这个功能背后的想法很简单：当用户在文本字段中输入一些关键词并点击搜索时，一个脚本在后台工作，获取搜索结果并在同一个页面上呈现它们。搜索页面不会重新加载，从而节省带宽，并提供更好、更具响应性的用户体验。
- en: 'Before we start implementing this, we need to keep in mind an important rule
    while working with AJAX: write your application so that it works without AJAX
    and then introduce AJAX to it. If you do so, you ensure that everyone will be
    able to use your application, including users who don''t have JavaScript enabled
    and those who use browsers without AJAX support.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现这个功能之前，我们需要牢记一个重要的规则，即在使用AJAX时编写应用程序，确保它在没有AJAX支持的浏览器和没有启用JavaScript的用户中也能正常工作。如果你这样做，你就确保每个人都能使用你的应用程序。
- en: Implementing a searching
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现搜索
- en: 'So, before we work with AJAX, let''s write a simple view that searches bookmarks
    by title. First of all, we need to create a search form, so open the `tweets/forms.py`
    file and add the following class to it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们使用AJAX之前，让我们编写一个简单的视图，通过标题搜索书签。首先，我们需要创建一个搜索表单，所以打开`tweets/forms.py`文件，并添加以下类：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, it''s a pretty straightforward form class with only one text
    field. This field will be used by the user to enter search keywords. Next, let''s
    create a view to conduct the search. Open the `tweets/views.py` file and enter
    the following code into it:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这是一个非常简单的表单类，只有一个文本字段。用户将使用这个字段输入搜索关键词。接下来，让我们创建一个视图来进行搜索。打开`tweets/views.py`文件，并输入以下代码：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Apart from a couple of method calls, the view should be very easy to understand.
    If you look at the `get` request, it is pretty simple, as it prepares the search
    form and then renders it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一些方法调用，这个视图应该非常容易理解。如果你看一下`get`请求，它非常简单，因为它准备搜索表单，然后呈现它。
- en: 'The `post()` method is where all the magic happens. When we are rendering the
    search result, it is just a layout rendering with the search form, that is, if
    you take a look at the new file we created called `search.html`, you can see the
    following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`post()`方法是所有魔法发生的地方。当我们呈现搜索结果时，它只是一个带有搜索表单的布局呈现，也就是说，如果你看一下我们创建的名为`search.html`的新文件，你会看到以下内容：'
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you look carefully, you will see the inclusion of a new section named `{%
    block js %}`. The concept used here is the same as of the `{% block content %}`
    block, that is, what is declared here will be rendered in the `base.html` file.
    Taking it further, and looking at the modified `base.html` file, we can see the
    following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会看到一个名为`{% block js %}`的新部分的包含。这里使用的概念与`{% block content %}`块相同，也就是说，这里声明的内容将在`base.html`文件中呈现。进一步看，再看修改后的`base.html`文件，我们可以看到以下内容：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code clearly shows the two new content blocks, which are as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码清楚地显示了两个新的内容块，如下所示：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: They are used to include the respective file types and to render the file types
    with the base, so that maintaining the project becomes much simpler using the
    simple rule of declaring just one CSS and JavaScript file per page. We will implement
    this later in the book with the concepts that call **assets pipeline**.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 它们用于包含相应的文件类型，并将文件类型与基础一起呈现，因此使用简单的规则，每页只声明一个CSS和JavaScript文件，从而使项目的维护变得更加简单。我们将在本书的后面使用调用**assets
    pipeline**的概念来实现这一点。
- en: Now, coming back to our AJAX search feature, you will see that this `search.html`
    file is similar to the `tweet.html` file.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们的AJAX搜索功能，你会发现这个`search.html`文件与`tweet.html`文件类似。
- en: 'For the search feature, we will create a new URL, which we need to append to
    the following `urls.py` file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于搜索功能，我们将创建一个新的URL，需要将其附加到以下的`urls.py`文件中：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `search.html` file, we defined the `search.js` method; let''s create
    this JavaScript file, which actually makes the AJAX request:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`search.html`文件中，我们定义了`search.js`方法；让我们创建这个JavaScript文件，它实际上发出了AJAX请求：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This JavaScript code gets triggered when the form is submitted, it makes an
    AJAX post request to the `/search` user with the serialized form data, and it
    gets the response. Then, with the response it gets, it appends the data to the
    element that has the class tweets.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单提交时，这段JavaScript代码会被触发，它会向`/search`用户发出一个AJAX post请求，带有序列化的表单数据，并获得响应。然后，根据获得的响应，它将数据附加到具有类别tweets的元素。
- en: 'If we open the user search in the browser, it will look like the following
    screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中打开用户搜索，它会看起来像下面的截图：
- en: '![Implementing a searching](img/image00303.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![实现搜索](img/image00303.jpeg)'
- en: Now, wait! What happens when this form is submitted?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，等等！当这个表单提交时会发生什么？
- en: 'The AJAX request goes to the `post()` method of the search class, which is
    as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX请求发送到搜索类的`post()`方法，如下所示：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We are checking the form validation after we extract from the `request.POST`
    method; if the form is valid, the query is extracted from the form object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`request.POST`方法中提取表单验证；如果表单有效，就从表单对象中提取查询。
- en: Then, the `tweets = Tweet.objects.filter(text__icontains===query)` method searches
    for the substring match for the given query term.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`tweets = Tweet.objects.filter(text__icontains===query)`方法搜索给定查询项的子字符串匹配。
- en: 'Searches are conducted using a method called `filter` in the `Tweets.objects`
    module. You can think of it as the equivalent of the `SELECT` statements in Django
    models. It receives the search criteria in its arguments and returns the search
    results. The name of each argument must adhere to the following naming convention:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索是使用`Tweets.objects`模块中的`filter`方法进行的。你可以把它看作是Django模型中`SELECT`语句的等价物。它接收搜索条件作为参数，并返回搜索结果。每个参数的名称必须遵循以下命名约定：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note that the `field` and `operator` variables are separated by two underscores:
    the field, which is the name of the field that we want to search by, and operator,
    which is the lookup method that we want to use. Here is a list of the commonly
    used operators:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`field` 和 `operator` 变量之间用两个下划线分隔：field 是我们想要搜索的字段的名称，operator 是我们想要使用的查找方法。以下是常用操作符的列表：
- en: '`exact`: This is the value of the argument that is an exact match of the field'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exact`: 参数的值与字段的精确匹配'
- en: '`contains`: This field contains the value of the argument'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contains`: 该字段包含参数的值'
- en: '`startswith`: This field starts with the value of the argument'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startswith`: 该字段以参数的值开头'
- en: '`lt`: This field is less than the value of the argument'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lt`: 该字段小于参数的值'
- en: '`gt`: This field is greater than the value of the argument'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gt`: 该字段大于参数的值'
- en: 'Also, there are case-insensitive versions of the first three operators: `iexact`,
    `icontains`, and `istartswith` that can be included in the list as well.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有前三个操作符的不区分大小写版本：`iexact`、`icontains` 和 `istartswith`，也可以包括在列表中。
- en: 'One thing that we are doing is totally different now, which is the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在做的一件完全不同的事情是：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Our goal was to load the search results without reloading or refreshing the
    search page. If so, how our previous render method will help us? It can't. We
    need some methods that can help us send the date to the browser without reloading
    it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是在不重新加载或刷新搜索页面的情况下加载搜索结果。如果是这样，我们之前的渲染方法将如何帮助我们？它不能。我们需要一些方法，可以帮助我们在不重新加载页面的情况下将数据发送到浏览器。
- en: We widely use the concepts in web development called **partials**. They are
    generally small snippets of HTML code generated on the server side, are rendered
    as JSON, and then they get appended to the existing DOM with the help of JavaScript.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们广泛使用网页开发中称为**partials**的概念。它们通常是在服务器端生成的小段 HTML 代码片段，以 JSON 格式呈现，然后通过 JavaScript
    添加到现有 DOM 中。
- en: 'To implement this method, we will first create a folder called partials in
    the existing template folder, a `_tweet_search.html` file with the following content:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个方法，我们首先会在现有模板文件夹中创建一个名为 partials 的文件夹，以及一个名为 `_tweet_search.html` 的文件，内容如下：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The code will render the entire tweet object within a well box or, if no tweet
    object is found, it will render `No tweet Found` inside the well box.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码将在一个良好的框中渲染整个推文对象，或者如果找不到推文对象，它将在框中渲染 `未找到推文`。
- en: 'The preceding concept is to render a partial as a string in the view, and if
    we need to pass any parameters for the render, we need to pass them in the first
    place with the call to generate the string from partials. To pass the parameters
    for partials, we need to create a context object and then pass our parameters:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的概念是在视图中将一个 partial 渲染为字符串，如果我们需要为渲染传递任何参数，我们需要在调用从 partials 生成字符串的地方首先传递它们。要为
    partials 传递参数，我们需要创建一个上下文对象，然后传递我们的参数：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'First, we will create the context with the `query` (which we will use later)
    and `tweets` parameters and use the `render_to_string()` function. Then, we can
    use JSON to dump the string to the `HttpResponse()` function with the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建包含 `query`（稍后将使用）和 `tweets` 参数的上下文，并使用 `render_to_string()` 函数。然后，我们可以使用
    JSON 将字符串转储到 `HttpResponse()` 函数，如下所示：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The list of imports are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 导入列表如下：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'That''s it! We completed a basic AJAX-based search for our tweets. Searching
    for `django` listed the two tweets we created, as shown in the following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们完成了一个基于 AJAX 的推文搜索。搜索 `django` 列出了我们创建的两条推文，如下截图所示：
- en: '![Implementing a searching](img/image00304.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![实现搜索](img/image00304.jpeg)'
- en: Go ahead and play with the search engine, and I'm sure you will fall more in
    love with Django.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用搜索引擎，并且我相信你会更加喜欢 Django。
- en: We now have a functional (albeit very basic) search page. The search functionality
    itself will be improved during later chapters, but what matters to us now is introducing
    AJAX to the search form, so that results are fetched behind the scenes and are
    presented to the user without reloading the page. Thanks to our modular code,
    this task will turn out to be much simpler than it may seem.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个功能性的（尽管非常基本的）搜索页面。搜索功能本身将在后面的章节中得到改进，但对我们来说现在重要的是将 AJAX 引入搜索表单，以便在幕后获取结果并呈现给用户，而无需重新加载页面。由于我们的模块化代码，这个任务将比看起来要简单得多。
- en: Implementing the live searching of tweets
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现实时搜索推文
- en: As we conducted a simple search in the previous section, we will now implement
    the live search, which is technically the same, but the only difference is that
    the search form will be submitted with every key stroke and the results will be
    loaded in real, time.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中进行了简单的搜索，现在我们将实现实时搜索，技术上是相同的，但唯一的区别是搜索表单将随着每次按键而提交，并且结果将实时加载。
- en: 'To implement live searches, we need to do the following two things:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现实时搜索，我们需要做以下两件事：
- en: We need to intercept and handle the event of submitting the search form. This
    can be done using the `submit()` method of jQuery.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要拦截并处理提交搜索表单的事件。这可以使用 jQuery 的 `submit()` 方法来完成。
- en: We need to use AJAX to load the search results in the background and insert
    them in the page.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要使用 AJAX 在后台加载搜索结果，并将它们插入页面中。
- en: jQuery offers a method called `load()` that retrieves a page from the server
    and inserts its contents into the selected element. In its simplest form, the
    function takes the URL of the remote page to be loaded as a parameter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 提供了一个名为 `load()` 的方法，用于从服务器检索页面并将其内容插入到所选元素中。在其最简单的形式中，该函数将远程页面的 URL
    作为参数。
- en: We will implement the live search on hashtags, that is, we will create a new
    page that is the same as the search page that we just created, but this will be
    for hashtags and we will use a live hashtag suggestion (autocomplete for hashtag).
    Before we begin, we need the Twitter `typeahead` JavaScript library for the same.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在标签上实现实时搜索，也就是说，我们将创建一个新页面，与我们刚刚创建的搜索页面相同，但这将用于标签，并且我们将使用实时标签建议（标签自动完成）。在开始之前，我们需要相同的
    Twitter `typeahead` JavaScript 库。
- en: Download the latest version of this library from [http://twitter.github.io/typeahead.js/](http://twitter.github.io/typeahead.js/).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [http://twitter.github.io/typeahead.js/](http://twitter.github.io/typeahead.js/)
    下载这个库的最新版本。
- en: For this chapter, we downloaded the version 10.05 of the library. Download it
    and save it to your current JavaScript folder.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们下载了版本为10.05的库。下载并保存到当前的 JavaScript 文件夹中。
- en: First of all, let's modify our search view a little, so that it only returns
    the search results without the rest of the search page when it receives an additional
    GET variable called AJAX. We do so to enable the JavaScript code on the client
    side to easily retrieve search results without the rest of the search page HTML
    format. This can be done by simply using the `bookmark_list.html` template instead
    of the `search.html` template when requested.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们稍微修改我们的搜索视图，以便在接收到名为 AJAX 的额外 GET 变量时，仅返回搜索结果而不是搜索页面的其余部分。我们这样做是为了使客户端的
    JavaScript 代码能够轻松地检索搜索结果，而不需要搜索页面的其余部分的 HTML 格式。这可以通过在请求时简单地使用 `bookmark_list.html`
    模板而不是 `search.html` 模板来实现。
- en: 'GET contains the key AJAX parameter. Open the `bookmarks/views.py` file and
    modify the `search_page` parameter (toward the end), so that it becomes as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: GET 包含关键的 AJAX 参数。打开 `bookmarks/views.py` 文件并修改 `search_page` 参数（朝文件末尾），使其如下所示：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, create a file called `search.js` in the `site_media` directory and link
    it to the `templates/search.html` file like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `site_media` 目录中创建一个名为 `search.js` 的文件，并将其链接到 `templates/search.html`
    文件，如下所示：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now for the fun part! Let''s create a function that loads the search results
    and inserts them into the corresponding `div` tag. Write the following code in
    the `site_media/search.js` file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是有趣的部分！让我们创建一个函数，加载搜索结果并将它们插入相应的 `div` 标签中。在 `site_media/search.js` 文件中写入以下代码：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s go through this function line by line:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行浏览这个函数：
- en: The function first gets the query string from the text field using the `val()`
    method.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数首先使用 `val()` 方法从文本字段中获取查询字符串。
- en: We use the `load()` method to get the search results from the `search_page`
    view and to insert the search results into the `#search-results` div. The request
    URL is constructed by first calling the `encodeURIComponent` parameter on query,
    which works exactly like the `urlencode` filter we used in the Django templates.
    Calling this function is important to ensure that the constructed URL remains
    valid even if the user enters special characters into the text field, such as
    `&`. After the escape query, we concatenate it with the `/search/?AJAX&query=`
    parameter. This URL invokes the `search_page` view and passes the GET variable's
    AJAX parameter and query to it. The view returns the search results and the `load()`
    method in turn loads the results into the `#search-results` div.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `load()` 方法从 `search_page` 视图获取搜索结果，并将搜索结果插入到 `#search-results` div 中。首先对查询调用
    `encodeURIComponent` 参数构造请求 URL，它的工作方式与我们在 Django 模板中使用的 `urlencode` 过滤器完全相同。调用这个函数很重要，以确保即使用户在文本字段中输入特殊字符，如
    `&`，构造的 URL 仍然有效。在转义查询后，我们将其与 `/search/?AJAX&query=` 参数连接起来。这个 URL 调用 `search_page`
    视图，并将 GET 变量的 AJAX 参数和查询传递给它。视图返回搜索结果，`load()` 方法便将结果加载到 `#search-results` div
    中。
- en: We return `False` from the function to tell the browser not to submit the form
    after calling our handler. If we don't return `False` in the function, the browser
    will continue to submit the form as usual and we don't want that.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从函数中返回 `False`，告诉浏览器在调用处理程序后不要提交表单。如果我们在函数中不返回 `False`，浏览器将继续像往常一样提交表单，而我们不希望这样。
- en: 'One little detail remains: where and when should you attach the `search_submit`
    parameter to the submit event of the search form? A rule of thumb when writing
    JavaScript is that we cannot manipulate elements in the document tree before the
    document finishes loading. Therefore, our function must be invoked as soon as
    the search page is loaded. Fortunately for us, jQuery provides a method to execute
    a function when the HTML document is loaded. Let''s utilize it by appending the
    following code to the `site_media/search.js` file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个小细节：在何处以及何时应该将 `search_submit` 参数附加到搜索表单的提交事件上？在编写 JavaScript 时的一个经验法则是，在文档完成加载之前，我们不能操作文档树中的元素。因此，我们的函数必须在搜索页面加载完成后立即调用。幸运的是，jQuery
    提供了一种在 HTML 文档加载时执行函数的方法。让我们通过将以下代码附加到 `site_media/search.js` 文件来利用它：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `$(document)` function selects the document element of the current page.
    Note that there are no quotations around the `document` variable; it's a variable
    provided by the browser, not a string.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(document)` 函数选择当前页面的文档元素。请注意，`document` 变量周围没有引号；它是浏览器提供的变量，而不是字符串。'
- en: The `ready()` method takes a function and executes it as soon as the selected
    element finishes loading. So, in effect, we are telling jQuery to execute the
    passed function as soon as the HTML document is loaded. We pass an anonymous function
    to the `ready()` method, and this function simply binds the `search_submit` parameter
    to the submit event of the `#search-form` form.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`ready()` 方法接受一个函数，并在所选元素完成加载后立即执行它。因此，实际上，我们告诉 jQuery 在 HTML 文档加载完成后立即执行传递的函数。我们将一个匿名函数传递给
    `ready()` 方法，这个函数简单地将 `search_submit` 参数绑定到 `#search-form` 表单的提交事件上。'
- en: That's it. We've implemented live searches with less than fifteen lines of code.
    To test the new functionality, navigate to `http://127.0.0.1:8000/search/`, submit
    queries, and note how the results are displayed without reloading the page.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们用不到十五行的代码实现了实时搜索。要测试新功能，转到 `http://127.0.0.1:8000/search/`，提交查询，并注意结果如何在不重新加载页面的情况下显示。
- en: The information covered in this section can be applied to any form that needs
    to be processed in the background without reloading the page. You can, for example,
    create a comment form with a preview button that loads the preview in the same
    page without reloading. In the next section, we will enhance the user page to
    let users edit their bookmarks in place without navigating away from the user
    page.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖的信息可以应用于任何需要在后台处理而无需重新加载页面的表单。例如，您可以创建一个带有预览按钮的评论表单，该按钮在同一页面上加载预览而无需重新加载。在下一节中，我们将增强用户页面，使用户可以在原地编辑书签而无需离开用户页面。
- en: Editing a tweet in place without loading a separate page
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不加载单独页面的情况下原地编辑推文
- en: Editing posted content is a very common task on websites. It's usually implemented
    by offering an **edit** link next to the content. When clicked on, this link takes
    the user to a form located at another page, where the content can be edited. When
    the user submits the form, they are redirected back to the content page.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑发布的内容是网站上非常常见的任务。通常通过在内容旁边提供一个“编辑”链接来实现。当用户点击链接时，该链接会将用户带到另一个页面上的一个表单，用户可以在那里编辑内容。用户提交表单后，会被重定向回内容页面。
- en: Imagine, on the other hand, that you could edit content without navigating away
    from the content page. When you click on the **edit** button, the content is replaced
    with a form. When you submit the form, it disappears and the updated content appears
    in its place. Everything happens on the same page; editing the form's rendering
    and submissions are done using JavaScript and AJAX. Wouldn't such a workflow be
    more intuitive and responsive?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，想象一下，您可以在不离开内容页面的情况下编辑内容。当您点击“编辑”按钮时，内容会被一个表单替换。当您提交表单时，它会消失，更新后的内容会出现在原来的位置。所有操作都在同一个页面上进行；使用JavaScript和AJAX来完成表单的渲染和提交。这样的工作流程会更直观和响应更快吗？
- en: The preceding technique described is called **in-place editing**. It now finds
    its way in Web applications and becomes more common. We will implement this feature
    in our application by letting the user edit their bookmarks in place on the user
    page.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 上述描述的技术称为**原地编辑**。它现在在Web应用程序中变得更加普遍。我们将通过让用户在用户页面上原地编辑书签来实现此功能。
- en: Since our application doesn't support the editing of bookmarks yet, we will
    implement this first and then modify the editing procedure to work in place.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序尚不支持编辑书签，我们将首先实现这一点，然后修改编辑过程以在原地工作。
- en: Implementing bookmark editing
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现书签编辑
- en: 'We already have most of the parts that are needed to implement bookmark editing.
    If you recall from the previous chapter, in the `bookmarks/views.py` file, we
    implemented the `bookmark_save_page` view in such a way that if the user tries
    to save the same URL more than once, the same bookmark is updated rather than
    being duplicated. This was easy to do thanks to the `get_or_create()` method provided
    by data models. This little detail greatly simplifies the implementation of bookmark
    editing. Here is what we need to do:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有大部分需要实现书签编辑的部分。如果您回忆一下前一章，我们在 `bookmarks/views.py` 文件中实现了 `bookmark_save_page`
    视图，以便如果用户尝试多次保存相同的URL，则更新相同的书签而不是创建副本。这得益于数据模型提供的 `get_or_create()` 方法，这个小细节极大地简化了书签编辑的实现。我们需要做的是：
- en: We pass the URL of the bookmark that we want to edit as a GET variable named
    URL to the `bookmark_save_page` view.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将要编辑的书签的URL作为名为URL的GET变量传递给 `bookmark_save_page` 视图。
- en: We modify the `bookmark_save_page` view, so that it populates the fields of
    the bookmark form if it receives the GET variable. The form is populated with
    the data of the bookmark that corresponds to the passed URL.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们修改 `bookmark_save_page` 视图，以便在接收到GET变量时填充书签表单的字段。该表单将填充与传递的URL对应的书签的数据。
- en: When the populated form is submitted, the bookmark will be updated, as we explained
    earlier, because it will seem to be that the user submitted the same URL another
    time.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当填充的表单被提交时，书签将被更新，就像我们之前解释的那样，因为它看起来好像用户又提交了相同的URL。
- en: Before we implement the preceding described technique, let's reduce the size
    of the `bookmark_save_page` view by moving the part that saves a bookmark to a
    separate function. We will call this function `_bookmark_save`. The underscore
    at the beginning of the name tells Python not to import this function when the
    views module is imported. The function expects a request and a valid form object
    as parameters; it saves a bookmark out of the form data and returns this bookmark.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现上述描述的技术之前，让我们通过将保存书签的部分移动到一个单独的函数中来减少 `bookmark_save_page` 视图的大小。我们将称此函数为
    `_bookmark_save`。名称开头的下划线告诉Python在导入视图模块时不要导入此函数。该函数期望请求和有效的表单对象作为参数；它将根据表单数据保存书签并返回该书签。
- en: 'Open the `bookmarks/views.py` file and create the following function; you can
    cut and paste the code from the `bookmark_save_page` view if you like, as we will
    not make any changes to it except for the `return` statement at the end:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `bookmarks/views.py` 文件并创建以下函数；如果愿意，可以从 `bookmark_save_page` 视图中复制并粘贴代码，因为我们除了最后的
    `return` 语句外不会对其进行任何更改：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The current logic in the `bookmark_save_page` view works like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`bookmark_save_page` 视图中的当前逻辑如下：'
- en: '[Pseudo Code]'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[伪代码]'
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To implement bookmark editing, we need to slightly modify the logic, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现书签编辑，我们需要稍微修改逻辑，如下所示：
- en: '[Pseudo Code]'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[伪代码]'
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s translate the preceding pseudo code into Python. Modify the `bookmark_save_page`
    view in the `bookmarks/views.py` file, so that it looks like the following code
    (the new code is highlighted):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将上述伪代码翻译成Python。修改 `bookmarks/views.py` 文件中的 `bookmark_save_page` 视图，使其看起来像以下代码（新代码已突出显示）：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This new section of the code first checks whether a GET variable called URL
    exists. If this is the case, it loads the corresponding `Link` and `Bookmark`
    objects of this URL and binds all the data to a bookmark saving form. You may
    wonder why we load the `Link` and `Bookmark` objects in a try-except construct
    that silently ignores exceptions.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的这一新部分首先检查是否存在名为URL的GET变量。如果是这样，它将加载此URL的相应`Link`和`Bookmark`对象，并将所有数据绑定到书签保存表单。您可能会想知道为什么我们在try-except结构中加载`Link`和`Bookmark`对象，并默默地忽略异常。
- en: Indeed, it's perfectly valid to raise an HTTP 404 exception if no bookmark was
    found for the requested URL. However, our code chooses to only populate the URL
    field in this situation, leaving the title and tags fields empty.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，如果没有找到请求的URL的书签，引发HTTP 404异常是完全有效的。然而，我们的代码选择在这种情况下只填充URL字段，留下标题和标签字段为空。
- en: 'Now, let''s add **edit** links next to each bookmark in the user page. Open
    the `templates/bookmark_list.html` file and insert the highlighted code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在用户页面的每个书签旁边添加**编辑**链接。打开`templates/bookmark_list.html`文件并插入突出显示的代码：
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note how we constructed edit links by appending the bookmark's URL to `/save/?url=
    {{ bookmark.link.url|urlencode }}`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何通过将书签的URL附加到`/save/?url= {{ bookmark.link.url|urlencode }}`来构建编辑链接的。
- en: 'Also, since we only want to show edit links on the user''s page, the template
    renders these links only when the `show_edit` flag is set to `True`. Otherwise,
    it wouldn''t make sense to let the user edit other people''s links. Now open the
    `bookmarks/views.py` file and add the `show_edit` flag to the template variables
    in the `user_page` flag:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们只想在用户页面上显示编辑链接，模板只在`show_edit`标志设置为`True`时呈现这些链接。否则，让用户编辑其他人的链接是没有意义的。现在打开`bookmarks/views.py`文件，并在`user_page`标志的模板变量中添加`show_edit`标志：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `username == request.user.username` expression evaluates to `True` only
    when users view their own page, and this is precisely what we want.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`username == request.user.username`表达式仅在用户查看自己的页面时评估为`True`，这正是我们想要的。'
- en: 'Finally, I suggest you reduce the font size of the edit links a little. Open
    the `site_media/style.css` file and append the following to its end:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我建议您稍微减小编辑链接的字体大小。打开`site_media/style.css`文件并将以下内容附加到其末尾：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: And we are done! Feel free to navigate to your user page and experiment with
    editing your bookmarks before we continue.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了！在继续之前，随意导航到您的用户页面并尝试编辑书签。
- en: Implementing in-place editing of bookmarks
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现书签的原地编辑
- en: 'Now that we have bookmark editing implemented, let''s move to the exciting
    part: adding in-place editing with AJAX!'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了书签编辑，让我们转向令人兴奋的部分：使用AJAX添加原地编辑！
- en: 'Our approach to this task will be as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法是：
- en: We will intercept the event of clicking on an edit link and use AJAX to load
    a bookmark editing form from the server. Then we will replace the bookmark on
    the page with the editing form.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将拦截点击编辑链接的事件，并使用AJAX从服务器加载书签编辑表单。然后我们将用编辑表单替换页面上的书签。
- en: When the user submits the edit form, we will intercept the submission event
    and use AJAX to send the updated bookmark to the server.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户提交编辑表单时，我们将拦截提交事件，并使用AJAX将更新后的书签发送到服务器。
- en: The server saves the bookmark and returns the HTML representation of the new
    bookmark. We will then replace the edit form on the page with the markup returned
    by the server.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器保存书签并返回新书签的HTML表示。然后我们将用服务器返回的标记替换页面上的编辑表单。
- en: We will implement the preceding procedure using an approach very similar to
    live searching. First, we will modify the `bookmark_save_page` view, so that it
    responds to AJAX requests when a GET variable called AJAX exits. Next, we will
    write JavaScript code to retrieve an edit form from the view, which posts bookmark
    data back to the server when the user submits this form.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与实时搜索非常相似的方法来实现前面的过程。首先，我们将修改`bookmark_save_page`视图，以便在GET变量称为AJAX存在时响应AJAX请求。接下来，我们将编写JavaScript代码，从视图中检索编辑表单，当用户提交此表单时，将书签数据发送回服务器。
- en: 'Since we want to return the markup of an edit form to the AJAX script from
    the `bookmark_save_page` view, let''s restructure our templates a little. Create
    a file called `bookmark_save_form.html` in templates and move the bookmark saving
    form from the `bookmark_save.html` file to this new file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望从`bookmark_save_page`视图返回一个编辑表单的标记给AJAX脚本，让我们稍微重构一下我们的模板。在模板中创建一个名为`bookmark_save_form.html`的文件，并将书签保存表单从`bookmark_save.html`文件移动到这个新文件中：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that we also changed the action attribute of the form to `/save/` and gave
    it an ID. This is necessary for the form to work on the user page as well as on
    the bookmark submission page.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还更改了表单的action属性为`/save/`并为其赋予了一个ID。这对于表单在用户页面以及书签提交页面上的工作是必要的。
- en: 'Next, include this new template in the `bookmark_save.html` file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`bookmark_save.html`文件中包含这个新模板：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Ok*, now we have the form in a separate template. Let''s update the `bookmark_save_page`
    view to handle both the normal and AJAX requests. Open the `bookmarks/views.py`
    file and update the view, so that it looks like the following (modified with the
    new lines that are highlighted):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*好*，现在我们将表单放在一个单独的模板中。让我们更新`bookmark_save_page`视图，以处理正常和AJAX请求。打开`bookmarks/views.py`文件并更新视图，使其看起来像下面修改后的样子（用新加粗的行）：'
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s examine each highlighted section separately:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分别检查每个突出显示的部分：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'At the beginning of the method, we will check whether a GET variable named
    AJAX exists. We will store the result in a variable called AJAX. Later in the
    method, we can check whether we are handling an AJAX request or not, using this
    variable:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法的开头，我们将检查是否存在名为AJAX的GET变量。我们将结果存储在名为AJAX的变量中。稍后在方法中，我们可以使用这个变量来检查我们是否正在处理AJAX请求：
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If we receive a POST request, we check whether the submitted form is valid
    or not. If it is valid, we save the bookmark. Next, we check whether this is an
    AJAX request. If it is, we render the saved bookmark using the `bookmark_list.html`
    template and return it to the requesting script. Otherwise, it is a normal form
    submission, so we redirect the user to their user page. On the other hand, if
    the form is not valid, we only act as if it''s an AJAX request by returning the
    string `''failure''`, which we will respond to by displaying an error dialog in
    JavaScript. We don''t need to do anything if it''s a normal request because the
    page will be reloaded and the form will display any errors in the input:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们收到POST请求，我们检查提交的表单是否有效。如果有效，我们保存书签。接下来，我们检查这是否是一个AJAX请求。如果是，我们使用`bookmark_list.html`模板呈现保存的书签，并将其返回给请求脚本。否则，这是一个正常的表单提交，因此我们将用户重定向到他们的用户页面。另一方面，如果表单无效，我们只会像处理AJAX请求一样返回字符串`'failure'`，我们将通过在JavaScript中显示错误对话框来响应。如果是正常请求，则无需执行任何操作，因为页面将重新加载，并且表单将显示输入中的任何错误：
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is checked at the end of the method. The execution reaches this point if
    there is no POST data, which means that we should render a form and return it.
    We use the `bookmark_save_form.html` template if it's an AJAX request and the
    `bookmark_save` method, otherwise save it as an HTML file.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这在方法的末尾进行检查。如果没有POST数据，即执行到这一点，这意味着我们应该呈现一个表单并返回它。如果是AJAX请求，则使用`bookmark_save_form.html`模板，否则将其保存为HTML文件。
- en: 'Our view is now ready to serve AJAX requests as well as normal page requests.
    Let''s write the JavaScript code that will take advantage of the updated view.
    Create a new file called `bookmark_edit.js` in the `site_media` profile. However,
    before we add any code to it, let''s link the `bookmark_edit.js` file to the `user_page.html`
    template. Open the `user_page.html` file and modify it as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视图现在已准备好为AJAX请求提供服务，也可以处理正常的页面请求。让我们编写JavaScript代码，以利用更新后的视图。在`site_media`文件夹中创建一个名为`bookmark_edit.js`的新文件。但是，在向其中添加任何代码之前，让我们将`bookmark_edit.js`文件链接到`user_page.html`模板。打开`user_page.html`文件，并进行以下修改：
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We have to write two functions in the `bookmark_edit.js` file:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`bookmark_edit.js`文件中编写两个函数：
- en: '`bookmark_edit`: This function handles the clicks on edit links. It loads an
    edit form from the server and replaces the bookmark with this form.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bookmark_edit`：此函数处理编辑链接的点击。它从服务器加载编辑表单，并用此表单替换书签。'
- en: '`bookmark_save`: This function handles the submissions of edit forms. It sends
    form data to the server and replaces the form with the bookmark HTML returned
    by the server.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bookmark_save`：此函数处理编辑表单的提交。它将表单数据发送到服务器，并用服务器返回的书签HTML替换表单。'
- en: 'Let''s start with the first function. Open the `site_media/bookmark_edit.js`
    file and write the following code in it:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个函数开始。打开`site_media/bookmark_edit.js`文件，并在其中编写以下代码：
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Because this function handles click events on an edit link, the `this` variable
    refers to the edit link itself. Wrapping it in the jQuery `$()` function and calling
    the `parent()` function returns the parent of the edit link, which is the `<li>`
    element of the bookmark (try it in the Firebug console to see the same for yourself).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个函数处理编辑链接上的点击事件，所以`this`变量指的是编辑链接本身。将其包装在jQuery `$()`函数中并调用`parent()`函数返回编辑链接的父元素，即书签的`<li>`元素（在Firebug控制台中尝试一下，看看自己是否能看到相同的结果）。
- en: After retrieving a reference to the bookmark's `<li>` element, we obtain a reference
    to the bookmark's title and extract the bookmark's URL from it using the `attr()`
    method.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取书签的`<li>`元素的引用之后，我们获取书签的标题的引用，并使用`attr()`方法从中提取书签的URL。
- en: 'Next, we use the `load()` method to put an editing form in place of the bookmark''s
    HTML file. This time, we are calling the `load()` method with two extra arguments
    in addition to the URL. The `load()` function takes two optional parameters, which
    are as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`load()`方法将编辑表单放置在书签的HTML文件中。这次，我们在URL之外调用`load()`方法时，还使用了两个额外的参数。`load()`函数接受两个可选参数，如下所示：
- en: It takes an object of key or value pairs if we are sending a POST request. Since
    we get the edit form from the server-side view using a GET request, we pass null
    for this parameter.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们发送POST请求，则它接受键或值对的对象。由于我们使用GET请求从服务器端视图获取编辑表单，因此对于此参数，我们传递null。
- en: It takes a function that is called when jQuery finishes loading the URL into
    the selected element. The function we are passing attaches the `bookmark_save()`
    method (which we are going to write next) to the form that we've just retrieved.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它接受一个函数，当jQuery完成将URL加载到所选元素时调用该函数。我们传递的函数将`bookmark_save()`方法（接下来我们将要编写的方法）附加到刚刚检索到的表单上。
- en: 'Finally, the function returns `False` to tell the browser not to follow the
    edit link. Now we need to attach the `bookmark_edit()` function to the event of
    clicking an edit link using `$(document).ready()`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该函数返回`False`，告诉浏览器不要跟随编辑链接。现在我们需要使用`$(document).ready()`将`bookmark_edit()`函数附加到单击编辑链接的事件上：
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If you try to edit a bookmark in the user page after writing this function,
    an edit form should appear, but you should also get a JavaScript error message
    in the Firebug console because the `bookmark_save()`function is not defined, so
    let''s write it:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在编写此函数后尝试在用户页面中编辑书签，则应该会出现编辑表单，但是您还应该在Firebug控制台中收到JavaScript错误消息，因为`bookmark_save()`函数未定义，所以让我们来编写它：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, the `this` variable refers to the edit form because we handle the event
    of submitting a form. The function starts by retrieving a reference to the form's
    parent, which is again the bookmark's `<li>` element. Next, the function retrieves
    the updated data from the form using the ID of each form field and the `val()`
    method.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`this`变量指的是编辑表单，因为我们处理提交表单的事件。该函数首先通过检索对表单的父元素（再次是书签的`<li>`元素）的引用来开始。接下来，该函数使用每个表单字段的ID和`val()`方法从表单中检索更新的数据。
- en: Then it uses a method called `$.post()` to send data back to the server. Finally,
    it returns `False` to prevent the browser from submitting the form.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它使用一个名为`$.post()`的方法将数据发送回服务器。最后，它返回`False`以防止浏览器提交表单。
- en: 'As you may have guessed, the `$.post()` function is a jQuery method that sends
    POST requests to the server. It takes three parameters, which are as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经猜到，`$.post()`函数是一个发送POST请求到服务器的jQuery方法。它有三个参数，如下：
- en: The URL of the target of the POST request.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POST请求目标的URL。
- en: An object of key/value pairs that represents POST data.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示POST数据的键/值对对象。
- en: A function that is invoked when the request is done. The server response is
    passed to this function as a string parameter.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当请求完成时调用的函数。服务器响应作为字符串参数传递给此函数。
- en: It's worth mentioning that jQuery provides a method called `$.get()` to send
    a GET request to the server. It takes the same types of parameters as the `$.post()`
    function. We use the `$.post()` method to send the updated bookmark data to the
    `bookmark_save_page` view. As discussed a few paragraphs ago, the view returns
    the update bookmark HTML if it succeeds in saving it. Otherwise, it returns the
    `failure` string.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，jQuery提供了一个名为`$.get()`的方法，用于向服务器发送GET请求。它接受与`$.post()`函数相同类型的参数。我们使用`$.post()`方法将更新的书签数据发送到`bookmark_save_page`视图。正如前面几段讨论的那样，如果视图成功保存书签，则返回更新的书签HTML。否则，它返回`failure`字符串。
- en: Therefore, we check whether the result returned from the server is `failure`
    or not. If the request succeeds, we insert the new bookmark before the old one
    using the `before()` method and remove the old bookmark from the HTML document
    using the `remove()` method. If, on the other hand, the request fails, we display
    an alert box displaying the failure.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们检查服务器返回的结果是否是“失败”。如果请求成功，我们使用`before()`方法在旧书签之前插入新书签，并使用`remove()`方法从HTML文档中删除旧书签。另一方面，如果请求失败，我们会显示一个显示失败的警报框。
- en: Several little things remain before we finish this section. Why do we insert
    the `$("li",result).get(0)` method instead of the result itself? If you check
    the `bookmark_save_page` view, you will see that it uses the `bookmark_list.html`
    template to construct the bookmark's HTML. However, the `bookmark_list.html` template
    returns the bookmark `<li>` element wrapped in an `<ul>` tag. Basically, the `$("li",
    result).get(0)` method tells jQuery to extract the first `<li>` element in the
    result and this is the element that we want. As you see from the preceding snippet,
    you can use the jQuery `$()` function to select the elements from an HTML string
    by passing this string as a second argument to the function.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成本节之前还有一些小事情。为什么我们插入`$("li",result).get(0)`方法而不是结果本身？如果您检查`bookmark_save_page`视图，您会看到它使用`bookmark_list.html`模板来构建书签的HTML。然而，`bookmark_list.html`模板返回包装在`<ul>`标签中的书签`<li>`元素。基本上，`$("li",
    result).get(0)`方法告诉jQuery从结果中提取第一个`<li>`元素，这就是我们想要的元素。正如您从前面的片段中看到的，您可以使用jQuery
    `$()`函数通过将该字符串作为函数的第二个参数传递来选择HTML字符串中的元素。
- en: The `bookmark_submit` template is attached to its event from within the `bookmark_edit`
    template, so we don't need to do anything about it in the `$(document).ready()`
    method.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`bookmark_submit`模板是从`bookmark_edit`模板中的事件附加的，因此我们不需要在`$(document).ready()`方法中做任何事情。'
- en: Lastly, after loading the updated bookmark into the page, we call the `$("ul.bookmarks.edit").click(bookmark_edit)`
    method again to attach the `bookmark_edit` template to the newly loaded edit link.
    If you don't do so and try to edit a bookmark twice, the second click on the edit
    link will take you to a separate form page.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在将更新的书签加载到页面后，我们再次调用`$("ul.bookmarks.edit").click(bookmark_edit)`方法，将`bookmark_edit`模板附加到新加载的编辑链接上。如果不这样做并尝试两次编辑书签，第二次点击编辑链接将带您到一个单独的表单页面。
- en: When you finish writing the JavaScript code, open your browser and go to your
    user page to experiment with the new feature. Edit the bookmarks, save them, and
    note how the changes are immediately reflected on the page without any reloading.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成编写JavaScript代码后，打开浏览器并转到您的用户页面，尝试使用新功能。编辑书签，保存它们，并注意到如何在页面上立即反映出更改而无需重新加载。
- en: Now that you have completed this section, you should have a good understanding
    of how in-place editing is implemented. There are many other scenarios where this
    feature can be useful, for example, it can be used to edit an article or a comment
    on the same page without navigating away to a form located on a different URL.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经完成了这一部分，应该对就地编辑的实现有很好的理解。还有许多其他情况下，这个功能可以很有用，例如，可以用来在同一页上编辑文章或评论，而不必跳转到位于不同URL上的表单进行编辑。
- en: In the next section, we will implement a third common AJAX feature that helps
    the user enter tags while submitting a bookmark.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现一个帮助用户在提交书签时输入标签的第三个常见的AJAX功能。
- en: Autocompletion of hashtags while submitting a tweet
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在提交推文时自动完成标签
- en: The last AJAX enhancement that we are going to implement in this chapter is
    autocompletion of tags. The concept of autocompletion found its way into web applications
    when Google released their Suggest searching interface. Suggest works by displaying
    the most popular search queries below the search input field based on what the
    user has typed so far. It's also similar to how code editors in integrated development
    environments offer code completion suggestions based on what you type. This feature
    saves time by letting the user type a few characters of the word they want and
    then lets them select it from a list without having to type it in completely.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中要实现的最后一个AJAX增强功能是标签的自动完成。自动完成的概念是在Google发布其Suggest搜索界面时进入Web应用程序的。Suggest通过根据用户到目前为止输入的内容，在搜索输入字段下方显示最受欢迎的搜索查询。这也类似于集成开发环境中的代码编辑器根据您的输入提供代码完成建议。这个功能通过让用户输入他们想要的单词的几个字符，然后让他们从列表中选择而不必完全输入来节省时间。
- en: We will implement this feature by offering suggestions when the user enters
    tags while submitting a bookmark, but instead of writing this feature from scratch,
    we are going to use a jQuery plugin to implement it. jQuery enjoys a large and
    continually growing list of plugins that provides a variety of features. Installing
    a plugin is no different from installing jQuery itself. You download one (or more)
    files and link them to your template and then you write a few lines of JavaScript
    code to activate the plugin.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在提交书签时提供建议来实现此功能，但我们不打算从头开始编写此功能，而是要使用jQuery插件来实现它。jQuery拥有一个不断增长的大型插件列表，提供各种功能。安装插件与安装jQuery本身没有什么不同。您下载一个（或多个）文件并将它们链接到您的模板，然后编写几行JavaScript代码来激活插件。
- en: You can browse the list of the available jQuery plugins by navigating to [http://docs.jquery.com/Plugins](http://docs.jquery.com/Plugins).
    Search for the autocomplete plugin in the list and download it, or you can directly
    grab it from [http://bassistance.de/jquery-plugins/jquery-plugin-autocomplete/](http://bassistance.de/jquery-plugins/jquery-plugin-autocomplete/).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过导航到[http://docs.jquery.com/Plugins](http://docs.jquery.com/Plugins)来浏览可用的jQuery插件列表。在列表中搜索autocomplete插件并下载它，或者您可以直接从[http://bassistance.de/jquery-plugins/jquery-plugin-autocomplete/](http://bassistance.de/jquery-plugins/jquery-plugin-autocomplete/)获取它。
- en: 'You will get a zip archive with many files in it. Extract the following files
    (which can be found in the `jquery/autocomplete/scroll` directory) to the `site_media`
    directory:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 您将收到一个包含许多文件的zip存档文件。将以下文件（可以在`jquery/autocomplete/scroll`目录中找到）提取到`site_media`目录中：
- en: '**jquery.autocomplete.css**'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jquery.autocomplete.css**'
- en: '**dimensions.js**'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dimensions.js**'
- en: '**jquery.bgiframe.min.js**'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jquery.bgiframe.min.js**'
- en: '**jquery.autocomplete.js**'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jquery.autocomplete.js**'
- en: 'Since we want to offer the autocomplete feature on the bookmark submission
    page, create an empty file called `tag_autocomplete.js` in the `site_media` folder.
    Then open the `templates/bookmark_save.html` file and link all of the preceding
    files to it:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在书签提交页面上提供自动完成功能，请在`site_media`文件夹中创建一个名为`tag_autocomplete.js`的空文件。然后打开`templates/bookmark_save.html`文件，并将所有前述文件链接到它：
- en: '[PRE52]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We now finished installing the plugin. If you read its documentation, you will
    find that this plugin is activated by calling a method named `autocomplete()`
    on a selected input element. The `autocomplete()` function takes the following
    parameters:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了插件的安装。如果你阅读它的文档，你会发现这个插件是通过在选定的输入元素上调用一个名为`autocomplete()`的方法来激活的。`autocomplete()`函数接受以下参数：
- en: '**A server-side URL**: For this, the plugin sends a GET request to this URL
    with what has been typed so far and expects the server to return a set of suggestions.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端URL**：对于这一点，插件向这个URL发送一个GET请求，其中包含到目前为止已经输入的内容，并期望服务器返回一组建议。'
- en: '**An object that can be used to specify various options**: Options that are
    of interest to us are multiple. This option has a Boolean variable that tells
    the plugin that the input field is used to enter multiple values (remember that
    we use the same text field to enter all the tags) and multiple separators that
    are used to tell the plugin which string separates multiple entries. In our case,
    it''s a single space character.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用于指定各种选项的对象**：我们感兴趣的选项有很多。这个选项有一个布尔变量，告诉插件输入字段用于输入多个值（记住我们使用同一个文本字段输入所有标签），以及用于告诉插件哪个字符串分隔多个条目的多个分隔符。在我们的情况下，它是一个单个空格字符。'
- en: 'So before activating the plugin, we need to write a view that receives user
    input and returns a set of suggestions. Open the `bookmarks/views.py` file and
    append the following to its end:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在激活插件之前，我们需要编写一个视图，接收用户输入并返回一组建议。打开`bookmarks/views.py`文件，并将以下内容追加到文件末尾：
- en: '[PRE53]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `autocomplete()` plugin sends user input in a GET variable named `q`. Therefore,
    we can verify that this variable exists and build a list of tags whose names begin
    with the value of this variable. This is done using the `filter()` method and
    the `istartswith` operator that we learned about earlier in this chapter. We only
    take the first ten results to avoid overwhelming the user with suggestions and
    to reduce the bandwidth and performance costs. Finally, we join the suggestions
    into a single string separated by newlines, wrap the string into an `HttpResponse`
    object, and return it.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`autocomplete()`插件将用户输入发送到名为`q`的GET变量。因此，我们可以验证该变量是否存在，并构建一个以该变量值开头的标签列表。这是使用我们在本章前面学到的`filter()`方法和`istartswith`运算符完成的。我们只取前十个结果，以避免给用户带来过多的建议，并减少带宽和性能成本。最后，我们将建议连接成一个由换行符分隔的单个字符串，将字符串包装成一个`HttpResponse`对象，并返回它。'
- en: 'With the suggestion view ready, add a URL entry to the plugin in the `urls.py`
    file, as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 有了建议视图准备好后，在`urls.py`文件中为插件添加一个URL条目，如下所示：
- en: '[PRE54]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now activate the plugin on the tags input field by entering the following code
    in the `site_media/tag_autocomplete.js` file:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`site_media/tag_autocomplete.js`文件中输入以下代码，激活标签输入字段上的插件：
- en: '[PRE55]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The code passes an anonymous function to the `$(document).ready()` method. This
    function invokes the `autocomplete()` function on the tags input field, passing
    the arguments that we talked about earlier.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码将一个匿名函数传递给`$(document).ready()`方法。这个函数在标签输入字段上调用`autocomplete()`函数，并传递了我们之前讨论过的参数。
- en: These few lines of code are all that we need in order to implement autocompletion
    of tags. To test the new feature, navigate to the bookmark submission form at
    `http://127.0.0.1:8000/save/` and try to enter a character or two in the tags
    field. Suggestions should appear based on the tags available in your database.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这几行代码就是我们实现标签自动完成所需要的全部内容。要测试新功能，请导航到`http://127.0.0.1:8000/save/`的书签提交表单，并尝试在标签字段中输入一个或两个字符。根据数据库中可用的标签，应该会出现建议。
- en: With this feature, we finish this chapter. We covered a lot of material and
    learned about many exciting technologies and techniques. After reading the chapter,
    you should be able to think of and implement many other enhancements to the user
    interface, such as the ability to delete bookmarks from the user page or to do
    live browsing of bookmarks by tags among, many other things.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个功能，我们完成了这一章。我们涵盖了很多材料，并学习了许多令人兴奋的技术和技巧。阅读完本章后，你应该能够想到并实现许多其他用户界面的增强功能，比如在用户页面上删除书签的能力，或者通过标签实时浏览书签等等。
- en: 'The next chapter will shift to a different topic: we will let users vote and
    comment on their favorite bookmarks and the front page of our application won''t
    remain as empty as it is now!'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将转向一个不同的主题：我们将让用户对他们最喜欢的书签进行投票和评论，我们的应用程序的首页将不再像现在这样空荡荡了！
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Phew! This was a long chapter, but hopefully you learned a lot from it! We
    started the chapter with learning about the jQuery framework and how to integrate
    it in to our Django project. After that, we implemented three exciting features
    in our bookmarking application: live searching, in-place editing, and autocompletion.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 呼，这是一个很长的章节，但希望你从中学到了很多！我们从学习jQuery框架和如何将其整合到我们的Django项目开始了这一章。之后，我们在我们的书签应用程序中实现了三个令人兴奋的功能：实时搜索、就地编辑和自动完成。
- en: The next chapter is going to be another exciting one. We will let users submit
    bookmarks to the front page and vote for their favorite bookmarks. We will also
    enable users to comment on bookmarks. So, read on!
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将是另一个令人兴奋的章节。我们将让用户提交书签到首页并为他们最喜欢的书签投票。我们还将让用户对书签进行评论。所以，请继续阅读！
