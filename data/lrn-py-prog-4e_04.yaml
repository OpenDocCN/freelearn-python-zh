- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Functions, the Building Blocks of Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数，代码的构建块
- en: ”To create architecture is to put in order. Put what in order? Functions and
    objects.”
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “创造架构就是整理。整理什么？函数和对象。”
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Le Corbusier
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —勒·柯布西耶
- en: In the previous chapters, we have seen that everything is an object in Python,
    and functions are no exception. But what exactly is a function? A function is
    *a block of reusable code designed to perform a specific task or a related group
    of tasks* . This unit can then be imported and used wherever it is needed. There
    are many advantages to using functions in your code, as we will see shortly.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的章节中，我们已经看到在Python中一切都是对象，函数也不例外。但函数究竟是什么呢？函数是*一个可重复使用的代码块，旨在执行特定的任务或一组相关的任务*。这个单元可以随后导入并在需要的地方使用。使用函数在代码中有许多优点，我们将在下面看到。 '
- en: 'In this chapter, we are going to cover the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Functions—what they are and why we should use them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数——它们是什么以及为什么我们应该使用它们
- en: Scopes and name resolution
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域和名称解析
- en: Function signatures—input parameters and return values
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数签名——输入参数和返回值
- en: Recursive and anonymous functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归和匿名函数
- en: Importing objects for code reuse
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入对象以实现代码重用
- en: 'We believe the saying *a picture is worth a thousand words* is particularly
    true when explaining functions to someone who is new to this concept, so please
    take a look at the following figure:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相信“一图胜千言”这句话在向对这一概念新手解释函数时尤其正确，所以请看一下以下图例：
- en: '![img](img/B30992_04_01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B30992_04_01.png)'
- en: 'Figure 4.1: An example of a function'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：函数的一个示例
- en: As you can see, a function is a block of instructions, packaged as a whole,
    like a box. Functions can accept input parameters and produce output values. Both
    of these are optional, as we will see in the examples in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，函数是一块指令的集合，作为一个整体打包，就像一个盒子。函数可以接受输入参数并产生输出值。这两者都是可选的，正如我们在本章的示例中将会看到的。
- en: A function in Python is defined using the `def` keyword, after which the name
    of the function follows, terminated by a pair of parentheses (which may or may
    not contain input parameters); a colon ( `:` ) then signals the end of the function
    definition. Immediately afterward, indented by four spaces, we find the body of
    the function, which is the set of instructions that the function will execute
    when called.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的函数使用`def`关键字定义，之后跟函数名，以一对括号（可能包含输入参数）结束；然后是一个冒号（`:`），表示函数定义的结束。紧接着，缩进四个空格，我们找到函数体，这是函数被调用时将执行的指令集合。
- en: Note that the indentation by four spaces is not mandatory, but it is the number
    of spaces suggested by PEP 8, and, in practice, it is the most widely used spacing
    measure.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，四个空格的缩进不是强制的，但这是PEP 8建议的空格数，在实践中，这是最广泛使用的间距度量。
- en: A function may or may not return an output. If a function wants to return an
    output, it does so by using the `return` keyword, followed by the desired output.
    You may have noticed the little `*` after *Optional* in the output section of
    the preceding diagram. This is because a function always returns something in
    Python, even if you do not explicitly use the `return` statement. If the function
    has no `return` statement in its body, or no value is given to the `return` statement
    itself, the function returns `None` .
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可能返回也可能不返回输出。如果函数想要返回输出，它将通过使用`return`关键字，后跟所需的输出来实现。你可能已经注意到了前一个图例输出部分中`Optional`后面的那个小`*`。这是因为Python中的函数总是返回某些东西，即使你没有显式使用`return`语句。如果函数体内没有`return`语句，或者没有给`return`语句本身提供值，函数将返回`None`。
- en: 'This design choice is rooted in several reasons, the most important of which
    are:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计选择基于几个原因，其中最重要的原因是：
- en: '**Simplicity and consistency** : Whether the function is explicitly returning
    a value or not, its behavior is consistent.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁性和一致性**：无论函数是否显式返回值，其行为都是一致的。'
- en: '**Complexity reduction** : Several languages make a distinction between functions
    (which return a value) and **procedures** (which do not). Functions in Python
    can act as both, with no need for separate constructs. This minimizes the number
    of concepts a programmer must learn.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性降低**：几种语言在函数（返回值的函数）和**过程**（不返回值的函数）之间做出区分。Python 中的函数可以同时充当这两种角色，无需单独的结构。这最小化了程序员必须学习的概念数量。'
- en: '**Consistency for multiple pathways** : Functions with multiple conditional
    branches will return `None` when no other return statement is executed. `None`
    , therefore, is a useful default value.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多路径一致性**：具有多个条件分支的函数在没有执行其他返回语句时将返回`None`。因此，`None`是一个有用的默认值。'
- en: The list provided demonstrates the multitude of factors that can influence an
    apparently simple design decision. It is the careful and deliberate choices underpinning
    Python’s design that contribute to its elegance, simplicity, and versatility.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表展示了众多可能影响看似简单的设计决策的因素。正是这些支撑Python设计的精心和深思熟虑的选择，使其具有优雅、简单和多功能性。
- en: Why use functions?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用函数？
- en: 'Functions are among the most important concepts and constructs of any language,
    so let us give you a few reasons why we need them:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是任何语言中最重要和最基本的概念和结构之一，所以让我们给你几个为什么我们需要它们的原因：
- en: They reduce code duplication in a program. Encapsulating the instructions for
    a task in a function that we can import and call whenever we want allows us to
    avoid duplicating the implementation.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们减少了程序中的代码重复。将任务的指令封装在我们可以导入和随时调用的函数中，使我们能够避免重复实现。
- en: They help in splitting a complex task or procedure into smaller blocks, each
    of which becomes a function.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有助于将复杂任务或过程拆分成更小的块，每个块都成为一个函数。
- en: They hide the implementation details from their users.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们隐藏了实现细节，不让用户知道。
- en: They improve traceability.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提高了可追溯性。
- en: They improve readability.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提高了可读性。
- en: Let us now look at a few examples to get a better understanding of each point.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些例子，以更好地理解每个要点。
- en: Reducing code duplication
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少代码重复
- en: Imagine that you are writing a piece of scientific software, and you need to
    calculate prime numbers up to a certain limit—as we did in the previous chapter.
    You have an algorithm to calculate them, so you copy it and paste it to wherever
    you need to use it. One day, though, a colleague gives you a more performant algorithm
    to calculate primes. At this point, you need to go over your whole code base and
    replace the old code with the new one.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在编写一段科学软件，你需要计算到一定限制的素数——就像我们在上一章中做的那样。你有一个计算它们的算法，所以你把它复制并粘贴到你需要使用它的任何地方。然而，有一天，一个同事给你一个更高效的算法来计算素数。在这个时候，你需要遍历整个代码库，用新代码替换旧代码。
- en: This procedure is quite error-prone. You can easily remove parts of the surrounding
    code by mistake or fail to remove some of the code you meant to replace. You also
    risk missing some of the places where the prime calculation is done, leaving your
    software in an inconsistent state where the same action is performed in different
    ways. What if, instead of replacing code with a better version of it, you need
    to fix a bug and you miss a spot. That would be even worse. What if the names
    of the variables in the old algorithm are different from those used in the new
    one? That will also complicate things.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程很容易出错。你可能会不小心删除周围代码的一部分，或者未能删除你打算替换的某些代码。你还可能错过一些主要计算完成的地方，导致你的软件处于不一致的状态，同一操作以不同的方式执行。如果，你不仅需要用更好的版本替换代码，还需要修复一个错误而你却错过了某个地方，那会变得更糟。如果旧算法中变量的名称与新的不同，这也会使事情变得复杂。
- en: To avoid all that, you write a function, `get_prime_numbers(upto)` , and use
    it anywhere you need to calculate a list of primes. When your colleague gives
    you a better implementation, all you need to do is replace the body of that function
    with the new code. The rest of the software will automatically adapt since it
    is just calling the function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免所有这些，你编写一个函数，`get_prime_numbers(upto)`，并在你需要计算素数列表的任何地方使用它。当你的同事给你一个更好的实现时，你只需要替换那个函数的主体为新代码。其余的软件将自动适应，因为它只是调用这个函数。
- en: Your code will be shorter and free from inconsistencies between old and new
    ways of performing a task. You are also less likely to leave behind undetected
    bugs that arise from copy-and-paste failures or oversights.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码会更短，并且不会出现旧方法和新方法执行任务时的一致性问题。你也更不可能留下由于复制粘贴失败或疏忽而产生的未被发现的问题。
- en: Splitting a complex task
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将复杂任务拆分
- en: Functions are also useful for splitting long or complex tasks into smaller ones.
    The result is that the code benefits from it in several ways, including readability,
    testability, and reusability.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 函数还有助于将长或复杂的任务拆分成更小的任务。结果是代码在可读性、可测试性和可重用性等方面受益。
- en: To give you a simple example, imagine that you are preparing a report. Your
    code needs to fetch data from a data source, parse it, filter it, and polish it,
    and then a whole series of algorithms needs to be run against it, to produce the
    results that will be written into the report. It is common to see procedures like
    this that are just one big `do_report(data_source)` function. There might be hundreds
    of lines of code that run before we finally produce the report.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你一个简单的例子，想象你正在准备一份报告。你的代码需要从数据源获取数据，解析它，过滤它，并对其进行润色，然后需要对它运行一系列算法，以生成将被写入报告的结果。常见的情况是，这样的流程通常只有一个大的`do_report(data_source)`函数。在最终生成报告之前，可能会有数百行代码需要运行。
- en: 'Inexperienced programmers, not well versed in the art of crafting simple, well
    structured code, may produce functions with hundreds of lines of code. They are
    hard to follow through, to find the places where things are changing context (such
    as finishing one task and starting the next one). Let us show you a better approach
    instead:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏经验的程序员，如果不擅长编写简单、结构良好的代码，可能会编写出数百行代码的函数。这些函数很难跟踪，很难找到事物改变上下文的地方（例如，完成一项任务并开始下一项任务）。让我们展示一个更好的方法：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The previous example is fictitious, of course, but can you see how easy it would
    be to go through the code? If the end result looks wrong, it would be easy to
    debug each of the single data outputs in the `do_report()` function. Moreover,
    it is even easier to exclude part of the process temporarily from the whole procedure
    (you just need to comment out the parts that you need to suspend). Code like this
    is easier to deal with.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子当然是虚构的，但你能否看出遍历代码有多容易？如果最终结果看起来不正确，那么在`do_report()`函数中调试每个单独的数据输出将会很容易。此外，从整个流程中临时排除部分过程（你只需注释掉需要暂停的部分）也更为简单。这样的代码更容易处理。
- en: Hiding implementation details
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏实现细节
- en: Let us stay with the preceding example to talk about this point as well. We
    can see that, by going through the code of the `do_report()` function, we can
    get a surprisingly good understanding without reading one single line of implementation.
    This is because functions hide the implementation details.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续之前的例子来讨论这个点。我们可以看到，通过遍历`do_report()`函数的代码，我们可以在不阅读任何一行实现代码的情况下获得一个令人惊讶的理解。这是因为函数隐藏了实现细节。
- en: This feature means that, if we do not need to delve into the details, we are
    not forced to, in the way that we would be if `do_report()` was just one big,
    long function. To understand what was going on, we would have to read and understand
    every single line of its code. When it is broken down into smaller functions,
    we do not necessarily need to read every line of every one of them to understand
    what the code does. This reduces the time we spend reading the code and, since
    in a professional environment reading code takes much more time than writing it,
    it is important to reduce it to a minimum.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性意味着，如果我们不需要深入了解细节，我们就不必像如果`do_report()`只是一个又长又大的函数那样被迫去深入。要理解发生了什么，我们不得不阅读并理解它的每一行代码。当它被分解成更小的函数时，我们不一定需要阅读每一个函数的每一行代码来理解代码的功能。这减少了我们阅读代码所花费的时间，因为在专业环境中阅读代码所花费的时间比编写代码多得多，因此将其减少到最低限度是很重要的。
- en: Improving readability
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高可读性
- en: Programmers sometimes do not see the point in writing a function with a body
    of one or two lines of code, so let us look at an example that shows you why you
    should probably still do it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员有时看不到编写一个只有一或两行代码的函数的意义，所以让我们看看一个例子，说明为什么你可能仍然应该这样做。
- en: 'Imagine that you need to multiply two matrices, like in the example below:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你需要乘以两个矩阵，就像下面的例子：
- en: '![img](img/B30992_04_001.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B30992_04_001.png)'
- en: 'Would you prefer to have to read this code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否更喜欢阅读以下代码：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or, would you prefer this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你更喜欢这个：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is much easier to understand that `c` is the result of the multiplication
    of `a` and `b` in the second example, and it is much easier to read the code.
    If we do not need to modify that multiplication logic, we do not even need to
    go into the implementation details of `matrix_mul()` . Therefore, readability
    is improved here while, in the first snippet, we would have to spend time trying
    to understand what that complicated list comprehension is doing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，理解`c`是`a`和`b`相乘的结果要容易得多，阅读代码也更容易。如果我们不需要修改这个乘法逻辑，我们甚至不需要进入`matrix_mul()`函数的实现细节。因此，在这里可读性得到了提高，而在第一个片段中，我们可能需要花费时间试图理解那个复杂的列表推导式在做什么。
- en: Do not worry if you do not understand list comprehensions, as we will study
    them in *Chapter 5* , *Comprehensions and Generators* .
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不理解列表推导式，请不要担心，我们将在*第五章*，*推导式和生成器*中学习它们。
- en: Improving traceability
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高可追溯性
- en: 'Imagine that we have written some code for an e-commerce website. We display
    the product prices on several pages. Imagine that the prices in the database are
    stored with no VAT (sales tax), but we want to display them on the website with
    VAT at 20%. Here are a few ways of calculating the VAT-inclusive price from the
    VAT-exclusive price:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们为电子商务网站编写了一些代码。我们在几个页面上显示产品价格。想象一下，数据库中的价格没有包含增值税（销售税），但我们想在网站上以20%的增值税显示它们。这里有几种从不含增值税价格计算含增值税价格的方法：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These four different ways of calculating a VAT-inclusive price are all perfectly
    acceptable; we have encountered all of them in the professional code that we have
    worked on over the years.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种计算含增值税价格的方法都是完全可以接受的；我们在过去几年中遇到的所有专业代码中都有遇到过。
- en: Now, imagine that we start selling products in different countries, and some
    of them have different VAT rates, so we need to refactor the code (throughout
    the website) in order to make that VAT calculation dynamic.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们开始在多个国家销售产品，其中一些国家有不同的增值税率，因此我们需要重构代码（在整个网站上）以使增值税计算动态化。
- en: How do we trace all the places in which we are performing a VAT calculation?
    Coding today is a collaborative task and we cannot be sure that the VAT has been
    calculated using only one of those forms. It is going to be difficult.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何追踪所有执行增值税计算的地方？现在的编码是一个协作任务，我们无法确定增值税是否只使用其中一种形式进行计算。这将是一件困难的事情。
- en: 'So, let us write a function that takes the input values `vat` and `price` (VAT-exclusive)
    and returns a VAT-inclusive price:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们编写一个函数，该函数接受输入值`vat`和`price`（不含增值税）并返回含增值税的价格：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we can import that function and use it in any place on the website where
    we need to calculate a VAT-inclusive price, and when we need to trace those calls,
    we can search for `calculate_price_with_vat` .
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以导入这个函数，并在网站上任何需要计算含增值税价格的地方使用它，当我们需要追踪这些调用时，我们可以搜索`calculate_price_with_vat`。
- en: Note that, in the preceding example, `price` is assumed to be VAT-exclusive,
    and `vat` is a percentage value (for example, 19, 20, or 23).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的例子中，`price`被认为是不含增值税的，而`vat`是一个百分比值（例如，19、20或23）。
- en: Scopes and name resolution
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围和命名解析
- en: 'In *Chapter 1* , *A Gentle Introduction to Python* , we discussed scopes and
    namespaces. We are going to expand on that concept now. Finally, we can talk in
    terms of functions, and this will make everything easier to understand. Let us
    start with a simple example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第一章*，*Python的温和介绍*中，我们讨论了范围和命名空间。现在我们将扩展这个概念。最后，我们可以用函数来讨论，这将使一切更容易理解。让我们从一个简单的例子开始：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We defined the `test` name in two different places in the previous example—it
    is actually in two different scopes. One is the global scope ( `test = 0` ), and
    the other is the local scope of the `my_function()` function ( `test = 1` ). If
    we execute the code, we will see this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在两个不同的地方定义了`test`这个名字——它实际上是在两个不同的范围内。一个是全局范围（`test = 0`），另一个是`my_function()`函数的局部范围（`test
    = 1`）。如果我们执行代码，我们会看到这个：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It is clear that `test = 1` shadows the `test = 0` assignment in `my_function()`
    . In the global context, `test` is still `0` , as you can see from the output
    of the program, but we define the `test` name again in the function body, and
    we set it to point to the integer `1` . Both of the `test` names therefore exist:
    one in the global scope, pointing to an int object with a value of `0` , and the
    other in the `my_function()` scope, pointing to an `int` object with a value of
    `1` . Let us comment out the line with `test = 1` . Python searches for the `test`
    name in the next enclosing namespace (recall the **LEGB** rule: **local** , **enclosing**
    , **global** , **built-in** , described in *Chapter 1* , *A Gentle Introduction
    to Python* ) and, in this case, we will see the value `0` printed twice. Try it
    in your code.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`test = 1`遮蔽了`my_function()`中的`test = 0`赋值。在全局范围内，`test`仍然是`0`，正如你可以从程序输出中看到的那样，但我们再次在函数体中定义了`test`名称，并将其设置为指向整数`1`。因此，两个`test`名称都存在：一个在全局作用域中，指向值为`0`的int对象，另一个在`my_function()`作用域中，指向值为`1`的`int`对象。让我们注释掉包含`test
    = 1`的行。Python会在下一个封装的作用域中搜索`test`名称（回想一下**LEGB**规则：**local**，**enclosing**，**global**，**built-in**，在*第一章*，*Python的温柔介绍*中描述），在这种情况下，我们会看到`0`被打印两次。在你的代码中试一试。
- en: 'Now, let us give you a more complex example with nested functions:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们给你一个更复杂的例子，包含嵌套函数：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we have two levels of shadowing. One level is in the
    `outer()` function, and the other one is in the `inner()` function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有两个层次的遮蔽。一个层次在`outer()`函数中，另一个层次在`inner()`函数中。
- en: 'If we run the code, we get:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行代码，我们会得到：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Try commenting out the `test = 1` line. Can you figure out what the result will
    be? When reaching the `print('outer:', test)` line, Python will have to look for
    `test` in the next enclosing scope; therefore it will find and print `0` , instead
    of `1` . Make sure you comment out `test = 2` as well, to see whether you understand
    what happens and whether the LEGB rule is clear to you, before proceeding.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试注释掉`test = 1`行。你能想出结果会是什么吗？当到达`print('outer:', test)`行时，Python将不得不在下一个封装的作用域中寻找`test`；因此，它会找到并打印`0`，而不是`1`。在继续之前，确保你也注释掉了`test
    = 2`，以确保你理解发生了什么，以及LEGB规则是否对你来说很清晰。
- en: Another thing to note is that Python gives us the ability to define a function
    in another function. The `inner()` function’s name is defined within the namespace
    of the `outer()` function, exactly as would happen with any other name.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的事情是，Python给了我们定义一个函数在另一个函数中的能力。`inner()`函数的名称是在`outer()`函数的作用域中定义的，这与任何其他名称的情况完全一样。
- en: The global and nonlocal statements
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局和非局部语句
- en: 'In the preceding example, we can alter what happens to the shadowing of the
    test name by using one of these two special statements: `global` and `nonlocal`
    . As you can see, when we define `test = 2` in the `inner()` function, we do not
    overwrite `test` in the `outer()` function or in the global scope.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以通过使用这两个特殊语句之一来改变对test名称的遮蔽：`global`和`nonlocal`。正如你所看到的，当我们定义`test
    = 2`在`inner()`函数中时，我们没有覆盖`outer()`函数或全局作用域中的`test`。
- en: We can get read access to those names if we use them in a nested scope that
    does not define them, but we cannot modify them because when we write an assignment
    instruction, we are actually defining a new name in the current scope.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在不定义它们的嵌套作用域中使用这些名称，我们可以获取对这些名称的读取访问权限，但因为我们实际上在当前作用域中定义了一个新名称，所以我们不能修改它们。
- en: 'We can use the `nonlocal` statement to change this behavior. According to the
    official documentation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`nonlocal`语句来改变这种行为。根据官方文档：
- en: ”The `nonlocal` statement causes the listed identifiers to refer to previously
    bound variables in the nearest enclosing scope excluding globals.”
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “`nonlocal`语句使列出的标识符引用最近封装作用域中先前绑定的变量，但不包括全局变量。”
- en: 'Let us introduce it in the `inner()` function and see what happens:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`inner()`函数中引入它，看看会发生什么：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice how in the body of the `inner()` function we have declared the `test`
    name to be `nonlocal` . Running this code produces the following result:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`inner()`函数体中我们如何声明`test`名称为`nonlocal`。运行此代码会产生以下结果：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By declaring `test` to be `nonlocal` in the `inner()` function, we actually
    bind the `test` name to the one declared in the `outer` function. If we removed
    the `nonlocal test` line from the `inner()` function and tried it inside the `outer()`
    function, we would get a `SyntaxError` , because the `nonlocal` statement works
    on enclosing scopes, but not in the global one.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `inner()` 函数中将 `test` 声明为 `nonlocal`，实际上是将 `test` 名称绑定到在 `outer` 函数中声明的那个。如果我们从
    `inner()` 函数中移除 `nonlocal test` 行并在 `outer()` 函数内部尝试，我们会得到一个 `SyntaxError`，因为
    `nonlocal` 语句作用于封装作用域，而不是全局作用域。
- en: 'Is there a way to get write access to that `test = 0` in the global namespace?
    Yes, we just need to use the `global` statement:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有一种方法可以获取全局命名空间中 `test = 0` 的写入权限？是的，我们只需要使用 `global` 语句：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that we have now declared the `test` name to be `global` , which will
    bind it to the one we defined in the global namespace ( `test = 0` ). Run the
    code and you should get the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在已经将 `test` 名称声明为 `global`，这将将其绑定到我们在全局命名空间中定义的那个（`test = 0`）。运行代码后，你应该得到以下结果：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This shows that the name affected by the `test = 2` assignment is now the one
    in the `global` scope. This would also work in the `outer()` function because,
    in this case, we are referring to the global scope.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明现在受 `test = 2` 赋值影响的名称是全局作用域中的那个。这也会在 `outer()` 函数中起作用，因为在这种情况下，我们正在引用全局作用域。
- en: Try it for yourself and see what changes. Spend some time to get comfortable
    with scopes and name resolution—it is very important. As a bonus question, can
    you tell what would happen if you defined `inner()` outside `outer()` in the preceding
    examples?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 亲自尝试并看看会发生什么变化。花些时间熟悉作用域和名称解析——这非常重要。作为附加问题，你能告诉我如果在先前的例子中将 `inner()` 定义在 `outer()`
    之外会发生什么吗？
- en: Input parameters
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入参数
- en: 'At the beginning of this chapter, we saw that a function can take input parameters.
    Before we delve into all the possible types of parameters, let us make sure you
    have a clear understanding of what passing an argument to a function means. There
    are three key points to keep in mind:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们看到了函数可以接受输入参数。在我们深入所有可能的参数类型之前，让我们确保你对向函数传递参数的含义有一个清晰的理解。有三个关键点需要记住：
- en: Argument-passing is nothing more than assigning an object to a local variable
    name
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数传递不过是将一个对象赋给局部变量名称
- en: Assigning an object to an argument name inside a function does not affect the
    caller
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内部将对象赋给参数名称不会影响调用者
- en: Changing a mutable object argument in a function does affect the caller
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数中更改可变对象参数会影响调用者
- en: 'Before we explore the topic of arguments any further, please allow us to clarify
    the terminology a little. According to the official Python documentation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步探讨参数主题之前，请允许我们稍微澄清一下术语。根据官方Python文档：
- en: ”Parameters are defined by the names that appear in a function definition, whereas
    arguments are the values actually passed to a function when calling it. Parameters
    define what types of arguments a function can accept.”
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “参数是由函数定义中出现的名称定义的，而参数是调用函数时实际传递给函数的值。参数定义了函数可以接受哪些类型的参数。”
- en: We will try to be precise when referring to parameters and arguments, but it
    is worth noting that they are sometimes used synonymously as well. Let us now
    look at some examples.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在提及参数和参数时将尽量做到精确，但值得注意的是，它们有时也被同义使用。现在让我们看看一些例子。
- en: Argument-passing
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数传递
- en: 'Take a look at the following code. We declare a name, `x` , in the global scope,
    then we declare a function, `func(y)` , and finally, we call it, passing `x` :'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码。我们在全局作用域中声明了一个名为 `x` 的变量，然后我们声明了一个函数 `func(y)`，最后我们调用它，传递 `x`：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When `func()` is called with `x` , within its local scope, a name, `y` , is
    created, and it is pointed to the same object that `x` is pointing to. This is
    better clarified in *Figure 4.2* (do not worry about the fact that this example
    was run with Python 3.11—this is a feature that has not changed).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `x` 调用 `func()` 函数时，在其局部作用域内，会创建一个名为 `y` 的变量，并且它指向与 `x` 相同的对象。这可以在 *图4.2*
    中更清楚地理解（不用担心这个例子是用Python 3.11运行的——这是一个没有改变的特性）。
- en: '![img](img/B30992_04_02.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B30992_04_02.png)'
- en: 'Figure 4.2: Understanding argument-passing with Python Tutor'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：使用Python Tutor理解参数传递
- en: 'The right-hand side of *Figure 4.2* depicts the state of the program when execution
    has reached the end, after `func()` has returned ( `None` ). Take a look at the
    **Frames** column, and note that we have two names, `x` and `func()` , in the
    global namespace ( **Global frame** ), pointing respectively to an **int** (with
    a value of `3` ) and to a `function` object. Right beneath it, in the rectangle
    titled **func** , we can see the function’s local namespace, in which only one
    name has been defined: `y` . Because we have called `func()` with `x` (line 6
    on the left side of the figure), `y` is pointing to the same object that `x` is.
    This is what happens under the hood when an argument is passed to a function.
    If we had used the name `x` instead of `y` in the function definition, things
    would have been exactly the same (but perhaps a bit confusing at first)—there
    would be a local `x` in the function, and a global `x` outside, as we saw in the
    *Scopes and name resolution* section previously in this chapter.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.2*的右侧展示了程序执行到达末尾时的状态，在`func()`返回（`None`）之后。看看**帧**列，你会注意到我们在全局命名空间（**全局帧**）中有两个名称，`x`和`func()`，分别指向一个**整数**（值为`3`）和一个`function`对象。在其下方，在标题为**func**的矩形中，我们可以看到函数的局部命名空间，其中只定义了一个名称：`y`。因为我们用`x`（图左侧的第6行）调用了`func()`，所以`y`指向与`x`相同的对象。这就是当将参数传递给函数时幕后发生的事情。如果我们用`x`而不是`y`在函数定义中使用，事情将会完全一样（但一开始可能有些令人困惑）——函数中会有一个局部的`x`，而全局的`x`在外面，就像我们在本章之前关于*作用域和名称解析*部分所看到的那样。'
- en: So, in a nutshell, what really happens is that the function creates, in its
    local scope, the names defined as parameters and, when we call it, we tell Python
    which objects those names must be pointed toward.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，简而言之，真正发生的事情是函数在其局部作用域中创建定义的名称作为参数，当我们调用它时，我们告诉Python这些名称必须指向哪些对象。
- en: Assignment to parameter names
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将值赋给参数名称
- en: 'Assignment to parameter names does not affect the caller. This is something
    that can be tricky to understand at first, so let us look at an example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将值赋给参数名称不会影响调用者。这可能是最初难以理解的事情之一，所以让我们来看一个例子：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, when we call the function with `func(x)` , the instruction
    `x = 7` is executed within the local scope of the `func()` function; the name
    `x` is pointed to an integer with a value of `7` , leaving the global `x` unaltered.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当我们用`func(x)`调用函数时，`x = 7`指令在`func()`函数的局部作用域中执行；名称`x`指向一个值为`7`的整数，而全局的`x`保持不变。
- en: Changing a mutable object
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改可变对象
- en: 'Changing a mutable object does affect the caller. This is important because
    although Python *appears to* behave differently with mutable objects, the behavior
    is, in fact, perfectly consistent. Let us look at an example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 修改可变对象会影响调用者。这一点很重要，因为尽管Python在处理可变对象时看起来行为不同，但实际上其行为是完全一致的。让我们来看一个例子：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, we changed the original object. If you think about it, there
    is nothing weird in this behavior. When we call `func(x)` , name `x` in the function’s
    namespace is set to point to the same object as the global `x` . Within the body
    of the function, we are not changing the global `x` , in that we are not changing
    which object it points to. We are merely accessing the element at position 1 in
    that object and changing its value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们改变了原始对象。如果你仔细想想，这种行为并没有什么奇怪之处。当我们调用`func(x)`时，函数命名空间中的`x`名称被设置为指向与全局`x`相同的对象。在函数体内部，我们并没有改变全局的`x`，也就是说，我们并没有改变它指向的对象。我们只是在那个对象的位置1访问元素并改变其值。
- en: 'Remember *point 2* in the *Input parameters* section: *Assigning an object
    to a parameter name within a function does not affect the caller* . If that is
    clear to you, the following code should not be surprising:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 记住*输入参数*部分中的*第2点*：*在函数内部将对象赋值给参数名不会影响调用者*。如果你明白了这一点，下面的代码应该不会让你感到惊讶：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Look at the two lines we have highlighted. At first, like before, we just access
    the caller object again, at position 1, and change that value to number `42` .
    Then, we reassign `x` to point to the `'something else'` string. This leaves the
    caller unaltered and, in fact, the output is the same as that of the previous
    snippet.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们标记的两行。一开始，就像之前一样，我们再次访问调用者对象，在位置1，并将该值改为数字`42`。然后，我们将`x`重新赋值以指向字符串`'something
    else'`。这不会改变调用者，实际上，输出与之前的代码片段相同。
- en: Take your time to play around with this concept, and experiment with prints
    and calls to the `id()` function until everything is clear in your mind. This
    is one of the key aspects of Python and it must be very clear, otherwise you risk
    introducing subtle bugs into your code. Once again, the Python Tutor website (
    [http://www.pythontutor.com/](http://www.pythontutor.com/) ) will help you a lot
    by giving you a visual representation of these concepts.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细研究这个概念，并通过打印和调用 `id()` 函数进行实验，直到你心中的一切都清晰。这是 Python 的一个关键特性，它必须非常清晰，否则你可能会在代码中引入微妙的错误。再次强调，Python
    Tutor 网站（[http://www.pythontutor.com/](http://www.pythontutor.com/)）通过提供这些概念的可视化表示，将极大地帮助你。
- en: Now that we have a good understanding of input parameters and how they behave,
    let us look at the different ways of passing arguments to functions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地理解了输入参数及其行为，让我们看看传递参数给函数的不同方式。
- en: Passing arguments
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递参数
- en: 'There are four different ways of passing arguments to a function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 传递函数参数有四种不同的方式：
- en: Positional arguments
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置参数
- en: Keyword arguments
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字参数
- en: Iterable unpacking
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可迭代解包
- en: Dictionary unpacking
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典解包
- en: Let us look at them one by one.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一来看。
- en: Positional arguments
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置参数
- en: 'When we call a function, each positional argument is assigned to the parameter
    in the corresponding *position* in the function definition:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用函数时，每个位置参数都被分配到函数定义中相应 *位置* 的参数：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is the most common way of passing arguments to functions (in some programming
    languages, this is the only way of passing arguments).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在某些编程语言中传递参数最常见的方式（在某些编程语言中，这是唯一的方式）。
- en: Keyword arguments
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键字参数
- en: 'Keyword arguments in a function call are assigned to parameters using the `name=value`
    syntax:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用中的关键字参数使用 `name=value` 语法分配给参数：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When we use keyword arguments, the order of the arguments does not need to match
    the order of the parameters in the function definition. This can make our code
    easier to read and debug. We do not need to remember (or look up) the order of
    parameters in a function definition. We can look at a function call and immediately
    know which argument corresponds to which parameter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用关键字参数时，参数的顺序不需要与函数定义中参数的顺序匹配。这可以使我们的代码更容易阅读和调试。我们不需要记住（或查找）函数定义中参数的顺序。我们可以查看函数调用，并立即知道哪个参数对应哪个参数。
- en: 'You can also use both positional and keyword arguments at the same time:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以同时使用位置参数和关键字参数：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Keep in mind, however, that **positional arguments always have to be listed
    before any keyword arguments** . For example, if you try something like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，**位置参数必须始终在关键字参数之前列出**。例如，如果你尝试这样做：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You will get the following error:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下错误：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Iterable unpacking
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可迭代解包
- en: 'Iterable unpacking uses the syntax `*iterable_name` to pass the elements of
    an *iterable* as positional arguments to a function:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代解包使用 `*iterable_name` 语法将可迭代对象的元素作为位置参数传递给函数：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is a very useful feature, particularly when we need to programmatically
    generate arguments for a function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用的特性，尤其是在我们需要以编程方式为函数生成参数时。
- en: Dictionary unpacking
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典解包
- en: 'Dictionary unpacking is to keyword arguments what iterable unpacking is to
    positional arguments. We use the syntax `**dictionary_name` to pass keyword arguments,
    constructed from the keys and values of a dictionary, to a function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 字典解包对于关键字参数来说，就像可迭代解包对于位置参数一样。我们使用 `**dictionary_name` 语法将字典的键和值构造的关键字参数传递给函数：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Combining argument types
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结合参数类型
- en: We have already seen that positional and keyword arguments can be used together,
    as long as they are passed in the proper order. We can also combine unpacking
    (of both kinds) with normal positional and keyword arguments. We can even combine
    unpacking multiple iterables and dictionaries.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，位置参数和关键字参数可以一起使用，只要它们按照正确的顺序传递。我们还可以将解包（两种类型）与正常的位置参数和关键字参数结合使用。我们甚至可以将多个可迭代对象和字典进行解包。
- en: 'Arguments must be passed in the following order:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 参数必须按照以下顺序传递：
- en: 'First, positional arguments: both ordinary ( `name` ) and iterable unpacking
    ( `*name` )'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，位置参数：普通（`name`）和解包（`*name`）
- en: Next come keyword arguments ( `name=value` ), which can be mixed with iterable
    unpacking `(*name` )
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是关键字参数（`name=value`），它可以与可迭代解包 `(*name)` 混合使用
- en: Finally, there is dictionary unpacking ( `**name` ), which can be mixed with
    keyword arguments ( `name=value` )
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，还有字典解包（`**name`），它可以与关键字参数（`name=value`）混合使用
- en: 'This will be much easier to understand with an example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过一个例子更容易理解：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: All the above calls to `func()` are equivalent and print `1 2 3 4 5 6` . Play
    around with this example until you are sure you understand it. Pay close attention
    to the errors you get when you get the order wrong.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述对 `func()` 的调用都是等效的，并打印 `1 2 3 4 5 6`。玩转这个例子，直到你确信你理解了它。当顺序错误时，请特别注意你得到的错误。
- en: The ability to unpack multiple iterables and dictionaries was introduced to
    Python by PEP 448. This PEP also introduced the ability to use unpacking in contexts
    other than just function calls. You can read all about it at [https://peps.python.org/pep-0448/](https://peps.python.org/pep-0448/)
    .
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 能够解包多个可迭代对象和字典的能力是由PEP 448引入到Python中的。这个PEP还引入了在函数调用之外使用解包的能力。你可以在[https://peps.python.org/pep-0448/](https://peps.python.org/pep-0448/)上阅读所有关于它的内容。
- en: 'When combining positional and keyword arguments, it is important to remember
    that each parameter can only appear once in the argument list:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当结合位置参数和关键字参数时，重要的是要记住每个参数在参数列表中只能出现一次：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we are passing two values for parameter `a` : the positional argument
    `2` and the keyword argument `a=1` . This is illegal, so we get an error when
    we try to run it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为参数 `a` 传递了两个值：位置参数 `2` 和关键字参数 `a=1`。这是非法的，所以当我们尝试运行它时，我们会得到一个错误：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Defining parameters
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义参数
- en: Function parameters can be classified into five groups.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数可以分为五组。
- en: 'Positional or keyword parameters: allow both positional and keyword arguments'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置或关键字参数：允许位置参数和关键字参数
- en: 'Variable positional parameters: collect an arbitrary number of positional arguments
    in a tuple'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变位置参数：在一个元组中收集任意数量的位置参数
- en: 'Variable keyword parameters: collect an arbitrary number of keyword arguments
    in a dictionary'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变关键字参数：在一个字典中收集任意数量的关键字参数
- en: 'Positional-only parameters: can only be passed as positional arguments'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅位置参数：只能作为位置参数传递
- en: 'Keyword-only parameters: can only be passed as keyword arguments'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅关键字参数：只能作为关键字参数传递
- en: All the parameters in the examples we have seen so far in this chapter are regular
    positional or keyword parameters. We have seen how they can be passed as both
    positional and keyword arguments. There is not much more to say about them, so
    let us look at the other categories. Before we do, though, let us briefly look
    at optional parameters.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们看到的所有参数都是常规的位置参数或关键字参数。我们已经看到了它们可以作为位置参数和关键字参数传递的方式。关于它们，没有太多可以说的，所以让我们看看其他类别。不过，在我们这样做之前，让我们简要地看看可选参数。
- en: Optional parameters
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选参数
- en: 'Apart from the categories we have looked at here, parameters can also be classified
    as either *required* or *optional* . **Optional parameters** have a default value
    specified in the function definition. The syntax is `name=value` :'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在这里看到的类别之外，参数还可以被分类为*必需*或*可选*。**可选参数**在函数定义中指定了默认值。语法是 `name=value`：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, `a` is required, while `b` has the default value `4` and `c` has the default
    value `88` . It is important to note that, with the exception of keyword-only
    parameters, required parameters must always be to the left of all optional parameters
    in the function definition. Try removing the default value from `c` in the above
    example and see what happens.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`a` 是必需的，而 `b` 有默认值 `4`，`c` 有默认值 `88`。重要的是要注意，除了仅关键字参数外，必需参数必须始终位于函数定义中所有可选参数的左侧。尝试在上面的例子中移除
    `c` 的默认值，看看会发生什么。
- en: Variable positional parameters
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变位置参数
- en: 'Sometimes you may prefer not to specify the exact number of positional parameters
    to a function; Python provides you with the ability to do this by using **variable
    positional parameters** . Let us look at a very common use case, the `minimum()`
    function. This is a function that calculates the minimum of its input values:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能更喜欢不指定函数的确切位置参数数量；Python通过使用**可变位置参数**为你提供了这样做的能力。让我们看看一个非常常见的用例，即 `minimum()`
    函数。这是一个计算输入值最小值的函数：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, when we define a parameter with an asterisk, `*` , prepended
    to its name, we are telling Python that this parameter will collect a variable
    number of positional arguments when the function is called. Within the function,
    `n` is a tuple. Uncomment `print(type(n))` to see for yourself, and play around
    with it for a bit.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当我们定义一个带有前缀星号`*`的参数时，我们是在告诉Python，当函数被调用时，这个参数将收集一个可变数量的位置参数。在函数内部，`n`是一个元组。取消注释`print(type(n))`来亲自查看，并稍作尝试。
- en: Note that a function can have at most one variable positional parameter—it would
    not make sense to have more. Python would have no way of deciding how to divide
    up the arguments between them. You also cannot specify a default value for a variable
    positional parameter. The default value is always an empty tuple.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一个函数最多只能有一个可变位置参数——拥有更多的参数是没有意义的。Python将无法决定如何在这些参数之间分配参数。你也不能为可变位置参数指定一个默认值。默认值始终是一个空元组。
- en: Have you noticed how we checked whether `n` was not empty with a simple `if
    n:` ? This is because collection objects evaluate to `True` when non-empty, and
    otherwise `False` , in Python. This is the case for tuples, sets, lists, dictionaries,
    and so on.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到我们是如何用简单的`if n:`来检查`n`是否为空的？这是因为集合对象在非空时在Python中评估为`True`，否则为`False`。这对元组、集合、列表、字典等都是如此。
- en: One other thing to note is that we may want to throw an error when we call the
    function with no parameters, instead of silently doing nothing. In this context,
    we are not concerned about making this function robust, but rather understanding
    variable positional parameters.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，当我们调用函数而没有参数时，我们可能希望抛出一个错误，而不是默默地什么也不做。在这种情况下，我们并不关心使这个函数健壮，而是理解可变位置参数。
- en: Did you notice that the syntax for defining variable positional parameters looks
    very much like the syntax for iterable unpacking? This is no coincidence. After
    all, the two features mirror each other. They are also frequently used together,
    since variable positional parameters save you from worrying about whether the
    length of the iterable you are unpacking matches the number of parameters in the
    function definition.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到定义可变位置参数的语法看起来非常像可迭代解包的语法？这并非巧合。毕竟，这两个特性是相互对应的。它们也经常一起使用，因为可变位置参数可以让你不必担心你解包的可迭代对象的长度是否与函数定义中参数的数量相匹配。
- en: Variable keyword parameters
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变关键字参数
- en: '**Variable keyword parameters** are very similar to variable positional parameters.
    The only difference is the syntax ( `**` instead of `*` ) and the fact that they
    are collected in a dictionary:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**可变关键字参数**与可变位置参数非常相似。唯一的区别是语法（使用`**`而不是`*`）以及它们被收集在一个字典中：'
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can see that adding `**` in front of the parameter name in the function
    definition tells Python to use that name to collect a variable number of keyword
    parameters. As in the case of variable positional parameters, each function can
    have at most one variable keyword parameter—and you cannot specify a default value.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在函数定义中将`**`添加到参数名之前告诉Python使用该名称来收集一个可变数量的关键字参数。与可变位置参数的情况一样，每个函数最多只能有一个可变关键字参数——你不能指定一个默认值。
- en: Just like variable positional parameters resemble iterable unpacking, variable
    keyword parameters resemble dictionary unpacking. Dictionary unpacking is also
    often used to pass arguments to functions with variable keyword parameters.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 就像可变位置参数类似于可迭代解包一样，可变关键字参数类似于字典解包。字典解包也常用于向具有可变关键字参数的函数传递参数。
- en: 'The reason why being able to pass a variable number of keyword arguments is
    so important may not be evident at the moment, so how about a more realistic example?
    Let us define a function that connects to a database: we want to connect to a
    default database by simply calling this function with no parameters. We also want
    to connect to any other database by passing to the function the appropriate parameters.
    Before you read on, try to spend a couple of minutes figuring out a solution by
    yourself:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 能够传递可变数量的关键字参数之所以如此重要，可能现在还不明显，那么让我们来看一个更实际的例子？让我们定义一个连接数据库的函数：我们希望通过不带参数调用这个函数来连接默认数据库。我们还想通过向函数传递适当的参数来连接任何其他数据库。在你继续阅读之前，试着花几分钟时间自己想出一个解决方案：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that, in the function, we can prepare a dictionary of connection parameters
    ( `conn_params` ) using default values as fallbacks, allowing them to be overwritten
    if they are provided in the function call. There are better ways to do this with
    fewer lines of code, but we are not concerned with that right now. Running the
    preceding code yields the following result:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在函数中，我们可以使用默认值作为后备来准备一个连接参数字典（`conn_params`），允许在函数调用中提供时覆盖它们。有更少代码行的方法来做这件事，但我们现在不关心那个。运行前面的代码会产生以下结果：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note the correspondence between the function calls and the output, and how default
    values are overridden according to what was passed to the function.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数调用与输出的对应关系，以及默认值是如何根据传递给函数的内容被覆盖的。
- en: Positional-only parameters
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅位置参数
- en: 'Starting from Python 3.8, PEP 570 ( [https://peps.python.org/pep-0570/](https://peps.python.org/pep-0570/)
    ) introduced **positional-only parameters** . There is a new function parameter
    syntax, `/` , indicating that a set of the function parameters must be specified
    positionally and *cannot* be passed as keyword arguments. Let us see a simple
    example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.8 开始，PEP 570 ([https://peps.python.org/pep-0570/](https://peps.python.org/pep-0570/))
    引入了**仅位置参数**。有一个新的函数参数语法 `/`，表示必须以位置指定一组函数参数，并且**不能**作为关键字参数传递。让我们看一个简单的示例：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding example, we define a function, `func()` , which specifies
    three parameters: `a` , `b` , and `c` . The `/` in the function signature indicates
    that `a` and `b` must be passed positionally, that is, not by keyword.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们定义了一个函数 `func()`，它指定了三个参数：`a`、`b` 和 `c`。函数签名中的 `/` 表示 `a` 和 `b` 必须通过位置传递，也就是说，不能通过关键字传递。
- en: 'The last two lines in the example show that we can call the function passing
    all three arguments positionally, or we can pass `c` by keyword. Both cases work
    fine, as `c` is defined after the `/` in the function signature. If we try to
    call the function by passing `a` or `b` by keyword, like so:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的最后两行显示，我们可以通过位置传递所有三个参数来调用函数，或者我们可以通过关键字传递 `c`。这两种情况都工作得很好，因为 `c` 在函数签名中的
    `/` 之后被定义。如果我们尝试通过关键字传递 `a` 或 `b` 来调用函数，如下所示：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This produces the following traceback:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下跟踪回溯：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding example shows us that Python is now complaining about how we called
    `func()` . We have passed `b` by keyword, but we are not allowed to do that.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例显示，Python 现在正在抱怨我们如何调用 `func()`。我们通过关键字传递了 `b`，但我们不允许这样做。
- en: 'Positional-only parameters can also be optional:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 仅位置参数也可以是可选的：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let us see what this feature brings to the language with a few examples borrowed
    from the official documentation. One advantage is the ability to fully emulate
    behaviors of existing C-coded functions:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过从官方文档中借用的一些示例来看看这个特性给语言带来了什么。一个优点是能够完全模拟现有 C 编码函数的行为：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Another important use case is to preclude keyword arguments when the parameter
    name is not helpful:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的用例是在参数名称没有帮助时排除关键字参数：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding example, the `obj` keyword argument impairs readability. Moreover,
    if we wish to refactor the internals of the `len` function, and rename `obj` to
    `the_object` (or any other name), the change is guaranteed not to break any client
    code, because there will not be any call to the `len()` function involving the
    now stale `obj` parameter name.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`obj` 关键字参数损害了可读性。此外，如果我们希望重构 `len` 函数的内部结构，并将 `obj` 重命名为 `the_object`（或任何其他名称），这种更改将保证不会破坏任何客户端代码，因为不会有任何调用
    `len()` 函数涉及现在过时的 `obj` 参数名称。
- en: 'Finally, using positional-only parameters implies that whatever is on the left
    of `/` remains available for use in variable keyword arguments, as shown by the
    following example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用仅位置参数意味着 `/` 左边的任何内容都可以用于变量关键字参数，如下面的示例所示：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The ability to retain parameter names in function signatures for use in `**kwargs`
    can lead to simpler and cleaner code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数签名中保留参数名称以在 `**kwargs` 中使用的能力可以导致代码更简单、更干净。
- en: 'Let us now explore the mirror version of positional-only: keyword-only parameters.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索仅位置参数的镜像版本：仅关键字参数。
- en: Keyword-only parameters
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅关键字参数
- en: 'Python 3 introduced **keyword-only parameters** . We are going to study them
    only briefly, as their use cases are not that frequent. There are two ways of
    specifying them, either after the variable positional parameters or after a bare
    `*` . Let us see an example of both:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3 引入了**仅关键字参数**。我们将只简要研究它们，因为它们的使用场景并不频繁。指定它们有两种方式，要么在变量位置参数之后，要么在裸星号
    `*` 之后。让我们看看两种方式的例子：
- en: '[PRE39]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As anticipated, the function `kwo()` takes a variable number of positional parameters
    ( `a` ) and a keyword-only one, `c` . The results of the calls are straightforward
    and you can uncomment the third call to see what error Python returns.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，函数 `kwo()` 接受一个可变数量的位置参数（`a`）和一个仅关键字参数，`c`。调用结果很简单，你可以取消注释第三个调用以查看 Python
    返回的错误。
- en: The same applies to the function `kwo2()` , which differs from `kwo` in that
    it takes a positional argument, `a` , a keyword argument, `b` , and then a keyword-only
    one, `c` . You can uncomment the third call to see the error that is produced.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于函数 `kwo2()`，它与 `kwo` 不同之处在于它接受一个位置参数 `a`，一个关键字参数 `b`，然后是一个仅关键字参数 `c`。你可以取消注释第三个调用以查看产生的错误。
- en: Now that you know how to specify different types of input parameters, let us
    see how you can combine them in function definitions.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何指定不同类型的输入参数，让我们看看如何在函数定义中组合它们。
- en: Combining input parameters
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合输入参数
- en: 'You can combine different parameter types in the same function (in fact, it
    is often very useful to do so). As in the case of combining different types of
    arguments in the same function call, there are some restrictions on ordering:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在同一个函数中组合不同类型的参数（实际上，这样做通常非常有用）。正如在同一个函数调用中组合不同类型的参数一样，有一些关于顺序的限制：
- en: Positional-only parameters come first, followed by a `/` .
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅位置参数首先出现，后面跟着一个 `/` 。
- en: Normal parameters go after any positional-only parameters.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常参数位于任何位置仅参数之后。
- en: Variable positional parameters go after normal parameters.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量位置参数位于正常参数之后。
- en: Keyword-only parameters go after variable positional parameters.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅关键字参数位于变量位置参数之后。
- en: Variable keyword parameters always go last.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量关键字参数总是放在最后。
- en: For positional-only and normal parameters, any required parameters must be defined
    before any optional parameters. This means that if you have an optional positional-only
    parameter, all your normal parameters must be optional too. This rule does not
    affect keyword-only parameters.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于位置仅和正常参数，任何必需的参数都必须在任何可选参数之前定义。这意味着如果你有一个可选的位置仅参数，所有你的正常参数也必须是可选的。这条规则不影响仅关键字参数。
- en: 'These rules can be a bit tricky to understand without an example, so let us
    look at a couple of them:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则在没有例子的情况下可能有点难以理解，所以让我们看看几个例子：
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note the order of the parameters in the function definition. The execution
    of this yields the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数定义中参数的顺序。执行结果如下：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let us now look at an example with keyword-only parameters:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个关于仅关键字参数的例子：
- en: '[PRE42]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Note that we have both positional-only and keyword-only parameters in the function
    declaration: `a` is positional-only, while `d` and `e` are keyword-only. They
    come after the `*args` variable positional argument, and it would be the same
    if they came right after a single `*` (in which case there would not be any variable
    positional parameter). The execution of this yields the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在函数声明中既有位置仅参数也有仅关键字参数：`a` 是位置仅参数，而 `d` 和 `e` 是仅关键字参数。它们在 `*args` 变量位置参数之后，如果它们直接跟在单个
    `*` 之后（在这种情况下将没有变量位置参数），结果将是相同的。执行结果如下：
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: One other thing to note is the names we gave to the variable positional and
    keyword parameters. You are free to choose differently but be aware that `args`
    and `kwargs` are the conventional names given to these parameters, at least generically.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一点需要注意，我们给变量位置参数和关键字参数取的名字。你可以自由选择不同的名字，但请注意，`args` 和 `kwargs` 是这些参数的传统名称，至少在通用意义上是这样。
- en: More signature examples
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多签名示例
- en: 'To briefly recap on function signatures that use the positional- and keyword-only
    specifiers, here are some further examples. Omitting the variable positional and
    keyword parameters, for brevity, we are left with the following syntax:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简要回顾使用位置和仅关键字指定符的函数签名，这里有一些进一步的例子。为了简洁起见，省略了变量位置和关键字参数，我们得到以下语法：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: First, we have positional-only, then positional or keyword parameters, and finally
    keyword-only ones.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有位置仅参数，然后是位置或关键字参数，最后是仅关键字参数。
- en: 'Some other valid signatures are presented below:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了其他一些有效的签名：
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'All of the above are valid signatures, while the following would be invalid:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的上述签名都是有效的，而以下将是无效的：
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can read about the grammar specifications in the official documentation:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档中阅读关于语法规范的说明：
- en: '[https://docs.python.org/3/reference/compound_stmts.html#function-definitions](https://docs.python.org/3/reference/compound_stmts.html#function-definitions)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/reference/compound_stmts.html#function-definitions](https://docs.python.org/3/reference/compound_stmts.html#function-definitions)'
- en: A useful exercise for you at this point would be to implement any of the above
    example signatures, print out the values of those parameters, like we have done
    in previous exercises, and play around passing arguments in different ways.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，对你来说一个有用的练习是实现上述示例签名中的任何一个，打印出那些参数的值，就像我们在之前的练习中所做的那样，并尝试以不同的方式传递参数。
- en: Avoid the trap! Mutable defaults
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免陷阱！可变默认值
- en: 'One thing to be aware of, in Python, is that default values are created at
    definition time; therefore, subsequent calls to the same function will possibly
    behave differently according to the mutability of their default values. Let us
    look at an example:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，有一件事需要注意，那就是默认值是在定义时创建的；因此，对同一函数的后续调用可能会根据其默认值的可变性而表现出不同的行为。让我们来看一个例子：
- en: '[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Both parameters have mutable default values. This means that, if you affect
    those objects, any modification will stick around in subsequent function calls.
    See if you can understand the output of those calls:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 两个参数都有可变的默认值。这意味着，如果你影响这些对象，任何修改都会在后续的函数调用中保留。看看你是否能理解这些调用的输出：
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'While this behavior may seem weird at first, it actually makes sense, and it
    is very handy—when using **memoization** techniques, for example. Even more interesting
    is what happens when, between the calls, we introduce one that does not use defaults,
    such as this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种行为一开始可能看起来很奇怪，但实际上是有道理的，而且非常方便——例如，当使用**记忆化**技术时。更有趣的是，当在调用之间引入一个不使用默认值的调用时会发生什么，比如这个：
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When we run this code, this is the output:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此代码时，这是输出：
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This output shows us that the defaults are retained even if we call the function
    with other values. One question that comes to mind is, how do I get a fresh empty
    value every time? Well, the convention is the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示，即使我们用其他值调用函数，默认值也会被保留。一个自然而然的问题就是，我如何每次都得到一个全新的空值？嗯，惯例是这样的：
- en: '[PRE51]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that, by using the preceding technique, if `a` is not passed when calling
    the function, we always get a brand new, empty list.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过使用前面的技术，如果在调用函数时没有传递`a`，我们总是会得到一个全新的、空的列表。
- en: After a thorough exposition of input parameters, it is now time to look at the
    other side of the coin, returning output values.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细阐述了输入参数之后，现在我们来看看硬币的另一面，即返回输出值。
- en: Return values
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回值
- en: We have already said that to return something from a function we need to use
    the `return` statement, followed by what we want to return. There can be as many
    `return` statements as needed in the body of a function.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过，要从函数中返回某些内容，我们需要使用`return`语句，后面跟着我们想要返回的内容。一个函数体内可以有任意多的`return`语句。
- en: On the other hand, if within the body of a function we do not return anything,
    or we invoke a bare `return` statement, the function will return `None` . This
    behavior is harmless when it is not needed, but allows for interesting patterns,
    and confirms Python as a very consistent language.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果在函数体内我们没有返回任何内容，或者调用了裸的`return`语句，函数将返回`None`。当不需要这种行为时，这种行为是无害的，但它允许有趣的模式，并证实Python是一种非常一致的语言。
- en: 'We say it is harmless because you are never forced to collect the result of
    a function call. We will show you what we mean with an example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说这是无害的，因为你永远不会被迫收集函数调用的结果。我们将用一个例子来展示我们的意思：
- en: '[PRE52]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that the whole body of the function is composed only of the `pass` statement.
    As the official documentation tells us, `pass` is a null operation, as, when it
    is executed, nothing happens. It is useful as a placeholder when a statement is
    required syntactically but no code needs to be executed. In other languages, we
    would probably just indicate that with a pair of curly brackets ( `{}` ), which
    define an *empty scope* ; but in Python, a scope is defined by indenting code,
    therefore a statement such as `pass` is necessary.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数的主体仅由`pass`语句组成。正如官方文档所述，`pass`是一个空操作，当它执行时，没有任何事情发生。它在需要语法上的语句但不需要执行代码时非常有用。在其他语言中，我们可能会用一对花括号（`{}`）来表示这一点，这定义了一个*空范围*；但在Python中，范围是通过缩进来定义的，因此需要一个如`pass`这样的语句。
- en: Notice also that the first call to `func()` returns a value ( `None` ) that
    we do not collect. As we mentioned before, collecting the return value of a function
    call is not mandatory.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`func()`的第一个调用返回一个值（`None`），我们没有收集。正如我们之前提到的，收集函数调用的返回值不是强制性的。
- en: 'Let us see a more interesting example. Remember that, in *Chapter 1* , *A Gentle
    Introduction to Python* , we talked about the *factorial* function. Let us write
    our own implementation here (for simplicity, we will assume the function is always
    called correctly with appropriate values, so we do not need to sanity-check the
    input argument):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更有趣的例子。记住，在*第一章*，*Python的温柔介绍*中，我们讨论了*阶乘*函数。让我们在这里编写我们自己的实现（为了简单起见，我们将假设函数总是以适当的值正确调用，因此我们不需要对输入参数进行合理性检查）：
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that we have two points of return. If `n` is either `0` or `1` , we return
    `1` . Otherwise, we perform the required calculation and return `result` .
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们有两个返回点。如果`n`是`0`或`1`，我们返回`1`。否则，我们执行所需的计算并返回`result`。
- en: 'In Python, it is common to use the `in` operator to do a membership check,
    as we did in the preceding example, instead of the more verbose:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，使用`in`运算符进行成员检查是很常见的，就像我们在前一个例子中所做的那样，而不是更冗长的：
- en: '[PRE54]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let us now try to write this function a little bit more succinctly:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试将这个函数写得更简洁一些：
- en: '[PRE55]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This simple example shows how Python is both elegant and concise. This implementation
    is readable even if we have never seen `reduce()` or `mul()` . If you cannot read
    or understand it, set aside a few minutes, and do some research in the Python
    documentation until its behavior is clear to you. Being able to look up functions
    in the documentation and understand code written by someone else is a task that
    every developer needs to be able to perform.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子展示了Python既优雅又简洁。即使我们没有见过`reduce()`或`mul()`，这个实现也是可读的。如果你不能阅读或理解它，请留出几分钟时间，在Python文档中做一些研究，直到它的行为对你来说很清楚。在文档中查找函数并理解别人编写的代码是每个开发者都需要能够执行的任务。
- en: To this end, make sure you look up the `help()` function, which proves quite
    helpful when exploring with the console.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，确保你查阅了`help()`函数，这在用控制台探索时非常有帮助。
- en: Returning multiple values
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回多个值
- en: 'To return multiple values is easy: you just use tuples. Let us look at a simple
    example that mimics the `divmod()` built-in function:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回多个值很简单：你只需使用元组。让我们看看一个简单的例子，它模仿了内置的`divmod()`函数：
- en: '[PRE56]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We could have wrapped the part that is highlighted in the preceding code within
    brackets, but there is no need for that. The preceding function returns both the
    result and the remainder of the division, at the same time.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们原本可以在前述代码中用括号括起高亮的部分，但这样做没有必要。前述函数同时返回了除法的结果和余数。
- en: In the source code for this example, we have left a simple example of a test
    function to make sure the code is doing the correct calculation.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子的源代码中，我们留下了一个简单的测试函数示例，以确保代码正在执行正确的计算。
- en: A few useful tips
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些有用的提示
- en: 'When writing functions, it is very useful to follow guidelines so that you
    write them well. We will quickly point some of them out:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写函数时，遵循一些指南非常有用，这样你就能写出好的函数。我们将很快指出其中的一些：
- en: '**Functions should do one thing** : Functions that do one thing are easy to
    describe in one short sentence; functions that do multiple things can be split
    into smaller functions that do one thing. These smaller functions are usually
    easier to read and understand.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数应该只做一件事**：只有一个功能的函数可以用一句话简单描述；做多件事的函数可以拆分成做一件事的小函数。这些较小的函数通常更容易阅读和理解。'
- en: '**Functions should be small** : The smaller they are, the easier it is to test
    and write them so that they do one thing.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数应尽量小**：它们越小，就越容易测试和编写，以便它们只做一件事。'
- en: '**The fewer input parameters, the better** : Functions that take a lot of parameters
    quickly become hard to manage (among other issues).'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入参数越少越好**：接受很多参数的函数很快就会变得难以管理（以及其他问题）。'
- en: '**Functions should be consistent in their return values** : Returning `False`
    and returning `None` are not the same thing, even if, within a Boolean context,
    they both evaluate to `False` . `False` means that we have information ( `False`
    ), while `None` means that there is no information. Try writing functions that
    return in a consistent way, no matter what happens in their logic.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数的返回值应保持一致**：返回`False`和返回`None`是两回事，即使在布尔上下文中它们都评估为`False`。`False`表示我们有信息（`False`），而`None`表示没有信息。尝试编写在逻辑中无论发生什么都能以一致方式返回结果的函数。'
- en: '**Functions should have no side effects** : In functional programming, there
    is the concept of **pure functions** . This type of function adheres to two main
    principles:'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数应无副作用**：在函数式编程中，有**纯函数**的概念。这种类型的函数遵循两个主要原则：'
- en: '**Deterministic output** : This means that given the same set of inputs, the
    output produced will always be the same. In other words, the function’s behavior
    is not dependent on any external or global state that might change during execution.'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确定性输出**：这意味着给定相同的输入集，产生的输出将始终相同。换句话说，函数的行为不依赖于任何可能在执行期间改变的外部或全局状态。'
- en: '**No side effects** : This means that pure functions do not cause any observable
    side effects in the system. That is, they do not alter any external state, like
    modifying global variables or performing I/O operations like reading from or writing
    to a file or the display.'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无副作用**：这意味着纯函数不会在系统中引起任何可观察的副作用。也就是说，它们不会改变任何外部状态，如修改全局变量或执行I/O操作，如从文件或显示中读取或写入。'
- en: While you should aim to write pure functions whenever possible, it is important
    that those you write should at least have no side effects. They should not affect
    the value of the arguments they are called with.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你应该尽可能编写纯函数，但重要的是你编写的函数至少不应有副作用。它们不应影响它们被调用的参数的值。
- en: 'This is probably the hardest statement to understand at this point, so we will
    give you an example using lists. In the following code, note how `numbers` is
    not sorted by the `sorted()` function, which returns a sorted copy of `numbers`
    . Conversely, the `list.sort()` method is acting on the `numbers` object itself,
    and that is fine because it is a method (a function that belongs to an object
    and therefore has the right to modify it):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是目前最难理解的说法，所以我们将用列表举例。在下面的代码中，注意`numbers`没有被`sorted()`函数排序，该函数返回`numbers`的排序副本。相反，`list.sort()`方法作用于`numbers`对象本身，这是可以的，因为它是一个方法（一个属于对象的函数，因此有权修改它）：
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Follow these guidelines and you will automatically shield yourself from certain
    types of bugs.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些指南，你将自动保护自己免受某些类型错误的影响。
- en: '*Chapter 3* of *Clean Code* , by Robert C. Martin, is dedicated to functions,
    and it is one of the best sets of guidelines we have ever read on the subject.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 《代码整洁之道》（Clean Code）的第三章节，由罗伯特·C·马丁（Robert C. Martin）所著，专门讨论函数，这是我们读过的关于这个主题最好的指南之一。
- en: Recursive functions
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归函数
- en: When a function calls itself to produce a result, it is said to be **recursive**
    . Sometimes recursive functions are very useful, in that they make it easier to
    write the logic. Some algorithms are very easy to write using recursion, while
    others are not. There is no recursive function that cannot be rewritten in an
    iterative fashion, so it is usually up to the programmer to choose the best approach
    for the case at hand.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数调用自身以产生结果时，它被称为**递归**。有时递归函数非常有用，因为它们使编写逻辑变得更容易。有些算法使用递归编写非常容易，而有些则不然。没有递归函数不能以迭代方式重写，所以通常取决于程序员选择最适合当前情况的最好方法。
- en: 'The body of a recursive function usually has two sections: one where the return
    value depends on a subsequent call to itself, and one where it does not (called
    the **base case** ).'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数的主体通常有两个部分：一个部分返回值依赖于对自身的后续调用，另一个部分则不（称为**基本情况**）。
- en: 'As an example, we can consider the (hopefully now familiar) **factorial** function,
    *N!* . The base case is when *N* is either 0 or 1—the function returns `1` with
    no need for further calculation. On the other hand, in the general case, *N!*
    returns the product:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以考虑（希望现在熟悉的）**阶乘**函数 *N!*。当 *N* 为 0 或 1 时，这是基本情况——函数返回 `1` 而无需进一步计算。另一方面，在一般情况下，*N!*
    返回乘积：
- en: '[PRE58]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If you think about it, *N!* can be rewritten like this: *N! = (N-1)! * N* .
    As a practical example, consider this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想想，*N!* 可以这样重写：*N! = (N-1)! * N* 。作为一个实际例子，考虑以下内容：
- en: '[PRE59]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let us write this down in code:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把以下内容用代码写下来：
- en: '[PRE60]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Recursive functions are often used when writing algorithms, and they can be
    really fun to write. As an exercise, try to solve a couple of simple problems
    using both a recursive and an iterative approach. Good candidates for practice
    might be calculating Fibonacci numbers or the length of a string—things like that.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数在编写算法时经常被使用，编写起来也很有趣。作为一个练习，尝试使用递归和迭代方法解决几个简单的问题。练习的好候选可能是计算斐波那契数或字符串的长度——诸如此类的事情。
- en: When writing recursive functions, always consider how many nested calls you
    make, since there is a limit. For further information on this, check out `sys.getrecursionlimit()`
    and `sys.setrecursionlimit()` .
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写递归函数时，始终要考虑你做了多少嵌套调用，因为这是有限制的。关于这方面的更多信息，请查看 `sys.getrecursionlimit()` 和
    `sys.setrecursionlimit()` 。
- en: Anonymous functions
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名函数
- en: One last type of function that we want to talk about is **anonymous** functions.
    These functions, which are called **lambdas** in Python, are usually used when
    a fully-fledged function with its own name would be overkill, and all we want
    is a quick, simple one-liner.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要讨论的一种函数类型是**匿名函数**。这些函数在 Python 中被称为**lambda**函数，通常在不需要具有自己名称的完整函数，而只需要一个简单的一行代码时使用。
- en: 'Imagine that we wanted a list of all the numbers up to a certain value of *N*
    that are also multiples of five. We could use the `filter()` function for this,
    which will require a function and an iterable as input. The return value is a
    filter object that, when iterated over, yields the elements from the input iterable
    for which the function returns `True` . Without using an anonymous function, we
    might do something like this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个包含所有到某个值 *N* 的数字的列表，这些数字也是五的倍数。我们可以使用 `filter()` 函数来做这件事，这需要一个函数和一个可迭代对象作为输入。返回值是一个过滤器对象，当你遍历它时，它会产生从输入可迭代对象中返回
    `True` 的元素。不使用匿名函数，我们可能会这样做：
- en: '[PRE61]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Note how we use `is_multiple_of_five()` to filter through the first *n* natural
    numbers. This seems a bit excessive—the task is simple and we do not need to keep
    the `is_multiple_of_five()` function around for anything else. Let us rewrite
    it using a lambda function:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何使用 `is_multiple_of_five()` 来过滤前 *n* 个自然数的。这看起来有点过度——任务很简单，我们不需要保留 `is_multiple_of_five()`
    函数用于其他任何事情。让我们用 lambda 函数重写它：
- en: '[PRE62]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The logic is the same, but the filtering function is now a lambda. Defining
    a lambda is very easy and follows this form:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑是相同的，但现在过滤函数是一个 lambda。定义 lambda 非常简单，遵循以下形式：
- en: '[PRE63]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'A function object is returned, which is equivalent to this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的是一个函数对象，它相当于以下内容：
- en: '[PRE64]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note that optional parameters are indicated following the common syntax of wrapping
    them in square brackets.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可选参数按照常见的语法用方括号括起来表示。
- en: 'Let us look at another couple of examples of equivalent functions, defined
    in both forms:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个等价函数的例子，这些函数以两种形式定义：
- en: '[PRE65]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The preceding examples are very simple. The first one adds two numbers, and
    the second one produces the uppercase version of a string. Note that we assigned
    what is returned by the `lambda` expressions to a name ( `adder_lambda` , `to_upper_lambda`
    ), but there is no need for that when you use lambdas in the way we did in the
    `filter()` example.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 上述例子非常简单。第一个例子是加两个数字，第二个例子是产生字符串的大写版本。请注意，我们已将 `lambda` 表达式返回的内容分配给一个名称（`adder_lambda`，`to_upper_lambda`），但在
    `filter()` 例子中我们以这种方式使用 lambda 时并不需要这样做。
- en: Function attributes
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数属性
- en: 'Every function is a fully fledged object and, as such, it has several attributes.
    Some of them are special and can be used in an introspective way to inspect the
    function object at runtime. The following script is an example that shows a few
    of them and how to display their value for an example function:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都是一个完整的对象，因此它有几个属性。其中一些是特殊的，可以在运行时以自省的方式检查函数对象。以下脚本是一个示例，展示了其中的一些属性以及如何显示示例函数的值：
- en: '[PRE66]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We used the built-in `getattr()` function to get the value of those attributes.
    `getattr(obj, attribute)` is equivalent to `obj.attribute` and comes in handy
    when we need to dynamically get an attribute at runtime, taking the name of the
    attribute from a variable (as in this example). Running this script yields:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了内置的`getattr()`函数来获取这些属性的值。`getattr(obj, attribute)`等同于`obj.attribute`，在需要动态获取运行时属性时非常有用，此时属性名称来自变量（如本例所示）。运行此脚本会产生以下结果：
- en: '[PRE67]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We have omitted the value of the `__globals__` attribute, as it was too big.
    An explanation of the meaning of this attribute can be found in the *Callable
    types* section of the *Python Data Model* documentation page:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了`__globals__`属性的值，因为它太大。关于此属性含义的解释可以在*Python数据模型*文档页面的*可调用类型*部分找到：
- en: '[https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy](https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[Python 3 数据模型标准层次结构](https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy)'
- en: You can use the built-in `dir()` function to get a list of all the attributes
    of any object.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用内置的`dir()`函数来获取任何对象的全部属性列表。
- en: 'One thing to notice in the previous example is the use of this clause:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中要注意的一点是这条语句的使用：
- en: '[PRE68]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This line makes sure that whatever follows is only executed when the module
    is run directly. When you run a Python script, Python sets the `__name__` variable
    to `"__main__"` in that script. Conversely, when you import a Python script as
    a module into another script, the `__name__` variable is set to the name of the
    script/module being imported.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码确保只有当模块直接运行时，随后的代码才会执行。当你运行一个Python脚本时，Python会将该脚本中的`__name__`变量设置为`"__main__"`。相反，当你将Python脚本作为模块导入到另一个脚本中时，`__name__`变量会被设置为正在导入的脚本/模块的名称。
- en: Built-in functions
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置函数
- en: Python comes with a lot of built-in functions. They are available anywhere,
    and you can get a list of them by inspecting the `builtins` module with `dir(__builtins__)`
    , or by going to the official Python documentation. Unfortunately, we do not have
    the room to go through all of them here. We have already seen some of them, such
    as `any` , `bin` , `bool` , `divmod` , `filter` , `float` , `getattr` , `id` ,
    `int` , `len` , `list` , `min` , `print` , `set` , `tuple` , `type` , and `zip`
    , but there are many more, which you should read about at least once. Get familiar
    with them, experiment, write a small piece of code for each of them, and make
    sure you have them at your fingertips so that you can use them when needed.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带了许多内置函数。它们在任何地方都可用，你可以通过检查`builtins`模块使用`dir(__builtins__)`或通过访问官方Python文档来获取它们的列表。不幸的是，我们没有足够的空间在这里介绍它们的所有内容。我们已经看到了一些，例如`any`、`bin`、`bool`、`divmod`、`filter`、`float`、`getattr`、`id`、`int`、`len`、`list`、`min`、`print`、`set`、`tuple`、`type`和`zip`，但还有很多其他的，你至少应该阅读一次。熟悉它们，进行实验，为每个函数编写一小段代码，并确保你能够随时使用它们。
- en: 'You can find a list of built-in functions in the official documentation, here:
    [https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html)
    .'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档中找到内置函数的列表，这里：[https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html)。
- en: Documenting your code
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录你的代码
- en: We are big fans of code that does not need documentation. When we write elegant
    code, following established principles, the code should come out as self-explanatory,
    with documentation being almost unnecessary. Nevertheless, adding a docstring
    to a function, or a comment with important information, can be very useful.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是无需文档的代码的忠实粉丝。当我们遵循既定原则编写优雅的代码时，代码应该自然地具有自解释性，文档几乎变得不必要。然而，给函数添加一个docstring，或者添加包含重要信息的注释，可能非常有用。
- en: You can find the guidelines for documenting Python in PEP 257 – Docstring conventions
    at [https://peps.python.org/pep-0257/](https://peps.python.org/pep-0257/) , but
    we will show you the basics here.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在PEP 257 – Docstring conventions中找到记录Python的指南，该指南位于[https://peps.python.org/pep-0257/](https://peps.python.org/pep-0257/)，但我们将在这里向您展示基础知识。
- en: 'Python is documented with strings, which are aptly called **docstrings** .
    Any object can be documented, and we can use either one-line or multi-line docstrings.
    One-liners are very simple. They should not provide another signature for the
    function, but instead state its purpose:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用字符串进行文档记录，这些字符串恰当地被称为**docstrings**。任何对象都可以进行文档记录，我们可以使用单行或多行docstrings。单行docstrings非常简单。它们不应提供函数的另一个签名，而应说明其目的：
- en: '[PRE69]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Using triple double-quoted strings allows you to expand easily later. Use sentences
    that end in a period, and do not leave blank lines before or after.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三重双引号字符串可以让你以后轻松扩展。使用以句号结尾的句子，并且不要在前后留下空白行。
- en: 'Multiline comments are structured in a similar way. There should be a one-liner
    that briefly gives you the gist of what the object is about, and then a more verbose
    description. As an example, we have documented a fictitious `connect()` function,
    using the **Sphinx** notation, in the following example:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释的结构与此类似。应该有一行简短地给出对象的大致内容，然后是一个更详细的描述。例如，我们在以下示例中使用了 **Sphinx** 语法，对虚构的
    `connect()` 函数进行了文档说明：
- en: '[PRE70]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Sphinx is one of the most widely used tools for creating Python documentation—in
    fact, the official Python documentation was written with it. It is definitely
    worth spending some time checking it out.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx 是创建 Python 文档最广泛使用的工具之一——实际上，官方的 Python 文档就是用它编写的。花些时间检查它绝对值得。
- en: The `help()` built-in function, which is intended for interactive use, creates
    a documentation page for an object using its docstring.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`help()` 内置函数，旨在用于交互式使用，它使用对象的文档字符串为其创建一个文档页面。'
- en: Importing objects
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入对象
- en: Now that we know a lot about functions, let us look at how to use them. The
    whole point of writing functions is to be able to reuse them later and, in Python,
    this translates to importing them into the namespace where they are needed. There
    are many ways to import objects into a namespace, but the most common ones are
    `import module_name` and `from module_name import function_name` . Of course,
    these are quite simplistic examples, but bear with us for the time being.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对函数有了很多了解，让我们看看如何使用它们。编写函数的全部意义在于能够以后重用它们，在 Python 中，这相当于将它们导入到需要的命名空间中。将对象导入命名空间有许多方法，但最常见的是
    `import module_name` 和 `from module_name import function_name` 。当然，这些只是相当简单的例子，但请耐心等待。
- en: 'The `import module_name` form finds the `module_name` module and defines a
    name for it in the local namespace, where the `import` statement is executed.
    The `from module_name import identifier` form is a little bit more complicated
    than that but basically does the same thing. It finds `module_name` and searches
    for an attribute (or a submodule) and stores a reference to `identifier` in the
    local namespace. Both forms have the option to change the name of the imported
    object using the `as` clause:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`import module_name` 形式查找 `module_name` 模块，并在执行 `import` 语句的本地命名空间中为其定义一个名称。`from
    module_name import identifier` 形式比这复杂一点，但基本上做的是同样的事情。它找到 `module_name` 并搜索一个属性（或子模块），并在本地命名空间中存储对
    `identifier` 的引用。这两种形式都有使用 `as` 子句更改导入对象名称的选项：'
- en: '[PRE71]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Just to give you a flavor of what importing looks like, here is an example
    from a test module of one of Fabrizio’s projects (notice that the blank lines
    between blocks of imports follow the guidelines from PEP 8 at [https://peps.python.org/pep-0008/#imports](https://peps.python.org/pep-0008/#imports)
    : standard library first, then third party, and finally local code):'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你了解导入的样子，这里有一个来自 Fabrizio 的项目测试模块的示例（注意，导入块之间的空白行遵循 PEP 8 的指南 [https://peps.python.org/pep-0008/#imports](https://peps.python.org/pep-0008/#imports)
    ：首先是标准库，然后是第三方库，最后是本地代码）：
- en: '[PRE72]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: When we have a structure of files starting in the root of our project, we can
    use the dot notation to get to the object we want to import into our current namespace,
    be it a package, a module, a class, a function, or anything else.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的文件结构从项目的根目录开始时，我们可以使用点符号来获取我们想要导入到当前命名空间的对象，无论是包、模块、类、函数还是其他任何东西。
- en: The `from module import` syntax also allows a catch-all clause, `from module
    import *` , which is sometimes used to get all the names from a module into the
    current namespace at once. This practice is frowned upon for several reasons,
    relating to performance and the risk of silently shadowing other names. You can
    read all that there is to know about imports in the official Python documentation
    but, before we leave the subject, let us give you a better example.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`from module import` 语法还允许一个通配符子句，`from module import *` ，有时用于一次性将模块中的所有名称导入到当前命名空间中。这种做法因性能和静默覆盖其他名称的风险而被不推荐。你可以在官方
    Python 文档中找到有关导入的所有信息，但在我们离开这个主题之前，让我们给你一个更好的例子。'
- en: 'Imagine that we have defined a couple of functions, `square(n)` and `cube(n)`
    , in a module, `funcdef.py` , which is in the `util` folder. We want to use them
    in a couple of modules that are at the same level as the `util` folder, called
    `func_import.py` and `func_from.py` . Showing the tree structure of that project
    produces something like this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们已经在`funcdef.py`模块中定义了几个函数，例如`square(n)`和`cube(n)`，这个模块位于`util`文件夹中。我们希望在位于与`util`文件夹同一级别的几个模块中使用它们，这些模块分别叫做`func_import.py`和`func_from.py`。展示该项目的树状结构会产生如下内容：
- en: '[PRE73]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Before we show you the code of each module, please remember that in order to
    tell Python that it is actually a package, we need to put an `__init__.py` module
    in it.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向您展示每个模块的代码之前，请记住，为了告诉Python它实际上是一个包，我们需要在它里面放置一个`__init__.py`模块。
- en: There are two things to note about the `__init__.py` file. First, it is a fully
    fledged Python module so you can put code into it as you would with any other
    module. Second, as of Python 3.3, its presence is no longer required to make a
    folder be interpreted as a Python package.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`__init__.py`文件有两点需要注意。首先，它是一个完整的Python模块，所以你可以像其他任何模块一样在其中放置代码。其次，从Python
    3.3开始，它的存在不再是将文件夹解释为Python包所必需的。
- en: 'The code is as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE74]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Both these files, when executed, print `100` and `1000` . You can see how differently
    we then access the `square` and `cube` functions, according to how and what we
    imported in the current scope.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个文件在执行时都会打印出`100`和`1000`。你可以看到我们如何根据当前作用域中导入的方式和内容，以不同的方式访问`square`和`cube`函数。
- en: Relative imports
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相对导入
- en: 'The type of import we have seen so far is called an **absolute import** ; that
    is, it defines the whole path of either the module that we want to import or from
    which we want to import an object. There is another way of importing objects into
    Python, which is called a **relative import** . Relative imports are done by adding
    as many leading dots in front of the module as the number of folders we need to
    backtrack, to find what we are searching for. Simply put, it is something such
    as this:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的导入类型被称为**绝对导入**；也就是说，它定义了我们要导入的模块或从中导入对象的整个路径。还有一种将对象导入Python的方法，称为**相对导入**。相对导入是通过在模块前添加与我们需要回溯的文件夹数量相同数量的前导点来完成的，以找到我们正在寻找的内容。简单来说，就是如下所示：
- en: '[PRE75]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Relative imports are quite useful when restructuring projects. Not having the
    full path in the imports allows the developer to move things around without having
    to rename too many of those paths.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 相对导入在重构项目时非常有用。在导入中不使用完整路径允许开发者移动东西，而无需重命名太多这些路径。
- en: 'For a complete explanation of relative imports, refer to PEP 328: [https://peps.python.org/pep-0328/](https://peps.python.org/pep-0328/)
    .'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相对导入的完整解释，请参阅PEP 328：[https://peps.python.org/pep-0328/](https://peps.python.org/pep-0328/)。
- en: In later chapters, we will create projects using different libraries and use
    several different types of imports, including relative ones, so make sure you
    take a bit of time to read up about them in the official Python documentation.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将使用不同的库创建项目，并使用几种不同类型的导入，包括相对导入，所以请确保你花一些时间在官方Python文档中阅读它们。
- en: One final example
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的一个例子
- en: Before we finish off this chapter, let us go through one last example. We could
    write a function to generate a list of prime numbers up to a limit; we have already
    seen the code for this in *Chapter 3* , *Conditionals and Iteration* , so let
    us make it a function and, to keep it interesting, let us optimize it a bit.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，让我们再看一个最后的例子。我们可以编写一个函数来生成一个直到某个限制的素数列表；我们已经在*第三章*，*条件与迭代*中看到了这个代码，所以让我们将其变成一个函数，并且为了保持其趣味性，让我们对其进行一点优化。
- en: First of all, we do not need to divide by all the numbers from *2* to *N-1*
    to decide whether a number, *N* , is prime. We can stop at *√N* (the square root
    of *N* ). Moreover, we do not need to test the division for all the numbers from
    *2* to *√N* , as we can just use the primes in that range. We leave it up to you
    to figure out the math for why this works, if you are interested.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们不需要除以从*2*到*N-1*的所有数字来决定一个数*N*是否为素数。我们可以在*√N*（*N*的平方根）处停止。此外，我们不需要测试从*2*到*√N*的所有数字的除法，因为我们可以直接使用该范围内的素数。如果你对此感兴趣，我们可以留给你去思考为什么这会起作用。
- en: 'Let us see how the code changes:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码是如何变化的：
- en: '[PRE76]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The code is the same as that in the previous chapter. We have changed the division
    algorithm so that we only test divisibility using the previously calculated primes,
    and we stopped once the testing divisor was greater than the root of the candidate.
    We used the `primelist` result list to get the primes for the division and calculated
    the root value using a fancy formula, the integer value of the ceiling of the
    root of the candidate. While a simple `int(k ** 0.5) + 1` would have also served
    our purpose, the formula we chose is cleaner and requires a couple of imports,
    which is what we wanted to show. Check out the functions in the `math` module—they
    are very interesting!
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与上一章相同。我们改变了除法算法，以便我们只使用之前计算出的质数来测试可除性，并且一旦测试除数大于候选数的平方根，我们就停止测试。我们使用`primelist`结果列表来获取用于除法的质数，并使用一个花哨的公式计算根值，即候选数根的整数上界。虽然简单的`int(k
    ** 0.5) + 1`也能达到我们的目的，但我们选择的公式更简洁，需要几个导入，这正是我们想要展示的。看看`math`模块中的函数——它们非常有趣！
- en: Summary
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the world of functions. They are very important
    and, from now on, we will use them in virtually everything we do. We talked about
    the main reasons for using them, the most important of which are code reuse and
    implementation hiding.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了函数的世界。它们非常重要，从现在起，我们将几乎在所有事情中使用它们。我们讨论了使用函数的主要原因，其中最重要的是代码重用和实现隐藏。
- en: We saw that a function object is like a box that takes optional inputs and may
    produce outputs. We can feed input arguments to a function in many different ways,
    using positional and keyword arguments, and using variable syntax for both types.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，一个函数对象就像一个盒子，它接受可选输入并可能产生输出。我们可以以多种不同的方式向函数提供输入参数，使用位置参数和关键字参数，以及使用变量语法来处理这两种类型。
- en: You should now know how to write a function, document it, import it into your
    code, and call it.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该知道如何编写函数、记录其文档、将其导入到你的代码中，并调用它。
- en: In the next chapter, we will be picking up the pace a little bit, so we suggest
    you spend a bit of time consolidating and enriching the knowledge you have gathered
    so far by experimenting with code and reading the Python official documentation.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将稍微加快节奏，所以我们建议你花一些时间通过实验代码和阅读Python官方文档来巩固和丰富你迄今为止所积累的知识。
- en: Join our community on Discord
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_4.xhtml)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.com/invite/uaKmaz7FEC](Chapter_4.xhtml)'
- en: '![img](img/QR_Code119001106417026468.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/QR_Code119001106417026468.png)'
