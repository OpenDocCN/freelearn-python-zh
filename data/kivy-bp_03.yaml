- en: Chapter 3. Sound Recorder for Android
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。Android录音机
- en: In the previous chapter, we briefly discussed how the Kivy app, generally cross-platform,
    may have parts of code working conditionally on selected systems, enhancing user
    experience for some users and performing other platform-specific tasks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要讨论了Kivy应用程序，通常是跨平台的，其部分代码可能在选定的系统上条件性工作，从而增强某些用户的体验并执行其他特定平台的任务。
- en: At times, this is essentially free; for example, multitouch just works if Kivy
    detects support for it on a target system—you don't need to write any code to
    turn it on, but only account for the sheer possibility of several pointer events
    firing at the same time for different touches.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这几乎是免费的；例如，如果Kivy检测到目标系统支持多点触控，多点触控就会正常工作——你不需要编写任何代码来启用它，只需考虑几个指针事件同时触发以供不同触控使用的情况。
- en: Other platform-dependent tasks include code that just cannot run on other systems
    for various reasons. Remember the mouse cursor customization from the Paint app?
    That code used low-level bindings to SDL cursor routines provided by Pygame, which
    is perfectly fine as long as you have SDL and Pygame running. So, in order to
    make our app multi-platform, we took precautions to avoid entering that specific
    code path on incompatible systems; otherwise, it would have crashed our program.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 其他平台相关任务包括由于各种原因在其他系统上无法运行的代码。还记得Paint应用程序中的鼠标光标自定义吗？那段代码使用了Pygame提供的低级绑定来调用SDL光标例程，只要你有SDL和Pygame运行，这是完全正常的。因此，为了使我们的应用程序多平台，我们采取了预防措施，避免在不兼容的系统上进入特定的代码路径；否则，它会导致我们的程序崩溃。
- en: Otherwise, Kivy applications are generally portable across all supported platforms—Mac,
    Windows, Linux, iOS, Android, and Raspberry Pi—with no significant problems. Until
    they aren't; we will discuss the reason for this in a second.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，Kivy应用程序通常可以在所有支持的平台上移植——Mac、Windows、Linux、iOS、Android和Raspberry Pi——没有显著的问题。直到它们不再如此；我们将在下一节讨论这个原因。
- en: '![Sound Recorder for Android](img/B01620_03_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![Android的录音机](img/B01620_03_01.jpg)'
- en: Kivy supports a wide variety of platforms
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy支持广泛的平台
- en: 'In this chapter, we''re going to cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Achieving interoperability between Python and Java using the **Pyjnius** library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Pyjnius**库实现Python和Java之间的互操作性
- en: Testing Kivy apps on a device (or an emulator) running Android OS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行Android操作系统的设备（或模拟器）上测试Kivy应用程序
- en: Working with Android's sound API from Python, which allows you to record and
    playback audio files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Python中与Android的声音API协同工作，这允许你录制和播放音频文件
- en: Making a tiled user interface layout, similar in concept to Windows Phone
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作类似Windows Phone概念的拼图用户界面布局
- en: Using icon fonts to improve the presentation of the app with vector icons
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图标字体通过矢量图标改善应用程序的展示
- en: Writing platform-dependent code
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写平台相关代码
- en: Most of the projects in this book are inherently cross-platform, thanks to Kivy
    being extremely portable. This time, however, we're building an app that will
    be purposefully single-platform. This is certainly a severe limitation that reduces
    our potential user base; on the other hand, this gives us an opportunity to rely
    on platform-specific bindings that provide extended functionality.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大多数项目都是跨平台的，这得益于Kivy的极高可移植性。然而，这次我们将有意识地构建一个单平台的应用程序。这无疑是一个严重的限制，会减少我们的潜在用户群；另一方面，这也给了我们依赖特定平台绑定的机会，这些绑定提供了扩展功能。
- en: The need for such bindings arises from the fact that Kivy strives to be as cross-platform
    as possible and delivers a similar user experience on every system it supports.
    This is a huge feature by itself; as a plus, we have the ability to write code
    once and run everywhere with little to no tweaks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种绑定的需求源于Kivy力求尽可能实现跨平台，并在它支持的每个系统上提供类似的用户体验。这本身就是一个巨大的特性；作为加分项，我们还有能力编写一次代码，在各个地方运行，几乎不需要任何调整。
- en: The downside of being cross-platform, however, is that you can only rely on
    the core functionality supported by every system. This "lowest common denominator"
    feature set includes rendering graphics on the screen, reproducing a sound if
    there is a sound card, accepting user input, and not much else.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，跨平台的缺点是，你只能依赖每个系统支持的核心理念功能。这个“最低共同分母”功能集包括在屏幕上渲染图形、如果有声卡则播放声音、接受用户输入以及其他不多的事情。
- en: Each Kivy app, by the virtue of being written in Python, also has access to
    the vast Python standard library. It facilitates networking, supports a number
    of application protocols, and provides many general-purpose algorithms and utility
    functions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个Kivy应用程序都是用Python编写的，因此它也可以访问庞大的Python标准库。它促进了网络通信，支持多种应用程序协议，并提供了许多通用算法和实用函数。
- en: Still, the **input-output** (**IO**) capabilities of a "pure Kivy" program are
    limited to those that are present on most platforms. This amounts to a tiny fraction
    of what a common computer system, such as a smartphone or a tablet PC, can actually
    do.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，“纯Kivy”程序的**输入输出**（**IO**）能力仅限于大多数平台上存在的功能。这仅占一个普通计算机系统（如智能手机或平板电脑）实际能做的极小一部分。
- en: 'Let''s take a look at the API surface of a modern mobile device (for the sake
    of this chapter, let''s assume it''s running Android). We''ll split everything
    in two parts: things that are supported directly by Python and/or Kivy, and things
    that aren''t.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看现代移动设备的API表面（为了本章的目的，让我们假设它正在运行Android）。我们将把所有内容分成两部分：由Python和/或Kivy直接支持的内容，以及不支持的内容。
- en: 'The following are features that are directly available in Python or Kivy:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Python或Kivy中直接可用的功能：
- en: Hardware-accelerated graphics
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件加速图形
- en: Touch screen input with optional multitouch
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有可选多点触控的触摸屏输入
- en: Sound playback (at the time of writing this, the playback is supported only
    for files in persistent storage)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频播放（在撰写本文时，播放仅支持持久存储中的文件）
- en: Networking, assuming that Internet connectivity is present
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络，假设存在互联网连接
- en: 'The following are features that aren''t supported or require an external library:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是不支持或需要外部库的功能：
- en: Modem, support for voice calls, and SMS
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调制解调器，支持语音通话和短信
- en: Use of built-in cameras for filming videos and taking pictures
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置摄像头录制视频和拍照
- en: Use of a built-in microphone to record sound
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置麦克风来录制声音
- en: Cloud storage for application data, associated with a user account
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与用户账户关联的应用程序数据云存储
- en: Bluetooth and other near-field networking features
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝牙和其他近场网络功能
- en: Location services and GPS
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定位服务和GPS
- en: Fingerprinting and other biometric security
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指纹识别和其他生物识别安全
- en: Motion sensors, that is, accelerometer and gyroscope
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运动传感器，即加速度计和陀螺仪
- en: Screen brightness control
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕亮度控制
- en: Vibration and other forms of haptic feedback
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 震动和其他形式的触觉反馈
- en: Battery charge level
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电池充电水平
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For most entries in the "not supported" list, different Python libraries are
    already present to fill the gap, such as Audiostream for a low-level sound recording
    and Plyer that handles many platform-specific tasks.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“不支持”列表中的大多数条目，已经存在不同的Python库来填补空白，例如用于低级声音记录的Audiostream和用于处理许多平台特定任务的Plyer。
- en: So, it's not like these features are completely unavailable to your application;
    realistically, the challenge is that these bits of functionality are insanely
    fragmented across different platforms (or even consecutive versions of the same
    platform, for example, Android); thus, you end up writing platform-specific, not
    portable code anyway.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这些功能并不是完全不可用给你的应用程序；实际上，挑战在于这些功能片段在不同平台（或者甚至是同一平台的连续版本，例如Android）上极其碎片化；因此，你最终不得不编写特定平台的、不可移植的代码。
- en: As you can see from the preceding comparison, a lot of functionality is available
    on Android, only partially covered by an existing Python or Kivy API. This leaves
    a huge amount of untamed potential for using platform-specific features in your
    applications. This is not a limitation, but an opportunity. Shortly, you will
    learn how to utilize any Android API from Python code, allowing your Kivy application
    to do practically anything.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的比较中可以看到，Android上提供了许多功能，但只有部分由现有的Python或Kivy API覆盖。这为在您的应用程序中使用平台特定功能留下了巨大的未开发潜力。这不仅仅是一个限制，而是一个机会。简而言之，您将很快学会如何从Python代码中利用任何Android
    API，使您的Kivy应用程序几乎可以做任何事情。
- en: Another advantage of narrowing the scope of your app to only a small selection
    of systems is that there are whole new classes of programs that can function (or
    even make sense) only on a mobile device with fitting hardware specifications.
    These include augmented reality apps, gyroscope-controlled games, panoramic cameras,
    and so on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的应用程序的范围缩小到只有一小部分系统的一个优势是，有一些全新的程序类只能在具有合适硬件规格的移动设备上运行（或甚至有意义）。这些包括增强现实应用程序、陀螺仪控制的游戏、全景相机等等。
- en: Introducing Pyjnius
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Pyjnius
- en: To harness the full power of our chosen platform, we're going to use a platform-specific
    API, which happens to be in Java and thus primarily Java-oriented. We are going
    to build a sound recorder app, similar to the apps commonly found in Android and
    iOS, albeit more simplistic. Unlike pure Kivy, the underlying Android API certainly
    provides us with ways of recording sound programmatically.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用我们选择的平台，我们将使用特定于平台的API，碰巧这个API是Java，因此主要是面向Java的。我们将构建一个录音应用程序，类似于在Android和iOS中常见的应用程序，尽管更简单。与纯Kivy不同，底层的Android
    API确实为我们提供了编程记录声音的方法。
- en: The rest of the chapter will cover this little recorder program throughout its
    development to illustrate the Python-Java interoperability using the excellent
    Pyjnius library, another great project made by Kivy developers. The concept we
    chose—sound recording and playback—is deliberately simple so as to outline the
    features of such interoperation without too much distraction caused by the sheer
    complexity of a subject and abundant implementation details.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将贯穿这个小录音程序的开发过程，使用优秀的Pyjnius库来展示Python-Java的互操作性，这是Kivy开发者制作的另一个伟大项目。我们选择的概念——录音和播放——故意很简单，以便在不引起主题的纯粹复杂性和大量实现细节的过多干扰的情况下，概述这种互操作性的功能。
- en: The most interesting property of Pyjnius is that it doesn't provide its own
    "overlay" API over Android's, but instead allows you to use Java classes directly
    from Python. It means that you have full access to the native Android API and
    the official Android documentation, which is obviously more suited for Java development,
    not Python. However, this is still better than having no API reference at all.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Pyjnius最有趣的特性是它不提供自己的“覆盖”API来覆盖Android的API，而是允许你直接从Python中使用Java类。这意味着你可以完全访问本地的Android
    API和官方的Android文档，这对于Java开发来说显然更合适，而不是Python。然而，这仍然比完全没有API参考要好。
- en: Note that you don't have to install Pyjnius locally to complete the tutorial,
    since we obviously aren't going to run the code that taps into Android Java classes
    on the machine used for development.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不需要在本地安装Pyjnius来完成教程，因为我们显然不会在用于开发的机器上运行调用Android Java类的代码。
- en: The source code of Pyjnius, together with the reference manual and some examples,
    can be found in the official repository at [https://github.com/kivy/pyjnius](https://github.com/kivy/pyjnius).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Pyjnius的源代码、参考手册和一些示例可以在官方仓库[https://github.com/kivy/pyjnius](https://github.com/kivy/pyjnius)找到。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We will talk about Pyjnius only in the context of Android development and interoperation,
    but keep in mind that you can do the same kind of integration with desktop Java.
    This is an interesting property because another option of scripting a Java API
    from Python is Jython, which is rather slow and incomplete. Pyjnius, on the other
    hand, allows you to use the official Python interpreter (CPython), together with
    a multitude of libraries such as NumPy, which facilitates very fast computation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将仅在Android开发和互操作性的背景下讨论Pyjnius，但请记住，你也可以用桌面Java进行同样的集成。这是一个有趣的特性，因为从Python脚本Java
    API的另一个选项是Jython，它相当慢且不完整。另一方面，Pyjnius允许你使用官方的Python解释器（CPython），以及像NumPy这样的众多库，这有助于非常快速的计算。
- en: So, if you absolutely have to call a Java library from Python, by all means
    consider Pyjnius as a good interop variant.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你绝对必须从Python调用Java库，那么请务必考虑Pyjnius作为一个好的互操作变体。
- en: Emulating Android
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟Android
- en: As mentioned earlier, this chapter's project targets Android exclusively, thus
    it will not work on your computer. Don't worry if you haven't got a spare Android
    gadget, or if you don't feel comfortable toying with the real, physical device
    for the purpose of this tutorial. There are good-quality Android emulators available
    to help you overcome this minor obstacle and toy with the Android OS from the
    comfort of your desktop.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，本章的项目仅针对Android，因此它不会在你的电脑上工作。如果你没有备用Android设备，或者如果你不觉得在教程的目的上玩真实的物理设备很舒服，请不要担心。有高质量的Android模拟器可以帮助你克服这个小小的障碍，并在你的桌面上玩Android操作系统。
- en: One of the best emulators out there is Genymotion (previously AndroVM), built
    on top of Oracle's VirtualBox virtual machine. You can grab a free copy from the
    official website, [http://www.genymotion.com/](http://www.genymotion.com/); at
    the time of writing this, their licensing is very liberal, allowing for practically
    unrestricted free personal use.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 目前市面上最好的模拟器之一是 Genymotion（之前称为 AndroVM），它建立在 Oracle 的 VirtualBox 虚拟机之上。你可以从官方网站
    [http://www.genymotion.com/](http://www.genymotion.com/) 获取免费副本；在撰写本文时，他们的许可非常宽松，允许几乎无限制的免费个人使用。
- en: The installation of the VM package is wildly different for every emulator and
    host OS combination, so we won't provide overly detailed instructions at this
    point. After all, these things are supposed to be user friendly nowadays, complete
    with instruction manuals and graphical user interfaces. Truly, we have reached
    the golden age of technology.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: VM 软件的安装对于每个模拟器和主机操作系统组合都大不相同，所以我们现在不会提供过于详细的说明。毕竟，这些事情现在应该是用户友好的，包括说明书和图形用户界面。确实，我们已经进入了技术的黄金时代。
- en: 'Even if the last sentence wasn''t entirely sarcastic, there would''ve been
    some things to consider when setting up and using a virtual machine for Android
    emulation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 即使最后一句话并不完全是讽刺的，但在设置和使用 Android 模拟的虚拟机时，也有一些事情需要考虑：
- en: Always use the latest version of Android. Backward compatibility or lack thereof
    can be pretty bad; debugging OS-level glitches isn't entertaining at all.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是使用最新的 Android 版本。向后兼容性或缺乏兼容性可能相当糟糕；调试操作系统级别的错误一点也不有趣。
- en: Don't hesitate to search the Internet for solutions. The Android community is
    huge, and if you have a problem, it means that you're most probably not alone.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要犹豫，在网上搜索解决方案。Android 社区非常庞大，如果你有问题，这意味着你很可能并不孤单。
- en: The Kivy Launcher app, which you may find very useful to test your own programs,
    is available in the form of an `.apk` file from the official Kivy website, [http://kivy.org/](http://kivy.org/);
    this will be useful for emulated Android devices that don't have access to Google
    Play.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kivy Launcher 应用程序，你可能觉得它非常有用，可以用来测试你自己的程序，可以从官方 Kivy 网站以 `.apk` 文件的形式获取，[http://kivy.org/](http://kivy.org/)；这对于没有访问
    Google Play 的模拟 Android 设备来说将非常有用。
- en: Lastly, there are many different emulators out there of varying quality and
    compatibility. If things just seem to blow up and cease working at random, maybe
    you should try another VM or Android distribution. Fiddling with the virtual machine's
    configuration may also help.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，市面上有许多不同质量、兼容性各异的模拟器。如果事情似乎随机崩溃并停止工作，也许你应该尝试另一个虚拟机或 Android 发行版。调整虚拟机的配置也可能有所帮助。
- en: 'The next screenshot depicts a Genymotion virtual machine running a recent version
    of Android, complete with usable Kivy Launcher:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图展示了运行最新版本 Android 的 Genymotion 虚拟机，并安装了可用的 Kivy Launcher：
- en: '![Emulating Android](img/B01620_03_02.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![模拟 Android](img/B01620_03_02.jpg)'
- en: Genymotion VM running Android 4.4.2 with Kivy Launcher installed
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Android 4.4.2 并安装了 Kivy Launcher 的 Genymotion 虚拟机
- en: Metro UI
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Metro UI
- en: 'While we''re at it, let''s build a user interface that resembles the Windows
    Phone home screen. This concept, basically a grid of colored rectangles (tiles)
    of various sizes, was known as **Metro UI** at some point in time, but was later
    renamed to **Modern UI** due to trademark issues. No matter the name, this is
    how it looks. This will give you a vague idea of what we''ll be aiming at during
    the course of this app''s development:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论这个话题时，让我们构建一个类似于 Windows Phone 主屏幕的用户界面。这个概念，基本上是一个各种尺寸的彩色矩形（瓷砖）的网格，在某个时候被称为
    **Metro UI**，但由于商标问题后来更名为 **Modern UI**。不管叫什么名字，这就是它的样子。这将给你一个大致的想法，了解在应用程序开发过程中我们将要达到的目标：
- en: '![Metro UI](img/B01620_03_03.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Metro UI](img/B01620_03_03.jpg)'
- en: Design inspiration – Windows Phone home screen with tiles
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 设计灵感 - 带有瓷砖的 Windows Phone 主屏幕
- en: 'Obviously, we aren''t going to replicate it as is, but rather make something
    that resembles the depicted user interface. The following list pretty much summarizes
    the distinctive features we''re after:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不会完全复制它，而是制作一个类似于所描述的用户界面。以下列表基本上总结了我们要追求的独特特性：
- en: Everything is aligned to a rectangular grid
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的元素都对齐到矩形网格
- en: UI elements feature the same flat look discussed in [Chapter 1](ch01.html "Chapter 1. Building
    a Clock App"), *Building a Clock App* (tiles use bright, solid colors, and there
    are no shadows or rounded corners)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI 元素具有与 [第 1 章](ch01.html "第 1 章。构建时钟应用程序") 中讨论的相同扁平外观，*构建时钟应用程序*（瓷砖使用明亮的纯色，没有阴影或圆角）
- en: Tiles that are considered more useful (for an arbitrary definition of "useful")
    are larger and thus easier to hit
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被认为更有用的（对于“有用”的任意定义）瓷砖更大，因此更容易点击
- en: If this sounds easy to you, then you're absolutely right. As you will see shortly,
    the Kivy implementation of such a UI is rather straightforward.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来对你来说很简单，那么你绝对是对的。正如你很快就会看到的，Kivy 实现这样的 UI 非常直接。
- en: The buttons
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按钮们
- en: 'To start off, we are going to tweak a `Button` class, just like we did in our
    previous applications. It resembles `ColorButton` from the Paint app ([Chapter
    2](ch02.html "Chapter 2. Building a Paint App"), *Building a Paint App*):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将调整一个 `Button` 类，就像我们在之前的程序中做的那样。它类似于 Paint 应用程序中的 `ColorButton` ([第 2
    章](ch02.html "第 2 章。构建 Paint 应用程序"), *构建 Paint 应用程序*)：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The texture we set as the background is solid white, exploiting the same trick
    that was used while creating the color palette. The `background_color` property
    acts as tint color, and assigning a plain white texture equals to painting the
    button in `background_color`. We don't want borders this time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置的背景纹理是纯白色，利用了在创建调色板时使用的相同技巧。`background_color` 属性充当着色色，将一个纯白色纹理分配给它相当于在
    `background_color` 中绘制按钮。这次我们不想有边框。
- en: 'The second (pressed `background_down`) texture is 25 percent transparent white.
    Combined with the pitch-black background color of the app, we''re getting a slightly
    darker shade of the same background color the button was assigned:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个（按下 `background_down`）纹理是 25% 透明的白色。与应用程序的纯黑色背景颜色结合，我们得到了按钮分配的相同背景颜色的稍微深一点的色调：
- en: '![The buttons](img/B01620_03_04.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![按钮](img/B01620_03_04.jpg)'
- en: 'Normal (left) and pressed (right) states of a button – the background color
    is set to #0080FF'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '按钮的正常（左）和按下（右）状态——背景颜色设置为 #0080FF'
- en: The grid structure
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格结构
- en: 'The layout is a bit more complex to build. In the absence of readily available
    Modern UI-like tiled layout, we are going to emulate it with the built-in `GridLayout`
    widget. It behaves just like the `BoxLayout` widget we used earlier, only in two
    dimensions instead of one, so there is no `orientation: ''horizontal''` or `''vertical''`
    property—the `GridLayout` widget is both at the same time.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '布局构建起来稍微复杂一些。在没有现成的类似现代 UI 的瓷砖布局可用的情况下，我们将使用内置的 `GridLayout` 小部件来模拟它。它表现得就像我们之前使用的
    `BoxLayout` 小部件一样，只是在两个维度上而不是一个维度上，因此没有 `orientation: ''horizontal''` 或 `''vertical''`
    属性——`GridLayout` 小部件同时具备这两个属性。'
- en: 'One such layout could have fulfilled all our needs, if not for the last requirement:
    we want to have bigger and smaller buttons. Presently, `GridLayout` doesn''t allow
    the merging of cells to create bigger ones (a functionality similar to the `rowspan`
    and `colspan` attributes in HTML would be nice to have). So, we will go in the
    opposite direction: start with the root `GridLayout` with big cells and add another
    `GridLayout` inside a cell to subdivide it.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是最后一个要求，这样一个布局就能满足我们的所有需求：我们想要有大小不同的按钮。目前，`GridLayout` 不允许合并单元格来创建更大的按钮（如果能有一个类似于
    HTML 中的 `rowspan` 和 `colspan` 属性的功能那就太好了）。因此，我们将采取相反的方向：从根 `GridLayout` 开始，使用大单元格，并在一个单元格内添加另一个
    `GridLayout` 来细分它。
- en: 'Thanks to nested layouts working great in Kivy, we arrive at the following
    Kivy language structure (let''s name the file `recorder.kv`):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于嵌套布局在 Kivy 中表现良好，我们得到了以下 Kivy 语言结构（让我们将文件命名为 `recorder.kv`）：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In order to run this code, you'll need the usual `main.py` boilerplate to serve
    as an application's entry point. Try writing this code yourself as an exercise.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行此代码，你需要一个标准的 `main.py` 模板作为应用程序的入口点。尝试自己编写这段代码作为练习。
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Refer to the beginning of the first chapter. The application class name will
    be different because it should reflect the name of the Kivy language file presented
    earlier.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考第一章的开头。应用程序的类名将不同，因为它应该反映之前展示的 Kivy 语言文件的名称。
- en: 'Note how the nested `GridLayout` widget sits on the same level as that of outer,
    large buttons. This should make perfect sense if you look at the previous screenshot
    of the WinPhone home screen: a pack of four smaller buttons takes up the same
    space (one outer grid cell) as a large button. The nested `GridLayout` is a container
    for those smaller buttons.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意嵌套的 `GridLayout` 小部件与外部的、较大的按钮处于同一级别。如果你查看之前的 WinPhone 主屏幕截图，这应该会很有意义：一组四个较小的按钮占据与一个较大的按钮相同的空间（一个外部网格单元格）。嵌套的
    `GridLayout` 是这些较小按钮的容器。
- en: Visual attributes
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视觉属性
- en: 'On the outer grid, `padding` is provided to create some distance from the edges
    of the screen. Other visual attributes are shared between `GridLayout` instances
    and moved to a class, resulting in the following code inside `recorder.kv`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部网格上，`padding` 提供了一些距离屏幕边缘的空间。其他视觉属性在 `GridLayout` 实例之间共享，并移动到一个类中，结果在 `recorder.kv`
    内部的代码如下：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's worth mentioning that both `padding` and `spacing` are effectively lists,
    not scalars. The `spacing[0]` property refers to a horizontal spacing, followed
    by a vertical one. However, we can initialize `spacing` with a single value, as
    shown in the preceding code; this value will then be used for everything.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`padding` 和 `spacing` 都实际上是列表，而不是标量。`spacing[0]` 属性指的是水平间距，然后是垂直间距。然而，我们可以使用前面代码中显示的单个值来初始化
    `spacing`；然后这个值将被用于所有内容。
- en: 'Each grid consists of two columns with some spacing in between. The `row_default_height`
    property is trickier: we can''t just say, "Let the row height be equal to the
    cell width." Instead, we compute the desired height manually, where 0.5 is because
    we have two columns:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网格由两列和一些间距组成。`row_default_height` 属性更复杂：我们不能只是说，“让行高等于单元格宽度。”相反，我们手动计算所需的高度，其中
    0.5 是因为我们有两个列：
- en: '![Visual attributes](img/7849OS_03_06.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![视觉属性](img/7849OS_03_06.jpg)'
- en: If we don't apply this tweak, the buttons inside the grid will fill all the
    available vertical space, which is undesirable, especially when there aren't that
    many buttons (every one of them ends up being too large). Instead, we want all
    the buttons nice and square, with empty space at the bottom left, well, empty.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不应用这个调整，网格内的按钮将填充所有可用的垂直空间，这是不希望的，尤其是在按钮不多的情况下（每个按钮最终都会变得太大）。相反，我们希望所有按钮都整齐划一，底部左侧留有空白，嗯，就是空白。
- en: 'The following is the screenshot of our app''s "Modern UI" tiles, resulting
    from the preceding code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们应用 "现代 UI" 磁贴的截图，这是前面代码的结果：
- en: '![Visual attributes](img/B01620_03_07.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![视觉属性](img/B01620_03_07.jpg)'
- en: The UI so far – clickable tiles of variable size not too dissimilar from our
    design inspiration
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的 UI – 可点击的、大小可变的磁贴，与我们设计灵感不太相似
- en: Scalable vector icons
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可缩放矢量图标
- en: One of the nice finishing touches we can apply to the application UI is the
    use of icons, and not just text, on buttons. We could, of course, just throw in
    a bunch of images, but let's borrow another useful technique from modern web development
    and use an icon font instead—as you will see shortly, these provide great flexibility
    at no cost.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以应用到应用程序 UI 中的一个很好的收尾细节是使用图标，而不仅仅是文本，在按钮上。当然，我们可以简单地加入一堆图片，但让我们借鉴现代网络开发中的一个有用技术，使用图标字体——正如你很快就会看到的，这些提供了极大的灵活性，而且不花任何成本。
- en: Icon fonts
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图标字体
- en: Icon fonts are essentially just like regular ones, except their glyphs are unrelated
    to the letters of a language. For example, you type "P" and the Python logo is
    rendered instead of the letter; every font invents its own mnemonic on how to
    assign letters to icons.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图标字体本质上与常规字体类似，只是它们的符号与语言的字母无关。例如，你输入 "P" 时，会渲染出 Python 的标志而不是字母；每个字体都会发明自己的记忆法来分配字母到图标。
- en: This is about the only downside to using an icon font—the code that uses such
    font heavily isn't very readable because character–icon mapping is hardly obvious.
    This can be mitigated by using constants instead of entering symbols directly.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是使用图标字体唯一的缺点——使用这种字体大量代码的可读性并不好，因为字符-图标映射几乎不明显。这可以通过使用常量而不是直接输入符号来缓解。
- en: There are also fonts that don't use English letters, instead they map icons
    to Unicode's "private use area" character codes. This is a technically correct
    way to build such a font, but application support for this Unicode feature varies—not
    every platform behaves the same in this regard, especially when it comes to mobile
    platforms. The font that we will use for our app does not assign private use characters
    and uses ASCII (plain English letters) instead.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 还有不使用英语字母的字体，它们将图标映射到 Unicode 的 "私有用途区域" 字符代码。这是一种技术上正确构建此类字体的方法，但应用程序对这种 Unicode
    功能的支持各不相同——不是每个平台在这方面表现都相同，尤其是在移动平台上。我们将为我们的应用使用的字体不分配私有用途字符，而是使用 ASCII（普通英语字母）。
- en: Rationale for using icon fonts
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用图标字体的理由
- en: 'On the Web, icon fonts solve a number of problems that are commonly associated
    with (raster) images:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上，图标字体解决了与（光栅）图像常见的一些问题：
- en: First and foremost, raster images don't scale well and may become blurry when
    resized—there are certain algorithms that produce better results than others,
    but as of today, the "state of the art" is still not perfect. In contrast, a vector
    picture is infinitely scalable, by definition.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先要考虑的是，位图图像不易缩放，在调整大小时可能会变得模糊——某些算法比其他算法产生更好的结果，但截至目前，“最佳实践”仍然不完美。相比之下，矢量图像按定义是无限可缩放的。
- en: Raster image files containing schematic graphics (such as icons and UI elements)
    tend to be larger than vector formats. This does not apply to photos encoded as
    JPEG, obviously.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含矢量图形（如图标和UI元素）的位图图像文件通常比矢量格式大。这显然不适用于编码为JPEG的照片。
- en: In addition, an icon font is typically just one file for any number of icons,
    which means one HTTP round trip. Regular icons (images) routinely end up in separate
    files, leading to significant HTTP overhead; there are ways to mitigate this,
    such as CSS sprites, but they are not universally used and have their own problems.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，图标字体通常只是一个文件，包含任意数量的图标，这意味着只需要一次HTTP往返。常规图标（图像）通常在单独的文件中，导致显著的HTTP开销；有减轻这种影响的方法，例如CSS精灵，但它们并不被普遍使用，并且也有它们自己的问题。
- en: 'In the case of icon fonts, a color change literally takes about a second—you
    can do just that by adding `color: red` (for example) to your CSS file. The same
    is true for size, rotation, and other properties that don''t involve changing
    the geometry of an image. Effectively, this means that making trivial adjustments
    to an icon does not require an image editor, like it normally would when dealing
    with bitmaps.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在图标字体的情况下，颜色更改实际上只需一秒钟——你只需在CSS文件中添加`color: red`（例如）即可做到这一点。同样，大小、旋转和其他不涉及改变图像几何形状的属性也是如此。实际上，这意味着对图标进行微调不需要图像编辑器，这在处理位图时通常是必需的。'
- en: Some of these points do not apply to Kivy apps that much, but overall, the use
    of icon fonts is considered a good practice in contemporary web development, especially
    since there are many free high-quality fonts to choose from—that's hundreds of
    icons readily available for inclusion in your project.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些观点对Kivy应用程序来说并不适用，但总的来说，在当代网络开发中使用图标字体被认为是一种良好的实践，特别是由于有许多免费的高质量字体可供选择——这意味着有成百上千的图标可以包含在你的项目中。
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Two great sources of free fonts (including those that are free for commercial
    usage) are **Font Squirrel** ([http://www.fontsquirrel.com](http://www.fontsquirrel.com))
    and **Google Fonts** ([https://www.google.com/fonts](https://www.google.com/fonts)).
    Never mind the general web development orientation of these sites, most fonts
    are just as usable in your offline programs as they are on the Web. If not more
    so, because browser support still isn't ideal.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 两个免费字体（包括那些可以免费用于商业用途的字体）的绝佳来源是**Font Squirrel**（[http://www.fontsquirrel.com](http://www.fontsquirrel.com)）和**Google
    Fonts**（[https://www.google.com/fonts](https://www.google.com/fonts)）。不要在意这些网站的一般网络开发方向，大多数字体在离线程序中的可用性与在网络上一样，甚至更好。因为浏览器的支持仍然不是理想的。
- en: 'The only thing that really matters is the file format: Kivy only supports True
    Type (`.ttf`) at the moment. Thankfully, this is the most popular font format
    out there anyway. Besides, it''s possible to convert a font from practically any
    other format to `.ttf`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 真正重要的是文件格式：目前Kivy只支持True Type（`.ttf`）格式。幸运的是，这已经是目前最流行的字体格式。此外，将任何其他格式的字体转换为`.ttf`格式也是可能的。
- en: Using the icon font in Kivy
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Kivy中使用图标字体
- en: 'In our application, we are going to use the Modern Pictograms (version 1) free
    font, designed by John Caserta. The following is a glimpse of how it looks:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将使用由John Caserta设计的Modern Pictograms（版本1）免费字体。以下是其外观的一瞥：
- en: '![Using the icon font in Kivy](img/B01620_03_08.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![在Kivy中使用图标字体](img/B01620_03_08.jpg)'
- en: A small sample of icons from the Modern Pictograms icon font
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Modern Pictograms图标字体的一小部分图标样本
- en: To load the font into our Kivy program, we'll use the same process outlined
    in [Chapter 1](ch01.html "Chapter 1. Building a Clock App"), *Building a Clock
    App*. In this specific case, it isn't strictly necessary, as icon fonts rarely
    have different font weights and styles. Still, accessing the font by display name
    (Modern Pictograms) rather than the filename (`modernpics.ttf`) is a better way.
    You can later rename or move the font file by updating just one occurrence of
    its path, and not every place where the font was used.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字体加载到我们的Kivy程序中，我们将使用在 [第1章](ch01.html "第1章。构建时钟应用程序") 中概述的相同过程，*构建时钟应用程序*。在这种情况下，这并不是严格必要的，因为图标字体很少有不同的字体粗细和样式。然而，通过显示名称（Modern
    Pictograms）而不是文件名（`modernpics.ttf`）来访问字体是一个更好的方法。你可以稍后通过只更新路径的一次出现来重命名或移动字体文件，而不必在每个使用字体的地方更新。
- en: 'The code so far (in `main.py`) looks like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的代码（在 `main.py` 中）看起来像这样：
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The actual use of the font happens inside `recorder.kv`. First, we want to
    update the `Button` class once again to allow us to change the font in the middle
    of a text using markup tags. This is shown in the following code snippet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 字体的实际使用发生在 `recorder.kv` 内。首先，我们希望再次更新 `Button` 类，以便我们可以在文本中使用标记标签来更改字体。这在上面的代码片段中显示：
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `halign: ''center''` attribute means that we want every line of text centered
    inside the button. The `markup: True` attribute is self-evident and required because
    the next step in customization of buttons will rely heavily on markup.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`halign: ''center''` 属性意味着我们希望按钮内的每一行文本都居中。`markup: True` 属性是显而易见的，并且是必需的，因为按钮定制的下一步将严重依赖于标记。'
- en: 'Now we can update button definitions. Here''s an example of this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更新按钮定义。以下是一个例子：
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Normally, you don't need parentheses around strings in Kivy language files;
    this syntax is useful only when the declaration is multiline. This notation is
    effectively the same as writing a long string on the same line.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在Kivy语言文件中不需要在字符串周围使用括号；这种语法仅在声明多行时有用。这种表示法实际上等同于在同一行上写一个长字符串。
- en: Notice the character `'e'` inside the `[font][size]` tags. That's the icon code.
    Every button in our app will use a different icon, and changing an icon amounts
    to replacing a single letter in the `recorder.kv` file. Complete mapping of the
    code for the Modern Pictograms font can be found on its official website at [http://modernpictograms.com/](http://modernpictograms.com/).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `[font][size]` 标签内的字符 `'e'`。这是图标代码。我们应用程序中的每个按钮都将使用不同的图标，更改图标相当于在 `recorder.kv`
    文件中替换一个字母。Modern Pictograms字体的代码完整映射可以在其官方网站 [http://modernpictograms.com/](http://modernpictograms.com/)
    上找到。
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In order to explore an icon font by hand, you'll need to use a font viewer.
    Typically, there is one readily available on your machine, regardless of an operating
    system.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了手动探索图标字体，你需要使用字体查看器。通常，无论操作系统如何，你的机器上都会有一个现成的查看器。
- en: The **Character Map** program is bundled with Windows
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符映射** 程序是Windows的一部分'
- en: On a Mac, there is a built-in application called **Font Book**
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Mac上，有一个内置的应用程序叫做 **Font Book**
- en: Linux has several viewers depending on the desktop environment of your choice,
    for example, **gnome-font-viewer** in GNOME
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux有多个查看器，取决于你选择的桌面环境，例如，GNOME中的 **gnome-font-viewer**
- en: Alternatively, just search the Web. Popular fonts usually have some sort of
    user manual online that explains character mapping.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，只需在网上搜索。流行的字体通常有一些在线的用户手册，解释字符映射。
- en: 'Long story short, this is how the UI of our application looks after the addition
    of icons to buttons:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这就是我们在按钮上添加图标后应用程序的UI看起来是什么样子：
- en: '![Using the icon font in Kivy](img/B01620_03_09.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![在Kivy中使用图标字体](img/B01620_03_09.jpg)'
- en: The sound recorder app interface – a modern UI with vector icons from the Modern
    Pictograms font
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 声音录制器应用程序界面 - 一个具有来自Modern Pictograms字体的矢量图标的现代UI
- en: This is already pretty close to the original Modern UI look.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经非常接近原始的Modern UI外观了。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might wonder what is the purpose of smaller green buttons at the top-right
    corner. The answer is that currently they're there for quantity alone. Three buttons
    that we actually need to implement a sound recorder—record, play, delete—just
    aren't enough to illustrate the Modern UI concept, as it needs more diversity
    to look even remotely interesting.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道顶部右角的小绿色按钮的用途是什么。答案是，目前它们仅仅是为了数量。实际上我们需要实现的三个按钮——录音、播放、删除——不足以说明Modern
    UI的概念，因为它需要更多的多样性才能看起来稍微有趣一些。
- en: Testing on Android
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android上进行测试
- en: Right now, our app still doesn't contain any non-portable code, but let's gradually
    move towards our platform of choice nevertheless and begin testing it on Android.
    The only prerequisite for this operation is an Android device, physical or virtualized,
    with the **Kivy Launcher** application installed and working.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序还不包含任何不可移植的代码，但让我们逐步转向我们选择的平台，并在Android上进行测试。进行此操作的唯一先决条件是安装并运行**Kivy
    Launcher**应用程序的Android设备，无论是物理的还是虚拟的。
- en: 'Packaging an app for Kivy Launcher is borderline trivial. We''re going to add
    two files, `android.txt` and `icon.png`, to the same folder where other sources
    (in this case, `main.py` and `recorder.kv`) reside and then copy the folder to
    an SD card of the Android device under `/Kivy`. The directory structure should
    look something like the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为Kivy Launcher打包应用程序几乎微不足道。我们将添加两个文件，`android.txt`和`icon.png`，到其他源（在这种情况下，`main.py`和`recorder.kv`）所在的同一文件夹，然后将文件夹复制到Android设备的SD卡上的`/Kivy`目录下。目录结构应类似于以下内容：
- en: '![Testing on Android](img/B01620_03_10.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![在Android上进行测试](img/B01620_03_10.jpg)'
- en: SD card directory structure for Kivy Launcher
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy Launcher的SD卡目录结构
- en: When you start Kivy Launcher, it will spell out the full path that it searches
    for projects. This may be useful, for example, when you have no SD card.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当您启动Kivy Launcher时，它将显示它搜索项目的完整路径。这可能很有用，例如，当您没有SD卡时。
- en: 'The format of the `android.txt` file is pretty self-evident:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`android.txt`文件的格式相当明显：'
- en: '[PRE6]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Title and author fields are just strings displayed in the list of apps. Orientation
    can be either portrait (vertical, *height > width*) or landscape (horizontal,
    *width > height*), depending on the application's preferred aspect ratio.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 标题和作者字段只是显示在应用程序列表中的字符串。方向可以是纵向（垂直，*高度 > 宽度*）或横向（水平，*宽度 > 高度*），具体取决于应用程序首选的宽高比。
- en: The icon `icon.png` is optional and will be blank if omitted. It is advisable
    to add it because it's much easier to look up applications based on their icons,
    and if you're planning to release the resulting app to the Google Play store,
    you'll need an icon anyway.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图标`icon.png`是可选的，如果省略，则将保持空白。建议添加它，因为根据图标查找应用程序要容易得多，而且如果您计划将生成的应用程序发布到Google
    Play商店，您无论如何都需要一个图标。
- en: Note that the icon's filename isn't customizable, and neither is the `main.py`
    filename, which must designate the application's entry point; otherwise, Kivy
    Launcher won't start the app.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，图标的文件名不可自定义，`main.py`的文件名也不可自定义，它必须指定应用程序的入口点；否则，Kivy Launcher不会启动应用程序。
- en: 'With all the files in place, you should see your Sound recorder program in
    the list when you start Kivy Launcher:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有文件就绪后，您在启动Kivy Launcher时应该能在列表中看到您的录音程序：
- en: '![Testing on Android](img/B01620_03_11.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![在Android上进行测试](img/B01620_03_11.jpg)'
- en: The Kivy Launcher applications list, containing every app we've written during
    the course of this book
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy Launcher应用程序列表，包含我们在本书的整个过程中编写的每个应用程序
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If instead you see a message containing instructions where to put files, please
    recheck your paths—unfortunately, the directory that Kivy Launcher searches for
    projects is not easily configurable at the time of writing this. This may improve
    in future versions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到一条包含放置文件指示的消息，请重新检查您的路径——遗憾的是，在撰写本文时，Kivy Launcher搜索项目所在的目录不容易配置。这可能在未来的版本中得到改善。
- en: Now you can start your app by tapping the corresponding entry in the list. This
    is the easiest way to test a Kivy program on Android—just copy files and you're
    all set (as opposed to packaging an `.apk` file, which is also relatively straightforward
    but considerably more involved).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以通过点击列表中的相应条目来启动您的应用程序。这是在Android上测试Kivy程序的最简单方法——只需复制文件，您就设置好了（与打包`.apk`文件相比，后者相对简单，但涉及更多步骤）。
- en: Using the native API
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原生API
- en: Having done the user interface part of the app, we will now turn to a native
    API and implement the sound recording and playback logic using the suitable Android
    Java classes, `MediaRecorder` and `MediaPlayer`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了应用的用户界面部分后，我们现在将转向原生API，并使用合适的Android Java类`MediaRecorder`和`MediaPlayer`来实现声音录制和播放逻辑。
- en: Technically, both Python and Java are object-oriented, and it may even appear
    at first glance that these languages are rather similar. The utilization of OOP
    principles, however, differs radically. In comparison to Python, many Java APIs
    suffer from (or enjoy immensely, depending on who you ask) over-architecting and
    general overuse of the object-oriented paradigm. So don't be surprised that otherwise
    very simple tasks may require you to import and instantiate quite a lot of classes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，Python和Java都是面向对象的，乍一看，这些语言可能看起来相当相似。然而，面向对象原则的应用却有着根本的不同。与Python相比，许多Java
    API都存在（或者根据您询问的人不同，可能会非常享受）过度架构和过度使用面向对象范式的问题。所以，不要对其他非常简单的任务可能需要您导入和实例化很多类而感到惊讶。
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In 1913, Vladimir Lenin wrote regarding the Java architecture:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 1913年，弗拉基米尔·列宁就Java架构写道：
- en: '*And there is only one way of smashing the resistance of those classes, and
    that is to find, in the very society which surrounds us, the forces which can
    constitute the power capable of sweeping away the old and creating the new.*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*要打破这些类的阻力，只有一个方法，那就是在我们周围的社会中找到能够构成扫除旧事物、创造新事物的力量的力量。*'
- en: The essay didn't mention Python or Pyjnius back then, but the message is clear—even
    a century ago, going overboard with classes wasn't very much welcome in the contemporary
    society.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 那篇论文当时没有提到Python或Pyjnius，但信息很明确——即使在一百年前，在当代社会中过度使用类也不是很受欢迎。
- en: 'Thankfully, the task at hand is relatively simple. To record a sound using
    the Android API, we only need the following five Java classes:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，手头的任务相对简单。要使用Android API录制声音，我们只需要以下五个Java类：
- en: '`android.os.Environment`: This class provides access to many useful environment
    variables. We are going to use it to determine the path where SD card is mounted
    so we can save the recorded audio file. It''s tempting to just hardcode `''/sdcard/''`
    or a similar constant, but in practice, every other Android device has a different
    filesystem layout. So let''s not do this even for the purposes of the tutorial.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.os.Environment`：此类提供了访问许多有用环境变量的权限。我们将使用它来确定SD卡挂载的路径，以便我们可以保存录制的音频文件。直接硬编码`''/sdcard/''`或类似的常量很有诱惑力，但在实践中，每个其他Android设备的文件系统布局都不同。所以，即使是为了教程的目的，我们也不应该这样做。'
- en: '`android.media.MediaRecorder`: This class is our main workhorse. It facilitates
    capturing audio and video and saving it to the filesystem.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.media.MediaRecorder`：此类是我们的主要工作马。它便于捕捉音频和视频并将其保存到文件系统中。'
- en: '`android.media.MediaRecorder$AudioSource`, `android.media.MediaRecorder$AudioEncoder`,
    and `android.media.MediaRecorder$OutputFormat`: These are enumerations that hold
    values we need to pass as arguments to the various methods of `MediaRecorder`.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.media.MediaRecorder$AudioSource`，`android.media.MediaRecorder$AudioEncoder`，和`android.media.MediaRecorder$OutputFormat`：这些是枚举，包含我们需要传递给`MediaRecorder`各种方法的参数。'
- en: Tip
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Java class naming scheme**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java类命名方案**'
- en: The dollar sign in the class name commonly means that the class is internal.
    This is not the exact heuristic, as you can declare a similar class name yourself
    without following any logic whatsoever—`'$'` is a usable character in Java variable
    and class names, not too dissimilar from, for example, JavaScript. Such unorthodox
    naming, however, is frowned upon.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 类名中的美元符号通常表示该类是内部的。这并不是一个精确的启发式方法，因为您可以在没有任何逻辑的情况下自己声明一个类似的名字——`'$'`是Java变量和类名中可用的字符，与例如JavaScript等语言类似。然而，这种非常规的命名是不被提倡的。
- en: Loading Java classes
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载Java类
- en: 'The code to load the aforementioned Java classes into your Python application
    is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述Java类加载到您的Python应用程序中的代码如下：
- en: '[PRE7]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you try to run the program at this point, you''ll receive an error, something
    along the lines of:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您此时尝试运行程序，您将收到一个错误，类似于以下内容：
- en: '**ImportError: No module named jnius**: You''ll encounter this error if you
    don''t have Pyjnius installed on your machine'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ImportError: 没有名为jnius的模块**：如果您在机器上没有安装Pyjnius，您将遇到此错误。'
- en: '**jnius.JavaException: Class not found ''android/os/Environment''**: You''ll
    encounter this error if Pyjnius is installed, but the Android classes we''re trying
    to load are missing (for example, when running on a desktop machine)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jnius.JavaException: 类未找到 ''android/os/Environment''**：如果您安装了Pyjnius，但尝试加载的Android类缺失（例如，在桌面机器上运行时），您将遇到此错误。'
- en: This is one of the rare cases when receiving an error means we did everything
    right. From now on, we should do all of the testing on Android device or inside
    an emulator because the code isn't cross-platform anymore. It relies unequivocally
    on Android-specific Java features.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种罕见的情况，收到错误意味着我们做的一切都是正确的。从现在开始，我们应该在 Android 设备或模拟器内部进行所有测试，因为代码不再是跨平台的了。它明确依赖于
    Android 特定的 Java 功能。
- en: Now we can use Java classes seamlessly in our Python code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以无缝地在我们的 Python 代码中使用 Java 类。
- en: Tip
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Keep in mind that the documentation for these classes is intended for use with
    Java, not Python. You can look it up on Google's official Android developers portal
    at [http://developer.android.com/reference/packages.html](http://developer.android.com/reference/packages.html)—translating
    code samples from Java to Python may appear intimidating at first, but in reality,
    it is dead simple (if a bit wordy).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些类的文档是为与 Java 一起使用而编写的，而不是 Python。你可以在 Google 官方的 Android 开发者门户上查找它 [http://developer.android.com/reference/packages.html](http://developer.android.com/reference/packages.html)——最初将代码示例从
    Java 转换为 Python 可能看起来有些令人生畏，但实际上非常简单（如果有些啰嗦）。
- en: Looking up the storage path
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找存储路径
- en: 'Let''s illustrate the practical cross-language API use with a simple example.
    In Java, we would do something like this in order to find out where an SD card
    is mounted:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来说明实际的多语言 API 使用。在 Java 中，我们会这样做来找出 SD 卡挂载的位置：
- en: '[PRE8]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When translated to Python, this code reads:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当转换为 Python 时，此代码的读取方式如下：
- en: '[PRE9]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is the exact same thing as shown in the previous code, only written in
    Python instead of Java.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前代码中显示的完全相同，只是用 Python 而不是 Java 编写的。
- en: 'While we''re at it, let''s also log this value, so that we can see in the Kivy
    log which exact path the `getAbsolutePath` method returned to our code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在做这件事的时候，也让我们记录这个值，这样我们就可以在 Kivy 日志中看到 `getAbsolutePath` 方法返回给我们的代码的确切路径：
- en: '[PRE10]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On my testing device, this produces the following line in the Kivy log:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的测试设备上，这会在 Kivy 日志中产生以下行：
- en: '[PRE11]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Reading logs from the device
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从设备读取日志
- en: When you're running a Kivy application from the terminal during development,
    logs appear immediately in the same terminal window. This very useful feature
    is also available, albeit less accessible, when your app runs inside Kivy Launcher.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在开发期间从终端运行 Kivy 应用程序时，日志会立即在同一终端窗口中显示。这个非常有用的功能在应用程序在 Kivy 启动器内部运行时也是可用的，尽管不太容易访问。
- en: To read Kivy logs, navigate to the folder where your app lives on the device
    (for example, `/Kivy/Recorder` on the SD card). Inside this folder, Kivy Launcher
    creates another directory named `.kivy`, with the default configuration and miscellaneous
    service information inside. Every time the application is started, a log file
    is created under `.kivy/logs`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取 Kivy 日志，导航到设备上你的应用程序所在的文件夹（例如，SD 卡上的 `/Kivy/Recorder`）。在这个文件夹内部，Kivy 启动器创建了一个名为
    `.kivy` 的另一个目录，其中包含默认配置和一些杂项服务信息。每次应用程序启动时，都会在 `.kivy/logs` 下创建一个日志文件。
- en: Alternatively, if you have the Android SDK installed, you can enable USB debugging
    on your device and then use the `adb logcat` command to see all the Android logs,
    including Kivy logs, in one place. This produces much more information about the
    internal processes happening inside the device, such as various hardware activating
    and deactivating, application windows changing their state, and so on.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你已经安装了 Android SDK，你可以在设备上启用 USB 调试，然后使用 `adb logcat` 命令在一个地方查看所有 Android
    日志，包括 Kivy 日志。这会产生关于设备内部发生的各种内部过程的大量信息，例如各种硬件的激活和去激活、应用程序窗口状态的变化等等。
- en: Logs can be of tremendous value when debugging strange program behavior or when
    an app just refuses to start. Kivy also prints all sorts of warnings about the
    runtime environment there, such as libraries or features missing, Python modules
    failing to load, and other potential problems.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 日志在调试奇怪的程序行为或当应用程序拒绝启动时非常有价值。Kivy 还会在那里打印关于运行时环境的各种警告，例如缺少库或功能、Python 模块加载失败以及其他潜在问题。
- en: Recording sound
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 录制声音
- en: Now, let's dive deeper into the rabbit hole of the Android API and actually
    record a sound from the mic. The following code is again basically a translation
    of Android API documentation into Python. If you're interested in the original
    Java version of this code, you may find it at [http://developer.android.com/guide/topics/media/audio-capture.html](http://developer.android.com/guide/topics/media/audio-capture.html)—it's
    way too lengthy to include here.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入Android API的兔子洞，实际上从麦克风录制声音。以下代码基本上是将Android API文档翻译成Python。如果您对这段代码的原始Java版本感兴趣，可以在[http://developer.android.com/guide/topics/media/audio-capture.html](http://developer.android.com/guide/topics/media/audio-capture.html)找到——它太长了，无法在这里包含。
- en: 'The following is the preparation code that initializes a `MediaRecorder` object:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是初始化`MediaRecorder`对象的准备代码：
- en: '[PRE12]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is the typical, straightforward, verbose Java way of initializing things,
    rewritten in Python word for word.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是典型的、直接的、冗长的Java初始化方式，用Python逐字重写。
- en: You can tweak the output file format and codec here, for example, change `AMR_NB`
    (**Adaptive Multi-Rate** codec, which is optimized for speech and hence widely
    used in GSM and other mobile phone networks) to `AudioEncoder.AAC` (**Advanced
    Audio Coding** standard, a more general-purpose codec similar to MP3). There is
    probably no good reason for this since the dynamic range of the built-in microphone
    is unlikely to be suitable for recording music anyway, but the choice is yours.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里调整输出文件格式和编解码器，例如，将`AMR_NB`（**自适应多速率**编解码器，针对语音优化，因此在GSM和其他移动电话网络中广泛使用）更改为`AudioEncoder.AAC`（**高级音频编解码器**标准，是一种更通用的编解码器，类似于MP3）。这样做可能没有很好的理由，因为内置麦克风的动态范围可能不适合录制音乐，但选择权在您手中。
- en: 'Now for the fun part, the "Begin/End recording" button. The following code
    snippet uses the same logic as already seen in [Chapter 1](ch01.html "Chapter 1. Building
    a Clock App"), *Building a Clock App*, when implementing the Start/Stop button
    for the stopwatch:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候来点乐趣了，“开始/结束录音”按钮。以下代码片段使用了与[第1章](ch01.html "第1章. 构建时钟应用程序")中实现计时器开始/停止按钮时相同的逻辑：
- en: '[PRE13]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, no rocket science was applied here either: we just stored the
    current state, `is_recording`, and then took the action depending on it, namely:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里也没有应用任何火箭科学：我们只是存储了当前状态，`is_recording`，然后根据它采取行动，即：
- en: Start or stop the `MediaRecorder` object (the highlighted part).
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始或停止`MediaRecorder`对象（高亮部分）。
- en: Flip the `is_recording` flag.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 翻转`is_recording`标志。
- en: Update the button text so that it reflects the current state (see the following
    screenshot).
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新按钮文本，使其反映当前状态（见以下截图）。
- en: 'The last part of the application that needs updating is the `recorder.kv` file.
    We need to tweak the "Begin/End recording" button so that it calls our `begin_end_recording()`
    function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更新的应用程序的最后部分是`recorder.kv`文件。我们需要调整“开始/结束录音”按钮，使其调用我们的`begin_end_recording()`函数：
- en: '[PRE14]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That''s it! If you run the application now, chances are that you''ll be able
    to actually record a sound file that is going to be stored on the SD card. However,
    please see the next section before you do this. The button that you created will
    look something like the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！如果您现在运行应用程序，很可能会记录下要存储在SD卡上的声音文件。然而，在这样做之前，请先查看下一节。您创建的按钮看起来可能如下所示：
- en: '![Recording sound](img/B01620_03_12.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![录音声音](img/B01620_03_12.jpg)'
- en: Begin recording and End recording – this one button summarizes our app's functionality
    so far
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 开始录音和结束录音——这个按钮概括了我们的应用程序到目前为止的功能
- en: Major caveat – permissions
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主要注意事项——权限
- en: The default Kivy Launcher app at the time of writing this doesn't have the necessary
    permission to record sound, `android.permission.RECORD_AUDIO`. This results in
    a crash as soon as the `MediaRecorder` instance is initialized.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 编写本文时，默认的Kivy启动器应用程序没有记录声音所需的权限，`android.permission.RECORD_AUDIO`。这导致`MediaRecorder`实例初始化时立即崩溃。
- en: 'There are many ways to mitigate this problem. First, the easiest one: for the
    sake of this tutorial, we already provide a modified Kivy Launcher that has the
    necessary permission enabled. You can find `KivyLauncherMod.apk` bundled with
    the book''s source code archive. The latest version of the package is also available
    for download at [https://github.com/mvasilkov/kivy_launcher_hack](https://github.com/mvasilkov/kivy_launcher_hack).'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以减轻这个问题。首先，最简单的一个：为了这个教程，我们已提供修改后的Kivy Launcher，其中已启用必要的权限。你可以在书籍的源代码存档中找到`KivyLauncherMod.apk`。该包的最新版本也可在[https://github.com/mvasilkov/kivy_launcher_hack](https://github.com/mvasilkov/kivy_launcher_hack)下载。
- en: Before you install the provided `.apk` file, please delete the existing version
    of the app, if any, from your device.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装提供的`.apk`文件之前，请从你的设备中删除现有版本的应用，如果有的话。
- en: Alternatively, if you're willing to fiddle with the gory details of bundling
    Kivy apps for Google Play, you can build Kivy Launcher yourself from the source
    code. Everything you need to do this can be found in the official Kivy GitHub
    account, [https://github.com/kivy](https://github.com/kivy).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你愿意处理为Google Play打包Kivy应用的繁琐细节，你可以从源代码自行构建Kivy Launcher。完成这项工作所需的所有信息都可以在官方Kivy
    GitHub账户[https://github.com/kivy](https://github.com/kivy)中找到。
- en: 'The third viable option (also probably easier than the previous one) is to
    tweak the already existing Kivy Launcher app. To do so, you can use the **apktool**
    ([https://code.google.com/p/android-apktool/](https://code.google.com/p/android-apktool/)).
    The exact steps you need to take are outlined as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种可行的选择（也可能比前一个更容易）是调整现有的Kivy Launcher应用。为此，你可以使用**apktool**([https://code.google.com/p/android-apktool/](https://code.google.com/p/android-apktool/))。你需要采取的确切步骤如下：
- en: 'Download the official `KivyLauncher.apk` file and extract it from the command
    line, assuming that the apktool is in your path:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载官方的`KivyLauncher.apk`文件，并从命令行提取它，假设apktool在你的路径中：
- en: '[PRE15]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the necessary permission statement to the `AndroidManifest.xml` file:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将必要的权限声明添加到`AndroidManifest.xml`文件中：
- en: '[PRE16]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Repackage `.apk` like this:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以这种方式重新打包`.apk`：
- en: '[PRE17]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Sign the resulting `.apk` file using the `jarsigner` utility. Have a look at
    the official documentation on signing Android packages, available at [http://developer.android.com/tools/publishing/app-signing.html#signing-manually](http://developer.android.com/tools/publishing/app-signing.html#signing-manually).
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`jarsigner`实用程序对生成的`.apk`文件进行签名。请查看关于在[http://developer.android.com/tools/publishing/app-signing.html#signing-manually](http://developer.android.com/tools/publishing/app-signing.html#signing-manually)手动签名Android包的官方文档。
- en: As a result of this procedure, the modified Kivy Launcher package will be able
    to record sound.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此过程，修改后的Kivy Launcher包将能够录制声音。
- en: Tip
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can add various other permissions in the same way to be able to exploit
    them in your Python code using Pyjnius. For example, in order to access the GPS
    API, your app needs the `android.permission.ACCESS_FINE_LOCATION` permission.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用同样的方式添加各种其他权限，以便在Python代码中使用Pyjnius利用它们。例如，为了访问GPS API，你的应用需要`android.permission.ACCESS_FINE_LOCATION`权限。
- en: All available permissions are listed in the Android documentation at [http://developer.android.com/reference/android/Manifest.permission.html](http://developer.android.com/reference/android/Manifest.permission.html).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可用的权限都在Android文档[http://developer.android.com/reference/android/Manifest.permission.html](http://developer.android.com/reference/android/Manifest.permission.html)中列出。
- en: Playing sound
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放声音
- en: 'Getting sound playback to work is easier; there is no permission for this,
    and the API is somewhat more concise too. We need to load just one more class,
    `MediaPlayer`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要使声音播放工作变得容易；不需要此权限，API也更为简洁。我们只需要加载一个额外的类，`MediaPlayer`：
- en: '[PRE18]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the code that will run when the user presses the Play button.
    We''ll also use the `reset_player()` function in the *Deleting files* section;
    otherwise, there could have been one slightly longer function:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在用户按下播放按钮时运行的代码。我们还会在*删除文件*部分使用`reset_player()`函数；否则，可能有一个稍微长一点的函数：
- en: '[PRE19]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The intricate details of each API call can be found in the official documentation,
    but overall, this listing is pretty self-evident: reset the player to its initial
    state, load the sound file, and push play. The file format is determined automatically,
    making our task at hand a wee bit easier.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 每个API调用的详细情况可以在官方文档中找到，但总体来说，这个列表相当直观：将播放器重置到初始状态，加载声音文件，然后播放。文件格式会自动确定，这使得我们的任务变得稍微容易一些。
- en: Tip
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'In practice, such code should always be wrapped in a `try ... catch` block.
    There are just too many things that can go wrong: the file may go missing or created
    in a wrong format, the SD card may become unplugged or otherwise unreadable, and
    other equally terrible things that will surely crash your program if given a chance.
    A good rule of thumb when doing IO is *better safe than sorry*.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这样的代码应该始终被包裹在一个 `try ... catch` 块中。可能会有太多事情出错：文件可能丢失或以错误的格式创建，SD卡可能被拔掉或无法读取，以及其他同样可怕的事情，如果有机会，这些事情一定会让你的程序崩溃。在进行输入输出操作时，一个好的经验法则是*宁可靠安全，不可靠后悔*。
- en: Deleting files
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除文件
- en: 'This last feature will use the `java.io.File` class, which is not strictly
    related to Android. One great thing about the official Android documentation is
    that it contains reference to these core Java classes too, despite the fact they
    predate the Android operating system by more than a decade. The actual code needed
    to implement file removal is exactly one line; it''s highlighted in the following
    listing:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的功能将使用 `java.io.File` 类，它与Android并不严格相关。官方Android文档的一个优点是，它还包含了这些核心Java类的引用，尽管它们比Android操作系统早了十多年。实现文件删除的实际代码正好是一行；它在下述列表中突出显示：
- en: '[PRE20]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, we stop the playback (if any) by calling the `reset_player()` function,
    and then remove the file—short and sweet.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过调用 `reset_player()` 函数停止播放（如果有），然后删除文件——简单直接。
- en: Interestingly, the `File.delete()` method in Java won't throw an exception in
    the event of a catastrophic failure, so there is no need to perform `try ... catch`
    in this case. Consistency, consistency everywhere.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Java中的 `File.delete()` 方法在发生灾难性故障时不会抛出异常，因此在这种情况下不需要执行 `try ... catch`。一致性，无处不在的一致性。
- en: Note
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An attentive reader will notice that we could also delete the file using Python's
    own `os.remove()` function. Doing this using Java achieves nothing special compared
    to a pure Python implementation; it's also slower. On the other hand, as a demonstration
    of Pyjnius, `java.io.File` works as good as any other Java class.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一个细心的读者会注意到，我们也可以使用Python自己的 `os.remove()` 函数来删除文件。与纯Python实现相比，这样做在Java中并没有什么特别之处；它也更快。另一方面，作为Pyjnius的演示，`java.io.File`
    与其他Java类一样有效。
- en: Also note that this function will run perfectly fine in a desktop OS as well
    because it's not Android-specific; you only need Java and Pyjnius installed in
    order for this to work.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，这个函数在桌面操作系统上也能完美运行，因为它不是Android特有的；你只需要安装Java和Pyjnius，这个功能才能工作。
- en: At this point, with the UI and all three major functions done, our application
    is complete for the purposes of this tutorial.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，随着用户界面和所有三个主要功能的完成，我们的应用程序对于本教程的目的来说已经完整了。
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Writing non-portable code has its strengths and weaknesses, just like any other
    global architectural decision. This particular choice, however, is especially
    hard because the switch to native API typically happens early in the project and
    may be completely impractical to undo at a later stage.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 编写不可移植的代码有其优点和缺点，就像任何其他全局架构决策一样。然而，这个特定的选择尤其困难，因为切换到本地API通常发生在项目早期，并且在后期阶段可能完全不切实际地撤销。
- en: 'The major advantage of the approach was discussed at the beginning of this
    chapter: with platform-specific code, you can do virtually anything that your
    platform is capable of. There are no artificial limits; your Python code has unrestricted
    access to the same underlying API as the native code.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的重大优势在本章的开头已经讨论过：使用平台特定代码，你可以几乎做你平台能做的任何事情。没有人为的限制；你的Python代码对相同的底层API的访问是无限的。
- en: 'On the downside, depending on a single platform is risky for a number of reasons:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一方面来看，依赖于单一平台是有风险的，原因有很多：
- en: The market of Android alone is provably smaller than that of Android plus iOS
    (this holds true for about every combination of operating systems).
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅Android的市场规模就比Android加上iOS的市场规模要小（这适用于几乎所有的操作系统组合）。
- en: Porting the program over to a new system becomes harder with every platform-specific
    feature you use.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着你使用的每个平台特定功能，将程序移植到新系统变得更加困难。
- en: If the project runs on just one platform, exactly one political decision may
    be sufficient to kill it. The chances of getting banned by Google is higher than
    that of getting the boot from both App Store and Google Play simultaneously. (Again,
    this holds true for practically every set of application marketplaces.)
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果项目只运行在一个平台上，可能只需要一个政治决定就足以将其扼杀。被谷歌封禁的可能性高于同时被App Store和Google Play踢出的可能性。（同样，这几乎适用于每一组应用程序市场。）
- en: Now that you're well aware of the options, it's up to you to make an educated
    choice regarding every app you develop.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经充分了解了各种选项，那么在开发每一个应用程序时，做出明智的选择就取决于你了。
- en: '**A few words on the UI**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于UI的一些话**'
- en: 'By all means, you should not hesitate to borrow and re-implement ideas (and
    layouts, fonts, colors, and so on) seen elsewhere. The phrase attributed to Pablo
    Picasso, "Good artists borrow; great artists steal," summarizes today''s web and
    application development neatly. (The "steal" part is figurative: please don''t
    actually steal things.)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，你都不应该犹豫去借鉴和重新实现在其他地方看到的思想（以及布局、字体、颜色等等）。归功于巴勃罗·毕加索的这句话，“好艺术家借鉴；伟大的艺术家偷窃”，简洁地总结了今天的网络和应用程序开发。
    （“偷窃”部分是比喻性的：请实际上不要真的去偷东西。）
- en: 'Also, let''s get this straight: the mere fact that Microsoft decided to use
    the "Modern UI" in a number of latest products, both mobile and desktop, doesn''t
    mean that the design itself is any good. What we know for sure is that this user
    interface paradigm will be immediately recognizable by users due to popularity,
    fortunate or otherwise, of Microsoft operating systems.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们明确一点：仅仅因为微软决定在许多最新的移动和桌面产品中使用“现代UI”，并不意味着这种设计本身有什么优点。我们确信的是，由于微软操作系统的普及，这种用户界面范式将立即被用户识别出来，无论这种普及是幸运的还是不幸的。
- en: Putting Java to rest, in the next chapter we will build a simple chat with client–server
    architecture on top of the popular Python web framework, **Twisted**.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将放下Java，使用流行的Python网络框架**Twisted**构建一个简单的基于客户端-服务器架构的聊天程序。
