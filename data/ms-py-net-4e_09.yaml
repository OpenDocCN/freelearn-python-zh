- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Building Network Web Services with Python
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python构建网络Web服务
- en: In the previous chapters, we were a consumer of the APIs provided by others.
    In *Chapter 3*, *APIs and Intent-Driven Networking*, we saw that we can use an
    `HTTP POST` request to NX-API at the `http://<your device ip>/ins` URL with the
    `CLI` command embedded in the `HTTP POST` body to execute commands remotely on
    the Cisco Nexus device; the device then returns the command execution output in
    its HTTP response return. In *Chapter 8*, *Network Monitoring with Python – Part
    2*, we used the `HTTP GET` method for our sFlow-RT at `http://<your host ip>:8008/version`
    with an empty body to retrieve the version of the sFlow-RT software. These request-response
    exchanges are examples of RESTful web services.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们是他人提供的API的消费者。在*第3章*，*APIs和Intent-Driven Networking*中，我们看到了我们可以使用`HTTP
    POST`请求到NX-API的`http://<your device ip>/ins` URL，在`HTTP POST`体中嵌入`CLI`命令，以在Cisco
    Nexus设备上远程执行命令；设备随后在其HTTP响应中返回命令执行输出。在*第8章*，*Network Monitoring with Python –
    Part 2*中，我们使用`HTTP GET`方法在我们的sFlow-RT上`http://<your host ip>:8008/version`，使用空体来检索sFlow-RT软件的版本。这些请求-响应交换是RESTful网络服务的例子。
- en: 'According to Wikipedia ([https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer)):'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科（[https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer)）：
- en: ”Representational state transfer (REST) or RESTful web services is one way of
    providing interoperability between computer systems on the internet. REST-compliant
    web services allow requesting systems to access and manipulate the textual representation
    of web resources using a uniform and predefined set of stateless operations.”
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “表示状态转移（REST）或RESTful网络服务是提供互联网上计算机系统之间互操作性的方法之一。符合REST规范的Web服务允许请求系统使用统一和预定义的无状态操作集来访问和操作Web资源的文本表示。”
- en: As noted, the use of RESTful web services using the HTTP protocol is only one
    of many methods of information exchange on the web; other forms of web services
    also exist. However, it is the most commonly used web service today, with the
    associated `GET`, `POST`, `PUT`, and `DELETE` verbs as a predefined way of exchanging
    information.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所注，使用HTTP协议的RESTful网络服务只是网络信息交换的许多方法之一；其他形式的网络服务也存在。然而，它是今天最常用的网络服务，相关的`GET`、`POST`、`PUT`和`DELETE`动词作为信息交换的预定义方式。
- en: If you are wondering about HTTPS versus HTTP, for our discussion, we are treating
    HTTPS as a secure extension of HTTP ([https://en.wikipedia.org/wiki/HTTPS](https://en.wikipedia.org/wiki/HTTPS))
    and the same underlying protocol as a RESTful API.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对HTTPS与HTTP进行比较，在我们的讨论中，我们将HTTPS视为HTTP的安全扩展（[https://en.wikipedia.org/wiki/HTTPS](https://en.wikipedia.org/wiki/HTTPS)），与RESTful
    API具有相同的底层协议。
- en: On the provider side, one of the advantages of providing RESTful services to
    users is the ability to hide internal operations from the user. For example, in
    the case of sFlow-RT, if we were to log in to the device to see the version of
    the software installed instead of using its RESTful API, we would need more in-depth
    knowledge of the tool to know where to check. However, by providing the resources
    as a URL, the API provider abstracts the version-checking operations from the
    requester, making the operation much simpler. The abstraction also provides a
    layer of security as it can open up the endpoints only as needed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务提供方，向用户提供RESTful服务的一个优点是能够隐藏内部操作。例如，在sFlow-RT的情况下，如果我们想登录设备查看安装的软件版本，而不是使用其RESTful
    API，我们就需要更深入地了解工具，知道在哪里检查。然而，通过将资源作为URL提供，API提供者将版本检查操作从请求者那里抽象出来，使得操作变得更加简单。这种抽象还提供了一层安全性，因为它可以根据需要仅打开端点。
- en: 'As the master of our network universe, RESTful web services provide many notable
    benefits that we can enjoy, such as the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们网络宇宙的主宰，RESTful网络服务为我们提供了许多显著的益处，我们可以享受以下好处：
- en: You can abstract the requester from learning about the internals of the network
    operations. For example, we can provide a web service to query the switch version
    without the requester knowing the exact CLI command or the switch API.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以抽象请求者，使其不必了解网络操作的内部。例如，我们可以提供一个网络服务来查询交换机版本，而无需请求者知道确切的CLI命令或交换机API。
- en: We can consolidate and customize operations that uniquely fit our network needs,
    such as a resource to upgrade all our top-of-rack switches.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以整合和定制符合我们网络需求独特操作的，例如一个用于升级我们所有机架顶部交换机的资源。
- en: We can provide better security by only exposing operations as needed. For example,
    we can provide read-only URLs (`GET`) to core network devices and read-write URLs
    (`GET`/`POST`/`PUT`/`DELETE`) to access-level switches.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过仅按需公开操作来提供更好的安全性。例如，我们可以为核心网络设备提供只读URL（`GET`），为访问级别交换机提供读写URL（`GET`/`POST`/`PUT`/`DELETE`）。
- en: 'In this chapter, we will use one of the most popular Python web frameworks,
    **Flask**, to create our RESTful web service for our network. In this chapter,
    we will learn about the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用最受欢迎的Python网络框架之一，**Flask**，来为我们的网络创建RESTful网络服务。在本章中，我们将学习以下内容：
- en: Comparing Python web frameworks
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较Python网络框架
- en: Introduction to Flask
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask简介
- en: Operations involving static network content
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涉及静态网络内容操作
- en: Operations involving dynamic network operations
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涉及动态网络操作的操作
- en: Authentication and authorization
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证和授权
- en: Running our web app in containers
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中运行我们的网络应用
- en: Let’s start by looking at the available Python web frameworks and why we chose
    Flask.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看可用的Python网络框架以及为什么我们选择了Flask开始。
- en: Comparing Python web frameworks
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较Python网络框架
- en: Python is known for its great many web frameworks. There is a running joke in
    the Python community about whether you can ever work as a full-time Python developer
    without working with any Python web frameworks. There are several Python web developer
    conferences, including DjangoCon US ([https://djangocon.us/](https://djangocon.us/)),
    DjangoCon EU ([https://djangocon.eu/](https://djangocon.eu/)), FlaskCon ([https://flaskcon.com/](https://flaskcon.com/)),
    Python Web Conference ([https://pythonwebconf.com/](https://pythonwebconf.com/)),
    and many local meetups. Each of the conferences attracts hundreds of attendees
    every year. Did I mention Python has a thriving web development community?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Python以其众多的网络框架而闻名。在Python社区中有一个流行的笑话，那就是你是否可以作为一个全职的Python开发者而不使用任何Python网络框架。有几个Python网络开发者会议，包括DjangoCon
    US ([https://djangocon.us/](https://djangocon.us/))、DjangoCon EU ([https://djangocon.eu/](https://djangocon.eu/))、FlaskCon
    ([https://flaskcon.com/](https://flaskcon.com/))、Python Web Conference ([https://pythonwebconf.com/](https://pythonwebconf.com/))以及许多本地聚会。每个会议每年都吸引数百名参与者。我提到过Python有一个蓬勃发展的网络开发社区吗？
- en: 'If you sort the Python web frameworks at [https://hotframeworks.com/languages/python](https://hotframeworks.com/languages/python),
    you can see that there is no shortage of choices when it comes to Python and web
    frameworks:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按[https://hotframeworks.com/languages/python](https://hotframeworks.com/languages/python)对Python网络框架进行排序，你会发现当涉及到Python和网络框架时，选择余地非常丰富：
- en: '![Table  Description automatically generated](img/B18403_09_01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![表格描述自动生成](img/B18403_09_01.png)'
- en: 'Figure 9.1: Python Web Framework Rankings (source: https://hotframeworks.com/languages/python)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：Python网络框架排名（来源：https://hotframeworks.com/languages/python）
- en: 'In the most recent 2021 Python Developer Survey, Flask slightly edged Django
    as the most popular web framework:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近的2021年Python开发者调查中，Flask略胜Django，成为最受欢迎的网络框架：
- en: '![A picture containing graphical user interface  Description automatically
    generated](img/B18403_09_02.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![包含图形用户界面的图片描述自动生成](img/B18403_09_02.png)'
- en: 'Figure 9.2: Python Developer Survey 2021 (source: https://lp.jetbrains.com/python-developers-survey-2021/)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：2021年Python开发者调查（来源：https://lp.jetbrains.com/python-developers-survey-2021/）
- en: With so many options to choose from, which framework should we pick? Trying
    all the frameworks one by one would be time-consuming. The question of which web
    framework is better is also a passionate topic among web developers. If you ask
    this question on any of the forums, such as Quora, or search on Reddit, get ready
    for some highly opinionated answers and heated debates.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这么多选项中，我们应该选择哪个框架？逐一尝试所有框架将耗费大量时间。哪个网络框架更好的问题也是网络开发者之间一个充满激情的话题。如果你在任何论坛上提出这个问题，比如Quora，或者在Reddit上搜索，准备好接受一些高度主观的回答和激烈的辩论。
- en: 'Speaking of Quora and Reddit, here’s an interesting fact: both Quora and Reddit
    were written in Python. Reddit uses Pylons ([https://www.reddit.com/wiki/faq#wiki_so_what_python_framework_do_you_use.3F](https://www.reddit.com/wiki/faq#wiki_so_what_python_framework_do_you_use.3F)),
    while Quora started with Pylons but replaced a portion of the framework with its
    in-house code ([https://www.quora.com/What-languages-and-frameworks-are-used-to-code-Quora](https://www.quora.com/What-languages-and-frameworks-are-used-to-code-Quora)).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 说到Quora和Reddit，这里有一个有趣的事实：Quora和Reddit都是用Python编写的。Reddit使用Pylons（[https://www.reddit.com/wiki/faq#wiki_so_what_python_framework_do_you_use.3F](https://www.reddit.com/wiki/faq#wiki_so_what_python_framework_do_you_use.3F)），而Quora最初使用Pylons，但用内部代码替换了框架的一部分（[https://www.quora.com/What-languages-and-frameworks-are-used-to-code-Quora](https://www.quora.com/What-languages-and-frameworks-are-used-to-code-Quora)）。
- en: 'Of course, I am biased toward programming languages (Python!) and web frameworks
    (Flask and Django!). In this section, I hope to convey my reasoning behind choosing
    one over the other for any particular project. Let’s pick the top two frameworks
    from the preceding HotFrameworks list and compare them:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我偏向于编程语言（Python！）和Web框架（Flask和Django！）。在本节中，我希望传达我选择其中一个而不是另一个进行特定项目的理由。让我们从先前的HotFrameworks列表中挑选前两个框架进行比较：
- en: '**Django**: The self-proclaimed “web framework for perfectionists with deadlines”
    is a high-level Python web framework that encourages rapid development and clean,
    pragmatic design ([https://www.djangoproject.com/](https://www.djangoproject.com/)).
    It is a large framework with pre-built code that provides an administrative panel
    and built-in content management.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Django**：自诩为“对完美主义者有截止日期的Web框架”，是一个高级Python Web框架，鼓励快速开发和清晰、实用的设计（[https://www.djangoproject.com/](https://www.djangoproject.com/)）。它是一个大型框架，包含预构建的代码，提供管理面板和内置内容管理。'
- en: '**Flask**: This is a microframework for Python and is based on Werkzeug, Jinja2,
    and other applications ([https://palletsprojects.com/p/flask/](https://palletsprojects.com/p/flask/)).
    By being a microframework, Flask intends on keeping the core small and easy to
    extend when needed. The “micro” in microframework does not mean that Flask lacks
    functionality, nor does it mean it cannot work in a production environment.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flask**：这是一个基于Werkzeug、Jinja2和其他应用的Python微框架（[https://palletsprojects.com/p/flask/](https://palletsprojects.com/p/flask/)）。作为一个微框架，Flask旨在保持核心小且易于扩展，当需要时。微框架中的“微”并不意味着Flask缺乏功能，也不意味着它不能在生产环境中工作。'
- en: I use Django for some of the larger projects while using Flask for quick prototypes.
    The Django framework has a strong opinion on how things should be done; any deviation
    from it would sometimes leave the user feeling that they are “fighting with the
    framework.” For example, if you look at the Django database documentation ([https://docs.djangoproject.com/en/4.0/ref/databases/](https://docs.djangoproject.com/en/4.0/ref/databases/))
    you will notice that the framework supports several different SQL databases. However,
    they are all variants of a SQL database such as MySQL, PostgreSQL, SQLite, and
    others.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用Django处理一些较大的项目，而使用Flask进行快速原型设计。Django框架对如何做事有很强的观点；任何偏离它的做法有时都会让用户感觉像是在“与框架抗争”。例如，如果你查看Django数据库文档（[https://docs.djangoproject.com/en/4.0/ref/databases/](https://docs.djangoproject.com/en/4.0/ref/databases/)），你会注意到该框架支持几种不同的SQL数据库。然而，它们都是SQL数据库的变体，如MySQL、PostgreSQL、SQLite等。
- en: What if we want to use a NoSQL database such as MongoDB or CouchDB? It might
    be possible, but it could leave us in our own hands because there is no official
    support from Django. Being an opinionated framework is certainly not a bad thing.
    It is just a matter of opinion (no pun intended).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用像MongoDB或CouchDB这样的NoSQL数据库呢？这可能可行，但可能会让我们自己动手，因为Django没有官方支持。作为一个有观点的框架当然不是坏事。这只是观点的问题（没有打趣的意思）。
- en: Keeping the core code small and extending it when needed is very appealing when
    we need something simple and fast. The initial example in the documentation to
    get Flask up and running consists of only six lines of code and is easy to understand,
    even if you don’t have any prior experience. Since Flask is built with extensions
    in mind, writing our extensions, such as a decorator, is relatively easy. Even
    though it is a microframework, the Flask core still includes the necessary components,
    such as a development server, debugger, integration with unit tests, RESTful request
    dispatching, and more, to get you started quickly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要简单快速的东西时，保持核心代码小并在需要时扩展它是非常吸引人的。文档中的初始示例只有六行代码，即使你没有任何先前的经验也容易理解。由于Flask是考虑到扩展而构建的，因此编写我们的扩展，如装饰器，相对容易。尽管它是一个微型框架，但Flask核心仍然包括必要的组件，如开发服务器、调试器、与单元测试的集成、RESTful请求分发等，以帮助您快速入门。
- en: As you can see, Django and Flask are the two most popular Python web frameworks
    by almost all measures. We can’t really go wrong picking either as our starting
    point. The popularity that comes with both frameworks means both have extensive
    community contribution and support, and can quickly develop modern features.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Django和Flask几乎在所有衡量标准上都是最受欢迎的Python网络框架。我们选择任何一个作为起点都不会出错。这两个框架带来的流行度意味着它们都有广泛的社区贡献和支持，并且可以快速开发现代功能。
- en: For the ease of deployment, I feel Flask is an ideal choice for us when it comes
    to building network web services to start with.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于部署，我认为在构建网络Web服务时，Flask是我们理想的选择。
- en: Flask and lab setup
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask和实验室设置
- en: 'In this chapter, we will continue to use a virtual environment to isolate the
    Python environment and dependencies. We can start a new virtual environment, or
    we can continue to use the existing virtual environment that we have been using.
    My preference is to start a new virtual environment. I will call mine `ch09-venv`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续使用虚拟环境来隔离Python环境和依赖。我们可以启动一个新的虚拟环境，或者我们可以继续使用我们一直在使用的现有虚拟环境。我的偏好是启动一个新的虚拟环境。我将称它为`ch09-venv`：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this chapter, we will install quite a few Python packages. To make life
    easier, I have included a `requirements.txt` file on this book’s GitHub repository;
    we can use it to install all the necessary packages (remember to activate your
    virtual environment). You should see packages being downloaded and successfully
    installed during the installation process:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将安装相当多的Python包。为了使生活更轻松，我在本书的GitHub仓库中包含了一个`requirements.txt`文件；我们可以使用它来安装所有必要的包（记得激活你的虚拟环境）。你应该在安装过程中看到正在下载和成功安装的包：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For our network topology, we will use the `2_DC_Topology` that we have been
    using in the first few chapters, as shown here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的网络拓扑，我们将使用我们在前几章中使用的`2_DC_Topology`，如图所示：
- en: '![](img/B18403_09_03.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18403_09_03.png)'
- en: 'Figure 9.3: Lab Topology'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：实验室拓扑
- en: Let’s take a look at Flask in the next section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来看看Flask。
- en: Please note that, from here on out, I will assume that you will always execute
    from the virtual environment and that you have installed the necessary packages
    in the `requirements.txt` file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从现在开始，我将假设您将始终在虚拟环境中执行，并且您已经在`requirements.txt`文件中安装了必要的包。
- en: Introduction to Flask
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask简介
- en: Like most popular open source projects, Flask has very good documentation, which
    is available at [https://flask.palletsprojects.com/en/2.0.x/](https://flask.palletsprojects.com/en/2.0.x/).
    If you’d like to dig deeper into Flask, the project documentation would be a great
    place to start.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数流行的开源项目一样，Flask拥有非常好的文档，可在[https://flask.palletsprojects.com/en/2.0.x/](https://flask.palletsprojects.com/en/2.0.x/)找到。如果你想深入了解Flask，项目文档是一个很好的起点。
- en: 'I highly recommend Miguel Grinberg’s work ([https://blog.miguelgrinberg.com/](https://blog.miguelgrinberg.com/))
    related to Flask. His blog, book, and video training have taught me a lot about
    Flask. Miguel’s class, *Building Web APIs with Flask*, inspired me to build my
    first Flask-based API, and inspired the writing of this chapter. You can take
    a look at his published code on GitHub: [https://github.com/miguelgrinberg/](https://github.com/miguelgrinberg/).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈推荐Miguel Grinberg与Flask相关的作品([https://blog.miguelgrinberg.com/](https://blog.miguelgrinberg.com/))。他的博客、书籍和视频培训让我对Flask有了很多了解。Miguel的《使用Flask构建Web
    API》课程激发了我构建第一个基于Flask的API，并启发了本章的写作。您可以在GitHub上查看他发布的代码：[https://github.com/miguelgrinberg/](https://github.com/miguelgrinberg/)。
- en: Flask versions
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask版本
- en: 'As of the time of writing, the latest version of Flask is version 2.2.2\. Flask
    version 2.0.0 was released in May 2021 from version 1.1.4\. There were several
    big changes introduced in the release, thus the big number jump in release numbers.
    Some of the big changes are listed below:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 到本书写作时，Flask 的最新版本是 2.2.2。Flask 2.0.0 版本于 2021 年 5 月从 1.1.4 版本发布。在这次发布中引入了几个重大变化，因此版本号有大幅提升。以下是一些重大变化的列表：
- en: Flask 2.0 officially dropped the support for Python 2 and Python 3.5\.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask 2.0 正式停止了对 Python 2 和 Python 3.5 的支持。
- en: Python 3 type hinting is supported.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 Python 3 类型提示。
- en: The HTTP method decorator was introduced.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入了 HTTP 方法装饰器。
- en: These changes probably mean very little at this point because we are just getting
    started with Flask. For now, just keep in mind the big version change if we were
    searching for answers and examples. If possible, look for examples based on version
    2 and beyond.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化可能在这个阶段意义不大，因为我们只是刚开始使用 Flask。目前，如果我们正在寻找答案和示例，请记住版本的大幅变化。如果可能的话，寻找基于 2
    版本及以上的示例。
- en: Flask examples
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask 示例
- en: 'Our first Flask application is contained in one single file, `chapter9_1.py`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一款 Flask 应用程序包含在一个单独的文件中，`chapter9_1.py`：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a simple design pattern for Flask apps. We create an instance of the
    `Flask` class with the first argument as the name of the application’s module
    package. In this case, we used a single module that can be started as an application;
    later on, we will see how we can import it as a package. We then use the route
    decorator to tell Flask which URL should be handled by the `hello_networkers()`
    function; in this case, we indicated the root path. We end the file with the usual
    name scope, checking when the script is run by itself ([https://docs.python.org/3.10/library/__main__.html](https://docs.python.org/3.10/library/__main__.html)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Flask 应用程序简单的设计模式。我们使用应用程序模块包的名称作为第一个参数创建 `Flask` 类的实例。在这种情况下，我们使用了一个可以作为应用程序启动的单个模块；稍后我们将看到如何将其作为包导入。然后我们使用路由装饰器告诉
    Flask 哪个 URL 应由 `hello_networkers()` 函数处理；在这种情况下，我们指明了根路径。我们以通常的名称作用域结束文件，检查脚本是否单独运行([https://docs.python.org/3.10/library/__main__.html](https://docs.python.org/3.10/library/__main__.html)).
- en: 'We also add the `host` and `debug` options, which allow more verbose output
    and allow us to listen on all the host interfaces. We can run this application
    using the development server:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了 `host` 和 `debug` 选项，这允许更详细的输出，并允许我们在所有主机接口上监听。我们可以使用开发服务器运行此应用程序：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you receive an error of **Address already in use** from the development server,
    change the port Flask Development Server runs on via the `port=xxxx` option, [https://flask.palletsprojects.com/en/2.2.x/server/](https://flask.palletsprojects.com/en/2.2.x/server/).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从开发服务器收到**地址已在使用**的错误，可以通过`port=xxxx`选项更改 Flask 开发服务器运行的端口，[https://flask.palletsprojects.com/en/2.2.x/server/](https://flask.palletsprojects.com/en/2.2.x/server/).
- en: Now that we have a server running, let’s test the server response with an HTTP
    client.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个服务器正在运行，让我们使用 HTTP 客户端测试服务器响应。
- en: The HTTPie client
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTPie 客户端
- en: We have already installed `HTTPie` ([https://httpie.org/](https://httpie.org/))
    as part of the installation from the `requirements.txt` file. This book is printed
    in black and white, so the example does not show color highlighting, but in your
    installation, you can see `HTTPie` has better syntax highlighting for HTTP transactions.
    It also has a more intuitive command-line interaction with the RESTful HTTP server.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 `HTTPie` ([https://httpie.org/](https://httpie.org/)) 作为 `requirements.txt`
    文件安装过程的一部分安装好了。这本书是黑白印刷的，所以示例中没有显示颜色高亮，但在你的安装中，你可以看到 `HTTPie` 对 HTTP 事务有更好的语法高亮。它还与
    RESTful HTTP 服务器有更直观的命令行交互。
- en: 'We can use it to test our first Flask application (more examples on `HTTPie`
    to follow). We will start a second terminal window on the management host, activate
    the virtual environment, and type the following in:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用它来测试我们的第一个 Flask 应用程序（后续将提供更多 `HTTPie` 的示例）。我们将在管理主机上启动第二个终端窗口，激活虚拟环境，并输入以下内容：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As a comparison, if we are using `curl`, we will need to use the `-i` switch
    to achieve the same output: `curl -i http://192.168.2.126:5000`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 作为比较，如果我们使用 `curl`，我们需要使用 `-i` 开关来达到相同的效果：`curl -i http://192.168.2.126:5000`。
- en: 'We will use `HTTPie` as our client for this chapter; it is worth taking a minute
    or two to take a look at its usage. We will use the free website HTTPBin ([https://httpbin.org/](https://httpbin.org/))
    to demonstrate the use of `HTTPie`. The usage of `HTTPie` follows this simple
    pattern:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`HTTPie`作为本章的客户端；花一两分钟了解其用法是值得的。我们将使用免费网站HTTPBin([https://httpbin.org/](https://httpbin.org/))来演示`HTTPie`的使用。`HTTPie`的使用遵循以下简单模式：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Following the preceding pattern, a `GET` request is very straightforward, as
    we have seen with our Flask development server:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前面的模式，一个`GET`请求非常直接，正如我们在我们的Flask开发服务器中看到的那样：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'JSON is the default implicit content type for `HTTPie`. If your HTTP body contains
    just strings, no other operation is needed. If you need to apply non-string JSON
    fields, use :`=` or other documented special characters. In the following example,
    we want the `"married"` variable to be a `Boolean` instead of a `string`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是`HTTPie`的默认隐式内容类型。如果你的HTTP正文只包含字符串，则不需要其他操作。如果你需要应用非字符串的JSON字段，请使用`:=`或其他文档化的特殊字符。在以下示例中，我们希望`"married"`变量是一个`Boolean`而不是一个字符串：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, `HTTPie` is a big improvement from the traditional curl syntax
    and makes testing the REST API a breeze.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`HTTPie`比传统的curl语法有了很大的改进，使得测试REST API变得轻而易举。
- en: More usage examples are available at [https://httpie.io/docs/cli/usage](https://httpie.io/docs/cli/usage).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 更多使用示例可在[https://httpie.io/docs/cli/usage](https://httpie.io/docs/cli/usage)找到。
- en: Getting back to our Flask program, a large part of API building is based on
    the flow of URL routing. Let’s look deeper at the `app.route()` decorator.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的Flask程序，API构建的大部分内容都是基于URL路由的流程。让我们更深入地看看`app.route()`装饰器。
- en: URL routing
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URL路由
- en: 'We added two additional functions and paired them up with the appropriate `app.route()`
    route in `chapter9_2.py`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`chapter9_2.py`中添加了两个额外的函数，并将它们与适当的`app.route()`路由配对：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The result is that different endpoints are passed to different functions. We
    can verify this with two `http` requests:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是不同的端点被传递到不同的函数中。我们可以通过两个`http`请求来验证这一点：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As the requests are made from the client side, the server screen will see the
    requests coming in:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于请求是从客户端发起的，服务器屏幕将看到请求进入：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see, the different endpoints correspond to different functions; whatever
    was returned from the function is what the server returns to the requester. Of
    course, the routing will be pretty limited if we have to keep it static all the
    time. There are ways to pass dynamic variables from the URL to Flask; we will
    look at an example of this in the next section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，不同的端点对应不同的函数；函数返回的内容就是服务器返回给请求者的内容。当然，如果我们必须始终保持路由静态，那么路由将会非常有限。有一种方法可以从URL传递动态变量到Flask；我们将在下一节中查看这个示例。
- en: URL variables
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URL变量
- en: 'We can pass dynamic variables to the URL, as seen in the `chapter9_3.py` examples:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将动态变量传递到URL中，如`chapter9_3.py`示例所示：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the two functions, we pass in dynamic information such as the hostname and
    interface number at the time when the client is making the request. Note that,
    in the `/routers/<hostname>` URL, we pass the `<hostname>` variable as a string;
    in `/routers/<hostname>/interface/<int:interface_number>` we specify the `int`
    variable should only be an integer. Let’s run the example and make some requests:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个函数中，我们在客户端发起请求时传递动态信息，如主机名和接口号。请注意，在`/routers/<hostname>` URL中，我们将`<hostname>`变量作为字符串传递；在`/routers/<hostname>/interface/<int:interface_number>`中，我们指定`int`变量应该仅是整数。让我们运行示例并发出一些请求：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the `int` variable is NOT an integer, an error will be thrown:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`int`变量不是整数，将会抛出错误：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The converter includes integers, float, and path (it accepts slashes).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器包括整数、浮点数和路径（它接受斜杠）。
- en: Besides matching static routes with dynamic variables, we can also generate
    URLs upon application launch. This is very useful when we do not know the endpoint
    variable in advance or if the endpoint is based on other conditions, such as the
    values queried from a database. Let’s take a look at an example of this.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了匹配静态路由与动态变量外，我们还可以在应用程序启动时生成URL。当我们事先不知道端点变量或端点基于其他条件（如从数据库查询的值）时，这非常有用。让我们看看这个示例。
- en: URL generation
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URL生成
- en: 'In `chapter9_4.py`, we wanted to dynamically create a URL during application
    launch in the form of `/<hostname>/list_interfaces`, where the hostname could
    be `r1`, `r2`, or `r3`. We already know we can statically configure three routes
    and three corresponding functions, but let’s see how we can do that upon application
    launch:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `chapter9_4.py` 中，我们希望在应用程序启动时动态创建一个 URL，形式为 `/<hostname>/list_interfaces`，其中主机名可以是
    `r1`、`r2` 或 `r3`。我们已经知道我们可以静态配置三个路由和三个相应的函数，但让我们看看如何在应用程序启动时实现这一点：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Upon its execution, we will have a few nice, logical URLs that loop around
    the routers list without statically defining each:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，我们将有一些很好的、逻辑上围绕路由列表循环的 URL，而不需要静态定义每个 URL：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For now, you can think of `app.text_request_context()` as a dummy request object
    necessary for demonstration purposes. If you are interested in the local context,
    feel free to look at [https://werkzeug.palletsprojects.com/en/2.2.x/local/](https://werkzeug.palletsprojects.com/en/2.2.x/local/).
    The dynamic generation of URL endpoints greatly simplifies our code, saves time,
    and makes the code easier to read.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你可以将 `app.text_request_context()` 视为一个用于演示目的的虚拟请求对象。如果你对局部上下文感兴趣，可以自由查看 [https://werkzeug.palletsprojects.com/en/2.2.x/local/](https://werkzeug.palletsprojects.com/en/2.2.x/local/)。动态生成
    URL 端点极大地简化了我们的代码，节省了时间，并使代码更容易阅读。
- en: The jsonify return
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jsonify 返回值
- en: 'Another time-saver in Flask is the `jsonify()` return, which wraps `json.dumps()`
    and turns the JSON output into a response object with `application/json` as the
    content type in the HTTP header. We can tweak the `chapter9_3.py` script a bit,
    as illustrated in `chapter9_5.py`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 中的另一个节省时间的功能是 `jsonify()` 返回值，它封装了 `json.dumps()`，并将 JSON 输出转换为带有 HTTP
    头中 `application/json` 作为内容类型的响应对象。我们可以稍微调整一下 `chapter9_3.py` 脚本，如 `chapter9_5.py`
    中所示：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With a few lines, the return result is now a `JSON` object with the appropriate
    header:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 几行代码后，返回结果现在是一个带有适当头部的 `JSON` 对象：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Combine all the Flask features we have learned so far, and we are now ready
    to build an API for our network.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 结合我们迄今为止学到的所有 Flask 特性，我们现在可以准备构建我们网络的 API。
- en: Network resource API
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络资源 API
- en: When we have network devices in production, each of the devices will have a
    certain state and information that you would like to keep in a persistent location
    so that you can easily retrieve them later on. This is often done in terms of
    storing data in a database. We saw many examples of such information storage in
    the monitoring chapters.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在生产中有网络设备时，每个设备都将有一定的状态和信息，你希望将其保存在持久的位置，以便你可以稍后轻松检索它们。这通常是通过在数据库中存储数据来完成的。我们在监控章节中看到了许多此类信息存储的例子。
- en: However, we would not normally give other non-network administrative users who
    might want this information direct access to the database; nor would they want
    to learn all the complex SQL query language. For these cases, we can leverage
    Flask and the **Flask-SQLAlchemy** extension of Flask to give them the necessary
    information via a network API.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们通常不会直接给其他可能需要这些信息的非网络管理用户数据库的直接访问权限；他们也不希望学习所有复杂的 SQL 查询语言。对于这些情况，我们可以利用
    Flask 和 Flask 的 **Flask-SQLAlchemy** 扩展来通过网络 API 提供他们所需的信息。
- en: You can learn more about Flask-SQLAlchemy at [https://flask-sqlalchemy.palletsprojects.com/en/2.x/](https://flask-sqlalchemy.palletsprojects.com/en/2.x/).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://flask-sqlalchemy.palletsprojects.com/en/2.x/](https://flask-sqlalchemy.palletsprojects.com/en/2.x/)
    上了解更多关于 Flask-SQLAlchemy 的信息。
- en: Flask-SQLAlchemy
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask-SQLAlchemy
- en: SQLAlchemy and the Flask-SQLAlchemy extension are database abstraction and object-relational
    mappers, respectively. It’s a fancy way to use the `Python` object for a database.
    To make things simple, we will use SQLite as the database, which is a flat file
    that acts as a self-contained SQL database. We will look at the content of `chapter9_db_1.py`
    as an example of using Flask-SQLAlchemy to create a network database and insert
    a few table entries into the database. This is a multiple-step process, and we
    will look at the steps in this section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 和 Flask-SQLAlchemy 扩展分别是数据库抽象和对象关系映射器。这是一种使用 `Python` 对象进行数据库的复杂方式。为了简化问题，我们将使用
    SQLite 作为数据库，它是一个作为自包含 SQL 数据库的平面文件。我们将以 `chapter9_db_1.py` 的内容为例，展示如何使用 Flask-SQLAlchemy
    创建网络数据库并在数据库中插入一些表条目。这是一个多步骤的过程，我们将在本节中查看这些步骤。
- en: 'To begin, we will create a Flask application and load the configuration for
    SQLAlchemy, such as the database path and name, then create the `SQLAlchemy` object
    by passing the application to it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个 Flask 应用程序并加载 SQLAlchemy 的配置，例如数据库路径和名称，然后通过传递应用程序来创建 `SQLAlchemy`
    对象：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can then create a device `database` object and its associated primary key
    and various columns:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个设备`database`对象及其相关的主键和各种列：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can invoke the `database` object, create entries, and insert them into the
    database table. Keep in mind that anything we add to the session needs to be committed
    to the database in order to be permanent:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用`database`对象，创建条目，并将它们插入到数据库表中。请注意，我们添加到会话中的任何内容都需要提交到数据库才能永久保存：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will run the Python script and check for the existence of the database file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行Python脚本并检查数据库文件的存在：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can use the interactive prompt to check the database table entries:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用交互式提示来检查数据库表条目：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can also create new entries in the same manner:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以以相同的方式创建新的条目：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let’s go ahead and delete the `network.db` file so it does not conflict with
    our other examples using the same `db` name:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续删除`network.db`文件，以免与使用相同`db`名称的其他示例冲突：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now we are ready to move on to build our network content API.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好继续构建我们的网络内容API。
- en: The network content API
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络内容API
- en: Before we dive into the code of building our API, let’s take a moment to think
    about the API structure we will create. Planning for an API is usually more an
    art than a science; it really depends on your situation and preference. What I
    suggest in this section is, by no means, the only way, but for now, stay with
    me for the purposes of getting started.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究构建API的代码之前，让我们花点时间思考我们将创建的API结构。为API规划通常更多的是艺术而不是科学；它实际上取决于你的情况和偏好。我在本节中建议的，绝对不是唯一的方法，但现在，为了开始，请跟随我。
- en: Recall that, in our diagram, we have four Cisco IOSv devices. Let’s pretend
    that two of them, `lax-edg-r1` and `lax-edg-r2`, are in the network role of the
    spine. The other two devices, `nyc-edg-r1` and `nyc-edg-r2`, are in our network
    service as leaves. These are arbitrary choices and can be modified later on, but
    the point is that we want to serve data about our network devices and expose them
    via an API.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在我们的图中，我们有四个Cisco IOSv设备。让我们假设其中两个，`lax-edg-r1`和`lax-edg-r2`，在网络中扮演脊的角色。其他两个设备，`nyc-edg-r1`和`nyc-edg-r2`，在我们的网络服务中作为叶子。这些是任意的选择，以后可以修改，但重点是我们要提供有关我们的网络设备的数据，并通过API公开它们。
- en: 'To make things simple, we will create two APIs, a devices group API and a single-device
    API:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，我们将创建两个API，一个是设备组API，另一个是单个设备API：
- en: '![Text  Description automatically generated with medium confidence](img/B18403_09_04.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成，置信度中等](img/B18403_09_04.png)'
- en: 'Figure 9.4: Network Content API'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：网络内容API
- en: 'The first API will be our `http://192.168.2.126/devices/` endpoint, which supports
    two methods: `GET` and `POST`. The `GET` request will return the current list
    of devices, while the `POST` request with the proper JSON body will create the
    device. Of course, you can choose different endpoints for creation and querying,
    but in this design, we choose to differentiate the two by the HTTP methods.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个API将是我们的`http://192.168.2.126/devices/`端点，它支持两种方法：`GET`和`POST`。`GET`请求将返回当前设备列表，而带有正确JSON主体的`POST`请求将创建设备。当然，你可以选择不同的端点进行创建和查询，但在这个设计中，我们选择通过HTTP方法来区分这两个操作。
- en: The second API will be specific to our device in the form of `http://192.168.2.126/devices/<device
    id>`. The API with the `GET` request will show the details of the device that
    we have entered into the database.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个API将以`http://192.168.2.126/devices/<device id>`的形式针对我们的设备。使用`GET`请求的API将显示我们已输入数据库的设备的详细信息。
- en: The `PUT` request will modify the entry with the update. Note that we use `PUT`
    instead of `POST`. This is typical of HTTP API usage; when we need to modify an
    existing entry, we will use `PUT` instead of `POST`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT`请求将修改带有更新的条目。请注意，我们使用`PUT`而不是`POST`。这在HTTP API使用中很典型；当我们需要修改现有条目时，我们将使用`PUT`而不是`POST`。'
- en: At this point, you should have a good idea about what your API will look like.
    To better visualize the final result, I will jump ahead and show the result quickly
    before we take a look at the code. If you want to follow the example, feel free
    to launch `chapter9_6.py` as the Flask server.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该对我们的API有一个很好的了解。为了更好地可视化最终结果，我在我们查看代码之前，将快速展示结果。如果你想跟随示例，请随意启动`chapter9_6.py`作为Flask服务器。
- en: 'A `POST` request to the `/devices/` API will allow you to create an entry.
    In this case, I would like to create our network device with attributes such as
    hostname, loopback IP, management IP, role, vendor, and the operating system it
    runs on:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 向`/devices/` API发送`POST`请求将允许您创建一个条目。在这种情况下，我想创建我们的网络设备，具有诸如主机名、环回IP、管理IP、角色、厂商和它运行的操作系统等属性：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'I can repeat the preceding step for the three additional devices:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以为另外三个设备重复前面的步骤：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we use the same API endpoint with the `GET` request, we will be able to
    see the list of network devices that we created:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用相同的API端点进行`GET`请求，我们将能够看到我们创建的网络设备列表：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Similarly, using the `GET` request for `/devices/<id>` will return specific
    information related to the device:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，使用`GET`请求对`/devices/<id>`的请求将返回与设备相关的特定信息：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s pretend we have downgraded the `lax-edg-r1` operating system from `15.6`
    to `14.6`. We can use the `PUT` request to update the device record:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们将`lax-edg-r1`操作系统从`15.6`降级到`14.6`。我们可以使用`PUT`请求来更新设备记录：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, let’s look at the code in `chapter9_6.py` that created the preceding APIs.
    What’s cool, in my opinion, is that all of these APIs were done in a single file,
    including the database interaction. Later on, when we outgrow the APIs at hand,
    we can always separate the components, such as having a separate file for the
    database class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`chapter9_6.py`中创建前面API的代码。在我看来，酷的地方在于所有这些API都是在单个文件中完成的，包括数据库交互。稍后，当我们超出当前API的范围时，我们总是可以分离组件，例如为数据库类创建一个单独的文件。
- en: The devices API
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备API
- en: 'The `chapter9_6.py` file starts with the necessary imports. Note that the following
    request import is the `request` object from the client and not the `requests`
    package that we were using in the previous chapters:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`chapter9_6.py`文件以必要的导入开始。请注意，以下请求导入的是客户端的`request`对象，而不是我们在前几章中使用的`requests`包：'
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We declared a `database` object with `id` as the primary key and string fields
    for `hostname`, `loopback`, `mgmt_ip`, `role`, `vendor`, and `os`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个以`id`作为主键的`database`对象，并为`hostname`、`loopback`、`mgmt_ip`、`role`、`vendor`和`os`声明了字符串字段：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `get_url()` function under the `Device` class returns a URL from the `url_for()`
    function. Note that the `get_device()` function that’s called is not defined just
    yet under the `/devices/<int:id>` route:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Device`类下的`get_url()`函数从`url_for()`函数返回一个URL。请注意，在`/devices/<int:id>`路由下尚未定义被调用的`get_device()`函数：'
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `export_data()` and `import_data()` functions are mirror images of each
    other. One is used to get the information from the database to the user `(export_data())`
    when we use the `GET` method. The other is to get information from the user to
    the database `(import_data())` when we use the `POST` or `PUT` method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`export_data()`和`import_data()`函数是镜像的。一个用于在`GET`方法中使用时从数据库获取信息到用户`(export_data())`，另一个用于在`POST`或`PUT`方法中使用时从用户获取信息到数据库`(import_data())`：'
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With the `database` object in place and the import and export functions created,
    the URL dispatch is straightforward for device operations. The `GET` request will
    return a list of devices by querying all the entries in the `devices` table and
    returning the URL of each entry. The `POST` method will use the `import_data()`
    function with the global `request` object as the input. It will then add the device
    and commit the information to the database:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在`database`对象就位并创建了导入和导出函数后，设备操作的路由派发就非常直接了。`GET`请求将通过查询`devices`表中的所有条目并返回每个条目的URL来返回设备列表。`POST`方法将使用`import_data()`函数和全局`request`对象作为输入。然后它将添加设备并将信息提交到数据库：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you look at the `POST` method, the returned body is an empty JSON body,
    with the status code `201` (created), as well as extra headers:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看`POST`方法，返回的正文是一个空的JSON正文，状态码为`201`（已创建），以及额外的头信息：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Let’s look at the API that queries and returns information for individual devices.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看查询并返回单个设备信息的API。
- en: The device ID API
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备ID API
- en: 'The route for individual devices specifies that the ID should be an integer,
    which can act as our first line of defense against a bad request. The two endpoints
    follow the same design pattern as our `/devices/` endpoint, where we use the same
    `import` and `export` functions:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 单个设备的路由指定ID应该是一个整数，这可以作为我们防止不良请求的第一道防线。两个端点遵循与我们的`/devices/`端点相同的设计模式，其中我们使用相同的`import`和`export`函数：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that the `query_or_404()` method provides a convenient way of returning
    `404 (not found)` if the database query returns negative for the ID passed in.
    This is a pretty elegant way of providing a quick check on the database query.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`query_or_404()`方法提供了一个方便的方法，当数据库查询对传入的ID返回负值时，返回`404（未找到）`。这是一种相当优雅的方式来快速检查数据库查询。
- en: 'Finally, the last part of the code creates the database table and starts the
    Flask development server:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码的最后部分创建了数据库表并启动了Flask开发服务器：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is one of the longer Python scripts in this book, so we took more time
    to explain it in detail. The script provides a way to illustrate how we can utilize
    the database in the backend to keep track of the network devices and only expose
    them to the external world as APIs using Flask.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书中较长的Python脚本之一，所以我们花了更多的时间来详细解释它。该脚本提供了一种方法，说明我们如何利用后端数据库来跟踪网络设备，并通过Flask将它们仅作为API暴露给外部世界。
- en: In the next section, we will take a look at how to use the API to perform asynchronous
    tasks on either individual devices or a group of devices.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用API在单个设备或一组设备上执行异步任务。
- en: Network dynamic operations
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络动态操作
- en: Our API can now provide static information about the network; anything we can
    store in the database can be returned to the requester. It would be great if we
    could interact with our network directly, such as a query for device information
    or to push configuration changes to the device.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API现在可以提供有关网络的静态信息；我们可以存储在数据库中的任何内容都可以返回给请求者。如果能直接与我们的网络交互就太好了，例如查询设备信息或将配置更改推送到设备。
- en: 'We will start this process by leveraging a script we have already seen in *Chapter
    2*, *Low-Level Network Device Interactions*, for interacting with a device via
    Pexpect. We will modify the script slightly into a function we can repeatedly
    use in `chapter9_pexpect_1.py`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过利用我们在*第2章*中已经看到的脚本开始这个过程，该脚本用于通过Pexpect与设备交互。我们将稍微修改该脚本，使其成为我们可以在`chapter9_pexpect_1.py`中重复使用的函数：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can test the new function via the interactive prompt:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过交互式提示测试新的功能：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Make sure our Pexpect script works before proceeding. The following code assumes
    that we have entered the necessary database information from the previous section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，确保我们的Pexpect脚本正常工作。以下代码假设我们已经从上一节中输入了必要的数据库信息。
- en: 'We can add a new API for querying the device version in `chapter9_7.py`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`chapter9_7.py`中添加一个新的API来查询设备版本：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The result will be returned to the requester:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将返回给请求者：
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can also add another endpoint that will allow us to perform a bulk action
    on multiple devices based on their common fields. In the following example, the
    endpoint will take the `device_role` attribute in the URL and match it up with
    the appropriate device(s):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加另一个端点，允许我们根据设备的公共字段对多个设备执行批量操作。在下面的示例中，端点将使用URL中的`device_role`属性并将其与适当的设备（们）匹配：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Of course, looping through all the devices in `Device.query.all()` is not efficient,
    as in the preceding code. In production, we will use a SQL query that specifically
    targets the role of the device.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，像前面的代码那样通过`Device.query.all()`循环遍历所有设备并不高效。在生产中，我们将使用一个专门针对设备角色的SQL查询。
- en: 'When we use the RESTful API, we can see that all the spine, as well as leaf,
    devices can be queried at the same time:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用RESTful API时，我们可以看到所有脊和叶设备可以同时查询：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As illustrated, the new API endpoints query the device(s) in real time and return
    the result to the requester. This works relatively well when you can guarantee
    a response from the operation within the timeout value of the transaction (30
    seconds, by default) or if you are OK with the HTTP session timing out before
    the operation is completed. One way to deal with the timeout issue is to perform
    the tasks asynchronously. We will look at how to do so in the next section.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，新的API端点实时查询设备（们）并返回结果给请求者。当你可以保证在事务的超时值（默认为30秒）内收到操作响应，或者你愿意在操作完成之前HTTP会话超时时，这工作相对较好。处理超时问题的一种方法是将任务异步执行。我们将在下一节中探讨如何这样做。
- en: Asynchronous operations
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步操作
- en: Asynchronous operations, when executing tasks out of the normal time sequence,
    are, in my opinion, an advanced topic of Flask.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的看法中，异步操作，当执行超出正常时间序列的任务时，是Flask的一个高级主题。
- en: 'Luckily, Miguel Grinberg ([https://blog.miguelgrinberg.com/](https://blog.miguelgrinberg.com/)),
    whose Flask work I am a big fan of, provides many posts and examples on his blog
    and his GitHub repository. For asynchronous operations, the example code in `chapter9_8.py`
    referenced Miguel’s GitHub code on the `Raspberry Pi` file ([https://github.com/miguelgrinberg/oreilly-flask-apis-video/blob/master/camera/camera.py](https://github.com/miguelgrinberg/oreilly-flask-apis-video/blob/master/camera/camera.py))
    for the background decorator. We will start by importing a few more modules:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Miguel Grinberg ([https://blog.miguelgrinberg.com/](https://blog.miguelgrinberg.com/))，我对他的Flask工作非常钦佩，在他的博客和GitHub仓库中提供了许多文章和示例。对于异步操作，`chapter9_8.py`中的示例代码引用了Miguel在GitHub上的`Raspberry
    Pi`文件中的代码（[https://github.com/miguelgrinberg/oreilly-flask-apis-video/blob/master/camera/camera.py](https://github.com/miguelgrinberg/oreilly-flask-apis-video/blob/master/camera/camera.py)）用于后台装饰器。我们将从导入几个额外的模块开始：
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The background decorator takes in a function and runs it as a background task
    using the thread and UUID for the task ID. It returns the status code `202` (accepted)
    and the location of the new resources for the requester to check. We will make
    a new URL for status checking:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 背景装饰器接收一个函数，并使用线程和UUID作为任务ID将其作为后台任务运行。它返回状态码`202`（已接受）和请求者检查的新资源位置。我们将为状态检查创建一个新的URL：
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Once we retrieve the resource, it is deleted. This is done by setting `app.config[''AUTO_DELETE_BG_TASKS'']`
    to `true` at the top of the app. We will add this decorator to our version endpoints
    without changing the other part of the code because all of the complexity is hidden
    in the decorator (how cool is that?):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们检索到资源，它就会被删除。这是通过在应用顶部设置`app.config['AUTO_DELETE_BG_TASKS']`为`true`来完成的。我们将添加此装饰器到我们的版本端点，而不会更改代码的其他部分，因为所有复杂性都隐藏在装饰器中（这有多酷？）：
- en: '[PRE46]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The end result is a two-part process. We will perform the `GET` request for
    the endpoint and receive the location header:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是两个步骤的过程。我们将对端点执行`GET`请求并接收位置头：
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can then make a second request to the location to retrieve the result:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以向该位置发出第二个请求以检索结果：
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To verify that the status code `202` is returned when the resource is not ready,
    we will use the following script, `chapter9_request_1.py`, to immediately make
    a request to the new resource:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证当资源尚未准备好时返回的状态码`202`，我们将使用以下脚本`chapter9_request_1.py`立即对新资源发出请求：
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As you can see in the result, the status code is returned while the resource
    is still being run in the background as `202`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在结果中看到的那样，状态码在资源仍在后台运行时返回为`202`：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Our APIs are coming along nicely! Because our network resource is valuable,
    we should secure API access to only authorized personnel. We will add basic security
    measures to our API in the next section.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API进展顺利！由于我们的网络资源宝贵，我们应该仅允许授权人员访问API。我们将在下一节中为我们的API添加基本的安全措施。
- en: Authentication and Authorization
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证和授权
- en: 'For basic user authentication, we will use Flask’s `httpauth` ([https://flask-httpauth.readthedocs.io/en/latest/](https://flask-httpauth.readthedocs.io/en/latest/))
    extension, written by Miguel Grinberg, as well as the password functions in Werkzeug.
    The `httpauth` extension should have been installed as part of the `requirements.txt`
    installation at the beginning of this chapter. The new file illustrating the security
    feature is named `chapter9_9.py`. In the script, we will start with a few more
    module imports:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本用户认证，我们将使用由Miguel Grinberg编写的Flask的`httpauth` ([https://flask-httpauth.readthedocs.io/en/latest/](https://flask-httpauth.readthedocs.io/en/latest/))
    扩展，以及Werkzeug中的密码函数。`httpauth`扩展应该在本书开头`requirements.txt`安装过程中已经安装。展示安全功能的新的文件名为`chapter9_9.py`。在脚本中，我们将从几个额外的模块导入开始：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We will create an `HTTPBasicAuth` object as well as the `user database` object.
    Note that, during the user creation process, we will pass the password value;
    however, we are only storing `password_hash` instead of the cleartext `password`
    itself:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`HTTPBasicAuth`对象以及`用户数据库`对象。请注意，在用户创建过程中，我们将传递密码值；然而，我们只存储`password_hash`而不是明文`password`本身：
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `auth` object has a `verify_password` decorator that we can use, along
    with Flask’s `g` global context object that was created when the user request
    started. Because `g` is global, if we save the user to the `g` variable, it will
    live through the entire transaction:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`auth`对象有一个`verify_password`装饰器，我们可以使用它，以及当用户请求开始时创建的Flask的`g`全局上下文对象。因为`g`是全局的，如果我们把用户保存到`g`变量中，它将贯穿整个事务：'
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'There is a handy `before_request` handler that can be used before any API endpoint
    is called. We will combine the `auth.login_required` decorator with the `before_request`
    handler that will be applied to all the API routes:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个方便的`before_request`处理器可以在调用任何API端点之前使用。我们将结合`auth.login_required`装饰器与将应用于所有API路由的`before_request`处理器：
- en: '[PRE54]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Lastly, we will use the `unauthorized` error handler to return a `response`
    object for the `401` unauthorized error:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用`unauthorized`错误处理器来返回一个`response`对象以处理`401`未授权错误：
- en: '[PRE55]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Before we can test user authentication, we will need to create users in our
    database:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够测试用户认证之前，我们需要在我们的数据库中创建用户：
- en: '[PRE56]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Once you start your Flask development server, try to make a request, like we
    did previously. You should see that, this time, the server will reject the request
    with a `401` unauthorized error:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你启动了Flask开发服务器，尝试发送一个请求，就像我们之前做的那样。你应该看到，这次，服务器将拒绝请求并返回一个`401`未授权错误：
- en: '[PRE57]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We will now need to provide the authentication header for our requests:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要为我们的请求提供认证头：
- en: '[PRE58]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We now have a decent RESTful API set up for our network. When our user wants
    to retrieve network device information, they can query for the static content
    of the network. They can also perform network operations for a single device or
    a group of devices. We also added basic security measures to ensure that only
    the users we created can retrieve the information from our API. The cool part
    is that this is all done within a single file in less than 250 lines of code (less
    than 200 if you subtract the comments)!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在为我们的网络设置了一个不错的RESTful API。当我们的用户想要检索网络设备信息时，他们可以查询网络的静态内容。他们还可以对单个设备或一组设备执行网络操作。我们还添加了基本的安全措施，以确保只有我们创建的用户才能从我们的API中检索信息。酷的地方在于，这一切都是在单个文件中完成的，代码行数不到250行（如果你减去注释，不到200行）！
- en: For more information on user session management, logging in, logging out, and
    remembering user sessions, I highly recommend using the Flask-Login ([https://flask-login.readthedocs.io/en/latest/](https://flask-login.readthedocs.io/en/latest/))
    extension.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 关于用户会话管理、登录、登出和记住用户会话的更多信息，我强烈推荐使用Flask-Login ([https://flask-login.readthedocs.io/en/latest/](https://flask-login.readthedocs.io/en/latest/))
    扩展。
- en: We have now abstracted the underlying vendor API away from our network and replaced
    them with our RESTful API. By providing the abstraction, we are free to use what
    is required in the backend, such as Pexpect, while providing a uniform frontend
    to our requester. We can even take a step forward and replace the underlying network
    device without impacting the users making API calls to us. Flask provides this
    abstraction in a compact and easy-to-use way for us. We can also run Flask with
    a smaller footprint, such as by using containers.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经将底层供应商API从我们的网络中抽象出来，并用我们的RESTful API替换了它们。通过提供抽象，我们可以自由地使用后端所需的内容，例如Pexpect，同时为我们的请求者提供一个统一的接口。我们甚至可以更进一步，替换底层的网络设备，而不会影响向我们发出API调用的人。Flask以紧凑且易于使用的方式为我们提供了这种抽象。我们还可以使用容器等较小的脚本来运行Flask。
- en: Running Flask in containers
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中运行Flask
- en: Containers have become very popular in the last few years. They offer more abstractions
    and virtualization beyond hypervisor-based virtual machines. For interested readers,
    we will offer a simple example of how we can run our Flask app in a Docker container.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，容器变得非常流行。它们提供了比基于虚拟机管理程序的虚拟机更多的抽象和虚拟化。对于感兴趣的读者，我们将提供一个简单的例子，说明我们如何在Docker容器中运行我们的Flask应用。
- en: We will build our example based on the free DigitalOcean Docker tutorial on
    building containers on Ubuntu 20.04 machines ([https://www.digitalocean.com/community/tutorials/how-to-build-and-deploy-a-flask-application-using-docker-on-ubuntu-20-04](https://www.digitalocean.com/community/tutorials/how-to-build-and-deploy-a-flask-application-using-docker-on-ubuntu-20-04)).
    If you are new to containers, I would highly recommend that you go through that
    tutorial and return to this section after.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于免费的DigitalOcean Docker教程构建我们的示例，该教程介绍了如何在Ubuntu 20.04机器上构建容器（[https://www.digitalocean.com/community/tutorials/how-to-build-and-deploy-a-flask-application-using-docker-on-ubuntu-20-04](https://www.digitalocean.com/community/tutorials/how-to-build-and-deploy-a-flask-application-using-docker-on-ubuntu-20-04)）。如果你是容器的新手，我强烈建议你完成那个教程，然后再回到这一部分。
- en: 'Let’s make sure Docker is installed:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保Docker已安装：
- en: '[PRE59]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We will make a directory named `TestApp` to house our code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`TestApp`的目录来存放我们的代码：
- en: '[PRE60]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the directory, we will make another directory called `app` and create the
    `__init__.py` file:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录中，我们将创建另一个名为`app`的目录并创建`__init__.py`文件：
- en: '[PRE61]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Under the `app` directory is where we will contain the logic of our application.
    Since we have been using a single-file app up to this point, we can simply copy
    over the contents of our `chapter9_6.py` file to the `app/__init__.py` file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app`目录下是我们将包含应用程序逻辑的地方。由于我们到目前为止一直在使用单文件应用程序，我们可以简单地将`chapter9_6.py`文件的 内容复制到`app/__init__.py`文件中：
- en: '[PRE62]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can also copy the SQLite database file we created to this directory:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将我们创建的SQLite数据库文件复制到这个目录中：
- en: '[PRE63]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We will place the `requirements.txt` file in the `TestApp` directory:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`requirements.txt`文件放在`TestApp`目录中：
- en: '[PRE64]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Due to a conflict with the `tiangolo/uwsgi-nginx-flask` image and some later
    versions of Flask packages, this requirements file is reverting to Flask 1.1.1\.
    The portion of code we worked on works in both version 1.1.1 and the latest Flask
    version.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与`tiangolo/uwsgi-nginx-flask`镜像和一些Flask包的后续版本的冲突，此需求文件正在回滚到Flask 1.1.1。我们工作的代码部分在1.1.1版本和最新的Flask版本中都能正常工作。
- en: 'We will create the `main.py` file as our entry point and an `ini` file for
    `uwsgi`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建`main.py`文件作为我们的入口点，以及一个`ini`文件用于`uwsgi`：
- en: '[PRE65]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We will use a pre-made Docker image and create a `Dockerfile` that builds the
    Docker image:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用预制的Docker镜像并创建一个`Dockerfile`来构建Docker镜像：
- en: '[PRE66]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Our `start.sh` shell script will build the image, run it as a daemon in the
    background, then forward port `8000` to the Docker container:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`start.sh`外壳脚本将构建镜像，作为守护进程在后台运行，然后将端口`8000`转发到Docker容器：
- en: '[PRE67]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can now use the `start.sh` script to build the image and launch our container:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`start.sh`脚本来构建镜像并启动我们的容器：
- en: '[PRE68]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Our Flask now runs in the container that can be viewed from our host machine
    port `8000`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的Flask运行在容器中，可以从我们的主机机端口`8000`查看：
- en: '[PRE69]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can see the **management host IP** displayed in the address bar as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到**管理主机IP**如下显示在地址栏中：
- en: '![](img/B18403_09_05.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18403_09_05.png)'
- en: 'Figure 9.5: Management Host IP Forwarding'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：管理主机IP转发
- en: 'We can see the **Flask API endpoint** as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到**Flask API端点**如下所示：
- en: '![](img/B18403_09_06.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18403_09_06.png)'
- en: 'Figure 9.6: API Endpoint'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：API端点
- en: 'Once we are done, we can use the following commands to stop and delete the
    container:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们可以使用以下命令停止和删除容器：
- en: '[PRE70]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We can also delete the Docker image:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以删除Docker镜像：
- en: '[PRE71]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: As we can see, running Flask in a container gives us even more flexibility and
    the option to deploy our API abstraction in production. Containers, of course,
    offer their complexity and add more management tasks, so we need to weigh up the
    benefits and overhead when it comes to our deployment methods. We are close to
    the end of this chapter, so let’s look at what we have done so far before looking
    forward to the next chapters.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在容器中运行Flask给我们带来了更多的灵活性，以及将我们的API抽象部署到生产中的选项。当然，容器提供了它们的复杂性，并增加了更多的管理任务，因此在我们选择部署方法时，我们需要权衡利弊。我们接近本章的结尾，所以让我们看看我们到目前为止所做的工作，然后再展望下一章。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started to move on to the path of building RESTful APIs
    for our network. We looked at popular Python web frameworks, namely Django and
    Flask, and compared and contrasted the two. By choosing Flask, we can start small
    and expand on features by using Flask extensions.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始转向为我们的网络构建RESTful API的道路。我们研究了流行的Python网络框架，即Django和Flask，并对两者进行了比较和对比。通过选择Flask，我们可以从小处着手，并通过使用Flask扩展来扩展功能。
- en: In our lab, we used the virtual environment to separate the Flask installation
    base from our global site packages. The lab network consists of several IOSv nodes,
    two of which we have designated as spine routers while the other two as leaf routers.
    We took a tour of the basics of Flask and used the simple `HTTPie` client to test
    our API setup.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实验室中，我们使用虚拟环境来将Flask安装基础与我们的全局站点包分开。我们的实验室网络由几个IOSv节点组成，其中两个被指定为脊路由器，而另外两个为叶子路由器。我们游览了Flask的基础知识，并使用简单的`HTTPie`客户端来测试我们的API设置。
- en: Among the different setups of Flask, we placed special emphasis on URL dispatch
    as well as URL variables because they are the initial logic between the requesters
    and our API system. We took a look at using Flask-SQLAlchemy and SQLite to store
    and return network elements that are static in nature. For operation tasks, we
    also created API endpoints while calling other programs, such as Pexpect, to accomplish
    configuration tasks. We improved the setup by adding asynchronous handling and
    user authentication to our API. We also looked at how to run our Flask API application
    in a Docker container.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flask的不同配置中，我们特别强调了URL分发以及URL变量，因为它们是请求者与我们的API系统之间的初始逻辑。我们研究了使用Flask-SQLAlchemy和SQLite来存储和返回本质上是静态的网络元素。对于操作任务，我们在调用其他程序（如Pexpect）以完成配置任务的同时，也创建了API端点。我们通过添加异步处理和用户认证到我们的API来改进了设置。我们还探讨了如何在Docker容器中运行我们的Flask
    API应用程序。
- en: In Chapter 10, Introduction to Async IO, we will shift gears to look at one
    of the newer features in Python 3, Async IO, and how it can be applied to network
    engineering.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10章“异步IO简介”中，我们将转换节奏，探讨Python 3中较新的功能之一——异步IO，以及它是如何应用于网络工程的。
- en: Join our book community
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的图书社区
- en: 'To join our community for this book – where you can share feedback, ask questions
    to the author, and learn about new releases – follow the QR code below:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的社区——在这里您可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
- en: '![](img/QR_Code2903617220506617062.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code2903617220506617062.png)'
