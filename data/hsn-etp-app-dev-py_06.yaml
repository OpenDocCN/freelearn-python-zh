- en: Example – Building BugZot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 构建BugZot
- en: Over the last few chapters, we have discussed numerous techniques that deal
    with building an enterprise-scale application. But what good is that knowledge
    if we don't have any idea where to utilize it?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们已经讨论了许多构建企业级应用程序的技术。但是，如果我们不知道在哪里应用这些知识，那么这些知识有什么用呢？
- en: During the course of this chapter, we will walk through the process of building
    an enterprise-grade web application, which will be used to track bugs reported
    by various stakeholders of products that are marketed by the Omega Corporation.
    The system that we will, from now on, call **BugZot**, aims to provide such functionality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的过程中，我们将学习构建一个企业级Web应用程序的过程，该应用程序将用于跟踪Omega公司销售的各种产品的各种利益相关者报告的错误。从现在开始，我们将称之为**BugZot**的系统旨在提供此功能。
- en: The application will use various concepts to build the system in a manner that
    allows it to be scaled easily as the number of users interacting with the system
    grows. We will see how to utilize the various techniques of optimized data access
    and storage, highly scalable deployments, and caching, to build an application
    that performs well, even in high load scenarios.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将使用各种概念构建系统，以便在用户与系统交互的数量增加时能够轻松扩展。我们将看到如何利用各种优化的数据访问和存储技术、高度可扩展的部署和缓存技术来构建一个性能良好的应用程序，即使在高负载情况下也能表现良好。
- en: 'Over the course of this chapter, we will learn about:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的过程中，我们将学习以下内容：
- en: Utilizing existing web frameworks for building an enterprise-grade web application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用现有的Web框架构建企业级Web应用程序
- en: Implementing optimizations to database access to speed up the application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现优化数据库访问以加快应用程序速度
- en: Implementing caching techniques to reduce load on the application backend
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施缓存技术以减少应用程序后端的负载
- en: Utilizing multithreading techniques to increase application concurrency
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用多线程技术增加应用程序的并发性
- en: Deploying application in a scalable manner for production
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以可扩展的方式部署应用程序以供生产使用
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code listings in this book can be found under `chapter06` directory at [https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python.](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码清单可以在[https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)的`chapter06`目录下找到。
- en: 'The code samples can be cloned by running the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过运行以下命令克隆代码示例：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The chapter aims to build a scalable bug tracking web application. To achieve
    this, we use quite a lot of pre-existing libraries and tools that are openly available
    and well tested to suit various use cases over time. The following set of tools
    will be required to build and run the demo application:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在构建一个可扩展的错误跟踪Web应用程序。为了实现这一目标，我们使用了许多现有的库和工具，这些库和工具是公开可用的，并经过了长时间的测试，以适应各种用例。构建和运行演示应用程序需要以下一组工具：
- en: PostgreSQL 9.6 or above
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL 9.6或更高版本
- en: Python 3.6 or above
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.6或更高版本
- en: Flask—Microframework for web development in Python ...
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask—Python中的Web开发微框架...
- en: Defining the requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义需求
- en: The first part of building any enterprise-grade application is to define what
    the application aims to do. Up to now, we know that our application is going to
    track bugs for the various products that are marketed by the Omega Corporation.
    But what things are required from our application that will prove to be useful
    for bug tracking? Let's take a look and try to define the requirements for the
    application that we are going to build.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 构建任何企业级应用程序的第一步是定义应用程序的目标。到目前为止，我们知道我们的应用程序将跟踪Omega公司销售的各种产品的错误。但是，我们的应用程序需要什么功能来进行错误跟踪呢？让我们来看一看，并尝试定义我们将要构建的应用程序的需求。
- en: '**Support for multiple products**: One of the fundamental requirements for
    our bug tracking system is to support the tracking of bugs for multiple products
    that the organization builds. This is also a required feature considering the
    future growth of the organization.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持多个产品**：我们的错误跟踪系统的一个基本要求是支持组织构建的多个产品的错误跟踪。考虑到组织的未来增长，这也是一个必需的功能。'
- en: '**Support for multiple components per product**: Although we can file the bugs
    at the product level itself, it will be too clumsy, specifically considering that
    most of the organizations have a separate team working on orthogonal features
    of a product. To make the tracking of bugs easier based on which component they
    have been filed, the bug tracking system should support the filing of bugs on
    a component to component basis.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持产品的多个组件**：虽然我们可以在产品级别上报告错误，但这将会太笨重，特别是考虑到大多数组织都有一个专门负责产品正交特性的团队。为了更容易地跟踪基于已提交的组件的错误，错误跟踪系统应支持基于组件的错误报告。'
- en: '**Support for attachments**: Many a time, the users filing a bug, or the ones
    involved in any way in the bug life cycle, might want to attach images showing
    the effect of the bug, or may want to attach patches to the bug so they can be
    tested before being incorporating into the product. This will require the bug
    tracking system to provide support for attaching files to the bug reports.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**附件支持**：很多时候，提交错误的用户，或者在错误生命周期中以任何方式参与的用户，可能希望附加显示错误效果的图像，或者可能希望附加错误的补丁，以便在合并到产品之前进行测试。这将需要错误跟踪系统提供支持，以将文件附加到错误报告中。'
- en: '**Support for comments**: Once the bug has been filed, a user who is responsible
    for solving that bug might require some other information about the bug, or may
    require some collaboration. This makes it compulsory for the bug tracking system
    to have support for comments. Also, not every comment can be made public. For
    example, if there is some patch that the developers might have attached to the
    bug report to be tested by the original submitter of the bug, but which has not
    yet been incorporated into the main product, the developers might want to keep
    the patch private, so that it can be seen only by people with privileged access.
    This makes the inclusion of functionality for private comments also a necessity.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持评论**：一旦提交了bug，负责解决该bug的用户可能需要有关该bug的其他信息，或者可能需要一些协作。这使得缺陷跟踪系统必须支持评论成为必须。此外，并非每条评论都可以公开。例如，如果开发人员可能已经附加到bug报告中以供原始提交者测试但尚未纳入主产品的补丁，开发人员可能希望保持补丁私有，以便只有特权访问的人才能看到。这也使得私人评论的功能的包含成为必要。'
- en: '**Support for multiple user roles**: Not everyone in the organization has the
    same level of access to the bug tracking system. For example, only people at the
    director level should be able to add new components to a product, and only employees
    should be able to see private comments on a bug. This calls for the inclusion
    of role-based access as a requirement for the system.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持多个用户角色**：组织中并非每个人对缺陷跟踪系统都具有相同级别的访问权限。例如，只有主管级别的人才能向产品添加新组件，只有员工才能看到bug的私人评论。这要求系统包含基于角色的访问权限作为要求。'
- en: 'These are some of the requirements that are specific to our bug tracking system.
    However, as a consequences of these, there are a few more requirements that obviously
    need to be included in the system. Some of these requirements are:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们的缺陷跟踪系统特定的一些要求。然而，由于这些，显然还有一些其他要求需要包含在系统中。其中一些要求是：
- en: '**Requirement for a user authentication system**: The system should provide
    a mechanism for authenticating the users based on some simple mechanism. For example,
    a user should be able to sign into the system by providing their username and
    password, or email id and password combination.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户认证系统的要求**：系统应该提供一种根据一些简单机制对用户进行认证的机制。例如，用户应该能够通过提供他们的用户名和密码，或者电子邮件和密码组合来登录系统。'
- en: '**Web interface for filing a new bug**: The application should provide a simple
    to use web interface that can be used by the users to file new bugs.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用于提交新bug的Web界面**：应用程序应该提供一个简单易用的Web界面，用户可以用来提交新的bug。'
- en: '**Support for bug life cycle**: Once a bug has been filed into the system,
    its life cycle starts in the NEW state. From there it may move on to the ASSIGNED
    state, when someone from the organization picks up the bug for validation and
    reproduction. From there, the bug can move into various states. This is known
    as a bug life cycle inside our tracking system. Our bug tracking system should
    provide the support for this life cycle, and how to handle it when the bug moves
    from one state to another.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持bug生命周期**：一旦bug被提交到系统中，它的生命周期就从NEW状态开始。从那里，它可能转移到ASSIGNED状态，当组织中的某人接手验证和重现bug时。从那里，bug可以进入各种状态。这被称为我们跟踪系统内的bug生命周期。我们的缺陷跟踪系统应该支持这种生命周期，并且应该如何处理当bug从一个状态转移到另一个状态。'
- en: So, with this, we finally have our requirements in place. These requirements
    play an important role when we move onto designing and defining how our bug tracking
    web application will be built. So, with the requirements in place, it's time for
    us to move onto defining how our code base will look.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们终于把我们的需求摆在了这里。当我们开始设计和定义我们的缺陷跟踪网络应用程序的构建方式时，这些需求将发挥重要作用。因此，有了需求，现在是时候开始定义我们的代码基础是什么样子了。
- en: Entering the development phase
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入开发阶段
- en: With our project structure defined and in place, it's time for us to get up
    and start developing our application. The development phase involves various steps,
    which include setting up the development environment, developing models, creating
    views that map to the models, and setting up the server.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的项目结构定义并就位，现在是时候站起来开始开发我们的应用程序了。开发阶段涉及各种步骤，包括设置开发环境，开发模型，创建与模型相对应的视图，并设置服务器。
- en: Setting up the development environment
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立开发环境
- en: The first step before we begin our development is to set up our development
    environment. This involves getting the required packages in place, and setting
    up the environment.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始开发之前的第一步是建立我们的开发环境。这涉及到准备好所需的软件包，并设置环境。
- en: Setting up the database
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立数据库
- en: 'Our web application relies heavily on the database for managing the individual
    records related to the users and the bugs that have been filed. For the demo application,
    we will set back with the PostgreSQL as the choice for our database. To install
    it on an RPM-based distribution, such as Fedora, the following command needs to
    be executed:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Web应用程序在管理与用户和已提交的bug相关的个人记录方面严重依赖数据库。对于演示应用程序，我们将选择PostgreSQL作为我们的数据库。要在基于RPM的发行版上安装它，例如Fedora，需要执行以下命令：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To install `postgresql` on any other distribution of Linux or any other operating
    system like Windows or Mac OS, the required commands for the distribution/OS will
    need to be executed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Linux的任何其他发行版或Windows或Mac OS等其他操作系统上安装`postgresql`，需要执行分发/操作系统的必需命令。
- en: Once we have the database installed, the next step is to initialize the database
    so that it can be used to store our application data. For setting ...
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了数据库，下一步就是初始化数据库，以便它可以用来存储我们的应用程序数据。用于设置...
- en: Setting up the virtual environment
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立虚拟环境
- en: 'Now with the database in place, let''s set up the virtual environment, which
    we will use for the purpose of application development. To set up the virtual
    environment, let''s run the following commands:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据库已经就位，让我们设置虚拟环境，这将用于应用程序开发的目的。为了设置虚拟环境，让我们运行以下命令：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command will set up a virtual environment in our current directory. The
    next thing after the virtual environment is set up is to install the required
    framework for the application development and other packages.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将在我们当前的目录中设置一个虚拟环境。设置虚拟环境之后的下一步是安装应用程序开发所需的框架和其他包。
- en: 'However, before we move on to installing the required packages, let''s just
    first activate our virtual environment by executing the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在继续安装所需的包之前，让我们首先通过执行以下命令激活我们的虚拟环境：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As a design decision, we will base our application on the Python Flask micro
    framework for web application development. The framework is an open source framework,
    which has been around for quite some years and enjoys the support of various plugins
    that can be easily installed along with the framework. The framework also is a
    very light framework, which comes with bare minimum set of modules pre-packaged,
    hence allowing for a smaller footprint. To install `flask`, execute the following
    command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个设计决策，我们将基于Python Flask微框架进行Web应用程序开发。这个框架是一个开源框架，已经存在了相当多年，并且得到了各种插件的支持，这些插件可以很容易地与框架一起安装。该框架也是一个非常轻量级的框架，它只带有最基本的预打包模块，因此允许更小的占用空间。要安装`flask`，执行以下命令：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once we have Flask installed, let''s move onto setting up a few other required
    packages that we are going to use in the development of our web application by
    executing the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了Flask，让我们继续设置我们将在Web应用程序开发中使用的其他一些必需的包，通过执行以下命令：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this, we are now done with the setup of our virtual environment. Now, let's
    move onto setting up how our code base will look.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在已经完成了虚拟环境的设置。现在，让我们继续设置我们的代码库将是什么样子。
- en: Structuring our project
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的项目
- en: Now, we are at a stage where we need to decide how our project structure will
    look. The project structure has a lot of importance, since it decides how the
    different components in our code will interact with each other and what point
    will mark the entry point of our application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们处于一个需要决定我们的项目结构将是什么样子的阶段。项目结构非常重要，因为它决定了我们代码中不同组件之间的交互方式，以及什么地方将标志着我们应用程序的入口点。
- en: A well-structured project will not only help in providing a better navigation
    for the project, but will also help in providing increased coherency between different
    parts of the code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个结构良好的项目不仅有助于为项目提供更好的导航，而且还有助于提供代码不同部分之间的增强一致性。
- en: 'So, let''s take a look at how our code structure will look and understand the
    significance of what a particular directory or file stands for:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们来看看我们的代码结构将是什么样子，并理解特定目录或文件的意义：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Initializing the Flask project
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化Flask项目
- en: So, we are finally entering the fun phase of our project where we will be building
    this project from scratch. So, let's not wait too long before we can see some
    action. The first thing we will do is to set up a basic project with Flask and
    get it running. To do this, let's fire up our code editor and set up our initial
    code base.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们终于进入了项目的有趣阶段，我们将从头开始构建这个项目。所以，让我们不要等太久，我们就可以看到一些行动。我们要做的第一件事是使用Flask设置一个基本项目并让它运行起来。为了做到这一点，让我们启动我们的代码编辑器并设置我们的初始代码库。
- en: 'Let''s open up the file `bugzot/application.py` and initialize our application
    code base:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开文件`bugzot/application.py`并初始化我们的应用程序代码库：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we have completed the very basic setup of our application. Let's spend
    some time trying to understand what we did here.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了应用程序的非常基本的设置。让我们花一些时间来理解我们在这里做了什么。
- en: At the very start of the file, we first imported the required packages over
    which we will be building our project. We imported the `Flask` application class
    from the package `flask`. Similarly, we import the code hashing library `bcrypt`,
    the `Flask` session class, and the SQLAlchemy support package for Flask, which
    provides SQLAlchemy integration with Flask.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的开头，我们首先导入了我们将要构建项目的所需包。我们从`flask`包中导入`Flask`应用程序类。类似地，我们导入了代码哈希库`bcrypt`，`Flask`会话类，以及用于Flask的SQLAlchemy支持包，它提供了与Flask的SQLAlchemy集成。
- en: Once we have imported all the required packages, the next thing is to initialize
    our Flask application. To do this, we create an instance of `Flask` class and
    store it in an object named `app`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导入了所有必需的包，下一步就是初始化我们的Flask应用程序。为此，我们创建一个`Flask`类的实例，并将其存储在一个名为`app`的对象中。
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: While creating this instance, we pass the class constructor two parameters.
    The first parameter is used to signify the name of the application to Flask. `__name__`
    provides, which we pass as the application name to the constructor. The second
    parameter, `instance_relative_config` allows us to override the application configuration
    from an instance folder.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这个实例时，我们向类构造函数传递了两个参数。第一个参数用于表示Flask的应用程序名称。`__name__`提供了我们传递给构造函数的应用程序名称。第二个参数`instance_relative_config`允许我们从实例文件夹中覆盖应用程序配置。
- en: 'With this, we have our Flask application instance setup done. Next thing inline
    is to load up the configuration for the application, which will be used to configure
    how the different components inside our application behave, and how our application
    will be served to the user. To do this, we need to read from our configuration
    file. The following two lines achieve this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的Flask应用程序实例设置就完成了。接下来要做的是加载应用程序的配置，这将用于配置应用程序内部不同组件的行为，以及我们的应用程序将如何提供给用户。为了做到这一点，我们需要从配置文件中读取。以下两行实现了这一点：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first line loads up our `config.py` file under the project root, treats
    it as an object, and loads up its configuration. The second line is responsible
    for reading the `config.py` file under the instance directory and loading any
    configuration that may be present there.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行加载了我们项目根目录下的`config.py`文件，将其视为一个对象，并加载了它的配置。第二行负责读取实例目录下的`config.py`文件，并加载可能存在的任何配置。
- en: Once these configurations are loaded, they are available under the `app.config`
    object. Most of the Flask plugins are configured to read the configuration from
    the `app.config`, hence reducing the clutter that may happen if every plugin had
    a different mechanism for dealing with the configuration.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些配置加载完成，它们就可以在`app.config`对象下使用。大多数Flask插件都配置为从`app.config`读取配置，因此减少了可能发生的混乱，如果每个插件都有不同的配置处理机制。
- en: 'With our configuration loaded up inside our application, we can now move on
    to initialize the remaining modules that we may require. In particular, we require
    a few more modules to establish our application functionality. These modules include
    the SQLAlchemy engine, which we will use to build and interact with our database
    models, a sessions module, which will be required to manage user sessions across
    the application, and a `bcrypt` module, which will be required to provide encryption
    support across the application. The following lines of code provide this functionality:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中加载配置后，我们现在可以继续初始化我们可能需要的其余模块。特别是，我们需要一些额外的模块来建立我们的应用程序功能。这些模块包括SQLAlchemy引擎，我们将使用它来构建和与我们的数据库模型交互，一个会话模块，它将被用来管理应用程序中的用户会话，以及一个`bcrypt`模块，它将被用来在整个应用程序中提供加密支持。以下代码提供了这些功能：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see from these lines of code, to configure these modules, all we needed
    to do was pass the Flask application object as a parameter to the respective class
    constructors and their configuration will be picked up from there itself.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些代码行中可以看出，要配置这些模块，我们所需要做的就是将Flask应用程序对象作为参数传递给各自的类构造函数，它们的配置将从那里自动获取。
- en: Now, we have our application initialization code in place, the next thing we
    need to do is to export the required components from our BugZot module so the
    application can be called from the project root.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将应用程序初始化代码放在了适当的位置，我们需要做的下一件事是从我们的BugZot模块中导出所需的组件，以便可以从项目根目录调用应用程序。
- en: To achieve this, all we need to do is to get these modules included in the module
    entry point. So, let's fire up the code editor and open `bugzot/__init__.py` where
    we need to get these objects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要做的就是将这些模块包含在模块入口点中。所以，让我们打开代码编辑器，打开`bugzot/__init__.py`，我们需要在那里获取这些对象。
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And we are done. We have all the required objects exported in our BugZot module.
    Now, the question is how to launch our application. So, to launch our application
    and make it serve the incoming requests, we need to complete a few more steps.
    So, let''s open up the `run.py` file inside our project root and add the following
    lines to it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们完成了。我们已经在BugZot模块中导出了所有必需的对象。现在，问题是如何启动我们的应用程序。因此，为了启动我们的应用程序并使其提供传入的请求，我们需要完成一些更多的步骤。所以，让我们打开项目根目录下的`run.py`文件，并添加以下行：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: And we are done. Wasn't that simple? All we did here was to import the `flask`
    app object we created inside our BugZot module and call the `run` method of the
    `app` object passing it the value for the `hostname` on which the application
    will be serving the users, and the port on which the application server should
    bind to listen to the requests.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，是不是很简单？我们在这里所做的就是导入我们在BugZot模块中创建的`flask`应用对象，并调用`app`对象的`run`方法，将应用程序将要提供给用户的`hostname`值和应用程序服务器应该绑定以监听请求的端口值传递给它。
- en: We are now all set to start our application server and make it listen to the
    incoming requests. However, before we do that, we need to just complete one more
    step, which is to create the configuration for the application. So, let's get
    going and create the configuration.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好启动我们的应用程序服务器，并使其监听传入的请求。但是，在我们这样做之前，我们只需要完成一个步骤，即创建应用程序的配置。所以，让我们开始并创建配置。
- en: Creating the configuration
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建配置
- en: 'Before we can start our application, we need to configure our modules that
    we are going to use in our application. So, let''s first go ahead and create the
    global configuration of our application by opening up `config.py` in our code
    editor and adding the following content to it:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们启动应用程序之前，我们需要配置我们将在应用程序中使用的模块。因此，让我们首先打开代码编辑器中的`config.py`，并向其中添加以下内容，以创建我们应用程序的全局配置：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With this, we have drafted our global application configuration. Let's try to
    ...
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经起草了全局应用程序配置。让我们尝试...
- en: Developing database models
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发数据库模型
- en: The database model forms an integral part of any real life application. This
    is because any serious application in enterprises will for sure be dealing with
    some kind of data that needs to be persisted across the time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库模型构成了任何现实生活应用程序的重要部分。这是因为企业中的任何严肃应用程序肯定会处理需要在时间跨度内持久化的某种数据。
- en: The same is the case for our BugZot. BugZot is used to track the bugs and their
    life cycle that are encountered in the products of Omega Corporation. Also, the
    application will have to keep a record of users that are registered on it. To
    achieve this, we will require multiple models, each serving its own purpose.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的BugZot也是一样的。BugZot用于跟踪Omega Corporation产品中遇到的错误及其生命周期。此外，应用程序还需要记录在其上注册的用户。为了实现这一点，我们将需要多个模型，每个模型都有自己的用途。
- en: For the development of this application, we will group all the related models
    under their own separate directories, so that we can maintain the clarity about
    which models serves what purpose. Also, this allows us to keep the code base clean
    from clutter, which may make it hard for the developers to understand what each
    file does as the code base grows in the future.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发这个应用程序，我们将所有相关的模型分组到它们自己的单独目录下，这样我们就可以清楚地知道每个模型的作用是什么。这也让我们能够保持代码库的整洁，避免开发人员在未来难以理解每个文件的作用。
- en: So, let's first get started with the development of the models that are required
    to manage the user accounts-related information.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先开始开发管理用户账户相关信息所需的模型。
- en: 'To get started with the development of the user account-related models, we
    first go on and create a directory named `users` inside our models directory:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始开发与用户账户相关的模型，我们首先创建一个名为`users`的目录，放在我们的模型目录下：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then initialize it as a submodule inside the models module.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其初始化为模型模块的子模块。
- en: 'Once we are done with this, we are good to go with the creation of our user
    model whose definition is shown in the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这一点，我们就可以开始创建我们的用户模型，其定义如下所示：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With this, we just created our user model that can be used to store the information
    related to our users. Most of the columns just provide the definitions for the
    data that we expect to store inside the database. However, there are a couple
    of interesting bits here, so let''s go through them:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们刚刚创建了我们的用户模型，可以用来存储与用户相关的信息。大多数列只是提供了我们期望存储在数据库中的数据的定义。然而，这里有一些有趣的地方，让我们来看看：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can see this attribute is mentioned in the username and the email column
    definition. We set the index attribute to True in the two columns because these
    two columns can be used frequently to access the data related to a particular
    user, and hence can benefit from the added optimization that comes with indexing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个属性在用户名和电子邮件列的定义中被提及。我们将索引属性设置为True，因为这两列经常被用来访问与特定用户相关的数据，因此可以从索引带来的优化中受益。
- en: The next interesting piece of information here is the relationship mapping to
    the roles model.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的下一个有趣的信息是与角色模型的关系映射。
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since every user inside our database has a role associated to it, we can just
    add a one to one relationship mapping from our user model to the role model. Also,
    if we take a look carefully, we have set `lazy=False`. There is a small reason
    why we want to avoid lazy loading here. The roles model is usually small, and
    there is only a one-to-one mapping from the users model to the role model. By
    avoiding lazy loading, we are shedding off some time that would have been spent
    in waiting, had our database access layer lazily loaded the data from the roles
    model. Now, the question arises, where is the role model?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们数据库中的每个用户都有一个与之关联的角色，我们可以从我们的用户模型到角色模型添加一个一对一的关系映射。此外，如果我们仔细看，我们设置了`lazy=False`。我们之所以要避免懒加载，有一个小原因。角色模型通常很小，而且用户模型到角色模型只有一个一对一的映射。通过避免懒加载，我们节省了一些时间，因为我们的数据库访问层不再懒加载来自角色模型的数据。现在，问题是，角色模型在哪里？
- en: The definition of the role model can be found under the `bugzot/models/users/roles.py`
    file, but we explicitly are not providing that definition here inside the book,
    to keep the chapter concise.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 角色模型的定义可以在`bugzot/models/users/roles.py`文件中找到，但我们明确地没有在书中提供该定义，以保持章节简洁。
- en: Also, we need a mechanism for verifying the email address of the users. We can
    do this by sending the users a small email containing an activation link, which
    they need to click. To do this, we also have to generate and store an activation
    key for every new user. For this, we leverage a new model named `ActivationKey`
    model whose definition can be found under the `bugzot/models/users/activation_key.py`
    file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要一种机制来验证用户的电子邮件地址。我们可以通过发送包含激活链接的小邮件给用户来实现这一点，他们需要点击该链接。为此，我们还需要为每个新用户生成并存储一个激活密钥。为此，我们利用了一个名为`ActivationKey`模型的新模型，其定义可以在`bugzot/models/users/activation_key.py`文件中找到。
- en: 'Once all of this is done, we are now ready to export these models out of our
    users model submodule. To do this, let''s fire up the module entrypoint file inside
    our code editor and export the models by adding the following lines to the `bugzot/models/users/__init__.py`
    file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有这些都完成了，我们现在可以准备将这些模型从用户模型子模块中导出。为了做到这一点，让我们打开代码编辑器中的模块入口文件，并通过向`bugzot/models/users/__init__.py`文件添加以下行来导出模型：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With this, we are done with the definition of our data models related to storing
    the information about the users.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们完成了与存储用户信息相关的数据模型的定义。
- en: The next thing inside our application is to define data models related to the
    categorization of the products for which the bugs can be filed. So, let's jump
    into the creation of the models related to the product categorization.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中的下一件事是定义与产品分类相关的数据模型，用于对可以提交bug的产品进行分类。因此，让我们开始创建与产品分类相关的模型。
- en: 'For creating the models related to the products, we first create a new submodule
    directory under the `bugzot/models` module and initialize it. Next, we provide
    the definition for the product model under `bugzot/models/products/products.py`
    as shown in the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建与产品相关的模型，我们首先在`bugzot/models`模块下创建一个新的子模块目录并进行初始化。接下来，我们在`bugzot/models/products/products.py`下提供产品模型的定义，如下所示：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With this a we have completed the definition of the product model that will
    be used to keep a track of the products, against which the bugs can be filed in
    our application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经完成了产品模型的定义，该模型将用于跟踪产品，用户可以在我们的应用程序中提交bug。
- en: 'There are a few more model definitions inside our products submodule as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的产品子模块中还有一些其他模型定义，如下所示：
- en: '**Category**: The category model is responsible for storing the information
    about the product categories to which a particular product belongs'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别**：类别模型负责存储关于特定产品所属的产品类别的信息'
- en: '**Component**: The component model is responsible for storing the information
    related to the product components against which a bug can be filed'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**：组件模型负责存储与产品组件相关的信息，其中一个错误可以被归类'
- en: '**Version**: The version model is responsible for storing the information related
    to the product versions against which a bug can be categorised'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本**：版本模型负责存储与产品版本相关的信息，其中一个错误可以被分类'
- en: Once all these models are defined, they can be exported out from the product's
    submodule so that they can be utilized inside the application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有这些模型被定义，它们就可以从产品的子模块中导出，以便在应用程序中使用。
- en: In a similar manner, we define the models related to the tracking of the bugs
    inside the system. We will skip over mentioning the definition of these models
    inside this chapter to keep the chapter length reasonable, but, for the curious
    mind, the definitions of these models can be easily tracked inside the `bugzot/models/bugs`
    directory in the code repository for this chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们定义了与系统内错误跟踪相关的模型。我们将跳过在本章节中提及这些模型的定义，以保持章节长度合理，但是，对于好奇的人来说，这些模型的定义可以很容易地在代码库中的`bugzot/models/bugs`目录中找到。
- en: Migrating the database models
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移数据库模型
- en: With our database models created and ready for use, the next thing is to migrate
    these database models to the database server that we are using to run the application.
    The process to do this is quite straightforward.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们创建的数据库模型并准备好使用，下一步是将这些数据库模型迁移到我们用来运行应用程序的数据库服务器。这个过程非常简单。
- en: 'To migrate the models to the database server, we first expose them into the
    application root. For example, to migrate the database models related to the users
    and products, all we need to do is to add the following line to the `bugzot/__init__.py`
    file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要将模型迁移到数据库服务器，我们首先将它们暴露到应用程序根目录中。例如，要迁移与用户和产品相关的数据库模型，我们只需要在`bugzot/__init__.py`文件中添加以下行：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once this is done, all we need to do is to call the `create_all()` method of
    the SQLAlchemy database object we created. This can be done by adding the following
    ...
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们只需要调用我们创建的SQLAlchemy数据库对象的`create_all()`方法。这可以通过添加以下...来完成
- en: Building the views
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建视图
- en: Once the models are generated and are ready for use, the next thing we require
    is to have a mechanism through which we can interact with these models in order
    to access or modify them. One of the ways through which we can achieve this functionality
    is through the use of views.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模型生成并准备就绪，我们需要的下一步是拥有一种机制，通过该机制我们可以与这些模型进行交互，以便访问或修改它们。我们可以通过视图的使用来实现这种功能的一种方式。
- en: With Flask, building the views is quite an easy task. The Flask web framework
    provides multiple methods for building views. Indeed, the `/ping` endpoint could
    also be termed as one of the views only which was built using a procedural style.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Flask，构建视图是相当容易的任务。Flask Web框架提供了多种构建视图的方法。事实上，`/ping`端点也可以被称为使用过程式风格构建的视图之一。
- en: Over the course of the example, we will now try to follow object oriented methodology
    while defining any of the resources in the application. So, let's move on and
    start developing some of our views.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例过程中，我们现在将尝试在定义应用程序中的任何资源时遵循面向对象的方法。因此，让我们继续并开始开发一些视图。
- en: Developing the index view
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发索引视图
- en: Whenever a user visits our application, most likely it will be the case that
    the user will be landing on the home page of the application. So, the first thing
    we build is the index view. This will also be one of the places where we can understand
    how to build simple views in Flask.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户访问我们的应用程序时，很可能用户会登陆到应用程序的主页上。因此，我们首先构建的是索引视图。这也是我们可以了解如何在Flask中构建简单视图的地方之一。
- en: 'So, as the first step, let''s create a new module inside the views directory
    of our project workspace for the index module by executing the following commands:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为第一步，让我们通过执行以下命令在项目工作空间的视图目录中创建一个新模块，用于索引模块：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With this, we are now ready to code our first view, the code for which follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在准备编写我们的第一个视图，其代码如下：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Getting the index view to render
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取索引视图以渲染
- en: 'Now, we have the index view ready. But, before this view can be served to the
    user, we need to provide Flask with a mapping about the endpoint on which this
    view will be rendered. To achieve this, let''s fire up our code editor and open
    `bugzot/__init__.py` and add the following lines to the file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了索引视图。但是，在此视图可以提供给用户之前，我们需要为Flask提供有关此视图将被渲染的端点的映射。为了实现这一点，让我们打开我们的代码编辑器并打开`bugzot/__init__.py`文件，并向文件中添加以下行：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, our focus is on the second line, which is responsible for mapping our
    view with a URL endpoint. The `add_url_rule()` of our flask application is the
    one that is responsible for providing these mappings. The method takes as its
    first parameter the URL path on which the view should be rendered. The `view_func`
    parameter provided to the method takes in the view that needs to be rendered on
    the provided URL endpoint.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们的重点是第二行，它负责将我们的视图与URL端点进行映射。我们的Flask应用程序的`add_url_rule()`负责提供这些映射。该方法的第一个参数是视图应该在其上呈现的URL路径。提供给该方法的`view_func`参数接受需要在提供的URL端点上呈现的视图。 '
- en: 'Once this is done, we are now ready to serve our index page. All we need to
    do now is to run the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们现在准备好提供我们的索引页面。现在我们只需要运行以下命令：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then visit [http://localhost:8000/](http://localhost:8000/) on your browser.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在浏览器上访问[http://localhost:8000/](http://localhost:8000/)。
- en: Building the user registration view
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用户注册视图
- en: Now, with the index view deployed and ready for use, let's move on to building
    a more complicated view where we allow the users to register on BugZot.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，部署并准备好使用的索引视图，让我们继续构建一个更复杂的视图，在这个视图中，我们允许用户在BugZot上注册。
- en: The following code implements a view known as `UserRegisterView`, which will
    allow the users to register to BugZot.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了一个名为`UserRegisterView`的视图，允许用户注册到BugZot。
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Deploying for concurrent access
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署以处理并发访问
- en: Until now, we were in the development stage and we could easily use the development
    server that comes packaged with Flask to quickly test our changes. But this development
    server is not a good choice if you are planning to run the application in production,
    and we need something more dedicated for that. This is because, in a production
    environment, we will be more concerned about the concurrency of the application,
    as well as its security aspects, like enabling SSL and providing more restricted
    access to some of the endpoints.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们处于开发阶段，可以轻松使用Flask自带的开发服务器快速测试我们的更改。但是，如果您计划在生产环境中运行应用程序，这个开发服务器并不是一个好选择，我们需要更专门的东西。这是因为在生产环境中，我们将更关注应用程序的并发性，以及其安全方面，比如启用SSL并为一些端点提供更受限制的访问。
- en: So, we need to figure out some choices here based on the fact that we need our
    application to handle a lot of concurrent accesses, while constantly maintaining
    a good response time for the users.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要根据我们的应用需要处理大量并发访问的事实，同时不断保持对用户的良好响应时间，来确定一些选择。
- en: 'With this in mind, we end up with the following set of choices, which, by their
    nature are also fairly common in many production environments:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们最终得到了以下一系列选择，它们的性质在许多生产环境中也是相当常见的：
- en: '**Application server**: Gunicorn'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用服务器**：Gunicorn'
- en: '**Reverse Proxy**: Nginx'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反向代理**：Nginx'
- en: Here, Gunicorn will be the application that will be responsible for handling
    the requests that are to be served by our Flask application, while Nginx takes
    care of request queuing and handling the distribution of the static assets.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Gunicorn将负责处理由我们的Flask应用程序提供的请求，而Nginx负责请求排队和处理静态资产的分发。
- en: So, first, let's set up Gunicorn and how we are going to serve the application
    through it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，首先，让我们设置Gunicorn以及我们将如何通过它提供应用程序。
- en: Setting up Gunicorn
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Gunicorn
- en: 'The first step that is involved in the setup of Gunicorn is its installation,
    which is quite an easy task. All we need to do is run the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Gunicorn的第一步是安装，这是一个相当简单的任务。我们只需要运行以下命令：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once this is done, we have Gunicorn available to be run. Gunicorn runs the
    application through **WSGI**, which stands for Web Server Gateway Interface. For
    Gunicorn to run our application, we need to create an additional file in our project
    workspace, known as `wsgi.py`, with the following contents:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成了这一步，我们就可以运行Gunicorn了。Gunicorn通过**WSGI**运行应用程序，WSGI代表Web服务器网关接口。为了让Gunicorn运行我们的应用程序，我们需要在项目工作空间中创建一个名为`wsgi.py`的额外文件，内容如下：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once we have defined the interface file, all we need to do is to run the following
    command to make Gunicorn ...
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了接口文件，我们只需要运行以下命令来使Gunicorn...
- en: Setting up Nginx as reverse proxy
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Nginx作为反向代理
- en: 'To use Nginx as our reverse proxy solution, we first need to get it installed
    on our system. For Fedora-based distributions, this can be easily installed by
    using the `dnf` or `yum` based package manager by running the following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Nginx用作我们的反向代理解决方案，我们首先需要在系统上安装它。对于基于Fedora的发行版，可以通过使用`dnf`或`yum`软件包管理器轻松安装，只需运行以下命令：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For other distributions, their package managers can be used to install the Nginx
    package.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他发行版，可以使用它们的软件包管理器来安装Nginx软件包。
- en: Once the Nginx package is installed, we now need to do its configuration to
    allow it to communicate with our application server.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Nginx软件包后，我们现在需要进行配置，以使其能够与我们的应用服务器进行通信。
- en: 'To configure Nginx to proxy the communication to our application server, create
    a file named `bugzot.conf` under the `/etc/nginx/conf.d` directory, with the following
    contents:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置Nginx将通信代理到我们的应用服务器，创建一个名为`bugzot.conf`的文件，放在`/etc/nginx/conf.d`目录下，内容如下：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now with the Nginx configured, we need to establish a relationship between our
    Gunicorn application server and Ngnix. So, let's do it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Nginx配置完成后，我们需要建立我们的Gunicorn应用服务器和Ngnix之间的关系。所以，让我们来做吧。
- en: Establishing communication between Nginx and Gunicorn
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立Nginx和Gunicorn之间的通信
- en: 'One thing to note inside the Nginx configuration that we just completed was
    the `proxy_pass` line:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚完成的Nginx配置中需要注意的一点是`proxy_pass`行：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The line tells Nginx to look for a socket file through which Nginx can communicate
    to the application server. We can tell Gunicorn to create this proxy file for
    us. This can be done by executing the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这行告诉Nginx查找一个套接字文件，通过它Nginx可以与应用服务器通信。我们可以告诉Gunicorn为我们创建这个代理文件。执行以下命令即可完成：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After executing this command, our Gunicorn web server will create a Unix socket
    and bind to it. Now, all that is remaining is to start our Nginx web server, which
    can be easily achieved by executing the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，我们的Gunicorn Web服务器将创建一个Unix套接字并绑定到它。现在，剩下的就是启动我们的Nginx Web服务器，只需执行以下命令即可轻松实现：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Once this is done, ...
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成了这一步，...
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we gained hands-on experience of how we can develop and host
    an enterprise-scale web application. To achieve this, we first started by making
    some technology decisions about which web frameworks and databases we were going
    to use. We then progressed to defining our project structure and how it will look
    on disk. The main aim was to achieve high modularity and less coupling between
    code. Once the project structure was defined, we then initialized a simple Flask
    application and implemented a route to check whether our server worked fine or
    not. We later progressed on to defining our models and views. Once these were
    defined, we altered our application to enable new routes that provide access to
    our views. Once our application development cycle was over, we then moved on to
    understanding how an application can be deployed using Gunicorn and Nginx to handle
    a large number of requests.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们获得了如何开发和托管企业级网络应用程序的实际经验。为了实现这一目标，我们首先做出了一些关于要使用哪些网络框架和数据库的技术决策。然后，我们继续定义我们的项目结构以及它在磁盘上的外观。主要目标是实现高度模块化和代码之间的耦合度较低。一旦项目结构被定义，我们就初始化了一个简单的Flask应用程序，并实现了一个路由来检查我们的服务器是否正常工作。然后，我们继续定义我们的模型和视图。一旦这些被定义，我们就修改了我们的应用程序，以启用提供对我们视图的访问的新路由。一旦我们的应用程序开发周期结束，我们就开始了解如何使用Gunicorn和Nginx部署应用程序以处理大量请求。
- en: Now as we move on to the next chapter, we will take a look at how we can work
    on to develop an optimized frontend for the applications we are developing and
    how can a frontend affect the experience of the user while interacting with our
    application.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们进入下一章时，我们将看看如何开发优化的前端，以适应我们正在开发的应用程序，并且前端如何影响用户与我们的应用程序交互时的体验。
- en: Questions
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are some of the other pre-built view classes provided by Flask?
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask提供了哪些其他预构建的视图类？
- en: Can we remove the foreign key constraint to role table from our user table without
    removing the relationship?
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能否在不删除关系的情况下从用户表中删除到角色表的外键约束？
- en: What are the other options apart from Gunicorn for serving the application?
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了Gunicorn之外，还有哪些用于提供应用程序的其他选项？
- en: How can we increase the number of Gunicorn workers?
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何增加Gunicorn工作进程的数量？
