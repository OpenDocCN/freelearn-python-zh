- en: Chapter 9. Imagining Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 想象中的图像
- en: We work with images almost on a daily basis. Uploading images to your Facebook
    profile page, or manipulating images while developing your mobile or web applications;
    there are abundant use cases. With so many advancements in the field of computer
    vision, imaging has become a critical field. Working with images is trivial with
    Python.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎每天都在处理图像。上传图像到您的Facebook个人资料页面，或者在开发移动或Web应用程序时操作图像；有大量的用例。随着计算机视觉领域的众多进步，成像已经成为一个关键领域。使用Python处理图像变得非常简单。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Converting images
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换图像
- en: Resizing, cropping, and generating thumbnails
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整大小、裁剪和生成缩略图
- en: Copy-pasting and watermarking images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制粘贴和添加水印的图像
- en: Image differences and comparison
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像差异和比较
- en: Face detection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人脸检测
- en: Imaging as a business process
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成像作为业务流程
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Images in the electronic world are a series of bits comprised of 0s and 1s.
    They are an electronic snapshot of a scene or a document. Even paintings or photographs
    can be digitized to form images. Let's go deeper into images and understand how
    they're structured.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子世界中，图像是由0和1组成的位序列。它们是场景或文档的电子快照。即使是绘画或照片也可以数字化成图像。让我们深入了解图像，了解它们的结构。
- en: Every image is sampled and is represented by a grid of dots called **pixels**.
    These pixels represent the smallest controllable elements of a picture shown on
    the screen. The greater the number of pixels available in an image, the more accurate
    is the representation of the image on the device screen.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每张图像都被采样，并由称为**像素**的点阵表示。这些像素代表屏幕上显示的图片的最小可控元素。图像中可用的像素数量越多，设备屏幕上图像的表示就越准确。
- en: 'The intensity of each pixel is variable. In the digital world, the color of
    an image is represented by three or four intensities of different colors: **red,
    green, and blue** (**RGB**) or **cyan, magenta, yellow, and black** (**CMYK**),
    respectively. Computer programs often represent colors in RGBA format, where A
    stands for alpha (or the transparency of a color). Each pixel is represented in
    the binary representation in the RGBA format and is stored by the computer as
    a sequence. The computer then reads this sequence for display and, in some cases,
    converts it to its analog version for printing. Let''s look at specific image
    attributes in detail.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个像素的强度是可变的。在数字世界中，图像的颜色由三种或四种不同颜色的强度表示：**红色、绿色和蓝色**（**RGB**）或**青色、品红色、黄色和黑色**（**CMYK**）。计算机程序通常使用RGBA格式来表示颜色，其中A代表alpha（或颜色的透明度）。每个像素在RGBA格式中以二进制表示，并由计算机作为序列存储。然后计算机读取这个序列进行显示，在某些情况下，将其转换为打印的模拟版本。让我们详细看看一些特定的图像属性。
- en: Image attributes
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像属性
- en: 'Let''s have a look at some of the image attributes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些图像属性：
- en: '**Image size**: As you learned earlier, computer images are stored as a series
    of 0s and 1s and are measured in pixels (rectangular dots). The file size of an
    image is calculated based on the number of pixels it contains and the amount of
    color information that is stored. The file size is, in fact, the space taken up
    by the image on the computer hard drive.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像大小**：如您之前所学的，计算机图像以一系列0和1存储，并以像素（矩形点）为单位进行测量。图像的文件大小是根据它包含的像素数量和存储的颜色信息量来计算的。实际上，文件大小是图像在计算机硬盘上占用的空间。'
- en: '**Bit depth**: It is the number of bits used to indicate the color of a single
    pixel. This concept can be defined as the bits per pixel, which denotes the number
    of bits used to describe a pixel. The greater the bit depth of an image, greater
    the number of colors it can store. A 1-bit image can store only two (2^1) colors--0
    and 1--and is hence black and white in color. When compared with it, an 8-bit
    image can store 256 (2^8) colors.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位深度**：这是表示单个像素颜色的位数。这个概念可以定义为每像素位数，表示描述像素所使用的位数。图像的位深度越大，它可以存储的颜色就越多。一个1位图像只能存储两种（2^1）颜色--0和1--因此是黑白颜色。与之相比，一个8位图像可以存储256（2^8）种颜色。'
- en: '**Image resolution**: Resolution refers to the number of pixels in an image.
    Resolution is sometimes identified by the width and height of the image. For example,
    an image of 1,920 by 1,024 pixel resolution contains 1,966,080 pixels or is a
    1.9-megapixel image.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像分辨率**：分辨率是指图像中的像素数量。分辨率有时通过图像的宽度和高度来识别。例如，分辨率为1920 x 1024像素的图像包含1,966,080个像素，或是一个1.9兆像素的图像。'
- en: '**Image quality**: It can be changed based on the information an image stores.
    Not all images need to store all the pixels to represent an image. For instance,
    a continuous block of blue sea in a picture need not have all the pixels, and
    the image can be compressed to reduce the disk space of the image without compromising
    on the image quality. This reduction in disk space is termed as compression. A
    higher compression means noticeable loss of detail. A typical compression type
    used in today''s world is the JPG compression, which reduces the size and also
    sacrifices the image''s quality.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像质量**：它可以根据图像存储的信息进行更改。并非所有图像都需要存储所有像素来表示图像。例如，图片中连续的蓝色海洋区域不需要所有像素，并且图像可以被压缩以减少图像的磁盘空间，而不会影响图像质量。这种磁盘空间的减少被称为压缩。更高的压缩意味着细节的明显损失。在当今世界，典型的压缩类型是JPG压缩，它减少了图像的大小，同时也牺牲了图像的质量。'
- en: '**Image formats**: Images are stored in a computer with different extensions.
    Formats such as BMP or TIF are not compressed at all; hence, they occupy more
    disk space. Files such as JPG can be compressed and you can also choose the compression
    level. Hence, TIF images are lossless and JPG compression is termed as lossy compression.
    It is interesting to note that lossy compressions make use of humans'' inability
    to differentiate minor differences in shades. Multiple lossy conversions will
    result in image degradation, whereas multiple lossless conversions will preserve
    the image quality. But generally, it''s a trade-off between image degradation
    and size when it comes to compression.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像格式**：图像在计算机中以不同的扩展名存储。例如，BMP或TIF这样的格式根本不进行压缩；因此，它们占用更多的磁盘空间。例如，JPG这样的文件可以进行压缩，您还可以选择压缩级别。因此，TIF图像是无损的，而JPG压缩被称为有损压缩。值得注意的是，有损压缩利用了人类无法区分细微色调差异的能力。多次有损转换会导致图像退化，而多次无损转换将保留图像质量。但通常，在压缩时，是在图像退化和大小之间进行权衡。'
- en: OK, that's a good start. In this chapter, we will go through some more concepts
    of images and look at the various operations that you can perform on images with
    Python. We'll take a look at multiple modules that will help us manipulate images
    the way we need them. At the end of the chapter, we will also look at a typical
    business process that can be automated with the knowledge we built with the recipes
    covered in the chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是一个良好的开端。在本章中，我们将探讨更多关于图像的概念，并查看您可以使用Python在图像上执行的各种操作。我们将查看多个模块，这些模块将帮助我们以所需的方式操作图像。在本章结束时，我们还将探讨一个可以通过本章中涵盖的食谱所构建的知识自动化的典型业务流程。
- en: 'During the course of this chapter, we will use the following Python modules:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的进行过程中，我们将使用以下Python模块：
- en: '`Pillow` ([https://pypi.python.org/pypi/Pillow](https://pypi.python.org/pypi/Pillow))'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pillow` ([https://pypi.python.org/pypi/Pillow](https://pypi.python.org/pypi/Pillow))'
- en: '`scipy` ([https://www.scipy.org/](https://www.scipy.org/))'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scipy` ([https://www.scipy.org/](https://www.scipy.org/))'
- en: '`opencv` ([https://pypi.python.org/pypi/opencv-python](https://pypi.python.org/pypi/opencv-python))'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opencv` ([https://pypi.python.org/pypi/opencv-python](https://pypi.python.org/pypi/opencv-python))'
- en: Converting images
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换图像
- en: Let's begin our journey of images with simple examples. But before going on,
    let's build our virtual environment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以简单的示例开始我们的图像之旅。但在继续之前，让我们构建我们的虚拟环境。
- en: 'We will build the virtual environment using the `virtualenv` command and also
    activate it:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`virtualenv`命令构建虚拟环境，并激活它：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Nice! So, we now have an independent environment to work on our recipes for
    this chapter. For the first set of examples, we will use Python''s Pillow module.
    Let''s install this module first before going to the recipe. We will use our favorite
    `python-pip` to install the Pillow module:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了！因此，我们现在有一个独立的环境来处理本章的食谱。对于第一组示例，我们将使用Python的Pillow模块。在我们进入食谱之前，让我们先安装这个模块。我们将使用我们喜欢的`python-pip`来安装Pillow模块：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, we now have our environment, and the `Pillow` module is also installed.
    We're now ready to work with the recipe.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有了我们的环境，并且`Pillow`模块也已经安装。我们现在可以开始使用食谱工作了。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this section, we will deal with converting images to a different format.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将处理将图像转换为不同格式的问题。
- en: First, let's just download an image that can be used as a sample image to perform
    all our operations. I love sunsets and that's the reason I have used a sunset
    image for most of the recipes in this chapter. This is how it looks. I store it
    on my laptop and name it `beach_sunset.png`:![How to do it...](img/image_09_001.jpg)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们下载一个可以作为示例图像来执行所有操作的图像。我喜欢日落，这也是为什么我在本章的大部分食谱中使用了日落图像。这是它的样子。我把它存储在我的笔记本电脑上，命名为
    `beach_sunset.png`：![如何做...](img/image_09_001.jpg)
- en: 'Now, let''s go ahead and write the Python code to convert this image to the
    JPEG format. The following code does exactly what we need. We store the Python
    code in a file named `convert.py`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续编写将此图像转换为 JPEG 格式的 Python 代码。以下代码正好符合我们的需求。我们将 Python 代码存储在一个名为 `convert.py`
    的文件中：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you run this program with Python's `convert.py` command it will take the
    original PNG image, convert it into JPG format, and store it as `beach-susnset-conv.jpg`.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你用 Python 的 `convert.py` 命令运行此程序时，它将取原始 PNG 图像，将其转换为 JPG 格式，并存储为 `beach-susnset-conv.jpg`。
- en: 'Neat! Now, let''s perform one more operation on this image and convert it to
    grayscale (black and white format). It''s common for people to convert images
    to black and white format to give them a nostalgic look; this can be easily achieved
    with the following set of command lines:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真棒！现在，让我们对这个图像执行一个额外的操作，并将其转换为灰度图（黑白格式）。人们通常将图像转换为黑白格式，以赋予它们怀旧的外观；这可以通过以下一系列命令行轻松实现：
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, when you run this program, you will see another image generated on your
    disk, with the name `beach-sunset-gray.png`, which looks as follows:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，当你运行这个程序时，你将在磁盘上看到另一个生成的图像，其名称为 `beach-sunset-gray.png`，如下所示：
- en: '![How to do it...](img/image_09_002.jpg)'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/image_09_002.jpg)'
- en: 'Cool, let''s go further and perform a few more operations such as rotating
    and flipping the image. These actions are often used in fun websites where you
    can simply play around with your images. The following code will help you rotate
    the images by 180 degrees:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很酷，让我们更进一步，执行一些旋转和翻转图像的操作。这些动作通常用于有趣的网站，你可以简单地玩弄你的图像。以下代码将帮助你将图像旋转 180 度：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you run this code with our base image, you will see an image rotated by
    180 degrees, that is, the image is seen upside down, as shown here:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你用我们的基础图像运行此代码，你会看到一个旋转了 180 度的图像，即图像是颠倒的，如下所示：
- en: '![How to do it...](img/image_09_003.jpg)'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/image_09_003.jpg)'
- en: 'While rotating images is nice, it''d be awesome fun if we could flip the images.
    PIL doesn''t disappoint here and provides you with the options of flipping the
    images horizontally and vertically. The following code will help us perform the
    flipping operations:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然旋转图像很酷，但如果我们可以翻转图像，那就更有趣了。PIL 在这里没有让人失望，并提供了水平翻转和垂直翻转图像的选项。以下代码将帮助我们执行翻转操作：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, if you run this piece of code, it will generate two images. The following
    image is the same as the original image, but is flipped horizontally (as if there
    is a mirror kept on the right side of the image). Note how the mountain has moved
    to the right of the image:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在如果你运行这段代码，它将生成两个图像。以下图像与原始图像相同，但水平翻转（就像在图像的右侧放了一面镜子）。注意山已经移动到图像的右侧：
- en: '![How to do it...](img/image_09_004.jpg)'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/image_09_004.jpg)'
- en: The following screenshot is a mirror image of the original image, which is flipped
    vertically. Notice, the mountain is still on the left-hand side of the image but
    it's upside down. Similar is the fate of the setting sun. Is it looking like sunrise?
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图是原始图像的镜像，它是垂直翻转的。注意，山仍然在图像的左侧，但它现在是颠倒的。落日的命运也是如此。它看起来像日出吗？
- en: '![How to do it...](img/image_09_005.jpg)'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/image_09_005.jpg)'
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this section, we dealt with two different image formats: PNG and JPEG. **Portable
    Network Graphics** (**PNG**) files are non-lossy files, compressing photographic
    images without degrading quality. It is an excellent file format for Internet
    graphics; it can be used with multiple backgrounds, and it supports transparency.
    For the image used in first code example, `beach_sunset.png`, the file size is
    550KB.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们处理了两种不同的图像格式：PNG 和 JPEG。**可移植网络图形**（**PNG**）文件是非损失性文件，在压缩照片图像时不会降低质量。它是一种优秀的网络图形文件格式；它可以用于多种背景，并支持透明度。对于第一个代码示例中使用的图像，`beach_sunset.png`，文件大小为
    550KB。
- en: '**Joint Photographic Experts Group** (**JPEG**) uses lossy compression techniques
    to compress images. JPGs compress images by reducing the sections of images to
    pixels or tiles. JPG images can be compressed at a ratio of N:1, depending on
    the settings. Since images get compressed easily and can reduce the Internet bandwidth
    for accessing images on the Internet, JPG has become a standard for images on
    the Internet. For the converted image, I see the file size is 450KB--almost 20%
    smaller size than the PNG files.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**联合图像专家小组** (**JPEG**) 使用有损压缩技术来压缩图像。JPG通过减少图像的部分到像素或瓦片来压缩图像。JPG图像可以根据设置以N:1的比例压缩。由于图像容易压缩并且可以减少访问互联网上图像的带宽，JPG已成为互联网上图像的标准。对于转换后的图像，我看到文件大小是450KB--比PNG文件小近20%。'
- en: Now, let's understand the Python code. We import the `Image` class from the
    `PIL` module. The `Image` class is responsible for opening, loading, and converting
    images, among other operations such as saving images on the disk. In our example,
    we open the PNG image with the `open()` method and save the image in the JPEG
    format with the `save()` method.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们理解Python代码。我们从`PIL`模块中导入`Image`类。`Image`类负责打开、加载和转换图像，以及其他操作，如将图像保存在磁盘上。在我们的示例中，我们使用`open()`方法打开PNG图像，并使用`save()`方法以JPEG格式保存图像。
- en: In the second example, we convert the image to the black and white format. Just
    as we have the RGB and CMYK formats, we also have the *L* format, which denotes
    black and white. While converting the image to the *L* format, it uses the ITU-R
    luma format, where *L=R*299/1000 + G*587/1000 + B*114/1000*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们将图像转换为黑白格式。正如我们有RGB和CMYK格式一样，我们也有*L*格式，它表示黑白。在将图像转换为*L*格式时，它使用ITU-R亮度格式，其中*L=R*299/1000
    + G*587/1000 + B*114/1000*。
- en: In terms of Python code, again we use the `Image` class to `open()` the file
    and use the `convert()` method with its argument as *L* to convert the image to
    black and white. Finally, we save the file on the disk with `save()` method. Here
    we maintain the file format to PNG.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python代码方面，我们再次使用`Image`类来`open()`文件，并使用带有参数*L*的`convert()`方法将图像转换为黑白。最后，我们使用`save()`方法将文件保存在磁盘上。我们保持文件格式为PNG。
- en: In the third example, we use the same `Image` class and `open()` the image to
    get the `img` object. This object is then used to call the `rotate()` method with
    the angle of rotation being the argument. In our example, we rotated the image
    by 180 degrees and finally called `save()` to save the rotated image on the disk
    with the name, `sunset180deg.jpg`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个示例中，我们使用相同的`Image`类和`open()`方法打开图像以获取`img`对象。然后，使用旋转角度作为参数调用`rotate()`方法。在我们的示例中，我们旋转了图像180度，并最终调用`save()`方法将旋转后的图像以`sunset180deg.jpg`的名称保存在磁盘上。
- en: In the last example, we make use of the `transpose()` method of the `PIL` module
    and flip the images both ways, that is, left-right and top-bottom, using the attributes
    `Image.FLIP_LEFT_RIGHT` and `Image.FLIP_TOP_BOTTOM`, and then save the flipped
    images with the names `sunset_horizontal_flip.png` and `sunset_vertical_flip.png`,
    respectively.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个示例中，我们使用了`PIL`模块的`transpose()`方法，并使用`Image.FLIP_LEFT_RIGHT`和`Image.FLIP_TOP_BOTTOM`属性将图像左右和上下翻转，然后分别以`sunset_horizontal_flip.png`和`sunset_vertical_flip.png`的名称保存翻转后的图像。
- en: There's more...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Pillow module has many more methods that help us perform more complex operations
    on our images, such as resizing, pasting, cropping, and what not. We will look
    at them in the next recipe of this chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Pillow模块有许多更多的方法可以帮助我们在图像上执行更复杂的操作，例如调整大小、粘贴、裁剪等等。我们将在本章的下一个示例中查看它们。
- en: Resizing, cropping, and generating thumbnails
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整大小、裁剪和生成缩略图
- en: Operations such as resizing images and cropping them to get a selected part
    of the image are very common, but these operations may become tedious when tried
    programmatically. See how we can achieve these tasks.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 调整图像大小和裁剪以获取图像的选定部分等操作非常常见，但当以编程方式尝试时，这些操作可能会变得繁琐。看看我们如何完成这些任务。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the `Pillow` library to resize and crop images.
    As we already have the Pillow module installed, we don't have to worry about any
    installations. Let's jump into doing stuff.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用`Pillow`库来调整图像大小和裁剪图像。由于我们已经安装了Pillow模块，我们不必担心任何安装。让我们开始操作吧。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, let''s look at how to resize an image to the given dimensions. Create
    a Python file, `resize.py`, and paste the following code snippet:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何将图像调整到给定的尺寸。创建一个Python文件，`resize.py`，并将以下代码片段粘贴进去：
- en: '[PRE6]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Also, download an image from the Internet and name it sunset.jpg. My image looks
    like this:![How to do it...](img/image_09_006.jpg)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，从互联网上下载一张图片，命名为sunset.jpg。我的图片看起来像这样：![如何操作...](img/image_09_006.jpg)
- en: Now, run the Python code with the `python resize.py` command, and look at your
    disk for the image, `sunset-resize.jpg`. You'll see that the image gets resized
    and looks similar to the following screenshot:![How to do it...](img/image_09_007.jpg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`python resize.py`命令运行Python代码，然后查看磁盘上的图像`sunset-resize.jpg`。你会看到图像被调整大小，看起来类似于以下截图：![如何操作...](img/image_09_007.jpg)
- en: 'The image also has the dimensions of 256 pixels by 256 pixels as expected:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如预期的那样，图像的尺寸也是256像素乘以256像素：
- en: '![How to do it...](img/image_09_008.jpg)'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/image_09_008.jpg)'
- en: 'Another operation often needed in programming is to generate thumbnails for
    images. Thumbnails are used as the preview of an original image and are typically
    used in movie review websites or book publishing websites. Let''s see if we can
    easily generate thumbnails with the Pillow module. Create a Python file and add
    this piece of code:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编程中经常需要的另一个操作是生成图像的缩略图。缩略图用作原始图像的预览，通常用于电影评论网站或图书出版网站。让我们看看我们是否可以轻松地使用Pillow模块生成缩略图。创建一个Python文件并添加以下代码：
- en: '[PRE7]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, if you run this piece of code, you will get an image, `sunset.thumbnail.jpg`,
    which is a thumbnail of the original image and will look as shown in the screenshot
    below. If you look at the size of the image, it will not be 128 x 128 (for me,
    it's 128 x 80 pixels). We will cover the reasons for this in a bit.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果你运行这段代码，你会得到一个名为`sunset.thumbnail.jpg`的图像，它是原始图像的缩略图，看起来如下面的截图所示。如果你查看图像的大小，它不会是128
    x 128（对我来说是128 x 80像素）。我们将在稍后解释这个原因。
- en: 'Nice! So, we have the thumbnail generated for the image and it can be used
    on a website as a profile thumbnail or a preview image:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太好了！因此，我们已经生成了图像的缩略图，它可以用作网站上的个人资料缩略图或预览图：
- en: '![How to do it...](img/image_09_009.jpg)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/image_09_009.jpg)'
- en: 'Another operation that we will cover in this recipe is the cropping of images.
    The following code does exactly what we need:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将介绍另一种操作，即图像裁剪。以下代码正好实现了我们所需要的功能：
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you run the preceding Python snippet, you will see an image generated on
    your disk, `sunset-crop.jpg`, which has a cropped image of the sun from the original
    sunset image. This is how it looks:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你运行前面的Python代码片段，你将在磁盘上看到一个名为`sunset-crop.jpg`的图像，它从原始日落图像中裁剪了太阳。它看起来是这样的：
- en: '![How to do it...](img/image_09_010.jpg)'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/image_09_010.jpg)'
- en: It was nice to see how we could perform multiple operations on the images with
    Pillow so easily and so intuitively. But how do these operations work; what are
    the methods used? Let's look at them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很棒，我们可以如此轻松且直观地使用Pillow对图像执行多个操作。但是这些操作是如何工作的；使用了哪些方法？让我们来看看。
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we again used Pillow's `Image` class to resize and crop images
    and generate thumbnails from our original image.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们再次使用了Pillow的`Image`类来调整图像大小、裁剪图像并从原始图像生成缩略图。
- en: In the first code snippet, we opened the sunset.jpg image with the `open()`
    method. We then used the `resize()` method with a tuple argument listing the width
    and height of the resized image. We then used the `save()` method with the filename,
    `sunset-esize.jpg` and the JPEG file format to save the file on the disk.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个代码片段中，我们使用`open()`方法打开了sunset.jpg图像。然后我们使用带有元组参数的`resize()`方法，列出了调整大小图像的宽度和高度。然后我们使用`save()`方法，文件名为`sunset-esize.jpg`，以JPEG格式将文件保存到磁盘上。
- en: In the second snippet, we opened the image with the `open()` method and got
    an image object. We then used the `thumbnail()` method of the `Image` class on
    the image object for generating the thumbnail. The `thumbnail()` method takes
    the size of the image (we used 128 x 128) and uses the BICUBIC image filtering
    mechanism. Finally, we saved the image with the `save()` method with the target
    filename set to `sunset.thumbnail.jpg`. We looked at the size of the thumbnail
    and figured that it's not exactly 128 x 128; in fact, it's 128 x 80\. This is
    because PIL keeps the width of the image to 128 pixels and then recalculates the
    height to maintain the aspect ratio of the image.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个片段中，我们使用`open()`方法打开图像并获取一个图像对象。然后，我们使用`Image`类的`thumbnail()`方法对图像对象进行缩略图生成。`thumbnail()`方法接受图像的大小（我们使用了128
    x 128），并使用BICUBIC图像过滤机制。最后，我们使用`save()`方法保存图像，目标文件名为`sunset.thumbnail.jpg`。我们查看缩略图的大小，并发现它并不完全是128
    x 128；实际上，它是128 x 80。这是因为PIL保持图像宽度为128像素，然后重新计算高度以保持图像的宽高比。
- en: And in the third example, we cropped the image with the `crop()` method of the
    `Image` class from the Pillow module. The `crop()` method takes all the four coordinates
    from where the image needs to be carved out from the original image. In our example,
    we have given the coordinates `left = 965`, `top = 700`, `right = 1265`, `bottom
    = 960` to crop the original image and the result obtained is the image of the
    sun as we saw in the examples.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个示例中，我们使用Pillow模块的`crop()`方法裁剪图像。`crop()`方法接受从原始图像中需要裁剪出的所有四个坐标。在我们的例子中，我们给出了坐标`left
    = 965`，`top = 700`，`right = 1265`，`bottom = 960`来裁剪原始图像，得到的结果就是我们看到的太阳图像。
- en: There's more...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: In the thumbnail generation example, I briefly mentioned filters that are applied
    to images for better clarity. I'm not covering these in detail in this chapter,
    but if you're interested, you can look at them in detail at [http://pillow.readthedocs.io/en/3.0.x/releasenotes/2.7.0.html#default-filter-for-thumbnails](http://pillow.readthedocs.io/en/3.0.x/releasenotes/2.7.0.html#default-filter-for-thumbnails).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在缩略图生成示例中，我简要提到了为了提高清晰度而应用于图像的过滤器。在本章中，我不会详细讨论这些内容，但如果您感兴趣，可以在[http://pillow.readthedocs.io/en/3.0.x/releasenotes/2.7.0.html#default-filter-for-thumbnails](http://pillow.readthedocs.io/en/3.0.x/releasenotes/2.7.0.html#default-filter-for-thumbnails)中详细了解。
- en: Copy-pasting and watermarking images
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制粘贴和添加水印图像
- en: In this recipe, we will cover one operation that is highly used by designers
    and marketers, that is, watermarking images. We will also see an interesting use
    of copy-pasting images over one another. Let's go ahead and look at them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将介绍设计师和营销人员高度使用的操作之一，即图像添加水印。我们还将看到将图像重叠粘贴的有趣用法。让我们继续看看它们。
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will continue to use Pillow to copy-paste images, but we
    will use another Python module, `wand`, for watermarking. So, as is the normal
    practice, let''s install the `wand` module first before we start writing any code.
    We install wand with our favorite tool, Python''s `pip`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将继续使用Pillow进行复制粘贴图像，但我们将使用另一个Python模块`wand`进行添加水印。所以，按照常规做法，在我们开始编写任何代码之前，让我们首先安装`wand`模块。我们使用我们喜欢的工具Python的`pip`安装wand：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Installed the module already? OK then, let's dive in.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 已经安装了模块吗？好的，那么，让我们深入探讨。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, let''s look at how to perform the copy-paste operation with Pillow.
    Remember, from the previous sections we have two images: the original image, `sunset.jpg`,
    and the image of the sun that was cropped from the original image, `sunset-crop.jpg`.
    We will use these images in the following Python code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何使用Pillow执行复制粘贴操作。记住，从前面的章节中，我们有两个图像：原始图像，`sunset.jpg`，以及从原始图像中裁剪出的太阳图像，`sunset-crop.jpg`。我们将在下面的Python代码中使用这些图像：
- en: '[PRE10]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's store the code in a file by the name, `copy_paste.py`, and run the code
    with the Python command, `copy_paste.py`. Once we run the code, we will see a
    new file being generated, called `pasted.jpg`, which looks like the following
    screenshot:![How to do it...](img/image_09_011.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将代码保存在名为`copy_paste.py`的文件中，并使用Python命令`copy_paste.py`运行代码。一旦运行代码，我们将看到一个新文件被生成，名为`pasted.jpg`，如下面的截图所示：![如何操作...](img/image_09_011.jpg)
- en: What we have managed to do is copy the cropped image, paste it on the original
    image, and save the pasted image as `pasted.jpg`. Cool, isn't it?
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经成功地将裁剪的图像复制，粘贴到原始图像上，并将粘贴的图像保存为`pasted.jpg`。酷吧，不是吗？
- en: 'Now, let''s look at an interesting example that has commercial use. In this
    example, we will add a watermark to an existing image and store it under a different
    name. But before we get into the Python code, let''s look at how the watermark
    image looks:'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个有趣的例子，它具有商业用途。在这个例子中，我们将向现有图片添加水印，并以不同的名称存储。但在我们进入Python代码之前，让我们看看水印图片看起来是什么样子：
- en: '![How to do it...](img/image_09_012.jpg)'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/image_09_012.jpg)'
- en: 'The following Python code helps us in adding the preceding watermark to our
    original `sunset.jpg` image file:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下Python代码帮助我们向我们的原始`sunset.jpg`图像文件添加前面的水印：
- en: '[PRE11]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run this code and you will see a `result.jpg` file being generated in your project.
    It will look similar to the following screenshot. Look at how the image is watermarked
    with the **Copyrighted Image** text on top:![How to do it...](img/image_09_013.jpg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此代码，你将在你的项目中看到一个`result.jpg`文件被生成。它看起来类似于以下截图。看看图片是如何在顶部带有**版权图片**文本的水印：![如何操作...](img/image_09_013.jpg)
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'For the first code snippet, we used the `PIL` module and the Image class to
    `open()` the cropped image and original image and get the file handles of both
    the files, namely: `img` and `pasteImg`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个代码片段，我们使用了`PIL`模块和Image类来`open()`裁剪的图片和原始图片，并获取两个文件的文件句柄，即：`img`和`pasteImg`。
- en: As the name suggests, we opened the cropped image `img` and pasted it on `pasteImg`,
    using the file handles.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，我们打开了裁剪的图片`img`，并使用文件句柄将其粘贴到`pasteImg`上。
- en: For pasting the image, we used Pillow's `paste()` module and passed the `img`
    file handle to it as the source image. We also passed the coordinates where the
    cropped image is to be pasted on the original image. Since we have chosen the
    coordinates to be (0, 0), the cropped image is pasted on the upper-left corner
    of the original image. Finally, we saved this image as `pasted.jpg`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了粘贴图片，我们使用了Pillow的`paste()`模块，并将`img`文件句柄作为源图片传递给它。我们还传递了裁剪图片要粘贴到原始图片上的坐标。由于我们选择的坐标是（0，0），所以裁剪的图片被粘贴到了原始图片的左上角。最后，我们将这张图片保存为`pasted.jpg`。
- en: In the second example, we opened the original image, `sunset.jpg`, and the watermark
    image, `watermark.jpg`, and created the file handles, `background` and `watermark`,
    respectively. We then used the `wand` module's `watermark()` method to add the
    watermark to the original image.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们打开了原始图片`sunset.jpg`和水印图片`watermark.jpg`，并分别创建了文件句柄`background`和`watermark`。然后我们使用`wand`模块的`watermark()`方法将水印添加到原始图片上。
- en: The `watermark()` method works on the background image object (in this case,
    background, our original image object). It uses image as the `keyword` argument,
    which indicates the object of the watermark image. You can also set the transparency
    of the watermark image, where `0` indicates that the watermark is completely visible
    while `1` indicates that it is invisible. Another useful thing you can achieve
    with the `watermark()` method is that you can choose the location of the watermark
    on the original image. In this example, we have chosen it to be at the coordinates `560`
    from the left and `300` from the top.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`watermark()`方法作用于背景图片对象（在这个例子中，背景，我们的原始图片对象）。它使用`image`作为`keyword`参数，表示水印图片的对象。您还可以设置水印图片的透明度，其中`0`表示水印完全可见，而`1`表示水印不可见。使用`watermark()`方法还可以实现的其他有用功能之一是，您可以选择水印在原始图片上的位置。在这个例子中，我们将其选择为从左`560`像素和从上`300`像素的位置。'
- en: Cool; that's it in this recipe. Let's go ahead and see what we have in store
    in the remaining recipes of this chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧；这个菜谱就到这里。让我们继续看看本章剩余的菜谱中还有什么。
- en: Image differences and comparison
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像差异和比较
- en: 'You must have definitely used a text-based search or even implemented one.
    But do you know, you can now even perform an image-based search? Of course, Google
    does that quite nicely. How do you think it does that? If you have to implement
    one yourself, you better know how to compare two images. Based on your use case,
    you may also want to get a `diff` or the difference between two images. In this
    recipe, we will cover two use cases:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定使用过基于文本的搜索，甚至实现过。但你可能不知道，你现在甚至可以进行基于图像的搜索？当然，谷歌做得相当不错。你认为它是如何做到的？如果你必须自己实现，你最好知道如何比较两张图片。根据你的用例，你可能还想要获取两张图片之间的`diff`或差异。在这个菜谱中，我们将涵盖两个用例：
- en: How to get the difference between two images and store the difference as an
    image
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取两张图片之间的差异并将差异存储为图片
- en: How to objectively compare two images with scientific methods
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何用科学方法客观比较两张图片
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: In this recipe, we will continue using Pillow to compare images. Along with
    our `Image` class, we will also use the `ImageChops` class to get the difference
    between two images. We will use the `scipy` module to compare the images at the
    pixel level.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将继续使用Pillow来比较图片。除了我们的`Image`类，我们还将使用`ImageChops`类来获取两张图片之间的差异。我们将使用`scipy`模块在像素级别比较图片。
- en: 'We already have the Pillow module installed, so let''s go ahead and install
    the `scipy` module using Python `pip`. On Mac OS X machine, you''ll need to have
    a compiler to install the `scipy` module. We will install the GCC compiler on
    Mac with Mac''s `brew` command:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经安装了Pillow模块，所以让我们继续使用Python的`pip`安装`scipy`模块。在Mac OS X机器上，你需要有一个编译器来安装`scipy`模块。我们将使用Mac的`brew`命令在Mac上安装GCC编译器：
- en: '[PRE12]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have GCC installed, let''s install `scipy` with `python-pip`. This
    is how the installation logs look on my system:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经安装了GCC，让我们使用`python-pip`安装`scipy`。以下是我系统上的安装日志：
- en: '[PRE13]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Now that the modules are already installed, let''s start utilizing them for
    our needs. First, let''s look at getting the difference between two images and
    storing the difference as an image itself. The following code does this operation:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在模块已经安装好了，让我们开始利用它们来满足我们的需求。首先，让我们看看如何获取两张图片之间的差异，并将这个差异存储为一张图片本身。以下代码执行了这个操作：
- en: '[PRE14]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code example, we calculated the difference between the original
    image, `sunset.jpg`, and the copy-pasted image, `pasted.jpg` (if you remember
    the previous recipe, `pasted.jpg` is obtained after pasting the cropped sun image
    on the original sunset image). This is how the difference image looks:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们计算了原始图像`sunset.jpg`和粘贴的图像`pasted.jpg`（如果你还记得之前的菜谱，`pasted.jpg`是在将裁剪的太阳图像粘贴到原始日落图像上后获得的）之间的差异。差异图像看起来是这样的：
- en: '![How to do it...](img/image_09_014.jpg)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/image_09_014.jpg)'
- en: Observe how the difference is only the cropped image of the sun since the base
    original image remains the same. Cool! What does the black region indicate? We
    will talk about it in the *How it works...* section.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 观察一下差异仅是太阳的裁剪图像，因为基础原始图像保持不变。酷！黑色区域表示什么？我们将在*如何工作...*部分讨论它。
- en: 'Now, let''s move ahead and look at calculating the difference between images
    in an objective manner. For this, we will use the `scipy` module. The following
    code example will help us with what we need:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续并看看如何以客观的方式计算图像之间的差异。为此，我们将使用`scipy`模块。以下代码示例将帮助我们完成所需的工作：
- en: '[PRE15]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we run the preceding Python code, we will get the difference in pixels in
    both these images. The output of our example is as follows:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们运行前面的Python代码，我们将得到这两张图片像素的差异。我们的示例输出如下：
- en: '[PRE16]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the first code snippet of this section, we calculated the difference between
    the two images using the `ImageChops` class of the Pillow library. As usual, we
    opened both the images with the `open()` method and got the image objects `image_one`
    and `image_two`, respectively.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第一段代码中，我们使用Pillow库的`ImageChops`类计算了两张图片之间的差异。像往常一样，我们使用`open()`方法打开了这两张图片，分别得到了`image_one`和`image_two`这两个图像对象。
- en: We then used the `difference()` method of the `ImageChops` class and passed
    the image objects as arguments to this method. The `difference()` method returns
    the `diff` object, which essentially is the object representing the difference
    between the two images.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用了`ImageChops`类的`difference()`方法，并将图像对象作为参数传递给这个方法。`difference()`方法返回一个`diff`对象，这个对象本质上代表了两个图像之间的差异。
- en: Finally, we saved the difference as an image on the disk with the name, `diff.jpg`.
    We also used the `getbbox()` method on the `diff` object, which calculates the
    bounding box of the nonzero regions in the image. Here nonzero regions indicate
    the pixels where the difference between `sunset.jpg` and `pasted.jpg` is 0.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将差异作为名为`diff.jpg`的图像保存在磁盘上。我们还对`diff`对象使用了`getbbox()`方法，这个方法计算图像中非零区域的边界框。这里非零区域表示`sunset.jpg`和`pasted.jpg`之间的差异为0的像素。
- en: Now, if you look at `diff.jpg`, it contains a huge black region. These are the
    pixels where the difference is 0, hence the color black. For same images, the
    `getbbox()` method returns `None`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你查看`diff.jpg`，它包含一个巨大的黑色区域。这些是差异为0的像素，因此颜色为黑色。对于相同的图片，`getbbox()`方法返回`None`。
- en: In the second example, we compared the two images based on zero norm, which
    indicates the number of pixels not equal to zero, or in other words, indicates
    how many pixels differ between the two images. For comparing images, we first
    read both the images using the `imread()` method of the `scipy` module. Both the
    image objects are `img1` and `img2`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们根据零范数比较了两个图像，这表示不等于零的像素数，换句话说，表示两个图像之间有多少像素不同。为了比较图像，我们首先使用 `scipy`
    模块的 `imread()` 方法读取两个图像。这两个图像对象都是 `img1` 和 `img2`。
- en: We then calculated the difference between the two images with `diff = img1 -
    img2`. This difference returned is of the `ndarray` type of `scipy`. When we pass
    this difference to the `norm()` method, it returns the number of pixels that are
    different between images.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `diff = img1 - img2` 计算了两个图像之间的差异。这个返回的差异是 `scipy` 的 `ndarray` 类型。当我们把这个差异传递给
    `norm()` 方法时，它返回图像之间不同的像素数。
- en: There's more...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are multiple ways of comparing images, which we haven't covered in this
    chapter. I suggest you do a deeper reading into this if you're really interested.
    But for all practical purposes, I think this chapter should suffice.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 比较图像有多种方法，我们在这章中没有涉及。如果你对此真的感兴趣，我建议你深入阅读。但就实际用途而言，我认为这一章应该足够了。
- en: Face detection
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面部检测
- en: We covered a lot of operations on images in the preceding sections. In this
    recipe, let's delve deeper and cover an advanced operation such as face detection
    in images.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了许多图像操作。在这个食谱中，让我们深入探讨并覆盖一个高级操作，例如图像中的面部检测。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use Python's `opencv` module, so let's start by installing
    the required module.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用 Python 的 `opencv` 模块，所以让我们首先安装所需的模块。
- en: 'For using `opencv` Python bindings, we have to first install `opencv` on our
    computer. On my Mac OS X machine, I use the `brew` utility to install `opencv`
    this way:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用 `opencv` Python 绑定，我们首先需要在我们的计算机上安装 `opencv`。在我的 Mac OS X 机器上，我使用 `brew`
    工具以这种方式安装 `opencv`：
- en: '[PRE17]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Just installing `opencv` on your computer doesn''t help. You also need to point
    the `cv2.so` (`.so` stands for shared object or library) to glue it with a virtual
    environment using the following commands:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只在计算机上安装 `opencv` 并没有帮助。你还需要使用以下命令将 `cv2.so`（`.so` 代表共享对象或库）指向虚拟环境，以便将其粘合：
- en: '[PRE18]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Cool! So, we now have `opencv` installed, which is required for our examples
    in this recipe.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！所以，我们现在已经安装了 `opencv`，这是我们在这个食谱中的示例所必需的。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Go to your favorite editor, create a Python file, and name it `face_detection.py`.
    Now, copy the following code into the Python file:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往你最喜欢的编辑器，创建一个 Python 文件，并将其命名为 `face_detection.py`。现在，将以下代码复制到 Python 文件中：
- en: '[PRE19]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, create an XML file by the name `haarcascade.xml` and copy the contents
    from the code repository of this book. In my example, I am using one of the pictures
    of myself, `Chetan.jpeg`, but you can use any of your pictures for this example.
    Here's how `Chetan.jpeg` looks:![How to do it...](img/image_09_015.jpg)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `haarcascade.xml` 的 XML 文件，并将代码库中的内容复制过来。在我的例子中，我使用的是我自己的一张照片，`Chetan.jpeg`，但你可以使用你自己的任何照片进行这个示例。以下是
    `Chetan.jpeg` 的样子：![如何做到这一点...](img/image_09_015.jpg)
- en: Now, let's run the Python code and see if our code is able to recognize my face
    from the image. We run the code with the command `python face_detection.py` and
    it generates an image, `Chetan_face.jpg`, which looks like the following. Indeed,
    it did detect my face.![How to do it...](img/image_09_016.jpg)
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行 Python 代码，看看我们的代码是否能够从图像中识别出我的脸。我们使用命令 `python face_detection.py` 运行代码，并生成一个图像，`Chetan_face.jpg`，它看起来如下。确实，它检测到了我的脸。![如何做到这一点...](img/image_09_016.jpg)
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In our recipe, we used the `opencv` module to first create a cascade classifier
    object with the `haarcascade.xml` file. We called this object `face_cascade`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的食谱中，我们使用了 `opencv` 模块，首先使用 `haarcascade.xml` 文件创建一个级联分类器对象。我们称这个对象为 `face_cascade`。
- en: Object detection using Haar's feature-based cascade classifiers is an effective
    object detection method proposed by Paul Viola and Michael Jones in 2001\. It
    is a machine learning-based approach, where a cascade function is trained from
    a lot of positive and negative images. It is then used to detect objects in other
    images.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Haar 特征的级联分类器进行对象检测是 Paul Viola 和 Michael Jones 在 2001 年提出的一种有效的对象检测方法。它是一种基于机器学习的方法，其中级联函数是从大量的正负图像中训练出来的。然后，它被用来检测其他图像中的对象。
- en: Haar features are fed into a standard XML file, which is what we used in our
    code example. You can actually train your classifier to detect the objects you
    wish. For instance, eye detection uses another classifier.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Haar特征被输入到一个标准的XML文件中，这是我们代码示例中使用的。实际上，你可以训练你的分类器来检测你希望的对象。例如，眼检测使用另一个分类器。
- en: Next, we read the original base image, `Chetan.jpeg`, using the `opencv` module's
    `imread()` method and defined the smallest window for detection.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`opencv`模块的`imread()`方法读取原始基础图像`Chetan.jpeg`，并定义了检测的最小窗口。
- en: In fact, Haar cascade classifier works on a sliding window approach and hence
    needs the smallest window for detection. The classifier also needs to have `minNeighbors`
    configured.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Haar级联分类器采用滑动窗口方法工作，因此需要最小的窗口进行检测。分类器还需要配置`minNeighbors`。
- en: Settings such as these are configured in the `detectMultiScale()` method of
    the cascade object. We have set `minSize=(30,30)` and `minNeighbors=3`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置是在级联对象的`detectMultiScale()`方法中配置的。我们已将`minSize=(30,30)`和`minNeighbors=3`设置为。
- en: Finally, we stored the detected image on the disk and the original image has
    a green rectangle as an indication of face detection on the image.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将检测到的图像存储在磁盘上，原始图像有一个绿色矩形作为图像上人脸检测的指示。
- en: There's more...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We looked at a very simple example of face detection with `opencv` and learned
    a bit about classifiers. `opencv` has more things that you may want to learn about.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看了一个使用`opencv`进行人脸检测的非常简单的例子，并了解了一些关于分类器的内容。`opencv`还有更多你可能想了解的内容。
- en: 'Here''s a link to a resource that you will find interesting to read: [http://docs.opencv.org/trunk/index.html](http://docs.opencv.org/trunk/index.html).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个链接到一篇你可能觉得有趣的资源：[http://docs.opencv.org/trunk/index.html](http://docs.opencv.org/trunk/index.html)。
- en: Imaging as a business process
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为一项业务流程的图像化
- en: Peter is an IT manager at MBI Inc, a big corporation. His company has been in
    existence for long enough for a majority of the contractual finance documents,
    standard operating procedures, and supply chain documents to be paper-based. He
    is tasked with this humongous responsibility of making his company go paperless.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 彼得是MBI Inc公司的一名IT经理，这是一家大型企业。他的公司已经存在很长时间，大多数合同财务文件、标准操作程序和供应链文件都是基于纸质的。他被赋予了这样一个巨大的责任，即让他的公司实现无纸化。
- en: This means that he is responsible for eliminating the hassle and cost of managing
    paper archives. With the imaging knowledge we have gathered so far (and we will
    learn more) in this chapter, let's see if we can help Peter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着他负责消除管理纸质档案的麻烦和成本。根据我们在本章中收集到的图像知识（我们还将学习更多），让我们看看我们是否可以帮助彼得。
- en: 'If you carefully analyze, Peter needs to achieve two important tasks:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细分析，彼得需要完成两个重要的任务：
- en: Scan the papers and store them in an electronic format as images
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描文件并将它们以图像格式存储在电子格式中
- en: Generate text files from these documents so that they can be easily indexed
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从这些文件生成文本文件，以便它们可以轻松索引
- en: Getting ready
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'For this exercise, let''s start by installing the required modules. We will
    need the following modules:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，让我们首先安装所需的模块。我们需要以下模块：
- en: '`scikit-image` ([http://scikit-image.org/](http://scikit-image.org/))'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scikit-image` ([http://scikit-image.org/](http://scikit-image.org/))'
- en: '`pyimagesearch` ([http://www.pyimagesearch.com/](http://www.pyimagesearch.com/))'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pyimagesearch` ([http://www.pyimagesearch.com/](http://www.pyimagesearch.com/))'
- en: '`tessaract` and `pytesseract` ([https://pypi.python.org/pypi/pytesseract/](https://pypi.python.org/pypi/pytesseract/))'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tessaract`和`pytesseract` ([https://pypi.python.org/pypi/pytesseract/](https://pypi.python.org/pypi/pytesseract/))'
- en: 'Let''s start installing the modules:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始安装模块：
- en: 'Let''s first start with `scikit-image`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先从`scikit-image`开始：
- en: '[PRE20]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, let's install `pyimagesearch`. This is a nice set of libraries developed
    by Adrian Rosebrock. He has his work open-sourced at [https://github.com/jrosebr1](https://github.com/jrosebr1).
    We, in fact, leverage the scanner example of `pyimagesearch` in this code recipe.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们安装`pyimagesearch`。这是一套由Adrian Rosebrock开发的库。他在[https://github.com/jrosebr1](https://github.com/jrosebr1)上开源了他的工作。实际上，我们在本代码示例中使用了`pyimagesearch`的扫描仪示例。
- en: 'Lastly, let''s install `tesseract` and `pytesseract`. We need to install `tesseract`,
    an **Optical Character Reader** (**OCR**) module, and `pytesseract`, a Python
    module to work with the OCR module:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们安装`tesseract`和`pytesseract`。我们需要安装`tesseract`，这是一个**光学字符识别器**（**OCR**）模块，以及`pytesseract`，这是一个用于与OCR模块一起工作的Python模块：
- en: '[PRE21]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: OK, cool! Now, let's look at the code in the *How to do it...* section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，太棒了！现在，让我们看看*如何做到这一点...*部分中的代码。
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Go to your favorite editor, create a Python file, and name it `scanner.py`.
    For Peter, it would be all about his financial documents, which are in the image
    format, but for the sake of this example, it'll be an image that I have handy
    with me. Here's how my image looks. It's the picture of a newspaper article on
    Andy Murray and I'm trying to digitalize it:![How to do it...](img/image_09_017-e1485235547936.jpg)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往你最喜欢的编辑器，创建一个Python文件，并将其命名为`scanner.py`。对于彼得来说，这将是关于他的财务文件，这些文件是图像格式，但为了这个示例，它将是我在手头上的图像。这是我图像的样子。这是一篇关于安迪·穆雷的报纸文章的照片，我正在尝试将其数字化：![如何做...](img/image_09_017-e1485235547936.jpg)
- en: 'Now, copy the following code in `scanner.py` and run the code with the command,
    `python scanner.py`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下代码复制到`scanner.py`中，并使用命令`python scanner.py`运行代码：
- en: '[PRE22]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once you run the Python code, you will see three images being created on your
    hard disk. The first one is the edge-detected image, which, in my case, looks
    as follows. It''s saved as `scan_edge.jpg`:'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦运行Python代码，你将在你的硬盘上看到三个图像被创建。第一个是边缘检测图像，在我的情况下，它看起来如下。它被保存为`scan_edge.jpg`：
- en: '![How to do it...](img/image_09_018.jpg)'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/image_09_018.jpg)'
- en: Next, we get another image, which detects the whole area of the image where
    text is found. This is called the contours image and is generated as `scan_contours.jpg`.
    See how it highlights the portion of the image where text is available:![How to
    do it...](img/image_09_019.jpg)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们获取另一张图像，它检测到图像中包含文本的整个区域。这被称为轮廓图像，并生成为`scan_contours.jpg`。看看它如何突出显示图像中包含文本的部分：![如何做...](img/image_09_019.jpg)
- en: Finally, we get the scanned copy of our news article on Andy Murray, and it
    is saved as `scanned.jpg`. Look how well the news article got scanned in the following
    screenshot:![How to do it...](img/image_09_020.jpg)
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们得到了关于安迪·穆雷的新闻文章的扫描副本，并保存为`scanned.jpg`。看看以下截图中的新闻文章扫描效果如何：![如何做...](img/image_09_020.jpg)
- en: Cool, this is the exact thing we wanted to achieve when we first started, isn't
    it? Give this to Peter and he will be very happy. He might be thinking of some
    costly consulting companies or scanners to do this job, while we could do it quickly and
    that too for free!
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太酷了，这正是我们一开始想要实现的东西，不是吗？把这个给彼得，他会非常高兴。他可能会想到一些昂贵的咨询公司或扫描仪来做这项工作，而我们可以快速完成，而且还是免费的！
- en: 'As if this was not enough, we have done more for Peter here. If you run the
    program, you will also get a text output, which gives out the text of the complete
    article. Using this text, Peter can choose to classify the documents and index
    them accordingly:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 似乎这还不够，我们在彼得这里还做了更多。如果你运行程序，你还会得到一个文本输出，它提供了整篇文章的文本。使用这个文本，彼得可以选择对文档进行分类并相应地索引它们：
- en: '[PRE23]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Awesome! Let's look at the internals of our program in the "How it works" section.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！让我们在“它是如何工作的”部分看看我们程序的内部结构。
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In our recipe, we started by taking a picture of our newspaper article. We named
    this as `murray.jpg`. I used a simple camera phone to take this image. We then
    went ahead and read the image using the `opencv` module's `imread()` method.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的食谱中，我们首先拍摄了我们报纸文章的照片。我们将其命名为`murray.jpg`。我使用了一部简单的手机摄像头来拍摄这张照片。然后我们继续使用`opencv`模块的`imread()`方法读取图像。
- en: We also computed the ratio of the original height to the new height, cloned
    the original image, and resized it. We used the `copy()` method to clone our image,
    and we used the `resize()` method to resize it to a new height.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还计算了原始高度与新高度的比例，克隆了原始图像，并将其调整大小。我们使用`copy()`方法克隆我们的图像，并使用`resize()`方法将其调整到新的高度。
- en: We then converted the image to the grayscale format with the `cvtColor()` method
    and then applied the Gaussian filter to blur the image.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用`cvtColor()`方法将图像转换为灰度格式，然后应用高斯滤波器来模糊图像。
- en: We subjected the blurred image to detect the edges of the text using the `Canny()`
    method and finally stored the edge-detected image as `scan_edge.jpg`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对模糊的图像使用`Canny()`方法检测文本的边缘，并将检测到的边缘图像保存为`scan_edge.jpg`。
- en: Next, we found the contours of the image using the `findContours()` method and
    stored the outline of the image as `scan_contours.jpg`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`findContours()`方法找到了图像的轮廓，并将图像的轮廓保存为`scan_contours.jpg`。
- en: We then ran a couple of transforms on the image. The four-point transform helped
    us get a top-down view of the original image. For this, we used the `four_point_transform()`
    method.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对图像进行了一些转换。四点转换帮助我们获得原始图像的俯视图。为此，我们使用了`four_point_transform()`方法。
- en: We also converted the image to grayscale and then thresholded it to give a black
    and white paper style feel. The `cvtColor()` method converts the image to grayscale
    and the `threshold_adaptive()` method applies the appropriate thresholds. And
    we're done; the image is now ready and is already scanned and saved as `scanned.jpg`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将图像转换为灰度，然后进行阈值处理，以获得黑白纸张风格的感受。`cvtColor()`方法将图像转换为灰度，而`threshold_adaptive()`方法应用适当的阈值。现在我们完成了；图像已经准备好，并且已经扫描并保存为`scanned.jpg`。
- en: But, as we saw in the previous section, we also printed the text of the newspaper
    column. This we could achieve by first reading the scanned image with Pillow's
    `Image` class and with the `pytessaract` module by using the `image_to_string()`
    method on the image object.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如我们在上一节中看到的，我们也打印了报纸专栏的文本。我们可以通过首先使用Pillow的`Image`类和`pytessaract`模块，在图像对象上使用`image_to_string()`方法来读取扫描的图像来实现这一点。
- en: Cool, so we have automated the business process of converting paper-based documents
    into the electronic format and added a facility to index the files so that they
    can be easily fed into the company's ERP processes. Peter is damn happy with you!
    Congrats!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，所以我们已经自动化了将纸质文档转换为电子格式的业务流程，并添加了一个索引文件的功能，以便它们可以轻松地输入公司的ERP流程。彼得非常高兴！恭喜你！
- en: There's more...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We looked at OCR to extract text data from scanned images, but there are many
    more things that can be achieved, such as intelligent character recognition (extracts
    hand-written text) and barcode recognition (recognition of many types of barcodes),
    among others. Also, in this chapter we haven't dealt much with image filtering.
    If you're really interested, you can do lot of reading on these topics, which
    is beyond the scope of this chapter.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了OCR技术从扫描图像中提取文本数据，但还有许多其他可以实现的事情，例如智能字符识别（提取手写文本）和条码识别（识别多种类型的条码），等等。此外，在本章中，我们并没有过多地处理图像滤波。如果你对此真的感兴趣，你可以阅读很多关于这些主题的内容，但这些内容超出了本章的范围。
