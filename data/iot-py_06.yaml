- en: Chapter 6. Working with Analog Inputs and Local Storage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 使用模拟输入和本地存储
- en: 'In this chapter, we will work with analog inputs to transform quantitative
    values retrieved from the real environment into qualitative values that we will
    use to fire actions. We will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用模拟输入将来自真实环境的定量值转换为定性值，我们将使用这些值来触发动作。我们将：
- en: Understand how analog inputs work
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模拟输入的工作原理
- en: Learn about the impact of the resolution of analog to digital converters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解模拟数字转换器分辨率的影响
- en: Measure a voltage with an analog pin and the `mraa` library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模拟引脚和`mraa`库测量电压
- en: Include a photoresistor in a voltage divider and wire an analog input pin with
    a voltage source
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分压器中包含光敏电阻，并将模拟输入引脚与电压源连接
- en: Transform a variable resistor into a voltage source
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可变电阻转换为电压源
- en: Determine the darkness level with analog input and the `mraa` library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模拟输入和`mraa`库确定黑暗程度
- en: Fire actions when the environment light changes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当环境光线变化时触发动作
- en: Control analog inputs with the wiring-x86 library
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用wiring-x86库控制模拟输入
- en: Work with different local storage options to log events
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的本地存储选项来记录事件
- en: Understanding the analog inputs
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模拟输入
- en: In [Chapter 1](ch01.html "Chapter 1. Understanding and Setting up the Base IoT
    Hardware"), *Understanding and Setting up the Base IoT Hardware*, we learned that
    the Intel Galileo Gen 2 board provides six analog input pins numbered from **A0**
    to **A5** and located in the lower-right corner of the front-side of the board.
    It is possible to measure from 0V (ground) to the value configured with the **IOREF**
    jumper position (5V by default) and the board provides 12 bits of resolution for
    the analog to digital converter. Thus, we can detect 4096 different values (212
    = 4096), or 4096 units, with values ranging from zero to 4095 (inclusive), where
    0 represents 0V and 4095 means 5V.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 理解和设置基础物联网硬件") *理解和设置基础物联网硬件* 中，我们了解到英特尔Galileo Gen 2板提供了从**A0**到**A5**编号的六个模拟输入引脚，位于板的前面板的右下角。可以测量从0V（地）到配置的**IOREF**跳线位置（默认为5V）的值，该板为模拟数字转换器提供12位的分辨率。因此，我们可以检测到4096个不同的值（2^12
    = 4096），或4096个单位，其值从0到4095（包含），其中0代表0V，4095表示5V。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In case you have an experience with other Arduino boards, you must take into
    account that the Intel Galileo Gen 2 board does not use the pin labeled **AREF**.
    In other Arduino boards, you can use this pin to set the analog reference voltage
    for the analog to digital conversion process. When we work with the Intel Galileo
    Gen 2 board, the maximum value for the analog pins is always going to be controlled
    by the **IOREF** jumper position (5V or 3.3V) and it is not possible to use any
    external reference for an analog input. In all our examples, we will work with
    the default position for the **IOREF** jumper, and therefore, the maximum value
    will be always 5V.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有其他Arduino板的经验，你必须考虑到英特尔Galileo Gen 2板不使用标记为**AREF**的引脚。在其他Arduino板上，你可以使用此引脚来设置模拟数字转换过程的模拟参考电压。当我们使用英特尔Galileo
    Gen 2板时，模拟引脚的最大值始终将由**IOREF**跳线位置（5V或3.3V）控制，并且无法为模拟输入使用任何外部参考。在我们的所有示例中，我们将使用**IOREF**跳线的默认位置，因此最大值始终为5V。
- en: We just need to apply a linear function to convert the raw values read from
    the analog pin and map them to the input voltage values. If we use 12 bits of
    resolution, the detected values will have a minimum difference or step of 5V /
    4095 = 0.001220012 V, approximately 1.22 mV (milliVolts) or 1.22E-03 V. We just
    need to multiply the raw value read from the analog pin by five and divide it
    by 4095.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要应用一个线性函数将模拟引脚读取的原始值转换为输入电压值。如果我们使用12位的分辨率，检测到的值将具有最小差异或步长为5V / 4095 = 0.001220012
    V，大约为1.22 mV（毫伏）或1.22E-03 V。我们只需要将模拟引脚读取的原始值乘以5，然后除以4095。
- en: The following graph shows the read values from an analog pin in the abscissa
    axis (*x*-axis) and the corresponding floating-point voltage value that it represents
    in the ordinate axis (*y*-axis).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了从模拟引脚读取的值在横轴（*x*-轴）上，以及它在纵轴（*y*-轴）上表示的相应浮点电压值。
- en: '![Understanding the analog inputs](img/B05042_06_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![理解模拟输入](img/B05042_06_01.jpg)'
- en: The equation for the previous graph is `y = x / 4095 * 5`, specifically `voltage_value
    = analog_pin_read_value / 4095 * 5`. We can run the following code in our Python
    interpreter to see the output with all the voltage values that can be generated
    with the formula for each raw value read from the analog pin from `0` to `4095`
    (inclusive).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 之前图表的方程式是 `y = x / 4095 * 5`，具体来说 `voltage_value = analog_pin_read_value / 4095
    * 5`。我们可以在我们的Python解释器中运行以下代码来查看输出，其中包括使用公式从模拟引脚读取的每个原始值（从`0`到`4095`，包括）可以生成的所有电压值。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We can also work with a lower resolution, such as 10 bits of resolution and
    we would be able to detect less different values, specifically 1024 different
    values (2^(10) = 1024), or 1024 units, from 0 to 1023 (inclusive). In this case,
    the values will have a minimum difference or step of 5V / 1023 = 0.004887585V,
    approximately 4.89mV (milliVolts) or 4.89E-03 V. In case we decide to work with
    this lower resolution, we just need to multiply the raw value read from the analog
    pin by five and divide it by 1023.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用较低的分辨率，例如10位分辨率，我们就能检测到更少的不同的值，具体是1024个不同的值（2^(10) = 1024），或1024个单位，从`0`到`1023`（包括）。在这种情况下，值的最小差异或步长将是5V
    / 1023 = 0.004887585V，大约是4.89mV（毫伏）或4.89E-03 V。如果我们决定使用这个较低的分辨率，我们只需将模拟引脚读取的原始值乘以五，然后除以1023。
- en: Wiring an analog input pin with a voltage source
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用电压源连接模拟输入引脚
- en: The easiest way to understand how to read the values from analog pins and map
    these values back to voltage values is to work with a very simple example. We
    will connect a power source to one of the analog input pins, specifically a pack
    with two AA or AAA 1.25 V rechargeable batteries in series. It is also possible
    to use AA or AAA 1.5 V standard batteries in series. Note that the maximum voltage
    with the two rechargeable batteries in series will be 2.5 V (1.25 V * 2), while
    the maximum voltage with the two standard batteries in series will be 3 V (1.5
    V * 2).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 理解如何从模拟引脚读取值并将这些值映射回电压值的最简单方法是通过一个非常简单的例子来操作。我们将连接一个电源到模拟输入引脚之一，具体来说是一个串联两个AA或AAA
    1.25 V可充电电池的电池组。也可以使用串联的两个AA或AAA 1.5 V标准电池。请注意，两个可充电电池串联时的最大电压将是2.5 V（1.25 V *
    2），而两个标准电池串联时的最大电压将是3 V（1.5 V * 2）。
- en: 'We will use the analog pin labeled **A0** to connect to the positive side (+)
    of the battery pack. Don''t forget that the positive side (+) of the batter pack
    is connected to the battery''s nipple. After we finish the necessary wirings,
    we will write Python code to measure the batteries pack voltage. This way, we
    will read the result of converting an analog value to its digital representation
    and we will map it to the voltage value. We need the following parts to work with
    this example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用标记为**A0**的模拟引脚连接到电池组的正极（+）。别忘了电池组的正极（+）连接到电池的乳头。完成必要的接线后，我们将编写Python代码来测量电池组的电压。这样，我们将读取将模拟值转换为数字表示的结果，并将其映射到电压值。为了使用这个例子，我们需要以下部件：
- en: Two AA or AAA 1.25 V rechargeable batteries or two AA or AAA 1.5 V standard
    batteries.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个AA或AAA 1.25 V可充电电池或两个AA或AAA 1.5 V标准电池。
- en: An appropriate battery holder to plug the two selected batteries in series and
    simplify wirings. For example, in case you use two AA 1.25 rechargeable batteries,
    you will need a 2 x AA battery holder.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个合适的电池夹，用于将两个选定的电池串联并简化接线。例如，如果你使用两个AA 1.25可充电电池，你需要一个2 x AA电池夹。
- en: A 2200Ω (2k2Ω) resistor with 5% tolerance (red red red gold).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个2200Ω（2k2Ω）的5%容差（红红红金）电阻。
- en: 'The following image shows the battery holder, the resistor connected to the
    breadboard, the necessary wirings, and the wirings from the Intel Galileo Gen
    2 board to the breadboard. The Fritzing file for the sample is `iot_fritzing_chapter_06_01.fzz`
    and the following image is the breadboard view:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了电池夹、连接到面包板的电阻、必要的接线以及从英特尔Galileo Gen 2板到面包板的接线。该示例的Fritzing文件为`iot_fritzing_chapter_06_01.fzz`，以下图像是面包板视图：
- en: '![Wiring an analog input pin with a voltage source](img/B05042_06_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![使用电压源连接模拟输入引脚的电路图](img/B05042_06_02.jpg)'
- en: 'The following schematic shows the schematic with the electronic components
    represented as symbols:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示显示了用符号表示电子组件的电路图：
- en: '![Wiring an analog input pin with a voltage source](img/B05042_06_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![使用电压源连接模拟输入引脚的电路图](img/B05042_06_03.jpg)'
- en: As seen in the previous schematic, the analog input pin labeled **A0** in the
    board's symbol, is connected to the positive terminal of the power source through
    the resistor. The negative terminal of the power source is connected to the ground.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，板符号上标记为 **A0** 的模拟输入引脚通过电阻连接到电源的正极。电源的负极连接到地。
- en: Now, it's time to make all the necessary wirings. Don't forget to shutdown the
    Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply
    from the Intel Galileo Gen 2 board before adding or removing any wire from the
    board's pins.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进行所有必要的接线了。在添加或移除任何线从板上的引脚之前，不要忘记关闭 Yocto Linux，等待所有板载 LED 熄灭，并从 Intel
    Galileo Gen 2 板上拔掉电源。
- en: Measuring voltage with analog inputs and the mraa library
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟输入和 mraa 库测量电压
- en: We will create a new `VoltageInput` class to represent a voltage source connected
    to our board, specifically, to an analog input pin. The following lines show the
    code for the new `VoltageInput` class that works with the `mraa` library. The
    code file for the sample is `iot_python_chapter_06_01.py`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的 `VoltageInput` 类来表示连接到我们的板上的电压源，具体来说，是连接到模拟输入引脚。以下行显示了与 `mraa` 库一起工作的新
    `VoltageInput` 类的代码。示例代码文件为 `iot_python_chapter_06_01.py`。
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have to specify the analog pin number to which the voltage source is connected
    when we create an instance of the `VoltageInput` class in the `analog_pin` required
    argument. The constructor, that is, the `__init__` method, creates a new `mraa.Aio`
    instance with the received `analog_pin` as its `pin` argument, saves its reference
    in the `aio` attribute and calls its `setBit` method to configure the analog to
    digital converter resolution to be of 12 bits, that is, to provide 4096 possible
    values to represent from 0 to 5V.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `VoltageInput` 类的实例时，我们必须指定电压源连接到的模拟引脚编号，`analog_pin` 是必需的参数。构造函数，即 `__init__`
    方法，使用接收到的 `analog_pin` 作为其 `pin` 参数创建一个新的 `mraa.Aio` 实例，将其引用保存到 `aio` 属性中，并调用其
    `setBit` 方法来配置模拟数字转换器的分辨率为 12 位，即提供 4096 个可能的值来表示从 0 到 5V。
- en: The class defines a `voltage` property that calls the `read` method for the
    related `mraa.Aio` instance (`self.aio`) to retrieve the raw value from the analog
    pin and saves it in the `raw_value` variable. Then, the code returns the result
    of dividing `raw_value` by `4095` and multiplying it by `5`. This way, the property
    returns the voltage value, converted from the raw value returned by the read function.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 该类定义了一个 `voltage` 属性，它调用相关 `mraa.Aio` 实例（`self.aio`）的 `read` 方法来从模拟引脚检索原始值，并将其保存到
    `raw_value` 变量中。然后，代码返回将 `raw_value` 除以 `4095` 并乘以 `5` 的结果。这样，该属性返回从读取函数返回的原始值转换的电压值。
- en: Now, we can write code that uses the new `VoltageInput` class to create an instance
    for the battery pack and easily retrieve the voltage value. The new class makes
    the necessary calculations to map the read value into a voltage value, and therefore,
    we just need to check the value of the `voltage` property without worrying about
    the specific details about the analog to digital converter and its resolution.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写使用新的 `VoltageInput` 类来创建电池包实例并轻松检索电压值的代码。新类执行必要的计算，将读取的值映射到电压值，因此我们只需检查
    `voltage` 属性的值，无需担心关于模拟数字转换器和其分辨率的详细信息。
- en: Now, we will write a loop that will retrieve the voltage value every second.
    The code file for the sample is `iot_python_chapter_06_01.py`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个循环，每秒检索一次电压值。示例代码文件为 `iot_python_chapter_06_01.py`。
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first line creates an instance of the previously coded `VoltageInput` class
    with `0` as the value of the `analog_pin` argument. This way, the instance will
    read the analog values from the pin labeled **A0**, that is connected to the positive
    terminal of the power source through the resistor.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个之前编码的 `VoltageInput` 类的实例，其中 `analog_pin` 参数的值为 `0`。这样，该实例将读取标记为 **A0**
    的引脚上的模拟值，该引脚通过电阻连接到电源的正极。
- en: 'Then, the code runs a loop forever, that is, until you interrupt the execution
    by pressing *Ctrl* + *C* or the button to stop the process in case you are using
    a Python IDE with remote development features to run the code in your board. The
    loop prints the voltage value at pin **A0** every two seconds. The following lines
    show a sample output line generated when the code is executed with two rechargeable
    batteries that have lost a bit of their charge:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将无限循环运行，也就是说，直到你通过按*Ctrl* + *C*或按下停止过程的按钮来中断执行。该循环每两秒打印一次**A0**引脚的电压值。以下是在使用两个电量略有下降的可充电电池执行代码时生成的示例输出行：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Wiring a photoresistor to an analog input pin
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将光敏电阻连接到模拟输入引脚
- en: Now, we will use a photoresistor, that is, a light sensor, specifically, an
    electronic component that provides a variable resistor that changes the resistor
    value based on the incident light intensity. As the incident light intensity increases,
    the resistance of the photoresistor decreases, and vice versa.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用光敏电阻，也就是光传感器，具体来说，这是一种电子元件，它提供了一个可变电阻，该电阻的阻值会根据入射光的强度而变化。随着入射光强度的增加，光敏电阻的阻值减小，反之亦然。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A photoresistor is also known as an **LDR** (short for **Light-Dependent Resistor**)
    or photocell. Bear in mind that pohotoresistors are not the best components to
    sense light with great accuracy. However, they are extremely useful to easily
    determine whether we are in a dark environment when we don't have problems with
    latencies that can reach one second.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 光敏电阻也被称为**LDR**（即**光敏电阻**）或光电管。请注意，光敏电阻并不是最佳的光感测元件，但当我们没有达到一秒的延迟问题时，它们在轻松确定我们是否处于黑暗环境中时非常有用。
- en: We cannot measure a resistance value with our board. However, we can read voltage
    values, and therefore, we will use a voltage divider configuration that will include
    the photoresistor as one of its two resistors. The voltage divider will output
    a high voltage value when the photoresistor receives a high amount of light and
    it will output a low voltage value when the photoresistor is in a dark zone, that
    is, when it receives little or no light at all.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法使用我们的板子测量电阻值。然而，我们可以读取电压值，因此，我们将使用一个电压分压器配置，其中包括光敏电阻作为其两个电阻之一。当光敏电阻接收到大量光线时，电压分压器将输出高电压值；当光敏电阻处于暗区，即接收到少量或没有光线时，它将输出低电压值。
- en: We learned how to read values from analog pins and map these values back to
    voltage values in the previous examples. We will use this knowledge to determine
    when it becomes dark using the photoresistor. Once we understand how the sensor
    works, we will react to the changes in the light conditions and we will log data
    about specific scenarios.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们学习了如何从模拟引脚读取值并将这些值映射回电压值。我们将使用这些知识来确定何时变暗。一旦我们理解了传感器的工作原理，我们将对光条件的变化做出反应，并记录特定场景的数据。
- en: 'We will use the analog pin labeled **A0** to connect the positive side (+)
    of the voltage divider that includes a photoresistor. After we finish the necessary
    wirings, we will write Python code to determine whether we are in a dark environment
    or not. This way, we will read the result of converting a resistance value into
    a voltage, and then converting this analog value into its digital representation.
    As we learned in our previous example, we will map the read digital value to a
    voltage value and then we will map this voltage value to a darkness measurement
    value. It sounds like a big mess, but it is really easier than it sounds. We need
    the following parts to work with this example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用标有**A0**的模拟引脚来连接包含光敏电阻的电压分压器的正极（+）。完成必要的接线后，我们将编写Python代码来确定我们是否处于黑暗环境中。这样，我们将读取将电阻值转换为电压的结果，然后将这个模拟值转换为它的数字表示。正如我们在之前的例子中学到的，我们将读取的数字值映射到电压值，然后我们将这个电压值映射到黑暗测量值。听起来很复杂，但实际上比听起来容易得多。我们需要以下部分来处理这个例子：
- en: A photoresistor
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光敏电阻
- en: A 10,000Ω (10kΩ) resistor with 5% tolerance (brown black orange gold)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个10,000Ω（10kΩ）的电阻，公差为5%（棕色 黑色 橙色 金色）
- en: 'The following diagram shows the photoresistor and the resistor connected to
    the breadboard, the necessary wirings and the wirings from the Intel Galileo Gen
    2 board to the breadboard. The Fritzing file for the sample is `iot_fritzing_chapter_06_02.fzz`
    and the following picture is the breadboard view:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了连接到面包板的光敏电阻和电阻，必要的布线和从英特尔Galileo Gen 2板到面包板的布线。该示例的Fritzing文件为`iot_fritzing_chapter_06_02.fzz`，以下图片是面包板视图：
- en: '![Wiring a photoresistor to an analog input pin](img/B05042_06_04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![将光敏电阻连接到模拟输入引脚的电路图](img/B05042_06_04.jpg)'
- en: 'The following picture shows the schematic with the electronic components represented
    as symbols:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了用符号表示的电子组件的电路图：
- en: '![Wiring a photoresistor to an analog input pin](img/B05042_06_05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![将光敏电阻连接到模拟输入引脚的电路图](img/B05042_06_05.jpg)'
- en: As seen in the previous schematic, the GPIO pin labeled **A0** in the board's
    symbol is connected to the voltage divider built with the photoresistor named
    **LDR1** and a 10kΩ resistor with 5% tolerance named **R1**. The **LDR1** photoresistor
    is wired to the **IOREF** pin. We already know that the pin labeled **IOREF**
    provides us the IOREF voltage, that is, 5V in our actual configuration. The **R1**
    resistor is wired to **GND** (ground).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，板符号上标记为**A0**的GPIO引脚连接到由名为**LDR1**的光敏电阻和5%公差为10kΩ的电阻**R1**构建的分压器。**LDR1**光敏电阻连接到**IOREF**引脚。我们已经知道标记为**IOREF**的引脚为我们提供IOREF电压，即在我们的实际配置中为5V。**R1**电阻连接到**GND**（地）。
- en: Now, it is time make all the necessary wirings. Don't forget to shutdown the
    Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply
    from the Intel Galileo Gen 2 board before adding or removing any wire from the
    board's pins.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进行所有必要的布线了。在添加或从板上的引脚移除任何电线之前，不要忘记关闭Yocto Linux，等待所有板载LED熄灭，并从英特尔Galileo
    Gen 2板上拔掉电源。
- en: Determining the darkness level with analog inputs and the mraa library
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟输入和mraa库确定黑暗程度
- en: We will create a new `DarknessSensor` class to represent the photoresistor included
    in the voltage divider and connected to our board, specifically, to an analog
    input pin. As we already wrote code to read and transform an analog input, we
    will use the previously created `VoltageInput` class. The following lines show
    the code for the new `DarknessSensor` class that works with the `mraa` library.
    The code file for the sample is `iot_python_chapter_06_02.py`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的`DarknessSensor`类来表示包含在分压器中并连接到我们的板上的光敏电阻，具体来说，是连接到模拟输入引脚。因为我们已经编写了读取和转换模拟输入的代码，所以我们将使用之前创建的`VoltageInput`类。以下行显示了与`mraa`库一起工作的新`DarknessSensor`类的代码。该示例的代码文件为`iot_python_chapter_06_02.py`。
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have to specify the analog pin number to which the voltage divider, which
    includes the photoresistor, is connected when we create an instance of the `DarknessSensor`
    class in the `analog_pin` required argument. The constructor, that is, the `__init__`
    method, creates a new `VoltageInput` instance with the received `analog_pin` as
    its `analog_pin` argument and saves its reference in the `voltage_input` attribute.
    Then, the constructor creates and initializes two attributes: `voltage` and `ambient_light`.
    Finally, the constructor calls the `measure_light` method.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`analog_pin`必需参数中创建`DarknessSensor`类的实例时，我们必须指定连接到包含光敏电阻的分压器的模拟引脚编号。构造函数，即`__init__`方法，使用接收到的`analog_pin`作为其`analog_pin`参数创建一个新的`VoltageInput`实例，并将其引用保存在`voltage_input`属性中。然后，构造函数创建并初始化两个属性：`voltage`和`ambient_light`。最后，构造函数调用`measure_light`方法。
- en: The class defines a `measure_light` method that saves the voltage value retrieved
    by checking the `self.voltage_input.voltage` property in the `voltage` attribute
    (`self.voltage`). This way, the code can check whether the value stored in the
    voltage attribute is lower than the three maximum voltage values that determine
    the light level and sets the appropriate value for the `ambient_light` attribute
    (`self.ambient_light`).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该类定义了一个`measure_light`方法，该方法通过检查`self.voltage_input.voltage`属性在`voltage`属性（`self.voltage`）中检索到的电压值来保存电压值。这样，代码可以检查存储在电压属性中的值是否低于确定光级的三个最大电压值，并为`ambient_light`属性（`self.ambient_light`）设置适当的值。
- en: 'The class defines the following three class attributes that determine the maximum
    voltage values that determine each light level:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 该类定义了以下三个类属性，这些属性确定了确定每个光级的最大电压值：
- en: '`extremely_dark_max_voltage`: If the retrieved voltage is lower than 2V, it
    means that the environment is extremely dark'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extremely_dark_max_voltage`：如果检索到的电压低于2V，这意味着环境非常暗'
- en: '`very_dark_max_voltage`: If the retrieved voltage is lower than 3V, it means
    that the environment is very dark'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`very_dark_max_voltage`: 如果检索到的电压低于3V，这意味着环境非常暗'
- en: '`dark_max_voltage`. If the retrieved voltage is lower than 4V, it means that
    the environment is just dark'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dark_max_voltage`。如果检索到的电压低于4V，这意味着环境只是暗'
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The values are configured for a specific photoresistor and environment conditions.
    You might need to set different values based on the voltage values retrieved with
    the photoresistor included in the voltage divider. Once you run the sample, you
    can check the voltage values and make the necessary adjustments to the voltage
    values stored in the previously explained class attributes. Remember that the
    voltage value will be higher, that is, closer to 5V, when the incident light increases.
    Thus, the darkest environment, the lower the measured voltage.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值是为特定光敏电阻和环境条件配置的。你可能需要根据包含在分压器中的光敏电阻检索到的电压值设置不同的值。一旦运行示例，你可以检查电压值并对之前解释过的类属性中存储的电压值进行必要的调整。记住，当入射光增加时，电压值会更高，即更接近5V。因此，最暗的环境，测量的电压越低。
- en: 'Our goal is to convert a quantitative value, specifically, a voltage value,
    into a qualitative value, that is, a value that explains the real situation in
    a real environment. The class defines the following four class attributes that
    specify the light level descriptions and determine one of the four light levels
    in which a voltage value will be converted after we call the `measure_light` method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是将一个定量值，特别是电压值，转换为定性值，即一个能够解释真实环境中真实情况的值。该类定义了以下四个类属性，指定光级描述并确定在调用`measure_light`方法后电压值将被转换为四个光级中的哪一个：
- en: '`light_extremely_dark`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`light_extremely_dark`'
- en: '`light_very_dark`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`light_very_dark`'
- en: '`light_dark`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`light_dark`'
- en: '`light_no_need_for_a_flashlight`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`light_no_need_for_a_flashlight`'
- en: Now, we can write the code that uses the new `DarkSensor` class to create an
    instance for the photoresistor included in the voltage divider and easily print
    a description of the light conditions. The new class uses the previously created
    `VoltageInput` class to make the necessary calculations to map the read value
    into a voltage value, and then, transforms it into a qualitative value that provides
    us with a description of the light conditions. Now, we will write a loop that
    will check whether the light conditions changed every two seconds. The code file
    for the sample is `iot_python_chapter_06_02.py`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写使用新的`DarkSensor`类创建分压器中包含的光敏电阻实例的代码，并轻松打印光条件描述。新类使用之前创建的`VoltageInput`类进行必要的计算，将读取的值映射到电压值，然后将其转换为定性值，为我们提供光条件描述。现在，我们将编写一个循环，每两秒检查一次光条件是否改变。示例的代码文件是`iot_python_chapter_06_02.py`。
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first line creates an instance of the previously coded `DarknessSensor`
    class with `0` as the value of the `analog_pin` argument and saves the instance
    in the `darkness_sensor` local variable. This way, the instance will use an instance
    of the `VoltageInput` class to read the analog values from the pin labeled **A0**.
    Then, the code initializes the `last_ambient_light` local variable with an empty
    string.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个之前编写的`DarknessSensor`类的实例，将`0`作为`analog_pin`参数的值，并将实例保存在`darkness_sensor`局部变量中。这样，该实例将使用`VoltageInput`类的实例从标记为**A0**的引脚读取模拟值。然后，代码将`last_ambient_light`局部变量初始化为空字符串。
- en: Then, the code runs a loop forever, that is, until you interrupt the execution
    by pressing *Ctrl* + *C* or the button to stop the process in case you are using
    a Python IDE with remote development features to run the code in your board. The
    loop calls the `darkness_sensor.measure_light` method to retrieve the current
    light conditions and saves the updated `darkness_sensor.ambient_light` value in
    the `new_ambient_light` local variable. Then, the code checks whether the `new_ambient_light`
    value is different from `last_ambient_light`. In case they are different, it means
    that the ambient light has changed, and therefore, it sets the value for `last_ambient_light`
    equal to `new_ambient_light`, and prints the ambient light description stored
    in `new_ambient_light`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将无限循环运行，即直到你通过按*Ctrl* + *C*或按下停止过程的按钮来中断执行。在这种情况下，如果你使用具有远程开发功能的Python
    IDE运行代码在你的板上，循环将调用`darkness_sensor.measure_light`方法来检索当前的光线条件，并将更新的`darkness_sensor.ambient_light`值保存在`new_ambient_light`局部变量中。然后，代码检查`new_ambient_light`值是否与`last_ambient_light`不同。如果它们不同，这意味着环境光线已经改变，因此，它将`last_ambient_light`的值设置为`new_ambient_light`，并打印存储在`new_ambient_light`中的环境光线描述。
- en: The loop prints the ambient light description only when it changes from the
    last printed value, and checks the ambient light every two seconds. The following
    line will start the example. Don't forget that you need to transfer the Python
    source code file to the Yocto Linux with an SFTP client.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当环境光线从最后打印的值变化时，循环打印环境光线描述，并且每两秒检查一次环境光线。以下行将启动示例。别忘了你需要使用SFTP客户端将Python源代码文件传输到Yocto
    Linux。
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After you run the example, perform the following actions:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行示例之后，执行以下操作：
- en: Use a smartphone or a flashlight to induce light over the photoresistor
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用智能手机或手电筒在光敏电阻上诱导光线
- en: Use your hand to generate a shadow over the photoresistor
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用你的手在光敏电阻上产生阴影
- en: Reduce the light in the environment, but not the minimum, just make it a bit
    dark
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少环境中的光线，但不是最小值，只是让它稍微暗一些
- en: Reduce the light in the environment to the minimum, a complete dark environment
    with no light at all
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将环境中的光线减少到最小，一个完全没有光线的完全黑暗环境
- en: 'As a result of the previous actions, you should see the following output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前述动作的结果，你应该看到以下输出：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Firing actions when the environment light changes
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境光线变化时的触发动作
- en: 'In previous examples, we worked with PWM to set the brightness level for the
    red, green, and blue components of an RGB LED. Now, we will add an RGB LED and
    we will set the brightness level for its three components based on the ambient
    light detected with the photoresistor. We will wire the RGB LED as we did in the
    example in which we worked with this component in [Chapter 4](ch04.html "Chapter 4. Working
    with a RESTful API and Pulse Width Modulation"), *Working with a RESTful API and
    Pulse Width Modulation*. We will use the following PWM output pins:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们使用PWM来设置RGB LED的红色、绿色和蓝色组件的亮度级别。现在，我们将添加一个RGB LED，并将基于光敏电阻检测到的环境光线为其三个组件设置亮度级别。我们将像在[第4章](ch04.html
    "第4章。使用RESTful API和脉宽调制")中处理此组件的示例那样布线RGB LED，*使用RESTful API和脉宽调制*。我们将使用以下PWM输出引脚：
- en: Pin **~6** to connect the anode pin for red LED
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**~6**引脚连接到红色LED的正极引脚
- en: Pin **~5** to connect the anode pin for green LED
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**~5**引脚连接到绿色LED的正极引脚
- en: Pin **~3** to connect the anode pin for blue LED.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**~3**引脚连接到蓝色LED的正极引脚。
- en: 'We need the following additional parts to work with this example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以下额外的部件来使用此示例：
- en: One common cathode 5mm RGB LED
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个常见的共阴极5mm RGB LED
- en: Three 270Ω resistors with 5% tolerance (red violet brown gold)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个270Ω、5%容差的电阻（红紫棕金）
- en: 'The following diagram shows the components connected to the breadboard, the
    necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard.
    The Fritzing file for the sample is `iot_fritzing_chapter_06_03.fzz` and the following
    picture is the breadboard view:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了连接到面包板的组件，必要的布线和从Intel Galileo Gen 2板到面包板的布线。示例的Fritzing文件为`iot_fritzing_chapter_06_03.fzz`，以下图片是面包板视图：
- en: '![Firing actions when the environment light changes](img/B05042_06_06.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![环境光线变化时的触发动作](img/B05042_06_06.jpg)'
- en: 'The following picture shows the schematic with the electronic components represented
    as symbols:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了用符号表示的电子组件的原理图：
- en: '![Firing actions when the environment light changes](img/B05042_06_07.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![环境光线变化时的触发动作](img/B05042_06_07.jpg)'
- en: As seen in the previous schematic, three PWM capable GPIO pins labeled **D3
    PWM**, **D5 PWM**, and **D6 PWM** in the board's symbol is connected to a 270Ω
    resistor, wired to an anode pin for each LED color, and the common cathode is
    connected to ground.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，板上的符号中标记为**D3 PWM**、**D5 PWM**和**D6 PWM**的三个具有PWM功能的GPIO引脚连接到一个270Ω电阻，该电阻连接到每个LED颜色的阳极引脚，而公共阴极连接到地。
- en: Now, it is time to insert the components in the breadboard and make all the
    necessary wirings. Don't forget to shutdown the Yocto Linux, wait for all the
    onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen
    2 board before adding or removing any wire from the board's pins.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将组件插入面包板并完成所有必要的布线了。在添加或移除任何线之前，别忘了关闭Yocto Linux，等待所有板载LED熄灭，并从Intel Galileo
    Gen 2板上拔掉电源。
- en: We will add the code for the `AnalogLed` class that represent an LED connected
    to our board that can have a brightness level from 0 to 255 inclusive. We created
    this class in [Chapter 4](ch04.html "Chapter 4. Working with a RESTful API and
    Pulse Width Modulation"), W*orking with a RESTful API and Pulse Width Modulation*
    and the code file for the sample was `iot_python_chapter_04_02.py`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加代表连接到我们的板上的LED的`AnalogLed`类的代码，该LED的亮度级别可以从0到255。我们在[第4章](ch04.html "第4章。使用RESTful
    API和脉宽调制")中创建了此类，*使用RESTful API和脉宽调制*，示例代码文件为`iot_python_chapter_04_02.py`。
- en: 'We will create a new `BoardInteraction` class to create an instance of our
    `DarknessSensor` class and one instance for each component of the RGB LED and
    easily control their brightness levels. The following lines show the code for
    the `BoardInteraction` class. The code file for the sample is `iot_python_chapter_06_03.py`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的`BoardInteraction`类来创建我们的`DarknessSensor`类的一个实例以及RGB LED每个组件的一个实例，以便轻松控制它们的亮度级别。以下行显示了`BoardInteraction`类的代码。示例代码文件为`iot_python_chapter_06_03.py`：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `BoardInteraction` class declares four class attributes: `darkness_sensor`,
    `red_led`, `green_led` and `blue_led`. The first class attribute saves a new instance
    of the `DarknessSensor` class and the last three class attributes save new instances
    of the previously imported `AnalogLed` class and represent the red, green, and
    blue LEDs connected to pins **~6**, **~5**, and **~3**. Then, the `BoardInteraction`
    class declares the following two class methods:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoardInteraction`类声明了四个类属性：`darkness_sensor`、`red_led`、`green_led`和`blue_led`。第一个类属性保存了`DarknessSensor`类的新实例，最后三个类属性保存了之前导入的`AnalogLed`类的新实例，分别代表连接到引脚**~6**、**~5**和**~3**的红、绿、蓝LED。然后，`BoardInteraction`类声明了以下两个类方法：'
- en: '`set_rgb_led_brightness`: Sets the same brightness level received in the `brightness_level`
    argument to the three components of the RGB LED.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_rgb_led_brightness`：将`brightness_level`参数接收到的相同亮度级别设置为RGB LED的三个组件。'
- en: '`update_leds_brightness`: Sets the brightness level for the three components
    of the RGB LED based on the `ambient_light` value of the DarknessSensor instance
    (`cls.darkness_sensor`). If it is extremely dark, the brightness level will be
    255\. If it is very dark, the brightness level will be 128\. If it is dark, the
    brightness level will be 64\. Otherwise, the RGB LED will be completely turned
    off.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_leds_brightness`：根据DarknessSensor实例（`cls.darkness_sensor`）的`ambient_light`值设置RGB
    LED的三个组件的亮度级别。如果非常暗，亮度级别将为255。如果很暗，亮度级别将为128。如果暗，亮度级别将为64。否则，RGB LED将完全关闭。'
- en: Now, we can write a code that uses the new `BoardInteraction` class to measure
    the ambient light and set the brightness for the RGB LED based on the retrieved
    value. As in our previous example, we will only make changes when the ambient
    light value changes from the current value. We will write a loop that will check
    whether the light conditions changed every two seconds. The code file for the
    sample is `iot_python_chapter_06_03.py`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写一个代码，使用新的`BoardInteraction`类来测量环境光线并根据获取的值设置RGB LED的亮度。正如我们之前的示例一样，我们只有在环境光线值从当前值变化时才会进行更改。我们将编写一个循环，每两秒检查一次光线条件是否发生变化。示例代码文件为`iot_python_chapter_06_03.py`。
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first line initializes the `last_ambient_light` local variable with an empty
    string. Then, the code runs a loop forever, that is, until you interrupt the execution.
    The loop calls the `BoardInteraction.darkness_sensor.measure_light` method to
    retrieve the current light conditions and saves the updated `BoardInteraction.darkness_sensor.ambient_light`
    value in the `new_ambient_light` local variable. Then, the code checks whether
    the `new_ambient_light` value is different from `last_ambient_light`. In case
    they are different, it means that the ambient light has changed, and therefore,
    it sets the value for `last_ambient_light` equal to `new_ambient_light`, prints
    the ambient light description stored in `new_ambient_light` and calls the `BoardInteraction.update_leds_brightness`
    method to set the brightness for the RGB LED based on the ambient light.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行初始化`last_ambient_light`局部变量为空字符串。然后，代码无限循环运行，即直到你中断执行。循环调用`BoardInteraction.darkness_sensor.measure_light`方法来检索当前光线条件，并将更新的`BoardInteraction.darkness_sensor.ambient_light`值保存到`new_ambient_light`局部变量中。然后，代码检查`new_ambient_light`值是否与`last_ambient_light`不同。如果它们不同，这意味着环境光线已经改变，因此，它将`last_ambient_light`的值设置为`new_ambient_light`，打印存储在`new_ambient_light`中的环境光线描述，并调用`BoardInteraction.update_leds_brightness`方法根据环境光线设置RGB
    LED的亮度。
- en: The following line will start the example. Don't forget that you need to transfer
    the Python source code file to the Yocto Linux with an SFTP client.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将开始示例。别忘了你需要使用SFTP客户端将Python源代码文件传输到Yocto Linux。
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After you run the example, perform the following actions, and you will see
    the RGB LED changing its brightness level as explained:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行示例之后，执行以下操作，你将看到RGB LED的亮度级别按以下方式变化：
- en: Use a smartphone or a flashlight to induce light over the photoresistor. The
    RGB LED will stay turned off.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用智能手机或手电筒在光敏电阻上产生光线。RGB LED将保持关闭。
- en: Use your hand to generate a shadow over the photoresistor. The RGB LED will
    turn on with a dimmed light.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用你的手在光敏电阻上产生阴影。RGB LED将以昏暗的灯光打开。
- en: Reduce the light in the environment, but not the minimum, just make it a bit
    dark. The RGB LED will increase its brightness.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少环境中的光线，但不是最小，只是让它变得有点暗。RGB LED将增加其亮度。
- en: Reduce the light in the environment to the minimum, a complete dark environment
    with no light at all. The RBG LED will increase its brightness to the maximum
    level.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将环境中的光线减少到最小，一个完全没有光线的完全黑暗环境。RGB LED将增加其亮度到最大级别。
- en: Use a smartphone or a flashlight to induce light over the photoresistor, again.
    The RGB LED will turn off.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用智能手机或手电筒再次在光敏电阻上产生光线。RGB LED将关闭。
- en: 'As a result of the previous actions, you should see the following output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于之前的操作，你应该看到以下输出：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We wrote object-oriented Python code that is easy to read and understand. With
    the help of the `mraa` library, we could easily fire actions when the environment
    light changes. We could control the brightness for an RGB LED when the ambient
    light changed. We worked with an analog input to determine the ambient light level
    and we used PWM to generate an analog output and control the RGB LED brightness
    level.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了易于阅读和理解的面向对象Python代码。借助`mraa`库，我们能够在环境光线变化时轻松触发动作。当环境光线改变时，我们可以控制RGB LED的亮度。我们使用模拟输入来确定环境光线水平，并使用PWM生成模拟输出以控制RGB
    LED的亮度级别。
- en: Controlling analog inputs with the wiring-x86 library
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用wiring-x86库控制模拟输入
- en: So far, we have been using the `mraa` library to work with analog inputs and
    retrieve the ambient light level. However, we have also been working with the
    `wiring-x86` library in our previous examples. We can change just a few lines
    of our object-oriented code to replace the `mraa` library with the `wiring-x86`
    one to read analog values.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用`mraa`库来处理模拟输入并检索环境光线水平。然而，我们也在之前的示例中使用了`wiring-x86`库。我们只需更改几行面向对象的代码，就可以用`wiring-x86`库替换`mraa`库来读取模拟值。
- en: First, we have to replace the code for the `AnalogLed` class with the version
    that works with the `wiring-x86` library. We created this version in [Chapter
    4](ch04.html "Chapter 4. Working with a RESTful API and Pulse Width Modulation"),
    *Working with a RESTful API and Pulse Width Modulation*, and the code file for
    the sample was `iot_python_chapter_04_04.py`. When we grab the code for the `AnalogLed`
    class, we will also have the `Board` class.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须用与`wiring-x86`库兼容的版本替换`AnalogLed`类的代码。我们在[第4章](ch04.html "第4章。使用RESTful
    API和脉冲宽度调制")中创建了此版本，*使用RESTful API和脉冲宽度调制*，示例代码文件为`iot_python_chapter_04_04.py`。当我们获取`AnalogLed`类的代码时，我们也将获得`Board`类。
- en: The following lines shows the new version of the `VoltageInput` class that works
    with the `wiring-x86` library instead of using `mraa`. The code file for the sample
    is `iot_python_chapter_06_04.py`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了与`wiring-x86`库兼容而不是使用`mraa`的`VoltageInput`类的新版本。示例代码文件为`iot_python_chapter_06_04.py`。
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We created a new version of the `VoltageInput` class that declares an `initial_analog_pin_number`
    class attribute set to `14`. The `wiring-x86` library uses Arduino compatible
    numbers to reference the analog input pins or ADC pins. Thus, analog input pin
    `0` is known as `14`, analog input pin `1` as `15`, and so on. As we don't want
    to make changes to the rest of our code, we use a class attribute to specify the
    number that we must sum to the received `analog_pin` value to convert it to a
    `wiring-x86` analog pin number.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`VoltageInput`类版本，该版本声明了一个`initial_analog_pin_number`类属性，并将其设置为`14`。`wiring-x86`库使用Arduino兼容的数字来引用模拟输入引脚或ADC引脚。因此，模拟输入引脚`0`被称为`14`，模拟输入引脚`1`被称为`15`，依此类推。由于我们不希望修改代码的其他部分，我们使用类属性来指定必须加到接收到的`analog_pin`值上以将其转换为`wiring-x86`模拟引脚编号的数字。
- en: The constructor, that is, the `__init__` method, saves a reference to the `Board.gpio`
    class attribute in `self.gpio` and calls its `pinMode` method with the received
    `analog_pin` and the value specified in `initial_analog_pin_number` class attribute
    as its `pin` argument, and `self.gpio.ANALOG_INPUT` as its `mode` argument. This
    way, we configure the pin to be an analog input pin converting the analog input
    pin number into a `wiring-x86` compatible analog input pin number. The `wiring-x86`
    library doesn't make a difference between GPIO and analog I/O pins, and we can
    manage all of them through the `Board.gpio` class attribute.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数，即`__init__`方法，将`Board.gpio`类属性的引用保存到`self.gpio`中，并使用接收到的`analog_pin`和`initial_analog_pin_number`类属性中指定的值作为其`pin`参数，以及`self.gpio.ANALOG_INPUT`作为其`mode`参数调用其`pinMode`方法。这样，我们配置引脚为模拟输入引脚，将模拟输入引脚编号转换为`wiring-x86`兼容的模拟输入引脚编号。`wiring-x86`库在GPIO和模拟I/O引脚之间没有区别，我们可以通过`Board.gpio`类属性来管理它们。
- en: All the `VoltageInput` instances will save a reference to the same `Board.gpio`
    class attribute that created an instance of the `GPIO` class, specifically, the
    `wiringx86.GPIOGalileoGen2` class with its `debug` argument set to `False` to
    avoid unnecessary debug information for the low-level communications.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`VoltageInput`实例都将保存对创建`GPIO`类实例的同一`Board.gpio`类属性的引用，特别是具有`debug`参数设置为`False`的`wiringx86.GPIOGalileoGen2`类，以避免为低级通信提供不必要的调试信息。
- en: The class defines a `voltage` property that calls the `analogRead` method for
    the GPIO instance (`self.gpio`) to retrieve the raw value from the analog pin
    and saves it in the `raw_value` variable. The result of the `self.analog_pin`
    attribute plus the value specified in `initial_analog_pin_number` class attribute
    specifies the `pin` value for the `analogRead` method call. Then, the code returns
    the result of dividing `raw_value` by `1023` and multiplying it by `5`. This way,
    the property returns the voltage value, converted from the raw value returned
    by the `analogRead` function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 该类定义了一个`voltage`属性，该属性调用GPIO实例（`self.gpio`）的`analogRead`方法以从模拟引脚获取原始值，并将其保存到`raw_value`变量中。`self.analog_pin`属性加上`initial_analog_pin_number`类属性中指定的值指定了`analogRead`方法调用中的`pin`值。然后，代码返回`raw_value`除以`1023`再乘以`5`的结果。这样，该属性返回电压值，该值是从`analogRead`函数返回的原始值转换而来的。
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Unluckily, the `wiring-x86` library doesn't support 12 bit of resolution for
    the analog to digital converter. The library works with a fixed 10 bit of resolution,
    and therefore, we are only able to detect 1024 different values (2^(10) = 1024),
    or 1024 units, with values ranging from 0 to 1023 (inclusive), where 0 represents
    0V and 1023 means 5V. For this reason, we have to divide raw_value by `1023` instead
    of `4095` within the `voltage` property.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`wiring-x86`库不支持模拟数字转换器的12位分辨率。该库使用固定的10位分辨率，因此我们只能检测到1024个不同的值（2^10 =
    1024），或1024个单位，其值范围从0到1023（包含），其中0代表0V，1023代表5V。因此，我们必须在`voltage`属性中将原始值除以`1023`而不是`4095`。
- en: The rest of the code remains the same one that we have used for the previous
    example. There is no need to make changes to the `DarknessSensor` class, the `BoardInteraction`
    class or the main loop because they will automatically work with the new `VoltageInput`
    class and there were no changes in the arguments for its constructor or its `voltage`
    property.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分与之前示例中使用的相同。不需要对`DarknessSensor`类、`BoardInteraction`类或主循环进行更改，因为它们将自动与新`VoltageInput`类一起工作，并且其构造函数或`voltage`属性的参数没有发生变化。
- en: 'The following line will start the new version of the example that works with
    the `wiring-x86` library:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将启动与`wiring-x86`库一起工作的示例的新版本：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We can make the same changes in the incident light over the photoresistor that
    we made in our previous example to check that we can achieve exactly the same
    results with the `wiring-x86` library. The only difference will be in the precision
    of the voltage values retrieved because we are working with 10 bits of resolution
    in the analog to digital converter in this case.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在之前示例中对光敏电阻上的入射光进行相同的更改，以检查我们是否可以使用`wiring-x86`库实现完全相同的结果。唯一的区别将是检索到的电压值的精度，因为我们在这个情况下使用的是模拟数字转换器的10位分辨率。
- en: Logging to files in the local storage
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地存储中记录日志
- en: Python provides a powerful and flexible logging API provided by a standard library
    module. We can use the logging module to track events that happen when our IoT
    applications run on the board and save them on a log file by taking advantage
    of the local storage options.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一个强大且灵活的日志API，由标准库模块提供。我们可以使用日志模块来跟踪在板上运行我们的物联网应用程序时发生的事件，并通过利用本地存储选项将它们保存到日志文件中。
- en: Now, we will make changes to our last version of our previous example that worked
    with the `mraa` library to log the voltage values read from the ambient light
    sensor. We only want to log the new voltage value when the ambient light changes,
    that is, when the value for `BoardInteraction.darkness_sensor.ambient_light` mutates.
    We will use the previous code as a baseline to add the new logging features. The
    code file for the sample was `iot_python_chapter_06_03.py`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对我们之前使用`mraa`库工作的示例的最后版本进行更改，以记录从环境光传感器读取的电压值。我们只想在环境光发生变化时记录新的电压值，即当`BoardInteraction.darkness_sensor.ambient_light`的值发生变化时。我们将使用之前的代码作为基准来添加新的日志功能。示例的代码文件为`iot_python_chapter_06_03.py`。
- en: We will replace the `__main__` method. The following lines show the new version
    that adds logging capabilities. The new lines of code are highlighted and the
    code file for the sample is `iot_python_chapter_06_05.py`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将替换`__main__`方法。以下行展示了添加了日志功能的新版本。新的代码行被突出显示，示例的代码文件为`iot_python_chapter_06_05.py`。
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first line calls the `logging.basicConfig` method to do the basic configuration
    for the logging system. The `fileName` argument specifies `"iot_python_chapter_06_05.log"`
    as the file name we want to use for logging. As we don't specify a value for the
    `fileMode` argument, the default `'a'` mode is used and the messages from successive
    runs will be appended to the specified log file name, that is, the file will never
    be overwritten.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行调用`logging.basicConfig`方法来对日志系统进行基本配置。`fileName`参数指定了我们要用于日志记录的文件名`"iot_python_chapter_06_05.log"`。由于我们没有为`fileMode`参数指定值，因此使用默认的`'a'`模式，连续运行的消息将被追加到指定的日志文件名，即文件不会被覆盖。
- en: Tip
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We didn't specify any path in the `fileName` argument, and therefore, the log
    file will be created in the same folder in which the Python script runs, that
    is, the `/home/root` folder. In this case, the log file will be using the storage
    space available in the microSD card that boots the Yocto Linux distribution.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`fileName`参数中未指定任何路径，因此，日志文件将在Python脚本运行的同一文件夹中创建，即`/home/root`文件夹。在这种情况下，日志文件将使用启动Yocto
    Linux分发的microSD卡上的可用存储空间。
- en: The `format` argument specifies `"%(asctime)s %(message)s"` because we want
    to store the date and time followed by a message. The `datefmt` argument specifies
    `"%m/%d/%Y %I:%M:%S %p"` as the date and time format we want to use for the date
    and time that will be included as a prefix for all the lines appended to the log.
    We want a short date (month/date/year) followed by a short time (hours/minutes/seconds
    AM/PM). We just want to log the information logs to the file, and therefore, the
    `level` argument specifies `logging.INFO` to set the root logger level to this
    value.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`format`参数指定了`"%(asctime)s %(message)s"`，因为我们希望存储日期和时间，然后是消息。`datefmt`参数指定了`"%m/%d/%Y
    %I:%M:%S %p"`作为我们希望用于包含在所有附加到日志的行前面的日期和时间格式的日期和时间。我们想要一个简短的日期（月/日/年），后面跟着一个简短的时间（小时/分钟/秒
    AM/PM）。我们只想将信息日志记录到文件中，因此，`level`参数指定了`logging.INFO`，将根日志记录器级别设置为该值。'
- en: 'The next line calls the `logging.info` method to log the first event: the application
    that has started its execution. Before entering into the loop, the code declared
    a new `last_voltage` local variable and initializes it to `0.0`. We want to log
    the previous voltage and the new voltage whenever the ambient light changes, and
    therefore, it is necessary to save the last voltage in a new variable. When the
    ambient light changes, a call to the `logging.info` method logs the transition
    from the previous voltage to the new voltage value. However, it is very important
    to notice that the first time this method is called, the previous voltage will
    be equal to `0.0`. The next line saves the value for the `BoardInteraction.darkness_sensor.voltage`
    in the `last_voltage` variable.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行调用`logging.info`方法来记录第一个事件：开始执行的应用程序。在进入循环之前，代码声明了一个新的`last_voltage`局部变量并将其初始化为`0.0`。我们希望在环境光改变时记录前一次电压和新的电压值，因此，将最后一次电压保存在新变量中是必要的。当环境光改变时，对`logging.info`方法的调用将记录从前一次电压到新电压值的转换。然而，非常重要的一点是要注意，当此方法第一次被调用时，前一次电压将等于`0.0`。下一行将`BoardInteraction.darkness_sensor.voltage`的值保存到`last_voltage`变量中。
- en: 'The following line will start the new version of the example that will create
    the `iot_python_chapter_06_05.log` file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将启动新版本的示例，该示例将创建`iot_python_chapter_06_05.log`文件：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Keep the Python script running for a few minutes and make many changes in the
    incident light over the photoresistor. This way, you will generate many lines
    in the log file. Then, you can use your favorite SFTP client to download the log
    file from `/home/root` and read it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让Python脚本运行几分钟，并对光敏电阻上的入射光进行多次更改。这样，你将在日志文件中生成许多行。然后，你可以使用你喜欢的SFTP客户端从`/home/root`下载日志文件并阅读它。
- en: 'The following lines show some sample lines generated in the log file after
    executing the application:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了在执行应用程序后生成的日志文件中的某些示例行：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Working with USB attached storage
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理USB附加存储
- en: Log files that record events related to sensors can grow really fast, and therefore,
    storing log files in the the microSD storage space might become a problem. We
    can work with microSD cards up to 32 GB. Thus, one option is to create the Yocto
    Linux image on a bigger microSD card and continue working with a single storage.
    This would require us to expand the partition from the default image. The other
    option is to take advantage of the cloud and just keep a constrained log in our
    local storage. However, we will work with this option later. Now, we want to explore
    the additional options we have to use local storage.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 记录与传感器相关事件的日志文件可能会迅速增长，因此，将日志文件存储在microSD存储空间可能会成为一个问题。我们可以处理高达32 GB的microSD卡。因此，一个选项是在更大的microSD卡上创建Yocto
    Linux镜像，并继续使用单个存储空间。这将需要我们从默认镜像中扩展分区。另一个选项是利用云服务，只需在我们的本地存储中保留受限制的日志。然而，我们将在稍后处理这个选项。现在，我们想要探索我们使用本地存储的附加选项。
- en: As we learned in [Chapter 1](ch01.html "Chapter 1. Understanding and Setting
    up the Base IoT Hardware"), *Understanding and Setting up the Base IoT Hardware*,
    The Intel Galileo Gen 2 board provides a USB 2.0 host connector, labeled **USB
    HOST**. We can use this connector to plug a USB thumb drive for additional storage
    and save the log file in this new storage.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第1章](ch01.html "第1章。理解和设置基础物联网硬件")中学习到的，*理解和设置基础物联网硬件*，英特尔Galileo Gen 2板提供了一个标记为**USB
    HOST**的USB 2.0主机连接器。我们可以使用此连接器插入USB闪存驱动器以进行额外存储，并将日志文件保存到新存储中。
- en: 'Before you plug any USB thumb drive, run the following command in the SSH terminal
    to list the partition tables:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入任何USB闪存驱动器之前，请在SSH终端中运行以下命令以列出分区表：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following lines show an example of the output generated by the previous
    command. Your output might be different because it depends on the microSD card
    that you are using to boot Yocto Linux. Notice that the `/dev/mmcblk0` disk identifies
    the microSD card and you have two partitions: `/dev/mmcblk0p1` and `/dev/mmcblk0p2`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了由上一个命令生成的输出示例。您的输出可能不同，因为它取决于您用于引导Yocto Linux的微SD卡。请注意，`/dev/mmcblk0`磁盘标识了微SD卡，并且您有两个分区：`/dev/mmcblk0p1`和`/dev/mmcblk0p2`。
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we will plug a USB thumb drive to the board's USB 2.0 host connector, we
    will run the necessary commands to mount it, and then we will make change to the
    code to save the log in a folder within the USB thumb drive. You will need a preformatted
    USB thumb drive compatible with USB 2.0 to run this example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把一个USB闪存驱动器插入到板载的USB 2.0主机连接器，我们将运行必要的命令来挂载它，然后我们将修改代码以将日志保存到USB闪存驱动器内的一个文件夹中。您需要一个与USB
    2.0兼容的预格式化USB闪存驱动器来运行此示例。
- en: The following picture shows a USB thumb drive plugged to the board's USB 2.0
    host connector, labeled **USB HOST**. Wait a few seconds after you plug the USB
    thumb drive.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了连接到板载USB 2.0主机连接器的USB闪存驱动器，标记为**USB HOST**。插入USB闪存驱动器后，请等待几秒钟。
- en: '![Working with USB attached storage](img/B05042_06_08.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![使用USB附加存储](img/B05042_06_08.jpg)'
- en: 'Yocto Linux will add a new block device to the `/dev` folder. Run the following
    command in the SSH terminal to list the partition tables:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto Linux将在`/dev`文件夹中添加一个新的块设备。在SSH终端中运行以下命令以列出分区表：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The following lines show an example of the output generated by the previous
    command. Your output might be different because it depends on the USB drive and
    also on the microSD card that you are using. Compare the output with the output
    generated when you executed the same command before you plugged the USB thumb
    drive. The additional lines provide information about the USB thumb drive, its
    disk name, and its partitions. The highlighted lines show the partition details
    for the USB thumb, identified as the `/dev/sda` disk and with a FAT32 partition
    `/dev/sda1`. We will use this partition name for one of our next steps.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了由上一个命令生成的输出示例。您的输出可能不同，因为它取决于您使用的USB驱动器和微SD卡。将输出与您在插入USB闪存驱动器之前执行相同命令时生成的输出进行比较。附加的行提供了有关USB闪存驱动器、其磁盘名称和其分区的信息。突出显示的行显示了USB分区的详细信息，标识为`/dev/sda`磁盘和FAT32分区`/dev/sda1`。我们将使用此分区名称作为我们下一步操作之一。
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, it is necessary to create a mount point. We have to create a new sub-folder
    in the `/media` folder. We will use `usb` as the name for the sub-folder, and
    therefore, the folder in which we will mount the drive will be `/media/usb`. Run
    the following command to create the folder:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有必要创建一个挂载点。我们必须在`/media`文件夹中创建一个新的子文件夹。我们将使用`usb`作为子文件夹的名称，因此我们将挂载驱动器的文件夹将是`/media/usb`。运行以下命令以创建文件夹：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Run the following command to mount the partition in the recently created `/media/usb`
    folder. In the previous steps we retrieved the partition name and it was named
    `/dev/sda1`. Your partition name might be different, and therefore, you just need
    to replace `/dev/sda1` with your partition name listed when you executed the fdisk
    command that listed the disks and their partitions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令在最近创建的`/media/usb`文件夹中挂载分区。在之前的步骤中，我们检索了分区名称，它被命名为`/dev/sda1`。您的分区名称可能不同，因此您只需将`/dev/sda1`替换为您在执行列出磁盘及其分区的fdisk命令时列出的分区名称即可。
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, we can access the contents of the USB thumb drive through the `/media/usb`
    folder, that is, whenever we create a folder or file in this folder, we are writing
    to the USB thumb drive partition.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过`/media/usb`文件夹访问USB闪存驱动器的内容，也就是说，无论何时我们在该文件夹中创建文件夹或文件，我们都是在向USB闪存驱动器分区写入。
- en: 'Run the following command to create a new `/media/usb/log` folder in which
    we will store the log for our IoT application:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以创建一个新的`/media/usb/log`文件夹，我们将在此文件夹中存储我们的物联网应用的日志：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, we will change the value we pass to the filename argument when we call
    the `logging.basicConfig` method within the `__main__` method. We want to save
    the log file within the `/media/usb/log` folder. This way, we will store it in
    the USB thumb drive, in the `log` folder. We will use the previous code as a baseline
    to change the log file name and its path. The code file for the sample was `iot_python_chapter_06_05.py`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更改在`__main__`方法中调用`logging.basicConfig`方法时传递给文件名参数的值。我们想在`/media/usb/log`文件夹中保存日志文件。这样，我们将它存储在USB闪存驱动器的`log`文件夹中。我们将使用之前的代码作为基准来更改日志文件名及其路径。示例代码文件是`iot_python_chapter_06_05.py`。
- en: The following lines show the new code that calls the `logging.basicConfig` method
    and the code file for the sample is `iot_python_chapter_06_06.py`. The rest of
    the code remains the same we have used in our previous example.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了调用`logging.basicConfig`方法的新代码和示例代码文件`iot_python_chapter_06_06.py`。其余的代码与我们在前面的示例中使用的一样。
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following line will start the new version of the example that will create
    the `iot_python_chapter_06_06.log` file in the `/media/usb/log` folder:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将启动新版本的示例，该示例将在`/media/usb/log`文件夹中创建`iot_python_chapter_06_06.log`文件：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Keep the Python script running for a few minutes and make many changes in the
    incident light over the photoresistor. This way, you will generate many lines
    in the log file. Then, you can use your favorite SFTP client to download the log
    file from `/media/usb/log` and read it. However, don't forget to go back to the
    `home/root` folder in your SFTP client because this is the folder in which you
    upload the Python scripts.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 保持Python脚本运行几分钟，并对光敏电阻上的环境光进行多次更改。这样，你将在日志文件中生成多行。然后，你可以使用你喜欢的SFTP客户端从`/media/usb/log`下载日志文件并阅读它。然而，别忘了在你的SFTP客户端中返回到`home/root`文件夹，因为这是上传Python脚本的那个文件夹。
- en: If you need to unplug the USB thumb drive to plug it on another computer or
    device, first you must interrupt the execution of the Python script, and then,
    you must run the following command to unmount the partition. In the previous steps
    we retrieved the partition name and it was named `/dev/sda1`. Your partition name
    might be different, and therefore, you just need to replace `/dev/sda1` with your
    partition name listed when you executed the `fdisk` command that listed the disks
    and their partitions. Be careful and make sure you run this command on the terminal
    that is running the shell on the Yocto Linux. Make sure you see the `root@galileo:~#`
    prompt before you execute it. If you run the command in a computer that runs Linux
    or OS X, you might unmount one of your drives.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将USB闪存驱动器拔出以连接到另一台计算机或设备，首先你必须中断Python脚本的执行，然后，你必须运行以下命令来卸载分区。在前面的步骤中，我们检索了分区名称，它被命名为`/dev/sda1`。你的分区名称可能不同，因此，你只需将`/dev/sda1`替换为你执行列出磁盘及其分区的`fdisk`命令时列出的分区名称。请小心，并确保你在运行Yocto
    Linux上的shell的终端上运行此命令。在执行之前，请确保你看到`root@galileo:~#`提示符。如果你在运行Linux或OS X的计算机上运行此命令，你可能会卸载你的一个驱动器。
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, you can remove the USB thumb drive from the USB 2.0 host connector.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以从USB 2.0主机连接器中拔出USB闪存驱动器。
- en: Test your knowledge
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'The Intel Galileo Gen 2 board provides the following resolution for the analog
    to digital converter:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Intel Galileo Gen 2板为模拟数字转换器提供以下分辨率：
- en: 32 bits.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 32位。
- en: 64 bits.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 64位。
- en: 12 bits.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 12位。
- en: 'The analog pins allow us to detect a maximum of:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟引脚允许我们检测的最大值：
- en: 4,096 different values, with values ranging from 0 to 4095 (inclusive).
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4096个不同的值，值的范围从0到4095（包含）。
- en: 16,384 different values, with values ranging from 0 to 16,383 (inclusive).
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 16384个不同的值，值的范围从0到16383（包含）。
- en: 256 different values, with values ranging from 0 to 255 (inclusive).
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 256个不同的值，值的范围从0到255（包含）。
- en: 'We can configure the number of bits we want to use as the resolution by calling
    the following method of an `mraa.Aio` instance:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过调用`mraa.Aio`实例的以下方法来配置我们想要使用的位数作为分辨率：
- en: '`setADCResolution`.'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setADCResolution`。'
- en: '`setBit`.'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setBit`。'
- en: '`setResolutionBits`.'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setResolutionBits`。'
- en: 'A call to the `read` method for a `mraa.Aio` instance returns:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`mraa.Aio`实例的`read`方法的调用返回：
- en: A raw number of units based on the number of the resolution bits configured
    for the instance.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于为实例配置的分辨率位数的一个原始单位数。
- en: A voltage value automatically converted from the raw number of units.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个从原始单位数自动转换的电压值。
- en: A resistance value measured in Ohms (Ω).
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个以欧姆（Ω）为单位的电阻值。
- en: 'We can use analog pins to read:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用模拟引脚来读取：
- en: Resistance values.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电阻值。
- en: Current values.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电流值。
- en: Voltage values.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电压值。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to work with analog inputs to measure voltage
    values. We understood the impact of the different bits of resolution for the analog
    to digital converter and we wrote code that converted the raw units read into
    voltage values.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用模拟输入来测量电压值。我们理解了模拟数字转换器不同位分辨率的影响，并编写了将读取的原始单位转换为电压值的代码。
- en: We measure voltages with an analog pin and both the mraa and the wiring-x86
    library. We were able to transform a variable resistor into a voltage source and
    make it possible to measure the darkness level with an analog input, a photoresistor
    and a voltage divider.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用模拟引脚和mraa以及wiring-x86库来测量电压。我们能够将可变电阻转换成电压源，并使其能够通过模拟输入、光敏电阻和分压器来测量黑暗程度。
- en: As in the previous chapters, we continued taking advantage of Python's object-oriented
    features and created classes to encapsulate voltage inputs, darkness sensors,
    and the necessary configurations with the mraa and wiring-x86 libraries. Our code
    is easy to read and understand and we can easily switch the underlying low-level
    library.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，我们继续利用Python的面向对象特性，并创建了类来封装电压输入、光敏传感器以及必要的配置，使用mraa和wiring-x86库。我们的代码易于阅读和理解，并且我们可以轻松切换底层低级库。
- en: We fired actions when the environment light changed and we were able to work
    with both analog inputs and analog outputs. Finally, we registered events by taking
    advantage of the logging features included in the Python standard library. We
    also learned to take advantage of the USB 2.0 host connector included in the Intel
    Galileo Gen 2 board to plug a USB thumb and use it as an additional storage.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当环境光线变化时，我们触发了动作，并且能够同时处理模拟输入和模拟输出。最后，我们通过利用Python标准库中包含的日志功能来注册事件。我们还学会了利用英特尔Galileo
    Gen 2板中包含的USB 2.0主机连接器来插入USB闪存驱动器并将其用作额外的存储。
- en: Now that we were able to read the analog inputs in different ways and configurations
    that made it possible for our IoT device to read analog values generated by changed
    in the environment, we can work with a wider variety of sensors to retrieve data
    from the real world, which is the topic of the next chapter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够以不同的方式和配置读取模拟输入，这使得我们的物联网设备能够读取由环境变化产生的模拟值，我们可以与更多种类的传感器一起工作，从现实世界获取数据，这是下一章的主题。
