- en: Running Automated Test Suites with Nose
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Nose运行自动化测试套件
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下示例：
- en: Getting nosy with testing
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用测试变得多管闲事
- en: Embedding nose inside Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将鼻子嵌入Python中
- en: Writing a nose extension to pick tests based on regular expressions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个nose扩展来基于正则表达式选择测试
- en: Writing a nose extension to generate a CSV report
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个nose扩展来生成CSV报告
- en: Writing a project-level script that lets you run different test suites
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个项目级脚本，让您运行不同的测试套件
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we looked at several ways to utilize unittest in creating
    automated tests. Now, we will look at different ways to gather tests together
    and run them. Nose is a useful utility that was built to discover tests and run
    them. It is flexible, can be run from either the command-line or embedded inside
    scripts, and is extensible through plugin. Due to its embeddable nature and high-level
    tools, such as project scripts, it can be built with testing as an option.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看了几种利用unittest创建自动化测试的方法。现在，我们将看看不同的方法来收集测试并运行它们。Nose是一个有用的实用程序，用于发现测试并运行它们。它灵活，可以从命令行或嵌入式脚本运行，并且可以通过插件进行扩展。由于其可嵌入性和高级工具（如项目脚本），可以构建具有测试选项的工具。
- en: What does nose offer that unittest does not? Key things include automatic test
    discovery and a useful plugin API. There are many nose plugins that provide everything
    from specially formatted test reports to integration with other tools. We will
    explore this in more detail in this chapter and in later parts of this book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: nose提供了unittest没有的东西吗？关键的东西包括自动测试发现和有用的插件API。有许多nose插件，提供从特殊格式的测试报告到与其他工具集成的一切。我们将在本章和本书的后面部分更详细地探讨这一点。
- en: For more information about nose refer to: [http://somethingaboutorange.com/mrl/projects/nose](http://somethingaboutorange.com/mrl/projects/nose).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有关nose的更多信息，请参阅：[http://somethingaboutorange.com/mrl/projects/nose](http://somethingaboutorange.com/mrl/projects/nose)。
- en: We need to activate our virtual environment and then install nose for the recipes
    in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要激活我们的虚拟环境，然后为本章的示例安装nose。
- en: 'Create a virtual environment, activate it, and verify that the tools are working:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个虚拟环境，激活它，并验证工具是否正常工作：
- en: '![](../images/00019.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00019.jpeg)'
- en: 'Next, use `pip install nose`, as shown in the following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`pip install nose`，如下面的截图所示：
- en: '![](../images/00020.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00020.jpeg)'
- en: Getting nosy with testing
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用测试变得多管闲事
- en: Nose automatically discovers tests when fed with a package, a module, or a file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供一个包、一个模块或一个文件时，nose会自动发现测试。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With the following steps, we will explore how nose automatically finds test
    cases and runs them:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，我们将探讨nose如何自动发现测试用例并运行它们：
- en: Create a new file called `recipe11.py` to store all the code for this recipe.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe11.py`的新文件，用于存储此示例的所有代码。
- en: 'Create a class to test. For this recipe, we will use a shopping cart application
    that lets us load items and then calculate the bill:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于测试的类。对于这个示例，我们将使用一个购物车应用程序，让我们加载物品，然后计算账单：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a test case that exercises the various parts of the shopping cart application:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试用例，练习购物车应用程序的各个部分：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use the command-line `nosetests` tool to run this recipe by filename and also
    by module:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令行`nosetests`工具按文件名和模块运行此示例：
- en: '![](../images/00021.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00021.jpeg)'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We started off by creating a simple application that lets us load up a `ShoppingCart`
    with `Items`. This application lets us look up each item and its price. Finally,
    we can calculate the total billing amount including the sales tax.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个简单的应用程序，让我们用`Items`加载`ShoppingCart`。这个应用程序让我们查找每个物品及其价格。最后，我们可以计算包括销售税在内的总账单金额。
- en: Next, we coded some test methods to exercise all these features using unittest.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写了一些测试方法，以使用unittest来练习所有这些功能。
- en: Finally, we used the command-line `nosetests` tool, which discovers test cases
    and automatically runs them. This saved us from hand coding a test runner to load
    test suites.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用了命令行`nosetests`工具，它发现测试用例并自动运行它们。这样可以避免手动编写测试运行器来加载测试套件。
- en: There's more...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Why is it so important to not write the test runner? What do we gain by using
    `nosetests`? After all, unittest gives us the ability to embed an auto-discovering
    test runner like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不编写测试运行器如此重要？使用`nosetests`我们能获得什么？毕竟，unittest给了我们嵌入自动发现测试运行器的能力，就像这样：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Would the same block of code work if the tests are spread across several modules?
    No, because `unittest.main()` only looks in the current module. To grow into multiple
    modules, we need to start loading tests using unittest's `loadTestsFromTestCase`
    method or other customized suites. It doesn't matter how we assemble suites. When
    we risk missing test cases, `nosetests` conveniently lets us search for all tests,
    or a subset of tests if needed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试分布在多个模块中，同一段代码块是否能够工作？不行，因为`unittest.main()`只查找当前模块。要扩展到多个模块，我们需要开始使用unittest的`loadTestsFromTestCase`方法或其他自定义套件来加载测试。我们如何组装套件并不重要。当我们有遗漏测试用例的风险时，`nosetests`方便地让我们搜索所有测试，或者根据需要搜索一部分测试。
- en: A common situation on projects is to spread out test cases between lots of modules.
    Instead of writing one big test case, we typically break things up into smaller
    test cases based on various setups, scenarios, and other logical groupings. It's
    a common practice to split up test cases based on which module is being tested.
    The point is that manually loading all the test cases for a real-world test suite
    can become labor-intensive.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中常见的情况是将测试用例分布在许多模块之间。我们通常不会编写一个大的测试用例，而是根据各种设置、场景和其他逻辑分组将其分解为较小的测试用例。根据正在测试的模块拆分测试用例是一种常见做法。关键是，手动加载真实世界测试套件的所有测试用例可能会变得费力。
- en: Nose is extensible
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nose是可扩展的
- en: Auto-discovery of tests isn't the only reason to use nose. Later in this chapter,
    we will explore how we can write a plugin to customize what it discovers and also
    the output of a test run.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 自动发现测试并不是使用nose的唯一原因。在本章的后面，我们将探讨如何编写插件来自定义它发现的内容以及测试运行的输出。
- en: Nose is embeddable
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nose是可嵌入的
- en: All the functionality nose provides can be utilized either by the command-line,
    or from inside a Python script. We will also explore this further in this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: nose提供的所有功能都可以通过命令行或Python脚本来使用。我们还将在本章中进一步探讨这一点。
- en: See also
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Asserting **the **basics* recipe in [Chapter 1](part0025.html#NQU20-dd965cfd3480473da68e719fadb0727c), *Using
    Unittest to Develop Basic Tests*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](part0025.html#NQU20-dd965cfd3480473da68e719fadb0727c)中的*断言基础*食谱，*使用Unittest开发基本测试*。'
- en: Embedding nose inside Python
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将nose嵌入Python中
- en: It's very convenient to embed nose inside a Python script. This lets us create
    higher-level test tools besides allowing the developer to add testing to an existing
    tool.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将nose嵌入Python脚本中非常方便。这不仅让我们创建更高级的测试工具，还允许开发人员将测试添加到现有工具中。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With these steps, we will explore using nose''s API inside a Python script
    to run some tests:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们将探索在Python脚本中使用nose的API来运行一些测试：
- en: Create a new file called `recipe12.py` to contain the code from this recipe.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe12.py`的新文件，以包含此示例中的代码。
- en: 'Create a class to test. For this recipe, we will use a shopping cart application
    that lets us load items and then calculate the bill:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个要测试的类。对于这个示例，我们将使用一个购物车应用程序，它让我们加载物品然后计算账单：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a test case with several test methods:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含多个测试方法的测试用例：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Create a script named `recipe12_nose.py` to use nose's API to run tests.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe12_nose.py`的脚本，以使用nose的API来运行测试。
- en: 'Make the script runnable and use nose''s `run()` method to run selected arguments:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使脚本可运行，并使用nose的`run()`方法来运行选定的参数：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the test script from the command line and see the verbose output:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行运行测试脚本并查看详细输出：
- en: '![](../images/00022.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00022.jpeg)'
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the test running code, we are using `nose.run()`. With no arguments, it simply
    picks up on `sys.argv` and acts like the command-line `nosetests`. But in this
    recipe, we are plugging in the name of the current module along with increased
    verbosity.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试运行代码中，我们使用了`nose.run()`。没有参数时，它简单地依赖于`sys.argv`并像命令行`nosetests`一样运行。但在这个示例中，我们插入了当前模块的名称以及增加的详细信息。
- en: There's more...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Unittest has `unittest.main()`, which discovers and runs test cases as well.
    How is this different? `unittest.main()` is geared to discover test cases in the
    same module where it is run. The `nose.run()` function is geared to let us pass
    in command-line arguments or load them programmatically.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Unittest有`unittest.main()`，它也发现并运行测试用例。这有什么不同？`unittest.main()`旨在在运行它的同一模块中发现测试用例。`nose.run()`函数旨在让我们传入命令行参数或以编程方式加载它们。
- en: 'For example, look at the following steps; we must complete them to turn up
    verbosity with unittest:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看以下步骤；我们必须完成它们以提高unittest的详细程度：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We had to import the test cases, use a test loader to create a test suite, and
    then run it through `TextTestRunner`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须导入测试用例，使用测试加载器创建测试套件，然后通过`TextTestRunner`运行它。
- en: 'To do the same thing with nose, this is all we need:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用nose做同样的事情，我们只需要这些：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is much more succinct. Any command-line options we could use with `nosetests` can be
    used here. This comes in handy when we use the the nose plugin, which we will
    explore in more detail in this chapter and throughout the rest of the book.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这更加简洁。我们可以在这里使用`nosetests`的任何命令行选项。当我们使用nose插件时，这将非常方便，我们将在本章和本书的其余部分中更详细地探讨。
- en: Writing a nose extension to pick tests based on regular expressions
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个nose扩展来基于正则表达式选择测试
- en: Out-of-the-box test tools such as nose are very useful. But eventually, we reach
    a point where the options don't match our needs. Nose has the powerful ability
    to code custom plugins, and this gives us the ability to fine-tune nose to meet
    our needs. This recipe will help us write a plugin that allows us to selectively
    choose test methods by matching their method names using a regular expression
    when we run `nosetests`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 像nose这样的开箱即用的测试工具非常有用。但最终，我们会达到一个选项不符合我们需求的地步。Nose具有编写自定义插件的强大能力，这使我们能够微调nose以满足我们的需求。这个示例将帮助我们编写一个插件，允许我们通过匹配测试方法的方法名使用正则表达式来选择性地选择测试方法，当我们运行`nosetests`时。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to have `easy_install` loaded in order to install the nose plugin that
    we are about to create. If you don't already have it, please visit [http://pypi.python.org/pypi/setuptools](http://pypi.python.org/pypi/setuptools)
    to download and install the package as indicated at the site.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要加载`easy_install`以安装即将创建的nose插件。如果您还没有它，请访问[http://pypi.python.org/pypi/setuptools](http://pypi.python.org/pypi/setuptools)下载并按照网站上的指示安装该软件包。
- en: 'If you have just installed it now, then you will have to do the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您刚刚安装了它，那么您将需要执行以下操作：
- en: Rebuild your `virtualenv` used for running code samples in this book
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新构建用于运行本书中代码示例的`virtualenv`
- en: Reinstall `nose` using `pip`
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pip`重新安装`nose`
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With the following steps, we will code a nose plugin that picks test methods
    to run by using a regular expression:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，我们将编写一个nose插件，通过正则表达式选择要运行的测试方法：
- en: Create a new file called `recipe13.py` to store the code for this recipe.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe13.py`的新文件，以存储此示例的代码。
- en: 'Create a shopping cart application that we can build some tests around:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个购物车应用程序，我们可以围绕它构建一些测试：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a test case that contains several test methods, including one that does
    not start with the word `test`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含多个测试方法的测试用例，包括一个不以单词`test`开头的方法：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run the module using `nosetests` from the command line, with `verbosity` turned
    on. How many test methods get run? How many test methods did we define?
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令行中的`nosetests`运行模块，并打开`verbosity`。有多少个测试方法被运行？我们定义了多少个测试方法？
- en: '![](../images/00023.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00023.jpeg)'
- en: Create a new file called `recipe13_plugin.py` to write a nose plugin for this
    recipe.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe13_plugin.py`的新文件，为此配方编写一个鼻子插件。
- en: 'Capture a handle to `sys.stderr` to support debugging and verbose output:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获`sys.stderr`的句柄以支持调试和详细输出：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a nose plugin named `RegexPicker` by subclassing `nose.plugins.Plugin`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过子类化`nose.plugins.Plugin`创建一个名为`RegexPicker`的鼻子插件：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our nose plugin requires a class-level name. This is used to define the `with-<name>`
    command-line option.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的鼻子插件需要一个类级别的名称。这用于定义`with-<name>`命令行选项。
- en: 'Override `Plugin.options` and add an option to provide the pattern on the command
    line:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`Plugin.options`并添加一个选项，在命令行上提供模式：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Override `Plugin.configuration` by having it fetch the pattern and verbosity:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`Plugin.configuration`，使其获取模式和详细信息：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When we extend `Plugin`, we inherit some other features, such as `self.enabled`,
    which is switched on when `-with-<name>` is used with nose.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们扩展`Plugin`时，我们继承了一些其他功能，例如`self.enabled`，当使用鼻子的`-with-<name>`时会打开。
- en: 'Override `Plugin.wantedMethod` so that it accepts test methods that match our
    regular expression:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`Plugin.wantedMethod`，使其接受与我们的正则表达式匹配的测试方法：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Write a test runner that programmatically tests our plugin by running the same
    test case that we ran earlier:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个测试运行器，通过运行与我们之前运行的相同的测试用例来以编程方式测试我们的插件：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Execute the test runner. Looking at the results in the following screenshot,
    how many test methods ran this time?
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行测试运行器。查看以下截图中的结果，这次运行了多少个测试方法？
- en: '![](../images/00024.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00024.jpeg)'
- en: 'Create a `setup.py` script that allows us to install and register our plugin
    with `nosetests`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`setup.py`脚本，允许我们安装并注册我们的插件到`nosetests`：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Install our new plugin:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装我们的新插件：
- en: '![](../images/00025.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00025.jpeg)'
- en: 'Run `nosetests` using `--with-regexpicker` from the command line:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行使用`--with-regexpicker`运行`nosetests`：
- en: '![](../images/00026.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00026.jpeg)'
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Writing a nose plugin has some requirements. First of all, we need the class-level
    `name` attribute. It is used in several places, including defining the command-line
    switch to invoke our plugin, `--with-<name>`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 编写鼻子插件有一些要求。首先，我们需要类级别的`name`属性。它在几个地方使用，包括定义用于调用我们的插件的命令行开关`--with-<name>`。
- en: 'Next, we write `options`. There is no requirement to override `Plugin.options`,
    but in this case we need a way to supply our plugin with the regular expression.
    To avoid destroying the useful machinery of `Plugin.options`, we call it first,
    and then add a line for our extra parameter using `parser.add_option`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写`options`。没有要求覆盖`Plugin.options`，但在这种情况下，我们需要一种方法来为我们的插件提供正则表达式。为了避免破坏`Plugin.options`的有用机制，我们首先调用它，然后使用`parser.add_option`为我们的额外参数添加一行：
- en: The first, unnamed arguments are string versions of the parameter, and we can
    specify multiple ones. We could have had `-rp` and `-re-pattern` if we had wanted
    to.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个未命名的参数是参数的字符串版本，我们可以指定多个参数。如果我们想要的话，我们可以有`-rp`和`-re-pattern`。
- en: '`Dest`: This is the name of the attribute that stores the results (see configure).'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dest`：这是存储结果的属性的名称（请参阅configure）。'
- en: '`Action`: This specifies what to do with the value of the parameter (store,
    append, and so on).'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Action`：这指定参数值的操作（存储，追加等）。'
- en: '`Default`: This specifies what value to store when none are provided (notice
    we use `test.*` to match standard unittest behavior).'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Default`：这指定在未提供值时存储的值（请注意，我们使用`test.*`来匹配标准的unittest行为）。'
- en: '`Help`: This provides help info to print out on the command line.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Help`：这提供了在命令行上打印的帮助信息。'
- en: Nose uses Python's `optparse.OptionParser` library to define options.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 鼻子使用Python的`optparse.OptionParser`库来定义选项。
- en: To find out more about Python's `optparse.OptionParser`, please refer to [http://docs.python.org/library/optparse.html](http://docs.python.org/library/optparse.html).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关Python的`optparse.OptionParser`的更多信息，请参阅[http://docs.python.org/library/optparse.html](http://docs.python.org/library/optparse.html)。
- en: Then, we write `configure`. There is also no requirement to override `Plugin.configure`.
    Because we had an extra option, `--pattern`, we need to harvest it. We also want
    to turn on a flag driven by `verbosity`, a standard nose option.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们编写`configure`。没有要求覆盖`Plugin.configure`。因为我们有一个额外的选项`--pattern`，我们需要收集它。我们还想通过`verbosity`（一个标准的鼻子选项）来打开一个标志。
- en: 'There are many things we can do when writing a nose plugin. In our case, we
    wanted to zero in on **test ****selection**. There are several ways to load tests,
    including by module, and filename. After loading, they are then run through a
    method where they are voted in or out. These voters are called `want*` methods
    and they include `wantModule`, `wantName`, `wantFunction`, and `wantMethod`, as
    well some others. We implemented `wantMethod` where we test `method.func_name`
    matches our pattern using Python''s `re` module. `want*` methods have three return
    value types:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写鼻子插件时，我们可以做很多事情。在我们的情况下，我们想要聚焦于**测试选择**。有几种加载测试的方法，包括按模块和文件名。加载后，它们通过一个方法运行，该方法会投票赞成或反对它们。这些投票者被称为`want*`方法，它们包括`wantModule`，`wantName`，`wantFunction`和`wantMethod`，还有一些其他方法。我们实现了`wantMethod`，在这里我们使用Python的`re`模块测试`method.func_name`是否与我们的模式匹配。`want*`方法有三种返回值类型：
- en: '`True`: This test is wanted.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`True`：这个测试是需要的。'
- en: '`False`: This test is not wanted (and will not be considered by another plugin).'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`False`：此测试不需要（并且不会被另一个插件考虑）。'
- en: '`None`: The plugin does not care whether another plugin (or nose) gets to choose.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`：插件不关心另一个插件（或鼻子）是否选择。'
- en: This is succinctly achieved by not returning anything from the `want*` method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不从`want*`方法返回任何内容来简洁地实现这一点。
- en: '`wantMethod` only looks at functions defined inside classes. `nosetests` is
    geared to find tests by many different methods and is not confined to just searching
    subclasses of `unittest.TestCase`. If tests are found in the module, but not as
    class methods, then this pattern matching is not utilized. For this plugin to
    be more robust, we would need lot of different tests and probably need to override
    the other `want*` test selectors.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`wantMethod`只查看在类内定义的函数。`nosetests`旨在通过许多不同的方法查找测试，并不仅限于搜索`unittest.TestCase`的子类。如果在模块中找到了测试，但不是作为类方法，那么这种模式匹配就不会被使用。为了使这个插件更加健壮，我们需要很多不同的测试，并且可能需要覆盖其他`want*`测试选择器。'
- en: There's more...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe just scratches the surface on plugin functionality. It focuses on
    the test selection process.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱只是浅尝插件功能。它侧重于测试选择过程。
- en: Later in this chapter, we will explore generating a specialized report. This
    involves using other plugin hooks that gather information after each test is run
    as well as generating a report after the test suite is exhausted. Nose provides
    a robust set of hooks allowing detailed customization to meet our changing needs.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，我们将探讨生成专门报告的方法。这涉及使用其他插件钩子，在每次测试运行后收集信息以及在测试套件耗尽后生成报告。Nose提供了一组强大的钩子，允许详细定制以满足我们不断变化的需求。
- en: Plugins should subclass `nose.plugins.Plugin`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 插件应该是`nose.plugins.Plugin`的子类。
- en: There is a lot of valuable machinery built into `Plugin`. Subclassing is the
    recommended means of developing a plugin. If you don't so this, you may have to
    add on methods and attributes you didn't realize were needed by nose (and that
    come for free when you subclass).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Plugin`中内置了很多有价值的机制。子类化是开发插件的推荐方法。如果不这样做，您可能需要添加您没有意识到nose需要的方法和属性（当您子类化时会自动获得）。'
- en: It's a good rule of thumb to subclass the parts of the nose API that we are
    plugging into instead of overriding.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的经验法则是子类化nose API的部分，而不是覆盖它。
- en: The online documentation for the nose API is a little incomplete. It tends to
    assume too much knowledge. If we override and our plugin doesn't work correctly,
    it may be difficult to debug what is happening.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: nose API的在线文档有点不完整。它倾向于假设太多的知识。如果我们覆盖了，但我们的插件没有正确工作，可能很难调试发生了什么。
- en: Do not subclass `nose.plugins.IPluginInterface`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 不要子类化`nose.plugins.IPluginInterface`。
- en: This class is used for documentation purposes only. It provides information
    about each of the hooks our plugin can access. But it is not designed for subclassing
    real plugins.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类仅用于文档目的。它提供了关于我们的插件可以访问的每个钩子的信息。但它不是为了子类化真正的插件而设计的。
- en: Writing a nose extension to generate a CSV report
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个nose扩展来生成CSV报告
- en: This recipe will help us write a plugin that generates a custom report listing
    successes and failures in a CSV file. It is used to demonstrate how to gather
    information after each test method completes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将帮助我们编写一个生成自定义报告的插件，列出CSV文件中的成功和失败。它用于演示如何在每个测试方法完成后收集信息。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to have `easy_install` loaded in order to install the nose plugin we
    are about to create. If you don't already have it, please visit [http://pypi.python.org/pypi/setuptools](http://pypi.python.org/pypi/setuptools)
    to download and install the package as indicated on the site.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要加载`easy_install`以安装我们即将创建的nose插件。如果您还没有它，请访问[http://pypi.python.org/pypi/setuptools](http://pypi.python.org/pypi/setuptools)下载并按照网站上的指示安装该软件包。
- en: 'If you have just installed it now, then you will have to do the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您刚刚安装了它，那么您将不得不执行以下操作：
- en: Rebuild your `virtualenv` used for running code samples in this book
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新构建您用于运行本书中代码示例的`virtualenv`
- en: Reinstall nose using `easy_install`
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`easy_install`重新安装nose
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new file named `recipe14.py` to store the code for this recipe.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe14.py`的新文件，用于存储此食谱的代码。
- en: 'Create a shopping cart application that we can build some tests around:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个购物车应用程序，我们可以围绕它构建一些测试：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a test case that contains several test methods, including one deliberately
    set to fail:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含多个测试方法的测试用例，包括一个故意设置为失败的测试方法：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Run the module using `nosetests` from the command line. Looking at the output
    in the following screenshot, does it appear that a CSV report exists?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行使用`nosetests`运行模块。查看下面的截图输出，是否存在CSV报告？
- en: '![](../images/00027.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00027.jpeg)'
- en: Create a new file called `recipe14_plugin.py` to store our new nose plugin.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe14_plugin.py`的新文件，用于存储我们的新nose插件。
- en: 'Create a nose plugin named `CsvReport` by subclassing `nose.plugins.Plugin`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过子类化`nose.plugins.Plugin`创建一个名为`CsvReport`的nose插件：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our nose plugin requires a class-level `name`. This is used to define the `-with-<name>`
    command-line option.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的nose插件需要一个类级别的`name`。这用于定义`-with-<name>`命令行选项。
- en: 'Override `Plugin.options` and add an option to provide the report''s filename
    on the command line:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`Plugin.options`并添加一个选项，在命令行上提供报告的文件名：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Override `Plugin.configuration` by having it fetch the filename from options:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过让它从选项中获取文件名来覆盖`Plugin.configuration`：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When we extend `Plugin`, we inherit some other features, such as `self.enabled`,
    which is switched on when `-with-<name>` is used with nose.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们扩展`Plugin`时，我们会继承一些其他功能，比如`self.enabled`，当使用nose的`-with-<name>`时会打开。
- en: 'Override `addSuccess`, `addFailure`, and `addError` to collect the results
    in an internal list:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`addSuccess`，`addFailure`和`addError`以在内部列表中收集结果：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Override `finalize` to generate the CSV report:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`finalize`以生成CSV报告：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Write a test runner that programmatically tests our plugin by running the same
    test case that we ran earlier:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个测试运行器，通过运行与我们之前运行的相同的测试用例来以编程方式测试我们的插件：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Execute the test runner. Looking at the output in the next screenshot, is there
    a test report now?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行测试运行器。查看下一个截图输出，现在是否有测试报告？
- en: '![](../images/00028.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00028.jpeg)'
- en: 'Open up and view the report using your favorite spreadsheet:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的电子表格打开并查看报告：
- en: '![](../images/00029.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00029.jpeg)'
- en: 'Create a `setup.py` script that allows us to install and register our plugin
    with `nosetests`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`setup.py`脚本，允许我们安装并注册我们的插件到`nosetests`：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Install our new plugin:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装我们的新插件：
- en: '![](../images/00030.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00030.jpeg)'
- en: 'Run `nosetests` using `--with-csv-report` from the command line:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行运行`nosetests`，使用`--with-csv-report`：
- en: '![](../images/00031.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00031.jpeg)'
- en: In the previous screenshot, notice how we have the previous log file, `recipe14.csv`,
    and the new one, `log.csv`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个截图中，注意我们有先前的日志文件`recipe14.csv`和新的日志文件`log.csv`。
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Writing a nose plugin has some requirements. First of all, we need the class-level
    `name` attribute. It is used in several places including defining the command-line
    switch to invoke our plugin, `--with-<name>`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 编写nose插件有一些要求。首先，我们需要类级别的`name`属性。它在几个地方使用，包括定义用于调用我们的插件的命令行开关，`--with-<name>`。
- en: 'Next, we write `options`. There is no requirement to override `Plugin.options`.
    But in this case, we need a way to supply our plugin with the name of the CSV
    report it will write. To avoid destroying the useful machinery of `Plugin.options`,
    we call it first, and then add a line for our extra parameter using `parser.add_option`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写`options`。没有必要覆盖`Plugin.options`。但在这种情况下，我们需要一种方法来提供我们的插件将写入的CSV报告的名称。为了避免破坏`Plugin.options`的有用机制，我们首先调用它，然后使用`parser.add_option`添加我们额外参数的行：
- en: The first, unnamed arguments are string versions of the parameter
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未命名的参数是参数的字符串版本
- en: '`dest`: This is the name of the attribute that stores the results (see configure)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dest`：这是存储结果的属性的名称（参见configure）'
- en: '`action`: This tells what to do with the value of the parameter (store, append,
    and so on)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action`：这告诉参数值要执行的操作（存储、追加等）'
- en: '`default`: This tells what value to store when none is provided'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：这告诉了当没有提供值时要存储什么值'
- en: '`help`: This provides help info to print out on the command line'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help`：这提供了在命令行上打印的帮助信息'
- en: Nose uses Python's `optparse.OptionParser` library to define options.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Nose使用Python的`optparse.OptionParser`库来定义选项。
- en: To learn more about `optparse.OptionParser`, visit [http://docs.python.org/optparse.html](http://docs.python.org/optparse.html).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`optparse.OptionParser`的信息，请访问[http://docs.python.org/optparse.html](http://docs.python.org/optparse.html)。
- en: Then, we write `configure`. There is also no requirement to override `Plugin.configure`.
    Because we had an extra option, `--csv-file`, we need to harvest it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们编写`configure`。同样，没有必要覆盖`Plugin.configure`。因为我们有一个额外的选项`--csv-file`，我们需要收集它。
- en: 'In this recipe, we want to capture the test case and the error report whenever
    a test method completes. To do this, we implement `addSuccess`, `addFailure`,
    and `addError`, because nose varies in what arguments are sent to these methods
    when called either programmatically or by the command-line, so we must use Python''s
    `*args`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们希望在测试方法完成时捕获测试用例和错误报告。为此，我们实现`addSuccess`、`addFailure`和`addError`，因为nose在以编程方式调用或通过命令行调用这些方法时发送的参数不同，所以我们必须使用Python的`*args`：
- en: The first slot of this tuple contains the `test`, an instance of `nose.case.Test`.
    Simply printing it is sufficient for our needs.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个元组的第一个槽包含`test`，一个`nose.case.Test`的实例。简单地打印它对我们的需求就足够了。
- en: The second slot of this tuple contains the `error`, an instance of the 3-tuple
    for `sys.exc_info()`. It is only included for `addFailure` and `addError`.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个元组的第二个槽包含`error`，是`sys.exc_info()`的3元组实例。它仅包括在`addFailure`和`addError`中。
- en: No more slots of this tuple are documented on nose's website. We generally ignore
    them.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nose网站上没有更多关于这个元组的槽的文档。我们通常忽略它们。
- en: There's more...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe digs a little deeper into the plugin's functionality. It focuses
    on processing done after a test method succeeds, fails, or causes an error. In
    our case, we just gather the results to put into a report. We could do other things,
    such as capture stack traces, send email failures to the development team, or
    send a page to the QA team letting them know a test suite is complete.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方深入探讨了插件功能。它侧重于在测试方法成功、失败或导致错误后进行的处理。在我们的情况下，我们只是收集结果以放入报告中。我们还可以做其他事情，比如捕获堆栈跟踪，将失败的邮件发送给开发团队，或者向QA团队发送页面，让他们知道测试套件已经完成。
- en: For more details about writing a nose plugin, read the *Writing **a **nose **extension* recipe to
    pick tests based on regular expressions.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有关编写nose插件的更多详细信息，请阅读*编写**nose**扩展*的配方，以根据正则表达式选择测试。
- en: Writing a project-level script that lets you run different test suites
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个项目级别的脚本，让您运行不同的测试套件
- en: Python, with its multi-paradigm nature, makes it easy to build applications
    and provide scripting support.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Python以其多范式的特性，使得构建应用程序并提供脚本支持变得容易。
- en: This recipe will help us explore building a project-level script that allows
    us to run different test suites. We will also show some extra command-line options
    to create hooks for packaging, publishing, registering, and writing automated
    documentation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将帮助我们探索构建一个项目级别的脚本，允许我们运行不同的测试套件。我们还将展示一些额外的命令行选项，以创建用于打包、发布、注册和编写自动文档的钩子。
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a script called `recipe15.py` that parses a set of options using Python''s
    `getopt` library:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe15.py`的脚本，使用Python的`getopt`库解析一组选项：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a function that maps to `-test`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个映射到`-test`的函数：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create stub functions that support `package`, `publish`, and `register`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建支持`package`、`publish`和`register`的存根函数：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a function to auto-generate docs using Python''s `pydoc` module:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，使用Python的`pydoc`模块自动生成文档：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add some code that defines debug levels and then parses options to allow the
    user to override:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些代码，定义调试级别，然后解析选项以允许用户进行覆盖：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add some code that scans the command-line options for `-help` and, if it''s
    found, exits the script:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些代码，扫描命令行选项以查找`-help`，如果找到，则退出脚本：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finish it by iterating through each of the command-line options and invoking
    the other functions based on which options are picked:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过迭代每个命令行选项并根据选择了哪些选项来调用其他函数来完成它：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run the `recipe15.py` script with `-help`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-help`运行`recipe15.py`脚本：
- en: '![](../images/00032.jpeg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00032.jpeg)'
- en: Create a new file called `recipe15_checkin.py` to create a new test suite.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe15_checkin.py`的新文件来创建一个新的测试套件。
- en: 'Reuse the test cases from the *Getting **nosy **with **testing* recipe to define
    a `check``in` test suite:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重用*获取**nosy**with**testing*食谱中的测试用例来定义一个`check``in`测试套件：
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Run the `recipe15.py` script, using `-test -package -publish -register -pydoc`.
    In the following screenshot, do you notice how it exercises each option in the
    same sequence as it was supplied on the command line?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-test -package -publish -register -pydoc`运行`recipe15.py`脚本。在下面的屏幕截图中，您是否注意到它如何按照在命令行上提供的相同顺序来执行每个选项？
- en: '![](../images/00033.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00033.jpeg)'
- en: 'Inspect the report generated in the `pydoc` directory:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查在`pydoc`目录中生成的报告：
- en: '![](../images/00034.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00034.jpeg)'
- en: Create a new file named `recipe15_all.py` to define another new test suite.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe15_all.py`的新文件来定义另一个新的测试套件。
- en: 'Reuse the test code from the earlier recipes of this chapter to define an `all`
    test suite:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重用本章早期食谱的测试代码来定义一个`all`测试套件：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run the `recipe15.py` script with `-suite=recipe15_all`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-suite=recipe15_all`运行`recipe15.py`脚本：
- en: '![](../images/00035.jpeg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00035.jpeg)'
- en: How it works...
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This script uses Python''s `getopt` library, which is modeled after the C programming
    language''s `getopt()` function. This means we use the API to define a set of
    commands, and then we iterate over the options, calling the corresponding functions:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本使用Python的`getopt`库，该库是模仿C编程语言的`getopt()`函数而建立的。这意味着我们使用API来定义一组命令，然后迭代选项，调用相应的函数：
- en: Visit [http://docs.python.org/library/getopt.html](http://docs.python.org/library/getopt.html)
    for more details on the `getopt` library.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[http://docs.python.org/library/getopt.html](http://docs.python.org/library/getopt.html)了解更多关于`getopt`库的详细信息。
- en: '`usage`: This is a function that provides help to the user.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usage`：这是一个为用户提供帮助的函数。'
- en: '`key`: The option definitions are included in the following block:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`键`：选项定义包含在以下块中：'
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We parse everything in the arguments except the first, as this is the executable
    itself:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解析除第一个参数之外的所有参数，因为这是可执行文件本身：
- en: '`"ht"` defines short options: `-h` and `-t`.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"ht"`定义了短选项：`-h`和`-t`。'
- en: The list defines long options. Those with `"="` accept an argument. Those without
    it are flags.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该列表定义了长选项。带有“=”的选项接受参数。没有“=”的选项是标志。
- en: If an option is received that isn't on the list, an exception is thrown; we
    print out `usage()` and then exit.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果收到不在列表中的选项，就会抛出异常；我们打印出`usage()`，然后退出。
- en: '`Test`: This activates loggers, which can be very useful if our app uses Python''s
    `logging` library.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`测试`：这激活了记录器，如果我们的应用程序使用Python的`logging`库，这将非常有用。'
- en: '`Package`: This generates tarballs. We created a stub, but it can be handy
    to provide a shortcut by running `setup.py sdist|bdist`.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`包`：这生成tarballs。我们创建了一个存根，但通过运行`setup.py sdist|bdist`提供一个快捷方式会很方便。'
- en: '`Publish`: Its function is to push tarballs to the deployment site. We created
    a stub, but deploying it to an S3 site or somewhere else is useful.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`发布`：它的功能是将tarballs推送到部署站点。我们创建了一个存根，但将其部署到S3站点或其他地方是有用的。'
- en: '`Register`: This is the register with PyPI. We created a stub, but it would
    be handy to provide a shortcut to running `setup.py register`.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`注册`：这是与PyPI注册。我们创建了一个存根，但提供一个快捷方式运行`setup.py register`会很方便。'
- en: '`create_pydocs`: These are auto-generated docs. Generating HTML files based
    on code is very convenient.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_pydocs`：这些是自动生成的文档。基于代码生成HTML文件非常方便。'
- en: 'With each of these functions defined, we can iterate over the options that
    were parsed. For this script, there is a sequence as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这些功能后，我们可以迭代解析的选项。对于这个脚本，有一个如下的顺序：
- en: Check whether there is a debugging override. We default to `logging.INFO`, but
    provide the ability to switch to `logging.DEBUG`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否有调试覆盖。我们默认为`logging.INFO`，但提供切换到`logging.DEBUG`的能力。
- en: Check whether `-h` or `-help` was called. If so, print out the `usage()` information
    and then exit with no more parsing.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否调用了`-h`或`-help`。如果是，打印出`usage()`信息，然后退出，不再解析。
- en: Finally, iterate over the options and call their corresponding functions.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，迭代选项并调用它们对应的函数。
- en: To exercise things, we first called this script with the `-help` option. That
    printed out the command choices we had.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习，我们首先使用`-help`选项调用了这个脚本。这打印出了我们的命令选择。
- en: Then we called it with all the options to demonstrate the features. The script
    is coded to exercise a `check in` suite when we use `-test`. This short test suite
    simulates running a quicker test that's designed to see whether things look alright.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用所有选项调用它来演示功能。当我们使用`-test`时，脚本被编码为执行`check in`套件。这个简短的测试套件模拟了运行一个更快的测试，旨在查看事情是否正常。
- en: Finally, we called the script with `-suite=recipe15_all`. This test suite simulates
    running a more complete test suite that typically takes longer.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`-suite=recipe15_all`调用了脚本。这个测试套件模拟了运行一个更完整的测试套件，通常需要更长时间。
- en: There's more...
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The features this script provides could easily be handled by commands that are
    already built. We looked at `nosetests` earlier in this chapter and saw how it
    can flexibly take arguments to pick tests.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本提供的功能可以很容易地通过已经构建的命令来处理。我们在本章前面看过`nosetests`，并且知道它可以灵活地接受参数来选择测试。
- en: Using `setup.py` to generate tarballs and register releases is also a commonly
    used feature in the Python community.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`setup.py`生成tarballs并注册发布也是Python社区中常用的功能。
- en: So, why write this script? Because we can tap all these features with a single
    command script, `setup.py` contains a prebuilt set of commands that involve bundling
    and uploading to the Python Project Index. Doing other tasks, such as generating
    **pydocs**, deploying to a location such as an Amazon S3 bucket, or any other
    system-level task, is not included. This script demonstrates how easy it is to
    wire in other command-line options and link them with the project management functions.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么要写这个脚本呢？因为我们可以通过一个单一的命令脚本利用所有这些功能，`setup.py`包含了一组预先构建的命令，涉及打包和上传到Python项目索引。执行其他任务，比如生成**pydocs**，部署到像Amazon
    S3桶这样的位置，或者任何其他系统级任务，都不包括在内。这个脚本演示了如何轻松地引入其他命令行选项，并将它们与项目管理功能链接起来。
- en: We can also conveniently embed the usage of `pydoc`. Basically, any Python library
    that serves project management needs can be embedded as well.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以方便地嵌入`pydoc`的使用。基本上，任何满足项目管理需求的Python库也可以被嵌入。
- en: On an existing project, I developed a script to provide a unified way to embed
    version info into a templated `setup.py` as well as documentation generated by
    `pydoc`, `sphinx`, and `DocBook`. The script saved me from having to remember
    all the commands needed to manage the project.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个现有的项目中，我开发了一个脚本，以统一的方式将版本信息嵌入到一个模板化的`setup.py`以及由`pydoc`、`sphinx`和`DocBook`生成的文档中。这个脚本让我不必记住管理项目所需的所有命令。
- en: Why didn't I extend `distutils` to create my own commands? It was a matter of
    taste. I preferred using `getopt` and working outside the framework of `distutils`
    instead of creating and registering new sub-commands.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我不扩展`distutils`来创建自己的命令？这是一个品味的问题。我更喜欢使用`getopt`，并在`distutils`框架之外工作，而不是创建和注册新的子命令。
- en: Why use getopt instead of optparse?
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用`getopt`而不是`optparse`？
- en: Python has several options for handling command-line option parsing. `getopt`
    is possibly the simplest. It is meant to quickly allow defining short and long
    options, but it has limits. It requires custom coding help output, as we did with
    the usage function.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Python有几种处理命令行选项解析的选项。`getopt`可能是最简单的。它旨在快速定义短选项和长选项，但它有限制。它需要自定义编码帮助输出，就像我们在使用函数中所做的那样。
- en: It also requires custom handling of the arguments. `optparse` provides more
    sophisticated options, such as better handling of arguments and auto-built help.
    But it also requires more code to get functional. `optparse` is also scheduled
    to be replaced by `argparse` in the future.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 它还需要对参数进行自定义处理。`optparse`提供了更复杂的选项，比如更好地处理参数和自动构建帮助。但它也需要更多的代码来实现功能。`optparse`也计划在未来被`argparse`取代。
- en: It is left as an exercise for you to write an alternative version of this script
    using `optparse`, to assess which one is a better solution.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试用`optparse`写一个这个脚本的替代版本，来评估哪一个是更好的解决方案。
