- en: Working with Decorators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与装饰器一起工作
- en: 'In this chapter, we will talk about decorators for functions and classes, which
    allow the decorating of functions and classes with more details. In this chapter,
    we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论函数和类的装饰器，允许更详细地装饰函数和类。在本章中，我们将涵盖以下内容：
- en: Reviewing functions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数回顾
- en: Introducing decorators
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍装饰器
- en: Using function decorators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数装饰器
- en: Using class decorators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类装饰器
- en: Examples of decorators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器示例
- en: Using the decorators module
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用装饰器模块
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Decorators in Python are any callable objects that can modify a function or
    class. They allow some additional functionality similar to other languages, such
    as declaring a method as a class or static method.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的装饰器是任何可调用的对象，可以修改一个函数或类。它们允许一些类似于其他语言的附加功能，例如将方法声明为类方法或静态方法。
- en: A class method is one that is called on a class rather than a particular instance.
    A static method is similar, but would be applied to all instances of a class,
    not just a specific instance. An instance method is the traditional method when
    dealing with OOP in Python.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法是在类上调用而不是在特定实例上调用的一种方法。静态方法类似，但将应用于类的所有实例，而不仅仅是特定实例。实例方法是处理Python中的面向对象的传统方法。
- en: When a call to a function or a class is made, it is passed to a decorator and
    the decorator returns a modified function/class. These modified objects generally
    include calls to the originally called object.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用一个函数或类时，它会被传递给装饰器，装饰器返回一个修改后的函数/类。这些修改后的对象通常包括对原始调用对象的调用。
- en: In this chapter, decorators can be used with functions and methods, but usually
    only the term *functions* will be used for brevity. *Method* will be used when
    explicitly talking about classes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，装饰器可以与函数和方法一起使用，但通常只会使用术语*函数*来简洁。当明确谈论类时，将使用*方法*。
- en: Reviewing functions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数回顾
- en: Because it is important to understand how functions work when we deal with decorators,
    we'll take a quick look at them. First, we need to remember that everything in
    Python is an object, including functions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因为当我们处理装饰器时，理解函数的工作方式很重要，所以我们将快速了解一下。首先，我们需要记住，Python中的所有东西都是对象，包括函数。
- en: 'Functions are created in Python by using the `def` keyword and naming the function;
    input arguments are optional. Following is a basic function for reference:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，通过使用`def`关键字和命名函数来创建函数；输入参数是可选的。以下是一个基本函数供参考：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Functions can have multiple names, that is, in addition to the function name
    itself, the function can be assigned to one or more variables. Each name has the
    same capabilities of the underlying function:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数可以有多个名称，也就是说，除了函数名本身之外，函数还可以被分配给一个或多个变量。每个名称都具有底层函数相同的特性：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Functions can be used as arguments for other functions. Some Python built-in
    functions, such as `map` and `filter`, use this feature to do their jobs:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数可以用作其他函数的参数。一些Python内置函数，如`map`和`filter`，使用此功能来完成其工作：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Functions can be nested within other functions:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数可以嵌套在其他函数内部：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Functions can be used as parameters to other functions. This is because function
    parameters are actually references to an object, and, since functions are objects,
    functions (actually references to the function object) can be used as parameters:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数可以用作其他函数的参数。这是因为函数参数实际上是对象的引用，由于函数是对象，因此函数（实际上是函数对象的引用）可以用作参数：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Functions can return functions. Again, this is because the return value of
    a function is a reference to an object:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数可以返回函数。这同样是因为函数的返回值是一个对象的引用：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Nested functions have access to the scope of their parent functions; this is
    also called **closure**. It is important to recognize that this access is read-only;
    nested functions cannot write out or assign variables to the outer scope.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 嵌套函数可以访问其父函数的作用域；这也被称为**闭包**。重要的是要认识到这种访问是只读的；嵌套函数不能写入或分配变量到外部作用域。
- en: 'In practice, this is no different than assigning arguments to function variables;
    the input argument is simply being passed to another, enclosed function rather
    than a variable:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这与将参数分配给函数变量没有区别；输入参数只是被传递到另一个，封装的函数而不是变量：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Functions and their object-oriented cousins, methods, are the workhorses of
    many programming languages. They allow code reuse, as a function can be called
    multiple times from different locations within the code. They can even be called
    from different programs, if the language supports it, for example, Python imports.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 函数及其面向对象的亲戚方法，是许多编程语言的工作马。它们允许代码重用，因为函数可以从代码的不同位置多次调用。如果语言支持，它们甚至可以从不同的程序中调用，例如Python的导入。
- en: Functions also allow abstraction of work. At their most basic level, a function
    is similar to a black box; all a developer needs to know is what data to feed
    a function and how the function deals with that data, that is, whether a value
    is returned. The actual algorithm within the function doesn't necessarily need
    to be known to use it, as long as the results are consistent.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 函数还允许抽象工作。在最基本层面上，一个函数类似于一个黑盒；开发者需要知道的是向函数提供什么数据以及函数如何处理这些数据，即是否返回一个值。只要结果一致，就不必了解函数内部的实际算法即可使用它。
- en: It is possible to write a program without functions, but it will require the
    entire program to be processed serially. Any functionality that needs to be repeated
    must be copy and pasted every time. This is why even the earliest, high-level
    programming languages included subroutines, which allowed the developer to jump
    out of the main logic flow to process some data, and then return back to the main
    flow. Prior to this, subroutines had to be implemented using a special call sequence
    to store the return address to the main code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以编写没有函数的程序，但整个程序需要串行处理。任何需要重复的功能都必须每次都复制粘贴。这就是为什么即使是早期的、高级的编程语言也包含了子程序，这允许开发者跳出主逻辑流程去处理一些数据，然后返回到主流程。在此之前，子程序必须通过特殊的调用序列来实现，以存储返回到主代码的地址。
- en: Introducing decorators
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍装饰器
- en: With that out of the way, we can talk about decorators. Decorators wrap a function
    in another function that modifies the original in some way, such as adding functionality,
    modifying arguments or results, and so on. Decorators are identified by the `@foo`
    nomenclature on the line above a function/method definition.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些之后，我们可以讨论装饰器。装饰器将一个函数包装在另一个函数中，以某种方式修改原始函数，例如添加功能、修改参数或结果等。装饰器通过函数/方法定义上方的一行上的`@foo`命名约定来识别。
- en: The workhorse of a decorator function is defining the `wrapper` function within
    it. In this case, the `wrapper` function is a nested function that actually does
    the modification work, though the decorator name is what is called.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器函数的核心工作是定义其内部的`wrapper`函数。在这种情况下，`wrapper`函数是一个嵌套函数，它实际上执行修改工作，尽管装饰器的名称才是被调用的。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Define the decorator function:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义装饰器函数：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Define the main function:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义主函数：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Use the main function as a variable and assign the decorator as its value:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主函数用作变量，并将装饰器作为其值赋给它：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Call the main function:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用主函数：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The whole program looks like `decorator.py`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个程序看起来像`decorator.py`：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When ran, the code prints the following:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时，代码会打印以下内容：
- en: '![](img/28244834-ff32-42b3-a63e-d748d793b201.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28244834-ff32-42b3-a63e-d748d793b201.png)'
- en: 'To eliminate the line `a_funct = fun_decorator(a_funct)`, we can use syntactic
    sugar (the `@` symbol) to annotate that the main function is modified by a decorator,
    as shown below in `decorator.py`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了消除`a_funct = fun_decorator(a_funct)`这一行，我们可以使用语法糖（`@`符号）来注释主函数已被装饰器修改，如下所示在`decorator.py`中：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The decorated function acts the same as when it was a variable:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被装饰的函数的行为与它作为变量时相同：
- en: '![](img/c7d3c982-f296-40f6-9e8a-0ced39075383.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7d3c982-f296-40f6-9e8a-0ced39075383.png)'
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When a function with a decorator is called, the call is caught by the decorator
    function, which then does its work. After it is complete, it hands off to the
    original function, which completes the job. Essentially, everything we discussed
    about preceding functions comes into play when working with decorators.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用带有装饰器的函数时，调用会被装饰器函数捕获，然后它执行自己的工作。完成后，它将任务转交给原始函数，以完成工作。本质上，我们在前面讨论的所有关于函数的内容在处理装饰器时都适用。
- en: '**Syntactic sugar** is special syntax within a programming language, designed
    to make life easier for a programmer by making code easier to read or write. Syntactic
    sugar expressions are identified by seeing if the code functionality is lost if
    the sugar goes away. In the case of decorators, we''ve already demonstrated that
    decorator functionality can be maintained without the `@` decorator; we just have
    to manually assign the decorator function to the main function variable.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法糖**是编程语言中的特殊语法，旨在通过使代码更容易阅读或编写来简化程序员的编程生活。语法糖表达式通过查看如果糖消失代码功能是否会丢失来识别。在装饰器的例子中，我们已经展示了即使没有`@`装饰器，装饰器功能也可以保持；我们只需手动将装饰器函数分配给主函数变量。'
- en: Decorated functions can be made permanent by using the first method, that is,
    if a decorated function is assigned to a variable, that variable can be used to
    call the decorated function every time, rather than the original function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用第一种方法，可以将装饰过的函数永久化，也就是说，如果将装饰过的函数分配给一个变量，那么每次都可以使用该变量来调用装饰过的函数，而不是原始函数。
- en: 'Methods can use decorators as well as functions. While any decorator can be
    made, there are a couple of standard decorators available to modify the methods
    for use with classes as well as instances. The following bullet points summarize
    the different methods covered:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 方法也可以使用装饰器以及函数。虽然可以创建任何装饰器，但有一些标准装饰器可用于修改方法，以便与类以及实例一起使用。以下要点总结了所涵盖的不同方法：
- en: Instance methods are the normal-use methods when working with classes. They
    take an `object(self)` call, where `self` identifies a particular instance to
    work with.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例方法是处理类时的常规使用方法。它们接受一个`object(self)`调用，其中`self`标识要与之一起工作的特定实例。
- en: Static methods are more universal, being able to work with all instances of
    a class as well as the class itself.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法更为通用，能够与类的所有实例以及类本身一起工作。
- en: Class methods operate on the class itself; instances are not affected.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类方法作用于类本身；实例不受影响。
- en: Using function decorators
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数装饰器
- en: 'Function decorators obviously apply to functions. The `@foo` decorator line
    is placed on the line prior to the function definition. The syntactic sugar takes
    one function and runs its results through another automatically; at the end of
    processing, the original function call''s name is applied to the final result.
    To the system, it looks like the original function call provided the result directly.
    Below is a demonstration of what a decorator looks like:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 函数装饰器显然适用于函数。`@foo`装饰器行放置在函数定义之前的一行。这种语法糖会将一个函数的结果自动传递给另一个函数；在处理结束时，原始函数调用的名称应用于最终结果。对于系统来说，它看起来就像原始函数调用直接提供了结果。以下是一个装饰器外观的示例：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When the Python interpreter gets to this code block, `my_function()` is processed
    and the result is passed to the function that `@foo_decorator` points to. The
    decorator function is processed and the result is substituted for the original `my_function()`
    results. In essence, the decorator hijacks the function call, modifying the original
    result and substituting the modification for the result the original function
    would have provided.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python解释器到达这个代码块时，`my_function()`会被处理，其结果会被传递给`@foo_decorator`指向的函数。装饰器函数会被处理，其结果会替换原始的`my_function()`结果。本质上，装饰器劫持了函数调用，修改了原始结果，并用修改后的结果替换了原始函数应该提供的结果。
- en: Decorator code modification can be in the form of management or augmentation
    of the original call. Once a function has done its work, the decorator takes over
    and does something to the original result, returning the modified code instead.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器代码的修改可以是管理或增强原始调用。一旦函数完成了其工作，装饰器就会接管并对原始结果进行操作，返回修改后的代码。
- en: This concept is reiterated because it is the most important part of decorators;
    at face value, decorators look complicated and it can be difficult to figure out
    how code works when decorators are involved.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这一概念被反复强调，因为它是装饰器最重要的部分；从表面上看，装饰器可能很复杂，当涉及装饰器时，可能很难弄清楚代码是如何工作的。
- en: Decorators can obviously be applied to any function that relates to the decorators
    modification goals. It is therefore in the programmer's best interest to create
    decorators that are generic enough that they can be used by multiple functions;
    otherwise, you may as well just make the function do what the end result is, rather
    than waste time on a decorator that will be used only once.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器显然可以应用于任何与装饰器修改目标相关的函数。因此，在程序员的最佳利益中，创建足够通用的装饰器，以便它们可以被多个函数使用；否则，你不妨直接让函数完成最终结果，而不是浪费时间在只使用一次的装饰器上。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'This walk through shows how to create a decorator that can be used to check
    arguments passed to a function. This can be handled in a number of different ways,
    such as `if...else` checks, `assert` statements, and so on, but, by using a decorator,
    we can use this code on any function that operates the same way:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南展示了如何创建一个装饰器，它可以用来检查传递给函数的参数。这可以通过多种方式处理，例如`if...else`检查、`assert`语句等，但通过使用装饰器，我们可以在任何以相同方式操作的函数上使用此代码：
- en: First, we have to decide what the decorator will do. For this use case, the
    decorator function will look at arguments being passed to a function and check
    whether the values passed are integers.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须决定装饰器将做什么。对于这个用例，装饰器函数将检查传递给函数的参数，并检查传递的值是否为整数。
- en: 'Write the decorator function just as you would write any other function:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照编写任何其他函数的方式编写装饰器函数：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Write the function that will be decorated. In this case, we are simply going
    to calculate some measurements of a circle when the radius is provided:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写将被装饰的函数。在这种情况下，我们只是简单地计算当提供半径时圆的一些测量值：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the remainder of the code, such as importing libraries and printing results.
    The following is `arg_check.py`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加其余的代码，例如导入库和打印结果。以下为`arg_check.py`：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When a value is provided as input to the function `circle_measures()`, the
    decorator `@arg_check` checks to see whether the value is an integer and if it
    is positive. If it meets the requirements, the function is allowed to finish and
    the results are printed, as shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当向`circle_measures()`函数提供值作为输入时，装饰器`@arg_check`会检查该值是否为整数以及是否为正数。如果满足要求，则允许函数完成并打印结果，如下面的截图所示：
- en: '![](img/497b5d31-9fa0-4c2b-a38c-afadbac2b7a1.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/497b5d31-9fa0-4c2b-a38c-afadbac2b7a1.png)'
- en: 'If the argument passed to the function is negative, then an exception is raised,
    as shown in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递给函数的参数是负数，则会引发异常，如下面的截图所示：
- en: '![](img/5d9aba7f-9d88-40ee-9c2f-958358921970.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d9aba7f-9d88-40ee-9c2f-958358921970.png)'
- en: 'If the argument passed in is not an integer, an alternate exception is raised,
    as shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传入的参数不是整数，则会引发一个替代异常，如下面的截图所示：
- en: '![](img/ad548d61-40b3-4905-a798-af9af4111daf.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad548d61-40b3-4905-a798-af9af4111daf.png)'
- en: 'This code relies on the value passed to the function behind-the-scenes; there
    is no mechanism to allow user input. Accepting user input actually makes it slightly
    more complicated. The change is simple enough, simply adding the input call and
    passing the value to the `circle_measures()` call:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码依赖于传递给函数背后的值；没有机制允许用户输入。接受用户输入实际上使其稍微复杂一些。更改很简单，只需添加输入调用并将值传递给`circle_measures()`调用即可：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, since the input is captured as a string, direct input to the function
    would always error out, as shown in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于输入被捕获为字符串，直接输入到函数中总是会出错，如下面的截图所示：
- en: '![](img/e7a7244b-f7f9-480f-a29e-641b6bd31577.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e7a7244b-f7f9-480f-a29e-641b6bd31577.png)'
- en: 'Casting the user input to a integer, that is, `diameter, circumference, area
    = circle_measures(int(r))`, at first glance, eliminates this problem, as the number
    will always be an integer. However, it just causes another problem if the value
    provided by the user doesn''t actually convert to an integer, as shown in the
    following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户输入转换为整数，即`diameter, circumference, area = circle_measures(int(r))`，乍一看，消除了这个问题，因为数字始终是整数。然而，如果用户提供的值实际上不能转换为整数，这只会造成另一个问题，如下面的截图所示：
- en: '![](img/730b69b3-eeec-4985-87f8-779d2ae6d7e3.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/730b69b3-eeec-4985-87f8-779d2ae6d7e3.png)'
- en: 'Obviously, with a little bit of work, all issues could be resolved, but this
    example shows a few things:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，经过一点努力，所有问题都可以解决，但这个例子展示了以下几点：
- en: It can be easier to make a program work when you don't have to account for all
    possible input values.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你不必考虑所有可能的输入值时，使程序工作可能更容易。
- en: Decorators can actually make life easier, if some thought is put into how to
    write their wrapper function.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在编写包装函数时投入一些思考，装饰器实际上可以使生活变得更简单。
- en: Effective testing of software is a critical piece of software development; testing
    for edge cases and potential out-of-bounds data input can reveal interesting things
    and prevent potential security issues.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效地测试软件是软件开发的关键部分；测试边缘情况和潜在的越界数据输入可以揭示有趣的事情并防止潜在的安全问题。
- en: Using class decorators
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类装饰器
- en: Starting with Python 2.6, decorators have been made to work with classes. In
    this case, rather than just applying solely to functions, class decorators can
    be used on individual instances of classes or can be used on the class itself.
    They are frequently used to make a developer's logic intentions more obvious.
    They can also help minimize errors when it comes to calling methods or when dealing
    with objects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 2.6开始，装饰器被设计成与类一起工作。在这种情况下，而不是仅仅应用于函数，类装饰器可以用于类的单个实例或用于类本身。它们通常用于使开发者的逻辑意图更明显。它们还可以帮助在调用方法或处理对象时最小化错误。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Class methods can be decorated as well. Instance methods are the most common
    form of methods, that is, functions in classes. Here is `cat_class.py` with a
    few methods to work with:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类方法也可以进行装饰。实例方法是方法的最常见形式，即类中的函数。以下是一个包含一些方法的`cat_class.py`示例：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To utilize this class, create an instance of `Cat`, providing the initial parameters:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用此类，创建一个`Cat`实例，提供初始参数：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, call the methods to ensure that they work:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，调用方法以确保它们能正常工作：
- en: '![](img/c7c22727-14a4-464a-b599-7977ef401e44.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7c22727-14a4-464a-b599-7977ef401e44.png)'
- en: 'Notice that the methods are tied to a particular instance; they cannot be called
    on the generic `Cat` class:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，方法与特定实例相关联；它们不能在通用的`Cat`类上调用：
- en: '![](img/f8460196-44ab-4f62-b87b-626e4fb6882c.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f8460196-44ab-4f62-b87b-626e4fb6882c.png)'
- en: 'Static methods are methods that apply to all instances. They are denoted by
    the `@staticmethod` decorator prior to a method definition. Also, the method itself
    does not require a `self` argument in the definition (`static_method.py`):'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态方法是应用于所有实例的方法。它们通过在方法定义之前使用`@staticmethod`装饰器来表示。此外，方法本身在定义中不需要`self`参数（`static_method.py`）：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Static methods can be applied to both instances and the class itself:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态方法可以应用于实例和类本身：
- en: '![](img/1b2a88c3-332e-428b-a3cc-d4d3a0a91d0d.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b2a88c3-332e-428b-a3cc-d4d3a0a91d0d.png)'
- en: Notice that on lines 29 and 31, calling the static method without parentheses
    returns the memory location of the method; the method is not bound to an instance,
    but is available to the class as well. Only when parentheses are used (lines 30
    and 32) will the correct return object be displayed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第29行和第31行，调用不带括号的静态方法返回方法的内存位置；该方法未绑定到实例，但也可供类使用。只有当使用括号时（第30行和第32行），才会显示正确的返回对象。
- en: 'Class methods are identified by the `@classmethod` decorator prior to creating
    the method. In addition, the method argument is `cls` instead of `self`. The following
    code can be added after the static method in the previous example (`class_method.py`):'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类方法通过在创建方法之前使用`@classmethod`装饰器来识别。此外，方法参数是`cls`而不是`self`。以下代码可以添加到上一个示例中的静态方法之后（`class_method.py`）：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, when instance is made, the class it comes from is checked. If the generic `Cat` class
    is the generator, a message will be printed. If a subclass of `Cat` is used, then
    the name of the class is printed:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当创建实例时，会检查它所属的类。如果通用的`Cat`类是生成器，则会打印一条消息。如果使用`Cat`的子类，则会打印出类的名称：
- en: '![](img/bfa5d66b-d6ff-4066-a352-9a4a282835e7.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bfa5d66b-d6ff-4066-a352-9a4a282835e7.png)'
- en: Examples of decorators
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器的示例
- en: Frameworks, such as for web development or graphical interface design, frequently
    have decorators to automate functionality for a developer. While a developer can
    access parts of a framework directly, such as modules and functions, using decorators
    to facilitate this process makes a programmer's life easier.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 框架，如用于Web开发或图形界面设计的框架，通常具有装饰器来自动化开发者的功能。虽然开发者可以直接访问框架的某些部分，如模块和函数，但使用装饰器来简化这个过程可以使程序员的寿命更长。
- en: For example, many web frameworks include a decorator, `@login_required`, to
    ensure that a user is authenticated with the website before being allowed to do
    anything on the site. While login and authentication capabilities could be coded
    by the developer, the framework includes that functionality because it is such
    an integral part of how websites work.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，许多 Web 框架包括一个装饰器 `@login_required`，以确保用户在网站上执行任何操作之前已经通过网站认证。虽然登录和认证功能可以由开发者编码实现，但框架包括该功能，因为它构成了网站工作方式的一个基本部分。
- en: Because it is such an important part of website functionality and is frequently
    used, having a well-developed authentication method should be provided by the
    framework. Much like cryptography, leaving it up to developers to properly implement
    can lead to trouble, as it is easier to do it wrong than to do it right.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是网站功能的一个重要部分并且经常被使用，因此框架应该提供一个经过良好开发的认证方法。就像密码学一样，将其留给开发者正确实现可能会导致问题，因为做错比做对更容易。
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To utilize this recipe, you will have to install the Flask web framework. However,
    the following Flask example doesn't cover everything regarding how to use Flask;
    the installation is simply to ensure that no errors occur. Flask itself can take
    an entire book to cover. This section is designed to show how decorators are used
    in the real world to accomplish a variety of tasks and is not intended to show
    a working Flask website.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个配方，你必须安装 Flask Web 框架。然而，以下 Flask 示例并没有涵盖如何使用 Flask 的所有内容；安装只是为了确保不会出现错误。Flask
    本身可能需要一本书来涵盖。本节旨在展示装饰器如何在现实世界中用于完成各种任务，而不是展示一个工作的 Flask 网站。
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Flask does not include a login decorator function, but the documentation does
    provide an example of how to roll your own ([http://flask.pocoo.org/docs/0.12/patterns/viewdecorators/](http://flask.pocoo.org/docs/0.12/patterns/viewdecorators/)).
    This should not be used for production use, even if it copies the Flask functionality,
    as you would then be responsible for ensuring that any modifications to your code
    don''t affect the login functionality:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 不包括登录装饰器函数，但文档确实提供了一个如何自己实现的例子 ([http://flask.pocoo.org/docs/0.12/patterns/viewdecorators/](http://flask.pocoo.org/docs/0.12/patterns/viewdecorators/))。即使它复制了
    Flask 的功能，也不应将其用于生产环境，因为那时你必须确保对代码的任何修改都不会影响登录功能：
- en: 'Import the `wraps` function from the Python standard library''s `functools`
    module. This is necessary to retain the original function''s data:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Python 标准库的 `functools` 模块导入 `wraps` 函数。这是为了保留原始函数的数据：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A number of Flask tools need to be imported. `g` is a Flask application global,
    a special object that is only valid for the active request and returns a different
    value for each request. `request` is the default request object in Flask; it remembers
    the matched endpoint and view arguments. `redirect` returns an HTTP 30x redirection
    code to send the client to the correct destination. `url_for` creates a URL for
    the given endpoint (a web page created by a function call):'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要导入许多 Flask 工具。`g` 是 Flask 应用程序的全局变量，是一个仅在当前请求中有效的特殊对象，并为每个请求返回不同的值。`request`
    是 Flask 中的默认请求对象；它记住匹配的端点和视图参数。`redirect` 返回一个 HTTP 30x 重定向代码，将客户端发送到正确的目的地。`url_for`
    为给定的端点创建一个 URL（由函数调用创建的网页）：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Write the login decorator function:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写登录装饰器函数：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When implementing the login decorator, it is the last decorator to be used
    prior to writing the main function:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现登录装饰器时，它是编写主函数之前最后使用的装饰器：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'One possible use of a decorator is to set up a timing function to time other
    functions. That way, you don''t have to call `time` from the command line when
    running a script. The following code should be written to a file and not entered
    into an interactive Python prompt (`time_decorator_creation.py`):'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 装饰器的一个可能用途是设置计时函数来计时其他函数。这样，在运行脚本时，你不必从命令行调用 `time`。以下代码应写入一个文件，而不是输入到交互式 Python
    提示符中（`time_decorator_creation.py`）：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `time_decorator` can be used with any function to provide the time it takes
    for the function to complete. The following code should be written to the same
    file as the preceding decorator (`time_dec.py`):'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`time_decorator` 可以与任何函数一起使用，以提供函数完成所需的时间。以下代码应写入与前面装饰器相同的文件（`time_dec.py`）：'
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Running the preceding code results in the following:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下结果：
- en: '![](img/8f1b249f-39ec-45d7-9d47-6feaf219d718.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8f1b249f-39ec-45d7-9d47-6feaf219d718.png)'
- en: 'This example (from [https://www.python.org/dev/peps/pep-0318/#examples](https://www.python.org/dev/peps/pep-0318/#examples))
    shows how to add attributes to a function. One use case may be automatically adding
    data to a function, such as metadata (`add_attributes.py`):'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个示例（来自[https://www.python.org/dev/peps/pep-0318/#examples](https://www.python.org/dev/peps/pep-0318/#examples)）展示了如何向函数添加属性。一个用例可能是自动向函数添加数据，例如元数据（`add_attributes.py`）：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Another example from the PEP-318 documentation is to create a decorator that
    enforces function argument and return types. This is useful when programatically
    running scripts that accept/return arguments, but you cannot guarantee the object
    types that may be input (`function_enforcement.py`):'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个来自PEP-318文档的示例是创建一个强制函数参数和返回类型的装饰器。这在程序运行接受/返回参数的脚本时很有用，但你无法保证可能输入的对象类型（`function_enforcement.py`）：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you write unit tests using the `nose` library, the following example (from [https://stackoverflow.com/users/9567/torsten-marek](https://stackoverflow.com/users/9567/torsten-marek)),
    demonstrates how a decorator can automatically pass parameters into a unit test
    function (the full code is not provided, just the implementation on the final
    function call):'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用`nose`库编写单元测试，以下示例（来自[https://stackoverflow.com/users/9567/torsten-marek](https://stackoverflow.com/users/9567/torsten-marek)）展示了如何使用装饰器自动将参数传递给单元测试函数（完整代码未提供，仅提供最终函数调用的实现）：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once the `Flask` modules are imported, the login decorator function provides
    the main logic for handling user authentication. The Python standard library's `@wraps()`
    decorator call does the same thing we have done previously with the `def wrapper()`
    function, except we are utilizing the `functools.wraps` function provided by `Flask`.
    This is necessary because the login decorator wraps and replaces the original
    function; without a wrapper, that original data would be lost during the handover.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦导入`Flask`模块，登录装饰器函数提供了处理用户认证的主要逻辑。Python标准库的`@wraps()`装饰器调用与之前我们用`def wrapper()`函数所做的一样，只是我们现在利用了`Flask`提供的`functools.wraps`函数。这是必要的，因为登录装饰器封装并替换了原始函数；如果没有包装器，原始数据在交接过程中会丢失。
- en: The `decorated_function()` takes any number of arguments, either as positional
    or keyword:value pairs. This function first checks to see whether the global object `g.user`
    is `None`, that is, a user not logged in. If this is the case, the user is automatically
    redirected to the `login` page. Because of how Flask works, each page URL is actually
    a function call; the function's name dictates the URI path (more information on
    Flask functionality is provided later).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`decorated_function()`函数可以接受任意数量的参数，无论是位置参数还是关键字：值对。这个函数首先检查全局对象`g.user`是否为`None`，即未登录的用户。如果是这种情况，用户将被自动重定向到`login`页面。由于Flask的工作方式，每个页面URL实际上是一个函数调用；函数的名称决定了URI路径（有关Flask功能的更多信息将在后面提供）。'
- en: If the user is already logged in, then the `f()` function (the original function
    called) is called with the arguments the login decorator received. Finally, the
    decorator function ends, returning logic control back to the original function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户已经登录，则使用登录装饰器接收到的参数调用`f()`函数（原始调用的函数）。最后，装饰器函数结束，将逻辑控制权返回给原始函数。
- en: There's more...
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here is a real-world example, `long_flask_program.py` from a blog project this
    author created, using the Flask web framework as part of an online mentoring curriculum
    ([https://github.com/crystalattice/Blogful](https://github.com/crystalattice/Blogful)):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个真实世界的示例，来自作者创建的一个博客项目，使用Flask Web框架作为在线辅导课程的一部分（[https://github.com/crystalattice/Blogful](https://github.com/crystalattice/Blogful)）：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding example, three decorators are applied to the function entries:
    `@app.route("/")`, `@app.route("/page/<int:page>")`, and `@login_required`. The
    decorators are built into Flask and are accessed via the Flask API. `@app.route()` captures
    URL requests and determines which function to call in relation to the URL. `@login_required` comes
    from the Flask login extension and ensures that a user is logged in prior to processing
    a function; if not, the user is redirected to a login screen.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，有三个装饰器应用于函数入口：`@app.route("/")`、`@app.route("/page/<int:page>")`和`@login_required`。这些装饰器是Flask内置的，通过Flask
    API访问。`@app.route()`捕获URL请求并确定与URL相关的函数调用。`@login_required`来自Flask登录扩展，确保在处理函数之前用户已登录；如果没有，用户将被重定向到登录界面。
- en: The `entries` function simply populates a web page with the entries in a blog's
    database. `@app.route("/")` specifies that, when the root URL is provided for
    the website, the browser will be brought to the `entries` function, which will
    process the request and display the blog entries (for the Flask framework, each
    function call in the `views.py` file becomes a URL address. Thus, `entries` would
    appear to a browser as `www.blog_website.com/entries`).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`entries`函数简单地用博客数据库中的条目填充网页。`@app.route("/")`指定当提供网站的根URL时，浏览器将被带到`entries`函数，该函数将处理请求并显示博客条目（对于Flask框架，`views.py`文件中的每个函数调用都成为一个URL地址。因此，`entries`在浏览器中看起来像`www.blog_website.com/entries`）。'
- en: The decorator `@app.route("/page/<int:page>")` specifies that with a URL with
    the resource locator ending in `/page/#`, such as `www.blog_website.com/page/2`,
    the decorator redirects the page request to `entries` and displays the blog posts
    for the indicated page, in this case page 2.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器`@app.route("/page/<int:page>")`指定当URL以资源定位器`/page/#`结尾时，例如`www.blog_website.com/page/2`，装饰器将页面请求重定向到`entries`，并显示指定页面的博客文章，在这种情况下是第2页。
- en: '`entries` defaults to the first page, as shown in the argument passed to it.
    The `default_entries` and `max_entries` dictate how many pages are available on
    the site. Obviously, changing or removing those values can make the blog site
    dump all entries to a single page.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`entries`默认为第一页，正如传递给它的参数所示。`default_entries`和`max_entries`决定了网站上可用的页数。显然，更改或删除这些值可以使博客网站将所有条目都显示在单个页面上。'
- en: The `@login_required` decorator catches calls or redirects to the `entries` function
    and makes a pit stop to Flask's authentication module. The user's session is queried
    to see whether the user has authenticated with the system; if not, the user is
    informed that authentication is required prior to accessing the site.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`@login_required`装饰器捕获对`entries`函数的调用或重定向，并在Flask的认证模块中稍作停留。查询用户的会话以查看用户是否已与系统进行身份验证；如果没有，用户将被告知在访问网站之前需要进行身份验证。'
- en: While functionality for the site could be set up without using decorators, it
    hopefully can be seen that using decorators makes it much easier to deal with
    website access. In this case, anytime the web server is told to send a page of
    blog posts to the browser, the URL is parsed to see whether it matches either
    the root "`/`" directory, or a specific page number. If so, then authentication
    is checked. If the user is logged into the site, then the blog post entries are
    finally displayed in the browser.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以在不使用装饰器的情况下设置网站的功能，但希望可以看到使用装饰器使处理网站访问变得更加容易。在这种情况下，每当网络服务器被指示向浏览器发送博客文章页面时，URL会被解析以查看它是否与根目录"`/`"或特定的页码匹配。如果是这样，则进行身份验证检查。如果用户已登录到网站，则最终在浏览器中显示博客文章条目。
- en: For this particular program, decorators are also available to catch requests
    to add and delete blog posts, display a particular blog entry (rather than an
    entire page), edit entries, display the login page, and logout a user.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的程序，装饰器也可以用来捕获添加和删除博客文章的请求，显示特定的博客条目（而不是整个页面），编辑条目，显示登录页面，以及注销用户。
- en: '`decorator_args.py`, below, is from another portion of the Flask blog application,
    showing how one decorator can be used to do different things, depending on the
    arguments passed to it:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`decorator_args.py`来自Flask博客应用的另一个部分，展示了如何使用一个装饰器根据传递给它的参数执行不同的操作：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In these examples, both `/entry/add` and `/login` URI calls accept either a
    `GET` or `POST` HTTP request for the database. In the case of a `GET` request,
    the database is queried and the desired information is returned to the screen. If
    the HTTP request is a `POST`, the appropriate decorator is called and the data
    provided in the request is input to the database.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，`/entry/add`和`/login` URI调用都接受对数据库的`GET`或`POST` HTTP请求。在`GET`请求的情况下，数据库被查询，所需信息被返回到屏幕上。如果HTTP请求是`POST`，则调用适当的装饰器，并将请求中提供的数据输入到数据库中。
- en: In both cases, the decorator function is effectively the same call; the only
    difference is whether it is a `GET` or `POST` request that is made. The decorator
    knows what to do, based on those arguments.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，装饰器函数实际上是相同的调用；唯一的区别是是否是`GET`或`POST`请求。装饰器根据这些参数知道该做什么。
- en: 'When dealing with login authentication, a better option is to use the [https://flask-login.readthedocs.io/en/latest/](https://flask-login.readthedocs.io/en/latest/) extension,
    which provides the following features:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理登录认证时，更好的选择是使用 [https://flask-login.readthedocs.io/en/latest/](https://flask-login.readthedocs.io/en/latest/)
    扩展，它提供了以下功能：
- en: Store active user's session ID
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储活动用户的会话ID
- en: Easy user login and logout
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的用户登录和注销
- en: Restricts views to logged in and logged out users
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制视图仅对登录和注销用户可见
- en: Handles "remember me" functionality
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理“记住我”功能
- en: Protects session cookies
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护会话cookie
- en: Integration with other Flask extensions
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他Flask扩展的集成
- en: Using the decorators module
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用装饰器模块
- en: With all the functionality that decorators provide, and their common use among
    Python packages, it's inevitable that someone would create a package just for
    decorators. [https://pypi.python.org/pypi/decorator](https://pypi.python.org/pypi/decorator) provides
    a `pip` installable package to help when working with decorators.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于装饰器提供的所有功能以及它们在Python包中的常用性，有人创建一个仅针对装饰器的包是不可避免的。[https://pypi.python.org/pypi/decorator](https://pypi.python.org/pypi/decorator)
    提供了一个可使用 `pip` 安装的包，以帮助在使用装饰器时工作。
- en: The `decorator` module is a very stable (more than 10 years old) tool that provides
    the ability to preserve decorated functions across different Python versions.
    The aim of the module is to simplify decorator usage, reduce boilerplate code,
    and enhance program readability and maintainability.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`decorator` 模块是一个非常稳定的（超过10年历史）工具，它提供了在不同Python版本之间保留装饰函数的能力。该模块的目标是简化装饰器使用，减少样板代码，并增强程序的可读性和可维护性。'
- en: 'Decorators can be broken down into two main types: signature-preserving and
    signature-changing. The preserving decorators take a function call and return
    a function as the output, without changing anything about the function call''s
    signature. These decorators are the most common type.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器可以分为两大类：签名保留和签名更改。保留装饰器接受一个函数调用并返回一个函数作为输出，而不改变函数调用的签名。这些装饰器是最常见的类型。
- en: Signature-changing decorators accept a function call, but change the signature
    when output, or simply return non-callable objects. `@staticmethod` and `@classmethod`,
    discussed previously, are examples of signature-changing decorators.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 签名更改装饰器接受一个函数调用，但在输出时更改签名，或者简单地返回不可调用的对象。之前讨论过的 `@staticmethod` 和 `@classmethod`
    是签名更改装饰器的例子。
- en: Identifying a function's signature is provided by Python's introspection capabilities.
    In essence, a signature provides all necessary information about a function, that
    is, input and output parameters, default arguments, and so on, so that a developer,
    or the program, knows how to use a function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Python的反射能力提供了函数签名的识别。本质上，签名提供了关于函数的所有必要信息，即输入和输出参数、默认参数等，以便开发人员或程序知道如何使用该函数。
- en: This module is designed to provide generic *factory of generators* to hide the
    complexity of making signature-preserving decorators. Preserving decorators, while
    more common, are not necessarily easy to code from scratch, especially if the
    decorator needs to accept all functions with any signature.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块旨在提供通用的生成器*工厂*，以隐藏创建签名保留装饰器的复杂性。保留装饰器虽然更常见，但并不一定容易从头编写代码，特别是如果装饰器需要接受任何签名的所有函数。
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'A common use of decorators, outside of frameworks, is to memoize functions.
    Memoization caches the results of a function call to a dictionary; if the function
    is called again with the same arguments, the result is pulled from the cache rather
    than rerunning the function again. Many memoization functions and decorators have
    been created, but most don''t preserve the signature. The following examples are
    taken from the `decorator` module''s documentation ([http://decorator.readthedocs.io/en/latest/tests.documentation.html](http://decorator.readthedocs.io/en/latest/tests.documentation.html)):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器在框架之外的一个常见用途是函数的缓存。缓存将函数调用的结果存储在字典中；如果函数再次以相同的参数调用，结果将从缓存中提取，而不是重新运行函数。已经创建了大量的缓存函数和装饰器，但大多数都不保留签名。以下示例取自
    `decorator` 模块的文档([http://decorator.readthedocs.io/en/latest/tests.documentation.html](http://decorator.readthedocs.io/en/latest/tests.documentation.html))：
- en: 'A memoization decorator can be written to cache the input arguments to a dictionary
    (`memoize_dec.py`):'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以编写一个缓存输入参数到字典的缓存装饰器（`memoize_dec.py`）：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A simple function, with one input argument, works just fine (`memoize_funct.py`):'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个简单的函数，有一个输入参数，运行得很好（`memoize_funct.py`）：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The problem comes when Python introspection tools, such as `pydoc` get involved.
    These introspection tools will see that the decorator states that any number of
    arguments can be accepted, as it is a generic function signature. However, the
    reality is that the main function (`f1()`) only accepts one argument. Trying to
    use more than one argument will result in an error.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 Python 反射工具，如 `pydoc` 参与进来时，问题出现了。这些反射工具将看到装饰器声明可以接受任意数量的参数，因为它是一个通用函数签名。然而，实际情况是主函数
    (`f1()`) 只接受一个参数。尝试使用多个参数将导致错误。
- en: 'If the `decorate` function from the `decorator` modules is used, this problem
    is alleviated. `decorate` takes two arguments: a caller function that describes
    the decorator''s functionality and the main function to be called.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用 `decorator` 模块中的 `decorate` 函数，这个问题可以得到缓解。`decorate` 接受两个参数：一个描述装饰器功能的调用函数和要调用的主函数。
- en: 'In this case, the new decorator becomes two separate functions. The first one
    is the `main` decorator function, that is, the wrapper (`call_dec.py`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，新的装饰器变成了两个独立的函数。第一个是 `main` 装饰器函数，即包装器（`call_dec.py`）：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The second function is the actual decorator that will be called (`def_memoize.py`):'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个函数是实际要调用的装饰器（`def_memoize.py`）：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Having two separate functions makes the decorator remove the need for nested
    functions (making it easier to walk through the logic flow) and the developer
    is forced to explicitly pass the desired function for decoration; closures are
    no longer required.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有两个独立的函数使得装饰器不再需要嵌套函数（这使得逻辑流程更容易理解），并且开发者被迫显式地传递要装饰的函数；闭包不再需要。
- en: 'The following code is a simple sleep timer to simulate data processing (`run_memoize.py`):'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码是一个简单的睡眠计时器，用于模拟数据处理（`run_memoize.py`）：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When the `data_simulator()` function is called for the first time, it will take
    the full two seconds to run, due to the sleep function call. However, when it
    is called in the future, the `done` response will be instantaneous because it
    is being pulled from the cache, rather than actually being processed.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当第一次调用 `data_simulator()` 函数时，由于调用了 sleep 函数，将需要整整两秒钟才能运行。然而，当将来再次调用时，`done`
    响应将是瞬间的，因为它是从缓存中提取的，而不是实际处理。
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The initial `memoize_uw()` decorator creates a blank dictionary to use as the
    cache. The enclosed `memoize()` function takes any number of arguments and looks
    to see whether any of them is a keyword; if so, a frozen set is used to take the
    arguments and use them as values for the keywords. If there are no keywords provided,
    then a new key:value item is created.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的 `memoize_uw()` 装饰器创建一个空字典作为缓存。封装的 `memoize()` 函数接受任意数量的参数，并检查其中是否有关键字；如果有，则使用冻结集合来接受参数，并将它们用作关键字的值。如果没有提供关键字，则创建一个新的键：值项。
- en: If the keyword is not already in the cache dictionary, then a new item is placed
    in the cache; otherwise, the cached item is pulled from the cache and becomes
    a return value. Finally, the entire decorator closes out and the final value is
    returned to the main program.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果关键字尚未在缓存字典中，则将新项放入缓存；否则，从缓存中提取缓存的项并成为返回值。最后，整个装饰器关闭，并将最终值返回给主程序。
- en: In the new `_memoize()` function, the same functionality is provided but, as
    the caller function to the decorator, its argument signature must be in the form
    of `(f, *args, **kw)`. It must also call the original function with the arguments;
    this is demonstrated with the line `cache[key] = func(*args, **kw)`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的 `_memoize()` 函数中，提供了相同的功能，但作为装饰器的调用函数，其参数签名必须以 `(f, *args, **kw)` 的形式。它还必须使用参数调用原始函数；这通过以下行演示：`cache[key]
    = func(*args, **kw)`。
- en: The new `memoize()` decorator implements the cache as an empty dictionary, like
    before, but uses the `decorate()` function to return the `_memoize()` results
    to the original function.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `memoize()` 装饰器实现了将缓存作为一个空字典，就像之前一样，但使用 `decorate()` 函数将 `_memoize()` 的结果返回给原始函数。
- en: There's more...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Honestly, there's a lot of moving parts here that can get confusing quickly,
    especially for inexperienced Python programmers. A lot of practice and documentation
    referencing is required to get a handle on both decorators and the `decorator` module.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这里有很多移动部件，可能会很快变得令人困惑，尤其是对于经验不足的 Python 程序员。需要大量的实践和文档参考才能掌握装饰器和 `decorator`
    模块。
- en: Do you have to use decorators? No. They are just designed to make the life of
    a programmer easier. Plus, you should know about them because a lot of third-party
    libraries and packages, particularly web and GUI frameworks, utilize them.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须使用装饰器吗？不。它们只是被设计来让程序员的日常生活更轻松。此外，你应该了解它们，因为许多第三方库和包，尤其是Web和GUI框架，都使用了它们。
- en: Once you get a handle on decorators in general, the `decorator` module will
    probably make more sense, as well as show itself to be useful in minimizing hand-coded
    decorators. There is a lot of functionality included in the module that this book
    doesn't cover, such as converting a caller function directly into a decorator,
    class decorators, and dealing with blocking calls, that is, a process that won't
    allow the program to continue until the process is resolved.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你掌握了装饰器的一般用法，`decorator`模块可能会更有意义，同时也会显示出它在最小化手动编写的装饰器方面的实用性。该模块包含了许多本书没有涵盖的功能，例如直接将调用函数转换为装饰器、类装饰器以及处理阻塞调用，即一个不会允许程序继续执行直到该过程得到解决的过程。
- en: See also
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: You can also refer to the *Using class decorators *recipe of this chapter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以参考本章的*使用类装饰器*配方。
