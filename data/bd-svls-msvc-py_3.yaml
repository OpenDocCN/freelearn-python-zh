- en: Deploying Your Serverless Stack
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署您的无服务器堆栈
- en: In the previous chapter, we created a fully-functional serverless data API using
    the API Gateway, Lambda, and DynamoDB with an IAM role, and tested it once it
    was deployed. However, most of the code and configuration was deployed manually;
    a process that is prone to error, not repeatable, and not scalable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用API Gateway、Lambda和DynamoDB创建了一个完全功能的无服务器数据API，并使用IAM角色进行了测试。然而，大部分的代码和配置都是手动部署的；这个过程容易出错，不可重复，也不可扩展。
- en: 'In this chapter, we are going to show you how to deploy all that infrastructure
    using only code and configuration. The topics covered are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您展示如何仅使用代码和配置来部署所有这些基础设施。涵盖的主题如下：
- en: An overview of serverless-stack build and deploy options
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器堆栈构建和部署选项概述
- en: Creating a profile, an S3 bucket, IAM policies, and IAM roles resources
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建配置文件、S3存储桶、IAM策略和IAM角色资源
- en: Building and deploying with API Gateway, Lambda, and DynamoDB
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用API Gateway、Lambda和DynamoDB构建和部署
- en: An overview of serverless stack build and deploy options
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器堆栈构建和部署选项概述
- en: In this section, we will discuss the challenges in manually provisioning infrastructure,
    infrastructure as code, building and deploying using the serverless application
    model, and building and deploying using the alternative options.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论手动配置基础设施、基础设施即代码、使用无服务器应用程序模型构建和部署，以及使用替代选项构建和部署时面临的挑战。
- en: Manually provisioning infrastructure
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动配置基础设施
- en: The challenge of provisioning infrastructure is that it used to be a very manual
    process. For example, administrators would follow the steps described in a manual
    by clicking items on a user interface, running a set of commands, or logging into
    the servers and editing configuration files. This became more and more challenging
    with the growth of cloud computing and web frameworks that started to scale out.
    This could just be done with a monolithic architecture and their shared web servers
    or application servers. However, with the microservices architecture, there are
    different web servers and databases developed using different languages, and thousands
    of services running that need to be tested, built, and deployed independently.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 配置基础设施的挑战在于它曾经是一个非常手动的过程。例如，管理员会按照手册中描述的步骤点击用户界面上的项目，运行一系列命令，或者登录服务器并编辑配置文件。随着云计算和开始扩展的Web框架的增长，这变得越来越具有挑战性。这可以通过单片架构和它们共享的Web服务器或应用服务器来完成。然而，使用微服务架构，使用不同语言开发的不同Web服务器和数据库，以及运行的数千个服务需要独立测试、构建和部署。
- en: There are a lot of efforts in deploying services manually in terms of cost,
    and also in terms of the ability to maintain such configurations at scale. The
    deployment of services has become slower to scale up and also to recover from
    any errors, as you would have the administrator, for example, remotely connecting
    via SSH onto your box, rebooting the machine, or trying to understand what the
    issues were and actually changing the configuration many times for many machines.
    It's also very difficult to test and make any process repeatable. Any configuration
    changes, done either by using a user interface or editing configuration files
    on one server, were not very repeatable and also prone to human error or misconfiguration.
    For example, we were using the AWS Management Console in the previous chapters.
    Had you made some errors in any of the configuration, you would have to go back,
    diagnose the issue, and fix it, which is very time-consuming.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 手动部署服务在成本方面需要付出很多努力，也很难在规模上维护这样的配置。服务的部署变得更加缓慢，也更难从任何错误中恢复，因为您可能需要管理员通过SSH远程连接到您的服务器，重新启动机器，或者尝试理解问题所在，并多次更改多台机器的配置。测试和使任何过程可重复也非常困难。无论是使用用户界面还是编辑一个服务器上的配置文件进行的任何配置更改，都不太可重复，也容易出现人为错误或配置错误。例如，在之前的章节中我们使用了AWS管理控制台。如果您在任何配置中出现错误，您将不得不返回诊断问题并进行修复，这将非常耗时。
- en: In the next section, we will talk about infrastructure as code and how it helps
    to resolve the issues we have with manually provisioning infrastructure or deploying
    services.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论基础设施即代码以及它如何帮助解决手动配置基础设施或部署服务时遇到的问题。
- en: Infrastructure as code
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施即代码
- en: Infrastructure as code is basically the process of managing and provisioning
    your resources through definition files or code. It provides a centralized way
    to manage configuration in terms of implementation and version control. Suddenly,
    the resource management and provisioning becomes much more like the agile process
    in the systems-development life cycle in software. All changes are validated,
    tested, and provisioned as part of a release process and using standard deployment
    pipelines. This also provides the ability to copy configuration used to deploy
    infrastructure in one region to another.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施即代码基本上是通过定义文件或代码来管理和配置资源的过程。它提供了一种集中管理配置的方式，涉及实施和版本控制。突然之间，资源管理和配置变得更像是软件开发生命周期中的敏捷过程。所有更改都经过验证、测试，并作为发布过程的一部分进行配置，并使用标准的部署流程。这也提供了将用于在一个区域部署基础设施的配置复制到另一个区域的能力。
- en: 'For example, let''s say you deployed infrastructure in the North Virginia region
    using code and configuration, you could easily modify it to make it work in the
    Ireland region too. This allows you to scale out very quickly in terms of your
    configuration around the infrastructure and this led to the development of the
    term DevOps. This is where developers get much more involved in the configuration,
    especially around the infrastructure, and the ops team (or operations teams) gets
    much more involved in the development process. The following diagram shows the
    different benefits of infrastructure as code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您使用代码和配置在北弗吉尼亚地区部署基础设施，您可以轻松修改它以使其在爱尔兰地区运行。这使您能够快速扩展基础设施周围的配置，从而导致了术语DevOps的发展。这是开发人员在配置方面更加参与，特别是在基础设施周围，而运维团队（或运维团队）在开发过程中更加参与。以下图表显示了基础设施即代码的不同优势：
- en: '![](img/9baf9c90-8f05-41e9-a1ed-ce1d4e83c094.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9baf9c90-8f05-41e9-a1ed-ce1d4e83c094.png)'
- en: There are many benefits in using infrastructure as code. The first one is cost
    reduction, as you expend a lot less effort on simple and repetitive tasks. You
    can also reduce cost when scaling or deploying similar infrastructure.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基础设施即代码有许多好处。第一个是成本降低，因为您在简单和重复的任务上花费的精力要少得多。在扩展或部署类似基础设施时，您还可以降低成本。
- en: When building any system, I usually like to build it so that it works with two
    environments. Once it works for two, it will work for many. For example, if you
    build code with a naming convention as a prefix or variable for each environment,
    such as **dev** for **development** and **stg** for **staging**, and substitute
    it when deploying it, then we can easily later add a **prd** prefix for **production**.
    Using a standard naming convention is always highly recommended. Another example
    could be to always have three characters as a convention or rule, so that you
    will not get into the situation of having multiple prefixes, such prod or production,
    that can introduce unexpected errors. In a config file, the environment variable
    that would get substituted could look like `${env}`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建任何系统时，我通常喜欢构建它以便它可以在两个环境中运行。一旦它在两个环境中运行，它就可以在许多环境中运行。例如，如果您使用命名约定作为每个环境的前缀或变量构建代码，例如**dev**代表**development**，**stg**代表**staging**，并在部署时进行替换，那么我们以后可以轻松地为**production**添加**prd**前缀。始终强烈建议使用标准命名约定。另一个例子可能是始终将三个字符作为约定或规则，这样您就不会陷入具有多个前缀的情况，例如prod或production，这可能会引入意外错误。在配置文件中，将被替换的环境变量可能看起来像`${env}`。
- en: The other point is the speed of execution; that is, your administrators or DevOps
    team can actually release infrastructure and services a lot faster than they would
    have done before. In addition, there's a reduction in the risk of errors that
    can be introduced, for example, through manual configuration or user-interface
    changes. Also, having traceability, validation, and testing at each step helps
    reduce the number of errors and issues. Overall, this helps reduce risks and improves
    security. Since you have this traceability, you can understand what was deployed
    and find out whether it was successful, or whether it's causing an issue and should
    be rolled back.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要点是执行速度；也就是说，您的管理员或DevOps团队实际上可以比以前更快地发布基础设施和服务。此外，通过在每个步骤进行跟踪、验证和测试，有助于减少错误和问题的数量。总的来说，这有助于降低风险并提高安全性。由于有了这种可追溯性，您可以了解部署了什么，以及它是否成功，或者它是否导致问题并应该回滚。
- en: Building and deploying using the Serverless Application Model (SAM)
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用无服务器应用程序模型（SAM）构建和部署
- en: A tool that's emerged recently is the SAM ([https://github.com/awslabs/serverless-application-model](https://github.com/awslabs/serverless-application-model)),
    which is maintained by AWS. It allows you to build and deploy your serverless
    stack. It provides a simplified way to define and deploy any serverless resources
    or applications. At its base, it employs a cloud formation, but using fewer lines
    of source code than if you used the AWS command line. The basic concept of using
    a SAM template file is that it can be either a JSON or YAML file that contains
    all the serverless configuration, and its mascot is SAM the squirrel.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最近出现的一个工具是由AWS维护的SAM（[https://github.com/awslabs/serverless-application-model](https://github.com/awslabs/serverless-application-model)）。它允许您构建和部署无服务器堆栈。它提供了一种简化的方式来定义和部署任何无服务器资源或应用程序。在其基础上，它采用了云形成，但使用的源代码行数比使用AWS命令行要少。使用SAM模板文件的基本概念是它可以是包含所有无服务器配置的JSON或YAML文件，其吉祥物是松鼠SAM。
- en: Building and deploying using alternate options
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用备选选项构建和部署
- en: There are alternative options to deploying your AWS serverless stack. The first
    one is the AWS **Command-Line Interface** (**CLI**). The AWS CLI is an option
    when, for example, your organization does not want to use cloud formation stacks
    for everything or for parts of your serverless stack. The AWS CLI is also usually
    ahead of SAM in terms of feature releases. So, in this book, I use some commands
    to complement what is not built into SAM yet.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 部署AWS无服务器堆栈有替代选项。第一个选项是AWS命令行界面（CLI）。当您的组织不想为所有内容或部分无服务器堆栈使用云形成堆栈时，AWS CLI是一个选择。AWS
    CLI在功能发布方面通常领先于SAM。因此，在本书中，我使用一些命令来补充SAM中尚未构建的部分。
- en: Serverless Framework, initially called JAWS, is built using Node.js technology.
    It was ahead of its time when it was first released, but now with the AWS SAM,
    it's an additional layer on top of AWS that's maintained by a third party. However,
    it does allow you to use other functions from other cloud providers, such as Google
    and Azure, which is a great feature, but I personally question the reuse of your
    function code across cloud providers as the event source, security, and data shape
    are different anyway.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless Framework，最初称为JAWS，是使用Node.js技术构建的。它在最初发布时领先于时代，但现在随着AWS SAM的出现，它是由第三方维护的AWS顶层附加层。然而，它确实允许您使用其他云提供商的其他功能，例如Google和Azure，这是一个很棒的功能，但我个人质疑在不同云提供商之间重用函数代码的事件源、安全性和数据形状都是不同的。
- en: Chalice and Zappa are Python-based frameworks for AWS and are similar to Python
    Flask and Bottle micro web frameworks, but again, they are another abstraction
    on top of AWS. You need to wait for any improvements to cascade through.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Chalice和Zappa是基于Python的AWS框架，类似于Python Flask和Bottle微型Web框架，但它们又是AWS的另一种抽象。您需要等待任何改进通过。
- en: In addition, there's also the risk of having a dependency on those frameworks
    when AWS features are deprecated. You will need to keep in sync with them or rely
    on those other frameworks' open source committers to actually make changes or
    contribute directly. If I had to go for one, I would choose SAM, but I do accept
    that some people prefer serverless.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还存在一种风险，即依赖这些框架当AWS功能被弃用时。您需要与它们保持同步，或者依赖于这些其他框架的开源贡献者来实际进行更改或直接贡献。如果我必须选择一个，我会选择SAM，但我也接受一些人更喜欢无服务器。
- en: SAM needs an S3 bucket for package deployment, and the Lambda needs IAM policies
    and IAM roles. So let's look at that next.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: SAM需要一个S3存储桶来进行包部署，Lambda需要IAM策略和IAM角色。接下来让我们来看看这些。
- en: Creating a profile, an S3 bucket, IAM policies, and IAM roles resources
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建配置文件、S3存储桶、IAM策略和IAM角色资源
- en: We will first set up an S3 bucket that will hold the source code for the Lambda
    deployment package. IAM policies and roles allow API Gateway to invoke Lambda,
    and Lambda to access DynamoDB. We set them up using the AWS Management Console;
    here, we will use the AWS CLI and SAM.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置一个S3存储桶，用于保存Lambda部署包的源代码。IAM策略和角色允许API Gateway调用Lambda，并允许Lambda访问DynamoDB。我们使用AWS管理控制台设置它们；在这里，我们将使用AWS
    CLI和SAM。
- en: The code, shell scripts, and configuration files used in this chapter are available
    under the `./serverless-microservice-data-api/` folder.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码、shell脚本和配置文件都可以在`./serverless-microservice-data-api/`文件夹下找到。
- en: Creating an AWS credentials profile
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建AWS凭据配置文件
- en: 'Follow these steps to create an AWS credentials profile:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建AWS凭据配置文件：
- en: 'Create an AWS profile called `demo`:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`demo`的AWS配置文件：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Re-enter the same AWS `aws_access_key_id` and `aws_secret_access_key` details
    as in [Chapter 1](669eac03-68f5-4097-83fb-0f0ecce5ef42.xhtml), *Serverless Microservices
    Architectures and Patterns*, for `newuser`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`[Chapter 1](669eac03-68f5-4097-83fb-0f0ecce5ef42.xhtml)`中重新输入与`newuser`相关的相同的AWS
    `aws_access_key_id`和`aws_secret_access_key`详细信息。
- en: 'Alternatively, you can copy the `[default]` profile by copying `[default]`
    and creating a new entry for `[demo]`, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过复制`[default]`来复制`[default]`配置文件，并创建一个`[demo]`的新条目，如下所示：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code provided with this book needs a profile name (here, `demo`) to make
    use of the right keys; please change this in each shell script, `common-variables.sh`,
    for each project if you use another profile name.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的代码需要一个配置文件名称（这里是`demo`）来使用正确的密钥；如果您使用其他配置文件名称，请在每个项目的shell脚本`common-variables.sh`中更改它。
- en: Creating an S3 bucket
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个S3存储桶
- en: 'To deploy the Lambda source code, you will need to use an existing S3 bucket
    or create a new one—use the following code to create one:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署Lambda源代码，您需要使用现有的S3存储桶或创建一个新的——使用以下代码来创建一个：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Ensure that `<your-bucket-name>` can be addressable—it must follow DNS naming
    conventions. To choose your AWS Region, refer to AWS Regions and Endpoints ([https://docs.aws.amazon.com/general/latest/gr/rande.html](https://docs.aws.amazon.com/general/latest/gr/rande.html)).
    Generally, those in the USA can use `us-east-1` and those in Europe can use `eu-west-1`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`<your-bucket-name>`是可寻址的，它必须遵循DNS命名约定。要选择您的AWS区域，请参考AWS区域和终端点（[https://docs.aws.amazon.com/general/latest/gr/rande.html](https://docs.aws.amazon.com/general/latest/gr/rande.html)）。通常，美国用户可以使用`us-east-1`，欧洲用户可以使用`eu-west-1`。
- en: Setting up the configuration files for your AWS account
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的AWS账户设置配置文件
- en: 'I''ve created a configuration file called `common-variables.sh` for each serverless
    project under `./bash/`, which creates environment variables that are used by
    the AWS CLI and SAM. You will need to modify them with your AWS account details.
    This is done to lay the groundwork to support multiple AWS accounts in more than
    one region. Here is an example of `common-variables.sh`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为`./bash/`下的每个无服务器项目创建了一个名为`common-variables.sh`的配置文件，该文件创建了AWS CLI和SAM使用的环境变量。您需要使用您的AWS账户详细信息对它们进行修改。这样做是为了为在多个地区支持多个AWS账户打下基础。以下是`common-variables.sh`的示例：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s try to understand the code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着理解这段代码：
- en: Update `<your-aws-region>` with your AWS region, such as `us-east-1`.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您的AWS区域（例如`us-east-1`）更新`<your-aws-region>`。
- en: I'm dynamically determining the `aws_account_id`, but you can also hardcode
    it as shown in the comments, in which case uncomment the line and update `<your-aws-accountid>`
    with your AWS account ID. If you do not know it, you can find your account number
    in the AWS Management Console | Support | Support Center screen.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我正在动态确定`aws_account_id`，但您也可以像注释中所示那样硬编码它，在这种情况下，请取消注释该行，并将`<your-aws-accountid>`更新为您的AWS账户ID。如果您不知道它，您可以在AWS管理控制台|支持|支持中心屏幕中找到您的账户号码。
- en: '`template` is the name of the SAM template that we will be using.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`是我们将使用的SAM模板的名称。'
- en: '`bucket` and `prefix` define the location of the deployed Lambda package.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bucket`和`prefix`定义了部署的Lambda包的位置。'
- en: Updating the polices and assuming roles files
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新策略和假定角色文件
- en: You will need to change the AWS `aws_account_id` (currently set to `000000000000`)
    in the IAM policy documents stored under the `./IAM` folder. In addition, the
    region currently set to `eu-west-1` will have to be changed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要更改存储在`./IAM`文件夹下的IAM策略文档中的AWS `aws_account_id`（当前设置为`000000000000`）。此外，当前设置为`eu-west-1`的区域也必须更改。
- en: 'To replace your `aws_account_id` (assuming that your AWS `aws_account_id` is
    `111111111111`), you can do it manually or you can run the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换您的`aws_account_id`（假设您的AWS `aws_account_id`是`111111111111`），您可以手动执行，也可以运行以下命令：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating the IAM roles and policies
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建IAM角色和策略
- en: We created the IAM policies and roles manually in the AWS Management Console.
    We will now look at how we can create these using the AWS CLI.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在AWS管理控制台中手动创建了IAM策略和角色。现在我们将看看如何使用AWS CLI创建这些。
- en: 'Here is a JSON policy, `dynamo-readonly-user-visits.json`, that we have created
    under the `./IAM/` directory:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在`./IAM/`目录下创建的JSON策略`dynamo-readonly-user-visits.json`：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To summarize the policy, it says that we have `Query` and `Scan` access to two
    DynamoDB tables called `user-visits` that we created manually or in Python, and
    `user-visits-sam` that we are going to create in this chapter using SAM.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下策略，它表示我们对两个名为`user-visits`的DynamoDB表具有`Query`和`Scan`访问权限，这些表可以手动创建或在Python中创建，以及我们将在本章中使用SAM创建的`user-visits-sam`。
- en: 'Create a policy that allows the Lambda function to write the logs to CloudWatch
    logs. Create a `lambda-cloud-write.json` file with the following content:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个允许Lambda函数将日志写入CloudWatch日志的策略。创建一个名为`lambda-cloud-write.json`的文件，内容如下：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When creating an IAM role, you also need specify the type of IAM role it can
    assume. We have created an `assume-role-lambda.json` file, which is known as a
    trusted entity:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 创建IAM角色时，还需要指定它可以承担的IAM角色类型。我们创建了一个名为`assume-role-lambda.json`的文件，这被称为受信任的实体：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Having the preceding defined as JSON code allows us to version-control the security
    and permissions in AWS. In addition, if someone deleted them by mistake, we can
    simply recreate them in AWS.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述内容定义为JSON代码使我们能够在AWS中对安全性和权限进行版本控制。此外，如果有人错误地删除了它们，我们可以在AWS中简单地重新创建它们。
- en: 'We will now created a shell script called `create-role.sh`, under the `./bash`
    folder, to create a Lambda IAM role and three IAM policies, and attach them to
    the IAM role:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个名为`create-role.sh`的shell脚本，在`./bash`文件夹下，以创建一个Lambda IAM角色和三个IAM策略，并将它们附加到IAM角色：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Execute the script using `./create-role.sh`. It will create one IAM role and
    three IAM policies, and attach them to the IAM role. Notice that here code is
    idempotent on purpose, as policy changes need to be managed carefully as they
    could impact others.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`./create-role.sh`执行脚本。它将创建一个IAM角色和三个IAM策略，并将它们附加到IAM角色。请注意，此处的代码是有意幂等的，因为策略更改需要谨慎管理，因为它们可能会影响其他人。
- en: Note that there is also the ability to create IAM roles in a SAM template, but
    using the AWS CLI means that the roles and policies can be reused rather than
    deleted when the serverless stack is deleted. This adds version control if you
    check them into the Git standard naming convention and helps the support team
    by centralizing the creation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，还可以在SAM模板中创建IAM角色，但是使用AWS CLI意味着在删除无服务器堆栈时可以重用角色和策略，而不是删除它们。如果将它们检入Git标准命名约定，则可以添加版本控制，并通过集中创建来帮助支持团队。
- en: Checking the IAM roles and policies
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查IAM角色和策略
- en: 'The AWS CLI gives you feedback on the creation of the IAM role and policies,
    but you can also check in the AWS Management Console:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CLI会在创建IAM角色和策略时给您反馈，但您也可以在AWS管理控制台中检查：
- en: Sign in to the AWS Management Console and open the IAM console at [https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录AWS管理控制台，并在[https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/)上打开IAM控制台。
- en: In the IAM navigation pane, choose Roles.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IAM导航窗格中，选择角色。
- en: Choose `lambda-dynamo-data-api` from the list of roles.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从角色列表中选择`lambda-dynamo-data-api`。
- en: Choose Show more under Permissions policies on the Permissions tab.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在权限选项卡下选择显示更多权限策略。
- en: 'You should see the following three attached policies:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下三个附加的策略：
- en: '![](img/67b3fe80-4e4b-475e-aece-57205716093b.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67b3fe80-4e4b-475e-aece-57205716093b.png)'
- en: Building and deploying with API Gateway, Lambda, and DynamoDB
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用API Gateway，Lambda和DynamoDB构建和部署
- en: 'There are three steps involved in deploying a serverless stack:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 部署无服务器堆栈涉及三个步骤：
- en: Build Lambda as a ZIP package
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Lambda构建为ZIP包
- en: Package your serverless stack using SAM and CloudFormation
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用SAM和CloudFormation打包您的无服务器堆栈
- en: Deploy your serverless stack using SAM and CloudFormation
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用SAM和CloudFormation部署您的无服务器堆栈
- en: Building the Lambda as a ZIP package
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Lambda构建为ZIP包
- en: 'Install ZIP if it is not installed already. For Ubuntu/Debian, you can use
    `sudo apt-get install zip -y`. Create a file called `create-lambda-package.sh`
    with the following content:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未安装ZIP，请安装ZIP。对于Ubuntu/Debian，您可以使用`sudo apt-get install zip -y`。创建一个名为`create-lambda-package.sh`的文件，内容如下：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will create a ZIP file of the Lambda code only if the source code has changed.
    This is what will be deployed to AWS and there are advantages in separating these
    commands when we need to package third-party libraries.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将仅在源代码发生更改时创建Lambda代码的ZIP文件。这是将部署到AWS的内容，并且在需要打包第三方库时，将这些命令分开具有优势。
- en: SAM YAML template
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SAM YAML模板
- en: 'We will use a SAM template to create the serverless stack. SAM uses YAML or
    JSON, and allows you to define the Lambda function and API Gateway settings, as
    well as create a DynamoDB table. The template looks as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用SAM模板创建无服务器堆栈。SAM使用YAML或JSON，并允许您定义Lambda函数和API Gateway设置，以及创建DynamoDB表。模板如下所示：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From top to bottom, we first specify the template type, a description, and pass
    in a string parameter, `AccountId`. We then specify the Lambda details, such as
    `Handler`, which is the entry point, location of the ZIP code, and give the function
    a name and description. We then choose 128 MB RAM as this is a proof of concept
    and we won't need more memory; we specify `3` for the timeout. After this, the
    Lambda will terminate even if it is still running; this limits costs and is reasonable,
    since we expect a synchronous response. We then have the IAM Lambda execution
    role with the `${AccountId}` parameter that gets passed in when we deploy the
    serverless stack.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从上到下，我们首先指定模板类型，描述，并传递一个字符串参数`AccountId`。然后，我们指定Lambda的细节，例如`Handler`，这是入口点，ZIP代码的位置，并为函数指定名称和描述。然后，我们选择128
    MB的RAM，因为这是一个概念验证，我们不需要更多的内存；我们为超时指定`3`。之后，即使Lambda仍在运行，它也会终止；这限制了成本，并且是合理的，因为我们期望同步响应。然后，我们有IAM
    Lambda执行角色，其中包含`${AccountId}`参数，该参数在部署无服务器堆栈时传递。
- en: 'We saw how to add the environment variable that will be available in the Lambda
    function. The variable is `environment: dev`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '我们看到如何添加将在Lambda函数中可用的环境变量。变量是`environment: dev`。'
- en: We then have the trigger or event source for the Lambda function. Here, we create
    an API Gateway with a resource in the `/visits/{resourceId}` path with the `GET`
    method that will invoke a Lambda function with `resourceId`, which will be the
    `EventId`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有Lambda函数的触发器或事件源。在这里，我们创建了一个API Gateway，其中包含`/visits/{resourceId}`路径的资源，使用`GET`方法调用一个带有`resourceId`的Lambda函数，该`resourceId`将是`EventId`。
- en: Finally, we create a DynamoDB table with an `EventId` hash of the data type
    `string` and an `EventDay` range of data type `number` using Python. To keep costs
    down (or free), I've put the read and write capacities to `1`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用Python创建了一个DynamoDB表，其中`EventId`的哈希数据类型为`string`，`EventDay`的范围数据类型为`number`。为了降低成本（或免费），我将读取和写入容量设置为`1`。
- en: So in one SAM YAML file, we have configured the Lambda, API Gateway with its
    Lambda integration, and created a new DynamoDB table.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在一个SAM YAML文件中，我们已经配置了Lambda，具有其Lambda集成的API Gateway，并创建了一个新的DynamoDB表。
- en: For DynamoDB, I strongly recommend that you append `sam` at the end when it
    is a resource created by SAM, so you know the origin. I also recommend that if
    a DynamoDB table is shared between services, you create it using Boto3 or the
    AWS CLI. This is because the deletion of one serverless stack could mean the table
    is deleted for all services.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于DynamoDB，我强烈建议在SAM创建的资源末尾附加`sam`，以便知道其来源。我还建议，如果DynamoDB表在服务之间共享，最好使用Boto3或AWS
    CLI进行创建。这是因为删除一个无服务器堆栈可能意味着该表对所有服务都被删除。
- en: Packaging and deploying your serverless stack
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包和部署您的无服务器堆栈
- en: Once the IAM role with policies, the ZIP package with the Lambda code, and SAM
    template are all created, you just need to run two CloudFormation commands to
    package and deploy your serverless stack.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦具有策略的IAM角色，具有Lambda代码的ZIP包和SAM模板都创建好了，您只需要运行两个CloudFormation命令来打包和部署您的无服务器堆栈。
- en: 'The first command packages the Lambda code with the SAM template and pushes
    it to S3:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令将Lambda代码与SAM模板打包并推送到S3：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The second command deploys it to AWS:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令将其部署到AWS：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: One of the great features in SAM is the ability to use parameters. Here, this
    is done when we deploy the stack with `--parameter-overrides AccountId=${aws_account_id}`.
    The benefit is that we can reuse the same SAM template for multiple environments,
    such as AWS Accounts and Regions, and any other parameters.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: SAM中的一个很棒的功能是能够使用参数。在这里，当我们使用`--parameter-overrides AccountId=${aws_account_id}`部署堆栈时就可以实现。好处是我们可以在多个环境中重用相同的SAM模板，例如AWS帐户和区域，以及任何其他参数。
- en: 'You can check that the stack has been deployed to AWS correctly by checking
    the AWS Management Console:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过检查AWS管理控制台来验证堆栈是否已正确部署到AWS：
- en: Sign into the AWS Management Console at [https://console.aws.amazon.com/cloudformation/](https://console.aws.amazon.com/cloudformation/).
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到AWS管理控制台[https://console.aws.amazon.com/cloudformation/](https://console.aws.amazon.com/cloudformation/)。
- en: Choose Management & Governance | CloudFormation or search for CloudFormation
    under Find services.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择管理和治理| CloudFormation或在“查找服务”下搜索CloudFormation。
- en: In the CloudFormation pane, choose lambda-dynamo-data-api.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在CloudFormation窗格中，选择lambda-dynamo-data-api。
- en: Choose Events. This shows the different events and is very useful for diagnosing
    any issues you get when deploying a stack. Usually, it will be a naming conflict
    (for example, a DynamoDB table with the same name exists) or an IAM-related issue
    (for example, a role does not exist).
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择事件。这显示了不同的事件，并且在部署堆栈时非常有用。通常，这将是命名冲突（例如，具有相同名称的DynamoDB表存在）或IAM相关问题（例如，角色不存在）。
- en: 'Choose Resources. This shows the resources that are managed by this CloudFormation
    stack:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择资源。这显示了由此CloudFormation堆栈管理的资源：
- en: '![](img/31906f76-725d-4686-b076-afb5dab963e7.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31906f76-725d-4686-b076-afb5dab963e7.png)'
- en: You can also check the AWS Management Console directly if the API Gateway, Lambda
    function, and DynamoDB table have been created correctly.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以直接检查AWS管理控制台，以确保API Gateway，Lambda函数和DynamoDB表已正确创建。
- en: 'For example, here is the same Lambda we created using Python, but deployed
    and managed by SAM. Unless you are doing a proof of concept, it is recommended
    that any further changes are managed by configuration changes rather than changes
    in the AWS Management Console, as this would break the infrastructure as code
    and automation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是我们使用Python创建的相同Lambda，但由SAM部署和管理。除非您正在进行概念验证，建议进一步的更改通过配置更改而不是AWS管理控制台中的更改进行管理，因为这将破坏基础架构作为代码和自动化：
- en: '![](img/7d50d164-b37e-440d-8c4f-89cd41154572.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d50d164-b37e-440d-8c4f-89cd41154572.png)'
- en: Putting it all together
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容放在一起
- en: In this chapter, we deployed a fully-working serverless stack without the need
    to use the AWS Management Console to configure any settings using the user interface.
    This is the recommended way to deploy infrastructure and code as it's much more
    repeatable, scalable, and less prone to errors. It also allows you to do things
    such as revert configurations when everything is version-controlled in Git.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们部署了一个完全可工作的无服务器堆栈，无需使用用户界面配置任何设置。这是部署基础设施和代码的推荐方式，因为它更具可重复性，可扩展性，并且不太容易出错。它还允许您在一切都在Git中进行版本控制时执行诸如还原配置之类的操作。
- en: 'The shell scripts available under the `./serverless-microservice-data-api/bash`
    folder:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`./serverless-microservice-data-api/bash`文件夹下提供的shell脚本：'
- en: '`common-variables.sh`: Environment variables used by other scripts'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`common-variables.sh`：其他脚本使用的环境变量'
- en: '`create-role.sh`: Lambda IAM role created with the three policies attached'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create-role.sh`：Lambda IAM角色创建并附加了三个策略'
- en: '`lambda-dynamo-data-api.yaml`: Defines the SAM YAML template'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lambda-dynamo-data-api.yaml`：定义SAM YAML模板'
- en: '`create-lambda-package.sh`: Creates the Lambda ZIP package'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create-lambda-package.sh`：创建Lambda ZIP包'
- en: '`build-package-deploy-lambda-dynamo-data-api.sh`: Orchestrates the building
    of the Lambda ZIP, packaging, and deployment'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build-package-deploy-lambda-dynamo-data-api.sh`：编排Lambda ZIP的构建，打包和部署'
- en: 'Here are the contents of `build-package-deploy-lambda-dynamo-data-api.sh`,
    which you can run when you modify your Lambda code or other SAM configuration
    settings:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`build-package-deploy-lambda-dynamo-data-api.sh`的内容，当您修改Lambda代码或其他SAM配置设置时，可以运行它：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Manually testing the serverless microservice
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动测试无服务器微服务
- en: 'The steps for testing are as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 测试步骤如下：
- en: Sign in to the AWS Management Console and open the API Gateway console at [https://console.aws.amazon.com/apigateway/](https://console.aws.amazon.com/apigateway/).
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到AWS管理控制台，在[https://console.aws.amazon.com/apigateway/](https://console.aws.amazon.com/apigateway/)打开API
    Gateway控制台。
- en: In the Amazon API Gateway navigation pane, choose APIs | lambda-dynamo-data-api
    | Stages.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Amazon API Gateway导航窗格中，选择API | lambda-dynamo-data-api | Stages。
- en: Select GET under `Prod/visits/{resourceId}/GET` to get the invoke URL, which should
    look like `https://{restapi_id}.execute-api.{region}.amazonaws.com/Prod/visits/{resourceId}`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Prod/visits/{resourceId}/GET`下选择GET以获取调用URL，应该看起来像`https://{restapi_id}.execute-api.{region}.amazonaws.com/Prod/visits/{resourceId}`。
- en: Open a new browser tab and enter the `https://{restapi_id}.execute-api.{region}.amazonaws.com/Prod/visits/{resourceId}` URL.
    You will get the `{"message":"resource_id not a number"}` response body. This
    is because we validated `resource_id` in the `parse_parameters()` URL function
    before querying DynamoDB to make sure that it is a number.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的浏览器选项卡，输入`https://{restapi_id}.execute-api.{region}.amazonaws.com/Prod/visits/{resourceId}`
    URL。您将获得`{"message":"resource_id not a number"}`响应正文。这是因为我们在查询DynamoDB之前通过`parse_parameters()`
    URL函数验证了`resource_id`，以确保它是一个数字。
- en: Open a new browser tab and enter the `https://{restapi_id}.execute-api.{region}.amazonaws.com/Prod/visits/324` URL.
    As we have used the correct `resourceId`, you should see [ ] in your browser tab.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的浏览器选项卡，输入`https://{restapi_id}.execute-api.{region}.amazonaws.com/Prod/visits/324`
    URL。由于我们使用了正确的`resourceId`，您应该在浏览器选项卡中看到[ ]。
- en: Why are we getting no data?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们没有得到数据？
- en: Well, no data has been loaded into the `user-visits-sam` DynamoDB table, that
    is why!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，没有数据加载到`user-visits-sam` DynamoDB表中，这就是为什么！
- en: Run `python3 ./aws_dynamo/dynamo_modify_items.py` to load some records into
    the `user-visits-sam` DynamoDB table.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`python3 ./aws_dynamo/dynamo_modify_items.py`将一些记录加载到`user-visits-sam` DynamoDB表中。
- en: 'Here are the contents of `dynamo_modify_items.py`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`dynamo_modify_items.py`的内容：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now go to the same endpoint in the browser, and you should get the following
    data back:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在浏览器中转到相同的端点，您应该会收到以下数据：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Open a new browser tab and enter the `https://{restapi_id}.execute-api.{region}.amazonaws.com/Prod/visits/324?startDate=20171002` URL.
    As we have added the `startDate=20171002` parameter, you should see the following
    in your browser tab:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的浏览器选项卡，输入`https://{restapi_id}.execute-api.{region}.amazonaws.com/Prod/visits/324?startDate=20171002`
    URL。由于我们添加了`startDate=20171002`参数，您应该在浏览器选项卡中看到以下内容：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Making code and configuration changes
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行代码和配置更改
- en: Code rarely stays static, as new requirements and business requests arise. To
    illustrate how well changes are supported, assume we made some changes to the
    Lambda function Python code and now want to use Python 3.7, instead of Python
    3.6.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很少保持静态，因为会出现新的需求和业务请求。为了说明对更改的良好支持，假设我们对Lambda函数Python代码进行了一些更改，现在想要使用Python
    3.7，而不是Python 3.6。
- en: 'We can update the code, configuration, and stack in three steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过三个步骤更新代码，配置和堆栈：
- en: Change the `lambda_return_dynamo_records.py` Python code to make it compliant
    with Python 3.7.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`lambda_return_dynamo_records.py`的Python代码，使其符合Python 3.7。
- en: 'Change the `lambda-dynamo-data-api.yaml` SAM template as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`lambda-dynamo-data-api.yaml`的SAM模板如下：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run `./build-package-deploy-lambda-dynamo-data-api.sh`. This will rebuild the
    Lambda ZIP package, as the code has changed. Package and deploy the code and SAM
    configuration, and then CloudFormation will manage and deploy the changes.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`./build-package-deploy-lambda-dynamo-data-api.sh`。这将重新构建Lambda ZIP包，因为代码已更改。打包和部署代码和SAM配置，然后CloudFormation将管理和部署更改。
- en: Deleting the serverless stack
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除无服务器堆栈
- en: 'When you no longer need your serverless stack, you can delete it in the AWS
    Management Console under CloudFormation:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不再需要您的无服务器堆栈时，您可以在AWS管理控制台的CloudFormation下删除它：
- en: Sign in to the AWS Management Console and open the CloudFormation console at
    [https://console.aws.amazon.com/cloudformation/](https://console.aws.amazon.com/cloudformation/).
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到AWS管理控制台，在[https://console.aws.amazon.com/cloudformation/](https://console.aws.amazon.com/cloudformation/)打开CloudFormation控制台。
- en: From the list, select lambda-dynamo-data-api.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中选择lambda-dynamo-data-api。
- en: Choose Actions and then Delete Stack.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择操作，然后选择删除堆栈。
- en: Choose Yes, Delete when prompted.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示时选择是，删除。
- en: 'Alternatively, you can run the following shell script with `./delete-stack.sh`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`./delete-stack.sh`运行以下shell脚本：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You now have a much deeper understanding and some practical experience of manually
    deploying your serverless stack in a repeatable and consistent way using infrastructure-as-code
    principles. You can adapt these for your organization's serverless microservice
    needs. You know the service deployment options and you used the AWS CLI to create
    a bucket, IAM roles, and IAM policies, as well as the AWS SAM to deploy the API
    Gateway, Lambda, and DynamoDB. You also saw how you can easily modify the SAM
    template file to propagate changes throughout the stack. The full Python source
    code, IAM policies, roles, Linux, and shell scripts are provided with this book
    so you can adapt it for your needs. You can now take advantage of them without
    having to use the AWS management console GUI manually, and only need to modify
    the scripts when deploying other serverless microservices.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对手动部署无服务器堆栈以可重复和一致的方式有了更深入的理解和一些实际经验，使用基础设施即代码原则。您可以根据组织的无服务器微服务需求进行调整。您了解了服务部署选项，并使用AWS
    CLI创建了存储桶、IAM角色和IAM策略，以及使用AWS SAM部署了API Gateway、Lambda和DynamoDB。您还看到了如何轻松修改SAM模板文件以在整个堆栈中传播更改。本书提供了完整的Python源代码、IAM策略、角色、Linux和shell脚本，因此您可以根据自己的需求进行调整。现在，您可以利用它们，而无需手动使用AWS管理控制台GUI，并且只需要在部署其他无服务器微服务时修改脚本。
- en: Now that we have shown you how to deploy the stacks, it's really important that
    you know the code is functioning and performing as expected, especially as the
    code base grows and will be used in a production environment. We have not yet
    covered the mechanism for automated deployment and testing. So, in the next chapter,
    we are going to discuss and walk through the different types of testing you should
    use on your serverless microservice.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经向您展示了如何部署堆栈，非常重要的是您知道代码是否按预期运行和执行，特别是随着代码库的增长，并且将在生产环境中使用。我们还没有涵盖自动部署和测试的机制。因此，在下一章中，我们将讨论并介绍您在无服务器微服务上应该使用的不同类型的测试。
