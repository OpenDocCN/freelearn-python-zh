- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Using Decorators to Improve Our Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用装饰器改进我们的代码
- en: In this chapter, we will explore decorators and see how they are useful in many
    situations where we want to improve our design. We will start by first exploring
    what decorators are, how they work, and how they are implemented.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨装饰器，并了解它们在许多我们想要改进设计的情况中的有用之处。我们将首先探索装饰器是什么，它们是如何工作的，以及它们是如何实现的。
- en: With this knowledge, we will then revisit concepts that we learned in previous
    chapters regarding general good practices for software design and see how decorators
    can help us comply with each principle.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，我们将回顾我们在前几章中学到的关于软件设计的一般良好实践的概念，并看看装饰器如何帮助我们遵守每个原则。
- en: 'The goals of this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标如下：
- en: To understand how decorators work in Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解装饰器在Python中的工作方式
- en: To learn how to implement decorators that apply to functions and classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何实现适用于函数和类的装饰器
- en: To effectively implement decorators, avoiding common implementation mistakes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了有效地实现装饰器，避免常见的实现错误
- en: To analyze how to avoid code duplication (the DRY principle) with decorators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析如何使用装饰器避免代码重复（DRY原则）
- en: To study how decorators contribute to the separation of concerns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究装饰器如何有助于关注点的分离
- en: To analyze examples of good decorators
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了分析好的装饰器的例子
- en: To review common situations, idioms, or patterns for when decorators are the
    right choice
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了回顾当装饰器是正确选择时的常见情况、习语或模式
- en: What are decorators in Python?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的装饰器是什么？
- en: Decorators were introduced in Python a long time ago, in PEP-318, as a mechanism
    to simplify the way functions and methods are defined when they have to be modified
    after their original definition.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是在Python中很久以前引入的，在PEP-318中，作为一种在函数和方法的原始定义之后需要修改时的简化定义方式的机制。
- en: We first have to understand that in Python, functions are regular objects just
    like pretty much anything else. That means you can assign them to variables, pass
    them around by parameters, or even apply other functions to them. It was typical
    to want to write a small function, and then apply some transformations to it,
    generating a new modified version of that function (similar to how function composition
    works in mathematics).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先必须理解，在Python中，函数就像几乎所有其他东西一样是常规对象。这意味着你可以将它们赋给变量，通过参数传递它们，甚至将其他函数应用于它们。通常，人们会想写一个小函数，然后对其应用一些转换，生成该函数的新修改版本（类似于数学中函数组合的工作方式）。
- en: One of the original motivations for introducing decorators was that because
    functions such as `classmethod` and `staticmethod` were used to transform the
    original definition of the method, they required an extra line, modifying the
    original definition of the function in a separate statement.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 引入装饰器的原始动机之一是因为像`classmethod`和`staticmethod`这样的函数用于转换方法的原始定义，它们需要一个额外的行，在单独的语句中修改函数的原始定义。
- en: More generally speaking, every time we had to apply a transformation to a function,
    we had to call it with the `modifier` function, and then reassign it to the same
    name the function was originally defined with.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 更普遍地说，每次我们需要对一个函数应用一个转换时，我们必须使用`modifier`函数来调用它，然后将其重新赋值回原来定义该函数的同一名称。
- en: 'For instance, if we have a function called `original`, and then we have a function
    that changes the behavior of `original` on top of it, called `modifier`, we have
    to write something like the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个名为`original`的函数，然后我们有一个在它之上改变`original`行为的函数，称为`modifier`，我们必须编写如下内容：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice how we change the function and reassign it to the same name. This is
    confusing, error-prone (imagine that someone forgets to reassign the function,
    or does reassign it but not in the line immediately after the function definition
    but much farther away), and cumbersome. For this reason, some syntax support was
    added to the language.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何更改函数并将其重新赋值回同一名称的。这很令人困惑，容易出错（想象一下有人忘记重新赋值函数，或者虽然重新赋值了，但不是在函数定义后的下一行，而是在更远的地方），而且很麻烦。因此，语言增加了一些语法支持。
- en: 'The previous example could be rewritten like so:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子可以重写如下：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This means that decorators are just syntactic sugar for calling whatever is
    after the decorator as a first parameter of the decorator itself, and the result
    would be whatever the decorator returns.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着装饰器只是将装饰器之后的内容作为装饰器本身的第一个参数调用的语法糖，结果将是装饰器返回的内容。
- en: The syntax for decorators improves the readability significantly, because now
    the reader of that code can find the whole definition of the function in a single
    place. Keep in mind that manually modifying functions as before is still allowed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器的语法大大提高了代码的可读性，因为现在代码的读者可以在一个地方找到函数的整个定义。请记住，手动修改函数如以前一样仍然是允许的。
- en: In general, try to avoid re-assigning values to a function already designed
    without using the decorator syntax. Particularly, if the function gets reassigned
    to something else and this happens in a remote part of the code (far from where
    the function was originally defined), this will make your code harder to read.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，尽量避免在不使用装饰器语法的情况下重新分配已经设计好的函数的值。特别是，如果函数被重新分配为其他内容，并且这种情况发生在代码的远程部分（远离函数最初定义的地方），这将使你的代码更难以阅读。
- en: In line with the Python terminology, and our example, `modifier` is what we
    call the **decorator**, and `original` is the decorated function, often also called
    a **wrapped** object.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python术语和我们的示例，`modifier`是我们所说的**装饰器**，而`original`是被装饰的函数，通常也称为**包装**对象。
- en: While the functionality was originally thought of for methods and functions,
    the actual syntax allows any kind of object to be decorated, so we are going to
    explore decorators applied to functions, methods, generators, and classes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最初的功能是为方法和函数考虑的，但实际的语法允许任何类型的对象被装饰，因此我们将探讨应用于函数、方法、生成器和类的装饰器。
- en: One final note is that while the name decorator is correct (after all, the decorator
    is making changes, extending, or working on top of the wrapped function), it is
    not to be confused with the decorator design pattern.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点需要注意的是，虽然装饰器的名字是正确的（毕竟，装饰器正在对包装函数进行更改、扩展或在其之上工作），但它不应与装饰器设计模式混淆。
- en: Function decorators
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数装饰器
- en: Functions are probably the simplest representation of a Python object that can
    be decorated. We can use decorators on functions to apply all sorts of logic to
    them—we can validate parameters, check preconditions, change the behavior entirely,
    modify its signature, cache results (create a memoized version of the original
    function), and more.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可能是Python中可以装饰的最简单对象表示。我们可以使用装饰器在函数上应用各种逻辑——我们可以验证参数，检查先决条件，完全改变其行为，修改其签名，缓存结果（创建原始函数的缓存版本），等等。
- en: 'As an example, we will create a basic decorator that implements a `retry` mechanism,
    controlling a particular domain-level exception and retrying a certain number
    of times:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，我们将创建一个基本的装饰器，实现一个`retry`机制，控制特定的域级别异常，并尝试一定次数：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The use of `@wraps` can be ignored for now, as it will be covered in the *Effective
    decorators – avoiding common mistakes* section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 目前可以忽略`@wraps`的使用，因为它将在*有效的装饰器 - 避免常见错误*部分进行讲解。
- en: The use of `_` in the `for` loop means that the number is assigned to a variable
    we are not interested in at the moment, because it's not used inside the `for`
    loop (it's a common idiom in Python to name `_` values that are ignored).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中使用`_`表示该数字被分配给一个我们目前不感兴趣的变量，因为它在`for`循环内没有使用（在Python中，命名被忽略的`_`值是一个常见的习惯用法）。
- en: 'The `retry` decorator doesn''t take any parameters, so it can be easily applied
    to any function, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`retry`装饰器不接受任何参数，因此它可以很容易地应用于任何函数，如下所示：'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The definition of `@retry` on top of `run_operation` is just syntactic sugar
    that Python provides to execute `run_operation = retry(run_operation)`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在`run_operation`上定义`@retry`只是Python提供的语法糖，用于执行`run_operation = retry(run_operation)`。
- en: In this limited example, we can see how decorators can be used to create a generic
    `retry` operation that, under certain conditions (in this case, represented as
    exceptions that could be related to timeouts), will allow calling the decorated
    code multiple times.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个有限的示例中，我们可以看到装饰器如何被用来创建一个通用的`retry`操作，在特定条件下（在这种情况下，表示可能相关的超时异常），将允许多次调用被装饰的代码。
- en: Decorators for classes
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类装饰器
- en: Classes are also objects in Python (frankly, pretty much everything is an object
    in Python, and it's hard to find a counter-example; however, there are some technical
    nuances). That means the same considerations apply; they can also be passed by
    parameters, assigned to variables, asked some methods, or be transformed (decorated).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，类也是对象（坦白说，在Python中几乎一切都是对象，很难找到反例；然而，有一些技术上的细微差别）。这意味着相同的考虑也适用；它们也可以通过参数传递，分配给变量，调用某些方法，或者被转换（装饰）。
- en: Class decorators were introduced in PEP-3129, and they have very similar considerations
    to the function decorators we just explored. The only difference is that when
    writing the code for this kind of decorator, we have to take into consideration
    that we are receiving a class as a parameter of the wrapped method, not another
    function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 类装饰器是在PEP-3129中引入的，并且它们与我们已经探索过的函数装饰器有非常相似的考虑。唯一的区别是，在编写这种装饰器的代码时，我们必须考虑到我们正在接收一个类作为包装方法的参数，而不是另一个函数。
- en: We have seen how to use a class decorator when we saw the `dataclasses.dataclass`
    decorator in *Chapter 2*, *Pythonic Code*. In this chapter, we will learn how
    to write our own class decorators.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在“第2章”，“Pythonic代码”中看到`dataclasses.dataclass`装饰器时，我们看到了如何使用类装饰器。在本章中，我们将学习如何编写我们自己的类装饰器。
- en: Some practitioners might argue that decorating a class is something rather convoluted
    and that such a scenario might jeopardize readability because we would be declaring
    some attributes and methods in the class, but behind the scenes, the decorator
    might be applying changes that would render a completely different class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一些从业者可能会认为装饰类是一种相当复杂的事情，并且这种场景可能会危及可读性，因为我们在类中声明了一些属性和方法，但幕后，装饰器可能正在应用一些会使其成为完全不同类的更改。
- en: 'This assessment is true, but only if this technique is heavily abused. Objectively,
    this is no different from decorating functions; after all, classes are just another
    type of object in the Python ecosystem, as functions are. We will review the pros
    and cons of this issue with decorators in the section titled *Decorators and separation
    of concerns*, but for now, we''ll explore the benefits of decorators that apply
    particularly to classes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种评估是正确的，但只有当这种技术被过度使用时。客观上，这与装饰函数没有区别；毕竟，类只是Python生态系统中的另一种类型对象，就像函数一样。我们将在标题为“装饰器和关注点分离”的章节中回顾使用装饰器的利弊，但现在，我们将探讨装饰器对类特别有益的益处：
- en: All the benefits of reusing code and the DRY principle. A valid case of a class
    decorator would be to enforce that multiple classes conform to a certain interface
    or criteria (by writing these checks only once in a decorator that is going to
    be applied to many classes).
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码重用和DRY原则的所有好处。一个有效的类装饰器用例是强制多个类遵守某个接口或标准（通过在将被应用于许多类的装饰器中只写一次这些检查）。
- en: We could create smaller or simpler classes that will be enhanced later on by
    decorators.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建更小或更简单的类，这些类可以通过装饰器在以后进行增强。
- en: The transformation logic we need to apply to a certain class will be much easier
    to maintain if we use a decorator, as opposed to more complicated (and often rightfully
    discouraged) approaches such as meta-classes.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用装饰器而不是更复杂（并且通常被正确劝阻）的方法，如元类，那么我们需要应用于特定类的转换逻辑将更容易维护。
- en: Among all the possible applications of decorators, we will explore a simple
    example to show the sorts of things they can be useful for. Keep in mind that
    this is not the only application type for class decorators, and also that the
    code I show you can have many other solutions as well, all with their pros and
    cons, but I've chosen decorators for the purpose of illustrating their usefulness.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有可能的装饰器应用中，我们将探索一个简单的例子来展示它们可能有用的情况。请记住，这并不是类装饰器的唯一应用类型，而且我向你展示的代码也可以有其他许多解决方案，所有这些解决方案都有其优缺点，但我选择装饰器是为了说明它们的有用性。
- en: Recalling our event systems for the monitoring platform, we now need to transform
    the data for each event and send it to an external system. However, each type
    of event might have its own particularities when selecting how to send its data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们的监控平台的事件系统，我们现在需要转换每个事件的 数据并将其发送到外部系统。然而，每种类型的事件在选择如何发送其数据时可能都有自己的特性。
- en: 'In particular, the `event` for a login might contain sensitive information
    such as credentials that we want to hide. Other fields such as `timestamp` might
    also require some transformations since we want to show them in a particular format.
    A first attempt at complying with these requirements would be as simple as having
    a class that maps to each particular event and knows how to serialize it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，登录事件的`event`可能包含敏感信息，例如我们想要隐藏的凭证。其他字段，如`timestamp`，也可能需要一些转换，因为我们希望以特定的格式显示它们。满足这些要求的一个初步尝试就是拥有一个映射到每个特定事件并知道如何序列化它的类：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we declare a class that is going to map directly with the login event,
    containing the logic for it—hide the `password` field, and format the `timestamp`
    as required.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明一个类，它将直接与登录事件映射，包含其逻辑——隐藏`password`字段，并按要求格式化`timestamp`。
- en: 'While this works and might look like a good option to start with, as time passes
    and we want to extend our system, we will find some issues:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可行，并且可能看起来是一个好的起点，但随着时间的推移，当我们想要扩展我们的系统时，我们会发现一些问题：
- en: '**Too many classes**: As the number of events grows, the number of serialization
    classes will grow in the same order of magnitude, because they are mapped one
    to one.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类太多**：随着事件数量的增长，序列化类的数量将以相同的数量级增长，因为它们是一对一映射的。'
- en: '**The solution is not flexible enough**: If we need to reuse parts of the components
    (for example, we need to hide the password in another type of event that also
    has it), we will have to extract this into a function, but also call it repeatedly
    from multiple classes, meaning that we are not reusing that much code after all.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案不够灵活**：如果我们需要重用组件的部分（例如，我们需要在另一个类型的事件中隐藏密码，该事件也有密码），我们必须将其提取到一个函数中，但还需要从多个类中重复调用它，这意味着我们最终并没有重用很多代码。'
- en: '**Boilerplate**: The `serialize()` method will have to be present in all event
    classes, calling the same code. Although we can extract this into another class (creating
    a mixin), it does not seem like a good use of inheritance.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板代码**：`serialize()`方法将必须存在于所有事件类中，调用相同的代码。虽然我们可以将其提取到另一个类中（创建一个混入类），但这似乎并不是继承的好用法。'
- en: An alternative solution is to dynamically construct an object that, given a
    set of filters (transformation functions) and an event instance, can serialize
    it by applying the filters to its fields. We then only need to define the functions
    to transform each type of field, and the serializer is created by composing many
    of these functions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是动态构建一个对象，给定一组过滤器（转换函数）和事件实例，可以通过应用过滤器到其字段来序列化它。然后我们只需要定义转换每种字段类型的函数，序列化器通过组合这些函数中的许多来创建。
- en: 'Once we have this object, we can decorate the class in order to add the `serialize()`
    method, which will just call these `Serialization` objects with itself:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个对象，我们就可以装饰类来添加`serialize()`方法，这个方法将只调用这些`Serialization`对象本身：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice how the decorator makes it easier for the user to know how each field
    is going to be treated without having to look into the code of another class.
    Just by reading the arguments passed to the class decorator, we know that the
    `username` and IP address will be left unmodified, the `password` will be hidden,
    and the `timestamp` will be formatted.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意装饰器如何让用户更容易知道每个字段将被如何处理，而无需查看另一个类的代码。只需阅读传递给类装饰器的参数，我们就可以知道`username`和IP地址将保持不变，`password`将被隐藏，而`timestamp`将被格式化。
- en: Now, the code of the class does not need the `serialize()` method defined, nor
    does it need to extend from a mixin that implements it, since the decorator will
    add it. This is probably the only part that justifies the creation of the class
    decorator because otherwise, the `Serialization` object could have been a class
    attribute of `LoginEvent`, but the fact that it is altering the class by adding
    a new method to it makes it impossible.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，类的代码不需要定义`serialize()`方法，也不需要从实现它的混入类扩展，因为装饰器会添加它。这可能是唯一可以证明创建类装饰器合理性的部分，因为否则`Serialization`对象可以是`LoginEvent`的类属性，但它是通过向其添加新方法来改变类的，这使得它变得不可能。
- en: Other types of decorator
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他类型的装饰器
- en: Now that we know what the `@` syntax for decorators means, we can conclude that
    it isn't just functions, methods, or classes that can be decorated; actually,
    anything that can be defined, such as generators, coroutines, and even objects
    that have already been decorated, can be decorated, meaning that decorators can
    be stacked.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了装饰器的`@`语法意味着什么，我们可以得出结论，不仅仅是函数、方法或类可以被装饰；实际上，任何可以被定义的东西，比如生成器、协程，甚至已经装饰过的对象，都可以被装饰，这意味着装饰器可以堆叠。
- en: The previous example showed how decorators can be chained. We first defined
    the class, and then applied `@dataclass` to it, which converted it into a data
    class, acting as a container for those attributes. After that, `@Serialization`
    will apply the logic to that class, resulting in a new class with the new `serialize()`
    method added to it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子展示了装饰器可以如何链式使用。我们首先定义了类，然后应用`@dataclass`到它上面，这将其转换成了一个数据类，作为一个容器的属性。之后，`@Serialization`将对那个类应用逻辑，结果产生一个新的类，其中添加了新的`serialize()`方法。
- en: Now that we know the fundamentals of decorators, and how to write them, we can
    move on to more complex examples. In the next sections, we'll see how to have
    more flexible decorators with parameters, and different ways of implementing them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了装饰器的基础知识以及如何编写它们，我们可以继续到更复杂的例子。在接下来的几节中，我们将看到如何拥有具有参数的更灵活的装饰器以及实现它们的不同方法。
- en: More advanced decorators
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更高级的装饰器
- en: 'With the introduction we''ve just had, we now know the basics of decorators:
    what they are, and their syntax and semantics.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们刚刚的介绍，我们现在已经了解了装饰器的基础知识：它们是什么，以及它们的语法和语义。
- en: Now we're interested in more advanced uses of decorators that will help us structure
    our code more cleanly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们感兴趣的是更高级的装饰器用法，这将帮助我们更干净地组织代码。
- en: We'll see that we can use decorators to separate concerns into smaller functions,
    and reuse code, but in order to so do effectively, we'd like to parametrize the
    decorators (otherwise, we'd end up repeating code). For this, we'll explore different
    options on how to pass arguments to decorators.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到我们可以使用装饰器将关注点分离成更小的函数，并重用代码，但为了有效地这样做，我们希望对装饰器进行参数化（否则，我们最终会重复代码）。为此，我们将探讨如何将参数传递给装饰器的不同选项。
- en: After that, we can see some examples of good uses of decorators.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以看到一些装饰器良好用法的例子。
- en: Passing arguments to decorators
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将参数传递给装饰器
- en: At this point, we already regard decorators as a powerful tool in Python. However,
    they could be even more powerful if we could just pass parameters to them so that
    their logic is abstracted even more.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将装饰器视为Python中的一个强大工具。然而，如果我们能够向它们传递参数，以便它们的逻辑被进一步抽象化，它们可能会更加强大。
- en: There are several ways of implementing decorators that can take arguments, but
    we will go over the most common ones. The first one is to create decorators as
    nested functions with a new level of indirection, making everything in the decorator
    fall one level deeper. The second approach is to use a class for the decorator
    (that is, to implement a callable object that still acts as a decorator).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种实现可以接受参数的装饰器的方法，但我们将介绍最常见的一些。第一种方法是将装饰器作为嵌套函数创建，增加一个间接层，使得装饰器中的所有内容都深入一个层次。第二种方法是使用一个类作为装饰器（即实现一个仍然充当装饰器的可调用对象）。
- en: In general, the second approach favors readability more, because it is easier
    to think in terms of an object than three or more nested functions working with
    closures. However, for completeness, we will explore both, and you can decide
    what is best for the problem at hand.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，第二种方法在可读性方面更有优势，因为相对于三个或更多使用闭包工作的嵌套函数，更容易从对象的角度思考。然而，为了完整性，我们将探讨两种方法，你可以决定哪种最适合当前的问题。
- en: Decorators with nested functions
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带嵌套函数的装饰器
- en: Roughly speaking, the general idea of a decorator is to create a function that
    returns another function (in functional programming, functions that take other
    functions as parameters are called higher-order functions, and it refers to the
    same concept we're talking about here). The internal function defined in the body
    of the decorator is going to be the one being called.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 大体来说，装饰器的一般思想是创建一个返回另一个函数的函数（在函数式编程中，接受其他函数作为参数的函数被称为高阶函数，这指的是我们在这里讨论的相同概念）。装饰器体内定义的内部函数将是将被调用的函数。
- en: Now, if we wish to pass parameters to it, we then need another level of indirection.
    The first function will take the parameters, and inside that function, we will
    define a new one, which will be the decorator, which in turn will define yet another
    new function, namely the one to be returned as a result of the decoration process.
    This means that we will have at least three levels of nested functions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们希望向它传递参数，我们则需要另一个间接层。第一个函数将接受参数，在该函数内部，我们将定义一个新的函数，这个新的函数将是装饰器，它反过来将定义另一个新的函数，即装饰过程的结果要返回的函数。这意味着我们将至少有三个嵌套函数的层次。
- en: Don't worry if this didn't seem clear so far. After reviewing the examples that
    are about to come, everything will become clear.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果到目前为止这还不清楚，请不要担心。在查看即将到来的示例之后，一切都会变得清晰。
- en: One of the first examples we saw of decorators implemented the retry functionality
    over some functions. This is a good idea, except it has a problem; our implementation
    did not allow us to specify the number of retries, and instead, this was a fixed
    number inside the decorator.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的第一批装饰器示例之一是在某些函数上实现了重试功能。这是一个好主意，但有一个问题；我们的实现不允许我们指定重试次数，而是在装饰器内部有一个固定的数字。
- en: Now, we want to be able to indicate how many retries each instance is going
    to have, and perhaps we could even add a default value to this parameter. In order
    to do this, we need another level of nested functions—first for the parameters,
    and then for the decorator itself.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望能够表明每个实例将要尝试的次数，也许我们甚至可以为此参数添加一个默认值。为了做到这一点，我们需要另一层嵌套函数——首先是参数，然后是装饰器本身。
- en: 'This is because we are now going to have something in the form of the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们现在将会有以下形式的内容：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And that has to return a decorator because the `@` syntax will apply the result
    of that computation to the object to be decorated. Semantically, it would translate
    to something like the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 而这必须返回一个装饰器，因为`@`语法将计算结果应用于要装饰的对象。从语义上讲，它将翻译成以下类似的内容：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Besides the number of desired retries, we can also indicate the types of exceptions
    we wish to control. The new version of the code supporting the new requirements
    might look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了想要的尝试次数之外，我们还可以指出我们希望控制的异常类型。支持新要求的代码的新版本可能看起来像这样：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here are some examples of how this decorator can be applied to functions, showing
    the different options it accepts:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些如何将这个装饰器应用于函数的示例，展示了它接受的不同选项：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using nested functions to implement decorators is probably the first thing we'd
    think of. This works well for most cases, but as you might have noticed, the indentation
    keeps adding up, for every new function we create, so soon it might lead to too
    many nested functions. Also, functions are stateless, so decorators written in
    this way won't necessarily hold internal data, as objects can.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用嵌套函数来实现装饰器可能是我们首先想到的事情。这在大多数情况下都很好用，但正如你可能已经注意到的，每创建一个新的函数，缩进就会增加，所以很快可能会导致嵌套函数过多。此外，函数是无状态的，所以以这种方式编写的装饰器不一定能保留内部数据，就像对象可以做到的那样。
- en: There's a different way of implementing decorators, which instead of using nested
    functions uses objects, as we explore in the next section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 实现装饰器还有另一种方式，它不是使用嵌套函数，而是使用对象，我们将在下一节中探讨。
- en: Decorator objects
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 装饰器对象
- en: The previous example requires three levels of nested functions. The first is
    going to be a function that receives the parameters of the decorator we want to
    use. Inside this function, the rest of the functions are closures that use these
    parameters, along with the logic of the decorator.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子需要三个级别的嵌套函数。第一个是一个接收我们想要使用的装饰器参数的函数。在这个函数内部，其余的函数都是闭包，它们使用这些参数，以及装饰器的逻辑。
- en: A cleaner implementation of this would be to use a class to define the decorator.
    In this case, we can pass the parameters in the `__init__` method, and then implement
    the logic of the decorator on the magic method named `__call__`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更干净的实现方法是使用类来定义装饰器。在这种情况下，我们可以在`__init__`方法中传递参数，然后在实际的`__call__`魔法方法上实现装饰器的逻辑。
- en: 'The code for the decorator will look like it does in the following example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器的代码看起来就像以下示例中的那样：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And this decorator can be applied pretty much like the previous one, like so:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器可以像之前的那个一样应用，如下所示：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It is important to note how the Python syntax takes effect here. First, we create
    the object, so before the `@` operation is applied, the object is created with
    its parameters passed to it. This will create a new object and initialize it with
    these parameters, as defined in the `init` method. After this, the `@` operation
    is invoked, so this object will wrap the function named `run_with_custom_reries_limit`,
    meaning that it will be passed to the `call` magic method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意Python语法在这里是如何起作用的。首先，我们创建对象，因此在`@`操作应用之前，对象就已经被创建，并且将参数传递给它。这将创建一个新的对象，并使用`init`方法中的这些参数对其进行初始化。之后，调用`@`操作，这意味着这个对象将包装名为`run_with_custom_retries_limit`的函数，意味着它将被传递给`call`魔法方法。
- en: Inside this call magic method, we defined the logic of the decorator as we normally
    do—we wrap the original function, returning a new one with the logic we want instead.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个调用魔法方法中，我们像平常一样定义了装饰器的逻辑——我们包装了原始函数，返回了一个具有我们想要逻辑的新函数。
- en: Decorators with default values
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有默认值的装饰器
- en: In the previous example, we saw a decorator that takes parameters, but those
    arguments have default values. The way the previous decorators were written will
    make sure that they work as long as users don't forget the parentheses to make
    the function call when using the decorator.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们看到了一个接受参数的装饰器，但那些参数有默认值。之前装饰器的写法确保了只要用户在使用装饰器时没有忘记在函数调用时使用括号，它们就能正常工作。
- en: 'For example, if we only wanted the default values, this would work:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们只想使用默认值，这将有效：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But this wouldn''t:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不会：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You might argue whether this is necessary and accept (perhaps with proper documentation)
    that the first example is how the decorator is meant to be used, and the second
    one is incorrect. And that would be fine, but it requires paying close attention,
    or runtime errors will occur.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会争论这是否必要，并接受（可能需要适当的文档）第一个例子是装饰器预期使用的方式，第二个例子是错误的。这将是可行的，但需要密切注意，否则将发生运行时错误。
- en: Of course, if the decorator takes parameters that don't have default values,
    then the second syntax doesn't make sense, and there's only one possibility, which
    might make things simpler.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果装饰器接受没有默认值的参数，那么第二种语法就没有意义，只有一个可能性，这可能会使事情变得更简单。
- en: Alternatively, you can make the decorator work with both syntaxes. As you might
    have guessed, this takes extra effort, and as always you should balance whether
    it's worth it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使装饰器同时支持这两种语法。正如你可能猜到的，这需要额外的努力，而且像往常一样，你应该权衡这是否值得。
- en: 'Let''s illustrate this with a simple example that uses a decorator with parameters
    to inject arguments into a function. We define a function that takes two parameters,
    and a decorator that does the same, and the idea is to call the function without
    arguments and let it work with the parameters passed by the decorator:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来说明这一点，这个例子使用了一个带参数的装饰器来将参数注入到函数中。我们定义了一个接受两个参数的函数和一个执行相同操作的装饰器，我们的想法是在不带参数的情况下调用函数，让它使用装饰器传递的参数：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: But of course, we define default values for the arguments of the decorator,
    so we can call it without values. And we'd like to also call it without the parentheses.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们为装饰器的参数定义了默认值，这样我们就可以不带值调用它。我们也希望不带括号调用它。
- en: 'The simplest and most naïve way of writing it would be separating both cases
    with a conditional:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单且最直接的方法是使用条件语句来区分这两种情况：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note something important about the signature of the decorator: the parameters
    are keyword-only. This simplifies the definition of the decorator a lot because
    we can assume the function is `None` when it''s being called without arguments
    (otherwise, if we were to pass the values by position, the first of the parameters
    we passed would be confused with the function). If we wanted to be more careful,
    instead of using `None` (or any sentinel value), we could inspect the parameter
    type, assert a function object of the type we expect, and then shift the parameters
    accordingly, but that would make the decorator much more complicated.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意关于装饰器签名的一个重要事项：参数只能是关键字参数。这大大简化了装饰器的定义，因为我们可以在没有参数调用函数时假设函数是`None`（否则，如果我们按位置传递值，我们传递的第一个参数会被误认为是函数）。如果我们想更加小心，而不是使用`None`（或任何哨兵值），我们可以检查参数类型，断言我们期望的函数对象类型，然后相应地调整参数，但这会使装饰器变得更加复杂。
- en: 'Another alternative would be to abstract part of the wrapped decorator, and
    then apply a partial application of the function (using `functools.partial`).
    To explain this better, let''s take an intermediate state, and use a `lambda`
    function that shows how the parameters to the decorator are applied, and how the
    decorator''s arguments are "shifted":'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个替代方案是将包装装饰器的一部分抽象出来，然后对函数进行部分应用（使用`functools.partial`）。为了更好地解释这一点，让我们考虑一个中间状态，并使用一个`lambda`函数来展示装饰器的参数是如何应用的，以及装饰器的参数是如何“移动”的：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is analogous to the previous example, in the sense that we have the definition
    of the `wrapped` function (how it's being decorated). Then, if no function is
    provided, we return a new function that takes a function as a parameter (`f`)
    and returns the decorator with that function applied and the rest of the parameters
    bound. Then, in the second recursive call, the function will exist, and the regular
    decorator function (wrapped) will be returned instead.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这与前面的例子类似，从意义上讲，我们有`wrapped`函数的定义（它是如何被装饰的）。然后，如果没有提供函数，我们返回一个新的函数，该函数接受一个函数作为参数（`f`），并返回应用了该函数的装饰器以及其余绑定参数。然后，在第二次递归调用中，函数将存在，并将返回常规的装饰器函数（wrapped）。
- en: 'You can achieve the same result by changing the `lambda` definition for a partial
    application of the function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过更改函数部分应用的`lambda`定义来达到相同的结果：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If this is too complex for our use cases, we can always decide to make the parameters
    of our decorators take mandatory values.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对我们的用例来说太复杂，我们总是可以决定让我们的装饰器参数接受强制值。
- en: In any case, it's probably a good idea to define the parameters of the decorators
    to be keyword-only (regardless of whether they have default values or not). This
    is because, in general, when applying a decorator, there isn't that much context
    about what each value is doing, and using positional values might not yield a
    very meaningful expression, so it's better to be more expressive and pass the
    name of the parameter along with the value.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，定义装饰器的参数为关键字参数（无论是否有默认值）可能是一个好主意。这是因为，通常在应用装饰器时，关于每个值的作用的上下文并不多，使用位置值可能不会产生非常有意义的表达式，因此最好更具有表达性，并将参数的名称与值一起传递。
- en: If you're defining decorators with arguments, prefer to make them keyword-only.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用参数定义装饰器，请优先使用关键字参数。
- en: Similarly, if our decorator does not intend to take parameters, and we want
    to be explicit about it, we can use the syntax we learned in *Chapter 2*, *Pythonic
    Code*, to define the function that our decorator receives as a single positional-only
    parameter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们的装饰器不打算接受参数，并且我们想明确这一点，我们可以使用我们在*第二章*中学到的语法来定义我们的装饰器接收的单个位置参数。
- en: 'For our first example, the syntax would be:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个例子，语法将是：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: But keep in mind, this is not strictly recommended, just a way to make it explicit
    to you how the decorator is supposed to be invoked.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，这并不是严格推荐的，只是让您更明确地了解装饰器应该如何被调用。
- en: Decorators for coroutines
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协程装饰器
- en: As explained in the introduction, since pretty much everything in Python is
    an object, then pretty much anything can be decorated, and this includes coroutines
    as well.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，由于Python中几乎所有东西都是一个对象，因此几乎所有东西都可以被装饰，这包括协程。
- en: However, there's a caveat here, and that is, as explained in previous chapters,
    asynchronous programming in Python introduces some differences in syntax. Therefore,
    these syntax differences will also be carried to the decorator.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个注意事项，正如前几章所解释的，Python中的异步编程引入了一些语法上的差异。因此，这些语法差异也将传递到装饰器中。
- en: Simply speaking, if we were to write a decorator for a coroutine, we could simply
    adapt to the new syntax (remember to await the wrapped coroutine and define the
    wrapped object as a coroutine itself, meaning the internal function will likely
    have to use '`async def`' instead of just '`def`').
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果我们为协程编写装饰器，我们可以简单地适应新的语法（记得等待包装的协程并将包装对象本身定义为协程，这意味着内部函数可能需要使用 '`async
    def`' 而不是仅仅使用 '`def`'）。
- en: The problem is if we want to have a decorator widely applicable to functions
    and coroutines. In most cases, creating two decorators would be the simplest (and
    perhaps best) approach, but if we wanted to expose a simpler interface for our
    users (by having fewer objects to remember), we could create a thin wrapper, acting
    like a dispatcher to two internal (not exposed) decorators. This would be like
    creating a *facade* but with a decorator.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于如果我们想要一个广泛适用于函数和协程的装饰器。在大多数情况下，创建两个装饰器可能是最简单（也许是最好的）的方法，但如果我们想为用户提供一个更简单的接口（通过让用户记住更少的对象），我们可以创建一个薄的包装器，充当两个内部（未公开）装饰器的调度器。这就像创建一个*外观*，但使用装饰器。
- en: 'There is no general rule about how hard it would be to create a decorator for
    functions and coroutines, because that depends on the logic we want to put in
    the decorator itself. For example, in the code below there is a decorator that
    changes the parameters of the functions it receives, and this will work both for
    a regular function or a coroutine:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关于为函数和协程创建装饰器的难度，没有一般规则，因为这取决于我们想在装饰器中放入的逻辑。例如，下面的代码中有一个装饰器，它会改变它接收到的函数的参数，并且这将对常规函数或协程都有效：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It's important to make one distinction about the coroutine though. The decorator
    will receive the coroutine as its `callable` argument, and then invoke it with
    the parameters. This creates the coroutine object (the task that will go to the
    event loop), but it doesn't await it, meaning that whoever calls `await coro()`
    will end up awaiting the coroutine resulting from what the decorator wrapped.
    This means, in simple cases like this one, we don't need to replace the coroutine
    with another coroutine (although this is generally recommended).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关于协程，我们需要做出一个重要的区分。装饰器将接收协程作为其`callable`参数，然后使用这些参数调用它。这创建了协程对象（将进入事件循环的任务），但它不会等待它，这意味着调用`await
    coro()`的人最终会等待装饰器包装的结果。这意味着，在像这种情况这样的简单情况下，我们不需要用另一个协程替换协程（尽管这通常是推荐的）。
- en: But again, this depends on what we need to do. If we need a `timing` function,
    then we have to wait for the function or coroutine to complete to measure the
    time, and for this we'll have to call `await` on it, which means that the wrapper
    object will in turn have to be a coroutine (but not the main decorator, though).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 但同样，这取决于我们想要做什么。如果我们需要一个`计时`函数，那么我们必须等待函数或协程完成以测量时间，为此我们必须在它上面调用`await`，这意味着包装器对象反过来必须是一个协程（但不是主要的装饰器）。
- en: 'The code below illustrates this example using a decorator that selectively
    decides how to wrap the caller function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例使用一个装饰器来选择性地决定如何包装调用函数来说明这一点：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The second wrapper is required for coroutines. If we didn't have it, then the
    code would have two problems. First, the call to `callable` (without `await`)
    would not actually wait for the operation to complete, meaning the results would
    be incorrect. And even worse, the value for the `result` key on the dictionary
    wouldn't be the result itself, but the coroutine created. As a consequence, the
    response would be a dictionary, and whoever tries to call that will try to await
    a dictionary, which will cause an error.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个包装器对于协程是必需的。如果我们没有它，那么代码会有两个问题。首先，对`callable`的调用（没有`await`）实际上不会等待操作完成，这意味着结果将是错误的。更糟糕的是，字典中`result`键的值不会是结果本身，而是创建的协程。因此，响应将是一个字典，任何尝试调用它的人都会尝试等待一个字典，这将导致错误。
- en: As a general rule, you should replace a decorated object with another one of
    the same kind, that is, a function with a function, and a coroutine with another
    coroutine.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条一般规则，你应该用一个同类的另一个对象来替换装饰过的对象，也就是说，用一个函数替换另一个函数，用一个协程替换另一个协程。
- en: We're still due to study one last enhancement that was recently added to Python,
    and it lifts some of the restrictions its syntax had.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该研究最近添加到Python中的一个最后增强功能，它消除了其语法的一些限制。
- en: Extended syntax for decorators
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器的扩展语法
- en: Python 3.9 introduced a novelty for decorators, with PEP-614 ([https://www.python.org/dev/peps/pep-0614/](https://www.python.org/dev/peps/pep-0614/)),
    because a more general grammar is allowed. Before this enhancement, the syntax
    for invoking decorators (after the `@`) was restricted to very limited expressions,
    and not every single Python expression was allowed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.9为装饰器引入了一个新特性，即PEP-614 ([https://www.python.org/dev/peps/pep-0614/](https://www.python.org/dev/peps/pep-0614/)），因为允许了更通用的语法。在此增强之前，调用装饰器（在`@`之后）的语法被限制在非常有限的表达式上，并不是每个Python表达式都被允许。
- en: With these restrictions lifted, we can now write more complex expressions and
    use them in our decorators, if we think that can save us some lines of code (but
    as always, be careful not to over-complicate and get a more compact but much harder-to-read
    line).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 解除这些限制后，我们现在可以编写更复杂的表达式，并在我们的装饰器中使用它们，如果我们认为这样可以节省一些代码行（但就像往常一样，要小心不要过度复杂化，得到一个更紧凑但难以阅读的行）。
- en: 'As an example, we can simplify some of the nested functions we typically have
    for a simple decorator that logs a function call along with its parameters. Here
    (and for illustration purposes only), I replaced the nested function definitions,
    typical of decorators, with two `lambda` expressions:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以简化一些通常用于简单装饰器（记录函数调用及其参数）的嵌套函数。在这里（仅用于说明目的），我将装饰器中典型的嵌套函数定义替换为两个`lambda`表达式：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The PEP document cites some examples for when this feature can be useful (like
    simplifying no-op functions to evaluate other expressions, or avoiding the use
    of the eval function).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: PEP文档引用了一些示例，说明此功能何时可能有用（例如，简化无操作函数以评估其他表达式，或避免使用`eval`函数）。
- en: 'The recommendation of this book for this feature is consistent with all the
    cases in which a more compact statement can be achieved: write the more compact
    version of the code as long as it doesn''t hurt readability. If the decorator
    expression becomes hard to read, prefer the more verbose but simpler alternative
    of writing two or more functions.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 本书对此功能的推荐与所有可以通过更紧凑的语句实现的情况一致：只要不影响可读性，就编写更紧凑的代码版本。如果装饰器表达式难以阅读，则优先选择更冗长但更简单的替代方案，即编写两个或更多函数。
- en: Good uses for decorators
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器的良好用途
- en: In this section, we will take a look at some common patterns that make good
    use of decorators. These are common situations for when decorators are a good
    choice.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些常见的模式，这些模式很好地使用了装饰器。这些是装饰器是一个好选择时的常见情况。
- en: 'From all the countless applications decorators can be used for, we will enumerate
    a few, the most common or relevant ones:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从装饰器可以用于的无数应用中，我们将列举一些，其中最常见或相关的：
- en: '**Transforming parameters**: Changing the signature of a function to expose
    a nicer API, while encapsulating details on how the parameters are treated and
    transformed underneath. We must be careful with this use of decorators, because
    it''s only a good trait when it''s intentional. That means, if we are explicitly
    using decorators to provide a good signature for functions that had a rather convoluted
    one, then it''s a great way of achieving cleaner code by means of decorators.
    If, on the other hand, the signature of a function changed inadvertently because
    of a decorator, then that''s something we would want to avoid (and we''ll discuss
    how toward the end of the chapter).'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换参数**：更改函数的签名以提供更友好的API，同时在下面封装如何处理和转换参数的细节。我们必须小心使用装饰器的这种用途，因为它只有在故意使用时才是好的特性。这意味着，如果我们明确使用装饰器为具有相当复杂签名的函数提供良好的签名，那么通过装饰器实现更干净的代码是一种很好的方法。另一方面，如果函数的签名由于装饰器而意外更改，那么这是我们想要避免的（我们将在本章末尾讨论如何避免）。'
- en: '**Tracing code**: Logging the execution of a function with its parameters.
    You might be familiar with multiple libraries that provide tracing capabilities,
    and often expose such functionality as decorators to add to our functions. This
    is a nice abstraction, and a good interface to provide, as a way of integrating
    the code with external parties without too much disruption. In addition, it''s
    a great source of inspiration, so we can write our own logging or tracing functionality
    as decorators.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪代码**：记录带有其参数的函数执行。你可能熟悉提供跟踪功能的多个库，并且通常将这些功能作为装饰器暴露出来，以便添加到我们的函数中。这是一个很好的抽象，也是一个很好的接口，可以作为将代码与外部各方集成而不会造成太大干扰的方式。此外，它也是一个很好的灵感来源，因此我们可以编写自己的日志或跟踪功能作为装饰器。'
- en: '**Validating parameters**: Decorators can be used to validate parameter types
    (against expected values or their annotations, for example) in a transparent way.
    With the use of decorators, we could enforce preconditions for our abstractions,
    following the ideas of designing by contract.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证参数**：装饰器可以以透明的方式验证参数类型（例如，与预期值或其注释进行比较）。使用装饰器，我们可以为我们的抽象强制执行先决条件，遵循设计合同的思路。'
- en: '**Implementing retry operations**: In a similar way to the example we''ve explored
    in the previous section.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现重试操作**：与我们在上一节中探讨的示例类似。'
- en: '**Simplifying classes by moving some (repetitive) logic into decorators**:
    This is related to the DRY principle, which we''ll revisit toward the end of the
    chapter.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过将一些（重复的）逻辑移动到装饰器中来简化类**：这与DRY原则相关，我们将在本章末尾重新回顾。'
- en: In the following sections, I'll discuss some of these topics in more detail.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我将更详细地讨论这些主题。
- en: Adapting function signatures
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配函数签名
- en: In object-oriented design, sometimes there's the case of having objects with
    different interfaces that need to interact. A solution to this problem is the
    adapter design pattern, which we shall discuss in *Chapter 7*, *Generators, Iterators,
    and Asynchronous Prpgramming*, when we review some of the main design patterns.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象设计中，有时存在具有不同接口的对象需要交互的情况。解决这个问题的一个方案是适配器设计模式，我们将在第7章“生成器、迭代器和异步编程”中讨论这个模式，当我们回顾一些主要设计模式时。
- en: The topic of this section is, however, similar, in the sense that sometimes
    we need to adapt not objects, but function signatures.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本节的主题在某种程度上是相似的，即有时我们需要适应的不是对象，而是函数签名。
- en: Imagine a scenario in which you're working with legacy code, and there's a module
    that contains lots of functions defined with a complex signature (lots of parameters,
    boilerplate, etc.). It would be nice to have a cleaner interface to interact with
    these definitions but changing lots of functions implies a major refactor.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这样一个场景：你正在处理遗留代码，并且有一个包含大量使用复杂签名（许多参数、样板代码等）定义的函数的模块。有一个更干净的接口来与这些定义交互会很不错，但改变许多函数意味着需要进行大规模重构。
- en: We can use decorators to keep the differences in the changes to a minimum.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用装饰器来将更改的差异降到最低。
- en: Sometimes we can use decorators as an adapter between our code and a framework
    we're using, if, for example, that framework has the aforementioned considerations.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可以使用装饰器作为我们代码和使用的框架之间的适配器，如果，例如，该框架有上述考虑。
- en: 'Imagine the case of a framework that expects to call functions defined by us,
    maintaining a certain interface:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这样一个框架，它期望调用我们定义的函数，保持一定的接口：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, we have that signature everywhere, and decide that it's better for us to
    create an abstraction from all those parameters that encapsulates them and exposes
    the behavior we need in our application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们到处都有这个签名，并决定最好从所有这些参数中创建一个抽象，它封装了它们，并暴露了我们在应用程序中需要的操作。
- en: 'So now we have lots of functions whose first line repeats the boilerplate of
    creating the same object again and again, and then the rest of the function only
    interacts with our domain object:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们有很多函数，它们的第一行重复创建相同的对象，而函数的其余部分只与我们的域对象交互：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, we could have a decorator changing the signature of the function,
    so that we can write our functions assuming the `helper` object is passed directly.
    In this case, the task of the decorator would be to intercept the original parameters,
    create the domain object, and then pass the `helper` object to our function. We
    then define our functions assuming we only receive the object we need, already
    initialized.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以有一个改变函数签名的装饰器，这样我们就可以假设直接传递`helper`对象来编写我们的函数。在这种情况下，装饰器的任务将是拦截原始参数，创建域对象，然后将`helper`对象传递给我们的函数。然后我们定义我们的函数，假设我们只接收我们需要的对象，并且已经初始化。
- en: 'Namely, we would like to write our code in this form:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们希望以这种形式编写我们的代码：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This works the other way around too, for example, if the legacy code we have
    is the one taking too many parameters, and we're always deconstructing an object
    that's already created, because refactoring the legacy code would be risky, then
    we can do that with a decorator as an intermediate layer.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以反过来，例如，如果我们有的遗留代码需要太多参数，而我们总是解构已经创建的对象，因为重构遗留代码会有风险，那么我们可以通过装饰器作为中间层来实现这一点。
- en: The idea is that this use of decorators can help you write functions with simpler,
    more compact signatures.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用装饰器的想法可以帮助你编写具有更简单、更紧凑签名的函数。
- en: Validating parameters
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数验证
- en: We have mentioned before that decorators can be used to validate parameters
    (and even enforce some preconditions or postconditions under the idea of **Design
    by Contract** (**DbC**)), so from this, you probably have got the idea that it
    is somewhat common to use decorators when dealing with or manipulating parameters.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，装饰器可以用来验证参数（甚至在“设计由合同”**DbC**）的概念下强制某些先决条件或后置条件），所以从这个角度来看，你可能已经意识到在处理或操作参数时使用装饰器是相当常见的。
- en: In particular, there are some cases where we find ourselves repeatedly creating
    similar objects or applying similar transformations that we would wish to abstract
    away. Most of the time, we can achieve this by simply using a decorator.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，有些情况下，我们会发现自己反复创建相似的对象或应用相似的转换，而我们希望将这些抽象出来。大多数时候，我们可以通过简单地使用装饰器来实现这一点。
- en: Tracing code
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪代码
- en: 'When talking about **tracing** in this section, we will refer to something
    more general that has to do with dealing with the execution of a function that
    we wish to monitor. This could refer to scenarios in which we want to:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中谈到**跟踪**时，我们将指代更一般的东西，这与处理我们希望监控的函数执行有关。这可能包括我们想要的情况：
- en: Trace the execution of a function (for example, by logging the lines it executes)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪函数的执行（例如，通过记录它执行的行）
- en: Monitor some metrics over a function (such as CPU usage or memory footprint)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控函数的一些指标（如CPU使用率或内存占用）
- en: Measure the running time of a function
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量函数的运行时间
- en: Log when a function was called, and the parameters that were passed to it
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录函数被调用时及其传递的参数
- en: In the next section, we will explore a simple example of a decorator that logs
    the execution of a function, including its name and the time it took to run.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一个简单的装饰器示例，该装饰器记录函数的执行，包括其名称和运行时间。
- en: Effective decorators – avoiding common mistakes
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有效的装饰器 - 避免常见错误
- en: While decorators are a great feature of Python, they are not exempt from issues
    if used incorrectly. In this section, we will see some common issues to avoid
    in order to create effective decorators.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管装饰器是Python的一个伟大特性，但如果使用不当，它们也不会免除问题。在本节中，我们将看到一些常见的避免问题，以便创建有效的装饰器。
- en: Preserving data about the original wrapped object
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留原始包装对象的有关数据
- en: One of the most common problems when applying a decorator to a function is that
    some of the properties or attributes of the original function are not maintained,
    leading to undesired, and hard-to-track, side effects.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在将装饰器应用于函数时，最常见的问题之一是原始函数的一些属性或属性没有被保留，导致不希望出现且难以追踪的副作用。
- en: 'To illustrate this, we show a decorator that is in charge of logging when the
    function is about to run:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们展示了一个负责在函数即将运行时记录日志的装饰器：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s imagine we have a function with this decorator applied to it. We
    might initially think that nothing of that function is modified with respect to
    its original definition:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们有一个应用了此装饰器的函数。我们可能会最初认为这个函数与它的原始定义相比没有任何修改：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: But maybe there are changes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但也许有变化。
- en: The decorator is not supposed to alter anything from the original function,
    but, as it turns out, since it contains a flaw, it's actually modifying its name
    and docstring, among other properties.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器不应该改变原始函数的任何内容，但，结果证明，由于它包含缺陷，它实际上正在修改其名称和docstring，以及其他属性。
- en: 'Let''s try to get `help` for this function:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试获取这个函数的`help`信息：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And let''s check how it''s called:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们检查它的调用方式：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And also, the annotations for the original function were lost:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，原始函数的注解也丢失了：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can see that, since the decorator is actually changing the original function
    for a new one (called `wrapped`), what we actually see are the properties of this
    function instead of those from the original function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，由于装饰器实际上是将原始函数替换为一个新的函数（称为`wrapped`），所以我们看到的是这个函数的属性，而不是原始函数的属性。
- en: If we apply a decorator like this one to multiple functions, all with different
    names, they will all end up being called `wrapped`, which is a major concern (for
    example, if we want to log or trace the function, this will make debugging even
    harder).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这样的装饰器应用于多个具有不同名称的函数，它们最终都会被调用为`wrapped`，这是一个主要问题（例如，如果我们想记录或跟踪函数，这将使调试更加困难）。
- en: Another problem is that if we placed docstrings with tests on these functions,
    they would be overridden by those of the decorator. As a result, the docstrings
    with the test we want will not run when we call our code with the `doctest` module
    (as we saw in *Chapter 1*, *Introduction, Code Formatting, and Tools*).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是我们如果在这些函数上放置带有测试的docstrings，它们将被装饰器的那些覆盖。结果，我们用`doctest`模块调用我们的代码时，我们想要的测试的docstrings将不会运行（如我们在*第一章*，*介绍、代码格式化和工具*中看到的）。
- en: 'The fix is simple, though. We just have to apply the wraps decorator in the
    internal function (`wrapped`), telling it that it is actually a wrapping function:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法很简单。我们只需在内部函数（`wrapped`）中应用`wraps`装饰器，告诉它这实际上是一个包装函数：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, if we check the properties, we will obtain what we expected in the first
    place. Check help for the function, like so:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们检查属性，我们将得到我们最初预期的结果。检查函数的帮助信息，如下所示：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And verify that its qualified name is correct, like so:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 并验证其限定名称是否正确，如下所示：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Most importantly, we recovered the unit tests we might have had on the docstrings!
    By using the `wraps` decorator, we can also access the original, unmodified function
    under the `__wrapped__` attribute. Although it should not be used in production,
    it might come in handy in some unit tests when we want to check the unmodified
    version of the function.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们恢复了可能存在于文档字符串上的单元测试！通过使用 `wraps` 装饰器，我们还可以通过 `__wrapped__` 属性访问原始的、未修改的函数。尽管在生产环境中不应使用它，但在某些单元测试中，当我们想要检查函数的未修改版本时，它可能很有用。
- en: 'In general, for simple decorators, the way we would use `functools.wraps` would
    typically follow the following general formula or structure:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，对于简单的装饰器，我们使用 `functools.wraps` 的方式会遵循以下通用公式或结构：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Always use `functools.wraps` applied over the wrapped function, when creating
    a decorator, as shown in the preceding formula.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建装饰器时，始终使用 `functools.wraps` 对包装函数进行应用，如前述公式所示。
- en: Dealing with side effects in decorators
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理装饰器中的副作用
- en: In this section, we will learn that it is advisable to avoid side effects in
    the body of the decorator. There are cases where this might be acceptable, but
    the bottom line is that if in doubt, decide against it, for the reasons that are
    explained ahead. Everything that the decorator needs to do aside from the function
    that it's decorating should be placed in the innermost function definition, or
    there will be problems when it comes to importing. Nonetheless, sometimes these
    side effects are required (or even desired) to run at import time, and the obverse
    applies.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解到在装饰器的主体中避免副作用是明智的。在某些情况下，这可能是可以接受的，但底线是，如果有疑问，应决定不这样做，原因将在下面解释。装饰器除了装饰的函数之外需要做的所有事情都应该放在最内层的函数定义中，否则在导入时会出现问题。尽管如此，有时这些副作用是必需的（甚至可能是期望的）在导入时运行，反之亦然。
- en: We will see examples of both, and where each one applies. If in doubt, err on
    the side of caution, and delay all side effects until the very last moment, right
    after the `wrapped` function is going to be called.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到这两种情况的示例，以及它们各自适用的场景。如果有疑问，应谨慎行事，并将所有副作用推迟到最后一刻，即在 `wrapped` 函数将要被调用之后。
- en: Next, we will see when it's not a good idea to place extra logic outside the
    `wrapped` function.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到在 `wrapped` 函数外部放置额外逻辑不是什么好主意的情况。
- en: Incorrect handling of side effects in a decorator
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 装饰器中对副作用的不正确处理
- en: 'Let''s imagine the case of a decorator that was created with the goal of logging
    when a function started running and then logging its running time:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个装饰器的例子，它的目的是在函数开始运行时记录日志，然后记录其运行时间：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we will apply the decorator to a regular function, thinking that it will
    work just fine:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将装饰器应用到普通函数上，认为它将正常工作：
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This decorator has a subtle yet critical bug in it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器中存在一个微妙但关键的错误。
- en: 'First, let''s import the function, call it several times, and see what happens:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们导入函数，多次调用它，看看会发生什么：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Just by importing the function, we will notice that something's amiss. The logging
    line should not be there, because the function was not invoked.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 只需导入函数，我们就会注意到有问题。日志行不应该在那里，因为函数没有被调用。
- en: 'Now, what happens if we run the function, and see how long it takes to run?
    Actually, we would expect that calling the same function multiple times will give
    similar results:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行函数，看看它运行需要多长时间？实际上，我们预计多次调用相同的函数将给出相似的结果：
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Every time we run the same function, it takes increasingly longer! At this point,
    you have probably already noticed the (now obvious) error.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们运行相同的函数，它所需的时间会越来越长！在这个时候，你可能已经注意到了（现在很明显）的错误。
- en: 'Remember the syntax for decorators. `@traced_function_wrong` actually means
    the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 记住装饰器的语法。`@traced_function_wrong` 实际上意味着以下内容：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: And this will run when the module is imported. Therefore, the time that is set
    in the function will be the time the module was imported. Successive calls will
    compute the time difference from the running time until that original starting
    time. It will also log at the wrong moment, and not when the function is actually
    called.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，函数中设置的时间将是模块导入的时间。随后的调用将计算从运行时间到原始起始时间的差异。它还会在错误的时间记录日志，而不是在函数实际被调用时。
- en: 'Luckily, the fix is also very simple—we just have to move the code inside the
    `wrapped` function in order to delay its execution:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，修复也很简单——我们只需将 `wrapped` 函数内部的代码移动，以延迟其执行：
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With this new version, the previous problems are resolved.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新版本，之前的问题都得到了解决。
- en: If the actions of the decorator had been different, the results could have been
    much more disastrous. For instance, if it requires that you log events and send
    them to an external service, it will certainly fail unless the configuration has
    been run right before this has been imported, which we cannot guarantee. Even
    if we could, it would be bad practice. The same applies if the decorator has any
    other sort of side effect, such as reading from a file, parsing a configuration,
    and many more.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果装饰器的行为不同，结果可能会更加灾难性。例如，如果它要求你记录事件并将它们发送到外部服务，那么除非在导入之前已经正确运行了配置，否则它肯定会失败。即使我们可以做到，这也是一种不良的做法。如果装饰器有任何其他类型的副作用，例如从文件中读取、解析配置等，也同样适用。
- en: Requiring decorators with side effects
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 需要具有副作用的装饰器
- en: Sometimes, side effects on decorators are necessary, and we should not delay
    their execution until the last possible minute, because that's part of the mechanism
    that is required for them to work.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，装饰器的副作用是必要的，我们不应该将它们的执行延迟到最后时刻，因为这是它们正常工作所需机制的一部分。
- en: One common scenario for when we don't want to delay the side effect of decorators
    is when we need to register objects to a public registry that will be available
    in the module.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不想延迟装饰器的副作用时，一个常见的场景是我们需要将对象注册到一个公共注册表中，该注册表将在模块中可用。
- en: For instance, going back to our previous `event` system example, we now want
    to only make some events available in the module, but not all of them. In the
    hierarchy of events, we might want to have some intermediate classes that are
    not actual events we want to process on the system, but some of their derivative
    classes instead.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，回到我们之前的`event`系统示例，我们现在只想在模块中使某些事件可用，而不是所有事件。在事件层次结构中，我们可能希望有一些中间类，它们不是我们希望在系统中处理的真实事件，而是它们的派生类。
- en: Instead of flagging each class based on whether it's going to be processed or
    not, we could explicitly register each class through a decorator.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是根据每个类是否将被处理来标记每个类，我们可以通过装饰器显式地注册每个类。
- en: 'In this case, we have a class for all events that relate to the activities
    of a user. However, this is just an intermediate table for the types of events
    we actually want, namely `UserLoginEvent` and `UserLogoutEvent`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一个与用户活动相关的所有事件的类。然而，这只是一个中间表，用于我们实际想要的事件类型，即`UserLoginEvent`和`UserLogoutEvent`：
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When we look at the preceding code, it seems that `EVENTS_REGISTRY` is empty,
    but after importing something from this module, it will get populated with all
    of the classes that are under the `register_event` decorator:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看前面的代码时，似乎`EVENTS_REGISTRY`是空的，但在从该模块导入某些内容后，它将填充所有在`register_event`装饰器下的类：
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This might seem like it's hard to read, or even misleading, because `EVENTS_REGISTRY`
    will have its final value at runtime, right after the module was imported, and
    we cannot easily predict its value by just looking at the code.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很难读懂，甚至具有误导性，因为`EVENTS_REGISTRY`将在模块导入后立即具有其最终值，在运行时，我们无法仅通过查看代码就轻易预测其值。
- en: 'While that is true, in some cases this pattern is justified. In fact, many
    web frameworks or well-known libraries use this to work and expose objects or
    make them available. That said, be aware of this risk, if you are to implement
    something similar in your own projects: most of the time, an alternative solution
    would be preferred.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如此，在某些情况下，这种模式是有道理的。事实上，许多Web框架或知名库都使用这种方法来工作，暴露对象或使它们可用。话虽如此，请注意这个风险，如果你在自己的项目中实现类似的功能：大多数情况下，选择一个替代方案会更受欢迎。
- en: It is also true that in this case, the decorator is not changing the `wrapped`
    object or altering the way it works in any way. However, the important note here
    is that if we were to do some modifications and define an internal function that
    modifies the `wrapped` object, we would still probably want the code that registers
    the resulting object outside it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，装饰器也没有改变`wrapped`对象或以任何方式改变其工作方式。然而，这里的重要提示是，如果我们对某些内容进行修改并定义一个内部函数来修改`wrapped`对象，我们仍然可能希望将注册结果的代码放在外部。
- en: Notice the use of the word *outside*. It does not necessarily mean before, it's
    just not part of the same closure; but it's in the outer scope, so it's not delayed
    until runtime.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到“*outside*”这个词的使用。它并不一定意味着“之前”，它只是不属于同一个闭包的一部分；但它在外部作用域中，所以它不会被延迟到运行时。
- en: Creating decorators that will always work
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建始终有效的装饰器
- en: There are several different scenarios to which decorators might apply. It can
    also be the case that we need to use the same decorator for objects that fall
    into these different multiple scenarios, for instance, if we want to reuse our
    decorator and apply it to a function, a class, a method, or a static method.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器可能适用于几种不同的场景。也可能存在这样的情况，我们需要为属于这些不同多个场景的对象使用相同的装饰器，例如，如果我们想重用我们的装饰器并将其应用于函数、类、方法或静态方法。
- en: If we create the decorator, just thinking about supporting only the first type
    of object we want to decorate, we might notice that the same decorator does not
    work equally well on a different type of object. A typical example is where we
    create a decorator to be used on a function, and then we want to apply it to a
    method of a class, only to realize that it does not work. A similar scenario might
    occur if we designed our decorator for a method, and then we want it to also apply
    for static methods or class methods.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只考虑支持我们想要装饰的第一种类型的对象来创建装饰器，我们可能会注意到，同样的装饰器在另一种类型的对象上工作得并不一样好。一个典型的例子是，我们创建一个用于函数的装饰器，然后我们想将其应用于类的某个方法，结果发现它不起作用。如果我们为方法设计了装饰器，然后我们希望它也能应用于静态方法或类方法，也可能出现类似的场景。
- en: When designing decorators, we typically think about reusing code, so we will
    want to use that decorator for functions and methods as well.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计装饰器时，我们通常考虑代码的重用，因此我们希望将这个装饰器用于函数和方法。
- en: 'Defining our decorators with the signature `*args` and `**kwargs` will make
    them work in all cases because it''s the most generic kind of signature that we
    can have. However, sometimes we might want not to use this, and instead define
    the decorator-wrapping function according to the signature of the original function,
    mainly because of two reasons:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用签名 `*args` 和 `**kwargs` 定义我们的装饰器将使它们在所有情况下都能工作，因为这是最通用的签名类型。然而，有时我们可能不想使用这种签名，而是根据原始函数的签名定义装饰器包装函数，这主要是因为两个原因：
- en: It will be more readable since it resembles the original function.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将更易于阅读，因为它类似于原始函数。
- en: It actually needs to do something with the arguments, so receiving `*args` and `**kwargs`
    wouldn't be convenient.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上需要处理这些参数，因此接收 `*args` 和 `**kwargs` 并不方便。
- en: Consider the case in which we have many functions in our code base that require
    a particular object to be created from a parameter. For instance, we pass a string,
    and initialize a driver object with it, repeatedly. Then we think we can remove
    the duplication by using a decorator that will take care of converting this parameter
    accordingly.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们代码库中有许多需要从参数创建特定对象的功能。例如，我们传递一个字符串，并使用它初始化一个驱动对象，反复进行。然后我们认为我们可以通过使用一个装饰器来处理这个参数的转换来消除重复。
- en: In the next example, we pretend that `DBDriver` is an object that knows how
    to connect and run operations on a database, but it needs a connection string.
    The methods we have in our code are designed to receive a string with the information
    of the database and require us to create an instance of `DBDrive`r always. The
    idea of the decorator is that it's going to take the place of this conversion
    automatically—the function will continue to receive a string, but the decorator
    will create a `DBDriver` and pass it to the function, so internally we can assume
    that we receive the object we need directly.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我们假设 `DBDriver` 是一个知道如何连接和运行数据库操作的对象，但它需要一个连接字符串。我们代码中的方法被设计为接收包含数据库信息的字符串，并要求我们始终创建
    `DBDriver` 实例。装饰器的想法是它会自动替换这个转换——函数将继续接收一个字符串，但装饰器将创建一个 `DBDriver` 实例并将其传递给函数，因此我们可以假设我们直接接收所需的对象。
- en: 'An example of using this in a function is shown in the next listing:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中展示了如何在函数中使用这个例子：
- en: '[PRE43]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It''s easy to verify that if we pass a string to the function, we get the result
    done by an instance of `DBDriver`, so the decorator works as expected:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个字符串传递给函数，我们可以得到由 `DBDriver` 实例执行的结果，所以装饰器按预期工作：
- en: '[PRE44]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'But now, we want to reuse this same decorator in a class method, where we find
    the same problem:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，我们想在类方法中重用这个相同的装饰器，我们发现同样的问题：
- en: '[PRE45]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We try to use this decorator, only to realize that it doesn''t work:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试使用这个装饰器，但发现它不起作用：
- en: '[PRE46]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: What is the problem?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是什么？
- en: The method in the class is defined with an extra argument—`self`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的方法定义了一个额外的参数——`self`。
- en: Methods are just a particular kind of function that receive `self` (the object
    they're defined upon) as the first parameter.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 方法只是接收`self`（它们定义的对象）作为第一个参数的特定类型的函数。
- en: Therefore, in this case, the decorator (designed to work with only one parameter,
    named `dbstring`) will interpret that `self` is said parameter, and call the method
    passing the string in the place of `self`, and nothing in the place of the second
    parameter, namely the string we are passing.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，这个装饰器（设计为只与一个名为`dbstring`的参数一起工作）将解释`self`是这个参数，并且将调用方法，用字符串代替`self`，在第二个参数的位置上没有内容，即我们传递的字符串。
- en: To fix this issue, we need to create a decorator that will work equally for
    methods and functions, and we do so by defining this as a decorator object that
    also implements the protocol descriptor.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要创建一个既适用于方法也适用于函数的装饰器，我们通过定义这个作为装饰器对象并实现协议描述符来实现这一点。
- en: Descriptors are fully explained in *Chapter 7*, *Generators, Iterators, and
    Asynchronous Programming*, so for now, we can just take this as a recipe that
    will make the decorator work.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符在*第7章*，*生成器、迭代器和异步编程*中得到了全面解释，所以现在我们只需将其视为一个使装饰器工作的配方。
- en: 'The solution is to implement the decorator as a class object and make this
    object a description, by implementing the `__get__` method:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是实现一个作为类对象的装饰器，并通过实现`__get__`方法使其成为一个描述符：
- en: '[PRE47]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Details on descriptors will be explained in *Chapter 6*, *Getting More Out of
    Our Objects with Descriptors*, but for the purposes of this example, we can now
    say that what it does is actually rebind the callable it's decorating to a method,
    meaning that it will bind the function to the object, and then recreate the decorator
    with this new callable.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符的详细信息将在*第6章*，*使用描述符获取更多对象功能*中解释，但为了这个示例，我们可以说它实际上是将它装饰的调用重新绑定到方法上，这意味着它将函数绑定到对象上，然后使用这个新的调用重新创建装饰器。
- en: For functions, it still works, because it won't call the `__get__` method at
    all.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数来说，这仍然有效，因为它根本不会调用`__get__`方法。
- en: Decorators and clean code
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器和整洁代码
- en: Now that we know more about decorators, how to write them, and avoiding common
    issues, it's time to take them to the next level and see how we can leverage what
    we have learned to achieve better software.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对装饰器有了更多的了解，如何编写它们，以及如何避免常见问题，是时候将它们提升到下一个层次，看看我们如何利用所学知识来制作更好的软件。
- en: We have briefly touched on this subject throughout the previous sections, but
    those were closer-to-the-code examples, as the suggestions referred to how to
    make specific lines (or sections) of the code more readable.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面几节中简要地提到了这个主题，但那些更接近代码的示例，因为建议是关于如何使特定的代码行（或部分）更易读。
- en: The topics discussed from now relate to more general design principles. Some
    of these ideas we have already visited in previous chapters, but the outlook here
    is to understand how we use decorators for such purposes.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始讨论的主题与更普遍的设计原则相关。其中一些想法我们在前面的章节中已经接触过，但这里的观点是理解我们如何为了这样的目的使用装饰器。
- en: Composition over inheritance
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合优于继承
- en: We have already discussed briefly that in general, it's better to have composition
    rather than inheritance because the latter carries some problems of making components
    of the code more coupled.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经简要讨论过，一般来说，组合比继承更好，因为后者会带来一些问题，使得代码组件更加耦合。
- en: 'In the book *Design Patterns: Elements of Reusable Object-Oriented Software*
    (DESIG01), most of the ideas around the design pattern are based on the following
    idea:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在书籍《设计模式：可复用面向对象软件元素》（DESIG01）中，围绕设计模式的大部分想法都是基于以下观点：
- en: Favor composition over class inheritance
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 优先组合而非类继承
- en: In *Chapter 2*, *Pythonic Code*, I introduced the idea of using the magic method
    `__getattr__` to resolve attributes dynamically on objects. I also gave the example
    that this could be used to automatically resolve attributes based on a naming
    convention should this be required by an external framework, for example. Let's
    explore two different versions of solving this problem.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2章*，*Pythonic代码*中，我介绍了使用魔法方法`__getattr__`在对象上动态解析属性的想法。我还给出了一个例子，说明这可以用来根据命名约定自动解析属性，如果外部框架需要的话。让我们探索两种不同的解决方案。
- en: For this example, let's assume we're interacting with a framework that has the
    naming convention of calling attributes with the prefix "`resolve_`" to resolve
    an attribute, but our domain objects only have those attributes without the "`resolve_`"
    prefix.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，让我们假设我们正在与一个命名约定为使用前缀"`resolve_`"来解析属性的框架交互，但我们的领域对象只有那些没有"`resolve_`"前缀的属性。
- en: 'Clearly, we don''t want to write a lot of repetitive methods named "`resolve_x`"
    for every attribute we have, so the first idea is to take advantage of the aforementioned
    `__getattr__` magic method, and place it in a base class:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不想为每个属性编写很多重复的名为"`resolve_x`"的方法，所以第一个想法是利用前面提到的`__getattr__`魔法方法，并将其放置在基类中：
- en: '[PRE48]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will do the trick, but can we do better?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这将解决问题，但我们能做得更好吗？
- en: 'We could devise a class decorator to set this method directly:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设计一个类装饰器来直接设置这个方法：
- en: '[PRE49]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Both versions would comply with the following behavior:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 两个版本都将符合以下行为：
- en: '[PRE50]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: First, we have the resolve method as a standalone function that respects the
    signature of how the original `__getattr__` would look like (that's why I even
    preserved `self` as the name of the first parameter, to be intentional about that
    function becoming a method).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一个独立的方法`resolve`，它遵循原始`__getattr__`的签名（这就是为什么我甚至保留了`self`作为第一个参数的名字，以便有意识地让这个函数成为一个方法）。
- en: The rest of the code seems rather simple. Our decorator only sets the method
    to the class it receives by parameter, and then we apply the decorator to our
    class without having to use inheritance anymore.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码看起来相当简单。我们的装饰器只将方法设置为我们通过参数接收的类，然后我们只需将装饰器应用于我们的类，就不再需要使用继承。
- en: How is this a little bit better than the previous example? For starters, we
    can argue the use of the decorator implies we're using composition (take a class,
    modify it, and return a new one) over inheritance, so our code is less coupled
    with the base class we had at the beginning.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的例子相比有什么好处呢？首先，我们可以争论使用装饰器意味着我们正在使用组合（取一个类，修改它，然后返回一个新的类）而不是继承，因此我们的代码与最初的基本类耦合度更低。
- en: 'Additionally, we can say that the use of inheritance (via a mixin class) in
    the first example was rather fictitious. We were not using inheritance to create
    a more specialized version of the class, only to take advantage of the `__getattr__`
    method. This would be bad for two (complementary) reasons: first, inheritance
    is not the best way to reuse code. Good code is reused by having small, cohesive
    abstractions, not creating hierarchies.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以说，第一个例子中使用继承（通过混合类）是相当虚构的。我们并没有使用继承来创建类的更专用版本，而是为了利用`__getattr__`方法。这有两个（互补的）原因：首先，继承不是重用代码的最佳方式。好的代码是通过拥有小的、内聚的抽象来重用的，而不是创建层次结构。
- en: Second, remember from previous chapters that creating a subclass should follow
    with the idea of specialization, the "is a" kind of relation. Think whether, from
    a conceptual point of view, a customer is indeed a `BaseResolverMivin` (and what
    is, by the way?).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，记得从之前的章节中，创建子类应该遵循特殊化的想法，“是一种”的关系。从概念上考虑，一个客户是否真的是一个`BaseResolverMivin`（顺便问一下，那是什么？）。
- en: 'To shed some more light on this second point, imagine you have a hierarchy
    like this one:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明这个第二点，想象你有一个像这样的层次结构：
- en: '[PRE51]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this case, the use of inheritance is arguably correct, after all, an encrypted
    connection is a more specific kind of connection. But what would be a more specific
    kind of `BaseResolverMixin`? This is a mixin class, so it's expected to be mixed
    in the hierarchy along with other classes (using multiple inheritance). The use
    of this mix-in class is purely pragmatic, and for implementational purposes. Don't
    get me wrong, this is a pragmatic book, so you'll have to deal with mix-in classes
    in your professional experience, and it's perfectly fine to use them, but if we
    can avoid this purely implementational abstraction, and replace it with something
    that doesn't compromise our domain objects (in this case the `Customer` class),
    that's even better.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用继承可以说是正确的，毕竟加密连接是一种更具体的连接类型。但什么是比`BaseResolverMixin`更具体的类型呢？这是一个混合类，所以它被期望与其他类（使用多重继承）一起混合在层次结构中。使用这种混合类纯粹是实用主义的，并且出于实现目的。请别误会，这是一本实用主义的书，所以你会在你的专业经验中处理混合类，使用它们是完全正常的，但如果我们可以避免这种纯粹实现上的抽象，并用不损害我们的领域对象（在这种情况下是`Customer`类）的东西来替换它，那就更好了。
- en: There's another exciting capability of the new design, which is extensibility.
    We have seen how decorators can be parametrized. Imagine the flexibility we could
    achieve in our design if we allowed the decorator to set any resolver function,
    not just the one we defined.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 新设计还有一个令人兴奋的能力，那就是可扩展性。我们已经看到装饰器可以参数化。想象一下，如果我们允许装饰器设置任何解析函数，而不仅仅是定义的那个，我们能在我们的设计中实现多大的灵活性。
- en: The DRY principle with decorators
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器与DRY原则
- en: We have seen how decorators allow us to abstract away certain logic into a separate
    component. The main advantage of this is that we can then apply the decorator
    multiple times to different objects in order to reuse code. This follows the **Don't
    Repeat Yourself** (**DRY**) principle since we define certain knowledge once and
    only once.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到装饰器如何允许我们将某些逻辑抽象到一个单独的组件中。这样做的主要优势是，我们可以将装饰器多次应用于不同的对象，以重用代码。这遵循了**不要重复自己**（**DRY**）原则，因为我们只定义某些知识一次。
- en: The `retry` mechanism implemented in the previous sections is a good example
    of a decorator that can be applied multiple times to reuse code. Instead of making
    each particular function include its own `retry` logic, we create a decorator
    and apply it several times. This makes sense once we have made sure that the decorator
    can work with methods and functions equally.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中实现的`retry`机制是一个很好的例子，它是一个可以多次应用以重用代码的装饰器。我们不是让每个特定的函数都包含自己的`retry`逻辑，而是创建一个装饰器并多次应用它。一旦我们确保装饰器可以与方法和函数一样工作，这样做是有意义的。
- en: The class decorator that defined how events are to be represented also complies
    with the DRY principle in the sense that it defines one specific place for the
    logic for serializing an event, without needing to duplicate code scattered among
    different classes. Since we expect to reuse this decorator and apply it to many
    classes, its development (and complexity) pay off.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 定义事件表示方式的类装饰器也符合DRY原则，因为它定义了一个特定的地方来处理序列化事件的逻辑，而不需要在不同的类中重复代码。由于我们预计会重用这个装饰器并将其应用于许多类，因此其开发（及其复杂性）是有回报的。
- en: This last remark is important to bear in mind when trying to use decorators
    in order to reuse code—we have to be absolutely sure that we will actually be
    saving code.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试使用装饰器重用代码时，这一点非常重要：我们必须绝对确信我们实际上会节省代码。
- en: Any decorator (especially if it is not carefully designed) adds another level
    of indirection to the code, and hence more complexity. Readers of the code might
    want to follow the path of the decorator to fully understand the logic of the
    function (although these considerations are addressed in the following section),
    so keep in mind that this complexity has to pay off. If there is not going to
    be too much reuse, then do not go for a decorator and opt for a simpler option
    (maybe just a separate function or another small class is enough).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 任何装饰器（尤其是如果它没有经过精心设计的话）都会给代码增加一个额外的间接层，从而增加更多的复杂性。代码的读者可能想要追踪装饰器的路径，以便完全理解函数的逻辑（尽管这些考虑在下一节中已经讨论过），因此请记住，这种复杂性必须得到回报。如果不太可能大量重用，那么就不应该选择装饰器，而应该选择更简单的选项（可能只是一个单独的函数或另一个小型类就足够了）。
- en: But how do we know what too much reuse is? Is there a rule to determine when
    to refactor existing code into a decorator? There is nothing specific to decorators
    in Python, but we could apply a general rule of thumb in software engineering
    (GLASS 01) that states that a component should be tried out at least three times
    before considering creating a generic abstraction in the sort of a reusable component.
    From the same reference (GLASS 01) (I encourage all readers to read *Facts and
    Fallacies of Software Engineering* because it is a great reference) also comes
    the idea that creating reusable components is three times harder than creating
    simple ones.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何知道过度重用是什么意思？有没有一个规则来确定何时将现有代码重构为装饰器？Python中并没有针对装饰器的特定内容，但我们可以应用软件工程中的一个通用经验法则（GLASS
    01），即一个组件至少应该尝试三次，然后再考虑创建一个通用的抽象，即可重用组件。同样来自同一参考（GLASS 01）（我鼓励所有读者阅读《软件工程的真相与谬误》，因为它是一个极好的参考资料）的想法是，创建可重用组件比创建简单的组件难三倍。
- en: 'The bottom line is that reusing code through decorators is acceptable, but
    only when you take into account the following considerations:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 核心观点是，通过装饰器重用代码是可以接受的，但前提是你必须考虑到以下因素：
- en: Do not create the decorator in the first place from scratch. Wait until the
    pattern emerges and the abstraction for the decorator becomes clear, and then
    refactor.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要一开始就从头开始创建装饰器。等待模式出现，装饰器的抽象变得清晰，然后再进行重构。
- en: Consider that the decorator has to be applied several times (at least three
    times) before implementing it.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到装饰器可能需要多次（至少三次）应用，然后再进行实现。
- en: Keep the code in the decorators to a minimum.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将装饰器中的代码保持到最小。
- en: As we have revisited the DRY principle from the point of view of decorators,
    we can still discuss the separation of concerns applied to decorators, as explored
    in the next section.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经从装饰器的角度重新审视了DRY原则，我们仍然可以讨论应用于装饰器的关注点分离，正如下一节所探讨的那样。
- en: Decorators and separation of concerns
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器与关注点分离
- en: The last point in the previous list is so important that it deserves a section
    of its own. We have already explored the idea of reusing code and noticed that
    a key element of reusing code is having components that are cohesive. This means
    that they should have the minimum level of responsibility—do one thing, one thing
    only, and do it well. The smaller our components, the more reusable, and the more
    they can be applied in a different context without carrying extra behavior that
    will cause coupling and dependencies, which will make the software rigid.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个列表中的最后一点非常重要，以至于它值得单独成节。我们已经探讨了代码重用的概念，并注意到重用代码的关键要素是具有凝聚性的组件。这意味着它们应该具有最小的职责水平——只做一件事，只做一件事，并且做好。我们的组件越小，它们就越可重用，并且可以在不同的上下文中应用，而不会携带额外的行为，这会导致耦合和依赖，从而使软件变得僵化。
- en: 'To show you what this means, let''s reprise one of the decorators that we used
    in a previous example. We created a decorator that traced the execution of certain
    functions with code similar to the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这意味着什么，让我们回顾一下我们在前一个示例中使用的一个装饰器。我们创建了一个装饰器，它使用类似于以下代码的方式来追踪某些函数的执行：
- en: '[PRE52]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, this decorator, while it works, has a problem—it is doing more than one
    thing. It logs that a particular function was just invoked, and also logs how
    much time it took to run. Every time we use this decorator, we are carrying these
    two responsibilities, even if we only wanted one of them.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个装饰器虽然有效，但有一个问题——它做了不止一件事。它记录了一个特定函数已被调用，并记录了运行所需的时间。每次我们使用这个装饰器时，我们都在承担这两项职责，即使我们只想承担其中之一。
- en: 'This should be broken down into smaller decorators, each one with a more specific
    and limited responsibility:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该被分解成更小的装饰器，每个装饰器都有更具体和有限的职责：
- en: '[PRE53]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Notice that the same functionality that we had previously can be achieved by
    simply combining both of them:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们之前拥有的相同功能可以通过简单地结合两者来实现：
- en: '[PRE54]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Notice how the order in which the decorators are applied is also important.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 注意装饰器应用顺序的重要性。
- en: Do not place more than one responsibility in a decorator. The **single responsibility
    principle** (**SRP**) applies to decorators as well.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在装饰器中放置超过一个职责。**单一职责原则**（SRP）同样适用于装饰器。
- en: Finally, we can analyze good decorators to get an idea of how they're used in
    practice. The next section starts wrapping up what we've learned in this chapter,
    by analyzing decorators.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以分析优秀的装饰器，以了解它们在实际中的应用。下一节将通过分析装饰器来总结本章所学内容。
- en: Analysis of good decorators
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优秀装饰器的分析
- en: As a closing note for this chapter, let's review some examples of good decorators
    and how they are used both in Python itself, as well as in popular libraries.
    The idea is to get guidelines on how good decorators are created.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的结束语，让我们回顾一些优秀的装饰器示例以及它们在Python本身以及流行库中的使用方式。目的是获取有关如何创建优秀装饰器的指导原则。
- en: 'Before jumping into examples, let''s first identify traits that good decorators
    should have:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入示例之前，让我们首先确定优秀装饰器应具备的特征：
- en: '**Encapsulation, or separation of concerns**: A good decorator should effectively
    separate different responsibilities between what it does and what it is decorating.
    It cannot be a leaky abstraction, meaning that a client of the decorator should
    only invoke it in black-box mode, without knowing how it is actually implementing
    its logic.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装，或关注点分离**：一个好的装饰器应该有效地将其所做之事与所装饰的内容之间的不同职责分开。它不能是一个有漏洞的抽象，这意味着装饰器的客户端应该只以黑盒模式调用它，而不了解其实际实现逻辑。'
- en: '**Orthogonality**: What the decorator does should be independent, and as decoupled
    as possible from the object it is decorating.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正交性**：装饰器所做的事情应该是独立的，并且尽可能与它所装饰的对象解耦。'
- en: '**Reusability**: It is desirable that the decorator can be applied to multiple
    types, and not that it just appears on one instance of one function, because that
    means that it could just have been a function instead. It has to be generic enough.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：希望装饰器可以应用于多种类型，而不仅仅是出现在一个函数的一个实例上，因为这意味着它可能只是一个函数。它必须足够通用。'
- en: 'A nice example of decorators can be found in the `Celery` project, where a
    task is defined by applying the decorator of the task from the application to
    a function:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Celery`项目中可以找到一个装饰器的美好例子，其中任务是通过将应用中的任务装饰器应用到函数上来定义的：
- en: '[PRE55]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: One of the reasons why this is a good decorator is because it is very good at
    something—encapsulation. The user of the library only needs to define the function
    body and the decorator will convert that into a task automatically. The `@app.task`
    decorator surely wraps a lot of logic and code, but none of that is relevant to
    the body of `mytask()`. It is complete encapsulation and separation of concerns—nobody
    will have to take a look at what that decorator does, so it is a correct abstraction
    that does not leak any details.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器之所以好，其中一个原因是因为它在某一方面非常出色——封装。库的用户只需要定义函数体，装饰器就会自动将其转换为任务。`@app.task`装饰器无疑封装了大量的逻辑和代码，但这些都无关紧要`mytask()`函数的主体。这是完整的封装和关注点的分离——没有人需要查看装饰器做了什么，因此它是一个正确的抽象，不会泄露任何细节。
- en: 'Another common use of decorators is in web frameworks (`Pyramid`, `Flask`,
    and `Sanic`, just to name a few), on which the handlers for views are registered
    to the URLs through decorators:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器的另一个常见用途是在Web框架中（例如`Pyramid`、`Flask`和`Sanic`，仅举几个例子），在这些框架中，视图的处理程序通过装饰器注册到URL：
- en: '[PRE56]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: These sorts of decorators have the same considerations as before; they also
    provide total encapsulation because a user of the web framework rarely (if ever)
    needs to know what the `@route` decorator is doing. In this case, we know that
    the decorator is doing something more, such as registering these functions to
    a mapper to the URL, and also that it is changing the signature of the original
    function to provide us with a nicer interface that receives a `request` object
    with all the information already set.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这类装饰器与之前的有相同的考虑因素；它们也提供了完全的封装，因为使用Web框架的用户很少（如果有的话）需要知道`@route`装饰器正在做什么。在这种情况下，我们知道装饰器正在做更多的事情，比如将这些函数注册到URL的映射器，并且它还在改变原始函数的签名，为我们提供一个更友好的接口，该接口接收一个已经设置好所有信息的`request`对象。
- en: The previous two examples are enough to make us notice something else about
    this use of decorators. They conform to an API. These libraries of frameworks
    are exposing their functionality to users through decorators, and it turns out
    that decorators are an excellent way of defining a clean programming interface.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个例子已经足够让我们注意到关于这种装饰器使用的一个其他方面。它们遵循一个API。这些库和框架通过装饰器向用户公开其功能，结果证明装饰器是定义干净编程接口的一种极好的方式。
- en: This is probably the best way we should think about decorators. Much like in
    the example of the class decorator that tells us how the attributes of the event
    are going to be handled, a good decorator should provide a clean interface so
    that users of the code know what to expect from the decorator, without needing
    to know how it works, or any of its details for that matter.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是我们应该考虑装饰器的最好方式。就像在类装饰器的例子中，它告诉我们事件属性将如何被处理一样，一个好的装饰器应该提供一个干净的接口，这样代码的用户就知道从装饰器可以期待什么，而无需了解它是如何工作的，或者它的任何细节。
- en: Summary
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Decorators are powerful tools in Python that can be applied to many things such
    as classes, methods, functions, generators, and many more. We have demonstrated
    how to create decorators in different ways, and for different purposes, and drew
    some conclusions along the way.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是Python中的强大工具，可以应用于许多事物，如类、方法、函数、生成器等等。我们已经展示了如何以不同的方式创建装饰器，用于不同的目的，并在过程中得出了一些结论。
- en: When creating a decorator for functions, try to make its signature match the
    original function being decorated. Instead of using the generic `*args` and `**kwargs`,
    making the signature match the original one will make it easier to read and maintain,
    and it will resemble the original function more closely, so it will be more familiar
    to readers of that code.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在为函数创建装饰器时，尽量使它的签名与被装饰的原函数相匹配。而不是使用通用的`*args`和`**kwargs`，使签名与原函数相匹配将使其更容易阅读和维护，并且会更接近原函数，因此对代码的读者来说会更加熟悉。
- en: Decorators are a very useful tool for reusing code and following the DRY principle.
    However, their usefulness comes at a cost, and if they are not used wisely, the
    complexity can do more harm than good. For that reason, we emphasize that decorators
    should be used when they are going to be applied multiple times (three or more
    times). In the same way as the DRY principle, we embrace the idea of separation
    of concerns, with the goal of keeping the decorators as small as possible.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是重用代码和遵循DRY原则的一个非常有用的工具。然而，它们的实用性是有代价的，如果使用不当，复杂性可能会带来比好处更多的坏处。因此，我们强调，装饰器应该在它们将被多次应用（三次或更多次）时使用。与DRY原则一样，我们支持关注点分离的理念，目标是使装饰器尽可能小。
- en: Another good use of decorators is to create cleaner interfaces, for instance,
    simplifying the definition of a class by extracting part of its logic into a decorator.
    In this sense, decorators also help readability by providing the users with information
    about what that particular component will be doing, without needing to know how
    (encapsulation).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器的另一个良好用途是创建更清晰的接口，例如，通过将部分逻辑提取到装饰器中来简化类的定义。从这个意义上讲，装饰器也通过向用户提供有关特定组件将执行什么操作的信息来帮助提高可读性，而无需了解如何实现（封装）。
- en: In the next chapter, we will take a look at another advanced feature of Python—descriptors.
    In particular, we will see how with the help of descriptors, we can create even
    better decorators and solve some of the issues we encountered in this chapter.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Python的另一个高级特性——描述符。特别是，我们将看到如何借助描述符，我们可以创建更好的装饰器并解决本章中遇到的一些问题。
- en: References
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Here is a list of information you can refer to:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一份您可以参考的信息列表：
- en: '*PEP-318*: *Decorators for Functions and Methods* ([https://www.python.org/dev/peps/pep-0318/](https://www.python.org/dev/peps/pep-0318/))'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-318*: *函数和方法的装饰器* ([https://www.python.org/dev/peps/pep-0318/](https://www.python.org/dev/peps/pep-0318/))'
- en: '*PEP-3129*: *Class Decorators* ([https://www.python.org/dev/peps/pep-3129/](https://www.python.org/dev/peps/pep-3129/))'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-3129*: *类装饰器* ([https://www.python.org/dev/peps/pep-3129/](https://www.python.org/dev/peps/pep-3129/))'
- en: '*WRAPT 01*: [https://pypi.org/project/wrapt/](https://pypi.org/project/wrapt/)'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WRAPT 01*: [https://pypi.org/project/wrapt/](https://pypi.org/project/wrapt/)'
- en: '*WRAPT 02*: [https://wrapt.readthedocs.io/en/latest/decorators.html#universal-decorators](https://wrapt.readthedocs.io/en/latest/decorators.html#universal-decorators
    )'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WRAPT 02*: [https://wrapt.readthedocs.io/en/latest/decorators.html#universal-decorators](https://wrapt.readthedocs.io/en/latest/decorators.html#universal-decorators)'
- en: '*The Functools module: The wraps function in the functools module of Python''s
    standard library* ([https://docs.python.org/3/library/functools.html#functools.wrap](https://docs.python.org/3/library/functools.html#functools.wrap))'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python标准库中的functools模块：wraps函数* ([https://docs.python.org/3/library/functools.html#functools.wrap](https://docs.python.org/3/library/functools.html#functools.wrap))'
- en: '*ATTRS 01*: *The attrs library* ([https://pypi.org/project/attrs/](https://pypi.org/project/attrs/))'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ATTRS 01*: *attrs库* ([https://pypi.org/project/attrs/](https://pypi.org/project/attrs/))'
- en: '*PEP-557*: *Data Classes* ([https://www.python.org/dev/peps/pep-0557/](https://www.python.org/dev/peps/pep-0557/))'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-557*: *数据类* ([https://www.python.org/dev/peps/pep-0557/](https://www.python.org/dev/peps/pep-0557/))'
- en: '*GLASS 01*: The book written by *Robert L. Glass* called *Facts and Fallacies
    of Software Engineering*'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GLASS 01*: 由*Robert L. Glass*所著的名为*软件工程的事实与谬误*的书籍'
- en: '*DESIG01*: The book written by *Erich Gamma* called *Design Patterns: Elements
    of Reusable Object-Oriented Software*'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DESIG01*: 由*Erich Gamma*所著的名为*设计模式：可复用面向对象软件元素*的书籍'
- en: '*PEP-614*: *Relaxing Grammar Restrictions On Decorators* ([https://www.python.org/dev/peps/pep-0614/](https://www.python.org/dev/peps/pep-0614/))'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-614*: *放宽装饰器的语法限制* ([https://www.python.org/dev/peps/pep-0614/](https://www.python.org/dev/peps/pep-0614/))'
