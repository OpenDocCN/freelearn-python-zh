- en: Chapter 9. Improving Performance – Part Two, NumPy and Parallelization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。提高性能 – 第二部分，NumPy 和并行化
- en: 'This is the final chapter in the series of the three chapters on performance
    improvement. It will introduce you to two important libraries, **NumPy**, a third-party
    package, and the built-in **multiprocessing** module. In this chapter, we will
    cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于性能改进的三章中的最后一章。它将介绍两个重要的库，**NumPy**，一个第三方包，以及内置的 **multiprocessing** 模块。在本章中，我们将涵盖以下主题：
- en: A brief introduction to the NumPy package
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 包的简要介绍
- en: Using NumPy to speed up the *Gold Hunt* application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 NumPy 加速 *Gold Hunt* 应用
- en: An introduction to parallel processing using the `multiprocessing` module
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `multiprocessing` 模块介绍并行处理
- en: Using the `multiprocessing` module to further improve the application runtime
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `multiprocessing` 模块进一步改善应用运行时间
- en: Prerequisites for this chapter
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章的先决条件
- en: You should read the last two chapters, [Chapter 7](ch07.html "Chapter 7. Performance
    – Identifying Bottlenecks"), *Performance – Identifying Bottlenecks*, and [Chapter
    8](ch08.html "Chapter 8. Improving Performance – Part One"), *Improving Performance
    – Part one*, on performance that teaches you how to identify the performance bottlenecks
    and improve the runtime using built-in functionality. This chapter takes the application
    to the next level by drastically improving performance.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该阅读最后两个章节，[第7章](ch07.html "第7章。性能 – 识别瓶颈")，*性能 – 识别瓶颈*，和[第8章](ch08.html "第8章。提高性能
    – 第一部分")，*提高性能 – 第一部分*，这些章节介绍了如何识别性能瓶颈并使用内置功能来提高运行时间。本章通过大幅提高性能将应用提升到下一个层次。
- en: This is how the chapter is organized
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这是本章的组织结构
- en: This chapter will be the *Part two* of performance improvement. Just like the
    previous chapter, the performance of the *Gold Hunt* program will be improved
    in steps. We will start with a quick introduction to NumPy, just enough to use
    its functionality for *optimization passes four* and *five*, which follow next.
    Moving ahead, there will be a superficial introduction to the `multiprocessing`
    module. In *optimization pass six*, we will use this module to parallelize a portion
    of the application code. Let's pull up the same bar chart from the previous chapter.
    The last two bars indicate the speedup accomplished by the end of this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将是性能改进的 *第二部分*。就像上一章一样，*Gold Hunt* 程序的性能将通过逐步改进。我们将从对 NumPy 的快速介绍开始，仅足够使用其功能进行
    *优化过程四* 和 *五*，接下来将介绍。继续前进，将对 `multiprocessing` 模块进行浅显的介绍。在 *优化过程六* 中，我们将使用此模块来并行化应用代码的一部分。让我们拉起上一章中相同的柱状图。最后两个柱子表示到本章结束时实现的加速。
- en: '![This is how the chapter is organized](img/B05034_09_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![这是本章的组织结构](img/B05034_09_01.jpg)'
- en: But the chart does not tell the full story. The *optimization pass four*, will
    significantly speedup the `generate_random_points` function of the *Gold Hunt*
    program. This speedup is not reflected in the chart as the function does not significantly
    contribute to the runtime in this scenario. Towards the end, the chapter will
    provide preliminary information on **PyPy** for further reading. PyPy is a Python
    interpreter that provides a **Just In Time** (**JIT**) compiler.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但图表并没有讲述完整的故事。*优化过程四*将显著加快 *Gold Hunt* 程序的 `generate_random_points` 函数。这种加速在图表中没有体现，因为在这个场景中该函数对运行时间没有显著贡献。在结尾部分，本章将提供关于
    **PyPy** 的初步信息，供进一步阅读。PyPy 是一个提供 **即时** (**JIT**) 编译器的 Python 解释器。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Running Gold Hunt optimization examples**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行 Gold Hunt 优化示例**'
- en: If you look closely at the profiling output shown in the upcoming discussion,
    you will notice a filename, `goldhunt_run_master.py`. Using this file is optional
    but it provides a convenient way to run any of the optimization passes. You can
    find this file in this chapter's supporting code bundle.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看即将讨论的性能分析输出，你会注意到一个文件名，`goldhunt_run_master.py`。使用此文件是可选的，但它提供了一种方便的方式来运行任何优化过程。你可以在这个章节的支持代码包中找到此文件。
- en: Introduction to NumPy
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy 简介
- en: NumPy is a powerful Python package for scientific computing. It provides a multidimensional
    `array` object that enables efficient implementation of numerical computations
    in Python. It also has a relatively smaller memory footprint when compared to
    a list. An `array` object is just one of the many important features of NumPy.
    Among other things, it offers linear algebra and random number generation capabilities.
    It also provides tools to access codes written in other languages, such as C/C++
    and Fortran. Let's start with a short introduction that gives a flavor of its
    capabilities. What we will discuss in this book is more like scratching the surface
    of NumPy! This chapter covers some features to be used later to speed up the *Gold
    Hunt* application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy是一个强大的Python科学计算包。它提供了一个多维`array`对象，使得在Python中高效实现数值计算成为可能。与列表相比，它的内存占用相对较小。`array`对象只是NumPy的许多重要特性之一。除此之外，它还提供了线性代数和随机数生成功能。它还提供了访问用其他语言编写的代码的工具，例如C/C++和Fortran。让我们从一个简短的介绍开始，以了解其功能。本书中我们将讨论的更多像是NumPy表面的冰山一角！本章涵盖了以后用于加速*黄金狩猎*应用程序的一些特性。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Review the official NumPy documentation ([http://docs.scipy.org](http://docs.scipy.org))
    to learn about several other features that are not covered here.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅官方NumPy文档([http://docs.scipy.org](http://docs.scipy.org))，了解这里未涵盖的几个其他特性。
- en: If you are already familiar with NumPy, you can optionally skip this introduction
    and directly move on to the *Optimizing Gold Hunt – Part two* section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉NumPy，你可以选择性地跳过这个介绍，直接进入*优化黄金狩猎 – 第二部分*部分。
- en: Installing NumPy
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装NumPy
- en: 'Some Python distributions, such as Anaconda ([https://www.continuum.io/downloads](https://www.continuum.io/downloads)),
    provide NumPy by default. If unavailable, use `pip` to install it. Here is how
    to do it on Linux, assuming `pip` is available as a command in the terminal:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Python发行版，例如Anaconda ([https://www.continuum.io/downloads](https://www.continuum.io/downloads))，默认提供NumPy。如果不可用，请使用`pip`安装它。以下是在Linux上安装的方法，假设`pip`可以在终端作为命令使用：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This should install NumPy. If you encounter problems, refer to the platform
    specific installation instructions at [http://www.scipy.org/install.html](http://www.scipy.org/install.html).
    Alternatively, you can use the earlier mentioned Anaconda Python distribution.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会安装NumPy。如果你遇到问题，请参阅[http://www.scipy.org/install.html](http://www.scipy.org/install.html)上的平台特定安装说明。或者，你可以使用前面提到的Anaconda
    Python发行版。
- en: 'Once installed, open the Python interpreter and type the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，打开Python解释器并输入以下命令：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Assuming the installation is successful, it should import NumPy. For the rest
    of the discussion, we will use the notation `np` as the alias for `numpy`. Keep
    the interpreter window open. For the rest of the introduction, we will run some
    simple NumPy operations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 假设安装成功，它应该导入NumPy。在接下来的讨论中，我们将使用`np`作为`numpy`的别名。保持解释器窗口打开。在接下来的介绍中，我们将运行一些简单的NumPy操作。
- en: Creating array objects
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数组对象
- en: 'As noted before, a multidimensional (**N-dimensional**) array object is one
    of the core NumPy capabilities. This array is provided by a built-in class, `numpy.ndarray`.
    It represents a collection of elements of the same type. In other words, it is
    a homogeneous array. There are several ways to create a Numpy array. Type the
    following code in your Python interpreter:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，多维（**N维**）数组对象是NumPy的核心功能之一。这个数组由内置类`numpy.ndarray`提供。它表示同一类型的元素集合。换句话说，它是一个同质数组。有几种方法可以创建NumPy数组。在你的Python解释器中输入以下代码：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This creates an array instance denoted by the `x` variable with two elements.
    This is of the `numpy.ndarray` type. It is a single dimensional array. You can
    access any element or change its value, just like a Python `list`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个由`x`变量表示的数组实例，包含两个元素。这是一个`numpy.ndarray`类型的数组。它是一个一维数组。你可以访问任何元素或更改其值，就像Python的`list`一样：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this simple example, the size of the array is `2`. This is also called the
    *shape* of an array. NumPy represents the array shape as a tuple of integers.
    It gives the size of the array along each dimension. This is shown in the following
    line of code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，数组的大小是`2`。这也被称为数组的*形状*。NumPy将数组形状表示为整数元组。它给出了每个维度的数组大小。这如下面的代码行所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Continuing further, here is another example that creates a two-dimensional
    array:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 继续深入，这里还有一个创建二维数组的例子：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `ndim` represents the number of dimensions of an array. The array shape
    indicates the size of two in each dimension.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`ndim`代表数组的维度数。数组形状表示每个维度的大小。
- en: 'Let''s review the `numpy.arange` function. This is similar to the Python `range`
    function. But, `arange` returns an `array` object instead of a `list`. The following
    is another way to create an array using `numpy.arange`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下`numpy.arange`函数。这与Python的`range`函数类似。但是，`arange`返回一个`array`对象而不是`list`。以下是用`numpy.arange`创建数组的另一种方法：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are many other ways to create arrays in NumPy. Refer to the documentation,
    ([http://docs.scipy.org/doc/numpy/reference/](http://docs.scipy.org/doc/numpy/reference/))
    for more details. Specifically, look for array creation routines.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy中创建数组的方法有很多。有关更多详细信息，请参阅文档（[http://docs.scipy.org/doc/numpy/reference/](http://docs.scipy.org/doc/numpy/reference/））。特别是，查找数组创建例程。
- en: Simple array operations
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单数组操作
- en: 'We will review some basic mathematical operations that can be performed on
    NumPy arrays. Let''s create two arrays, `x` and `y` (these are one-dimensional
    arrays or vectors):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾一些可以在NumPy数组上执行的基本数学操作。让我们创建两个数组，`x`和`y`（这些是一维数组或向量）：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Using these arrays, you can perform mathematical operations, such as addition,
    subtraction, multiplication, and so on. NumPy performs all these operations element
    by element:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些数组，您可以执行数学运算，如加法、减法、乘法等。NumPy按元素逐个执行所有这些操作：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is important to note here that `x*y` is not the inner product. It is just
    a multiplication of the corresponding elements in the `x` and `y` arrays. The
    inner product of these vectors can be accomplished using the `dot` function, as
    follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意的是，`x*y`不是内积。它只是`x`和`y`数组中相应元素的乘法。这些向量的内积可以通过`dot`函数实现，如下所示：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following code illustrates the concept using a two-dimensional array. Here,
    `x2.dot(y2)` is a matrix multiplication operation:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用二维数组说明了这个概念。在这里，`x2.dot(y2)`是一个矩阵乘法操作：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Array slicing and indexing
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组切片和索引
- en: For single dimensional arrays, the **indexing** and **slicing** operations are
    similar to a Python `list`. If you are unfamiliar with the `list` slicing operation,
    refer to [https://docs.python.org/3/tutorial/introduction.html#lists](https://docs.python.org/3/tutorial/introduction.html#lists).
    This is an important concept. In this chapter, we will only need to perform a
    few basic indexing operations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一维数组，**索引**和**切片**操作与Python `list`类似。如果您不熟悉`list`切片操作，请参阅[https://docs.python.org/3/tutorial/introduction.html#lists](https://docs.python.org/3/tutorial/introduction.html#lists)。这是一个重要的概念。在本章中，我们只需要执行几个基本的索引操作。
- en: Indexing
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引
- en: 'Array indexing is essentially an operation that enables us to access a particular
    element in an array. Here is a simple one-dimensional array with a size of five:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 数组索引本质上是一种操作，使我们能够访问数组中的特定元素。这里有一个简单的一维数组，大小为五个：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The simplest indexing operation is shown below, which accesses an element of
    this array. This operation is similar to how it is done for a Python `list`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了最简单的索引操作，它访问了这个数组的一个元素。这个操作与Python `list`中的操作类似：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is how you can retrieve elements from a two-dimensional array:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您如何从二维数组中检索元素的方法：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once complete, it returns an array with only the first row.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，它返回一个只包含第一行的数组。
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'It is important to note that the basic array indexing does not return a copy
    of the original array. It just points to the same memory location as the original
    array. Refer to the following link where the basic and advanced indexing has been
    comprehensively documented: [http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html](http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，基本的数组索引不会返回原始数组的副本。它只是指向与原始数组相同的内存位置。请参阅以下链接，其中详细记录了基本和高级索引：[http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html](http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html）
- en: 'The following code will retrieve a single value from a two-dimensional array:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将从二维数组中检索一个值：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this basic introduction to array indexing, let's learn about some common
    slicing operations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在对数组索引的基本介绍之后，让我们学习一些常见的切片操作。
- en: Slicing
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切片
- en: 'Suppose you want to get an array with only the first two elements. Just like
    a `list`, you will need to specify a start and an end. For example, `b[start:stop]`
    means the resulting (sliced) array will begin at the `start` index and end at
    the `stop-1` index:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要获取只包含前两个元素的数组。就像一个`list`一样，你需要指定一个起始点和结束点。例如，`b[start:stop]`意味着结果（切片）数组将从`start`索引开始，并在`stop-1`索引结束：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Similarly, to get any array with only the elements at the positions `1` and
    `2`, you can do as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要获取只包含位置`1`和`2`的元素的任何数组，你可以这样做：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For the N-dimensional arrays, you have to give the slicing instructions in
    each direction. Consider the following array with four rows and columns:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于N维数组，你必须在每个方向上给出切片指令。考虑以下具有四行四列的数组：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s slice this array so that it returns only the first row. Here is the
    syntax to do that:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切片这个数组，使其只返回第一行。这里是实现这一点的语法：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you want to get only the first column of `z2` instead, then specify the
    slicing as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想获取`z2`的第一个列，那么可以这样指定切片：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following slicing operation will create a new array using elements of the
    first two rows and columns:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下切片操作将使用前两行和列的元素创建一个新的数组：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To gain a better understanding of array slicing operations, try more examples
    in a Python interpreter. See the documentation for details (search the Web for
    NumPy array slicing).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解数组切片操作，请在Python解释器中尝试更多示例。有关详细信息，请参阅文档（在网络上搜索NumPy数组切片）。
- en: Broadcasting
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广播
- en: 'Broadcasting is another important NumPy feature. Let''s understand this concept
    with a simple example. We have two arrays, `p0` and `p1`, as shown in the following
    example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 广播是NumPy的另一个重要特性。让我们通过一个简单的例子来理解这个概念。我们有两个数组，`p0`和`p1`，如下例所示：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The shapes of these arrays are as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数组的形状如下：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Although the arrays have different shapes, NumPy can perform arithmetic operations
    on these arrays. A basic multiplication operation is shown next:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数组具有不同的形状，NumPy可以在这些数组上执行算术运算。下面展示了一个基本的乘法操作：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is referred to as broadcasting. The `p0` array has a smaller shape relative
    to `p1`. The broadcasting enables this array to work with `p1`. In this example,
    it enables the multiplication operation. Of course, the two arrays need to meet
    certain requirements to take advantage of this feature. Refer to the NumPy documentation
    to learn more about broadcasting.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为广播。`p0`数组相对于`p1`具有较小的形状。广播使得这个数组可以与`p1`一起工作。在这个例子中，它使得乘法操作成为可能。当然，这两个数组需要满足某些要求才能利用这个特性。请参考NumPy文档以了解更多关于广播的信息。
- en: Miscellaneous functions
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他函数
- en: Let's look at some advanced mathematical operations that you can perform using
    the NumPy arrays.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你可以使用NumPy数组执行的一些高级数学运算。
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Most of the operations illustrated here will be used in the upcoming discussion
    on performance improvement using NumPy. So, pay close attention to this section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的大部分操作将在后续关于使用NumPy进行性能改进的讨论中使用。所以，请密切关注这一部分。
- en: numpy.ndarray.tolist
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: numpy.ndarray.tolist
- en: 'This is a handy function that returns the NumPy array as a Python `list` object.
    Depending on the array dimension, it can be a nested list. Here is an example
    that shows this function in action:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实用的函数，它将NumPy数组作为Python `list`对象返回。根据数组维度，它可以是嵌套列表。以下是一个展示此函数如何工作的示例：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: numpy.reshape
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: numpy.reshape
- en: 'As the name suggests, it changes the shape of an array without actually changing
    its data. Look at the following code; the `x` array is one dimensional and has
    a size (shape) of `9`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，它在不实际更改数据的情况下改变数组的形状。看看以下代码；`x`数组是一维的，大小（形状）为`9`：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s see how to reshape this into a matrix that has three rows and columns.
    In other words, the following code returns an array with a new shape of `(3,3)`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将其重塑为具有三行三列的矩阵。换句话说，以下代码返回一个形状为`(3,3)`的新数组：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The new shape selected should be compatible with the original shape of the array;
    otherwise, it will throw an error. For the preceding example, if you reshape it
    as `np.reshape(x, (3,2))`, it will throw a value error complaining about changed
    size.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 选择的新形状应该与数组的原始形状兼容；否则，它将抛出一个错误。对于前面的例子，如果你将其重塑为`np.reshape(x, (3,2))`，它将抛出一个值错误，抱怨大小已更改。
- en: numpy.random
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: numpy.random
- en: This module provides several functions for random sampling. For a detailed list,
    refer to [http://docs.scipy.org/doc/numpy/reference/routines.random.html](http://docs.scipy.org/doc/numpy/reference/routines.random.html).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块提供了几个随机抽样的函数。有关详细列表，请参阅 [http://docs.scipy.org/doc/numpy/reference/routines.random.html](http://docs.scipy.org/doc/numpy/reference/routines.random.html)。
- en: 'Let''s review `np.random.uniform` that draws samples from a uniform distribution:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 `np.random.uniform`，它从均匀分布中抽取样本：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first two arguments of this function represent the lower (`0.0`) and upper
    (`2.0`) boundaries of the output interval. You can specify any float value as
    the limit. All the random values or samples generated by the function lie within
    these two limits. The default lower and upper limits are `0.0` and `1.0`, respectively.
    The `size` argument represents the shape of the output array. In the preceding
    example, it is specified as a single integer value. If you do not specify the
    `size` argument, it defaults to `None`. In that case, the function will simply
    return a single floating point number. The following is a slightly complicated
    example of when the `size` (or shape) argument is a tuple `(2,2)`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的前两个参数代表输出区间的下限（`0.0`）和上限（`2.0`）。你可以指定任何浮点值作为限制。函数生成的所有随机值或样本都位于这两个限制之间。默认的下限和上限分别是
    `0.0` 和 `1.0`。`size` 参数代表输出数组的形状。在先前的例子中，它指定为一个单个整数值。如果你不指定 `size` 参数，它默认为 `None`。在这种情况下，函数将简单地返回一个单一的浮点数。以下是一个
    `size`（或形状）参数为元组 `(2,2)` 的稍微复杂一点的例子：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Have you already noticed a difference between Python's built-in `random.uniform`
    function and NumPy equivalent's `np.random.uniform`? The Numpy `np.random.uniform`
    function, can optionally give us an `array` object with samples drawn from uniform
    distribution, whereas the built-in `random.uniform` can only give us a single
    number. We will use this NumPy function in *optimization pass four*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否已经注意到 Python 内置的 `random.uniform` 函数和 NumPy 等效的 `np.random.uniform` 函数之间的区别？NumPy
    的 `np.random.uniform` 函数可以选择性地给我们一个包含从均匀分布中抽取的样本的 `array` 对象，而内置的 `random.uniform`
    只能给我们一个单一的数字。我们将在 *优化过程四* 中使用这个 NumPy 函数。
- en: numpy.dstack
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: numpy.dstack
- en: 'This provides a simple way to stack or concatenate a sequence of arrays along
    a third axis. Consider two NumPy arrays, `x` and `y`, representing the x and y
    coordinates of some points in space. These arrays are shown below:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一种简单的方法来沿第三个轴堆叠或连接一系列数组。考虑两个 NumPy 数组，`x` 和 `y`，它们代表空间中一些点的 x 和 y 坐标。这些数组如下所示：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Thus, `x[0]=1` and `y[0]=10` represent a point `(1, 10)`. Likewise, we can
    represent other points for the remaining elements. Sometimes, it is convenient
    to use a single array to express the coordinates of several such points, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`x[0]=1` 和 `y[0]=10` 代表一个点 `(1, 10)`。同样，我们可以为剩余的元素表示其他点。有时，使用一个单一的数组来表示这些点的坐标是很方便的，如下所示：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'How do we create such an array using the `x` and `y` arrays shown earlier?
    There are multiple ways to do this. One option is to use `numpy.dstack`. This
    function enables stacking arrays along a third axis to create a single array.
    The following code shows how to create a `points` array discussed earlier using
    the input `x` and `y` arrays:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用前面显示的 `x` 和 `y` 数组创建这样的数组？有多种方法可以做到这一点。一个选项是使用 `numpy.dstack`。此函数允许沿第三个轴堆叠数组以创建单个数组。以下代码显示了如何使用输入的
    `x` 和 `y` 数组创建前面讨论的 `points` 数组：
- en: '[PRE31]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Notice that the resultant array is three-dimensional:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，结果数组是三维的：
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The size of the array along each axis (or dimension) is given by its shape:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 沿每个轴（或维度）的数组大小由其形状给出：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We will use this function in *optimization pass five*. Similarly, there are
    other ways of stacking arrays, for example, `numpy.hstack` or `numpy.vstack`.
    These are not discussed in this book. Refer to the NumPy documentation for further
    details.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *优化过程五* 中使用此函数。同样，还有其他堆叠数组的方法，例如 `numpy.hstack` 或 `numpy.vstack`。这些在本章中未讨论。有关更多详细信息，请参阅
    NumPy 文档。
- en: numpy.einsum
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: numpy.einsum
- en: This function provides a way to compute the **Einstein notation** (or **Einstein
    summation convention**) on the input arrays for the operations (called **operands**).
    In terms of performance, this function offers great efficiency. Later in the chapter,
    we will exploit it to find the square of the distance between two points.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数提供了一种在输入数组上计算 **爱因斯坦符号**（或 **爱因斯坦求和约定**）的方法，用于操作（称为 **操作数**）。在性能方面，此函数提供了极大的效率。在章节的后面，我们将利用它来找到两点之间的距离的平方。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Understanding the mathematical concept behind `einsum` can be a bit challenging,
    especially if you do not have a math background. In that case, just remember one
    key thing about `numpy.einsum`—It is a function that allows you to perform some
    highly efficient operations involving arrays. For example, a matrix multiplication
    operation between two NumPy arrays or a dot product can be done more efficiently
    using `numpy.einsum`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 `einsum` 背后的数学概念可能有点挑战性，尤其是如果你没有数学背景的话。在这种情况下，只需记住关于 `numpy.einsum` 的一个关键点——它是一个允许你执行一些涉及数组的非常高效操作的函数。例如，两个
    NumPy 数组之间的矩阵乘法操作或点积可以使用 `numpy.einsum` 更高效地完成。
- en: Refer to the NumPy documentation for more information on this function. Also,
    see [https://en.wikipedia.org/wiki/Einstein_notation](https://en.wikipedia.org/wiki/Einstein_notation)
    for information on Einstein notation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 NumPy 文档以获取有关此函数的更多信息。有关爱因斯坦符号的信息，请参阅 [https://en.wikipedia.org/wiki/Einstein_notation](https://en.wikipedia.org/wiki/Einstein_notation)。
- en: 'This can be better explained with an example. Consider the following equations
    that represent two vectors, *A* and *B*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过一个例子来更好地解释。考虑以下表示两个向量 *A* 和 *B* 的方程：
- en: '![numpy.einsum](img/B05034_09_02.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![numpy.einsum](img/B05034_09_02.jpg)'
- en: 'These are two points in space with some *x*, *y*, and *z* coordinates. The
    dot product of these vectors is represented as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是空间中的两个点，具有一些 *x*、*y* 和 *z* 坐标。这些向量的点积表示如下：
- en: '![numpy.einsum](img/B05034_09_03.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![numpy.einsum](img/B05034_09_03.jpg)'
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To learn more about a dot product, see [https://en.wikipedia.org/wiki/Dot_product](https://en.wikipedia.org/wiki/Dot_product).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于点积的信息，请参阅 [https://en.wikipedia.org/wiki/Dot_product](https://en.wikipedia.org/wiki/Dot_product)。
- en: 'It is a scalar product and can be represented as a summation, as shown in the
    following equation:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个标量积，可以表示为以下方程中的求和，如下所示：
- en: '![numpy.einsum](img/B05034_09_04.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![numpy.einsum](img/B05034_09_04.jpg)'
- en: 'The Einstein summation convention for the preceding equation is written as
    follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方程的爱因斯坦求和约定如下所示：
- en: '![numpy.einsum](img/B05034_09_05.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![numpy.einsum](img/B05034_09_05.jpg)'
- en: Here, it is implied that *AiBi* is a summation over *i* with a lower bound of
    *1* and upper bound of *3*. This is the Einstein summation convention in a nutshell.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，隐含的是 *AiBi* 是对 *i* 的求和，下限为 *1*，上限为 *3*。这就是爱因斯坦求和约定的精髓。
- en: '`numpy.einsum` evaluates the Einstein summation convention on the given input
    arrays. The basic syntax is shown below—there are other optional arguments as
    well, but those are not shown here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.einsum` 对给定的输入数组评估爱因斯坦求和约定。以下显示了基本语法——还有其他可选参数，但在此处未显示：'
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first argument, `subscripts`, is a string that represents a list of subscript
    labels. These are separated by a comma and each label represents a dimension of
    a particular operand. In the example we just saw, there was only one subscript
    label, *i*. The second argument, `operands`, represents the input arrays (*A*
    and *B* in the example).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数，`subscripts`，是一个表示一系列下标标签的字符串。这些标签通过逗号分隔，每个标签代表特定操作数的维度。在我们刚才看到的例子中，只有一个下标标签，*i*。第二个参数，`operands`，代表输入数组（例如，例子中的
    *A* 和 *B*）。
- en: 'Suppose the *A* and *B* vectors are one dimensional. Their inner product can
    be represented with the subscript string `''i,i''`. This can be better explained
    with the following example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *A* 和 *B* 向量是一维的。它们的内积可以用下标字符串 `'i,i'` 来表示。以下是一个更好的例子来解释这一点：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The arrays `a` and `b` are one dimensional. You can also cross-check the answer
    using the `numpy.inner` function, which returns the same answer:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 数组 `a` 和 `b` 是一维的。您也可以使用 `numpy.inner` 函数来交叉检查答案，该函数返回相同的答案：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `numpy.einsum` function is faster and also memory efficient. Now, take
    a look at the following code—it represents a dot product (or matrix multiplication)
    of two vectors, `a2` and `b2`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.einsum` 函数更快，而且内存效率更高。现在，看看以下代码——它表示两个向量 `a2` 和 `b2` 的点积（或矩阵乘法）：'
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The subscript string for `numpy.einsum` is `''ij,jk''`, where `ij` is the subscript
    for two dimensions of array `a2`, and `jk` is the one for array `b2`. The dot
    product can also be obtained by following this example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.einsum` 的下标字符串为 `''ij,jk''`，其中 `ij` 是数组 `a2` 的两个维度的下标，而 `jk` 是数组 `b2`
    的下标。点积也可以通过以下示例获得：'
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Computing distance square with einsum
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 einsum 计算距离平方
- en: The examples shown so far should just give you a flavor of the `einsum` function.
    Let's only discuss how to use this function to calculate the square of the distance
    between two points. Again, for a comprehensive reference, refer to the NumPy documentation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止展示的示例应该只是给你一个关于`einsum`函数的味觉。让我们只讨论如何使用这个函数来计算两点之间的距离的平方。再次提醒，为了全面的参考，请参阅NumPy文档。
- en: 'Consider any point `p1` with coordinates (`0, 2`). Furthermore, assume that
    the center is located at (`0,` `0`). As the x coordinate of the `p1` point is
    `0`, you can easily determine the distance between `p1` and center as 2 units.
    The square of the distance can be found using the `einsum` function, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑任意一个坐标为(`0, 2`)的点`p1`。此外，假设中心位于(`0,` `0`)。由于`p1`点的x坐标是`0`，你可以很容易地确定`p1`和中心之间的距离是2个单位。距离的平方可以使用`einsum`函数找到，如下所示：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, imagine that there are multiple such points and you want to find the square
    of the distance of each point from the center. Here is one way to compute this
    using `einsum`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设有多个这样的点，并且你想找到每个点与中心的距离的平方。这是使用`einsum`计算的一种方法：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `points` array represents a list of points. For each of these points, we
    will find a vector, with `center` as its starting point and the given point (from
    the `points` array) as its end. Let''s represent the array of such vectors as
    `diff`, as shown in the following example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`points`数组代表一系列点。对于这些点中的每一个，我们将找到一个向量，以`center`作为起点，以`points`数组中的给定点作为终点。让我们将这样的向量数组表示为`diff`，如下面的示例所示：'
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As the center is (`0,0`), the `diff` array is essentially the same as the `points`
    array. The following line of code shows the `einsum` syntax—it uses the ellipsis
    notation (`…`), to the left of each term in the subscripts argument:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于中心是(`0,0`)，`diff`数组本质上与`points`数组相同。以下代码行显示了`einsum`语法——它使用省略号符号(`…`)在子脚本的每个项的左侧：
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It returns an array that contains a square of the distances for each point in
    the `points` array. That's all we need!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个包含`points`数组中每个点距离平方的数组。这就是我们需要的全部！
- en: What does this ellipsis notation do? Why didn't we use the earlier syntax?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个省略号符号表示什么？为什么我们没有使用早期的语法？
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The earlier syntax involved single dimensional arrays (`d`) that had only one
    subscript label. We cannot use it here as the operand (or the `diffs` array) for
    the Einstein sum is a two-dimensional array. To understand this, let''s look at
    the `diffs` array one more time:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的语法涉及单维数组（`d`），它只有一个下标标签。在这里我们不能使用它作为操作数（或`diffs`数组），因为爱因斯坦求和的操作数是一个二维数组。为了理解这一点，让我们再次看看`diffs`数组：
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Consider any row of this array. It is essentially a vector between a point
    and the center. For example, `[0, 2]` represents a vector between a center `[0,0]`
    and a point `[0,2]`. The other dimension of the array is to hold many such vectors.
    The ellipsis symbol, "`…`", is a convenient way to broadcast the second dimension.
    The alternative syntax to get the same result is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个数组的任意一行。它本质上是一个点和中心之间的向量。例如，`[0, 2]`代表一个中心`[0,0]`和一个点`[0,2]`之间的向量。数组的另一个维度是用来存放许多这样的向量。省略号符号"`…`"是一个方便地广播第二个维度的方式。得到相同结果的另一种语法如下：
- en: '[PRE45]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'However, if the array shapes change further, you will need to work on constructing
    a proper subscript string for the `einsum` function again. The NumPy documentation
    has several examples that show how to use `einsum`. Here is a NumPy version 1.10
    documentation: [http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.einsum.html](http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.einsum.html).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果数组形状进一步改变，你将需要再次工作于为`einsum`函数构建一个合适的下标字符串。NumPy文档中有几个示例展示了如何使用`einsum`。以下是一个NumPy
    1.10版本的文档：[http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.einsum.html](http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.einsum.html)。
- en: Where to get more information on NumPy?
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哪里可以找到更多关于NumPy的信息？
- en: In the NumPy introduction, you were presented with several links to the documentation.
    Just for the completeness, let's summarize where to find more information on NumPy.
    You can start by visiting their website ([http://www.numpy.org/](http://www.numpy.org/))
    or just do a web search on NumPy to get to its homepage.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在NumPy的介绍中，你被提供了几个指向文档的链接。为了完整性，让我们总结一下在哪里可以找到更多关于NumPy的信息。你可以从访问他们的网站([http://www.numpy.org/](http://www.numpy.org/))或在网上搜索NumPy以到达其主页开始。
- en: '**SciPy** is another project worth mentioning. It is a library that integrates
    several open source tools for mathematics, science, and engineering disciplines.
    NumPy, matplotlib, and pandas are some of its core packages. See the project website
    ([https://www.scipy.org/](https://www.scipy.org/)) for more information.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**SciPy** 是另一个值得提及的项目。它是一个集成了数学、科学和工程学科多个开源工具的库。NumPy、matplotlib和pandas是其核心包之一。更多信息请参阅项目网站([https://www.scipy.org/](https://www.scipy.org/))。'
- en: In an earlier discussion, several links were provided to the NumPy documentation.
    Looking at those links, you must have already noticed that they all point to the
    SciPy website. The documentation for both NumPy and SciPy is located at [http://docs.scipy.org/doc/](http://docs.scipy.org/doc/).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的讨论中，提供了一些指向NumPy文档的链接。查看这些链接，你一定已经注意到它们都指向SciPy网站。NumPy和SciPy的文档都位于[http://docs.scipy.org/doc/](http://docs.scipy.org/doc/)。
- en: The open source pandas library is used for data analysis using Python. It provides
    high performance data structures and tools to analyze data. Refer to [http://pandas.pydata.org/](http://pandas.pydata.org/)
    for more information.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 用于Python数据分析的开源pandas库。它提供了高性能的数据结构和工具来分析数据。更多信息请参阅[http://pandas.pydata.org/](http://pandas.pydata.org/)。
- en: Optimizing Gold Hunt – Part two
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化黄金狩猎 – 第二部分
- en: The previous section served as a short introduction to NumPy. Recall that, in
    earlier chapters, we gradually improved the runtime performance of the game. The
    last recorded timing was the one obtained with *optimization pass three*. We successfully
    reduced the total runtime down to nearly 44 seconds from the original time of
    about 106 seconds. NumPy supports vectorized calculation routines such as element-wise
    multiplication. It internally uses efficient C loops that help run such operations
    faster. Let's leverage NumPy capabilities to speed up the *Gold Hunt* game even
    further.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节简要介绍了NumPy。回想一下，在早期章节中，我们逐步提高了游戏的运行性能。最后一次记录的时间是使用**优化迭代三次**获得的时间。我们成功将总运行时间从大约106秒减少到近44秒。NumPy支持向量化计算例程，如元素级乘法。它内部使用高效的C循环，有助于加快此类操作的运行速度。让我们利用NumPy的功能，进一步加快*黄金狩猎*游戏的运行速度。
- en: Gold Hunt optimization – pass four
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黄金狩猎优化 – 第四次迭代
- en: It is now time to resume the optimization operation for the *Gold Hunt* problem.
    Let's start with *optimization pass four*. We will focus our attention once again
    on the function, `generate_random_numbers`. As a refresher, the `cProfiler` output
    of the last optimization run reported the total time as ~ 2.6 seconds and a cumulative
    time, which includes the time spent by sub-functions, was ~ 5.2 seconds*.*
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候继续对*黄金狩猎*问题进行优化操作了。让我们从**优化迭代四次**开始。我们将再次关注函数`generate_random_numbers`。作为一个复习，上次优化运行的`cProfiler`输出报告了总时间为约2.6秒，累计时间（包括子函数花费的时间）为约5.2秒**。
- en: '![Gold Hunt optimization – pass four](img/B05034_09_06.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![黄金狩猎优化 – 第四次迭代](img/B05034_09_06.jpg)'
- en: '| *You are right. For this example, it is not worth optimizing this piece of
    code. The 5.2 seconds time doesn''t look that bad. At this time, the function
    is called only once, as indicated by the* `ncalls` *column of the* `cProfile`
    *output. But any future requirements can potentially make this function a new
    bottleneck. As an example, imagine a new game scenario where there are hundreds
    of such gold fields or places full of abandoned weapons. We might need to call
    such a function many times. This will increase the total time spent in generating
    points. Keeping this in mind, let''s work on improving its performance.* |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| *你说得对。对于这个例子，优化这段代码不值得。5.2秒的时间看起来并不那么糟糕。目前，该函数只被调用一次，正如`cProfile`输出的`ncalls`列所示。但任何未来的需求都可能使这个函数成为新的瓶颈。例如，想象一个新游戏场景，其中有成百上千这样的黄金区域或充满废弃武器的场所。我们可能需要多次调用这样的函数。这将增加生成点所需的总时间。考虑到这一点，让我们努力提高其性能。*
    |'
- en: 'We will revamp the code from the previous optimization run (`goldhunt_pass3.py`).
    The supporting source code is in the `goldhunt_pass4.py` file. The first thing
    we will add is the NumPy `import` statement at the beginning of the file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新编写上次优化运行中的代码（`goldhunt_pass3.py`）。支持源代码位于`goldhunt_pass4.py`文件中。我们将首先在文件开头添加NumPy的`import`语句：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The reworked `generate_random_points` function is illustrated in the following
    code snippet:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了重新工作的`generate_random_points`函数：
- en: '![Gold Hunt optimization – pass four](img/B05034_09_07.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![黄金狩猎优化 – 第四次迭代](img/B05034_09_07.jpg)'
- en: 'It is optional to use local variables such as `l_uniform`. Those are used here
    to skip the function reevaluation. This was already discussed in the *Skipping
    the dots* section from the previous chapter. Let''s review this function next:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用局部变量，如 `l_uniform`，是可选的。这些变量在这里用于跳过函数重新评估。这已经在上一章的 *跳过点* 部分中讨论过了。让我们接下来回顾这个函数：
- en: Compare the new function with the previous implementation. The key thing to
    note here is the use of the NumPy functions, such as `np.random.uniform`, `np.sqrt`,
    and others in place of the built-in functions.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新函数与之前的实现进行比较。这里需要注意的关键点是使用 NumPy 函数，例如 `np.random.uniform`、`np.sqrt` 等，来替代内置函数。
- en: Another major difference is that we no longer need a `for` loop. The `np.random.uniform`
    function returns a NumPy array. The last argument specifies its size. Refer to
    the earlier introductory section on NumPy for more information on the `random.uniform`
    functionality.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个主要区别是我们不再需要 `for` 循环。`np.random.uniform` 函数返回一个 NumPy 数组。最后一个参数指定其大小。有关 `random.uniform`
    功能的更多信息，请参阅之前关于 NumPy 的介绍部分。
- en: The `x` and `y` coordinates are computed using the `radius` and `theta` arrays.
    Note that the variables, `x` and `y`, are created as NumPy arrays. For efficiency
    reasons, we will return these as Python lists. This is accomplished by using `numpy.ndarray.tolist()`,
    a method accessible to NumPy `array` objects.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `radius` 和 `theta` 数组计算 `x` 和 `y` 坐标。请注意，变量 `x` 和 `y` 是作为 NumPy 数组创建的。出于效率考虑，我们将以
    Python 列表的形式返回这些坐标。这是通过使用 `numpy.ndarray.tolist()` 方法实现的，该方法对 NumPy `array` 对象可用。
- en: 'Let''s profile this code and compare the performance with the previous optimization
    pass. Here is the command to execute this code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分析这段代码，并将其性能与之前的优化过程进行比较。以下是执行此代码的命令：
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The profiler output is shown next:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器的输出如下所示：
- en: '![Gold Hunt optimization – pass four](img/B05034_09_08.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![黄金狩猎优化 – 第四次迭代](img/B05034_09_08.jpg)'
- en: Observe the cumulative time column for the `generate_random_points` function.
    The cumulative time for the original function was ~ 5.2 seconds, that is now reduced
    to `0.346` seconds. This is already a significant improvement.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到 `generate_random_points` 函数的累积时间列。原始函数的累积时间约为 5.2 秒，现在已减少到 `0.346` 秒。这已经是一个显著的改进。
- en: Tip
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'It is possible to further improve the performance of the `generate_random_points`
    function. For example, at the beginning of the function, you can compute the product
    `2*l_pi`, for example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能进一步改进 `generate_random_points` 函数的性能。例如，在函数的开始处，你可以计算乘积 `2*l_pi`，例如：
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Then use this variable in the computation of `theta`. However, this will only
    result in a marginal improvement in the runtime.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在计算 `theta` 时使用这个变量。然而，这只会对运行时间产生微小的改进。
- en: Gold Hunt optimization – pass five
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黄金狩猎优化 – 第五次迭代
- en: In this optimization pass, we will further improve the runtime performance of
    the `GoldHunt.find_coins` method. The original method is shown in the following
    code snippet for convenience. You can also find it in an earlier `goldhunt_pass4.py`
    file. For more details, see the previous chapter's, *Gold Hunt Optimization –
    Pass two* section.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次优化过程中，我们将进一步改进 `GoldHunt.find_coins` 方法的运行时性能。为了方便起见，原始方法在以下代码片段中显示。你还可以在之前的
    `goldhunt_pass4.py` 文件中找到它。有关更多详细信息，请参阅上一章的 *黄金狩猎优化 – 第二次迭代* 部分。
- en: '![Gold Hunt optimization – pass five](img/B05034_09_09.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![黄金狩猎优化 – 第五次迭代](img/B05034_09_09.jpg)'
- en: Recall that the last recorded runtime for this method was about 38 seconds.
    Our task is to improve it further. We will start the optimization work by making
    a small change to the `generate_random_points` function. Recall that this function
    returns the `x` and `y` coordinates of the *gold coins* on the field as Python
    lists. Instead, let's return these as NumPy arrays.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，此方法最后记录的运行时间约为 38 秒。我们的任务是进一步改进它。我们将通过修改 `generate_random_points` 函数来开始优化工作。回想一下，这个函数返回场地上
    *金币* 的 `x` 和 `y` 坐标作为 Python 列表。相反，让我们将这些作为 NumPy 数组返回。
- en: Tip
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you have skipped reading the earlier introductory section on NumPy, now would
    be the time to go back and read it! The *optimization pass five* uses the NumPy
    functions discussed in that section. More specifically, the code presented next
    uses the `einsum` and `dpstack` functions. You may find the `einsum` syntax confusing.
    Therefore, it is recommended that you read the introduction first before diving
    into the code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跳过了之前关于 NumPy 的介绍部分，现在应该是返回去阅读它的时候了！*优化第五次迭代* 使用了该部分讨论的 NumPy 函数。更具体地说，下面的代码片段使用了
    `einsum` 和 `dpstack` 函数。你可能觉得 `einsum` 语法很复杂。因此，建议你在深入研究代码之前先阅读介绍。
- en: 'In the `find_coins` method, we will use the NumPy functions that work efficiently
    with these NumPy arrays. The following code fragment shows the updated function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `find_coins` 方法中，我们将使用与这些 NumPy 数组高效工作的 NumPy 函数。下面的代码片段显示了更新的函数：
- en: '![Gold Hunt optimization – pass five](img/B05034_09_10.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![黄金狩猎优化 – 第五次迭代](img/B05034_09_10.jpg)'
- en: 'With this change, let''s quickly review the reworked `find_coins` method next:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个修改，让我们快速回顾一下重新工作的 `find_coins` 方法：
- en: '![Gold Hunt optimization – pass five](img/B05034_09_11.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![黄金狩猎优化 – 第五次迭代](img/B05034_09_11.jpg)'
- en: 'Let''s review the preceding code snippet:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面的代码片段：
- en: Recall that our task is to find the square of the distance between any gold
    coin on the field and the center of the search circle, and then use this value
    to check if the gold coin lies inside the search circle.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回想一下，我们的任务是找到场地上任何金币与搜索圆心的距离平方，然后使用这个值来检查金币是否位于搜索圆内。
- en: The input argument, `x_list` and `y_list`, are the NumPy arrays representing
    the x and y positions of the gold coins on the field.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入参数 `x_list` 和 `y_list` 是表示金币在场地上 x 和 y 位置的 NumPy 数组。
- en: Using these coordinates, we will create a single `points` array that contains
    (x, y) coordinate pairs as its elements. This is accomplished using `numpy.dstack`.
    See the earlier introductory section on NumPy for an example usage.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这些坐标，我们将创建一个包含 (x, y) 坐标对的 `points` 数组，作为其元素。这是通过使用 `numpy.dstack` 实现的。请参阅之前关于
    NumPy 的介绍部分以获取示例用法。
- en: Next, we will find the vector between each point in the `points` array and the
    `center` array for the search circle. These vectors are stored as the elements
    of the `diff` array.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将找到 `points` 数组中每个点与搜索圆的 `center` 数组之间的向量。这些向量作为 `diff` 数组的元素存储。
- en: Using this `diff` array, we will find the square of the distances between all
    the gold coins from the center using `einsum`. See an earlier, *Computing distance
    square with einsum* section, where this was discussed in detail.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这个 `diff` 数组，我们将使用 `einsum` 计算所有金币与中心的距离平方。请参阅前面的，*使用 einsum 计算距离平方* 部分，其中对此进行了详细讨论。
- en: Finally, we will check if the gold coin lies inside the circle by comparing
    the distance squares. The `enumerate()` function is a built-in function that presents
    a cleaner way to get the current index (`i`) of the loop and the corresponding
    value (`d`).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将通过比较距离平方来检查金币是否位于圆内。`enumerate()` 函数是一个内置函数，它以更简洁的方式提供获取循环当前索引（`i`）和对应值（`d`）的方法。
- en: 'The code is ready. Now, it is time to profile it:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 代码已经准备好了。现在，是时候分析它了：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The profiler output is shown below:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是分析器的输出：
- en: '![Gold Hunt optimization – pass five](img/B05034_09_12.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![黄金狩猎优化 – 第五次迭代](img/B05034_09_12.jpg)'
- en: Observe that the cumulative time taken by the `find_coins` function has gone
    down to ~19.5 seconds from the earlier ~ 38 seconds. It is nearly a 50% improvement
    for this function alone. Also, the total runtime is now ~ 21.5 seconds compared
    to the previous timing of ~38 seconds.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到 `find_coins` 函数的累积时间已经从之前的 ~38 秒下降到 ~19.5 秒。仅对于这个函数来说，这几乎是 50% 的改进。此外，总运行时间现在是
    ~21.5 秒，而之前的计时是 ~38 秒。
- en: Tip
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'It is possible to improve the performance of `find_coins` by using list comprehension
    instead of the `for` loop. However, the improvement will be marginal. You can
    try it as an exercise (no solution is provided). Here is a sample code that uses
    list comprehension:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用列表推导而不是 `for` 循环来提高 `find_coins` 的性能。然而，这种改进将是微不足道的。你可以将其作为练习尝试（不提供解决方案）。以下是一个使用列表推导的示例代码：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Parallelization with the multiprocessing module
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 multiprocessing 模块进行并行化
- en: Before jumping onto the discussion of the `multiprocessing` module, let's first
    understand what we mean by parallelization. This will be a very short introduction
    to parallelization, just enough to understand how to use some features of the
    `multiprocessing` module.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论`multiprocessing`模块之前，让我们首先了解我们所说的并行化是什么意思。这将是一个非常简短的并行化介绍，仅足够理解如何使用`multiprocessing`模块的一些功能。
- en: Introduction to parallelization
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行化简介
- en: Imagine you are standing in a long queue at a checkout counter in a grocery
    store, waiting for your turn. Now, three more counters are opened to serve the
    customers and the existing queue is split. As a result, you can pay and get out
    of the store quickly.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你站在一家杂货店收银台的长队中，等待你的轮次。现在，又开了三个收银台来服务顾客，现有的队列被分割。结果，你可以快速付款并离开商店。
- en: Parallelization, in some sense, accomplishes similar results. In this example,
    each counter can be imagined as a separate process, carrying out independent tasks
    of accepting payments. The initial queue of the customers can be imagined as your
    program. This long queue is then divided into independent queues (or tasks), processing
    them parallely on separate counters (processes).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，并行化实现了类似的结果。在这个例子中，每个计数器可以想象成一个独立的过程，执行独立的接受支付任务。顾客的初始队列可以想象成你的程序。然后，这个长队列被分成独立的队列（或任务），在各自的计数器（进程）上并行处理。
- en: The *Gold Hunt* program we have written so far runs serially. The program executes
    a set of tasks one after another on a single processor. This is analogous to the
    single counter in the previously mentioned grocery store example. Many times,
    it is possible to split the program into smaller tasks and run them independently
    using multiple processes or threads.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止编写的**黄金狩猎**程序是顺序执行的。程序在一个单一处理器上依次执行一系列任务。这类似于之前提到的杂货店例子中的单个计数器。很多时候，可以将程序分成更小的任务，并使用多个进程或线程独立运行。
- en: Let's quickly review two broad programming models that handle parallel process
    communications. These are **shared memory** and **distributed memory** parallelization.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾两种处理并行进程通信的广泛编程模型。这些是**共享内存**和**分布式内存**并行化。
- en: Shared memory parallelization
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享内存并行化
- en: In the shared memory programming model, the parallel processes access the same
    memory segment. Thus, the exchange of data and the communication between processes
    happens through this common memory. This programming model is often referred to
    as *threaded programming*. The disadvantage of the shared memory model is something
    known as a **race condition**. Here, multiple threads compete to access or modify,
    for instance, data at a memory location. The race condition can be avoided by
    controlling access to that critical information using *locks*. However, this adds
    to the programming overhead. Refer to [https://en.wikipedia.org/wiki/Shared_memory](https://en.wikipedia.org/wiki/Shared_memory)
    for further information.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在共享内存编程模型中，并行进程访问相同的内存段。因此，数据交换和进程间的通信通过这个公共内存进行。这种编程模型通常被称为**线程编程**。共享内存模型的缺点是所谓的**竞态条件**。在这里，多个线程竞争访问或修改，例如，内存位置的数据。可以通过使用**锁**来控制对关键信息的访问来避免竞态条件。然而，这会增加编程开销。有关更多信息，请参阅[https://en.wikipedia.org/wiki/Shared_memory](https://en.wikipedia.org/wiki/Shared_memory)。
- en: Distributed memory parallelization
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分布式内存并行化
- en: Here, each process gets its own memory space. The processes do not share any
    memory resources, and they run independent of each other. The communication between
    the processes happens over inter-process communication channels. This is referred
    to as **message passing**. To learn more about message passing, see [https://en.wikipedia.org/wiki/Message_passing](https://en.wikipedia.org/wiki/Message_passing).
    Since the processes do not share the same memory space, there is an additional
    communication overhead associated with the distributed memory mechanism.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个进程都有自己的内存空间。进程之间不共享任何内存资源，并且它们独立运行。进程间的通信通过进程间通信通道进行。这被称为**消息传递**。要了解更多关于消息传递的信息，请参阅[https://en.wikipedia.org/wiki/Message_passing](https://en.wikipedia.org/wiki/Message_passing)。由于进程不共享相同的内存空间，与分布式内存机制相关的通信开销也额外增加。
- en: Global interpreter lock
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局解释器锁
- en: In Python, the `threading` module provides a high-level interface for thread
    based parallelization. To avoid the race condition discussed earlier, Python employs
    a mechanism called **global interpreter lock** (**GIL**). When a thread is executing
    a block of code, a global lock is acquired. This lock makes sure that only one
    thread is executed at a time in the Python interpreter environment. The disadvantage
    of GIL is that you cannot take full advantage of a multiprocessor machine.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，`threading`模块提供了一个基于线程的并行化的高级接口。为了避免前面讨论的竞争条件，Python采用了一种称为**全局解释器锁**（**GIL**）的机制。当一个线程正在执行代码块时，它会获取一个全局锁。这个锁确保在Python解释器环境中一次只有一个线程被执行。GIL的缺点是，你无法充分利用多核处理器。
- en: The multiprocessing module
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多进程模块
- en: The `multiprocessing` module addresses the GIL problem and provides a simple
    way to parallelize Python programs. Instead of using threads, it uses sub-processes
    and avoids GIL. In this module, the exchange of data between processes is supported
    using two communication channels, a `Queue` class and a `Pipe` function. This
    module also provides several other useful features, such as *managers* and *proxy
    objects*. The `Manager` object is created using `multiprocessing.Manager()`. It
    controls a server process that manages the Python objects. The manager also enables
    other processes to manipulate these Python objects using proxies. Discussing these
    features is beyond the scope of this book. Python documentation has great examples
    of how these features work. Refer to [https://docs.python.org/3/library/multiprocessing.html](https://docs.python.org/3/library/multiprocessing.html)
    for more information.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`模块解决了GIL问题，并为并行化Python程序提供了一种简单的方法。它不是使用线程，而是使用子进程，并避免了GIL。在这个模块中，进程间数据交换是通过两个通信通道实现的，一个`Queue`类和一个`Pipe`函数。此模块还提供了其他一些有用的功能，如*管理器*和*代理对象*。`Manager`对象是通过`multiprocessing.Manager()`创建的。它控制一个服务器进程，该进程管理Python对象。管理器还允许其他进程通过代理来操作这些Python对象。讨论这些功能超出了本书的范围。Python文档中有关于这些功能如何工作的优秀示例。有关更多信息，请参阅[https://docs.python.org/3/library/multiprocessing.html](https://docs.python.org/3/library/multiprocessing.html)。'
- en: In this chapter, we will cover only a few features of the `Pool` class.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将仅介绍`Pool`类的几个功能。
- en: The Pool class
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Pool`类'
- en: The `multiprocessing.Pool` class provides a simple approach to parallelize the
    program. It is used to manage a pool of worker processes and defines methods that
    enable various ways to run the given tasks parallely.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing.Pool`类提供了一种简单的方法来并行化程序。它用于管理一组工作进程，并定义了允许以各种方式并行运行给定任务的方法。'
- en: Tip
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The other basic approach is to use the `Process` class, which is not discussed
    in this book. See the previous documentation link for details.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种基本的方法是使用`Process`类，本书没有讨论这个类。有关详细信息，请参阅前面的文档链接。
- en: The `Pool.map` and `Pool.apply` methods are among the ones frequently used.
    These are the parallel equivalents of the Python built-in `map` and `apply` functions.
    Both these methods block the main program until a worker process is finished and
    the results are ready. The blocking nature is useful if you are interested in
    getting a sequential output from the parallel processes. They also have their
    asynchronous variants, namely `map_async` and `apply_async`. The asynchronous
    variants are better suited to run parallel jobs where you don't care about the
    order in which results are returned by the processes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool.map`和`Pool.apply`方法是经常使用的方法之一。这些是Python内置的`map`和`apply`函数的并行等效方法。这两种方法都会阻塞主程序，直到工作进程完成并且结果准备好。如果你对从并行进程中获取顺序输出感兴趣，这种阻塞特性是有用的。它们也有它们的异步变体，即`map_async`和`apply_async`。异步变体更适合运行你不在乎结果返回顺序的并行作业。'
- en: Tip
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `apply` function is no longer a built-in function in Python 3\. However,
    it was supported in Python 2.7\. You can refer to Python 2 documentation to learn
    what this function does.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`函数在Python 3中不再是内置函数。然而，它在Python 2.7中得到了支持。你可以参考Python 2文档来了解这个函数的功能。'
- en: 'Let''s work on a simple example that shows how to use the `Pool` class and
    its methods, `map` and `apply`. Observe the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来展示如何使用`Pool`类及其方法`map`和`apply`。观察以下代码：
- en: '![The Pool class](img/B05034_09_13.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![The Pool class](img/B05034_09_13.jpg)'
- en: 'Let''s review the preceding code snippet:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面的代码片段：
- en: We start by importing the `multiprocessing` module.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先导入`multiprocessing`模块。
- en: The `pool` instance is created with two worker processes. You can specify the
    number of worker processes as an optional input argument.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用两个工作进程创建`pool`实例。您可以指定工作进程的数量作为可选输入参数。
- en: After creating a pool of workers, the `pool.map` method is called. As previously
    stated, this is a parallel equivalent of the built-in `map` function. The first
    argument is a trivial function called `get_result`. This function is applied to
    the `iterable` specified as the second argument.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建工作进程池之后，调用`pool.map`方法。如前所述，这是内置`map`函数的并行等效。第一个参数是一个简单的函数`get_result`。此函数应用于作为第二个参数指定的`iterable`。
- en: In this case, the `get_result` function is applied on each element of the `numbers`
    list. Inside this function, we also print the name of the current worker process
    doing the job.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，`get_result`函数应用于`numbers`列表的每个元素。在这个函数内部，我们还打印出执行任务的当前工作进程的名称。
- en: The `pool.close()` method stops the worker processes after execution, whereas
    the `pool.join()` method blocks until the worker process terminates. This mimics
    the API provided by the `threading` module.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pool.close()`方法在执行后停止工作进程，而`pool.join()`方法阻塞，直到工作进程终止。这模仿了`threading`模块提供的API。'
- en: 'The preceding code can also be found in `pool_example.py`. In this file, you
    just need to enable the relevant code and disable the other function calls. The
    file can be run from the Command Prompt, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码也可以在`pool_example.py`文件中找到。在这个文件中，您只需要启用相关代码并禁用其他函数调用。该文件可以从命令提示符运行，如下所示：
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here is a sample command-line output after this execution:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这是执行后的一个示例命令行输出：
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Notice that the elements of the output list (`mylist`) are arranged in the same
    order as the input list (`numbers`). In other words, we have the input as `[2,
    4, 6, 8]` and the output is 10 times each element, given as `[20, 40, 60, 80]`.
    This may or may not be the case for asynchronous variants. It will depend on which
    order the processes finish and return the results for.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输出列表（`mylist`）的元素排列顺序与输入列表（`numbers`）相同。换句话说，我们有输入`[2, 4, 6, 8]`，输出是每个元素的10倍，给出`[20,
    40, 60, 80]`。对于异步变体，情况可能如此也可能不如此。这取决于进程完成并返回结果的顺序。
- en: 'With just a single line change, we can run the same example using `Pool.apply`.
    The following code snippet shows how to do this. The `get_result` function is
    not shown as it remains the same as before, as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 只需一行代码的更改，我们就可以使用`Pool.apply`运行相同的示例。下面的代码片段显示了如何做到这一点。`get_result`函数没有显示，因为它与之前相同，如下所示：
- en: '![The Pool class](img/B05034_09_14.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![Pool类](img/B05034_09_14.jpg)'
- en: 'Here, we created `mylist` using list comprehension. For each element of the
    `numbers` list, it calls the `Pool.apply` method. The first argument to the method
    is the name of the function whereas the second argument, `args`,is used to specify
    the other arguments to this function. This method offers convenient syntax to
    specify any number of arguments to the function being sent to the worker processes.
    The rest of the code and programming output remains the same, as shown in the
    `Pool.map` method example. Let''s review one of the asynchronous variants, `Pool.apply_async`.
    The code is shown as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用列表推导式创建了`mylist`。对于`numbers`列表中的每个元素，它调用`Pool.apply`方法。该方法的第一参数是函数的名称，而第二个参数`args`用于指定此函数的其他参数。此方法提供了方便的语法来指定要发送给工作进程的函数的任意数量的参数。其余的代码和编程输出保持不变，如`Pool.map`方法示例中所示。让我们回顾一下异步变体之一，`Pool.apply_async`。代码如下：
- en: '![The Pool class](img/B05034_09_15.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![Pool类](img/B05034_09_15.jpg)'
- en: 'Let''s talk through this code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这段代码：
- en: This involves two changes. The first one is a trivial one. The `apply` method
    is simply replaced with `apply_async` (shown highlighted). There is no change
    in the method syntax.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这涉及两个更改。第一个是微不足道的。将`apply`方法简单地替换为`apply_async`（如高亮显示所示）。方法语法没有变化。
- en: However, the output of the `apply_async` call does not directly give us the
    final values we need. Instead, it returns the object of a `Pool.ApplyResult` class.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，`apply_async`调用的输出并不直接给出我们需要的最终值。相反，它返回`Pool.ApplyResult`类的对象。
- en: In this example, `apply_async` is used inside a list comprehension. So, the
    elements of the `results` list are objects of the `ApplyResult` class.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，`apply_async`被用在列表推导式中。因此，`results`列表的元素是`ApplyResult`类的对象。
- en: The final value can be obtained using the `ApplyResult.get()` method. We do
    this using a list comprehension, as shown in the preceding image. Alternatively,
    you can also use the generator expression syntax discussed in the previous chapter.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终值可以通过使用`ApplyResult.get()`方法获得。我们使用列表推导，如图中所示。或者，你也可以使用前一章中讨论的生成器表达式语法。
- en: With this short introduction on parallelization, let's see how to parallelize
    some functionality from the *Gold Hunt* application.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在对并行化进行简短介绍之后，让我们看看如何将*黄金狩猎*应用程序的一些功能并行化。
- en: Parallelizing the Gold Hunt program
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行化黄金狩猎程序
- en: Looking at the previous profiler output, the `find_coins` function is still
    the main bottleneck with ~19.5 seconds of cumulative time. Let's see how parallelization
    can help speed it up further.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的分析器输出中可以看出，`find_coins`函数仍然是主要的瓶颈，累计耗时约19.5秒。让我们看看并行化如何帮助进一步加快速度。
- en: Revisiting the gold field
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视金矿场
- en: 'Here is the *gold field* image from [Chapter 7](ch07.html "Chapter 7. Performance
    – Identifying Bottlenecks"), *Performance – Identifying Bottlenecks*:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是[第7章](ch07.html "第7章。性能 – 识别瓶颈")中*性能 – 识别瓶颈*的*金矿场*图像：
- en: '![Revisiting the gold field](img/B05034_09_16.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![重新审视金矿场](img/B05034_09_16.jpg)'
- en: 'Let''s quickly summarize what we already saw in [Chapter 7](ch07.html "Chapter 7. Performance
    – Identifying Bottlenecks"), *Performance – Identifying Bottlenecks*:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速总结一下我们在[第7章](ch07.html "第7章。性能 – 识别瓶颈")中已经看到的内容，*性能 – 识别瓶颈*：
- en: The `find_coins` method is called for each of the small search circles shown
    in the figure. So, if there are 10 search circles, `find_coins` will be called
    10 times, one after the other.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_coins`方法被调用以显示图中的每个小搜索圆。因此，如果有10个搜索圆，`find_coins`将被连续调用10次。'
- en: The `find_coins` method returns the coordinates of the gold coins lying inside
    the given search circle.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_coins`方法返回给定搜索圆内金币的坐标。'
- en: The information about all such collected coins is maintained in a list object.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有这些收集到的金币信息都保存在一个列表对象中。
- en: There is one important thing to note here. It is a serial execution. You start
    with the first circle, collect the coins and move on to the next one, and repeat
    the procedure until you hit the other end of the field.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个需要注意的重要事项。这是一个串行执行。你从第一个圆开始，收集金币，然后移动到下一个，重复此过程，直到到达田野的另一端。
- en: '| *So how can we further enhance the search operation? Any thoughts, Mr. Great
    Dwarf?* |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| *那么我们如何进一步优化搜索操作呢？有什么想法吗，伟大的矮人先生？* |'
- en: '![Revisiting the gold field](img/B05034_09_17.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![重新审视金矿场](img/B05034_09_17.jpg)'
- en: '| *Perfect! The search* *operation inside each circle is independent of the
    others. Therefore, the* `find_coins` *function can be independently executed for
    each search circle. This is an ideal candidate for parallelization.* |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| *太棒了！**由于每个圆内的搜索操作与其他操作是独立的，因此`find_coins`函数可以独立于每个搜索圆执行。这是一个并行化的理想候选者。*
    |'
- en: '![Revisiting the gold field](img/B05034_09_18.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![重新审视金矿场](img/B05034_09_18.jpg)'
- en: '| *That is even better!**Since the order in which the results are returned
    (by the worker processes) is not important, we can use* `Pool.apply_async` *to
    parallelize this task.* |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| *这甚至更好！**由于结果返回的顺序（由工作进程返回）并不重要，我们可以使用* `Pool.apply_async` *来并行化这个任务。* |'
- en: Gold Hunt optimization – Pass six, parallelization
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黄金狩猎优化 – 第六次流程，并行化
- en: As a first step, you should skim through the `play` method of the last *optimization
    pass five*. Most of the changes we are about to make will be in this method. Additionally,
    we will pass some more arguments to the `find_coins` method.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，你应该浏览一下上一次**优化流程五**的`play`方法。我们即将进行的多数更改都将在这个方法中进行。此外，我们还将向`find_coins`方法传递一些额外的参数。
- en: So, we decided to use a pool of worker processes represented by a `Pool` object.
    The *work queue* of this `Pool` object consists of all the search circles inside
    the gold field shown earlier. Each worker process will parallely run the search
    operation (`find_coins`), and it doesn't depend on other search circles. Generally,
    the worker processes within a `Pool` object are not terminated until the complete
    work queue is processed. When a worker process is done finding the coins in a
    particular search circle, it may get assigned to perform this operation for another
    search circle.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们决定使用一个由`Pool`对象表示的工作进程池。这个`Pool`对象的工作队列由之前显示的金矿内的所有搜索圆组成。每个工作进程将并行运行搜索操作（`find_coins`），并且它不依赖于其他搜索圆。通常，`Pool`对象内的工作进程在处理完完整的工作队列之前不会终止。当一个工作进程完成特定搜索圆中硬币的查找后，它可能会被分配去为另一个搜索圆执行此操作。
- en: '| *So what changes are required to be done to the play method? The code will
    be very similar to the basic example of* `apply_async`*, as seen earlier. Does
    anything else need to be changed in the existing method? Our friend Elf has a
    question...* |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| *那么需要对`play`方法进行哪些更改？代码将与之前看到的`apply_async`基本示例非常相似。在现有方法中还需要更改其他内容吗？我们的朋友精灵有一个问题...*
    |'
- en: '![Gold Hunt optimization – Pass six, parallelization](img/B05034_09_19.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![金矿优化 – 第六步，并行化](img/B05034_09_19.jpg)'
- en: '| *You are spot on! The existing* `play` *method serially runs the search operation.
    It starts with the leftmost circle, finds the coins, and moves on to the next
    circle by updating* `x_ref`. *Note that we have chosen* `y_ref` *as* `0.0` *in
    this example.**When we run this search* *operation on parallel processes, each
    circle will have its unique center coordinates. We need to provide appropriate
    values of these coordinates to each parallel process. To do this, let''s remove
    the dependence on* `x_ref` *and* `y_ref`*. The center coordinates of all the circles
    will be determined and stored in a list before parallelizing the search operation.*
    |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| *你说得对！现有的* `play` *方法串行运行搜索操作。它从最左边的圆开始，找到硬币，然后通过更新* `x_ref` *移动到下一个圆。* 注意，在这个例子中，我们选择了
    `y_ref` *为* 0.0 *。**当我们并行运行这个搜索操作时，每个圆都将有其独特的中心坐标。我们需要为每个并行过程提供这些坐标的适当值。为此，让我们移除对*
    `x_ref` *和* `y_ref` *的依赖。在并行化搜索操作之前，将确定并存储所有圆的中心坐标。* |'
- en: 'The `play` method with the preceding changes is shown below:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 带有前面更改的`play`方法如下所示：
- en: '![Gold Hunt optimization – Pass six, parallelization](img/B05034_09_20.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![金矿优化 – 第六步，并行化](img/B05034_09_20.jpg)'
- en: 'Let''s talk through the important changes in this method:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下这个方法中的重要变化：
- en: In a `while` loop, we will first determine the centers of all the search circles
    and store the coordinates in a list called `x_centers`. The y coordinate (`y_ref`)
    is not updated because we have chosen it as constant `(0.0)` for all the circles.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个`while`循环中，我们首先确定所有搜索圆的中心，并将坐标存储在一个名为`x_centers`的列表中。y坐标（`y_ref`）没有更新，因为我们已经选择将其作为所有圆的常量（0.0）。
- en: In the same `while` loop, another `circle_number` list is populated to represent
    the circle id. This is just for printing purposes so that we will know which search
    operation is being performed.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在相同的`while`循环中，另一个`circle_number`列表被填充以表示圆的ID。这只是为了打印目的，这样我们就会知道正在执行哪个搜索操作。
- en: After preparing the list, a pool of worker threads is created and then `apply_async`
    is called in a list comprehension.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备好列表后，创建了一个工作线程池，然后在列表推导式中调用`apply_async`。
- en: Recall that the first argument to the `Pool.apply_async` method is the name
    of the function (`self.find_coins)`, whereas the second argument, `args`, is used
    to specify all the arguments to this function.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回想一下，`Pool.apply_async`方法的第一个参数是函数的名称（`self.find_coins`），而第二个参数`args`用于指定此函数的所有参数。
- en: The rest of the code is similar to what we saw in the introduction of the `multiprocessing`
    module. The `apply_async` call returns a list containing objects of the `ApplyResult`
    class. Then, the `get()` method of this class is used to obtain the final values.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的其余部分与我们在`multiprocessing`模块介绍中看到的内容类似。`apply_async`调用返回一个包含`ApplyResult`类对象的列表。然后，使用这个类的方法`get()`来获取最终值。
- en: Tip
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are using Python 2.7.9, you may have to create and use a global function
    as the first argument to `apply_async`. This global function can then return the
    `GoldHunt.find_coins` method. This is a workaround to avoid a `PicklingError`
    exception noticed while testing the code. For Python 3.x, there is no problem.
    This code is provided in the supplementary code bundle. See the Python 2 equivalent
    of the `goldhunt_pass6_parallel.py` file for details.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Python 2.7.9，您可能需要创建并使用一个全局函数作为`apply_async`的第一个参数。然后这个全局函数可以返回`GoldHunt.find_coins`方法。这是在测试代码时发现`PicklingError`异常的解决方案。对于Python
    3.x，没有这个问题。此代码包含在补充代码包中。有关`goldhunt_pass6_parallel.py`文件的Python 2等价物的详细信息，请参阅。
- en: Finally, there are some changes to the `GoldHunt.find_coins` method. It now
    takes the `process_x_ref` and `circle_number` functions as two new arguments.
    The `process_x_ref` function represents the x coordinate of a given search circle.
    The `process_` prefix is added just to distinguish it from `self.x_ref`, and indicate
    that its value will be different for each worker process.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对`GoldHunt.find_coins`方法进行了一些修改。现在它接受`process_x_ref`和`circle_number`函数作为两个新的参数。`process_x_ref`函数表示给定搜索圆的x坐标。添加`process_`前缀是为了区分它和`self.x_ref`，并表明其值对于每个工作进程将是不同的。
- en: Using `apply_async`, we will run this method on separate parallel processes.
    Each process gets its own circle center and number to be given as an input for
    the `find_coins` method. The method is shown in the following code snippet. The
    highlighted code indicates the changes in comparison with the previous optimization
    pass.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`apply_async`，我们将在这个单独的并行进程中运行这个方法。每个进程都有自己的圆心坐标和要提供给`find_coins`方法的数字。该方法在下面的代码片段中显示。高亮显示的代码表示与之前的优化迭代相比的变化。
- en: '![Gold Hunt optimization – Pass six, parallelization](img/B05034_09_21.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![黄金狩猎优化 – 第六次迭代，并行化](img/B05034_09_21.jpg)'
- en: 'The rest of the code remains the same as the previous optimization pass. The
    source code is provided in the `goldhunt_pass6_parallel.py` file. Let''s run this
    code and see the profiler output:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分与之前的优化迭代保持相同。源代码在`goldhunt_pass6_parallel.py`文件中提供。让我们运行这段代码并查看分析器的输出：
- en: '[PRE53]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This will print information on the search circles as it did earlier. Here is
    the profiler output:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出与之前相同的信息，以下是分析器的输出：
- en: '![Gold Hunt optimization – Pass six, parallelization](img/B05034_09_22.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![黄金狩猎优化 – 第六次迭代，并行化](img/B05034_09_22.jpg)'
- en: Note that the `find_coins` call is not shown in the profiler output. It is hidden
    inside the reported timing of the `play` method. Comparing the cumulative time
    (`cumtime`) of the `play` method should give a reasonable estimate on the performance
    gain with parallelization.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`find_coins`调用在分析器输出中没有显示。它隐藏在`play`方法报告的时间中。比较`play`方法的累积时间（`cumtime`）应该可以给出并行化带来的性能提升的合理估计。
- en: In summary, the parallelization has helped improve the total timing from earlier,
    ~21.5 seconds to ~13.5 seconds.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，并行化帮助将总时间从之前的约21.5秒减少到约13.5秒。
- en: Tip
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Depending on your machine specifications, you can try increasing the number
    of worker processes by updating the argument to the `Pool` class. For example,
    instead of three processes you can run the program with four processes. However,
    this is a simple case and the runtime is so short that you will hardly see any
    further improvement. In fact, the overhead of the sub-processes may even result
    in a slightly degraded performance. Also, depending on the problem, beyond a certain
    number of processes, the performance gain due to parallelization can fade away.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的机器配置，您可以尝试通过更新`Pool`类的参数来增加工作进程的数量。例如，您可以用四个进程而不是三个进程来运行程序。然而，这是一个简单的情况，运行时间非常短，您几乎看不到任何进一步的改进。实际上，子进程的开销甚至可能导致性能略有下降。此外，根据问题，超过一定数量的进程后，由于并行化带来的性能提升可能会逐渐消失。
- en: Other methods for parallelization
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他并行化方法
- en: 'Is the `apply_async` method the only way to parallelize this problem? Certainly
    not. There are other methods in the `multiprocessing` module that can do this
    efficiently. `Pool.starmap_async` is one such method available in Python 3.3 and
    beyond. We are not going to discuss this here, but the following code shows how
    to invoke it along with the `itertools.repeat` function:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply_async`方法是并行化这个问题的唯一方法吗？当然不是。`multiprocessing`模块中有其他方法可以有效地完成这项工作。`Pool.starmap_async`是Python
    3.3及以上版本中可用的一种方法。我们不会在这里讨论它，但以下代码展示了如何使用`itertools.repeat`函数调用它：'
- en: '[PRE54]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: For more information on such methods, refer to the `multiprocessing` module
    documentation.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于此类方法的信息，请参阅 `multiprocessing` 模块文档。
- en: Further reading
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: In the series of the three chapters on performance, we covered several important
    aspects. The things learned here will help you with the majority of common application
    performance enhancement tasks. Where do we go from here? There are some other
    important topics that you can explore, among those are JIT compilers and **Graphics
    Processing Unit** (**GPU**) programming. This section aims at providing some basic
    information on these two topics. You can follow the links provided here for further
    understanding.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于性能的三个章节系列中，我们涵盖了几个重要的方面。在这里学到的知识将帮助你完成大多数常见的应用性能提升任务。接下来我们该做什么呢？还有一些其他重要的主题你可以探索，其中包括即时编译器（JIT
    compilers）和**图形处理单元**（**GPU**）编程。本节旨在提供这两个主题的一些基本信息。你可以通过这里提供的链接进一步了解。
- en: JIT compilers
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JIT 编译器
- en: Python is an interpreted language. In simple terms, it means that the code is
    parsed and executed directly without involving any code compilation. Although
    this offers a great deal of flexibility, the program typically runs slower.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种解释语言。简单来说，这意味着代码是直接解析和执行的，而不涉及任何代码编译。虽然这提供了很大的灵活性，但程序通常运行得较慢。
- en: In high-level programming languages such as C++, the code is compiled ahead
    of time or before the execution. Generally speaking, a compiled program (C++)
    runs faster compared to the equivalent interpreted program (Python).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 C++ 这样的高级编程语言中，代码是在编译之前或执行之前编译的。一般来说，编译程序（C++）比等效的解释程序（Python）运行得更快。
- en: Thus, we have an interpreted code on one side which offers flexibility and a
    compiled code on the other that runs faster. The JIT compiler gets the best of
    both worlds. It compiles the code, but instead of compiling it ahead of execution,
    it does this just-in-time or during the program execution.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在一边有一个提供灵活性的解释代码，在另一边有一个运行速度更快的编译代码。即时编译器取两者之长。它编译代码，但不是在执行之前编译，而是在程序执行期间即时编译。
- en: PyPy is one such project that provides an alternative implementation of the
    Python language that comes with a JIT compiler. Python programs often run faster
    with PyPy. It is also memory efficient and offers high compatibility with the
    existing Python code. To learn more about PyPy, check out [http://pypy.org](http://pypy.org).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: PyPy 是这样一个项目，它提供了一个带有 JIT 编译器的 Python 语言的替代实现。Python 程序在 PyPy 上通常运行得更快。它还内存高效，并与现有的
    Python 代码具有高度的兼容性。要了解更多关于 PyPy 的信息，请查看 [http://pypy.org](http://pypy.org)。
- en: '**Numba** is another project aimed at speeding up the application. It provides
    a JIT compiler and a very simple syntax to mark a function for optimization using
    a JIT compiler. You just need to use the `numba.git()` decorator. In other words,
    add `@jit` above the function name to mark the function for optimization. If you
    are using the Anaconda Python distribution discussed in [Chapter 1](ch01.html
    "Chapter 1. Developing Simple Applications"), *Developing Simple Applications*,
    it already provides the `numba` module by default. To learn more, visit the project
    home page ([http://numba.pydata.org](http://numba.pydata.org)).'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**Numba** 是另一个旨在加速应用的计划。它提供了一个即时编译器和一个非常简单的语法来标记一个函数，以便使用即时编译器进行优化。你只需要使用 `numba.git()`
    装饰器。换句话说，在函数名上方添加 `@jit` 来标记该函数进行优化。如果你正在使用第1章中讨论的 Anaconda Python 发行版，*开发简单应用*，它默认已经提供了
    `numba` 模块。要了解更多信息，请访问项目主页 ([http://numba.pydata.org](http://numba.pydata.org))。'
- en: GPU accelerated computing
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GPU 加速计算
- en: GPU is traditionally used for applications involving heavy rendering, such as
    game applications. It is now widely used for applications involving scientific
    simulations, neural networks, financial modeling, and so on. The massively parallel
    architecture of a GPU offers tremendous performance improvement (of the order
    of 100x or more) over the CPU-based parallelization. A typical strategy is to
    identify the most compute intensive part of your application, and then send it
    to a GPU. The rest of the code can continue to use CPU. However, it is not as
    simple as it sounds, especially if you are working on a legacy code. In such cases,
    the challenge can be to make it compatible to fully utilize the GPU acceleration.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 一直被用于涉及大量渲染的应用程序，如游戏应用程序。现在它被广泛用于涉及科学模拟、神经网络、金融建模等应用程序。GPU 的海量并行架构在性能上比基于
    CPU 的并行化有巨大的提升（达到 100 倍或更多）。一个典型的策略是确定应用程序中最计算密集的部分，然后将它发送到 GPU。其余的代码可以继续使用 CPU。然而，这并不像听起来那么简单，尤其是如果你正在处理遗留代码。在这种情况下，挑战可能在于使其与
    GPU 加速完全兼容。
- en: '**PyCUDA** ([https://pypi.python.org/pypi/pycuda](https://pypi.python.org/pypi/pycuda))
    is a popular Python package that provides a wrapper to access Nvidia''s CUDA parallel
    API. CUDA is a parallel computing platform by NVIDIA. More information can be
    found at [http://www.nvidia.com/object/cuda_home_new.html](http://www.nvidia.com/object/cuda_home_new.html).'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**PyCUDA** ([https://pypi.python.org/pypi/pycuda](https://pypi.python.org/pypi/pycuda))
    是一个流行的 Python 包，它提供了一个包装器来访问 Nvidia 的 CUDA 并行 API。CUDA 是由 NVIDIA 开发的一个并行计算平台。更多信息可以在
    [http://www.nvidia.com/object/cuda_home_new.html](http://www.nvidia.com/object/cuda_home_new.html)
    找到。'
- en: '**PyOpenCL** ([https://pypi.python.org/pypi/pyopencl](https://pypi.python.org/pypi/pyopencl))
    is another Python package. It provides an easy access to the **Open Computing
    Language** (**OpenCL**) API. OpenCL is a framework for parallel computation. Refer
    to [https://en.wikipedia.org/wiki/OpenCL](https://en.wikipedia.org/wiki/OpenCL)
    for further information.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**PyOpenCL** ([https://pypi.python.org/pypi/pyopencl](https://pypi.python.org/pypi/pyopencl))
    是另一个 Python 包。它提供了一个简单的接口来访问 **Open Computing Language** (**OpenCL**) API。OpenCL
    是一个并行计算的框架。有关更多信息，请参阅 [https://en.wikipedia.org/wiki/OpenCL](https://en.wikipedia.org/wiki/OpenCL)。'
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With this chapter, we end the series of chapters focused on performance improvements.
    Let's first summarize what you learned in this chapter. We started with a basic
    introduction to the NumPy library and saw how to leverage it to further speed
    up the *Gold Hunt* application. In particular, we used the array (`numpy.ndarray`)
    data structure and other functionalities, such as `numpy.random.uniform` and `numpy.einsum`
    to achieve the speedup. The final optimization pass involved parallelizing the
    code. The chapter briefly introduced you to the basics of parallel processing.
    We used functionality from Python's `multiprocessing.Pool` class to further trim
    down the application runtime.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们结束了关于性能提升的一系列章节。让我们首先总结一下本章学到的内容。我们从 NumPy 库的基本介绍开始，看到了如何利用它来进一步加速 *Gold
    Hunt* 应用程序。特别是，我们使用了数组 (`numpy.ndarray`) 数据结构以及其他功能，如 `numpy.random.uniform` 和
    `numpy.einsum` 来实现加速。最后的优化步骤涉及并行化代码。本章简要介绍了并行处理的基础知识。我们使用了 Python 的 `multiprocessing.Pool`
    类的功能来进一步缩短应用程序的运行时间。
- en: Finally, let's summarize the three performance chapters together. We started
    by profiling the code to identify the performance bottlenecks and learned about
    the big O notation. We gradually addressed these bottlenecks to improve the application
    performance. This was accomplished by several means, ranging from changing the
    algorithm and implementing efficient data structures to using the functionality
    from a Python standard library. We further improved the runtime by using NumPy
    and also by parallelizing the code.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将三个性能章节的内容一起总结一下。我们首先对代码进行性能分析以确定性能瓶颈，并了解了大 O 表示法。我们逐步解决这些瓶颈以提高应用程序的性能。这是通过多种方式实现的，包括改变算法、实现高效的数据结构以及使用
    Python 标准库的功能。我们还通过使用 NumPy 和并行化代码进一步提高了运行时间。
- en: Tip
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The timings reported by the profiler will vary widely. It depends on your machine
    specifications, and also on the current running tasks. So, the timings observed
    in your case will likely be different than the numbers reported in this book.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器报告的时间可能会有很大的差异。它取决于你的机器规格，也取决于当前运行的任务。因此，你观察到的时间可能与本书中报告的数字不同。
- en: For the *Gold Hunt* example discussed in these chapters, the total runtime was
    reduced almost by an order of magnitude, from an initial value of about 106 seconds
    to a final runtime of nearly 13.5 seconds.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些章节中讨论的*黄金狩猎*示例，总运行时间几乎减少了一个数量级，从最初的约106秒减少到最终的近13.5秒。
- en: So far, in this book, you learned several key aspects of application development
    using command-line programs. In the final chapter, we'll see how to develop simple
    GUI applications in Python.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，你已经学习了使用命令行程序进行应用开发的几个关键方面。在最后一章，我们将看到如何使用Python开发简单的图形用户界面（GUI）应用程序。
