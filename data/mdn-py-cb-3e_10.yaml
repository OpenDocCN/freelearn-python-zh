- en: '10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '10'
- en: Working with Type Matching and Annotations
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型匹配和注释进行工作
- en: This chapter will look at how we can work with data structures that have a variety
    of data types. This often means inspecting the type of an attribute, an element
    of a tuple, or a value in a dictionary.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨我们如何与具有各种数据类型的数据结构一起工作。这通常意味着检查属性的类型、元组的一个元素或字典中的一个值。
- en: In previous chapters, we’ve avoided spending too much time on data validation
    considerations. In this chapter, we’ll look closely at validating input values
    to be sure they conform to expected data types and value ranges.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们避免过多地关注数据验证的考虑。在本章中，我们将仔细检查输入值，以确保它们符合预期的数据类型和值范围。
- en: This data validation is a kind of type-checking. It validates a narrower domain
    of values than the very broad classes of integer or string. The application must
    check the values of objects to be sure they’re valid for the intended purpose.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据验证是一种类型检查。它验证的值域比整数或字符串等非常广泛的类要窄。应用程序必须检查对象的值，以确保它们适用于预期的目的。
- en: Some data structures like JSON or XML documents can contain objects of a variety
    of data types. A common situation is summarized as First Normal Form (1NF), where
    each item in a collection is of the same type. This isn’t universal, however.
    When parsing complex files like programming language statements, we’ll see a sequence
    of distinct data types. The presence of diverse types means that the application
    software can’t simply assume a single, consistent type, but must process the available
    data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据结构，如JSON或XML文档，可以包含各种数据类型的对象。一个常见的情况可以总结为第一范式（1NF），其中集合中的每个项目都是同一类型。然而，这并不普遍。当解析复杂的文件，如编程语言语句时，我们会看到一系列不同的数据类型。不同类型的存在意味着应用程序软件不能简单地假设一个单一、一致的类型，而必须处理可用的数据。
- en: 'In this chapter, we’ll look at a number of recipes related to types and type
    matching:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨与类型和类型匹配相关的多个配方：
- en: '[Designing with type hints](ch014.xhtml#x1-5740001)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用类型提示进行设计](ch014.xhtml#x1-5740001)'
- en: '[Using the built-in type matching functions](ch014.xhtml#x1-5820002)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用内置的类型匹配函数](ch014.xhtml#x1-5820002)'
- en: '[Using the match statement](ch014.xhtml#x1-5880003)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用match语句](ch014.xhtml#x1-5880003)'
- en: '[Handling type conversions](ch014.xhtml#x1-5940004)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[处理类型转换](ch014.xhtml#x1-5940004)'
- en: '[Implementing more strict type checks with Pydantic](ch014.xhtml#x1-6000005)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用Pydantic实现更严格的类型检查](ch014.xhtml#x1-6000005)'
- en: '[Including run-time valid value checks](ch014.xhtml#x1-6060006)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[包含运行时有效值检查](ch014.xhtml#x1-6060006)'
- en: 10.1 Designing with type hints
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.1 使用类型提示进行设计
- en: Annotations in function definitions were introduced to the language syntax back
    in 2006, without any formal semantics. The annotations idea came with a list of
    potential use cases, one of which was type checking. In 2014, the idea of type
    hints were solidified and formalized into a typing module and some associated
    tools including the mypy tool.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义中的注释在2006年引入到语言语法中，没有正式的语义。注释的想法附带了一系列潜在的使用案例，其中之一是类型检查。在2014年，类型提示的想法得到了巩固和正式化，成为了一个类型模块和一些相关工具，包括mypy工具。
- en: For a few years, annotations were a general kind of syntax and type hints were
    a specific use case for annotations. By 2017, other uses for annotations were
    deprecated and the annotation syntax was expressly focused on type hints. While
    there was once a subtle difference between annotations and type hints, the distinction
    has since evaporated, leaving us with two synonyms.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，注释是一种通用的语法，类型提示是注释的一个特定用例。到2017年，注释的其他用途已被弃用，并且注释语法明确专注于类型提示。虽然注释和类型提示之间曾经存在细微的差别，但这种区别已经消失，留下了两个同义词。
- en: 'There are three important aspects of using type hints:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型提示有三个重要方面：
- en: Type hints are optional. We can write Python without type hints.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型提示是可选的。我们可以不使用类型提示来编写Python代码。
- en: Type hints can be applied gradually. Part of an application can have hints,
    where another part lacks them. Tools like mypy can tolerate mixtures of code with
    and without hints.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型提示可以逐步应用。应用程序的一部分可以有提示，而另一部分则没有。像mypy这样的工具可以容忍带有和不带有提示的代码的混合。
- en: Type hints are not used at run time and have no performance overhead.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型提示在运行时不会被使用，并且没有性能开销。
- en: Throughout this book, we’ve treated hints as essential to good software design.
    They’re as essential as unit tests and coherent documentation, both of which are
    also technically optional, but essential for trustworthy software. We’ve found
    them to help prevent problems by enforcing a level of rigor and formality.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将提示视为良好软件设计的必要条件。它们与单元测试和连贯的文档一样重要，这两者也是技术上的可选项，但对于可信赖的软件来说是必不可少的。我们发现它们通过强制执行一定程度的严谨性和正式性来帮助防止问题。
- en: 'Python’s processing relies on duck typing rules. For more background, see Chapter [8](ch012.xhtml#x1-4520008),
    specifically, the [Leveraging Python’s duck typing](ch012.xhtml#x1-4670003) recipe.
    There are two broad design patterns available to us:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Python的处理依赖于鸭子类型规则。有关更多背景信息，请参阅第[8](ch012.xhtml#x1-4520008)章，特别是[Leveraging
    Python’s duck typing](ch012.xhtml#x1-4670003)食谱。我们有两种广泛的设计模式可供选择：
- en: A strict hierarchy with a common superclass.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有共同超类的一严格层次结构。
- en: Leveraging duck typing, a collection of classes can have common features, often
    defined as a protocol that specifies the relevant features.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用鸭子类型，一组类可以具有共同特性，通常定义为指定相关特性的协议。
- en: In this recipe, we’ll look at two approaches to designing code that includes
    type hints and can be checked by tools like mypy.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将探讨两种设计包含类型提示且可由mypy等工具检查的代码的方法。
- en: 10.1.1 Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1.1 准备工作
- en: 'We’ll look at a problem that involves working with two distinct types of data
    that are mingled together in a source file. In this case, we’re going to classify
    the contents of the data directory with a large number of data files. Additionally,
    we have an src directory with a large number of sub-directories that contain application
    programs and scripts. We want to create a collection of data structures to represent
    two distinct classes of data files:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究一个涉及处理在源文件中混合在一起的两个不同类型数据的问题。在这种情况下，我们将使用具有大量数据文件的数据目录的内容进行分类。此外，我们还有一个src目录，其中包含大量包含应用程序程序和脚本的子目录。我们想要创建一组数据结构来表示两种不同的数据文件类：
- en: Data files not named by any application program or script
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未被任何应用程序程序或脚本命名的数据文件
- en: Data files that are referenced by one or more application programs
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被一个或多个应用程序程序引用的数据文件
- en: 10.1.2 How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1.2 如何做...
- en: 'There are two broad strategies for designing this kind of program:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 设计此类程序有两种广泛的方法：
- en: Sketch out the data types and transformations first, then write code to fit
    the types.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先概述数据类型和转换，然后编写代码以适应这些类型。
- en: Write code first and then add type hints to the working code.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先编写代码，然后为工作代码添加类型提示。
- en: Neither can be described as best. In many cases, the two evolve side by side.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 都不能说是最好的。在许多情况下，两者是并行发展的。
- en: We’ll look at each of these in separate variations in this recipe.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本食谱中分别查看这些内容的各种变体。
- en: Type hints first design
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 首先类型提示设计
- en: 'We’re going to work with diverse classes of objects. In this variation, we’ll
    define the type hints first, and then fill in the needed processing. Here’s how
    we can define a classifier and the related classes starting from the class definitions:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理各种类的对象。在这个变体中，我们将首先定义类型提示，然后填写所需的处理。以下是从类定义开始定义分类器和相关类的方法：
- en: Define the two subclasses. In this example, we’ll call them Unreferenced and
    Referenced files. For each class, write a sentence describing the unique purpose
    for the instances of each class. These serve as the starting point for the class
    definitions.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个子类。在这个例子中，我们将它们称为未引用文件和引用文件。对于每个类，写一句话来描述每个类实例的独特用途。这些将作为类定义的起点。
- en: 'Chose an appropriate variety of available classes. This might be an ordinary
    class with mutable attributes, a NamedTuple, or a @dataclass. Starting with a
    @dataclass often gives the most flexibility. Switching between named tuples, dataclasses,
    and frozen dataclasses involves minimal syntax changes:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择合适的可用类。这可能是一个具有可变属性的普通类、一个NamedTuple或一个@dataclass。通常从@dataclass开始可以提供最大的灵活性。在命名元组、dataclasses和冻结数据classes之间切换涉及最小的语法变化：
- en: '[PRE0]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Unreferenced class definition would be similar, with an appropriate docstring.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 未引用类定义将与适当的文档字符串相似。
- en: 'Add the attributes with values that will define the state of each instance.
    For the Referenced class, this is the Path and a collection of Path objects for
    each source file that has a reference. These two attribute definitions look like
    this:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加定义每个实例状态的属性和值。对于Referenced类，这是Path以及每个有引用的源文件的Path对象集合。这两个属性定义看起来是这样的：
- en: '[PRE1]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For the Unreferenced class, however, there really aren’t very many other attributes
    beyond the path. This raises an interesting question: does this deserve a separate
    class declaration, or can it simply be a Path object?'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于Unreferenced类，实际上并没有很多其他属性，除了路径。这提出了一个有趣的问题：这值得一个单独的类声明，还是它可以简单地是一个Path对象？
- en: 'Because Python permits type aliases and type unions, there’s no real need for
    an Unreferenced class; the existing Path will do. It is helpful to provide a type
    alias for this:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于Python允许类型别名和类型联合，实际上不需要Unreferenced类；现有的Path就足够了。提供这个类型别名是有帮助的：
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Formalize the union of these distinct classes.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正式化这些不同类的联合。
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have the type definitions, we can write a function that is an iterator
    over the ContentType union of classes. This function will yield a sequence of
    Unreferenced and Referenced objects, one for each data file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了类型定义，我们可以编写一个函数，该函数是ContentType类联合的迭代器。这个函数将产生一系列Unreferenced和Referenced对象，每个数据文件一个。
- en: 'The function might look like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可能看起来是这样的：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The datafile_iter() function skips past any non-file names in the data directory.
    It also skips some source code directories, __pycache__, and.venv. Additionally,
    we have to ignore some of the files in Chapter 10 because these files will have
    test cases that contain names of data files, creating confusing results.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: datafile_iter()函数会跳过数据目录中的任何非文件名。它还会跳过一些源代码目录、__pycache__和.venv。此外，我们必须忽略第10章中的一些文件，因为这些文件将包含数据文件名称的测试用例，从而产生令人困惑的结果。
- en: If a data file name appears in a source file, the reference is saved in the
    used_by collection. Files with a non-empty used_by collection will create a Referenced
    instance. The remaining files are Path objects; because of the TypeAlias these
    are recognized as Unreferenced instances, also. We don’t need to formally cast
    or convert a Path object to the Unreferenced type. Tools like mypy will use the
    TypeAlias to see the equivalence without any additional code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据文件名出现在源文件中，引用将被保存在used_by集合中。具有非空used_by集合的文件将创建一个Referenced实例。其余的文件是Path对象；由于TypeAlias，这些也被识别为Unreferenced实例。我们不需要正式地将Path对象转换为Unreferenced类型。像mypy这样的工具将使用TypeAlias来查看等价性，而无需任何额外的代码。
- en: The resulting iterator provides a mix of objects of distinct types. In the [Using
    the match statement](ch014.xhtml#x1-5880003) recipe, we’ll look at convenient
    ways to process objects of diverse types.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 结果迭代器提供了一系列不同类型的对象。在[使用match语句](ch014.xhtml#x1-5880003)的配方中，我们将探讨处理不同类型对象的便捷方法。
- en: Code first design
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 首先进行代码设计
- en: 'We’re going to work with diverse classes of objects. In this variation, we’ll
    define the processing first, and then fold in type hints to clarify our intent.
    Here’s how we can define a classifer and the related classes starting from a function
    definition:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理多种类的对象。在这个变体中，我们将首先定义处理程序，然后加入类型提示以阐明我们的意图。以下是从函数定义开始定义分类器和相关类的方法：
- en: 'Start with a function definition that provides the needed parameters:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从提供所需参数的函数定义开始：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Write the processing to accumulate the required data values. In this case, we
    need to iterate through the names of the data files. For each data file, we need
    to look for references in all of the source files.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写处理程序以累积所需的数据值。在这种情况下，我们需要遍历数据文件名称。对于每个数据文件，我们需要在所有源文件中查找引用。
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Decide what the various outputs from the function need to be. In some cases,
    we can yield tuple objects with the various kinds of values that are available.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定函数的各种输出需要什么。在某些情况下，我们可以产生包含各种可用值的元组对象。
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For paths without any references in the source, we yield the Path object. For
    paths that have references in the source, we can yield the data Path and a list
    of source Path instances.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于源中没有引用的路径，我们产生Path对象。对于源中有引用的路径，我们可以产生数据Path和源Path实例的列表。
- en: 'For objects with more complicated internal state, consider introducing a class
    definition to properly encapsulate the state. For this example, it makes sense
    to introduce a type for data files that have references. This would lead to replacing
    a simple, anonymous tuple with a NamedTuple like the following:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于具有更复杂内部状态的对象，考虑引入类定义以正确封装状态。对于这个例子，引入一个具有引用的数据文件类型是有意义的。这将导致用以下类似的NamedTuple替换一个简单、匿名的元组：
- en: '[PRE8]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This, in turn, leads to revising the yield statement for the Referenced instances.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这反过来又导致对Referenced实例的yield语句进行修订。
- en: '[PRE9]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Revisit the function definition to add type hints.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回顾函数定义以添加类型提示。
- en: '[PRE10]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The processing in both variants of the recipe is nearly identical. The differences
    are minor choices on how best to present the results. In the previous example,
    an explicit union named Content_Type was created. For this version, the union
    is implicit.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 调方程序的两个变体中的处理几乎相同。差异在于如何最好地呈现结果的选择。在前一个例子中，创建了一个显式的联合类型Content_Type。对于这个版本，联合类型是隐式的。
- en: 10.1.3 How it works...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1.3 它是如何工作的...
- en: Python duck typing permits a great deal of latitude in design. We can start
    with type definitions or we can start from code and add type hints. The final
    code will tend to be similar because it performs the same processing on the same
    data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Python的鸭子类型允许在设计中有很大的灵活性。我们可以从类型定义开始，也可以从代码开始并添加类型提示。最终的代码往往会相似，因为它对相同的数据执行相同的处理。
- en: The choice between a code first or type first approach may lead to an insight
    about performance or optimization. Each choice emphasizes distinct attributes
    of the final code. The code-first approach can emphasize simple processing, where
    type first might emphasize uniformity of the objects being processed. The choice
    of approach can also stem from the author’s degree of comfort with Python’s types.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 代码优先或类型优先的选择可能会导致对性能或优化的洞察。每个选择都强调最终代码的特定属性。代码优先的方法可能强调简单的处理，而类型优先可能强调正在处理的对象的统一性。选择方法也可能源于作者对Python类型的舒适度。
- en: In some cases, the process of writing the type hints may suggest algorithms
    or optimizations. This can lead to beneficial refactoring of code already written.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，编写类型提示的过程可能会暗示算法或优化。这可能导致对已编写代码的有益重构。
- en: It’s important to note that the presence or absence of type hints has no performance
    impact. Any performance gains (or losses) are ordinary design issues that might
    be made more visible through the use of type hints.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，类型提示的存在与否对性能没有影响。任何性能的提升（或损失）都是普通的设计问题，使用类型提示可能会使这些问题更加明显。
- en: 10.1.4 There’s more...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1.4 更多内容...
- en: When decomposing a large problem into smaller pieces, the interfaces among the
    smaller pieces are essential design decisions that must be made early in the design
    process. An early decision on data structures often leads to a type first design
    process overall. The externally facing components must have well-defined interfaces.
    The functions or methods that support these external components may be designed
    more freely with fewer constraints.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当将一个大问题分解成更小的部分时，小部分之间的接口是设计过程中必须早期做出的关键设计决策。对数据结构的早期决策通常会导致整体上采用类型优先的设计过程。面向外部的组件必须具有明确定义接口。支持这些外部组件的函数或方法可以设计得更加自由，约束更少。
- en: This leads to type first for the overall architecture of complicated software,
    reserving a choice of type first or code first design when working on the more
    detailed layers. When we consider distributed applications – like web services
    – where servers and clients are on separate machines, we find that type first
    is essential.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致在复杂软件的整体架构中首先考虑类型，当在更详细的层次上工作时，保留类型优先或代码优先的设计选择。当我们考虑分布式应用程序——如网络服务——其中服务器和客户端位于不同的机器上时，我们发现类型优先是必不可少的。
- en: As the volume of code grows, the importance of type hints also grows. It’s challenging
    to keep a lot of details in the space between one’s ears. Having a type hint to
    summarize a more complicated data structure can reduce the clutter of details
    around the code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 随着代码量的增加，类型提示的重要性也在增加。很难将大量细节记住在脑海中。有一个类型提示来总结更复杂的数据结构可以减少代码周围的细节杂乱。
- en: In distributed computing environments, we’ll often need to consider that some
    components may not be Python programs. In these cases, we can’t share Python type
    hints. This means we’re forced to use a schema definition that exists outside
    Python, but provides needed mappings to Python types.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式计算环境中，我们经常需要考虑某些组件可能不是 Python 程序。在这些情况下，我们无法共享 Python 类型提示。这意味着我们被迫使用存在于
    Python 之外的模式定义，但它提供了对 Python 类型的所需映射。
- en: Examples of these kinds of formal definitions that transcend languages include
    JSON Schema, Protocol Buffers, AVRO, and many others. The JSON Schema approach
    is typical, and is supported by a number of Python tools. Later in this chapter,
    we’ll look at using Pydantic, which has support for defining data using JSON Schema.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 跨越语言的这类正式定义的例子包括 JSON Schema、Protocol Buffers、AVRO 以及许多其他。JSON Schema 方法是典型的，并且被许多
    Python 工具支持。在本章后面，我们将探讨使用 Pydantic，它支持使用 JSON Schema 定义数据。
- en: 10.1.5 See also
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1.5 参见
- en: In the [Reading JSON and YAML documents](ch015_split_001.xhtml#x1-6520006) recipe
    in Chapter [11](ch015_split_000.xhtml#x1-61500011), we’ll return to using JSON
    documents for complicated data.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第[11](ch015_split_000.xhtml#x1-61500011)章的[阅读 JSON 和 YAML 文档](ch015_split_001.xhtml#x1-6520006)配方中，我们将重新使用
    JSON 文档来处理复杂数据。
- en: In the [Using the match statement](ch014.xhtml#x1-5880003) recipe, later in
    this chapter, we’ll look at how to use the match statement to process data of
    a variety of types. This makes it relatively easy to work with unions of types.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章后面的[使用 match 语句](ch014.xhtml#x1-5880003)配方中，我们将探讨如何使用 match 语句处理各种类型的数据。这使得处理类型联合相对容易。
- en: In the [Implementing more strict type checks with Pydantic](ch014.xhtml#x1-6000005)
    recipe, later in this chapter, we’ll look at stronger type definitions using the
    pydantic package.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章后面的[使用 Pydantic 实现更严格的类型检查](ch014.xhtml#x1-6000005)配方中，我们将探讨使用 pydantic 包进行更强的类型定义。
- en: 10.2 Using the built-in type matching functions
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.2 使用内置类型匹配函数
- en: When we have a collection of objects with mixed types, we often need to distinguish
    among the types. When working with classes that we’ve defined, it’s possible to
    define classes that are properly polymorphic. This is not generally the case when
    working with Python’s internal objects, or working with collections of data that
    involve a mixture of classes we’ve defined, and built-in classes that are part
    of Python.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们有一个混合类型的对象集合时，我们通常需要区分这些类型。当我们使用自己定义的类时，我们可以定义正确多态的类。这通常不是使用 Python 的内部对象或处理涉及我们定义的类和
    Python 内置类的数据集合的情况。 '
- en: 'When working entirely with our own classes, we can design them to have common
    methods and attributes, but offer distinct behavior depending on which of the
    subclasses is involved. This kind of design fits the ”L” design principle in the
    S.O.L.I.D design principles: the Liskov Substitution Principle. Any of the subclasses
    can be used in place of the superclass, because they all have a common set of
    method definitions. For more information on this, see Chapter [8](ch012.xhtml#x1-4520008).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完全使用自己的类时，我们可以设计它们具有共同的方法和属性，但根据涉及哪个子类提供不同的行为。这种设计符合 S.O.L.I.D 设计原则中的“L”原则：Liskov
    替换原则。任何子类都可以替换基类使用，因为它们都有一个共同的方法定义集。有关更多信息，请参阅第[8](ch012.xhtml#x1-4520008)章。
- en: 'This kind of abstraction-driven design is not always needed with Python. Because
    of Python’s duck-typing, designs don’t require a common superclass. In some cases,
    it isn’t even practical: we may have diverse types without a unifying abstraction.
    It’s very common to work with mixtures of objects from built-in classes, as well
    as objects from our own class definitions. We can’t impose polymorphism on the
    built-in classes.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种以抽象驱动的设 计在 Python 中并不总是需要的。由于 Python 的鸭子类型，设计不需要一个共同的基类。在某些情况下，这甚至不切实际：我们可能有多种类型而没有统一的抽象。与内置类以及我们自己的类定义中的对象混合工作是非常常见的。我们不能对内置类施加多态性。
- en: How can we leverage the built-in functions to write functions and methods that
    are flexible with respect to type? For this recipe, we’ll reuse the processing
    from the [Designing with type hints](ch014.xhtml#x1-5740001) recipe earlier in
    this chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何利用内置函数来编写对类型灵活的函数和方法？对于这个配方，我们将重用本章前面[使用类型提示进行设计](ch014.xhtml#x1-5740001)配方中的处理。
- en: 10.2.1 Getting ready
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2.1 准备工作
- en: 'In the [Designing with type hints](ch014.xhtml#x1-5740001) recipe, we defined
    a function datafile_iter() that emitted two distinct types of objects: Path objects
    and Referenced objects. A Referenced object was a bundle of Path instances, showing
    a data file that was used by one or more application programs. A stand-alone Path
    object was a data file not used by any application program. These unreferenced
    paths are candidates for removal to reduce clutter.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在[使用类型提示进行设计](ch014.xhtml#x1-5740001)的配方中，我们定义了一个名为datafile_iter()的函数，该函数发出两种不同的对象：Path对象和Referenced对象。一个Referenced对象是一组Path实例的集合，显示一个被一个或多个应用程序使用的数据文件。一个独立的Path对象是一个未被任何应用程序使用的数据文件。这些未引用的路径是移除以减少杂乱的对象。
- en: We need to process these two classes of objects in distinct ways. They’re created
    by a single generator function, datafile_iter(). This function emits a sequence
    of Unreferenced and Referenced instances. This mixture means an application must
    filter objects by their type.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以不同的方式处理这两类对象。它们由单个生成函数datafile_iter()创建。此函数发出一系列未引用和引用实例。这种混合意味着应用程序必须通过类型过滤对象。
- en: 'The application will work with a sequence of objects. These will be created
    by a function with the following definition:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将与一系列对象一起工作。这些对象将由以下定义的函数创建：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The datafile_iter() function will produce a sequence of Unreferenced and Referenced
    objects. This will reflect the current state of files in a given directory. Some
    will have references in source code; others will lack any references. See the
    [Designing with type hints](ch014.xhtml#x1-5740001) recipe for this function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: datafile_iter()函数将生成一系列未引用和引用的对象。这将反映给定目录中文件的状态。一些将在源代码中有引用；其他则没有任何引用。请参阅[使用类型提示进行设计](ch014.xhtml#x1-5740001)配方中的此函数。
- en: 10.2.2 How to do it...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2.2 如何操作...
- en: 'The application function to do analysis will consume objects of a variety of
    types. The function is designed as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 执行分析的应用程序函数将消费各种类型的对象。该函数设计如下：
- en: 'Start with a definition like the following that shows the types consumed:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下定义开始，该定义显示了消耗的类型：
- en: '[PRE12]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create an empty list that will hold the data files that have references. Write
    the for statement to consume objects from the source iterable, and populate that
    list:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空列表，该列表将保存具有引用的数据文件。编写for语句以从源可迭代对象中消费对象，并填充该列表：
- en: '[PRE13]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To distinguish objects by type, we can use the isinstance() function to see
    if an object is a class of a given type.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了通过类型区分对象，我们可以使用isinstance()函数来查看一个对象是否是给定类型的类。
- en: 'To distinguish the class, use the isinstance() function:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要区分类，请使用isinstance()函数：
- en: '[PRE14]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'While it’s technically unnecessary, it always seems prudent to include an else
    condition to raise an exception in the unlikely event that the datafile_iter function
    was changed in some astonishing way:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然技术上是不必要的，但似乎总是明智地包括一个else条件，在不太可能的情况下，如果datafile_iter函数以某种惊人的方式更改，则引发异常：
- en: '[PRE15]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For more about this design pattern, see the [Designing complex if...elif chains](ch006_split_000.xhtml#x1-1170005)
    recipe in Chapter [2](ch006_split_000.xhtml#x1-840002).
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于此设计模式的更多信息，请参阅第[2](ch006_split_000.xhtml#x1-840002)章中的[设计复杂的if...elif链](ch006_split_000.xhtml#x1-1170005)配方。
- en: 'Write the final summary:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写最终的总结：
- en: '[PRE16]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 10.2.3 How it works...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2.3 它是如何工作的...
- en: The isinstance() function examines an object to see what classes it belongs
    to. The second argument can be single class or a tuple of alternative classes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: isinstance()函数检查一个对象属于哪些类。第二个参数可以是单个类或替代类的元组。
- en: It’s important to note that an object often has a number of parent classes,
    forming a lattice, stemming from the class object. If multiple inheritance is
    being used, there can be a large number of paths through the super class definitions.
    The isinstance() function examines all the alternative parent classes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，一个对象通常有许多父类，形成一个从类对象起源的晶格。如果使用多重继承，可以通过超级类定义有大量的路径。isinstance()函数检查所有替代父类。
- en: The isinstance() function is aware of TypeAlias names in addition to the classes
    imported and defined within the application. This gives us a great deal of flexibility
    to use meaning names in type hints.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: isinstance()函数不仅了解在应用程序中导入和定义的类，还了解TypeAlias名称。这为我们提供了很大的灵活性，可以在类型提示中使用有意义的名称。
- en: 'In Python 3.12, the TypeAlias construct can be replaced with the new type statement:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.12中，TypeAlias构造可以替换为新的type语句：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'See [Mypy Issue #15238](https://github.com/python/mypy/issues/15238) for more
    information on support for the type statement by the mypy tool.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '有关mypy工具对类型语句的支持的更多信息，请参阅[Mypy Issue #15238](https://github.com/python/mypy/issues/15238)。'
- en: Until this is resolved, we’ve elected to use TypeAlias in this book.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题得到解决之前，我们选择在这本书中使用TypeAlias。
- en: 10.2.4 There’s more...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2.4 更多内容...
- en: The isinstance() function is the kind of Boolean function that works well with
    the filter() higher-order function. For more information, see the [Picking a subset
    – three ways to filter](ch013_split_000.xhtml#x1-5270004) recipe in Chapter [9](ch013_split_000.xhtml#x1-5020009).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: isinstance()函数是与filter()高阶函数配合得很好的布尔函数。有关更多信息，请参阅第九章（ch013_split_000.xhtml#x1-5270004）中的[选择子集
    – 三种过滤方式](ch013_split_000.xhtml#x1-5020009)配方。
- en: 'In addition to the built-in isinstance() to interrogate objects, there is also
    a issubclass() function that lets an application examine type definitions. It’s
    important to distinguish between instances of a class and a class object; the
    issubclass() function is used to examine type definitions. The issubclass() function
    is often used for metaprogramming: software that’s concerned with software rather
    than the application data. When designing functions that work with types of objects,
    rather than objects, the issubclass() function is necessary.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置的isinstance()函数用于查询对象外，还有一个iscsubclass()函数允许应用程序检查类型定义。区分类的实例和类对象很重要；iscsubclass()函数用于检查类型定义。iscsubclass()函数通常用于元编程：关注软件本身而不是应用程序数据的软件。当设计处理对象类型的函数而不是对象时，iscsubclass()函数是必要的。
- en: When examining the type of objects, the match statement is often a better choice
    than the isinstance() function. The reason is that a match statement’s case clause
    has very sophisticated type pattern matching, where the isinstance() function
    is limited to ensuring the object has a given class (or a class in a tuple of
    classes) in its parents.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查对象类型时，match语句通常比isinstance()函数更好。原因是match语句的case子句具有非常复杂的类型模式匹配，而isinstance()函数仅限于确保对象在其父类中具有给定的类（或类元组中的类）。
- en: 10.2.5 See also
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2.5 另请参阅
- en: See the [Using the match statement](ch014.xhtml#x1-5880003) recipe for an alternative
    to this, using the match statement.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关替代方案，请参阅[使用match语句](ch014.xhtml#x1-5880003)配方。
- en: See Chapter [7](ch011_split_000.xhtml#x1-3760007) and Chapter [8](ch012.xhtml#x1-4520008)
    for several recipes related to playing cards and the interesting class hierarchies
    they involve.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关与玩牌和它们所涉及的有趣类层次结构相关的多个配方，请参阅第七章（ch011_split_000.xhtml#x1-3760007）和第八章（ch012.xhtml#x1-4520008）。
- en: 10.3 Using the match statement
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.3 使用match语句
- en: 'One important reason for defining a collection of closely-related types is
    to distinguish the processing that applies to the objects. One technique for providing
    distinct behavior is by using a polymorphic design: a number of subclasses provide
    distinct implementations of a common function. When working entirely with our
    own classes, we can design them to have common methods and attributes, but offer
    distinct behavior depending on which of the subclasses is involved. This is covered
    in Chapter [8](ch012.xhtml#x1-4520008).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一组紧密相关的类型的一个重要原因是为了区分应用于对象的处理方式。提供不同行为的一种技术是通过使用多态设计：多个子类提供了对公共函数的不同实现。当我们完全使用自己的类时，我们可以设计它们具有共同的方法和属性，但根据涉及哪个子类提供不同的行为。这一点在第八章（ch012.xhtml#x1-4520008）中有详细说明。
- en: This is not generally possible when working with Python’s internal objects,
    or when working with collections of data that involve a mixture of classes we’ve
    defined, and built-in classes that are part of Python. In these cases, it’s simpler
    to rely on type matching to implement distinct behaviors. One approach was shown
    in the [Using the built-in type matching functions](ch014.xhtml#x1-5820002) recipe
    in this chapter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当与Python的内部对象一起工作，或者与涉及我们定义的类和Python内部部分内置类的数据集合一起工作时，通常不可能实现这一点。在这些情况下，简单地依赖类型匹配来实现不同的行为会更简单。本章中[使用内置类型匹配函数](ch014.xhtml#x1-5820002)配方中展示了一种方法。
- en: We can also use the match statement to write functions and methods that are
    flexible and work with argument values of a variety of types. For the recipe,
    we’ll reuse the processing from the [Designing with type hints](ch014.xhtml#x1-5740001)
    and [Using the built-in type matching functions](ch014.xhtml#x1-5820002) recipes
    earlier in this chapter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用match语句来编写灵活的函数和方法，这些函数和方法可以处理各种类型的参数值。对于这个配方，我们将重用本章前面提到的[使用类型提示进行设计](ch014.xhtml#x1-5740001)和[使用内置类型匹配函数](ch014.xhtml#x1-5820002)配方中的处理过程。
- en: 10.3.1 Getting ready
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3.1 准备工作
- en: 'In the [Designing with type hints](ch014.xhtml#x1-5740001) recipe, we defined
    a datafile_iter() function that emitted two distinct types of objects: Path objects
    and Referenced objects.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在[使用类型提示进行设计](ch014.xhtml#x1-5740001)配方中，我们定义了一个datafile_iter()函数，该函数发出两种不同的对象类型：Path对象和Referenced对象。
- en: We need to process these two classes of objects in distinct ways. This mixture
    means an application must filter them by their type.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以不同的方式处理这两种类型的对象。这种混合意味着应用程序必须通过它们的类型来过滤它们。
- en: 10.3.2 How to do it...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3.2 如何做...
- en: 'The application will work with a sequence of objects of distinct types. The
    function is designed as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将处理一系列不同类型的对象。函数设计如下：
- en: 'Start with a definition like the following that shows the types consumed:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下定义开始，显示消耗的类型：
- en: '[PRE18]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function will consume an iterable sequence of objects. This function will
    count the ones that have references. It will suggest deleting the files with no
    references.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数将消耗一个对象的可迭代序列。这个函数将计算具有引用的对象数量。它将建议删除没有引用的文件。
- en: 'Create an empty list that will hold the data files that have references. Write
    the for statement to consume objects from the source iterable:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空列表，用于存储具有引用的数据文件。编写for语句以从源可迭代中消耗对象：
- en: '[PRE19]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Write the start of the match statement with the file variable:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用文件变量开始编写match语句：
- en: '[PRE20]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To process a file of the various classes, create case statements that show
    the kinds of objects that must be matched. These cases are indented within the
    match statement:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要处理各种类别的文件，创建显示必须匹配的对象类型的case语句。这些case语句在match语句内缩进：
- en: '[PRE21]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'While it’s technically unnecessary, it always seems prudent to include a case _:
    condition. The _ will match anything. The body of this clause can raise an exception
    in the unlikely event that the datafile_iter function was changed in some astonishing
    way:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '虽然技术上不是必需的，但似乎总是明智地包括一个case _: condition。_将匹配任何内容。在这个子句的主体中，如果datafile_iter函数以某种惊人的方式被更改，可能会抛出异常：'
- en: '[PRE22]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For more about this design pattern, see the [Designing complex if...elif chains](ch006_split_000.xhtml#x1-1170005)
    recipe in Chapter [2](ch006_split_000.xhtml#x1-840002).
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多关于这种设计模式的信息，请参阅第[2](ch006_split_000.xhtml#x1-840002)章中的[设计复杂的if...elif链](ch006_split_000.xhtml#x1-1170005)配方。
- en: 'Write the final summary:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写最终的总结：
- en: '[PRE23]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 10.3.3 How it works...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3.3 它是如何工作的...
- en: 'The match statement uses a sequence of case clauses to establish a class that
    matches the given object. While there are a wide variety of case clauses, one
    common case is the case class() as name: variant, called the class pattern. Within
    (), we can provide sub-patterns to match objects with specific kinds of parameters.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 'match语句使用一系列case子句来建立与给定对象匹配的类。虽然存在许多不同的case子句，但一个常见的case是case class() as name:
    variant，称为类模式。在括号内，我们可以提供子模式来匹配具有特定参数类型的对象。'
- en: For this example, we didn’t need the more sophisticated matching patterns. We
    can provide what looks like an instance – made from the class name and() – to
    show that the case clause will match an instance of the class. No additional detail
    regarding the structure of the instance is necessary.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们不需要更复杂的匹配模式。我们可以提供一个看起来像实例的东西——由类名和()组成——以表明case子句将匹配类的实例。不需要有关实例结构的任何额外细节。
- en: The use of case Unreferenced() almost looks as if the expression Unreferenced()
    will create an instance of the Unreferenced class. The intent here is not to create
    an object, but to write an expression that looks very much like object creation.
    This syntax helps to clarify the intent of using the case to match any object
    of the named class.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: case Unreferenced()的使用几乎看起来像表达式Unreferenced()将创建Unreferenced类的一个实例。这里的意图不是创建一个对象，而是编写一个看起来非常像对象创建的表达式。这种语法有助于阐明使用case来匹配命名类中任何对象的意图。
- en: Other patterns are available that allow matching simple literal values, sequences,
    and mappings, as well as classes. Further, there are ways to provide groups of
    alternatives, and even apply additional filtering via a guard condition that’s
    used in conjunction with the pattern matching.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 其他模式允许匹配简单的字面值、序列和映射，以及类。此外，还有方法提供替代方案组，甚至可以通过与模式匹配一起使用的守卫条件应用额外的过滤。
- en: The case _ clause is a wildcard clause. It will match anything provided in the
    match statement. The _ variable name has special significance here, and only this
    variable can be used.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: case _子句是一个通配符子句。它将匹配在匹配语句中提供的任何内容。_变量名在这里有特殊意义，并且只能使用这个变量。
- en: Central to this design is the clarity of the case definitions. These are much
    more readable than isinstance() function evaluation in a series of elif clauses.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计的关键是case定义的清晰性。这些比一系列elif子句中的isinstance()函数评估更易于阅读。
- en: 10.3.4 There’s more...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3.4 更多内容...
- en: We’ll extend this recipe to show some of the sophisticated type matching available
    in these case clauses. Consider the case where we want to separate a referenced
    file that has only a single item in the list of applications that refer to it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展这个配方，展示这些case子句中一些复杂的类型匹配。考虑我们想要从只包含一个引用它的应用程序列表中的引用文件中分离出来的情况。
- en: 'We’re looking for objects that look like this specific example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在寻找看起来像这个具体示例的对象：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This case can be summarized as Referenced(_, [Path()]). We want to match an
    instance of the Referenced class where the second parameter is a list with a single
    Path instance.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况可以总结为Referenced(_, [Path()])。我们想要匹配一个Referenced类的实例，其中第二个参数是一个包含单个Path实例的列表。
- en: 'This turns into a new case clause. Here’s the new, more specific case, followed
    by the more general case:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这变成了一个新的case子句。以下是新的、更具体的case子句，后面跟着更一般的case子句：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The match statement works through the cases in order. The more-specific cases
    must precede the less-specific cases. If we flip the order of these two cases,
    case Referenced() would match before case Referenced(_, [Path()]) would even be
    examined. The most general case, case _: must be last.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配语句按顺序处理情况。更具体的情况必须先于更不具体的情况。如果我们颠倒这两个情况的顺序，case Referenced()将先匹配，而case Referenced(_,
    [Path()])甚至不会被检查。最一般的情况，case _:，必须是最后的。
- en: 10.3.5 See also
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3.5 参考信息
- en: See the [Using the built-in type matching functions](ch014.xhtml#x1-5820002)
    recipe for an alternative approach using the built-in isinstance() function.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[使用内置类型匹配函数](ch014.xhtml#x1-5820002)的配方，了解使用内置isinstance()函数的替代方法。
- en: See Chapter [8](ch012.xhtml#x1-4520008) for several recipes related to polymorphic
    class design. Sometimes, this can reduce the need for type matching.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅第[8](ch012.xhtml#x1-4520008)章，了解与多态类设计相关的几个配方。有时，这可以减少对类型匹配的需求。
- en: 10.4 Handling type conversions
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.4 处理类型转换
- en: One of the useful features of Python is the ”numeric tower” idea. See The Numeric
    Tower in the Python standard library documentation. The idea is that numeric values
    can move ”up” the tower from integral to rational to real to complex.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Python的一个有用特性是“数值塔”概念。请参阅Python标准库文档中的数值塔。这个概念是指数值可以从整数移动到有理数，再到实数，最后到复数，沿着塔“向上”移动。
- en: 'The numeric conversions are based on the idea that there are a several overlapping
    domains of numbers. These include ℤ integers, ℚ rational numbers, ℙ irrational
    numbers, ℝ real numbers, and ℂ complex numbers. The idea is that these form a
    nested series of sets: ℤ ⊂ℚ ⊂ℝ ⊂ℂ. Also, ℚ ∪ℙ = ℝ: the real numbers include rational
    and irrational numbers.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 数值转换基于这样的想法，即存在几个重叠的数值域。这些包括ℤ整数、ℚ有理数、ℙ无理数、ℝ实数和ℂ复数。这些形成了一个嵌套的集合系列：ℤ ⊂ℚ ⊂ℝ ⊂ℂ。此外，ℚ
    ∪ℙ = ℝ：实数包括有理数和无理数。
- en: 'These built-in numeric types follow the abstract concepts:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内置的数值类型遵循抽象概念：
- en: ℂ is implemented by the complex type. Any of the types below this type can be
    converted to a complex value.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ℂ通过复数类型实现。任何低于此类型的类型都可以转换为复数值。
- en: ℝ is supported by the float type. It’s important to note that float involves
    approximations, and doesn’t fully match the mathematical ideal of real numbers.
    When an operator in this class encounters int or fraction values, it will create
    the equivalent float value.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ℝ由float类型支持。需要注意的是，float涉及近似，并不完全符合实数的数学理想。当这个类中的运算符遇到int或分数值时，它将创建等效的float值。
- en: ℚ uses the Fraction class in the fractions module. When an arithmetic operator
    in the Fraction class encounters an int it will quietly create a Fraction with
    the same value as the integer. ![z 1](img/file73.png) = z.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ℚ使用fractions模块中的Fraction类。当Fraction类中的算术运算符遇到int时，它将静默地创建一个与整数具有相同值的Fraction。![z
    1](img/file73.png) = z。
- en: ℤ is the int class.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ℤ是int类。
- en: Generally, the Python language avoids too many conversions to other types. Strings,
    for example, are not automatically parsed to create numeric values. An explicit
    built-in function like int() or float() needs to be used to process strings with
    numbers.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Python语言避免过多地转换为其他类型。例如，字符串不会自动解析以创建数值。需要使用显式的内置函数如int()或float()来处理包含数字的字符串。
- en: 'We’ll often want our own types to share this kind of behavior. We’d like our
    functions to be flexible, and convert objects to other types when needed. We may,
    for example, want to permit a number of representations for a latitude-longitude
    point. These alternatives might include:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常希望自己的类型共享这种行为。我们希望我们的函数是灵活的，并在需要时将对象转换为其他类型。例如，我们可能希望允许纬度-经度点的多种表示。这些替代方案可能包括：
- en: A tuple of two floating-point numeric values
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含两个浮点数值的元组
- en: A pair of strings, with each string representing a floating-point value
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对字符串，每个字符串代表一个浮点值
- en: A single string with two numeric values separated by a "," character
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含两个由逗号字符分隔的数值的单个字符串
- en: As with the numeric tower, our own class definitions need to convert other types
    into the needed target type.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与数值塔一样，我们自己的类定义需要将其他类型转换为所需的目标类型。
- en: 10.4.1 Getting ready
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4.1 准备工作
- en: We’ll consider a function to compute distances between points on the surface
    of the Earth. This involves some clever spherical trigonometry. For more information,
    see Chapter [3](ch007_split_000.xhtml#x1-1610003), specifically, the [Picking
    an order for parameters based on partial functions](ch007_split_001.xhtml#x1-1940006)
    recipe. Also see the [Creating contexts and context managers](ch011_split_001.xhtml#x1-43700011)
    recipe in Chapter [7](ch011_split_000.xhtml#x1-3760007).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑一个计算地球上表面两点之间距离的函数。这涉及到一些巧妙的球面三角学。更多信息，请参阅第[3](ch007_split_000.xhtml#x1-1610003)章，特别是[基于部分函数选择参数顺序](ch007_split_001.xhtml#x1-1940006)配方。还可以参阅第[7](ch011_split_000.xhtml#x1-3760007)章中的[创建上下文和上下文管理器](ch011_split_001.xhtml#x1-43700011)配方。
- en: 'The function is defined as:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义如下：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This definition requires converting source data into individual float values.
    In applications that integrate data from a number of sources, these conversions
    are so common that it seems better to centralize them into a function that wraps
    the essential haversine() computation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义需要将源数据转换为单个浮点值。在集成来自多个源的数据的应用中，这些转换非常常见，因此最好将它们集中到一个封装基本haversine()计算的函数中。
- en: 'We want a function like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个这样的函数：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This function will compute distances among points defined as a variety of data
    types. The *args parameter means all of the positional argument values will be
    combined into a single tuple. A number of validation rules must be applied to
    make sense of this tuple. Here are the rules we’ll start with: Four float values:
    use these directly. Example: distance(36.12, -86.67, 33.94, -118.40, R=6372.8).
    Four strings: convert these to float. Example: distance("36.12", "-86.67", "33.94", "-118.40", R=6372.8).
    two strings: parse each string, breaking on a ”,”. Each string should have two
    float values. Example: distance("36.12,-86.67", "33.94,-118.40", R=6372.8). Two
    tuples: unpack each tuple to make sure it has two float values. Example: distance((36.12, -86.67), (33.94, -118.40), R=6372.8).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将计算定义为各种数据类型的点之间的距离。*args参数意味着所有位置参数值将组合成一个单一的元组。必须应用一系列验证规则来理解这个元组。以下是我们将开始的规则：四个浮点值：直接使用这些值。例如：distance(36.12,
    -86.67, 33.94, -118.40, R=6372.8)。四个字符串：将这些字符串转换为浮点值。例如：distance("36.12", "-86.67",
    "33.94", "-118.40", R=6372.8)。两个字符串：解析每个字符串，以逗号分隔。每个字符串应包含两个浮点值。例如：distance("36.12,-86.67",
    "33.94,-118.40", R=6372.8)。两个元组：解包每个元组以确保它包含两个浮点值。例如：distance((36.12, -86.67),
    (33.94, -118.40), R=6372.8)。
- en: Ideally, it might be nice to support combinations of these, also. We’ll design
    a function that performs the needed type conversions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，也许支持这些组合也不错。我们将设计一个执行所需类型转换的函数。
- en: 10.4.2 How to do it...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4.2 如何实现...
- en: 'A function that includes type conversions is often built separately from the
    underlying processing. It can help testing and debugging if these two aspects
    of processing – conversions and computations – are separated:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 包含类型转换的函数通常与底层处理分开构建。如果将这些处理方面的两个部分——转换和计算——分开，这有助于测试和调试：
- en: 'Import the needed literal_eval() function to do the conversions of strings
    that are expected to be Python literals:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的 `literal_eval()` 函数以转换预期为 Python 字面量的字符串：
- en: '[PRE28]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With this function, we can evaluate literal_eval("2,3") to get a result of a
    proper tuple, (2, 3). We don’t need to use a regular expression to decompose the
    string to see the pattern of the text.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这个函数，我们可以评估 `literal_eval("2,3")` 来得到一个正确的元组结果，(2, 3)。我们不需要使用正则表达式来分解字符串以查看文本的模式。
- en: 'Define the distance function that performs conversions:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义执行转换的距离函数：
- en: '[PRE29]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Start the match statement for the various kinds of argument patterns.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始匹配各种参数模式的匹配语句。
- en: '[PRE30]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Write the individual cases, moving from more specific to less specific. Start
    with four distinct float values, since no conversion needs to be done. The tuple
    of float values has a more complex type structure, but doesn’t require any conversion.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写单独的情况，从更具体到更不具体。从四个不同的浮点值开始，因为不需要进行转换。浮点值的元组具有更复杂的类型结构，但不需要任何转换。
- en: '[PRE31]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We’ve provided the lat_1, lon_1, lat_2, and on_2 variables to bind the values
    from the args structure to variable names. This saves us from having to write
    assignment statements to unpack an argument tuple. The pass statement placeholder
    is used because no further processing is required beyond unpacking the data structure.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们提供了 `lat_1`、`lon_1`、`lat_2` 和 `lon_2` 变量，以便将 `args` 结构中的值绑定到变量名。这使我们免去了编写解包参数元组的赋值语句。使用
    `pass` 语句占位符是因为不需要进行除解包数据结构之外的其他处理。
- en: 'Write the cases that involve conversions of the supplied values:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写涉及提供的值转换的情况：
- en: '[PRE32]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When the argument values are four strings, we provided four variables to unpack
    the four strings.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当参数值是四个字符串时，我们提供了四个变量来解包这四个字符串。
- en: When the argument pattern is two strings, we provided two variables, ll1 and
    ll2, that each needed to be converted into two tuples of numbers and then unpacked.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当参数模式是两个字符串时，我们提供了两个变量，ll1 和 ll2，每个变量都需要被转换为两个数字元组然后解包。
- en: 'Write the default case that will match anything else and raise an exception:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个默认情况，它会匹配任何其他情况并引发异常：
- en: '[PRE33]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now that the arguments have been properly unpacked and any conversions applied,
    use the haversine() function to compute the required result:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在参数已经被正确解包并且应用了任何转换，使用 `haversine()` 函数来计算所需的结果：
- en: '[PRE34]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 10.4.3 How it works...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4.3 它是如何工作的...
- en: The essential feature for type conversions is using a match statement to provide
    appropriate conversions for the supported types. In this example, we tolerated
    a mixture of strings and tuples that could be converted and unpacked to locate
    the required four argument values. The match statement has many clever type-matching
    rules. For example, an expression like ((float(f1), float(f2)), (float(f3), float(f4)))
    will match two tuples, each with two float values. Further, it unpacks the values
    from the tuples and assigns them to four variables.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换的基本功能是使用匹配语句为支持的类型提供适当的转换。在这个例子中，我们容忍了可以转换和解包的字符串和元组的混合，以定位所需的四个参数值。匹配语句有许多聪明的类型匹配规则。例如，表达式
    `((float(f1), float(f2)), (float(f3), float(f4)))` 将匹配两个元组，每个元组包含两个浮点值。此外，它从元组中解包值并将它们分配给四个变量。
- en: The mechanics of converting the values are also based on a built-in feature.
    The float() function converts numeric strings to float values or raises a ValueError
    exception.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 转换值的机制也基于内置功能。`float()` 函数将数字字符串转换为浮点值或引发 `ValueError` 异常。
- en: The ast.literal_eval() function is very handy for evaluating strings that are
    Python literals. The function is safe from evaluating dangerous expressions because
    it is limited to literal values, and a few simple data structures – tuples, lists,
    dicts, and sets – built from literal values. It permits us to parse a string like
    "36.12,-86.67" into (36.12, -86.67) directly.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`ast.literal_eval()` 函数对于评估字符串形式的 Python 字面量非常方便。该函数由于仅限于字面值和一些简单数据结构（由字面值构建的元组、列表、字典和集合）而安全，因此不会评估危险的表达式。它允许我们直接将字符串
    "36.12,-86.67" 解析为 (36.12, -86.67)。'
- en: 10.4.4 There’s more...
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4.4 更多...
- en: 'The use of independent case clauses makes it relatively easy to add additional
    type conversions. We might, for example, want to handle a tuple of two dictionary
    structures that look like {"lat": 36.12, "lon": -86.67}. This can be matched with
    the following case:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '使用独立的 case 子句使得添加额外的类型转换相对容易。例如，我们可能想要处理看起来像 {"lat": 36.12, "lon": -86.67}
    的两个字典结构的元组。这可以与以下 case 匹配：'
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The argument tuple pattern has () around it, making it easy to break it into
    multiple lines. The four values extracted from the dictionaries will be bound
    to four target variables.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 参数元组模式周围有括号（()），这使得它很容易被拆分成多行。从字典中提取的四个值将被绑定到四个目标变量上。
- en: 'If we want to permit more flexibility, we can consider the case where we have
    two argument values of a mixture of type patterns. For example, distance("36.12,-86.67", (33.94, -118.40), R=6372.8).
    This has two distinct formats: a string and a tuple with a pair of float values.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要允许更多的灵活性，我们可以考虑这种情况：我们有两个类型模式的混合参数值。例如，distance("36.12,-86.67", (33.94,
    -118.40), R=6372.8)。这有两种不同的格式：一个字符串和一个包含一对浮点值的元组。
- en: 'Rather than enumerate all of the possible combinations, we can decompose the
    parsing of a pair of values into a separate function, parse(), that applies the
    same conversion to both argument values:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是列举所有可能的组合，我们可以将一对值的解析分解成一个单独的函数，parse()，它将对两个参数值应用相同的转换：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This new parse() function must handle all the cases where a latitude and longitude
    are provided together. This includes strings, tuples, and mappings. It looks like
    this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的 parse() 函数必须处理提供经纬度值的所有情况。这包括字符串、元组和映射。它看起来是这样的：
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will slightly simplify the match statement in the distance function. The
    refactored statement only handles four cases:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这将稍微简化 distance 函数中的 match 语句。重构后的语句只处理四种情况：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first two cases handle the situation where four argument values are provided.
    The third case looks at a pair of values, which can have any of the pair formats.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种情况处理提供了四个参数值的情况。第三种情况查看一对值，这些值可以是任何一对格式。
- en: We expressly avoid the case where three argument values are provided. This requires
    a bit more care to interpret, since one of the three argument values must be a
    latitude and longitude pair. The other two values must be separated latitude and
    longitude values. The logic is not overwhelmingly complicated, but the details
    stray from the central idea of this recipe.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们明确避免提供三个参数值的情况。这需要更多的注意来解释，因为三个参数值中的一个必须是经纬度对。其他两个值必须是分开的经纬度值。逻辑并不特别复杂，但细节偏离了这个配方的核心思想。
- en: While the recipe focuses on built-in types including str and float, any type
    can be used. A customized Leg type, for example, with start and stop locations
    could easily be added in a case clause.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个配方侧重于内置类型，包括 str 和 float，但任何类型都可以使用。例如，可以很容易地在 case 子句中添加一个自定义的 Leg 类型，它具有起始和结束位置。
- en: 10.4.5 See also
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4.5 参见
- en: For more information on numbers and conversions, see the [Choosing between float,
    decimal, and fraction](ch005_split_000.xhtml#x1-180001) recipe in Chapter [1](ch005_split_000.xhtml#x1-170001).
    This provides some more information about the limitations of the float approximation.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于数字和转换的更多信息，请参阅第 [1](ch005_split_000.xhtml#x1-170001) 章的 [选择 float、decimal
    和 fraction 之间的区别](ch005_split_000.xhtml#x1-180001) 配方。这提供了一些关于 float 近似限制的更多信息。
- en: For more information on the haversine() function, see the [Picking an order
    for parameters based on partial functions](ch007_split_001.xhtml#x1-1940006) recipe
    in Chapter [3](ch007_split_000.xhtml#x1-1610003). Also see the [Creating contexts
    and context managers](ch011_split_001.xhtml#x1-43700011) recipe in Chapter [7](ch011_split_000.xhtml#x1-3760007).
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 haversine() 函数的更多信息，请参阅第 [3](ch007_split_000.xhtml#x1-1610003) 章的 [基于部分函数选择参数顺序](ch007_split_001.xhtml#x1-1940006)
    配方。还可以参阅第 [7](ch011_split_000.xhtml#x1-3760007) 章的 [创建上下文和上下文管理器](ch011_split_001.xhtml#x1-43700011)
    配方。
- en: 10.5 Implementing more strict type checks with Pydantic
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.5 使用 Pydantic 实现更严格的类型检查
- en: For the most part, Python’s internal processing will handle a great many simple
    validity checks properly. If we’ve written a function to convert a string to float,
    the function will work with float values and string values. It will raise a ValueError
    exception if we try to apply the float() function to a Path object.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数情况，Python 的内部处理将正确地处理许多简单的有效性检查。如果我们编写了一个将字符串转换为浮点数的函数，该函数将处理浮点值和字符串值。如果我们尝试将
    float() 函数应用于 Path 对象，它将引发 ValueError 异常。
- en: In order for type hints to be optional, run-time type-checking is the minimum
    level of checking required to make sure some processing can proceed. This is emphatically
    distinct from the strict checks that tools like mypy make.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使类型提示可选，运行时类型检查是确保某些处理可以继续的最小检查级别。这与 mypy 等工具执行的严格检查截然不同。
- en: Type hints do no run-time processing.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示不执行运行时处理。
- en: Python (without any add-on packages) does no data type checks or value range
    checks at run-time. Exceptions are raised when an operator is confronted with
    a type it can’t process, without regard to the type hints.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Python（不使用任何附加包）在运行时不会进行数据类型检查或值范围检查。当操作符遇到它无法处理的类型时，会引发异常，而不考虑类型提示。
- en: This means that Python may be able to process a type that was excluded by a
    hint. It’s possible to write a narrow hint like list[str]. An object of set[str]
    may also work with the given body of the function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 Python 可能能够处理被提示排除的类型。可以编写一个窄提示，如 list[str]。具有给定函数体的 set[str] 对象也可能与 Pydantic
    包一起工作。
- en: There are applications where we’d like stronger checks at run-time. These are
    often helpful in applications where extensions or plug-ins are used, and we’d
    like to be sure the additional plug-in code behaves properly.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用中，我们希望在运行时进行更强的检查。这些通常在需要使用扩展或插件的程序中很有帮助，我们希望确保额外的插件代码表现良好。
- en: One way to provide for run-time type checking is to use the Pydantic package.
    This module allows us to define complex objects that are accompanied by run-time
    type checking, as well as management of schema definitions that can be shared
    widely.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 提供运行时类型检查的一种方法是通过使用 Pydantic 包。此模块允许我们定义带有运行时类型检查的复杂对象，以及可以广泛共享的模式定义管理。
- en: In Chapter [5](ch009.xhtml#x1-2890005), in the [Creating dictionaries – inserting
    and updating](ch009.xhtml#x1-2900001) recipe, we looked at a log file that we
    needed to parse into a more useful structure. In Chapter [9](ch013_split_000.xhtml#x1-5020009),
    in the [Writing generator functions with the yield statement](ch013_split_000.xhtml#x1-5030001)
    recipe, we looked at writing a generator function that would parse and yield the
    parsed objects. We called the resulting objects RawLog, with no type checks or
    type conversions. We applied a simple transformation to create a DatedLog instance
    with the date-time stamp converted from text to a datetime.datetime object.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 [5](ch009.xhtml#x1-2890005) 章，在 [创建字典 – 插入和更新](ch009.xhtml#x1-2900001) 食谱中，我们查看了一个需要解析成更有用结构的日志文件。在第
    [9](ch013_split_000.xhtml#x1-5020009) 章，在 [使用 yield 语句编写生成器函数](ch013_split_000.xhtml#x1-5030001)
    食谱中，我们查看了一个编写生成器函数的例子，该函数将解析并生成解析后的对象。我们将这些生成的对象称为 RawLog，没有类型检查或类型转换。我们应用了一个简单的转换来创建一个带有日期时间戳从文本转换为
    datetime.datetime 对象的 DatedLog 实例。
- en: The pydantic package can handle some of this conversion to a DatedLog instance,
    saving us some programming. Further, because the schema can be generated automatically,
    we can build a JSON Schema definition and do JSON serialization without a lot
    of complicated work.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 包可以处理一些转换为 DatedLog 实例的转换，从而节省我们一些编程工作。此外，由于模式可以自动生成，我们可以构建 JSON Schema
    定义并执行 JSON 序列化，而无需进行大量复杂的工作。
- en: 'The Pydantic package must be downloaded and installed. Generally, this is done
    with the following terminal command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 必须下载并安装 Pydantic 包。通常，这可以通过以下终端命令完成：
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Using the python -m pip command ensures that we will use the pip command that
    goes with the currently active virtual environment, shown as cookbook3 in the
    example.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 python -m pip 命令确保我们将使用与当前活动虚拟环境一起的 pip 命令，在示例中显示为 cookbook3。
- en: 10.5.1 Getting ready
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5.1 准备工作
- en: The log data has date-time stamps represented as string values. We need to parse
    these to create proper datetime objects. To keep things focused in this recipe,
    we’ll use a simplified log produced by a web server written with Flask.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 日志数据中的日期时间戳以字符串值表示。我们需要解析这些值以创建适当的 datetime 对象。为了使本食谱中的内容更集中，我们将使用 Flask 编写的
    Web 服务器生成的简化日志。
- en: 'The entries start out as lines of text that look like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 条目最初是类似以下的文本行：
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We’ve seen other examples of working with this kind of log in the [Using more
    complex structures – maps of lists](ch012.xhtml#x1-4810005) recipe in Chapter [8](ch012.xhtml#x1-4520008).
    Using REs from the [String parsing with regular expressions](ch005_split_000.xhtml#x1-350003)
    recipe in Chapter [1](ch005_split_000.xhtml#x1-170001), we can decompose each
    line into a more useful structure.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 8 章](ch012.xhtml#x1-4520008)的[使用更复杂结构 - 列表映射](ch012.xhtml#x1-4810005)配方中看到了其他处理这种日志的例子。使用[第
    1 章](ch005_split_000.xhtml#x1-170001)中的[使用正则表达式进行字符串解析](ch005_split_000.xhtml#x1-350003)配方中的
    RE，我们可以将每一行分解成更有用的结构。
- en: Looking at the other recipes, the regular expression used for parsing had an
    important feature. The names used in the (?P<name>...) groups were specifically
    designed to be ordinary Python attribute names. This will fit nicely with the
    class definition we’ll build later.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 观察其他配方，用于解析的正则表达式具有一个重要的特性。在 (?P<name>...) 组中使用的名称被特别设计为普通的 Python 属性名称。这将很好地与我们将要构建的类定义相匹配。
- en: We’ll need to define a class that captures the essential content of each log
    line in a useful form. We’ll use the Pydantic package to define and populate this
    class.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义一个类，以有用的形式捕获每条日志行的基本内容。我们将使用 Pydantic 包来定义和填充这个类。
- en: 10.5.2 How to do it...
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5.2 如何操作...
- en: 'We’ll need the following imports to create this class definition:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建这个类定义，我们需要以下导入：
- en: '[PRE41]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In order to properly validate a string that has a number of values, an Enum
    class is required. We’ll define a subclass of StrEnum to list the valid string
    values. Each class-level variable provides a name and the string literal that
    is the serialization for the name:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了正确验证具有多个值的字符串，需要一个 Enum 类。我们将定义 StrEnum 的子类来列出有效的字符串值。每个类级别变量提供了一个名称和用于名称序列化的字符串字面量：
- en: '[PRE42]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this class, the Python attribute names and the string literals match. This
    isn’t a requirement. It happens to be convenient for this collection of enumerated
    string values.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个类中，Python 属性名称和字符串字面量相匹配。这不是一个要求。对于这个枚举字符串值的集合来说，这碰巧很方便。
- en: 'The class will be a subclass of the BaseModel class from the pydantic package:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类将是 pydantic 包中的 BaseModel 类的子类：
- en: '[PRE43]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The BaseModel class must be the superclass for any model that makes use of pydantic
    features.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: BaseModel 类必须是任何使用 pydantic 特性的模型的超类。
- en: 'We’ll define each field with a field name that matches the group name in the
    regular expression used to parse the fields. This is not a requirement, but it
    makes it very easy to build instances of the LogData class from the group dictionary
    that’s part of a regular expression Match object:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义每个字段，字段名称与解析字段使用的正则表达式中的组名称相匹配。这不是一个要求，但它使得从正则表达式匹配对象的部分组字典构建 LogData 类的实例变得非常容易：
- en: '[PRE44]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The date is defined to be a datetime.datetime instance. The inherited methods
    from the BaseModel class will handle this conversion. The level is an instance
    of the LevelClass. Again, features from BaseModel will handle this conversion
    for us. We’ve used the Annotated type to provide a type, str, and an annotation
    argument, Field(...). This will be used by the methods of BaseModel to validate
    the field’s content.
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 日期被定义为 datetime.datetime 实例。从 BaseModel 类继承的方法将处理这个转换。级别是 LevelClass 的实例。同样，BaseModel
    的特性将为我们处理这个转换。我们使用了 Annotated 类型来提供类型，str，以及一个注解参数，Field(...)。这将由 BaseModel 的方法用于验证字段的内容。
- en: 'Here’s a generator function to read and parse log records:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个生成器函数，用于读取和解析日志记录：
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will use the regular expression pattern, pattern to parse each record.
    The group dictionary, match.groupdict() will have the group names and the parsed
    text. The model_validate() method of the BaseModel will build an instance of the
    LogData class from the dictionary created by the compiled regular expression.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用正则表达式模式，pattern 来解析每条记录。组字典，match.groupdict() 将包含组名称和解析后的文本。BaseModel 的
    model_validate() 方法将从编译的正则表达式创建的字典构建 LogData 类的实例。
- en: 'It looks like the following example when we use this logdata_iter function
    to create instances of the LogData class:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用这个 logdata_iter 函数来创建 LogData 类的实例时，它看起来像以下示例：
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This function has transformed lines of text into LogData objects populated
    with proper Python objects: datetime.datetime instances and enumerated values
    from the LevelClass. Further, it’s validated the module names to be sure they
    match a specific regular expression pattern.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数已将文本行转换为填充了适当的 Python 对象（datetime.datetime 实例和来自 LevelClass 的枚举值）的 LogData
    对象：进一步，它验证了模块名称以确保它们匹配特定的正则表达式模式。
- en: 10.5.3 How it works...
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5.3 它是如何工作的...
- en: The Pydantic package includes numerous tools for data validation and class definition.
    Python’s use of types, and more detailed Annotated types, provides syntax that
    helps us define the members of a class, including data conversions and data validations.
    In this example, the conversions were implied; the class provided the target type,
    and the methods inherited from the BaseModel class made sure that source data
    was properly converted to the desired target type.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 包包括许多用于数据验证和类定义的工具。Python 的类型使用，以及更详细的 Annotated 类型，提供了帮助我们定义类成员的语法，包括数据转换和数据验证。在这个例子中，转换是隐含的；类提供了目标类型，从
    BaseModel 类继承的方法确保源数据被正确转换为所需的目标类型。
- en: 'This small class definition had three distinct kinds of types hints:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小的类定义有三个不同类型的类型提示：
- en: The date and level field involved conversions to a target type.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期和级别字段涉及转换为目标类型。
- en: The module field used an annotated type to provide a Pydantic Field definition
    for the attribute. The regular expression pattern will check each string value
    to be sure it matches the required pattern.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块字段使用注解类型为属性提供了 Pydantic Field 定义。正则表达式模式将检查每个字符串值以确保它匹配所需的模式。
- en: The message field provided a simple type that will match the source data type.
    No additional validation will be performed for this field.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供的消息字段提供了一个简单的类型，该类型将与源数据类型匹配。对于此字段不会执行任何额外的验证。
- en: There are some parallels between the way the @dataclass and a BaseModel subclass
    work. The Pydantic package provides considerably more sophisticated definitions
    than a dataclass definition. A @dataclass, for example, does not do type checking
    or any automatic data conversion. The type information provided when defining
    a dataclass is primarily of interest to tools like mypy. In contrast, the subclasses
    of BaseModel do considerably more automated conversion and run-time type checking.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '@dataclass 和 BaseModel 子类的工作方式之间有一些相似之处。Pydantic 包提供了比 dataclass 定义更为复杂的定义。例如，@dataclass
    不执行类型检查或任何自动数据转换。在定义 dataclass 时提供的类型信息主要对像 mypy 这样的工具感兴趣。相比之下，BaseModel 的子类执行了更多的自动化转换和运行时类型检查。'
- en: The subclasses of DataModel come with a large number of methods.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: DataModel 的子类附带了许多方法。
- en: The model_dump_json() and model_validate_json() methods are particularly helpful
    for web services where the application often works with RESTful transfers of object
    state in JSON notation. These can be serialized into newline-delimited files to
    collect a number of complicated objects into files in a standardized physical
    format.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`model_dump_json()` 和 `model_validate_json()` 方法对于网络服务特别有帮助，在这些服务中，应用程序通常与以
    JSON 表示法表示的对象状态的 RESTful 传输一起工作。这些可以序列化为换行符分隔的文件，以便将多个复杂对象收集到以标准化物理格式存储的文件中。'
- en: The Pydantic package tends to be extremely fast. The current version involves
    Python extensions that are compiled to provide very high performance. Clearly,
    a dataclass – which lacks a number of Pydantic features – will be faster, but
    do less. However, the additional data validation is often worth the overhead.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 包通常非常快。当前版本涉及编译为提供非常高性能的 Python 扩展。显然，缺少许多 Pydantic 功能的数据类将更快，但功能更少。然而，额外的数据验证通常值得额外的开销。
- en: 10.5.4 There’s more...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5.4 更多...
- en: One of the benefits of working with Pydantic is the automatic support for JSON
    Schema definitions and JSON serialization.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Pydantic 一起工作的一个好处是自动支持 JSON Schema 定义和 JSON 序列化。
- en: 'This shows how we can get the JSON Schema for a model:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了我们可以如何获取模型的 JSON Schema：
- en: '[PRE47]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The details of the JSON Schema are long and match the Python definition of the
    class. We’ve omitted the output.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Schema 的细节很长，与 Python 类的定义相匹配。我们省略了输出。
- en: 'We can serialize these LogData instances in JSON notation. Here’s how this
    looks:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些 LogData 实例以 JSON 表示法进行序列化。以下是它的样子：
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We’ve used the model_dump_json() method to serialize the object as a JSON document.
    This lets us convert documents from a variety of sources to a common format. This
    makes it easy to create analytic processing around the common format, separating
    parsing, merging, and validating from the analysis and the interesting results
    of the analytic processing.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用model_dump_json()方法将对象序列化为JSON文档。这使我们能够将来自各种来源的文档转换为通用格式。这使得围绕通用格式创建分析处理变得容易，将解析、合并和验证与分析和分析处理的有趣结果分开。
- en: 10.5.5 See also
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5.5 参考信息
- en: See the [Including run-time valid value checks](ch014.xhtml#x1-6060006) recipe
    for some additional validation rules that are possible.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关一些可能的附加验证规则，请参阅[包含运行时有效值检查](ch014.xhtml#x1-6060006)配方。
- en: See the [Using dataclasses for mutable objects](ch011_split_000.xhtml#x1-4010005)
    recipe in Chapter [7](ch011_split_000.xhtml#x1-3760007) for more on dataclasses.
    The Pydantic variant on dataclasses is often more useful than the dataclasses
    module.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关数据类的更多信息，请参阅第[7](ch011_split_000.xhtml#x1-3760007)章中的[使用数据类处理可变对象](ch011_split_000.xhtml#x1-4010005)配方。Pydantic对数据类的变体通常比数据类模块更有用。
- en: See the [Reading JSON and YAML documents](ch015_split_001.xhtml#x1-6520006)
    recipe in Chapter [11](ch015_split_000.xhtml#x1-61500011) for information related
    to reading data in JSON format.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关以JSON格式读取数据的更多信息，请参阅第[11](ch015_split_000.xhtml#x1-61500011)章中的[读取JSON和YAML文档](ch015_split_001.xhtml#x1-6520006)配方。
- en: 10.6 Including run-time valid value checks
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.6 包含运行时有效值检查
- en: 'Data analytics often involves a great deal of ”data wrangling”: dealing with
    invalid data, or unusual data. It’s common for source application software to
    change, leading to new formats for data files, causing problems in downstream
    analytic applications when parsing those files. A change in enterprise processes
    or policies may lead to new data types or new coded values that can disrupt analytic
    processing.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 数据分析通常涉及大量的“数据处理”：处理无效数据或异常数据。源应用程序软件的变化很常见，导致数据文件的新格式，当解析这些文件时，可能会给下游分析应用带来问题。企业流程或政策的变更可能会导致新的数据类型或新的编码值，这可能会干扰分析处理。
- en: Similarly, when working with machines and robots, sometimes called the Internet
    of Things, it’s common for a device to provide invalid data when it’s starting
    up, or when it’s failing to operate normally. In some cases, it may be necessary
    to raise alarms when bad data arrives. In other cases, the out-of-range data needs
    to be quietly ignored.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当与机器和机器人（有时称为物联网）一起工作时，设备在启动时或无法正常工作时提供无效数据是很常见的。在某些情况下，当不良数据到达时，可能需要发出警报。在其他情况下，超出范围的数据需要被悄悄忽略。
- en: 'The Pydantic package offers very sophisticated validation functions that allow
    us two choices:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic包提供了非常复杂的验证函数，允许我们有两个选择：
- en: Convert data from unusual formats into Python objects.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据从非标准格式转换为Python对象。
- en: Raise an exception for data that cannot be converted or fails to pass more specific
    domain checks.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于无法转换或未能通过更具体领域检查的数据，抛出异常。
- en: In some cases, we also need to validate the resulting object is internally consistent.
    This often means that several fields must be checked for consistency with each
    other. This is called model validation, which is distinct from isolated field
    validation.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们还需要验证生成的对象在内部是否一致。这通常意味着必须检查几个字段是否相互一致。这被称为模型验证，它与单独字段验证是不同的。
- en: The idea of validation can be extended. It can embrace both rejecting invalid
    data and filtering out data that’s valid, but uninteresting, for a given application.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 验证的概念可以扩展。它可以包括拒绝无效数据，以及过滤掉对于特定应用来说有效但无趣的数据。
- en: 10.6.1 Getting ready
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6.1 准备工作
- en: We’re looking at the US National Oceanographic and Atmospheric Administration
    (NOAA) data on coastal tides. Moving a large sailboat means making sure there’s
    enough water for it to float. This constraint requires checking predictions for
    the height of the tides at places that are known to be shallow and difficult to
    pass.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在查看美国国家海洋和大气管理局（NOAA）关于海岸潮汐的数据。移动一艘大型帆船意味着确保有足够的水让它浮起来。这个约束条件要求检查已知浅且难以通过的地区的潮汐高度预测。
- en: In particular, a place called El Jobean, on the Myakka river, has a shallow
    spot that requires some care when transiting it. We can get the tidal prediction
    from the NOAA [Tides and Currents](https://tidesandcurrents.noaa.gov/noaatidepredictions.html?id=8725769)
    web site. This web page allows putting in a range of dates and downloading a text
    file with tide predictions for the given range of dates.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，一个名为El Jobean的地方，位于Myakka河上，有一个浅滩，在穿越时需要小心。我们可以从NOAA [潮汐和流速](https://tidesandcurrents.noaa.gov/noaatidepredictions.html?id=8725769)网站获取潮汐预测。这个网页允许输入日期范围并下载给定日期范围的潮汐预测文本文件。
- en: 'The resulting text file looks as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文本文件看起来如下所示：
- en: '[PRE49]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This data is almost in CSV format, but a few quirks make it difficult to process.
    Here are some complicating factors:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据几乎符合CSV格式，但一些怪癖使其难以处理。以下是一些复杂因素：
- en: The file has 19 lines of data before the useful column heading line.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在有用的列标题行之前，文件有19行数据。
- en: The columns use the tab character \t as a delimiter instead of a comma.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列使用制表符（\t）作为分隔符，而不是逗号。
- en: The heading row for the relevant data has some extraneous whitespace hidden
    in it.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关数据的标题行中隐藏了一些多余的空格。
- en: 'The following function will provide clean CSV rows for further processing:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数将提供干净的CSV行以供进一步处理：
- en: '[PRE50]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The Extra tab in the header comment handles the heading, which has an extra
    whitespace character in it. This header row has two \t characters between the
    Date and Day column names:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 标题注释中的额外制表符用于处理标题，其中包含一个额外的空格字符。这个标题行在日期和日期列名称之间有两个制表符（\t）：
- en: '[PRE51]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: See the [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003) recipe
    in Chapter [4](ch008_split_000.xhtml#x1-2240004) for more on this technique for
    removing an item from a list.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 有关从列表中删除项的技术，请参阅第[4](ch008_split_000.xhtml#x1-2240004)章中的[切片和切块列表](ch008_split_000.xhtml#x1-2400003)配方。
- en: This list of column names can be used to build a DictReader instance to consume
    the rest of the data. (See the [Reading delimited files with the CSV module](ch015_split_000.xhtml#x1-6320003)
    recipe in Chapter [11](ch015_split_000.xhtml#x1-61500011) for more on CSV files.)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列名称列表可以用来构建一个DictReader实例以消费其余的数据。（有关CSV文件，请参阅第[11](ch015_split_000.xhtml#x1-61500011)章中的[使用CSV模块读取分隔文件](ch015_split_000.xhtml#x1-6320003)配方。）
- en: We can convert each from a dictionary to a class instance using Pydantic validation
    features.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Pydantic验证功能将每个字典转换为类实例。
- en: 10.6.2 How to do it...
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6.2 如何做到这一点...
- en: 'The core data model will validate rows of data, creating an instance of a class.
    We can add features to this class to handle the application-specific processing.
    Here’s how we build this class:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 核心数据模型将验证数据行，创建一个类的实例。我们可以向这个类添加功能以处理特定于应用程序的处理。以下是构建这个类的方法：
- en: 'Start with the imports for the the data types within each row, plus the BaseModel
    class and some related classes:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从每行中的数据类型导入开始，加上BaseModel类和一些相关类：
- en: '[PRE52]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Define the domain of values for the High/Low column. The two codes are enumerated
    as an Enum subclass:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义高/低列的值域。这两个代码作为Enum子类的枚举：
- en: '[PRE53]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Since the date text is not in the default format used by Pydantic, we need
    to define a validation function that will produce a date object from the given
    string:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于日期文本不是Pydantic使用的默认格式，我们需要定义一个验证函数，该函数将从给定的字符串生成日期对象：
- en: '[PRE54]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The Pydantic validators can be used on internal Python objects as well as strings
    from source CSV files or JSON documents. When applied to a datetime.date object,
    no additional conversion is needed.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Pydantic验证器可以用于内部Python对象以及来自源CSV文件或JSON文档的字符串。当应用于datetime.date对象时，不需要额外的转换。
- en: 'Define the model. The validation_alias parameter of the Field definition will
    pluck data from a source field in the dictionary that’s not exactly the same as
    the target attribute name in the class:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义模型。字段定义的validation_alias参数将从字典中的源字段中提取数据，该字段与类中目标属性名称不完全相同：
- en: '[PRE55]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Each field uses an Annotated type to define the base type, and additional details
    required to validate strings and convert them to that type.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个字段使用Annotated类型来定义基本类型，以及验证字符串和将它们转换为该类型所需的其他详细信息。
- en: The day field – with the day of the week – is not actually useful. It’s derived
    data from the date. For debugging purposes, this is preserved.
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 天字段（包含星期几）实际上并不有用。它是从日期派生出来的数据。出于调试目的，这个数据被保留。
- en: 'Given this class, we can use it to validate model instances from a sequence
    of dictionary instances. It looks like this:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个类，我们可以用它来验证来自一系列字典实例的模型实例。它看起来是这样的：
- en: '[PRE56]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This sequence of objects contains too much data. We can use Pydantic to also
    filter the data, and pass only the useful rows. We’ll do this by revising this
    class definition and creating an alternative that includes the rules for the data
    to be passed.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象序列包含太多数据。我们可以使用 Pydantic 来过滤数据，并只传递有用的行。我们将通过修改这个类定义并创建一个包含要传递的数据规则的替代方案来实现这一点。
- en: 10.6.3 How it works...
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6.3 它是如何工作的...
- en: 'The BaseModel class includes a number of operations that work with the annotated
    type hints of the class attributes. Consider this type hint:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: BaseModel 类包括一些与类属性注释类型提示一起工作的操作。考虑这个类型提示：
- en: '[PRE57]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This provides a base type, datetime.date. It provides a Field object that will
    extract the field named ’Date ’ from a dictionary, and apply validation rules
    to it. Finally, the PlainValidator object provides a one-step validation rule
    that’s applied to the source data. The validate_date() function was written to
    accept date objects as already valid, and convert string objects into date objects.
    This allows the validation to be used for raw data as well as Python objects.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个基础类型 datetime.date。它提供了一个 Field 对象，可以从字典中提取名为 'Date' 的字段，并对其应用验证规则。最后，PlainValidator
    对象提供了一个一步验证规则，应用于源数据。validate_date() 函数被编写为接受已验证的日期对象，并将字符串对象转换为日期对象。这允许验证用于原始数据以及
    Python 对象。
- en: 'Our application involves some narrowing of the domains of data for this example.
    There are three important criteria:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的应用程序涉及对数据域的某些缩小。有三个重要标准：
- en: We’re only interested in high tide predictions.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只对高潮预测感兴趣。
- en: We’d prefer the tide be at least 1.5 (45 cm) feet above baseline.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望潮高至少比基准线高 1.5 英尺（45 厘米）。
- en: We need this to occur after 10:00 and before 17:00.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要这个操作在 10:00 之后和 17:00 之前发生。
- en: We can leverage Pydantic to perform additional validations to narrow the data
    domains. These additional validations can reject high tides less than the minimum
    of 1.5 feet.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用 Pydantic 来执行额外的验证，以缩小数据域。这些额外的验证可以拒绝低于 1.5 英尺的最小潮高。
- en: 10.6.4 There’s more...
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6.4 更多内容...
- en: We can extend this model to add validation rules that narrow the domain of valid
    rows to those that match our selection criteria based on time of day and height
    of tide. We’ll be applying these more narrow data validation rules after any data
    conversions. These rules will raise ValidationError exceptions. This expands the
    imports from the pydantic package.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此模型扩展以添加验证规则，将有效行的域缩小到符合我们基于一天中的时间和潮高选择标准的那些行。我们将在任何数据转换之后应用这些更窄的数据验证规则。这些规则将引发
    ValidationError 异常。这扩展了从 pydantic 包中的导入。
- en: 'We’ll define a number of additional validation functions. Here’s a validator
    that raises an exception for low-tide data:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一系列额外的验证函数。以下是一个为低潮数据引发异常的验证器：
- en: '[PRE58]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The assert statement is elegantly simple for this task. This can also be done
    with if and raise.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: assert 语句对于这个任务来说非常简洁。这也可以用 if 和 raise 来完成。
- en: 'A similar validator can raise an exception for data outside the acceptable
    time window:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的验证器可以引发异常，对于超出可接受时间窗口的数据：
- en: '[PRE59]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, we can combine these additional validators into the annotated type
    definitions:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将这些额外的验证器组合到注释类型定义中：
- en: '[PRE60]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The additional validators will reject data where the criteria don’t match our
    narrow requirements. The output will only have high tides, greater than 1.5 feet,
    and during daylight hours.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的验证器将拒绝不符合我们狭窄要求的标准的数据。输出将只包含高潮，潮高大于 1.5 英尺，并且在白天。
- en: 'This data forms a sequence of HighTideTable instances, like the following:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据形成了一个高潮表实例的序列，如下所示：
- en: '[PRE61]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We’ve omitted some rows to show just the first row, a row from the middle, and
    the last row. These are HighTideTable objects with attributes that are Python
    objects, suitable for further analysis and processing.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了一些行，只显示第一行、中间的一行和最后一行。这些是具有 Python 对象属性的高潮表对象，适合进一步分析和处理。
- en: The general approach to Pydantic design means individual rules for combining
    raw data fields, converting data, and filtering data are all separated. We can
    confidently change one of these rules without having to worry about breaking other
    parts of the application.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 设计的一般方法意味着组合原始数据字段、转换数据和过滤数据的规则都是分开的。我们可以放心地更改这些规则之一，而不用担心破坏应用程序的其他部分。
- en: 'This recipe included three varieties of checks:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方包括三种检查方法：
- en: A range check to be sure a continuous value is within the allowed range. AfterValidator
    is used to make sure a string is converted to a time.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围检查以确保连续值在允许的范围内。AfterValidator 用于确保字符串被转换为时间。
- en: A minimum check to be sure a continuous value is above a limit. For numbers,
    this can be done by the Field definition directly.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保连续值超过限制的最小检查。对于数字，这可以通过字段定义直接完成。
- en: A required value check to be sure a discrete value has one of the required values.
    AfterValidator is used to make sure a string is converted the enumerated type.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必要值检查以确保离散值具有所需的其中一个值。AfterValidator 用于确保字符串被转换为枚举类型。
- en: These kinds of checks are performed after the essential type matching and used
    to apply narrower validation rules.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的检查在基本类型匹配之后执行，并用于应用更窄的验证规则。
- en: 10.6.5 See also
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6.5 参见
- en: In Chapter [11](ch015_split_000.xhtml#x1-61500011) we’ll look more deeply at
    reading files of data.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 [11](ch015_split_000.xhtml#x1-61500011) 章中，我们将更深入地探讨读取数据文件。
- en: See the [Implementing more strict type checks with Pydantic](ch014.xhtml#x1-6000005)
    recipe for additional examples of using Pydantic. Pydantic uses compiled Python
    extensions to apply the validation rules with little overhead.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见 [使用 Pydantic 实现更严格的类型检查](ch014.xhtml#x1-6000005) 菜单以获取使用 Pydantic 的更多示例。Pydantic
    使用编译的 Python 扩展来应用验证规则，几乎没有开销。
- en: Join our community Discord space
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
