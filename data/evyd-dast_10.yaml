- en: 'Chapter 10. Heaps: Ordered Trees'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。堆：有序树
- en: '**Heaps** are a special category of the tree data structure, that are ordered
    with respect to the value of the tree''s nodes or the keys associated with each
    node. This ordering is either ascending in a min heap, meaning that the root node
    is smaller in value or priority than it''s child nodes, or descending in a max
    heap, meaning that the root node is larger in value or priority than it''s child
    nodes. Note that heap data structures should not be confused with the heap memory
    of a computer system, which is the name typically used for system''s dynamically
    allocated memory.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆**是树数据结构的一个特殊类别，它们根据树节点的值或与每个节点关联的键进行排序。这种排序在最小堆中是升序的，意味着根节点的值或优先级小于其子节点，或者在最大堆中是降序的，意味着根节点的值或优先级大于其子节点。请注意，堆数据结构不应与计算机系统的堆内存混淆，后者通常用于系统动态分配的内存。'
- en: 'In this chapter we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Defining the heap data structure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义堆数据结构
- en: Array implementation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组实现
- en: Creating heaps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建堆
- en: Common operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见操作
- en: Heap implementations
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆实现
- en: 'Like trees, heaps are typically implemented using either linked lists or linked
    nodes, or an array. Since we examined the linked node approach in [Chapter 9](part0050_split_000.html#1FLS41-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 9. Trees: Non-Linear Structures"), *Trees: Nonlinear Structures*, in
    this chapter, we''ll examine an array implementation of a heap called a **binary
    heap**.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与树类似，堆通常使用链表或链节点，或数组来实现。由于我们在第 9 章（[第 9 章](part0050_split_000.html#1FLS41-77f2b5b248f04368a6f723b0e9357ef3
    "第 9 章。树：非线性结构"））中考察了链节点方法，“树：非线性结构”，在本章中，我们将考察一种称为 **二叉堆** 的堆的数组实现。
- en: '![Heap implementations](img/00015.jpeg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![堆实现](img/00015.jpeg)'
- en: A binary heap is a tree structure where all levels of the tree are filled completely,
    with the possible exception of the last or deepest level. In the case of the deepest
    level the nodes are filled from left to right until the level is full. As you
    can see from the preceding figure, in an array-based implementation each parent
    node has two child nodes that are located at *2i + 1* and *2i + 2, *where i is
    the index of the parent node and the first node of the collection is found at
    index 0.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉堆是一种树结构，其中树的所有层级都被完全填充，除了最后一层或最深层。在最后一层的情况下，节点从左到右填充，直到该层填满。如图所示，在基于数组的实现中，每个父节点有两个子节点，它们位于
    *2i + 1* 和 *2i + 2*，其中 i 是父节点的索引，集合的第一个节点位于索引 0。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Alternate implementations skip the 0 index of the array to simplify the arithmetic
    of finding child and parent nodes for a given index. In this design, the child
    nodes for any given index i are located at *2i* and 2i + 1.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的实现跳过了数组的 0 索引，以简化给定索引查找子节点和父节点的算术。在这个设计中，任何给定索引 i 的子节点位于 *2i* 和 2i + 1。
- en: Heap operations
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆操作
- en: Not all implementations of the heap data structures expose the same operational
    methods. However, the more common operations should be available or made available
    as needed by the developer.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有堆数据结构的实现都公开相同的操作方法。然而，更常见的操作应该可用，或者根据开发者的需要提供。
- en: '**Insert**:The Insert operation adds a new node to the heap. This operation
    must also re-order the heap to ensure that the newly added node maintains the
    heap property. This operation has an **O**(*log n*) operational cost.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Insert**：Insert 操作向堆中添加一个新节点。此操作必须重新排序堆，以确保新添加的节点保持堆属性。此操作的操作成本为 **O**(*log
    n*)。'
- en: '**FindMax**: The FindMax operation is synonymous with a max heap, and returns
    the largest value or highest-priority object in the collection. In an array-based
    implementation, this is typically the object at either index 0 or index 1, depending
    on the design. This is equivalent to the *peek* operation in a stack or queue,
    which is important when using a heap to implement a priority queue. This operation
    has an **O**(*1*) operational cost.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FindMax**：FindMax 操作与最大堆同义，并返回集合中的最大值或最高优先级对象。在基于数组的实现中，这通常是索引 0 或索引 1 的对象，具体取决于设计。这相当于栈或队列中的
    *peek* 操作，当使用堆实现优先队列时非常重要。此操作的操作成本为 **O**(*1*)。'
- en: '**FindMin**: The FindMin operation is related to a min heap, and returns the
    smallest value or lowest-priority object in the collection. In an array-based
    implementation this is typically the object at either index 0 or index 1, depending
    on the design. This operation has an **O**(*1*) operational cost.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FindMin**: FindMin操作与最小堆相关，并返回集合中最小值或最低优先级的对象。在基于数组的实现中，这通常是索引为0或1的对象，具体取决于设计。此操作的操作成本为**O(1**)。'
- en: '**ExtractMax**: The ExtractMax operation is related to a max heap, and both
    returns the largest value or highest-priority object in the collection and removes
    it from the collection. This is equivalent to the *pop* operation in a stack or
    queue structure. As with FindMax, this is typically the object at either index
    0 or index 1 depending on the design. This operation will also re-order the heap
    to maintain the heap property. This operation has an **O**(*log n*) operational
    cost.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ExtractMax**: ExtractMax操作与最大堆相关，既返回集合中最大值或最高优先级的对象，又将其从集合中移除。这相当于在栈或队列结构中的*pop*操作。与FindMax操作类似，这通常是索引为0或1的对象，具体取决于设计。此操作还将重新排序堆以维护堆属性。此操作的操作成本为**O(n**)。'
- en: '**ExtractMin**: The ExtractMin operation is related to a min heap, and both
    returns the smallest value or lowest-priority object in the collection and removes
    it from the collection. As with FindMin, this is typically the object at either
    index 0 or index 1 depending on the design. This operation will also re-order
    the heap to maintain the heap property. This operation has an **O**(*log n*) operational
    cost.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ExtractMin**: ExtractMin操作与最小堆相关，既返回集合中最小值或最低优先级的对象，又将其从集合中移除。与FindMin操作类似，这通常是索引为0或1的对象，具体取决于设计。此操作还将重新排序堆以维护堆属性。此操作的操作成本为**O(n**)。'
- en: '**DeleteMax**: The DeleteMax operation is related to a max heap, and simply
    removes the largest value or highest priority object in the collection. As with
    FindMax, this is typically the object at either index 0 or index 1 depending on
    the design. This operation will also re-order the heap to maintain the heap property.
    This operation has an **O**(*log n*) operational cost.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DeleteMax**: 删除最大值操作与最大堆相关，简单地说就是从集合中移除最大值或最高优先级的对象。与FindMax操作类似，这通常是索引为0或1的对象，具体取决于设计。此操作还将重新排序堆以维护堆属性。此操作的操作成本为**O(n**)。'
- en: '**DeleteMin**: The DeleteMin operation is related to a min heap, and simply
    removes the smallest value or lowest priority object in the collection. As with
    FindMin, this is typically the object at either index 0 or index 1 depending on
    the design. This operation will also re-order the heap to maintain the heap property.
    This operation has an **O**(*log n*) operational cost.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DeleteMin**: 删除最小值操作与最小堆相关，简单地说就是从集合中移除最小值或最低优先级的对象。与FindMin操作类似，这通常是索引为0或1的对象，具体取决于设计。此操作还将重新排序堆以维护堆属性。此操作的操作成本为**O(n**)。'
- en: '**Count**: The Count operation returns the total number of nodes in the heap.
    This operation has an O(*1*) operational cost.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Count**: Count操作返回堆中的节点总数。此操作的操作成本为**O(1**)。'
- en: '**Children**:The Children operation will return the two child nodes for the
    provided node or node index. This operation has an **O**(*2*) operational cost
    since two calculations must be performed to gather the child nodes.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Children**: 子节点操作将返回给定节点或节点索引的两个子节点。由于必须执行两次计算以收集子节点，因此此操作的操作成本为**O(2**)。'
- en: '**Parent**: The Parent operation will return the parent node for any given
    node or node index. This operation has an **O**(*1*) operational cost.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Parent**: 父节点操作将返回任何给定节点或节点索引的父节点。此操作的操作成本为**O(1**)。'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'This list of operations may remind you somewhat of the tree data structure
    discussed in [Chapter 9](part0050_split_000.html#1FLS41-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 9. Trees: Non-Linear Structures"), *Trees: Non-linear Structures*. It
    is important to note that, although a binary heap is quite similar to a binary
    search tree, the two should not be confused. Like a binary search tree, a heap
    data structure organizes each node of the collection. The heap orders nodes priority
    based on some arbitrary property of the node or the environment, while the values
    of each node are not necessarily ordered at all. In a binary search tree, on the
    other hand, the values of the nodes themselves are ordered.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这一系列操作可能会让你想起第9章中讨论的树数据结构，即“非线性结构：树”。重要的是要注意，尽管二叉堆与二叉搜索树非常相似，但两者不应混淆。像二叉搜索树一样，堆数据结构组织集合中的每个节点。堆根据节点或环境的某些任意属性对节点进行排序，而每个节点的值并不一定是有序的。另一方面，在二叉搜索树中，节点的值本身是有序的。
- en: Instantiating heaps
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化堆
- en: Since heaps are a form of tree data structure, it is unsurprising that we will
    not find a native concrete implementation in the languages we are discussing.
    However, the heap data structure is actually quite simple to implement. Therefore,
    we are going to build our own heap structure, specifically a min heap.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于堆是一种树形数据结构，我们在讨论的语言中不会找到原生的具体实现并不奇怪。然而，堆数据结构实际上非常简单实现。因此，我们将构建自己的堆结构，具体来说是一个最小堆。
- en: Min heap structure
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小堆结构
- en: Before we begin, we need to detail a few characteristics our heap structure
    will possess. For starters, we are going to implement the heap using an array,
    and the first node will occupy the `0` index in this array. This decision is important
    because it affects the formula we use to calculate each node's parent and Children.
    Next, we will need an object to represent the nodes in our heap. Since this is
    going to be a very simple object for our demonstration, we'll define its class
    in-line with our heap implementation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要详细说明我们的堆结构将具有的一些特性。首先，我们将使用数组来实现堆，第一个节点将占据这个数组的`0`索引。这个决定很重要，因为它影响我们计算每个节点父节点和子节点的公式。接下来，我们需要一个对象来表示我们堆中的节点。由于这将是我们的演示中一个非常简单的对象，我们将直接在堆实现中定义它的类。
- en: Since this is a min heap, we will only need to implement the `min` operations.
    Therefore, our implementation must expose methods for `FindMin` (peek), `ExtractMin`
    (pop), and `DeleteMin`. The heap's *Insert*, *Count*, *Children*, and *Parent*
    operations will each be implemented as single methods.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个最小堆，我们只需要实现`min`操作。因此，我们的实现必须公开`FindMin`（查看）、`ExtractMin`（弹出）和`DeleteMin`方法。堆的`Insert`、`Count`、`Children`和`Parent`操作将分别作为单独的方法实现。
- en: Our min heap implementation will also need two supporting methods to re-order
    the collection whenever a node is added or removed. We'll call these methods `OrderHeap`
    and `SwapNodes`, and their functions should be self-explanatory.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最小堆实现还需要两个辅助方法来重新排序集合，每当添加或删除节点时。我们将这些方法命名为`OrderHeap`和`SwapNodes`，它们的功能应该是自解释的。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that an implementation of a max heap is almost identical to a `min` heap
    except that you switch around the variables in a few operations. We'll examine
    those differences in-line with our implementations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最大堆的实现几乎与最小堆相同，只是在几个操作中交换了变量。我们将在实现中详细说明这些差异。
- en: '**C#**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'C# provides enough functionality for us to create a versatile heap data structure
    with very little code. First we need to build the simple class that represents
    the nodes of the heap:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: C#提供了足够的功能，让我们用很少的代码创建一个通用的堆数据结构。首先，我们需要构建一个简单的类来表示堆的节点：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This class is very simple, containing only a `public` property to store our
    integer data. Since this class' contents are consistent in each of the following
    language examples, we will only examine it here.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类非常简单，只包含一个`public`属性来存储我们的整数数据。由于这个类的内容在以下每种语言示例中都是一致的，我们在这里只检查它。
- en: 'Next we can implement our heap functions. Here''s what a concrete implementation
    of the `MinHeap` class might look like in C#:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以实现我们的堆函数。下面是一个`MinHeap`类在C#中的具体实现示例：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our `MinHeap` class includes two public fields. The first is a `List<HeapNode>`
    named `elements` that represents our heap collection. The second is a `Count`
    field that will return the total number of elements in the collection. Finally,
    our constructor simply initializes the `elements` collection.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`MinHeap`类包含两个公共字段。第一个是一个名为`elements`的`List<HeapNode>`，它代表我们的堆集合。第二个是一个`Count`字段，它将返回集合中的元素总数。最后，我们的构造函数简单地初始化`elements`集合。
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Insert(HeapNode item)` method accepts a new `HeapNode` object and adds
    it to the collection. Once the object has been added, the method calls `OrderHeap()`to
    make sure the new object is placed in the correct position to maintain the heap
    property.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Insert(HeapNode item)`方法接受一个新的`HeapNode`对象并将其添加到集合中。一旦对象被添加，方法就调用`OrderHeap()`以确保新对象被放置在正确的位置以保持堆属性。'
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Delete(HeapNode item)` method accepts a `HeapNode` item to be removed from
    the collection. The method first finds the index of the item to be removed, then
    gets the index of the last object in the collection. Next, the method deletes
    the matching node by overwriting its position with a reference to the last node
    in the heap and then the last node is removed. Finally, the `OrderHeap()` method
    is called to ensure the final collection satisfies the heap property.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delete(HeapNode item)`方法接受一个要从中移除的`HeapNode`对象。该方法首先找到要移除的项的索引，然后获取集合中最后一个对象的索引。接下来，方法通过用堆中的最后一个节点的引用覆盖其位置来删除匹配的节点，然后移除最后一个节点。最后，调用`OrderHeap()`方法以确保最终的集合满足堆属性。'
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `ExtractMin()` method first confirms that the `elements` collection has
    at least one element. If not, the method returns `null`. Otherwise, the method
    creates a new instance of `HeapNode` called `item` and sets it to the root object
    in the collection, which is the smallest object or the object with the lowest
    priority. Next, the method calls `Delete(item)` to remove the node from the collection.
    Finally, since the `ExtractMin` function must return an object, the method returns
    `item` to the caller.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExtractMin()`方法首先确认`elements`集合至少有一个元素。如果没有，则方法返回`null`。否则，方法创建一个新的`HeapNode`实例，称为`item`，并将其设置为集合中的根对象，即最小的对象或具有最低优先级的对象。接下来，方法调用`Delete(item)`从集合中删除节点。最后，由于`ExtractMin`函数必须返回一个对象，方法将`item`返回给调用者。'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `FindMin()` method is very similar to the `ExtractMin()` method, except
    that it does not remove the returned minimum value from the collection. The method
    first confirms that the element's collection has at least one element. If not,
    the method returns `null`. Otherwise the method returns the root object in the
    collection, which is the smallest object or the object with the lowest priority.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindMin()`方法与`ExtractMin()`方法非常相似，不同之处在于它不会从集合中移除返回的最小值。该方法首先确认元素集合至少有一个元素。如果没有，则方法返回`null`。否则，方法返回集合中的根对象，即最小的对象或具有最低优先级的对象。'
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The private `OrderHeap()` method is the heart of the `MinHeap` class. This is
    the method responsible for maintaining the heap property of the collection. The
    method first establishes a `for` loop based on the length of the elements collection,
    and begins iterating through the collection from the end to the beginning.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 私有的`OrderHeap()`方法是`MinHeap`类的核心。这是负责维护集合堆属性的方法。该方法首先根据元素集合的长度建立了一个`for`循环，并从集合的末尾开始向前迭代。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since we know that the two children of any object at index i are located at
    indices *2i + 1* and *2i + 2*, we likewise know that the parent of any object
    at index i is found at *(i - 1) / 2*. This formula only works because the resulting
    value is defined as an integer, meaning that any floating-point values are truncated
    and only the whole number value is retained. This algorithm, implemented in the
    `OrderHeap()` method via the `int parentPosition = (i - 1) / 2;` code, is what
    ensures the heap data structure retains its binary nature.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道任何索引为i的对象的两个子节点位于索引*2i + 1*和*2i + 2*，我们同样知道任何索引为i的对象的父节点位于*(i - 1) / 2*。这个公式之所以有效，是因为结果值被定义为整数，这意味着任何浮点值都会被截断，只保留整数值。这个算法通过`OrderHeap()`方法中的`int
    parentPosition = (i - 1) / 2;`代码实现，确保堆数据结构保持其二进制性质。
- en: Using the `min` heap property formula, the `for` loop first identifies the parent
    index for the current node. Next, the value of the current node's `Data` field
    is compared to that of the parent; if the parent is larger, the method calls `SwapElements(parentPosition,
    i)`. Once each of the nodes has been evaluated, the method is complete and the
    heap property is consistent throughout the collection.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最小堆属性公式，`for` 循环首先确定当前节点的父索引。接下来，将当前节点 `Data` 字段的值与父节点的值进行比较；如果父节点更大，则方法调用
    `SwapElements(parentPosition, i)`。一旦评估了每个节点，方法就完成了，整个集合的堆属性是一致的。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that, by switching the two operands of the `if` statement, or by simply
    changing the comparator from `>` to `<`, or, our collection would effectively
    change from a min heap to a max heap. Using this knowledge, it would be very simple
    indeed to create a heap collection that could be defined as either a `min` heap
    or a `max` heap at *runtime*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过交换 `if` 语句的两个操作数，或者简单地更改比较器从 `>` 到 `<`，或者，我们的集合实际上会从最小堆变为最大堆。利用这一知识，确实可以非常简单地创建一个堆集合，该集合可以在
    *运行时* 被定义为最小堆或最大堆。
- en: The `SwapElements(int firstIndex, int secondIndex)` method's function is self-explanatory.
    Each of the nodes at the given indices is swapped to enforce the heap property.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`SwapElements(int firstIndex, int secondIndex)` 方法的功能是显而易见的。给定索引处的每个节点都被交换，以强制执行堆属性。'
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using the same rule, which states that the two children of any object at index
    i are located at indices *2i + 1* and *2i + 2*, the `GetChildren(int parentIndex)`
    method gathers and returns the two child nodes for a given parent index. The method
    first confirms that `parentIndex` is not less than `0`, otherwise it returns `null`.
    If the `parentIndex` is valid, the method creates a new `List<Heapnode>` and populates
    it using the calculated child indices before returning the `children` collection.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的规则，即任何对象的索引为 i 的两个子节点位于索引 *2i + 1* 和 *2i + 2*，`GetChildren(int parentIndex)`
    方法会收集并返回给定父索引的两个子节点。该方法首先确认 `parentIndex` 不小于 `0`，否则返回 `null`。如果 `parentIndex`
    有效，该方法会创建一个新的 `List<Heapnode>` 并使用计算出的子索引填充它，然后返回 `children` 集合。
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, `GetParent(int childIndex)` works on the same principle as `GetChildren`.
    If the given `childIndex` is greater than `0` the node has a parent. The method
    confirms that we are not searching for the root node and also confirms that the
    index is not out of bounds for the collection. If either check fails, the method
    returns `null`. Otherwise, the method determines the node's parent index and then
    returns the node found at that index.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`GetParent(int childIndex)` 方法与 `GetChildren` 方法的工作原理相同。如果给定的 `childIndex`
    大于 `0`，则节点有一个父节点。该方法确认我们不是在搜索根节点，并确认索引不在集合的界限之外。如果任一检查失败，该方法返回 `null`。否则，该方法确定节点的父索引，然后返回在该索引处找到的节点。
- en: '**Java**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'Java also provides the basic tools necessary to build a robust implementation
    of our `MinHeap` class with little code. Here''s how that class might look in
    Java:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Java 还提供了构建我们 `MinHeap` 类的健壮实现所需的基本工具，而无需编写太多代码。以下是该类在 Java 中的可能外观：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our `MinHeap` class includes one public field of abstract type `List<HeapNode>`
    named `elements` that represents our heap collection. The class also include a
    method named `size()`, which will return the total number of elements in the collection.
    Finally, our constructor simply initializes the `elements` collection as an `ArrayList<HeapNode>`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `MinHeap` 类包括一个名为 `elements` 的公共字段，其类型为抽象类型 `List<HeapNode>`，代表我们的堆集合。该类还包括一个名为
    `size()` 的方法，它将返回集合中的元素总数。最后，我们的构造函数只是将 `elements` 集合初始化为 `ArrayList<HeapNode>`：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `insert(HeapNode item)` method accepts a new `HeapNode` object and adds
    it to the collection. Once the object has been added, the method calls `orderHeap()` to
    make sure the new object is placed in the correct position to maintain the heap
    property.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert(HeapNode item)` 方法接受一个新的 `HeapNode` 对象并将其添加到集合中。一旦对象被添加，该方法调用 `orderHeap()`
    确保新对象被放置在正确的位置以保持堆属性。'
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `delete(HeapNode item)` method accepts a `HeapNode` item to be removed from
    the collection. The method first finds the index of the item to be removed, then
    gets the index of the last object in the collection. Next, the method deletes
    the matching node by overwriting its position with a reference to the last node
    in the heap and then the last node is removed. Finally, `orderHeap()` is called
    to ensure the final collection satisfies the heap property.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete(HeapNode item)` 方法接受一个要从中移除的 `HeapNode` 项目。该方法首先找到要删除的项目索引，然后获取集合中最后一个对象的索引。接下来，通过将堆中最后一个节点的引用覆盖到该位置来删除匹配的节点，然后删除最后一个节点。最后，调用
    `orderHeap()` 确保最终的集合满足堆属性。'
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `extractMin()` method first confirms that the `elements` collection has
    at least one element. If not, the method returns `null`. Otherwise the method
    creates a new instance of `HeapNode` called `item` and sets it to the root object
    in the collection, which is the smallest object or the object with the lowest
    priority. Next, the method calls `delete(item)` to remove the node from the collection.
    Finally, since the `ExtractMin` function must return an object, the method returns
    `item` to the caller.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`extractMin()` 方法首先确认 `elements` 集合至少有一个元素。如果没有，该方法返回 `null`。否则，该方法创建一个名为 `item`
    的新 `HeapNode` 实例，并将其设置为集合中的根对象，即最小的对象或具有最低优先级的对象。接下来，该方法调用 `delete(item)` 从集合中删除该节点。最后，由于
    `ExtractMin` 函数必须返回一个对象，因此该方法将 `item` 返回给调用者。'
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `findMin()` method is very similar to the `extractMin()` method, except
    that it does not remove the returned minimum value from the collection. The method
    first confirms that the elements collection has at least one element. If not,
    the method returns `null`. Otherwise the method returns the root object in the
    collection by calling `elements.get(0)`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`findMin()` 方法与 `extractMin()` 方法非常相似，不同之处在于它不会从集合中删除返回的最小值。该方法首先确认 `elements`
    集合至少有一个元素。如果没有，该方法返回 `null`。否则，该方法通过调用 `elements.get(0)` 返回集合中的根对象。'
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The private `orderHeap()` method is responsible for maintaining the heap property
    of the collection. The method first establishes a `for` loop based on the length
    of the elements collection, and begins iterating through the collection from the
    end to the beginning.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 私有的 `orderHeap()` 方法负责维护集合的堆属性。该方法首先根据 `elements` 集合的长度建立 `for` 循环，并从集合的末尾开始迭代到开头。
- en: Using the min heap property formula, the `for` loop first identifies the parent
    index for the current node. Next, the value of the current node's `Data` field
    is compared to that of the parent, and if the parent is larger, the method calls
    `swapElements(parentPosition, i)`. Once each of the nodes has been evaluated,
    the method is complete and the heap property is consistent throughout the collection.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最小堆属性公式，`for` 循环首先确定当前节点的父索引。接下来，将当前节点的 `Data` 字段值与父节点的值进行比较，如果父节点更大，则调用 `swapElements(parentPosition,
    i)`。一旦评估了每个节点，方法就完成了，并且整个集合的堆属性是一致的。
- en: The `swapElements(int firstIndex, int secondIndex)` method's function is self-explanatory.
    Each of the nodes at the given indices is swapped to enforce the heap property.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`swapElements(int firstIndex, int secondIndex)` 方法的功能是显而易见的。给定索引处的每个节点都被交换，以强制执行堆属性。'
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using the same rule, which states that the two children of any object at index
    i are located at indices *2i + 1* and *2i + 2*, the `getChildren(int parentIndex)`
    method gathers and returns the two child nodes for a given parent index. The method
    first confirms that `parentIndex` is not less than 0, otherwise it returns `null`.
    If the `parentIndex` is valid, the method creates a new `ArrayList<Heapnode>`
    and populates it using the calculated child indices before returning the `children`
    collection.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的规则，即任何对象的两个子节点位于索引 *2i + 1* 和 *2i + 2*，`getChildren(int parentIndex)` 方法收集并返回给定父索引的两个子节点。该方法首先确认
    `parentIndex` 不小于 0，否则返回 `null`。如果 `parentIndex` 有效，该方法创建一个新的 `ArrayList<Heapnode>`
    并使用计算出的子索引填充它，然后再返回 `children` 集合。
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, `getParent(int childIndex)` works on the same principle as `getChildren`.
    If the given `childIndex` is greater than 0 the node has a parent. The method
    confirms that we are not searching for the root node and also confirms that the
    index is not out of bounds for the collection. If either check fails, the method
    returns `null`. Otherwise, the method determines the node's parent index and then
    returns the node found at that index.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`getParent(int childIndex)` 与 `getChildren` 的工作原理相同。如果给定的 `childIndex` 大于
    0，则节点有一个父节点。该方法确认我们不是在搜索根节点，并确认索引不在集合的界限之外。如果任一检查失败，则方法返回 `null`。否则，该方法确定节点的父索引，然后返回在该索引处找到的节点。
- en: '**Objective-C**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'Using an `NSMutableArray` as the core structure, Objective-C can also easily
    implement the min heap data structure. Here''s how the `EDSMinHeap` class might
    look in Objective-C:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `NSMutableArray` 作为核心结构，Objective-C 也可以轻松实现最小堆数据结构。以下是 `EDSMinHeap` 类在 Objective-C
    中的可能外观：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using the class cluster `NSMutableArray`, we create an ivar for our class called
    `_elements`. Our initializer instantiates this array, giving us the underlying
    data structure to build our `EDSMinHeap` class on.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类簇 `NSMutableArray`，我们为我们的类创建一个名为 `_elements` 的 ivar。初始化器实例化此数组，为我们构建 `EDSMinHeap`
    类提供了底层数据结构。
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Our `EDSMinHeap` class includes one public property named `Count`, and the `getCount()`
    accessor returns the `count` property of the `_elements` array.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `EDSMinHeap` 类包括一个名为 `Count` 的公共属性，`getCount()` 访问器返回 `_elements` 数组的 `count`
    属性。
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `insert:` method accepts a new `EDSHeapNode` object and adds it to the
    array. Once the object has been added, the method calls `orderHeap` to make sure
    the new object is placed in the correct position to maintain the heap property:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert:` 方法接受一个新的 `EDSHeapNode` 对象并将其添加到数组中。一旦对象被添加，该方法就调用 `orderHeap` 确保新对象被放置在正确的位置以维护堆属性：'
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `delete:` method accepts an `EDSHeapNode` item to be removed from the collection.
    The method first finds the index of the item to be removed using `indexOfObject:`,
    then deletes the matching node by overwriting its position with a reference to
    the `lastObject` in the heap. Next, the last node is removed using `removeLastObject`.
    Finally, `orderHeap:` is called to ensure the final collection satisfies the heap
    property.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete:` 方法接受一个要从中移除的 `EDSHeapNode` 对象。该方法首先使用 `indexOfObject:` 找到要移除的对象的索引，然后通过用堆中的
    `lastObject` 的引用覆盖其位置来删除匹配的节点。接下来，使用 `removeLastObject` 移除最后一个节点。最后，调用 `orderHeap:`
    确保最终的集合满足堆属性。'
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `extractMin` method first confirms that the `_elements` collection has at
    least one element. If not, the method returns `nil`. Otherwise, the method creates
    a new instance of `EDSHeapNode` called `item` and sets it to the root object in
    the collection, which is the smallest object or the object with the lowest priority.
    Next, the method calls `delete:` to remove the node from the collection. Finally,
    since the *ExtractMin* function must return an object, the method returns `item`
    to the caller.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`extractMin` 方法首先确认 `_elements` 集合至少有一个元素。如果没有，该方法返回 `nil`。否则，该方法创建一个名为 `item`
    的新 `EDSHeapNode` 实例，并将其设置为集合中的根对象，即最小的对象或具有最低优先级的对象。接下来，该方法调用 `delete:` 从集合中删除该节点。最后，由于
    *ExtractMin* 函数必须返回一个对象，因此该方法将 `item` 返回给调用者。'
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `findMin` method is very similar to the `extractMin` method, except that
    it does not remove the returned minimum value from the collection. The method
    first confirms that the elements collection has at least one element. If not,
    the method returns `nil`. Otherwise the method returns the first object in the
    collection, which is the root node.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`findMin` 方法与 `extractMin` 方法非常相似，不同之处在于它不会从集合中移除返回的最小值。该方法首先确认元素集合至少有一个元素。如果没有，该方法返回
    `nil`。否则，该方法返回集合中的第一个对象，即根节点。'
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The private `orderHeap` method is responsible for maintaining the heap property
    of the collection. The method first establishes a `for` loop based on the length
    of the elements collection, and begins iterating through the collection from the
    end to the beginning.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 私有的 `orderHeap` 方法负责维护集合的堆属性。该方法首先根据元素集合的长度建立 `for` 循环，并从后向前遍历集合。
- en: Using the min heap property formula, the `for` loop first identifies the parent
    index for the current node. Next, the value of the current node's `data` property
    is compared to that of the parent, and if the parent is larger, the method calls
    `swapElement:withElement:`. Once each of the nodes has been evaluated, the method
    is complete and the heap property is consistent throughout the collection.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最小堆属性公式，`for`循环首先识别当前节点的父索引。接下来，将当前节点`data`属性的值与父节点的值进行比较，如果父节点更大，则方法调用`swapElement:withElement:`。一旦每个节点都被评估，方法就完成了，整个集合的堆属性是一致的。
- en: The `swapElement:withElement:` method's function is self-explanatory. Each of
    the nodes at the given indices is swapped to enforce the heap property.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`swapElement:withElement:`方法的功能是显而易见的。给定索引处的每个节点都被交换，以强制执行堆属性。'
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using the rule that states the two children of any object at index i are located
    at indices *2i + 1* and *2i + 2*, the `childrenOfParentIndex:` method gathers
    and returns the two child nodes for a given parent index. The method first confirms
    that `parentIndex` is not less than 0, otherwise it returns `nil`. If the `parentIndex`
    is valid, the method creates a new `NSMutableArray` and populates it using nodes
    from the calculated child indices before returning the `children` collection.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用规定任何对象在索引i处的两个子节点位于索引*2i + 1*和*2i + 2*的规则，`childrenOfParentIndex:`方法收集并返回给定父索引的两个子节点。该方法首先确认`parentIndex`不小于0，否则返回`nil`。如果`parentIndex`有效，则方法创建一个新的`NSMutableArray`，并使用计算出的子索引中的节点填充它，然后返回`children`集合。
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, `parentOfChildIndex:` works on the same principle as `childrenOfParentIndex:`.
    If the given `childIndex` is greater than 0, the node has a parent. The method
    confirms that we are not searching for the root node and also confirms that the
    index is not out of bounds for the collection. If either check fails, the method
    returns `nil`. Otherwise, the method determines the node's parent index and then
    returns the node found at that index.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`parentOfChildIndex:`与`childrenOfParentIndex:`的工作原理相同。如果给定的`childIndex`大于0，则节点有一个父节点。该方法确认我们不是在搜索根节点，并且也确认索引不在集合的界限之外。如果任一检查失败，则方法返回`nil`。否则，该方法确定节点的父索引，然后返回在该索引处找到的节点。
- en: '**Swift**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Our Swift `MinHeap` class is similar in structure and functionality to the
    C# and Java implementations. Here''s what an example of the `MinHeap` class might
    look like in Swift:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Swift `MinHeap`类在结构和功能上与C#和Java实现相似。以下是一个Swift中`MinHeap`类的示例：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using the `Array` class we create a private property for our class called `_elements`.
    Since our property is declared and instantiated simultaneously, and there is no
    other custom code requiring instantiation, we can exclude the explicit public
    initializer and rely on the default initializer. Our class also provides a public
    method called `getCount()`, which returns the size of the `_elements` array.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Array`类，我们为我们的类创建一个名为`_elements`的私有属性。由于我们的属性是声明和实例化同时进行的，并且没有其他需要实例化的自定义代码，我们可以排除显式的公共初始化器并依赖于默认初始化器。我们的类还提供了一个名为`getCount()`的公共方法，它返回`_elements`数组的大小。
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `insert(HeapNode item)` method accepts a new `HeapNode` object and adds
    it to the collection. Once the object has been added the method calls `orderHeap()`to
    make sure the new object is placed in the correct position to maintain the heap
    property.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert(HeapNode item)`方法接受一个新的`HeapNode`对象并将其添加到集合中。一旦对象被添加，方法就调用`orderHeap()`以确保新对象被放置在正确的位置以保持堆属性。'
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `delete(HeapNode item)` method accepts a `HeapNode` item to be removed from
    the collection. The method first finds the `index` of the item to be removed,
    then deletes the matching node by overwriting its position with a reference to
    the `last` object in the heap. Finally, the `orderHeap()` method is called to
    ensure the final collection satisfies the heap property.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete(HeapNode item)`方法接受一个要从集合中删除的`HeapNode`项。该方法首先找到要删除的项的`index`，然后通过用堆中的`last`对象的引用覆盖其位置来删除匹配的节点。最后，调用`orderHeap()`方法以确保最终的集合满足堆属性。'
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `extractMin()` method first confirms that the `elements` collection has
    at least one element. If not, the method returns `nil`. Otherwise the method creates
    a new variable called `item` and sets it to the root object in the collection,
    which is the smallest `HeapNode` or the `HeapNode` with the lowest priority. Next,
    the method calls `delete(item: Heapnode)` to remove the node from the collection.
    Finally, the method returns `item` to the caller.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`extractMin()` 方法首先确认 `elements` 集合至少有一个元素。如果没有，则方法返回 `nil`。否则，该方法创建一个名为 `item`
    的新变量，并将其设置为集合中的根对象，即最小的 `HeapNode` 或具有最低优先级的 `HeapNode`。接下来，该方法调用 `delete(item:
    Heapnode)` 从集合中删除节点。最后，该方法将 `item` 返回给调用者。'
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `findMin()` method is very similar to the `extractMin()` method, except
    that it does not remove the returned minimum value from the collection. The method
    first confirms that the elements collection has at least one element. If not,
    the method returns `nil`. Otherwise the method returns `_elements[0]`, which is
    the root object in the collection.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`findMin()` 方法与 `extractMin()` 方法非常相似，不同之处在于它不会从集合中移除返回的最小值。该方法首先确认元素集合至少有一个元素。如果没有，则方法返回
    `nil`。否则，该方法返回 `_elements[0]`，这是集合中的根对象。'
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The private `orderHeap()` method is responsible for maintaining the heap property
    of the collection. The method first establishes a `for` loop based on the length
    of the elements collection, and begins iterating through the collection from the
    end to the beginning.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 私有 `orderHeap()` 方法负责维护集合的堆属性。该方法首先根据元素集合的长度建立 `for` 循环，并从末尾开始迭代集合。
- en: 'Using the min heap property formula, the `for` loop first identifies the parent
    index for the current node. Next, the value of the current node''s `data` field
    is compared to that of the parent, and if the parent is larger, the method calls
    `swapElements(first: Int, second: Int)`. Once each of the nodes has been evaluated,
    the method is complete and the heap property is consistent throughout the collection.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '使用最小堆属性公式，`for` 循环首先确定当前节点的父索引。然后，将当前节点 `data` 字段的值与父节点的值进行比较，如果父节点更大，则方法调用
    `swapElements(first: Int, second: Int)`。一旦评估了每个节点，方法完成，整个集合的堆属性保持一致。'
- en: 'The `swapElements(int firstIndex, int secondIndex)` method''s function is self-explanatory.
    Each of the nodes at the given indices is swapped to enforce the heap property:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`swapElements(int firstIndex, int secondIndex)` 方法的功能是显而易见的。给定索引处的每个节点都被交换，以强制执行堆属性：'
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Using the same rule that states the two children of any object at index `i`
    are located at indices *2i + 1* and *2i + 2*, the `getChildren(parentIndex: Int)`
    method gathers and returns the two child nodes for a given parent index. The method
    first confirms that `parentIndex` is not less than 0, otherwise it returns `nil`.
    If the `parentIndex` is valid, the method creates a new `Array` of `HeapNode`
    objects and populates it using the calculated child indices before returning the
    `children` collection:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '使用相同的规则，即任何对象的索引 `i` 的两个子节点位于索引 *2i + 1* 和 *2i + 2*，`getChildren(parentIndex:
    Int)` 方法收集并返回给定父索引的两个子节点。该方法首先确认 `parentIndex` 不小于 0，否则返回 `nil`。如果 `parentIndex`
    有效，该方法创建一个新的 `Array`，包含 `HeapNode` 对象，并使用计算出的子索引填充它，然后返回 `children` 集合：'
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, `getParent(childIndex: Int)` works on the same principle as `getChildren`.
    If the given `childIndex` is greater than `0` the node has a parent. The method
    confirms that we are not searching for the root node and also confirms that the
    index is not out of bounds for the collection. If either check fails, the method
    returns `nil`. Otherwise, the method determines the node''s parent index and then
    returns the node found at that index.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，`getParent(childIndex: Int)` 方法与 `getChildren` 方法的工作原理相同。如果给定的 `childIndex`
    大于 `0`，则节点有一个父节点。方法确认我们不是在寻找根节点，并确认索引不在集合的界限之外。如果任一检查失败，则方法返回 `nil`。否则，方法确定节点的父索引，然后返回在该索引处找到的节点。'
- en: Common applications
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见应用
- en: 'Heap data structures are actually quite common, although you may not always
    realize you are working with one. Here are some of the most common applications
    for the heap data structure:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 堆数据结构实际上相当常见，尽管你可能并不总是意识到你正在处理一个。以下是堆数据结构最常见的应用之一：
- en: '**Selection algorithms**: A selection algorithm is used to determine the k^(th)
    smallest or largest element in a collection, or the median valued object of a
    collection. In a typically collection, this operation costs O(n). However, in
    an ordered heap implemented with an array finding the k^(th) element is an **O**(1)
    operation because we can find the element by simply examining the k index in the
    array.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择算法**：选择算法用于确定集合中的第k个最小或最大元素，或者集合的中值对象。在通常的集合中，这种操作的成本为O(n)。然而，在一个使用数组实现的有序堆中，找到第k个元素是一个**O**(1)操作，因为我们只需简单地检查数组中的k索引即可找到该元素。'
- en: '**Priority queue**: Priority queues are an abstract data structure similar
    to standard queues except that the nodes contain an additional value representing
    the priority of that object in relation to others in the collection. Due to the
    natural sorting of the heap data structure, priority queues are often implemented
    using the heap.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先队列**：优先队列是一种类似于标准队列的抽象数据结构，除了节点包含一个额外的值，表示该对象相对于集合中其他对象的优先级。由于堆数据结构的自然排序，优先队列通常使用堆来实现。'
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about heap data structures. We examined the most
    common operations when working with heaps and their complexity cost. Following
    this we created our own simple min heap data structure class from scratch, and
    discussed how the min heap property formula is used to calculate parents or children
    for any given node index. Finally, we examined the most common applications for
    heap data structures.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了堆数据结构。我们考察了与堆一起工作时最常用的操作及其复杂度成本。随后，我们从头开始创建了自己的简单最小堆数据结构类，并讨论了如何使用最小堆属性公式来计算任何给定节点索引的父节点或子节点。最后，我们考察了堆数据结构最常见的应用。
