- en: Chapter 4. Working with a RESTful API and Pulse Width Modulation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 使用RESTful API和脉冲宽度调制
- en: 'In this chapter, we will interact with the board with HTTP requests and we
    will use pulse width modulation to generate different output voltages. We shall:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过HTTP请求与板子交互，并使用脉冲宽度调制来生成不同的输出电压。我们将：
- en: Work with the Tornado web server to build a RESTful API in Python
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Tornado网络服务器在Python中构建RESTful API
- en: Compose and send HTTP requests to print numbers in LEDs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合并发送HTTP请求以在LED上打印数字
- en: Work with pulse width modulation to control the output voltage in pins
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脉冲宽度调制控制引脚上的输出电压
- en: Fade in and fade out LEDs connected to the board
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 淡入和淡出连接到板子的LED
- en: Use different tools to compose and send HTTP requests that interact with the
    board
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的工具来组合和发送与板子交互的HTTP请求
- en: Build a RESTful API to mix red, green and blue and generate millions of colors
    with an RGB LED
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RGB LED构建RESTful API来混合红色、绿色和蓝色，并生成数百万种颜色
- en: Use the `mraa` and `wiring-x86` libraries to control pulse width modulation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`mraa`和`wiring-x86`库来控制脉冲宽度调制
- en: Printing numbers in LEDs with a RESTful API
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RESTful API在LED上打印数字
- en: 'Tornado is a Python web framework and asynchronous networking library. It is
    well known for providing great scalability due to its non-blocking network I/O.
    We will take advantage of the fact that Tornado makes it really easy to build
    a RESTful API and make it possible for any client to consume this API and print
    numbers in LEDs connected to the board. The following is the web page for the
    Tornado web server: [http://www.tornadoweb.org](http://www.tornadoweb.org).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Tornado是一个Python网络框架和异步网络库。它因其非阻塞网络I/O而广为人知，提供了出色的可伸缩性。我们将利用Tornado使得构建RESTful
    API变得非常容易，并使任何客户端都能消费这个API，并在连接到板子的LED上打印数字。以下是为Tornado网络服务器提供的网页：[http://www.tornadoweb.org](http://www.tornadoweb.org)。
- en: In [Chapter 1](ch01.html "Chapter 1. Understanding and Setting up the Base IoT
    Hardware"), *Understanding and Setting up the Base IoT Hardware*, we installed
    the `pip` installer to easily install additional Python 2.7.3 packages in the
    Yocto Linux that we are running on the board. Now, we will use a `pip` installer
    to install Tornado 4.3\. We just need to run the following command in the SSH
    terminal to install the package.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 理解和设置基础物联网硬件")*理解和设置基础物联网硬件*中，我们安装了`pip`安装程序，以便在板子上运行的Yocto
    Linux中轻松安装额外的Python 2.7.3包。现在，我们将使用`pip`安装程序来安装Tornado 4.3。我们只需在SSH终端中运行以下命令即可安装该包。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The last lines for the output will indicate that the `tornado` package has been
    successfully installed. Don't worry about the error messages related to building
    wheel and the insecure platform warning.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示`tornado`包已成功安装。不要担心与构建轮和平台不安全警告相关的错误消息。
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we will install HTTPie, a command-line HTTP client written in Python that
    makes it easy to send HTTP requests and uses a syntax that is easier than curl
    (also known as cURL). HTTPie displays colorized output and will make it easy for
    us to send HTTP requests to test our RESTful API. We just need to run the following
    command in the SSH terminal to install the package.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将安装HTTPie，这是一个用Python编写的命令行HTTP客户端，它使得发送HTTP请求变得容易，并使用比curl（也称为cURL）更简单的语法。HTTPie显示彩色输出，这将使我们能够轻松发送HTTP请求来测试我们的RESTful
    API。我们只需在SSH终端中运行以下命令即可安装该包。
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The last lines for the output will indicate that the `httpie` package has been
    successfully installed. Don't worry about the insecure platform warning.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示`httpie`包已成功安装。不要担心平台不安全警告。
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we can use an `http` command to easily send HTTP requests to `localhost`
    and test the RESTful API built with Tornado. Obviously, after we test that the
    RESTful API is working OK locally, we want to send HTTP requests from a computer
    or device connected to our LAN. You can install HTTPie in your computer or use
    any other application that allows you to compose and send HTTP requests, such
    as the previously mentioned curl utility ([http://curl.haxx.se](http://curl.haxx.se))
    or Telerik Fiddler ([http://www.telerik.com/fiddler](http://www.telerik.com/fiddler))
    in case you are working on Windows. Telerik Fiddler is a free web debugging proxy
    with a GUI but it only runs on Windows. You can even use apps that can compose
    and send HTTP requests from mobile devices and test the RESTful API by using them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `http` 命令轻松地向 `localhost` 发送 HTTP 请求并测试使用 Tornado 构建的 RESTful API。显然，在我们测试本地
    RESTful API 正常工作后，我们希望从连接到我们局域网的计算机或设备发送 HTTP 请求。你可以在你的计算机上安装 HTTPie 或使用任何其他允许你编写和发送
    HTTP 请求的应用程序，例如之前提到的 curl 工具([http://curl.haxx.se](http://curl.haxx.se)) 或在 Windows
    系统上使用的 Telerik Fiddler([http://www.telerik.com/fiddler](http://www.telerik.com/fiddler))。Telerik
    Fiddler 是一个带有图形用户界面的免费网页调试代理，但它只能在 Windows 上运行。你甚至可以使用能够从移动设备编写和发送 HTTP 请求的应用程序，并通过它们测试
    RESTful API。
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are working on either OS X or Linux, you can open a Terminal and start
    using curl from the command line. If you are working on Windows, you can easily
    install curl from the Cygwin package installation option, and execute it from
    the Cygwin terminal.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 OS X 或 Linux 系统，你可以打开终端并从命令行开始使用 curl。如果你正在使用 Windows 系统，你可以轻松地从 Cygwin
    软件包安装选项中安装 curl，并在 Cygwin 终端中执行它。
- en: In order to build a RESTful API with Tornado, first we have to create subclasses
    of the `tornado.web.RequestHandler` class and override the necessary methods to
    handle the HTTP requests to the URL. For example, if we want to handle an HTTP
    `GET` request with a synchronous operation, we must create a new subclass of the
    `tornado.web.RequestHandler` class and define the `get` method with the required
    arguments, if any. If we want to handle an HTTP `PUT` request, we just need to
    define the `put` method with the required arguments. Then, we have to map the
    URL pattern in an instance of the `tornado.web.Application` class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Tornado 构建 RESTful API，我们首先必须创建 `tornado.web.RequestHandler` 类的子类并重写必要的处理
    HTTP 请求到 URL 的方法。例如，如果我们想处理一个同步操作的 HTTP `GET` 请求，我们必须创建 `tornado.web.RequestHandler`
    类的新子类并定义带有所需参数的 `get` 方法（如果有）。如果我们想处理 HTTP `PUT` 请求，我们只需定义带有所需参数的 `put` 方法。然后，我们必须在
    `tornado.web.Application` 类的实例中映射 URL 模式。
- en: 'The following lines show the new classes that we must add to our existing code
    with either the `mraa` or the `wiring-x86` libraries that made it possible to
    print numbers in LEDs in the previous chapter. We already had the `Led` and `NumberInLeds`
    classes and the code adds the following classes: `BoardInteraction`, `VersionHandler`,
    `PutNumberInLedsHandler`, `GetCurrentNumberHandler`. The code file for the sample
    is `iot_python_chapter_04_01.py`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行展示了我们必须添加到现有代码中的新类，无论是使用 `mraa` 还是 `wiring-x86` 库，这些库使得在前一章中在 LED 中打印数字成为可能。我们已经有
    `Led` 和 `NumberInLeds` 类，代码添加了以下类：`BoardInteraction`、`VersionHandler`、`PutNumberInLedsHandler`、`GetCurrentNumberHandler`。示例代码文件为
    `iot_python_chapter_04_01.py`。
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `BoardInteraction` class declares two class attributes: `number_in_leds`
    and `current_number`. The other classes define methods that work with these class
    attributes, to access a common `NumberInLeds` instance, saved in `number_in_leds`,
    and the current number that is being displayed with LEDs, saved in `current_number`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoardInteraction` 类声明了两个类属性：`number_in_leds` 和 `current_number`。其他类定义了与这些类属性一起工作的方法，以访问保存在
    `number_in_leds` 中的公共 `NumberInLeds` 实例，以及保存在 `current_number` 中的当前通过 LED 显示的数字。'
- en: 'The code declares the following three subclasses of `tornado.web.RequestHandler`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了以下三个 `tornado.web.RequestHandler` 的子类：
- en: '`VersionHandler`: Defines the parameter less `get` method that returns a response
    with the version number and the last build date.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VersionHandler`：定义了一个无参数的 `get` 方法，该方法返回包含版本号和最后构建日期的响应。'
- en: '`PutNumberInLedsHandler`: Defines the `put` method that requires a number argument
    that specifies the number that has to be printed with LEDs. The method calls the
    `print_number` method for the `NumberInLeds` instance stored in the `BoardInteraction.number_in_leds`
    class attribute with the desired number of LEDs to be turned on specified in the
    `number` attribute. Then, the code saves the number that is being printed with
    LEDs in the `BoardInteraction.current_number` class attribute and returns a response
    with the printed number.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PutNumberInLedsHandler`: 定义了一个需要数字参数的 `put` 方法，该参数指定了必须通过LED打印的数字。该方法调用存储在
    `BoardInteraction.number_in_leds` 类属性中的 `NumberInLeds` 实例的 `print_number` 方法，并使用在
    `number` 属性中指定的要开启的LED数量。然后，代码将正在打印的数字保存到 `BoardInteraction.current_number` 类属性中，并返回一个包含打印数字的响应。'
- en: '`GetCurrentNumberHandler`: Defines the parameter less `get` method that returns
    a response with the value of the `BoardInteraction.current_number` class attribute,
    that is, the number that is being printed with LEDs.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetCurrentNumberHandler`: 定义了一个参数较少的 `get` 方法，该方法返回一个包含 `BoardInteraction.current_number`
    类属性值的响应，即正在通过LED打印的数字。'
- en: The following lines use the previously declared subclasses of `tornado.web.RequestHandler`
    to make up the web application with Tornado that represents the RESTful API and
    the new `__main__` method. The code file for the sample is `iot_python_chapter_04_01.py`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的行使用先前声明的 `tornado.web.RequestHandler` 的子类来使用Tornado构建网络应用程序，代表RESTful API和新的
    `__main__` 方法。示例代码文件为 `iot_python_chapter_04_01.py`。
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, the code creates an instance of the `tornado.web.Application` class named
    `application` with the list of request handlers that make up the web application.
    The code passes a list of tuples to the `Application` constructor. The list is
    composed of a regular expression (`regexp`) and a subclass of `tornado.web.RequestHandler`
    (`request_class`).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码创建了一个名为 `application` 的 `tornado.web.Application` 类实例，其中包含组成网络应用程序的请求处理器列表。代码将一个元组列表传递给
    `Application` 构造函数。该列表由正则表达式（`regexp`）和 `tornado.web.RequestHandler` 的子类（`request_class`）组成。
- en: The `__main__` method prints a message indicating the port number in which the
    HTTP server is listening and uses the `NumberInLeds` instance saved in `BoardInteraction.number_in_leds`
    to print number 0, that is, to turn off the nine LEDs. The next line calls the
    `application.listen` method to build an HTTP server for the application with the
    defined rules on the specified port. The code passes `8888` for the `port` argument,
    that is, the default port value for the Tornado HTTP server.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`__main__` 方法打印一条消息，指示HTTP服务器正在监听的端口号，并使用保存在 `BoardInteraction.number_in_leds`
    中的 `NumberInLeds` 实例打印数字0，即关闭九个LED。下一行调用 `application.listen` 方法，在指定的端口上为应用程序构建一个具有定义规则的HTTP服务器。代码将
    `8888` 作为 `port` 参数传递，即Tornado HTTP服务器的默认端口号。'
- en: 'Then, the call to `tornado.ioloop.IOLoop.instance().start()` starts the server
    created with `application.listen`. This way, whenever the web application receives
    a request, Tornado iterates over the list of request handlers that make up the
    web application and creates an instance of the first `tornado.web.RequestHandler`
    subclass whose associated regular expression matches the request path. Then, Tornado
    calls one of the following methods the corresponding parameters for the new instance
    based on the HTTP request:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，调用 `tornado.ioloop.IOLoop.instance().start()` 启动了使用 `application.listen`
    创建的服务器。这样，每当网络应用程序收到请求时，Tornado会遍历组成网络应用程序的请求处理器列表，并为第一个与请求路径匹配的关联正则表达式的 `tornado.web.RequestHandler`
    子类创建一个实例。然后，Tornado根据HTTP请求调用以下方法之一，并基于新实例的相应参数：
- en: '`head`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`head`'
- en: '`get`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`'
- en: '`post`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post`'
- en: '`delete`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`'
- en: '`patch`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patch`'
- en: '`put`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put`'
- en: '`options`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options`'
- en: The following table shows some HTTP requests that match the regular expressions
    defined in the preceding code. In this case, the HTTP requests use localhost because
    they are executed locally on the Yocto Linux running on the board. If we replace
    localhost with the board's assigned IP address, we can make the HTTP requests
    from any computer or device connected to our LAN.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了与前面代码中定义的正则表达式匹配的一些HTTP请求。在这种情况下，HTTP请求使用localhost，因为它们是在板上运行的Yocto Linux本地执行的。如果我们用板的分配IP地址替换localhost，我们就可以从任何连接到我们的LAN的计算机或设备发出HTTP请求。
- en: '| HTTP verb and request URL | Tuple (`regexp`, `request_class`) that matches
    the request path | `RequestHandler` subclass and method that is called |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| HTTP动词和请求URL | 匹配请求路径的元组（`regexp`，`request_class`） | 被调用的 `RequestHandler`
    子类和方法 |'
- en: '| --- | --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `GET http://localhost:8888/version` | `(r"/version", VersionHandler)])` |
    `VersionHandler.get()` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `GET http://localhost:8888/version` | `(r"/version", VersionHandler)])` |
    `VersionHandler.get()` |'
- en: '| `PUT http://localhost:8888/putnumberinleds/5` | `(r"/putnumberinleds/([0-9])",
    PutNumberInLedsHandler)` | `PutNumberInLedsHandler.put(5)` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `PUT http://localhost:8888/putnumberinleds/5` | `(r"/putnumberinleds/([0-9])",
    PutNumberInLedsHandler)` | `PutNumberInLedsHandler.put(5)` |'
- en: '| `PUT http://localhost:8888/putnumberinleds/8` | `(r"/putnumberinleds/([0-9])",
    PutNumberInLedsHandler)` | `PutNumberInLedsHandler.put(8)` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `PUT http://localhost:8888/putnumberinleds/8` | `(r"/putnumberinleds/([0-9])",
    PutNumberInLedsHandler)` | `PutNumberInLedsHandler.put(8)` |'
- en: '| `GET http://localhost:8888/getcurrentnumber` | `(r"/getcurrentnumber", GetCurrentNumberHandler)`
    | `GetCurrentNumberHandler.get()` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `GET http://localhost:8888/getcurrentnumber` | `(r"/getcurrentnumber", GetCurrentNumberHandler)`
    | `GetCurrentNumberHandler.get()` |'
- en: 'The `RequestHandler` class declares a `SUPPORTED_METHODS` class attribute with
    the following code. In this case, we haven''t overridden the class attribute,
    and therefore, we inherit superclass declaration:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestHandler`类声明了一个`SUPPORTED_METHODS`类属性，以下代码。在这种情况下，我们没有重写类属性，因此，我们继承了超类的声明：'
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The default code declared in the superclass for the `get`, `head`, `post`, `delete`,
    `patch`, `put`, and `options` methods is a single line that raises an `HTTPError`.
    For example, the following line shows the code for the `get` method defined in
    the `RequestHandler` class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在超类中声明的`get`、`head`、`post`、`delete`、`patch`、`put`和`options`方法的默认代码是一行，它会引发`HTTPError`。例如，以下行显示了在`RequestHandler`类中定义的`get`方法的代码。
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Whenever the web application receives a request and matches the URL pattern,
    Tornado performs the following actions:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时，Web应用程序收到请求并与URL模式匹配，Tornado都会执行以下操作：
- en: Create a new instance of the `RequestHandler` subclass that has been mapped
    to the URL pattern.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个映射到URL模式的`RequestHandler`子类的实例。
- en: Call the `initialize` method with the keyword arguments specified in the application
    configuration. We can override the `initialize` method to save the arguments into
    member variables.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用应用程序配置中指定的关键字参数调用`initialize`方法。我们可以重写`initialize`方法，将参数保存到成员变量中。
- en: No matter which is the HTTP request, call the `prepare` method. If we call either
    `finish` or `send_error`, Tornado won't call any additional methods. We can override
    the `prepare` method to execute code that is necessary for any HTTP request and
    then write the specific code in the `get`, `head`, `post`, `delete`, `patch`,
    `put` or `options` methods.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论哪个HTTP请求，调用`prepare`方法。如果我们调用`finish`或`send_error`，Tornado不会调用任何其他方法。我们可以重写`prepare`方法来执行任何HTTP请求所需的代码，然后在`get`、`head`、`post`、`delete`、`patch`、`put`或`options`方法中编写特定的代码。
- en: Call the method according to the HTTP request with the arguments based on the
    URL regular expression that captured the different groups. As previously explained,
    we must override the methods we want our `RequestHandler` subclass to be able
    to process. For example, if there was an HTTP `GET` request, Tornado will call
    the `get` method with the different arguments.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据基于URL正则表达式捕获的不同组调用方法。如前所述，我们必须重写我们希望我们的`RequestHandler`子类能够处理的方法。例如，如果有HTTP
    `GET`请求，Tornado将调用`get`方法并传递不同的参数。
- en: In this case, we are working with synchronous handlers, and therefore, Tornado
    calls `on_finish` after the previous method called according to the HTTP request
    returned. We can override the `on_finish` method to perform cleanup or logging.
    It is very important to understand that Tornado calls `on_finish` after it sent
    the response to the client.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在使用同步处理器，因此，Tornado在根据HTTP请求返回之前的方法调用后调用`on_finish`。我们可以重写`on_finish`方法来执行清理或记录。非常重要的一点是，Tornado在向客户端发送响应后调用`on_finish`。
- en: The following line will start the HTTP server and our RESTful API in the Yocto
    Linux running on the board. Don't forget that you need to transfer the Python
    source code file to the Yocto Linux with an SFTP client, as explained in the previous
    chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将在板上的Yocto Linux上启动HTTP服务器和我们的RESTful API。不要忘记，你需要使用SFTP客户端将Python源代码文件传输到Yocto
    Linux，正如前一章所述。
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After we start the HTTP server, we will see the following output and all the
    LEDs on the board are going to be turned off.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们启动HTTP服务器后，我们将看到以下输出，并且板上的所有LED都将关闭。
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Composing and sending HTTP requests
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组成和发送HTTP请求
- en: The HTTP server is running in Yocto Linux and waiting for our HTTP requests
    to control the LEDs on connected to the Intel Galileo Gen 2 board. Now, we will
    compose and send HTTP requests locally in Yocto Linux and then from other computer
    or devices connected to our LAN.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 服务器正在 Yocto Linux 上运行，等待我们的 HTTP 请求来控制连接到 Intel Galileo Gen 2 板上的 LED。现在，我们将在
    Yocto Linux 本地编写和发送 HTTP 请求，然后从其他计算机或设备发送，这些设备连接到我们的局域网。
- en: HTTPie supports curl-like shorthands for localhost. For example, `:8888` is
    a shorthand that expands to `http://localhost:8888`. We already have an SSH terminal
    running the HTTP server, and therefore, we can run the following command in another
    SSH terminal.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPie 支持类似 curl 的本地主机缩写。例如，`:8888` 是一个展开为 `http://localhost:8888` 的缩写。我们已经在另一个
    SSH 终端中运行了 HTTP 服务器，因此，我们可以在另一个 SSH 终端中运行以下命令。
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The previous command will compose and send the following HTTP request: `GET
    http://localhost:8888/version`. The request is the simplest case in our RESTful
    API because it will match and run the `VersionHandler.get` method that just receives
    `self` as a parameter because the URL pattern doesn''t include any parameters.
    The method creates a response dictionary and then calls the `self.write` method
    with `response` as a parameter. The `self.write` method writes the received chunk
    to the output buffer. Because the chunk (`response`) is a dictionary, `self.write`
    writes it as JSON and sets the `Content-Type` of the response to `application/json`.
    The following lines show an example response for the HTTP request, including the
    response headers:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组成并发送以下 HTTP 请求：`GET http://localhost:8888/version`。该请求是我们 RESTful API
    中的最简单情况，因为它将匹配并运行只接收 `self` 作为参数的 `VersionHandler.get` 方法，因为 URL 模式不包含任何参数。该方法创建一个响应字典，然后调用
    `self.write` 方法并将 `response` 作为参数。`self.write` 方法将接收到的数据块写入输出缓冲区。因为数据块（`response`）是一个字典，`self.write`
    将其作为 JSON 写入，并将响应的 `Content-Type` 设置为 `application/json`。以下行显示了 HTTP 请求的示例响应，包括响应头：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can execute HTTPie with the `-b` option in case we don't want to include
    the header in the response. For example, the following line performs the same
    HTTP request but doesn't display the header in the response output.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想在响应中包含头信息，我们可以使用 `-b` 选项执行 HTTPie。例如，以下行执行相同的 HTTP 请求，但不在响应输出中显示头信息。
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once we know that our request is running OK, we can open a new terminal, command-line
    or the GUI tool that we want to use to compose and send HTTP requests from a computer
    or any device connected to the LAN. We just need to use the IP address assigned
    to the board instead of `localhost` in our request URLs. Don't forget to replace
    `192.168.1.107` with your board's IP address in the next requests.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道我们的请求正在正常运行，我们可以打开一个新的终端、命令行或我们想要使用的 GUI 工具，从计算机或任何连接到局域网的设备上编写和发送 HTTP
    请求。我们只需要在我们的请求 URL 中使用分配给板的 IP 地址而不是 `localhost`。不要忘记在下一个请求中将 `192.168.1.107`
    替换为您的板 IP 地址。
- en: Now, we can run the following HTTPie command in a computer or device to use
    the RESTful API to make the board turn on the five LEDs. After you enter the command,
    you will notice the SSH terminal that displays the output for the Python code
    will display a message indicating that it is turning on 5 LEDs and the additional
    messages indicating the LEDs that are being turned on and off. In addition, you
    will see 5 LEDs turned on.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在计算机或设备上运行以下 HTTPie 命令来使用 RESTful API 使板上的五个 LED 点亮。在您输入命令后，您会注意到显示 Python
    代码输出的 SSH 终端将显示一条消息，表明它正在点亮 5 个 LED 以及指示正在点亮和关闭的 LED 的附加消息。此外，您将看到 5 个 LED 点亮。
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The previous command will compose and send the following HTTP request: `PUT
    http://192.168.1.107:8888/putnumberinleds/5`. The request will match and run the
    `PutNumberInLedsHandler.put` method that receives `5` in its `number` parameter.
    The following lines show the response from the HTTP server with the number that
    has been printed in LEDs, that is, the number of LEDs that have been turned on:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组成并发送以下 HTTP 请求：`PUT http://192.168.1.107:8888/putnumberinleds/5`。该请求将匹配并运行接收
    `5` 作为其 `number` 参数的 `PutNumberInLedsHandler.put` 方法。以下行显示了 HTTP 服务器的响应，其中包含了打印在
    LED 上的数字，即已点亮的 LED 数量：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The following image shows two Terminal windows side-by-side on OS X. The Terminal
    window at the left-hand side is running on a computer that is generating the HTTP
    requests and the Terminal window at the right-hand side is the SSH terminal that
    is running the Tornado HTTP server in Yocto Linux and displays the output for
    our Python code. It is a good idea to use a similar configuration to check the
    output while we compose and send the HTTP requests.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了 OS X 上并排的两个终端窗口。左侧的终端窗口在一台生成 HTTP 请求的计算机上运行，右侧的终端窗口是运行在 Yocto Linux
    上的 Tornado HTTP 服务器 SSH 终端，它显示了我们 Python 代码的输出。在组合和发送 HTTP 请求时检查输出，使用类似的配置是一个好主意。
- en: '![Composing and sending HTTP requests](img/B05042_04_01.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![组合和发送 HTTP 请求](img/B05042_04_01.jpg)'
- en: In Fiddler, click **Composer** or press *F9*, select **PUT** in the dropdown
    menu in the **Parsed** tab, and enter `192.168.1.107:8888/putnumberinleds/5` in
    the textbox at the right-hand side of the dropdown (don't forget to replace the
    IP with your board's IP). Then, click **Execute** and double-click on the 200
    result that appears on the capture log. If you want to see the raw response, just
    click on the **Raw** button below the **Request Headers** panel.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fiddler 中，点击 **Composer** 或按 *F9*，在 **Parsed** 选项卡的下拉菜单中选择 **PUT**，然后在下拉菜单右侧的文本框中输入
    `192.168.1.107:8888/putnumberinleds/5`（不要忘记将 IP 替换为您的板子 IP）。然后，点击 **Execute**
    并双击捕获日志中出现的 200 结果。如果您想查看原始响应，只需点击 **Request Headers** 面板下方的 **Raw** 按钮即可。
- en: The following image shows a Fiddler window side-by-side with a Putty terminal
    window on Windows. The Fiddler window at the left-hand side is running on a computer
    that is generating the HTTP requests and the Putty terminal window at the right-hand
    side is the SSH terminal that is running the Tornado HTTP server in Yocto Linux
    and displays the output for our Python code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了 Windows 上 Fiddler 窗口和 Putty 终端窗口并排。左侧的 Fiddler 窗口在一台生成 HTTP 请求的计算机上运行，右侧的
    Putty 终端窗口是运行在 Yocto Linux 上的 SSH 终端，它显示了我们 Python 代码的输出。
- en: '![Composing and sending HTTP requests](img/B05042_04_02.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![组合和发送 HTTP 请求](img/B05042_04_02.jpg)'
- en: We can run the following HTTPie command in a computer or device to use the RESTful
    API to tell us how many LEDs are turned on.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在计算机或设备上运行以下 HTTPie 命令来使用 RESTful API 告诉我们已点亮多少个 LED。
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The previous command will compose and send the following HTTP request: `GET
    http://192.168.1.107:8888/getcurrentnumber`. The request will match and run the
    `GetCurrentNumber.get` method. The following lines show the response from the
    HTTP server with the number that has been printed in LEDs, that is, the number
    of LEDs that have been turned on with the last API call:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上一条命令将组合并发送以下 HTTP 请求：`GET http://192.168.1.107:8888/getcurrentnumber`。该请求将匹配并运行
    `GetCurrentNumber.get` 方法。以下几行显示了来自 HTTP 服务器的响应，其中包含了打印在 LED 上的数字，即最后一次 API 调用中已点亮的
    LED 数量：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we take a look again at the list of request handlers that make up the web
    application, we will notice that the entry for `putnumberinleds` specifies a regular
    expression that accepts numbers from 0 to 9 as its parameters:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看构成 Web 应用的请求处理器列表，我们会注意到 `putnumberinleds` 的条目指定了一个正则表达式，该正则表达式接受从 0
    到 9 的数字作为其参数：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we run the following HTTPie command in a computer or device to use the RESTful
    API to make the board turn on twelve LEDs, the request won't match any regular
    expression in the list of request handlers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在计算机或设备上运行以下 HTTPie 命令来使用 RESTful API 使板子点亮十二个 LED，请求将不会匹配请求处理器列表中的任何正则表达式。
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Thus, Tornado will return a `404: Not found` error as a result.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，Tornado 将返回一个 `404: Not found` 错误作为结果。'
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The same will happen if we run the following HTTPie command in a computer or
    device because `x` isn't a number between 0 and 9.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在计算机或设备上运行以下 HTTPie 命令，也会发生相同的情况，因为 `x` 不是 0 到 9 之间的数字。
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The following HTTPie command will turn on 8 LEDs.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 HTTPie 命令将点亮 8 个 LED。
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The previous command will compose and send the following HTTP request: `PUT
    http://192.168.1.107:8888/putnumberinleds/8`. The request will match and run the
    `PutNumberInLedsHandler.put` method that receives `8` in its `number` parameter.
    The following lines show the response from the HTTP server with the number that
    has been printed in LEDs, that is, the number of LEDs that have been turned on:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 上一条命令将组合并发送以下 HTTP 请求：`PUT http://192.168.1.107:8888/putnumberinleds/8`。该请求将匹配并运行接收
    `8` 作为其 `number` 参数的 `PutNumberInLedsHandler.put` 方法。以下几行显示了来自 HTTP 服务器的响应，其中包含了打印在
    LED 上的数字，即已点亮的 LED 数量：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The number of LEDs that are turned on changed from 5 to 8, and therefore, we
    can run the following HTTPie command in a computer or device to use the RESTful
    API to tell us how many LEDs are turned on.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 打开的LED数量从5变为8，因此，我们可以在计算机或设备上运行以下HTTPie命令，使用RESTful API告诉我们打开了多少个LED。
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following lines show the response from the HTTP server with the number
    that has been printed in LEDs:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了HTTP服务器响应，其中包含已打印在LED上的数字：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We created a very simple RESTful API that allows us to turn on LEDs and check
    which is the number that is currently printed in LEDs. Of course, we should add
    authentication and overall security to the RESTful API in order to make it complete.
    Our RESTful API makes it possible for us to print numbers in LEDs with any application,
    mobile app or web application that can compose and send HTTP requests.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个非常简单的RESTful API，允许我们打开LED并检查当前打印在LED上的数字。当然，我们应该向RESTful API添加身份验证和整体安全性，以使其完整。我们的RESTful
    API使我们能够使用任何可以编写和发送HTTP请求的应用程序、移动应用程序或Web应用程序在LED上打印数字。
- en: Wiring pins with PWM capabilities
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带PWM功能的引脚布线
- en: 'We want to control the output voltage to make it possible to fade in and fade
    out three LEDs of three different colors: red, green and blue. The lower the output
    voltage, the lower the brightness level for the LEDs. The higher the output voltage,
    the higher the brightness level for the LEDs. Thus, as the output voltage is nearer
    to 0V, the brightness for the LEDs is lower and when the output voltage is nearer
    the IOREF voltage, that is, 5V in our actual configuration, the brightness is
    higher for the LEDs. Specifically, we want to be able to set 256 brightness levels
    for each LED, from 0 to 255\. In this case, we will use three LEDs but we will
    move to a single RGB LED capable of mixing the three colors in a single electronic
    component later in this chapter.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要控制输出电压，以便能够淡入淡出三种不同颜色的三个LED：红色、绿色和蓝色。输出电压越低，LED的亮度级别越低。输出电压越高，LED的亮度级别越高。因此，当输出电压接近0V时，LED的亮度较低，而当输出电压接近IOREF电压，即在我们的实际配置中为5V时，LED的亮度较高。具体来说，我们希望能够为每个LED设置256个亮度级别，从0到255。在这种情况下，我们将使用三个LED，但稍后在本章中我们将转向一个能够在一个电子组件中混合三种颜色的单色RGB
    LED。
- en: When we worked with GPIO pins configured as digital outputs, we could set an
    output voltage of 0V (low value) or the IOREF voltage, that is, 5V in our actual
    configuration (high value). Thus, we could just turn off or turn on the LED with
    its maximum brightness level (without burning it).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用配置为数字输出的GPIO引脚工作时，我们可以设置0V（低值）或IOREF电压，即在我们的实际配置中为5V（高值）。因此，我们可以通过其最大亮度级别关闭或打开LED（而不烧毁它）。
- en: 'If we connect our red, green and blue LEDs to three GPIO pins and we configure
    them as digital outputs, we won''t be able to set 256 brightness levels. We have
    to connect the three LEDs to three of the digital I/O pins that we can use as
    **PWM** (short for **Pulse Width Modulation**) output pins. In [Chapter 1](ch01.html
    "Chapter 1. Understanding and Setting up the Base IoT Hardware"), *Understanding
    and Setting up the Base IoT Hardware*, when we learned about the I/O pins included
    in the Intel Galileo Gen 2 board, we learned that the pins labeled with a tilde
    symbol (~) as a prefix for the number can be used as PWM output pins. Thus, we
    can use the following pins to connect the three LEDs:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将红色、绿色和蓝色LED连接到三个GPIO引脚，并将它们配置为数字输出，我们将无法设置256个亮度级别。我们必须将三个LED连接到三个我们可以用作**PWM**（脉冲宽度调制）输出引脚的数字I/O引脚。在[第1章](ch01.html
    "第1章. 理解和设置基础物联网硬件")中，*理解和设置基础物联网硬件*，当我们学习了英特尔Galileo Gen 2板上的I/O引脚时，我们了解到带有波浪线符号(~)作为数字前缀的引脚可以用作PWM输出引脚。因此，我们可以使用以下引脚连接三个LED：
- en: Pin **~6** to connect the red LED
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**~6**引脚连接到红色LED
- en: Pin **~5** to connect the green LED
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**~5**引脚连接到绿色LED
- en: Pin **~3** to connect the blue LED
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**~3**引脚连接到蓝色LED
- en: 'After we finish the necessary wirings, we will write Python code to create
    another RESTful API that will allow us to set the brightness for each of the three
    LEDs. We need the following parts to work with this example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成必要的布线后，我们将编写Python代码来创建另一个RESTful API，允许我们设置三个LED中的每个LED的亮度。我们需要以下部分来使用此示例：
- en: One red ultrabright 5mm LED
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个红色超亮5mm LED
- en: One green ultrabright 5mm LED
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个绿色超亮5mm LED
- en: One blue ultrabright 5mm LED
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个蓝色超亮5mm LED
- en: Three 270Ω resistors with 5% tolerance (red violet brown gold)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个5%容差的270Ω电阻（红紫棕金）
- en: 'The following diagram shows the components connected to the breadboard, the
    necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard.
    The Fritzing file for the sample is `iot_fritzing_chapter_04_02.fzz` and the following
    image is the breadboard view:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了连接到面包板的组件、必要的布线和从英特尔Galileo Gen 2板到面包板的布线。示例的Fritzing文件为`iot_fritzing_chapter_04_02.fzz`，以下图像是面包板视图：
- en: '![Wiring pins with PWM capabilities](img/B05042_04_03.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![具有PWM功能的引脚布线](img/B05042_04_03.jpg)'
- en: In this case, we wanted the three LEDs to be close to each other. This way,
    the three LEDs can project their light to a black surface and we can see how the
    intersection of the three colors generates a color that will be similar to a color
    selected in a color picker we will use later.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们希望三个LED彼此靠近。这样，三个LED可以将光线投射到黑色表面上，我们可以看到三种颜色的交汇处产生的颜色将类似于我们在稍后将要使用的颜色选择器中选择的颜色。
- en: The following image shows the schematic with the electronic components represented
    as symbols.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了用符号表示的电子组件的原理图。
- en: '![Wiring pins with PWM capabilities](img/B05042_04_04.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![具有PWM功能的引脚布线](img/B05042_04_04.jpg)'
- en: As seen in the previous schematic, three PWM capable GPIO pins labeled **D3
    PWM**, **D5 PWM** and **D6 PWM** in the board's symbol is connected to a **270Ω**
    resistor, wired to an LED's anode, and each LED's cathode is connected to ground.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，板上的符号中标记为**D3 PWM**、**D5 PWM**和**D6 PWM**的三个具有PWM功能的GPIO引脚连接到一个**270Ω**电阻，该电阻连接到LED的正极，每个LED的负极连接到地。
- en: Now, it is time to insert the components in the breadboard and make all the
    necessary wirings. Don't forget to shutdown the Yocto Linux, wait for all the
    onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen
    2 board before adding or removing any wire from the board's pins.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将组件插入面包板并完成所有必要的布线了。不要忘记关闭Yocto Linux，等待所有板载LED熄灭，并在从板上的引脚添加或移除任何电线之前，从英特尔Galileo
    Gen 2板上拔掉电源。
- en: Using PWM to generate analog values
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PWM生成模拟值
- en: Pulse width modulation, known as PWM, is a technique that makes it possible
    to generate an analog result with digital means through the usage of a digital
    on-off pattern. The pins that provide PWM capabilities use a digital control to
    create a square wave and it can simulate voltages between the configured **IOREF**
    voltage (5V in the default board configuration) and 0V by controlling the amount
    of time that the signal spends in the ON status (**IOREF** voltage) and the time
    the signal spends in the OFF status (0V). The pulse width is the duration of the
    signal in the ON status (**IOREF** voltage), and therefore, pulse width modulation
    means changing the pulse width to get perceived analog values.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 脉宽调制，简称PWM，是一种通过使用数字开/关模式，通过数字方式生成模拟结果的技术。提供PWM功能的引脚使用数字控制来创建方波，并且可以通过控制信号在开启状态（**IOREF**电压）和关闭状态（0V）中停留的时间来模拟配置的**IOREF**电压（默认板配置为5V）和0V之间的电压。脉冲宽度是信号在开启状态（**IOREF**电压）中的持续时间，因此，脉宽调制意味着通过改变脉冲宽度来获取感知到的模拟值。
- en: When you repeat the signal in the ON status and the signal in the OFF status
    hundreds of times per second with a LED connected to the PWM pin, we can generate
    the same result as if the signal is a steady voltage between 0V and the **IOREF**
    voltage to control the LED's brightness level.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你每秒重复数百次开启状态和关闭状态的信号，并且将LED连接到PWM引脚时，我们可以生成与信号在0V和**IOREF**电压之间保持恒定电压相同的信号，以控制LED的亮度级别。
- en: We can write floating point values from 0 to 1 to the PWM enabled pins configured
    as analog output, that is, from 0% duty cycle (always signal in the OFF status)
    to 100% duty cycle (always signal in the ON status). We want to represent 256
    brightness values (from 0 to 255 inclusive), and therefore, the following graph
    shows the brightness values in the abscissa axis (*x*-axis) and the corresponding
    floating point values that have to be written to the pin in the ordinate axis
    (*y*-axis).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将从0到1的浮点值写入配置为模拟输出的PWM启用引脚，即从0%占空比（始终处于关闭状态）到100%占空比（始终处于开启状态）。我们想要表示256个亮度值（从0到255），因此，以下图表显示了横坐标轴（*x*-轴）上的亮度值和相应的浮点值，这些值必须写入纵坐标轴（*y*-轴）上的引脚。
- en: '![Using PWM to generate analog values](img/B05042_04_05.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![使用PWM生成模拟值](img/B05042_04_05.jpg)'
- en: 'The equation for the previous graph is the following: `y = x / 255`, specifically
    `value = brightness / 255`. We can run the following code in our Python interpreter
    to see the output with all the values that will be written for each brightness
    level from 0 to 255 inclusive.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 之前图表的方程式如下：`y = x / 255`，具体来说，`值 = 亮度 / 255`。我们可以在我们的 Python 解释器中运行以下代码来查看所有从
    0 到 255（包括）的亮度级别将写入的所有值。
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can multiply the floating point values by 5 to calculate the voltage value
    for each brightness level. As we are working with the default settings for the
    board, the **IOREF** jumper is set to 5V, and therefore, a 1.0 value in the output
    means 5V (`1.0 x 5 = 5`). A value of 0.5 in the output means 2.5V (`0.5 x 5 =
    2.5`). The following graph shows the brightness values in the abscissa axis (x-axis)
    and the corresponding voltage values in the output that will generate the corresponding
    brightness value in the LEDs in the ordinate axis (*y*-axis).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将浮点值乘以 5 来计算每个亮度级别的电压值。由于我们使用的是板子的默认设置，**IOREF** 跳线设置为 5V，因此输出中的 1.0 值表示
    5V（`1.0 x 5 = 5`）。输出中的 0.5 值表示 2.5V（`0.5 x 5 = 2.5`）。以下图表显示了横坐标轴（x 轴）上的亮度值和对应于纵坐标轴（y
    轴）上生成相应亮度值的输出电压值。
- en: '![Using PWM to generate analog values](img/B05042_04_06.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![使用 PWM 生成模拟值](img/B05042_04_06.jpg)'
- en: 'The equation for the previous graph is the following: `y = x / 255 * 5`, specifically
    `voltage = brightness / 255 * 5`. We can run the following code in our Python
    interpreter to see the output with all the voltages that will be generated for
    each brightness level from 0 to 255 inclusive.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 之前图表的方程式如下：`y = x / 255 * 5`，具体来说，`电压 = 亮度 / 255 * 5`。我们可以在我们的 Python 解释器中运行以下代码来查看所有从
    0 到 255（包括）的亮度级别将生成的所有电压输出。
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We will create a new `AnalogLed` class to represent an LED connected to our
    board that can have a brightness level from 0 to 255 inclusive. The following
    lines show the code for the new `AnalogLed` class. The code file for the sample
    is `iot_python_chapter_04_02.py`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的 `AnalogLed` 类来表示连接到我们的板子上的 LED，该 LED 可以具有从 0 到 255（包括）的亮度级别。以下行显示了新
    `AnalogLed` 类的代码。示例的代码文件为 `iot_python_chapter_04_02.py`。
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have to specify the pin number to which the LED is connected when we create
    an instance of the `AnalogLed` class in the `pin` required argument, and a name
    for the LED in the `name` required argument. The constructor, that is, the `__init__`
    method, creates a new `mraa.Pwm` instance with the received `pin` as its `pin`
    argument, saves its reference in the `pwm` attribute and calls its `period_us`
    method to configure the PWM period in 700 microseconds (700 µs). Thus, the output
    duty cycle will determine the percentage of the 700 microsecond period during
    which the signal is in the ON status. For example, a 0.5 (50%) output duty cycle
    means that the signal will be ON during 350 microseconds of the 700 microseconds
    period (700 * 0.5 = 350).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 `pin` 必需参数中创建 `AnalogLed` 类的实例时，我们必须指定连接 LED 的引脚号，并在 `name` 必需参数中指定 LED
    的名称。构造函数，即 `__init__` 方法，创建一个新的 `mraa.Pwm` 实例，其 `pin` 参数为接收到的 `pin`，将其引用保存到 `pwm`
    属性中，并调用其 `period_us` 方法以将 PWM 周期配置为 700 微秒（700 µs）。因此，输出占空比将确定信号处于 ON 状态的 700
    微秒周期中的百分比。例如，0.5（50%）的输出占空比意味着信号将在 700 微秒周期中的 350 微秒内处于 ON 状态（700 * 0.5 = 350）。
- en: Then, the the code calls the `pwm.enable` method with `True` as a parameter
    to set the enable status of the PWM pin and allow us to start setting the output
    duty-cycle percentage for the PWM pin with calls to the `pwm.write` method.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码使用 `True` 作为参数调用 `pwm.enable` 方法，以设置 PWM 引脚的启用状态，并允许我们通过调用 `pwm.write`
    方法开始设置 PWM 引脚的输出占空比百分比。
- en: The next line creates a `brightness_value` attribute initialized with 0 that
    will allow us to easily retrieve the last brightness value set to the LED connected
    to the pin. Finally, the constructor calls the `set_brightness` method with 0
    as the value for the `value` argument to set the brightness level for the LED
    connected to the configured pin to 0.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行创建了一个 `brightness_value` 属性，其初始值为 0，这将使我们能够轻松检索设置到连接到引脚的 LED 的最后一个亮度值。最后，构造函数使用
    0 作为 `value` 参数的值调用 `set_brightness` 方法，以将配置引脚连接的 LED 的亮度级别设置为 0。
- en: The class defines a `set_brightness` method that receives a brightness level
    value in the `value` argument. The first lines of code make sure that we always
    set a brightness level between 0 and 255 (inclusive). In case the `value` argument
    has a value that isn't included in that range, the code assigns the lower-level
    (0) or upper-level value (255) to the `brightness_value` variable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该类定义了一个`set_brightness`方法，该方法接收一个亮度级别值作为`value`参数。代码的前几行确保我们始终设置一个介于0到255（包括）之间的亮度级别。如果`value`参数的值不包含在该范围内，代码将较低级别（0）或较高级别（255）的值分配给`brightness_value`变量。
- en: Then, the code calculates the necessary output duty-cycle percentage for the
    PWM pin to represent the brightness level as a floating point value between `1.0f`
    (100%) and `0.0f` (0%). The code saves the value in the `led_value` variable and
    then calls the `self.pwm.write` method with this variable for the percentage argument
    to set the output duty-cycle for the pin configured as PWM output to `led_value`.
    The next line saves the valid brightness level to the `brightness_value` attribute.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码计算PWM引脚所需的输出占空比百分比，以表示亮度级别作为一个介于`1.0f`（100%）和`0.0f`（0%）之间的浮点值。代码将此值保存在`led_value`变量中，然后使用此变量作为百分比参数调用`self.pwm.write`方法，以设置配置为PWM输出的引脚的输出占空比为`led_value`。下一行将有效的亮度级别保存到`brightness_value`属性中。
- en: Finally, the code prints details about the LED name, the pin number and the
    brightness level that has been set. This way, the method translates a brightness
    level from 0 to 255 (inclusive) into the appropriate output duty-cycle value for
    the pin and writes the output to control the connected LED's brightness level.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码打印有关LED名称、引脚编号和已设置的亮度级别的详细信息。这样，该方法将亮度级别从0到255（包括）转换为适当的输出占空比值，并将输出写入以控制连接的LED的亮度级别。
- en: Now, we can write code that uses the new `AnalogLed` class to create one instance
    for each of the three LEDs and easily control their brightness levels. The following
    lines show the code for the `BoardInteraction` class. The code file for the sample
    is `iot_python_chapter_04_02.py`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写使用新的`AnalogLed`类创建每个LED的一个实例的代码，并轻松控制它们的亮度级别。以下行显示了`BoardInteraction`类的代码。示例的代码文件是`iot_python_chapter_04_02.py`。
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `BoardInteraction` class just declares three class attributes: `red_led`,
    `green_led` and `blue_led`. The three class attributes save new instances of the
    previously created `AnalogLed` class and represent the red, green and blue LEDs
    connected to pins **~6**, **~5** and **~3**. Now, we will create other classes
    that define methods that work with these class attributes to access common `AnalogLed`
    instances.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoardInteraction`类仅声明了三个类属性：`red_led`、`green_led`和`blue_led`。这三个类属性保存了之前创建的`AnalogLed`类的新实例，并代表连接到引脚**~6**、**~5**和**~3**的红、绿和蓝LED。现在，我们将创建其他类，这些类定义了与这些类属性一起工作的方法，以访问常见的`AnalogLed`实例。'
- en: 'The next lines show the code that adds the following classes: `VersionHandler`,
    `PutRedBrightnessHandler`, `PutGreenBrightnessHandler` and `PutBlueBrightnessHandler`.
    The code file for the sample is `iot_python_chapter_04_02.py`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行显示了添加以下类的代码：`VersionHandler`、`PutRedBrightnessHandler`、`PutGreenBrightnessHandler`和`PutBlueBrightnessHandler`。示例的代码文件是`iot_python_chapter_04_02.py`。
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The code declares the following four subclasses of `tornado.web.RequestHandler`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了以下四个`tornado.web.RequestHandler`的子类：
- en: '`VersionHandler`: Defines the parameter less `get` method that returns a response
    with the version number and the last build date.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VersionHandler`：定义了一个无参数的`get`方法，该方法返回包含版本号和最后构建日期的响应。'
- en: '`PutRedBrightnessHandler`: Defines the `put` method that requires a value argument
    that specifies the desired brightness level for the red LED. The method calls
    the `set_brightness` method for the `AnalogNumber` instance stored in the `BoardInteraction.red_led`
    class attribute with the desired brightness level specified in the `value` argument.
    Then, the code returns a response with the brightness level that has been translated
    to an output duty cycle percentage in the PWM pin to which the red LED is connected
    to.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PutRedBrightnessHandler`：定义了一个`put`方法，该方法需要一个`value`参数，该参数指定了红色LED所需的亮度级别。该方法调用存储在`BoardInteraction.red_led`类属性中的`AnalogNumber`实例的`set_brightness`方法，并使用`value`参数中指定的所需亮度级别。然后，代码返回一个响应，其中包含已转换为PWM引脚输出占空比百分比的亮度级别，该PWM引脚连接到红色LED。'
- en: '`PutGreenBrightnessHandler`: Defines the `put` method to set the desired brightness
    level for the green LED. It works as the previously described `PutRedBrightnessHandler`
    method but instead of using the `BoardInteraction.red_led` class attribute, the
    code uses `BoardInteraction.green_led` class attribute to control the brightness
    level for the green LED.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PutGreenBrightnessHandler`: 定义了 `put` 方法来设置绿色 LED 所需的亮度级别。它的工作方式与之前描述的 `PutRedBrightnessHandler`
    方法相同，但代码使用 `BoardInteraction.green_led` 类属性来控制绿色 LED 的亮度级别，而不是使用 `BoardInteraction.red_led`
    类属性。'
- en: '`PutBlueBrightnessHandler`: Defines the `put` method to set the desired brightness
    level for the blue LED. It works as the previously described `PutRedBrightnessHandler`
    method but instead of using the `BoardInteraction.red_led` class attribute, the
    code uses `BoardInteraction.blue_led` class attribute to control the brightness
    level for the blue LED.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PutBlueBrightnessHandler`: 定义了 `put` 方法来设置蓝色 LED 所需的亮度级别。它的工作方式与之前描述的 `PutRedBrightnessHandler`
    方法相同，但代码使用 `BoardInteraction.blue_led` 类属性来控制蓝色 LED 的亮度级别，而不是使用 `BoardInteraction.red_led`
    类属性。'
- en: 'The next lines show the code that adds the following classes: `GetRedBrightnessHandler`,
    `GetGreenBrightnessHandler` and `GetBlueBrightnessHandler`. The code file for
    the sample is `iot_python_chapter_04_02.py`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的几行展示了添加以下类的代码：`GetRedBrightnessHandler`、`GetGreenBrightnessHandler` 和 `GetBlueBrightnessHandler`。示例的代码文件是
    `iot_python_chapter_04_02.py`。
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The code declares the following three subclasses of `tornado.web.RequestHandler`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了以下三个 `tornado.web.RequestHandler` 的子类：
- en: '`GetRedBrightnessHandler`: Defines the parameter less `get` method that returns
    a response with the value of the `BoardInteraction.red_led.brightness_value` attribute,
    that is, the brightness value set to the red LED'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetRedBrightnessHandler`: 定义了一个无参数的 `get` 方法，该方法返回一个包含 `BoardInteraction.red_led.brightness_value`
    属性值的响应，即设置到红色 LED 的亮度值'
- en: '`GetGREENBrightnessHandler`: Defines the parameter less `get` method that returns
    a response with the value of the `BoardInteraction.green_led.brightness_value`
    attribute, that is, the brightness value set to the green LED'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetGREENBrightnessHandler`: 定义了一个无参数的 `get` 方法，该方法返回一个包含 `BoardInteraction.green_led.brightness_value`
    属性值的响应，即设置到绿色 LED 的亮度值'
- en: '`GetBlueBrightnessHandler`: Defines the parameter less `get` method that returns
    a response with the value of the `BoardInteraction.blue_led.brightness_value`
    attribute, that is, the brightness value set to the blue LED'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetBlueBrightnessHandler`: 定义了一个无参数的 `get` 方法，该方法返回一个包含 `BoardInteraction.blue_led.brightness_value`
    属性值的响应，即设置到蓝色 LED 的亮度值'
- en: The following lines use the previously declared subclasses of `tornado.web.RequestHandler`
    to make up the web application with Tornado that represents a new RESTful API
    and the new `__main__` method. The code file for the sample is `iot_python_chapter_04_02.py`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的几行使用之前声明的 `tornado.web.RequestHandler` 子类，用 Tornado 构建了一个 Web 应用程序，它代表一个新的
    RESTful API 和新的 `__main__` 方法。示例的代码文件是 `iot_python_chapter_04_02.py`。
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As happened in our previous example, the code creates an instance of the `tornado.web.Application`
    class named `application` with the list of request handlers that make up the web
    application, that is, the tuples of regular expressions and subclasses of `tornado.web.RequestHandler`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，代码创建了一个名为 `application` 的 `tornado.web.Application` 类实例，其中包含构成 Web 应用的请求处理器列表，即正则表达式和
    `tornado.web.RequestHandler` 子类的元组。
- en: The following table shows some HTTP requests that match the regular expressions
    defined in the preceding code. In this case, the HTTP requests use `192.168.1.107`
    because they are executed from a computer connected to our LAN. Don't forget to
    replace `192.168.1.107` with your board's IP address in the next requests.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了与前面代码中定义的正则表达式匹配的一些 HTTP 请求。在这种情况下，HTTP 请求使用 `192.168.1.107`，因为它们是从连接到我们局域网的计算机执行的。不要忘记在下一个请求中将
    `192.168.1.107` 替换为您的板子的 IP 地址。
- en: '| HTTP verb and request URL | Tuple (`regexp`, `request_class`) that matches
    the request path | `RequestHandler` subclass and method that is called |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| HTTP 方法及请求 URL | 匹配请求路径的元组 (`regexp`, `request_class`) | 被调用的 `RequestHandler`
    子类和方法 |'
- en: '| --- | --- | --- |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `PUT http:// 192.168.1.107:8888/putredbrightness/30` | `(r"/putredbrightness/([0-9]+)",
    PutRedBrightnessHandler)` | `PutRedBrightnessHandler.put(30)` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `PUT http:// 192.168.1.107:8888/putredbrightness/30` | `(r"/putredbrightness/([0-9]+)",
    PutRedBrightnessHandler)` | `PutRedBrightnessHandler.put(30)` |'
- en: '| `PUT http:// 192.168.1.107:8888/putgreenbrightness/128` | `(r"/putgreenbrightness/([0-9]+)",
    PutGreenBrightnessHandler)` | `PutGreenBrightnessHandler.put(128)` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `PUT http:// 192.168.1.107:8888/putgreenbrightness/128` | `(r"/putgreenbrightness/([0-9]+)",
    PutGreenBrightnessHandler)` | `PutGreenBrightnessHandler.put(128)` |'
- en: '| `PUT http:// 192.168.1.107:8888/putbluebrightness/255` | `(r"/putbluebrightness/([0-9]+)",
    PutBlueBrightnessHandler)` | `PutGreenBrightnessHandler.put(255)` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `PUT http:// 192.168.1.107:8888/putbluebrightness/255` | `(r"/putbluebrightness/([0-9]+)",
    PutBlueBrightnessHandler)` | `PutGreenBrightnessHandler.put(255)` |'
- en: '| `GET http:// 192.168.1.107:8888/getredbrightness` | `(r"/getredbrightness",
    GetRedBrightnessHandler)` | `GetRedBrightnessHandler.get()` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `GET http:// 192.168.1.107:8888/getredbrightness` | `(r"/getredbrightness",
    GetRedBrightnessHandler)` | `GetRedBrightnessHandler.get()` |'
- en: '| `GET http:// 192.168.1.107:8888/getgreenbrightness` | `(r"/getgreenbrightness",
    GetGreenBrightnessHandler)` | `GetGreenBrightnessHandler.get()` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `GET http:// 192.168.1.107:8888/getgreenbrightness` | `(r"/getgreenbrightness",
    GetGreenBrightnessHandler)` | `GetGreenBrightnessHandler.get()` |'
- en: '| `GET http:// 192.168.1.107:8888/getbluebrightness` | `(r"/getbluebrightness",
    GetBlueBrightnessHandler)` | `GetBlueBrightnessHandler.get()` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `GET http:// 192.168.1.107:8888/getbluebrightness` | `(r"/getbluebrightness",
    GetBlueBrightnessHandler)` | `GetBlueBrightnessHandler.get()` |'
- en: The following line will start the HTTP server and our RESTful API that allows
    us to control the brightness level for red, green and blue LEDs in the Yocto Linux
    running on the board. Don't forget that you need to transfer the Python source
    code file to the Yocto Linux with an SFTP client, as explained in the previous
    chapter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将启动 HTTP 服务器和我们的 RESTful API，允许我们在板上的 Yocto Linux 中控制红色、绿色和蓝色 LED 的亮度级别。不要忘记，你需要使用
    SFTP 客户端将 Python 源代码文件传输到 Yocto Linux，正如前一章所述。
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After we start the HTTP server, we will see the following output and all the
    red, green and blue LEDs are going to be turned off.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 HTTP 服务器后，我们将看到以下输出，并且所有红色、绿色和蓝色 LED 都将被关闭。
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Generating analog values via HTTP requests
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 HTTP 请求生成模拟值
- en: The HTTP server is running in Yocto Linux and waiting for our HTTP requests
    to control the LEDs on connected to the Intel Galileo Gen 2 board. Now, we will
    compose and send HTTP requests from other computer or devices connected to our
    LAN and we will control the brightness levels for the red, green and blue LEDs.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 服务器正在 Yocto Linux 中运行，等待我们的 HTTP 请求来控制连接到 Intel Galileo Gen 2 板的 LED。现在，我们将从连接到我们的局域网的另一台计算机或设备上编写和发送
    HTTP 请求，并将控制红色、绿色和蓝色 LED 的亮度级别。
- en: Open a new terminal, command-line or the GUI tool that we want to use to compose
    and send HTTP requests from a computer or any device connected to the LAN. Don't
    forget to replace `192.168.1.107` with your board's IP address in the next requests.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的终端、命令行或我们想要用来从计算机或任何连接到局域网的设备上编写和发送 HTTP 请求的 GUI 工具。不要忘记在接下来的请求中将 `192.168.1.107`
    替换为你的板子的 IP 地址。
- en: 'Run the following HTTPie command in a computer or device to use the RESTful
    API to make the board set the brightness level for the red LED to 30\. After you
    enter the command, you will notice the SSH terminal that displays the output for
    the Python code will display the following message: **Red LED connected to PWM
    Pin #6 set to brightness 30**. In addition, you will see the red LED turned on
    with a very low brightness level.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '在计算机或设备上运行以下 HTTPie 命令来使用 RESTful API 将板子的红色 LED 亮度设置为 30。输入命令后，你会注意到显示 Python
    代码输出的 SSH 终端将显示以下消息：**连接到 PWM 引脚 #6 的红色 LED 设置为亮度 30**。此外，你将看到红色 LED 以非常低的亮度打开。'
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The previous command will compose and send the following HTTP request: `PUT
    http://192.168.1.107:8888/putredbrightness/30`. The request will match and run
    the `PutRedBrightnessHandler.put` method that receives `30` in its `value` parameter.
    The following lines show the response from the HTTP server with the brightness
    level that has been set for the red LED by taking advantage of PWM:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送以下 HTTP 请求：`PUT http://192.168.1.107:8888/putredbrightness/30`。请求将匹配并运行接收
    `30` 作为其 `value` 参数的 `PutRedBrightnessHandler.put` 方法。以下行显示了 HTTP 服务器对通过 PWM 设置的红色
    LED 亮度级别的响应：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can run the following HTTPie command in a computer or device to use the RESTful
    API to tell us the current brightness level for the red LED.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在计算机或设备上运行以下 HTTPie 命令来使用 RESTful API 获取红色 LED 的当前亮度级别。
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The previous command will compose and send the following HTTP request: `GET
    http://192.168.1.107:8888/getredbrightness`. The request will match and run the
    `GetRedBrightnessHandler.get` method. The following lines show the response from
    the HTTP server with the brightness level that has been previously set for the
    red LED with the API call:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下 HTTP 请求：`GET http://192.168.1.107:8888/getredbrightness`。该请求将匹配并运行
    `GetRedBrightnessHandler.get` 方法。以下几行显示了 HTTP 服务器对之前通过 API 调用设置的红色 LED 亮度级别的响应：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, run the following HTTPie command in a computer or device to use the RESTful
    API to make the board set the brightness level for the green LED to 128\. After
    you enter the command, you will notice the SSH terminal that displays the output
    for the Python code will display the following message: **Green LED connected
    to PWM Pin #5 set to brightness 128**. In addition, you will see the green LED
    turned on with a very low brightness level.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，在计算机或设备上运行以下 HTTPie 命令以使用 RESTful API 将绿色 LED 的亮度设置为 128。在您输入命令后，您将注意到显示
    Python 代码输出的 SSH 终端将显示以下消息：**连接到 PWM 引脚 #5 的绿色 LED 设置为亮度 128**。此外，您将看到绿色 LED 以非常低的亮度级别打开。'
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The previous command will compose and send the following HTTP request: `PUT
    http://192.168.1.107:8888/putgreenbrightness/128`. The request will match and
    run the `PutGreenBrightnessHandler.put` method that receives `128` in its `value`
    parameter. The following lines show the response from the HTTP server with the
    brightness level that has been set for the green LED:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下 HTTP 请求：`PUT http://192.168.1.107:8888/putgreenbrightness/128`。该请求将匹配并运行接收其
    `value` 参数中的 `128` 的 `PutGreenBrightnessHandler.put` 方法。以下几行显示了 HTTP 服务器对已设置的绿色
    LED 亮度级别的响应：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we run the following HTTPie command in a computer or device to use
    the RESTful API to make the board set the brightness level for the blue LED to
    `255`, that is, its highest brightness level. After you enter the command, you
    will notice the SSH terminal that displays the output for the Python code will
    display the following message: **Blue LED connected to PWM Pin #3 set to brightness
    255**. In addition, you will see the blue LED turned on with its highest brightness
    level.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我们在计算机或设备上运行以下 HTTPie 命令以使用 RESTful API 将板上的蓝色 LED 亮度设置为 `255`，即其最高亮度级别。在您输入命令后，您将注意到显示
    Python 代码输出的 SSH 终端将显示以下消息：**连接到 PWM 引脚 #3 的蓝色 LED 设置为亮度 255**。此外，您将看到蓝色 LED 以其最高亮度级别打开。'
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The previous command will compose and send the following HTTP request: `PUT
    http://192.168.1.107:8888/putbluebrightness/255`. The request will match and run
    the `PutBlueBrightnessHandler.put` method that receives 255 in its `value` parameter.
    The following lines show the response from the HTTP server with the brightness
    level that has been set for the blue LED:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下 HTTP 请求：`PUT http://192.168.1.107:8888/putbluebrightness/255`。该请求将匹配并运行接收其
    `value` 参数中的 255 的 `PutBlueBrightnessHandler.put` 方法。以下几行显示了 HTTP 服务器对已设置的蓝色 LED
    亮度级别的响应：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, we can run the following two HTTPie commands to use the RESTful API to
    tell us the current brightness levels for the green and blue LEDs.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行以下两个 HTTPie 命令来使用 RESTful API 告诉我们绿色和蓝色 LED 的当前亮度级别。
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following lines show the two responses from the HTTP server with the brightness
    levels that had been set for the green and blue LEDs:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行显示了 HTTP 服务器对已设置的绿色和蓝色 LED 亮度级别的两个响应：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We created a very simple RESTful API that allows us to set the desired brightness
    for red, green and blue LEDs, and check their current brightness levels. Our RESTful
    API makes it possible for us to generate different colors with the intersections
    of the three color and their different brightness levels with any application,
    mobile app or web application that can compose and send HTTP requests.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个非常简单的 RESTful API，允许我们设置红色、绿色和蓝色 LED 的所需亮度，并检查它们的当前亮度级别。我们的 RESTful API
    使得我们能够通过三种颜色及其不同亮度级别的交集，在任何可以组合和发送 HTTP 请求的应用程序、移动应用程序或 Web 应用程序中生成不同的颜色。
- en: Preparing the RESTful API for Web application requirements
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备 RESTful API 以满足 Web 应用程序需求
- en: We want to develop a simple web application that displays a color picker to
    allow the user to choose a color. Once the user picks a color, we can obtain the
    red, green and blue components from 0 to 255 inclusive. We want to set the brightness
    level for the red, green and blue LEDs on the board based on the red, green and
    blue values for the selected color. Based on this requirement, it is convenient
    to add a new `PUT` method to our RESTful API to allow us to change the brightness
    levels for the three LEDs in single API call.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望开发一个简单的Web应用程序，显示一个颜色选择器，允许用户选择颜色。一旦用户选择了一种颜色，我们就可以从0到255获取红色、绿色和蓝色的分量。我们希望根据所选颜色的红色、绿色和蓝色值设置板上红色、绿色和蓝色LED的亮度级别。根据这一要求，添加一个新的`PUT`方法到我们的RESTful
    API中，以便我们可以在单个API调用中更改三个LED的亮度级别是方便的。
- en: The next lines show the code that adds a new `PutRGBBrightnessHandler` class.
    The code file for the sample is `iot_python_chapter_04_03.py`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的行显示了添加新`PutRGBBrightnessHandler`类的代码。示例的代码文件是`iot_python_chapter_04_03.py`。
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The code declares a new subclass of `tornado.web.RequestHandler` named `PutRGBBrightnessHandler`.
    The class defines the `put` method that requires three arguments that specify
    the desired brightness for each of the three LEDs: red, green and blue. The method
    calls the `set_brightness` method for the `AnalogNumber` instances stored in the
    `BoardInteraction.red_led`, `BoardInteraction.green_led` and `BoardInteraction.blue_led`
    class attributes with the desired brightness levels specified in the arguments.
    Then, the code returns a response with the brightness levels that have been translated
    to output duty cycle percentages in the PWM pins to which the red, green and blue
    LEDs are connected to.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了一个名为`PutRGBBrightnessHandler`的新子类，该子类名为`tornado.web.RequestHandler`。该类定义了一个`put`方法，该方法需要三个参数，用于指定三个LED（红色、绿色和蓝色）所需的亮度。该方法调用存储在`BoardInteraction.red_led`、`BoardInteraction.green_led`和`BoardInteraction.blue_led`类属性中的`AnalogNumber`实例的`set_brightness`方法，并使用参数中指定的所需亮度级别。然后，代码返回一个响应，其中亮度级别已转换为连接到红色、绿色和蓝色LED的PWM引脚的输出占空比。
- en: Now, it is necessary to add the highlighted lines to the code that creates an
    instance of the `tornado.web.Application` class named `application` with the list
    of request handlers that make up the web application, that is, the tuples of regular
    expressions and subclasses of `tornado.web.RequestHandler`. The code file for
    the sample is `iot_python_chapter_04_03.py`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有必要将突出显示的行添加到创建名为`application`的`tornado.web.Application`类实例的代码中，该实例具有构成Web应用程序的请求处理程序列表，即正则表达式和`tornado.web.RequestHandler`子类的元组。示例的代码文件是`iot_python_chapter_04_03.py`。
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The following line will start the HTTP server and our new version of the RESTful
    API that allows us to control the brightness level for red, green and blue LEDs
    with a single API call in the Yocto Linux running on the board. Don't forget that
    you need to transfer the Python source code file to the Yocto Linux with an SFTP
    client, as explained in the previous chapter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将启动HTTP服务器和我们在板上运行的Yocto Linux的新版RESTful API，该API允许我们通过单个API调用控制红色、绿色和蓝色LED的亮度级别。不要忘记，你需要使用SFTP客户端将Python源代码文件传输到Yocto
    Linux，正如前一章所述。
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: After we start the HTTP server, we will see the following output and all the
    red, green and blue LEDs are going to be turned off.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们启动HTTP服务器后，我们将看到以下输出，并且所有红色、绿色和蓝色LED都将关闭。
- en: '[PRE47]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'With the new RESTful API we can compose the following HTTP verb and request
    URL:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的RESTful API，我们可以组合以下HTTP动词和请求URL：
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The previous request path will match the previously added tuple (`regexp`, `request_class`)
    `(r"/putrgbbrightness/r([0-9]+)g([0-9]+)b([0-9]+)", PutRGBBrightnessHandler)`
    and Tornado will call the `PutRGBBrightnessHandler.put` method with the values
    for `red`, `green` and `blue`, specifically `PutRGBBrightnessHandler.put(30, 128,
    255)`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 之前请求的路径将与之前添加的元组（`regexp`，`request_class`）`(`r"/putrgbbrightness/r([0-9]+)g([0-9]+)b([0-9]+)",
    PutRGBBrightnessHandler)`）匹配，Tornado将调用`PutRGBBrightnessHandler.put`方法，并带有红色、绿色和蓝色的值，具体为`PutRGBBrightnessHandler.put(30,
    128, 255)`。
- en: Run the following HTTPie command in a computer or device to use the RESTful
    API to make the board set the brightness level for the three LEDs with the previously
    analyzed request path.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机或设备上运行以下HTTPie命令以使用RESTful API通过之前分析的请求路径设置板上三个LED的亮度级别。
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After you enter the command, you will notice the SSH terminal that displays
    the output for the Python code will display the following three messages:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在你输入命令后，你会注意到SSH终端会显示Python代码的输出，将显示以下三条消息：
- en: '**Red LED connected to PWM Pin #6 set to brightness 30**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红色LED连接到PWM引脚#6，亮度设置为30**'
- en: '**Green LED connected to PWM Pin #5 set to brightness 128**'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绿色LED连接到PWM引脚#5，亮度设置为128**'
- en: '**Blue LED connected to PWM Pin #3 set to brightness 255**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝色LED连接到PWM引脚#3，亮度设置为255**'
- en: 'In addition, you will see the three LEDs turned on with their different brightness
    levels. The following lines show the response from the HTTP server with the brightness
    levels that have been set for the three LEDs:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您将看到三个LED以不同的亮度级别点亮。以下行显示了HTTP服务器对已设置三个LED亮度级别的响应：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Using PWM plus a RESTful API to set colors for an RGB LED
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PWM和RESTful API设置RGB LED的颜色
- en: 'Now, we will use the same source code to make it possible to change the color
    of an RGB LED, specifically, a common cathode RGB LED. This electronic component
    provides a common cathode and three anodes, that is, an anode for each of the
    three colors: red, green and blue. We can use our code to pulse width modulate
    the three colors and make the LED produce the mixed colors. We don''t need to
    use a black surface to see the intersection of the three colors because the RGB
    LED mixes the three colors for us.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用相同的源代码来改变RGB LED的颜色，特别是共阴极RGB LED。这个电子元件提供了一个共阴极和三个阳极，即每个颜色（红、绿、蓝）都有一个阳极。我们可以使用我们的代码来脉冲宽度调制三种颜色，使LED产生混合颜色。我们不需要使用黑色表面来观察三种颜色的交汇，因为RGB
    LED会为我们混合这三种颜色。
- en: The following image shows a common cathode RGB LED with one of the most common
    configurations for the pins, where the common cathode is the second pin and the
    longest one.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了一个常见的共阴极RGB LED及其引脚的配置，其中共阴极是第二个引脚，也是最长的引脚。
- en: '![Using PWM plus a RESTful API to set colors for an RGB LED](img/B05042_04_07.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![使用PWM和RESTful API设置RGB LED的颜色](img/B05042_04_07.jpg)'
- en: The following table shows the pin configuration for the previous RGB LED, from
    left to right. However, always make sure that you check the datasheet for your
    RGB LED to check the right pins for the common cathode and the anode for each
    color.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了之前RGB LED的引脚配置，从左到右。然而，始终确保检查您RGB LED的数据表，以确认共阴极和每种颜色的阳极的正确引脚。
- en: '| Pin number | Description |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 引脚编号 | 描述 |'
- en: '| --- | --- |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | Anode pin for red LED |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 红色LED的阳极引脚 |'
- en: '| 2 | Common cathode pin |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 共阴极引脚 |'
- en: '| 3 | Anode pin for green LED |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 绿色LED的阳极引脚 |'
- en: '| 4 | Anode pin for blue LED |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 蓝色LED的阳极引脚 |'
- en: 'Based on the previous table, we will connect the three anode pins to three
    of the digital I/O pins that we can use as **PWM** (short for **Pulse Width Modulation**)
    output pins. We will use the same PWM output pins that we used in our previous
    example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前的表格，我们将连接三个阳极引脚到三个我们可以用作**PWM**（脉冲宽度调制）输出引脚的数字I/O引脚。我们将使用与之前示例中相同的PWM输出引脚：
- en: Pin **~6** to connect the anode pin for red LED
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引脚**~6**用于连接红色LED的阳极引脚
- en: Pin **~5** to connect the anode pin for green LED
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引脚**~5**用于连接绿色LED的阳极引脚
- en: Pin **~3** to connect the anode pin for blue LED.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引脚**~3**用于连接蓝色LED的阳极引脚。
- en: 'After we finish the necessary wirings, we will use the same Python code to
    run our RESTful API and mix colors by changing the brightness levels for red,
    green and blue. We need the following parts to work with this example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 完成必要的接线后，我们将使用相同的Python代码运行我们的RESTful API，并通过改变红、绿、蓝三色的亮度级别来混合颜色。我们需要以下部件来完成此示例：
- en: One common cathode 5mm RGB LED
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个常见的共阴极5mm RGB LED
- en: Three 270Ω resistors with 5% tolerance (red violet brown gold)
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个270Ω电阻，公差为5%（红紫棕金）
- en: 'The following diagram shows the components connected to the breadboard, the
    necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard.
    The Fritzing file for the sample is `iot_python_chapter_04_03.fzz` and the following
    image is the breadboard view:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了连接到面包板的组件、必要的接线以及从英特尔Galileo Gen 2板到面包板的接线。该示例的Fritzing文件为`iot_python_chapter_04_03.fzz`，以下图像是面包板视图：
- en: '![Using PWM plus a RESTful API to set colors for an RGB LED](img/B05042_04_08.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![使用PWM和RESTful API设置RGB LED的颜色](img/B05042_04_08.jpg)'
- en: 'The following image shows the schematic with the electronic components represented
    as symbols:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了带有电子元件符号的电路图：
- en: '![Using PWM plus a RESTful API to set colors for an RGB LED](img/B05042_04_09.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![使用PWM和RESTful API设置RGB LED的颜色](img/B05042_04_09.jpg)'
- en: As seen in the previous schematic, three PWM capable GPIO pins labeled **D3
    PWM**, **D5 PWM** and **D6 PWM** in the board's symbol is connected to a **270Ω**
    resistor, wired to an anode pin for each LED color, and the common cathode is
    connected to ground.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，板上的符号中标记为 **D3 PWM**、**D5 PWM** 和 **D6 PWM** 的三个具有 PWM 功能的 GPIO 引脚连接到一个
    **270Ω** 电阻，该电阻连接到每个 LED 颜色的阳极引脚，而公共阴极连接到地。
- en: Now, it is time to insert the components in the breadboard and make all the
    necessary wirings. Don't forget to shutdown the Yocto Linux, wait for all the
    onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen
    2 board before adding or removing any wire from the board's pins.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将组件插入到面包板中并完成所有必要的布线了。不要忘记关闭 Yocto Linux，等待所有板载 LED 熄灭，并在从板上的引脚添加或移除任何电线之前，从英特尔
    Galileo Gen 2 板上拔掉电源。
- en: After the board boots Yocto Linux, we have to start the HTTP server with our
    latest version of the RESTful API that allows us to control the brightness level
    for red, green and blue LEDs with a single API call.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在板载 Yocto Linux 启动后，我们必须启动我们的最新版本的 RESTful API 的 HTTP 服务器，该 API 允许我们通过单个 API
    调用来控制红、绿和蓝 LED 的亮度级别。
- en: '[PRE51]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Run the following HTTPie command in a computer or device to use the RESTful
    API to make the board set the brightness level for the colors included in the
    RGB LED.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机或设备上运行以下 HTTPie 命令以使用 RESTful API 使板设置 RGB LED 中包含的颜色亮度级别。
- en: '[PRE52]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After you enter the command, you will notice the RGB LED displays a yellow
    light because we set both red and green to its maximum brightness level while
    we turned off the blue component. The following lines show the response from the
    HTTP server with the brightness levels that have been set for the three colors:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在您输入命令后，您会注意到 RGB LED 显示出黄色光，因为我们同时将红色和绿色设置为最大亮度级别，同时关闭了蓝色组件。以下几行显示了 HTTP 服务器对三种颜色已设置的亮度级别的响应：
- en: '[PRE53]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, run the following HTTPie command.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下 HTTPie 命令。
- en: '[PRE54]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'After you enter the command, you will notice the RGB LED displays a pink or
    light magenta light because we set green to its maximum brightness level and blue
    to half its maximum brightness level while we turned off the green component.
    The following lines show the response from the HTTP server with the brightness
    levels that have been set for the three colors:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在您输入命令后，您会注意到 RGB LED 显示出粉红色或浅紫色光，因为我们设置了绿色为最大亮度级别，蓝色为最大亮度的一半，同时关闭了绿色组件。以下几行显示了
    HTTP 服务器对三种颜色已设置的亮度级别的响应：
- en: '[PRE55]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, run the following HTTPie command:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下 HTTPie 命令：
- en: '[PRE56]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After you enter the command, you will notice the RGB LED displays a cyan light
    because we set both green and blue to its maximum brightness level while we turned
    off the red component. The following lines show the response from the HTTP server
    with the brightness levels that have been set for the three colors:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在您输入命令后，您会注意到 RGB LED 显示出青色光，因为我们同时将绿色和蓝色设置为最大亮度级别，同时关闭了红色组件。以下几行显示了 HTTP 服务器对三种颜色已设置的亮度级别的响应：
- en: '[PRE57]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We can generate 256 * 256 * 256 different colors, which is 16,777,216 colors
    (more than 16 million colors) for the light generated by the RGB LED. We just
    need to use our RESTful API and change the values for the red, green and blue
    components.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以生成 256 * 256 * 256 种不同的颜色，即 16,777,216 种颜色（超过 1600 万种颜色），这是 RGB LED 产生的光的颜色。我们只需使用我们的
    RESTful API 并更改红、绿和蓝组件的值即可。
- en: Controlling PWM with the wiring-x86 library
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 wiring-x86 库控制 PWM
- en: So far, we have been using the `mraa` library to work with PWM and change the
    brightness level for the different LEDs and colors within an RGB LED. However,
    in the first chapter, we also installed the `wiring-x86` library. We can change
    just a few lines of our object-oriented code to replace the `mraa` library with
    the `wiring-x86` one to change the brightness levels for the red, green and blue
    components.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用 `mraa` 库来处理 PWM 并更改 RGB LED 中不同 LED 和颜色的亮度级别。然而，在第一章中，我们也安装了 `wiring-x86`
    库。我们可以通过更改几行面向对象的代码来用 `wiring-x86` 库替换 `mraa` 库，以更改红、绿和蓝组件的亮度级别。
- en: There is an important difference between the `mraa` library and the `wiring-x86`
    library when working with PWM. The former works with floating point values from
    0.0f to 1.0f to set the output duty cycle percentage, but the latter works with
    values from 0 to 255 inclusive to set this value. Thus, when working with the
    `wiring-x86` library, we don't need to translate the desired brightness level
    to an output duty cycle percentage and we can use the brightness level value to
    specify the value for PWM. As a result, the code is simpler in this case.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用PWM时，`mraa`库和`wiring-x86`库之间存在一个重要的区别。前者使用0.0f到1.0f的浮点值来设置输出占空比百分比，但后者使用0到255（包含）的值来设置此值。因此，当使用`wiring-x86`库时，我们不需要将所需的亮度级别转换为输出占空比百分比，我们可以使用亮度级别值来指定PWM的值。因此，在这种情况下，代码更简单。
- en: The following lines shows the code for a `Board` class followed by the new version
    of the `AnalogLed` class that works with the `wiring-x86` library instead of using
    `mraa`. The code file for the sample is `iot_python_chapter_04_04.py`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了`Board`类的代码，随后是使用`wiring-x86`库而不是使用`mraa`的`AnalogLed`类的新版本。示例的代码文件为`iot_python_chapter_04_04.py`。
- en: '[PRE58]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We just needed to change a few lines from the previous code of the `AnalogLed`
    class. The new lines that interact with the `wiring-x86` library are highlighted
    in the previous code. The constructor, that is, the `__init__` method, saves a
    reference to the `Board.gpio` class attribute in `self.gpio` and calls its `pinMode`
    method with the received `pin` as its `pin` argument and `self.gpio.PWM` as its
    `mode` argument. This way, we configure the pin to be an output PWM pin. All the
    `Led` instances will save a reference to the same `Board.gpio` class attribute
    that created an instance of the `GPIO` class, specifically, the `wiringx86.GPIOGalileoGen2`
    class with its `debug` argument set to `False` to avoid unnecessary debug information
    for the low-level communications.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要从`AnalogLed`类的上一个代码中更改几行。与`wiring-x86`库交互的新行在之前的代码中突出显示。构造函数，即`__init__`方法，将`Board.gpio`类属性引用保存到`self.gpio`中，并使用接收到的`pin`作为其`pin`参数，使用`self.gpio.PWM`作为其`mode`参数调用其`pinMode`方法。这样，我们配置引脚为输出PWM引脚。所有的`Led`实例都将保存对创建`GPIO`类实例的同一`Board.gpio`类属性的引用，特别是具有`debug`参数设置为`False`的`wiringx86.GPIOGalileoGen2`类，以避免低级通信中的不必要调试信息。
- en: The `set_brightness` method calls the `analogWrite` method for the GPIO instance
    (`self.gpio`) to set the output duty-cycle for the pin configured as PWM output
    to `brightness_value`. The `self.pin` attribute specifies the `pin` value for
    the `analogWrite` method call. Because `brightness_value` is already a value between
    0 and 255 (inclusive), it is valid value for the `analogWrite` method.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_brightness`方法调用GPIO实例（`self.gpio`）的`analogWrite`方法来设置配置为PWM输出的引脚的输出占空比为`brightness_value`。`self.pin`属性指定了`analogWrite`方法调用中的`pin`值。因为`brightness_value`已经是一个介于0和255（包含）之间的值，所以它是`analogWrite`方法的合法值。'
- en: The rest of the code for our RESTful API remains the same one that we have used
    for the previous example. There is no need to make changes to this class because
    it will automatically work with the new `AnalogLed` class and there were no changes
    in the arguments for its constructor or its `set_brightness` methods.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们RESTful API的其余代码与之前示例中使用的相同。没有必要更改此类，因为它将自动与新的`AnalogLed`类一起工作，并且其构造函数或`set_brightness`方法的参数没有发生变化。
- en: The following line will start the HTTP server and our new version of the RESTful
    API that works with the `wiring-x86` library. Don't forget that you need to transfer
    the Python source code file to the Yocto Linux with an SFTP client, as explained
    in the previous chapter.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将启动HTTP服务器和与`wiring-x86`库一起工作的我们新的RESTful API版本。不要忘记，你需要像前一章中解释的那样，使用SFTP客户端将Python源代码文件传输到Yocto
    Linux。
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Tip
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We can make the same HTTP requests we made in our previous example to check
    that we can achieve exactly the same results with the `wiring-x86` library.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们在上一个示例中使用的相同HTTP请求来检查我们是否可以使用`wiring-x86`库达到完全相同的结果。
- en: Test your knowledge
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'PWM stands for:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PWM代表：
- en: Pin Work Mode.
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引脚工作模式。
- en: Pulse Weight Modulation.
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脉冲宽度调制。
- en: Pulse Width Modulation.
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脉冲宽度调制。
- en: 'In the Intel Galileo Gen 2 board, the pins labeled with the following symbol
    as a prefix for the number can be used as PWM output pins:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Intel Galileo Gen 2板上，以下符号作为前缀的引脚可以用作PWM输出引脚：
- en: Hash sign (**#**).
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哈希符号（**#**）。
- en: Dollar sign (**$**).
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 美元符号（**$**）。
- en: Tilde symbol (**~**).
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 波浪符号（**~**）。
- en: 'A 100% duty cycle (always signal in the ON status) in a PWM pin will generate
    a steady voltage equal to:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PWM引脚上的100%占空比（始终处于开启状态）将产生一个稳定的电压，等于：
- en: 0 V.
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 0 V。
- en: The voltage specified in the position in which the IOREF jumper is located.
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定在IOREF跳线所在位置的电压。
- en: 6 V.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6 V。
- en: 'A 0% duty cycle (always signal in the OFF status) in a PWM pin will generate
    a steady voltage equal to:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PWM引脚上的0%占空比（始终处于关闭状态）将产生一个稳定的电压，等于：
- en: 0 V.
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 0 V。
- en: The voltage specified in the position in which the IOREF jumper is located.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定在IOREF跳线所在位置的电压。
- en: 6 V.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6 V。
- en: 'A 50% duty cycle in a PWM pin with a LED connected to it will generate the
    same result as a steady voltage equal to:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PWM引脚上有一个LED连接时，50%的占空比将产生与稳定电压等于的结果：
- en: 0 V.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 0 V。
- en: Half the voltage specified in the position in which the IOREF jumper is located.
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定在IOREF跳线所在位置的电压的一半。
- en: 6 V * 0.5 = 3 V.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6 V * 0.5 = 3 V。
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we worked with Tornado web server, Python, the HTTPie command-line
    HTTP client, and the `mraa` and `wiring-x86` libraries. As in the previous chapters,
    we took advantage of Python's object-oriented features and we generated many versions
    of RESTful APIs that allowed us to interact with the board in computers and devices
    connected to the LAN.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了Tornado网络服务器、Python、HTTPie命令行HTTP客户端以及`mraa`和`wiring-x86`库。与前面的章节一样，我们利用了Python的面向对象特性，并生成了许多版本的RESTful
    API，使我们能够与连接到LAN的计算机和设备上的板进行交互。
- en: We could compose and send HTTP requests that printed number in LEDs, changed
    the brightness levels for three LEDs and generated millions of colors with an
    RGB LED.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写并发送HTTP请求，这些请求会在LED上打印数字，改变三个LED的亮度级别，并使用RGB LED生成数百万种颜色。
- en: Now that we created our first RESTful APIs that made is possible for computers
    and devices to interact with our IoT device, we can take advantage of additional
    features that allow us to read digital inputs and analog values, which is the
    topic of the next chapter.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了第一个RESTful API，这使得计算机和设备能够与我们的物联网设备交互，我们可以利用额外的功能来读取数字输入和模拟值，这是下一章的主题。
