- en: Making a Package
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建包
- en: In the previous chapter, we saw how to install Python and third-party packages
    of code that we can use with Python. In this chapter, we'll see how packages are
    represented on the computer's filesystem. We'll take a look at how to add code
    modules inside the package, how to make those code modules interact with each
    other within the package, and how to access data from non-code files that are
    incorporated into our package.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何安装Python和我们可以与Python一起使用的第三方代码包。在本章中，我们将看到包在计算机文件系统中的表示。我们将探讨如何在包内部添加代码模块，如何使这些代码模块在包内部相互交互，以及如何访问包含在我们包中的非代码文件中的数据。
- en: By the end of this chapter, you'll have a pretty good idea about how to create
    your own packages of Python code. Packages will form the basis for programs and
    help you to make your code modular.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将很好地了解如何创建自己的Python代码包。包将成为程序的基础，并帮助你使代码模块化。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating an empty package
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个空包
- en: Adding modules to the package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向包中添加模块
- en: Accessing code from other modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其他模块访问代码
- en: Adding static data files to the package
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向包中添加静态数据文件
- en: Creating an empty package
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个空包
- en: The first section of this chapter deals with creating a simple empty package,
    which won't do anything yet, but by the time we're done, we'll be able to import
    the empty package into the Python shell.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分将处理创建一个简单的空包，目前它不会做任何事情，但当我们完成时，我们将能够将空包导入Python shell。
- en: Simple Python projects may consist of a single code module, but normally there
    are multiple modules combined together into a package. A package can contain as
    many modules as we need it to. Packages start their lives as folders on the filesystem,
    which means we can make them just as we would make any other folder.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的Python项目可能只包含一个代码模块，但通常是将多个模块组合成一个包。一个包可以包含我们需要的任何数量的模块。包从文件系统上的文件夹开始，这意味着我们可以像创建任何其他文件夹一样创建它们。
- en: 'If you prefer to use your operating system''s file browser to make folders,
    that''s fine, but I usually use the command line. For example let''s run a demo
    package:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用操作系统的文件浏览器来创建文件夹，那也行，但我通常使用命令行。例如，让我们运行一个演示包：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is shown as the following screenshot:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下屏幕截图中有显示：
- en: '![](img/93df4e38-10cc-4c9e-adce-7fb163f047f7.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/93df4e38-10cc-4c9e-adce-7fb163f047f7.jpg)'
- en: Turning a regular folder into a package
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将普通文件夹变成包
- en: 'There are two things that turn a regular folder into a package. These are explained
    as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个东西将普通文件夹变成包。以下是对它们的解释：
- en: The first is *where is it* that is, the location of the folder. Python only
    looks in certain places for packages and if your folder isn't in the right place,
    Python won't notice it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点是*它在哪*，即文件夹的位置。Python只在特定位置查找包，如果你的文件夹不在正确的位置，Python将不会注意到它。
- en: 'The `sys.path` variable contains the list of all the places Python will look
    for packages. The `sys.path` variable is fairly sparse, but user configuration
    can make it much more extensive as shown in the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.path`变量包含Python将查找包的所有位置列表。`sys.path`变量相当稀疏，但用户配置可以使它变得更为广泛，如下面的屏幕截图所示：'
- en: '![](img/15a9435e-92b9-44d6-82b1-35dfd6501e41.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/15a9435e-92b9-44d6-82b1-35dfd6501e41.jpg)'
- en: Notice that the first entry in the list is an empty string. This stands for
    the current working directory.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意列表中的第一个条目是一个空字符串。这代表当前工作目录。
- en: For those who are using the command line, the current working directory is just
    the folder we're currently in.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用命令行的人来说，当前工作目录只是我们当前所在的文件夹。
- en: 'We can change the current working directory with the `cd` command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`cd`命令来更改当前工作目录：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `cd..` command in the preceding code means go back to the previous directory
    or the parent directory. So, in this case, I went in and out of `demopackage`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中的`cd..`命令表示返回到上一个目录或父目录。因此，在这种情况下，我进入了`demopackage`并退了出来。
- en: The fact that the current working directory is in the path is convenient during
    development; it means that we could just set the current working directory to
    the place where we're doing our development and all of our packages become available,
    at least, as long as we also use the command line to launch Python.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当前工作目录在路径中对于开发来说很方便；这意味着我们可以将当前工作目录设置为我们进行开发的地方，这样我们的所有包都可用，至少在我们也使用命令行启动Python时是这样。
- en: The second thing that turns a regular folder into a package is the presence
    of `__init__.py` file, though not strictly necessary since Python 3.3 and beyond.
    An `init` file marks the folder as a package, which makes it load more efficiently
    and also gives us a place to put information and code relevant to the interface
    of the package as a whole.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将普通文件夹转换为包的第二个原因是存在 `__init__.py` 文件，尽管从 Python 3.3 及更高版本开始，这并非严格必要。一个 `init`
    文件将文件夹标记为包，这使得它加载更高效，同时也为我们提供了一个放置与包整体接口相关的信息和代码的地方。
- en: While it's quite common that the `__init__.py` file is completely empty and
    serves only as a marker, there's one language feature that won't be supported
    unless we add a little code to the file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `__init__.py` 文件通常是空的，仅作为标记，但有一个语言特性，除非我们在文件中添加一些代码，否则将不会得到支持。
- en: 'This feature is the ability to import all the package''s modules using the
    `import*` syntax, as shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性是能够使用 `import*` 语法导入包的所有模块，如下所示：
- en: '![](img/6ba7b4dd-eeed-4b97-8974-0f7776d10eb7.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ba7b4dd-eeed-4b97-8974-0f7776d10eb7.jpg)'
- en: Importing all package modules
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入所有包模块
- en: If we want Python to be able to import all the package's modules using `import*`
    syntax, we have to tell it the names of all those modules.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让 Python 能够使用 `import*` 语法导入所有包的模块，我们必须告诉它所有这些模块的名称。
- en: 'To do this, we add the module names to a list called `__all__` in the `init`
    file as shown in the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，我们需要将模块名称添加到名为 `__all__` 的列表中，如以下代码所示：
- en: '![](img/e260d3ec-8221-427c-9503-f279ae03fe16.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e260d3ec-8221-427c-9503-f279ae03fe16.jpg)'
- en: 'If you don''t have *emacs* installed on your system, you can install it by
    using the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你系统上没有安装 *emacs*，你可以使用以下命令进行安装：
- en: '`**sudo apt install emacs24**` In the preceding screenshot, I have used Ubuntu,
    thus the editor is white background, however in case of Windows OS and macOS,
    the background of the editor can be different.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`**sudo apt install emacs24**` 在前面的屏幕截图中，我使用了 Ubuntu，因此编辑器的背景是白色的，然而在 Windows
    OS 和 macOS 的情况下，编辑器的背景可能不同。'
- en: You might be wondering why we need to do this manually rather than Python just
    scanning the filesystem for module files.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们需要手动执行此操作，而不是让 Python 直接扫描文件系统以查找模块文件。
- en: 'Well, there are a couple of reasons:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，有几个原因：
- en: First, Python tries not to make any assumptions about whether filenames are
    case-sensitive or not. On some operating systems, filenames are case-sensitive
    and on other operating systems they are not. Module names are variables, so it's
    better they originate within the source code, rather than depending on something
    external that might change depending on where the code is run.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，Python 尽量不假设文件名是否区分大小写。在某些操作系统上，文件名是区分大小写的，而在其他操作系统上则不是。模块名是变量，因此它们最好在源代码中起源，而不是依赖于可能根据代码运行的位置而改变的外部因素。
- en: The second reason for doing this manually is that importing a module makes code
    execute.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动执行此操作的第二原因是导入模块会使代码执行。
- en: Imagine we have a package that plays soundtracks. In addition to the general
    purpose code, we also have a bunch of modules that handle audio output on various
    systems.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们有一个播放音轨的包。除了通用代码之外，我们还有许多处理各种系统音频输出的模块。
- en: Allowing our users to do an `import*` to bring their packages' programming interface
    into their module is quite reasonable; however, we don't want all of the output
    modules to load, just the one that's appropriate to the system we're running on.
    Trying to load any of the others would most likely trigger an exception in the
    user's code. The way `__all__` works now, we can exclude the output modules from
    `import*` and get the best of both worlds.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 允许用户使用 `import*` 将他们的包编程接口导入到模块中是相当合理的；然而，我们不想加载所有输出模块，只想加载适合我们正在运行的系统的那个模块。尝试加载其他任何模块很可能会在用户的代码中触发异常。现在
    `__all__` 的工作方式，我们可以排除输出模块从 `import*` 中，从而实现两全其美。
- en: Alright, let's make sure that Python is willing to import our demo package before
    we move on to the next part, which is how to add source code modules to a package.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，在我们继续下一部分之前，即如何将源代码模块添加到包中之前，让我们确保 Python 愿意导入我们的演示包。
- en: Adding modules to the package
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加模块到包
- en: Now, let's take look at how to add actual code to the package and look out for
    a couple of pitfalls to avoid.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何将实际代码添加到包中，并注意一些需要避免的陷阱。
- en: 'Python modules have the same name as objects that they have as filenames, except
    without the `.py` suffix. This means that the filenames need to be valid Python
    variable names  and also that they should use letters and symbols that are reliably
    available across different operating systems. The following screenshot showns
    an example for this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Python模块的名称与它们作为文件名所对应的对象名称相同，只是没有`.py`后缀。这意味着文件名需要是有效的Python变量名，并且它们应该使用在不同操作系统上可靠可用的字母和符号。以下截图展示了这一示例：
- en: '![](img/e66aaf50-521f-427c-9518-cb0ddacc16cd.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e66aaf50-521f-427c-9518-cb0ddacc16cd.jpg)'
- en: So, module names should not start with a number because Python variables are
    not allowed to start with numbers. Also, it should not use capital letters because
    some common operating system don't differentiate between filenames containing
    capital letters and filenames that are all lowercase. As long as we stay within
    Python variable name guidelines and remember to use a `.py` suffix, we can name
    our modules anything we please.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模块名称不应以数字开头，因为Python变量不允许以数字开头。也不应使用大写字母，因为一些常见的操作系统不区分包含大写字母的文件名和全部小写的文件名。只要我们遵守Python变量命名指南并记得使用`.py`后缀，我们就可以随意命名我们的模块。
- en: So, we just pick a filename and start writing Python code into a file with that
    name in the `package` folder. That simple scenario is also the common case, but
    there's another possibility.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需选择一个文件名，然后在`package`文件夹中以该名称创建一个文件，并将Python代码写入其中。这种简单场景也是常见情况，但还有一种可能性。
- en: Module loading with namespace packages
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命名空间包进行模块加载
- en: 'As mentioned earlier, starting with Python 3.3, it''s possible to have a `package`
    folder that doesn''t contain an `init` file. Leaving out the `init` file means
    we can''t support `import*` or the other tricks within it that we''ll discover
    as we go along. But, there''s more to it than that. The following screenshot shows
    a code example for this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，从Python 3.3开始，可以有一个不包含`init`文件的`package`文件夹。省略`init`文件意味着我们无法支持`import*`或其他我们将在后续发现其中的技巧。但不仅如此。以下截图展示了这一示例的代码：
- en: '![](img/deaa05f7-42be-4323-a8b8-d9b1eac596b4.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/deaa05f7-42be-4323-a8b8-d9b1eac596b4.jpg)'
- en: 'When the `init` file is missing, the folder becomes part of a `namespace package`
    folder. When Python is importing, it combines all of the `namespace package` folders
    it finds, that share a name, into a single logical package, as shown in the following
    screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当缺少`init`文件时，文件夹成为`namespace package`文件夹的一部分。当Python导入时，它会将找到的所有具有相同名称的`namespace
    package`文件夹组合成一个逻辑包，如下面的截图所示：
- en: '![](img/880b45e2-324a-41b9-ad4e-df5b379cca34.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/880b45e2-324a-41b9-ad4e-df5b379cca34.jpg)'
- en: This behavior means that while choosing the module filename, Python still follows
    the same rules, we could potentially place that file into one of any number of
    `namespace package` folders instead of into a singular concrete `package` folder.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为意味着在选择模块文件名时，Python仍然遵循相同的规则，我们可能将文件放置在任何数量的`namespace package`文件夹中，而不是单一的实体`package`文件夹中。
- en: What do we gain from that? Often nothing!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能从中得到什么？通常什么也没有！
- en: As I mentioned earlier, packages with an `init` load faster, and in many cases,
    the extra abstraction of namespace packages doesn't buy us anything.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，带有`init`的包加载速度更快，在许多情况下，命名空间包的额外抽象并没有给我们带来任何好处。
- en: There are cases, however, when we want different parts of the same package to
    be distributed or managed separately and when we do, `namespace packages` address
    that need. For example, imagine again that we are working on a package for playing
    soundtracks. If we make a `namespace package` folder for audio codecs, each codec
    could be installed and removed individually using `pip` or the operating system's
    normal package management tools.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，我们希望同一包的不同部分被分别分发或管理，在这种情况下，`namespace packages`可以满足这一需求。例如，再次想象我们正在为一个播放音轨的包工作。如果我们为音频编解码器创建一个`namespace
    package`文件夹，每个编解码器都可以使用`pip`或操作系统的常规包管理工具单独安装和删除。
- en: On a slightly different topic, now let's talk about the difference between how
    a package is structured and the interface it should present for use by external
    code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个稍微不同的话题上，现在让我们谈谈包的结构和它应该为外部代码使用提供的接口之间的区别。
- en: The Package structure and interface
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包结构及接口
- en: For the convenience and sanity of ourselves as the package developers, it's
    often best to break up the code in a package into many different modules, all
    of which contain a selection of conceptually related code; this is the package's
    structure. As a rule of thumb, whenever we think we might want to break the code
    up into more modules, we probably should go with that impulse.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便和保持我们作为包开发者的理智，通常最好是将包中的代码拆分成许多不同的模块，所有这些模块都包含一组概念上相关的代码；这就是包的结构。一般来说，每当我们认为可能需要将代码拆分成更多模块时，我们可能应该跟随这种冲动。
- en: 'On the other hand, external code calling on our package is best off when it
    can take advantage of our code with just one or two import statements that bring
    in a small number of functions or classes. This is the package''s interface, and
    as a rule of thumb, it should be as minimal as possible, while preserving full
    functionality, as shown in the following code example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当外部代码调用我们的包时，最好能够仅通过一个或两个导入语句来利用我们的代码，这些语句引入了少量函数或类。这是包的接口，一般来说，它应该尽可能简单，同时保留完整的功能，如下面的代码示例所示：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Fortunately, we can have our cake and eat it too!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以同时拥有我们的蛋糕并享用它！
- en: We could divide our code up however we wish and then import the most useful
    elements into our `init` file, which will make them part of the package's route
    namespace. If all that's in an `init` file is `import` statements, we don't need
    the `__all__` variable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照自己的意愿将代码拆分，然后将最有用的元素导入到我们的`init`文件中，这样它们就成为包的路由命名空间的一部分。如果`init`文件中只有`import`语句，我们不需要`__all__`变量。
- en: An `import*` statement will grab the contents of the `init` file except for
    variables, starting with an underscore. However, if we define or import anything
    in the `init` file that should not be part of the public interface, we can use
    the `__all__` variable to narrow down and control what we export.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`import*`语句将抓取`init`文件的内容，除了以下划线开头的变量。然而，如果我们定义或导入在`init`文件中不应成为公共接口的一部分的内容，我们可以使用`__all__`变量来缩小范围并控制我们导出的内容。'
- en: Just remember, if we have an all list, it needs to list everything that is part
    of the package's interface, whether a module, class, function, or variable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，如果我们有一个所有列表，它需要列出包接口的所有部分，无论是模块、类、函数还是变量。
- en: The rest of the modules in the package are still available to be explicitly
    imported. We're just making it convenient to access the parts that are most likely
    to be useful outside our own package.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 包中其余的模块仍然可以显式导入。我们只是使访问那些最有可能在我们自己的包外部有用的部分变得方便。
- en: Now we have a good idea of how to name our modules, where to put them so that
    they become part of our package, and how to give our package a convenient interface.
    Next, we'll move on to looking at how to make the modules in a package interact
    with each other.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地了解了如何命名我们的模块，将它们放在哪里以便它们成为我们包的一部分，以及如何为我们的包提供一个方便的接口。接下来，我们将继续探讨如何使包中的模块相互交互。
- en: Accessing code from other modules
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从其他模块访问代码
- en: We'll start off this section by understanding the difference between absolute
    and relative imports, then move on to writing those, and finally, we'll look at
    cyclic dependencies.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从理解绝对导入和相对导入之间的区别开始本节，然后继续编写这些导入，最后我们将查看循环依赖。
- en: When we are importing one of the package's modules from outside the package,
    there's only one sensible way that it could work-we tell Python which package
    and module we want, and it either finds and imports it or raises an exception
    if it can't. Simple!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从包外部导入包的一个模块时，只有一种合理的方式可以工作——我们告诉Python我们想要的包和模块，如果它找到了并导入了它，或者如果找不到则抛出异常。简单！
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When we''re already inside a package, the situation is more ambiguous because
    `import name` could just as easily mean "look for `name` within this package"
    or "look for `name` in the Python search path." Python breaks this ambiguity by
    defining `import name` to mean that a package or module called **name** should
    be searched for in Python''s search path:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们已经在包内部时，情况更为模糊，因为`import name`可能意味着“在这个包内寻找`name`”或“在Python搜索路径中寻找`name`。”Python通过定义`import
    name`意味着应该搜索Python搜索路径中的名为**name**的包或模块来消除这种歧义：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Also, it also gives us a way to specify a relative `import` if we''d rather
    have it just look within the current package. We can specify a relative `import`
    by putting a dot in front of the name of the module we want to import, as shown
    in the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还为我们提供了一种指定相对`import`的方法，如果我们更愿意让它只查找当前包。我们可以通过在要导入的模块名称前放置一个点来指定相对`import`，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When Python sees this, it will look for a module called `name` in the same package
    as the module our code is running in.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python看到这一点时，它将在我们的代码正在运行的模块所在的同一包中寻找名为`name`的模块。
- en: 'Often, we only need one or two objects from another module and it''s more convenient
    to import those objects directly into our global scope than it would be to import
    the module as a whole and access its contents. Python lets us do that with a slight
    variation on the `import` syntax:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们只需要从另一个模块中导入一个或两个对象，直接将这些对象导入我们的全局作用域比导入整个模块并访问其内容更方便。Python允许我们通过在`import`语法上稍作变化来实现这一点：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, sometimes we want to rename an object within our scope as we import
    it. We could do that by modifying our import with the `as` keyword:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有时在我们导入对象时，我们可能想要将其重命名。我们可以通过使用`as`关键字修改我们的导入语句来实现这一点：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, even though the object is called `Foo` in the `name`
    module, in our current module, it's named `Bar`. This trick works for absolute
    imports too by the way.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，即使对象在`name`模块中被称为`Foo`，在我们的当前模块中，它被称为`Bar`。顺便说一下，这个技巧对绝对导入也适用。
- en: Before we move on, let's take note that Python 2 used a different rule for deciding
    where to find imported code. In Python 2, it first tried to find a target of an
    import within the current package. Then, if no matching module was found there,
    it went out and looked for it on the search path. This approach usually did the
    right thing, but occasionally caused problems due to the ambiguous meaning; and
    it meant that we couldn't have some packages, sub-packages, or modules that shared
    the name of anything in the standard library or other installed packages. So,
    this behavior was changed in Python 3.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们注意一下Python 2在决定在哪里查找导入代码时使用了一个不同的规则。在Python 2中，它首先尝试在当前包中找到导入的目标。然后，如果没有找到匹配的模块，它就会在搜索路径上查找。这种方法通常做对了，但偶尔由于含义不明确而引起问题；这也意味着我们无法拥有一些包、子包或模块，它们的名称与标准库或其他已安装包中的任何内容相同。因此，在Python
    3中改变了这种行为。
- en: Importing a cyclic dependency
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入循环依赖
- en: 'There is something that might trip us up when we''re importing a module that
    shares the same package. Sometimes, the module we''re importing wants to import
    us as well. This is called a **cyclic dependency**. When we try to import a cyclic
    dependency, we''ll almost always get an attribute error exception, as in the following
    example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们导入一个与同一包共享的模块时，可能会遇到一些问题。有时，我们正在导入的模块也希望导入我们。这种情况被称为**循环依赖**。当我们尝试导入循环依赖时，我们几乎总是会得到一个属性错误异常，如下面的例子所示：
- en: '![](img/9cb740b2-3831-4c8d-8375-97be13077540.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9cb740b2-3831-4c8d-8375-97be13077540.jpg)'
- en: That happens because when we ask Python to import the first module, Python immediately
    creates a module object for it and begins executing the code in the module.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当我们请求Python导入第一个模块时，Python立即为它创建一个模块对象，并开始执行模块中的代码。
- en: That's fine, except that, when Python gets to the `import` statement for the
    next module in this cycle, it pauses running the code in the first module, leaving
    it not fully initialized. Even that isn't normally a problem because Python will
    come back and finish the initialization later.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有问题，但是，当Python到达这个循环中下一个模块的`import`语句时，它会暂停第一个模块中的代码执行，使其未完全初始化。尽管这通常不是问题，因为Python会在稍后回来完成初始化。
- en: However, when the second module asks to import the first module, Python just
    hands it the already allocated, and not fully initialized, module object. When
    the second module tries to access the variables stored in the first object, many
    of them will not yet have been created. Hence, an attribute error is raised.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当第二个模块请求导入第一个模块时，Python只是将已经分配但尚未完全初始化的模块对象传递给它。当第二个模块尝试访问第一个对象中存储的变量时，其中许多变量尚未创建。因此，会引发一个属性错误。
- en: Resolving attribute errors raised due to cyclic dependencies
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决由于循环依赖引起的属性错误
- en: 'There are two common ways to address the attribute error. The first one is
    usually considered the best. This method is to break the cycle by taking some
    of the code from one of the modules and moving it into a third module, which both
    the other modules can import without causing a cycle. In the following example,
    if we move the `A` class into its own module, there would be no cycle and all
    would be well:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 解决属性错误有两种常见的方法。第一种通常被认为是最好的。这种方法是通过将某个模块中的部分代码移入一个第三模块，这样其他模块就可以导入它而不会造成循环。在下面的示例中，如果我们把`A`类移入它自己的模块，就不会有循环，一切都会顺利：
- en: '![](img/dad5ee64-c51b-489d-935b-13e1ac917d9b.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dad5ee64-c51b-489d-935b-13e1ac917d9b.jpg)'
- en: 'The other way to address this problem is to move the `import` statement that
    causes the cycle, as shown in the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的另一种方法是移动造成循环的`import`语句，就像以下截图所示：
- en: '![](img/93ba170e-592f-4227-9b25-3d8f3ebf975f.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/93ba170e-592f-4227-9b25-3d8f3ebf975f.jpg)'
- en: If we move the `import` statement down, as shown in the preceding example, until
    it's below all the variable definitions that are needed by the other modules in
    this cycle, the module will be initialized enough when it's imported by the other
    modules. Python will still come back and finish the initialization later.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`import`语句向下移动，就像前面示例中那样，直到它位于其他模块需要的所有变量定义之下，当其他模块导入时，模块将初始化足够，Python会在稍后回来完成初始化。
- en: Adding static data files to the package
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将静态数据文件添加到包中
- en: If we're going to add static data files to the package, where should we put
    them?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要将静态数据文件添加到包中，我们应该把它们放在哪里？
- en: Well we can put them anywhere that's convenient within the `package` folder,
    but it's often a good idea to create a subfolder specifically for holding the
    data files. This keeps data files separate from the source code and generally
    makes them a little easier to work with.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`package`文件夹内的任何方便的地方放置它们，但通常创建一个专门用于存放数据文件的子文件夹是个好主意。这可以将数据文件与源代码分开，并且通常使它们更容易处理。
- en: The data files that are part of a package should be assumed to be read-only.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 包的一部分数据文件应假定是只读的。
- en: 'There are many reasons that might cause the files to not be writable at runtime.
    So, if we want to write data to a file while our code is running, we need to pick
    somewhere else to store it. Only files that do not change are appropriate for
    inclusion in a package:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多原因可能导致文件在运行时不可写。因此，如果我们想在代码运行时写入数据，我们需要选择其他地方来存储它。只有不改变文件才适合包含在包中：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So, that said, all we have to do to include a data file in our package is drop
    it into our package and then access the data with the `get_data` function from
    the `util` package in the standard library:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这么说来，我们想要在我们的包中包含一个数据文件，只需要将其放入我们的包中，然后使用标准库中`util`包的`get_data`函数来访问数据：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `get_data` function takes two parameters:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_data`函数接受两个参数：'
- en: The name of the package we want to get the data from
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要从该包获取数据的包名
- en: The relative path of the data file inside the package
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包内数据文件的相对路径
- en: Using forward slashes to separate path components, we pass it these two pieces
    of information and it returns a byte object to us containing the contents of the
    file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正斜杠分隔路径组件，我们传递这两条信息，它就会返回一个包含文件内容的字节对象给我们。
- en: If we want a text string instead of bytes, that's easily done. We just need
    to apply the proper string decoder to the bytes object and we'll get back a unicode
    text string. This technique will work even if our package has been compressed
    into a ZIP file or otherwise hidden away because it uses the same underlying mechanism
    that Python uses to load module source code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个文本字符串而不是字节，这很容易做到。我们只需要将适当的字符串解码器应用到字节对象上，我们就会得到一个Unicode文本字符串。即使我们的包已经被压缩成ZIP文件或其他方式隐藏起来，这种技术仍然有效，因为它使用了Python加载模块源代码相同的底层机制。
- en: If Python can find the code, it can find the data file as well. That's all there
    is to working with static data that's packaged up alongside our code. It's simple
    and useful.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Python能够找到代码，它同样可以找到数据文件。这就是与打包在代码旁边的静态数据一起工作的全部内容。简单且实用。
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to create a Python package as a directory on
    the filesystem and how to mark it with an `__init__.py` file, so that importing
    is efficient and we can add package metadata. We looked at adding code modules
    to a package. We saw how code modules within the same package interact.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在文件系统中创建一个Python包作为目录，以及如何通过一个`__init__.py`文件来标记它，以便导入高效并且我们可以添加包元数据。我们探讨了如何向包中添加代码模块。我们看到了同一包内的代码模块是如何交互的。
- en: We learned how to put together a Python code package that can be used in a program
    or distributed to other programmers. Soon, we'll see how to turn a package into
    a complete program as well. In the next chapter, we'll step back a little bit
    and talk about some best practices for working with Python code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何组合一个Python代码包，它可以被用于程序中或分发给其他程序员使用。很快，我们将看到如何将一个包转换成一个完整的程序。在下一章中，我们将稍微退后一步，讨论一些与Python代码一起工作的最佳实践。
