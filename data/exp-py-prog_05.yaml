- en: Chapter 5. Writing a Package
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。编写包
- en: 'This chapter focuses on a repeatable process to write and release Python packages.
    Its intentions are:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了编写和发布Python包的可重复过程。其意图是：
- en: To shorten the time needed to set up everything before starting the real work
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始真正工作之前缩短设置所需的时间
- en: To provide a standardized way to write packages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种标准化的编写包的方式
- en: To ease the use of a test-driven development approach
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化测试驱动开发方法的使用
- en: To facilitate the releasing process
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促进发布过程
- en: 'It is organized into the following four parts:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 它分为以下四个部分：
- en: A **common** **pattern** for all packages that describes the similarities between
    all Python packages, and how `distutils` and `setuptools` play a central role
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有包的**常见模式**，描述了所有Python包之间的相似之处，以及`distutils`和`setuptools`如何发挥核心作用
- en: What **namespace packages** are and why they can be useful
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是**命名空间包**以及它们为何有用
- en: How to register and upload packages in the **Python Package Index** (**PyPI**)
    with emphasis on security and common pitfalls
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在**Python包索引**（**PyPI**）中注册和上传包，重点放在安全性和常见陷阱上
- en: The **stand-alone executables** as an alternative way to package and distribute
    Python applications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立可执行文件作为打包和分发Python应用程序的替代方式
- en: Creating a package
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个包
- en: Python packaging can be a bit overwhelming at first. The main reason for that
    is the confusion about proper tools for creating Python packages. Anyway, once
    you create your first package, you will see that this is not as hard as it looks.
    Also, knowing proper, state-of-the art packaging tools helps a lot.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python打包一开始可能有点令人不知所措。这主要是因为对于创建Python包的适当工具的混乱。不管怎样，一旦您创建了第一个包，您会发现这并不像看起来那么困难。此外，了解适当的、最新的打包工具也会有很大帮助。
- en: You should know how to create packages even if you are not interested in distributing
    your code as open source. Knowing how to make your own will give you more insight
    into the packaging ecosystem and will help you to work with third-party code available
    on PyPI that you are probably using.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您不打算将代码作为开源分发，您也应该知道如何创建包。了解如何制作自己的包将使您更深入地了解打包生态系统，并有助于您使用PyPI上可用的第三方代码。
- en: Also, having your closed source project or its components available as source
    distribution packages can help you to deploy your code in different environments.
    Advantages of leveraging the Python packaging ecosystem in code deployment will
    be described in more detail in the next chapter. Here we will focus on proper
    tools and techniques to create such distributions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将您的闭源项目或其组件作为源分发包可用，可以帮助您在不同环境中部署代码。利用Python打包生态系统在代码部署中的优势将在下一章中更详细地描述。在这里，我们将专注于创建这样的分发的适当工具和技术。
- en: The confusing state of Python packaging tools
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python打包工具的混乱状态
- en: The state of Python packaging was very confusing for a long time and it took
    many years to bring organization to this topic. Everything started with the `distutils`
    package introduced in 1998 that was later enhanced by `setuptools` in 2003\. These
    two projects started a long and knotted story of forks, alternative projects,
    and complete rewrites that tried to once and for all fix Python's packaging ecosystem.
    Unfortunately, most of these attempts never succeeded. The effect was quite the
    opposite. Each new project that aimed to supersede `setuptools` or `distutils`
    only added up to the already huge confusion around packaging tools. Some of such
    forks were merged back to their ancestors (like `distribute` that was a fork of
    `setuptools`) but some were left abandoned (like `distutils2`).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间以来，Python打包的状态非常混乱，花了很多年时间才将这个话题组织起来。一切都始于1998年引入的`distutils`包，后来在2003年由`setuptools`进行了增强。这两个项目开启了一个漫长而复杂的分叉、替代项目和完全重写的故事，试图一劳永逸地修复Python的打包生态系统。不幸的是，大多数尝试都没有成功。效果恰恰相反。每个旨在取代`setuptools`或`distutils`的新项目都增加了已经围绕打包工具的巨大混乱。一些这样的分叉被合并回它们的祖先（比如`distribute`是`setuptools`的一个分叉），但有些被遗弃了（比如`distutils2`）。
- en: Fortunately, this state is gradually changing. An organization called **Python
    Packaging Authority** (**PyPA**) was formed to bring back the order and organization
    to the packaging ecosystem. **Python Packaging User Guide** ([https://packaging.python.org](https://packaging.python.org)),
    maintained by PyPA, is the authoritative source of information about the latest
    packaging tools and best practices. Treat it as the best source of information
    about packaging and a complementary reading to this chapter. The guide also contains
    a detailed history of changes and new projects related to packaging, so it will
    be useful if you already know a bit but want to make sure you still use the proper
    tools.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这种状态正在逐渐改变。一个名为**Python打包管理机构**（**PyPA**）的组织成立，旨在恢复打包生态系统的秩序和组织。由PyPA维护的**Python打包用户指南**（[https://packaging.python.org](https://packaging.python.org)）是关于最新打包工具和最佳实践的权威信息来源。把它视为关于打包的最佳信息来源，以及本章的补充阅读。该指南还包含了与打包相关的更改和新项目的详细历史，因此如果您已经了解一些内容但想确保仍在使用适当的工具，它将非常有用。
- en: Stay away from other popular Internet resources, such as **The Hitchhiker's
    Guide to Packaging**. It is old, not maintained, and mostly obsolete. It may be
    interesting only for historical reasons and the Python Packaging User Guide is
    in fact a fork of this old resource.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 远离其他流行的互联网资源，比如**打包者指南**。它已经过时，没有维护，大部分已经过时。它可能只是出于历史原因有趣，而Python打包用户指南实际上是这个旧资源的一个分支。
- en: The current landscape of Python packaging thanks to PyPA
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 由于PyPA，Python打包的当前格局
- en: 'PyPA, besides providing an authoritative guide for packaging, also maintains
    packaging projects and the standardization process for new official aspects of
    packaging. All of PyPA''s projects can be found under a single organization on
    GitHub: [https://github.com/pypa](https://github.com/pypa).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为打包提供权威指南外，PyPA还维护打包项目和新官方打包方面的标准化过程。PyPA的所有项目都可以在GitHub的一个组织下找到：[https://github.com/pypa](https://github.com/pypa)。
- en: 'Some of them were already mentioned in the book. The most notable are:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些在书中已经提到。最显著的是：
- en: '`pip`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip`'
- en: '`virtualenv`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virtualenv`'
- en: '`twine`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`twine`'
- en: '`warehouse`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`warehouse`'
- en: Note that most of them were started outside of this organization and only moved
    under PyPA patronage as mature and widespread solutions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，其中大多数是在该组织之外启动的，并且只有在成熟和广泛使用的解决方案下才移至PyPA赞助下。
- en: Thanks to PyPA engagement, the progressive abandoning of the eggs format in
    favor of wheels for built distributions is already happening. The future may bring
    us even more fresh breath. PyPA is actively working on `warehouse`, which aims
    to completely replace current PyPI implementations. This will be a huge step in
    packaging history because `pypi` is so old and neglected a project that only a
    few of us can imagine gradually improving it without a total rewrite.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PyPA的参与，逐渐放弃鸡蛋格式，转而使用wheels进行构建分发已经在进行中。未来可能会带来更多新的变化。PyPA正在积极开发`warehouse`，旨在完全取代当前的PyPI实现。这将是包装历史上的一大步，因为`pypi`是一个如此古老和被忽视的项目，只有少数人能够想象在没有完全重写的情况下逐渐改进它。
- en: Tool recommendations
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具推荐
- en: 'Python Packaging User Guide gives a few suggestions on recommended tools for
    working with packages. They can be generally divided into two groups: tools for
    installing packages and tools for package creation and distribution.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Python Packaging User Guide给出了一些建议，推荐使用一些工具来处理软件包。它们通常可以分为两组：用于安装软件包的工具和用于创建和分发软件包的工具。
- en: 'Utilities from the first group recommended by PyPA were already mentioned in
    [Chapter 1](ch01.html "Chapter 1. Current Status of Python"), *Current Status
    of Python*, but let''s repeat them here for the sake of consistency:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: PyPA推荐的第一组工具已经在[第1章](ch01.html "第1章。Python的当前状态")中提到过，但为了保持一致，让我们在这里重复一下：
- en: Use `pip` for installing packages from PyPI
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pip`从PyPI安装软件包
- en: Use `virtualenv` or `venv` for application-level isolation of the Python environment
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`virtualenv`或`venv`来实现Python环境的应用级隔离
- en: 'The Python Packaging User Guide recommendations of tools for package creation
    and distribution are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Python Packaging User Guide给出了一些建议，推荐用于创建和分发软件包的工具如下：
- en: Use `setuptools` to define projects and create **source distributions**
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`setuptools`来定义项目并创建**源分发**
- en: Use **wheels** in favor of **eggs** to create **built distributions**
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**wheels**而不是**eggs**来创建**构建分发**
- en: Use `twine` to upload package distributions to PyPI
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`twine`将软件包分发上传到PyPI
- en: Project configuration
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目配置
- en: It should be obvious that the easiest way to organize the code of big applications
    is to split it into several packages. This makes the code simpler, and easier
    to understand, maintain, and change. It also maximizes the reusability of each
    package. They act like components.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见，组织大型应用程序代码的最简单方法是将其拆分为几个软件包。这使得代码更简单，更易于理解，维护和更改。它还最大化了每个软件包的可重用性。它们就像组件一样。
- en: setup.py
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: setup.py
- en: The root directory of a package that has to be distributed contains a `setup.py`
    script. It defines all metadata as described in the `distutils` module, combined
    as arguments in a call to the standard `setup()` function. Despite `distutils`
    is a standard library module, it is recommended that you use the `setuptools`
    package instead, which provides several enhancements to the standard `distutils`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 必须分发的软件包的根目录包含一个`setup.py`脚本。它定义了`distutils`模块中描述的所有元数据，作为对标准`setup()`函数的参数的组合。尽管`distutils`是一个标准库模块，但建议您使用`setuptools`包，它对标准`distutils`提供了几个增强功能。
- en: 'Therefore, the minimum content for this file is:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，此文件的最小内容是：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`name` gives the full name of the package. From there, the script provides
    several commands that can be listed with the `–-help-commands` option:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`给出了软件包的完整名称。从那里，脚本提供了几个命令，可以使用`--help-commands`选项列出：'
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The actual list of commands is longer and can vary depending on the available
    `setuptools` extensions. It was truncated to show only those that are most important
    and relevant to this chapter. **Standard** **commands** are the built-in commands
    provided by `distutils`, whereas **extra** **commands** are the ones created by
    third-party packages such as `setuptools` or any other package that defines and
    registers a new command. One such extra command registered by another package
    is `bdist_wheel` provided by the `wheel` package.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的命令列表更长，可以根据可用的`setuptools`扩展而变化。它被截断以仅显示对本章最重要和相关的命令。**标准** **命令**是`distutils`提供的内置命令，而**额外**
    **命令**是由第三方软件包创建的命令，例如`setuptools`或定义和注册新命令的任何其他软件包。另一个软件包注册的额外命令是由`wheel`软件包提供的`bdist_wheel`。
- en: setup.cfg
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: setup.cfg
- en: The `setup.cfg` file contains default options for commands of the `setup.py`
    script. This is very useful if the process for building and distributing the package
    is more complex and requires many optional arguments to be passed to the `setup.py`
    commands. This allows you to store such default parameters in code on a per-project
    basis. This will make your distribution flow independent from the project and
    also provide transparency about how your package was built and distributed to
    the users and other team members.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.cfg`文件包含`setup.py`脚本命令的默认选项。如果构建和分发软件包的过程更复杂，并且需要传递许多可选参数给`setup.py`命令，这将非常有用。这允许您在每个项目的代码中存储这些默认参数。这将使您的分发流程独立于项目，并且还可以提供关于如何构建和分发软件包给用户和其他团队成员的透明度。'
- en: 'The syntax for the `setup.cfg` file is the same as provided by the built-in
    `configparser` module so it is similar to the popular Microsoft Windows INI files.
    Here is an example of the setup configuration file that provides some `global`,
    `sdist`, and `bdist_wheel` command defaults:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.cfg`文件的语法与内置的`configparser`模块提供的语法相同，因此类似于流行的Microsoft Windows INI文件。以下是一个设置配置文件的示例，其中提供了一些`global`，`sdist`和`bdist_wheel`命令的默认值：'
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example configuration will ensure that source distributions will always
    be created with two formats (ZIP and TAR) and built wheel distributions will be
    created as universal wheels (Python version independent). Also, most of output
    will be suppressed on every command by the global `quiet` switch. Note that this
    is only for demonstration purposes and it may not be a reasonable choice to suppress
    the output for every command by default.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例配置将确保始终使用两种格式（ZIP和TAR）创建源分发，并且将创建通用轮（与Python版本无关）的构建轮分发。此外，通过全局`quiet`开关，每个命令的大部分输出都将被抑制。请注意，这仅用于演示目的，可能不是默认情况下抑制每个命令的输出的合理选择。
- en: MANIFEST.in
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MANIFEST.in
- en: 'When building a distribution with `sdist` command, `distutils` browses the
    package directory looking for files to include in the archive. `distutils` will
    include:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sdist`命令构建分发时，`distutils`浏览包目录，寻找要包含在存档中的文件。`distutils`将包括：
- en: All Python source files implied by the `py_modules`, `packages`, and `scripts`
    options
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由`py_modules`，`packages`和`scripts`选项隐含的所有Python源文件
- en: All C source files listed in the `ext_modules` option
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ext_modules`选项中列出的所有C源文件'
- en: 'Files that match the glob pattern `test/test*.py` are: `README`, `README.txt`,
    `setup.py`, and `setup.cfg`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与glob模式`test/test*.py`匹配的文件是：`README`，`README.txt`，`setup.py`和`setup.cfg`。
- en: Besides, if your package is under subversion or CVS, `sdist` will browse folders
    such as `.svn` to look for files to include. Integration with other version control
    systems is also possible through extensions. `sdist` builds a `MANIFEST` file
    that lists all files and includes them into the archive.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您的包处于子版本或CVS下，`sdist`将浏览文件夹，如`.svn`，以寻找要包含的文件。还可以通过扩展与其他版本控制系统集成。`sdist`构建一个列出所有文件并将它们包含到存档中的`MANIFEST`文件。
- en: Let's say you are not using these version control systems, and need to include
    more files. Now you can define a template called `MANIFEST.in` in the same directory
    as that of `setup.py` for the `MANIFEST` file, where you indicate to `sdist` which
    files to include.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您不使用这些版本控制系统，并且需要包含更多文件。现在，您可以在与`setup.py`相同的目录中定义一个名为`MANIFEST.in`的模板，用于`MANIFEST`文件，其中您指示`sdist`包含哪些文件。
- en: 'This template defines one inclusion or exclusion rule per line, for example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板每行定义一个包含或排除规则，例如：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The full list of the `MANIFEST.in` commands can be found in official `distutils`
    documentation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`MANIFEST.in`的完整命令列表可以在官方`distutils`文档中找到。'
- en: Most important metadata
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最重要的元数据
- en: 'Besides the name and the version of the package being distributed, the most
    important arguments `setup` can receive are:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了要分发的软件包的名称和版本外，`setup`可以接收的最重要的参数是：
- en: '`description`: This includes a few sentences to describe the package'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`: 这包括几句话来描述该包'
- en: '`long_description`: This includes a full description that can be in reStructuredText'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long_description`: 这包括一个可以使用reStructuredText的完整描述'
- en: '`keywords`: This is a list of keywords that define the package'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keywords`: 这是定义该包的关键字列表'
- en: '`author`: This is the author''s name or organization'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`author`: 这是作者的姓名或组织'
- en: '`author_email`: This is the contact e-mail address'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`author_email`: 这是联系电子邮件地址'
- en: '`url`: This is the URL of the project'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`: 这是项目的URL'
- en: '`license`: This is the license (GPL, LGPL, and so on)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`license`: 这是许可证（GPL，LGPL等）'
- en: '`packages`: This is a list of all names in the package; `setuptools` provides
    a small function called `find_packages` that calculates this'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`packages`: 这是包中所有名称的列表；`setuptools`提供了一个称为`find_packages`的小函数来计算这个列表'
- en: '`namespace_packages`: This is a list of namespaced packages'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namespace_packages`: 这是命名空间包的列表'
- en: Trove classifiers
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Trove classifiers
- en: 'PyPI and `distutils` provide a solution for categorizing applications with
    the set of classifiers called **trove classifiers**. All the classifiers form
    a tree-like structure. Each classifier is a form of string where every namespace
    is separated by the `::` substring. Their list is provided to the package definition
    as a `classifiers` argument to the `setup()` function. Here is an example list
    of classifiers for some project available on PyPI (here `solrq`):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: PyPI和`distutils`提供了一组分类应用程序的解决方案，称为**trove classifiers**。所有分类器形成一个类似树状的结构。每个分类器都是一种字符串形式，其中每个命名空间都由`::`子字符串分隔。它们的列表作为`classifiers`参数提供给`setup()`函数的包定义。以下是PyPI上某个项目（这里是`solrq`）的分类器示例列表：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: They are completely optional in the package definition but provide a useful
    extension to the basic metadata available in the `setup()` interface. Among others,
    trove classifiers may provide information about supported Python versions or systems,
    the development stage of the project, or the license under which the code is released.
    Many PyPI users search and browse the available packages by categories so a proper
    classification helps packages to reach their target.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在包定义中是完全可选的，但为`setup()`接口中可用的基本元数据提供了有用的扩展。除其他外，trove classifiers可能提供有关支持的Python版本或系统、项目的开发阶段或代码发布的许可证的信息。许多PyPI用户通过分类搜索和浏览可用的软件包，因此适当的分类有助于软件包达到其目标。
- en: Trove classifiers serve an important role in the whole packaging ecosystem and
    should never be ignored. There is no organization that verifies packages classification,
    so it is your responsibility to provide proper classifiers for your packages and
    not introduce chaos to the whole package index.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Trove classifiers在整个打包生态系统中起着重要作用，不应被忽视。没有组织验证软件包的分类，因此您有责任为您的软件包提供适当的分类器，并且不要给整个软件包索引引入混乱。
- en: 'At the time of writing this book, there are 608 classifiers available on PyPI
    that are grouped into nine major categories:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 撰写本书时，PyPI上有608个分类器，分为九个主要类别：
- en: Development status
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发状态
- en: Environment
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境
- en: Framework
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架
- en: Intended audience
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期受众
- en: License
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许可证
- en: Natural language
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自然语言
- en: Operating system
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统
- en: Programming language
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程语言
- en: Topic
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题
- en: New classifiers are added from time to time, so it is possible that these numbers
    will be different at the time you read it. The full list of currently available
    trove classifiers is available with the `setup.py register --list-classifiers`
    command.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 新的分类器会不时地被添加，因此在您阅读时这些数字可能会有所不同。当前可用的所有trove分类器的完整列表可通过`setup.py register --list-classifiers`命令获得。
- en: Common patterns
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见模式
- en: 'Creating a package for distribution can be a tedious task for inexperienced
    developers. Most of the metadata that `setuptools` or `distuitls` accept in their
    `setup()` function call can be provided manually, ignoring the fact that this
    may be available in other parts of the project:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分发而创建一个包对于经验不足的开发人员来说可能是一项繁琐的任务。`setuptools`或`distuitls`在它们的`setup()`函数调用中接受的大部分元数据可以手动提供，忽略了这些可能在项目的其他部分中可用的事实：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While this will definitely work, it is hard to maintain in the long term and
    leaves a place for future mistakes and inconsistencies. Both `setuptools` and
    `distutils` cannot automatically pick various metadata information from the project
    sources, so you need to provide them by yourself. There are some common patterns
    among the Python community for solving the most popular problems like dependency
    management, version/readme inclusion, and so on. It is worth knowing at least
    a few of them because they are so popular that they could be considered as packaging
    idioms.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这肯定会起作用，但在长期内很难维护，并且留下了未来错误和不一致的可能性。`setuptools`和`distutils`都无法自动从项目源中提取各种元数据信息，因此您需要自己提供它们。在Python社区中有一些常见的模式用于解决最常见的问题，如依赖管理、版本/自述文件的包含等。至少了解其中一些是值得的，因为它们如此受欢迎，以至于它们可以被视为包装习语。
- en: Automated inclusion of version string from package
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从包中自动包含版本字符串
- en: The **PEP 440 (Version Identification and Dependency Specification)** document
    specifies a standard for version and dependency specification. It is a long document
    that covers accepted version specification schemes and how version matching and
    comparison in Python packaging tools should work. If you are using or plan to
    use a complex project version numbering scheme, then reading this document is
    obligatory. If you are using a simple scheme that consists of one, two, three,
    or more numbers separated by dots, then you can let go the reading of PEP 440\.
    If you don't know how to choose the proper versioning scheme, I greatly recommend
    following semantic versioning that was already mentioned in [Chapter 1](ch01.html
    "Chapter 1. Current Status of Python"), *Current Status of Python*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**PEP 440（版本标识和依赖规范）**文档规定了版本和依赖规范的标准。这是一个长篇文档，涵盖了接受的版本规范方案以及Python包装工具中版本匹配和比较应该如何工作。如果您正在使用或计划使用复杂的项目版本编号方案，那么阅读这个文档是义不容辞的。如果您使用的是由点分隔的一个、两个、三个或更多数字组成的简单方案，那么您可以放弃阅读PEP
    440。如果您不知道如何选择适当的版本方案，我强烈建议遵循语义化版本控制，这已经在[第1章](ch01.html "第1章。Python的当前状态")中提到过了。'
- en: The other problem is where to include that version specifier for a package or
    module. There is PEP 396 (Module Version Numbers), which deals exactly with this
    problem. Note that it is only informational and has *deferred* status, so it is
    not a part of the standards track. Anyway, it describes what seems to be a *de
    facto* standard now. According to PEP 396, if a package or module has a version
    specified, it should be included as a `__version__` attribute of a package root
    (`__init__.py`) or module file. Another de facto standard is to also include the
    `VERSION` attribute that contains the tuple of version parts. This helps users
    to write compatibility code because such version tuples can be easily compared
    if the versioning scheme is simple enough.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是在包或模块中包含版本说明符的位置。有PEP 396（模块版本号），它正好处理这个问题。请注意，它只是信息性的，并且具有*延迟*状态，因此它不是标准跟踪的一部分。无论如何，它描述了现在似乎是*事实*标准。根据PEP
    396，如果包或模块有指定的版本，它应该被包含为包根（`__init__.py`）或模块文件的`__version__`属性。另一个*事实*标准是还包括包含版本部分的`VERSION`属性的元组。这有助于用户编写兼容性代码，因为如果版本方案足够简单，这样的版本元组可以很容易地进行比较。
- en: 'So many packages available on PyPI follow both standards. Their `__init__.py`
    files contain version attributes that look like the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: PyPI上有很多包都遵循这两个标准。它们的`__init__.py`文件包含如下所示的版本属性：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The other suggestion of deferred PEP 396 is that the version provided in the
    distutils'' `setup()` function should be derived from `__version__`, or vice versa.
    Python Packaging User Guide features multiple patterns for a single-sourcing project
    version and each of them has its own advantages and limitations. My personal favorite
    is rather long and is not included in the PyPA''s guide but has the advantage
    of limiting the complexity to `setup.py` script only. This boiler plate assumes
    that the version specifier is provided by the `VERSION` attribute of package''s
    `__init__` module and extracts this data for inclusion in the `setup()` call.
    Here is the excerpt from some imaginary package''s `setup.py` script that presents
    this approach:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟PEP 396的另一个建议是，distutils的`setup()`函数中提供的版本应该从`__version__`派生，或者反之亦然。Python包装用户指南提供了单一源项目版本的多种模式，每种模式都有其自己的优点和局限性。我个人比较喜欢的是比较长的模式，它没有包含在PyPA的指南中，但它的优点是将复杂性限制在`setup.py`脚本中。这个样板假设版本说明符由包的`__init__`模块的`VERSION`属性提供，并提取这些数据以包含在`setup()`调用中。以下是一些虚构包的`setup.py`脚本的摘录，展示了这种方法：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: README file
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自述文件
- en: Python Packaging Index can display a project's readme or the value of `long_description`
    on the package page in PyPI portal. You can write this description using reStructuredText
    ([http://docutils.sourceforge.net/rst.html](http://docutils.sourceforge.net/rst.html))
    markup, so it will be formatted to HTML on upload. Unfortunately, only reStructuredText
    is currently available as a documentation markup on PyPI. This is unlikely to
    change in the near future. More likely, additional markup languages will be supported
    when we see the `warehouse` project replacing completely current PyPI implementations.
    Unfortunately, the final release of `warehouse` is still unknown.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Python Packaging Index可以在PyPI门户网站的软件包页面上显示项目的readme或`long_description`的值。你可以使用reStructuredText
    ([http://docutils.sourceforge.net/rst.html](http://docutils.sourceforge.net/rst.html))标记编写这个描述，因此在上传时它将被格式化为HTML。不幸的是，目前只有reStructuredText作为PyPI上的文档标记可用。在不久的将来，这种情况不太可能改变。更有可能的是，当我们看到`warehouse`项目完全取代当前的PyPI实现时，将支持更多的标记语言。不幸的是，`warehouse`的最终发布日期仍然未知。
- en: Still, many developers want to use different markup languages for various reasons.
    The most popular choice is Markdown, which is the default markup language on GitHub—the
    place where most open source Python development currently happens. So, usually,
    GitHub and Markdown enthusiasts either ignore this problem or provide two independent
    documentation texts. Descriptions provided to PyPI are either short versions of
    what is available on the project's GitHub page or it is plain unformatted Markdown
    that does not present well on PyPI.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多开发人员出于各种原因希望使用不同的标记语言。最受欢迎的选择是Markdown，这是GitHub上默认的标记语言——大多数开源Python开发目前都在这里进行。因此，通常，GitHub和Markdown爱好者要么忽视这个问题，要么提供两个独立的文档文本。提供给PyPI的描述要么是项目GitHub页面上可用的简短版本，要么是在PyPI上呈现不佳的纯Markdown格式。
- en: 'If you want to use something different than reStructuredText markup language
    for your project''s README, you can still provide it as a project description
    on the PyPI page in a readable form. The trick lies in using the `pypandoc` package
    to translate your other markup language into reStructuredText while uploading
    the package to Python Package Index. It is important to do it with a fallback
    to plain content of your readme file, so the installation won''t fail if the user
    has no `pypandoc` installed:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为你的项目的README使用不同于reStructuredText标记语言的东西，你仍然可以以可读的形式在PyPI页面上提供它作为项目描述。诀窍在于使用`pypandoc`软件包将你的其他标记语言转换为reStructuredText，同时上传到Python
    Package Index时要有一个回退到你的readme文件的纯内容，这样如果用户没有安装`pypandoc`，安装就不会失败：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Managing dependencies
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 管理依赖
- en: 'Many projects require some external packages to be installed and/or used. When
    the list of dependencies is very long there comes a question as to how to manage
    it. The answer in most cases is very simple. Do not over-engineer the problem.
    Keep it simple and provide the list of dependencies explicitly in your `setup.py`
    script:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 许多项目需要安装和/或使用一些外部软件包。当依赖列表非常长时，就会出现如何管理的问题。在大多数情况下，答案非常简单。不要过度设计问题。保持简单，并在你的`setup.py`脚本中明确提供依赖列表：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Some Python developers like to use `requirements.txt` files for tracking lists
    of dependencies for their packages. In some situations, you might find a reason
    for doing that but in most cases this is a relic of times where the code of that
    project was not properly packaged. Anyway, even such notable projects as Celery
    still stick to this convention. So if you are not willing to change your habits
    or you are somehow forced to use requirement files, then at least do it properly.
    Here is one of the popular idioms for reading the list of dependencies from the
    `requirements.txt` file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Python开发人员喜欢使用`requirements.txt`文件来跟踪他们软件包的依赖列表。在某些情况下，你可能会找到理由这样做，但在大多数情况下，这是该项目代码未正确打包的遗留物。无论如何，即使像Celery这样的知名项目仍然坚持这种约定。因此，如果你不愿意改变你的习惯，或者你在某种程度上被迫使用要求文件，那么至少要做到正确。以下是从`requirements.txt`文件中读取依赖列表的一种流行习语：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The custom setup command
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义设置命令
- en: '`distutils` allows you to create new commands. A new command can be registered
    with an entry point, which was introduced by `setuptools` as a simple way to define
    packages as plug-ins.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`distutils`允许你创建新的命令。新的命令可以通过入口点进行注册，这是由`setuptools`引入的一种将软件包定义为插件的简单方法。'
- en: An entry point is a named link to a class or a function that is made available
    through some APIs in `setuptools`. Any application can scan for all registered
    packages and use the linked code as a plug-in.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 入口点是通过`setuptools`提供的一种通过一些API公开的类或函数的命名链接。任何应用程序都可以扫描所有已注册的软件包，并将链接的代码用作插件。
- en: 'To link the new command, the `entry_points` metadata can be used in the setup
    call:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要链接新的命令，可以在设置调用中使用`entry_points`元数据：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All named links are gathered in named sections. When `distutils` is loaded,
    it scans for links that were registered under `distutils.commands`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所有命名链接都被收集在命名部分中。当`distutils`被加载时，它会扫描在`distutils.commands`下注册的链接。
- en: This mechanism is used by numerous Python applications that provide extensibility.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制被许多提供可扩展性的Python应用程序使用。
- en: Working with packages during development
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开发过程中使用软件包
- en: Working with `setuptools` is mostly about building and distributing packages.
    However, you still need to know how to use them to install packages directly from
    project sources. And the reason for that is simple. It is good to test if your
    packaging code works properly before submitting a package to PyPI. And the simplest
    way to test it is by installing it. If you will send a broken package to the repository,
    then in order to re-upload it, you need to increase the version number.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`setuptools`主要是关于构建和分发软件包。然而，你仍然需要知道如何使用它们直接从项目源安装软件包。原因很简单。在提交软件包到PyPI之前，测试包装代码是否正常工作是很重要的。测试的最简单方法是安装它。如果你将一个有问题的软件包发送到存储库，那么为了重新上传它，你需要增加版本号。
- en: Testing if your code is packaged properly before the final distribution saves
    you from unnecessary version number inflation and obviously from wasted time.
    Also, installation directly from your own sources using `setuptools` may be essential
    when working on multiple related packages at the same time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终分发之前测试代码是否打包正确可以避免不必要的版本号膨胀，显然也可以节省时间。此外，在同时处理多个相关包时，直接从自己的源代码使用`setuptools`进行安装可能是必不可少的。
- en: setup.py install
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: setup.py install
- en: The `install` command installs the package into Python environment. It will
    try to build the package if no previous build was made and then inject the result
    into the Python tree. When a source distribution is provided, it can be uncompressed
    in a temporary folder and then installed with this command. The `install` command
    will also install dependencies that are defined in the `install_requires` metadata.
    This is done by looking at the packages in the Python Package Index.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`install`命令将包安装到Python环境中。如果之前没有进行构建，它将尝试构建包，然后将结果注入Python树中。当提供源分发时，可以将其解压缩到临时文件夹，然后使用此命令安装。`install`命令还将安装在`install_requires`元数据中定义的依赖项。这是通过查看Python包索引中的包来完成的。'
- en: 'An alternative to the bare `setup.py` script when installing a package is to
    use `pip`. Since it is a tool that is recommended by PyPA, you should use it even
    when installing a package in your local environment for development purposes.
    In order to install a package from local sources, run the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装包时，除了使用裸`setup.py`脚本之外，还可以使用`pip`。由于它是PyPA推荐的工具，即使在本地环境中安装包用于开发目的时，也应该使用它。为了从本地源安装包，请运行以下命令：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Uninstalling packages
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 卸载包
- en: 'Amazingly, `setuptools` and `distutils` lack the `uninstall` command. Fortunately,
    it is possible to uninstall any Python package using `pip`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，`setuptools`和`distutils`缺乏`uninstall`命令。幸运的是，可以使用`pip`卸载任何Python包：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Uninstalling can be a dangerous operation when attempted on system-wide packages.
    This is another reason why it is so important to use virtual environments for
    any development.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统范围的包上尝试卸载可能是一种危险的操作。这是为什么对于任何开发都使用虚拟环境如此重要的另一个原因。
- en: setup.py develop or pip -e
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: setup.py develop或pip -e
- en: Packages installed with `setup.py install` are copied to the site-packages directory
    of your current environment. This means whenever you make a change to the sources
    of that package, you are required to re-install it. This is often a problem during
    intensive development because it is very easy to forget about the need to perform
    installation again. This is why `setuptools` provides an extra `develop` command
    that allows us to install packages in **development mode**. This command creates
    a special link to project sources in the deployment directory (site-packages)
    instead of copying the whole package there. Package sources can be edited without
    need of re-installation and it is available in `sys.path` as it were installed
    normally.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`setup.py install`安装的包将被复制到当前环境的site-packages目录中。这意味着每当您对该包的源代码进行更改时，都需要重新安装它。这在密集开发过程中经常是一个问题，因为很容易忘记需要再次进行安装。这就是为什么`setuptools`提供了额外的`develop`命令，允许我们以**开发模式**安装包。此命令在部署目录（site-packages）中创建对项目源代码的特殊链接，而不是将整个包复制到那里。包源代码可以在不需要重新安装的情况下进行编辑，并且可以像正常安装一样在`sys.path`中使用。
- en: '`pip` also allows installing packages in such a mode. This installation option
    is called *editable mode* and can be enabled with the `-e` parameter in the `install`
    command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip`还允许以这种模式安装包。这种安装选项称为*可编辑模式*，可以在`install`命令中使用`-e`参数启用：'
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Namespace packages
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间包
- en: '*The Zen of Python*, which you can read by writing `import this` in the interpreter
    session, says the following about namespaces:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python之禅*，您可以通过在解释器会话中编写`import this`来阅读，关于命名空间说了以下内容：'
- en: '*Namespaces are one honking great idea—let''s do more of those!*'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*命名空间是一个了不起的想法——让我们做更多这样的事情！*'
- en: 'And this can be understood in at least two ways. The first is a namespace in
    the context of the language. We all use namespaces without even knowing:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以以至少两种方式理解。第一种是在语言环境中的命名空间。我们都在不知不觉中使用命名空间：
- en: The global namespace of a module
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的全局命名空间
- en: The local namespace of the function or method invocation
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数或方法调用的本地命名空间
- en: The built-in name's namespace
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置名称的命名空间
- en: The other kind of namespaces can be provided at packaging levels. These are
    **namespaced packages**. This is often an overlooked feature that can be very
    useful in structuring the package ecosystem in your organization or in a very
    large project.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种命名空间可以在打包级别提供。这些是**命名空间包**。这通常是一个被忽视的功能，可以在组织的包生态系统或非常庞大的项目中非常有用。
- en: Why is it useful?
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这有什么用呢？
- en: Namespace packages can be understood as a way of grouping related packages or
    modules higher than a meta-package level, where each of these packages can be
    installed independently.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间包可以被理解为一种在元包级别以上对相关包或模块进行分组的方式，其中每个包都可以独立安装。
- en: Namespace packages are especially useful if you have your application components
    developed, packaged, and versioned independently but you still want to access
    them from the same namespace. This helps to make clear to which organization or
    project every package belongs. For instance, for some imaginary Acme company,
    the common namespace could be `acme`. The result could lead to the creation of
    the general `acme` namespace package that will serve as a container for other
    packages from this organization. For example, if someone from Acme wants to contribute
    to this namespace with, for example, an SQL-related library, he can create a new
    `acme.sql` package that registers itself in `acme`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序组件是独立开发、打包和版本化的，但您仍希望从相同的命名空间访问它们，命名空间包尤其有用。这有助于明确每个包属于哪个组织或项目。例如，对于一些虚构的Acme公司，通用命名空间可以是`acme`。结果可能会导致创建一个通用的`acme`命名空间包，用于容纳该组织的其他包。例如，如果Acme的某人想要贡献一个与SQL相关的库，他可以创建一个新的`acme.sql`包，并将其注册到`acme`中。
- en: 'It is important to know the difference between normal and namespace packages
    and what problems they solve. Normally (without namespace packages), you would
    create a package `acme` with an `sql` subpackage/submodule with the following
    file structure:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要了解普通包和命名空间包之间的区别以及它们解决的问题。通常（没有命名空间包），您将创建一个带有以下文件结构的`acme`包和`sql`子包/子模块：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Whenever you want to add a new subpackage, let''s say `templating`, you are
    forced to include it in the source tree of `acme`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您想要添加一个新的子包，比如`templating`，您都被迫将其包含在`acme`的源树中：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Such an approach makes independent development of `acme.sql` and `acme.templating`
    almost impossible. The `setup.py` script will also have to specify all dependencies
    for every subpackage, so it is impossible (or at least very hard) to have an installation
    of just some of the `acme` components optionally. Also, it is an unresolvable
    issue if some of the subpackages have conflicting requirements.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使得独立开发`acme.sql`和`acme.templating`几乎不可能。`setup.py`脚本还必须为每个子包指定所有的依赖关系，因此不可能（或者至少非常困难）只安装一些`acme`组件。而且，如果一些子包有冲突的要求，这是一个无法解决的问题。
- en: 'With namespace packages, you can store the source tree for each of these subpackages
    independently:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名空间包，您可以独立存储每个子包的源树：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can also register them independently in PyPI or any package index you use.
    Users can choose which of the subpackages they want to install from the `acme`
    namespace but they never install the general `acme` package (it does not exist):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在PyPI或您使用的任何包索引中独立注册它们。用户可以选择从`acme`命名空间安装哪些子包，但他们永远不会安装通用的`acme`包（它不存在）：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that independent source trees are not enough to create namespace packages
    in Python. You need a bit of additional work if you don't want your packages to
    overwrite each other. Also, proper handling may be different depending on the
    Python language version you target. Details of that are described in the next
    two sections.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，独立的源树不足以在Python中创建命名空间包。如果您不希望您的包互相覆盖，您需要做一些额外的工作。此外，根据您的Python语言版本目标，正确的处理可能会有所不同。这方面的细节在接下来的两节中描述。
- en: PEP 420 – implicit namespace packages
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PEP 420 - 隐式命名空间包
- en: 'If you use and target only Python 3, then there is good news for you. **PEP
    420 (Implicit Namespace Packages)** introduced a new way to define namespace packages.
    It is a part of the standards track and became an official part of the language
    since the 3.3 version. In short, every directory that contains Python packages
    or modules (including namespace packages too) is considered a namespace package
    if it does not contain the `__init__.py` file. So, the following are examples
    of file structures presented in the previous section:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只使用和针对Python 3，那么对您来说有个好消息。**PEP 420（隐式命名空间包）**引入了一种新的定义命名空间包的方法。它是标准跟踪的一部分，并且自3.3版本以来成为语言的官方部分。简而言之，如果一个目录包含Python包或模块（包括命名空间包），并且不包含`__init__.py`文件，则被视为命名空间包。因此，以下是在上一节中介绍的文件结构示例：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'They are enough to define that `acme` is a namespace package in Python 3.3
    and later. Minimal `setup.py` scripts using setup tools will look like the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 它们足以定义`acme`是Python 3.3及更高版本中的命名空间包。使用设置工具的最小`setup.py`脚本将如下所示：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Unfortunately, `setuptools.find_packages()` does not support PEP 420 at the
    time of writing this book. Anyway, this may change in the future. Also, a requirement
    to explicitly define a list of packages seems to be a very small price for easy
    integration of namespace packages.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在撰写本书时，`setuptools.find_packages()`不支持PEP 420。无论如何，这在将来可能会改变。此外，明确定义包列表的要求似乎是易于集成命名空间包的一个非常小的代价。
- en: Namespace packages in previous Python versions
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在以前的Python版本中的命名空间包
- en: There is no way to make the namespaces packages in PEP 420 layout to work in
    Python versions older than 3.3\. Still, this concept is very old and commonly
    used in such mature projects like Zope, so it is definitely possible to use them
    but without implicit definition. In older versions of Python, there are several
    ways to define that the package should be treated as a namespace.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 420布局中的命名空间包在Python 3.3之前的版本中无法工作。然而，这个概念非常古老，在像Zope这样的成熟项目中经常被使用，因此肯定可以使用它们，但不能进行隐式定义。在Python的旧版本中，有几种方法可以定义包应该被视为命名空间。
- en: 'The simplest one is to create a file structure for each component that resembles
    an ordinary package layout without namespace packages and leave everything to
    `setuptools`. So, the example layout for `acme.sql` and `acme.templating` could
    be the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是为每个组件创建一个文件结构，类似于普通包布局而不是命名空间包，并将一切交给`setuptools`。因此，`acme.sql`和`acme.templating`的示例布局可能如下所示：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that for both `acme.sql` and `acme.templating`, there is an additional
    source file `acme/__init__.py`. This must be left empty. The `acme` namespace
    package will be created if we provide this name as a value of the `namespace_packages`
    keyword argument of the `setuptools.setup()` function:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于`acme.sql`和`acme.templating`，还有一个额外的源文件`acme/__init__.py`。这个文件必须保持空白。如果我们将这个名称作为`setuptools.setup()`函数的`namespace_packages`关键字参数的值提供，`acme`命名空间包将被创建：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Easiest does not mean best. `setuptools`, in order to register a new namespace,
    will call for the `pkg_resources.declare_namespace()` function in your `__init__.py`
    file. It will happen even if the `__init__.py` file is empty. Anyway, as the official
    documentation says, it is your own responsibility to declare namespaces in the
    `__init__.py` file, and this implicit behavior of `setuptools` may be dropped
    in the future. In order to be safe and "future-proof", you need to add the following
    line to the file `acme/__init__.py`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单并不意味着最好。为了注册一个新的命名空间，`setuptools`将在您的`__init__.py`文件中调用`pkg_resources.declare_namespace()`函数。即使`__init__.py`文件是空的，也会发生这种情况。无论如何，正如官方文档所说，声明命名空间在`__init__.py`文件中是您自己的责任，`setuptools`的这种隐式行为可能会在将来被取消。为了安全和"未来证明"，您需要在文件`acme/__init__.py`中添加以下行：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Uploading a package
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传软件包
- en: Packages will be useless without an organized way to store, upload, and download
    them. Python Packaging Index is the main source of open source packages in the
    Python community. Anyone can freely upload new packages and the only requirement
    is to register on the PyPI site—[https://pypi.python.org/pypi](https://pypi.python.org/pypi).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 没有组织的方式存储、上传和下载软件包将是无用的。Python软件包索引是Python社区中开源软件包的主要来源。任何人都可以自由上传新软件包，唯一的要求是在PyPI网站上注册-[https://pypi.python.org/pypi](https://pypi.python.org/pypi)。
- en: You are not limited, of course, to only this index and all packaging tools support
    the usage of alternative package repositories. This is especially useful for distributing
    closed source code among internal organizations or for deployment purposes. Details
    of such packaging usage with instructions on how to create your own package index
    will be explained in the next chapter. Here we focus only on open-source uploads
    to PyPI with only a little mention on how to specify alternative repositories.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您不仅限于这个索引，所有打包工具都支持使用替代软件包存储库。这对于在内部组织中分发闭源代码或用于部署目的尤其有用。如何使用这样的打包工具以及如何创建自己的软件包索引的说明将在下一章中解释。在这里，我们只关注向PyPI上传开源软件，只简要提及如何指定替代存储库。
- en: PyPI – Python Package Index
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyPI- Python软件包索引
- en: Python Package Index is, as already mentioned, the official source of open source
    package distributions. Downloading from it does not require any account or permission.
    The only thing you need is a package manager that can download new distributions
    from PyPI. Your preferred choice should be `pip`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Python软件包索引，如前所述，是开源软件包分发的官方来源。从中下载不需要任何帐户或权限。您唯一需要的是一个可以从PyPI下载新分发包的软件包管理器。您应该首选`pip`。
- en: Uploading to PyPI – or other package index
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上传到PyPI-或其他软件包索引
- en: Anyone can register and upload packages to PyPI provided that he or she has
    an account registered. Packages are bound to the user, so, by default, only the
    user that registered the name of the package is its admin and can upload new distributions.
    This could be a problem for bigger projects, so there is an option to design other
    users as package maintainers so that they are able to upload new distributions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人都可以注册并上传软件包到PyPI，只要他或她已经注册了帐户。软件包与用户绑定，因此，默认情况下，只有注册软件包名称的用户是其管理员，并且可以上传新的分发包。这可能对于更大的项目来说是一个问题，因此有一个选项可以将其他用户设计为软件包维护者，以便他们能够上传新的分发包。
- en: 'The easiest way to upload a package is to use the `upload` command of the `setup.py`
    script:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 上传软件包的最简单方法是使用`setup.py`脚本的`upload`命令：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, `<dist-commands>` is a list of commands that creates distribution to
    upload. Only distributions created during the same `setup.py` execution will be
    uploaded to the repository. So, if you would upload source distribution, built
    distribution, and wheel package at once, then you need to issue the following
    command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<dist-commands>`是一个创建要上传的分发包的命令列表。只有在同一次`setup.py`执行期间创建的分发包才会上传到存储库。因此，如果您要同时上传源分发包、构建分发包和wheel软件包，那么您需要发出以下命令：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When uploading using `setup.py`, you cannot reuse already built distributions
    and are forced to rebuild them on every upload. This might make some sense but
    can be inconvenient for large or complex projects in which creation of the distribution
    may actually take a considerable amount of time. Another problem of `setup.py
    upload` is that it can use plaintext HTTP or unverified HTTPS connection on some
    Python versions. This is why `twine` is recommended as a secure replacement for
    `setup.py upload`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`setup.py`上传时，您不能重复使用已构建的分发包，并且被迫在每次上传时重新构建它们。这可能有些合理，但对于大型或复杂的项目来说可能不方便，因为创建分发包可能需要相当长的时间。`setup.py
    upload`的另一个问题是，它可能在某些Python版本上使用明文HTTP或未经验证的HTTPS连接。这就是为什么建议使用`twine`作为`setup.py
    upload`的安全替代品。
- en: 'Twine is the utility for interacting with PyPI that currently serves only one
    purpose—securely uploading packages to the repository. It supports any packaging
    format and always ensures that the connection is secure. It also allows you to
    upload files that were already created, so you are able to test distributions
    before the release. An example usage of `twine` still requires invoking `setup.py`
    for building distributions:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Twine是与PyPI交互的实用程序，目前只提供一个功能-安全地上传软件包到存储库。它支持任何打包格式，并始终确保连接是安全的。它还允许您上传已经创建的文件，因此您可以在发布之前测试分发包。`twine`的一个示例用法仍然需要调用`setup.py`来构建分发包：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you have not yet registered this package, then the upload will fail because
    you need to register it first. This can also be done using `twine`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未注册此软件包，则上传将失败，因为您需要先注册它。这也可以使用`twine`来完成：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: .pypirc
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .pypirc
- en: '`.pypirc` is a configuration file that stores information about Python packages
    repositories. It should be located in your home directory. The format for this
    file is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`.pypirc`是一个存储有关Python软件包存储库信息的配置文件。它应该位于您的主目录中。该文件的格式如下：'
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `distutils` section should have the `index-servers` variable that lists
    all sections describing all the available repositories and credentials to them.
    There are only three variables that can be modified for each repository section:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`distutils`部分应该有`index-servers`变量，列出所有描述所有可用存储库和其凭据的部分。对于每个存储库部分，只有三个变量可以修改：'
- en: '`repository`: This is the URL of the package repository (it defaults to [https://www.python.org/pypi](https://www.python.org/pypi))'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`存储库`：这是软件包存储库的URL（默认为[https://www.python.org/pypi](https://www.python.org/pypi)）'
- en: '`username`: This is the username for authorization in the given repository'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`用户名`：这是在给定存储库中进行授权的用户名'
- en: '`password`: This is the user password for authorization in plaintext'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`密码`：这是用于授权的用户密码，以明文形式'
- en: Note that storing your repository password in plaintext may not be the wisest
    security choice. You can always leave it blank and you will be prompted for it
    whenever it is necessary.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以明文形式存储存储库密码可能不是明智的安全选择。您可以始终将其留空，并在必要时提示输入密码。
- en: The `.pypirc` file should be respected by every packaging tool built for Python.
    While this may not be true for every packaging-related utility out there, it is
    supported by the most important ones such as `pip`, `twine`, `distutils`, and
    `setuptools`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`.pypirc`文件应该受到为Python构建的每个打包工具的尊重。虽然这对于每个与打包相关的实用程序来说可能并不正确，但它得到了最重要的工具的支持，如`pip`、`twine`、`distutils`和`setuptools`。'
- en: Source packages versus built packages
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源包与构建包
- en: 'There are generally two types of distributions for Python packages:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Python软件包通常有两种类型的分发：
- en: Source distributions
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源分发
- en: Built (binary) distributions
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建（二进制）分发
- en: Source distributions are the simplest and most platform independent. For pure
    Python packages, it is a no-brainer. Such a distribution contains only Python
    sources and these should be already highly portable.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 源分发是最简单和最独立于平台的。对于纯Python软件包，这是毫无疑问的。这种分发只包含Python源代码，这些源代码应该已经非常易于移植。
- en: A more complex situation is when your package introduces some extensions written,
    for example, in C. Source distributions will still work provided that the package
    user has a proper development toolchain in his/her environment. This consists
    mostly of the compiler and proper C header files. For such cases, the built distribution
    format may be better suited because it may provide already built extensions for
    specific platforms.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的情况是，当您的软件包引入一些扩展时，例如用C编写的扩展。只要软件包用户在其环境中具有适当的开发工具链，源分发仍将起作用。这主要包括编译器和适当的C头文件。对于这种情况，构建的分发格式可能更适合，因为它可能已经为特定平台提供了构建好的扩展。
- en: sdist
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sdist
- en: The `sdist` command is the simplest command available. It creates a release
    tree where everything needed to run the package is copied. This tree is then archived
    in one or many archive files (often, it just creates one tarball). The archive
    is basically a copy of the source tree.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`sdist`命令是最简单的可用命令。它创建一个发布树，其中复制了运行软件包所需的一切。然后将此树存档在一个或多个存档文件中（通常只创建一个tarball）。存档基本上是源树的副本。'
- en: 'This command is the easiest way to distribute a package from the target system
    independently. It creates a `dist` folder with the archives in it that can be
    distributed. To be able to use it, an extra argument has to be passed to `setup`
    to provide a version number. If you don''t give it a `version` value, it will
    use `version = 0.0.0`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令是从目标系统独立地分发软件包的最简单方法。它创建一个包含存档的`dist`文件夹，可以进行分发。为了使用它，必须向`setup`传递一个额外的参数来提供版本号。如果不给它一个`version`值，它将使用`version
    = 0.0.0`：
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This number is useful to upgrade an installation. Every time a package is released,
    the number is raised so that the target system knows it has changed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字对于升级安装是有用的。每次发布软件包时，都会提高这个数字，以便目标系统知道它已经更改。
- en: 'Let''s run the `sdist` command with this extra argument:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个额外的参数运行`sdist`命令：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Under Windows, the archive will be a ZIP file.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows下，归档将是一个ZIP文件。
- en: The version is used to mark the name of the archive, which can be distributed
    and installed on any system that has Python. In the `sdist` distribution, if the
    package contains C libraries or extensions, the target system is responsible for
    compiling them. This is very common for Linux-based systems or Mac OS because
    they commonly provide a compiler, but it is less usual to have it under Windows.
    That's why a package should always be distributed with a prebuilt distribution
    as well, when it is intended to run under several platforms.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 版本用于标记存档的名称，可以在任何安装了Python的系统上分发和安装。在`sdist`分发中，如果软件包包含C库或扩展，目标系统负责编译它们。这在基于Linux的系统或Mac
    OS中非常常见，因为它们通常提供编译器，但在Windows下很少见。这就是为什么当软件包打算在多个平台上运行时，应该始终使用预构建的分发进行分发。
- en: bdist and wheels
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: bdist和wheels
- en: 'To be able to distribute a prebuilt distribution, `distutils` provides the
    `build` command, which compiles the package in four steps:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够分发预构建的分发，`distutils`提供了`build`命令，它在四个步骤中编译软件包：
- en: '`build_py`: This builds pure Python modules by byte-compiling them and copying
    them into the build folder.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build_py`：这将通过对其进行字节编译并将其复制到构建文件夹中来构建纯Python模块。'
- en: '`build_clib`: This builds C libraries, when the package contains any, using
    C compiler and creating a static library in the build folder.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build_clib`：当软件包包含任何C库时，使用C编译器构建C库并在构建文件夹中创建一个静态库。'
- en: '`build_ext`: This builds C extensions and puts the result in the build folder
    like `build_clib`.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build_ext`：这将构建C扩展并将结果放在构建文件夹中，如`build_clib`。'
- en: '`build_scripts`: This builds the modules that are marked as scripts. It also
    changes the interpreter path when the first line was set (`!#`) and fixes the
    file mode so that it is executable.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build_scripts`：这将构建标记为脚本的模块。当第一行被设置为（`!#`）时，它还会更改解释器路径，并修复文件模式，使其可执行。'
- en: Each of these steps is a command that can be called independently. The result
    of the compilation process is a build folder that contains everything needed for
    the package to be installed. There's no cross-compiler option yet in the `distutils`
    package. This means that the result of the command is always specific to the system
    it was built on.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤中的每一步都是可以独立调用的命令。编译过程的结果是一个包含了安装软件包所需的一切的构建文件夹。`distutils`包中还没有交叉编译器选项。这意味着命令的结果始终特定于它所构建的系统。
- en: When some C extensions have to be created, the build process uses the system
    compiler and the Python header file (`Python.h`). This **include** file is available
    from the time Python was built from the sources. For a packaged distribution,
    an extra package for your system distribution is probably required. At least in
    popular Linux distributions, it is often named `python-dev`. It contains all the
    necessary header files for building Python extensions.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要创建一些C扩展时，构建过程使用系统编译器和Python头文件（`Python.h`）。这个**include**文件是从Python构建源代码时就可用的。对于打包的发行版，可能需要额外的系统发行版包。至少在流行的Linux发行版中，通常被命名为`python-dev`。它包含了构建Python扩展所需的所有必要的头文件。
- en: The C compiler used is the system compiler. For a Linux-based system or Mac
    OS X, this would be **gcc** or **clang** respectively. For Windows, Microsoft
    Visual C++ can be used (there's a free command-line version available) and the
    open-source project MinGW can be used as well. This can be configured in `distutils`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的C编译器是系统编译器。对于基于Linux的系统或Mac OS X，分别是**gcc**或**clang**。对于Windows，可以使用Microsoft
    Visual C++（有免费的命令行版本可用），也可以使用开源项目MinGW。这可以在`distutils`中配置。
- en: The `build` command is used by the `bdist` command to build a binary distribution.
    It calls `build` and all the dependent commands, and then creates an archive in
    the same way as `sdist` does.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`build`命令由`bdist`命令用于构建二进制分发。它调用`build`和所有依赖的命令，然后以与`sdist`相同的方式创建存档。'
- en: 'Let''s create a binary distribution for `acme.sql` under Mac OS X:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Mac OS X下为`acme.sql`创建一个二进制发行版：
- en: '[PRE31]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that the newly created archive's name contains the name of the system
    and the distribution it was built under (*Mac OS X 10.3*).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，新创建的存档名称包含了系统名称和它构建的发行版名称（*Mac OS X 10.3*）。
- en: 'The same command called under Windows will create a specific distribution archive:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows下调用相同的命令将创建一个特定的分发存档：
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If a package contains C code, apart from a source distribution, it's important
    to release as many different binary distributions as possible. At the very least,
    a Windows binary distribution is important for those who don't have a C compiler
    installed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果软件包包含C代码，除了源分发外，释放尽可能多的不同二进制分发是很重要的。至少，对于那些没有安装C编译器的人来说，Windows二进制分发是很重要的。
- en: A binary release contains a tree that can be copied directly into the Python
    tree. It mainly contains a folder that is copied into Python's `site-packages`
    folder. It may also contain cached bytecode files (`*.pyc` files on Python 2 and
    `__pycache__/*.pyc` on Python 3).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制发行版包含一个可以直接复制到Python树中的树。它主要包含一个文件夹，该文件夹被复制到Python的`site-packages`文件夹中。它还可能包含缓存的字节码文件（在Python
    2上为`*.pyc`文件，在Python 3上为`__pycache__/*.pyc`）。
- en: 'The other kind of built distributions are "wheels" provided by the `wheel`
    package. When installed (for example, using `pip`), `wheel` adds a new `bdist_wheel`
    command to the `distutils`. It allows creating platform-specific distributions
    (currently only for Windows and Mac OS X) that provides alternatives to normal
    `bdist` distributions. It was designed to replace another distribution introduced
    earlier by `setuptools`—eggs. Eggs are now obsolete so won''t be featured here.
    The list of advantages of using wheels is quite long. Here are the ones that are
    mentioned in the Python Wheels page ([http://pythonwheels.com/](http://pythonwheels.com/)):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种构建分发是由`wheel`包提供的“wheels”。当安装（例如，使用`pip`）时，`wheel`会向`distutils`添加一个新的`bdist_wheel`命令。它允许创建特定于平台的分发（目前仅适用于Windows和Mac
    OS X），为普通的`bdist`分发提供了替代方案。它旨在取代`setuptools`早期引入的另一种分发——eggs。Eggs现在已经过时，因此不会在这里介绍。使用wheels的优势列表非常长。以下是Python
    Wheels页面（[http://pythonwheels.com/](http://pythonwheels.com/)）中提到的优势：
- en: Faster installation for pure python and native C extension packages
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯Python和本地C扩展包的更快安装
- en: Avoids arbitrary code execution for installation. (Avoids `setup.py`)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免安装时的任意代码执行。（避免`setup.py`）
- en: Installation of a C extension does not require a compiler on Windows or OS X
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows或OS X上安装C扩展不需要编译器
- en: Allows better caching for testing and continuous integration
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许更好的缓存用于测试和持续集成
- en: Creates `.pyc` files as part of the installation to ensure they match the Python
    interpreter used
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`.pyc`文件作为安装的一部分，以确保它们与使用的Python解释器匹配
- en: More consistent installs across platforms and machines
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨平台和机器上的安装更一致
- en: According to PyPA recommendation, wheels should be your default distribution
    format. Unfortunately, platform-specific wheels for Linux are not available yet
    so if you have to distribute packages with C extensions, then you need to create
    `sdist` distribution for Linux users.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 根据PyPA的建议，wheels应该是您的默认分发格式。不幸的是，Linux的特定平台wheels目前还不可用，因此如果您必须分发带有C扩展的软件包，那么您需要为Linux用户创建`sdist`分发。
- en: Standalone executables
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立可执行文件
- en: Creating standalone executables is a commonly overlooked topic in materials
    that cover packaging of Python code. This is mainly because Python lacks proper
    tools in its standard library that could allow programmers to create simple executables
    that could be run by users without the need to install the Python interpreter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 创建独立的可执行文件是Python代码打包材料中常常被忽视的一个话题。这主要是因为Python在其标准库中缺乏适当的工具，允许程序员创建简单的可执行文件，用户可以在不需要安装Python解释器的情况下运行。
- en: Compiled languages have a big advantage over Python in that they allow creation
    of an executable application for the given system architecture that could be run
    by users in a way that does not require them to have any knowledge of the underlying
    technology. Python code, when distributed as a package, requires the Python interpreter
    in order to be run. This creates a big inconvenience for users who do not have
    enough technical proficiency.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 编译语言在一个重要方面比Python具有优势，那就是它们允许为给定的系统架构创建可执行应用程序，用户可以以一种不需要了解底层技术的方式运行。Python代码在作为包分发时需要Python解释器才能运行。这给没有足够技术能力的用户带来了很大的不便。
- en: 'Developer-friendly operating systems such as Mac OS X or most Linux distributions
    come with Python pre-installed. So, for their users, the Python-based application
    still could be distributed as a source package that relies on specific **interpreter
    directive** in the main script file, which is popularly called **shebang**. For
    most Python applications, this takes the following form:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员友好的操作系统，比如Mac OS X或大多数Linux发行版，都预装了Python。因此，对于他们的用户，基于Python的应用程序仍然可以作为依赖于主脚本文件中特定**解释器指令**的源代码包进行分发，这通常被称为**shebang**。对于大多数Python应用程序，这采用以下形式：
- en: '[PRE33]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Such directive, when used as a first line of script, will mark it to be interpreted
    by default by the Python version for the given environment. This can, of course,
    take a more detailed form, which requires a specific Python version such as `python3.4`,
    `python3`, or `python2`. Note that this will work in most popular POSIX systems,
    but isn't portable at all by definition. This solution relies on the existence
    of specific Python versions and also availability of `env` executable exactly
    at `/usr/bin/env`. Both of these assumptions may fail on some operating systems.
    Also, shebangs will not work on Windows at all. Additionally, bootstrapping of
    the Python environment on Windows can be a challenge even for experienced developers,
    so you cannot expect that nontechnical users will be able to do that by themselves.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的指令，当作为脚本的第一行使用时，将默认标记为由给定环境的Python版本解释。当然，这可以更详细地表达，需要特定的Python版本，比如`python3.4`、`python3`或`python2`。请注意，这将在大多数流行的POSIX系统中工作，但根据定义，这在任何情况下都不具备可移植性。这个解决方案依赖于特定的Python版本的存在，以及`env`可执行文件确切地位于`/usr/bin/env`。这些假设都可能在某些操作系统上失败。另外，shebang
    在Windows上根本不起作用。此外，即使对于经验丰富的开发人员，在Windows上启动Python环境也可能是一个挑战，因此你不能指望非技术用户能够自己做到这一点。
- en: The other thing to consider is the simple user experience in the desktop environment.
    Users usually expect that applications can be run from the desktop by simply clicking
    on them. Not every desktop environment will support that with Python applications
    distributed as a source.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件要考虑的事情是在桌面环境中的简单用户体验。用户通常希望可以通过简单点击桌面上的应用程序来运行它们。并非每个桌面环境都支持将Python应用程序作为源代码分发后以这种方式运行。
- en: Therefore, it would be best if we are able to create a binary distribution that
    would work as any other compiled executable. Fortunately, it is possible to create
    an executable that has both the Python interpreter and our project embedded. This
    allows users to open our application without caring about Python or any other
    dependency.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好能够创建一个二进制分发，它可以像任何其他编译的可执行文件一样工作。幸运的是，可以创建一个既包含Python解释器又包含我们项目的可执行文件。这允许用户打开我们的应用程序，而不必关心Python或任何其他依赖项。
- en: When are standalone executables useful?
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立的可执行文件何时有用？
- en: Standalone executables are useful in situations where simplicity of user experience
    is more important than the user's ability to interfere with applications' code.
    Note that the fact that you are distributing application as executable only makes
    code reading or modification harder—not impossible. It is not a way to secure
    applications code and should only be used as a way to make interacting with an
    application simpler.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 独立的可执行文件在用户体验的简单性比用户能够干预应用程序代码更重要的情况下是有用的。请注意，仅仅将应用程序作为可执行文件分发只会使代码阅读或修改变得更加困难，而不是不可能。这不是保护应用程序代码的方法，应该只用作使与应用程序交互的方式更简单的方法。
- en: Standalone executables should be a preferred way of distributing applications
    for nontechnical end users and also seems to be the only reasonable way of distributing
    a Python application for Windows.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 独立的可执行文件应该是为非技术终端用户分发应用程序的首选方式，似乎也是为Windows分发Python应用程序的唯一合理方式。
- en: 'Standalone executables are usually a good choice for:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 独立的可执行文件通常是一个不错的选择：
- en: Applications that depend on specific Python versions that may not be easily
    available on the target operating systems
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于目标操作系统上可能不容易获得的特定Python版本的应用程序
- en: Applications that rely on modified precompiled CPython sources
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于修改后的预编译的CPython源代码的应用程序
- en: Applications with graphical interfaces
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有图形界面的应用程序
- en: Projects that have many binary extensions written in different languages
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有许多用不同语言编写的二进制扩展的项目
- en: Games
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏
- en: Popular tools
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流行的工具
- en: 'Python does not have any built-in support for building standalone executables.
    Fortunately, there are some community projects solving that problem with varied
    success. The four most notable are:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有任何内置支持来构建独立的可执行文件。幸运的是，有一些社区项目在解决这个问题，取得了不同程度的成功。最值得注意的四个是：
- en: PyInstaller
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyInstaller
- en: cx_Freeze
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cx_Freeze
- en: py2exe
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: py2exe
- en: py2app
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: py2app
- en: Each one of them is slightly different in use and also each one of them has
    slightly different limitations. Before choosing your tool, you need to decide
    which platform you want to target, because every packaging tool can support only
    a specific set of operating systems.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 它们每一个在使用上都略有不同，而且每一个都有略微不同的限制。在选择工具之前，您需要决定要针对哪个平台，因为每个打包工具只能支持特定的操作系统集。
- en: The best case scenario is if you make such a decision at the very beginning
    of the project's life. None of these tools, of course, require deep interaction
    in your code, but if you start building standalone packages early, you can automate
    the whole process and save future integration time and costs. If you leave this
    for later, you may find yourself in a situation where the project is built in
    such a sophisticated way that none of the available tools will work. Providing
    a standalone executable for such a project will be problematic and will take a
    lot of your time.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的情况是在项目的早期阶段就做出这样的决定。当然，这些工具都不需要在您的代码中进行深入的交互，但是如果您早期开始构建独立的软件包，您可以自动化整个过程，并节省未来的集成时间和成本。如果您把这个留到以后，您可能会发现项目构建得非常复杂，以至于没有任何可用的工具可以使用。为这样的项目提供一个独立的可执行文件将是困难的，并且会花费大量的时间。
- en: PyInstaller
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PyInstaller
- en: 'PyInstaller ([http://www.pyinstaller.org/](http://www.pyinstaller.org/)) is
    by far the most advanced program to freeze Python packages into standalone executables.
    It provides the most extensive multiplatform compatibility among every available
    solution at the moment, so it is the most recommended one. Platforms that PyInstaller
    supports are:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: PyInstaller（[http://www.pyinstaller.org/](http://www.pyinstaller.org/)）是目前将Python软件包冻结为独立可执行文件的最先进的程序。它在目前所有可用的解决方案中提供了最广泛的多平台兼容性，因此是最推荐的。PyInstaller支持的平台有：
- en: Windows (32-bit and 64-bit)
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows（32位和64位）
- en: Linux (32-bit and 64-bit)
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux（32位和64位）
- en: Mac OS X (32-bit and 64-bit)
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mac OS X（32位和64位）
- en: FreeBSD, Solaris, and AIX
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeBSD、Solaris和AIX
- en: Supported versions of Python are Python 2.7 and Python 3.3, 3.4, and 3.5\. It
    is available on PyPI, so it can be installed in your working environment using
    `pip`. If you have problems installing it this way, you can always download the
    installer from the project's page.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的Python版本是Python 2.7和Python 3.3、3.4和3.5。它可以在PyPI上找到，因此可以使用`pip`在您的工作环境中安装它。如果您在安装时遇到问题，您可以随时从项目页面下载安装程序。
- en: Unfortunately, cross-platform building (cross-compilation) is not supported
    so if you want to build your standalone executable for a specific platform, then
    you need to perform building on that platform. This is not a big trouble today
    with the advent of many virtualization tools. If you don't have a specific system
    installed on your computer, you can always use Vagrant that will provide you with
    the desired operating system as a virtual machine.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，不支持跨平台构建（交叉编译），因此如果您想为特定平台构建独立的可执行文件，那么您需要在该平台上执行构建。随着许多虚拟化工具的出现，这在今天并不是一个大问题。如果您的计算机上没有安装特定的系统，您可以随时使用Vagrant，它将为您提供所需的操作系统作为虚拟机。
- en: 'Usage for simple applications is easy. Let''s assume our application is contained
    in the script named `myscript.py`. This is a simple "Hello world!" application.
    We want to create a standalone executable for Windows users and we had our sources
    located under `D://dev/app` in the filesystem. Our application can be bundled
    with the following short command:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 简单应用程序的使用很容易。假设我们的应用程序包含在名为`myscript.py`的脚本中。这是一个简单的“Hello world！”应用程序。我们想为Windows用户创建一个独立的可执行文件，并且我们的源代码位于文件系统中的`D://dev/app`下。我们的应用程序可以使用以下简短的命令进行打包：
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'PyInstaller''s standard output is quite long even for simple applications,
    so it was truncated in the preceding example for the sake of brevity. If run on
    Windows, the resulting structure of directories and files will be as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: PyInstaller的标准输出即使对于简单的应用程序也非常长，因此为了简洁起见，在前面的示例中进行了截断。如果在Windows上运行，目录和文件的结果结构将如下所示：
- en: '[PRE35]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `dist/myscript` directory contains the built application that can now be
    distributed to the users. Note that the whole directory must be distributed. It
    contains all additional files that are required to run our application (DLLs,
    compiled extension libraries, and so on). A more compact distribution can be obtained
    with the `--onefile` switch of the `pyinstaller` command:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`dist/myscript`目录包含了可以分发给用户的构建应用程序。请注意，整个目录必须被分发。它包含了运行我们的应用程序所需的所有附加文件（DLL、编译的扩展库等）。可以使用`pyinstaller`命令的`--onefile`开关获得更紧凑的分发：'
- en: '[PRE36]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When built with the `--onefile` option, the only file you need to distribute
    to other users is the single executable found in the `dist` directory (here, `myscript.exe`).
    For small applications, this is probably the preferred option.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--onefile`选项构建时，您需要分发给其他用户的唯一文件是`dist`目录中找到的单个可执行文件（这里是`myscript.exe`）。对于小型应用程序，这可能是首选选项。
- en: 'One of the side effects of running the `pyinstaller` command is the creation
    of the `*.spec` file. This is an autogenerated Python module containing specification
    on how to create executables from your sources. For example, we already used this
    in the following code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`pyinstaller`命令的一个副作用是创建`*.spec`文件。这是一个自动生成的Python模块，包含了如何从您的源代码创建可执行文件的规范。例如，我们已经在以下代码中使用了这个：
- en: '[PRE37]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This `.spec` file contains all `pyinstaller` arguments specified earlier. This
    is very useful if you have performed a lot of customizations to your build because
    this can be used instead of building scripts that would have to store your configuration.
    Once created, you can use it as an argument to the `pyinstaller` command instead
    of your Python script:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`.spec`文件包含了之前指定的所有`pyinstaller`参数。如果您对构建进行了大量的自定义，这将非常有用，因为这可以代替必须存储您的配置的构建脚本。创建后，您可以将其用作`pyinstaller`命令的参数，而不是您的Python脚本：
- en: '[PRE38]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that this is a real Python module, so you can extend it and perform more
    complex customizations to the building procedure using a language that you already
    know. Customizing the `.spec` file is especially useful when you are targeting
    many different platforms. Also, not all of the `pyinstaller` options are available
    through the command-line arguments and can be used only when modifying `.spec`
    file.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是一个真正的Python模块，因此您可以使用自己已经了解的语言对其进行扩展并对构建过程进行更复杂的自定义。当您针对许多不同的平台时，自定义`.spec`文件尤其有用。此外，并非所有的`pyinstaller`选项都可以通过命令行参数使用，只有在修改`.spec`文件时才能使用。
- en: PyInstaller is an extensive tool, which by its usage is very simple for the
    great majority of programs. Anyway, the thorough reading of its documentation
    is recommended if you are interested in using it as a tool to distribute your
    applications.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: PyInstaller是一个功能强大的工具，使用起来对于大多数程序来说非常简单。无论如何，如果您有兴趣将其作为分发应用程序的工具，建议仔细阅读其文档。
- en: cx_Freeze
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: cx_Freeze
- en: 'cx_Freeze ([http://cx-freeze.sourceforge.net/](http://cx-freeze.sourceforge.net/))
    is another tool for creating standalone executables. It is a simpler solution
    than PyInstaller, but also supports the three major platforms:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Freeze ([http://cx-freeze.sourceforge.net/](http://cx-freeze.sourceforge.net/))是另一个用于创建独立可执行文件的工具。它比PyInstaller更简单，但也支持三个主要平台：
- en: Windows
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows
- en: Linux
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux
- en: Mac OS X
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mac OS X
- en: 'Same as PyInstaller, it does not allow us to perform cross-platform builds,
    so you need to create your executables on the same operating system you are distributing
    to. The major disadvantage of cx_Freeze is that it does not allow us to create
    real single-file executables. Applications built with it need to be distributed
    with related DLL files and libraries. Assuming that we have the same application
    as featured in the *PyInstaller* section, the example usage is very simple as
    well:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 与PyInstaller一样，它不允许我们执行跨平台构建，因此您需要在分发到的相同操作系统上创建您的可执行文件。cx_Freeze的主要缺点是它不允许我们创建真正的单文件可执行文件。使用它构建的应用程序需要与相关的DLL文件和库一起分发。假设我们有与*PyInstaller*部分中的相同应用程序，那么示例用法也非常简单：
- en: '[PRE39]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Resulting structure of files is as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文件结构如下：
- en: '[PRE40]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Instead of providing the own format for build specification (like PyInstaller
    does), cx_Freeze extends the `distutils` package. This means you can configure
    how your standalone executable is built with the familiar `setup.py` script. This
    makes cx_Freeze very convenient if you already distribute your package using `setuptools`
    or `distutils` because additional integration requires only small changes to your
    `setup.py` script. Here is an example of such a `setup.py` script using `cx_Freeze.setup()`
    for creating standalone executables on Windows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Freeze不是提供自己的构建规范格式（就像PyInstaller一样），而是扩展了`distutils`包。这意味着您可以使用熟悉的`setup.py`脚本配置独立可执行文件的构建方式。如果您已经使用`setuptools`或`distutils`来分发软件包，那么cx_Freeze非常方便，因为额外的集成只需要对`setup.py`脚本进行小的更改。以下是一个使用`cx_Freeze.setup()`创建Windows独立可执行文件的`setup.py`脚本示例：
- en: '[PRE41]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'With such a file, the new executable can be created using the new `build_exe`
    command added to the `setup.py` script:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样一个文件，可以使用添加到`setup.py`脚本的新`build_exe`命令来创建新的可执行文件：
- en: '[PRE42]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The usage of cx_Freeze seems a bit easier than PyInstaller''s and `distutils`
    integration is a very useful feature. Unfortunately this project may cause some
    troubles for inexperienced developers:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Freeze的使用似乎比PyInstaller和`distutils`集成更容易一些，这是一个非常有用的功能。不幸的是，这个项目可能会给经验不足的开发人员带来一些麻烦：
- en: Installation using `pip` may be problematic under Windows
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows下使用`pip`进行安装可能会有问题
- en: The official documentation is very brief and lacking in some places
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方文档非常简短，某些地方缺乏说明
- en: py2exe and py2app
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: py2exe和py2app
- en: 'py2exe ([http://www.py2exe.org/](http://www.py2exe.org/)) and py2app ([https://pythonhosted.org/py2app/](https://pythonhosted.org/py2app/))
    are two other programs that integrate with Python packaging either via `distutils`
    or `setuptools` in order to create standalone executables. Here they are mentioned
    together because they are very similar in both usage and their limitations. The
    major drawback of py2exe and py2app is that they target only a single platform:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: py2exe ([http://www.py2exe.org/](http://www.py2exe.org/))和py2app ([https://pythonhosted.org/py2app/](https://pythonhosted.org/py2app/))是另外两个集成到Python打包中的程序，可以通过`distutils`或`setuptools`创建独立可执行文件。它们被一起提到，因为它们在使用和限制方面非常相似。py2exe和py2app的主要缺点是它们只针对单个平台：
- en: py2exe allows building Windows executables
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: py2exe允许构建Windows可执行文件
- en: py2app allows building Mac OS X apps
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: py2app允许构建Mac OS X应用程序
- en: 'Because the usage is very similar and requires only modification of the `setup.py`
    script, these packages seem to complement each other. The documentation of py2app
    projects the following example of the `setup.py` script that allows to build standalone
    executables with the right tool (either py2exe or py2app), depending on the platform
    used:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用方法非常相似，只需要修改`setup.py`脚本，这些软件包似乎互补。py2app项目的官方文档提供了以下`setup.py`脚本示例，可以根据所使用的平台使用正确的工具（py2exe或py2app）构建独立可执行文件：
- en: '[PRE43]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With such a script, you can build your Windows executable using the `python
    setup.py py2exe` command and Mac OS X app using `python setup.py py2app`. Cross
    compilation is of course not possible.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的脚本，您可以使用`python setup.py py2exe`命令构建Windows可执行文件，并使用`python setup.py py2app`构建Mac
    OS X应用程序。当然，跨编译是不可能的。
- en: Despite some limitations and less elasticity than PyInstaller or cx_Freeze,
    it is good to know that there are always py2exe and py2app projects. In some cases,
    PyInstaller or cx_Freeze might fail to build executable for the project properly.
    In such situations, it is always worth checking whether other solutions can handle
    our code.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管cx_Freeze的一些限制和弹性不如PyInstaller或cx_Freeze，但了解总是有py2exe和py2app项目。在某些情况下，PyInstaller或cx_Freeze可能无法正确地构建项目的可执行文件。在这种情况下，值得检查其他解决方案是否能够处理我们的代码。
- en: Security of Python code in executable packages
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可执行软件包中Python代码的安全性
- en: It is important to know that standalone executables does not make application
    code secure by any means. It is not an easy task to decompile the embedded code
    from such executable files, but it is doable for sure. What is even more important
    is that the results of such de-compilation (if done with proper tools) might look
    strikingly similar to original sources.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，独立可执行文件并不以任何方式使应用程序代码安全。从这种可执行文件中反编译嵌入的代码并不是一件容易的任务，但肯定是可行的。更重要的是，这种反编译的结果（如果使用适当的工具进行）可能看起来与原始源代码非常相似。
- en: This fact makes standalone Python executables not a viable solution for closed
    source projects where leaking of the application code could harm the organization.
    So, if your whole business can be copied simply by copying the source code of
    your application, then you should think of other ways to distribute the application.
    Maybe providing software as a service will be a better choice for you.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事实使得独立的Python可执行文件对于泄漏应用程序代码可能会损害组织的闭源项目来说并不是一个可行的解决方案。因此，如果你的整个业务可以通过简单地复制应用程序的源代码来复制，那么你应该考虑其他分发应用程序的方式。也许提供软件作为服务对你来说会是更好的选择。
- en: Making decompilation harder
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使反编译变得更加困难
- en: 'As already said, there is no reliable way to secure applications from de-compilation
    with the tools available at the moment. Still, there are some ways to make this
    process harder. But harder does not mean less probable. For some of us, the most
    tempting challenges are the hardest ones. And we all know that the eventual prize
    in this challenge is very high: the code that you tried to secure.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 正如已经说过的，目前没有可靠的方法可以防止应用程序被反编译。但是，有一些方法可以使这个过程变得更加困难。但更困难并不意味着不太可能。对于我们中的一些人来说，最具诱惑力的挑战是最困难的挑战。我们都知道，这个挑战的最终奖励是非常高的：您试图保护的代码。
- en: 'Usually the process of de-compilation consists of a few steps:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，反编译的过程包括几个步骤：
- en: Extracting the project's binary representation of bytecode from standalone executables.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从独立可执行文件中提取项目的字节码的二进制表示。
- en: Mapping of a binary representation to bytecode of a specific Python version.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将二进制表示映射到特定Python版本的字节码。
- en: Translation of bytecode to AST.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字节码转换为AST。
- en: Recreation of sources directly from AST.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接从AST重新创建源代码。
- en: 'Providing the exact solutions for deterring developers from such reverse-engineering
    of standalone executables would be pointless for obvious reasons. So here are
    only some ideas for hampering of the de-compilation process or devaluating its
    results:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 提供确切的解决方案来阻止开发人员对独立可执行文件进行逆向工程将是毫无意义的，因为这是显而易见的原因。因此，这里只提供了一些阻碍反编译过程或贬值其结果的想法：
- en: Removing any code metadata available at runtime (docstrings), so the eventual
    results will be a bit less readable
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除运行时可用的任何代码元数据（文档字符串），因此最终结果会变得不太可读
- en: Modifying the bytecode values used by the CPython interpreter so that conversion
    from binary to bytecode and later to AST requires more effort
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改CPython解释器使用的字节码值，以便从二进制转换为字节码，然后再转换为AST需要更多的工作
- en: Using a version of CPython sources modified in such a complex way that even
    if decompiled sources of the application are available they are useless without
    decompiling the modified CPython binary
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用经过复杂修改的CPython源代码版本，即使可用应用程序的反编译源代码也无法在没有反编译修改后的CPython二进制文件的情况下使用
- en: Using obfuscation scripts on sources before bundling them into executables,
    which will make sources less valuable after the de-compilation
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将源代码捆绑成可执行文件之前，使用混淆脚本对源代码进行混淆，这样在反编译后源代码的价值就会降低
- en: Such solutions make the development process a lot harder. Some of the above
    ideas require a very deep understanding of Python runtime but each one of them
    is riddled with many pitfalls and disadvantages. Mostly, they only defer what
    is inevitable. Once your trick is broken, it renders all your additional efforts
    a waste of time and resources.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解决方案使开发过程变得更加困难。上述一些想法需要对Python运行时有很深的理解，但它们每一个都充满了许多陷阱和缺点。大多数情况下，它们只是推迟了不可避免的结果。一旦你的技巧被破解，所有额外的努力都将成为时间和资源的浪费。
- en: The only reliable way to not allow your closed code leak outside of your application
    is to not ship it directly to users in any form. And this is only true if other
    aspects of your organization's security stay airtight.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许您的闭源代码以任何形式直接发货给用户是唯一可靠的方法。只有在您组织的其他方面保持严密的安全性时，这才是真实的。
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter described details of Python's packaging ecosystem. Now, after reading
    it, you should know which tools suit your packaging needs and also which types
    of distributions your project requires. You should also know the popular techniques
    for common problems and how to provide useful metadata to your project.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了Python的打包生态系统的细节。现在，在阅读完本章之后，您应该知道哪些工具适合您的打包需求，以及您的项目需要哪些类型的分发。您还应该知道常见问题的流行技术以及如何为您的项目提供有用的元数据。
- en: We also discussed the topic of standalone executables that are very useful,
    especially in distributing desktop applications.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了独立可执行文件的话题，这些文件非常有用，特别是在分发桌面应用程序时。
- en: Next chapter will extensively rely on what we have learned here to show how
    to efficiently deal with code deployments in a reliable and automated way.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将广泛依赖我们在这里学到的知识，展示如何以可靠和自动化的方式有效处理代码部署。
