- en: Chapter 10. Python Design Patterns I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。Python设计模式I
- en: 'In the last chapter, we were briefly introduced to design patterns, and covered
    the iterator pattern, a pattern so useful and common that it has been abstracted
    into the core of the programming language itself. In this chapter, we''ll be reviewing
    other common patterns, and how they are implemented in Python. As with iteration,
    Python often provides an alternative syntax to make working with such problems
    simpler. We will cover both the "traditional" design, and the Python version for
    these patterns. In summary, we''ll see:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了设计模式，并介绍了迭代器模式，这是一个非常有用和常见的模式，已经被抽象成编程语言核心的一部分。在本章中，我们将回顾其他常见的模式，以及它们在Python中的实现。与迭代一样，Python通常提供替代语法，以使处理此类问题更简单。我们将介绍这些模式的“传统”设计和Python版本。总之，我们将看到：
- en: Numerous specific patterns
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多特定的模式
- en: A canonical implementation of each pattern in Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中每种模式的典型实现
- en: Python syntax to replace certain patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python语法以替换某些模式
- en: The decorator pattern
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: The decorator pattern allows us to "wrap" an object that provides core functionality
    with other objects that alter this functionality. Any object that uses the decorated
    object will interact with it in exactly the same way as if it were undecorated
    (that is, the interface of the decorated object is identical to that of the core
    object).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式允许我们用其他对象包装提供核心功能的对象，从而改变这个功能。使用装饰对象的任何对象将与未装饰的对象完全相同地交互（即，装饰对象的接口与核心对象的接口相同）。
- en: 'There are two primary uses of the decorator pattern:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式有两个主要用途：
- en: Enhancing the response of a component as it sends data to a second component
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强组件发送数据到第二个组件的响应
- en: Supporting multiple optional behaviors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多个可选行为
- en: 'The second option is often a suitable alternative to multiple inheritance.
    We can construct a core object, and then create a decorator around that core.
    Since the decorator object has the same interface as the core object, we can even
    wrap the new object in other decorators. Here''s how it looks in UML:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项通常是多重继承的一个合适替代方案。我们可以构建一个核心对象，然后在该核心周围创建一个装饰器。由于装饰器对象具有与核心对象相同的接口，因此我们甚至可以将新对象包装在其他装饰器中。在UML中的样子如下：
- en: '![The decorator pattern](images/8781OS_10_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![装饰器模式](images/8781OS_10_01.jpg)'
- en: Here, **Core** and all the decorators implement a specific **Interface**. The
    decorators maintain a reference to another instance of that **Interface** via
    composition. When called, the decorator does some added processing before or after
    calling its wrapped interface. The wrapped object may be another decorator, or
    the core functionality. While multiple decorators may wrap each other, the object
    in the "center" of all those decorators provides the core functionality.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**Core**和所有装饰器都实现了特定的**接口**。装饰器通过组合维护对**接口**的另一个实例的引用。在调用时，装饰器在调用其包装的接口之前或之后进行一些附加处理。包装对象可以是另一个装饰器，也可以是核心功能。虽然多个装饰器可以相互包装，但是所有这些装饰器中的对象提供了核心功能。
- en: A decorator example
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器示例
- en: 'Let''s look at an example from network programming. We''ll be using a TCP socket.
    The `socket.send()` method takes a string of input bytes and outputs them to the
    receiving socket at the other end. There are plenty of libraries that accept sockets
    and access this function to send data on the stream. Let''s create such an object;
    it will be an interactive shell that waits for a connection from a client and
    then prompts the user for a string response:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个网络编程的例子。我们将使用TCP套接字。`socket.send()`方法接受输入字节的字符串，并将其输出到另一端的接收套接字。有很多库接受套接字并访问此函数以在流上发送数据。让我们创建这样一个对象；它将是一个交互式shell，等待客户端的连接，然后提示用户输入一个字符串响应：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `respond` function accepts a socket parameter and prompts for data to be
    sent as a reply, then sends it. To use it, we construct a server socket and tell
    it to listen on port `2401` (I picked the port randomly) on the local computer.
    When a client connects, it calls the `respond` function, which requests data interactively
    and responds appropriately. The important thing to notice is that the `respond`
    function only cares about two methods of the socket interface: `send` and `close`.
    To test this, we can write a very simple client that connects to the same port
    and outputs the response before exiting:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`respond`函数接受一个套接字参数，并提示发送回复的数据，然后发送它。要使用它，我们构造一个服务器套接字，并告诉它在本地计算机上的端口`2401`上进行监听（我随机选择了端口）。当客户端连接时，它调用`respond`函数，该函数交互地请求数据并做出适当的响应。要注意的重要事情是，`respond`函数只关心套接字接口的两种方法：`send`和`close`。为了测试这一点，我们可以编写一个非常简单的客户端，连接到相同的端口并在退出之前输出响应：'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To use these programs:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些程序：
- en: Start the server in one terminal.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个终端中启动服务器。
- en: Open a second terminal window and run the client.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开第二个终端窗口并运行客户端。
- en: At the **Enter a value:** prompt in the server window, type a value and press
    enter.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器窗口的**输入值：**提示中，输入一个值并按回车键。
- en: The client will receive what you typed, print it to the console, and exit. Run
    the client a second time; the server will prompt for a second value.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端将接收您输入的内容，将其打印到控制台并退出。再次运行客户端；服务器将提示输入第二个值。
- en: Now, looking again at our server code, we see two sections. The `respond` function
    sends data into a socket object. The remaining script is responsible for creating
    that socket object. We'll create a pair of decorators that customize the socket
    behavior without having to extend or modify the socket itself.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次查看我们的服务器代码，我们看到两个部分。`respond`函数将数据发送到套接字对象中。剩下的脚本负责创建该套接字对象。我们将创建一对装饰器，定制套接字行为，而无需扩展或修改套接字本身。
- en: 'Let''s start with a "logging" decorator. This object outputs any data being
    sent to the server''s console before it sends it to the client:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个“日志记录”装饰器开始。在将数据发送到客户端之前，该对象会将发送到服务器控制台的任何数据输出：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This class decorates a socket object and presents the `send` and `close` interface
    to client sockets. A better decorator would also implement (and possibly customize)
    all of the remaining socket methods. It should properly implement all of the arguments
    to `send`, (which actually accepts an optional flags argument) as well, but let's
    keep our example simple! Whenever `send` is called on this object, it logs the
    output to the screen before sending data to the client using the original socket.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类装饰了一个套接字对象，并向客户端套接字提供`send`和`close`接口。一个更好的装饰器还应该实现（并可能自定义）所有剩余的套接字方法。它还应该正确实现`send`的所有参数（实际上接受一个可选的标志参数），但让我们保持我们的例子简单！每当在这个对象上调用`send`时，它都会在将数据发送到客户端之前将输出记录到屏幕上，使用原始套接字。
- en: 'We only have to change one line in our original code to use this decorator.
    Instead of calling `respond` with the socket, we call it with a decorated socket:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要改变原始代码中的一行，就可以使用这个装饰器。我们不再用套接字调用`respond`，而是用一个装饰过的套接字调用它：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While that's quite simple, we have to ask ourselves why we didn't just extend
    the socket class and override the `send` method. We could call `super().send`
    to do the actual sending, after we logged it. There is nothing wrong with this
    design either.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很简单，但我们必须问自己为什么我们不直接扩展套接字类并覆盖`send`方法。我们可以调用`super().send`在记录后执行实际发送。这种设计也没有问题。
- en: 'When faced with a choice between decorators and inheritance, we should only
    use decorators if we need to modify the object dynamically, according to some
    condition. For example, we may only want to enable the logging decorator if the
    server is currently in debugging mode. Decorators also beat multiple inheritance
    when we have more than one optional behavior. As an example, we can write a second
    decorator that compresses data using `gzip` compression whenever `send` is called:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当面临装饰器和继承之间的选择时，只有在我们需要根据某些条件动态修改对象时，才应该使用装饰器。例如，我们可能只想在服务器当前处于调试模式时启用日志装饰器。当我们有多个可选行为时，装饰器也比多重继承更胜一筹。例如，我们可以编写第二个装饰器，每当调用`send`时，它都使用`gzip`压缩数据：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `send` method in this version compresses the incoming data before sending
    it on to the client.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本中的`send`方法在发送到客户端之前压缩传入的数据。
- en: 'Now that we have these two decorators, we can write code that dynamically switches
    between them when responding. This example is not complete, but it illustrates
    the logic we might follow to mix and match decorators:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这两个装饰器，我们可以编写代码，在响应时动态地在它们之间切换。这个例子并不完整，但它说明了我们可能遵循的混合装饰器的逻辑：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code checks a hypothetical configuration variable named `log_send`. If
    it's enabled, it wraps the socket in a `LoggingSocket` decorator. Similarly, it
    checks whether the client that has connected is in a list of addresses known to
    accept compressed content. If so, it wraps the client in a `GzipSocket` decorator.
    Notice that none, either, or both of the decorators may be enabled, depending
    on the configuration and connecting client. Try writing this using multiple inheritance
    and see how confused you get!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查了一个名为`log_send`的假设配置变量。如果启用了它，它会将套接字包装在`LoggingSocket`装饰器中。类似地，它检查连接的客户端是否在已知接受压缩内容的地址列表中。如果是，它会将客户端包装在`GzipSocket`装饰器中。请注意，这两个装饰器中的任何一个、两个或都可能被启用，取决于配置和连接的客户端。尝试使用多重继承来编写这个，并看看你会有多困惑！
- en: Decorators in Python
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中的装饰器
- en: The decorator pattern is useful in Python, but there are other options. For
    example, we may be able to use monkey-patching, which we discussed in [Chapter
    7](ch07.html "Chapter 7. Python Object-oriented Shortcuts"), *Python Object-oriented
    Shortcuts*, to get a similar effect. Single inheritance, where the "optional"
    calculations are done in one large method can be an option, and multiple inheritance
    should not be written off just because it's not suitable for the specific example
    seen previously!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式在Python中很有用，但也有其他选择。例如，我们可能能够使用我们在[第7章](ch07.html "第7章。Python面向对象的快捷方式")中讨论过的猴子补丁来获得类似的效果。单继承，其中“可选”计算是在一个大方法中完成的，也是一个选择，多重继承不应该被写入，只是因为它对先前看到的特定示例不合适！
- en: In Python, it is very common to use this pattern on functions. As we saw in
    a previous chapter, functions are objects too. In fact, function decoration is
    so common that Python provides a special syntax to make it easy to apply such
    decorators to functions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，对函数使用这种模式是非常常见的。正如我们在之前的章节中看到的，函数也是对象。事实上，函数装饰是如此常见，以至于Python提供了一种特殊的语法，使得很容易将这样的装饰器应用到函数上。
- en: 'For example, we can look at the logging example in a more general way. Instead
    of logging, only send calls on sockets, we may find it helpful to log all calls
    to certain functions or methods. The following example implements a decorator
    that does just this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以更一般地看待日志示例。我们可能会发现，与其仅在套接字上发送调用，不如记录对某些函数或方法的所有调用会更有帮助。以下示例实现了一个刚好做到这一点的装饰器：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This decorator function is very similar to the example we explored earlier;
    in those cases, the decorator took a socket-like object and created a socket-like
    object. This time, our decorator takes a function object and returns a new function
    object. This code is comprised of three separate tasks:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器函数与我们之前探讨的示例非常相似；在那些情况下，装饰器接受一个类似套接字的对象，并创建一个类似套接字的对象。这一次，我们的装饰器接受一个函数对象，并返回一个新的函数对象。这段代码由三个独立的任务组成：
- en: A function, `log_calls`, that accepts another function
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`log_calls`的函数，接受另一个函数
- en: This function defines (internally) a new function, named `wrapper`, that does
    some extra work before calling the original function
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数定义了（内部）一个名为`wrapper`的新函数，在调用原始函数之前做一些额外的工作
- en: This new function is returned
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个新函数被返回
- en: Three sample functions demonstrate the decorator in use. The third one includes
    a sleep call to demonstrate the timing test. We pass each function into the decorator,
    which returns a new function. We assign this new function to the original variable
    name, effectively replacing the original function with a decorated one.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 三个示例函数演示了装饰器的使用。第三个示例包括一个睡眠调用来演示定时测试。我们将每个函数传递给装饰器，装饰器返回一个新函数。我们将这个新函数赋给原始变量名，有效地用装饰后的函数替换了原始函数。
- en: This syntax allows us to build up decorated function objects dynamically, just
    as we did with the socket example; if we don't replace the name, we can even keep
    decorated and non-decorated versions for different situations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法允许我们动态地构建装饰函数对象，就像我们在套接字示例中所做的那样；如果我们不替换名称，甚至可以为不同情况保留装饰和非装饰版本。
- en: Often these decorators are general modifications that are applied permanently
    to different functions. In this situation, Python supports a special syntax to
    apply the decorator at the time the function is defined. We've already seen this
    syntax when we discussed the `property` decorator; now, let's understand how it
    works.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这些装饰器是应用于不同函数的永久性通用修改。在这种情况下，Python支持一种特殊的语法，在函数定义时应用装饰器。当我们讨论`property`装饰器时，我们已经看到了这种语法；现在，让我们了解一下它是如何工作的。
- en: 'Instead of applying the decorator function after the method definition, we
    can use the `@decorator` syntax to do it all at once:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`@decorator`语法一次完成所有操作，而不是在方法定义之后应用装饰器函数：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The primary benefit of this syntax is that we can easily see that the function
    has been decorated at the time it is defined. If the decorator is applied later,
    someone reading the code may miss that the function has been altered at all. Answering
    a question like, "Why is my program logging function calls to the console?" can
    become much more difficult! However, the syntax can only be applied to functions
    we define, since we don't have access to the source code of other modules. If
    we need to decorate functions that are part of somebody else's third-party library,
    we have to use the earlier syntax.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法的主要好处是我们可以很容易地看到函数在定义时已经被装饰。如果装饰器是后来应用的，阅读代码的人可能会错过函数已经被修改的事实。回答类似“为什么我的程序将函数调用记录到控制台？”这样的问题可能会变得更加困难！然而，这种语法只能应用于我们定义的函数，因为我们无法访问其他模块的源代码。如果我们需要装饰第三方库中的函数，我们必须使用之前的语法。
- en: There is more to the decorator syntax than we've seen here. We don't have room
    to cover the advanced topics here, so check the Python reference manual or other
    tutorials for more information. Decorators can be created as callable objects,
    not just functions that return functions. Classes can also be decorated; in that
    case, the decorator returns a new class instead of a new function. Finally, decorators
    can take arguments to customize them on a per-function basis.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器语法比我们在这里看到的要复杂得多。我们没有空间在这里涵盖高级主题，所以请查看Python参考手册或其他教程获取更多信息。装饰器可以被创建为可调用对象，而不仅仅是返回函数的函数。类也可以被装饰；在这种情况下，装饰器返回一个新类，而不是一个新函数。最后，装饰器可以接受参数，以便根据每个函数的情况进行自定义。
- en: The observer pattern
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The observer pattern is useful for state monitoring and event handling situations.
    This pattern allows a given object to be monitored by an unknown and dynamic group
    of "observer" objects.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式对于状态监控和事件处理情况非常有用。这种模式允许一个给定的对象被一个未知和动态的“观察者”对象组监视。
- en: Whenever a value on the core object changes, it lets all the observer objects
    know that a change has occurred, by calling an `update()` method. Each observer
    may be responsible for different tasks whenever the core object changes; the core
    object doesn't know or care what those tasks are, and the observers don't typically
    know or care what other observers are doing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每当核心对象上的值发生变化时，它都会通过调用`update()`方法来通知所有观察者对象发生了变化。每个观察者在核心对象发生变化时可能负责不同的任务；核心对象不知道或不关心这些任务是什么，观察者通常也不知道或不关心其他观察者在做什么。
- en: 'Here, it is in UML:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是UML：
- en: '![The observer pattern](images/8781OS_10_02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![观察者模式](images/8781OS_10_02.jpg)'
- en: An observer example
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个观察者示例
- en: 'The observer pattern might be useful in a redundant backup system. We can write
    a core object that maintains certain values, and then have one or more observers
    create serialized copies of that object. These copies might be stored in a database,
    on a remote host, or in a local file, for example. Let''s implement the core object
    using properties:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式可能在冗余备份系统中很有用。我们可以编写一个维护特定值的核心对象，然后让一个或多个观察者创建该对象的序列化副本。这些副本可以存储在数据库中，远程主机上，或者本地文件中。让我们使用属性来实现核心对象：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This object has two properties that, when set, call the `_update_observers`
    method on itself. All this method does is loop over the available observers and
    let each one know that something has changed. In this case, we call the observer
    object directly; the object will have to implement `__call__` to process the update.
    This would not be possible in many object-oriented programming languages, but
    it's a useful shortcut in Python that can help make our code more readable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象有两个属性，当设置时，会在自身上调用`_update_observers`方法。这个方法只是循环遍历可用的观察者，并让每个观察者知道发生了一些变化。在这种情况下，我们直接调用观察者对象；对象将必须实现`__call__`来处理更新。在许多面向对象的编程语言中，这是不可能的，但在Python中这是一个有用的快捷方式，可以帮助我们的代码更易读。
- en: 'Now let''s implement a simple observer object; this one will just print out
    some state to the console:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现一个简单的观察者对象；这个对象只会将一些状态打印到控制台上：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There''s nothing terribly exciting here; the observed object is set up in the
    initializer, and when the observer is called, we do "something." We can test the
    observer in an interactive console:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别激动人心的；观察对象在初始化程序中设置，当观察者被调用时，我们会“做一些事情”。我们可以在交互式控制台中测试观察者：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After attaching the observer to the inventory object, whenever we change one
    of the two observed properties, the observer is called and its action is invoked.
    We can even add two different observer instances:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将观察者附加到库存对象后，每当我们更改两个观察属性中的一个时，观察者都会被调用并调用其动作。我们甚至可以添加两个不同的观察者实例：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This time when we change the product, there are two sets of output, one for
    each observer. The key idea here is that we can easily add totally different types
    of observers that back up the data in a file, database, or Internet application
    at the same time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这次当我们更改产品时，有两组输出，每个观察者一个。这里的关键思想是我们可以轻松地添加完全不同类型的观察者，同时备份数据到文件、数据库或Internet应用程序。
- en: The observer pattern detaches the code being observed from the code doing the
    observing. If we were not using this pattern, we would have had to put code in
    each of the properties to handle the different cases that might come up; logging
    to the console, updating a database or file, and so on. The code for each of these
    tasks would all be mixed in with the observed object. Maintaining it would be
    a nightmare, and adding new monitoring functionality at a later date would be
    painful.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式将被观察的代码与观察的代码分离。如果我们不使用这种模式，我们将不得不在每个属性中放置代码来处理可能出现的不同情况；记录到控制台，更新数据库或文件等。所有这些任务的代码都将混在观察对象中。维护它将是一场噩梦，并且在以后的日期添加新的监视功能将是痛苦的。
- en: The strategy pattern
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式
- en: The strategy pattern is a common demonstration of abstraction in object-oriented
    programming. The pattern implements different solutions to a single problem, each
    in a different object. The client code can then choose the most appropriate implementation
    dynamically at runtime.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式是面向对象编程中抽象的常见演示。该模式在不同对象中实现了单个问题的不同解决方案。客户端代码可以在运行时动态选择最合适的实现。
- en: 'Typically, different algorithms have different trade-offs; one might be faster
    than another, but uses a lot more memory, while a third algorithm may be most
    suitable when multiple CPUs are present or a distributed system is provided. Here
    is the strategy pattern in UML:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，不同的算法有不同的权衡；一个可能比另一个更快，但使用的内存更多，而第三个算法可能在多个CPU存在或提供分布式系统时最合适。这是UML中的策略模式：
- en: '![The strategy pattern](images/8781OS_10_03.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![策略模式](images/8781OS_10_03.jpg)'
- en: The **User** code connecting to the strategy pattern simply needs to know that
    it is dealing with the **Abstraction** interface. The actual implementation chosen
    performs the same task, but in different ways; either way, the interface is identical.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到策略模式的**用户**代码只需要知道它正在处理**抽象**接口。所选择的实际实现以不同的方式执行相同的任务；无论如何，接口都是相同的。
- en: A strategy example
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略示例
- en: The canonical example of the strategy pattern is sort routines; over the years,
    numerous algorithms have been invented for sorting a collection of objects; quick
    sort, merge sort, and heap sort are all fast sort algorithms with different features,
    each useful in its own right, depending on the size and type of inputs, how out
    of order they are, and the requirements of the system.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式的典型示例是排序例程；多年来，已经发明了许多用于对对象集合进行排序的算法；快速排序、合并排序和堆排序都是具有不同特性的快速排序算法，每种算法在不同情况下都有用，具体取决于输入的大小和类型，它们的顺序有多乱，以及系统的要求。
- en: 'If we have client code that needs to sort a collection, we could pass it to
    an object with a `sort()` method. This object may be a `QuickSorter` or `MergeSorter`
    object, but the result will be the same in either case: a sorted list. The strategy
    used to do the sorting is abstracted from the calling code, making it modular
    and replaceable.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有需要对集合进行排序的客户端代码，我们可以将其传递给具有`sort()`方法的对象。该对象可以是`QuickSorter`或`MergeSorter`对象，但无论哪种情况，结果都将是相同的：排序后的列表。用于排序的策略从调用代码中抽象出来，使其模块化和可替换。
- en: Of course, in Python, we typically just call the `sorted` function or `list.sort`
    method and trust that it will do the sorting in a near-optimal fashion. So, we
    really need to look at a better example.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在Python中，我们通常只调用`sorted`函数或`list.sort`方法，并相信它会以接近最佳的方式进行排序。因此，我们确实需要看一个更好的例子。
- en: Let's consider a desktop wallpaper manager. When an image is displayed on a
    desktop background, it can be adjusted to the screen size in different ways. For
    example, assuming the image is smaller than the screen, it can be tiled across
    the screen, centered on it, or scaled to fit. There are other, more complicated,
    strategies that can be used as well, such as scaling to the maximum height or
    width, combining it with a solid, semi-transparent, or gradient background color,
    or other manipulations. While we may want to add these strategies later, let's
    start with the basic ones.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个桌面壁纸管理器。当图像显示在桌面背景上时，可以以不同的方式调整到屏幕大小。例如，假设图像小于屏幕，则可以在屏幕上平铺，居中显示，或者缩放以适应。还有其他更复杂的策略可以使用，例如缩放到最大高度或宽度，与纯色、半透明或渐变背景颜色结合，或其他操作。虽然我们可能希望稍后添加这些策略，但让我们从基本策略开始。
- en: 'Our strategy objects takes two inputs; the image to be displayed, and a tuple
    of the width and height of the screen. They each return a new image the size of
    the screen, with the image manipulated to fit according to the given strategy.
    You''ll need to install the `pillow` module with `pip3 install pillow` for this
    example to work:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的策略对象需要两个输入；要显示的图像和屏幕宽度和高度的元组。它们各自返回一个新的图像，大小与屏幕相同，并根据给定的策略进行调整。您需要使用`pip3
    install pillow`安装`pillow`模块，以使此示例工作。
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we have three strategies, each using `PIL` to perform their task. Individual
    strategies have a `make_background` method that accepts the same set of parameters.
    Once selected, the appropriate strategy can be called to create a correctly sized
    version of the desktop image. `TiledStrategy` loops over the number of input images
    that would fit in the width and height of the image and copies it into each location,
    repeatedly. `CenteredStrategy` figures out how much space needs to be left on
    the four edges of the image to center it. `ScaledStrategy` forces the image to
    the output size (ignoring aspect ratio).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有三种策略，每种策略都使用`PIL`来执行它们的任务。各个策略都有一个`make_background`方法，接受相同的参数集。一旦选择了适当的策略，就可以调用它来创建一个正确大小的桌面图像版本。`TiledStrategy`循环遍历可以适应图像宽度和高度的输入图像数量，并将其重复复制到每个位置。`CenteredStrategy`计算出需要在图像的四个边缘留下多少空间来使其居中。`ScaledStrategy`强制图像到输出大小（忽略纵横比）。
- en: Consider how switching between these options would be implemented without the
    strategy pattern. We'd need to put all the code inside one great big method and
    use an awkward `if` statement to select the expected one. Every time we wanted
    to add a new strategy, we'd have to make the method even more ungainly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑如果没有策略模式，如何在这些选项之间进行切换。我们需要把所有的代码放在一个很大的方法中，并使用一个笨拙的`if`语句来选择预期的选项。每次我们想要添加一个新的策略，我们都需要使方法变得更加笨拙。
- en: Strategy in Python
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中的策略
- en: The preceding canonical implementation of the strategy pattern, while very common
    in most object-oriented libraries, is rarely seen in Python programming.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式的前面的经典实现，在大多数面向对象的库中非常常见，但在Python编程中很少见。
- en: These classes each represent objects that do nothing but provide a single function.
    We could just as easily call that function `__call__` and make the object callable
    directly. Since there is no other data associated with the object, we need do
    no more than create a set of top-level functions and pass them around as our strategies
    instead.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类分别代表什么都不做，只提供一个函数的对象。我们可以轻松地称这个函数为`__call__`，并直接使对象可调用。由于没有与对象关联的其他数据，我们只需要创建一组顶级函数，并将它们作为我们的策略传递。
- en: Opponents of design pattern philosophy will therefore say, "because Python has
    first-class functions, the strategy pattern is unnecessary". In truth, Python's
    first-class functions allow us to implement the strategy pattern in a more straightforward
    way. Knowing the pattern exists can still help us choose a correct design for
    our program, but implement it using a more readable syntax. The strategy pattern,
    or a top-level function implementation of it, should be used when we need to allow
    client code or the end user to select from multiple implementations of the same
    interface.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，设计模式哲学的反对者会说，“因为Python有一流函数，策略模式是不必要的”。事实上，Python的一流函数允许我们以更直接的方式实现策略模式。知道模式存在仍然可以帮助我们选择程序的正确设计，但使用更可读的语法来实现它。策略模式，或者它的顶级函数实现，应该在我们需要允许客户端代码或最终用户从同一接口的多个实现中进行选择时使用。
- en: The state pattern
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态模式
- en: 'The state pattern is structurally similar to the strategy pattern, but its
    intent and purpose are very different. The goal of the state pattern is to represent
    state-transition systems: systems where it is obvious that an object can be in
    a specific state, and that certain activities may drive it to a different state.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式在结构上类似于策略模式，但其意图和目的是非常不同的。状态模式的目标是表示状态转换系统：在这些系统中，一个对象可以处于特定状态，某些活动可能会驱使它转移到不同的状态。
- en: To make this work, we need a manager, or context class that provides an interface
    for switching states. Internally, this class contains a pointer to the current
    state; each state knows what other states it is allowed to be in and will transition
    to those states depending on actions invoked upon it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个工作起来，我们需要一个管理者，或者提供切换状态接口的上下文类。在内部，这个类包含一个指向当前状态的指针；每个状态都知道它被允许处于哪些其他状态，并且会根据在其上调用的动作来过渡到这些状态。
- en: 'So we have two types of classes, the context class and multiple state classes.
    The context class maintains the current state, and forwards actions to the state
    classes. The state classes are typically hidden from any other objects that are
    calling the context; it acts like a black box that happens to perform state management
    internally. Here''s how it looks in UML:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有两种类型的类，上下文类和多个状态类。上下文类维护当前状态，并将动作转发给状态类。状态类通常对于调用上下文的任何其他对象都是隐藏的；它就像一个黑匣子，偶然会在内部执行状态管理。在UML中它是这样的。
- en: '![The state pattern](images/8781OS_10_04.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![状态模式](images/8781OS_10_04.jpg)'
- en: A state example
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态示例
- en: 'To illustrate the state pattern, let''s build an XML parsing tool. The context
    class will be the parser itself. It will take a string as input and place the
    tool in an initial parsing state. The various parsing states will eat characters,
    looking for a specific value, and when that value is found, change to a different
    state. The goal is to create a tree of node objects for each tag and its contents.
    To keep things manageable, we''ll parse only a subset of XML - tags and tag names.
    We won''t be able to handle attributes on tags. It will parse text content of
    tags, but won''t attempt to parse "mixed" content, which has tags inside of text.
    Here is an example "simplified XML" file that we''ll be able to parse:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明状态模式，让我们构建一个XML解析工具。上下文类将是解析器本身。它将以字符串作为输入，并将工具放在初始解析状态中。各种解析状态将吃掉字符，寻找特定的值，当找到该值时，转换到不同的状态。目标是为每个标签及其内容创建一个节点对象树。为了保持事情可管理，我们只解析XML的一个子集
    - 标签和标签名称。我们将无法处理标签上的属性。它将解析标签的文本内容，但不会尝试解析“混合”内容，其中包含文本内的标签。这是一个我们将能够解析的“简化XML”文件的例子：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Before we look at the states and the parser, let''s consider the output of
    this program. We know we want a tree of `Node` objects, but what does a `Node`
    look like? Well, clearly it''ll need to know the name of the tag it is parsing,
    and since it''s a tree, it should probably maintain a pointer to the parent node
    and a list of the node''s children in order. Some nodes have a text value, but
    not all of them. Let''s look at this `Node` class first:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看状态和解析器之前，让我们考虑一下这个程序的输出。我们知道我们想要一个`Node`对象的树，但`Node`是什么样子呢？显然，它需要知道它正在解析的标签的名称，并且由于它是一棵树，它可能需要维护指向父节点的指针和按顺序排列的节点子节点列表。有些节点有文本值，但不是所有节点都有。让我们先看看这个`Node`类：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This class sets default attribute values upon initialization. The `__str__`
    method is supplied to help visualize the tree structure when we're finished.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类在初始化时设置默认属性值。提供`__str__`方法来帮助可视化树结构完成时的情况。
- en: Now, looking at the example document, we need to consider what states our parser
    can be in. Clearly it's going to start in a state where no nodes have yet been
    processed. We'll need a state for processing opening tags and closing tags. And
    when we're inside a tag with text contents, we'll have to process that as a separate
    state, too.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看示例文档，我们需要考虑解析器可能处于哪些状态。显然，它将从尚未处理任何节点的状态开始。我们需要一个状态来处理开放标签和关闭标签。当我们在具有文本内容的标签内部时，我们还需要将其处理为单独的状态。
- en: 'Switching states can be tricky; how do we know if the next node is an opening
    tag, a closing tag, or a text node? We could put a little logic in each state
    to work this out, but it actually makes more sense to create a new state whose
    sole purpose is figuring out which state we''ll be switching to next. If we call
    this transition state **ChildNode**, we end up with the following states:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 状态切换可能会很棘手；我们如何知道下一个节点是开放标签、关闭标签还是文本节点？我们可以在每个状态中放入一些逻辑来解决这个问题，但实际上创建一个新状态来唯一目的是确定下一个要切换到的状态更有意义。如果我们将这个过渡状态称为**ChildNode**，我们最终得到以下状态：
- en: '**FirstTag**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FirstTag**'
- en: '**ChildNode**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ChildNode**'
- en: '**OpenTag**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenTag**'
- en: '**CloseTag**'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CloseTag**'
- en: '**Text**'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Text**'
- en: 'The **FirstTag** state will switch to **ChildNode**, which is responsible for
    deciding which of the other three states to switch to; when those states are finished,
    they''ll switch back to **ChildNode**. The following state-transition diagram
    shows the available state changes:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**FirstTag**状态将切换到**ChildNode**，负责决定切换到其他三个状态中的哪一个；当这些状态完成时，它们将切换回**ChildNode**。以下状态转换图显示了可用的状态更改：'
- en: '![A state example](images/8781OS_10_05.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![状态示例](images/8781OS_10_05.jpg)'
- en: 'The states are responsible for taking "what''s left of the string", processing
    as much of it as they know what to do with, and then telling the parser to take
    care of the rest of it. Let''s construct the `Parser` class first:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 状态负责获取“字符串的剩余部分”，处理它们所知道的部分，然后告诉解析器处理剩下的部分。现在，首先构造`Parser`类：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The initializer sets up a few variables on the class that the individual states
    will access. The `parse_string` instance variable is the text that we are trying
    to parse. The `root` node is the "top" node in the XML structure. The `current_node`
    instance variable is the one that we are currently adding children to.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化程序在类上设置了一些变量，个别状态将访问这些变量。`parse_string`实例变量是我们试图解析的文本。`root`节点是XML结构中的“顶部”节点。`current_node`实例变量是我们当前正在向其添加子节点的变量。
- en: The important feature of this parser is the `process` method, which accepts
    the remaining string, and passes it off to the current state. The parser (the
    `self` argument) is also passed into the state's process method so that the state
    can manipulate it. The state is expected to return the remainder of the unparsed
    string when it is finished processing. The parser then recursively calls the `process`
    method on this remaining string to construct the rest of the tree.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解析器的重要特性是`process`方法，它接受剩余的字符串，并将其传递给当前状态。解析器（`self`参数）也被传递到状态的`process`方法中，以便状态可以操作它。状态预计在完成处理时返回未解析字符串的剩余部分。然后解析器递归调用这个剩余字符串上的`process`方法来构造树的其余部分。
- en: 'Now, let''s have a look at the `FirstTag` state:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看`FirstTag`状态：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This state finds the index (the `i_` stands for index) of the opening and closing
    angle brackets on the first tag. You may think this state is unnecessary, since
    XML requires that there be no text before an opening tag. However, there may be
    whitespace that needs to be consumed; this is why we search for the opening angle
    bracket instead of assuming it is the first character in the document. Note that
    this code is assuming a valid input file. A proper implementation would be rigorously
    testing for invalid input, and would attempt to recover or display an extremely
    descriptive error message.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个状态找到第一个标签的开放和关闭尖括号的索引（`i_`代表索引）。您可能认为这个状态是不必要的，因为XML要求在开放标签之前没有文本。但是，可能需要消耗空白字符；这就是为什么我们搜索开放尖括号而不是假设它是文档中的第一个字符。请注意，此代码假定输入文件有效。正确的实现将严格测试无效输入，并尝试恢复或显示极具描述性的错误消息。
- en: The method extracts the name of the tag and assigns it to the root node of the
    parser. It also assigns it to `current_node`, since that's the one we'll be adding
    children to next.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法提取标签的名称并将其分配给解析器的根节点。它还将其分配给`current_node`，因为接下来我们将向其添加子节点。
- en: 'Then comes the important part: the method changes the current state on the
    parser object to a `ChildNode` state. It then returns the remainder of the string
    (after the opening tag) to allow it to be processed.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是重要的部分：该方法将解析器对象上的当前状态更改为`ChildNode`状态。然后返回字符串的剩余部分（在开放标签之后）以便进行处理。
- en: 'The `ChildNode` state, which seems quite complicated, turns out to require
    nothing but a simple conditional:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChildNode`状态，看起来相当复杂，结果却只需要一个简单的条件：'
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `strip()` call removes whitespace from the string. Then the parser determines
    if the next item is an opening or closing tag, or a string of text. Depending
    on which possibility occurs, it sets the parser to a particular state, and then
    tells it to parse the remainder of the string.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: “strip（）”调用从字符串中删除空格。然后解析器确定下一个项是开放标签、关闭标签还是文本字符串。根据发生的可能性，它将解析器设置为特定状态，然后告诉它解析字符串的其余部分。
- en: 'The `OpenTag` state is similar to the `FirstTag` state, except that it adds
    the newly created node to the previous `current_node` object''s `children` and
    sets it as the new `current_node`. It places the processor back in the `ChildNode`
    state before continuing:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: “OpenTag”状态类似于“FirstTag”状态，只是它将新创建的节点添加到先前的“current_node”对象的“children”中，并将其设置为新的“current_node”。然后在继续之前将处理器放回“ChildNode”状态：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `CloseTag` state basically does the opposite; it sets the parser''s `current_node`
    back to the parent node so any further children in the outside tag can be added
    to it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: “CloseTag”状态基本上做相反的事情；它将解析器的“current_node”设置回父节点，以便可以将外部标签中的任何进一步的子节点添加到其中：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The two `assert` statements help ensure that the parse strings are consistent.
    The `if` statement at the end of the method ensures that the processor terminates
    when it is finished. If the parent of a node is `None`, it means that we are working
    on the root node.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 两个“assert”语句有助于确保解析字符串一致。方法末尾的“if”语句确保处理器在完成时终止。如果节点的父节点是“None”，则意味着我们正在处理根节点。
- en: 'Finally, the `TextNode` state very simply extracts the text before the next
    close tag and sets it as a value on the current node:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，“TextNode”状态非常简单地提取下一个关闭标签之前的文本，并将其设置为当前节点的值：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we just have to set up the initial state on the parser object we created.
    The initial state is a `FirstTag` object, so just add the following to the `__init__`
    method:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需在我们创建的解析器对象上设置初始状态。初始状态是一个“FirstTag”对象，所以只需将以下内容添加到“__init__”方法中：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To test the class, let''s add a main script that opens an file from the command
    line, parses it, and prints the nodes:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个类，让我们添加一个主脚本，从命令行打开一个文件，解析它，并打印节点：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code opens the file, loads the contents, and parses the result. Then it
    prints each node and its children in order. The `__str__` method we originally
    added on the node class takes care of formatting the nodes for printing. If we
    run the script on the earlier example, it outputs the tree as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码打开文件，加载内容，并解析结果。然后按顺序打印每个节点及其子节点。我们最初在节点类上添加的“__str__”方法负责格式化节点以进行打印。如果我们在之前的示例上运行脚本，它将输出树如下：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Comparing this to the original simplified XML document tells us the parser is
    working.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与原始简化的XML文档进行比较告诉我们解析器正在工作。
- en: State versus strategy
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态与策略
- en: The state pattern looks very similar to the strategy pattern; indeed, the UML
    diagrams for the two are identical. The implementation, too, is identical; we
    could even have written our states as first-class functions instead of wrapping
    them in objects, as was suggested for strategy.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式看起来与策略模式非常相似；实际上，两者的UML图是相同的。实现也是相同的；我们甚至可以将我们的状态编写为一等函数，而不是将它们包装在对象中，就像策略建议的那样。
- en: While the two patterns have identical structures, they solve completely different
    problems. The strategy pattern is used to choose an algorithm at runtime; generally,
    only one of those algorithms is going to be chosen for a particular use case.
    The state pattern, on the other hand is designed to allow switching between different
    states dynamically, as some process evolves. In code, the primary difference is
    that the strategy pattern is not typically aware of other strategy objects. In
    the state pattern, either the state or the context needs to know which other states
    that it can switch to.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两种模式具有相同的结构，但它们解决的问题完全不同。策略模式用于在运行时选择算法；通常，针对特定用例只会选择其中一个算法。另一方面，状态模式旨在允许在某些过程发展时动态地在不同状态之间切换。在代码中，主要区别在于策略模式通常不知道其他策略对象。在状态模式中，状态或上下文需要知道它可以切换到哪些其他状态。
- en: State transition as coroutines
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态转换作为协程
- en: The state pattern is the canonical object-oriented solution to state-transition
    problems. However, the syntax for this pattern is rather verbose. You can get
    a similar effect by constructing your objects as coroutines. Remember the regular
    expression log file parser we built in [Chapter 9](ch09.html "Chapter 9. The Iterator
    Pattern"), *The Iterator Pattern*? That was a state-transition problem in disguise.
    The main difference between that implementation and one that defines all the objects
    (or functions) used in the state pattern is that the coroutine solution allows
    us to encode more of the boilerplate in language constructs. There are two implementations,
    but neither one is inherently better than the other, but you may find that coroutines
    are more readable, for a given definition of "readable" (you have to understand
    the syntax of coroutines, first!).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式是面向对象的标准解决方案，用于状态转换问题。但是，这种模式的语法相当冗长。通过构造对象为协程，您可以获得类似的效果。还记得我们在[第9章](ch09.html
    "第9章. 迭代器模式")中构建的正则表达式日志文件解析器吗？那是一个伪装的状态转换问题。该实现与定义状态模式中使用的所有对象（或函数）的实现之间的主要区别在于，协程解决方案允许我们将更多的样板代码编码为语言结构。有两种实现，但没有一种本质上比另一种更好，但您可能会发现协程更易读，根据“易读”的定义（首先您必须了解协程的语法！）。
- en: The singleton pattern
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式
- en: The singleton pattern is one of the most controversial patterns; many have accused
    it of being an "anti-pattern", a pattern that should be avoided, not promoted.
    In Python, if someone is using the singleton pattern, they're almost certainly
    doing something wrong, probably because they're coming from a more restrictive
    programming language.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式是最具争议的模式之一；许多人指责它是一种“反模式”，一种应该避免而不是推广的模式。在Python中，如果有人使用单例模式，几乎可以肯定他们做错了什么，可能是因为他们来自更严格的编程语言。
- en: So why discuss it at all? Singleton is one of the most famous of all design
    patterns. It is useful in overly object-oriented languages, and is a vital part
    of traditional object-oriented programming. More relevantly, the idea behind singleton
    is useful, even if we implement that idea in a totally different way in Python.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么要讨论它呢？单例是所有设计模式中最著名的之一。它在过度面向对象的语言中很有用，并且是传统面向对象编程的重要部分。更相关的是，单例背后的思想是有用的，即使我们在Python中以完全不同的方式实现了这个思想。
- en: The basic idea behind the singleton pattern is to allow exactly one instance
    of a certain object to exist. Typically, this object is a sort of manager class
    like those we discussed in [Chapter 5](ch05.html "Chapter 5. When to Use Object-oriented
    Programming"), *When to Use Object-oriented Programming*. Such objects often need
    to be referenced by a wide variety of other objects, and passing references to
    the manager object around to the methods and constructors that need them can make
    code hard to read.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式背后的基本思想是允许某个对象的确切一个实例存在。通常，这个对象是一种类似于我们在[第5章](ch05.html "第5章。何时使用面向对象编程")中讨论的管理类，*何时使用面向对象编程*。这些对象通常需要被各种其他对象引用，并且将对管理对象的引用传递给需要它们的方法和构造函数可能会使代码难以阅读。
- en: 'Instead, when a singleton is used, the separate objects request the single
    instance of the manager object from the class, so a reference to it need not to
    be passed around. The UML diagram doesn''t fully describe it, but here it is for
    completeness:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当使用单例时，单独的对象从类中请求管理对象的单个实例，因此无需传递对它的引用。UML图表并未完全描述它，但为了完整起见，这里是：
- en: '![The singleton pattern](images/8781OS_10_06.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![单例模式](images/8781OS_10_06.jpg)'
- en: In most programming environments, singletons are enforced by making the constructor
    private (so no one can create additional instances of it), and then providing
    a static method to retrieve the single instance. This method creates a new instance
    the first time it is called, and then returns that same instance each time it
    is called again.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程环境中，通过使构造函数私有（以便没有人可以创建它的其他实例），然后提供一个静态方法来检索单个实例来强制实施单例。该方法在第一次调用时创建一个新实例，然后在每次再次调用时返回相同的实例。
- en: Singleton implementation
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例实现
- en: 'Python doesn''t have private constructors, but for this purpose, it has something
    even better. We can use the `__new__` class method to ensure that only one instance
    is ever created:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有私有构造函数，但为此，它有更好的东西。我们可以使用`__new__`类方法来确保只创建一个实例：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When `__new__` is called, it normally constructs a new instance of that class.
    When we override it, we first check if our singleton instance has been created;
    if not, we create it using a `super` call. Thus, whenever we call the constructor
    on `OneOnly`, we always get the exact same instance:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`__new__`时，通常会构造该类的新实例。当我们重写它时，我们首先检查我们的单例实例是否已创建；如果没有，我们使用`super`调用来创建它。因此，无论何时我们在`OneOnly`上调用构造函数，我们总是得到完全相同的实例：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The two objects are equal and located at the same address; thus, they are the
    same object. This particular implementation isn't very transparent, since it's
    not obvious that a singleton object has been created. Whenever we call a constructor,
    we expect a new instance of that object; in this case, that contract is violated.
    Perhaps, good docstrings on the class could alleviate this problem if we really
    think we need a singleton.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个对象是相等的，并且位于相同的地址；因此，它们是同一个对象。这种特定的实现并不是非常透明，因为不明显地创建了一个单例对象。每当我们调用构造函数时，我们期望得到该对象的一个新实例；在这种情况下，这个约定被违反了。也许，如果我们真的认为需要一个单例，类上的良好文档字符串可以缓解这个问题。
- en: But we don't need it. Python coders frown on forcing the users of their code
    into a specific mindset. We may think only one instance of a class will ever be
    required, but other programmers may have different ideas. Singletons can interfere
    with distributed computing, parallel programming, and automated testing, for example.
    In all those cases, it can be very useful to have multiple or alternative instances
    of a specific object, even though a "normal' operation may never require one.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们并不需要它。Python程序员不喜欢强迫他们的代码使用者进入特定的思维方式。我们可能认为一个类只需要一个实例，但其他程序员可能有不同的想法。单例可能会干扰分布式计算、并行编程和自动化测试，例如。在所有这些情况下，拥有特定对象的多个或替代实例可能非常有用，即使“正常”操作可能永远不需要一个。
- en: Module variables can mimic singletons
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 模块变量可以模拟单例
- en: Normally, in Python, the singleton pattern can be sufficiently mimicked using
    module-level variables. It's not as "safe" as a singleton in that people could
    reassign those variables at any time, but as with the private variables we discussed
    in [Chapter 2](ch02.html "Chapter 2. Objects in Python"), *Objects in Python*,
    this is acceptable in Python. If someone has a valid reason to change those variables,
    why should we stop them? It also doesn't stop people from instantiating multiple
    instances of the object, but again, if they have a valid reason to do so, why
    interfere?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在Python中，可以使用模块级变量来充分模拟单例模式。它不像单例那样“安全”，因为人们随时可以重新分配这些变量，但与我们在[第2章](ch02.html
    "第2章。Python中的对象")中讨论的私有变量一样，在Python中是可以接受的。如果有人有正当理由更改这些变量，我们为什么要阻止他们呢？它也不会阻止人们实例化对象的多个实例，但同样，如果他们有正当理由这样做，为什么要干涉呢？
- en: Ideally, we should give them a mechanism to get access to the "default singleton"
    value, while also allowing them to create other instances if they need them. While
    technically not a singleton at all, it provides the most Pythonic mechanism for
    singleton-like behavior.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们应该为它们提供一种机制来访问“默认单例”值，同时也允许它们在需要时创建其他实例。虽然从技术上讲根本不是单例，但它提供了最符合Python风格的单例行为机制。
- en: 'To use module-level variables instead of a singleton, we instantiate an instance
    of the class after we''ve defined it. We can improve our state pattern to use
    singletons. Instead of creating a new object every time we change states, we can
    create a module-level variable that is always accessible:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块级变量而不是单例，我们在定义类之后实例化类的实例。我们可以改进我们的状态模式以使用单例。我们可以创建一个模块级变量，而不是在每次改变状态时创建一个新对象，这样始终可以访问该变量：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: All we've done is create instances of the various state classes that can be
    reused. Notice how we can access these module variables inside the classes, even
    before the variables have been defined? This is because the code inside the classes
    is not executed until the method is called, and by this point, the entire module
    will have been defined.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的只是创建可以重复使用的各种状态类的实例。请注意，即使在定义变量之前，我们也可以在类内部访问这些模块变量？这是因为类内部的代码直到调用方法时才会执行，到这个时候整个模块都将被定义。
- en: The difference in this example is that instead of wasting memory creating a
    bunch of new instances that must be garbage collected, we are reusing a single
    state object for each state. Even if multiple parsers are running at once, only
    these state classes need to be used.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的不同之处在于，我们不是浪费内存创建必须进行垃圾回收的大量新实例，而是为每个状态重用单个状态对象。即使同时运行多个解析器，也只需要使用这些状态类。
- en: When we originally created the state-based parser, you may have wondered why
    we didn't pass the parser object to `__init__` on each individual state, instead
    of passing it into the process method as we did. The state could then have been
    referenced as `self.parser`. This is a perfectly valid implementation of the state
    pattern, but it would not have allowed leveraging the singleton pattern. If the
    state objects maintain a reference to the parser, then they cannot be used simultaneously
    to reference other parsers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最初创建基于状态的解析器时，您可能会想知道为什么我们没有将解析器对象传递给每个单独的状态的`__init__`，而是像我们所做的那样将其传递给process方法。然后状态可以被引用为`self.parser`。这是状态模式的一个完全有效的实现，但它不允许利用单例模式。如果状态对象保持对解析器的引用，那么它们就不能同时用于引用其他解析器。
- en: Tip
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember, these are two different patterns with different purposes; the fact
    that singleton's purpose may be useful for implementing the state pattern does
    not mean the two patterns are related.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这是两种不同目的的模式；单例模式的目的可能有助于实现状态模式，但这并不意味着这两种模式有关联。
- en: The template pattern
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板模式
- en: 'The template pattern is useful for removing duplicate code; it''s an implementation
    to support the **Don''t Repeat Yourself** principle we discussed in [Chapter 5](ch05.html
    "Chapter 5. When to Use Object-oriented Programming"), *When to Use Object-oriented
    Programming*. It is designed for situations where we have several different tasks
    to accomplish that have some, but not all, steps in common. The common steps are
    implemented in a base class, and the distinct steps are overridden in subclasses
    to provide custom behavior. In some ways, it''s like a generalized strategy pattern,
    except similar sections of the algorithms are shared using a base class. Here
    it is in the UML format:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 模板模式对于消除重复代码很有用；它是支持我们在[第5章](ch05.html "第5章。何时使用面向对象编程")中讨论的**不要重复自己**原则的实现，*何时使用面向对象编程*。它设计用于在需要完成一些具有部分但不完全相同步骤的几个不同任务的情况下。通用步骤在基类中实现，不同的步骤在子类中被覆盖以提供自定义行为。在某种程度上，它类似于广义策略模式，只是使用基类共享算法的相似部分。以下是它的UML格式：
- en: '![The template pattern](images/8781OS_10_07.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![模板模式](images/8781OS_10_07.jpg)'
- en: A template example
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板示例
- en: Let's create a car sales reporter as an example. We can store records of sales
    in an SQLite database table. SQLite is a simple file-based database engine that
    allows us to store records using SQL syntax. Python 3 includes SQLite in its standard
    library, so there are no extra modules required.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以创建一个汽车销售报告为例。我们可以在SQLite数据库表中存储销售记录。SQLite是一个简单的基于文件的数据库引擎，允许我们使用SQL语法存储记录。Python
    3在其标准库中包含了SQLite，因此不需要额外的模块。
- en: 'We have two common tasks we need to perform:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个需要执行的常见任务：
- en: Select all sales of new vehicles and output them to the screen in a comma-delimited
    format
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择所有新车销售并以逗号分隔的格式将其输出到屏幕上
- en: Output a comma-delimited list of all salespeople with their gross sales and
    save it to a file that can be imported to a spreadsheet
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出所有销售人员及其总销售额的逗号分隔列表，并将其保存到可以导入电子表格的文件中
- en: 'These seem like quite different tasks, but they have some common features.
    In both cases, we need to perform the following steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些似乎是非常不同的任务，但它们有一些共同的特点。在这两种情况下，我们都需要执行以下步骤：
- en: Connect to the database.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到数据库。
- en: Construct a query for new vehicles or gross sales.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个查询以获取新车辆或总销售额。
- en: Issue the query.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发出查询。
- en: Format the results into a comma-delimited string.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果格式化为逗号分隔的字符串。
- en: Output the data to a file or e-mail.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据输出到文件或电子邮件。
- en: The query construction and output steps are different for the two tasks, but
    the remaining steps are identical. We can use the template pattern to put the
    common steps in a base class, and the varying steps in two subclasses.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个任务的查询构建和输出步骤不同，但其余步骤相同。我们可以使用模板模式将通用步骤放入基类中，将不同的步骤放入两个子类中。
- en: 'Before we start, let''s create a database and put some sample data in it, using
    a few lines of SQL:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们创建一个数据库并使用几行SQL将一些示例数据放入其中：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Hopefully you can see what's going on here even if you don't know SQL; we've
    created a table to hold the data, and used six insert statements to add sales
    records. The data is stored in a file named `sales.db`. Now we have a sample we
    can work with in developing our template pattern.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 希望即使您不懂SQL，也能看出这里发生了什么；我们创建了一个表来保存数据，并使用六个插入语句添加了销售记录。数据存储在名为`sales.db`的文件中。现在我们有一个示例可以用来开发我们的模板模式。
- en: 'Since we''ve already outlined the steps that the template has to perform, we
    can start by defining the base class that contains the steps. Each step gets its
    own method (to make it easy to selectively override any one step), and we have
    one more managerial method that calls the steps in turn. Without any method content,
    here''s how it might look:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经概述了模板必须执行的步骤，我们可以从定义包含这些步骤的基类开始。每个步骤都有自己的方法（以便轻松地选择性地覆盖任何一个步骤），并且我们还有一个管理方法，依次调用这些步骤。没有任何方法内容，它可能看起来像这样：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `process_format` method is the primary method to be called by an outside
    client. It ensures each step is executed in order, but it does not care if that
    step is implemented in this class or in a subclass. For our examples, we know
    that three methods are going to be identical between our two classes:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_format`方法是外部客户端要调用的主要方法。它确保每个步骤按顺序执行，但它不在乎该步骤是在这个类中实现还是在子类中实现。对于我们的例子，我们知道两个类之间的三个方法将是相同的：'
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To help with implementing subclasses, the two methods that are not specified
    raise `NotImplementedError`. This is a common way to specify abstract interfaces
    in Python when abstract base classes seem too heavyweight. The methods could have
    empty implementations (with `pass`), or could be fully unspecified. Raising `NotImplementedError`,
    however, helps the programmer understand that the class is meant to be subclassed
    and these methods overridden; empty methods or methods that do not exist are harder
    to identify as needing to be implemented and to debug if we forget to implement
    them.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助实现子类，两个未指定的方法会引发`NotImplementedError`。这是在Python中指定抽象接口的常见方式，当抽象基类看起来太笨重时。这些方法可以有空实现（使用`pass`），或者可以完全未指定。然而，引发`NotImplementedError`有助于程序员理解该类是要被子类化并且这些方法被重写；空方法或不存在的方法更难以识别需要被实现并且如果我们忘记实现它们时调试。
- en: Now we have a template class that takes care of the boring details, but is flexible
    enough to allow the execution and formatting of a wide variety of queries. The
    best part is, if we ever want to change our database engine from SQLite to another
    database engine (such as py-postgresql), we only have to do it here, in this template
    class, and we don't have to touch the two (or two hundred) subclasses we might
    have written.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个模板类，它处理了乏味的细节，但足够灵活，可以执行和格式化各种查询。最好的部分是，如果我们想要将数据库引擎从SQLite更改为另一个数据库引擎（例如py-postgresql），我们只需要在这里，在这个模板类中做，而不必触及我们可能编写的两个（或两百个）子类。
- en: 'Let''s have a look at the concrete classes now:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看具体的类：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'These two classes are actually pretty short, considering what they''re doing:
    connecting to a database, executing a query, formatting the results, and outputting
    them. The superclass takes care of the repetitive work, but lets us easily specify
    those steps that vary between tasks. Further, we can also easily change steps
    that are provided in the base class. For example, if we wanted to output something
    other than a comma-delimited string (for example: an HTML report to be uploaded
    to a website), we can still override `format_results`.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类实际上相当简短，考虑到它们的功能：连接到数据库，执行查询，格式化结果并输出它们。超类处理了重复的工作，但让我们轻松地指定那些在任务之间变化的步骤。此外，我们还可以轻松地更改在基类中提供的步骤。例如，如果我们想要输出除逗号分隔字符串之外的其他内容（例如：要上传到网站的HTML报告），我们仍然可以重写`format_results`。
- en: Exercises
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: While writing this chapter, I discovered that it can be very difficult, and
    extremely educational, to come up with good examples where specific design patterns
    should be used. Instead of going over current or old projects to see where you
    can apply these patterns, as I've suggested in previous chapters, think about
    the patterns and different situations where they might come up. Try to think outside
    your own experiences. If your current projects are in the banking business, consider
    how you'd apply these design patterns in a retail or point-of-sale application.
    If you normally write web applications, think about using design patterns while
    writing a compiler.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本章时，我发现很难，但也非常有教育意义，找到应该使用特定设计模式的好例子。与其像我在之前的章节中建议的那样检查当前或旧项目以查看可以应用这些模式的地方，不如考虑这些模式和可能出现的不同情况。尝试超越自己的经验。如果你当前的项目是银行业务，考虑在零售或销售点应用这些设计模式。如果你通常编写Web应用程序，考虑在编写编译器时使用设计模式。
- en: Look at the decorator pattern and come up with some good examples of when to
    apply it. Focus on the pattern itself, not the Python syntax we discussed; it's
    a bit more general than the actual pattern. The special syntax for decorators
    is, however, something you may want to look for places to apply in existing projects
    too.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 看看装饰器模式，并想出一些适用它的好例子。专注于模式本身，而不是我们讨论的Python语法；它比实际模式更一般。然而，装饰器的特殊语法是你可能想要寻找现有项目中适用的地方。
- en: What are some good areas to use the observer pattern? Why? Think about not only
    how you'd apply the pattern, but how you would implement the same task without
    using observer? What do you gain, or lose, by choosing to use it?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用观察者模式的一些好领域是什么？为什么？不仅考虑如何应用模式，还要考虑如何在不使用观察者的情况下实现相同的任务？选择使用它会得到什么，或失去什么？
- en: Consider the difference between the strategy and state patterns. Implementation-wise,
    they look very similar, yet they have different purposes. Can you think of cases
    where the patterns could be interchanged? Would it be reasonable to redesign a
    state-based system to use strategy instead, or vice versa? How different would
    the design actually be?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑策略模式和状态模式之间的区别。在实现上，它们看起来非常相似，但它们有不同的目的。你能想到模式可以互换的情况吗？重新设计一个基于状态的系统以使用策略，或者反之亦然，是否合理？设计实际上会有多大的不同？
- en: The template pattern is such an obvious application of inheritance to reduce
    duplicate code that you may have used it before, without knowing its name. Try
    to think of at least half a dozen different scenarios where it would be useful.
    If you can do this, you'll be finding places for it in your daily coding all the
    time.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 模板模式是继承的明显应用，可以减少重复的代码，你可能以前就使用过它，只是不知道它的名字。试着想出至少半打不同的场景，它在这些场景中会有用。如果你能做到这一点，你将会在日常编码中经常找到它的用武之地。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter discussed several common design patterns in detail, with examples,
    UML diagrams, and a discussion of the differences between Python and statically
    typed object-oriented languages. The decorator pattern is often implemented using
    Python's more generic decorator syntax. The observer pattern is a useful way to
    decouple events from actions taken on those events. The strategy pattern allows
    different algorithms to be chosen to accomplish the same task. The state pattern
    looks similar, but is used instead to represent systems can move between different
    states using well-defined actions. The singleton pattern, popular in some statically
    typed languages, is almost always an anti-pattern in Python.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细讨论了几种常见的设计模式，包括示例、UML图和Python与静态类型面向对象语言之间的差异讨论。装饰器模式通常使用Python更通用的装饰器语法来实现。观察者模式是一种有用的方式，可以将事件与对这些事件采取的行动分离开来。策略模式允许选择不同的算法来完成相同的任务。状态模式看起来类似，但实际上是用来表示系统可以使用明确定义的操作在不同状态之间移动。单例模式在一些静态类型语言中很受欢迎，但在Python中几乎总是反模式。
- en: In the next chapter, we'll wrap up our discussion of design patterns.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将结束对设计模式的讨论。
