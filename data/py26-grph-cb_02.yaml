- en: Chapter 2. Drawing Fundamental Shapes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 绘制基本形状
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: A straight line and the coordinate system
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直线和坐标系统
- en: Drawing a dashed line
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制虚线
- en: Lines of varying styles with arrows and endcaps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带箭头和端盖的样式各异的线条
- en: A two-segment line with a sharp bend
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有尖锐弯曲的两段线条
- en: A line with a curved bend
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有弯曲的线条
- en: Drawing intricate stored shapes - the curly vine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制复杂的存储形状 - 卷须
- en: Drawing a rectangle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制矩形
- en: Drawing overlapping rectangles
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制重叠的矩形
- en: Drawing concentric squares
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制同心正方形
- en: A circle from an oval
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从椭圆得到的圆
- en: A circle from an arc
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从弧得到的圆
- en: Three ellipses
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个椭圆
- en: The simplest polygon
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最简单的多边形
- en: A star polygon
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 星形多边形
- en: The art of cloning stars
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制星星的艺术
- en: Introduction
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Graphics are all about pictures and drawings. In computer programs, a line is
    not drawn by a hand, holding a pencil, but by the manipulation of numbers on a
    screen. This chapter provides the fine-grained detail or atomic structure for
    the rest of the book. Here we lay down the most basic graphic building blocks
    in their simplest form. The most useful options are presented inside self-contained
    programs. You can if you want, use the code without understanding in detail how
    it works. You can learn by doing. You can learn by playing and play is the serious
    work that unskilled animals do in order to learn almost everything they need for
    survival.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图形都是关于图片和绘制的。在计算机程序中，线条不是由手持铅笔的手绘制的，而是通过在屏幕上操作数字来绘制的。本章提供了本书其余部分所需的精细细节或原子结构。在这里，我们以最简单的形式阐述了最基本的图形构建块。最有用的选项在自包含的程序中展示。如果您愿意，可以使用代码而不必详细了解其工作原理。您可以边做边学。您可以边玩边学，而玩耍是无技能动物为了学习几乎一切生存所需的东西而进行的严肃工作。
- en: You can cut and paste the code and it should just work without modification.
    The code is easily modified and you are encouraged to tinker with it and tweak
    the parameters inside the drawing methods. The more you tinker with it, the more
    you will understand.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以复制粘贴代码，它应该无需修改即可正常工作。代码很容易修改，并鼓励您对其进行调整，修改绘图方法中的参数。您调整得越多，理解得就越多。
- en: The area of screen where lines and shapes are drawn is the canvas in Python.
    It is created when the Tkinter method `canvas()` is executed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，绘制线条和形状的屏幕区域是画布。当执行 Tkinter 方法 `canvas()` 时创建画布。
- en: Central to using numbers to describe lines and shapes is a coordinate system
    that says where a line or shape starts and where it ends. In Tkinter, as in most
    computer graphic systems, the top-left is the start of the screen or canvas and
    bottom-right is the end where the largest numbers describe location. This system
    is shown in the next figure, which is the universal computer screen coordinate
    system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数字描述线条和形状的核心是一个坐标系统，它说明了线条或形状的起始点和结束点。在 Tkinter 中，就像在大多数计算机图形系统中一样，屏幕或画布的左上角是起点，而右下角是终点，最大的数字描述了位置。这个系统在下一张图中展示，它是通用的计算机屏幕坐标系统。
- en: '![Introduction](img/3845OS_02_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![简介](img/3845OS_02_01.jpg)'
- en: A straight line and the coordinate system
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直线和坐标系统
- en: Draw a straight line on a canvas. It is important to understand that the start
    of the coordinate system is always at the top left-hand corner of the canvas as
    shown in the previous figure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布上绘制一条直线。重要的是要理解，坐标系统的起点始终位于画布的左上角，如图中所示。
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In a text editor type the lines below that appear between the two `#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`
    divider/separators.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中输入出现在两个 `#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>` 分隔符之间的以下行。
- en: Save this as a file named `line_1.py`, inside the directory called `constr`
    again.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其保存为名为 `line_1.py` 的文件，再次放在名为 `constr` 的目录中。
- en: As before, open up an X terminal or DOS window if you are using MS Windows.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，如果您使用的是 MS Windows，请打开一个 X 终端或 DOS 窗口。
- en: Change directory (command `cd /constr)` into the directory `constr` - where
    `line_1.py` is located.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换目录（命令 `cd /constr`）到 `constr` 目录 - 其中包含 `line_1.py`。
- en: Type `python line_1.py` and your program will execute. The result should look
    like the following screenshot:![How to do it...](img/3845_02_02.jpg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `python line_1.py` 并运行您的程序。结果应该看起来像下面的截图：![如何操作...](img/3845_02_02.jpg)
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: We have written the coordinates for our line differently from the way we did
    in the previous chapter because we want to introduce symbolic assignments into
    the `create_line()` method. This is a preliminary step to making our code re-usable.
    There is more than one way to specify the points that define the location of line.
    The neatest way is to define a Python list or tuple by name and then just insert
    this name of the list as the argument of the `create_line()` method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为线条编写的坐标与上一章中的方式不同，因为我们想将符号赋值引入到 `create_line()` 方法中。这是使我们的代码可重用的初步步骤。指定定义线条位置的点的位置有多种方法。最整洁的方法是定义一个名为
    Python 列表或元组的名称，然后只需将此列表名称作为 `create_line()` 方法的参数插入即可。
- en: 'For example, if we wanted to draw two lines, one from (x=50, y=25) to (x= 220,
    y=44) and the second line between(x=11, y=22) and (x=44, y=33) then we could write
    the following lines in our program:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想画两条线，一条从 (x=50, y=25) 到 (x=220, y=44)，另一条线从 (x=11, y=22) 到 (x=44, y=33)，那么我们可以在程序中写下以下几行：
- en: '`line_1 = 50, 25, 220, 44 #` this is a tuple and can NEVER change'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`line_1 = 50, 25, 220, 44 #` 这是一个元组，永远不能改变'
- en: '`line_2 = [11, 22, 44, 33] #` this is a list and can be changed anytime.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`line_2 = [11, 22, 44, 33] #` 这是一个列表，可以随时更改。'
- en: '`canvas_1.create_line(line_1)`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canvas_1.create_line(line_1)`'
- en: '`canvas_1.create_line(line_2)`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canvas_1.create_line(line_2)`'
- en: Note that although `line_1 = 50, 25, 220, 44` is syntactically correct Python,
    it is considered to be poor Python grammar. It is better to write `line_1 = (
    50, 25, 220, 44)` because this is more explicit and therefore clearer to someone
    reading the code. Another point to note is that `canvas_1` is an arbitrary name
    I have given to the particular instance of a canvas of a certain size. You can
    give it any name you like.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管 `line_1 = 50, 25, 220, 44` 在语法上是正确的 Python 代码，但它被认为是一种较差的 Python 语法。更好的写法是
    `line_1 = (50, 25, 220, 44)`，因为这更加明确，因此对阅读代码的人来说更清晰。另一个需要注意的点是 `canvas_1` 是我给特定大小的画布实例所取的一个任意名称。你可以给它取任何你喜欢的名字。
- en: There's more...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Most shapes can be made up of pieces of lines joined together in a multitude
    of ways. An extremely useful attribute that Tkinter offers is the ability to transform
    sequences of straight lines into smooth curves. This attribute of lines can be
    used in surprising ways and is illustrated in recipe 6.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数形状都可以由以多种方式连接在一起的线段组成。Tkinter 提供的一个极其有用的属性是将直线序列转换为平滑曲线的能力。这种线条属性可以用令人惊讶的方式使用，并在第
    6 个菜谱中进行了说明。
- en: Draw a dashed line
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 画一条虚线
- en: A straight dashed line, three pixels thick is drawn.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 画一条直线虚线，线宽为三像素。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: The instructions used in the previous example are used. The only change is in
    the name of the Python program. This time you should use the name `dashed_line.py`
    instead of `line_1.py`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中使用的说明仍然适用。唯一的变化是 Python 程序的名称。这次你应该使用名称 `dashed_line.py` 而不是 `line_1.py`。
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The new things here are the addition of some style specifications for the line.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里新增加的是为线条添加一些样式规范。
- en: '`dash=( 3,5)` says that there should be three solid pixels followed by five
    blank pixels and `width = 3` specifies that the line should be 3 pixels thick.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`dash=( 3,5)` 表示应该有三个实像素后跟五个空白像素，`width = 3` 指定线宽为 3 像素。'
- en: There's more...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can specify a limitless variety of dash-space patterns. A dash-space pattern
    specified as `dash = (5, 3, 24, 2, 3, 11)` would result in a line with three patterns
    repeated over and over throughout the length of the line. The pattern would consist
    of five solid pixels followed by three blank pixels. Then there would be 24 solid
    pixels followed by only two blank pixels. The third variation would be three solid
    followed by 11 blank pixels and then the whole set of three patterns would begin
    again. The list of dash-blank pairs can go on as long as you like. The even-numbered
    length specifications will specify the length of solid pixels.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定无限多种虚线-空格模式。一个指定为 `dash = (5, 3, 24, 2, 3, 11)` 的虚线-空格模式将导致一条线，其模式在整个线长上重复三次。模式将包括五个实像素后跟三个空白像素。然后会有
    24 个实像素后跟仅两个空白像素。第三种变化是三个实像素后跟 11 个空白像素，然后整个三模式集再次开始。虚线-空格对的列表可以无限延长。偶数长度的规范将指定实像素的长度。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The dash attribute is quirky on different operating systems. For instance on
    a Linux operating system it behaves as it should by obeying the directives for
    line and space distances but on MS Windows there is no respect for solid-dash
    directives if they exceed ten pixels in size
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的操作系统上，虚线属性可能会有所不同。例如，在Linux操作系统上，它应该遵守线与空间距离的指令，但在MS Windows上，如果虚线长度超过十像素，则不会尊重实线-虚线指令。
- en: Lines of varying styles with arrows and endcaps
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有箭头和端盖的样式各异的线条
- en: Four lines are drawn in different styles. We see how attributes like color and
    end shape can be obtained. A Python `for loop` is used to make an interesting
    pattern using the specifications of the dash attribute. In addition the color
    of the canvas background has been made green.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 画了四条不同风格的线条。我们看到如何获得颜色和端形状等属性。使用虚线属性的说明，通过Python的`for循环`制作了一个有趣的图案。此外，画布背景的颜色已被设置为绿色。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The instructions used in recipe 1 should be used again.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 应再次使用配方1中的说明。
- en: Just use the name `4lines.py` when you write, save, and execute this program.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写、保存和执行这个程序时，只需使用名称`4lines.py`。
- en: Arrows and endcaps have been introduced into the line specifications.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 已经将箭头和端盖引入到线规格中。
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To draw a line you only need to give the start point and the end point.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要画线，你只需要给出起点和终点。
- en: '![How it works...](img/3845_02_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/3845_02_03.jpg)'
- en: The preceding screenshot shows the result of execution on Ubuntu Linux
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了在Ubuntu Linux上执行的结果。
- en: In this example we have saved a bit of work by re-using previous line position
    specifications. See the next two screenshots.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过重新使用之前的线位置说明节省了一些工作。请看接下来的两张截图。
- en: '![How it works...](img/3845_02_04.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/3845_02_04.jpg)'
- en: The preceding screenshot shows the result of execution on MS Windows XP.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了在MS Windows XP上执行的结果。
- en: There's more...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here is where you may see the difference between Linux's and MS Windows's ability
    to draw dashed lines using Tkinter. The solid portion of the dash was specified
    as 19 pixels long. On the Linux (Ubuntu9.10) platform this specification was respected
    but Windows disregarded the instruction.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到Linux和MS Windows使用Tkinter绘制虚线的能力差异。虚线的实线部分被指定为19像素长。在Linux（Ubuntu9.10）平台上，这个指定被尊重，但Windows忽略了指令。
- en: A two segment line with a sharp bend
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个有两个段且弯曲尖锐的线条
- en: Lines do not have to be straight. A more general type of line can be made up
    of many straight segments joined together. You simply decide where you want the
    points that join sections of the multi-segment line and the order in which they
    should be joined.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 线不必是直的。更一般类型的线可以由许多直线段连接而成。你只需决定你想连接多段线各部分的位置以及它们应该连接的顺序。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The instructions are the same as for recipe 1\. Just use the name `sharp_bend.py`
    when you write, save, and execute this program.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 指令与配方1相同。当你编写、保存和执行这个程序时，只需使用名称`sharp_bend.py`。
- en: Just make a list of the `x,y` pairs defining each point and place them in the
    sequence that you want them connected in. The list can be as long as you like.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 只需列出定义每个点的`x,y`对，并将它们按你想要连接的顺序排列。列表可以任意长。
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'For clarity only three points have been defined: first =(x1,y1), second =(x2,y2)
    and third = (x3, y3). However, there is no limit to the number of sequential points
    that could be specified.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，只定义了三个点：第一个点为=(x1,y1)，第二个点为=(x2,y2)，第三个点为=(x3, y3)。然而，指定顺序点的数量并没有限制。
- en: '![How it works...](img/3845_02_05.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/3845_02_05.jpg)'
- en: The preceding screenshot shows the line with a sharp bend.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了带有尖锐弯曲的线条。
- en: There's more...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Ultimately you could have complicated figures stored as long sequences of points
    in files on some storage device. For example, you might want to produce something
    like a cartoon strip.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你可以在某些存储设备上的文件中存储复杂的图形，作为长序列的点。例如，你可能想制作类似卡通条的东西。
- en: You could construct a library of body parts and face features seen from different
    angles. There could be a selection of different mouth and eye shapes. The daily
    chore of assembling your comic strip could be partially automated. One of the
    things you would need to think about would be how to scale the component parts
    to be larger or smaller and also how to position them in different places and
    even rotate them to different angles. All these ideas are developed in this book.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以构建一个从不同角度看到的身体部位和面部特征的库。可能会有不同形状的嘴和眼睛。组装你的漫画条的任务可以部分自动化。你需要考虑的一件事是如何调整组件的大小，以及如何将它们放置在不同的位置，甚至将它们旋转到不同的角度。所有这些想法都在这本书中得到了发展。
- en: In particular see the next examples of how complex shapes can be stored and
    manipulated in a relatively compact form. The **SVG** (**Scaled Vector Graphics**)
    standard for drawing manipulation, particularly on web pages, uses a similar but
    different convention for representing shapes. Because both SVG and Tkinter are
    well defined it means that you can construct code for converting from one form
    to the other.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是查看以下示例，了解复杂形状如何以相对紧凑的形式存储和处理。用于绘图操作的**SVG**（**缩放矢量图形**）标准，尤其是在网页上，用于表示形状的约定与Tkinter类似但不同。由于SVG和Tkinter都得到了很好的定义，这意味着你可以构建代码以将一种形式转换为另一种形式。
- en: Examples of this are shown in [Chapter 6](ch06.html "Chapter 6. Working with
    Pictures"),
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此内容的示例请见[第6章](ch06.html "第6章。处理图片")，
- en: A line with a curved bend
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一条带有弯曲的线
- en: The most interesting lines are curved. Change the straight, two-segment line
    of the previous example into a smooth curve that fits parallel to the ends of
    each segment. Tkinter makes the curve out of 12 straight segments. 12 segments
    is the default number. However, you can change it to any other sensible number.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的线条是弯曲的。将上一个例子中的直线、两段线改为与每段线端平行拟合的平滑曲线。Tkinter使用12段直线来制作曲线。12段是默认数量。然而，你可以将其更改为任何其他合理的数字。
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Substitute the line `canvas_1.create_line(x1,y1, x2,y2, x3,y3)` with the line
    `canvas_1.create_line(x1,y1, x2,y2, x3,y3, smooth="true")`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将`canvas_1.create_line(x1,y1, x2,y2, x3,y3)`这一行替换为`canvas_1.create_line(x1,y1,
    x2,y2, x3,y3, smooth="true")`。
- en: The line is now curved. This is immensely useful when making drawings we only
    need to specify a minimal number of points and Tkinter fits a curved shape to
    it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 线现在弯曲了。这在制作我们只需要指定少量点的绘图时非常有用，Tkinter会将其拟合成曲线形状。
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: The program output for `smooth="true"` attribute is shown in the next screenshot.
    The `smooth='true'` attribute hides a large amount of serious mathematical curve
    manufacture taking place under the hood.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当`smooth="true"`属性被设置时，程序输出结果将在下一张截图显示。`smooth='true'`属性隐藏了大量在幕后进行的严肃数学曲线制造过程。
- en: To fit a curve to a pair of intersecting lines requires the curve and the lines
    to run parallel at the beginning and end but in the middle an entirely different
    process known as **spline fitting** is used. The consequence of this is that this
    kind of curvaceous smoothing is computationally expensive and if you do too much
    of it your program execution slows down. This has implications for what kinds
    of action can be successfully animated.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要将曲线拟合到一对相交的直线，曲线和直线在开始和结束时需要平行，但在中间则使用一种称为**样条拟合**的完全不同的过程。结果是这种曲线平滑处理在计算上非常昂贵，如果你做得太多，程序执行速度会减慢。这影响了哪些动作可以被成功动画化。
- en: '![How it works...](img/3845_02_06.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3845_02_06.jpg)'
- en: There's more...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: What we do later is to use the curve attribute to make more pleasing and exciting
    shapes. Ultimately you could accumulate for yourself a library of shapes. If you
    did this you would be re-creating some vector graphics that are freely available
    from the web. Look at [www.openclipart.org](http://www.openclipart.org). The pictures
    which are freely downloadable from this site are in SVG (Scaled Vector Graphics)
    format. If you look at the code of these pictures in a text editor you will see
    lines of code that are vaguely similar to the way these Tkinter programs specify
    the points. Some techniques for extracting useful shapes from existing SVG pictures
    will be demonstrated in [Chapter 6](ch06.html "Chapter 6. Working with Pictures"),
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后要做的是使用曲线属性来制作更令人愉悦和令人兴奋的形状。最终，你可以为自己积累一个形状库。如果你这样做，你将重新创建一些可以从网络上免费获取的矢量图形。看看
    [www.openclipart.org](http://www.openclipart.org)。从这个网站上免费下载的图片是 SVG（缩放矢量图形）格式。如果你在文本编辑器中查看这些图片的代码，你会看到一些代码行，它们与这些
    Tkinter 程序指定点的方略有几分相似。在 [第 6 章](ch06.html "第 6 章。处理图片") 中将演示从现有的 SVG 图片中提取有用形状的一些技术，
- en: Drawing intricate shapes the curly vine
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制复杂的形状——卷曲的藤蔓
- en: The task here is to draw a complicated shape in such a way that you can use
    it as a framework to produce unlimited variety and beauty.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的任务是绘制一个复杂的形状，以便你可以将其用作框架，产生无限多样性和美丽。
- en: We start out with a pencil and paper and draw a curly growing vine shape and
    transfer it in the simplest and most direct way into some code that will draw
    it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始用铅笔和纸绘制一个卷曲生长的藤蔓形状，并以最简单、最直接的方式将其转换成一些代码，以绘制它。
- en: 'This is a very important example because it reveals the essential elegance
    of both Python and Tkinter. The central inspiring design philosophy of Python
    is captured in two words: simplicity and clarity. This is what makes Python one
    of the best computer coding languages ever conceived.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常重要的例子，因为它揭示了 Python 和 Tkinter 的基本优雅性。Python 的核心启发设计理念可以用两个词来概括：简单和清晰。这就是
    Python 成为有史以来最好的计算机编程语言之一的原因。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: When they want to create a fresh design, most graphic artists start with a pencil
    and paper sketch because of the uncluttered subconscious freedom it gives. For
    this example, a complex curve was needed the kind of organic design used in framing
    pictures in antique books.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当他们想要创建一个全新的设计时，大多数图形艺术家都会从铅笔和纸草图开始，因为这给了他们无杂乱的潜意识自由。对于这个例子，需要一个复杂的曲线，这种有机设计用于在古董书中装裱图片。
- en: The smooth line was drawn with a pencil on paper and marked off at roughly,
    evenly spaced intervals with X's. Using a millimeter marked ruler the distance
    from each x to the left edge and the bottom of the paper was measured approximately.
    High accuracy is not needed because the curved nature of the line compensates
    for small imperfections.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 用铅笔在纸上画出平滑的线条，并在大约均匀间隔的地方用 X 标记。使用毫米刻度尺，测量每个 x 到左边和纸张底部的距离，大约测量。由于线条的曲线性质会补偿小的缺陷，所以不需要高精度。
- en: How to do it…
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: These measurements, 32 each in the x and y directions for a Tkinter canvas were
    typed into separate lists. One called `x_vine` for the x coordinates and `y_vine`
    for the y coordinates.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测量值，Tkinter 画布的 x 和 y 方向上各有 32 个，被输入到单独的列表中。一个叫做 `x_vine` 的用于 x 坐标，另一个叫做 `y_vine`
    的用于 y 坐标。
- en: Besides this hand-crafted way of creating the raw shape, the rest of the procedure
    is identical for all the previous examples.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种手工制作原始形状的方式之外，其余的步骤与所有之前的示例相同。
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The result is shown in the next screenshot which is a smoothed line of 32 straight
    segments.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在下一张屏幕截图中显示，这是一条由 32 段直线组成的平滑线条。
- en: '![How it works...](img/3845_02_07.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3845_02_07.jpg)'
- en: The essential trick in this task is to create a list of numbers that is in precisely
    the correct form to place into a `create_line()` method. It has to be an unbroken
    sequence, comma-separated, of pairs of matched x and y position coordinates of
    the complex curve we want to draw.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务中的关键技巧是创建一个数字列表，该列表可以精确地放入 `create_line()` 方法中。它必须是一个不间断的序列，由逗号分隔，包含我们想要绘制的复杂曲线的匹配的
    x 和 y 位置坐标对。
- en: So first we create an empty list `Q[]` to which we are going to append alternate
    values of the x and y coordinates.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先创建一个空列表 `Q[]`，我们将向其中追加 x 和 y 坐标的交替值。
- en: 'Because we want to leave the original lists `x_vine` and `y_vine` intact (for
    re-use elsewhere perhaps) we create working copies using:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们希望保留原始列表 `x_vine` 和 `y_vine` 的完整性（可能用于其他地方的重用），所以我们使用以下方式创建工作副本：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And finally the magic interleaved merging into one list with:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过以下方式将魔法交错合并到一个列表中：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `for in range()` combination and the block of code following it work cyclically
    through the code starting at `i=0`, increasing one by one each until the last
    value `len(X)` is reached. Then the block of code is exited and execution continues
    below the block. `Len(X)` is a function that gives back ('returns' in programmers'
    parlance) the number of elements in `X. Q` emerges from this perfect for immediate
    drawing in `create_line(Q)`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`for in range()` 组合及其后的代码块以循环方式遍历代码，从 `i=0` 开始，每次增加一个，直到达到最后一个值 `len(X)`。然后退出代码块，执行继续到块下方。`len(X)`
    是一个返回（在程序员术语中称为“返回”）`X` 中元素数量的函数。`Q` 从这里产生，非常适合立即在 `create_line(Q)` 中绘制。'
- en: If you leave out the `smooth='true'` attribute you will see the original join
    points that came from the original paper draw and measure process.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你省略了 `smooth='true'` 属性，你将看到来自原始论文绘制和测量过程的原始连接点。
- en: There's more...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Some interesting effects like curling smoke, charcoal, and glowing neon are
    produced by copying and transforming the curly vine in various ways in [Chapter
    6](ch06.html "Chapter 6. Working with Pictures"),
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以各种方式复制和变换卷曲的藤蔓，在[第6章](ch06.html "第6章。处理图片")中产生了诸如卷曲烟雾、炭笔和发光霓虹灯等有趣的效果，
- en: Draw a rectangle
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制一个矩形
- en: Draw a basic rectangle by specifying its position, shape, and color attributes
    as named variables.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定位置、形状和颜色属性作为命名变量来绘制基本矩形。
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The instructions used in recipe 1 should be used.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 应使用配方1中使用的说明。
- en: Just use the name `rectangle.py` when you write, save, and execute this program.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 写作、保存和执行此程序时，只需使用名称 `rectangle.py`。
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The results are given in the next screenshot showing a basic rectangle.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在下一张屏幕截图给出，显示了一个基本矩形。
- en: '![How it works...](img/3845_02_08.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3845_02_08.jpg)'
- en: When drawing rectangles, circles, ellipses and arcs you specify the start point
    (the bottom-left corner) and then the end point (top-right corner) of the bounding
    box surrounding the figure being drawn. In the case of rectangles and squares,
    the bounding box coincides with the figure. But in the case of circles, ellipses,
    and arcs the bounding box is of course larger.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制矩形、圆形、椭圆和弧时，你指定围绕要绘制的图形的边界框的起点（左下角）和终点（右上角）。在矩形和正方形的情况下，边界框与图形重合。但在圆形、椭圆和弧的情况下，边界框当然更大。
- en: With this recipe we have tried a new way of defining the shape of the rectangle.
    We give the start point as `[x_start, y_start]` and then we just state the width
    and height that we want as `[x_width, y_height]`. This way the end point is `[x_start
    + x_width, y_start + y_height]`. This way you only need to state what the new
    start point is if you want to create a multiplicity of rectangles having the same
    height and width.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个配方，我们尝试了一种新的定义矩形形状的方法。我们将起点指定为 `[x_start, y_start]`，然后我们只声明我们想要的宽度为 `[x_width,
    y_height]`。这样，终点就是 `[x_start + x_width, y_start + y_height]`。这样，如果你想创建具有相同高度和宽度的多个矩形，你只需要声明新的起点。
- en: There's more...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the next example, we use a common shape to draw a series of similar but different
    rectangles.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们使用一个常见的形状来绘制一系列相似但不同的矩形。
- en: Draw overlapping rectangles
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制重叠矩形
- en: Draw three overlapping rectangles by changing the numerical values defining
    their position, shape, and color variables.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改变定义其位置、形状和颜色变量的数值，绘制三个重叠的矩形。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: As before the instructions used in recipe 1 should be used.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，应使用配方1中使用的说明。
- en: Just use the name `3rectangles.py` when you write, save, and execute this program.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 写作、保存和执行此程序时，只需使用名称 `3rectangles.py`。
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The results are given in the next screenshot, which shows overlapping rectangles
    drawn in sequence.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在下一张屏幕截图给出，显示了按顺序绘制的重叠矩形。
- en: '![How it works...](img/3845_02_09.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3845_02_09.jpg)'
- en: The height and width of the rectangles have been kept the same but their start
    positions have been shifted to different positions. In addition a common-named
    variable called `kula` has been used as a common attribute in each `create-rectangle()`
    method. In between drawing each rectangle a new value is assigned to `kula` to
    give each successive rectangle a different color.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形的高度和宽度保持不变，但它们的起始位置已经移动到不同的位置。此外，一个名为`kula`的通用变量被用作每个`create-rectangle()`方法中的通用属性。在绘制每个矩形之间，`kula`被分配一个新的值，以使每个连续的矩形具有不同的颜色。
- en: Just a short comment on color here. Ultimately colors used in Tkinter code are
    number values with each numerical value specifying how much red, green, and blue
    to mix together. However, inside the Tkinter libraries are collections of romantically
    named colors like 'rose pink', 'lime green', and 'cornflower blue'. Each named
    color is assigned a specific numerical value that creates the color suggested
    by the name. Sometimes you will see some of these referred to as web colors. Sometimes
    you assign a name to a color only to have the Python interpreter reject it as
    unrecognized or use only shades of grey. This tricky topic is sorted out in [Chapter
    5](ch05.html "Chapter 5. The Magic of Color"),
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只是对颜色做一个简短的评论。最终，Tkinter代码中使用的颜色是数值，每个数值指定了混合多少红色、绿色和蓝色。然而，在Tkinter库中，有一些浪漫命名的颜色集合，如“玫瑰粉”、“草绿色”和“矢车菊蓝”。每个命名的颜色都被分配了一个特定的数值，以创建与名称建议的颜色。有时你会看到这些颜色被称为网络颜色。有时你给颜色起一个名字，但Python解释器会拒绝它，或者只使用灰色调。这个棘手的话题在[第5章](ch05.html
    "第5章。颜色的魔法")中得到了解决，
- en: There's more...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The way the attributes of drawn shapes have been specified may appear to be
    long winded. The programs would be shorter and neater if we just put the absolute
    numerical values of the parameters inside the methods that draw the functions.
    In the preceding example, we could have expressed the rectangles as:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 规定绘制形状属性的方式可能看起来很冗长。如果我们只是将参数的绝对数值放入绘制函数的方法中，程序将会更短、更整洁。在前面的例子中，我们可以将矩形表示为：
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are good reasons for specifying attribute values outside of the methods.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法之外指定属性值有很好的理由。
- en: It allows you to make reusable code that can be used repeatedly regardless of
    specific values of variables.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许你创建可重用的代码，可以重复使用，而不管变量的具体值如何。
- en: It makes the code self-explanatory when you use `x_start` instead of a number.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你使用`x_start`而不是数字时，这使得代码更加自解释。
- en: It lets you change the values of attributes in a controlled systematic manner.
    There are many examples of this later.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许你以受控的系统性方式改变属性值。后面有很多这样的例子。
- en: Draw concentric squares
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制同心正方形
- en: Draw three concentric squares by changing the numerical values defining its
    position, shape, and color variables.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改变定义位置、形状和颜色变量的数值，绘制三个同心正方形。
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The instructions used in recipe 1 should be used.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用菜谱1中使用的指令。
- en: Just use the name `3concentric_squares.py` when you write, save, and execute
    this program.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写、保存和执行这个程序时，只需使用名称`3concentric_squares.py`。
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The results are given in the next screenshot.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将在下一张屏幕截图给出。
- en: '![How it works...](img/3845_02_9A.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3845_02_9A.jpg)'
- en: In this recipe, we have specified where we want the geometric center of the
    rectangles located. This is at the position `[x_center, y_center]` in each instance.
    You need to do this whenever you want to draw shapes that are concentric. Generally
    it is always awkward to try and position the center of some drawn figure by manipulating
    the bottom-right corner. It does of course mean that there is a small amount of
    arithmetic in calculating where the bottom-left and top-right corners of the bounding
    box are but this is a small price to pay for the artistic freedom you gain. You
    only have to use this technique once and it is at your beck and call forever.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们指定了矩形的几何中心所在的位置。在每个实例中，这是 `[x_center, y_center]` 位置。每当你想要绘制同心形状时，你需要这样做。通常，通过操纵底右角来尝试定位某个绘制图形的中心总是很尴尬。当然，这也意味着在计算边界框的左下角和右上角时需要进行一些算术运算，但这是为了你获得的艺术自由而付出的微小代价。你只需使用这种技术一次，它就会永远听从你的召唤。
- en: A circle from an oval
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从椭圆形到圆形
- en: The best way to draw a circle is to use the Tkinter's `create_oval()` method
    from the canvas widget.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 画圆的最佳方式是使用Tkinter的`create_oval()`方法，该方法来自画布小部件。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The instructions used in the first recipe should be used.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 应使用第一个菜谱中使用的说明。
- en: Just use the name `circle_1.py` when you write, save, and execute this program.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 编写、保存和执行此程序时，只需使用名称 `circle_1.py`。
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: The results are given in the next screenshot, showing a basic circle.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将在下一张截图给出，显示一个基本的圆。
- en: '![How it works...](img/3845_02_10.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3845_02_10.jpg)'
- en: 'A circle is just an ellipse whose height and width are equal. In the example
    here, we have created a circle with the a very compact-looking statement: `canvas_1.create_oval(xy)`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 圆只是一个高度和宽度相等的椭圆。在这里的例子中，我们使用一个非常紧凑的语句创建了一个圆：`canvas_1.create_oval(xy)`。
- en: The compactness comes from the trick of specifying the dimension attributes
    as a Python tuple `xy = 20, 20, 420, 420` . It actually would be better in other
    instances to use a list such as `xy = [ 20, 20, 420, 420 ]` because a list allows
    you to alter the value of the individual member variables, whereas a tuple is
    an unchangeable sequence of constant values. Tuples are referred to as immutable.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 紧凑性来自于将维度属性指定为 Python 元组 `xy = 20, 20, 420, 420` 的技巧。实际上，在其他情况下，使用列表如 `xy =
    [ 20, 20, 420, 420 ]` 可能会更好，因为列表允许你更改单个成员变量的值，而元组是一个不可变的常量值序列。元组被称为不可变。
- en: There's more...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Drawing a circle as a special case of an oval is definitely the best way to
    draw circles. An inexperienced user of Tkinter may be tempted into using an arc
    to do the job. This is a mistake because as shown in the next recipe the behavior
    of the `create_arc()` method does not allow an unblemished circle to be drawn.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将圆作为椭圆的特殊情况绘制确实是绘制圆的最佳方式。Tkinter 的不熟练用户可能会被诱惑使用圆弧来完成这项工作。这是一个错误，因为如下一道菜谱所示，`create_arc()`
    方法的行为不允许绘制无瑕疵的圆。
- en: A circle from an arc
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从圆弧创建圆
- en: Another way to make a circle is to use the `create_arc()` method. This method
    may appear to be a more natural way to make circles but it does not allow you
    to quite complete the circle. If you do try to the circle disappears.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 制作圆的另一种方法是使用 `create_arc()` 方法。这种方法可能看起来是制作圆的更自然方式，但它不允许你完全完成圆。如果你尝试这样做，圆就会消失。
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The instructions used in the first example should be used.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 应使用第一个示例中使用的说明。
- en: Just use the name `arc_circle.py` when you write, save and execute this program.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 编写、保存和执行此程序时，只需使用名称 `arc_circle.py`。
- en: '[PRE12]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: The results are given in the next screenshot, showing a failed circle resulting
    from `create_arc()`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将在下一张截图给出，显示由于 `create_arc()` 导致的失败圆圈。
- en: '![How it works...](img/3845_02_11.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3845_02_11.jpg)'
- en: Generally the `create_arc()` method is not the best method of making complete
    circles because an attempt to go from 0 to 360 degrees results in the disappearance
    of the circle from view. Rather use the `create_oval()` method. However, there
    are occasions when you need the properties of the `create_arc()` method to be
    able to create a particular distribution of color. See the color wheel in the
    later chapters for a good example of this.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`create_arc()` 方法不是制作完整圆的最佳方法，因为从 0 度到 360 度的尝试会导致圆从视图中消失。相反，使用 `create_oval()`
    方法。然而，有时你需要 `create_arc()` 方法的属性来创建特定的颜色分布。参见后续章节中的颜色轮，这是一个很好的例子。
- en: There's more...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `create_arc()` method is well suited to the production of the pie charts
    favored in corporate presentations. The `create_arc()` method draws a segment
    of a circle with the ends of the arc joined to the center by radial lines. But
    if we just want to draw a circle those radial lines are unwanted.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_arc()` 方法非常适合制作企业演示中喜欢的饼图。`create_arc()` 方法绘制圆的一段，弧的端点通过径向线与中心相连。但如果我们只想画一个圆，那些径向线是不需要的。'
- en: Three arc ellipses
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三个圆弧椭圆
- en: Three elliptic arcs are drawn.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制了三个椭圆弧。
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The instructions used in recipe 1 should be used.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 应使用菜谱 1 中使用的说明。
- en: Just use the name `3arc_ellipses.py` when you write, save, and execute this
    program.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 编写、保存和执行此程序时，只需使用名称 `3arc_ellipses.py`。
- en: '[PRE13]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: The results are given in the next screenshot, showing well-behaved `create_arc()`
    ellipses.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将在下一张截图给出，显示行为良好的 `create_arc()` 椭圆。
- en: '![How it works...](img/3845_02_12.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3845_02_12.jpg)'
- en: The point to note here is that just like rectangles and ovals; the overall shape
    of the drawn object is governed by the shape of the bounding box. Start and finish
    (that is extent) angles are expressed in conventional degrees. Note that if trigonometry
    functions are going to be used then the circular measure has to be radians and
    not degrees.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的要点是，就像矩形和椭圆形一样；绘制对象的总体形状由边界框的形状决定。起始和结束（即范围）角度以传统度数表示。请注意，如果将要使用三角函数，则圆形度量必须是弧度而不是度数。
- en: There's more...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `create_arc()` method has been made user-friendly by requiring angular measurements
    in degrees rather than radians because most people can visualize degree amounts
    more easily than radians. But you need to know this is NOT the case with angular
    measurement in any function used by the math module. All the trigonometric functions
    like sine, cosine, and tangent use radian angular measurement which are only a
    minor convenience. The math module provides easy to use conversion functions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_arc()` 方法通过要求以度数而不是弧度进行角度测量，使其对用户更加友好，因为大多数人更容易可视化度数而不是弧度。但是，你需要知道，在
    math 模块使用的任何函数中，角度测量并不是这种情况。所有像正弦、余弦和正切这样的三角函数都使用弧度角度测量，这只是一个小的便利。math 模块提供了易于使用的转换函数。'
- en: Polygons
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多边形
- en: Draw a polygon. A polygon is a closed, multi-sided figure. These sides are made
    up of straight line segments. The specification of points is identical to that
    of multi-segment lines.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一个多边形。多边形是一个封闭的、多边形的图形。这些边由直线段组成。点的指定与多段线的指定相同。
- en: How to do it...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The instructions used in recipe 1 should be used.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用配方1中使用的说明。
- en: Just use the name `triangle_polygon.py` when you write, save, and execute this
    program.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写、保存和执行此程序时，只需使用名称 `triangle_polygon.py`。
- en: '[PRE14]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The results are given in the next screenshot, showing a polygon triangle.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将在下一张截图给出，显示一个多边形三角形。
- en: '![How it works...](img/3845_02_13.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/3845_02_13.jpg)'
- en: The `create_polygon()` method draws a sequence of straight line segments between
    the points specified as the arguments of the method. The final point is automatically
    joined to the first point to close the figure. As the figure is closed you can
    fill the interior with color.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_polygon()` 方法在作为方法参数指定的点之间绘制一系列直线段。最后一个点自动与第一个点相连以闭合图形。由于图形是闭合的，你可以用颜色填充内部。'
- en: A star polygon
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 星形多边形
- en: Draw a five-pointed star using named variables to specify the polygon attributes
    so that all the points or vertexes or tips of the star are defined with reference
    to a single start position. We refer to this position as the anchor position.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名变量来指定多边形属性，以使用单个起始位置定义星的所有点或顶点或尖端。我们称这个位置为锚点位置。
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The instructions used in recipe 1 should be used.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用配方1中使用的说明。
- en: Just use the name `star_polygon.py` when you write, save, and execute this program.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写、保存和执行此程序时，只需使用名称 `star_polygon.py`。
- en: '[PRE15]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The results are given in the next screenshot, a polygon star.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将在下一张截图给出，一个多边形星形。
- en: '![How it works...](img/3845_02_14.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/3845_02_14.jpg)'
- en: The first position of the star is the point `[x_anchor, y_anchor]`. All the
    other points are positive or negative additions to the position of the anchor
    point. This concept was introduced in the recipes for the three superimposed rectangles.
    This idea of drawing complicated shapes with reference to a point defined as a
    pair of named variables is very useful and is used extensively in the second half
    of this book.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 星的第一位置是点 `[x_anchor, y_anchor]`。所有其他点都是相对于锚点位置的正值或负值。这个概念在三个重叠矩形的配方中已经介绍过。这种以一对命名变量定义的点为参考绘制复杂形状的想法非常有用，并且在本书的后半部分被广泛使用。
- en: To improve code readability, the pairs of x and y variables defining each point
    are laid out vertically making use of the line continuation character \ (backslash).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高代码的可读性，定义每个点的 x 和 y 变量的成对排列是垂直的，利用了行续字符 \ (反斜杠)。
- en: Cloning and resizing stars
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆和调整星形大小
- en: A technique of simultaneous re-positioning and resizing a set of stars is shown.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 展示了一种同时重新定位和调整一组星形大小的技术。
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The instructions used in recipe 1 should be used.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用配方1中使用的说明。
- en: Just use the name `clone_stars.py` when you write, save, and execute this program.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写、保存和执行此程序时，只需使用名称 `clone_stars.py`。
- en: '[PRE16]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The results are given in the next screenshot, showing a string of stars with
    changing size.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个屏幕截图显示了大小变化的星串。
- en: '![How it works...](img/3845_02_15.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3845_02_15.jpg)'
- en: In addition to the variable and conveniently re-assigned anchor point of the
    polygon star we have now introduced an amplification factor that can change the
    size of any particular star without distorting it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 除了多边形星形的可变和方便重新分配的锚点外，我们还引入了一个放大因子，可以改变任何特定星形的大小而不会扭曲它。
- en: There's more...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The last three examples have illustrated some important and fundamental ideas
    used to draw pre-defined shapes in any size and in any position. It was important
    to separate these effects in different examples at this stage so that the separate
    actions are easy to understand. Later on, where the effects are used in combination,
    it becomes difficult to wrap your head around what is happening, particularly
    if extra transformations like rotation are involved. If we animate code that generates
    images it can be much easier to understand geometric relationships. By animate,
    I mean the display of successive images separated by short-time intervals similar
    to the way images in movies are manipulated. Such time-regulated animation, surprisingly,
    offers methods of examining the behavior of image-generating code in a way that
    is much more intuitive and clear to the human brain. This idea is developed in
    the later chapters.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个例子已经展示了用于绘制任何大小和位置的预定义形状的一些重要和基本思想。在这个阶段，将这些效果分开在不同的例子中是很重要的，这样单独的动作就更容易理解。稍后，当这些效果被组合使用时，理解正在发生的事情就变得困难，尤其是如果涉及到额外的变换，如旋转。如果我们对生成图像的代码进行动画处理，那么理解几何关系会容易得多。通过动画，我指的是以类似于电影中处理图像的方式，通过短时间间隔显示连续图像。这种时间调节的动画，出人意料地，提供了检查图像生成代码行为的方法，这对人类大脑来说更加直观和清晰。这个想法在后面的章节中得到了发展。
