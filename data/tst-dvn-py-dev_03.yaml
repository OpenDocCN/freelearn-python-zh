- en: Chapter 3. Code Smells and Refactoring
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 代码异味和重构
- en: In the previous chapter, we went through the TDD cycle in a little more detail.
    In this chapter, we will look at the related concept of code smells and refactoring.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们更详细地介绍了TDD周期。在本章中，我们将探讨相关的概念：代码异味和重构。
- en: One of the biggest advantages of following a test-driven development process
    is that the tests that we write are always around to make sure that we don't break
    anything. This gives us a safety net to tinker with the code and make sure that
    it is easy to read, easy to maintain, and well written. Without tests, we always
    have a nagging doubt about whether we are about to break something, and more often
    than not we decide to leave things alone. This leads to the code decaying over
    time, until it is such a mess that no one wants to touch it anymore. The result
    is that it takes longer to implement new features, not only because the design
    is a mess, but also because we have to follow it with extensive testing to make
    sure none of the existing functionality has broken.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循测试驱动开发过程的最大优点之一是，我们编写的测试总是存在，以确保我们不会破坏任何东西。这为我们提供了一个安全网，可以随意修改代码，并确保代码易于阅读、易于维护且编写良好。没有测试，我们总是对即将破坏某物感到担忧，而且往往决定什么都不做。这导致代码随着时间的推移而退化，直到它变得如此混乱，以至于没有人愿意再触碰它。结果是，实现新功能所需的时间更长，这不仅因为设计混乱，而且因为我们必须进行广泛的测试以确保现有功能没有破坏。
- en: 'For this reason, it is vital that we do not skip the third step of the TDD
    cycle: refactoring.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们绝对不能跳过TDD周期的第三步：重构。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This code for this chapter starts at the point after the exercise in the previous
    chapter has been completed. See the [Appendix A](apa.html "Appendix A. Answers
    to Exercises"), *Answers to Exercises* for the changes done in the exercise, or
    download the starting point of the code for this chapter from [https://github.com/siddhi/test_driven_python](https://github.com/siddhi/test_driven_python)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码从上一章的练习完成后的点开始。参见[附录A](apa.html "附录 A. 练习答案")，*练习答案*，了解练习中做出的更改，或者从[https://github.com/siddhi/test_driven_python](https://github.com/siddhi/test_driven_python)下载本章代码的起点。
- en: A dual crossover moving average
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双交叉移动平均
- en: In the previous chapter, we wrote a method to check for an increasing trend.
    We will take that example forward in this chapter by developing a method to check
    for a dual crossover moving average.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们编写了一个检查上升趋势的方法。在本章中，我们将通过开发一个检查双交叉移动平均的方法来继续那个例子。
- en: A **dual crossover moving average** (**DMAC**) is a simple indicator to show
    the short-term trend of a stock compared to a long-term trend.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**双交叉移动平均**（**DMAC**）是一个简单的指标，用于显示股票的短期趋势与长期趋势相比。'
- en: 'The following figure shows how the DMAC works:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了DMAC的工作原理：
- en: '![A dual crossover moving average](img/3125_03_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![双交叉移动平均](img/3125_03_01.jpg)'
- en: Consider a stock, with closing prices as shown above. First, we calculate two
    moving average trends. The short-term (5-day) moving average is calculated by
    taking the moving average for a short number of days. The long-term moving average
    is calculated by taking the moving average for a longer number of days, for example
    the moving average of the last 10 days.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个股票，其收盘价如上所示。首先，我们计算两个移动平均趋势。短期（5天）移动平均是通过计算较短天数内的移动平均得到的。长期移动平均是通过计算较长天数内的移动平均得到的，例如最后10天的移动平均。
- en: When we plot the values of the long- term and short-term moving average graphs,
    we see that at certain points, the short-term graph crosses from below the long-term
    to above the long-term graph. This point represents a **Buy Signal**. At other
    points, the short-term crosses from above to below. This point represents a **Sell
    Signal**. At all other points, nothing should be done.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们绘制长期和短期移动平均图时，我们会看到在某些点上，短期图从低于长期图交叉到高于长期图。这一点代表一个**买入信号**。在其他点上，短期图从上方交叉到下方。这一点代表一个**卖出信号**。在所有其他点上，不应采取任何行动。
- en: Implementing the dual crossover moving average
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现双交叉移动平均
- en: 'What we are going to do is to implement a method `get_crossover_signal` for
    the `Stock` class. The following are the requirements for the method:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现一个名为`get_crossover_signal`的方法，用于`Stock`类。以下是该方法的以下要求：
- en: The method takes a date as a parameter, and returns if there is any crossover
    on that date
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法接受一个日期作为参数，并返回该日期是否有任何交叉。
- en: The method should return `1` if there is a **Buy Signal** (5-day moving average
    crosses 10-day moving average from below to above on that date)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在**买入信号**（5天移动平均线从下方交叉到上方），则该方法应返回1
- en: The method should return –1 if there is a **Sell Signal** (5-day moving average
    crosses 10-day moving average from above to below on that date)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在**卖出信号**（5天移动平均线从上方交叉到下方），则该方法应返回-1
- en: If there is no crossover, then the method returns 0 (**neutral** signal)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有交叉，则该方法返回0（**中性信号**）
- en: The method should only take into account the closing price (the last update
    for the date), and not the opening or intermediate prices for the date
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法应仅考虑收盘价（该日期的最后更新），而不是该日期的开盘价或中间价
- en: If there are no updates for the date, then the method should use the previous
    closing price
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果该日期没有更新，则该方法应使用前一天的收盘价
- en: If there is not enough data to calculate the long-term moving average (we need
    closing prices for at least 11 days), then the method should return 0
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有足够的数据来计算长期移动平均数（我们需要至少11天的收盘价），则该方法应返回0
- en: Identifying code smells
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别代码异味
- en: The following is an implementation that passes the tests (for a listing of the
    test cases, download the code for this chapter from [https://github.com/siddhi/test_driven_python](https://github.com/siddhi/test_driven_python)).
    The implementation uses the `timedelta` class from the `datetime` module, so you'll
    have to import it at the top of the file to get it to work.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个通过测试的实现（要查看测试用例列表，请从[https://github.com/siddhi/test_driven_python](https://github.com/siddhi/test_driven_python)下载本章的代码）。该实现使用了`datetime`模块中的`timedelta`类，因此您需要在文件顶部导入它才能使其工作。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While the above code implements the functionality, it is totally unreadable.
    This is what happens when the refactoring step is skipped. It will take a long
    time to understand when we come back to this code after some months to fix a bug
    or add functionality. Therefore, refactoring regularly is crucial.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然上述代码实现了功能，但它完全无法阅读。这就是在跳过重构步骤时会发生的情况。几个月后回来修复错误或添加功能时，理解它将花费很长时间。因此，定期重构至关重要。
- en: 'What are the problems you can find with this code? The following are some problems:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你能在这段代码中找到哪些问题？以下是一些问题：
- en: '**Long method**: Long methods and classes are difficult to read and understand.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长方法**：长方法和类难以阅读和理解。'
- en: '**Unclear naming**: For instance, what is variable `cpl` supposed to be?'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不清晰的命名**：例如，变量`cpl`应该代表什么？'
- en: '**Complex conditionals**: The `if` conditions are quite complicated, and it
    is unclear what exactly they are checking for.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的条件语句**：`if`条件相当复杂，不清楚它们具体检查了什么。'
- en: '**Bad comments**: None of the comments are descriptive and, in addition, two
    comments both say `BUY signal`. Obviously, one of them is wrong.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**糟糕的注释**：所有注释都没有描述性，而且另外两个注释都说了`买入信号`。显然，其中一个是错误的。'
- en: '**Magic constants**: In various places, the numbers 5, 10, –11, and so on are
    hard coded. Suppose we decide to change the long-term moving average to use a
    20-day period, then where are the places we need to change? What is the possibility
    that we may miss one?'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**魔法常数**：在多个地方，数字5、10、-11等被硬编码。假设我们决定将长期移动平均数改为使用20天周期，那么我们需要更改哪些地方？我们可能会遗漏一个更改的可能性有多大？'
- en: '**Code duplication**: Both the conditionals seem almost the same, with a very
    minor difference.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码重复**：这两个条件似乎几乎相同，只有非常小的差异。'
- en: All these problems are generally referred to as code smells. **Code smells**
    are simple patterns that can be easily spotted and refactored to make code better.
    Sometimes, code smells can be rectified by doing a few simple changes. Other times,
    it may lead up to a change of the design itself.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题通常被称为代码异味。**代码异味**是简单且易于发现的模式，可以通过重构来改进代码。有时，通过进行一些简单的更改就可以修正代码异味。有时，它甚至可能导致设计本身的改变。
- en: Refactoring
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码重构
- en: '**Refactoring** is the process of cleaning up code or changing a design using
    a sequence of very small steps. No new functionality is added or removed during
    the refactoring process. The aim of refactoring is to make the code better by
    eliminating some code smell. There are many types of refactoring, from the extremely
    simple going up to much more complex refactorings. Let us apply some of these
    to the code above.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**重构**是通过一系列非常小的步骤来清理代码或更改设计的过程。在重构过程中不添加或删除任何新功能。重构的目的是通过消除一些代码异味来使代码变得更好。有各种各样的重构，从极其简单的到更复杂的重构。让我们将这些应用于上面的代码。'
- en: The Rename Variable and Rename Method refactorings
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重命名变量和重命名方法的重构
- en: These two are probably the two simplest refactorings. The names are self explanatory—the
    refactoring is to rename a variable or a method. Although simple, they are very
    important because poor variable and method names are very common code smells.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种可能是最简单的重构。名称本身就说明了问题——重构是将变量或方法重命名。虽然简单，但它们非常重要，因为糟糕的变量和方法名称在代码中非常常见。
- en: 'The following are the steps to apply the **Rename Variable** refactoring:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将**重命名变量**重构应用于代码的步骤：
- en: Run all the tests to make sure they are passing.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行所有测试以确保它们通过。
- en: Change the name of the variable, and make the change in all the places where
    it is being used.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变变量的名称，并在所有使用该变量的地方进行更改。
- en: Run all the tests again to make sure we didn't break anything.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行所有测试以确保我们没有破坏任何东西。
- en: 'The **Rename Method** refactoring follows the following sequence of steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**重命名方法**重构遵循以下步骤：'
- en: Run all the tests to make sure they are passing.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行所有测试以确保它们通过。
- en: Change the name of the method, and make the change in all the places where this
    method is being called.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变方法名称，并在所有调用此方法的地方进行更改。
- en: Run all the tests again.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行所有测试。
- en: 'Let us now apply the Rename Variable refactoring to our code. The `cpl` variable
    holds the list of the closing prices of the stock for the last 11 days. We should
    rename this to something more descriptive, like `closing_price_list`. Let us do
    this now:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将重命名变量重构应用于我们的代码。`cpl`变量保存了过去11天股票的收盘价列表。我们应该将其重命名为更具描述性的名称，例如`closing_price_list`。我们现在就来做这件事：
- en: Run the tests (a listing of the test cases is given in the *Exercise* section
    at the end of this chapter).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试（测试用例列表在本书末尾的*练习*部分给出）。
- en: Rename `cpl` to `closing_price_list` at all places in the method.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法的所有地方将`cpl`重命名为`closing_price_list`。
- en: Run the tests again. If there are any places where we forgot to rename the variable,
    then the tests will fail and we can fix it and run the tests again.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试。如果有任何地方我们忘记重命名变量，那么测试将失败，我们可以修复它并再次运行测试。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Tests as a safety net**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试作为安全网**'
- en: Having a solid set of tests is critical before we do refactoring. This is because
    tests give us the confidence that we haven't broken anything during the refactoring.
    We will be running the tests multiple times during a refactoring as we proceed
    from step to step.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行重构之前，拥有一个坚实的测试集是至关重要的。这是因为测试让我们有信心在重构过程中没有破坏任何东西。在重构过程中，我们将多次运行测试，因为我们从一步到下一步进行。
- en: Let us now apply the Rename Variable refactoring to our code. The `cpl` variable
    holds the list of the closing prices of the stock for the last eleven days. We
    should rename this to something more descriptive, like `closing_price`_list.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将重命名变量重构应用于我们的代码。`cpl`变量保存了过去11天股票的收盘价列表。我们应该将其重命名为更具描述性的名称，例如`closing_price_list`。
- en: 'A quick search and replace and the code now looks like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 快速搜索和替换后，代码现在看起来是这样的：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Commenting Styles
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释风格
- en: Next, let us look at the comments in the method. Generally speaking, comments
    are a code smell because they indicate that the code itself is not easy to read.
    Some comments, like the one in the code above, simply repeat what the code is
    doing. Often, we put in a comment like this because it is easier to do so rather
    than clean up the code. So, wherever we see comments, it is worthwhile exploring
    if a code cleanup might be required. The other problem with comments is that they
    can very easily go out of sync with the code. It is quite common that when we
    come back in the future to implement a new feature, we don't update the comments.
    It leads to a great deal of confusion when we try to understand code where the
    comments are not in sync with the code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看方法中的注释。一般来说，注释是代码的坏味道，因为它们表明代码本身不易读。一些注释，如上面的代码中的注释，只是简单地重复了代码正在做什么。我们经常添加这样的注释，因为这样做比清理代码要容易。所以，无论何时我们看到注释，都值得探索是否需要代码清理。注释的另一个问题是它们可以非常容易地与代码不同步。当我们未来回来实现新功能时，我们没有更新注释是很常见的情况。当我们试图理解注释与代码不同步的代码时，这会导致大量的困惑。
- en: 'not all comments are bad. Helpful comments explain *why* a certain piece of
    code has been written that way. This is the information that cannot be deduced
    by just reading the code. Consider the following examples:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有注释都是不好的。有用的注释解释了为什么某个代码片段要以这种方式编写。这是仅通过阅读代码无法推断出的信息。考虑以下示例：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first example shows a comment that just repeats the code below it. There
    is no value added here by the comments. A cursory glance at the code will tell
    the reader exactly what the comment says.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例显示了一个仅仅重复下面代码的注释。这里注释没有增加任何价值。粗略地看一下代码，读者就能确切地知道注释在说什么。
- en: The second example shows a much better comment. This comment doesn't repeat
    the code, but instead explains the rationale behind why this particular piece
    of code exists.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例显示了一个更好的注释。这个注释没有重复代码，而是解释了为什么存在这段特定代码的合理性。
- en: In the third example, the hardcoded numbers have been replaced by constants.
    In this example, the code is self-explanatory, so we can get rid of the comment
    altogether.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个示例中，硬编码的数字已经被常数替换。在这个例子中，代码是自我解释的，因此我们可以完全去掉注释。
- en: The three examples show the ideal process for writing comments. First, we see
    if we can make the code clearer in such a way that we don't need comments. If
    that is not possible, then write a comment around why the code has been written
    in a particular way. If you are tempted to write a comment about what a piece
    of code does, then stop and think about refactoring the code instead.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 三个示例展示了编写注释的理想过程。首先，我们看看是否可以通过某种方式使代码更清晰，以至于我们不需要注释。如果这不可能，那么就写一个注释，解释为什么代码要以这种方式编写。如果你倾向于写一个关于代码片段做什么的注释，那么请停下来思考是否需要重构代码。
- en: Replace Magic Literals with Constants
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将魔法数字替换为常数
- en: 'As we saw in the previous example, replacing hardcoded values with constants
    accomplishes two things: first, should we need to change the values, we can do
    it at a single place, and, second, the constants are more descriptive and help
    make the code more readable.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个示例所示，用常数替换硬编码的值可以完成两件事：首先，如果我们需要更改这些值，我们可以在一个地方完成更改，其次，常数更具描述性，有助于使代码更易读。
- en: 'The process for this refactoring is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重构的过程如下：
- en: Run the tests.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。
- en: Create the constant and replace one hardcoded value with the constant.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建常数，并用常数替换一个硬编码的值。
- en: Run the tests again.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试。
- en: Repeat steps 2 and 3 until all values are replaced with the constant.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤2和3，直到所有值都被常数替换。
- en: 'Our method uses the timespan for the long-term moving average and the short-term
    moving average in all the calculations. We can create constants to identify these
    two values like the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法在所有计算中使用长期移动平均和短期移动平均的时间跨度。我们可以创建常数来标识这两个值，如下所示：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can then use the constants in our method like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们方法中的常数，如下所示：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Apart from the constants used in the calculation, we can also replace the return
    value with more descriptive `Enum` class. This is a new feature in Python 3.4
    that we can use here.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于计算的常数外，我们还可以用更具描述性的`Enum`类替换返回值。这是Python 3.4中的一个新特性，我们可以在这里使用它。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While `Enum` is a part of the standard library in Python 3.4, it has also been
    backported to earlier versions of Python. Download and install the enum34 package
    from PyPy if you are using an older Python version.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Enum`是Python 3.4标准库的一部分，但它也被回滚到更早的Python版本。如果你使用的是较旧的Python版本，请从PyPy下载并安装enum34包。
- en: 'To do this, we first import `Enum` as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们首先按照以下方式导入`Enum`：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We then create the enumeration class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建枚举类。
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we can replace the return value with the enumeration:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以用枚举替换返回值：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this change, we can also remove the comments above the return values, as
    the constants are descriptive enough.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，我们还可以删除返回值上面的注释，因为常量已经足够描述性。
- en: The Extract Method refactoring
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取方法重构
- en: 'Another way to make comments redundant is to take the code and put it in a
    method with a descriptive name. This also helps break down a long method into
    smaller methods that are easier to understand. The **Extract Method** refactoring
    is used for this purpose. The steps for the Extract Method refactoring are as
    follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使注释冗余的方法是将代码放入一个具有描述性名称的方法中。这也帮助将长方法分解成更小的、更容易理解的方法。**提取方法**重构用于此目的。提取方法重构的步骤如下：
- en: Run the existing tests.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行现有的测试。
- en: Identify the variables in the code block that we want to refactor, that are
    also used before the code block. These variables will need to be passed into our
    method as parameters.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别代码块中我们想要重构的变量，这些变量也在代码块之前使用。这些变量需要作为参数传递到我们的方法中。
- en: Identify the variables in the code block that are used after the code block.
    These variables will be the return values from our method.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别代码块中在代码块之后使用的变量。这些变量将是我们方法返回的值。
- en: Create a method with a descriptive name that takes in the above variables as
    a parameter.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有描述性名称的方法，该方法接受上述变量作为参数。
- en: Make the new method return the appropriate values that are needed after the
    code block.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使新方法返回代码块之后需要的适当值。
- en: Move the code block into the method. Replace the lines with a call to the method.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码块移动到方法中。用对方法的调用替换这些行。
- en: Run the tests again.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试。
- en: 'Let us apply this refactoring to our method. This loop is used to create a
    list of closing prices for each of the previous eleven days:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这种重构应用到我们的方法中。这个循环用于为前十一天的每一天创建一个收盘价列表：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can extract this code into a separate method. Here are the steps to do so:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这段代码提取到一个单独的方法中。以下是这样做的方法：
- en: 'First, we create a new method called `_get_closing_price_list`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`_get_closing_price_list`的新方法：
- en: '[PRE9]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method takes two parameters because those values are used in the loop.
    Currently they are local variables, but once we extract the loop into this method,
    we will need to pass those values to the method.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个方法接受两个参数，因为那些值在循环中使用。目前它们是局部变量，但一旦我们将循环提取到这个方法中，我们就需要将这些值传递给方法。
- en: 'We now cut the loop code from the main method and paste it into this new method:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将循环代码从主方法中剪切并粘贴到这个新方法中：
- en: '[PRE10]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At this point, the loop still refers to the `NUM_DAYS` constant that was a
    local variable. We need to change this to use the value from the parameter. We
    also make this method return the `closing_price_list`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，循环仍然引用的是`NUM_DAYS`常量，这是一个局部变量。我们需要将其更改为使用参数的值。我们还将此方法返回`closing_price_list`：
- en: '[PRE11]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we put in a call to this method where the loop code originally was
    used:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将调用此方法的地方放在循环代码原本的位置：
- en: '[PRE12]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now we run the tests to make sure we didn't break anything. They should all
    pass.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们运行测试以确保我们没有破坏任何东西。它们都应该通过。
- en: 'Our code after refactoring looks like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后的代码看起来像这样：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Replace Calculation with Temporary Variable
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换计算为临时变量
- en: Let us now turn our attention to the conditional statements where we perform
    the checks for crossover.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向执行交叉检查的条件语句。
- en: The conditional is messy because we are doing many calculations and comparisons
    at the same time, which is hard to follow. We can clean this up by using temporary
    variables to store the calculation values and then using the variables in the
    conditionals.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句很混乱，因为我们同时进行许多计算和比较，这很难跟踪。我们可以通过使用临时变量来存储计算值，然后在条件中使用这些变量来清理它。
- en: In this refactoring, we are not using the variables for any purpose other than
    just being able to give a name to the calculations, and thereby making the code
    easier to read.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个重构中，我们并没有使用变量来达到任何目的，只是给计算一个名字，从而使代码更容易阅读。
- en: 'The following is how we do this refactoring:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何进行这个重构的：
- en: Run the tests.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。
- en: Take the calculation and assign it to a variable. Make the name of the variable
    explain the purpose of the calculation.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将计算赋值给一个变量。变量的名称应该解释计算的目的。
- en: Use the variable in the conditional.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在条件中使用变量。
- en: Run the tests.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。
- en: 'Let us extract the four calculations in our conditional into variables:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将条件语句中的四个计算提取到变量中：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can then use these variables in the conditional:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后可以在条件中使用这些变量：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Extract Conditional to Method
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取条件到方法
- en: We can now turn our attention to the conditional. It isn't very clear as to
    what comparison is happening in the conditional. One way to handle this is to
    continue with the Replace Calculation with Temporary Variable refactoring above.
    Another option is to apply the **Extract Conditional to Method** refactoring.
    In this refactoring, we take the comparison and move it into its own method with
    a descriptive name.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将注意力转向条件语句。在条件语句中并不清楚正在发生什么比较。一种处理方法是在上面的重构中继续使用**用临时变量替换计算**。另一种选择是应用**将条件提取到方法中**的重构。在这个重构中，我们将比较移动到它自己的方法中，并给它一个描述性的名称。
- en: 'The following are the steps for the refactoring:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对重构的步骤：
- en: Run the tests.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。
- en: Take the entire conditional and move it into a method.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将整个条件语句移动到方法中。
- en: Call the method where the conditional was before.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在条件之前调用该方法。
- en: Run the tests.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。
- en: 'Here is the conditional code that we currently have:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是目前我们拥有的条件代码：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'First we apply the Replace Calculation with Temporary Variable refactoring
    and extract the moving average calculation into a named variable:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应用**用临时变量替换计算**的重构，并将移动平均计算提取到一个命名变量中：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next the comparisons being made in the conditional can be extracted to methods
    like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，可以将条件语句中进行的比较提取到像这样的方法中：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We now call the method in the `if` statement, passing in our temporary variables
    as parameters:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在`if`语句中调用该方法，将我们的临时变量作为参数传入：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is what the method looks like after the last few refactorings:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是经过最后几次重构后的方法看起来像这样：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The DRY principle
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DRY原则
- en: One of the most important principles in writing good code is the DRY principle.
    **DRY** stands for **Don't Repeat Yourself**. If you ever find yourself writing
    the same (or similar) code in multiple places, there is a good chance that a refactoring
    will allow you to put that logic in once place and call it from each place that
    it is needed. It could be something as simple as moving the code into a function
    and calling the function from each place, or it could be a more complex refactoring.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写良好代码的重要原则中，DRY原则是最重要的。**DRY**代表**不要重复自己**。如果你发现自己多次（或相似）在多个地方编写相同的代码，那么重构将允许你将这种逻辑放在一个地方，并在需要的地方调用它。这可能只是将代码移动到函数中，并在每个地方调用该函数，或者可能是一个更复杂的重构。
- en: 'Take another look at the conditionals that we just refactored:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 再看看我们刚刚重构的条件语句：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can see that they are almost the same. The only difference being that the
    comparisons are the other way around. Is there a way we can eliminate this code
    duplication?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它们几乎相同。唯一的区别是比较的顺序相反。我们能否消除这种代码重复？
- en: 'One way is to change the order of the comparators in the first method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是在第一个方法中改变比较器的顺序：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Except for parameter names, it is now identical to the second method:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除了参数名称外，现在它与第二个方法完全相同：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can now merge both methods into one:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将两个方法合并为一个：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'and call this single method in both conditionals:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 并在两个条件语句中调用这个单一的方法：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice how the order of the short and long term parameters are exchanged between
    the two calls. The first checks that the short term moving average crosses the
    long term moving average from down to up. The second checks that the long term
    moving average crosses the short term moving average from down to up—this is the
    same as checking that the short term crosses from above to below. By doing the
    same check in both cases (below to above) and exchanging the parameters, we are
    able to eliminate the duplication in the code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意两个调用之间短期和长期参数的顺序是如何交换的。第一个检查短期移动平均线从下向上穿过长期移动平均线。第二个检查长期移动平均线从下向上穿过短期移动平均线——这等同于检查短期从上方穿过下方。通过在两种情况下（从下到上）执行相同的检查并交换参数，我们能够消除代码中的重复。
- en: Single Responsibility Principle
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: At this point, we have performed a number of local refactorings. These are refactorings
    such as moving code into or out of methods, pulling calculations into variables,
    and so on. These refactorings improve the readability of the code, but are mostly
    localized changes and don't affect the larger design.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经执行了一系列局部重构。这些重构包括将代码移动到或从方法中，将计算拉入变量中等。这些重构提高了代码的可读性，但大多是局部更改，不会影响更大的设计。
- en: From a design perspective, the most common reason that classes get cluttered
    is due to not following the **Single Responsibility Principle** (**SRP**). What
    this principle states is that a class should have a single, clear, coherent purpose.
    A class that tries to do too many different things is an indicator of a poor design.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从设计角度来看，导致类变得杂乱的最常见原因是没有遵循**单一职责原则**（**SRP**）。这个原则表明，一个类应该有一个单一、明确、连贯的目的。试图做太多不同事情的课程是设计不佳的指标。
- en: 'Let us review whether the `Stock` class meets this criterion. The core responsibilities
    of the class are as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下`Stock`类是否符合这一标准。该类的基本职责如下：
- en: Keeping a history of price updates for a particular stock
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为特定股票保存价格更新的历史记录
- en: Checking whether the stock meets certain conditions
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查股票是否符合某些条件
- en: 'In addition, the class is also performing the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该类还执行以下操作：
- en: Calculating a list of closing prices per day (or, more generally, code for handling
    a time series)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算每天的收盘价列表（或更一般地，处理时间序列的代码）
- en: Calculating the moving average for various points in time
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算不同时间点的移动平均数
- en: The latter two responsibilities should be offloaded to a separate class.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 后两个责任应该分配给一个单独的类。
- en: Extract Class
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取类
- en: The **Extract Class** refactoring is used to take some functionality and move
    it into a separate class. This is easily the most commonly used design refactoring.
    It is an ideal refactoring to apply when we see that a class has become saddled
    with multiple responsibilities.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**提取类**重构用于将一些功能移动到单独的类中。这可能是最常用的设计重构。当我们看到某个类承担了多个责任时，这是一个理想的重构应用场景。'
- en: 'The following is what we want to do:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们想要做的事情：
- en: Move all code relating to managing a time series into a `TimeSeries` class
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有与时间序列管理相关的代码移动到`TimeSeries`类中
- en: Move all code relating to moving averages into a `MovingAverage` class
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有与移动平均数相关的代码移动到`MovingAverage`类中
- en: 'The steps for performing an Extract Class refactoring are as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 执行提取类重构的步骤如下：
- en: Run all tests.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行所有测试。
- en: Create a new class.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新类。
- en: Instantiate the new class in the `__init__` scope, or pass it in as a parameter.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__init__`作用域中实例化新类，或者将其作为参数传递。
- en: Move one method from the source class to the new class. If the code to be moved
    is not in a method, then extract it to a local method using the Extract Method
    refactoring first.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个方法从源类移动到新类中。如果要移动的代码不在方法中，则首先使用提取方法重构将其提取到局部方法中。
- en: Change all local calls to call the method in the new class instance.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有局部调用更改为调用新类实例中的方法。
- en: Run the tests again.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试。
- en: Repeat steps 3 to 5 for each piece of functionality to be moved.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个要移动的功能重复步骤3到5。
- en: Let us now extract all the time series related functionality into a `TimeSeries`
    class.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将所有与时间序列相关的功能提取到`TimeSeries`类中。
- en: First, we create a file called `timeseries.py` in the `stock_alerter` directory.
    We'll create our class here.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`stock_alerter`目录中创建一个名为`timeseries.py`的文件。我们将在其中创建我们的类。
- en: 'Next, we''ll create an empty `TimeSeries` class in `timeseries.py` as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`timeseries.py`中创建一个空的`TimeSeries`类，如下所示：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So far, we''ve been using `price_history`, a list, to store the price history.
    We now want to store all this information in our `TimeSeries` class. We''ll make
    this transition step by step. The first step is to add an instance variable to
    the `Stock` class as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用 `price_history`，一个列表，来存储价格历史。我们现在想将所有这些信息存储在我们的 `TimeSeries` 类中。我们将逐步进行这个过渡。第一步是在
    `Stock` 类中添加一个实例变量，如下所示：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Remember to import `TimeSeries` at the top of the file before making this change.
    Now we can migrate the update functionality into the `TimeSeries` class as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在做出这个更改之前在文件顶部导入 `TimeSeries`。现在我们可以将更新功能迁移到 `TimeSeries` 类中，如下所示：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once migrated, we make a call to the new method in the `Stock` class as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦迁移，我们就在 `Stock` 类中调用新的方法，如下所示：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice how we have just added the call to the timeseries, but we haven't removed
    the old call that updates `self.price_history`. This is because this list is still
    used directly in other places. By not removing this line yet, we don't break any
    functionality. All the tests still pass. Once we are done with the migration,
    we'll come back and remove this line.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们刚刚添加了对 timeseries 的调用，但我们还没有移除更新 `self.price_history` 的旧调用。这是因为这个列表仍然在其他地方直接使用。通过不立即删除此行，我们不会破坏任何功能。所有测试仍然通过。一旦我们完成迁移，我们将回来删除此行。
- en: 'Now we need to change the price and `is_increasing_trend` methods to stop using
    `self.price_history` and start using the time series class. This is what they
    look like currently:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要更改价格和 `is_increasing_trend` 方法，以停止使用 `self.price_history` 并开始使用时间序列类。它们目前看起来是这样的：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Our next step is to add a dictionary access method to `TimeSeries`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是向 `TimeSeries` 添加一个字典访问方法：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This enables us to change the `Stock.price` and `Stock.is_increasing_trend`
    methods to use the `TimeSeries` class instead of accessing `self.price_history`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够将 `Stock.price` 和 `Stock.is_increasing_trend` 方法更改为使用 `TimeSeries` 类而不是访问
    `self.price_history`。
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We should run the tests again to check that the new implementation of `Stock.price`
    and `Stock.is_increasing_trend` still work as expected. All 21 tests should still
    be passing.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该再次运行测试，以检查 `Stock.price` 和 `Stock.is_increasing_trend` 的新实现是否仍然按预期工作。所有
    21 个测试都应该仍然通过。
- en: Move Method to Class
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将方法移动到类中
- en: There is one final place where `self.price_history` is used, and this is in
    the `_get_closing_price_list` method. Instead of replacing the usage of `self.price_history`,
    we are instead going to move the whole method into the `TimeSeries` class. This
    is the **Move Method to Class** refactoring.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `self.price_history` 被使用的一个最终位置，是在 `_get_closing_price_list` 方法中。我们不是替换 `self.price_history`
    的使用，而是将整个方法移动到 `TimeSeries` 类中。这是 **将方法移动到类中** 的重构。
- en: 'To do this refactoring, we will do the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行这个重构，我们将执行以下操作：
- en: Run the tests.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。
- en: Move the method to the target class. If the method uses any instance variables,
    then we need to add them to the parameter list.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将方法移动到目标类。如果方法使用任何实例变量，那么我们需要将它们添加到参数列表中。
- en: Replace all calls to use the method in the other class, adding any new parameters
    that need to be passed.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换所有调用以使用其他类中的方法，并添加任何需要传递的新参数。
- en: Some callers may not have a reference to the target class. In that case, we
    need to instantiate the object in the `__init__` scope or pass a reference to
    it as a parameter.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些调用者可能没有目标类的引用。在这种情况下，我们需要在 `__init__` 范围内实例化对象，或者将其引用作为参数传递。
- en: Run the tests again.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试。
- en: Usually, at the end of this refactoring, we need to do some further local refactoring
    in the target class. So, some of those extra parameters that were added might
    need to be moved elsewhere or changed. Some parameters might be added to the initializer
    and callers modified appropriately.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在这个重构的末尾，我们需要在目标类中进行一些进一步的局部重构。因此，一些额外添加的参数可能需要移动到其他地方或进行更改。一些参数可能被添加到初始化器中，调用者相应地进行修改。
- en: The following example will make this clearer. Let us start by moving the `_get_closing_price_list`
    method to the `TimeSeries` class. Since this will be a public method in the new
    class, we can drop the initial underscore in the name.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将使这一点更加清晰。让我们首先将 `_get_closing_price_list` 方法移动到 `TimeSeries` 类中。由于这将是新类中的一个公共方法，我们可以从名称中删除初始的下划线。
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice the extra `price_history` parameter that we added to this method. The
    original method used the `self.price_history` variable. Since this is an instance
    variable of the `Stock` class, it is not available in the `TimeSeries` class.
    To fix that, we pass in the `price_history` as a parameter and use this in the
    method.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们添加到这个方法中的额外`price_history`参数。原始方法使用了`self.price_history`变量。由于这是`Stock`类的实例变量，它不在`TimeSeries`类中可用。为了解决这个问题，我们传入`price_history`作为参数并在方法中使用它。
- en: 'The call from the `Stock` class now looks like the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`Stock`类的调用现在如下所示：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We run the tests at this point to validate that all the tests are still passing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个时候运行测试以验证所有测试是否仍在通过。
- en: 'Once we verify that the tests are passing, we can now go back and remove the
    extra parameter that we added. The `TimeSeries` class has its own instance variable
    `self.series` that contains the price history. We can use this variable in the
    method and remove the extra parameter. The method now becomes as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们验证测试通过，我们现在可以回过头来删除我们添加的额外参数。`TimeSeries`类有自己的实例变量`self.series`，其中包含价格历史。我们可以在方法中使用这个变量并删除额外参数。现在该方法如下：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And the call becomes as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 调用如下所示：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run the tests again to check that everything is working, as shown in the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试以检查一切是否正常，如下所示：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Oops! Looks like some of the tests are failing!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！看起来有些测试失败了！
- en: 'The problem is that the updates stored in `self.price_history` use the `price`
    attribute to refer to the price, but the `timeseries` module calls it value. So,
    we need to change the places where we calculate the moving average and replace
    price with value. With that change, the tests pass again and our moving average
    calculation now looks like the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于存储在`self.price_history`中的更新使用`price`属性来引用价格，但`timeseries`模块将其称为value。因此，我们需要更改计算移动平均的地方，并将价格替换为value。有了这个更改，测试再次通过，我们的移动平均计算现在如下所示：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The above code is the same as before except that we now use `update.value` instead
    of `update.price`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与之前相同，只是我们现在使用`update.value`而不是`update.price`。
- en: 'Now, `price_history` is no longer used anywhere in the `Stock` class, so we
    can remove it from the class. We can also remove the `PriceEvent` named tuple
    as well as any unused imports. The initializer and update method after those changes
    are as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`price_history`在`Stock`类中不再被使用，因此我们可以将其从类中删除。我们还可以删除名为`PriceEvent`的元组以及任何未使用的导入。这些更改后的初始化器和更新方法如下：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: With this change, our Extract Class refactoring is complete.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，我们的提取类重构已经完成。
- en: The importance of tests
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试的重要性
- en: The Extract Class refactoring shows the importance of having a good unit test
    suite as well as running it frequently during the refactoring. It is easy to overlook
    small things when moving code around, which could end up breaking the code. By
    running the tests often, we know immediately when we break something. This makes
    it easy to fix the mistake. Had we done the whole refactoring before running the
    tests, it would have not been clear which step in the refactoring broke the tests,
    and we would have to go back and debug the whole refactoring.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 提取类重构显示了拥有一个好的单元测试套件以及在重构期间频繁运行它的重要性。在移动代码时很容易忽略小事，这可能会导致代码损坏。通过经常运行测试，我们可以立即知道我们破坏了什么。这使得修复错误变得容易。如果我们测试之前就完成了整个重构，那么我们就不清楚重构的哪个步骤破坏了测试，我们就必须回过头来调试整个重构。
- en: One more thing that we need to do is to adjust the tests after the refactoring
    is complete. In some refactorings, such as Extract Class, we may find that we
    have to also move tests to the new class. For instance, if we had any tests for
    the `_get_closing_price_list` method, then we would move those tests over to the
    `TimeSeries` class. In this case, since the method was not public, we didn't write
    tests for them and we didn't have anything to move.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要做的一件事是在重构完成后调整测试。在一些重构中，例如提取类（Extract Class），我们可能会发现我们还需要将测试移动到新的类中。例如，如果我们有任何针对`_get_closing_price_list`方法的测试，那么我们会将这些测试移动到`TimeSeries`类中。在这种情况下，由于该方法不是公开的，我们没有为它们编写测试，也没有任何东西可以移动。
- en: After the refactoring, that method has become a public method on the `TimeSeries`
    class, and it currently doesn't have any tests. It is a good idea to go back and
    write some tests for the method.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后，该方法已成为`TimeSeries`类的一个公开方法，目前还没有任何测试。回过头来为该方法编写一些测试是个好主意。
- en: Exercise
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Just as we extracted the time series code into its own class, we can also extract
    the moving average code into a separate class. Try doing this refactoring as an
    exercise. Once you are done, check out the Appendix for a walkthrough of one possible
    solution.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将时间序列代码提取到其自己的类中一样，我们也可以将移动平均代码提取到单独的类中。尝试作为练习进行这个重构。完成后，查看附录以了解一个可能的解决方案的概述。
- en: Wrapping up
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Here is the algorithm for calculating the DMAC in pseudocode:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是计算DMAC的伪代码算法：
- en: Calculate the short term and long term moving averages.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算短期和长期移动平均。
- en: If the short term crosses the long term from bottom to top, then *buy*.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果短期移动平均从底部穿过长期移动平均到顶部，那么*买入*。
- en: If the long term crosses the short term from bottom to top, then *sell*.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果长期移动平均从底部穿过短期移动平均到顶部，那么*卖出*。
- en: Otherwise do nothing.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则什么也不做。
- en: 'This is the code we started with, which passed all the tests:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的起始代码，它通过了所有测试：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After the moving average code is extracted into its own class (see the exercise
    above to try this, or the [Appendix A](apa.html "Appendix A. Answers to Exercises"),
    *Answers to Exercises* to see one solution of how we got here), this is what the
    `get_crossover_signal` method looks like:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在将移动平均代码提取到其自己的类中（参见上面的练习尝试这样做，或查看[附录A](apa.html "附录 A. 练习答案")，*练习答案*以查看我们如何到达这里的其中一个解决方案）之后，这是`get_crossover_signal`方法的样子：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The difference is clear. The refactored code reads just like the pseudocode
    above, with an almost 1:1 correspondence. A person who knows the algorithm will
    instantly know what this method is doing. We don't need to write a line of comments
    to make this readable. We cannot say the same for the code we started with.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 差异很明显。重构后的代码就像上面的伪代码一样，几乎是一对一对应。了解算法的人会立刻知道这个方法在做什么。我们不需要写一行注释来使它可读。我们无法对我们开始时的代码说同样的话。
- en: The new code is only 9 statements long and delegates all the non-core functionality
    to the `TimeSeries` and `MovingAverage` classes. These classes are themselves
    quite short, and easy to understand. Overall, the refactoring has made a huge
    improvement in the quality of the code.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码只有9条语句长，并将所有非核心功能委托给`TimeSeries`和`MovingAverage`类。这些类本身相当短，易于理解。总的来说，重构大大提高了代码的质量。
- en: The best part? We made small changes and always had the tests as a safety net
    so we were sure we didn't break anything. Without the tests, we could not have
    undertaken these refactorings—the risk of breaking code is just too large. In
    fact, while writing the code that you see in this chapter, I did break the tests
    several times. Fortunately the tests were there and the errors were fixed in minutes.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的部分是什么？我们进行了小的改动，并且始终将测试作为安全网，以确保我们没有破坏任何东西。没有测试，我们无法承担这些重构——破坏代码的风险太大。实际上，在编写本章中您看到的代码时，我多次破坏了测试。幸运的是，测试在那里，错误在几分钟内就被修复了。
- en: One might ask about the time taken to perform all the refactorings we have gone
    through so far. This chapter looks quite huge and intimidating, but once we are
    comfortable with the techniques, it would take only about 30 to 60 minutes to
    perform all these refactorings.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人可能会问，我们迄今为止所进行的所有重构所需的时间。本章看起来相当庞大且令人畏惧，但一旦我们熟悉了这些技术，完成所有这些重构只需要大约30到60分钟。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you looked at some of the most common code smells as well as
    the most common refactorings to fix them. You saw, step by step, how to perform
    each of the refactorings on our project and how having a good test suite enables
    us to perform such refactorings with confidence. Test-driven development and refactoring
    go hand in hand and are invaluable tools in any developer's toolbox. In the next
    chapter, we will take a look at testing code interactions using mock objects.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您查看了一些最常见的代码恶臭以及修复它们的常见重构。您一步一步地看到了如何在我们的项目中执行每个重构，以及一个好的测试套件如何使我们能够自信地执行这些重构。测试驱动开发和重构是相辅相成的，并且是任何开发者工具箱中的无价之宝。在下一章中，我们将探讨使用模拟对象测试代码交互。
