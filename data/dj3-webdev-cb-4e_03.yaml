- en: Forms and Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单和视图
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating an app with CRUDL functions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个带有CRUDL功能的应用程序
- en: Saving the author of a model instance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存模型实例的作者
- en: Uploading images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传图片
- en: Creating a form layout with custom templates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义模板创建表单布局
- en: Creating a form layout with django-crispy-forms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用django-crispy-forms创建表单布局
- en: Working with formsets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表单集
- en: Filtering object lists
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤对象列表
- en: Managing paginated lists
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理分页列表
- en: Composing class-based views
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合基于类的视图
- en: Providing Open Graph and Twitter Card data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供Open Graph和Twitter Card数据
- en: Providing schema.org vocabularies
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供schema.org词汇
- en: Generating PDF documents
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成PDF文档
- en: Implementing a multilingual search with Haystack and Whoosh
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Haystack和Whoosh实现多语言搜索
- en: Implementing a multilingual search with Elasticsearch DSL
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Elasticsearch DSL实现多语言搜索
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: While a database structure is defined in models, views provide the endpoints
    necessary to show content to users or to let them enter new and updated data.
    In this chapter, we will focus on views for managing forms, the list view, and
    views generating alternative outputs to HTML. In the simplest examples, we will
    leave the creation of URL rules and templates up to you.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数据库结构在模型中定义，但视图提供了必要的端点，以向用户显示内容或让他们输入新的和更新的数据。在本章中，我们将重点关注用于管理表单、列表视图和生成HTML以外的替代输出的视图。在最简单的示例中，我们将把URL规则和模板的创建留给您。
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To work with the code of this chapter, as before, you will need the latest stable
    version of Python, MySQL, or a PostgreSQL database, and a Django project with
    a virtual environment. Some recipes will require specific Python dependencies. In
    addition, for generating PDF documents, you will need the `cairo`, `pango`, `gdk-pixbuf`,
    and `libffi` libraries. For searches, you will need an Elasticsearch server. You
    will get more details about them later in the corresponding recipes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用本章的代码，您将需要最新稳定版本的Python、MySQL或PostgreSQL数据库，以及带有虚拟环境的Django项目。一些教程将需要特定的Python依赖项。此外，为了生成PDF文档，您将需要`cairo`、`pango`、`gdk-pixbuf`和`libffi`库。对于搜索，您将需要一个Elasticsearch服务器。您将在相应的教程中获得更多关于它们的详细信息。
- en: Most of the templates in this chapter will use the Bootstrap 4 CSS framework
    for a nicer look and feel.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的大多数模板将使用Bootstrap 4 CSS框架，以获得更美观的外观和感觉。
- en: You can find all of the code for this chapter in the `ch03` directory of the
    GitHub repository at: [https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub存储库的`ch03`目录中找到本章的所有代码：[https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition)。
- en: Creating an app with CRUDL functions
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个带有CRUDL功能的应用程序
- en: In computer science, the **CRUDL** acronym stands for **Create**, **Read**,
    **Update**, **Delete**, and **List** functions. Many Django projects with interactive
    functionality will need you to implement all of those functions to manage data
    on the website. In this recipe, we will see how to create URLs and views for these
    basic functions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，**CRUDL**首字母缩写代表**创建**、**读取**、**更新**、**删除**和**列表**功能。许多具有交互功能的Django项目将需要您实现所有这些功能来管理网站上的数据。在本教程中，我们将看到如何为这些基本功能创建URL和视图。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s create a new app called `ideas` and put it in `INSTALLED_APPS` in the
    settings. Create the following `Idea` model with an `IdeaTranslations` model for
    translations inside of that app:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`ideas`的新应用程序，并将其放入设置中的`INSTALLED_APPS`中。在该应用程序中创建以下`Idea`模型，并在该模型内部创建`IdeaTranslations`模型以进行翻译：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We are using several concepts here from the previous chapter: we inherit from
    model mixins and utilize a model translation table. Read more about that in the
    *Using model mixins* and the *Working with model translation tables* recipes.
    We are going to use the `ideas` app and these models for all of the recipes in
    this chapter.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了上一章的几个概念：我们从模型混合继承，并利用了模型翻译表。在*使用模型混合*和*使用模型翻译表*教程中了解更多。我们将在本章的所有教程中使用`ideas`应用程序和这些模型。
- en: 'In addition, create an analogous `categories` app with the `Category` and `CategoryTranslations`
    models:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，创建一个类似的`categories`应用程序，其中包括`Category`和`CategoryTranslations`模型：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The CRUDL functionality in Django consists of forms, views, and URL rules.
    Let''s create them:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Django中的CRUDL功能包括表单、视图和URL规则。让我们创建它们：
- en: 'Add a new `forms.py` file to the `ideas` app with the model form for adding
    and changing the instances of your `Idea` model:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ideas`应用程序中添加一个新的`forms.py`文件，其中包含用于添加和更改`Idea`模型实例的模型表单：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add a new `views.py` file to the `ideas` app with the views to manipulate the
    `Idea` model:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ideas`应用程序中添加一个新的`views.py`文件，其中包含操作`Idea`模型的视图：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create the `urls.py` file in the `ideas` app with the URL rules:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ideas`应用程序中创建`urls.py`文件，其中包含URL规则：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let''s plug in these URL rules to the project''s URL configuration. We
    will also include the accounts'' URL rules from the Django-contributed `auth`
    app, so that our `@login_required` decorator works properly:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将这些URL规则插入到项目的URL配置中。我们还将包括Django贡献的`auth`应用程序中的帐户URL规则，以便我们的`@login_required`装饰器正常工作：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should now be able to create the following templates:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您应该能够创建以下模板：
- en: '`registration/login.html` with a form to log in'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registration/login.html`中带有登录表单'
- en: '`ideas/idea_list.html` with a list of ideas'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ideas/idea_list.html`中包含一个想法列表'
- en: '`ideas/idea_detail.html` with the details about an idea'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ideas/idea_detail.html`中包含有关想法的详细信息'
- en: '`ideas/idea_form.html` with a form to add or change an idea'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ideas/idea_form.html`中包含添加或更改想法的表单'
- en: '`ideas/idea_deleting_confirmation.html` with an empty form to confirm idea
    deletion'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ideas/idea_deleting_confirmation.html`中包含一个空表单，用于确认删除想法'
- en: 'In the templates, you can address the URLs of the `ideas` app via the namespace
    and path names as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，您可以通过命名空间和路径名称来访问`ideas`应用程序的URL，如下所示：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you get stuck or want to save time, check the corresponding templates in
    the code files for this book, which you can find at [https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition/tree/master/ch03/myproject_virtualenv/src/django-myproject/myproject/templates/ideas](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition/tree/master/ch03/myproject_virtualenv/src/django-myproject/myproject/templates/ideas).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到困难或想节省时间，请查看本书的代码文件中相应的模板，您可以在[https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition/tree/master/ch03/myproject_virtualenv/src/django-myproject/myproject/templates/ideas](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition/tree/master/ch03/myproject_virtualenv/src/django-myproject/myproject/templates/ideas)找到。
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we are using a UUID field for the primary key of the `Idea`
    model. With this ID, each idea has an un-guessable unique URL. Alternatively,
    you can use slug fields for URLs, but then you have to make sure that each slug
    is populated and is unique throughout the website.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用UUID字段作为`Idea`模型的主键。有了这个ID，每个想法都有一个不可预测的唯一URL。或者，您也可以使用slug字段用于URL，但是您必须确保每个slug都被填充并且在整个网站中是唯一的。
- en: 'It is not recommended to use the default incremental IDs for URLs, for security
    reasons: users can figure out how many items you have in the database and try
    to access the next or previous item, although they might not have permission to
    do that.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全原因，不建议使用默认的增量ID用于URL：用户可以找出数据库中有多少项，并尝试访问下一个或上一个项目，尽管他们可能没有权限这样做。
- en: In our example, we are using generic class-based views for the listing and reading
    ideas and function-based views for creating, updating, and deleting them. The
    views that change the records in the database require authenticated users with
    the `@login_required` decorator. It would be also perfectly fine to use class-based
    views or function-based views for all CRUDL functions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用基于类的通用视图来列出和阅读想法，并使用基于函数的视图来创建、更新和删除它们。更改数据库中记录的视图需要经过身份验证的用户，使用`@login_required`装饰器。对于所有CRUDL功能，使用基于类的视图或基于函数的视图也是完全可以的。
- en: After successfully adding or changing an idea, the user will be redirected to
    the detail view. After deleting an idea, the user will be redirected to the list
    view.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 成功添加或更改想法后，用户将被重定向到详细视图。删除想法后，用户将被重定向到列表视图。
- en: There's more...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In addition, you can use the Django messages framework to display success messages
    at the top of the page after each successful addition, change, or delete.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用Django消息框架在每次成功添加、更改或删除后在页面顶部显示成功消息。
- en: You can read about them in the official documentation at: [https://docs.djangoproject.com/en/2.2/ref/contrib/messages/](https://docs.djangoproject.com/en/2.2/ref/contrib/messages/).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中阅读有关它们的信息：[https://docs.djangoproject.com/en/2.2/ref/contrib/messages/](https://docs.djangoproject.com/en/2.2/ref/contrib/messages/)。
- en: See also
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using model mixins* recipe in [Chapter 2](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*, Models
    and Database Structure*
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第2章](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*的*使用模型混合*食谱中，模型和数据库结构'
- en: The *Working with model translation tables* recipe in [Chapter 2](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*, Models
    and Database Structure*
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第2章](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*的*使用模型翻译表*食谱中，模型和数据库结构'
- en: The *Saving the author of a model instance* recipe
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*保存模型实例的作者*食谱'
- en: The *Arranging the base.html template* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第4章](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*的*安排base.html模板*食谱中，模板和JavaScript'
- en: Saving the author of a model instance
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存模型实例的作者
- en: The first argument of every Django view is the `HttpRequest` object, which by
    convention is named `request`. It contains metadata about the request sent from
    a browser or other client, including such items as the current language code,
    user data, cookies, and session. By default, forms that are used by views accept
    the GET or POST data, files, initial data, and other parameters; however, they
    do not inherently have access to the `HttpRequest` object. In some cases, it is
    useful to additionally pass `HttpRequest` to the form, especially when you want
    to filter out the choices of form fields based on other request data or handle
    saving something such as the current user or IP in the form.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Django视图的第一个参数是`HttpRequest`对象，按照惯例命名为`request`。它包含有关从浏览器或其他客户端发送的请求的元数据，包括当前语言代码、用户数据、cookie和会话等项目。默认情况下，视图使用的表单接受GET或POST数据、文件、初始数据和其他参数；但是，它们本身并没有访问`HttpRequest`对象的能力。在某些情况下，将`HttpRequest`附加到表单中是有用的，特别是当您想要根据其他请求数据过滤表单字段的选择或处理保存诸如当前用户或IP之类的内容时。
- en: In this recipe, we will see an example of a form where, for added or changed
    ideas, the current user is saved as an author.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到一个表单的例子，其中，对于添加或更改的想法，当前用户将被保存为作者。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will build upon the example in the previous recipe.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在前一个示例中进行扩展。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To complete this recipe, execute the following two steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此食谱，请执行以下两个步骤：
- en: 'Modify the `IdeaForm` model form as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`IdeaForm`模型表单如下：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Modify the view to add or change the ideas:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改视图以添加或更改想法：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's take a look at the form. At first, we exclude the `author` field from
    the form because we want to handle it programatically. We overwrite the `__init__()`
    method to accept `HttpRequest` as the first parameter and store it in the form.
    The `save()` method of a model form handles the saving of the model. The `commit`
    parameter tells the model form to save the instance immediately or otherwise to
    create and populate the instance, but not save it yet. In our case, we get the
    instance without saving it, then assign the author from the current user. Finally,
    we save the instance if `commit` is `True`. We will call the dynamically added `save_m2m()`
    method of the form to save many-to-many relations, for example, categories.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个表单。首先，我们从表单中排除`author`字段，因为我们希望以编程方式处理它。我们重写`__init__()`方法，接受`HttpRequest`作为第一个参数，并将其存储在表单中。模型表单的`save()`方法处理模型的保存。`commit`参数告诉模型表单立即保存实例，否则创建并填充实例，但尚未保存。在我们的情况下，我们获取实例而不保存它，然后从当前用户分配作者。最后，如果`commit`为`True`，我们保存实例。我们将调用动态添加的`save_m2m()`方法来保存多对多关系，例如类别。
- en: In the view, we just pass the `request` variable to the form as the first parameter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中，我们只需将`request`变量作为第一个参数传递给表单。
- en: See also
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating an app with CRUDL functions* recipe
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用CRUDL功能创建应用程序*食谱'
- en: The *Uploading images* recipe
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*上传图像*食谱'
- en: Uploading images
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传图像
- en: In this recipe, we will take a look at the easiest way to handle image uploads.
    We will add a `picture` field to the `Idea` model, and we will create image versions
    of different dimensions for different purposes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将看一下处理图像上传的最简单方法。我们将在`Idea`模型中添加一个`picture`字段，并为不同目的创建不同尺寸的图像版本。
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For images with image versions, we will need the `Pillow` and `django-imagekit`
    libraries. Let''s install them with `pip` in your virtual environment (and include
    them in `requirements/_base.txt`):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有图像版本的图像，我们将需要`Pillow`和`django-imagekit`库。让我们在虚拟环境中使用`pip`安装它们（并将它们包含在`requirements/_base.txt`中）：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then, add `"imagekit"` to `INSTALLED_APPS` in the settings.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在设置中将`"imagekit"`添加到`INSTALLED_APPS`。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Execute these steps to complete the recipe:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成食谱：
- en: 'Modify the `Idea` model to add a `picture` field and image version specifications:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`Idea`模型以添加`picture`字段和图像版本规格：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Create a model form, `IdeaForm`, for the `Idea` model in `forms.py`, just like
    we did in the previous recipes.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`forms.py`中为`Idea`模型创建一个模型表单`IdeaForm`，就像我们在之前的食谱中所做的那样。
- en: 'In the view for adding or changing ideas, make sure to post `request.FILES`
    beside `request.POST` to the form:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加或更改想法的视图中，确保将`request.FILES`与`request.POST`一起发布到表单中：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the template, make sure to have encoding type set to `"multipart/form-data"`,
    as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板中，确保将编码类型设置为`"multipart/form-data"`，如下所示：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you are using `django-crispy-form` as described in the *Creating a form layout
    with django-crispy-forms* recipe, the `enctype` attribute will be added to the
    form automatically.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用`django-crispy-form`，如*使用django-crispy-forms创建表单布局*食谱中所述，`enctype`属性将自动添加到表单中。
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Django model forms are created dynamically from models. They provide the specified
    fields from the model so you don't need to redefine them manually in the form.
    In the preceding example, we created a model form for the `Idea` model. When we
    save the form, the form knows how to save each field in the database, as well
    as how to upload the files and save them in the media directory.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Django模型表单是从模型动态创建的。它们提供了模型中指定的字段，因此您不需要在表单中手动重新定义它们。在前面的示例中，我们为`Idea`模型创建了一个模型表单。当我们保存表单时，表单知道如何将每个字段保存在数据库中，以及如何上传文件并将其保存在媒体目录中。
- en: The `upload_to()` function in our example is used for saving the image to a
    specific directory and defining its name such that it wouldn't clash with filenames
    for other model instances. Each file will be saved under a path such as `ideas/2020/01/0422c6fe-b725-4576-8703-e2a9d9270986.jpg`,
    which consists of the year and month of the upload and the primary key of the
    `Idea` instance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`upload_to()`函数用于将图像保存到特定目录，并定义其名称，以便不会与其他模型实例的文件名冲突。每个文件将保存在类似`ideas/2020/01/0422c6fe-b725-4576-8703-e2a9d9270986.jpg`的路径下，其中包括上传的年份和月份以及`Idea`实例的主键。
- en: Some filesystems (such as FAT32 and NTFS) have a limited amount of files available
    per directory; therefore, it is a good practice to divide them into directories
    by upload date, alphabet, or other criteria.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文件系统（如FAT32和NTFS）每个目录可用的文件数量有限；因此，将它们按上传日期、字母顺序或其他标准划分为目录是一个好习惯。
- en: 'We are creating three image versions using `ImageSpecField` from django-imagekit:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`django-imagekit`中的`ImageSpecField`创建了三个图像版本：
- en: '`picture_social` is used for social sharing.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`picture_social`用于社交分享。'
- en: '`picture_large` is used for the detail view.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`picture_large`用于详细视图。'
- en: '`picture_thumbnail` is used for the list view.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`picture_thumbnail`用于列表视图。'
- en: Image versions are not linked in the database but just saved in the default
    file storage under a file path such as `CACHE/images/ideas/2020/01/0422c6fe-b725-4576-8703-e2a9d9270986/`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图像版本未在数据库中链接，而只是保存在默认文件存储中，路径为`CACHE/images/ideas/2020/01/0422c6fe-b725-4576-8703-e2a9d9270986/`。
- en: 'In the template, you can use the original or a specific image version, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，您可以使用原始图像或特定图像版本，如下所示：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At the end of the `Idea` model definition, we overwrite the `delete()` method
    to delete the image versions and the picture from the disk just before deleting
    the instance of `Idea` itself.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Idea`模型定义的末尾，我们重写`delete()`方法，以便在删除`Idea`实例之前删除图像版本和磁盘上的图片。
- en: See also
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a form layout with django-crispy-forms* recipe
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用django-crispy-forms创建表单布局*食谱'
- en: The *Arranging the base.html template* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*，模板和JavaScript*中的*安排base.html模板*食谱'
- en: The *Providing responsive images* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第4章](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*的*提供响应式图片*食谱中'
- en: Creating a form layout with custom templates
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义模板创建表单布局
- en: In earlier versions of Django, all form rendering was handled exclusively in
    Python code, but since Django 1.11, template-based form widget rendering has been
    introduced. In this recipe, we will examine how to use custom templates for form
    widgets. We are going to use the Django administration form to illustrate how
    the custom widget templates can improve the usability of the fields.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期版本的Django中，所有表单渲染都是在Python代码中处理的，但自从Django 1.11以来，引入了基于模板的表单小部件渲染。在这个食谱中，我们将研究如何使用自定义模板来处理表单小部件。我们将使用Django管理表单来说明自定义小部件模板如何提高字段的可用性。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s create the default Django administration for the `Idea` model and its
    translations:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`Idea`模型及其翻译的默认Django管理：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you access the administration form for the ideas, it will look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您访问想法的管理表单，它将如下所示：
- en: '![](img/d063e19c-516f-4966-bad8-b91d5a734cda.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d063e19c-516f-4966-bad8-b91d5a734cda.png)'
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To complete the recipe, follow these steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个食谱，请按照以下步骤进行：
- en: 'Ensure that the template system will be able to find customized templates by
    adding `"django.forms"` to `INSTALLED_APPS`, including the `APP_DIRS` flag as
    `True` at the templates configuration, and using the `"TemplatesSetting"` form
    renderer:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`"django.forms"`添加到`INSTALLED_APPS`，在模板配置中将`APP_DIRS`标志设置为`True`，并使用`"TemplatesSetting"`表单渲染器，确保模板系统能够找到自定义模板：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Edit the `admin.py` file as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`admin.py`文件如下：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, create a template for your picture field:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为您的图片字段创建一个模板：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If you look at the administration form for ideas now, you will see something
    like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在查看想法的管理表单，您会看到类似这样的东西：
- en: '![](img/50557bdd-bdfe-4d29-acb7-9e64af5eb808.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50557bdd-bdfe-4d29-acb7-9e64af5eb808.png)'
- en: 'There are two changes here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个变化：
- en: The category selection is now using a widget with multiple checkboxes.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在类别选择使用的是一个带有多个复选框的小部件。
- en: The picture field is now rendered with a specific template, showing a preview
    of the image and help text with preferred file types and dimensions.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在图片字段使用特定模板呈现，显示图像预览和帮助文本，显示首选文件类型和尺寸。
- en: What we did here, was we overwrote the model form for the idea and modified
    the widget for the categories and the template for the picture field.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是覆盖了idea的模型表单，并修改了类别的小部件和图片字段的模板。
- en: The default form renderer in Django is `"django.forms.renderers.DjangoTemplates"`,
    and it only searches for the templates in app directories. We changed it to `"django.forms.renderers.TemplatesSetting"`
    to also have a look in the templates under `DIRS` paths.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Django中的默认表单渲染器是`"django.forms.renderers.DjangoTemplates"`，它只在应用程序目录中搜索模板。我们将其更改为`"django.forms.renderers.TemplatesSetting"`，以便在`DIRS`路径下的模板中也进行查找。
- en: See also
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Working with model translation tables* recipe in [Chapter 2](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*,
    Models and Database Structure*
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第2章](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*的*使用模型翻译表*食谱中'
- en: The *Uploading images* recipe
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*上传图片*食谱'
- en: The *Creating a form layout with django-crispy-forms* recipe
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用django-crispy-forms创建表单布局*食谱'
- en: Creating a form layout with django-crispy-forms
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用django-crispy-forms创建表单布局
- en: 'The `django-crispy-forms` Django app allows you to build, customize, and reuse
    forms using one of the following CSS frameworks: Uni-Form, Bootstrap 3, Bootstrap
    4, or Foundation. The use of `django-crispy-forms` is somewhat analogous to fieldsets
    in the Django contributed administration; however, it is more advanced and customizable.
    You define form layout in the Python code and need not worry about how each field
    is presented in HTML. Moreover, if you need to add specific HTML attributes or
    wrapping, you can easily do that too. All of the markup used by `django-crispy-forms`
    is located in templates that can be overwritten for specific needs.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`django-crispy-forms` Django应用程序允许您使用以下CSS框架之一构建、自定义和重用表单：Uni-Form、Bootstrap
    3、Bootstrap 4或Foundation。使用`django-crispy-forms`有点类似于Django贡献的管理中的字段集；但是，它更先进和可定制。您可以在Python代码中定义表单布局，而不必担心每个字段在HTML中的呈现方式。此外，如果您需要添加特定的HTML属性或包装，您也可以轻松实现。`django-crispy-forms`使用的所有标记都位于可以根据特定需求进行覆盖的模板中。'
- en: In this recipe, we will create a nice layout for the frontend form to add or
    edit ideas using the Bootstrap 4, popular frontend framework for developing responsive,
    mobile-first web projects.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用Bootstrap 4创建一个漂亮的布局，用于添加或编辑想法的前端表单，这是一个用于开发响应式、移动优先网站项目的流行前端框架。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will start with the `ideas` app that we created in this chapter. Next, we''ll
    execute the following tasks one by one:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从本章中创建的`ideas`应用程序开始。接下来，我们将依次执行以下任务：
- en: Make sure you have created a `base.html` template for your site. Learn more
    about this in the *Arranging the base.html template* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您已经为您的站点创建了一个`base.html`模板。在[第4章](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*的*安排base.html模板*食谱中了解更多。
- en: Integrate the Bootstrap 4 frontend framework CSS and JS files
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成Bootstrap 4前端框架的CSS和JS文件
- en: from [https://getbootstrap.com/docs/4.3/getting-started/introduction/](https://getbootstrap.com/docs/4.3/getting-started/introduction/) into
    the `base.html` template.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://getbootstrap.com/docs/4.3/getting-started/introduction/](https://getbootstrap.com/docs/4.3/getting-started/introduction/)中获取到`base.html`模板。
- en: 'Install `django-crispy-forms` in your virtual environment with `pip` (and include
    it in `requirements/_base.txt`):'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的虚拟环境中使用`pip`安装`django-crispy-forms`（并将其包含在`requirements/_base.txt`中）：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Make sure that `"crispy_forms"` is added to `INSTALLED_APPS` in the settings,
    and then set `"bootstrap4"` as the template pack to be used in this project:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在设置中将`"crispy_forms"`添加到`INSTALLED_APPS`中，并将`"bootstrap4"`设置为此项目中要使用的模板包：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Follow these steps:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: 'Let''s modify the model form for the ideas:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改想法的模型表单：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, let''s create the `picture_guidelines.html` template with the following
    content:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们创建`picture_guidelines.html`模板，内容如下：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, let''s update the template for the form of ideas:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们更新想法表单的模板：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the model form for ideas, we create a form helper with a layout consisting
    of a main fieldset, picture fieldset, categories fieldset, and submit button.
    Each fieldset consists of fields. Any fieldset, field, or button can have additional
    parameters that become the attributes of the field, for example,  `rows="3"` or
    `placeholder=_("Please enter a title")`. For HTML `class` and `id` attributes,
    there are specific parameters, `css_class` and `css_id`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在想法的模型表单中，我们创建了一个包含主要字段集、图片字段集、类别字段集和提交按钮的表单助手布局。每个字段集都包含字段。任何字段集、字段或按钮都可以具有附加参数，这些参数成为字段的属性，例如`rows="3"`或`placeholder=_("Please
    enter a title")`。对于HTML的`class`和`id`属性，有特定的参数，`css_class`和`css_id`。
- en: 'The page with the idea form will look similar to the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: idea表单页面将类似于以下内容：
- en: '![](img/188283f1-62f5-40af-b4b8-5a1adc05995b.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/188283f1-62f5-40af-b4b8-5a1adc05995b.png)'
- en: Just like in the previous recipe, we modify the widget for the categories field
    and add additional help text for the picture field.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在上一个配方中一样，我们修改了类别字段的小部件，并为图片字段添加了额外的帮助文本。
- en: There's more...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: For basic usage, the given example is more than necessary. However, if you need
    a specific markup for the forms in your project, you can still overwrite and modify
    templates of the `django-crispy-forms` app, as there is no markup hardcoded in
    the Python files, rather all of the generated markup is rendered through templates.
    Just copy the templates from the `django-crispy-forms` app to your project's template
    directory and change them as required.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本用法，给定的示例已经足够了。但是，如果您需要项目中表单的特定标记，您仍然可以覆盖和修改`django-crispy-forms`应用程序的模板，因为Python文件中没有硬编码的标记，而是通过模板呈现所有生成的标记。只需将`django-crispy-forms`应用程序中的模板复制到项目的模板目录中，并根据需要进行更改。
- en: See also
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating an app with CRUDL functions* recipe
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用CRUDL功能创建应用程序*配方'
- en: The *Creating a form layout with custom templates* recipe
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用自定义模板创建表单布局*配方'
- en: The *Filtering object lists* recipe
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*过滤对象列表*配方'
- en: The *Managing paginated lists* recipe
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管理分页列表*配方'
- en: The *Composing class-based views* recipe
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组成基于类的视图*配方'
- en: The *Arranging the base.html template* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*，模板和JavaScript*中的*安排base.html模板*配方'
- en: Working with formsets
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用formsets
- en: Besides normal or model forms, Django has a concept of formsets. These are sets
    of forms of the same type that allow us to create or change multiple instances
    at once. Django formsets can be enriched with JavaScript, which allows us to add
    them to a page dynamically. That's exactly what we will work on in this recipe.
    We will extend the form of ideas to allow adding translations to different languages
    on the same page.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了普通或模型表单外，Django还有一个表单集的概念。这些是相同类型的表单集，允许我们一次创建或更改多个实例。Django表单集可以通过JavaScript进行增强，这使我们能够动态地将它们添加到页面中。这正是我们将在本配方中要做的。我们将扩展想法的表单，以允许在同一页上为不同语言添加翻译。
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's continue working on `IdeaForm` from the previous recipe, *Creating a form
    layout with django-crispy-forms*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在上一个配方*使用django-crispy-forms创建表单布局*中继续工作`IdeaForm`。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: 'Let''s modify the form layout for `IdeaForm`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改`IdeaForm`的表单布局：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, let''s add `IdeaTranslationsForm` at the end of the same file:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在同一个文件的末尾添加`IdeaTranslationsForm`：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Modify the view to add or change ideas, as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改视图以添加或更改想法，如下所示：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, let''s edit the `idea_form.html` template and add a reference to the `inlines.js`
    script file at the end:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们编辑`idea_form.html`模板，并在末尾添加对`inlines.js`脚本文件的引用：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create the template for the translation formsets:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为翻译formsets创建模板：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Last but not least, add the JavaScript to manipulate the formsets:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，添加JavaScript来操作formsets：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You might know about formsets from the Django model administration. Formsets
    are used there in the mechanism of inlines for child models having foreign keys
    to a parent model.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经从Django模型管理中了解了formsets。在那里，formsets用于具有对父模型的外键的子模型的inlines机制。
- en: 'In this recipe, we added formsets to the idea form using `django-crispy-forms`.
    The result will look like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用`django-crispy-forms`向idea表单添加了formsets。结果将如下所示：
- en: '![](img/9685ebfb-8112-4d54-888d-0326cd58da3a.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9685ebfb-8112-4d54-888d-0326cd58da3a.png)'
- en: As you can see, we can insert the formsets not necessarily at the end of the
    form, but anywhere in between, where it makes sense. In our example, it makes
    sense to list out translations just after translatable fields.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们可以将formsets插入到表单的末尾，也可以在其中任何位置插入，只要有意义。在我们的示例中，将翻译列出在可翻译字段之后是有意义的。
- en: The form layout for the translations forms has the main fieldset just like the
    layout of `IdeaForm`, but in addition, it has `id` and `DELETE` fields that are
    necessary for recognition of each model instance and the possibility to remove
    them from the list. The `DELETE` field is actually a checkbox that if checked,
    deletes the appropriate item from the database. Also, the form helper for the
    translation has `form_tag=False`, which doesn't generate the `<form>` tag, and
    `disable_csrf=True`, which doesn't include the CSRF token, because we have already
    defined these in the parent form, `IdeaForm`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译表单的表单布局与`IdeaForm`的布局一样，但另外还有`id`和`DELETE`字段，这对于识别每个模型实例和从列表中删除它们是必要的。`DELETE`字段实际上是一个复选框，如果选中，将从数据库中删除相应的项目。此外，翻译的表单助手具有`form_tag=False`，它不生成`<form>`标签，以及`disable_csrf=True`，它不包括CSRF令牌，因为我们已经在父表单`IdeaForm`中定义了这些内容。
- en: In the view, if the request is sent by the POST method and both the form and
    the formset are valid, then we save the form and create respective translation
    instances without saving them at first. This is done by the `commit=False` attribute.
    For each translation instance, we assign the idea and then save the translations
    to the database. Lastly, we check whether any forms in the formset were marked
    for deletion and delete them from the database.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中，如果请求是通过POST方法发送的，并且表单和表单集都有效，则我们保存表单并创建相应的翻译实例，但首先不保存它们。这是通过`commit=False`属性完成的。对于每个翻译实例，我们分配想法，然后将翻译保存到数据库中。最后，我们检查表单集中是否有任何标记为删除的表单，并将其从数据库中删除。
- en: In the `translations.html` template, we render each form in the formset and
    then we add an extra hidden empty form, which will be used by JavaScript to generate
    new forms of the formset to be added dynamically.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`translations.html`模板中，我们渲染表单集中的每个表单，然后添加一个额外的隐藏空表单，JavaScript将使用它来动态生成表单集的新表单。
- en: Each formset form has prefixes for all fields. For example, the `title` field
    of the first formset form will have an HTML field name, `"translations-0-title"`,
    and the `DELETE` field of the same formset form will have an HTML field name, `"translations-0-DELETE"`.
    The empty form has a word, `"__prefix__"`, instead of the index, for example,
    `"translations-__prefix__-title"`. This is abstracted at the Django level, but
    necessary to know for manipulating the formset forms with JavaScript.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表单集表单都有所有字段的前缀。例如，第一个表单集表单的`title`字段将具有HTML字段名称`"translations-0-title"`，同一表单集表单的`DELETE`字段将具有HTML字段名称`"translations-0-DELETE"`。空表单具有一个单词`"__prefix__"`，而不是索引，例如`"translations-__prefix__-title"`。这在Django级别进行了抽象，但是在使用JavaScript操纵表单集表单时需要了解这一点。
- en: 'The `inlines.js` JavaScript does a few things:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`inlines.js` JavaScript执行了一些操作：'
- en: For each existing formset form, it initializes its JavaScript-powered widgets
    (you could use tooltips, day or color pickers, maps, and so on) and creates a
    delete button, which is shown instead of the `DELETE` checkbox.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个现有的表单集表单，它初始化其JavaScript驱动的小部件（您可以使用工具提示、日期或颜色选择器、地图等），并创建一个删除按钮，该按钮显示在`DELETE`复选框的位置。
- en: When a delete button is clicked, it checks the `DELETE` checkbox and hides the
    formset form from the user.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当单击删除按钮时，它会检查`DELETE`复选框并将表单集表单隐藏在用户视野之外。
- en: When the add button is clicked, it clones the empty form and replaces `"__prefix__"`
    with the next available index, adds the new form to the list, and initiates JavaScript-powered
    widgets.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当单击添加按钮时，它会克隆空表单，并用下一个可用索引替换`"__prefix__"`，将新表单添加到列表中，并初始化JavaScript驱动的小部件。
- en: There's more...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The JavaScript uses an array, `window.WIDGET_INIT_REGISTER`, which contains
    functions that should be called to initiate widgets with a given formset form.
    To register a new function in another JavaScript file, you can do the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript使用一个数组`window.WIDGET_INIT_REGISTER`，其中包含应调用以初始化具有给定表单集表单的小部件的函数。要在另一个JavaScript文件中注册新函数，可以执行以下操作：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will apply tooltip functionality for all occurrences in the formset forms
    where the tags in the markup have `data-toggle="tooltip"` and `title` attributes,
    as in this example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为标记中具有`data-toggle="tooltip"`和`title`属性的表单集表单中的所有出现应用工具提示功能，就像这个例子中一样：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: See also
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a form layout with django-crispy-forms* recipe
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用django-crispy-forms创建表单布局的配方
- en: The *Arranging the base.html template* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*，模板和JavaScript*中的*安排base.html模板*配方'
- en: Filtering object lists
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤对象列表
- en: In web development, besides views with forms, it is typical to have object-list
    views and detail views. List views can simply list objects that are ordered, for
    example, alphabetically or by creation date; however, that is not very user-friendly
    with huge amounts of data. For the best accessibility and convenience, you should
    be able to filter the content by all possible categories. In this recipe, we will
    see the pattern that is used to filter list views by any number of categories.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发中，除了具有表单的视图之外，还典型地具有对象列表视图和详细视图。列表视图可以简单地列出按字母顺序或创建日期排序的对象；然而，对于大量数据来说，这并不是非常用户友好的。为了获得最佳的可访问性和便利性，您应该能够按所有可能的类别对内容进行筛选。在本配方中，我们将看到用于按任意数量的类别筛选列表视图的模式。
- en: 'What we''ll be creating is a list view of ideas that can be filtered by author,
    category, or rating. It will look similar to the following with Bootstrap 4 applied
    to it:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的是一个可以按作者、类别或评分进行筛选的想法列表视图。它将类似于以下内容，并应用了Bootstrap 4：
- en: '![](img/0dc5a7c9-2254-4018-a314-e97c6be30a32.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0dc5a7c9-2254-4018-a314-e97c6be30a32.png)'
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For the filtering example, we will use the `Idea` model with relation to the
    author and categories to filter by. It will also be possible to filter by ratings,
    which is `PositiveIntegerField` with choices. Let's use the ideas app with the
    models that we created in the previous recipes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于筛选示例，我们将使用具有与作者和类别相关的`Idea`模型。还可以按评分进行筛选，这是具有选择的`PositiveIntegerField`。让我们使用先前配方中创建的模型的ideas应用。
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To complete the recipe, follow these steps:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个配方，请按照以下步骤操作：
- en: 'Create `IdeaFilterForm` with all of the possible categories to filter by:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`IdeaFilterForm`，其中包含所有可能的类别以进行过滤：
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create the `idea_list` view to list filtered ideas:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`idea_list`视图以列出经过筛选的想法：
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the same file, add the helper function, `filter_facets()`:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，添加辅助函数`filter_facets()`：
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you haven't done so already, create a `base.html` template. You can do that
    according to the example provided in the *Arranging the base.html template* recipe
    in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*, Templates and JavaScript*.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未这样做，请创建`base.html`模板。您可以根据[第4章](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*，模板和JavaScript*中的*安排base.html模板*配方中提供的示例进行操作。
- en: 'Create the `idea_list.html` template with the following content:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`idea_list.html`模板，内容如下：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, let''s create the template for the filters. This template uses the `{%
    modify_query %}` template tag, described in the *Creating a template tag to modify
    request query parameters* recipe in [Chapter 5](c4fd2c24-3a56-4d2d-9ef3-c455e8a626ef.xhtml)*,
    Custom Template Filters and Tags*, to generate URLs for the filters:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们创建过滤器的模板。此模板使用了在[第5章](c4fd2c24-3a56-4d2d-9ef3-c455e8a626ef.xhtml)*，自定义模板过滤器和标记*中描述的`{%
    modify_query %}`模板标记，以生成过滤器的URL：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Each of the categories will follow a common pattern in the filters sidebar,
    so we can create and include templates with the common parts. First, we have the
    filter heading, corresponding to `misc/includes/filter_heading.html`, as in the
    following:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个类别将遵循过滤器侧边栏中的通用模式，因此我们可以创建和包含具有共同部分的模板。首先，我们有过滤器标题，对应于`misc/includes/filter_heading.html`，如下所示：
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And then each filter will contain a link to reset filtering for that category,
    represented by `misc/includes/filter_all.html` here. This template also uses the
    `{% modify_query %}` template tag, described in the *Creating a template tag to
    modify request query parameters* recipe in [Chapter 5](c4fd2c24-3a56-4d2d-9ef3-c455e8a626ef.xhtml)*,
    Custom Template Filters and Tags*:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，每个过滤器将包含一个重置该类别过滤的链接，在这里表示为`misc/includes/filter_all.html`。此模板还使用了`{% modify_query
    %}`模板标记，在[第5章](c4fd2c24-3a56-4d2d-9ef3-c455e8a626ef.xhtml)*，自定义模板过滤器和标记*中描述了这个模板标记：
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The idea list needs to be added to the URLs for the `ideas` app:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要将想法列表添加到`ideas`应用的URL中：
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We are using the `facets` dictionary that is passed to the template context
    to know which filters we have and which filters are selected. To look deeper,
    the `facets` dictionary consists of two sections: the `categories` dictionary
    and the `selected` dictionary. The `categories` dictionary contains QuerySets
    or choices of all filterable categories. The `selected` dictionary contains the
    currently selected values for each category. In `IdeaFilterForm`, we make sure
    that only those categories and authors are listed that have at least one idea.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用传递给模板上下文的`facets`字典来了解我们有哪些过滤器以及选择了哪些过滤器。要深入了解，`facets`字典包括两个部分：`categories`字典和`selected`字典。`categories`字典包含所有可过滤类别的QuerySets或选择。`selected`字典包含每个类别的当前选定值。在`IdeaFilterForm`中，我们确保只列出至少有一个想法的类别和作者。
- en: In the view, we check whether the query parameters are valid in the form and
    then filter the QuerySet of objects based on the selected categories. Additionally,
    we set the selected values to the `facets` dictionary, which will be passed to
    the template.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中，我们检查表单中的查询参数是否有效，然后根据所选类别过滤对象的QuerySet。此外，我们将选定的值设置为将传递给模板的`facets`字典。
- en: In the template, for each categorization from the `facets` dictionary, we list
    all of the categories and mark the currently selected category as active. If nothing
    is selected for a given category, we mark the default "All" link as the active
    one.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，对于`facets`字典中的每个分类，我们列出所有类别，并将当前选定的类别标记为活动状态。如果没有为给定类别选择任何内容，我们将默认的“全部”链接标记为活动状态。
- en: See also
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Managing paginated lists* recipe
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管理分页列表*配方'
- en: The *Composing class-based views* recipe
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于类的视图的组合*配方'
- en: The *Arranging the base.html template* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安排base.html模板*配方在[第4章](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*，模板和JavaScript*'
- en: The *Creating a template tag to modify request query parameters* recipe in [Chapter
    5](c4fd2c24-3a56-4d2d-9ef3-c455e8a626ef.xhtml)*, Custom Template Filters and Tags*
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](c4fd2c24-3a56-4d2d-9ef3-c455e8a626ef.xhtml)*，自定义模板过滤器和标记*中描述的*创建一个模板标记来修改请求查询参数*配方
- en: Managing paginated lists
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理分页列表
- en: If you have dynamically changing lists of objects or their count is greater
    than 24 or so, you will likely need pagination to provide a good user experience.
    Instead of the full QuerySet, pagination provides a specific number of items in
    the dataset that corresponds to the appropriate size for one page. We also display
    links to allow users to access the other pages making up the complete set of data.
    Django has classes to manage paginated data, and we will see how to use them in
    this recipe.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有动态更改的对象列表或其数量大于24个左右，您可能需要分页以提供良好的用户体验。分页不提供完整的QuerySet，而是提供数据集中特定数量的项目，这对应于一页的适当大小。我们还显示链接，允许用户访问组成完整数据集的其他页面。Django有用于管理分页数据的类，我们将看到如何在这个配方中使用它们。
- en: Getting ready
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's start with the models, forms, and views of the `ideas` app from the *Filtering
    object lists* recipe.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从*过滤对象列表*配方开始`ideas`应用的模型、表单和视图。
- en: How to do it...
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To add pagination to the list view of the ideas, follow these steps:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要将分页添加到想法的列表视图中，请按照以下步骤操作：
- en: 'Import the necessary pagination classes from Django into the `views.py` file.
    We will add pagination management to the `idea_list` view just after filtering.
    Also, we will slightly modify the context dictionary by assigning `page` to the
    `object_list` key:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Django中导入必要的分页类到`views.py`文件中。我们将在过滤后的`idea_list`视图中添加分页管理。此外，我们将通过将`page`分配给`object_list`键，稍微修改上下文字典：
- en: '[PRE40]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Modify the `idea_list.html` template as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`idea_list.html`模板如下：
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create the pagination widget template:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建分页小部件模板：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When you look at the results in the browser, you will see the pagination controls,
    similar to the follo wing:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在浏览器中查看结果时，您将看到分页控件，类似于以下内容：
- en: '![](img/b53de7b4-5c07-4550-a0b0-c22c96e06655.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b53de7b4-5c07-4550-a0b0-c22c96e06655.png)'
- en: How do we achieve this? When QuerySet is filtered out, we will create a paginator
    object passing QuerySet and the maximal amount of items that we want to show per
    page, which is 24 here. Then, we will read the current page number from the query
    parameter, `page`. The next step is to retrieve the current page object from the
    paginator. If the page number is not an integer, we get the first page. If the
    number exceeds the number of possible pages, the last page is retrieved. The page
    object has methods and attributes necessary for the pagination widget shown in
    the preceding screenshot. Also, the page object acts like QuerySet so that we
    can iterate through it and get the items from the fraction of the page.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何实现这一点？当QuerySet被过滤掉时，我们将创建一个分页器对象，传递QuerySet和我们想要每页显示的最大项目数，这里是24。然后，我们将从查询参数`page`中读取当前页码。下一步是从分页器中检索当前页对象。如果页码不是整数，我们获取第一页。如果页码超过可能的页数，就会检索到最后一页。页面对象具有分页小部件中所需的方法和属性，如前面截图中所示。此外，页面对象的行为类似于QuerySet，因此我们可以遍历它并从页面的一部分获取项目。
- en: The snippet marked in the template creates a pagination widget with the markup
    for the Bootstrap 4 frontend framework. We show the pagination controls only if
    there are more pages than the current one. We have the links to the previous and
    next pages, and the list of all page numbers in the widget. The current page number
    is marked as active. To generate URLs for the links, we use the `{% modify_query
    %}` template tag, which will be described later in the *Creating a template tag
    to modify request query parameters* recipe in [Chapter 5](c4fd2c24-3a56-4d2d-9ef3-c455e8a626ef.xhtml)*,
    Custom Template Filters and Tags*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中标记的片段创建了一个分页小部件，其中包含Bootstrap 4前端框架的标记。只有在当前页面多于一个时，我们才显示分页控件。我们有到上一页和下一页的链接，以及小部件中所有页面编号的列表。当前页码被标记为活动状态。为了生成链接的URL，我们使用`{%
    modify_query %}`模板标签，稍后将在[第5章](c4fd2c24-3a56-4d2d-9ef3-c455e8a626ef.xhtml)*，自定义模板过滤器和标签*的*创建一个模板标签以修改请求查询参数*方法中进行描述。
- en: See also
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Filtering object lists* recipe
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*过滤对象列表*的方法'
- en: The *Composing class-based views* recipe
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组合基于类的视图*的方法'
- en: The *Creating a template tag to modify request query parameters* recipe in [Chapter
    5](c4fd2c24-3a56-4d2d-9ef3-c455e8a626ef.xhtml)*, Custom Template Filters and Tags*
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板标签以修改请求查询参数*的方法在[第5章](c4fd2c24-3a56-4d2d-9ef3-c455e8a626ef.xhtml)*，自定义模板过滤器和标签*'
- en: Composing class-based views
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合基于类的视图
- en: Django views are callables that take requests and return responses. In addition
    to function-based views, Django provides an alternative way to define views as
    classes. This approach is useful when you want to create reusable modular views
    or combine views of the generic mixins. In this recipe, we will convert the previously
    shown function-based `idea_list` view into a class-based `IdeaListView` view.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Django视图是可调用的，接受请求并返回响应。除了基于函数的视图之外，Django还提供了一种将视图定义为类的替代方法。当您想要创建可重用的模块化视图或组合通用混合视图时，这种方法非常有用。在这个方法中，我们将之前显示的基于函数的`idea_list`视图转换为基于类的`IdeaListView`视图。
- en: Getting ready
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create the models, form, and template similar to the previous recipes, *Filtering
    object lists* and *Managing paginated lists*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 创建与前面的*过滤对象列表*和*管理分页列表*类似的模型、表单和模板。
- en: How to do it...
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to execute the recipe:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤执行该方法：
- en: 'Our class-based view, `IdeaListView`, will inherit the Django `View` class
    and override the `get()` method:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的基于类的视图`IdeaListView`将继承Django的`View`类并重写`get()`方法：
- en: '[PRE43]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We will need to create a URL rule in the URL configuration using the class-based
    view. You may have added a rule previously for the function-based `idea_list`
    view, which would have been similar. To include a class-based view in the URL
    rules, use the `as_view()` method as follows:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在URL配置中创建一个URL规则，使用基于类的视图。您可能之前已经为基于函数的`idea_list`视图添加了一个规则，这将是类似的。要在URL规则中包含基于类的视图，使用`as_view()`方法如下：
- en: '[PRE44]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following are the things happening in the `get()` method, which is called
    for HTTP GET requests:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`get()`方法中发生的事情，该方法用于处理HTTP GET请求：
- en: First, we create the `form` object, passing the `request.GET` dictionary-like
    object to it. The `request.GET` object contains all of the query variables that
    are passed using the GET method.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们创建`form`对象，将`request.GET`类似字典的对象传递给它。`request.GET`对象包含使用GET方法传递的所有查询变量。
- en: 'Then, the `form` object is passed to the `get_queryset_and_facets()` method,
    which returns the associated values via a tuple containing two elements: QuerySet
    and the `facets` dictionary respectively.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，将`form`对象传递给`get_queryset_and_facets()`方法，该方法通过包含两个元素的元组返回相关值：QuerySet和`facets`字典。
- en: The current request object and retrieved QuerySet are passed to the `get_page()`
    method, which returns the current page object.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将当前请求对象和检索到的QuerySet传递给`get_page()`方法，该方法返回当前页对象。
- en: Lastly, we create a `context` dictionary and render the response.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个`context`字典并呈现响应。
- en: If we needed to support it, we could also provide a `post()` method, which is
    called for HTTP POST requests.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要支持，我们还可以提供一个`post()`方法，该方法用于处理HTTP POST请求。
- en: There's more...
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As you see, the `get()` and `get_page()` methods are largely generic, so we
    could create a generic `FilterableListView` class with these methods in the `core`
    app. Then, in any app that requires a filterable list, we could create a class-based
    view that extends `FilterableListView` to handle such scenarios. This extending
    class would define only the `form_class` and `template_name` attributes and the
    `get_queryset_and_facets()` method. Such modularity and extensibility represent
    two of the key benefits of how class-based views work.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`get()`和`get_page()`方法在很大程度上是通用的，因此我们可以在`core`应用程序中使用这些方法创建一个通用的`FilterableListView`类。然后，在任何需要可过滤列表的应用程序中，我们可以创建一个基于类的视图，该视图扩展了`FilterableListView`以处理这种情况。这个扩展类只需定义`form_class`和`template_name`属性以及`get_queryset_and_facets()`方法。这种模块化和可扩展性代表了基于类的视图工作的两个关键优点。
- en: See also
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Filtering object lists* recipe
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*过滤对象列表*的步骤'
- en: The *Managing paginated lists* recipe
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管理分页列表*的步骤'
- en: Providing Open Graph and Twitter Card data
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供Open Graph和Twitter Card数据
- en: 'If you want the content of your website to be shared on social networks, you
    should at least implement Open Graph and Twitter Card meta tags. These meta tags
    define how the web page is represented in Facebook or Twitter feeds: what title
    and description will be shown, what image will be set, and what the URL is about.
    In this recipe, we will prepare the `idea_detail.html` template for social sharing.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望网站的内容在社交网络上分享，您至少应该实现Open Graph和Twitter Card元标记。这些元标记定义了网页在Facebook或Twitter动态中的呈现方式：将显示什么标题和描述，将设置什么图片，以及URL是关于什么的。在这个步骤中，我们将为`idea_detail.html`模板准备社交分享。
- en: Getting ready
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's continue with the `ideas` app from previous recipes.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用之前步骤中的`ideas`应用。
- en: How to do it...
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to complete the recipe:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成步骤：
- en: Make sure to have the `Idea` model created with the picture field and picture
    version specifications. See the *Creating an app with CRUDL functions* and *Uploading
    images* recipes for more information.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已创建包含图片字段和图片版本规格的`Idea`模型。有关更多信息，请参阅*使用CRUDL功能创建应用*和*上传图片*的步骤。
- en: Make sure to have a detail view ready for ideas. See the *Creating an app with
    CRUDL functions* recipe for information on how to do that.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保为ideas准备好详细视图。有关如何操作，请参阅*使用CRUDL功能创建应用*的步骤。
- en: Plug the detail view into the URL configuration. How to do that is described
    in the *Creating an app with CRUDL functions* recipe.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将详细视图插入URL配置中。如何操作在*使用CRUDL功能创建应用*的步骤中有描述。
- en: 'In the settings of your specific environment, define `WEBSITE_URL` and `MEDIA_URL`
    as full URLs of the media files, as in this example:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在特定环境的设置中，定义`WEBSITE_URL`和`MEDIA_URL`作为媒体文件的完整URL，就像这个例子中一样：
- en: '[PRE45]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `core` app, create a context processor returning the `WEBSITE_URL` variable
    from the settings:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`core`应用中，创建一个上下文处理器，从设置中返回`WEBSITE_URL`变量：
- en: '[PRE46]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Plug in the context processor in the settings:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置中插入上下文处理器：
- en: '[PRE47]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create the `idea_detail.html` template with the following content:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含以下内容的`idea_detail.html`模板：
- en: '[PRE48]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Open Graph tags are meta tags with special names starting with `og:` and Twitter
    card tags are meta tags with special names starting with `twitter:`. These meta
    tags define the URL, title, description, and image of the current page, site name,
    author, and locale. It is important to provide full URLs there; the path alone
    would be not enough.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Open Graph标签是具有以`og:`开头的特殊名称的元标记，Twitter卡片标签是具有以`twitter:`开头的特殊名称的元标记。这些元标记定义了当前页面的URL、标题、描述和图片，站点名称、作者和区域设置。在这里提供完整的URL是很重要的；仅提供路径是不够的。
- en: We use the `picture_social` image version which has the optimal dimensions for
    social networks: 1024 × 512 px.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`picture_social`图片版本，其在社交网络上具有最佳尺寸：1024×512像素。
- en: You can validate your Open Graph implementation at [https://developers.facebook.com/tools/debug/sharing/](https://developers.facebook.com/tools/debug/sharing/).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://developers.facebook.com/tools/debug/sharing/](https://developers.facebook.com/tools/debug/sharing/)上验证您的Open
    Graph实现。
- en: Twitter Card implementation can be validated at [https://cards-dev.twitter.com/validator](https://cards-dev.twitter.com/validator).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter卡片实现可以在[https://cards-dev.twitter.com/validator](https://cards-dev.twitter.com/validator)上进行验证。
- en: See also
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating an app with CRUDL functions* recipe
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用CRUDL功能创建应用*的步骤'
- en: The *Uploading images* recipe
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*上传图片*的步骤'
- en: The *Providing schema.org vocabularies* recipe
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提供schema.org词汇*的步骤'
- en: Providing schema.org vocabularies
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供schema.org词汇
- en: It is important to have semantic markup for **Search Engine Optimization** (**SEO**).
    But to improve search engine rankings even more, it is beneficial to provide structured
    data according to schema.org vocabularies. Many applications from Google, Microsoft,
    Pinterest, Yandex, and others use schema.org structures to create rich extensible
    experiences such as special consistent-looking cards in the search results for
    events, movies, authors, and so on.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**搜索引擎优化**（**SEO**）来说，拥有语义标记是很重要的。但为了进一步提高搜索引擎排名，根据schema.org词汇提供结构化数据是很有益的。许多来自Google、Microsoft、Pinterest、Yandex等的应用程序使用schema.org结构，以创建丰富的可扩展体验，比如在搜索结果中为事件、电影、作者等创建特殊的一致外观卡片。
- en: There are several encodings, including RDFa, Microdata, and JSON-LD, that can
    be used to create schema.org vocabularies. In this recipe, we will prepare structured
    data for the `Idea` model in JSON-LD format, which is preferred and recommended
    by Google.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种编码，包括RDFa、Microdata和JSON-LD，可以用来创建schema.org词汇。在这个步骤中，我们将以JSON-LD格式为`Idea`模型准备结构化数据，这是Google首选和推荐的格式。
- en: Getting ready
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s install the `django-json-ld` package into your project''s virtual environment (and
    include it in `requirements/_base.txt`):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`django-json-ld`包安装到项目的虚拟环境中（并将其包含在`requirements/_base.txt`中）：
- en: '[PRE49]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Put `"django_json_ld"` under `INSTALLED_APPS` in the settings:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置中的`INSTALLED_APPS`下放置`"django_json_ld"`：
- en: '[PRE50]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How to do it...
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to complete the recipe:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成步骤：
- en: 'Add the `structured_data` property with the following content to the `Idea`
    model:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Idea`模型中添加包含以下内容的`structured_data`属性：
- en: '[PRE51]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Modify the `idea_detail.html` template:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`idea_detail.html`模板：
- en: '[PRE52]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `{% render_json_ld %}` template tag will render the script tag similar
    to this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% render_json_ld %}`模板标签将呈现类似于以下内容的脚本标签：'
- en: '[PRE53]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `structured_data` property returns a nested dictionary according to the
    schema.org vocabularies that are well understood by most popular search engines.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`structured_data`属性返回一个嵌套字典，根据schema.org词汇，这些词汇被大多数流行的搜索引擎所理解。'
- en: You can decide which vocabularies to apply to your models by checking the official
    documentation at [https://schema.org/docs/schemas.html](https://schema.org/docs/schemas.html).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看官方文档[https://schema.org/docs/schemas.html](https://schema.org/docs/schemas.html)来决定要应用于模型的词汇。
- en: See also
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a model mixin to take care of meta tags* recipe in [Chapter 2](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*,
    Models and Database Structure*
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*，模型和数据库结构*中的*创建一个模型mixin来处理元标签*配方'
- en: The *Creating an app with CRUDL functions* recipe
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用CRUDL功能创建应用*配方'
- en: The *Uploading images* recipe
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*上传图片*配方'
- en: The *Providing Open Graph and Twitter Card data* recipe
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提供Open Graph和Twitter Card数据*配方'
- en: Generating PDF documents
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成PDF文档
- en: Django views allow you to create much more than just HTML pages. You can create
    files of any type. For example, in the *Exposing settings in JavaScript* recipe
    in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*, Templates and JavaScript*,
    our view provides its output as a JavaScript file rather than HTML. You can also
    create PDF documents for invoices, tickets, receipts, booking confirmations, and
    so on. In this recipe, we will show you how to generate handouts to print for
    each idea from the database. We are going to use the **WeasyPrint** library to
    make PDF documents out of HTML templates.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Django视图允许您创建的不仅仅是HTML页面。您可以创建任何类型的文件。例如，在[第4章](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*，模板和JavaScript*中的*暴露设置*配方中，我们的视图提供其输出作为JavaScript文件而不是HTML。您还可以创建PDF文档，用于发票、门票、收据、预订确认等。在这个配方中，我们将向您展示如何为数据库中的每个想法生成手册以打印。我们将使用**WeasyPrint**库将HTML模板制作成PDF文档。
- en: Getting ready
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'WeasyPrint depends on several libraries that you need to install on your computer.
    On macOS, you can install them with Homebrew using this command:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: WeasyPrint依赖于您需要在计算机上安装的几个库。在macOS上，您可以使用Homebrew使用此命令安装它们：
- en: '[PRE54]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, you can install WeasyPrint itself in the virtual environment of your
    project. Also, include it in `requirements/_base.txt`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在项目的虚拟环境中安装WeasyPrint本身。还要将其包含在`requirements/_base.txt`中：
- en: '[PRE55]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: For other operating systems, check the installation instructions at [https://weasyprint.readthedocs.io/en/latest/install.html](https://weasyprint.readthedocs.io/en/latest/install.html).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他操作系统，请查看[https://weasyprint.readthedocs.io/en/latest/install.html](https://weasyprint.readthedocs.io/en/latest/install.html)上的安装说明。
- en: 'Also, we''ll be using `django-qr-code` to generate a **QR code** linking back
    to the website for quick access. Let''s also install it in the virtual environment
    (and include it in `requirements/_base.txt`):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将使用`django-qr-code`生成链接回网站以便快速访问的**QR码**。让我们也在虚拟环境中安装它（并将其包含在`requirements/_base.txt`中）：
- en: '[PRE56]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add `"qr_code"` to `INSTALLED_APPS` in the settings:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置中将`"qr_code"`添加到`INSTALLED_APPS`：
- en: '[PRE57]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How to do it...
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to complete the recipe:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成配方：
- en: 'Create the view that will generate the PDF document:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建将生成PDF文档的视图：
- en: '[PRE58]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Plug this view into the URL configuration:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此视图插入URL配置：
- en: '[PRE59]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create a template for the PDF document:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为PDF文档创建模板：
- en: '[PRE60]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Also, create the `base_pdf.html` template:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要创建`base_pdf.html`模板：
- en: '[PRE61]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works...
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'WeasyPrint generates ready-to-print, pixel-perfect documents. Our example of
    a handout we could give out to an audience at presentations will look similar
    to this:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: WeasyPrint生成准备打印的像素完美的文档。我们可以向演示会的观众提供的手册示例看起来类似于这样：
- en: '![](img/fa351e86-8e13-4efb-8820-54e1db58e70f.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa351e86-8e13-4efb-8820-54e1db58e70f.png)'
- en: The layout of the document is defined in markup and CSS. WeasyPrint has its
    own rendering engine. Read more about supported features in the official documentation
    at: [https://weasyprint.readthedocs.io/en/latest/features.html](https://weasyprint.readthedocs.io/en/latest/features.html).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 文档的布局是在标记和CSS中定义的。WeasyPrint有自己的渲染引擎。在官方文档中阅读更多关于支持功能的信息：[https://weasyprint.readthedocs.io/en/latest/features.html](https://weasyprint.readthedocs.io/en/latest/features.html)。
- en: You can use SVG images, which will be saved as vector graphics, not bitmaps,
    and therefore will be crispier in the printout. Inline SVGs are not yet supported,
    but you can use `<img>` tags with a data source or external URL there. In our
    example, we use SVG images for the QR code and for the logo in the footer.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用SVG图像，这些图像将保存为矢量图形，而不是位图，因此在打印时会更清晰。内联SVG尚不受支持，但您可以在那里使用带有数据源或外部URL的`<img>`标签。在我们的示例中，我们使用SVG图像作为QR码和页脚中的徽标。
- en: Let's get through the code of the view. We render the `idea_handout_pdf.html`
    template with the selected idea as an `html` string. Then, we create an `HttpResponse`
    object of PDF content type with the filename composed of the current date and
    slugified idea title. Then, we create WeasyPrint's HTML object with HTML content
    and write it to the response as if we would write to a file. In addition, we use
    the `FontConfiguration` object, which allows us to attach and use web fonts from
    CSS configuration in the layout. Lastly, we return the response object.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下视图的代码。我们使用所选想法作为`html`字符串渲染`idea_handout_pdf.html`模板。然后，我们创建一个PDF内容类型的`HttpResponse`对象，文件名由当前日期和slugified想法标题组成。然后，我们创建WeasyPrint的HTML对象与HTML内容，并将其写入响应，就像我们写入文件一样。此外，我们使用`FontConfiguration`对象，它允许我们在布局中附加和使用来自CSS配置的网络字体。最后，我们返回响应对象。
- en: See also
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating an app with CRUDL functions* recipe
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用CRUDL功能创建应用*配方'
- en: The *Uploading images* recipe
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*上传图片*配方'
- en: The *Exposing settings in JavaScript* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript中的*暴露设置*配方在[第4章](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*，模板和JavaScript*中
- en: Implementing a multilingual search with Haystack and Whoosh
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Haystack和Whoosh实现多语言搜索
- en: One of the main functionalities of content-driven websites is a full-text search.
    Haystack is a modular search API that supports the Solr, Elasticsearch, Whoosh,
    and Xapian search engines. For each model in your project that has to be findable
    in the search, you need to define an index that will read out the textual information
    from the models and place it into the backend. In this recipe, you will learn
    how to set up a search with Haystack and the Python-based Whoosh search engine
    for a multilingual website.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 内容驱动网站的主要功能之一是全文搜索。Haystack是一个模块化的搜索API，支持Solr、Elasticsearch、Whoosh和Xapian搜索引擎。对于项目中每个需要在搜索中找到的模型，您需要定义一个索引，该索引将从模型中读取文本信息并将其放入后端。在本食谱中，您将学习如何为多语言网站使用Haystack和基于Python的Whoosh搜索引擎设置搜索。
- en: Getting ready
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are going to use the previously defined `categories` and `ideas` apps.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用先前定义的`categories`和`ideas`应用程序。
- en: 'Make sure you have installed `django-haystack` and `Whoosh` in your virtual
    environment (and include them in `requirements/_base.txt`):'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在您的虚拟环境中安装了`django-haystack`和`Whoosh`（并将它们包含在`requirements/_base.txt`中）：
- en: '[PRE62]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How to do it...
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s set up a multilingual search with Haystack and Whoosh by executing the
    following steps:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过执行以下步骤来设置Haystack和Whoosh的多语言搜索：
- en: 'Create a `search` app that will contain `MultilingualWhooshEngine` and search
    indexes for our ideas. The search engine will live in the `multilingual_whoosh_backend.py`
    file:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含`MultilingualWhooshEngine`和我们想法的搜索索引的`search`应用程序。搜索引擎将位于`multilingual_whoosh_backend.py`文件中：
- en: '[PRE63]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s create the search indexes, as follows:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建搜索索引，如下所示：
- en: '[PRE64]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Configure the settings to use `MultilingualWhooshEngine`:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置设置以使用`MultilingualWhooshEngine`：
- en: '[PRE65]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Add a path to the URL rules:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加URL规则的路径：
- en: '[PRE66]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We will need a template for the search form and search results, as given here:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个搜索表单和搜索结果的模板，如下所示：
- en: '[PRE67]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Add a pagination template at `misc/includes/pagination.html` just like in the *Managing
    paginated lists* recipe.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`misc/includes/pagination.html`中添加一个分页模板，就像在*管理分页列表*食谱中一样。
- en: 'Call the `rebuild_index` management command to index the database data and
    prepare the full-text search to be used:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`rebuild_index`管理命令来对数据库数据进行索引并准备全文搜索的使用：
- en: '[PRE68]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How it works...
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`MultilingualWhooshEngine` specifies two custom properties:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultilingualWhooshEngine`指定了两个自定义属性：'
- en: '`backend` points to `MultilingualWhooshSearchBackend`, which ensures that the
    items will be indexed for each language given in the `LANGUAGES` setting and put
    under the associated Haystack index location defined in `HAYSTACK_CONNECTIONS`.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backend`指向`MultilingualWhooshSearchBackend`，它确保项目将为`LANGUAGES`设置中给定的每种语言进行索引，并将其放在`HAYSTACK_CONNECTIONS`中定义的相关Haystack索引位置下。'
- en: '`query` references `MultilingualWhooshSearchQuery`, whose responsibility is
    to ensure that, when searching for keywords, the Haystack connection specific
    to the current language will be used.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query`引用了`MultilingualWhooshSearchQuery`，其责任是确保在搜索关键字时，将使用特定于当前语言的Haystack连接。'
- en: Each index has a `text` field, where full text from a specific language of a
    model will be stored. The model for the index is determined by the `get_model()`
    method, the `index_queryset()` method defines what QuerySet to index, and the
    content to search within is defined as a newline-separated string in the `prepare_text()`
    method.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 每个索引都有一个`text`字段，用于存储模型特定语言的全文。索引的模型由`get_model()`方法确定，`index_queryset()`方法定义要索引的QuerySet，`prepare_text()`方法中定义要在其中搜索的内容为换行分隔的字符串。
- en: For the template, we have incorporated a few elements of Bootstrap 4 using the
    out-of-the-box rendering capabilities for forms. This might be enhanced using
    an approach such as explained in the *Creating a form layout with django-crispy-forms*
    recipe from earlier in this chapter.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模板，我们已经使用了Bootstrap 4的一些元素，使用了表单的开箱即用的渲染功能。可以使用类似本章前面解释的*使用django-crispy-forms创建表单布局*的方法来增强这一点。
- en: 'The final search page will have the form in the sidebar and the search results
    in the main columns and will look similar to the following:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的搜索页面将在侧边栏中有一个表单，在主列中有搜索结果，并且看起来类似于以下内容：
- en: '![](img/675a5960-e419-4368-977e-e4cc65304211.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![](img/675a5960-e419-4368-977e-e4cc65304211.png)'
- en: The easiest way to update the search index regularly is to call the `rebuild_index`
    management command, perhaps by a cron job every night. To learn about it, check
    the *Setting up cron jobs for regular tasks* recipe in [Chapter 13](498be2b9-4d46-4b50-ab7a-27c535792ae6.xhtml)*,
    Maintenance*.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 定期更新搜索索引的最简单方法是调用`rebuild_index`管理命令，也许可以通过每晚的cron作业来实现。要了解更多信息，请查看[第13章](498be2b9-4d46-4b50-ab7a-27c535792ae6.xhtml)*维护*中的*设置定期任务的cron作业*食谱。
- en: See also
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a form layout with django-crispy-forms* recipe
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用django-crispy-forms创建表单布局*食谱'
- en: The *Managing paginated lists* recipe
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管理分页列表*食谱'
- en: The *Setting up cron jobs for regular tasks* recipe in [Chapter 13](498be2b9-4d46-4b50-ab7a-27c535792ae6.xhtml)*,
    Maintenance*
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第13章](498be2b9-4d46-4b50-ab7a-27c535792ae6.xhtml)*维护*中的*设置定期任务的cron作业*食谱'
- en: Implementing a multilingual search with Elasticsearch DSL
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Elasticsearch DSL实现多语言搜索
- en: Haystack with Whoosh is a good stable search mechanism that requires just some
    Python modules, but for better performance, we recommend using Elasticsearch.
    In this recipe, we'll show you how to use it for a multilingual search.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: Haystack与Whoosh是一个良好的稳定搜索机制，只需要一些Python模块，但为了获得更好的性能，我们建议使用Elasticsearch。在本食谱中，我们将向您展示如何为多语言搜索使用它。
- en: Getting ready
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To start with, let''s install the Elasticsearch server. On macOS, you can do
    that with Homebrew:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们安装Elasticsearch服务器。在macOS上，您可以使用Homebrew来完成：
- en: '[PRE69]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: At the time of writing, the latest stable version of Elasticsearch on Homebrew
    is 6.8.2.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Homebrew上的最新稳定版本的Elasticsearch是6.8.2。
- en: 'Install `django-elasticsearch-dsl` in your virtual environment (and include
    it in `requirements/_base.txt`):'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的虚拟环境中安装`django-elasticsearch-dsl`（并将其包含在`requirements/_base.txt`中）：
- en: '[PRE70]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Note that it is important to install a matching `django-elasticsearch-dsl` version.
    Otherwise, you will get errors when trying to connect to the Elasticsearch server
    or building an index. You can see a version compatibility table at [https://github.com/sabricot/django-elasticsearch-dsl](https://github.com/sabricot/django-elasticsearch-dsl).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，安装匹配的`django-elasticsearch-dsl`版本非常重要。否则，当尝试连接到Elasticsearch服务器或构建索引时，将会出现错误。您可以在[https://github.com/sabricot/django-elasticsearch-dsl](https://github.com/sabricot/django-elasticsearch-dsl)上查看版本兼容性表。
- en: How to do it...
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s set up a multilingual search with Elasticsearch DSL by executing the
    following steps:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过执行以下步骤设置多语言搜索与Elasticsearch DSL：
- en: 'Modify the settings file and add `"django_elasticsearch_dsl"` to `INSTALLED_APPS`
    and set the `ELASTICSEARCH_DSL` setting as follows:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改设置文件，并将`"django_elasticsearch_dsl"`添加到`INSTALLED_APPS`，并将`ELASTICSEARCH_DSL`设置如下：
- en: '[PRE71]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In the `ideas` app, create a `documents.py` file with `IdeaDocument` for the
    idea search index, as follows:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ideas`应用程序中，创建一个`documents.py`文件，其中包含`IdeaDocument`用于idea搜索索引，如下所示：
- en: '[PRE72]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Add `prepare_*` methods to `IdeaDocument` to prepare data for the index:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`IdeaDocument`添加`prepare_*`方法以准备索引的数据：
- en: '[PRE73]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Add some properties and methods to `IdeaDocument` to return translated content
    from the indexed documents:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`IdeaDocument`添加一些属性和方法，以从索引文档中返回翻译内容：
- en: '[PRE74]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'One more thing to do in the `documents.py` file is to monkey-patch the `UUIDField` mappings
    because, by default, it is not yet supported by Django Elasticsearch DSL. To do
    that, insert this line just after the imports section:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`documents.py`文件中还有一件事要做，那就是对`UUIDField`映射进行修补，因为默认情况下，Django Elasticsearch
    DSL尚不支持它。为此，请在导入部分之后插入此行：
- en: '[PRE75]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create `IdeaSearchForm` under `forms.py` in your `ideas` app:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ideas`应用程序的`forms.py`中创建`IdeaSearchForm`：
- en: '[PRE76]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Add the view for searching with Elasticsearch:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加用于使用Elasticsearch搜索的视图：
- en: '[PRE77]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Create an `idea_search.html` template for the search form and search results:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`idea_search.html`模板，用于搜索表单和搜索结果：
- en: '[PRE78]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Add a pagination template at `misc/includes/pagination.html` just like in the
    *Managing paginated lists* recipe.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`misc/includes/pagination.html`中添加一个分页模板，就像*管理分页列表*配方中一样。
- en: 'Call the `search_index --rebuild` management command to index the database
    data and prepare the full-text search to be used:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`search_index --rebuild`管理命令来索引数据库数据并准备使用全文搜索：
- en: '[PRE79]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: How it works...
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Django Elasticsearch DSL documents are similar to model forms. There you define
    which fields of the model to save to the index that later will be used for the
    search queries. In our `IdeaDocument` example, we are saving the UUID, rating,
    author, categories, titles, contents, and URL paths in all languages and a picture
    thumbnail URL. The `Index` class defines the settings of the Elasticsearch index
    for this document. The `Django` class defines where to populate the index fields
    from. There is the `related_models` setting that tells after which model changes
    to also update this index. In our case, it is a `Category` model. Note that with
    `django-elasticsearch-dsl`, the indexes will be updated automatically whenever
    the models are saved. That is done using signals.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: Django Elasticsearch DSL文档类似于模型表单。在那里，您定义要保存到索引的模型字段，以便稍后用于搜索查询。在我们的`IdeaDocument`示例中，我们保存UUID、评分、作者、类别、标题、内容和URL路径以及所有语言和图片缩略图URL。`Index`类定义了此文档的Elasticsearch索引的设置。`Django`类定义了从哪里填充索引字段。有一个`related_models`设置，告诉在哪个模型更改后也更新此索引。在我们的情况下，它是一个`Category`模型。请注意，使用`django-elasticsearch-dsl`，只要保存模型，索引就会自动更新。这是使用信号完成的。
- en: The `get_instances_from_related()` method tells how to retrieve the `Idea` model
    instances when a `Category` instance is changed.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_instances_from_related()`方法告诉如何在更改`Category`实例时检索`Idea`模型实例。'
- en: The `prepare()` and `prepare_*()` methods of `IdeaDocument` tell where to take
    the data from and how to save the data for specific fields. For example, we are
    reading the data for `title_lt` from the `title` field of the `IdeaTranslations`
    model where the `language` field equals `"lt"`.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`IdeaDocument`的`prepare()`和`prepare_*()`方法告诉从哪里获取数据以及如何保存特定字段的数据。例如，我们从`IdeaTranslations`模型的`title`字段中读取`title_lt`的数据，其中`language`字段等于`"lt"`。'
- en: The last properties and methods of the `IdeaDocument` are there to use for retrieval
    of information from the index in the currently active language.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`IdeaDocument`的最后属性和方法用于从当前活动语言的索引中检索信息。'
- en: Then, we have a view with the search form. There is a query field in the form
    called `q`. When it is submitted, we are searching for the queried word in the
    title, content, or category's title field of the current language. Then, we wrap
    the search results with a lazily evaluated `SearchResults` class, so that we could
    use it with the default Django paginator.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个带有搜索表单的视图。表单中有一个名为`q`的查询字段。当提交时，我们在当前语言的标题、内容或类别标题字段中搜索查询的单词。然后，我们用惰性评估的`SearchResults`类包装搜索结果，以便我们可以将其与默认的Django分页器一起使用。
- en: 'The template of the view will have the search form in the sidebar and the search
    results in the main column, and it will look something like this:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的模板将在侧边栏中包含搜索表单，在主列中包含搜索结果，并且看起来会像这样：
- en: '![](img/e41b1ce7-bc57-4f78-9cb0-74cb7b297949.png)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e41b1ce7-bc57-4f78-9cb0-74cb7b297949.png)'
- en: See also
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating an app with CRUDL functions* recipe
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建具有CRUDL功能的应用程序*配方'
- en: The *Implementing a multilingual search with Haystack and Whoosh* recipe
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Haystack和Whoosh实现多语言搜索*配方'
- en: The *Creating a form layout with django-crispy-forms* recipe
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用django-crispy-forms创建表单布局*配方'
- en: The *Managing paginated lists* recipe
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管理分页列表*配方'
