- en: Building a Serverless Application in AWS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWS中构建无服务器应用程序
- en: This chapter will introduce the concept of serverless applications using AWS
    Lambda as the tool of choice. This will help you understand the concept, intuition,
    and working components involved in a serverless tool. It will also explain the
    nuances involved in security, user-controls, and versioning code inside Lambda.
    You will be guided via hands-on tutorials and lessons for understanding and learning
    to use AWS Lambda. So, it is recommended that you follow along this chapter with
    a laptop and an AWS account setup to easily execute the given instructions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍使用AWS Lambda作为首选工具的无服务器应用程序的概念。这将帮助您了解无服务器工具中涉及的概念、直觉和工作组件。它还将解释Lambda内部涉及的安全性、用户控制和版本控制代码的微妙之处。您将通过实践教程和课程指导，了解并学习如何使用AWS
    Lambda。因此，建议您在本章中使用笔记本电脑和已设置好的AWS帐户，以便轻松执行给定的指令。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Triggers in AWS Lambda
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Lambda中的触发器
- en: Lambda functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda函数
- en: Functions as containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为容器
- en: Configuring functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置函数
- en: Testing Lambda functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Lambda函数
- en: Versioning Lambda functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本化Lambda函数
- en: Creating deployment packages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建部署包
- en: Triggers in AWS Lambda
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS Lambda中的触发器
- en: 'Serverless functions are on-demand computational concepts. So, there has to
    be an event that needs to trigger a Lambda function so that the entire computational
    process is started. AWS Lambda has several events which can act as a trigger.
    Almost all services of AWS can act as AWS Lambda''s triggers. Here is the list
    of services that you can use for generating events for Lambda to respond to:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器函数是按需计算概念。因此，必须有一个事件来触发Lambda函数，以便启动整个计算过程。AWS Lambda有几个事件可以充当触发器。几乎所有AWS服务都可以充当AWS
    Lambda的触发器。以下是您可以用于生成Lambda事件的服务列表：
- en: API Gateway
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API Gateway
- en: AWS IoT
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS IoT
- en: CloudWatch Events
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudWatch事件
- en: CloudWatch Logs
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudWatch日志
- en: CodeCommit
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CodeCommit
- en: Cognito Sync Trigger
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cognito同步触发器
- en: DynamoDB
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DynamoDB
- en: Kinesis
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kinesis
- en: S3
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S3
- en: SNS
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SNS
- en: 'The triggers page of AWS Lambda looks like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda的触发器页面如下所示：
- en: '![](img/0a984ab1-eb98-4ad2-94f8-1f4d6fef5c53.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a984ab1-eb98-4ad2-94f8-1f4d6fef5c53.png)'
- en: 'Let''s take a look at some of the following important and widely-used triggers
    that are available, and understand how they can be leveraged as FaaS in the serverless
    paradigm. They are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下一些重要和广泛使用的触发器，并了解它们如何作为无服务器范例中的FaaS来利用。它们如下：
- en: '**API Gateway**: This trigger can be used to create efficient, scalable, and
    serverless APIs. One scenario where a serverless API makes sense would be while
    building a querying interface for S3\. Let us assume that we have a bunch of text
    files in an S3 bucket. Whenever a user hits the API with a query parameter, which
    can be some word that we want to search in the text files in the bucket, the API
    Gateway''s trigger will launch a Lambda function that executes the computational
    logic and workload for executing the query. The Lambda function that we want our
    API to trigger can be specified at the API creation time. The trigger will be
    created accordingly in the corresponding Lambda function''s console. This is what
    it looks like:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API Gateway**：此触发器可用于创建高效、可扩展和无服务器的API。构建S3查询接口时，无服务器API有意义的一个场景是。假设我们在一个S3存储桶中有一堆文本文件。每当用户使用查询参数命中API时，该参数可以是我们想要在存储桶中的文本文件中搜索的某个单词，API
    Gateway的触发器将启动一个Lambda函数，执行计算逻辑和工作量以执行查询。我们希望API触发的Lambda函数可以在API创建时指定。触发器将相应地在相应的Lambda函数控制台中创建。如下所示：'
- en: '![](img/7739cf3b-f508-40b2-bcb5-0e7ead874b3e.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7739cf3b-f508-40b2-bcb5-0e7ead874b3e.png)'
- en: '**CloudWatch**: It events mostly help the user in setting the cron scheduling
    for Lambda. The CloudWatch Logs trigger is useful whenever a user wants to execute
    a computational workload depending on some keyword in the Cloudwatch Logs. However,
    the CloudWatch Alarms cannot trigger Lambda directly via the CloudWatch trigger.
    They have to be sent via a notification system, such as the **AWS Simple Notification
    Service** (**AWS SNS**). This is how you can create a cron execution in AWS Lambda.
    In the following screenshot, the Lambda function is set to execute every minute:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CloudWatch**：它主要帮助用户设置Lambda的cron调度。CloudWatch日志触发器在用户想要根据Cloudwatch日志中的某个关键字执行计算工作负载时非常有用。但是，CloudWatch警报不能直接通过CloudWatch触发器直接触发Lambda。它们必须通过通知系统发送，例如**AWS简单通知服务**（**AWS
    SNS**）。以下是如何在AWS Lambda中创建cron执行的方法。在下面的屏幕截图中，Lambda函数设置为每分钟执行一次：'
- en: '![](img/4c9fd799-c9c5-4366-8fbe-f4f124270bf2.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c9fd799-c9c5-4366-8fbe-f4f124270bf2.png)'
- en: '**S3**: This is a document store of AWS. So, whenever a file is added, removed,
    or changed, an event will be sent to AWS Lambda when added as a trigger. So, if
    you want to do some computational workload on a file as soon as the file gets
    uploaded, then this trigger helps to do that. This is what an S3''s event structure
    looks like:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S3**：这是AWS的文档存储。因此，每当添加、删除或更改文件时，将作为触发器添加到AWS Lambda时，事件将被发送到AWS Lambda。因此，如果您想在文件上传后立即对文件进行一些计算工作，那么这个触发器可以帮助您实现。S3的事件结构如下：'
- en: '![](img/e83a0e56-4388-4c0c-bd0d-3db52c93c7c9.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e83a0e56-4388-4c0c-bd0d-3db52c93c7c9.png)'
- en: '**AWS SNS**: The SNS service of AWS helps users to send notifications to other
    systems. This service can also be used for catching CloudWatch Alarms and sending
    the notifications to a Lambda function for computational execution. This is what
    a sample SNS event looks like:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS SNS**：AWS的SNS服务帮助用户向其他系统发送通知。此服务还可用于捕获CloudWatch警报，并将通知发送到Lambda函数以进行计算执行。以下是示例SNS事件的样子：'
- en: '![](img/c7c76994-3f94-4d4f-9560-7d0148941068.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7c76994-3f94-4d4f-9560-7d0148941068.png)'
- en: Lambda functions
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda函数
- en: '**Lambda functions** are the core operating parts of a serverless architecture.
    They contain the code which is supposed to be executed. These functions are executed
    whenever the trigger attached to it has been set off. We have already learned
    about some of the most popular Lambda triggers in the previous section.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lambda函数**是无服务器架构的核心操作部分。它们包含了应该执行的代码。这些函数在触发器被触发时执行。我们已经在上一节中了解了一些最受欢迎的Lambda触发器。'
- en: Whenever a Lambda function is triggered, it creates a container with the respective
    settings set by the user. We'll learn more about the container in our next section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每当Lambda函数被触发时，它会创建一个具有用户设置的容器。我们将在下一节中了解更多关于容器的知识。
- en: The spinning up of containers takes a bit of time, which may result in a latency
    whenever a fresh invocation of a Lambda function is done, as it takes time to
    set up the environment and bootstrap the settings mentioned by the user in the
    Advanced settings tab. So, to overcome this latency, AWS thaws a container for
    some time for reuse in case of another Lambda invocation within the thawing time.
    So, using a thawed or a ready-made Lambda function helps in overcoming the latency
    problem. However, the same global namespace of the thawed container would be reused
    for the new invocation too.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的启动需要一些时间，这可能导致在进行Lambda函数的新调用时出现延迟，因为需要时间来设置环境并引导用户在高级设置选项卡中提到的设置。因此，为了克服这种延迟，AWS会在一段时间内解冻一个容器以便在解冻时间内进行另一个Lambda调用时重用。因此，使用解冻或现成的Lambda函数有助于克服延迟问题。然而，解冻容器的相同全局命名空间也将被用于新的调用。
- en: So, if the Lambda function has any global variables that get manipulated inside
    the function, it is a good idea to convert them into local namespaces, as the
    manipulated global namespace variables will be reused, leading to faulty execution
    results of the Lambda function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果Lambda函数有任何在函数内部被操作的全局变量，将它们转换为本地命名空间是一个好主意，因为被操作的全局命名空间变量将被重用，导致Lambda函数的执行结果出现故障。
- en: 'The user needs to specify the technical details for the Lambda function in
    the Advanced Settings tab, which include the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 用户需要在高级设置选项卡中指定Lambda函数的技术细节，其中包括以下内容：
- en: 'Memory (MB): This is the maximum memory that the Lambda function needs to be
    allocated for the purpose of your function. The CPU of the container would be
    assigned accordingly.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存（MB）：这是Lambda函数需要分配的最大内存，用于您的函数。容器的CPU将相应地分配。
- en: 'Timeout: The maximum amount of time the function needs to execute before the
    container gets automatically stopped.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超时：在容器自动停止之前，函数需要执行的最长时间。
- en: 'DLQ Resource: This is a dead-letter setting to AWS Lambda. The user can add
    either an SQS queue or an SNS topic for configuring this. Lambda functions get
    asynchronously retried for at least five times on failure.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DLQ资源：这是对AWS Lambda的死信设置。用户可以添加SQS队列或SNS主题进行配置。Lambda函数在失败时会异步重试至少五次。
- en: 'VPC: This enables the Lambda function to access components or services in some
    particular VPCs. The Lambda function executes in a default VPC of its own.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VPC：这使得Lambda函数能够访问特定VPC中的组件或服务。Lambda函数在自己的默认VPC中执行。
- en: 'KMS key: If there are any environment variables entered along with the Lambda
    function, this helps us encrypt them using an **AWS Key Management Service** (**KMS**)
    by default.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KMS密钥：如果有任何环境变量与Lambda函数一起输入，这将帮助我们默认使用**AWS密钥管理服务**（**KMS**）对它们进行加密。
- en: 'The Lambda function''s Advanced settings page looks like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda函数的高级设置页面如下：
- en: '![](img/6883b0ae-4195-4621-9e2a-af3407fd3ee2.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6883b0ae-4195-4621-9e2a-af3407fd3ee2.png)'
- en: Functions as containers
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为容器
- en: For understanding the concept of functions being executed as/inside containers,
    we need to properly understand the concept of containers. To cite the definition
    of a container from the Docker documentation ([https://www.docker.com/what-docker](https://www.docker.com/what-docker))[:](https://www.docker.com/what-docker)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解函数作为/在容器内执行的概念，我们需要正确理解容器的概念。引用Docker文档中对容器的定义（[https://www.docker.com/what-docker](https://www.docker.com/what-docker)）[:](https://www.docker.com/what-docker)
- en: 'A container image is a lightweight, stand-alone, executable package of a piece
    of software that includes everything needed to run it: code, runtime, system tools,
    system libraries, settings.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像是一个轻量级的、独立的、可执行的软件包，包括运行它所需的一切：代码、运行时、系统工具、系统库、设置。
- en: What is available for both Linux and Windows based applications; containerized
    software will always run the same, regardless of the environment.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于Linux和Windows应用程序；容器化软件将始终在相同的环境中运行，而不受环境的影响。
- en: Containers isolate software from its surroundings (for example, differences
    between development and staging environments) and help reduce conflicts between
    teams running different software on the same infrastructure.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 容器将软件与其周围环境隔离（例如开发和分段环境之间的差异），并帮助减少不同软件在同一基础设施上运行时的冲突。
- en: 'So, the concept of containers is that they are self-sustainable isolated environments
    just like the containers in a container ship that can be hosted and be worked
    upon any host OS, the host OS being the host ship in our analogy. The figurative
    depiction of the analogy would look something like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，容器的概念是它们是自包含的隔离环境，就像集装箱船上的集装箱一样，可以托管和在任何主机操作系统上工作，主机操作系统在我们的类比中是主机船。这个类比的形象描述会看起来像这样：
- en: '![](img/e2c26768-83bf-4ca5-afa0-960f651ce95a.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2c26768-83bf-4ca5-afa0-960f651ce95a.png)'
- en: 'Similar to the aforementioned analogy, AWS Lambda''s functions are also launched
    inside a unique container for each function. So, let us understand this topic
    in more detail, point by point:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与前述类比类似，AWS Lambda的函数也是在每个函数的独特容器中启动的。因此，让我们逐点更详细地了解这个主题：
- en: The Lambda function can be in the form of a single code file or in the form
    of a **deployment package**. The deployment package is a zipped file that includes
    the core function file along with the libraries which would be used by the function.
    We shall be learning in detail about how to create the deployment package in the
    *Creating deployment packages* section of this chapter.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda函数可以是单个代码文件或**部署包**的形式。部署包是一个包含核心函数文件以及函数使用的库的压缩文件。我们将在本章的*创建部署包*部分详细了解如何创建部署包。
- en: Whenever a function is triggered or started, AWS spins up an EC2 instance with
    the AWS Linux operating system for running the function. The configuration of
    the instance would be dependent on the ones provided by the user in the Advanced
    settings tab of the Lambda function.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当函数被触发或启动时，AWS会为运行函数而启动一个带有AWS Linux操作系统的EC2实例。实例的配置将取决于用户在Lambda函数的高级设置选项卡中提供的配置。
- en: There is a maximum time limit of 300 seconds, or 5 minutes, for a function to
    execute successfully, after which the container would be destroyed. So, this needs
    to be kept in mind while designing the Lambda functions and/or the deployment
    packages.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数执行成功的最长时间限制为300秒，或5分钟，之后容器将被销毁。因此，在设计Lambda函数和/或部署包时需要牢记这一点。
- en: Configuring functions
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置函数
- en: 'In this section, we will go through the ways of configuring Lambda functions
    and understand all the settings in great detail. Like in the previous section,
    we will learn about each configuration and its settings, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍配置Lambda函数的方法，并详细了解所有设置。与上一节类似，我们将了解每个配置及其设置，如下所示：
- en: 'You can go to the page of AWS Lambda by selecting it from the drop-down menu
    that is present in the top-left corner of the AWS console. This can be done as
    follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过从AWS控制台左上角的下拉菜单中选择AWS Lambda来转到AWS Lambda页面。可以按以下步骤操作：
- en: '![](img/a971c7c0-ac7c-4032-838a-9306e5ac0a07.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a971c7c0-ac7c-4032-838a-9306e5ac0a07.png)'
- en: 'Once the Lambda option is selected, it redirects the user to the AWS Lambda
    console, which looks something like this:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Lambda选项后，它会将用户重定向到AWS Lambda控制台，外观类似于这样：
- en: '![](img/5f3040c3-80f1-4d46-ad5f-61968215099a.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f3040c3-80f1-4d46-ad5f-61968215099a.png)'
- en: 'For creating a function, you need to click on the orange Create a function
    button on the right. This will open a console for the function creation. This
    looks something like this:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个函数，您需要点击右侧的橙色“创建函数”按钮。这将打开一个用于函数创建的控制台。外观类似于这样：
- en: '![](img/91b67fee-892c-4954-91a5-47b0584f523d.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91b67fee-892c-4954-91a5-47b0584f523d.png)'
- en: 'Let''s create a function from scratch in order to understand the configurations
    better. So, for doing that, click on the Author from scratch button on the top-right
    corner. After clicking it, the user will be directed to Lambda''s first-run console,
    which looks something like this:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从头开始创建一个函数，以更好地了解配置。因此，为了做到这一点，请点击右上角的“从头开始”按钮。点击后，用户将被引导到Lambda的首次运行控制台，外观类似于这样：
- en: '![](img/86d6c931-dd7b-4ee2-8ce5-2f546d3e9569.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86d6c931-dd7b-4ee2-8ce5-2f546d3e9569.png)'
- en: 'This page has three configurations which the user can select, which are Name,
    Role, and Existing role. The Name value is where the user can enter the name of
    the Lambda function. The Role value is how you can define permissions in the AWS
    environment. The Role value''s drop-down list would contain the following options:
    Choose an existing role, Create new role from template(s), and Create a custom
    role. They can be seen as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此页面有三个用户可以选择的配置，即名称、角色和现有角色。名称值是用户可以输入Lambda函数名称的地方。角色值是您可以在AWS环境中定义权限的方式。角色值的下拉列表将包含以下选项：选择现有角色、从模板创建新角色和创建自定义角色。它们可以如下所示：
- en: '![](img/ee94ac27-0a27-49bb-8c39-dcc09e308f43.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee94ac27-0a27-49bb-8c39-dcc09e308f43.png)'
- en: 'The Choose an existing role option will enable us to select an already existing
    role with pre-configured permissions. The second option helps the user with creating
    a role from pre-baked templates. The Create a custom role option allows the user
    to create a role with permissions from scratch. The list of pre-baked roles looks
    like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 选择现有角色选项将使我们能够选择具有预配置权限的现有角色。第二个选项帮助用户从预先制作的模板创建角色。创建自定义角色选项允许用户从头开始创建具有权限的角色。预先制作的角色列表如下：
- en: '![](img/605762e3-0a24-47b9-a644-eb349c5ff5c9.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/605762e3-0a24-47b9-a644-eb349c5ff5c9.png)'
- en: 'Select one from the pre-baked templates for the sake of this tutorial. By pressing Create
    function in the lower-right part of the screen, we will land on the Lambda function''s
    creation page, which looks similar to this:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了本教程的目的，从预先制作的模板中选择一个。通过在屏幕右下角的“创建函数”按钮，我们将进入Lambda函数创建页面，其外观类似于这样：
- en: '![](img/aaa97414-bac6-40c6-9f48-c034de864930.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aaa97414-bac6-40c6-9f48-c034de864930.png)'
- en: 'The preceding page indicates that we have successfully created an AWS Lambda
    function. We shall now explore the advanced settings of this function. They are
    present in the lower part of the same console. They will look something like this:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一页中，我们成功创建了一个AWS Lambda函数。现在我们将探索该函数的高级设置。它们位于同一控制台的下部。它们看起来会像这样：
- en: '![](img/b159cb6f-45db-4ad8-9f75-fc8d1f5c408e.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b159cb6f-45db-4ad8-9f75-fc8d1f5c408e.png)'
- en: We shall now try to understand each of those parts in detail.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将详细了解每个部分。
- en: 'The unfurled Environment variables section contains text boxes to enter the
    key-value pair of environment variables that will be used by our function. One
    can also optionally mention details on the encryption setting that we want to
    have for the environment variables. The encryption needs to be done via **AWS
    KMS** (**Key Management Service**). The unfurled settings box of the environment
    variables looks something like this:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开的环境变量部分包含文本框，用于输入我们函数将使用的环境变量的键值对。还可以选择提及我们希望为环境变量设置的加密设置。加密需要通过**AWS KMS**（**密钥管理服务**）进行。环境变量的展开设置框看起来像这样：
- en: '![](img/1240de6e-18aa-45f9-9ae0-dbe9acc35964.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1240de6e-18aa-45f9-9ae0-dbe9acc35964.png)'
- en: 'The next settings section is Tags. This is similar to the tagging feature of
    all the available AWS services for easy service discovery purposes. So, similar
    to all AWS services''s tags, this also needs just a key and a value. The unfurled
    Tags section looks something like this:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的设置部分是标签。这类似于所有可用AWS服务的标记功能，用于方便的服务发现目的。因此，与所有AWS服务的标记类似，这也只需要一个键和一个值。展开的标签部分看起来像这样：
- en: '![](img/c81faef8-1e1f-4f68-8ffd-4bf992e09763.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c81faef8-1e1f-4f68-8ffd-4bf992e09763.png)'
- en: 'The next section that will be visible after the Tags section is the Execution
    role section, in which the user can set the **Identity Access Management (IAM)**
    role for the execution of the Lambda function. As we have already discussed what
    IAM roles are previously in the book, we will not be covering that again here.
    If the user has not set the role when creating the function itself, they can always
    set that here. The section will be visible in the Lambda console as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标签部分之后将可见的下一部分是执行角色部分，用户可以在其中为Lambda函数的执行设置**身份访问管理（IAM）**角色。由于我们之前已经讨论过IAM角色是什么，所以在这里不会再次涉及。如果用户在创建函数时没有设置角色，他们可以在这里设置。Lambda控制台中将显示如下部分：
- en: '![](img/7125de51-b42f-4c62-879e-d1d4d75c9efa.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7125de51-b42f-4c62-879e-d1d4d75c9efa.png)'
- en: The next section is the Basic settings section, which includes settings such
    as the memory of the Lambda container, time-out for the container, and the description
    for the Lambda function. The memory of the container can range from 128 MB to
    1,536 MB. The user can choose any value within that range and will be billed accordingly.
    The time-out can be set from 1 second to 300 seconds, which is 5 minutes. The
    time-out is the time which the Lambda function and its container would run before
    being stopped or terminated. The next setting is the Description value of the
    Lambda function, which acts as the metadata of a Lambda function. The section
    looks like this in the console:![](img/f710d7d7-5215-4817-81a2-b1ec059106a6.png)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是基本设置部分，其中包括Lambda容器的内存、容器的超时时间和Lambda函数的描述等设置。容器的内存可以在128 MB到1,536 MB之间。用户可以在该范围内选择任何值，并将按相应的费用计费。超时时间可以设置为1秒到300秒，即5分钟。超时时间是Lambda函数及其容器在被停止或终止之前运行的时间。下一个设置是Lambda函数的描述值，它充当Lambda函数的元数据。控制台中的该部分如下所示：![](img/f710d7d7-5215-4817-81a2-b1ec059106a6.png)
- en: The next section is the Network section, which is also about the network settings
    of the Lambda function related to **AWS's Virtual Private Cloud** (**VPC**) and
    related subnets. Even if No VPC is selected as an option, AWS Lambda runs in its
    own secure VPC. However, if your Lambda function accesses or deals with any other
    service which is in a particular VPC or in a subnet, the corresponding information
    needs to be added in this section so that the network allows traffic from the
    Lambda function's container. This section looks like this in the console:![](img/f75cfc81-b7f7-412c-a8c9-ace0d6d69a21.jpg)The
    sensitive information in the preceding screenshot, such as the IP address and
    the ID of the VPC, are masked for security purposes.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是网络部分，也涉及与**AWS虚拟私有云**（**VPC**）和相关子网有关的Lambda函数的网络设置。即使选择了无VPC作为选项，AWS Lambda也会在其自己的安全VPC中运行。但是，如果Lambda函数访问或处理位于特定VPC或子网中的任何其他服务，则需要在此部分中添加相应的信息，以便网络允许Lambda函数容器的流量。控制台中的该部分如下所示：![](img/f75cfc81-b7f7-412c-a8c9-ace0d6d69a21.jpg)为了安全起见，前面截图中的敏感信息，如IP地址和VPC的ID，已被屏蔽。
- en: The next section is the Debugging and error handling section. This section enables
    the user to set up measures for ensuring fault tolerance and exception handling
    of the Lambda function. This includes the **Dead Letter Queue** (**DLQ**) settings.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是调试和错误处理部分。该部分使用户能够设置确保Lambda函数容错和异常处理的措施。这包括**死信队列**（**DLQ**）设置。
- en: 'Lambda automatically retries failed executions for asynchronous invocations.
    So, the payloads that were not processed would be automatically forwarded to the
    DLQ resource. The DLQ settings look like this in the Lambda console:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda会自动重试异步调用的失败执行。因此，未处理的有效负载将自动转发到DLQ资源。Lambda控制台中的DLQ设置如下：
- en: '![](img/b74e9b2e-a5e1-4007-bea9-82a6be36cf5f.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b74e9b2e-a5e1-4007-bea9-82a6be36cf5f.png)'
- en: 'The user can also enable active tracing for the Lambda functions, which would
    help in detailed monitoring of the Lambda container. This setting in the Debugging
    and error handling section of the Lambda console looks like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 用户还可以为Lambda函数启用主动跟踪，这将有助于详细监视Lambda容器。Lambda控制台中的调试和错误处理部分的设置如下：
- en: '![](img/a74a9e4c-467c-476a-81ef-81b5a7805148.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a74a9e4c-467c-476a-81ef-81b5a7805148.png)'
- en: Testing Lambda functions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda函数测试
- en: 'Just like every other software system and programming paradigm, proper testing
    of Lambda functions and serverless architectures is very important before deploying
    into production. We will try to understand the testing of Lambda functions in
    the following points:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他软件系统和编程范式一样，Lambda函数和无服务器架构在部署到生产环境之前进行适当的测试非常重要。我们将在以下几点中尝试理解Lambda函数的测试：
- en: 'In the top-most bar of the Lambda console, one can observe the Save and test
    option, which is represented by an orange button. This button saves the Lambda
    function and then runs the configured tests on that function. This looks something
    like this in the console:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Lambda控制台的最顶部栏中，可以看到保存并测试选项，用橙色按钮表示。这个按钮保存Lambda函数，然后运行配置的测试函数。在控制台中看起来像这样：
- en: '![](img/60f3caa0-0530-4b40-9e10-3dd991c15c94.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60f3caa0-0530-4b40-9e10-3dd991c15c94.png)'
- en: 'Also, in the same bar, there exists a drop-down menu that reads Select a test
    event…. This contains a list of testing events available for testing Lambda functions.
    The drop-down looks like this:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在同一栏中，存在一个下拉菜单，上面写着选择一个测试事件…. 这包含了用于测试Lambda函数的测试事件列表。下拉菜单看起来像这样：
- en: '![](img/1114f014-a1ad-4033-99b3-8cf90d913e9c.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1114f014-a1ad-4033-99b3-8cf90d913e9c.png)'
- en: 'Now, for further configuration of test events for the Lambda function, the
    user needs to select the Configure test events option in the drop-down. This will
    open a popup with the test events menu, which looks like this:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了进一步配置Lambda函数的测试事件，用户需要在下拉菜单中选择配置测试事件选项。这将打开一个带有测试事件菜单的弹出窗口，看起来像这样：
- en: '![](img/564fb42c-4c4e-4461-884b-7106e608fa50.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/564fb42c-4c4e-4461-884b-7106e608fa50.png)'
- en: 'That would open the basic Hello World template, which has three pre-configured
    JSON format test events, or edge cases. However, depending on what the Lambda
    function does, one can select some other test event. The available list of testing
    templates can be seen in the Event template drop-down menu. The list in the drop-down
    looks something like this:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开基本的Hello World模板，其中包含三个预配置的JSON格式测试事件，或边缘情况。但是，根据Lambda函数的功能，可以选择其他测试事件。可用的测试模板列表可以在事件模板下拉菜单中看到。下拉菜单中的列表看起来像这样：
- en: '![](img/905d7bd8-21d2-46c3-a276-25ebdd9a786e.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/905d7bd8-21d2-46c3-a276-25ebdd9a786e.png)'
- en: 'For example, let''s imagine we are building a pipeline that involves the Lambda
    function getting started whenever an image file is added to an S3 bucket, and
    the function does some image processing tasks and puts it back to some data store.
    The test event of the S3 Put notification looks something like this:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，让我们想象我们正在构建一个流水线，其中Lambda函数在将图像文件添加到S3存储桶时启动，并且该函数执行一些图像处理任务并将其放回到某个数据存储中。S3
    Put通知的测试事件看起来像这样：
- en: '![](img/339a2a51-15e7-4502-b96a-1eb712e5514e.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/339a2a51-15e7-4502-b96a-1eb712e5514e.png)'
- en: 'After selecting or creating a test event, the user can select the Create option
    in the bottom-right corner of the event creation console, wherein you shall be
    asked to enter a name for the event. After entering the necessary details, the
    user will be re-directed back to the Lambda console. Now, when you check the TestEvent drop-down
    in the Lambda console, you can see the saved test event in the list. This can
    be verified as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择或创建测试事件后，用户可以在事件创建控制台的右下角选择创建选项，然后将被要求为事件输入名称。输入必要的细节后，用户将被重定向回Lambda控制台。现在，当您在Lambda控制台中检查TestEvent下拉菜单时，可以在列表中看到保存的测试事件。可以按以下方式验证：
- en: '![](img/7d7b1f3b-595b-4bad-bf33-99ac957fade3.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d7b1f3b-595b-4bad-bf33-99ac957fade3.png)'
- en: As I have named the event as **TestEvent**, the test is visible by the same
    name in the events drop-down menu.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我将事件命名为**TestEvent**，因此在事件下拉菜单中以相同的名称可见测试。
- en: 'Additionally, when we take a closer look at the event structure of S3 in the
    test event, we can observe the meta-details that are being made available to the
    Lambda function. The event structure looks like this:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，当我们仔细观察S3测试事件中的事件结构时，我们可以观察到向Lambda函数提供的元数据。事件结构看起来像这样：
- en: '![](img/ff15ffd2-7bb5-4303-bc13-bba656deb732.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff15ffd2-7bb5-4303-bc13-bba656deb732.png)'
- en: Versioning Lambda functions
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda函数的版本控制
- en: 'The concept of the **Version Control System** (**VCS**) is for controlling
    and managing versions of code. This functionality is available directly from the
    main Lambda console. Let''s try and learn how to version our Lambda functions:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**版本控制系统**（**VCS**）的概念是用于控制和管理代码版本。这个功能直接从主Lambda控制台中可用。让我们尝试学习如何为我们的Lambda函数进行版本控制：'
- en: 'The first option in the Actions drop-down in the Lambda console is the Publish
    new version option. This option can be seen here:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda控制台中操作下拉菜单中的第一个选项是发布新版本选项。可以在这里看到这个选项：
- en: '![](img/7b880937-3308-472d-800e-00ed54ce1452.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b880937-3308-472d-800e-00ed54ce1452.png)'
- en: 'When the Publish new version option is selected, the versioning popup of the
    Lambda console would be seen on the console. This would ask about the name for
    the new version of your Lambda function. The popup looks something like this:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当选择发布新版本选项时，Lambda控制台的版本控制弹出窗口将出现在控制台上。这将询问您的Lambda函数的新版本名称。弹出窗口看起来像这样：
- en: '![](img/b78150b6-6c9e-4eee-905f-17633a6a48cf.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b78150b6-6c9e-4eee-905f-17633a6a48cf.png)'
- en: 'After clicking the Publish button, you will be re-directed to the main Lambda
    console. The successfully created Lambda version in the console looks something
    like this:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击发布按钮后，您将被重定向到主Lambda控制台。控制台中成功创建的Lambda版本看起来像这样：
- en: '![](img/a117ec47-8651-41bc-b503-6db458194811.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a117ec47-8651-41bc-b503-6db458194811.png)'
- en: 'In the bottom half of the page, the following message can be noticed: Code
    and handler editing is only available for the $LATEST version. This means that
    one can only edit the code in the version named $LATEST.  The versioned version
    of Lambda functions are read-only and cannot be edited and manipulated. When something
    goes wrong or when the user wants to revert back or refer to a previous version,
    that version will overlay the $LATEST version to make edits possible. The message
    looks like this:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面的下半部分，可以注意到以下消息：代码和处理程序编辑仅适用于$LATEST版本。这意味着只能编辑名为$LATEST的版本中的代码。版本化的Lambda函数是只读的，不能被编辑和操作。当出现问题或用户想要恢复或参考以前的版本时，该版本将覆盖$LATEST版本以使编辑成为可能。消息看起来像这样：
- en: '![](img/6c35f1e1-7d34-4c9d-8119-2f43400a4d43.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c35f1e1-7d34-4c9d-8119-2f43400a4d43.png)'
- en: 'When the Click here to go to $LATEST link is clicked, the user will be re-directed
    to the $LATEST version of the function, which can be edited and manipulated by
    the user. The console of the $LATEST version of the Lambda function looks like
    this:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点击“点击此处转到 $LATEST 链接”时，用户将被重定向到函数的 $LATEST 版本，用户可以对其进行编辑和操作。Lambda 函数的 $LATEST
    版本控制台如下所示：
- en: '![](img/d872e1c7-1d3b-4aa7-afce-6a4e9a8b1117.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d872e1c7-1d3b-4aa7-afce-6a4e9a8b1117.png)'
- en: Creating deployment packages
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建部署包
- en: 'Lambda functions that have external libraries as dependencies can be packaged
    as deployment packages and be uploaded into the AWS Lambda console. This is very
    similar to creating a virtual environment in Python. So in this section, we shall
    learn and understand the process of creating Python deployment for using in the
    Lambda functions. We shall try and understand the process of creating deployment
    packages in detail, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 具有外部库依赖项的 Lambda 函数可以打包为部署包，并上传到 AWS Lambda 控制台。这与在 Python 中创建虚拟环境非常相似。因此，在本节中，我们将学习并了解创建
    Python 部署包以在 Lambda 函数中使用的过程。我们将尝试并详细了解创建部署包的过程，如下所示：
- en: Deployment packages are generally in the format of ZIP packages. The contents
    of the ZIP package is exactly the same as a normal library of any programming
    language.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署包通常是 ZIP 包的格式。ZIP 包的内容与任何编程语言的普通库完全相同。
- en: 'The package structure should be such that the library folders and the function
    file are in the same destination or in the same hierarchy inside the folder structure
    of the deployment package. The layout looks something like this:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包的结构应该是库文件夹和函数文件在部署包的相同目标或相同层次结构内。布局看起来像这样：
- en: '![](img/f46e42f6-0700-481b-be63-584d08bb0682.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f46e42f6-0700-481b-be63-584d08bb0682.png)'
- en: 'The Python libraries can be installed by using the `pip install <library_name>
    -t <path_of_the_target_folder>` command. This will install the package inside
    the target folder. This can be done as in the following screenshot:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用 `pip install <library_name> -t <path_of_the_target_folder>` 命令安装 Python
    库。这将在目标文件夹内安装包。如下截图所示：
- en: '![](img/986316e5-9244-4ed2-bc1c-ff4ed09e6777.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/986316e5-9244-4ed2-bc1c-ff4ed09e6777.png)'
- en: 'Now, when we have the entire deployment package''s folder along with the library
    folders ready, we need to zip all of the folders including the Lambda function
    file before uploading it into the console. The following screenshot shows how
    the zipping needs to be done as per the folder hierarchy:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当我们有整个部署包文件夹以及库文件夹准备就绪时，我们需要在上传到控制台之前将所有文件夹包括 Lambda 函数文件进行压缩。以下截图显示了如何根据文件夹层次结构进行压缩：
- en: '![](img/d5dac1d7-bb73-4319-ba28-b07c503af622.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5dac1d7-bb73-4319-ba28-b07c503af622.png)'
- en: 'Now, as the zipped package is ready, we shall be trying to upload the package
    to the Lambda console for processing. For uploading a Lambda package, we need
    to select the drop-down list of the Code entry type option in the console. The
    selection looks like this in the Lambda console:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，由于压缩包已准备就绪，我们将尝试将包上传到 Lambda 控制台进行处理。要上传 Lambda 包，我们需要在控制台中选择“代码输入类型”选项的下拉列表。在
    Lambda 控制台中，选择如下所示：
- en: '![](img/6ccd81c5-5cfb-4e7d-a4c5-f46fe32736ad.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ccd81c5-5cfb-4e7d-a4c5-f46fe32736ad.png)'
- en: 'Once the Upload a .ZIP file option is selected, the uploader will become visible,
    where the user can directly upload the deployment package or even upload it via
    an S3 bucket. The wizard would look like this in the Lambda console:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦选择了“上传 .ZIP 文件”选项，上传者将变为可见状态，用户可以直接上传部署包，甚至可以通过 S3 存储桶上传。在 Lambda 控制台中，向导将如下所示：
- en: '![](img/6f4fa67b-53b7-4580-a9a9-c2258507f36c.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f4fa67b-53b7-4580-a9a9-c2258507f36c.png)'
- en: 'As mentioned previously, the user can choose to upload the deployment package
    via an S3 file location too. This wizard looks like this in the Lambda console:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，用户还可以选择通过 S3 文件位置上传部署包。在 Lambda 控制台中，该向导如下所示：
- en: '![](img/12130c7f-5d6e-487a-9c9f-76eb692be568.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12130c7f-5d6e-487a-9c9f-76eb692be568.png)'
- en: 'The deployment package''s naming should be aligned with the values entered
    in the handler part of the settings. The deployment package''s name and the Lambda
    function file''s name are separated by a dot (`.`) and arranged in that order.
    This can be explicitly seen in the following screenshot:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署包的命名应与设置中处理程序部分输入的值对齐。部署包的名称和 Lambda 函数文件的名称由点（`.`）分隔，并按照这个顺序排列。可以在以下截图中明确看到：
- en: '![](img/406c2dc0-125f-4d22-850a-6be24e2035fe.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/406c2dc0-125f-4d22-850a-6be24e2035fe.jpg)'
- en: '`index` should be the name of the Lambda function''s file name deployment package.
    The `handler` function file is the name of the core function handler inside, which
    is the Lambda function. As AWS''s documentation states:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`index` 应该是 Lambda 函数的 文件名 部署包的名称。`handler` 函数文件是核心函数处理程序的名称，即 Lambda 函数。正如
    AWS 的文档所述：'
- en: The module-name export value in your function". For example, index.handler would
    call exports.handler in index.py.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中导出的模块名称值”。例如，index.handler 将调用 index.py 中的 exports.handler。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned the concepts of how triggers work for AWS Lambda
    and how to select triggers depending on the problem statement and time intervals,
    in case of cron job triggers. We understood what Lambda functions are, along with
    understanding their functionalities and settings related to memory, VPCs, security,
    and fault tolerance. We also learned about the way container reuse is done under
    the hood specifically for AWS Lambda. Then, we covered event-driven functions
    and how they are implemented under the hood, the concept of containers, and their
    uses and applications in the domain of software engineering in general. Most importantly,
    from the concepts we learned regarding containers, we can now appreciate the options
    for choosing containers for running the Lambda functions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 AWS Lambda 触发器的工作原理以及根据问题陈述和时间间隔选择触发器的概念，特别是在 cron 作业触发器的情况下。我们了解了
    Lambda 函数是什么，以及它们的功能和与内存、VPC、安全性和容错相关的设置。我们还了解了 AWS Lambda 特定的容器重用方式。然后，我们涵盖了事件驱动函数以及它们在软件工程领域中的概念、用途和应用。最重要的是，通过我们学习的容器概念，我们现在可以欣赏选择容器来运行
    Lambda 函数的选项。
- en: After that, we talked about all the configuration settings available in the
    AWS Lambda dashboard, which are necessary to build and run a Lambda function from
    start to finish without any settings-related problems. We also learned about and
    understood the security settings inside Lambda so that the necessary VPC details
    and security keys settings are taken care of when configuring our Lambda functions.
    This was followed by testing Lambda functions depending on the choice of trigger
    selected. We learned what the responses of various AWS services look like, as
    they are the inputs for the Lambda functions. We then learned how to write custom
    hand-made tests for custom testing purposes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们讨论了 AWS Lambda 仪表板中的所有配置设置，这些设置对于从头到尾构建和运行 Lambda 函数而言是必要的，而且不会出现任何与设置相关的问题。我们还学习了并了解了
    Lambda 中的安全设置，以便在配置 Lambda 函数时处理必要的 VPC 详细信息和安全密钥设置。接着是根据所选触发器的选择来测试 Lambda 函数。我们学习了各种
    AWS 服务的响应是什么样子，因为它们是 Lambda 函数的输入。然后，我们学习了如何编写自定义手工测试以进行自定义测试。
- en: Following that, we saw how versioning happens for the AWS Lambda functions.
    We learned the differences between past and present versions. We also learned
    that the present version is immutable, unlike the past versions, and also how
    to revert to past versions without much effort. We also learned how to create
    deployment packages for functions that have dependencies on external packages,
    which are not included in Python's standard library. We came across the function
    code naming nuances, including the filename and the method handler names, followed
    by the two ways deployment packages can be uploaded to the Lambda console; one
    being a manual upload and the other being from an S3 file location.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们看到了 AWS Lambda 函数的版本控制是如何进行的。我们学习了过去版本和现在版本之间的区别。我们还了解到现在版本是不可变的，不像过去的版本，以及如何在不费力的情况下恢复到过去的版本。我们还学习了如何为依赖于外部包的函数创建部署包，这些包不包括在
    Python 的标准库中。我们遇到了函数代码命名的微妙之处，包括文件名和方法处理程序名称，以及部署包可以上传到 Lambda 控制台的两种方式；一种是手动上传，另一种是从
    S3 文件位置上传。
- en: In the next chapter, we will be gaining a detailed understanding of the different
    triggers available in the Lambda console and how to use them. We will also learn
    about implementing them in Python code. We will understand the event structures
    and the responses from different AWS services and use that to build our Lambda
    functions. We will understand how to integrate each trigger into a Lambda function
    and do a specific task in Python. Finally, we will also be learning about ideas
    and best practices on how to move your existing infrastructures to serverless
    using the serverless paradigm.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细了解 Lambda 控制台中提供的不同触发器以及如何使用它们。我们还将学习如何在 Python 代码中实现它们。我们将了解事件结构以及来自不同
    AWS 服务的响应，并利用它们来构建我们的 Lambda 函数。我们将了解如何将每个触发器集成到 Lambda 函数中，并在 Python 中执行特定任务。最后，我们还将学习有关如何使用无服务器范例将现有基础架构迁移到无服务器的想法和最佳实践。
