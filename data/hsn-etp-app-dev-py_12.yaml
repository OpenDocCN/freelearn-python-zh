- en: Testing and Tracing in Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务中的测试和跟踪
- en: Up until now, we have got to see how microservices can help us change the way
    that we build and deliver our application to production. Be it faster rollouts
    for new features, or keeping the teams small, microservices enable that for us.
    But with this architecture, where every single component is a small service in
    its own, we have got some challenges to solve. These challenges involve how we
    can aim to ship a stable and bug free application into production while following
    the microservices approach.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了微服务如何帮助我们改变构建和交付应用程序到生产环境的方式。无论是更快地推出新功能，还是保持团队的小规模，微服务都能为我们实现这一点。但是在这种架构中，每个组件都是自己的小服务，我们有一些挑战需要解决。这些挑战涉及我们如何在遵循微服务方法的同时将稳定且无错误的应用程序部署到生产环境中。
- en: Inside the Monolithic architecture, we had only a small number of moving components
    that required testing. We could write unit tests to test the individual methods
    of the Monolithic application, and then move on to integration testing to verify
    if these components operate correctly with each other. But now, with the advent
    of microservices, we have got more and more moving components in the picture.
    Inside the microservices, we have different features where each feature is described
    as its own microservice.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体架构中，我们只有少量需要测试的移动组件。我们可以编写单元测试来测试单体应用程序的各个方法，然后进行集成测试以验证这些组件是否与彼此正确运行。但是现在，随着微服务的出现，图片中有越来越多的移动组件。在微服务内，我们有不同的功能，其中每个功能都被描述为自己的微服务。
- en: Over the course of this chapter, we will take a look at how the testing of microservices
    differ from that of the Monolithic applications, where we now need to account
    not only for the correct functioning of an individual microservice, but also have
    to make sure that these services communicate with each other in a well-defined
    manner to produce the correct results for the business needs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的过程中，我们将看看微服务的测试与单体应用程序的测试有何不同，我们现在不仅需要考虑单个微服务的正确功能，还需要确保这些服务以明确定义的方式相互通信，以满足业务需求的正确结果。
- en: Also, since the information in a microservices-based application flows from
    one service to another, it becomes important for us to understand the flow of
    this information when a client makes a request to when the response is generated.
    By doing this, we can accurately find and fix any of the issues that may generate
    an incorrect response or cause a bottleneck in the application performance.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于基于微服务的应用程序中的信息从一个服务流向另一个服务，我们需要了解当客户端发出请求时到生成响应时这些信息的流动。通过这样做，我们可以准确地找到并修复可能导致不正确响应或导致应用程序性能瓶颈的任何问题。
- en: 'As a reader, by the end of this chapter, you can expect to learn about the
    following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为读者，在本章结束时，您可以期望了解以下内容：
- en: The difference between the testing of Monolithic applications and microservices-based
    applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体应用程序和基于微服务的应用程序的测试之间的差异
- en: Approaching the testing of microservices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务测试的方法
- en: Implementing distributed tracing inside microservices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在微服务内实施分布式跟踪
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code listings in this book can be found under `chapter12` directory at [https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码清单可以在[https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)的`chapter12`目录下找到。
- en: 'The code samples can be cloned by running the following command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过运行以下命令克隆代码示例：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The requirements for the Python-based application can be installed by executing
    the following command on your Terminal:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在终端上执行以下命令来安装基于Python的应用程序的要求：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Beyond the usual Python-based requirements, the code samples in this chapter
    need to have the following additional dependencies to work correctly:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通常的基于Python的要求之外，本章中的代码示例需要具有以下附加依赖项才能正常工作：
- en: '**Docker**: The docker client is required to run some of the tools that we
    will be using inside the ...'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：需要docker客户端来运行我们将在其中使用的一些工具...'
- en: Testing in the microservices world
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务世界中的测试
- en: As we move away from the Monolithic architecture, we need to understand that
    the processes that used to work for us in the Monolithic application development
    also need to move along. During the development of the Monolithic application,
    we used to work with the testing strategies such as unit testing, which aimed
    to cover the functionality of the individual methods inside an application, followed
    by integration testing, which is used to cover the fact that these methods operate
    correctly with each other.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们远离单体架构，我们需要了解在单体应用程序开发中为我们工作的过程也需要跟随。在开发单体应用程序期间，我们通常使用单元测试等测试策略，旨在覆盖应用程序内部各个方法的功能，然后进行集成测试，用于覆盖这些方法是否与彼此正确运行的事实。
- en: Inside the microservices architecture, things get a little bit complicated.
    We now have small services where each service is supposed to perform a specific
    functionality. These services indeed need to interact with each other over the
    network to produce any meaningful output for the business use case that might
    be there. But things do not end here. Each of these microservices are composed
    of several individual methods and interfaces that it needs to work correctly.
    This makes the case of testing the microservices an interesting one, because now,
    we not only need to perform the unit testing of the individual components of the
    microservices and the interaction between them, but we also need to test if the
    microservices are able to operate correctly with each other.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，情况变得有点复杂。现在我们有了小型服务，每个服务都应该执行特定的功能。这些服务确实需要通过网络相互交互，以产生任何可能存在的业务用例的有意义输出。但事情并不会在这里结束。每个微服务都由多个需要正确工作的个体方法和接口组成。这使得测试微服务的情况变得有趣，因为现在我们不仅需要对微服务的各个组件和它们之间的交互进行单元测试，还需要测试微服务是否能够正确地相互操作。
- en: This asks for a more elaborate testing of the application, with several different
    techniques. Let's take a look at these techniques to understand them better.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要对应用程序进行更详尽的测试，使用多种不同的技术。让我们看看这些技术，以便更好地理解它们。
- en: Unit testing in microservices
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务中的单元测试
- en: Unit testing inside microservices follows the same principles as in the testing
    of the Monolithic applications. We work on writing the unit tests for the individual
    methods inside a microservice and run those tests either manually or through automation
    so as to validate if those components are producing the expected result or not.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务内的单元测试遵循与单体应用程序测试相同的原则。我们致力于为微服务内的各个方法编写单元测试，并手动或通过自动化运行这些测试，以验证这些组件是否产生了预期的结果。
- en: Functionality testing in microservices
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务中的功能测试
- en: Once we are sure that the individual methods inside a microservice work properly,
    we need to make sure that a microservice, in its complete independence, is able
    to function without any kind of issues. This happens because most of the microservices
    are a complete package in themselves. They come with their own set of dependencies,
    as well as the data sources through which they can manage their data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定微服务内部的各个方法正常工作，我们需要确保微服务在完全独立的情况下能够在没有任何问题的情况下运行。这是因为大多数微服务本身就是一个完整的包。它们具有自己的一套依赖项，以及可以管理其数据的数据源。
- en: As a developer, it is important for us to make sure that the microservice is
    able to interact properly with its dependencies. For this, we work on implementing
    the functionality testing for the microservices.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，重要的是确保微服务能够与其依赖项正确交互。为此，我们致力于实现微服务的功能测试。
- en: Also, during the functionality testing, we need to take care of certain things.
    Since each API endpoint inside a microservice may need to interact with some other
    microservice to produce the correct result, we might need to mock the presence
    of some microservices for the functionality testing to complete successfully.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在功能测试期间，我们需要注意一些事情。由于微服务内的每个API端点可能需要与其他微服务交互以产生正确的结果，我们可能需要模拟某些微服务的存在，以便功能测试能够成功完成。
- en: Integration testing in microservices
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务中的集成测试
- en: Once we are sure that our microservices work correctly with their dependencies,
    it's time for us to make sure that they have the same checkboxes ticked when they
    are interacting with each other. This is important due to the fact that these
    services, no matter what, need to interact with each other to produce any meaningful
    business outcome.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定我们的微服务与其依赖项正确工作，就是时候确保它们在相互交互时也具有相同的复选框。这是重要的，因为这些服务无论如何都需要相互交互，以产生任何有意义的业务结果。
- en: During the integration tests, we usually aim to test the request response cycle
    by introducing both the correct and incorrect parameters to an API endpoint so
    as to verify that the microservices are able to handle both the use cases and
    do not fail. This ensures that the communication interfaces between two external
    services are robust enough for the varied inputs that ...
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成测试期间，我们通常旨在通过向API端点引入正确和不正确的参数来测试请求-响应周期，以验证微服务能够处理两种用例并且不会失败。这确保了两个外部服务之间的通信接口足够健壮，能够处理各种输入...
- en: End-to-end testing in microservices
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务中的端到端测试
- en: Once we have assured that the different microservices are able to operate seamlessly
    with each other to generate a meaningful result, it's time to validate if the
    whole system, consisting of the different microservices and their dependencies,
    work without any problems. This kind of testing aims to cover the request-response
    cycle through the whole system, validating the outputs produced in the intermediate
    stages, as well as the final stages. This is known as **end-to-end** testing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确保不同的微服务能够无缝地相互操作以产生有意义的结果，就是时候验证整个系统，包括不同的微服务及其依赖项，是否能够在没有任何问题的情况下工作。这种测试旨在覆盖整个系统的请求-响应周期，验证中间阶段产生的输出以及最终阶段。这被称为端到端测试。
- en: This kind of testing ensures that the system as a whole behaves in a well-defined
    manner and does not produce any surprises when an input that is beyond the domain
    of the system is provided to the system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试确保整个系统以明确定义的方式运行，并且在向系统提供超出系统域的输入时不会产生任何意外。
- en: Scalability testing
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性测试
- en: Every microservice inside the infrastructure is made to handle a certain set
    of requests. As the number of requests to the application increases, some of the
    microservices may see an increased load on them in comparison to the other services.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施中的每个微服务都是为处理一定的请求而设计的。随着对应用程序的请求数量增加，一些微服务可能会比其他服务承受更大的负载。
- en: Imagine there is an e-commerce website that is based upon the microservices
    architecture. There is a flash sale going on, and a lot of customers are trying
    to checkout and pay for their purchase at the same time. If the services that
    handle the checkout and payment for the customers does not scale up during the
    increased load, the customers may face increased response times or timeouts, creating
    chaos for the e-commerce company, whose customer care might now be busy in dealing
    with ...
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，有一个基于微服务架构的电子商务网站。正在进行限时抢购，很多顾客同时尝试结账和付款。如果处理顾客结账和付款的服务在负载增加时没有扩展，顾客可能会面临增加的响应时间或超时，给电子商务公司带来混乱，其客户服务现在可能正忙于处理...
- en: Challenges in microservices testing
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务测试中的挑战
- en: 'The microservice architecture raises quite some challenges when it comes to
    testing. These challenges sometimes happen as a side effect of the architecture,
    the poor testing strategy, or the inexperience with the microservices architecture.
    The following are some of the challenges that make microservices testing a complex
    procedure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及测试时，微服务架构提出了一些挑战。这些挑战有时是架构的副作用，测试策略不佳，或者对微服务架构的经验不足。以下是使微服务测试成为复杂过程的一些挑战：
- en: '**Incomplete knowledge of the microservices**: For integration testing and
    debugging of issues inside an application built over microservices architecture,
    the tester responsible for writing the tests for the application needs to have
    complete knowledge about the infrastructure and the individual microservices.
    Without this knowledge, the tester is unable to write tests that can cover all
    the possible request flows inside an application that may result in some of the
    bugs escaping during the testing phase.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对微服务的知识不完整**：对于基于微服务架构构建的应用程序的集成测试和调试问题，负责编写应用程序测试的测试人员需要完全了解基础设施和各个微服务。没有这些知识，测试人员无法编写能够覆盖应用程序中所有可能的请求流程的测试，这可能导致一些错误在测试阶段逃脱。'
- en: '**Poor coordination**: In the development of microservices, there are multiple
    teams that own their set of microservices, and are usually working on their pace.
    This may cause an issue in the coordination and can delay the testing of the application
    in case a microservice, on which there are certain dependencies, has still not
    come out of the development phase.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协调不足**：在开发微服务时，有多个团队拥有自己的一组微服务，并且通常以自己的节奏工作。这可能会导致协调问题，并且可能会延迟应用程序的测试，如果某个微服务，其上有某些依赖，仍然没有完成开发阶段。'
- en: '**Increased complexity**: For an application that has only a small number of
    microservices, the testing is usually easy. But this testing becomes more and
    more cumbersome as the number of microservices powering an application increases.
    This is because now, the testers are supposed to write tests for the increased
    number of request flows, and also to make sure that the different API endpoints
    function as intended.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加的复杂性**：对于只有少量微服务的应用程序，测试通常很容易。但随着支持应用程序的微服务数量的增加，这种测试变得越来越繁琐。这是因为现在测试人员需要为增加的请求流程编写测试，并确保不同的API端点按预期运行。'
- en: '**High flexibility**: Microservices allow for increased flexibility. As a developer,
    we are free to choose a technology stack that is going to power a particular microservice.
    The same thing adds to the increased issues for the testing of the application
    because now, the tests need to take into account the different types of components
    that are being used to power a particular microservice.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高灵活性**：微服务允许增加灵活性。作为开发人员，我们可以自由选择技术栈来支持特定的微服务。同样，这也增加了应用程序测试的问题，因为现在测试需要考虑用于支持特定微服务的不同类型的组件。'
- en: 'The preceding points are a few challenges that make the work of testing the
    microservices a challenging task. However, every problem comes with a solution,
    and so do these challenges. Let''s take a look at the possible workarounds we
    have to overcome these challenges, outlined as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上述观点是使测试微服务工作成为一项具有挑战性的任务的一些挑战。然而，每个问题都有解决方案，这些挑战也不例外。让我们看看我们有哪些可能的解决方法来克服这些挑战，如下所述：
- en: '**Implement release schedules**: The teams responsible for building an application
    can commit to a schedule for the release of application in terms of Milestone.
    At every stage in the Milestone, some of the services are made available for testing
    based on the priority of the service to be deployed. This helps in improving the
    team''s coordination.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实施发布计划**：负责构建应用程序的团队可以承诺按里程碑发布应用程序的计划。在每个里程碑阶段，根据要部署的服务的优先级，一些服务将可用于测试。这有助于改善团队的协调。'
- en: '**Standardize the API endpoints:** Every service needs to expose a set of APIs
    that it uses for taking in a request and generating a response. Standardizing
    the APIs and defining what parameters a particular API endpoint may require helps
    a lot during the testing phase, where the testers can now mock a service easily,
    even if the service is not yet available for testing.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准化API端点**：每个服务都需要公开一组用于接收请求和生成响应的API。标准化API并定义特定API端点可能需要的参数在测试阶段非常有帮助，测试人员现在可以轻松地模拟一个服务，即使该服务尚未可用于测试。'
- en: '**Standardize development practices**: Although every team that is responsible
    for the development of a particular microservice is free to use any set of tools
    for the development of microservice, it is usually a good practice to standardize
    the set of tools and technologies that may be used by a team so as to avoid unnecessary
    complexity inside the infrastructure.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准化开发实践**：尽管负责开发特定微服务的每个团队都可以自由选择用于开发微服务的任何一组工具，但通常最好将团队可能使用的一组工具和技术标准化，以避免基础设施内部的不必要复杂性。'
- en: '**Integration of DevOps practices**: As the shift to microservices architecture
    happens, the DevOps practices should also be adopted, which aims to make the teams
    responsible for the complete life cycle of the microservice they are developing.
    This not only helps in speeding up the development process, but also allows for
    thorough testing of the microservices before they are deployed in production.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成DevOps实践**：随着微服务架构的转变，应该采用DevOps实践，旨在使团队对其正在开发的微服务的完整生命周期负责。这不仅有助于加快开发过程，还允许在部署到生产环境之前对微服务进行彻底测试。'
- en: Now, we are aware of what kind of changes the process requires for the testing
    of the microservices architecture. This allows us to plan our strategy ahead,
    and make sure that the services are well-tested before they are deployed into
    the production environment.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道了测试微服务架构所需的变化。这使我们能够提前规划我们的策略，并确保服务在部署到生产环境之前经过了充分测试。
- en: With the knowledge of testing in place, it's now time to understand a very important
    concept in the area of microservices that allows us to understand how the individual
    services are behaving in production.  This also allows us to figure out where
    exactly a particular request inside a microservices-based application is failing.
    So, let's take a deep dive into this concept.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试知识的基础上，现在是时候了解微服务领域中一个非常重要的概念，它让我们能够了解个别服务在生产环境中的行为。这也让我们能够找出基于微服务的应用程序中特定请求失败的确切位置。因此，让我们深入了解这个概念。
- en: Tracing requests inside microservices
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务内部的请求追踪
- en: Inside any application, a request may flow through several components before
    a final response for the request is generated. All of these components may do
    some processing that might be required on the process before they hand the request
    off to another component.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序内，一个请求可能在生成请求的最终响应之前流经多个组件。所有这些组件可能会在将请求交给另一个组件之前进行一些处理，这些处理可能在进程之前是必需的。
- en: The tracing of a request allows us to visualize a rich amount of detail about
    the flow of a particular request. With the complete picture of the flow of the
    request, we can now work on finding out the places that may be causing a bottleneck
    in the performance of the request-response cycle, or figure out the components
    that may be causing the generation of an incorrect result.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请求追踪使我们能够可视化关于特定请求流的丰富细节。有了对请求流的完整了解，我们现在可以着手查找可能导致请求-响应周期性能瓶颈的地方，或者找出可能导致生成不正确结果的组件。
- en: Today, in the application development world, any serious application ...
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，在应用程序开发世界中，任何严肃的应用程序...
- en: The OpenTracing standard
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenTracing标准
- en: Currently, there are a number of solutions out there in the wild that provide
    the functionality of implementing tracing for applications. Some of these solutions
    are proprietary, while the others are open source in nature.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，市面上有许多解决方案提供了实现应用程序追踪功能。其中一些解决方案是专有的，而另一些是开源的。
- en: As a developer, you are free to choose any of them based on the requirements
    of the application, and what facilities are provided by the solution you have
    chosen. But the problem is, what happens if you want to move to a different tracing
    solution because the solution provides better features and more control over the
    environment? Now you are stuck because you might need to change a lot of things
    in your infrastructure and the application code to get the new tracing solution
    to work. That's a lot of trouble.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，您可以根据应用程序的要求和所选择解决方案提供的功能自由选择任何解决方案。但问题是，如果您想要切换到不同的追踪解决方案，因为该解决方案提供了更好的功能和更多对环境的控制，会发生什么？现在您陷入困境，因为您可能需要更改基础设施和应用程序代码中的许多内容才能使新的追踪解决方案正常工作。这是很麻烦的。
- en: The OpenTracing standard provides a common set of vendor neutral APIs and instrumentation
    for implementing distributed tracing inside the applications. Any tracing solution
    that implements this set of standard APIs is compatible with the OpenTracing standard,
    and can interoperate with the other tools that follow the same standard.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTracing标准提供了一组通用的供应商中立API和仪器，用于在应用程序内实现分布式追踪。任何实现了这组标准API的追踪解决方案都与OpenTracing标准兼容，并且可以与遵循相同标准的其他工具进行互操作。
- en: Our choice of Jaeger as a tracing tool for our demo applications is also an
    OpenTracing compliant tool. Now, without spending any more time, let's get our
    hands dirty by implementing tracing inside the application we built in the previous
    chapter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择Jaeger作为演示应用程序的追踪工具，它也是符合OpenTracing标准的工具。现在，让我们不再浪费时间，在我们在上一章中构建的应用程序内实现追踪。
- en: Implementing tracing inside ToDo manager
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在待办事项管理器内实现追踪
- en: In the previous chapter, we worked on building a simple application that allows
    us to manage `ToDo` lists. It's time for us to implement request tracing inside
    this application. For the first example, we will work on implementing tracing
    of the requests inside our user service.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们致力于构建一个简单的应用程序，允许我们管理“待办事项”列表。现在是时候在这个应用程序内实现请求追踪了。作为第一个示例，我们将致力于在用户服务内实现请求追踪。
- en: 'For the tracing to work, we will need to have a few requirements in place.
    If you followed the *Technical requirements* section of this book, you are in
    a good place to start working with the tutorial. But, before we dive into implementing
    the tracing, let''s take a look at the following components that we will require:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使追踪工作，我们需要满足一些要求。如果您遵循了本书的*技术要求*部分，您就可以开始使用本教程了。但在我们深入实施追踪之前，让我们看看我们将需要的以下组件：
- en: '**Jaeger all-in-one image:** The Jaeger all-in-one image provides us with the
    Jaeger server, the agent, and a UI that ...'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jaeger全一体图像：** Jaeger全一体图像为我们提供了Jaeger服务器、代理和UI...'
- en: Distributed tracing
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式追踪
- en: Inside the microservices world, the requests may travel from one service to
    another before a final response is generated. Even our simple example of a `todo`
    list management application shows this behavior, where the `todo` manager service
    frequently makes a request to the user service to implement user authentication,
    and to gather the details about the user, thus creating a new `todo` list.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务世界中，请求可能在生成最终响应之前从一个服务传输到另一个服务。即使是我们简单的`todo`列表管理应用程序的示例也展示了这种行为，`todo`管理器服务经常向用户服务发出请求以实现用户身份验证，并收集有关用户的详细信息，从而创建一个新的`todo`列表。
- en: The distributed tracing system aims to enable the tracing of the requests while
    they travel from one microservice to another.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式追踪系统旨在在请求从一个微服务到另一个微服务的传输过程中实现追踪。
- en: To achieve this, the tracing systems utilize a number of mechanisms, the easiest
    of which is to embed a unique tracing key into the HTTP headers of every request
    that is being made. The tracing system is then able to differentiate and aggregate
    a particular request as it flows from one service to another by reading the request
    identifier that is present in the HTTP headers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，追踪系统利用了许多机制，其中最简单的机制是将唯一的追踪密钥嵌入到每个请求的HTTP标头中。然后，追踪系统能够通过读取HTTP标头中存在的请求标识符来区分和聚合特定请求，从而使请求从一个服务流向另一个服务。
- en: Now, it's time for us to see the distributed tracing in action. For this, we
    will make a few changes to enable tracing inside our `todo` manager service.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候让我们看看分布式追踪是如何运作的了。为此，我们将进行一些更改，以在我们的`todo`管理器服务内启用追踪。
- en: 'The following snippet of code showcases the changes required to enable distributed
    tracing inside the `todo` manager service:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了在`todo`管理器服务内启用分布式追踪所需的更改：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With the preceding code in place inside the `todo_service.py` file, we have
    the distributed tracing enabled. But before we see this in action, there are a
    few things that we need to take a look at. In the preceding code snippet, we imported
    one extra method named `install_all_patches()` from the `opentracing_instrumentation`
    library which is shown as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`todo_service.py`文件中放置了上述代码后，我们已经启用了分布式追踪。但在看到它实际运行之前，有一些事情我们需要看一看。在上述代码片段中，我们从`opentracing_instrumentation`库中导入了一个额外的方法`install_all_patches()`，如下所示：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method is responsible for enabling the tracing of the actions that takes
    place inside the SQL library or through the `python_requests` library.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法负责启用在SQL库内或通过`python_requests`库进行的操作的追踪。
- en: Once this library was imported along with the `jaeger_client` and `flask_opentracing`,
    we moved on to configure and enable the tracing for the application inside the
    `init_tracer` method.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个库与`jaeger_client`和`flask_opentracing`一起导入，我们就继续配置和启用应用程序内的追踪，这是在`init_tracer`方法中完成的。
- en: Now, with the tracing configured, let's restart our application and then make
    a request to `http://localhost:5001/list/new` by passing the appropriate parameters
    to the API endpoint for creating a new `todo` list.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，追踪已配置好，让我们重新启动应用程序，然后通过向API端点传递适当的参数，向`http://localhost:5001/list/new`发出请求，以创建一个新的`todo`列表。
- en: 'Once this action succeeds, we can navigate back to our Jaeger UI running at
    `http://localhost:16686` to see that the Jaeger UI shows the trace for the API
    call we just made. The following screenshot shows a sample of how the screen may
    look:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个操作成功，我们可以转到运行在`http://localhost:16686`上的Jaeger UI，查看Jaeger UI显示我们刚刚进行的API调用的追踪。以下截图显示了屏幕可能的样子：
- en: '![](Images/120840da-d633-454c-9c8e-560edce20740.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/120840da-d633-454c-9c8e-560edce20740.png)'
- en: As we can see from the preceding screenshot, the Jaeger UI does not only show
    the request trace for the todo manager API service endpoint, but also goes further
    into displaying the endpoint that was called inside the user service, while providing
    the details of how much time was spent in each of the API endpoints before the
    response was generated back to the client application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述截图中可以看出，Jaeger UI不仅显示了todo管理器API服务端点的请求跟踪，还进一步显示了在用户服务内调用的端点，并提供了在响应返回给客户端应用程序之前在每个API端点上花费了多少时间的详细信息。
- en: With this, we now have an idea of how the distributed tracing inside microservices
    looks. But what are the possible use cases that can see a benefit from having
    this kind of tracing in place? Let's find out.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在知道了微服务内部的分布式跟踪是什么样子的。但是有哪些可能的用例可以从这种追踪中受益呢？让我们找出来。
- en: Benefits of distributed tracing
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式追踪的好处
- en: 'With distributed tracing in place inside our application based on microservices
    architecture, we have enabled a lot of power to tackle quite some use cases, such
    as the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于微服务架构的应用程序中实施分布式追踪后，我们已经能够处理许多用例，例如以下用例：
- en: '**Understanding the flow of the application**: With distributed tracing, we
    can now visualize how an incoming request from the client flows inside our application
    from one service to another. This kind of information is really useful in figuring
    out how the application works and to enable better testing of the application.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解应用程序的流程：** 通过分布式追踪，我们现在可以可视化客户端发来的请求在我们的应用程序内从一个服务到另一个服务的流动。这种信息对于弄清楚应用程序的工作原理并实现更好的应用程序测试非常有用。'
- en: '**Narrowing down the bugs**: With the idea of how the request goes from one
    service to another, we can quickly isolate the services that may be causing the
    request to produce an incorrect response by analysing what steps ...'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩小错误范围**：通过了解请求是如何从一个服务传递到另一个服务的，我们可以通过分析每个步骤来快速确定可能导致请求产生错误响应的服务...'
- en: Summary
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Over the course of this chapter, we got to learn about how the move to microservices
    architecture affects the processes inside our application development life cycle.
    We got to learn about how the testing inside microservices-based applications
    differ from that of the Monolithic applications, and what kind of testing phases
    are usually required when dealing with the microservices architecture. We then
    learned about the challenges that arise in the testing phases, due to the move
    toward a microservices-based approach, and how we can overcome them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的过程中，我们了解了向微服务架构的转变如何影响应用程序开发生命周期内的流程。我们了解了微服务应用程序内的测试与单体应用程序的测试有何不同，以及在处理微服务架构时通常需要哪些测试阶段。然后，我们了解了在测试阶段出现的挑战，由于向微服务架构的转变，以及我们如何克服这些挑战。
- en: The second part of this chapter took us through the journey of distributed tracing
    inside the application, where we did a hands-on to enable us to trace the flow
    of requests in the ToDo manager application we developed in the previous chapter.
    During this, we got to learn about how the tracing works, and how distributed
    tracing differs from the normal methods of tracing. We also learned about how
    the OpenTracing standard is helping provide a vendor neutral API for enabling
    distributed tracing inside microservices-based applications.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第二部分带领我们深入了解应用程序内的分布式跟踪，我们进行了实际操作，使我们能够跟踪我们在上一章中开发的ToDo管理器应用程序中的请求流程。在此过程中，我们了解了跟踪的工作原理，以及分布式跟踪与常规跟踪方法的区别。我们还了解了OpenTracing标准如何帮助提供一个供应商中立的API，以实现微服务应用程序内的分布式跟踪。
- en: Now, with all of this knowledge, let's move on to take a look at another approach
    of developing our enterprise applications where instead of building services or
    components, we will build functions that execute on the occurrence of a certain
    event. The next chapter takes us through this serverless approach of application
    development.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了所有这些知识，让我们继续来看一下另一种开发企业应用程序的方法，其中我们不是构建服务或组件，而是构建在发生某个事件时执行的函数。下一章将带领我们了解这种无服务器的应用程序开发方法。
- en: Questions
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How can we write integration tests for microservices?
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何为微服务编写集成测试？
- en: How does tracing a Monolithic application differ from that of microservices-based
    applications?
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪单体应用程序与跟踪基于微服务的应用程序有何不同？
- en: What other tools are available except Jaeger for enabling distributed tracing?
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了Jaeger之外，还有哪些工具可用于实现分布式跟踪？
- en: How can we instrument a specific part of code using Jaeger?
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何使用Jaeger对代码的特定部分进行仪器化？
