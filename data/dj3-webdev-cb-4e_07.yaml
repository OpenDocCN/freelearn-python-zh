- en: Security and Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全和性能
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Making forms secure from **Cross-Site Request Forgery** (**CSRF**)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使表单免受跨站点请求伪造（CSRF）的攻击
- en: Making requests secure with **Content Security Policy** (**CSP**)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内容安全策略（CSP）使请求安全
- en: Using django-admin-honeypot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用django-admin-honeypot
- en: Implementing password validation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施密码验证
- en: Downloading authorized files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载经授权的文件
- en: Adding a dynamic watermark to images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向图像添加动态水印
- en: Authenticating with Auth0
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Auth0进行身份验证
- en: Caching the method return value
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存方法返回值
- en: Using Memcached to cache Django views
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Memcached缓存Django视图
- en: Using Redis to cache Django views
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redis缓存Django视图
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Software will never last if it inappropriately exposes sensitive information,
    makes the user suffer through interminable wait times, or requires extensive amounts
    of hardware. It is our responsibility as developers to make sure that applications
    are secure and performant. In this chapter, we will examine just some of the many
    ways we can keep our users (and yourself) safe while operating within Django applications.
    Then, we'll cover a few options for caching that can reduce processing and get
    data to users at a lower expense in terms of money and time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果软件不适当地暴露敏感信息，使用户遭受无休止的等待时间，或需要大量的硬件，那么它将永远无法持久。作为开发人员，我们有责任确保应用程序是安全和高性能的。在本章中，我们将仅仅讨论保持用户（和自己）在Django应用程序中安全运行的许多方法之一。然后，我们将介绍一些可以减少处理并以更低的成本（金钱和时间）将数据传递给用户的缓存选项。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To work with the code in this chapter, you will need the latest stable version
    of Python, a MySQL or PostgreSQL database, and a Django project with a virtual
    environment.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用本章中的代码，您需要最新稳定版本的Python，一个MySQL或PostgreSQL数据库，以及一个带有虚拟环境的Django项目。
- en: 'You can find all the code for this chapter in the `ch07` directory of this
    book''s GitHub repository at: [https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库的`ch07`目录中找到本章的所有代码：[https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition)。
- en: Making forms secure from Cross-Site Request Forgery (CSRF)
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使表单免受跨站点请求伪造（CSRF）的攻击
- en: Without the proper precautions, malicious sites could potentially invoke requests
    against your website, which would result in undesired changes being made to your
    server. For example, they could affect a user's authentication or alter content
    without the user's consent. Django comes bundled with a system for preventing
    CSRF attacks such as these, and we'll review that in this recipe.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有适当的预防措施，恶意网站可能会针对您的网站发起请求，这将导致对服务器进行不希望的更改。例如，他们可能会影响用户的身份验证或未经用户同意地更改内容。Django捆绑了一个系统来防止此类CSRF攻击，我们将在本章中进行审查。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start with the `ideas` app that we created in the *Creating an app with CRUDL
    functions* recipe in [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)*,
    Forms and Views*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们在第3章中创建的*使用CRUDL功能创建应用*中的*ideas*应用开始。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To enable CSRF prevention in Django, follow these steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Django中启用CSRF预防，请按照以下步骤操作：
- en: 'Make sure that `CsrfViewMiddleware` is included in your project settings, as
    shown here:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在项目设置中包含`CsrfViewMiddleware`，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Make sure the form view is rendered using the request context. For example,
    in the existing `ideas` app, we have this:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保使用请求上下文呈现表单视图。例如，在现有的`ideas`应用中，我们有这样的：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the template for the form, make sure it uses the `POST` method and includes
    the `{% csrf_token %}` tag:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单模板中，确保使用“POST”方法并包括“{% csrf_token %}”标记：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you use `django-crispy-forms` for the form layout, the CSRF token will be
    included by default:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用`django-crispy-forms`进行表单布局，则CSRF令牌将默认包含在其中：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Django uses a hidden field approach to prevent CSRF attacks. A token is generated
    on the server, based on a combination of request-specific and randomized information.
    Through `CsrfViewMiddleware`, this token is automatically made available via the
    request context.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Django使用隐藏字段方法来防止CSRF攻击。服务器上生成一个令牌，基于请求特定和随机化的信息组合。通过`CsrfViewMiddleware`，此令牌会自动通过请求上下文提供。
- en: 'While it is not recommended to disable this middleware, it is possible to mark
    individual views to get the same behavior by applying the `@csrf_protect` decorator:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不建议禁用此中间件，但可以通过应用“@csrf_protect”装饰器来标记单个视图以获得相同的行为：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Similarly, we can exclude individual views from CSRF checks, even when the
    middleware is enabled, by using the `@csrf_exempt` decorator:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`@csrf_exempt`装饰器从CSRF检查中排除单个视图，即使中间件已启用：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The built-in `{% csrf_token %}` tag generates the hidden input field that provides
    the token, as shown in the following example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的“{% csrf_token %}”标记生成提供令牌的隐藏输入字段，如下例所示：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is considered invalid to include the token for forms that submit requests
    using the `GET`, `HEAD`, `OPTIONS`, or `TRACE` methods, as any requests using
    those methods should not cause side effects in the first place. In most cases,
    web forms that require CSRF protection will be `POST` forms.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用“GET”、“HEAD”、“OPTIONS”或“TRACE”方法提交请求的表单中包含令牌被认为是无效的，因为任何使用这些方法的请求首先不应该引起副作用。在大多数情况下，需要CSRF保护的Web表单将是“POST”表单。
- en: When a protected form using an unsafe method is submitted without the required
    token, Django's built-in form validation will recognize this and reject the request
    outright. Only those submissions containing a token with a valid value will be
    allowed to proceed. As a result, external sites will be unable to make changes
    to your server since they won't be able to know and include the currently valid
    token value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用不安全的方法提交受保护的表单而没有所需的令牌时，Django的内置表单验证将识别此情况并拒绝请求。只有包含有效值令牌的提交才允许继续进行。因此，外部站点将无法更改您的服务器，因为它们将无法知道并包含当前有效的令牌值。
- en: There's more...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In many cases, it is desirable to enhance a form so that it can be submitted
    over Ajax. These also need to be protected using CSRF tokens, and while it is
    possible to inject the token as extra data in each request, using such an approach
    requires developers to remember to do so for each and every `POST` request. The
    alternative of using a CSRF token header exists and it makes things more efficient.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，希望增强一个表单，以便可以通过Ajax提交。这些也需要使用CSRF令牌进行保护，虽然可能在每个请求中作为额外数据注入令牌，但使用这种方法需要开发人员记住为每个`POST`请求这样做。使用CSRF令牌标头的替代方法存在，并且使事情更有效。
- en: 'First, the token value needs to be retrieved, and how we do this depends on
    the value of the `CSRF_USE_SESSIONS` setting. When it is `True`, the token is
    stored in the session rather than a cookie, so we must use the `{% csrf_token
    %}` tag to include it in the DOM. Then, we can read that element to retrieve the
    data in JavaScript:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要检索令牌值，我们如何做取决于`CSRF_USE_SESSIONS`设置的值。当它为`True`时，令牌存储在会话中而不是cookie中，因此我们必须使用`{%
    csrf_token %}`标签将其包含在DOM中。然后，我们可以读取该元素以在JavaScript中检索数据：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When the `CSRF_USE_SESSIONS` setting is in the default `False` state, the preferred
    source of the token value is the `csrftoken` cookie. While it is possible to roll
    your own cookie manipulation methods, there are many utilities available that
    simplify this process. For example, we can extract the token easily by name using
    the **js-cookie** API, available at [https://github.com/js-cookie/js-cookie](https://github.com/js-cookie/js-cookie),
    as shown here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CSRF_USE_SESSIONS`设置处于默认的`False`状态时，令牌值的首选来源是`csrftoken` cookie。虽然可以自己编写cookie操作方法，但有许多可简化此过程的实用程序可用。例如，我们可以使用**js-cookie**
    API轻松按名称提取令牌，该API可在[https://github.com/js-cookie/js-cookie](https://github.com/js-cookie/js-cookie)上找到，如下所示：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once the token has been extracted, it needs to be set as the CSRF token header
    value for `XmlHttpRequest`. Although this might be done separately for each request,
    doing so has the same drawbacks as adding the data to the request parameters for
    each request. Instead, we might use jQuery and its ability to attach data to all
    requests automatically before they are sent, like so:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦令牌被提取，它需要被设置为`XmlHttpRequest`的CSRF令牌标头值。虽然可以为每个请求单独执行此操作，但这样做与为每个请求添加数据到请求参数具有相同的缺点。相反，我们可以使用jQuery及其在发送请求之前自动附加数据的能力，如下所示：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See also
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating an app with CRUDL functions* recipe in [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)*,
    Forms and Views*
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用CRUDL功能创建应用程序*配方在[第3章](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)*，表单和视图*'
- en: The *Implementing password validation* recipe
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实施密码验证*配方'
- en: The *Downloading authorized files* recipe
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*下载授权文件*配方'
- en: The *Authenticating with Auth0* recipe
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Auth0进行身份验证*配方'
- en: Making requests secure with Content Security Policy (CSP)
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内容安全策略（CSP）使请求安全
- en: 'Dynamic multi-user websites usually allow users to add all kinds of data from
    a wide variety of media types: images, videos, audios, HTML, JavaScript snippets,
    and so on. This opens up the potential of users adding malicious code to the website
    that could steal cookies or other personal information, call unwanted Ajax requests
    in the background, or do other harm. Modern browsers support an extra layer of
    security that whitelists the sources of your media resources. It is called CSP
    and in this recipe, we will show you how to use it within a Django website.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 动态多用户网站通常允许用户从各种媒体类型中添加各种数据：图像、视频、音频、HTML、JavaScript片段等。这打开了用户向网站添加恶意代码的潜力，这些代码可能窃取cookie或其他个人信息，在后台调用不需要的Ajax请求，或者造成其他伤害。现代浏览器支持额外的安全层，它列入白名单您媒体资源的来源。它被称为CSP，在这个配方中，我们将向您展示如何在Django网站中使用它。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's start with an existing Django project; for example, the one containing
    the `ideas` app from [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)*,
    Forms and Views*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个现有的Django项目开始；例如，包含来自[第3章](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)*，表单和视图*的`ideas`应用程序。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To protect your project with CSP, follow these steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用CSP保护您的项目，请按照以下步骤：
- en: 'Install `django-csp` into your virtual environment:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`django-csp`安装到您的虚拟环境中：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the settings, add `CSPMiddleware`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置中，添加`CSPMiddleware`：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the same settings file, add the `django-csp` settings for whitelisting the
    sources of included media that you trust, for example, the CDN for jQuery and
    Bootstrap (you''ll find a detailed explanation of this in the *How it works...*
    section):'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的设置文件中，添加`django-csp`设置以列入您信任的包含媒体的来源，例如，jQuery和Bootstrap的CDN（您将在*它是如何工作的...*部分找到对此的详细解释）：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you have any inline scripts or styles anywhere in the templates, whitelist
    them using a cryptographic `nonce`, as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在模板中的任何地方有内联脚本或样式，请使用加密的`nonce`将它们列入白名单，如下所示：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'CSP directives can be added to the meta tags in the head section or the response
    headers:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: CSP指令可以添加到头部的meta标签或响应头中：
- en: 'The `meta` tag syntax looks like this:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta`标签的语法如下：'
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our chosen `django-csp` module uses **response headers** to create the list
    sources that you want to be loaded into the website. You can check the headers
    in the Network section of the browser''s inspector, as follows:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们选择的`django-csp`模块使用**响应头**来创建您希望加载到网站中的源列表。您可以在浏览器检查器的网络部分中检查头，如下所示：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'CSP allows you to define resource types and allowed sources next to each other.
    The main directives that you can use are as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: CSP允许您将资源类型和允许的来源定义在一起。您可以使用的主要指令如下：
- en: '`default-src` is used as a fallback for all unset sources and is controlled
    in the Django settings by `CSP_DEFAULT_SRC`.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default-src`用作所有未设置来源的回退，并在Django设置中由`CSP_DEFAULT_SRC`控制。'
- en: '`script-src` is used for `<script>` tags and is controlled in the Django settings
    by `CSP_DEFAULT_SRC`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`script-src`用于`<script>`标签，并在Django设置中由`CSP_DEFAULT_SRC`控制。'
- en: '`style-src` is used for the `<style>` and `<link rel="stylesheet">` tags and
    CSS `@import` statements, and is controlled by the `CSP_STYLE_SRC` setting.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`style-src`用于`<style>`和`<link rel="stylesheet">`标签以及CSS `@import`语句，并由`CSP_STYLE_SRC`设置控制。'
- en: '`img-src` is used for the `<img>` tags and is controlled by the `CSP_IMG_SRC`
    setting.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`img-src`用于`<img>`标签，并由`CSP_IMG_SRC`设置控制。'
- en: '`frame-src` is used for the `<frame>` and `<iframe>` tags and is controlled
    by the `CSP_FRAME_SRC` setting.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frame-src`用于`<frame>`和`<iframe>`标签，并由`CSP_FRAME_SRC`设置控制。'
- en: '`media-src` is used for the `<audio>` , `<video>`, and `<track>` tags and is
    controlled by the `CSP_MEDIA_SRC` setting.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`media-src`用于`<audio>`、`<video>`和`<track>`标签，并由`CSP_MEDIA_SRC`设置控制。'
- en: '`font-src` is used for the web fonts and is controlled by the `CSP_FONT_SRC`
    setting.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`font-src`用于Web字体，并由`CSP_FONT_SRC`设置控制。'
- en: '`connect-src` is used for the resources loaded by JavaScript and is controlled
    by the `CSP_CONNECT_SRC` setting.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect-src`用于JavaScript加载的资源，并由`CSP_CONNECT_SRC`设置控制。'
- en: A full list of resource types and analogical settings can be found at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy ](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)and [https://django-csp.readthedocs.io/en/latest/configuration.html](https://django-csp.readthedocs.io/en/latest/configuration.html),
    respectively.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy ](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)和[https://django-csp.readthedocs.io/en/latest/configuration.html](https://django-csp.readthedocs.io/en/latest/configuration.html)找到每个指令的值的完整列表。
- en: 'The values for each directive can be one or more from the following list (the
    single quotes matter):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每个指令的值可以是以下列表中的一个或多个（单引号很重要）：
- en: '`*`: Allow all sources'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`：允许所有来源'
- en: '`''none''`: Disallow all sources'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''none''`：禁止所有来源'
- en: '`''self''`: Allow sources from the same domain'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''self''`：允许来自相同域的来源'
- en: A protocol; for instance, `https:` or `data:`
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议；例如，`https:`或`data:`
- en: A domain; for instance, `example.com` or `*.example.com`
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域名；例如，`example.com`或`*.example.com`
- en: A website URL, for instance, `https://example.com`
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站URL，例如，`https://example.com`
- en: '`''unsafe-inline''`: Allow inline `<script>` or `<style>` tags'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''unsafe-inline''`：允许内联`<script>`或`<style>`标签'
- en: '`''unsafe-eval''`: Allow script execution with the `eval()` function'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''unsafe-eval''`：允许使用`eval()`函数执行脚本'
- en: '`''nonce-<b64-value>''`: Allow specific tags by cryptographic nonces'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''nonce-<b64-value>''`：通过加密nonce允许特定标签'
- en: '`''sha256-...''`: Allow resources by their source hashes'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''sha256-...''`：通过源哈希允许资源'
- en: 'There is no general bulletproof way to configure `django-csp`. It''s always
    a process of trial and error. However, here are our guidelines:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 没有通用的配置`django-csp`的绝对方法。这总是一个反复试验的过程。不过，以下是我们的指导原则：
- en: Start by adding the CSP for an existing working project. Premature restrictions
    will only make it more difficult to develop the website.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先为现有的工作项目添加CSP。过早的限制只会使开发网站变得更加困难。
- en: Check all the scripts, styles, fonts, and other static files that have been
    hardcoded into the templates and whitelist them.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查所有已硬编码到模板中的脚本、样式、字体和其他静态文件，并将它们列入白名单。
- en: 'Allow all sources for images, media, and frames if you allow media to be embedded
    into blog posts or other dynamic content, as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果允许媒体嵌入到博客文章或其他动态内容中，请允许所有来源的图像、媒体和框架，如下所示：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you use inline scripts or styles, add `nonce="{{ request.csp_nonce }}"` to
    them.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用内联脚本或样式，请在其中添加`nonce="{{ request.csp_nonce }}"`。
- en: Avoid `'unsafe-inline'` and `'unsafe-eval'` CSP values unless the only way to
    enter HTML into the website is by hardcoding it in the templates.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非通过在模板中硬编码HTML是唯一的进入网站的方式，否则避免使用`'unsafe-inline'`和`'unsafe-eval'`CSP值。
- en: 'Browse through the website and search for any content that is not loading correctly.
    If you see a message like the following in the developer console, it means that
    the content was restricted by CSP:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览网站，搜索任何未正确加载的内容。如果在开发者控制台中看到以下消息，意味着内容受到CSP的限制：
- en: 'Refused to execute inline script because it violates the following Content
    Security Policy directive: "script-src ''self'' https://stackpath.bootstrapcdn.com/
    https://code.jquery.com/ https://cdnjs.cloudflare.com/". Either the ''unsafe-inline''
    keyword, a hash (''sha256-P1v4zceJ/oPr/yp20lBqDnqynDQhHf76lljlXUxt7NI=''), or
    a nonce (''nonce-...'') is required to enable inline execution.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 拒绝执行内联脚本，因为它违反了以下内容安全策略指令：“script-src 'self' https://stackpath.bootstrapcdn.com/
    https://code.jquery.com/ https://cdnjs.cloudflare.com/”。要启用内联执行，需要使用'unsafe-inline'关键字、哈希（'sha256-P1v4zceJ/oPr/yp20lBqDnqynDQhHf76lljlXUxt7NI='）或nonce（'nonce-...'）。
- en: 'Errors like these usually occur because some third-party tools such as django-cms,
    Django Debug Toolbar, and Google Analytics are trying to include a resource through
    JavaScript. You can whitelist those resources with source hashes like the one
    we saw in the error message:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这类错误通常是因为一些第三方工具，如django-cms、Django Debug Toolbar和Google Analytics，试图通过JavaScript包含资源而发生的。您可以使用资源哈希来将这些资源列入白名单，就像我们在错误消息中看到的那样：
- en: '`''sha256-P1v4zceJ/oPr/yp20lBqDnqynDQhHf76lljlXUxt7NI=''`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`''sha256-P1v4zceJ/oPr/yp20lBqDnqynDQhHf76lljlXUxt7NI=''`。'
- en: If you develop modern **Progressive Web Apps** (**PWAs**), consider checking
    the directives for the manifest and web workers controlled by the `CSP_MANIFEST_SRC`
    and `CSP_WORKER_SRC` settings.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您开发现代的**渐进式Web应用**（**PWA**），请考虑检查由`CSP_MANIFEST_SRC`和`CSP_WORKER_SRC`设置控制的清单和Web
    Workers的指令。
- en: See also
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Making forms secure from Cross Site Request Forgery (CSRF)* recipe
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使表单免受跨站请求伪造（CSRF）*的安全配方'
- en: Using django-admin-honeypot
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用django-admin-honeypot
- en: If you keep the default administration path for your Django website, you make
    it possible for hackers to perform brute-force attacks and try to log in with
    different passwords from their lists. There is an app called django-admin-honeypot
    that allows you to fake the login screen and detect those brute-force attacks.
    In this recipe, we'll learn how to use it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您保留Django网站的默认管理路径，您将使黑客能够执行暴力攻击，并尝试使用其列表中的不同密码登录。有一个名为django-admin-honeypot的应用程序，允许您伪造登录屏幕并检测这些暴力攻击。在本教程中，我们将学习如何使用它。
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We can start with any Django project that we want to secure. For example, you
    can extend the project from the previous recipe.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从任何要保护的Django项目开始。例如，您可以扩展上一个教程中的项目。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to set up django-admin-honeypot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤设置django-admin-honeypot：
- en: 'Install the module in your virtual environment:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的虚拟环境中安装模块：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add `"admin_honeypot"` to `INSTALLED_APPS` in your settings:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置中的`INSTALLED_APPS`中添加`"admin_honeypot"`：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Modify the URL rules:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改URL规则：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If you go to the default administration URL, `http://127.0.0.1:8000/en/admin/`,
    you will see the login screen, but whatever you enter will be described as an
    invalid password:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您转到默认的管理URL，`http://127.0.0.1:8000/en/admin/`，您将看到登录屏幕，但无论您输入什么都将被描述为无效密码：
- en: '![](img/7fc7521b-9438-4ccd-9e5c-6b7efa6b23fc.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc7521b-9438-4ccd-9e5c-6b7efa6b23fc.png)'
- en: The real site's administration is now under `http://127.0.0.1:8000/en/management/`,
    where you can see the tracked logins from the honeypot.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 真实网站的管理现在位于`http://127.0.0.1:8000/en/management/`，您可以在那里看到来自蜜罐的跟踪登录。
- en: There's more...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'At the time of writing, django-admin-honeypot is not perfectly functioning
    with Django 3.0 – the administration interface escapes the HTML where it should
    render it safely. Until django-admin-honeypot is updated and a new release is
    available, we can fix it by making some changes, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，django-admin-honeypot与Django 3.0的功能不完善-管理界面会转义HTML，而应该安全地呈现它。在django-admin-honeypot更新并提供新版本之前，我们可以通过进行一些更改来修复它，如下所示：
- en: 'Create an app called `admin_honeypot_fix` with the `admin.py` file that contains
    the following code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`admin_honeypot_fix`的应用程序，其中包含以下代码的`admin.py`文件：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the same app, create an `apps.py` file with the new app configuration:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个应用程序中，创建一个带有新应用程序配置的`apps.py`文件：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Replace `"admin_honeypot"` with the new app configuration in `INSTALLED_APPS`
    in the settings:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置中的`INSTALLED_APPS`中用新的应用程序配置替换`"admin_honeypot"`：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The login attempts at the honeypot will now look like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 蜜罐中的登录尝试现在看起来是这样的：
- en: '![](img/3c76c52b-0f5c-4272-ab40-01ca4603d480.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c76c52b-0f5c-4272-ab40-01ca4603d480.png)'
- en: See also
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Implementing password validation* recipe
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实施密码验证*教程'
- en: The *Authenticating with Auth0* recipe
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Auth0进行身份验证*教程'
- en: Implementing password validation
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施密码验证
- en: Among the items at the top of the list of software security failures is the
    choice of insecure passwords by users. In this recipe, we will learn how to enforce
    minimum password requirements through both built-in and custom password validators
    so that users are guided toward setting up more secure authentication.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件安全失败列表的前面，有一项是用户选择不安全密码。在本教程中，我们将学习如何通过内置和自定义密码验证器来强制执行最低密码要求，以便用户被引导设置更安全的身份验证。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Open the project's settings file and locate the `AUTH_PASSWORD_VALIDATORS` setting.
    Also, create a new `auth_extra` app containing a `password_validation.py` file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 打开项目的设置文件并找到`AUTH_PASSWORD_VALIDATORS`设置。此外，创建一个新的`auth_extra`应用程序，其中包含一个`password_validation.py`文件。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to set up stronger password validation for your project:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤为您的项目设置更强大的密码验证：
- en: 'Let''s customize the settings for the validators that are included with Django
    by adding some options:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加一些选项来自定义Django中包含的验证器的设置：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the `MaximumLengthValidator` class to the `password_validation.py` file
    in the new `auth_extra` app, as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的`auth_extra`应用程序的`password_validation.py`文件中添加`MaximumLengthValidator`类，如下所示：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the same file, create the `SpecialCharacterInclusionValidator` class:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，创建`SpecialCharacterInclusionValidator`类：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, add the new validators to the settings:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将新的验证器添加到设置中：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Django contains a set of default password validators:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Django包含一组默认密码验证器：
- en: '`UserAttributeSimilarityValidator` ensures that any password that''s chosen
    is not too similar to certain attributes of the user. By default, the similarity
    ratio is set to `0.7` and the attributes that are checked are the username, first
    and last name, and email address. If any of these attributes contains multiple
    words, each word is checked independently.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserAttributeSimilarityValidator`确保所选择的任何密码不会与用户的某些属性太相似。默认情况下，相似性比率设置为`0.7`，并且检查的属性是用户名，名字和姓氏以及电子邮件地址。如果这些属性中包含多个单词，则每个单词都会被独立检查。'
- en: '`MinimumLengthValidator` checks that the password that''s entered is at least
    the minimum number of characters in length. By default, passwords must be eight
    or more characters long.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MinimumLengthValidator`检查输入的密码至少是多少个字符长。默认情况下，密码必须至少为八个字符长。'
- en: '`CommonPasswordValidator` refers to a file containing a list of passwords that
    are often used, and hence are insecure. The list Django uses by default contains
    1,000 such passwords.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommonPasswordValidator`指的是一个包含经常使用的密码列表的文件，因此是不安全的。 Django默认使用的列表包含1,000个这样的密码。'
- en: '`NumericPasswordValidator` verifies that the password that''s entered is not
    made up entirely of numbers.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumericPasswordValidator`验证输入的密码是否完全由数字组成。'
- en: When you use the `startproject` management command to create a new project,
    these are added with their default options as the initial set of validators. In
    this recipe, we've shown how these options can be adjusted for our project needs,
    increasing the minimum length of passwords to 12 characters.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`startproject`管理命令创建新项目时，这些选项将作为初始验证器集合的默认选项添加。在这个配方中，我们已经展示了如何调整这些选项以满足我们项目的需求，将密码的最小长度增加到12个字符。
- en: For `UserAttributeSimilarityValidator`, we have also reduced `max_similarity`
    to `0.5`, which means that passwords must differ more greatly from user attributes
    than the default.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`UserAttributeSimilarityValidator`，我们还将`max_similarity`减少到`0.5`，这意味着密码必须与用户属性有更大的差异。
- en: 'Looking at `password_validation.py`, we have defined two new validators:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`password_validation.py`，我们定义了两个新的验证器：
- en: '`MaximumLengthValidator` is very similar to the built-in one for minimum length,
    ensuring that the password is no longer than the default of 24 characters'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaximumLengthValidator`与内置的最小长度验证器非常相似，确保密码不超过默认的24个字符'
- en: '`SpecialCharacterInclusionValidator` checks that one or more special characters
    – defined as the `$`, `%`, `:`, `#`, and `!` symbols by default – are found within
    the given password'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SpecialCharacterInclusionValidator`检查密码中是否包含一个或多个特殊字符，默认情况下定义为`$`、`%`、`:`、`#`和`!`符号'
- en: 'Each validator class has two required methods:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每个验证器类都有两个必需的方法：
- en: The `validate()` method performs the actual checks against the `password` argument.
    Optionally, a second `user` argument will be passed when a user has been authenticated.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validate()`方法执行对`password`参数的实际检查。可选地，当用户已经通过身份验证时，将传递第二个`user`参数。'
- en: We must also provide a `get_help_text()` method, which returns a string describing
    the validation requirements for the user.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还必须提供一个`get_help_text()`方法，该方法返回描述用户验证要求的字符串。
- en: Finally, we add the new validators to the settings in order to override the
    defaults to allow up to a 32-character maximum length for the password, and to
    be able to add the symbols `{`, `}`, `^`, and `&` to the default special character
    list.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将新的验证器添加到设置中，以覆盖默认设置，允许密码的最大长度为32个字符，并且能够将符号`{`、`}`、`^`和`&`添加到默认的特殊字符列表中。
- en: There's more...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The validators that are provided in `AUTH_PASSWORD_VALIDATORS` are executed
    automatically for the `createsuperuser` and `changepassword` management commands,
    as well as the built-in forms that are used to change or reset passwords. There
    will be times where you will want to use the same validation for custom password
    management code, though. Django provides functions for that level of integration
    and you can check the details in the contributed Django `auth` app in the `django.contrib.auth.password_validation`
    module.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AUTH_PASSWORD_VALIDATORS`中提供的验证器会自动执行`createsuperuser`和`changepassword`管理命令，以及用于更改或重置密码的内置表单。但是，有时您可能希望对自定义密码管理代码使用相同的验证。Django提供了该级别集成的函数，您可以在`django.contrib.auth.password_validation`模块中的贡献的Django
    `auth`应用程序中检查详细信息。
- en: See also
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Downloading authorized files* recipe
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*下载授权文件*配方'
- en: The *Authenticating with Auth0* recipe
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Auth0进行身份验证*配方'
- en: Downloading authorized files
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载授权文件
- en: Sometimes, you may only need to allow specific people to download intellectual
    property from your website. For example, music, videos, literature, or other artistic
    works should only be accessible to paid members. In this recipe, you will learn
    how to restrict image downloads only to authenticated users using the contributed
    Django auth app.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能只需要允许特定的人从您的网站下载知识产权。例如，音乐、视频、文学或其他艺术作品只应该对付费会员开放。在这个配方中，您将学习如何使用贡献的Django
    auth应用程序，将图像下载限制仅对经过身份验证的用户。
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's start with the `ideas` app that we created in [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml),
    *Forms and Views*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们在[第3章](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)中创建的`ideas`应用开始。
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Execute these steps one by one:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步执行这些步骤：
- en: 'Create the view that will require authentication to download a file, as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建需要身份验证才能下载文件的视图，如下所示：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the download view to the URL configuration:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下载视图添加到URL配置中：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Set up the login view in our project URL configuration:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们项目的URL配置中设置登录视图：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a template for the login form, as shown in the following code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建登录表单的模板，如下所示：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the template of idea details, add a link to the download:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在想法详情的模板中，添加一个下载链接：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should restrict users from bypassing Django and downloading restricted
    files directly. To do so, on an Apache web server, you can put a `.htaccess` file
    in the `media/ideas` directory by using the following content if you are running Apache
    2.4:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该限制用户绕过Django直接下载受限文件。要做到这一点，在Apache web服务器上，如果您正在运行Apache 2.4，可以在`media/ideas`目录中放置一个`.htaccess`文件，内容如下：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When using `django-imagekit`, as shown in the examples throughout this book,
    the generated image versions will be stored and served from the `media/CACHE`
    directory, so our `.htaccess` configuration won't affect it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`django-imagekit`时，如本书中的示例所示，生成的图像版本将存储在`media/CACHE`目录中，并从那里提供服务，因此我们的`.htaccess`配置不会影响它。
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `download_idea_picture` view streams the original uploaded picture from
    a specific idea. The `Content-Disposition` header that is set to `attachment`
    makes the file downloadable instead of being immediately shown in the browser.
    The filename for the file is also set in this header, and will be something similar
    to `gamified-donation-platform.jpg`. If the picture for an idea is unavailable,
    a 404 page will be shown with a very simple message: Picture unavailable.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`download_idea_picture`视图从特定想法中流式传输原始上传的图片。设置为`attachment`的`Content-Disposition`标头使文件可下载，而不是立即在浏览器中显示。该文件的文件名也在此标头中设置，类似于`gamified-donation-platform.jpg`。如果某个想法的图片不可用，将显示一个带有非常简单消息的404页面：图片不可用。'
- en: 'The `@login_required` decorator will redirect the visitor to the login page
    if they try to access the downloadable file without being logged in. The login
    screen will look like this by default:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`@login_required`装饰器将在访问可下载文件时重定向访问者到登录页面，如果他们未登录。默认情况下，登录屏幕如下所示：'
- en: '![](img/273c8926-f6a8-4087-b876-ae6bd05c0981.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/273c8926-f6a8-4087-b876-ae6bd05c0981.png)'
- en: See also
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Uploading images* recipe from [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml),
    *Forms and Views*
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[第3章](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)的*上传图像*食谱，*表单和视图*
- en: The *Creating a form layout with custom templates* recipe from [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml),
    *Forms and Views*
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[第3章](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)的*使用自定义模板创建表单布局*食谱，*表单和视图*
- en: The *Creating a form layout with django-crispy-forms* recipe from [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml),
    *Forms and Views*
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[第3章](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)的*使用django-crispy-forms创建表单布局*食谱，*表单和视图*
- en: The *Arranging the base.html template* recipe from [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml),
    *Templates and JavaScript*
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[第4章](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)的*安排base.html模板*食谱，*模板和JavaScript*
- en: The *Implementing password validation* recipe
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实施密码验证*食谱'
- en: The *Adding a dynamic watermark to images* recipe
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*向图像添加动态水印*食谱'
- en: Adding a dynamic watermark to images
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向图像添加动态水印
- en: Sometimes, it is desirable to allow users to see images, but keep them from
    being redistributed due to intellectual property and artistic rights. In this
    recipe, we will learn how to apply a watermark to images that are displayed on
    your site.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，允许用户查看图像，但防止由于知识产权和艺术权利而重新分发是可取的。在这个食谱中，我们将学习如何向在您的网站上显示的图像应用水印。
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: Let's start with the `core` and `ideas` apps that we created in the *Creating
    an app with CRUDL functions *recipe in [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml),
    *Forms and Views*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们在[第3章](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)中创建的`core`和`ideas`应用程序开始，*创建具有CRUDL功能的应用程序*食谱，*表单和视图*。
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to apply a watermark to the displayed idea images:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将水印应用于显示的idea图像：
- en: 'If you haven''t done so already, install `django-imagekit` into your virtual
    environment:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未这样做，请将`django-imagekit`安装到您的虚拟环境中：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Put `"imagekit"` into `INSTALLED_APPS` in the settings:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置中将`"imagekit"`放入`INSTALLED_APPS`：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `core` app, create a file called `processors.py` with a `WatermarkOverlay`
    class, as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`core`应用程序中，创建一个名为`processors.py`的文件，其中包含`WatermarkOverlay`类，如下所示：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `Idea` model, add the `watermarked_picture_large` specification next
    to the `picture` field, as follows:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Idea`模型中，将`watermarked_picture_large`规格添加到`picture`字段旁边，如下所示：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Using a graphical program of your choice, create a semi-transparent PNG image
    with white text or a logo on a transparent background. Make it 800 x 400 px in
    size. Save the image as `site_static/site/img/watermark.png`. Here''s what it
    might look like:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您选择的图形程序，在透明背景上创建一个带有白色文本或标志的半透明PNG图像。将其大小设置为800 x 400像素。将图像保存为`site_static/site/img/watermark.png`。它可能看起来像这样：
- en: '![](img/e5d2c032-4ad3-426e-9fa5-a932de9e6183.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5d2c032-4ad3-426e-9fa5-a932de9e6183.png)'
- en: 'Run the `collectstatic` management command afterward:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后运行`collectstatic`管理命令：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Edit the idea detail template and add the watermarked image there, as follows:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑idea详细模板，并添加水印图像，如下所示：
- en: '[PRE38]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If we navigate to the idea detail page, we should see the large image masked
    by our watermark, similar to this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们导航到idea详细页面，我们应该看到大图像被我们的水印遮盖，类似于这样：
- en: '![](img/527e60a3-66e9-45f5-87bd-f521ce8fc34f.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/527e60a3-66e9-45f5-87bd-f521ce8fc34f.png)'
- en: Let's examine how this was done. In the detail template, the `src` attribute
    for the `<img>` tag uses the idea's image specification, that is, `watermarked_picture_large`,
    to create a modified image that is then saved under the `media/CACHE/` directory
    and served from there.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看是如何做到的。在详细模板中，`<img>`标签的`src`属性使用了idea的图像规格，即`watermarked_picture_large`，以创建一个修改后的图像，然后将其保存在`media/CACHE/`目录下并从那里提供服务。
- en: 'The `django-imagekit` specifications use processors to modify images. Two processors
    are used there:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`django-imagekit`规格使用处理器修改图像。那里使用了两个处理器：'
- en: '`ResizeToFill` resizes the image to 800 × 400 px'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResizeToFill`将图像调整为800×400像素'
- en: Our custom processor, `WatermarkOverlay`, applies the semi-transparent overlay
    to it
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的自定义处理器`WatermarkOverlay`将半透明叠加层应用于它
- en: '`django-imagekit` processors must have a `process()` method that takes the
    image from the previous processors and returns a new modified image. In our case,
    we compose the result from the original and the semi-transparent overlay.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`django-imagekit`处理器必须具有一个`process()`方法，该方法获取来自先前处理器的图像并返回一个新的修改后的图像。在我们的情况下，我们将结果从原始图像和半透明叠加层组合而成。'
- en: See also
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Downloading authorized files* recipe
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*下载授权文件*食谱'
- en: Authenticating with Auth0
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Auth0进行身份验证
- en: As the number of services people interact with daily increases, so does the
    number of usernames and passwords that they need to remember. Beyond just that,
    each additional place where user information is stored is another place that it
    could be stolen from, in the event of a security breach. To help mitigate this,
    services such as **Auth0** allow you to centralize authentication services on
    a single, secure platform.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 随着人们每天互动的服务数量的增加，他们需要记住的用户名和密码的数量也在增加。除此之外，用户信息存储的每个额外位置都是在安全漏洞发生时可能被盗窃的另一个位置。为了帮助缓解这一问题，诸如**Auth0**之类的服务允许您在单一安全平台上集中身份验证服务。
- en: In addition to its support for username and password credentials, Auth0 has
    the ability to authenticate users via social platforms such as Google, Facebook,
    or Twitter. You could use passwordless login via single-time codes sent by SMS
    or email, and there is even enterprise-level support for different services. In
    this recipe, you'll learn how to connect an Auth0 application to Django and how
    to integrate it to handle user authentication.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 除了支持用户名和密码凭据外，Auth0 还可以通过 Google、Facebook 或 Twitter 等社交平台验证用户。您可以使用通过短信或电子邮件发送的一次性代码进行无密码登录，甚至支持不同服务的企业级支持。在本教程中，您将学习如何将
    Auth0 应用连接到 Django，并如何集成它以处理用户身份验证。
- en: Getting ready
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: If you haven't done so yet, create an Auth0 application at [https://auth0.com/](https://auth0.com/)​
    and configure it by following the instructions there. Two social connections are
    provided in the free plan, so we will activate Google and Twitter to log in with
    them. You can also try other services. Note that some of them require you to register
    an app and get API keys and secrets.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未这样做，请在 [https://auth0.com/](https://auth0.com/) 创建一个 Auth0 应用，并按照那里的说明进行配置。免费计划提供了两个社交连接，因此我们将激活
    Google 和 Twitter 以使用它们登录。您还可以尝试其他服务。请注意，其中一些服务需要您注册应用并获取 API 密钥和密钥。
- en: 'Next, we need to install `python-social-auth` and some other dependencies in
    the project. Include these dependencies in your `pip` requirements:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在项目中安装 `python-social-auth` 和其他一些依赖项。将这些依赖项包含在您的 `pip` 要求中：
- en: '[PRE39]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`social-auth-app-django` is a Django-specific package of the `python-social-auth`
    project that allows you to authenticate to your website using one of many social
    connections.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`social-auth-app-django` 是 `python-social-auth` 项目的 Django 特定包，允许您使用许多社交连接之一进行网站身份验证。'
- en: Install those dependencies with `pip` into your virtual environment.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pip` 将这些依赖项安装到您的虚拟环境中。
- en: How to do it...
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To connect Auth0 to your Django project, follow these steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Auth0 连接到您的 Django 项目，请按照以下步骤进行：
- en: 'Add the social authentication app to `INSTALLED_APPS` in the settings file,
    like so:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置文件中的 `INSTALLED_APPS` 中添加社交身份验证应用，如下所示：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, add the Auth0 settings required by the `social_django` app, which will
    be similar to the following:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加 `social_django` 应用所需的 Auth0 设置，如下所示：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Make sure that you define `AUTH0_DOMAIN`, `AUTH0_KEY`, and `AUTH0_SECRET` in
    your secrets or environment variables. The values for those variables can be found
    in the settings of your Auth0 app that you created in *Step 1* of this recipe's *Getting
    ready* section.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您在您的秘密或环境变量中定义 `AUTH0_DOMAIN`，`AUTH0_KEY` 和 `AUTH0_SECRET`。这些变量的值可以在您在本教程的
    *准备就绪* 部分的 *第 1 步* 中创建的 Auth0 应用的设置中找到。
- en: 'We need to create a backend for the Auth0 connection, as shown in the following
    example:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为 Auth0 连接创建一个后端，如下例所示：
- en: '[PRE42]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add the new backend to your `AUTHENTICATION_BACKENDS` setting, as shown in
    the following code:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新后端添加到您的 `AUTHENTICATION_BACKENDS` 设置中，如下所示：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We want the social authentication user to be accessible from any template.
    Therefore, we''ll create a context processor for it:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望社交身份验证用户可以从任何模板中访问。因此，我们将为其创建一个上下文处理器：
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, we need to register it in the settings:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在设置中注册它：
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, let''s create views for the index page, dashboard, and logout:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为索引页面、仪表板和注销创建视图：
- en: '[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create the index template, as follows:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建索引模板，如下所示：
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create a dashboard template accordingly:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相应地创建仪表板模板：
- en: '[PRE48]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Update the URL rules:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 URL 规则：
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, add the login URL settings:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加登录 URL 设置：
- en: '[PRE50]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'If you point a browser to the index page of your project, you will see a link
    inviting you to log in. When you click on it, you will be redirected to the Auth0
    authentication system, whose screen will look similar to the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将浏览器指向项目的索引页面，您将看到一个链接邀请您登录。当您点击它时，您将被重定向到 Auth0 身份验证系统，其屏幕将类似于以下内容：
- en: '![](img/6999e777-9040-41a5-93e8-b93bd128971a.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6999e777-9040-41a5-93e8-b93bd128971a.png)'
- en: This much is enabled out of the box by `python-social-auth`, an `Auth0` backend,
    by configuring its associated `SOCIAL_AUTH_*` settings.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是由 `python-social-auth` 和 `Auth0` 后端的 `SOCIAL_AUTH_*` 设置配置的开箱即用功能。
- en: 'Once a successful login has been completed, the Auth0 backend receives the
    data from the response and processes it. The associated data is attached to the
    user object associated with the request. In the dashboard view, which is reached
    as a result of authentication proceeding to `LOGIN_REDIRECT_URL`, user details
    are extracted and added to the template context. `dashboard.html` is then rendered.
    The result may look as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功完成登录，Auth0 后端将接收来自响应的数据并处理它。相关数据附加到与请求关联的用户对象。在达到 `LOGIN_REDIRECT_URL` 的身份验证结果的仪表板视图中，提取用户详细信息并添加到模板上下文中。然后呈现
    `dashboard.html`。结果可能如下所示：
- en: '![](img/0da83ec6-d5be-411f-9d3b-865f1de66ba7.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0da83ec6-d5be-411f-9d3b-865f1de66ba7.png)'
- en: The logout button presented on the dashboard will proceed to log the user back
    out when pressed.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板上呈现的注销按钮在按下时将注销用户。
- en: See also
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Implementing password validation* recipe
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实施密码验证* 教程'
- en: The *Downloading authorized files* recipe
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*下载授权文件* 教程'
- en: Caching the method return value
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存方法返回值
- en: If you call a model method with heavy calculations or database queries multiple
    times in the request-response cycle, the performance of the view might become
    very slow. In this recipe, you will learn about a pattern that you can use to
    cache the return value of a method for later repetitive use. Note that we are
    not using the Django cache framework here, only what Python provides us by default.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在请求-响应周期中多次调用具有繁重计算或数据库查询的模型方法，则视图的性能可能会变得非常慢。在本教程中，您将了解一种模式，可以使用它来缓存方法的返回值以供以后重复使用。请注意，我们在这里不使用
    Django 缓存框架，只使用 Python 默认提供的内容。
- en: Getting ready
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Choose an app with a model that has a time-consuming method that will be used
    repetitively in the same request-response cycle.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个具有耗时方法的模型的应用程序，该方法将在同一请求-响应周期中重复使用。
- en: How to do it...
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'This is a pattern that you can use to cache a method return value of a model
    for repetitive use in views, forms, or templates, as follows:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个模式，您可以用它来缓存模型的方法返回值，以便在视图、表单或模板中重复使用，如下所示：
- en: '[PRE51]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'For example, let''s create a `get_thumbnail_url()` method for the `ViralVideo`
    model. You will explore this in more detail later in the *Using database query
    expressions* recipe in [Chapter 10](dc084cae-d894-487f-8071-08c63c80f852.xhtml)*,
    Bells and Whistles*:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，让我们为`ViralVideo`模型创建一个`get_thumbnail_url()`方法。您将在[第10章](dc084cae-d894-487f-8071-08c63c80f852.xhtml)*数据库查询表达式*食谱中更详细地探讨这个问题，标题是《花里胡哨》：
- en: '[PRE52]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this generic example, the method checks whether the `_expensive_value_cached`
    attribute exists for the model instance. If it doesn't exist, time-consuming calculations
    are performed and the result is assigned to this new attribute. At the end of
    the method, the cached value is returned. Of course, if you have several weighty
    methods, you will need to use different attribute names to save each calculated
    value.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个通用的例子中，该方法检查模型实例是否存在`_expensive_value_cached`属性。如果不存在，将执行耗时的计算，并将结果赋给这个新属性。在方法结束时，返回缓存的值。当然，如果您有几个繁重的方法，您将需要使用不同的属性名称来保存每个计算出的值。
- en: You can now use something such as `{{ object.some_expensive_function }}` in
    the header and footer of a template, and the time-consuming calculations will
    be done just once.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在模板的页眉和页脚中使用`{{ object.some_expensive_function }}`之类的东西，耗时的计算将只进行一次。
- en: 'In a template, you can also use the function in both the `{% if %}` condition
    and the output of the value, as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，您还可以在`{% if %}`条件和值的输出中使用该函数，如下所示：
- en: '[PRE53]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the other example, we checked the thumbnail of a YouTube video by parsing
    the URL of the video''s embed code, getting its ID, and then composing the URL
    of the thumbnail image. By doing this, you can use it in a template, as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个例子中，我们通过解析视频嵌入代码的URL，获取其ID，然后组成缩略图图像的URL来检查YouTube视频的缩略图。通过这样做，您可以在模板中使用它，如下所示：
- en: '[PRE54]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: There's more...
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The approach we have just described only works if the method is called without
    arguments so that the result will always be the same. But what if the input varies?
    Since Python 3.2, there is a decorator we can use to provide basic **Least Recently
    Used** (**LRU**) caching of method calls based on a hash of the arguments (at
    least those that are hashable).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚描述的方法只有在方法被调用时没有参数时才有效，这样结果将始终相同。但是如果输入有所不同怎么办？自Python 3.2以来，有一个装饰器可以使用，基于参数的哈希（至少是可哈希的参数）提供基本的**最近最少使用**（**LRU**）缓存。
- en: 'For example, let''s look at a contrived and trivial example with a function
    that takes in two values and returns the result of some expensive logic:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看一个人为而琐碎的例子，有一个函数接受两个值，并返回一些昂贵逻辑的结果：
- en: '[PRE55]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we had such a function and wanted to provide a cache to store the results
    of some commonly used input variations, we could do so easily with the `@lru_cache`
    decorator from the `functools` package, as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有这样一个函数，并且希望提供一个缓存来存储一些常用输入变化的结果，我们可以很容易地使用`functools`包中的`@lru_cache`装饰器来实现，如下所示：
- en: '[PRE56]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now, we have provided a caching mechanism that will store up to 100 results
    under the keys that we hashed from the input. The `typed` option was added in
    Python 3.3 and, by specifying `True`, we have made it so that a call that has `a=1`
    and `b=2` will be stored separately from one with `a=1.0` and `b=2.0`. Depending
    on how the logic operates and what the return value is, such variation may or
    may not be appropriate.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们提供了一个缓存机制，它将在从输入中计算出的哈希键下存储最多100个结果。`typed`选项是在Python 3.3中添加的，通过指定`True`，我们使得具有`a=1`和`b=2`的调用将与具有`a=1.0`和`b=2.0`的调用分开存储。根据逻辑操作的方式和返回值的内容，这种变化可能合适也可能不合适。
- en: You can learn more about the `@lru_cache` decorator in the `functools` documentation
    at [https://docs.python.org/3/library/functools.html#functools.lru_cache](https://docs.python.org/3/library/functools.html#functools.lru_cache).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.python.org/3/library/functools.html#functools.lru_cache](https://docs.python.org/3/library/functools.html#functools.lru_cache)的`functools`文档中了解更多关于`@lru_cache`装饰器的信息。
- en: 'We could also use this decorator for the examples earlier in this recipe to
    simplify the code, as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在本食谱中的前面的例子中使用这个装饰器来简化代码，如下所示：
- en: '[PRE57]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: See also
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*, Templates and JavaScript*'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*模板和JavaScript*'
- en: The *Using Memcached to cache Django views* recipe
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Memcached缓存Django视图*食谱'
- en: The *Using Redis to cache Django views* recipe
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Redis缓存Django视图*食谱'
- en: Using Memcached to cache Django views
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Memcached缓存Django视图
- en: Django allows us to speed up the request-response cycle by caching the most
    expensive parts, such as database queries or template rendering. The fastest and
    most reliable caching natively supported by Django is the memory-based cache server
    **Memcached**. In this recipe, you will learn how to use Memcached to cache a
    view for the `viral_videos` app. We'll explore this further in the *Using database
    query expressions* recipe in [Chapter 10](dc084cae-d894-487f-8071-08c63c80f852.xhtml)*,
    Bells and Whistles*.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Django允许我们通过缓存最昂贵的部分，如数据库查询或模板渲染，来加快请求-响应周期。Django本身支持的最快、最可靠的缓存是基于内存的缓存服务器**Memcached**。在这个食谱中，您将学习如何使用Memcached来为`viral_videos`应用程序缓存视图。我们将在[第10章](dc084cae-d894-487f-8071-08c63c80f852.xhtml)*数据库查询表达式*食谱中进一步探讨这个问题，标题是《花里胡哨》。
- en: Getting ready
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There are several things we need to do in order to prepare caching for our
    Django project:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为我们的Django项目准备缓存，我们需要做几件事：
- en: 'Let''s install the `memcached` service. For example, the simplest way to do
    that on macOS is to use Homebrew:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们安装`memcached`服务。例如，在macOS上最简单的方法是使用Homebrew：
- en: '[PRE58]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, you can start, stop, or restart the Memcached service with these commands:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以使用以下命令启动、停止或重新启动Memcached服务：
- en: '[PRE59]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: On other operating systems, you can install Memcached using apt-get, yum, or
    other default package management utilities. Another option is to compile it from
    the source, as mentioned at [https://memcached.org/downloads](https://memcached.org/downloads).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他操作系统上，您可以使用apt-get、yum或其他默认的软件包管理工具安装Memcached。另一个选项是从源代码编译，如[https://memcached.org/downloads](https://memcached.org/downloads)中所述。
- en: 'Install Memcached Python bindings in your virtual environment, as follows:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的虚拟环境中安装Memcached Python绑定，如下：
- en: '[PRE60]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How to do it...
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To integrate caching for your specific views, perform the following steps:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 要为特定视图集成缓存，请执行以下步骤：
- en: 'Set `CACHES` in the project settings, as follows:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目设置中设置`CACHES`如下：
- en: '[PRE61]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Make sure that you have `CACHE_LOCATION` set to `"localhost:11211"` in your
    secrets or environment variables.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的秘密或环境变量中的`CACHE_LOCATION`设置为`"localhost:11211"`。
- en: 'Modify the views of the `viral_videos` app, as follows:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`viral_videos`应用的视图，如下：
- en: '[PRE62]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If you follow the Redis setup in the next recipe, you'll see that there is no
    change whatsoever in the `views.py` file. This shows us that we can change the
    underlying caching mechanism at will without ever needing to modify the code that
    uses it.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照下一个配方中的Redis设置，您会发现`views.py`文件没有任何变化。这表明我们可以随意更改底层的缓存机制，而无需修改使用它的代码。
- en: How it works...
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As you will see later in the *Using database query expressions* recipe in [Chapter
    10](dc084cae-d894-487f-8071-08c63c80f852.xhtml), *Bells and Whistles*, the detail
    view of the viral video shows the number of impressions by authenticated and anonymous
    users. If you access a viral video (such as at `http://127.0.0.1:8000/en/videos/1/`)
    and refresh the page a few times with caching enabled, you will notice that the
    number of impressions changes only once a minute. This is because each response
    is cached for 60 seconds for every user. We set caching for the view using the
    `@cache_page` decorator.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将在[第10章](dc084cae-d894-487f-8071-08c63c80f852.xhtml)的*使用数据库查询表达式*配方中看到的那样，病毒视频的详细视图显示了经过认证和匿名用户的印象数量。如果您访问一个病毒视频（例如在`http://127.0.0.1:8000/en/videos/1/`）并启用缓存后刷新页面几次，您会注意到印象数量只在一分钟内改变一次。这是因为每个响应对于每个用户都被缓存60秒。我们使用`@cache_page`装饰器为视图设置了缓存。
- en: Memcached is a key-value store and it uses the full URL by default to generate
    the key for each cached page. When two visitors access the same page simultaneously,
    the first visitor's request would receive the page generated by the Python code,
    and the second one would get the same HTML code but from the Memcached server.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Memcached是一个键值存储，它默认使用完整的URL来为每个缓存页面生成键。当两个访问者同时访问同一页面时，第一个访问者的请求会收到由Python代码生成的页面，而第二个访问者会从Memcached服务器获取相同的HTML代码。
- en: In our example, to ensure that each visitor gets treated separately, even if
    they access the same URL, we are using the `@vary_on_cookie` decorator. This decorator
    checks the uniqueness of the `Cookie` header in the HTTP request.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，为了确保每个访问者即使访问相同的URL也会被单独处理，我们使用了`@vary_on_cookie`装饰器。这个装饰器检查了HTTP请求中`Cookie`头的唯一性。
- en: You can learn more about Django's cache framework from the official documentation
    at [https://docs.djangoproject.com/en/3.0/topics/cache/](https://docs.djangoproject.com/en/3.0/topics/cache/).
    Similarly, you can find out more about Memcached at [https://memcached.org/](https://memcached.org/).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从官方文档[https://docs.djangoproject.com/en/3.0/topics/cache/](https://docs.djangoproject.com/en/3.0/topics/cache/)了解更多关于Django缓存框架的信息。同样，您也可以在[https://memcached.org/](https://memcached.org/)了解更多关于Memcached的信息。
- en: See also
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Caching the method return value* recipe
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*缓存方法返回值*配方'
- en: The *Using Redis to cache Django views* recipe
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Redis缓存Django视图*配方'
- en: The *Using database query expressions* recipe in [Chapter 10](dc084cae-d894-487f-8071-08c63c80f852.xhtml)*,
    Bells and Whistles*
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第10章](dc084cae-d894-487f-8071-08c63c80f852.xhtml)*，花里胡哨*'
- en: Using Redis to cache Django views
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redis缓存Django视图
- en: Although Memcached is well established in the market as a caching mechanism,
    and well supported by Django, Redis is an alternate system that provides all the
    functionality of Memcached and more. Here, we'll revisit the process from the
    *Using Memcached to cache Django views* recipe and learn how to do the same using
    Redis instead.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Memcached在市场上作为缓存机制已经很成熟，并且得到了Django的很好支持，但Redis是一个提供了Memcached所有功能以及更多功能的备用系统。在这里，我们将重新审视*使用Memcached缓存Django视图*的过程，并学习如何使用Redis来实现相同的功能。
- en: Getting ready
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There are several things we need to do in order to prepare caching for our
    Django project:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为我们的Django项目准备缓存，我们需要做几件事：
- en: 'Let''s install the Redis service. For example, the simplest way to do that
    on macOS is to use Homebrew:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们安装Redis服务。例如，在macOS上最简单的方法是使用Homebrew：
- en: '[PRE63]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, you can start, stop, or restart the Redis service with these commands:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以使用以下命令启动、停止或重新启动Redis服务：
- en: '[PRE64]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: On other operating systems, you can install Redis using apt-get, yum, or other
    default package management utilities. Another option is to compile it from the
    source, as mentioned at [https://redis.io/download](https://redis.io/download).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他操作系统上，您可以使用apt-get、yum或其他默认的软件包管理工具安装Redis。另一个选项是从源代码编译，如[https://redis.io/download](https://redis.io/download)中所述。
- en: 'Install the Redis cache backend for Django and its dependencies in your virtual
    environment, as follows:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的虚拟环境中安装Django和其依赖的Redis缓存后端，如下：
- en: '[PRE65]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How to do it...
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To integrate caching for your specific views, perform the following steps:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要为特定视图集成缓存，请执行以下步骤：
- en: 'Set `CACHES` in the project settings, as follows:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目设置中设置`CACHES`如下：
- en: '[PRE66]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Make sure that you have `CACHE_LOCATION` set to `"localhost:6379"` in your secrets
    or environment variables.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的秘密或环境变量中的`CACHE_LOCATION`设置为`"localhost:6379"`。
- en: 'Modify the views of the `viral_videos` app, as follows:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`viral_videos`应用的视图，如下：
- en: '[PRE67]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If you followed the Memcached setup from the previous recipe, you will see that
    there is no change whatsoever in the `views.py` here. This shows you that we can
    change the underlying caching mechanism at will without ever needing to modify
    the code that uses it.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照上一个教程中的Memcached设置进行操作，您会发现在这里的`views.py`中没有任何变化。这表明我们可以随意更改底层缓存机制，而无需修改使用它的代码。
- en: How it works...
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Just like with Memcached, we set caching for the view using the `@cache_page` decorator.
    So, each response is cached for 60 seconds for every user. A viral video detail
    view (such as the one at `http://127.0.0.1:8000/en/videos/1/`) shows the number
    of impressions by authenticated and anonymous users. With caching enabled, if
    you refresh the page a few times, you will notice that the number of impressions
    changes only once a minute.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用Memcached一样，我们使用`@cache_page`装饰器为视图设置缓存。因此，每个用户的每个响应都会被缓存60秒。视频详细信息视图（例如`http://127.0.0.1:8000/en/videos/1/`）显示了经过认证和匿名用户的印象数量。启用缓存后，如果您多次刷新页面，您会注意到印象数量每分钟只变化一次。
- en: Just like Memcached, Redis is a key-value store, and when used for caching,
    it generates the key for each cached page based on the full URL. When two visitors
    access the same page simultaneously, the first visitor's request would receive
    the page generated by the Python code, and the second one would get the same HTML
    code but from the Redis server.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Memcached一样，Redis是一个键值存储，当用于缓存时，它会根据完整的URL为每个缓存页面生成密钥。当两个访问者同时访问同一页面时，第一个访问者的请求将接收到由Python代码生成的页面，而第二个访问者将从Redis服务器获取相同的HTML代码。
- en: In our example, to ensure that each visitor gets treated separately, even if
    they access the same URL, we are using the `@vary_on_cookie` decorator. This decorator
    checks the uniqueness of the `Cookie` header in the HTTP request.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，为了确保每个访问者即使访问相同的URL也会被单独对待，我们使用了`@vary_on_cookie`装饰器。该装饰器检查HTTP请求中`Cookie`头的唯一性。
- en: You can learn more about Django's cache framework from the official documentation
    at [https://docs.djangoproject.com/en/3.0/topics/cache/](https://docs.djangoproject.com/en/3.0/topics/cache/).
    Similarly, you can find out more about Memcached at [https://redis.io/](https://redis.io/).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从官方文档了解有关Django缓存框架的更多信息[https://docs.djangoproject.com/en/3.0/topics/cache/](https://docs.djangoproject.com/en/3.0/topics/cache/)。同样，您也可以在[https://redis.io/](https://redis.io/)上了解有关Memcached的更多信息。
- en: There's more...
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While Redis is able to handle caching in the same manner as Memcached, there
    is a multitude of additional options for the caching algorithm built right into
    the system. In addition to caching, Redis can also be used as a database or message
    store. It supports a variety of data structures, transactions, pub/sub, and automatic
    failover, among other things.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: Redis能够像Memcached一样处理缓存，系统内置了大量额外的缓存算法选项。除了缓存，Redis还可以用作数据库或消息存储。它支持各种数据结构、事务、发布/订阅和自动故障转移等功能。
- en: 'Through the django-redis-cache backend, Redis can also be configured as the
    session backend with almost no effort, like so:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 通过django-redis-cache后端，Redis也可以轻松配置为会话后端，就像这样：
- en: '[PRE68]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: See also
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Caching the method return value* recipe
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*缓存方法返回值*教程'
- en: The *Using Memcached to cache Django views* recipe
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Memcached缓存Django视图*教程'
- en: The *Using database query expressions* recipe in [Chapter 10](dc084cae-d894-487f-8071-08c63c80f852.xhtml)*,
    Bells and Whistles*
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第10章](dc084cae-d894-487f-8071-08c63c80f852.xhtml)*，花里胡哨*'
