- en: Chapter 7. Python Extensions in Other Languages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。其他语言中的Python扩展
- en: 'When writing Python-based applications, you are not limited to the Python language
    alone. There are tools such as Hy, mentioned briefly in [Chapter 3](ch03.html
    "Chapter 3. Syntax Best Practices – above the Class Level"), *Syntax Best Practices
    – above the Class Level*. It allows you to write modules, packages, or even whole
    applications with some other language (dialect of Lisp) that will run in Python
    virtual machine. Although it gives you the ability to express program logic with
    completely different syntax, it is still quite the same language because it compiles
    to the same bytecode. It means that it has the same limitations as ordinary Python
    code:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写基于Python的应用程序时，您不仅限于Python语言。还有一些工具，比如Hy，在[第3章](ch03.html "第3章。语法最佳实践-类级别以上")中简要提到，*语法最佳实践-类级别以上*。它允许您使用其他语言（Lisp的方言）编写模块、包，甚至整个应用程序，这些应用程序将在Python虚拟机中运行。尽管它使您能够用完全不同的语法表达程序逻辑，但它仍然是相同的语言，因为它编译成相同的字节码。这意味着它具有与普通Python代码相同的限制：
- en: Threading usability is greatly reduced due to the existence of GIL
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于GIL的存在，线程的可用性大大降低
- en: It is not compiled
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有被编译
- en: It does not provide static typing and possible optimizations that come with
    it
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不提供静态类型和可能的优化
- en: The solution that helps in overcoming such core limitations are extensions that
    are entirely written in a different language and expose their interface through
    Python extension APIs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助克服这些核心限制的解决方案是完全用不同的语言编写的扩展，并通过Python扩展API公开它们的接口。
- en: 'This chapter will discuss the main reasons for writing your own extensions
    in other languages and introduce you to the popular tools that help to create
    them. You will learn:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论使用其他语言编写自己的扩展的主要原因，并向您介绍帮助创建它们的流行工具。您将学到：
- en: How to write simple extensions in C using the Python/C API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Python/C API编写简单的C扩展
- en: How to do the same using Cython
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Cython做同样的事情
- en: What are the main challenges and problems introduced by extensions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展引入的主要挑战和问题是什么
- en: How to interface with compiled dynamic libraries without creating dedicated
    extensions and using only Python code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何与编译的动态库进行接口，而不创建专用扩展，仅使用Python代码
- en: Different language means – C or C++
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的语言意味着-C或C++
- en: When we talk about extensions in different languages, we think almost exclusively
    about C and C++. Even tools such as Cython or Pyrex that provide Python language
    supersets only for the purpose of extensions are in fact source-to-source compilers
    that generate the C code from extended Python-like syntax.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论不同语言的扩展时，我们几乎只考虑C和C++。甚至像Cython或Pyrex这样的工具，它们提供Python语言的超集，仅用于扩展的目的，实际上是源到源编译器，从扩展的Python-like语法生成C代码。
- en: It's true that you can use dynamic/shared libraries written in any language
    in Python if only such compilation is possible and so it goes a way beyond C and
    C++. But shared libraries are intrinsically generic. They can be used in any language
    that supports their loading. So, even if you write such a library in a completely
    different language (let's say Delphi or Prolog), it is hard to name such library
    a Python extension if it does not use the Python/C API.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只有这样的编译是可能的，那么确实可以在Python中使用任何语言编写的动态/共享库，因此它远远超出了C和C++。但共享库本质上是通用的。它们可以在支持它们加载的任何语言中使用。因此，即使您用完全不同的语言（比如Delphi或Prolog）编写这样的库，很难称这样的库为Python扩展，如果它不使用Python/C
    API。
- en: 'Unfortunately, writing your own extensions only in C or C++ using the bare
    Python/C API is quite demanding. Not only because it requires a good understanding
    of one of the two languages that are relatively hard to master, but also because
    it requires exceptional amount of boilerplate. There is a lot of repetitive code
    that must be written only to provide an interface that will glue your implemented
    logic with Python and its datatypes. Anyway, it is good to know how pure C extensions
    are built because:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，仅使用裸的Python/C API在C或C++中编写自己的扩展是相当苛刻的。这不仅因为它需要对这两种相对难以掌握的语言之一有很好的理解，而且还因为它需要大量的样板文件。有很多重复的代码必须编写，只是为了提供一个接口，将您实现的逻辑与Python及其数据类型粘合在一起。无论如何，了解纯C扩展是如何构建的是很好的，因为：
- en: You will understand better how Python works in general
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将更好地了解Python的工作原理
- en: One day you may need to debug or maintain a native C/C++ extension
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一天，您可能需要调试或维护本机C/C++扩展
- en: It helps with understanding how higher-level tools for building extensions work
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于理解构建扩展的高级工具的工作原理
- en: How do extensions in C or C++ work
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C或C++中的扩展是如何工作的
- en: Python interpreter is able to load extensions from dynamic/shared libraries
    if they provide an applicable interface using Python/C API. This API must be incorporated
    in source code of extension using the `Python.h` C header file that is distributed
    with Python sources. In many distributions of Linux, this header file is contained
    in a separate package (for example, `python-dev` in Debian/Ubuntu) but under Windows,
    it is distributed by default and can be found in the `includes/` directory of
    your Python installation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Python解释器能够使用Python/C API提供适当的接口，它就能从动态/共享库中加载扩展。这个API必须被合并到扩展的源代码中，使用与Python源代码一起分发的`Python.h`
    C头文件。在许多Linux发行版中，这个头文件包含在一个单独的软件包中（例如，在Debian/Ubuntu中是`python-dev`），但在Windows下，默认情况下分发，并且可以在Python安装的`includes/`目录中找到。
- en: Python/C API traditionally changes with every release of Python. In most cases,
    these are only additions of new features to the API, so it is typically source-compatible.
    Anyway, in most cases, they are not binary compatible due to changes in the **Application
    Binary Interface** (**ABI**). This means that extensions must be built separately
    for every version of Python. Note also that different operating systems have noncompatible
    ABIs, so this makes it practically impossible to create a binary distribution
    for every possible environment. This is the reason why most Python extensions
    are distributed in source form.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python/C API通常会随着Python的每个版本发布而改变。在大多数情况下，这些只是对API的新功能的添加，因此通常是源代码兼容的。无论如何，在大多数情况下，它们不是二进制兼容的，因为**应用程序二进制接口**（**ABI**）发生了变化。这意味着扩展必须为每个Python版本单独构建。还要注意，不同的操作系统具有不兼容的ABI，因此这几乎不可能为每种可能的环境创建二进制分发。这就是为什么大多数Python扩展以源代码形式分发的原因。
- en: Since Python 3.2, a subset of Python/C API has been defined to have stable ABIs.
    It is possible then to build extensions using this limited API (with a stable
    ABI), so extensions can be built only once and will work with any version of Python
    higher than or equal to 3.2 without the need for recompilation. Anyway, this limits
    the amount of API features and does not solve the problems of older Python versions
    or the distribution of the extension in binary form to environments using different
    operating systems. So this is a trade-off, and price of the stable ABI seems to
    be a bit high for very low gain.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 自Python 3.2以来，已经定义了Python/C API的一个子集，具有稳定的ABI。因此可以使用这个有限的API（具有稳定的ABI）构建扩展，因此扩展只需构建一次，就可以在任何高于或等于3.2的Python版本上工作，无需重新编译。无论如何，这限制了API功能的数量，并且不能解决旧版本Python或以二进制形式分发扩展到使用不同操作系统的环境的问题。因此这是一个权衡，稳定ABI的代价似乎有点高而收益很低。
- en: One thing you need to know is that Python/C API is a feature that is limited
    to CPython implementations. Some efforts were made to bring extension support
    to alternative implementations such as PyPI, Jython, or IronPython, but it seems
    that there is no viable solution for them at the moment. The only alternative
    Python implementation that should deal easily with extensions is Stackless Python
    because it is in fact only a modified version of CPython.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要知道的一件事是，Python/C API是限于CPython实现的功能。一些努力已经为PyPI、Jython或IronPython等替代实现带来了扩展支持，但目前似乎没有可行的解决方案。唯一一个应该轻松处理扩展的替代Python实现是Stackless
    Python，因为它实际上只是CPython的修改版本。
- en: 'C extensions for Python need to be compiled into shared/dynamic libraries before
    they will be available to use because obviously there is no native way to import
    C/C++ code into Python directly from sources. Fortunately, `distutils` and `setuptools`
    provide helpers to define compiled extensions as modules so compilation and distribution
    can be handled using the `setup.py` script as if they were ordinary Python packages.
    This is an example of the `setup.py` script from the official documentation that
    handles the packaging of simple packages with built extensions:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Python的C扩展需要在可用之前编译成共享/动态库，因为显然没有本地的方法可以直接从源代码将C/C++代码导入Python。幸运的是，`distutils`和`setuptools`提供了帮助，将编译的扩展定义为模块，因此可以使用`setup.py`脚本处理编译和分发，就像它们是普通的Python包一样。这是官方文档中处理带有构建扩展的简单包的`setup.py`脚本的一个示例：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once prepared that way, there is one additional step required in your distribution
    flow:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好之后，你的分发流程还需要一个额外的步骤：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will compile all your extensions provided as the `ext_modules` argument
    according to all additional compiler settings provided with the `Extension()`
    call. The compiler that will be used is the one that is default for your environment.
    This compilation step is not required if the package is going to be distributed
    with source distribution. In that case, you need to be sure that the target environment
    has all compilation prerequisites, such as a compiler, header files, and additional
    libraries that are going to be linked to the binary (if your extension needs any).
    More details of packaging the Python extensions will be explained later in the
    *Challenges* section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这将根据`ext_modules`参数编译所有你的扩展，根据`Extension()`调用提供的所有额外编译器设置。将使用的编译器是你的环境的默认编译器。如果要分发源代码分发包，则不需要进行这个编译步骤。在这种情况下，你需要确保目标环境具有所有编译的先决条件，例如编译器、头文件和将链接到二进制文件的其他库（如果你的扩展需要）。有关打包Python扩展的更多细节将在*挑战*部分中解释。
- en: Why you might want to use extensions
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么你可能想使用扩展
- en: 'It''s not easy to say when it is a reasonable decision to write extensions
    in C/C++. The general rule of thumb could be, *never, unless you have no other
    choice*. But this is a very subjective statement that leaves a lot of room for
    interpretation of what is not doable in Python. In fact, it is hard to find a
    thing that cannot be done using pure Python code, but there are some problems
    where extensions may be especially useful:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 写C/C++扩展是否明智的决定并不容易。一般的经验法则可能是，“除非别无选择，否则永远不要”。但这是一个非常主观的说法，留下了很多解释空间，关于在Python中做不到的事情。事实上，很难找到一件事情，纯Python代码做不到，但有一些问题，扩展可能特别有用：
- en: Bypassing **GIL** (**Global Interpreter Lock**) in the Python threading model
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绕过Python线程模型中的**全局解释器锁**（**GIL**）
- en: Improving performance in critical code sections
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进关键代码部分的性能
- en: Integrating third-party dynamic libraries
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成第三方动态库
- en: Integrating source code written in different languages
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成用不同语言编写的源代码
- en: Creating custom datatypes
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义数据类型
- en: For example, the core language constraints such as GIL can easily be overcome
    with a different approach to concurrency, such as green threads or multiprocessing
    instead of a threading model.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，核心语言约束，如GIL，可以通过不同的并发方法轻松克服，例如绿色线程或多进程，而不是线程模型。
- en: Improving performance in critical code sections
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进关键代码部分的性能
- en: Let's be honest. Python is not chosen by developers because of performance.
    It does not execute quickly, but allows you to develop quickly. Still, no matter
    how performant we are as programmers, thanks to this language, we may sometimes
    find a problem that may not be solved efficiently using pure Python.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们诚实一点。开发人员选择Python并不是因为性能。它执行速度不快，但可以让你快速开发。尽管我们作为程序员有多么高效，多亏了这种语言，有时我们可能会发现一些问题，这些问题可能无法使用纯Python有效解决。
- en: In most cases, solving performance problems is really only about choosing proper
    algorithms and data structures and not about limiting the constant factor of language
    overhead. And it is not actually a good solution to rely on extensions in order
    to shave off some CPU cycles if the code is already written poorly or does not
    use proper algorithms. It is often possible that performance can be improved to
    an acceptable level without the need to increase the complexity of your project
    by looping in another language to the stack. And if it is possible, it should
    be done that way in the first place. Anyway, it is also very likely that even
    with *state of the art* algorithmic approach and the best suited data structures
    that are available to our disposal, we will not be able to fit some arbitrary
    technological constraints using Python alone.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，解决性能问题实际上只是选择合适的算法和数据结构，而不是限制语言开销的常数因子。如果代码已经编写得很差或者没有使用适当的算法，依赖扩展来节省一些CPU周期实际上并不是一个好的解决方案。通常情况下，性能可以在不需要通过在堆栈中循环另一种语言来增加项目复杂性的情况下提高到可接受的水平。如果可能的话，应该首先这样做。无论如何，即使使用*最先进*的算法方法和最适合的数据结构，我们也很可能无法仅仅使用Python就满足一些任意的技术约束。
- en: 'The example field that puts some well-defined limits on the application''s
    performance is the **Real Time Bidding** (**RTB**) business. In short, the whole
    RTB is about buying and selling advertisement inventory (places for ads) in a
    way similar to real auctions or stock exchanges. The trading usually takes place
    through some ad exchange service that sends information about available inventory
    to **demand-side platforms** (**DSP**) interested in buying them. And this is
    the place where things get exciting. Most ad exchanges use the OpenRTB protocol
    (which is based on HTTP) for communication with potential bidders where DSP is
    the site responsible for serving responses to its HTTP requests. And ad exchanges
    always put very limited time constraints (usually between 50 and 100 ms) on the
    whole process—from the first TPC packet received to the last byte written by the
    server. To spice things up, it is not uncommon for DSP platforms to process tens
    of thousands of requests per second. Being able to push the time of request processing
    even by a few milliseconds is the *to be or not to be* in this business. This
    means that porting even trivial code to C may be reasonable in that situation
    but only if it''s a part of some performance bottleneck and cannot be improved
    any further algorithmically. As someone once said:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将一些对应用程序性能施加了明确定义限制的示例领域是**实时竞价**（**RTB**）业务。简而言之，整个RTB都是关于以类似于真实拍卖或证券交易的方式购买和销售广告库存（广告位置）。交易通常通过一些广告交换服务进行，该服务向有兴趣购买它们的**需求方平台**（**DSP**）发送有关可用库存的信息。这就是事情变得令人兴奋的地方。大多数广告交换使用基于HTTP的OpenRTB协议与潜在竞标者进行通信，其中DSP是负责对其HTTP请求提供响应的站点。广告交换总是对整个过程施加非常有限的时间限制（通常在50到100毫秒之间）——从接收到第一个TPC数据包到服务器写入的最后一个字节。为了增加趣味，DSP平台通常每秒处理成千上万个请求并不罕见。能够将请求处理时间推迟几毫秒甚至是这个行业的生死攸关。这意味着即使是将微不足道的代码移植到C语言在这种情况下也是合理的，但前提是它是性能瓶颈的一部分，并且在算法上不能进一步改进。正如有人曾经说过的：
- en: '*"You can''t beat a loop written in C."*'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“你无法击败用C语言编写的循环。”*'
- en: Integrating existing code written in different languages
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整合不同语言编写的现有代码
- en: A lot of useful libraries have been written during the short history of computer
    science. It would be a great loss to forget about all that heritage every time
    a new programming language pops out, but it is also impossible to reliably port
    any piece of software that was ever written to any available language.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学的短暂历史中，已经编写了许多有用的库。每次出现新的编程语言时忘记所有这些遗产将是一个巨大的损失，但也不可能可靠地将曾经编写的任何软件完全移植到任何可用的语言。
- en: The C and C++ languages seem to be the most important languages that provide
    a lot of libraries and implementation that you would like to integrate in your
    application code without the need to port them completely to Python. Fortunately,
    CPython is already written in C, so the most natural way to integrate such code
    is precisely through custom extensions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++语言似乎是提供了许多库和实现的最重要的语言，你可能希望在应用程序代码中集成它们，而无需完全将它们移植到Python。幸运的是，CPython已经是用C编写的，因此通过自定义扩展是集成这样的代码的最自然的方式。
- en: Integrating third-party dynamic libraries
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成第三方动态库
- en: Integration of code written using different technologies does not end with C/C++.
    A lot of libraries, especially third-party software with closed sources, are distributed
    as compiled binaries. In C, it is really easy to load such shared/dynamic libraries
    and call their functions. This means that you can use any C library as long as
    you wrap it with extensions using Python/C API.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同技术编写的代码的集成并不仅限于C/C++。许多库，特别是具有闭源的第三方软件，都是以编译后的二进制形式分发的。在C中，加载这样的共享/动态库并调用它们的函数非常容易。这意味着只要使用Python/C
    API包装它，就可以使用任何C库。
- en: This, of course, is not the only solution and there are tools such as `ctypes`
    or CFFI that allow you to interact with dynamic libraries using pure Python without
    the need of writing extensions in C. Very often, the Python/C API may still be
    a better choice because it provides a better separation between the integration
    layer (written in C) and the rest of the application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是唯一的解决方案，还有诸如`ctypes`或CFFI之类的工具，允许您使用纯Python与动态库进行交互，而无需编写C扩展。通常情况下，Python/C
    API可能仍然是更好的选择，因为它在集成层（用C编写）和应用程序的其余部分之间提供了更好的分离。
- en: Creating custom datatypes
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义数据类型
- en: Python provides a very versatile selection of built-in datatypes. Some of them
    really use state of the art internal implementations (at least in CPython) that
    are specifically tailored for usage in the Python language. The number of basic
    types and collections available out-of-the-box may look impressive for newcomers,
    but it is clear that it does not cover all of our possible needs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了非常多样化的内置数据类型。其中一些真正使用了最先进的内部实现（至少在CPython中），专门为在Python语言中使用而量身定制。基本类型和可用的集合数量对于新手来说可能看起来令人印象深刻，但显然它并不能涵盖我们所有可能的需求。
- en: You can, of course, create many custom data structures in Python either by basing
    them completely on some built-in types or by building them from scratch as completely
    new classes. Unfortunately, for some applications that may heavily rely on such
    custom data structures, the performance might not be enough. The whole power of
    complex collections such as `dict` or `set` comes from their underlying C implementation.
    Why not do the same and implement some of your custom data structures in C too?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以通过完全基于一些内置类型或从头开始构建全新类来在Python中创建许多自定义数据结构。不幸的是，对于一些可能严重依赖这些自定义数据结构的应用程序来说，性能可能不够。像`dict`或`set`这样的复杂集合的全部功能来自它们的底层C实现。为什么不做同样的事情，也在C中实现一些自定义数据结构呢？
- en: Writing extensions
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写扩展
- en: As already said, writing extensions is not a simple task but in exchange for
    your hard work, it can give you a lot of advantages. The easiest and recommended
    approach to your own extensions is to use tools such as Cython or Pyrex or simply
    integrate the existing dynamic libraries with `ctypes` or `cffi`. These projects
    will increase your productivity and also make code easier to develop, read, and
    maintain.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，编写扩展并不是一项简单的任务，但作为您辛勤工作的回报，它可以给您带来许多优势。编写自己扩展的最简单和推荐的方法是使用诸如Cython或Pyrex的工具，或者简单地使用`ctypes`或`cffi`集成现有的动态库。这些项目将提高您的生产力，还会使代码更易于开发、阅读和维护。
- en: 'Anyway, if you are new to this topic, it is good to know that you can start
    your adventure with extensions by writing one using nothing more than bare C code
    and Python/C API. This will improve your understanding of how extensions work
    and will also help you to appreciate the advantages of alternative solutions.
    For the sake of simplicity, we will take a simple algorithmic problem as an example
    and try to implement it using three different approaches:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，如果您对这个主题还不熟悉，了解一点是好的，即您可以通过仅使用裸C代码和Python/C API编写一个扩展来开始您的扩展之旅。这将提高您对扩展工作原理的理解，并帮助您欣赏替代解决方案的优势。为了简单起见，我们将以一个简单的算法问题作为示例，并尝试使用三种不同的方法来实现它：
- en: Writing a pure C extension
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写纯C扩展
- en: Using Cython
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cython
- en: Using Pyrex
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Pyrex
- en: 'Our problem will be finding the *nth* number of the Fibonacci sequence. It
    is very unlikely that you would like to create compiled extensions solely for
    this problem, but it is very simple so it will serve as a very good example of
    wiring any C function to Python/C APIs. Our only goals are clarity and simplicity,
    so we won''t try to provide the most efficient solution. Once we know this, our
    reference implementation of the Fibonacci function implemented in Python looks
    as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的问题将是找到斐波那契数列的第*n*个数字。很少有人会仅为了这个问题创建编译扩展，但它非常简单，因此它将作为将任何C函数连接到Python/C API的非常好的示例。我们的唯一目标是清晰和简单，因此我们不会试图提供最有效的解决方案。一旦我们知道这一点，我们在Python中实现的斐波那契函数的参考实现如下：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that this is one of the most simple implementations of the `fibonnaci()`
    function and a lot of improvements could be applied to it. We refuse to improve
    our implementation (using a memoization pattern, for instance) though because
    this is not the purpose of our example. In the same manner, we won't optimize
    our code later when discussing implementations in C or Cython even though the
    compiled code gives many more possibilities to do so.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是`fibonnaci()`函数的最简单实现之一，可以对其进行许多改进。尽管如此，我们拒绝改进我们的实现（例如使用记忆化模式），因为这不是我们示例的目的。同样地，即使编译后的代码提供了更多的优化可能性，我们在讨论C或Cython中的实现时也不会优化我们的代码。
- en: Pure C extensions
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯C扩展
- en: Before we fully dive into the code examples of Python extensions written in
    C, here is a huge warning. If you want to extend Python with C, you need to already
    know both of these languages well. This is especially true for C. Lack of proficiency
    with it can lead to real disasters because it can be easily mishandled.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完全深入C编写的Python扩展的代码示例之前，这里有一个重要的警告。如果您想用C扩展Python，您需要已经对这两种语言非常了解。这对于C尤其如此。对它的熟练程度不足可能会导致真正的灾难，因为它很容易被误用。
- en: If you have decided that you need to write C extension for Python, I assume
    that you already know the C language to a level that will allow you to fully understand
    the examples that are presented. Nothing other than Python/C API details will
    be explained here. This book is about Python and not any other language. If you
    don't know C at all, you should definitely not try to write your own Python extensions
    in C until you gain enough experience and skills. Leave it to others and stick
    with Cython or Pyrex because they are a lot safer from the beginner's perspective.
    This is mostly because Python/C API, despite having been crafted with great care,
    is definitely not a good introduction to C.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经决定需要为Python编写C扩展，我假设您已经对C语言有了足够的了解，可以完全理解所呈现的示例。这里将不会解释除Python/C API细节之外的任何内容。本书是关于Python而不是其他任何语言。如果您根本不懂C，那么在获得足够的经验和技能之前，绝对不应该尝试用C编写自己的Python扩展。把它留给其他人，坚持使用Cython或Pyrex，因为从初学者的角度来看，它们更安全得多。这主要是因为Python/C
    API，尽管经过精心设计，但绝对不是C的良好入门。
- en: 'As proposed earlier, we will try to port the `fibonacci()` function to C and
    expose it to Python code as an extension. The bare implementation without the
    wiring to Python/C API that is analogous to the previous Python example could
    be roughly as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将尝试将`fibonacci()`函数移植到C并将其作为扩展暴露给Python代码。没有与Python/C API连接的裸实现，类似于前面的Python示例，大致如下：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And here is the example of a complete, fully functional extension that exposes
    this single function in a compiled module:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个完整、完全功能的扩展的示例，它在编译模块中公开了这个单一函数：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding example might be a bit overwhelming at first glance because we
    had to add four times more code just to make the `fibonacci()` C function accessible
    from Python. We will discuss every bit of that code later, so don''t worry. But
    before we do that, let''s see how it can be packaged and executed in Python. The
    minimal `setuptools` configuration for our module needs to use the `setuptools.Extension`
    class in order to instruct the interpreter how our extension is compiled:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子乍一看可能有点令人不知所措，因为我们不得不添加四倍的代码才能让`fibonacci()` C函数可以从Python中访问。我们稍后会讨论代码的每一部分，所以不用担心。但在我们讨论之前，让我们看看如何将其打包并在Python中执行。我们模块的最小`setuptools`配置需要使用`setuptools.Extension`类来指示解释器如何编译我们的扩展：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The build process for the extension can be initialized with Python''s `setup.py`
    build command, but will also be automatically performed on package installation.
    The following transcript presents the result of installation in development mode
    and a simple interactive session where our compiled `fibonacci()` function is
    inspected and executed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的构建过程可以通过Python的`setup.py`构建命令来初始化，但也会在包安装时自动执行。以下是在开发模式下安装的结果以及一个简单的交互会话，我们在其中检查和执行我们编译的`fibonacci()`函数：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A closer look at Python/C API
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对Python/C API的更详细了解
- en: Since we know how to properly package, compile, and install custom C extensions
    and we are sure that it works as expected, now it is the right time to discuss
    our code in detail.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道如何正确地打包、编译和安装自定义C扩展，并且确信它按预期工作，现在是讨论我们的代码的正确时间。
- en: 'The extensions module starts with a single C preprocessor directive that includes
    the `Python.h` header file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展模块以一个包含`Python.h`头文件的单个C预处理指令开始：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This pulls the whole Python/C API and is everything you need to include to be
    able to write your extensions. In more realistic cases, your code will require
    a lot more preprocessor directives to take benefit from C standard library functions
    or to integrate other source files. Our example was simple, so no more directives
    were required.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引入整个Python/C API，并且是您需要包含的一切，以便能够编写您的扩展。在更现实的情况下，您的代码将需要更多的预处理指令，以从C标准库函数中获益或集成其他源文件。我们的示例很简单，因此不需要更多的指令。
- en: 'Next we have the core of our module:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们模块的核心：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding `fibonacci()` function is the only part of our code that does
    something useful. It is pure C implementation that Python by default can't understand.
    The rest of our example will create the interface layer that will expose it through
    Python/C API.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`fibonacci()`函数是我们代码中唯一有用的部分。它是纯C实现，Python默认情况下无法理解。我们的示例的其余部分将创建接口层，通过Python/C
    API将其暴露出来。
- en: 'The first step of exposing this code to Python is the creation of the C function
    that is compatible with the CPython interpreter. In Python, everything is an object.
    This means that C functions called in Python also need to return real Python objects.
    Python/C APIs provide a `PyObject` type and every callable must return the pointer
    to it. The signature of our function is:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码暴露给Python的第一步是创建与CPython解释器兼容的C函数。在Python中，一切都是对象。这意味着在Python中调用的C函数也需要返回真正的Python对象。Python/C
    API提供了`PyObject`类型，每个可调用函数都必须返回指向它的指针。我们函数的签名是：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that the preceding signature does not specify the exact list of arguments
    but only `PyObject* args` that will hold the pointer to the structure that contains
    the tuple of the provided values. The actual validation of the argument list must
    be performed inside of the function body and this is exactly what `fibonacci_py()`
    does. It parses the `args` argument list assuming it is the single `unsigned int`
    type and uses that value as an argument to the `fibonacci()` function to retrieve
    the Fibonacci sequence element:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的签名并未指定确切的参数列表，而只是`PyObject* args`，它将保存指向包含提供的值元组的结构的指针。参数列表的实际验证必须在函数体内执行，这正是`fibonacci_py()`所做的。它解析`args`参数列表，假设它是单个`unsigned
    int`类型，并将该值用作`fibonacci()`函数的参数来检索斐波那契数列元素：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding example function has some serious bugs, which the eyes of an experienced
    developer should spot very easily. Try to find it as an exercise in working with
    C extensions. For now, we leave it as it is for the sake of brevity. We will try
    to fix it later when discussing details of dealing with errors in the *Exception
    handling* section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例函数有一些严重的错误，有经验的开发人员的眼睛应该很容易发现。尝试找到它，作为使用C扩展的练习。现在，为了简洁起见，我们将它保留下来。在*异常处理*部分讨论处理错误的细节时，我们将尝试稍后修复它。
- en: The `"l"` string in the `PyArg_ParseTuple(args, "l", &n)` call means that we
    expect `args` to contain only a single `long` value. In case of failure, it will
    return `NULL` and store information about the exception in the per-thread interpreter
    state. The details of exception handling will be described a bit later in the
    *Exception handling* section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`"l"`字符串在`PyArg_ParseTuple(args, "l", &n)`调用中意味着我们希望`args`只包含一个`long`值。如果失败，它将返回`NULL`并在每个线程的解释器状态中存储有关异常的信息。关于异常处理的详细信息将在*异常处理*部分稍后描述。'
- en: The actual signature of the parsing function is `int PyArg_ParseTuple(PyObject
    *args, const char *format, ...)` and what goes after the `format` string is a
    variable length list of arguments that represents parsed value output (as pointers).
    This is analogous to how the `scanf()` function from the C standard library works.
    If our assumption fails and the user provides an incompatible arguments list,
    then `PyArg_ParseTuple()` will raise the proper exception. This is a very convenient
    way to encode function signatures once you get used to it but has a huge downside
    when compared to plain Python code. Such Python call signatures implicitly defined
    by the `PyArg_ParseTuple()` calls cannot be easily inspected inside of the Python
    interpreter. You need to remember this fact when using code provided as extensions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 解析函数的实际签名是`int PyArg_ParseTuple(PyObject *args, const char *format, ...)`，在`format`字符串之后的是一个可变长度的参数列表，表示解析值输出（作为指针）。这类似于C标准库中的`scanf()`函数的工作方式。如果我们的假设失败，用户提供了不兼容的参数列表，那么`PyArg_ParseTuple()`将引发适当的异常。一旦你习惯了这种方式，这是一种非常方便的编码函数签名的方式，但与纯Python代码相比，它有一个巨大的缺点。由`PyArg_ParseTuple()`调用隐式定义的这种Python调用签名在Python解释器内部不能轻松地检查。在使用作为扩展提供的代码时，您需要记住这一点。
- en: As already said, Python expects objects to be returned from callables. This
    means that we cannot return a raw `long long` value obtained from the `fibonacci()`
    function as a result of `fibonacci_py()`. Such an attempt would not even compile
    and there is no automatic casting of basic C types to Python objects. The `Py_BuildValue(*format,
    ...)` function must be used instead. It is the counterpart of `PyArg_ParseTuple()`
    and accepts a similar set of format strings. The main difference is that the list
    of arguments is not a function output but an input, so actual values must be provided
    instead of pointers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Python期望从可调用对象返回对象。这意味着我们不能将从`fibonacci()`函数获得的`long long`值作为`fibonacci_py()`的结果返回。这样的尝试甚至不会编译，基本C类型不会自动转换为Python对象。必须使用`Py_BuildValue(*format,
    ...)`函数。它是`PyArg_ParseTuple()`的对应物，并接受类似的格式字符串集。主要区别在于参数列表不是函数输出而是输入，因此必须提供实际值而不是指针。
- en: After `fibonacci_py()` is defined, most of the heavy work is done. The last
    step is to perform module initialization and add metadata to our function that
    will make usage a bit simpler for users. This is the boilerplate part of our extension
    code that for some simple examples, such as this one, can take more place than
    actual functions that we want to expose. In most cases, it simply consists of
    some static structures and one initialization function that will be executed by
    the interpreter on module import.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`fibonacci_py()`之后，大部分繁重的工作都已完成。最后一步是执行模块初始化并向我们的函数添加元数据，这将使用户的使用变得更简单一些。这是我们扩展代码的样板部分，对于一些简单的例子，比如这个例子，可能会占用比我们想要公开的实际函数更多的空间。在大多数情况下，它只是由一些静态结构和一个初始化函数组成，该函数将由解释器在模块导入时执行。
- en: 'At first, we create a static string that will be a content of Python docstring
    for the `fibonacci_py()` function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个静态字符串，它将成为`fibonacci_py()`函数的Python文档字符串的内容：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that this could be *inlined* somewhere later in `fibonacci_module_methods`,
    but it is a good practice to have docstrings separated and stored in close proximity
    to the actual function definition that they refer to.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这可能会*内联*在`fibonacci_module_methods`的某个地方，但将文档字符串分开并存储在与其引用的实际函数定义的附近是一个很好的做法。
- en: 'The next part of our definition is the array of the `PyMethodDef` structures
    that define methods (functions) that will be available in our module. This structure
    contains exactly four fields:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的下一部分是`PyMethodDef`结构的数组，该数组定义了将在我们的模块中可用的方法（函数）。该结构包含四个字段：
- en: '`char* ml_name`: This is the name of the method.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char* ml_name`: 这是方法的名称。'
- en: '`PyCFunction ml_meth`: This is the pointer to the C implementation of the function.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyCFunction ml_meth`: 这是指向函数的C实现的指针。'
- en: '`int ml_flags`: This includes the flags indicating either the calling convention
    or binding convention. The latter is applicable only for definition of class methods.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int ml_flags`: 这包括指示调用约定或绑定约定的标志。后者仅适用于定义类方法。'
- en: '`char* ml_doc`: This is the pointer to the content of method/function docstring.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char* ml_doc`: 这是指向方法/函数文档字符串内容的指针。'
- en: 'Such an array must always end with a sentinel value of `{NULL, NULL, 0, NULL}`
    that indicates its end. In our simple case, we created the `static PyMethodDef
    fibonacci_module_methods[]` array that contains only two elements (including the
    sentinel value):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的数组必须始终以`{NULL, NULL, 0, NULL}`的哨兵值结束，表示其结束。在我们的简单情况下，我们创建了`static PyMethodDef
    fibonacci_module_methods[]`数组，其中只包含两个元素（包括哨兵值）：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And this is how the first entry maps to the `PyMethodDef` structure:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是第一个条目如何映射到`PyMethodDef`结构：
- en: '`ml_name = "fibonacci"`: Here, the `fibonacci_py()` C function will be exposed
    as a Python function under the `fibonacci` name'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ml_name = "fibonacci"`: 在这里，`fibonacci_py()` C函数将以`fibonacci`名称作为Python函数公开'
- en: '`ml_meth = (PyCFunction)fibonacci_py`: Here, the casting to `PyCFunction` is
    simply required by Python/C API and is dictated by the call convention defined
    later in `ml_flags`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ml_meth = (PyCFunction)fibonacci_py`: 在这里，将`PyCFunction`转换仅仅是Python/C API所需的，并且由`ml_flags`中定义的调用约定决定'
- en: '`ml_flags = METH_VARARGS`: Here, the `METH_VARARGS` flag indicates that the
    calling convention of our function accepts a variable list of arguments and no
    keyword arguments'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ml_flags = METH_VARARGS`: 在这里，`METH_VARARGS`标志表示我们的函数的调用约定接受可变参数列表，不接受关键字参数'
- en: '`ml_doc = fibonacci_docs`: Here, the Python function will be documented with
    the content of the `fibonacci_docs` string'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ml_doc = fibonacci_docs`: 在这里，Python函数将使用`fibonacci_docs`字符串的内容进行文档化'
- en: 'When an array of function definitions is complete, we can create another structure
    that contains the definition of the whole module. It is described using the `PyModuleDef`
    type and contains multiple fields. Some of them are useful only for more complex
    scenarios, where fine-grained control over the module initialization process is
    required. Here we are interested only in the first five of them:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数定义数组完成时，我们可以创建另一个结构，其中包含整个模块的定义。它使用`PyModuleDef`类型进行描述，并包含多个字段。其中一些仅适用于需要对模块初始化过程进行细粒度控制的更复杂的情况。在这里，我们只对其中的前五个感兴趣：
- en: '`PyModuleDef_Base m_base`: This should always be initialized with `PyModuleDef_HEAD_INIT`.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyModuleDef_Base m_base`: 这应该始终用`PyModuleDef_HEAD_INIT`进行初始化。'
- en: '`char* m_name`: This is the name of the newly created module. In our case it
    is `fibonacci`.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char* m_name`: 这是新创建模块的名称。在我们的例子中是`fibonacci`。'
- en: '`char* m_doc`: This is the pointer to the docstring content for the module.
    We usually have only a single module defined in one C source file, so it is OK
    to inline our documentation string in the whole structure.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char* m_doc`: 这是模块的文档字符串内容的指针。通常在一个C源文件中只定义一个模块，因此将我们的文档字符串内联在整个结构中是可以的。'
- en: '`Py_ssize_t m_size`: This is the size of the memory allocated to keep the module
    state. This is only used when support for multiple subinterpreters or multiphase
    initialization is required. In most cases, you don''t need that and it is gets
    the value `-1`.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Py_ssize_t m_size`: 这是分配给保持模块状态的内存的大小。只有在需要支持多个子解释器或多阶段初始化时才会使用。在大多数情况下，您不需要它，它的值为`-1`。'
- en: '`PyMethodDef* m_methods`: This is a pointer to the array containing module-level
    functions described by the `PyMethodDef` values. It could be `NULL` if the module
    does not expose any functions. In our case, it is `fibonacci_module_methods`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyMethodDef* m_methods`: 这是指向包含由`PyMethodDef`值描述的模块级函数的数组的指针。如果模块不公开任何函数，则可以为`NULL`。在我们的情况下，它是`fibonacci_module_methods`。'
- en: 'The other fields are explained in detail in the official Python documentation
    (refer to [https://docs.python.org/3/c-api/module.html](https://docs.python.org/3/c-api/module.html))
    but are not needed in our example extension. They should be set to `NULL` if not
    required and they will be initialized with that value implicitly when not specified.
    This is why our module description contained in the `fibonacci_module_definition`
    variable can take this simple five-element form:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 其他字段在官方Python文档中有详细解释（参考[https://docs.python.org/3/c-api/module.html](https://docs.python.org/3/c-api/module.html)），但在我们的示例扩展中不需要。如果不需要，它们应该设置为`NULL`，当未指定时，它们将隐式地初始化为该值。这就是为什么我们的模块描述包含在`fibonacci_module_definition`变量中可以采用这种简单的五元素形式的原因：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The last piece of code that crowns our work is the module initialization function.
    This must follow a very specific naming convention, so the Python interpreter
    can easily pick it when the dynamic/shared library is loaded. It should be named
    `PyInit_name`, where *name* is your module name. So it is exactly the same string
    that was used as the `m_base` field in the `PyModuleDef` definition and as the
    first argument of the `setuptools.Extension()` call. If you don''t require a complex
    initialization process for the module, it takes a very simple form, exactly like
    in our example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段代码是我们工作的巅峰，即模块初始化函数。这必须遵循非常特定的命名约定，以便Python解释器在加载动态/共享库时可以轻松地选择它。它应该被命名为`PyInit_name`，其中*name*是您的模块名称。因此，它与在`PyModuleDef`定义中用作`m_base`字段和`setuptools.Extension()`调用的第一个参数的字符串完全相同。如果您不需要对模块进行复杂的初始化过程，它将采用与我们示例中完全相同的非常简单的形式：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `PyMODINIT_FUNC` macro is a preprocessor macro that will declare the return
    type of this initialization function as `PyObject*` and add any special linkage
    declarations if required by the platform.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`PyMODINIT_FUNC`宏是一个预处理宏，它将声明此初始化函数的返回类型为`PyObject*`，并根据平台需要添加任何特殊的链接声明。'
- en: Calling and binding conventions
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用和绑定约定
- en: 'As explained in the *A closer look at Python/C API* section, the `ml_flags`
    bitfield of the `PyMethodDef` structure contains flags for calling and binding
    conventions. **Calling convention flags** are:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如*深入了解Python/C API*部分所述，`PyMethodDef`结构的`ml_flags`位字段包含调用和绑定约定的标志。**调用约定标志**包括：
- en: '`METH_VARARGS`: This is a typical convention for the Python function or method
    that only accepts arguments as its parameters. The type provided as the `ml_meth`
    field for such a function should be `PyCFunction`. The function will be provided
    with two arguments of the `PyObject*` type. The first is either the `self` object
    (for methods) or the `module` object (for module functions). A typical signature
    for the C function with that calling convention is `PyObject* function(PyObject*
    self, PyObject* args)`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`METH_VARARGS`: 这是Python函数或方法的典型约定，只接受参数作为其参数。对于这样的函数，`ml_meth`字段提供的类型应该是`PyCFunction`。该函数将提供两个`PyObject*`类型的参数。第一个要么是`self`对象（对于方法），要么是`module`对象（对于模块函数）。具有该调用约定的C函数的典型签名是`PyObject*
    function(PyObject* self, PyObject* args)`。'
- en: '`METH_KEYWORDS`: This is the convention for the Python function that accepts
    keyword arguments when called. Its associated C type is `PyCFunctionWithKeywords`.
    The C function must accept three arguments of the `PyObject*` type: `self`, `args`,
    and a dictionary of keyword arguments. If combined with `METH_VARARGS`, the first
    two arguments have the same meaning as for the previous calling convention, otherwise
    `args` will be `NULL`. The typical C function signature is: `PyObject* function(PyObject*
    self, PyObject* args, PyObject* keywds)`.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`METH_KEYWORDS`：这是Python函数在调用时接受关键字参数的约定。其关联的C类型是`PyCFunctionWithKeywords`。C函数必须接受三个`PyObject*`类型的参数：`self`，`args`和关键字参数的字典。如果与`METH_VARARGS`组合，前两个参数的含义与前一个调用约定相同，否则`args`将为`NULL`。典型的C函数签名是：`PyObject*
    function(PyObject* self, PyObject* args, PyObject* keywds)`。'
- en: '`METH_NOARGS`: This is the convention for Python functions that do not accept
    any other argument. The C function should be of the `PyCFunction` type, so the
    signature is the same as that of the `METH_VARARGS` convention (two `self` and
    `args` arguments). The only difference is that `args` will always be `NULL`, so
    there is no need to call `PyArg_ParseTuple()`. This cannot be combined with any
    other calling convention flag.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`METH_NOARGS`：这是Python函数不接受任何其他参数的约定。C函数应该是`PyCFunction`类型，因此签名与`METH_VARARGS`约定相同（两个`self`和`args`参数）。唯一的区别是`args`将始终为`NULL`，因此不需要调用`PyArg_ParseTuple()`。这不能与任何其他调用约定标志组合。'
- en: '`METH_O`: This is the shorthand for functions and methods accepting single
    object arguments. The type of C function is again `PyCFunction`, so it accepts
    two `PyObject*` arguments: `self` and `args`. Its difference `from METH_VARARGS`
    is that there is no need to call `PyArg_ParseTuple()` because `PyObject*` provided
    as `args` will already represent the single argument provided in the Python call
    to that function. This also cannot be combined with any other calling convention
    flag.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`METH_O`：这是接受单个对象参数的函数和方法的简写。C函数的类型再次是`PyCFunction`，因此它接受两个`PyObject*`参数：`self`和`args`。它与`METH_VARARGS`的区别在于不需要调用`PyArg_ParseTuple()`，因为作为`args`提供的`PyObject*`将已经表示在Python调用该函数时提供的单个参数。这也不能与任何其他调用约定标志组合。'
- en: 'A function that accepts keywords is described either with `METH_KEYWORDS` or
    a bitwise combination of calling convention flags in the form of `METH_VARARGS
    |` `METH_KEYWORDS`. If so, it should parse its arguments with `PyArg_ParseTupleAndKeywords()`
    instead of `PyArg_ParseTuple()` or `PyArg_UnpackTuple()`. Here is an example module
    with a single function that returns `None` and accepts two named keyword arguments
    that are printed on standard output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接受关键字的函数可以用`METH_KEYWORDS`或者`METH_VARARGS |` `METH_KEYWORDS`的形式来描述。如果是这样，它应该使用`PyArg_ParseTupleAndKeywords()`来解析它的参数，而不是`PyArg_ParseTuple()`或者`PyArg_UnpackTuple()`。下面是一个示例模块，其中有一个返回`None`的函数，接受两个命名关键字参数，并将它们打印到标准输出：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Argument parsing in Python/C API is very elastic and is extensively described
    in the official documentation at [https://docs.python.org/3.5/c-api/arg.html](https://docs.python.org/3.5/c-api/arg.html).
    The format argument in `PyArg_ParseTuple()` and `PyArg_ParseTupleAndKeywords()`
    allows fine grained control over argument number and types. Every advanced calling
    convention known in Python can be coded in C with this API including:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Python/C API中的参数解析非常灵活，并且在官方文档中有详细描述。`PyArg_ParseTuple()`和`PyArg_ParseTupleAndKeywords()`中的格式参数允许对参数数量和类型进行精细的控制。Python中已知的每个高级调用约定都可以使用此API在C中编码，包括：
- en: Functions with default values for arguments
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有默认参数值的函数
- en: Functions with arguments specified as keyword-only
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定为关键字参数的函数
- en: Functions with a variable number of arguments
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有可变数量参数的函数
- en: The **binding convention flags** are `METH_CLASS`, `METH_STATIC`, and `METH_COEXIST`,
    are reserved for methods, and cannot be used to describe module functions. The
    first two are quite self-explanatory. They are the C counterparts of `classmethod`
    and `staticmethod` decorators and change the meaning of the `self` argument passed
    to the C function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**绑定约定标志**是`METH_CLASS`，`METH_STATIC`和`METH_COEXIST`，它们保留给方法，并且不能用于描述模块函数。前两个相当不言自明。它们是`classmethod`和`staticmethod`装饰器的C对应物，并且改变了传递给C函数的`self`参数的含义。'
- en: '`METH_COEXIST` allows loading a method in place of the existing definition.
    It is useful very rarely. This is mostly when you would like to provide an implementation
    of the C method that would be generated automatically from the other features
    of the type that was defined. Python documentation gives an example of the `__contains__()`
    wrapper method that would be generated if the type has the `sq_contains` slot
    defined. Unfortunately, defining your own classes and types using Python/C API
    is beyond the scope of this introductory chapter. We will cover creating your
    own types in extensions later when discussing Cython because doing that in pure
    C requires way too much boilerplate code and leaves a lot of room for making mistakes.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`METH_COEXIST`允许在现有定义的位置加载一个方法。这很少有用。这主要是当您想要提供一个从已定义的类型的其他特性自动生成的C方法的实现时。Python文档给出了`__contains__()`包装器方法的示例，如果类型定义了`sq_contains`槽，它将自动生成。不幸的是，使用Python/C
    API定义自己的类和类型超出了本入门章节的范围。在讨论Cython时，我们将在以后讨论创建自己的类型，因为在纯C中这样做需要太多样板代码，并且容易出错。'
- en: Exception handling
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常处理
- en: C, unlike Python, or even C++ does not have syntax for raising and catching
    exceptions. All error handling is usually handled with function return values
    and optional global state for storing details that can explain the cause of the
    last failure.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python甚至C++不同，C没有语法来引发和捕获异常。所有错误处理通常通过函数返回值和可选的全局状态来处理，用于存储可以解释最后一次失败原因的细节。
- en: 'Exception handling in Python/C API is built around that simple principle. There
    is a global per thread indicator of the last error that occurred and functioned
    in the C API. It is set to describe the cause of a problem. There is also a standardized
    way to inform the caller of a function if this state was changed during the call:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Python/C API中的异常处理建立在这个简单原则的基础上。有一个全局的每个线程指示器，用于描述C API中发生的最后一个错误。它被设置为描述问题的原因。还有一种标准化的方法，用于在调用期间通知函数的调用者是否更改了此状态：
- en: If the function is supposed to return a pointer, it returns `NULL`
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数应返回指针，则返回`NULL`
- en: If the function is supposed to return an `int` type, it returns `-1`
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数应返回`int`类型，则返回`-1`
- en: The only exceptions from the preceding rules in Python/C API are the `PyArg_*()`
    functions that return `1` to indicate success and `0` to indicate failure.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python/C API中，前述规则的唯一例外是返回`1`表示成功，返回`0`表示失败的`PyArg_*（）`函数。
- en: 'To see how this works in practice, let''s recall our `fibonacci_py()` function
    from the example in the previous sections:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这在实践中是如何工作的，让我们回顾一下前几节中示例中的`fibonacci_py（）`函数：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Lines that somehow take part in our error handling are highlighted. It starts
    at the very beginning with the initialization of the `result` variable that is
    supposed to store the return value of our function. It is initialized with `NULL`
    that, as we already know, is an indicator of error. And this is how you will usually
    code your extensions, assuming that error is the default state of your code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以某种方式参与我们的错误处理的行已经被突出显示。它从初始化`result`变量开始，该变量应存储我们函数的返回值。它被初始化为`NULL`，正如我们已经知道的那样，这是一个错误指示器。这通常是您编写扩展的方式，假设错误是代码的默认状态。
- en: Later we have the `PyArg_ParseTuple()` call that will set error info in case
    of an exception and return `0`. This is part of the `if` statement and in that
    case we don't do anything more and return `NULL`. Whoever calls our function will
    be notified about the error.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们有`PyArg_ParseTuple（）`调用，如果发生异常，将设置错误信息并返回`0`。这是`if`语句的一部分，在这种情况下，我们不做任何其他操作并返回`NULL`。调用我们的函数的人将收到有关错误的通知。
- en: '`Py_BuildValue()` can also raise an exception. It is supposed to return `PyObject*`
    (pointer), so in case of failure it gives `NULL`. We can simply store it as our
    result variable and pass further as a return value.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Py_BuildValue（）`也可能引发异常。它应返回`PyObject*`（指针），因此在失败的情况下会返回`NULL`。我们可以简单地将其存储为我们的结果变量，并将其作为返回值传递。'
- en: 'But our job does not end with caring for exceptions raised by Python/C API
    calls. It is very probable that you will need to inform the extension user that
    some other kind of error or failure occurred. Python/C API has multiple functions
    that help you to raise an exception, but the most common one is `PyErr_SetString()`.
    It sets an error indicator with the given exception type with an additional string
    provided as the error cause explanation. The full signature of this function is:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的工作并不仅仅是关心Python/C API调用引发的异常。很可能您需要通知扩展用户发生了其他类型的错误或失败。Python/C API有多个函数可帮助您引发异常，但最常见的是`PyErr_SetString（）`。它使用提供的附加字符串设置错误指示器和给定的异常类型作为错误原因的解释。此函数的完整签名是：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'I have already said that implementation of our `fibonacci_py()` function has
    serious bug. Now is the right time to fix it. Fortunately, we have proper tools
    to do that. The problem lies in insecure casting of the `long` type to `unsigned
    int` in the following lines:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经说过我们的`fibonacci_py（）`函数的实现存在严重错误。现在是修复它的正确时机。幸运的是，我们有适当的工具来做到这一点。问题在于在以下行中将`long`类型不安全地转换为`unsigned
    int`：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Thanks to the `PyArg_ParseTuple()` call, the first and only argument will be
    interpreted as a `long` type (the `"l"` specifier) and stored in the local `n`
    variable. Then it is cast to `unsigned int` so the issue will occur if the user
    calls the `fibonacci()` function from Python with a negative value. For instance,
    `-1`, as a signed 32-bit integer, will be interpreted as `4294967295` when cast
    to an unsigned 32-bit integer. Such a value will cause deep recursion and will
    result in stack overflow and a segmentation fault. Note that the same may happen
    if the user gives an arbitrarily large positive argument. We cannot fix this without
    a complete redesign of the C `fibonacci()` function, but we can at least try to
    ensure that argument that is passed meets some preconditions. Here we check if
    the value of the `n` argument is greater than or equal to zero and we raise a
    `ValueError` exception if that''s not true:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢`PyArg_ParseTuple（）`调用，第一个且唯一的参数将被解释为`long`类型（“l”指定符），并存储在本地`n`变量中。然后将其转换为`unsigned
    int`，因此如果用户使用负值从Python调用`fibonacci（）`函数，则会出现问题。例如，作为有符号32位整数的`-1`在转换为无符号32位整数时将被解释为`4294967295`。这样的值将导致深度递归，并导致堆栈溢出和分段错误。请注意，如果用户提供任意大的正参数，也可能会发生相同的情况。我们无法在没有完全重新设计C
    `fibonacci（）`函数的情况下解决这个问题，但至少我们可以尝试确保传递的参数满足一些先决条件。在这里，我们检查`n`参数的值是否大于或等于零，如果不是，则引发`ValueError`异常：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The last note is that the global error state does not clear by itself. Some
    of the errors can be handled gracefully in your C functions (same as using the
    `try ... except` clause in Python) and you need to be able to clear the error
    indicator if it is no longer valid. The function for that is `PyErr_Clear()`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点是全局错误状态不会自行清除。您的C函数中可能会优雅地处理一些错误（就像在Python中使用`try ... except`子句一样），如果错误指示器不再有效，则需要能够清除错误指示器。用于此目的的函数是`PyErr_Clear（）`。
- en: Releasing GIL
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 释放GIL
- en: I have already mentioned that extensions can be a way to bypass Python GIL.
    There is a famous limitation of the CPython implementation stating that only one
    thread at a time can execute Python code. While multiprocessing is the suggested
    approach to circumvent this problem, it may not be a good solution for some highly
    parallelizable algorithms due to the resource overhead of running additional processes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到扩展可以是绕过Python GIL的一种方法。CPython实现有一个著名的限制，即一次只能有一个线程执行Python代码。虽然多进程是绕过这个问题的建议方法，但对于一些高度可并行化的算法来说，由于运行额外进程的资源开销，这可能不是一个好的解决方案。
- en: 'Because extensions are mostly used in cases where a bigger part of the work
    is performed in pure C without any calls to Python/C API, it is possible (even
    advisable) to release GIL in some application sections. Thanks to this, you can
    still benefit from having multiple CPU cores and multithreaded application design.
    The only thing you need to do is to wrap blocks of code that are known to not
    use any of Python/C API calls or Python structures with specific macros provided
    by Python/C API. These two preprocessor macros are provided to simplify the whole
    procedure of releasing and reacquiring the Global Interpreter Lock:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因为扩展主要用于在纯C中执行大部分工作而没有调用Python/C API的情况下，所以在一些应用程序部分释放GIL是可能的（甚至是建议的）。由于这一点，您仍然可以从拥有多个CPU核心和多线程应用程序设计中受益。您唯一需要做的就是使用Python/C
    API提供的特定宏将已知不使用任何Python/C API调用或Python结构的代码块进行包装。这两个预处理器宏旨在简化释放和重新获取全局解释器锁的整个过程：
- en: '`Py_BEGIN_ALLOW_THREADS`: This declares the hidden local variable where the
    current thread state is saved and it releases GIL'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Py_BEGIN_ALLOW_THREADS`：这声明了隐藏的本地变量，保存了当前线程状态并释放了GIL'
- en: '`Py_END_ALLOW_THREADS`: This reacquires GIL and restores the thread state from
    the local variable declared with the previous macro'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Py_END_ALLOW_THREADS`：这重新获取GIL并从使用前一个宏声明的本地变量恢复线程状态'
- en: 'When we look carefully at our `fibonacci` extension example, we can clearly
    see that the `fibonacci()` function does not execute any Python code and does
    not touch any of the Python structures. This means that the `fibonacci_py()` function
    that simply wraps the `fibonacci(n)` execution could be updated to release GIL
    around that call:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们仔细观察我们的`fibonacci`扩展示例时，我们可以清楚地看到`fibonacci()`函数不执行任何Python代码，也不触及任何Python结构。这意味着简单包装`fibonacci(n)`执行的`fibonacci_py()`函数可以更新以在调用周围释放GIL：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Reference counting
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用计数
- en: Finally, we come to the important topic of memory management in Python. Python
    has its own garbage collector, but it is designed only to solve the issue of cyclic
    references in the **reference counting** algorithm. Reference counting is the
    primary method of managing the deallocation of objects that are no longer needed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了Python中内存管理的重要主题。Python有自己的垃圾回收器，但它只设计用来解决**引用计数**算法中的循环引用问题。引用计数是管理不再需要的对象的释放的主要方法。
- en: Python/C API documentation introduces an *ownership of references* to explain
    how it deals with deallocation of objects. Objects in Python are never owned and
    they are always shared. The actual creation of objects is managed by Python's
    memory manager. It is the component of CPython interpreter that is responsible
    for allocating and deallocating memory for objects that are stored in a private
    heap. What can be owned instead is a reference to the object.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Python/C API文档引入了*引用的所有权*来解释它如何处理对象的释放。Python中的对象从不被拥有，它们总是被共享。对象的实际创建由Python的内存管理器管理。这是CPython解释器的一个组件，负责为存储在私有堆中的对象分配和释放内存。可以拥有的是对对象的引用。
- en: 'Every object in Python that is represented by a reference (`PyObject*` pointer)
    has an associated reference count. When it goes to zero, it means that no one
    holds any valid reference to the object and the deallocator associated with its
    type can be called. Python/C API provides two macros for increasing and decreasing
    reference counts: `Py_INCREF()`, and `Py_DECREF()`. But before we discuss their
    details, we need to understand a few more terms related to reference ownership:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的每个对象，由一个引用（`PyObject*`指针）表示，都有一个关联的引用计数。当引用计数为零时，意味着没有人持有对象的有效引用，可以调用与其类型相关联的解分配器。Python/C
    API提供了两个宏来增加和减少引用计数：`Py_INCREF()`和`Py_DECREF()`。但在讨论它们的细节之前，我们需要了解与引用所有权相关的一些术语：
- en: '**Passing of ownership**: Whenever we say that the function *passes the ownership*
    over a reference, it means that it has already increased the reference count and
    it is the responsibility of the caller to decrease the count when the reference
    to the object is no longer needed. Most of the functions that return the newly
    created objects, such as `Py_BuildValue`, do that. If that object is going to
    be returned from our function to another caller, then the ownership is passed
    again. We do not decrease the reference count in that case because it is no longer
    our responsibility. This is why the `fibonacci_py()` function does not call `Py_DECREF()`
    on the `result` variable.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有权的传递**：每当我们说函数*传递了对引用的所有权*时，这意味着它已经增加了引用计数，调用者有责任在不再需要对象的引用时减少计数。大多数返回新创建对象的函数，比如`Py_BuildValue`，都会这样做。如果该对象将从我们的函数返回给另一个调用者，那么所有权会再次传递。在这种情况下，我们不会减少引用计数，因为这不再是我们的责任。这就是为什么`fibonacci_py()`函数不在`result`变量上调用`Py_DECREF()`的原因。'
- en: '**Borrowed references**: The *borrowing* of references happens when the function
    receives a reference to some Python object as an argument. The reference count
    for such a reference should never be decreased in that function unless it was
    explicitly increased in its scope. In our `fibonacci_py()` function the `self`
    and `args` arguments are such borrowed references and thus we do not call `PyDECREF()`
    on them. Some of the Python/C API functions may also return borrowed references.
    The notable examples are `PyTuple_GetItem()` and `PyList_GetItem()`. It is often
    said that such references are *unprotected*. There is no need to dispose of its
    ownership unless it will be returned as a function''s return value. In most cases,
    extra care should be taken if we use such borrowed references as arguments of
    other Python/C API calls. It may be necessary in some circumstances to additionally
    protect such references with additional `Py_INCREF()` before using as argument
    to other function and then calling `Py_DECREF()` when it is no longer needed.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**借用引用**：*借用*引用发生在函数将某个Python对象的引用作为参数接收时。在该函数中，除非在其范围内明确增加了引用计数，否则不应该减少此类引用的引用计数。在我们的`fibonacci_py()`函数中，`self`和`args`参数就是这样的借用引用，因此我们不对它们调用`PyDECREF()`。Python/C
    API的一些函数也可能返回借用引用。值得注意的例子是`PyTuple_GetItem()`和`PyList_GetItem()`。通常说这样的引用是*不受保护*的。除非它将作为函数的返回值返回，否则不需要释放其所有权。在大多数情况下，如果我们将这样的借用引用用作其他Python/C
    API调用的参数，就需要额外小心。在某些情况下，可能需要在将其用作其他函数的参数之前，额外使用`Py_INCREF()`来保护这样的引用，然后在不再需要时调用`Py_DECREF()`。'
- en: '**Stolen references**: It is also possible for the Python/C API function to
    *steal* the reference instead of *borrowing* it when provided as a call argument.
    This is the case of exactly two functions: `PyTuple_SetItem()` and `PyList_SetItem()`.
    They fully take over the responsibility of the reference passed to them. They
    do not increase the reference count by themselves but will call `Py_DECREF()`
    when the reference is no longer needed.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**窃取引用**：Python/C API函数还可以在提供为调用参数时*窃取*引用，而不是*借用*引用。这是确切的两个函数的情况：`PyTuple_SetItem()`和`PyList_SetItem()`。它们完全承担了传递给它们的引用的责任。它们本身不增加引用计数，但在不再需要引用时会调用`Py_DECREF()`。'
- en: Keeping an eye on the reference counts is one of the hardest things when writing
    complex extensions. Some of the not-so-obvious issues may not be noticed until
    the code is run in a multithreaded setup.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写复杂的扩展时，监视引用计数是最困难的事情之一。一些不那么明显的问题可能直到在多线程设置中运行代码时才会被注意到。
- en: 'The other common problem is caused by the very nature of Python''s object model
    and the fact that some functions return borrowed references. When the reference
    count goes to zero, the deallocation function is executed. For user-defined classes,
    it is possible to define a `__del__()` method that will be called at that moment.
    This can be any Python code and it is possible that it will affect other objects
    and their reference counts. The official Python documentation gives the following
    example of code that may be affected by this problem:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的问题是由Python对象模型的本质和一些函数返回借用引用的事实引起的。当引用计数变为零时，将执行解分配函数。对于用户定义的类，可以定义一个`__del__()`方法，在那时将被调用。这可以是任何Python代码，可能会影响其他对象及其引用计数。官方Python文档给出了以下可能受到此问题影响的代码示例：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It looks completely harmless, but the problem is in fact that we cannot know
    what elements the `list` object contains. When `PyList_SetItem()` sets a new value
    on the `list[1]` index, the ownership of the object that was previously stored
    at that index is disposed. If it was the only existing reference, the reference
    count will become 0 and the object will become deallocated. It is possible that
    it was some user-defined class with a custom implementation of the `__del__()`
    method. A serious issue will occur if in the result of such a `__del__()` execution
    `item[0]` will be removed from the list. Note that `PyList_GetItem()` returns
    a *borrowed* reference! It does not call `Py_INCREF()` before returning a reference.
    So in that code, it is possible that `PyObject_Print()` will be called with a
    reference to an object that no longer exists. This will cause a segmentation fault
    and crash the Python interpreter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来完全无害，但问题实际上是我们无法知道`list`对象包含哪些元素。当`PyList_SetItem()`在`list[1]`索引上设置一个新值时，之前存储在该索引处的对象的所有权被处理。如果它是唯一存在的引用，引用计数将变为0，并且对象将被解分配。可能是某个用户定义的类，具有`__del__()`方法的自定义实现。如果在这样的`__del__()`执行的结果中，`item[0]`将从列表中移除，将会出现严重问题。请注意，`PyList_GetItem()`返回一个*借用*引用！在返回引用之前，它不会调用`Py_INCREF()`。因此，在该代码中，可能会调用`PyObject_Print()`，并且会使用一个不再存在的对象的引用。这将导致分段错误并使Python解释器崩溃。
- en: 'The proper approach is to protect borrowed references for the whole time we
    need them because there is a possibility that any call in-between may cause deallocation
    of any other object—even if they are seemingly unrelated:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的方法是在我们需要它们的整个时间内保护借用引用，因为有可能在其中的任何调用可能导致任何其他对象的解分配，即使它们看似无关：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Cython
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cython
- en: Cython is both an optimizing static compiler and the name of a programming language
    that is a superset of Python. As a compiler, it can perform *source to source*
    compilation of native Python code and its Cython dialect to Python C extensions
    using Python/C API. It allows you to combine the power of Python and C without
    the need to manually deal with Python/C API.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Cython既是一个优化的静态编译器，也是Python的超集编程语言的名称。作为编译器，它可以对本地Python代码和其Cython方言进行*源到源*编译，使用Python/C
    API将其转换为Python C扩展。它允许您结合Python和C的强大功能，而无需手动处理Python/C API。
- en: Cython as a source to source compiler
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cython作为源到源编译器
- en: For extensions created using Cython, the major advantage you will get is using
    the superset language that it provides. Anyway, it is possible to create extensions
    from plain Python code using *source to source* compilation. This is the simplest
    approach to Cython because it requires almost no changes to the code and can give
    some significant performance improvements at a very low development cost.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cython创建的扩展的主要优势是可以使用它提供的超集语言。无论如何，也可以使用*源到源*编译从纯Python代码创建扩展。这是Cython的最简单方法，因为它几乎不需要对代码进行任何更改，并且可以在非常低的开发成本下获得一些显著的性能改进。
- en: 'Cython provides a simple `cythonize` utility function that allows you to easily
    integrate the compilation process with `distutils` or `setuptools`. Let''s assume
    that we would like to compile a pure Python implementation of our `fibonacci()`
    function to a C extension. If it is located in the `fibonacci` module, the minimal
    `setup.py` script could be as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Cython提供了一个简单的`cythonize`实用函数，允许您轻松地将编译过程与`distutils`或`setuptools`集成。假设我们想将`fibonacci()`函数的纯Python实现编译为C扩展。如果它位于`fibonacci`模块中，最小的`setup.py`脚本可能如下所示：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Cython used as a source compilation tool for the Python language has another
    benefit. Source to source compilation to extensions can be a fully optional part
    of source distribution installation process. If the environment where the package
    needs to be installed does not have Cython or any other building prerequisites,
    it can be installed as a normal *pure Python* package. The user should not notice
    any functional difference in the behavior of code distributed that way.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Cython作为Python语言的源编译工具还有另一个好处。源到源编译到扩展可以是源分发安装过程的完全可选部分。如果需要安装包的环境没有Cython或任何其他构建先决条件，它可以像普通的*纯Python*包一样安装。用户不应该注意到以这种方式分发的代码行为上的任何功能差异。
- en: 'A common approach for distributing extensions built with Cython is to include
    both Python/Cython sources and C code that would be generated from these source
    files. This way the package can be installed in three different ways depending
    on the existence of building prerequisites:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cython构建的扩展的常见方法是包括Python/Cython源代码和从这些源文件生成的C代码。这样，该包可以根据构建先决条件的存在以三种不同的方式安装：
- en: If the installation environment has Cython available, the extension C code is
    generated from the Python/Cython sources that are provided
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果安装环境中有Cython可用，则会从提供的Python/Cython源代码生成扩展C代码。
- en: If Cython is not available but there are available building prerequisites (C
    compiler, Python/C API headers), the extension is built from distributed pre-generated
    C files
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果Cython不可用，但存在构建先决条件（C编译器，Python/C API头文件），则从分发的预生成C文件构建扩展。
- en: If neither of the preceding prerequisites is available but the extension is
    created from pure Python sources, the modules are installed like ordinary Python
    code, and the compilation step is skipped
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果前述的先决条件都不可用，但扩展是从纯Python源创建的，则模块将像普通的Python代码一样安装，并且跳过编译步骤。
- en: 'Note that Cython documentation says that including generated C files as well
    as Cython sources is the recommended way of distributing Cython extensions. The
    same documentation says that Cython compilation should be disabled by default
    because the user may not have the required version of Cython in his environment
    and this may result in unexpected compilation issues. Anyway, with the advent
    of environment isolation, this seems to be a less worrying problem today. Also,
    Cython is a valid Python package that is available on PyPI, so it can easily be
    defined as your project requirement in a specific version. Including such a prerequisite
    is, of course, a decision with serious implications and should be considered very
    carefully. The safer solution is to leverage the power of the `extras_require`
    feature in the `setuptools` package and allow the user to decide whether he wants
    to use Cython with a specific environment variable:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Cython文档表示，包括生成的C文件以及Cython源是分发Cython扩展的推荐方式。同样的文档表示，Cython编译应该默认禁用，因为用户可能在他的环境中没有所需版本的Cython，这可能导致意外的编译问题。无论如何，随着环境隔离的出现，这似乎是一个今天不太令人担忧的问题。此外，Cython是一个有效的Python包，可以在PyPI上获得，因此可以很容易地在特定版本中定义为您项目的要求。当然，包括这样的先决条件是一个具有严重影响的决定，应该非常谨慎地考虑。更安全的解决方案是利用`setuptools`包中的`extras_require`功能的强大功能，并允许用户决定是否要使用特定环境变量来使用Cython：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `pip` installation tool supports the installation of packages with the
    *extras* option by adding the `[extra-name]` suffix to the package name. For the
    preceding example, the optional Cython requirement and compilation during the
    installation from local sources can be enabled using the following command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip`安装工具支持通过在包名后添加`[extra-name]`后缀来使用*extras*选项安装包。对于前面的示例，可以使用以下命令启用从本地源安装时的可选Cython要求和编译：'
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Cython as a language
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cython作为一种语言
- en: Cython is not only a compiler but also a superset of the Python language. Superset
    means that any valid Python code is allowed and it can be further updated with
    additional features, such as support for calling C functions or declaring C types
    on variables and class attributes. So any code written in Python is also written
    in Cython. This explains why ordinary Python modules can be so easily compiled
    to C using the Cython compiler.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Cython不仅是一个编译器，还是Python语言的超集。超集意味着任何有效的Python代码都是允许的，并且可以进一步更新为具有额外功能的代码，例如支持调用C函数或在变量和类属性上声明C类型。因此，任何用Python编写的代码也是用Cython编写的。这解释了为什么普通的Python模块可以如此轻松地使用Cython编译为C。
- en: But we won't stop on that simple fact. Instead of saying that our reference
    `fibonacci()` function is also code for valid extensions in this superset of Python,
    we will try to improve it a bit. This won't be any real optimization to our function
    design but some minor updates that will allow it to benefit from being written
    in Cython.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不会停留在这个简单的事实上。我们将尝试对我们的参考`fibonacci()`函数进行一些改进，而不是说它也是Python的超集中有效扩展的代码。这不会对我们的函数设计进行任何真正的优化，而是一些小的更新，使它能够从在Cython中编写的好处中受益。
- en: 'Cython sources use a different file extension. It is `.pyx` instead of `.py`.
    Let''s assume that we still want to implement our Fibbonacci sequence. The content
    of `fibonacci.pyx` might look like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Cython源文件使用不同的文件扩展名。它是`.pyx`而不是`.py`。假设我们仍然想要实现我们的Fibbonacci序列。`fibonacci.pyx`的内容可能如下所示：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, the only thing that has really changed is the signature of
    the `fibonacci()` function. Thanks to optional static typing in Cython, we can
    declare the `n` argument as `unsigned int`, and this should slightly improve the
    way our function works. Additionally, it does a lot more than we did previously
    when writing extensions by hand. If the argument of the Cython function is declared
    with a static type, then the extension will automatically handle conversion and
    overflow errors by raising proper exceptions:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，真正改变的只是`fibonacci()`函数的签名。由于Cython中的可选静态类型，我们可以将`n`参数声明为`unsigned int`，这应该稍微改进了我们函数的工作方式。此外，它比我们以前手工编写扩展时做的事情要多得多。如果Cython函数的参数声明为静态类型，则扩展将自动处理转换和溢出错误，引发适当的异常：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We already know that Cython compiles only *source to source* and the generated
    code uses the same Python/C API that we would use when writing C code for extensions
    by hand. Note that `fibonacci()` is a recursive function, so it calls itself very
    often. This will mean that although we declared a static type for input argument,
    during the recursive call it will treat itself like any other Python function.
    So `n-1` and `n-2` will be packed back into the Python object and then passed
    to the hidden wrapper layer of the internal `fibonacci()` implementation that
    will again bring it back to the `unsigned int` type. This will happen again and
    again until we reach the final depth of recursion. This is not necessarily a problem
    but involves a lot more argument processing than really required.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道Cython只编译*源到源*，生成的代码使用与我们手工编写C代码扩展时相同的Python/C API。请注意，`fibonacci()`是一个递归函数，因此它经常调用自身。这意味着尽管我们为输入参数声明了静态类型，在递归调用期间，它将像任何其他Python函数一样对待自己。因此，`n-1`和`n-2`将被打包回Python对象，然后传递给内部`fibonacci()`实现的隐藏包装层，再次将其转换为`unsigned
    int`类型。这将一次又一次地发生，直到我们达到递归的最终深度。这不一定是一个问题，但涉及到比实际需要的更多的参数处理。
- en: 'We can cut off the overhead of Python function calls and argument processing
    by delegating more of the work to a pure C function that does not know anything
    about Python structures. We did this previously when creating C extensions with
    pure C and we can do that in Cython too. We can use the `cdef` keyword to declare
    C-style functions that accept and return only C types:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将更多的工作委托给一个纯C函数来削减Python函数调用和参数处理的开销。我们以前在使用纯C创建C扩展时就这样做过，我们在Cython中也可以这样做。我们可以使用`cdef`关键字声明只接受和返回C类型的C风格函数：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can go even further. With a plain C example, we finally showed how to release
    GIL during the call of our pure C function, so the extension was a bit nicer for
    multithreaded applications. In previous examples, we have used `Py_BEGIN_ALLOW_THREADS`
    and `Py_END_ALLOW_THREADS` preprocessor macros from Python/C API headers to mark
    section of code as free from Python calls. The Cython syntax is a lot shorter
    and easier to remember. GIL can be released around the section of code using a
    simple `with nogil` statement:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以走得更远。通过一个简单的C示例，我们最终展示了如何在调用我们的纯C函数时释放GIL，因此扩展对多线程应用程序来说更加友好。在以前的示例中，我们使用了Python/C
    API头文件中的`Py_BEGIN_ALLOW_THREADS`和`Py_END_ALLOW_THREADS`预处理器宏来标记代码段为无需Python调用。Cython语法要简短得多，更容易记住。可以使用简单的`with
    nogil`语句在代码段周围释放GIL：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can also mark the whole C style function as safe to call without GIL:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将整个C风格函数标记为无需GIL即可调用：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It is important to know that such functions cannot have Python objects as arguments
    or return types. Whenever a function marked as `nogil` needs to perform any Python/C
    API call, it must acquire GIL using the `with gil` statement.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，这样的函数不能将Python对象作为参数或返回类型。每当标记为`nogil`的函数需要执行任何Python/C API调用时，它必须使用`with
    gil`语句获取GIL。
- en: Challenges
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: To be honest, I started my adventure with Python only because I was tired of
    all the difficulty of writing software in C and C++. In fact, it is very common
    that programmers start to learn Python when they realize that other languages
    do not deliver what the users need. Programming in Python, when compared to C,
    C++, or Java, is a breeze. Everything seems to be simple and well designed. You
    might think that there are no places where you can trip and there are no other
    programming languages required anymore.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，我之所以开始接触Python，只是因为我厌倦了用C和C++编写软件的所有困难。事实上，程序员们意识到其他语言无法满足用户需求时，很常见的是开始学习Python。与C、C++或Java相比，用Python编程是一件轻而易举的事情。一切似乎都很简单而且设计良好。你可能会认为没有地方会让你绊倒，也不再需要其他编程语言了。
- en: And of course nothing could be more wrong. Yes, Python is an amazing language
    with a lot of cool features and it is used in many fields. But it does not mean
    that it is perfect and does not have any downsides. It is easy to understand and
    write, but this easiness comes with a price. It is not as slow as many think,
    but will never be as fast as C. It is highly portable, but its interpreter is
    not available on as many architectures as compilers for other languages are. We
    could go with that list forever.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种想法是错误的。是的，Python是一种令人惊叹的语言，具有许多很酷的功能，并且在许多领域中被使用。但这并不意味着它是完美的，也没有任何缺点。它易于理解和编写，但这种简单性是有代价的。它并不像许多人认为的那样慢，但永远不会像C那样快。它高度可移植，但它的解释器并不像其他语言的编译器那样在许多架构上都可用。我们可以永远列出这样的列表。
- en: 'One of the solutions to that problem is to write extensions, so we can bring
    of some of the advantages of *good old C* back to Python. And in most cases, it
    works well. The question is: are we really using Python because we want to extend
    it with C? The answer is *no*. This is only an inconvenient necessity in situations
    where we don''t have any better option.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个方法是编写扩展，这样我们就可以将*好老的C*的一些优点带回Python。在大多数情况下，这样做效果很好。问题是：我们真的是因为想用C来扩展Python吗？答案是否定的。这只是在我们没有更好选择的情况下的一种不便的必要性。
- en: Additional complexity
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外的复杂性
- en: It is not a secret that developing applications in many different languages
    is not an easy task. Python and C are completely different technologies and it
    is very hard to find anything that they have in common. It is also true that there
    is no application that is free of bugs. If extensions become common in your codebase,
    debugging can become painful. Not only because debugging of C code requires completely
    different workflow and tools, but also because you will need to switch context
    between two different languages very often.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无秘密，用许多不同的语言开发应用程序并不是一件容易的事情。Python和C是完全不同的技术，很难找到它们共同之处。同样真实的是没有一个应用程序是没有bug的。如果在你的代码库中扩展变得很常见，调试可能会变得痛苦。不仅因为调试C代码需要完全不同的工作流程和工具，而且因为你需要经常在两种不同的语言之间切换上下文。
- en: We are all humans and all have limited cognitive capabilities. There are, of
    course, people who can handle multiple layers of abstraction and technology stacks
    at the same time efficiently but they seem to be very rare specimens. No matter
    how skilled you are, there is always an additional price to pay for maintaining
    such hybrid solutions. This will either involve extra effort and time required
    to switch between C and Python, or additional stress that will make you eventually
    less efficient.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都是人类，都有有限的认知能力。当然，有些人可以有效地处理多层抽象和技术堆栈，但他们似乎是非常罕见的。无论你有多么有技巧，对于维护这样的混合解决方案，总是需要额外付出代价。这要么涉及额外的努力和时间来在C和Python之间切换，要么涉及额外的压力，最终会使你效率降低。
- en: According to the TIOBE index, C is still one of the most popular programming
    languages. Despite this fact, it is very common for Python programmers to know
    very little or almost nothing about it. Personally, I think that C should be *lingua
    franca* in the programming world, but my opinion is very unlikely to change anything
    in this matter. Python also is so seductive and easy to learn that a lot of programmers
    forget about all their previous experiences and completely switch to the new technology.
    And programming is not like riding a bike. This particular skill erodes faster
    if not used and polished sufficiently. Even programmers with strong C background
    are risking to gradually lose their previous knowledge if they decide to dive
    into Python for too long. All of the above leads to one simple conclusion—it is
    harder to find people who will be able to understand and extend your code. For
    open source packages, this means fewer voluntary contributors. In closed source,
    this means that not all of your teammates will be able to develop and maintain
    extensions without breaking things.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 根据TIOBE指数，C仍然是最流行的编程语言之一。尽管事实如此，Python程序员很常见地对它知之甚少，甚至几乎一无所知。就我个人而言，我认为C应该是编程世界的*通用语言*，但我的观点在这个问题上很不可能改变任何事情。Python也是如此诱人和易学，以至于许多程序员忘记了他们以前的所有经验，完全转向了新技术。而编程不像骑自行车。如果不经常使用和充分磨练，这种特定的技能会更快地消失。即使是具有扎实C背景的程序员，如果决定长时间深入Python，也会逐渐失去他们以前的知识。以上所有情况都导致一个简单的结论——很难找到能够理解和扩展你的代码的人。对于开源软件包，这意味着更少的自愿贡献者。对于闭源软件，这意味着并非所有的队友都能够在不破坏东西的情况下开发和维护扩展。
- en: Debugging
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试
- en: When it comes to failures, extensions may break, very badly. Static typing gives
    you a lot of advantages over Python and allows you to catch a lot of issues during
    the compilation step that would be hard to notice in Python without a rigorous
    testing routine and full test coverage. On the other hand, all memory management
    must be performed manually. And faulty memory management is the main reason of
    most programming errors in C. In the best case scenario, such mistakes will only
    result in some memory leaks that will gradually eat all of your environment resources.
    The best case does not mean easy to handle. Memory leaks are really tricky to
    find without using proper external tools such as Valgrind. Anyway, in most cases,
    the memory management issues in your extension's code will result in a segmentation
    fault that is unrecoverable in Python and will cause the interpreter to crash
    without raising any exception. This means that you will eventually need to arm
    up with additional tools that most Python programmers don't need to use. This
    adds complexity to your development environment and workflow.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到失败时，扩展可能会出现严重故障。静态类型给你比Python更多的优势，并允许你在编译步骤中捕获很多问题，这些问题在Python中很难注意到，除非进行严格的测试例程和全面的测试覆盖。另一方面，所有内存管理必须手动执行。错误的内存管理是C中大多数编程错误的主要原因。在最好的情况下，这样的错误只会导致一些内存泄漏，逐渐消耗所有环境资源。最好的情况并不意味着容易处理。内存泄漏真的很难在不使用适当的外部工具（如Valgrind）的情况下找到。无论如何，在大多数情况下，扩展代码中的内存管理问题将导致分段错误，在Python中无法恢复，并且会导致解释器崩溃而不引发任何异常。这意味着最终您将需要额外的工具，大多数Python程序员不需要使用。这给您的开发环境和工作流程增加了复杂性。
- en: Interfacing with dynamic libraries without extensions
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无需扩展即可与动态库进行接口
- en: Thanks to `ctypes` (a module in the standard library) or `cffi` (an external
    package), you can integrate just about every compiled dynamic/shared library in
    Python no matter in what language it was written. And you can do that in pure
    Python without any compilation steps, so this is an interesting alternative to
    writing extensions in C.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ctypes`（标准库中的一个模块）或`cffi`（一个外部包），您可以在Python中集成几乎所有编译的动态/共享库，无论它是用什么语言编写的。而且您可以在纯Python中进行，无需任何编译步骤，因此这是编写C扩展的有趣替代方案。
- en: This does not mean you don't need to know anything about C. Both solutions require
    from you a reasonable understanding of C and how dynamic libraries work in general.
    On the other hand, they remove the burden of dealing with Python reference counting
    and greatly reduce the risk of making painful mistakes. Also interfacing with
    C code through `ctypes` or `cffi` is more portable than writing and compiling
    the C extension module.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着您不需要了解C。这两种解决方案都需要您对C有合理的理解，以及对动态库的工作原理有所了解。另一方面，它们消除了处理Python引用计数的负担，并大大减少了犯错误的风险。通过`ctypes`或`cffi`与C代码进行接口，比编写和编译C扩展模块更具可移植性。
- en: ctypes
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ctypes
- en: '`ctypes` is the most popular module to call functions from dynamic or shared
    libraries without the need of writing custom C extensions. The reason for that
    is obvious. It is part of the standard library, so it is always available and
    does not require any external dependencies. It is a **foreign function interface**
    (**FFI**) library and provides an API for creating C-compatible datatypes.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctypes` 是调用动态或共享库函数最流行的模块，无需编写自定义的C扩展。其原因是显而易见的。它是标准库的一部分，因此始终可用，不需要任何外部依赖。它是一个**外部函数接口**（**FFI**）库，并提供了一个用于创建兼容C数据类型的API。'
- en: Loading libraries
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载库
- en: 'There are four types of dynamic library loaders available in `ctypes` and two
    conventions to use them. The classes that represent dynamic and shared libraries
    are `ctypes.CDLL`, `ctypes.PyDLL`, `ctypes.OleDLL`, and `ctypes.WinDLL`. The last
    two are only available on Windows, so we won''t discuss them here. The differences
    between `CDLL` and `PyDLL` are as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctypes`中有四种类型的动态库加载器，以及两种使用它们的约定。表示动态和共享库的类有`ctypes.CDLL`、`ctypes.PyDLL`、`ctypes.OleDLL`和`ctypes.WinDLL`。最后两个仅在Windows上可用，因此我们不会在这里讨论它们。`CDLL`和`PyDLL`之间的区别如下：'
- en: '`ctypes.CDLL`: This class represents loaded shared libraries. The functions
    in these libraries use the standard calling convention, and are assumed to return
    `int`. GIL is released during the call.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ctypes.CDLL`：此类表示已加载的共享库。这些库中的函数使用标准调用约定，并假定返回`int`。在调用期间释放GIL。'
- en: '`ctypes.PyDLL`: This class works like `CDLL`, but GIL is not released during
    the call. After execution, the Python error flag is checked and an exception is
    raised if it is set. It is only useful when directly calling functions from Python/C
    API.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ctypes.PyDLL`：此类与`CDLL`类似，但在调用期间不会释放GIL。执行后，将检查Python错误标志，并在设置时引发异常。仅在直接从Python/C
    API调用函数时才有用。'
- en: 'To load a library, you can either instantiate one of the preceding classes
    with proper arguments or call the `LoadLibrary()` function from the submodule
    associated with a specific class:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载库，您可以使用前述类之一实例化，并使用适当的参数，或者调用与特定类相关联的子模块的`LoadLibrary()`函数：
- en: '`ctypes.cdll.LoadLibrary()` for `ctypes.CDLL`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ctypes.cdll.LoadLibrary()` 用于 `ctypes.CDLL`'
- en: '`ctypes.pydll.LoadLibrary()` for `ctypes.PyDLL`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ctypes.pydll.LoadLibrary()` 用于 `ctypes.PyDLL`'
- en: '`ctypes.windll.LoadLibrary()` for `ctypes.WinDLL`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ctypes.windll.LoadLibrary()` 用于 `ctypes.WinDLL`'
- en: '`ctypes.oledll.LoadLibrary()` for `ctypes.OleDLL`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ctypes.oledll.LoadLibrary()` 用于 `ctypes.OleDLL`'
- en: The main challenge when loading shared libraries is how to find them in a portable
    way. Different systems use different suffixes for shared libraries (`.dll` on
    Windows, `.dylib` on OS X, `.so` on Linux) and search for them in different places.
    The main offender in this area is Windows, that does not have a predefined naming
    scheme for libraries. Because of that, we won't discuss the details of loading
    libraries with `ctypes` on this system and concentrate mainly on Linux and Mac
    OS X that deal with this problem in a consistent and similar way. If you are anyway
    interested in Windows platform, refer to the official `ctypes` documentation that
    has plenty of information about supporting that system (refer to [https://docs.python.org/3.5/library/ctypes.html](https://docs.python.org/3.5/library/ctypes.html)).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载共享库时的主要挑战是如何以便携方式找到它们。不同的系统对共享库使用不同的后缀（Windows上为`.dll`，OS X上为`.dylib`，Linux上为`.so`）并在不同的位置搜索它们。在这方面的主要问题是Windows，它没有预定义的库命名方案。因此，我们不会讨论在这个系统上使用`ctypes`加载库的细节，而主要集中在处理这个问题的一致和类似方式的Linux和Mac
    OS X上。如果您对Windows平台感兴趣，可以参考官方的`ctypes`文档，其中有大量关于支持该系统的信息（参见[https://docs.python.org/3.5/library/ctypes.html](https://docs.python.org/3.5/library/ctypes.html)）。
- en: 'Both library loading conventions (the `LoadLibrary()` function and specific
    library-type classes) require you to use the full library name. This means all
    the predefined library prefixes and suffixes need to be included. For example,
    to load the C standard library on Linux, you need to write the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 加载库的两种约定（`LoadLibrary()`函数和特定的库类型类）都要求您使用完整的库名称。这意味着需要包括所有预定义的库前缀和后缀。例如，在Linux上加载C标准库，您需要编写以下内容：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, for Mac OS X, this would be:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对于Mac OS X，这将是：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Fortunately, the `ctypes.util` submodule provides a `find_library()` function
    that allows to load a library using its name without any prefixes or suffixes
    and will work on any system that has a predefined scheme for naming shared libraries:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`ctypes.util`子模块提供了一个`find_library()`函数，允许使用其名称加载库，而无需任何前缀或后缀，并且将在具有预定义共享库命名方案的任何系统上工作：
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Calling C functions using ctypes
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ctypes调用C函数
- en: 'When the library is successfully loaded, the common pattern is to store it
    as a module-level variable with the same name as library. The functions can be
    accessed as object attributes, so calling them is like calling a Python function
    from any other imported module:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当成功加载库时，通常的模式是将其存储为与库同名的模块级变量。函数可以作为对象属性访问，因此调用它们就像调用来自任何其他已导入模块的Python函数一样：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Unfortunately, all the built-in Python types except integers, strings, and
    bytes are incompatible with C datatypes and thus must be wrapped in the corresponding
    classes provided by the `ctypes` module. Here is the full list of compatible datatypes
    that comes from the `ctypes` documentation:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，除了整数、字符串和字节之外，所有内置的Python类型都与C数据类型不兼容，因此必须包装在`ctypes`模块提供的相应类中。以下是来自`ctypes`文档的完整兼容数据类型列表：
- en: '| ctypes type | C type | Python type |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: ctypes类型 | C类型 | Python类型 |
- en: '| --- | --- | --- |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '--- | --- | --- |'
- en: '| `c_bool` | `_Bool` | `bool` (1) |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '`c_bool` | `_Bool` | `bool`（1） |'
- en: '| `c_char` | `char` | 1-character `bytes` object |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '`c_char` | `char` | 1个字符的`bytes`对象 |'
- en: '| `c_wchar` | `wchar_t` | 1-character `string` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '`c_wchar` | `wchar_t` | 1个字符的`string` |'
- en: '| `c_byte` | `char` | `int` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '`c_byte` | `char` | `int` |'
- en: '| `c_ubyte` | `unsigned char` | `int` |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '`c_ubyte` | `unsigned char` | `int` |'
- en: '| `c_short` | `short` | `int` |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '`c_short` | `short` | `int` |'
- en: '| `c_ushort` | `unsigned short` | `int` |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '`c_ushort` | `unsigned short` | `int` |'
- en: '| `c_int` | `int` | `int` |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '`c_int` | `int` | `int` |'
- en: '| `c_uint` | `unsigned int` | `int` |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '`c_uint` | `unsigned int` | `int` |'
- en: '| `c_long` | `long` | `int` |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '`c_long` | `long` | `int` |'
- en: '| `c_ulong` | `unsigned long` | `int` |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '`c_ulong` | `unsigned long` | `int` |'
- en: '| `c_longlong` | `__int64 or long long` | `int` |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '`c_longlong` | `__int64或long long` | `int` |'
- en: '| `c_ulonglong` | `unsigned __int64 or unsigned long long` | `int` |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '`c_ulonglong` | `unsigned __int64或unsigned long long` | `int` |'
- en: '| `c_size_t` | `size_t` | `int` |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '`c_size_t` | `size_t` | `int` |'
- en: '| `c_ssize_t` | `ssize_t or Py_ssize_t` | `int` |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '`c_ssize_t` | `ssize_t或Py_ssize_t` | `int` |'
- en: '| `c_float` | `float` | `float` |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '`c_float` | `float` | `float` |'
- en: '| `c_double` | `double` | `float` |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '`c_double` | `double` | `float` |'
- en: '| `c_longdouble` | `long double` | `float` |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '`c_longdouble` | `long double` | `float` |'
- en: '| `c_char_p` | `char * (NUL terminated)` | `bytes` object or `None` |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '`c_char_p` | `char *（NUL终止）` | `bytes`对象或`None` |'
- en: '| `c_wchar_p` | `wchar_t * (NUL terminated)` | `string` or `None` |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '`c_wchar_p` | `wchar_t *（NUL终止）` | `string`或`None` |'
- en: '| `c_void_p` | `void *` | `int` or `None` |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '`c_void_p` | `void *` | `int`或`None` |'
- en: 'As you can see, the preceding table does not contain dedicated types that would
    reflect any of the Python collections as C arrays. The recommended way to create
    types for C arrays is to simply use the multiplication operator with the desired
    basic `ctypes` type:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，上表中没有专门的类型来反映任何Python集合作为C数组。创建C数组类型的推荐方法是简单地使用所需的基本`ctypes`类型与乘法运算符：
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Passing Python functions as C callbacks
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将Python函数作为C回调传递
- en: It is a very popular design pattern to delegate part of the work of function
    implementation to custom callbacks provided by the user. The most known function
    from the C standard library that accepts such callbacks is a `qsort()` function
    that provides a generic implementation of the **Quicksort** algorithm. It is rather
    unlikely that you would like to use this algorithm instead of the default Python
    **Timsort** that is more suited for sorting Python collections. Anyway, `qsort()`
    seems to be a canonical example of an efficient sorting algorithm and a C API
    that uses the callback mechanism that is found in many programming books. This
    is why we will try to use it as an example of passing the Python function as a
    C callback.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数实现的一部分委托给用户提供的自定义回调是一种非常流行的设计模式。C标准库中接受此类回调的最知名函数是提供了**Quicksort**算法的`qsort()`函数。您可能不太可能使用此算法而不是更适合对Python集合进行排序的默认Python
    **Timsort**。无论如何，`qsort()`似乎是一个高效排序算法和使用回调机制的C API的典型示例，在许多编程书籍中都可以找到。这就是为什么我们将尝试将其用作将Python函数作为C回调传递的示例。
- en: 'The ordinary Python function type will not be compatible with the callback
    function type required by the `qsort()` specification. Here is the signature of
    `qsort()` from the BSD `man` page that also contains the type of accepted callback
    type (the `compar` argument):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 普通的Python函数类型将不兼容`qsort()`规范所需的回调函数类型。以下是来自BSD `man`页面的`qsort()`签名，其中还包含了接受的回调类型（`compar`参数）的类型：
- en: '[PRE36]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So in order to execute `qsort()` from `libc`, you need to pass:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了执行`libc`中的`qsort()`，您需要传递：
- en: '`base`: This is the array that needs to be sorted as a `void*` pointer.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base`：这是需要作为`void*`指针排序的数组。'
- en: '`nel`: This is the number of elements as `size_t`.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nel`：这是`size_t`类型的元素数量。'
- en: '`width`: This is the size of the single element in the array as `size_t`.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`：这是`size_t`类型的数组中单个元素的大小。'
- en: '`compar`: This is the pointer to the function that is supposed to return `int`
    and accepts two `void*` pointers. It points to the function that compares the
    size of two elements being sorted.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compar`：这是指向应该返回`int`并接受两个`void*`指针的函数的指针。它指向比较正在排序的两个元素大小的函数。'
- en: We already know from the *Calling C functions using ctypes* section how to construct
    the C array from other `ctypes` types using the multiplication operator. `nel`
    should be `size_t`, and it maps to Python `int`, so it does not require any additional
    wrapping and can be passed as `len(iterable)`. The `width` value can be obtained
    using the `ctypes.sizeof()` function once we know the type of our `base` array.
    The last thing we need to know is how to create the pointer to the Python function
    compatible with the `compar` argument.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从*使用ctypes调用C函数*部分知道了如何使用乘法运算符从其他`ctypes`类型构造C数组。`nel`应该是`size_t`，它映射到Python
    `int`，因此不需要任何额外的包装，可以作为`len(iterable)`传递。一旦我们知道了`base`数组的类型，就可以使用`ctypes.sizeof()`函数获取`width`值。我们需要知道的最后一件事是如何创建与`compar`参数兼容的Python函数指针。
- en: 'The `ctypes` module contains a `CFUNTYPE()` factory function that allows us
    to wrap Python functions and represents them as C callable function pointers.
    The first argument is the C return type that the wrapped function should return.
    It is followed by the variable list of C types that the function accepts as its
    arguments. The function type compatible with the `compar` argument of `qsort()`
    will be:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctypes`模块包含一个`CFUNTYPE()`工厂函数，允许我们将Python函数包装并表示为C可调用函数指针。第一个参数是包装函数应该返回的C返回类型。它后面是作为其参数接受的C类型的可变列表。与`qsort()`的`compar`参数兼容的函数类型将是：'
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`CFUNTYPE()` uses the `cdecl` calling convention, so it is compatible only
    with the `CDLL` and `PyDLL` shared libraries. The dynamic libraries on Windows
    that are loaded with `WinDLL` or `OleDLL` use the `stdcall` calling convention.
    This means that the other factory must be used to wrap Python functions as C callable
    function pointers. In `ctypes`, it is `WINFUNCTYPE()`.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`CFUNTYPE()`使用`cdecl`调用约定，因此只与`CDLL`和`PyDLL`共享库兼容。在Windows上使用`WinDLL`或`OleDLL`加载的动态库使用`stdcall`调用约定。这意味着必须使用其他工厂将Python函数包装为C可调用函数指针。在`ctypes`中，它是`WINFUNCTYPE()`。'
- en: 'To wrap everything up, let''s assume that we want to sort a randomly shuffled
    list of integer numbers with a `qsort()` function from the standard C library.
    Here is the example script that shows how to do that using everything that we
    have learned about `ctypes` so far:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一切，假设我们想要使用标准C库中的`qsort()`函数对随机洗牌的整数列表进行排序。以下是一个示例脚本，展示了如何使用到目前为止我们学到的关于`ctypes`的一切来实现这一点：
- en: '[PRE38]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The comparison function provided as a callback has an additional `print` statement,
    so we can see how it is executed during the sorting process:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回调提供的比较函数有一个额外的`print`语句，因此我们可以看到它在排序过程中是如何执行的：
- en: '[PRE39]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: CFFI
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CFFI
- en: CFFI is a Foreign Function Interface for Python that is an interesting alternative
    to `ctypes`. It is not a part of the standard library but is easily available
    as a `cffi` package on PyPI. It is different from `ctypes` because it puts more
    emphasis on reusing plain C declarations instead of providing extensive Python
    APIs in a single module. It is way more complex and also has a feature that also
    allows you to automatically compile some parts of your integration layer into
    extensions using C compiler. So it can be used as a hybrid solution that fills
    the gap between C extensions and `ctypes`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: CFFI是Python的外部函数接口，是`ctypes`的一个有趣的替代方案。它不是标准库的一部分，但在PyPI上很容易获得作为`cffi`软件包。它与`ctypes`不同，因为它更注重重用纯C声明，而不是在单个模块中提供广泛的Python
    API。它更加复杂，还具有一个功能，允许您自动将集成层的某些部分编译成扩展，使用C编译器。因此，它可以用作填补C扩展和`ctypes`之间差距的混合解决方案。
- en: 'Because it is a very large project, it is impossible to shortly introduce it
    in a few paragraphs. On the other hand, it would be a shame to not say something
    more about it. We have already discussed one example of integrating the `qsort()`
    function from the standard library using `ctypes`. So, the best way to show the
    main differences between these two solutions will be to re-implement the same
    example with `cffi`. I hope that one block of code is worth more than a few paragraphs
    of text:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个非常庞大的项目，不可能在几段话中简要介绍它。另一方面，不多说一些关于它的东西会很遗憾。我们已经讨论了使用`ctypes`集成标准库中的`qsort()`函数的一个例子。因此，展示这两种解决方案之间的主要区别的最佳方式将是使用`cffi`重新实现相同的例子。我希望一段代码能比几段文字更有价值：
- en: '[PRE40]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter explained one of the most advanced topics in the book. We discussed
    the reasons and tools for building Python extensions. We started from writing
    pure C extensions that depend only on Python/C API and then re-implemented them
    with Cython to show how easy it can be if you only choose the proper tool.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了本书中最高级的主题之一。我们讨论了构建Python扩展的原因和工具。我们从编写纯C扩展开始，这些扩展仅依赖于Python/C API，然后用Cython重新实现它们，以展示如果你选择合适的工具，它可以是多么容易。
- en: There are still some reasons for doing things *the hard way* and using nothing
    more than the pure C compiler and the `Python.h` headers. Anyway, the best recommendation
    is to use tools such as Cython or Pyrex (not featured here) because it will make
    your codebase more readable and maintainable. It will also save you from most
    of the issues caused by incautious reference counting and memory management.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一些理由可以*以困难的方式*做事，并且仅使用纯C编译器和`Python.h`头文件。无论如何，最好的建议是使用诸如Cython或Pyrex（这里没有介绍）这样的工具，因为它将使您的代码库更易读和可维护。它还将使您免受由粗心的引用计数和内存管理引起的大部分问题的困扰。
- en: Our discussion of extensions ended with the presentation of `ctypes` and CFFI
    as an alternative way to solve the problems of integrating shared libraries. Because
    they do not require writing custom extensions to call functions from compiled
    binaries, they should be your tools of choice for doing that—especially if you
    don't need to use custom C code.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对扩展的讨论以`ctypes`和CFFI作为集成共享库的替代方法的介绍结束。因为它们不需要编写自定义扩展来调用编译后的二进制文件中的函数，所以它们应该是你在这方面的首选工具，特别是如果你不需要使用自定义的C代码。
- en: In next chapter, we will take a short rest from low-level programming techniques
    and delve into topics that are no less important—code management and version control
    systems.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从低级编程技术中短暂休息，并深入探讨同样重要的主题——代码管理和版本控制系统。
