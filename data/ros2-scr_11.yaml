- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Launch Files – Starting All Your Nodes at Once
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动文件 – 同时启动所有节点
- en: At this point, you know how to write nodes, how to make them communicate with
    topics, services, and actions, and how to make them more dynamic with parameters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你知道如何编写节点，如何使它们通过主题、服务和动作进行通信，以及如何通过参数使它们更加动态。
- en: In this last chapter of *Part 2*, we will bring everything together and go one
    step further toward making your application more scalable. Here, we will talk
    about launch files, which allow you to start all your nodes and parameters at
    once.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节 *第2部分* 的最后一章中，我们将把所有内容整合起来，并进一步使你的应用程序更具可扩展性。在这里，我们将讨论启动文件，它允许你一次性启动所有节点和参数。
- en: To start with launch files, it’s important that you’re comfortable with the
    concepts seen in the previous chapters. As a starting point, we will use the code
    inside the **ch8** folder from the book’s GitHub repository ([https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch)).
    You can find the final code for launch files in the **ch9** folder.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用启动文件，重要的是你对前几章中看到的概念感到舒适。作为一个起点，我们将使用书中 GitHub 仓库（[https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch)）中的
    **ch8** 文件夹内的代码。你可以在 **ch9** 文件夹中找到启动文件的最终代码。
- en: First, as always, I will use a real-life example to explain why you need launch
    files and what they are exactly. You will then dive into the code and create your
    own launch file with XML and Python (we will discuss which language is more appropriate).
    You will also experiment with extra configurations to fully customize your nodes
    inside launch files, and you will practice more with a final challenge.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，像往常一样，我将使用一个真实世界的例子来解释为什么你需要启动文件以及它们究竟是什么。然后，你将深入代码，使用 XML 和 Python 创建你自己的启动文件（我们将讨论哪种语言更合适）。你还将通过额外的配置来完全自定义启动文件内的节点，并通过最后的挑战进行更多的练习。
- en: By the end of this chapter, you will be able to properly scale your ROS 2 applications
    and know how to use or modify existing launch files. Almost every ROS 2 application
    or stack contains one or several launch files. Being comfortable with them is
    key to becoming a great ROS developer.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够正确地扩展你的 ROS 2 应用程序，并知道如何使用或修改现有的启动文件。几乎每个 ROS 2 应用程序或堆栈都包含一个或多个启动文件。对这些文件感到舒适是成为一名优秀的
    ROS 开发者的关键。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is a ROS 2 launch file?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS 2 启动文件是什么？
- en: Creating and installing an XML launch file
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和安装 XML 启动文件
- en: Creating a Python launch file – XML or Python for launch files?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 Python 启动文件 – 启动文件使用 XML 还是 Python？
- en: Configuring nodes inside a launch file
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启动文件中配置节点
- en: Launch file challenge
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动文件挑战
- en: What is a ROS 2 launch file?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROS 2 启动文件是什么？
- en: After everything you’ve learned already, understanding the concept of launch
    files will not be very difficult.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在你已经学到的所有内容的基础上，理解启动文件的概念不会非常困难。
- en: You have experimented a bit with launch files in [*Chapter 3*](B22403_03.xhtml#_idTextAnchor092).
    We will now, as usual, start from scratch and see what a launch file is with an
    example. First, we’ll look at why we need launch files.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在 [*第3章*](B22403_03.xhtml#_idTextAnchor092) 中对启动文件进行了一些实验。现在，我们将像往常一样从头开始，通过一个示例来了解启动文件是什么。首先，我们将探讨为什么我们需要启动文件。
- en: Why launch files?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么需要启动文件？
- en: As your ROS 2 application starts to grow, so does the number of nodes and parameters.
    For example, a ROS stack I developed for a robotic arm had more than 15 nodes
    and 200 parameters. Imagine opening 15 terminals and starting all the nodes one
    by one with all the correct values for parameters. This would quickly become a
    nightmare.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的 ROS 2 应用程序开始增长，节点和参数的数量也在增加。例如，我为一个机械臂开发的 ROS 栈有超过 15 个节点和 200 个参数。想象一下打开
    15 个终端，并逐个启动所有节点，同时为每个参数设置正确的值。这很快就会变成一场噩梦。
- en: 'For this explanation, let’s assume we have the following nodes in our application:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释这一点，让我们假设在我们的应用程序中有以下节点：
- en: Three camera nodes with different settings
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有不同设置的三个相机节点
- en: Two LED panel nodes with varying numbers of LEDs
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有不同数量 LED 的两个 LED 面板节点
- en: One battery node
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个电池节点
- en: Another node with more parameters
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个具有更多参数的节点
- en: 'Here is what your application would look like:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你的应用程序看起来会是什么样子：
- en: '![Figure 9.1 – ROS 2 application with seven nodes and sixteen parameters](img/B22403_09_1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 具有七个节点和十六个参数的 ROS 2 应用](img/B22403_09_1.jpg)'
- en: Figure 9.1 – ROS 2 application with seven nodes and sixteen parameters
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 具有七个节点和十六个参数的 ROS 2 应用
- en: To start all those nodes, you will need to open seven terminals and start the
    nodes one by one. For each node, you will also need to provide all the required
    parameters’ values (with what you’ve seen in the previous chapter, you can use
    YAML param files to make this easier). Not only is this not scalable, but it will
    make your development process much slower and frustrating. With so many terminals,
    it’s easy to make mistakes or to forget which terminal is doing what.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动所有这些节点，您需要打开七个终端并逐个启动节点。对于每个节点，您还需要提供所有必需参数的值（根据您在上一章中看到的，您可以使用YAML参数文件来简化这个过程）。这不仅不可扩展，而且会使您的开发过程变得缓慢且令人沮丧。有这么多终端，很容易出错或忘记哪个终端在做什么。
- en: A solution you could think of is to create a script (a **bash** script, for
    example) to start all **ros2 run** commands from one file. That way, you could
    run your application from just one terminal. This would reduce development time
    and allow your application to scale.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以考虑的一个解决方案是创建一个脚本（例如bash脚本）来从一个文件中启动所有**ros2 run**命令。这样，您就可以从一个终端运行您的应用程序。这将减少开发时间，并允许您的应用程序扩展。
- en: Well, this is exactly what launch files are made for. There’s no need to write
    your own script; all you need to do is create a launch file and follow a few syntax
    rules. Launch files can be installed within your ROS 2 application. Let’s look
    at an example in the next section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这正是启动文件的作用所在。您不需要编写自己的脚本；您需要做的只是创建一个启动文件并遵循一些语法规则。启动文件可以安装到您的ROS 2应用程序中。让我们在下一节中看看一个例子。
- en: Example of a launch file with seven nodes
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 七节点启动文件的示例
- en: 'If we continue with our example, here is how your nodes would be organized:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续我们的例子，以下是您的节点组织方式：
- en: '![Figure 9.2 – Launch file with all nodes and parameters](img/B22403_09_2.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 包含所有节点和参数的启动文件](img/B22403_09_2.jpg)'
- en: Figure 9.2 – Launch file with all nodes and parameters
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 包含所有节点和参数的启动文件
- en: Inside one file, you start all the nodes and provide the values you want for
    each parameter. This file can be written with XML, YAML, or Python—we will see
    how to do that in a moment. Then, once the launch file is written, you will install
    it (**colcon build**) and run it with the **ros2 launch** command-line tool.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个文件中，您启动所有节点并为每个参数提供您想要的值。这个文件可以用XML、YAML或Python编写——我们稍后会看到如何做到这一点。然后，一旦编写了启动文件，您将使用**colcon
    build**安装它，并使用**ros2 launch**命令行工具运行它。
- en: It’s not uncommon to have a few dozen nodes and a few hundred parameters inside
    one application. Without launch files, it would be impossible to quickly start
    the application, and you would spend most of your time debugging trivial things.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个应用程序中拥有几十个节点和几百个参数并不罕见。没有启动文件，您将无法快速启动应用程序，您将花费大部分时间调试琐碎的事情。
- en: Launch files allow you to customize and scale your application easily. There
    is not much more to say; the concept is fairly straightforward. Most of the work
    is about learning how to implement one and knowing the features to customize your
    nodes to make them more dynamic. This is what we will dive into right now.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 启动文件允许您轻松地自定义和扩展您的应用程序。没有太多可说的；这个概念相当直接。大部分工作都是关于学习如何实现一个，以及了解如何自定义节点以使它们更加动态的功能。这正是我们现在要深入探讨的。
- en: Creating and installing an XML launch file
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和安装XML启动文件
- en: You will now create your first launch file. We will start with XML. Later in
    this chapter, we will also write Python launch files and compare the two languages,
    but let’s keep things simple to get started.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将创建您的第一个启动文件。我们将从XML开始。在本章的后面部分，我们还将编写Python启动文件，并比较这两种语言，但为了便于入门，让我们保持简单。
- en: To properly create, install, and start a launch file, you need to do a bit of
    setup. In this section, we will follow all the necessary setup steps with a minimal
    launch file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确创建、安装和启动一个启动文件，您需要进行一些设置。在本节中，我们将使用一个最小启动文件遵循所有必要的设置步骤。
- en: What we want to do here is to start the number application (**number_publisher**
    and **number_counter** nodes) from one terminal, with just one command line. Let’s
    get started.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里想做的事情是从一个终端启动数字应用程序（**number_publisher**和**number_counter**节点），只使用一条命令行。让我们开始吧。
- en: Setting up a package for launch files
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为启动文件设置包
- en: Where should you put your launch files? You could theoretically create a launch
    file in any existing package.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该把启动文件放在哪里？从理论上讲，您可以在任何现有包中创建启动文件。
- en: However, this method can quickly lead to a dependency mess between packages.
    If package A requires package B, and you create a launch file in package B to
    start nodes from both packages, then you have created what’s called a *dependency
    loop*. Package A depends on package B, and package B depends on package A. This
    is a very bad way to start a ROS application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法可能会迅速导致包之间的依赖混乱。如果包A需要包B，而你又在包B中创建了一个启动文件来启动这两个包的节点，那么你就创建了一个所谓的*依赖循环*。包A依赖于包B，而包B又依赖于包A。这是启动ROS应用程序的一个非常糟糕的方式。
- en: As a best practice, we will create a package dedicated to launch files. We will
    not modify any existing package; instead, we will create a completely independent
    one.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，我们将创建一个专门用于启动文件的包。我们不会修改任何现有的包；相反，我们将创建一个完全独立的包。
- en: First, let’s choose a name for this package. We will follow a common naming
    convention. We start with the name of the robot or application, followed by the
    **_bringup** suffix. As we don’t have a robot here, we will call this package
    **my_robot_bringup**. If your robot were named *abc*, you would create an **abc_bringup**
    package.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为这个包选择一个名字。我们将遵循一个常见的命名约定。我们以机器人或应用程序的名字开头，后面跟着**_bringup**后缀。由于我们这里没有机器人，我们将把这个包命名为**my_robot_bringup**。如果你的机器人名字是*abc*，你会创建一个**abc_bringup**包。
- en: 'Navigate to the **src** directory in your ROS 2 workspace and create this package.
    It will not contain any Python or C++ nodes. For the build type, you can choose
    **ament_cmake** (you could even omit the build type, as **ament_cmake** is the
    default anyway):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到你的ROS 2工作空间中的**src**目录并创建这个包。它将不包含任何Python或C++节点。对于构建类型，你可以选择**ament_cmake**（你也可以省略构建类型，因为**ament_cmake**已经是默认的）：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Alternatively, you could just run **$ ros2 pkg** **create my_robot_bringup**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以直接运行**$ ros2 pkg** **create my_robot_bringup**。
- en: 'Once the package is created, we can remove directories that we don’t need:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了包，我们可以删除我们不需要的目录：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we create a **launch** directory. This is where we will put all our launch
    files for this application:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个**launch**目录。这是我们将会放置所有这个应用程序的启动文件的地方：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Before we create a launch file, let’s finish the package configuration. Open
    the **CMakeLists.txt** file and add these lines:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建启动文件之前，让我们完成包配置。打开**CMakeLists.txt**文件并添加以下行：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will install the **launch** directory when you build your package with
    **colcon build**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用**colcon build**构建你的包时，这将会安装**launch**目录。
- en: Now, the package is correctly configured. You only need to do those steps once
    for each ROS 2 application. Then, to add a launch file, you just have to create
    a new file inside the **launch** folder. Let’s do that.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，包已经正确配置。你只需要为每个ROS 2应用程序执行这些步骤一次。然后，要添加启动文件，你只需在**launch**文件夹内创建一个新文件。让我们这么做。
- en: Writing an XML launch file
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写XML启动文件
- en: 'Navigate to the **launch** folder you created inside the **my_robot_bringup**
    package. To create a launch file, you will first choose a name and then use the
    **.launch.xml** extension. Since we have named our application the *number app*,
    let’s create a new file named **number_app.launch.xml**:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到你在**my_robot_bringup**包内创建的**launch**文件夹。要创建一个启动文件，你首先选择一个名字，然后使用**.launch.xml**扩展名。由于我们给我们的应用程序命名为*number
    app*，让我们创建一个名为**number_app.launch.xml**的新文件：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Open the file, and let’s start to write the content for the launch file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件，让我们开始为启动文件编写内容。
- en: 'First, you will need to open and close a **<launch>** tag. Everything you write
    will be between those two lines. This is the minimum code for an XML launch file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要打开和关闭一个**<launch>**标签。你写的所有内容都将在这两条线之间。这是XML启动文件的最小代码：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then, we want to start the **number_publisher** and **number_counter** nodes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们想要启动**number_publisher**和**number_counter**节点。
- en: 'As a quick reminder, in the terminal, you would run this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快速提醒，在终端中，你会运行这个：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, I started one node from the Python package and the other one from the
    C++ package. The two arguments we need to provide for **ros2 run** are the package
    name and executable name. This is the same inside a launch file. To add a node,
    use a **<node>** tag with the **pkg** and **exec** arguments:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我从Python包和一个C++包中分别启动了一个节点。我们需要为**ros2 run**提供的两个参数是包名和可执行文件名。在启动文件中也是同样的。要添加一个节点，使用带有**pkg**和**exec**参数的**<node>**标签：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this, we start the same two nodes from the launch file. As you can see,
    there’s nothing very complicated. Later on in this chapter, we will see how to
    configure the application with remappings, parameters, namespaces, and so on.
    For now, let’s focus on running this minimal launch file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们从启动文件中启动了相同的两个节点。正如你所看到的，这并没有什么特别复杂的。在本章的后面部分，我们将看到如何通过重映射、参数、命名空间等来配置应用程序。现在，让我们专注于运行这个最小化的启动文件。
- en: Installing and starting a launch file
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和启动启动文件
- en: You now have to install your new launch file before you can start using it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用之前，你必须安装你的新启动文件。
- en: 'As we are starting nodes from the **my_py_pkg** and **my_cpp_pkg** packages,
    we need to add the dependencies in the **package.xml** file of the **my_robot_bringup**
    package:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是从**my_py_pkg**和**my_cpp_pkg**包中启动节点，我们需要在**my_robot_bringup**包的**package.xml**文件中添加依赖项：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Previously, we only used a `<depend>` tag when specifying dependencies. In this
    case, there is nothing to build; we only need the dependency when executing the
    launch file. Thus, we use a weaker tag, `<exec_depend>`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们只在指定依赖项时使用过`<depend>`标签。在这种情况下，没有需要构建的内容；我们只需要在执行启动文件时需要依赖项。因此，我们使用一个较弱的标签，`<exec_depend>`。
- en: For each new package you use in your launch files, you will add a new **<exec_depend>**
    tag in the **package.xml** file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你在启动文件中使用的每个新包，你需要在**package.xml**文件中添加一个新的**<exec_depend>**标签。
- en: 'Now, we can install the launch file. To do so, you just need to build your
    package:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以安装启动文件。要这样做，你只需要构建你的包：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, source your environment, and use the **ros2 launch** command-line tool
    to start the launch file. The full command is **ros2 launch <****package_name>
    <launch_file_name>**:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，源你的环境，并使用**ros2 launch**命令行工具来启动启动文件。完整的命令是**ros2 launch <package_name> <launch_file_name>**：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You will see the following logs:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下日志：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'What’s happening here? Let’s take a closer look:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？让我们仔细看看：
- en: A log file is created and the logging verbosity is set.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个日志文件，并设置了日志详细程度。
- en: Each executable that you provided in the launch file is started as a new process.
    You can see the process name (for example, `number_publisher-1`) and the process
    ID (denoted as `pid`).
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动文件中提供的每个可执行文件都将作为一个新的进程启动。你可以看到进程名称（例如，`number_publisher-1`）和进程ID（表示为`pid`）。
- en: Then, as all nodes are started in the same terminal, you will see all logs from
    all nodes.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，由于所有节点都在同一个终端中启动，你会看到所有节点的所有日志。
- en: This example is quite simple, as we just start two executables with no additional
    configuration. Launch files will become quite handy when the number of nodes and
    settings gets bigger. Also, the **ros2 launch** command-line tool is very easy
    to use. There is not really much more than what we’ve seen here.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子相当简单，因为我们只是启动了两个没有额外配置的可执行文件。当节点数量和设置增多时，启动文件将变得非常有用。此外，**ros2 launch**命令行工具非常容易使用。实际上，这里没有比我们看到的更多的内容。
- en: Now that you have completed the process to create, install, and start a launch
    file, let’s talk about Python launch files.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了创建、安装和启动启动文件的过程，让我们来谈谈Python启动文件。
- en: Creating a Python launch file – XML or Python for launch files?
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Python启动文件 – XML还是Python用于启动文件？
- en: 'There are actually three languages you can use to create launch files in ROS
    2: Python, XML, and YAML. I will not cover YAML launch files as they are not seldom
    used, and YAML doesn’t have any competitive advantage over XML for launch files.
    Here, we will be focusing on Python and XML.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以使用三种语言在ROS 2中创建启动文件：Python、XML和YAML。我不会介绍YAML启动文件，因为它们很少使用，而且YAML在启动文件方面没有比XML更强的优势。在这里，我们将重点关注Python和XML。
- en: We will start this section by creating a Python launch file (the same application
    as before). Then, I will compare XML and Python launch files and give you some
    guidance on how to get the best out of them both.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个部分开始，创建一个Python启动文件（与之前相同的应用程序）。然后，我会比较XML和Python启动文件，并给你一些关于如何充分利用两者的指导。
- en: Writing a Python launch file
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Python启动文件
- en: As we already have a fully configured **my_robot_bringup** package for our application,
    there’s no need to do anything else. All we have to do is create a new file inside
    the **launch** directory.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了一个完全配置好的**my_robot_bringup**包用于我们的应用程序，因此不需要做任何事情。我们只需要在**launch**目录内创建一个新文件。
- en: 'For Python launch files, you will use the **.launch.py** extension. Create
    a new file named **number_app.launch.py**. Here is the code required to start
    the **number_publisher** and **number_counter** nodes:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python 启动文件，你将使用 **.launch.py** 扩展名。创建一个名为 **number_app.launch.py** 的新文件。以下是启动
    **number_publisher** 和 **number_counter** 节点的代码：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first thing you will notice is that the code is much, much longer than
    the XML one. I will come back to this in a minute when I compare Python and XML.
    For now, let’s focus on the required steps to write a Python launch file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会注意到，代码比 XML 长得多。当我比较 Python 和 XML 时，我会在一会儿回来讨论这个问题。现在，让我们专注于编写 Python 启动文件所需的步骤：
- en: The launch file must include a `generate_launch_description()` function. Make
    sure you don’t make any typos.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动文件必须包含一个 `generate_launch_description()` 函数。确保你没有打错字。
- en: In this function, you will need to create and return a `LaunchDescription` object.
    You can get this from the `launch` module.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数中，你需要创建并返回一个 `LaunchDescription` 对象。你可以从 `launch` 模块中获取它。
- en: To add a node in the launch file, you create a `Node` object (from `launch_ros.actions`)
    and specify the package and executable name. Then, you can add this object to
    the `LaunchDescription` object.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在启动文件中添加一个节点，你创建一个 `Node` 对象（来自 `launch_ros.actions`），并指定包和可执行文件名。然后，你可以将此对象添加到
    `LaunchDescription` 对象中。
- en: That’s it for now, but there are more options that we will explore a bit later
    in this chapter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，但还有更多选项，我们将在本章稍后探讨。
- en: Once you have written the launch file, make sure to add all required dependencies
    in the **package.xml** file of the **my_robot_bringup** package. As we already
    did that with the XML launch file (and we have the same dependencies here), we
    can skip this step.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你编写了启动文件，请确保在 **my_robot_bringup** 包的 **package.xml** 文件中添加所有必需的依赖项。因为我们已经用
    XML 启动文件做了这件事（并且我们有相同的依赖项），所以我们可以跳过这一步。
- en: 'Finally, to install this launch file, build the **my_robot_bringup** package
    again. Since we already wrote the necessary instructions in the **CMakeLists.txt**
    file, the launch file will be installed. All you need to do after that is to source
    your environment and start the launch file with **ros2 launch**:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了安装这个启动文件，重新构建 **my_robot_bringup** 包。由于我们已经在 **CMakeLists.txt** 文件中编写了必要的指令，启动文件将被安装。之后你需要做的就是设置你的环境，并使用
    **ros2 launch** 命令启动启动文件：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To create, install, and start a Python launch file, the process is the same
    as for an XML launch file. Only the code is different. Let’s now compare the two
    languages regarding their use in launch files.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建、安装并启动一个 Python 启动文件，其过程与 XML 启动文件相同。只是代码不同。现在让我们比较这两种语言在启动文件中的应用。
- en: XML versus Python for launch files
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动文件中的 XML 与 Python
- en: I have a strong bias toward simplicity, so, from seeing the previous code examples,
    you can already guess where I’m going to stand.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常倾向于简洁，所以，从看到之前的代码示例，你就可以猜到我的立场了。
- en: To answer the XML versus Python question, let’s first go back in time.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答 XML 与 Python 的选择问题，我们首先回顾一下过去。
- en: The issue with Python launch files
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 启动文件的问题
- en: In ROS 1, the first version of ROS, XML was the only language used for launch
    files. Python was actually also available, but due to non-existent documentation,
    nobody knew about it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ROS 1 的第一个版本中，XML 是启动文件使用的唯一语言。Python 实际上也是可用的，但由于没有文档，没有人知道它。
- en: At the beginning of ROS 2, the development team put a stronger emphasis on Python
    launch files and started to write the documentation only for Python, thus making
    it the default language for launch files. XML (and YAML) launch files were also
    supported, but again, due to non-existent documentation, nobody was using them.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ROS 2 的早期，开发团队对 Python 启动文件给予了更多的重视，并开始只为 Python 编写文档，因此使其成为启动文件的默认语言。XML（和
    YAML）启动文件也得到支持，但由于没有文档，没有人使用它们。
- en: I was initially enthusiastic about the idea of writing Python launch files,
    as this meant you could take advantage of the Python logic and syntax to make
    launch files much more dynamic and easier to write. That’s the theory, but in
    practice, I realized I didn’t see any programming logic in most of the launch
    files I found, and it was just another—more complex and difficult—way to write
    a description, which is basically why XML exists in the first place.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我最初对编写 Python 启动文件的想法很热情，因为这意味着你可以利用 Python 的逻辑和语法使启动文件更加动态和易于编写。这是理论，但在实践中，我发现我在大多数找到的启动文件中都没有看到任何编程逻辑，它只是另一种——更复杂和困难——编写描述的方法，而这正是
    XML 存在的根本原因。
- en: You can already see the added complexity in the two previous examples. To start
    two nodes, it takes four lines in XML and twenty lines in Python (I could optimize
    the code and make it less than fifteen lines, but that’s still a lot more). For
    the same number of nodes, you can expect Python launch files to be two to five
    times longer than the XML version.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经可以看到在前两个例子中增加的复杂性。要启动两个节点，XML 需要 4 行，Python 需要 20 行（我可以优化代码并使其少于 15 行，但这仍然很多）。对于相同数量的节点，你可以预期
    Python 启动文件比 XML 版本长两到五倍。
- en: Also, with more functionalities (parameters, arguments from the terminal, conditions,
    paths, and so on), you will have to use an increasing amount of Python imports
    that are hard to find and use. You will realize this as we see more examples of
    XML and Python launch files all along this book.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着更多功能（参数、终端参数、条件、路径等）的增加，你将不得不使用越来越多的 Python 导入，这些导入难以找到和使用。当你看到这本书中更多的
    XML 和 Python 启动文件示例时，你会意识到这一点。
- en: Fortunately, XML is coming back, as the official documentation is starting to
    include it as well as Python. More and more developers have started to use XML
    launch files again, which is a good thing because more online tutorials and open
    source code will include them.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，XML 正在回归，因为官方文档开始包括它以及 Python。越来越多的开发者又开始使用 XML 启动文件，这是一个好事，因为更多的在线教程和开源代码将包括它们。
- en: How to combine XML and Python launch files in your application
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何在你的应用程序中结合 XML 和 Python 启动文件
- en: XML launch files are much simpler and smaller to write than Python launch files.
    However, for some advanced use cases, Python will be the only choice, as it contains
    some functionalities that are not available for XML. This could be a problem because
    if you need just one Python functionality, it would mean that you’d need to write
    the entire launch file in Python.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: XML 启动文件比 Python 启动文件简单得多，也小得多。然而，对于某些高级用例，Python 将是唯一的选择，因为它包含一些 XML 中不可用的功能。这可能会成为一个问题，因为如果你只需要一个
    Python 功能，这意味着你需要用 Python 编写整个启动文件。
- en: Fortunately, there is a very easy way to solve that. As we will see in a minute,
    you can include any kind of launch file into any other launch file, be it Python,
    XML, or YAML.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个非常简单的方法可以解决这个问题。正如我们将在下一分钟看到的，你可以将任何类型的启动文件包含到任何其他启动文件中，无论是 Python、XML
    还是 YAML。
- en: So, if you absolutely need to use Python for a specific launch functionality,
    then go ahead and create a Python launch file for that. You can then include this
    launch file in your *main* XML launch file. You can also include any other existing
    Python launch file (from an already installed package) that contains the functionality
    you need. By doing this, you keep your code minimal and simple.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你绝对需要为特定的启动功能使用 Python，那么就创建一个 Python 启动文件。然后，你可以将此启动文件包含在你的 *主* XML 启动文件中。你也可以包含任何其他现有的
    Python 启动文件（来自已安装的包），它包含你需要的功能。通过这样做，你可以保持你的代码最小化和简单。
- en: Now, what to do when you need to create a Python launch file for a specific
    use case? The syntax is really complicated, and there are too many imports for
    any functionality. It can quickly become a challenge.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你需要为特定用例创建一个 Python 启动文件时，该怎么办？语法非常复杂，任何功能都有太多的导入。这很快就会成为一个挑战。
- en: What I myself do when I have to create a Python launch file is to try to find
    an existing launch file on GitHub that does what I want and tweak the code so
    that it works with my application. I gave up on trying to learn or even memorize
    the Python launch file syntax. I am not usually a fan of the “copy/paste from
    the internet” method, but I make an exception for Python launch files.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我需要创建一个 Python 启动文件时，我会尝试在 GitHub 上找到一个现有的启动文件，它做我想做的事情，并调整代码使其与我的应用程序兼容。我已经放弃尝试学习或甚至记住
    Python 启动文件的语法。我通常不是“从互联网复制粘贴”方法的粉丝，但我会为 Python 启动文件破例。
- en: In the end, it’s a matter of choice for you. A correctly written XML, YAML,
    or Python launch file will do the exact same thing. As for YAML, it’s just another
    markup language, and I find XML easier to use for launch files. My recommendation
    is to use XML whenever possible. Use Python only if you have to and only for the
    functionalities that require Python. Then, include the Python launch file inside
    your XML one.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这完全取决于你的选择。一个正确编写的 XML、YAML 或 Python 启动文件将完成完全相同的事情。至于 YAML，它只是另一种标记语言，我发现
    XML 对于启动文件来说更容易使用。我的建议是在可能的情况下使用 XML。只有在必须使用 Python 并且仅用于需要 Python 的功能时才使用 Python。然后，将
    Python 启动文件包含在你的 XML 启动文件中。
- en: Following this process will make your life easier when developing ROS 2 applications.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 按照此过程操作将使您在开发ROS 2应用程序时更加轻松。
- en: Including a launch file inside another launch file
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在另一个启动文件中包含启动文件
- en: Since I talked about including a Python launch file inside an XML launch file,
    let’s see how to do that. The syntax won’t be that complicated.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我提到了在XML启动文件中包含Python启动文件，让我们看看如何做到这一点。语法不会太复杂。
- en: 'Make sure you add everything inside **<launch></launch>** tags. To include
    another launch file, use an **<include>** tag. Here is an example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将**<launch></launch>**标签内的所有内容都添加进去。要包含另一个启动文件，请使用**<include>**标签。以下是一个示例：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This line, with **find-pkg-share**, will find the path to the **number_app.launch.py**
    launch file inside the **my_robot_bringup** package. Then, the content of the
    launch file will be included. Even if you include a Python launch file inside
    an XML one, this will work.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行，使用**find-pkg-share**，将找到位于**my_robot_bringup**包内的**number_app.launch.py**启动文件的路径。然后，将包含启动文件的内容。即使您在XML文件中包含Python启动文件，这也会起作用。
- en: You can reuse this line in any other XML launch file; just replace the package
    name and launch filename.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此行用于任何其他XML启动文件；只需替换包名和启动文件名即可。
- en: 'Now, if you wanted to do the opposite (which means including an XML launch
    file inside a Python launch file), here is what you would need to write:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您想执行相反的操作（这意味着在Python启动文件中包含XML启动文件），以下是您需要编写的代码：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code example illustrates what I was saying about the extra complexity brought
    by Python launch files. This complexity is not justified here, as it adds nothing
    compared to the XML file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码示例说明了关于Python启动文件带来的额外复杂性的说法。这种复杂性在这里是不必要的，因为它与XML文件相比没有增加任何东西。
- en: With those two code examples, you can now combine any XML and Python launch
    files.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个代码示例，你现在可以结合任何XML和Python启动文件。
- en: Now that you have seen the process of creating a launch file in both XML and
    Python, let’s go a bit further and add some extra configuration for the nodes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了在XML和Python中创建启动文件的过程，让我们更进一步，为节点添加一些额外的配置。
- en: Configuring nodes inside a launch file
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在启动文件中配置节点
- en: So far, we have just started two nodes, with zero extra configuration. When
    you start a node with **ros2 run**, as we have seen in the previous chapters in
    *Part 2*, you can rename it, rename topics/services/actions, add parameters, and
    so on.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只启动了两个节点，没有额外的配置。当您使用**ros2 run**启动节点时，如我们在*第2部分*的上一章中看到的，您可以重命名它，重命名主题/服务/动作，添加参数等。
- en: In this section, you will learn how to do that inside a launch file. We will
    also introduce the concept of namespaces. All code examples will be in XML and
    Python.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何在启动文件中执行此操作。我们还将介绍命名空间的概念。所有代码示例都将使用XML和Python。
- en: Renaming nodes and communications
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重命名节点和通信
- en: 'In an XML launch file, to rename a node, simply add a **name** argument in
    a **<****node>** tag:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML启动文件中，要重命名一个节点，只需在**<node>**标签中添加一个**name**参数：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Changing the name for a topic/service/action is actually named *remapping*.
    To remap a communication, you have to use a **<remap>** tag, inside the **<****node>**
    tag:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 更改主题/服务/动作的名称实际上被称为*重映射*。要重映射通信，您必须在**<node>**标签内使用**<remap>**标签：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can add as many **<remap>** tags as you want, each one in a new line.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加任意多的**<remap>**标签，每个标签占一行。
- en: Note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This is a quick XML reminder, but it can be useful if you’re not used to XML
    and can prevent lots of errors in the future. For one-line tags, you open the
    tag and end it with `/>` (for example, `<node />`). If you need to add a tag inside
    a tag, you then have to open the tag and close it later, like we did for `<launch>...</launch>`
    or `<node>...</node>`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速的XML提醒，但如果你不熟悉XML，它可能很有用，可以防止未来出现很多错误。对于单行标签，您打开标签并以`/>`结束（例如，`<node />`）。如果您需要在标签内添加标签，那么您必须打开标签并在稍后关闭它，就像我们为`<launch>...</launch>`或`<node>...</node>`所做的那样。
- en: 'From this, let’s say we want to start two **number_publisher** nodes and one
    **number_counter** node. On top of that, we also want to remap the topic from
    **number** to **my_number**. Here is the full XML launch file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，假设我们想要启动两个**number_publisher**节点和一个**number_counter**节点。在此基础上，我们还想将主题从**number**重命名为**my_number**。以下是完整的XML启动文件：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We rename the two **number_publisher** nodes to avoid name conflicts. Then,
    we make sure to add the same **<remap>** tag for all nodes in which we use a publisher
    or subscriber on the **number** topic.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将两个**number_publisher**节点重命名以避免名称冲突。然后，我们确保为所有使用**number**主题的发布者或订阅者的节点添加相同的**<remap>**标签。
- en: Additional tip
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 额外提示
- en: When you rename nodes and remap communications, use `rqt_graph` to verify that
    everything is working fine. With the graphical view, you can easily spot if a
    topic name is not the same on both sides of the communication.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重命名节点和重新映射通信时，使用`rqt_graph`来验证一切是否正常工作。通过图形视图，你可以轻松地发现通信两边的主题名称是否不同。
- en: 'Here is the code to do the same thing with a Python launch file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用Python启动文件做同样事情的代码：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After renaming and remapping, let’s see how to add parameters to your nodes
    inside a launch file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在重命名和重新映射之后，让我们看看如何在启动文件中为你的节点添加参数。
- en: Parameters in a launch file
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动文件中的参数
- en: Setting parameters’ values for a node in a launch file is pretty straightforward.
    We will first see how to provide the values directly, and then how to load a YAML
    file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动文件中为节点设置参数的值相当直接。我们将首先看看如何直接提供这些值，然后是如何加载一个YAML文件。
- en: Setting parameters’ values directly
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接设置参数的值
- en: 'To add a parameter’s value for a node in an XML launch file, you first need
    to open and close the **<node></node>** tag. Inside this tag, you will add one
    **<param>** tag per parameter, with two arguments: **name** and **value**.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要在XML启动文件中为节点添加参数的值，你首先需要打开和关闭**<node></node>**标签。在这个标签内，你将为每个参数添加一个**<param>**标签，带有两个参数：**name**和**value**。
- en: 'Here is an example, where we set the **number** and **publish_period** parameters
    for the **number_publisher** node:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，我们为**number_publisher**节点设置了**number**和**publish_period**参数：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It will work the same as adding **-p <parameter>:=<value>** after the **ros2**
    **run** command.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 它将和在**ros2 run**命令后添加**-p <parameter>:=<value>**一样工作。
- en: 'Now, you can combine renaming, remapping, and setting parameters. Let’s add
    parameters to the previous example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以结合重命名、重新映射和设置参数。让我们向之前的示例添加参数：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In a Python launch file, you need to add a list of dictionaries in the **Node**
    object:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python启动文件中，你需要在**Node**对象中添加一个字典列表：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Setting each parameter’s value like this will work fine if you only have a handful
    of parameters. For bigger numbers, it’s more suitable to use a YAML file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只有少量参数，像这样设置每个参数的值将工作得很好。对于更多的参数，使用YAML文件更合适。
- en: Note
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Do not confuse YAML param files with YAML launch files. Launch files can be
    written in Python, XML, and YAML (though we didn’t use YAML in this book). Any
    of those launch files can include YAML param files, to add parameters’ values
    for the nodes in the launch file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将YAML参数文件与YAML启动文件混淆。启动文件可以用Python、XML和YAML编写（尽管在这本书中我们没有使用YAML）。任何这些启动文件都可以包含YAML参数文件，以添加启动文件中节点的参数值。
- en: Installing and loading a YAML param file in a launch file
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在启动文件中安装和加载YAML参数文件
- en: 'To provide parameters’ values using a YAML file, you will need to follow this
    process:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用YAML文件提供参数值，你需要遵循以下过程：
- en: Create a YAML file with the values.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含值的YAML文件。
- en: Install this file inside the `_bringup` package.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件安装到`_bringup`包中。
- en: Load the YAML file in your launch file (we will do that with XML and then Python).
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的启动文件中加载YAML文件（我们将使用XML和Python来做这件事）。
- en: 'For this example, we are going to reuse the **number_params.yaml** file that
    we created in [*Chapter 8*](B22403_08.xhtml#_idTextAnchor394). In this file, you
    can find the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将重用我们在[*第8章*](B22403_08.xhtml#_idTextAnchor394)中创建的**number_params.yaml**文件。在这个文件中，你可以找到以下代码：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will perfectly match the nodes that we launched in the previous example,
    as the names are exactly the same.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这将完美匹配我们在上一个示例中启动的节点，因为名称完全相同。
- en: Now, what we have done so far is just provide the path to the file when starting
    a node with **ros2 run**. To use the YAML param file inside a launch file, we
    will need to install it in the package.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们到目前为止所做的一切只是提供了在启动节点时使用**ros2 run**启动文件的路径。要使用启动文件内的YAML参数文件，我们需要在包中安装它。
- en: 'To do that, create a new directory inside the **my_robot_bringup** package.
    You could choose any name for that directory, but we will follow a common convention
    and name it **config**:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，在**my_robot_bringup**包内创建一个新的目录。你可以为这个目录选择任何名字，但我们将遵循一个常见的约定，将其命名为**config**：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Put the **number_params.yaml** file inside this **config** directory. This is
    where you will also put all other YAML param files for this application.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将**number_params.yaml**文件放入这个**config**目录中。这也是你将放置此应用程序的所有其他YAML参数文件的地方。
- en: 'Now, to write instructions to install this directory (and all the YAML files
    inside), open the **CMakeLists.txt** file of the **my_robot_bringup** package
    and add one line:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了编写安装此目录（以及其中所有的 YAML 文件）的指令，打开**my_robot_bringup**包的**CMakeLists.txt**文件并添加一行：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You only need to do this once. Any other file inside the **config** directory
    will be installed when running **colcon build** for that package.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要做一次。在**config**目录中的任何其他文件在为该包运行**colcon build**时都会被安装。
- en: 'Before we build the package, let’s modify the launch file so that we can use
    this YAML param file. The way to do this in XML is easy. You will add a **<param>**
    tag, but instead of **name** and **value**, you need to specify a **from** argument:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建包之前，让我们修改启动文件，以便我们可以使用这个 YAML 参数文件。在 XML 中这样做很简单。你将添加一个**<param>**标签，但与**name**和**value**不同，你需要指定一个**from**参数：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we’ve seen previously in this chapter, **$(find-pkg-share <package_name>)**
    will locate the installation folder for that package. Then, you only need to finish
    with the relative path to the file you want to retrieve.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面看到的，**$(find-pkg-share <package_name>)**将定位该包的安装文件夹。然后，你只需要完成你想要检索的文件的相对路径。
- en: To test this, first build your package. This will install the YAML param files
    and the launch files. Then, source your environment and start the XML launch file.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，首先构建你的包。这将安装 YAML 参数文件和启动文件。然后，设置你的环境并启动 XML 启动文件。
- en: 'That’s it for parameters. Let’s now see the Python version. In your launch
    file, add the following imports:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 参数部分到此结束。现在，让我们看看 Python 版本。在你的启动文件中添加以下导入：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, retrieve the YAML file:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，检索 YAML 文件：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, load the configuration into the node:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将配置加载到节点中：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this, you should be able to start any node you want with any number of
    parameters without having any scaling issues.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你应该能够以任何数量的参数启动任何节点，而不会遇到任何缩放问题。
- en: Let’s now finish this section with namespaces. I have briefly mentioned them
    a few times during this book. As you now have a better understanding of how names
    work in ROS 2, and as namespaces are especially useful in launch files, this is
    a good time to start with them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用命名空间结束这一节。我在这本书中简要提到了它们几次。由于你现在对 ROS 2 中名称的工作方式有了更好的理解，并且由于命名空间在启动文件中特别有用，现在是开始使用它们的好时机。
- en: Namespaces
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: Namespaces are quite common in programming, and you are probably already familiar
    with them. With a namespace, you can group some functionalities (variables, functions,
    and so on) inside one *container* that has a name. This can help you better organize
    your code and avoid name conflicts.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间在编程中相当常见，你可能已经对它们很熟悉了。使用命名空间，你可以将一些功能（变量、函数等）分组在一个具有名称的*容器*中。这可以帮助你更好地组织代码并避免名称冲突。
- en: In ROS, namespaces are also quite practical. Let’s say you want to start an
    application that contains two identical robots, but you want to be able to control
    each robot independently. Instead of renaming the nodes, topics, services, and
    actions for each robot, you could just add a namespace.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ROS 中，命名空间也非常实用。假设你想要启动一个包含两个相同机器人的应用程序，但你想要能够独立控制每个机器人。你不需要为每个机器人重命名节点、主题、服务和动作，你只需添加一个命名空间。
- en: If you have a node named **robot_controller** and a topic named **cmd_vel**,
    then those can become **/robot1/robot_controller** and **/robot1/cmd_vel** for
    the first robot. For the second robot, this would be **/robot2/robot_controller**
    and **/robot2/cmd_vel**. This way, the two robots are still running on the same
    application, but you make sure that the velocity command for each robot is independent.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个名为**robot_controller**的节点和一个名为**cmd_vel**的主题，那么对于第一个机器人，这些可以成为**/robot1/robot_controller**和**/robot1/cmd_vel**。对于第二个机器人，这将变为**/robot2/robot_controller**和**/robot2/cmd_vel**。这样，两个机器人仍然在同一个应用程序上运行，但你确保每个机器人的速度命令是独立的。
- en: As you make progress with ROS 2 and learn new stacks and plugins, you will encounter
    namespaces everywhere. Let’s now see how to work with namespaces. As we have not
    done this previously, we will first use namespaces with the **ros2 run** command
    line, and then add them in our launch file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对 ROS 2 的进步和学习新的堆栈和插件，你将在各个地方遇到命名空间。现在，让我们看看如何与命名空间一起工作。因为我们之前没有这样做，所以我们将首先使用**ros2
    run**命令行使用命名空间，然后将其添加到我们的启动文件中。
- en: Starting a node inside a namespace
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在命名空间内启动节点
- en: Adding a namespace to a node is quite straightforward.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将命名空间添加到节点中相当简单。
- en: First of all, after the **ros2 run <package> <executable>** command, you add
    **--ros-args** once. Then, to specify a namespace, you will write **-r __ns:=<namespace>**.
    The **-r** option (or **--remap**) is the same as the one for renaming a node,
    only instead of **__node**, you use **__ns** here.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在**ros2 run <package> <executable>**命令之后，你只需添加一次**--ros-args**。然后，要指定一个命名空间，你将写**-r
    __ns:=<namespace>**。**-r**选项（或**--remap**）与重命名节点的选项相同，只是在这里你使用**__ns**而不是**__node**。
- en: 'Let’s start our **number_publisher** node inside a **/****abc** namespace:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在**/****abc**命名空间内启动我们的**number_publisher**节点：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After this, you can check what the node and topic names are:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，你可以检查节点和主题名称：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, **/abc** was added to the node name but also to the topic name—if
    you have services and actions, the namespace will be equally applied.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，**/abc**被添加到了节点名称中，同时也被添加到了主题名称中——如果你有服务和动作，命名空间将被同样应用。
- en: Important note
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The namespace was successfully applied because the topic name defined in the
    code is `number` without any leading slash. If you had written `/number` in the
    code, then the topic would have been considered to be in the *global* scope or
    namespace. Adding a namespace to the node will change the node name but not the
    topic name. Thus, pay attention to this when defining communication (topic, service,
    action) names in your code.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间成功应用是因为代码中定义的主题名称是`number`，没有任何前导斜杠。如果你在代码中写了`/number`，那么这个主题将被认为是处于**全局**作用域或命名空间中。给节点添加命名空间将改变节点名称，但不会改变主题名称。因此，在定义代码中的通信（主题、服务、动作）名称时，请注意这一点。
- en: 'Now, as the topic name is **/abc/number**, if we want to start the **number_counter**
    node and receive some data, we need to either rename the topic or also add a namespace
    to the node:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于主题名称是**/abc/number**，如果我们想启动**number_counter**节点并接收一些数据，我们需要要么重命名主题，要么也给节点添加命名空间：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When adding namespaces, name mismatches can become a frequent issue. One of
    the best ways to verify that things are working is to run **rqt_graph**:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加命名空间时，名称不匹配可能成为频繁出现的问题。验证事物是否正常工作的最佳方法之一是运行**rqt_graph**：
- en: '![Figure 9.3 – Double-checking namespaces with rqt_graph](img/B22403_09_3.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 使用rqt_graph检查命名空间](img/B22403_09_3.jpg)'
- en: Figure 9.3 – Double-checking namespaces with rqt_graph
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 使用rqt_graph检查命名空间
- en: With this, you can see that both nodes are publishing or subscribing to the
    **/****abc/number** topic.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，你可以看到这两个节点都在发布或订阅**/****abc/number**主题。
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can combine any type of renaming. For example, you could both add a namespace
    and rename the node: `$ ros2 run my_py_pkg number_publisher --ros-args -r __ns:=/abc
    -``r __node:=num_pub`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以组合任何类型的重命名。例如，你可以同时添加命名空间并重命名节点：`$ ros2 run my_py_pkg number_publisher --ros-args
    -r __ns:=/abc -r __node:=num_pub`。
- en: Now that you know how to provide a namespace for a node at runtime, let’s see
    how to do this inside a launch file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何在运行时为节点提供命名空间，让我们看看如何在启动文件中做到这一点。
- en: Specifying a namespace in a launch file
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在启动文件中指定命名空间
- en: 'To add a namespace to a node in an XML launch file, you just have to add a
    **namespace** argument inside the **<node>** tag. Let’s continue with our previous
    example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要在XML启动文件中给节点添加命名空间，你只需要在**<node>**标签内部添加一个**namespace**参数。让我们继续使用之前的例子：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For Python, the syntax is also quite easy; here too, you just need to add a
    **namespace** argument inside the **Node** object:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python，语法也很简单；在这里，你只需要在**Node**对象内部添加一个**namespace**参数：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you add a namespace to this node, you will also add the same namespace to
    nodes that are directly communicating with it:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给这个节点添加了命名空间，你也将给与之直接通信的节点添加相同的命名空间：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Adding namespaces to nodes in a launch file is quite straightforward. However,
    there is one important thing you need to pay attention to. If you are using YAML
    param files, you also need to specify the namespace in the YAML file. Open the
    **number_params.yaml** file and add the namespace to the node name:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动文件中给节点添加命名空间相当直接。然而，有一件重要的事情你需要注意。如果你使用YAML参数文件，你还需要在YAML文件中指定命名空间。打开**number_params.yaml**文件，并将命名空间添加到节点名称中：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you don’t do this, the parameters will be applied to the **/num_pub2** node,
    which doesn’t exist, since it’s named **/abc/num_pub2**. This can be a common
    source of errors, so make sure you double-check param files when adding namespaces.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有这样做，参数将被应用到**/num_pub2**节点上，但这个节点不存在，因为它被命名为**/abc/num_pub2**。这可能是错误的一个常见来源，所以在添加命名空间时务必仔细检查参数文件。
- en: After all those modifications, make sure to build the **my_robot_bringup** package
    again and source the environment before you start any launch file.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些修改之后，确保在启动任何启动文件之前再次构建 **my_robot_bringup** 包并源代码环境。
- en: You have now seen a few ways to configure your nodes inside a launch file. With
    this base knowledge, you can already scale your application a lot. Let’s finish
    this chapter with a new challenge so that you can practice more on your own.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了在启动文件中配置节点的一些方法。有了这些基础知识，你现在已经可以扩展你的应用程序很多了。让我们通过一个新的挑战来结束这一章，这样你可以自己练习更多。
- en: Launch file challenge
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动文件挑战
- en: In this challenge, you will practice more with launch files, YAML param files,
    remappings, and namespaces. This will be the conclusion of *Part 2*. To complete
    this challenge, you can decide to write the launch file in XML, Python, or both.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个挑战中，你将更多地练习使用启动文件、YAML参数文件、重映射和命名空间。这将是我们第二部分的结论。为了完成这个挑战，你可以决定用XML、Python或两者都来编写启动文件。
- en: Challenge
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挑战
- en: What we want to do here is to start two **turtlesim** windows, each one with
    one turtle. Then, for each turtle, we run a **turtle_controller** node (the one
    we have been developing throughout the previous chapters).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里想要做的是启动两个 **turtlesim** 窗口，每个窗口中有一个海龟。然后，对于每个海龟，我们运行一个 **turtle_controller**
    节点（这是我们之前章节中一直在开发的节点）。
- en: 'The goal is to have each **turtle_controller** node controlling only one turtle.
    This is what the result should look like:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是让每个 **turtle_controller** 节点只控制一个海龟。结果应该看起来像这样：
- en: '![Figure 9.4 – Two  different turtles with two independent controllers](img/B22403_09_4.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 两个不同的海龟和两个独立的控制器](img/B22403_09_4.jpg)'
- en: Figure 9.4 – Two different turtles with two independent controllers
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 两个不同的海龟和两个独立的控制器
- en: 'For each turtle, we will apply different settings (parameters):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个海龟，我们将应用不同的设置（参数）：
- en: 'First `turtlesim` window:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个 `turtlesim` 窗口：
- en: '`128` for the RGB value)'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`128` 用于RGB值）'
- en: 'First controller:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个控制器：
- en: '`1.5`'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.5`'
- en: 'Second `turtlesim` window:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个 `turtlesim` 窗口：
- en: '`128` for the RGB value)'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`128` 用于RGB值）'
- en: 'Second controller:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个控制器：
- en: '`0.5`'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.5`'
- en: 'Here are the steps you can take:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可以采取的步骤：
- en: Create a `turtle_params.yaml` file with the parameters for each node. Install
    this in the `my_robot_bringup` package.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含每个节点参数的 `turtle_params.yaml` 文件。将其安装到 `my_robot_bringup` 包中。
- en: Create a new launch file and start the four nodes. Load the parameters from
    the YAML param file. Put the different nodes into appropriate namespaces (to keep
    it simple, use `t1` and `t2` for `turtle1` and `turtle2`, respectively).
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的启动文件并启动四个节点。从YAML参数文件中加载参数。将不同的节点放入适当的命名空间中（为了简单起见，分别使用 `t1` 和 `t2` 作为
    `turtle1` 和 `turtle2` 的命名空间）。
- en: Build, source, and start the launch file. You will see that some topics and
    services are not matching, and thus you will know what remappings you need to
    add.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建、源代码并启动启动文件。你会看到一些主题和服务不匹配，因此你会知道你需要添加哪些重映射。
- en: To make it easier, start with just one pair of nodes (**turtlesim** and **turtle_controller**),
    and then add another pair when it’s working.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，先从一对节点（**turtlesim** 和 **turtle_controller**）开始，然后当它工作后再添加另一对。
- en: 'Here is an important point for this challenge: we will not modify any of the
    existing code—even if it would make things easier. The goal is to take the nodes
    exactly as they are (use the code from the **ch8** folder in the repo) and make
    things work using appropriate namespaces and remappings in the launch file and
    YAML param file.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是挑战中的一个重要点：我们不会修改任何现有的代码——即使这样做会使事情变得更容易。目标是使用节点原样（使用存储库中 **ch8** 文件夹中的代码）并使用启动文件和YAML参数文件中的适当命名空间和重映射来使事情工作。
- en: Solution
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Create a new file named **turtle_params.yaml**, inside the **config** directory
    of the **my_robot_bringup** package. As a base, you can take the one that we did
    in the parameter challenge for [*Chapter 8*](B22403_08.xhtml#_idTextAnchor394).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **my_robot_bringup** 包的 **config** 目录下创建一个名为 **turtle_params.yaml** 的新文件。作为一个基础，你可以参考我们在[*第8章*](B22403_08.xhtml#_idTextAnchor394)参数挑战中使用的那个。
- en: In this file, we will add parameters for all four nodes. Before we do this,
    we need to know exactly what will be the name for each node, including the namespaces.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们将为所有四个节点添加参数。在我们这样做之前，我们需要确切地知道每个节点的名称，包括命名空间。
- en: 'With the **t1** and **t2** namespaces, if we just add a namespace and we don’t
    rename the nodes, we will then have these names:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **t1** 和 **t2** 命名空间，如果我们只是添加一个命名空间而不重命名节点，那么我们将有这些名称：
- en: '`/``t1/turtlesim`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/``t1/turtlesim`'
- en: '`/``t2/turtlesim`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/``t2/turtlesim`'
- en: '`/``t1/turtle_controller`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/``t1/turtle_controller`'
- en: '`/``t2/turtle_controller`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/``t2/turtle_controller`'
- en: 'After making this choice, we can write the YAML param file:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出这个选择后，我们可以编写 YAML 参数文件：
- en: '[PRE37]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This contains all the configurations given in the challenge. Now, create a new
    launch file (for example, **turtlesim_control.launch.xml**) inside the **launch**
    directory.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了挑战中给出的所有配置。现在，在 **launch** 目录中创建一个新的启动文件（例如，**turtlesim_control.launch.xml**）。
- en: 'In this launch file, let’s start with something simple. We want to try to run
    one **turtlesim** node and one **turtle_controller** node, using the **t1** namespace:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个启动文件中，让我们从简单的东西开始。我们想要尝试运行一个 **turtlesim** 节点和一个 **turtle_controller** 节点，使用
    **t1** 命名空间：
- en: '[PRE38]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As we are starting nodes from the **turtlesim** and **turtle_controller** packages,
    we also add two new **<exec_depend>** tags in the **package.xml** file:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是从 **turtlesim** 和 **turtle_controller** 包中启动节点，我们在 **package.xml** 文件中也添加了两个新的
    **<exec_depend>** 标签：
- en: '[PRE39]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, if you launch this (make sure to build and source first), you will see
    the **turtlesim** node, but the turtle won’t move. Why is that?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你启动这个（确保先构建和源代码），你会看到 **turtlesim** 节点，但海龟不会移动。这是为什么？
- en: 'If you look at the topic list, you will find these two topics:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看主题列表，你会找到这两个主题：
- en: '[PRE40]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With **rqt_graph**, you can also see that the **turtlesim** node is subscribing
    to **/t1/turtle1/cmd_vel**, but the **turtle_controller** node is publishing on
    **/turtle1/cmd_vel**. Why did the namespace work for the node name but not for
    the topic name?
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **rqt_graph**，你还可以看到 **turtlesim** 节点正在订阅 **/t1/turtle1/cmd_vel**，但 **turtle_controller**
    节点正在发布到 **/turtle1/cmd_vel**。为什么命名空间对节点名称有效，但对主题名称无效？
- en: This is because we wrote **/turtle1/cmd_vel** in the code, and not **turtle1/cmd_vel**.
    The fact that we added a leading slash makes the namespace the *global* namespace.
    Thus, if you try to add a namespace to that, it will not be taken into account.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们在代码中写的是 **/turtle1/cmd_vel**，而不是 **turtle1/cmd_vel**。我们在前面添加了一个斜杠，这使得命名空间成为
    *全局* 命名空间。因此，如果你尝试给那个命名空间添加内容，它将不会被考虑。
- en: 'We have two options here: either we modify the code (we simply need to remove
    this leading slash) or we adapt the launch file to make this work. As specified
    in the challenge instructions, we are not going to modify the code. The reason
    why I’m adding this constraint is because, in real life, you won’t necessarily
    be able to modify the code of the nodes you run. Thus, knowing how to solve a
    name mismatch without touching the code is a great skill to have.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两种选择：要么修改代码（我们只需要删除这个前导斜杠），要么调整启动文件以使其工作。正如挑战说明中指定的，我们不会修改代码。我添加这个约束的原因是，在现实生活中，你并不一定能修改你运行的节点的代码。因此，知道如何在不接触代码的情况下解决名称不匹配是一个非常有用的技能。
- en: 'So, if you look at the topic and service names (we don’t use actions here),
    you will see that we have two topics and one service to modify. Let’s add some
    **<remap>** tags inside the node:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你查看主题和服务名称（我们这里不使用动作），你会看到我们有两个主题和一个服务需要修改。让我们在节点内部添加一些 **<remap>** 标签：
- en: '[PRE41]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can now start the launch file, and you will see the turtle moving. Now
    that we have this working, adding a second pair of nodes is easy. We basically
    need to copy/paste the two nodes and replace **t1** with **t2**:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以启动启动文件，你会看到海龟在移动。现在我们有了这个功能，添加第二对节点很容易。我们基本上需要复制/粘贴这两个节点，并将 **t1** 替换为
    **t2**：
- en: '[PRE42]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The challenge is now complete. If you start this launch file, you will see two
    **turtlesim** windows, each one containing a turtle that moves at a different
    speed and using different pen colors.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战现在完成了。如果你启动这个启动文件，你会看到两个 **turtlesim** 窗口，每个窗口中都有一个海龟以不同的速度移动，并使用不同的笔色。
- en: You can find the complete code and package organization in the book’s GitHub
    repository (including the Python launch file).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在书的 GitHub 仓库中找到完整的代码和包组织结构（包括 Python 启动文件）。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you worked on ROS 2 launch files. Launch files allow you to
    properly scale your application with multiple nodes, parameters, and sets of configuration.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了 ROS 2 启动文件。启动文件允许你通过多个节点、参数和配置集合来正确地扩展你的应用程序。
- en: You can write a launch file in Python, XML, or YAML. Here, you discovered the
    Python and XML syntax and saw that XML is probably the best choice by default.
    The syntax is much easier, and the code is much shorter. If you ever need to combine
    XML and Python launch files, you can do so by including a launch file in another
    one.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用 Python、XML 或 YAML 编写启动文件。在这里，你发现了 Python 和 XML 语法，并看到 XML 可能是默认的最佳选择。语法更简单，代码更短。如果你需要将
    XML 和 Python 启动文件结合起来，你可以通过在一个启动文件中包含另一个启动文件来实现。
- en: The best practice is to set up a dedicated package for launch files and YAML
    files. You can name the package using the **_bringup** suffix. Launch files will
    be installed in a **launch** folder, and YAML param files in a **config** folder.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是为启动文件和YAML文件设置一个专门的软件包。您可以使用**_bringup**后缀来命名软件包。启动文件将安装在**launch**文件夹中，YAML参数文件将安装在**config**文件夹中。
- en: 'If you correctly understand how to start nodes with the **ros2 run command**,
    then doing so in a launch file is pretty straightforward: you just need to provide
    the package and executable name for each node. The only thing to learn is the
    XML or Python syntax.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正确理解了如何使用**ros2 run命令**启动节点，那么在启动文件中这样做就相当简单：您只需为每个节点提供软件包和可执行文件名称。您需要学习的是XML或Python语法。
- en: 'In a launch file, you can also configure your nodes in multiple ways:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动文件中，您也可以以多种方式配置您的节点：
- en: Renaming the node and/or adding a namespace
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名节点和/或添加命名空间
- en: Remapping topics, services, and actions
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射主题、服务和动作
- en: Adding parameters, individually or from a YAML param file
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加参数，单独或从YAML参数文件中添加
- en: This is what we have seen so far, but there are many other ways to configure
    your nodes that you will discover throughout your ROS 2 learning journey.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们迄今为止所看到的，但在您的ROS 2学习之旅中，您会发现还有许多其他配置节点的方法。
- en: '*Part 2* of this book is now finished. You have discovered all the core concepts
    that will allow you to write complete ROS 2 applications and join existing ROS
    2 projects. You should now be able to interact with any ROS 2 node, write code
    to communicate with it, and scale your application with parameters and launch
    files.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的**第2部分**现在已经完成。您已经发现了所有核心概念，这将使您能够编写完整的ROS 2应用程序并加入现有的ROS 2项目。现在您应该能够与任何ROS
    2节点进行交互，编写与它通信的代码，并通过参数和启动文件扩展您的应用程序。
- en: Now, this part was heavily focused on programming (Python and C++), which is
    incredibly important, but ROS 2 is more than just that. In *Part 3*, we will dive
    into some additional concepts and tools (**TransForms** (**TFs**), **Unified Robot
    Description Format** (**URDF**), **Gazebo**) so that you can design a custom application
    for a robot, including a 3D simulation. This, combined with the programming we
    did in *Part 2*, will be the backbone of any ROS 2 application you work on.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这一部分主要关注编程（Python和C++），这非常重要，但ROS 2不仅仅是这些。在**第3部分**中，我们将深入研究一些额外的概念和工具（**TransForms**（**TFs**），**统一机器人描述格式**（**URDF**），**Gazebo**），这样您就可以为机器人设计一个自定义应用程序，包括3D模拟。这与我们在**第2部分**中进行的编程相结合，将成为您所工作的任何ROS
    2应用程序的骨干。
