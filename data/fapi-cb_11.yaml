- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Middleware and Webhooks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件和 Webhooks
- en: In this chapter, we delve into the advanced and crucial aspects of middleware
    and webhooks in FastAPI. Middleware in FastAPI allows you to process requests
    and responses globally before they reach your route handlers and after they leave
    them. Webhooks, on the other hand, enable your FastAPI application to communicate
    with other services by sending real-time data updates. Both middleware and webhooks
    are essential for building robust, efficient, and scalable applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究 FastAPI 中间件和 Webhooks 的高级和关键方面。FastAPI 中的中间件允许你在请求和响应到达路由处理器之前以及离开之后全局地处理它们。另一方面，Webhooks
    允许你的 FastAPI 应用通过发送实时数据更新与其他服务进行通信。中间件和 Webhooks 对于构建健壮、高效和可扩展的应用程序至关重要。
- en: We will start by exploring how to create custom **Asynchronous Server Gateway
    Interface** (**ASGI**) middleware from scratch. This will give you a deep understanding
    of how middleware works at a fundamental level.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从探索如何从头开始创建自定义 **异步服务器网关接口**（**ASGI**）中间件开始。这将让你深入理解中间件在基本层面的工作原理。
- en: Next, we’ll develop middleware specifically for response modification, allowing
    you to intercept and alter responses before they are sent back to the client.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开发专门用于响应修改的中间件，允许你在将响应发送回客户端之前拦截和修改它们。
- en: We will also cover handling **Cross-Origin Resource Sharing** (**CORS**) with
    middleware. This is particularly important for applications that need to interact
    with different domains securely. Finally, we will dive into creating webhooks
    in FastAPI, demonstrating how to set them up and test them effectively.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍如何使用中间件处理 **跨源资源共享**（**CORS**）。这对于需要安全地与不同域交互的应用程序尤为重要。最后，我们将深入探讨在 FastAPI
    中创建 Webhooks，展示如何有效地设置和测试它们。
- en: By the end of this chapter, you will have a comprehensive understanding of how
    to implement and utilize middleware and webhooks in your FastAPI applications.
    These skills will enable you to build more dynamic, responsive, and integrated
    web services.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将全面了解如何在 FastAPI 应用程序中实现和使用中间件和 Webhooks。这些技能将使你能够构建更动态、响应更快、更集成的网络服务。
- en: 'In this chapter, we’re going to go through the following recipes:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Creating custom ASGI middleware
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义 ASGI 中间件
- en: Developing middleware for request modification
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发用于请求修改的中间件
- en: Developing middleware for response modification
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发用于响应修改的中间件
- en: Handling CORS with middleware
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用中间件处理 CORS
- en: Restricting incoming requests from hosts
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制来自主机的传入请求
- en: Implementing webhooks
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 Webhooks
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: At this stage of the book, you should already have a good understanding of the
    basics of FastAPI, how to install it, and how to run it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书的这一阶段，你应该已经对 FastAPI 的基础知识有了很好的理解，包括如何安装它以及如何运行它。
- en: 'The code used in the chapter is hosted on GitHub at the following address:
    [https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter11](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter11).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码托管在 GitHub 上，地址如下：[https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter11](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter11)。
- en: It is recommended to set up a virtual environment for the project in the project
    root folder to efficiently manage dependencies and maintain project isolation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在项目根目录中为项目设置一个虚拟环境，以有效地管理依赖项并保持项目隔离。
- en: 'Throughout the chapter, we will only be using the standard `fastapi` library
    with `uvicorn`. You can install all the dependencies within your virtual environment
    using `pip` from the command line by running the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个章节中，我们只将使用标准的 `fastapi` 库和 `uvicorn`。你可以通过在命令行中运行以下命令，在你的虚拟环境中使用 `pip` 安装所有依赖项：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For the *Handling CORS with middleware* recipe, having some basic knowledge
    of JavaScript and HTML will be beneficial.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *使用中间件处理 CORS* 的配方，具备一些基本的 JavaScript 和 HTML 知识将有所帮助。
- en: Creating custom ASGI middleware
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义 ASGI 中间件
- en: ASGI is a specification for Python web servers and applications to communicate
    with each other, designed to support asynchronous functionality. Middleware is
    a critical component in web applications, providing a way to process requests
    and responses.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ASGI 是一个用于 Python 网络服务器和应用程序之间通信的规范，旨在支持异步功能。中间件是网络应用中的一个关键组件，它提供了一种处理请求和响应的方式。
- en: We have already seen, in the *Creating custom middleware* recipe in [*Chapter
    8*](B21025_08.xhtml#_idTextAnchor262), *Advanced Features and Best Practices*,
    how to create custom middleware. However, this technique relies on the `BasicHTTPMiddleware`
    class from the Starlette library, which is a high-level implementation of HTTP
    middleware.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [*第 8 章*](B21025_08.xhtml#_idTextAnchor262) 的 *创建自定义中间件* 菜谱中看到，如何创建自定义中间件。然而，这种技术依赖于
    Starlette 库中的 `BasicHTTPMiddleware` 类，这是一个高级 HTTP 中间件的实现。
- en: In this recipe, we’ll learn how to create custom ASGI middleware from scratch
    and integrate it into a FastAPI application. The middleware will be simple and
    will only print log message information on the terminal.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何从头开始创建自定义 ASGI 中间件并将其集成到 FastAPI 应用程序中。这个中间件将很简单，它只会在终端上打印日志消息信息。
- en: This approach provides greater control over the request/response cycle compared
    to the `BasicHTTPMiddleware` class, allowing for advanced customizations and the
    creation of any kind of middleware with a deeper level of customization.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `BasicHTTPMiddleware` 类相比，这种方法提供了对请求/响应循环的更大控制，允许进行高级自定义，并创建任何类型的具有更深层次自定义的中间件。
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Since we will use the Starlette library to build middleware, a sound knowledge
    of this library would be beneficial, although not necessary.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用 Starlette 库来构建中间件，因此对这一库有良好的了解将是有益的，尽管不是必需的。
- en: Regarding the development environment, we will exclusively utilize the `fastapi`
    package with `uvicorn`. Ensure they are installed in your environment.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关于开发环境，我们将仅使用 `fastapi` 包和 `uvicorn`。确保它们已安装在你的环境中。
- en: How to do it…
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s start by creating a project root folder called `middleware_project`.
    Under the root folder, create a folder called `middleware` containing a module
    called `asgi_middleware.py`. Let’s start the module by declaring the logger that
    we will use during the middleware call:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为 `middleware_project` 的项目根目录开始。在根目录下，创建一个名为 `middleware` 的文件夹，其中包含一个名为
    `asgi_middleware.py` 的模块。让我们从声明在中间件调用期间将使用的记录器开始：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then we can define the middleware class as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以定义中间件类如下：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we need to include the middleware in our application. Under the project
    root folder, create the `main.py` module containing the FastAPI class to run the
    application, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在我们的应用程序中包含中间件。在项目根目录下，创建一个包含 FastAPI 类的 `main.py` 模块来运行应用程序，如下所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is all you need to implement custom ASGI middleware in a FastAPI application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你在 FastAPI 应用程序中实现自定义 ASGI 中间件所需的所有内容。
- en: How it works…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To see the middleware in action, let’s create a general endpoint in `main.py`
    module, as in the following example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到中间件的实际效果，让我们在 `main.py` 模块中创建一个通用的端点，如下面的示例所示：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Spin up the server by running `uvicorn main:app` from the command line. You
    will see the following messages:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在命令行中运行 `uvicorn main:app` 来启动服务器。你会看到以下消息：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Among the messages, you will notice those indicating that we have already entered
    the middleware. Now try to call the root endpoint. You can do it by opening the
    browser at `http://localhost:8000/`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在消息中，你会注意到那些表示我们已经进入中间件的消息。现在尝试调用根端点。你可以通过在浏览器中打开 `http://localhost:8000/` 来实现。
- en: 'Still on the terminal, this time you will notice both middleware messages for
    entering and exiting:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在终端上，这次你会注意到进入和退出中间件的两个消息：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we understand from the logs, we entered the middleware twice, once on the
    startup and once when calling the endpoint, but we exited the middleware only
    once.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 根据日志，我们两次进入了中间件，一次是在启动时，一次是在调用端点时，但我们只退出了一次中间件。
- en: This is why the ASGI middleware intercepts every event of the application, not
    only the HTTP request but also the `lifespan` event, which includes the startup
    and shutdown.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么 ASGI 中间件拦截应用程序的每个事件，不仅包括 HTTP 请求，还包括 `lifespan` 事件，这包括启动和关闭。
- en: 'Information on the event type within the middleware is stored in the `scope`
    parameter of the `__call__` method. Let’s include the following logs in the `ASGIMiddleware.__call__`
    method to improve our understanding of the mechanism:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间件中存储的事件类型信息存储在 `__call__` 方法的 `scope` 参数中。让我们在 `ASGIMiddleware.__call__`
    方法中包含以下日志，以改善我们对机制的理解：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you restart the server and remake the call to `http://localhost:8000/`, you
    will now see the log messages specifying the event scope type to be `lifespan`
    at the server startup and `http` after the endpoint call.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新启动服务器并重新调用 `http://localhost:8000/`，你现在将看到在服务器启动时指定事件作用域类型为 `lifespan`，在端点调用后为
    `http` 的日志消息。
- en: There’s more…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We have just seen how to build ASGI middleware as a class. However, you can
    also do it by leveraging the function decorator pattern. For example, you can
    build the same middleware like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何将 ASGI 中间件作为一个类来构建。然而，你也可以利用函数装饰器模式来完成它。例如，你可以这样构建相同的中间件：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is the equivalent of the `ASGIMiddleware` class defined earlier in the
    *How to do it…* subsection. To make it work, it should be passed as an argument
    to the FastAPI instance in exactly the same way:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与在 *如何做…* 子部分中之前定义的 `ASGIMiddleware` 类等效的。为了使其工作，它应该以完全相同的方式作为参数传递给 FastAPI
    实例：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Based on your personal preference, you can choose the style you prefer. However,
    for the rest of the chapter, we will continue using the middleware class style.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的个人喜好，你可以选择你喜欢的风格。然而，在本章的其余部分，我们将继续使用中间件类风格。
- en: See also
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can read more on the ASGI specification in the dedicated documentation
    page:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在专门的文档页面了解更多关于 ASGI 规范的信息：
- en: '*ASGI* *Documentation*: [https://asgi.readthedocs.io/en/latest/](https://asgi.readthedocs.io/en/latest/)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ASGI* 文档：[https://asgi.readthedocs.io/en/latest/](https://asgi.readthedocs.io/en/latest/)'
- en: 'Middleware classes in FastAPI derive from the Starlette library. You can find
    extensive documentation on creating ASGI middleware on the Starlette documentation
    page:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 中的中间件类是从 Starlette 库派生出来的。你可以在 Starlette 文档页面上找到创建 ASGI 中间件的详细文档：
- en: '*Pure ASGI* *Middleware*: [https://www.starlette.io/middleware/#pure-asgi-middleware](https://www.starlette.io/middleware/#pure-asgi-middleware)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*纯 ASGI* 中间件：[https://www.starlette.io/middleware/#pure-asgi-middleware](https://www.starlette.io/middleware/#pure-asgi-middleware)'
- en: Developing middleware for request modification
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发请求修改的中间件
- en: Middleware in web applications serves as a powerful tool for processing requests.
    Custom middleware can intercept and modify these messages, allowing developers
    to add or modify functionalities.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络应用程序中，中间件作为处理请求的强大工具。自定义中间件可以拦截并修改这些消息，允许开发者添加或修改功能。
- en: In this recipe, we’ll focus on developing custom ASGI middleware to modify responses
    before they are sent to the client by hashing the body of each request, if necessary.
    This approach provides the flexibility to add or change response headers, body
    content, and other properties dynamically. By the end of the recipe, you will
    be able to develop custom middleware to control every API request.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将专注于开发自定义 ASGI 中间件，在将请求体发送到客户端之前对其进行哈希处理（如果需要）。这种方法提供了动态添加或更改响应头、请求体内容和其它属性的能力。到食谱结束时，你将能够开发自定义中间件来控制每个
    API 请求。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we begin, please make sure you have completed the previous recipe, *Creating
    custom ASGI middleware*, to create specific custom ASGI middleware. We will be
    working on the `middleware_project` application, but the recipe can easily be
    applied to any application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请确保你已经完成了之前的食谱，*创建自定义 ASGI 中间件*，以创建特定的自定义 ASGI 中间件。我们将使用 `middleware_project`
    应用程序进行工作，但这个食谱可以轻松地应用到任何应用程序上。
- en: 'Before creating the middleware, in the `main.py` module, let’s create a `POST
    /send` endpoint that accepts body content in the request, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建中间件之前，在 `main.py` 模块中，让我们创建一个 `POST /send` 端点，它接受请求中的请求体内容，如下所示：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The endpoint will print the body content to the terminal and return it as a
    response as well.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 端点将打印请求体内容到终端，并将其作为响应返回。
- en: Now that we have our endpoint, we can create the middleware to hash the body
    content before sending it to the endpoint.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了端点，我们可以创建中间件来在发送到端点之前对请求体进行哈希处理。
- en: How to do it…
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In the `middleware` folder, let’s create a module called `request_middleware.py`
    that will host our middleware class. Let’s go through the following steps to create
    the middleware:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `middleware` 文件夹中，让我们创建一个名为 `request_middleware.py` 的模块，它将托管我们的中间件类。让我们按照以下步骤创建中间件：
- en: 'Start the module with the required imports like this:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以这种方式开始模块，导入所需的模块：
- en: '[PRE11]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will use the types from the Starlette library to create the middleware class
    and the `sha1` function to hash the body.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用 Starlette 库中的类型来创建中间件类，并使用 `sha1` 函数来哈希请求体。
- en: Given that only certain `HTTP` verbs accept the body (`POST` and `PUT`, but
    not `GET` for example), we will pass to the middleware the paths as parameters
    where the modifications should be applied.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于只有某些 `HTTP` 动词接受正文（例如 `POST` 和 `PUT`，但不包括 `GET`），我们将把应应用修改的路径作为参数传递给中间件。
- en: 'Create a middleware class called `HashBodyContentMiddleware`, as follows:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个名为 `HashBodyContentMiddleware` 的中间件类，如下所示：
- en: '[PRE12]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will pass the list of paths into the `allowed_paths` parameters.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将把路径列表传递给 `allowed_paths` 参数。
- en: 'Define the `__call__` method of the class:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义类的 `__call__` 方法：
- en: '[PRE13]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the event is not an HTTP request or the path is not listed, the middleware
    won’t take any action and will leave the request passing through the next step.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果事件不是一个 HTTP 请求或者路径不在列表中，中间件将不会采取任何行动，并将请求传递到下一步。
- en: 'The information about the body is brought by the `receive` variable. However,
    the `receive` variable is a coroutine, and it should be passed as that to the
    `self.app` object. We will overcome this by creating a new coroutine within the
    function, as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于正文的信息由 `receive` 变量提供。然而，`receive` 变量是一个协程，应该将其作为协程传递给 `self.app` 对象。我们将通过在函数中创建一个新的协程来克服这一点，如下所示：
- en: '[PRE14]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The body request will be modified by the coroutine that is passed to the following
    steps of the FastAPI object application.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正文请求将由传递给 FastAPI 对象应用后续步骤的协程修改。
- en: 'Now we need to add the middleware to the FastAPI instance. We can do it in
    the `main.py` module. But this time we will leverage the `add_middleware` method
    of the FastAPI instance object like this:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要将中间件添加到 FastAPI 实例中。我们可以在 `main.py` 模块中完成此操作。但这次我们将利用 FastAPI 实例对象的 `add_middleware`
    方法，如下所示：
- en: '[PRE15]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now the application will make the request pass through our middleware.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在应用程序将使请求通过我们的中间件。
- en: 'This is all you need to implement it. To test the middleware, let’s spin up
    the server with `uvicorn` from the command line by running the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是实现它的全部内容。为了测试中间件，让我们通过命令行运行以下命令来启动 `uvicorn` 服务器：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then go to the interactive documentation at `http://localhost:8000/docs` and
    test the `POST/send` endpoint. For example, check whether you can send a body
    string like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后转到 `http://localhost:8000/docs` 上的交互式文档，并测试 `POST/send` 端点。例如，检查你是否可以发送如下所示的正文字符串：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If everything is correctly done, you should receive a response body like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切操作正确，你应该会收到如下所示的响应正文：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You have just implemented custom ASGI middleware that hashes the body for the
    specified endpoints.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚实现了自定义 ASGI 中间件，该中间件为指定的端点哈希正文。
- en: This was a simple example, but the potential of controlling requests is limitless.
    For example, you can use it to introduce an additional security layer to prevent
    cross-scripting injection of undesired content.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，但控制请求的潜力是无限的。例如，你可以用它来引入额外的安全层，以防止跨脚本注入不受欢迎的内容。
- en: See also
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Creating middleware to modify the request is documented on the Starlette documentation
    page:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Starlette 文档页面上有关于创建用于修改请求的中间件的说明：
- en: '*Inspecting or modifying the* *request*: [https://www.starlette.io/middleware/#inspecting-or-modifying-the-request](https://www.starlette.io/middleware/#inspecting-or-modifying-the-request)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查或修改请求*：[https://www.starlette.io/middleware/#inspecting-or-modifying-the-request](https://www.starlette.io/middleware/#inspecting-or-modifying-the-request)'
- en: Developing middleware for response modification
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发用于响应修改的中间件
- en: Besides processing requests, middleware in web applications is also a powerful
    tool for processing responses. Custom middleware allows us to intercept responses
    before they are returned to the API caller. This can be useful for checking response
    content or personalizing the response. In this recipe, we will develop custom
    ASGI middleware to add customized headers to all the responses.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了处理请求外，Web 应用程序中的中间件也是处理响应的强大工具。自定义中间件允许我们在响应返回给 API 调用者之前拦截响应。这可以用于检查响应内容或个性化响应。在这个配方中，我们将开发自定义
    ASGI 中间件，为所有响应添加自定义头。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be creating custom ASGI middleware that modifies the response of each
    HTTP call. Before we get started on this recipe, take a look at the *Creating
    custom ASGI middleware* recipe. Also, this recipe will be complementary to the
    previous recipe, *Developing middleware for* *request modification*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建自定义 ASGI 中间件，以修改每个 HTTP 调用的响应。在我们开始这个配方之前，请查看 *创建自定义 ASGI 中间件* 配方。此外，这个配方将补充先前的配方，*为请求修改开发中间件*。
- en: While you can apply this recipe to your own project, we will continue working
    on the `middleware_project` project that we initialized in the *Developing middleware
    for request* *modification* recipe.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以将这个配方应用到你的项目中，但我们将继续在 *为请求修改开发中间件* 配方中初始化的 `middleware_project` 项目上工作。
- en: How to do it…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will create our middleware class in a dedicated module in the `middleware`
    folder. We will call the module `response_middleware.py`. Let's start building
    the middleware by going through the following steps.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `middleware` 文件夹中的专用模块中创建我们的中间件类。我们将把这个模块命名为 `response_middleware.py`。让我们通过以下步骤开始构建中间件。
- en: 'Let’s start writing the imports we will use to define the middleware:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始编写我们将用于定义中间件的导入语句：
- en: '[PRE19]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we can start defining the `ExtraHeadersResponseMiddleware` middleware
    class as follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以开始定义 `ExtraHeadersResponseMiddleware` 中间件类，如下所示：
- en: '[PRE20]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will pass the headers list as an argument to the middleware. Then, the `__call__`
    method will be as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把头部信息列表作为参数传递给中间件。然后，`__call__` 方法将如下所示：
- en: '[PRE21]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We restrain the middleware to HTTP event calls. Similar to what we saw in the
    previous recipe, *Developing middleware for request modification*, we modify the
    send object, which is a coroutine, and we pass it to the next middleware, as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将中间件限制在HTTP事件调用上。类似于我们在之前的配方中看到的，*为请求修改开发中间件*，我们修改发送对象，它是一个协程，并将其传递给下一个中间件，如下所示：
- en: '[PRE22]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The response’s headers are generated from the `message` parameter of the `send_with_extra_headerds`
    coroutine object.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 响应的头部信息是从 `send_with_extra_headers` 协程对象的 `message` 参数生成的。
- en: 'Once the middleware is defined, we need to add it to the `FastAPI` object instance
    to make it effective. We can add it in the `main.py` module as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦定义了中间件，我们需要将其添加到 `FastAPI` 对象实例中，使其生效。我们可以在 `main.py` 模块中添加它，如下所示：
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we add two headers to the response, `new-header` and `another-header`.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们向响应中添加了两个头部，`new-header` 和 `another-header`。
- en: To test it, spin up the server by running `uvicorn main:app` and open the interactive
    documentation. Call one of the endpoints and check the headers in the response.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了测试它，通过运行 `uvicorn main:app` 启动服务器并打开交互式文档。调用其中一个端点并检查响应中的头部信息。
- en: 'Here is the list of the headers you get when calling the `GET /` endpoint:'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在调用 `GET /` 端点时，你会得到以下头部信息列表：
- en: '[PRE24]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You will find the two headers we previously added to the default ones.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将找到我们之前添加到默认头部信息中的两个头部。
- en: You have just implemented middleware that modifies API responses.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚实现了修改API响应的中间件。
- en: See also
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In the Starlette documentation, you can find an example of how to create middleware
    that modifies the response:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在Starlette文档中，你可以找到一个创建修改响应的中间件的示例：
- en: '*Inspecting or modifying the* *response*: [https://www.starlette.io/middleware/#inspecting-or-modifying-the-response](https://www.starlette.io/middleware/#inspecting-or-modifying-the-response)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查或修改* *响应*：[https://www.starlette.io/middleware/#inspecting-or-modifying-the-response](https://www.starlette.io/middleware/#inspecting-or-modifying-the-response)'
- en: Handling CORS with middleware
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用中间件处理CORS
- en: CORS is a security feature implemented in web browsers to prevent malicious
    websites from making unauthorized requests to APIs hosted on different origins.
    When building APIs, especially for public consumption, it’s crucial to handle
    CORS properly to ensure legitimate requests are served while unauthorized ones
    are blocked.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: CORS是浏览器中实现的一种安全特性，用于防止恶意网站对来自不同源的主机上的API发起未经授权的请求。在构建API时，特别是对于公共消费的API，正确处理CORS至关重要，以确保合法请求得到服务，而未经授权的请求被阻止。
- en: In this recipe, we will explore how to handle CORS using custom middleware in
    FastAPI. This approach allows us to deeply understand the CORS mechanism and gain
    flexibility in customizing the behavior to fit specific requirements.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探讨如何在FastAPI中使用自定义中间件来处理CORS。这种方法使我们能够深入了解CORS机制，并获得灵活性，以适应特定的要求。
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will apply the recipe to the `middleware_project` application. Make sure
    you have the FastAPI application running with at least the `GET /` endpoint already
    set up.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个配方应用到 `middleware_project` 应用程序上。确保你已经运行了FastAPI应用程序，并且至少已经设置了 `GET /`
    端点。
- en: Since the recipe will show how to set up CORS middleware to manage CORS, you
    will need a simple HTML web page that calls our API.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个配方将展示如何设置CORS中间件来管理CORS，你需要一个简单的HTML网页来调用我们的API。
- en: You can create one yourself or download the `cors_page.xhtml` file from the
    project’s GitHub repository. The file is a simple HTML page that sends a request
    to the FastAPI application at `http://localhost:8000/` and displays the response
    on the same page.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自己创建一个，或者从项目的 GitHub 仓库下载 `cors_page.xhtml` 文件。该文件是一个简单的 HTML 页面，它向 `http://localhost:8000/`
    上的 FastAPI 应用程序发送请求，并在同一页面上显示响应。
- en: Before starting the recipe, spin up your FastAPI application by running `uvicorn
    main:app`. To view the page, open `cors_page.xhtml` using a modern browser. Then,
    open the developer console. In most browsers, you can do this by right-clicking
    on the page, selecting **Inspect** from the menu, and then toggling to the **Console**
    tab.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始配方之前，通过运行 `uvicorn main:app` 启动您的 FastAPI 应用程序。要查看页面，使用现代浏览器打开 `cors_page.xhtml`。然后，打开开发者控制台。在大多数浏览器中，您可以通过右键单击页面，从菜单中选择
    **Inspect**，然后切换到 **Console** 标签来做到这一点。
- en: 'On the page, press the **Send CORS Request** button. You should see an error
    message on the command line like the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面上，按 **发送 CORS 请求** 按钮。您应该在命令行上看到如下错误消息：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That means that the call has been blocked by the CORS policy.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着调用已被 CORS 策略阻止。
- en: Let’s start the recipe and see how to fix it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始这个配方，看看如何修复它。
- en: How to do it…
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: In FastAPI, CORS can be handled with a dedicated `CORSMiddleware` class from
    the Starlette library.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FastAPI 中，可以使用来自 Starlette 库的专用 `CORSMiddleware` 类来处理 CORS。
- en: 'Let’s add the middleware to our application in the `main.py` module:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `main.py` 模块中添加中间件：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, rerun the server, open `cors_page.xhtml` again, and try to press the **Send
    CORS Request** button. This time, you see the response message directly on the
    page.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新运行服务器，再次打开 `cors_page.xhtml`，然后尝试按 **发送 CORS 请求** 按钮。这次，您将在页面上直接看到响应消息。
- en: The `allow_origins` parameter specifies the host origin from which the CORS
    should be allowed. If `allow_origins=[*]`, it means that any origin is allowed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`allow_origins` 参数指定了允许 CORS 的主机源。如果 `allow_origins=[*]`，则表示允许任何源。'
- en: The `allow_methods` parameter specifies the HTTP methods that are allowed. By
    default, only `GET` is allowed, and if `allow_methods=[*]`, it means that all
    methods are allowed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`allow_methods` 参数指定了允许的 HTTP 方法。默认情况下，只允许 `GET`，如果 `allow_methods=[*]`，则表示允许所有方法。'
- en: Then, the `allow_headers` parameter specifies the headers that are allowed.
    Similarly, if we use `allow_headers=[*]`, it means that all headers are allowed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`allow_headers` 参数指定了允许的头部。同样，如果我们使用 `allow_headers=[*]`，则表示允许所有头部。
- en: In a production environment, it’s important to carefully evaluate each of these
    parameters to ensure security standards and to make your application run safely.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，仔细评估这些参数对于确保安全标准和使您的应用程序安全运行非常重要。
- en: This is all that’s needed to implement CORS middleware for allowing CORS from
    clients.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是实现允许客户端 CORS 的 CORS 中间件所需的所有内容。
- en: See also
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关信息
- en: 'For more information about CORS, check out the **Mozilla** documentation page:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 CORS 的更多信息，请查看 **Mozilla** 的文档页面：
- en: '*CORS*: [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CORS*: [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)'
- en: 'You can see more about the functionalities and discover other parameters of
    the CORS middleware in FastAPI on the documentation page:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在文档页面上了解更多关于 CORS 中间件的功能以及 FastAPI 中的其他参数：
- en: '*Use* *CORSMiddleware*: [https://fastapi.tiangolo.com/tutorial/cors/#use-corsmiddleware](https://fastapi.tiangolo.com/tutorial/cors/#use-corsmiddleware)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用* *CORSMiddleware*: [https://fastapi.tiangolo.com/tutorial/cors/#use-corsmiddleware](https://fastapi.tiangolo.com/tutorial/cors/#use-corsmiddleware)'
- en: 'You can also have a look at the Starlette documentation page:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以查看 Starlette 的文档页面：
- en: '*CORSMiddleware*: [https://www.starlette.io/middleware/#corsmiddleware](https://www.starlette.io/middleware/#corsmiddleware)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CORSMiddleware*: [https://www.starlette.io/middleware/#corsmiddleware](https://www.starlette.io/middleware/#corsmiddleware)'
- en: Restricting incoming requests from hosts
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制来自主机的请求
- en: In modern web applications, security is paramount. One crucial aspect of security
    is ensuring that your application only processes requests from trusted sources.
    This practice helps to mitigate risks such as **Domain Name System** (**DNS**)
    rebinding attacks, where an attacker tricks a user’s browser into interacting
    with an unauthorized domain.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代网络应用程序中，安全性至关重要。安全性的一个关键方面是确保您的应用程序只处理来自受信任源请求。这种做法有助于减轻诸如 **域名系统** (**DNS**)
    重绑定攻击等风险，攻击者会诱使用户的浏览器与未经授权的域进行交互。
- en: FastAPI provides middleware called `TrustedHostMiddleware`, which allows you
    to specify which hosts are considered trusted. Requests from any other hosts will
    be rejected. This recipe will guide you through setting up and using the `TrustedHostMiddleware`
    class to secure your FastAPI application by accepting requests only from specific
    hosts.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 提供了一个名为 `TrustedHostMiddleware` 的中间件，它允许你指定哪些主机被认为是可信的。来自任何其他主机的请求将被拒绝。本指南将指导你如何设置和使用
    `TrustedHostMiddleware` 类，通过仅接受来自特定主机的请求来保护你的 FastAPI 应用。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will apply the recipe to the `middleware_project` application. The application
    will need to be working with at least one endpoint to test.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个方法应用到 `middleware_project` 应用中。该应用至少需要一个端点来测试。
- en: How to do it…
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现它...
- en: 'Let’s restrict the request to calls coming from localhost. In `main.py`, let’s
    import `TrustedHostMiddleware` and add it to the FastAPI object instance application,
    as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将请求限制为来自本地主机的调用。在 `main.py` 中，让我们导入 `TrustedHostMiddleware` 并将其添加到 FastAPI
    对象实例应用中，如下所示：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To test it, let’s try to refuse a call. Let’s spin up the server by broadcasting
    our service to the network. We can do it by specifying the undefined host address,
    `0.0.0.0`, when running `uvicorn`, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，让我们尝试拒绝一个调用。让我们通过在运行 `uvicorn` 时指定未定义的主机地址 `0.0.0.0` 来启动服务器。如下所示：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will make our application visible to the network.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们的应用对网络可见。
- en: To retrieve the address of your machine within the local network, you can run
    `ipconfig` on Windows or `ip addr` on Linux or macOS.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取你的机器在本地网络中的地址，你可以在 Windows 上运行 `ipconfig`，在 Linux 或 macOS 上运行 `ip addr`。
- en: 'From another device connected to the same local network as the machine running
    our FastAPI application (such as a smartphone), open a browser and enter `http://<your
    local address>:8000`. If everything is correctly set up, you will see the following
    message in the browser:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从连接到运行我们的 FastAPI 应用的同一本地网络的另一台设备（例如智能手机）打开浏览器，输入 `http://<你的本地地址>:8000`。如果一切设置正确，你将在浏览器中看到以下消息：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'While on the machine running the FastAPI server, you will see a log message
    like the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在运行 FastAPI 服务器的机器上时，你会看到如下类似的日志消息：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is all you need to set up middleware to prevent your application from being
    reached by undesired hosts.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你设置中间件以防止你的应用被不受欢迎的主机访问所需的所有内容。
- en: See also
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关链接
- en: 'You can learn more about `TrustedHostMiddleware` on the FastAPI documentation
    page:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 FastAPI 文档页面上了解更多关于 `TrustedHostMiddleware` 的信息：
- en: '*TrustedHostMiddleware*: [https://fastapi.tiangolo.com/advanced/middleware/#trustedhostmiddleware](https://fastapi.tiangolo.com/advanced/middleware/#trustedhostmiddleware)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TrustedHostMiddleware*: [https://fastapi.tiangolo.com/advanced/middleware/#trustedhostmiddleware](https://fastapi.tiangolo.com/advanced/middleware/#trustedhostmiddleware)'
- en: 'Since `TrustedHostMiddleware` is defined in the Starlette library, you can
    also find it in the Starlette documentation at the following link:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `TrustedHostMiddleware` 定义在 Starlette 库中，你还可以在以下链接的 Starlette 文档中找到它：
- en: '*TrustedHostMiddleware*: [https://www.starlette.io/middleware/#trustedhostmiddleware](https://www.starlette.io/middleware/#trustedhostmiddleware)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TrustedHostMiddleware*: [https://www.starlette.io/middleware/#trustedhostmiddleware](https://www.starlette.io/middleware/#trustedhostmiddleware)'
- en: Implementing webhooks
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Webhooks
- en: '**Webhooks** play a crucial role in modern web development by enabling different
    systems to communicate and respond to events in real time. They are essentially
    HTTP callbacks triggered by specific events in one system, which then send a message
    or payload to another system. This asynchronous event-driven architecture allows
    for seamless integration with third-party services, real-time notifications, and
    automated workflows. Understanding how to implement webhooks effectively will
    empower you to build more interactive and responsive applications.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**Webhooks** 在现代网络开发中发挥着至关重要的作用，通过使不同的系统能够实时通信和响应事件。它们本质上是由一个系统中的特定事件触发的 HTTP
    回调，随后将消息或有效负载发送到另一个系统。这种异步事件驱动架构允许与第三方服务无缝集成、实时通知和自动化工作流程。了解如何有效地实现 Webhooks 将使你能够构建更互动和响应式的应用。'
- en: In this recipe, we will see how to create webhooks in FastAPI. We will create
    a webhook that notifies the webhook subscribers for each request of the API, acting
    like a monitoring system. By the end of this recipe, you will be able to implement
    a robust webhook system in your FastAPI application, facilitating real-time communication
    and integration with other services.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看到如何在FastAPI中创建webhooks。我们将创建一个webhook，它会通知每个API请求的webhook订阅者，就像一个监控系统。到这个配方的最后，您将能够实现一个健壮的webhook系统，在您的FastAPI应用程序中促进实时通信和与其他服务的集成。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To set up the webhook for sending requests to the subscriber, we will use custom
    ASGI middleware. Please ensure that you have already followed the *Creating custom
    ASGI middleware* recipe. We will be continuing our work on the `middleware_project`
    API. However, you will find guidelines on how to implement your webhook that can
    be easily adapted to the specific needs of your project.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置用于向订阅者发送请求的webhook，我们将使用自定义ASGI中介件。请确保您已经遵循了*创建自定义ASGI中介件*的配方。我们将继续在`middleware_project`
    API上工作。但是，您将找到如何实现您的webhook的指南，这些指南可以轻松地适应您项目的特定需求。
- en: 'If you are starting a new project from scratch, make sure to install the `fastapi`
    package with `uvicorn` in your environment. You can do this using `pip`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是从头开始创建一个新项目，请确保在您的环境中安装了带有`uvicorn`的`fastapi`包。您可以使用`pip`来完成此操作：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once you have the packages, we can start the recipe.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了这些包，我们就可以开始这个配方。
- en: How to do it…
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To build a webhook system in our API, we will need to do the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的API中构建webhook系统，我们需要做以下几步：
- en: Set up the URL registration system.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置URL注册系统。
- en: Implement the webhook callbacks.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现webhook回调。
- en: Document the webhook.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录webhook。
- en: Let’s go through the implementation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现来了解。
- en: Setting up the URL registration system
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置URL注册系统
- en: A webhook call will send an HTTP request to the list of URLs registered to the
    webhook. The API will require a URL registration system. This can be achieved
    by creating a dedicated endpoint that will store the URL in a stateful system,
    such as a database. However, for demonstration purposes, we will store the URLs
    in the application state, which might also be a good choice for small applications.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一个webhook调用将向注册到webhook的URL列表发送HTTP请求。API将需要一个URL注册系统。这可以通过创建一个专门的端点来实现，该端点将URL存储在有状态系统中，例如数据库。但是，为了演示目的，我们将URL存储在应用程序状态中，这对于小型应用程序来说可能也是一个不错的选择。
- en: 'Let’s create it by going through the following steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤来创建它：
- en: 'In `main.py`, let’s create the lifespan context manager to store the registered
    URLs:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.py`中，让我们创建一个生命周期上下文管理器来存储已注册的URL：
- en: '[PRE32]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s pass the lifespan as an argument to the FastAPI object, as follows:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将生命周期作为一个参数传递给FastAPI对象，如下所示：
- en: '[PRE33]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we can create the endpoint to register the URL, as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个端点来注册URL，如下所示：
- en: '[PRE34]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The endpoint will accept a text string in the body. If the `http` or `https`
    protocol is missing in the string, an `"http://"` string will be prepended to
    the URL before being stored.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 端点将接受正文中的文本字符串。如果字符串中缺少`http`或`https`协议，将在存储之前将`"http://"`字符串添加到URL前面。
- en: You have just implemented the URL registration system. Now, let’s continue to
    implement the webhook callbacks.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚实现了URL注册系统。现在，让我们继续实现webhook回调。
- en: Implementing the webhook callbacks
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现webhook回调
- en: 'After setting up the registration system, we can begin creating the webhook’s
    calls. As previously stated, this particular webhook will alert subscribers for
    every API call. We’ll utilize this information to develop specialized middleware
    that will handle the calls. Let’s do it by following these steps:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置注册系统之后，我们可以开始创建webhook的调用。如前所述，这个特定的webhook将在每次API调用时提醒订阅者。我们将利用这些信息来开发专门的中介件来处理调用。让我们按照以下步骤进行：
- en: 'Let’s create a new module in the `middleware` folder called `webhook.py` and
    define the event to communicate with the subscribers:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`middleware`文件夹中创建一个新的模块，名为`webhook.py`，并定义与订阅者通信的事件：
- en: '[PRE35]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we define a coroutine that will be used to make the requests to the subscriber
    URLs, as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个协程，它将被用来向订阅者URL发送请求，如下所示：
- en: '[PRE36]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The client sends a request to the URL. If the request fails, a message is printed
    to the terminal.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 客户端向URL发送请求。如果请求失败，将在终端打印一条消息。
- en: 'We then define the middleware that will intercept the request. We start with
    the imports, as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们然后定义将拦截请求的中介件。我们首先进行导入，如下所示：
- en: '[PRE37]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We then add the `WebhookSenderMiddleware` class, as follows
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接着，我们添加`WebhookSenderMiddleware`类，如下所示
- en: '[PRE38]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will filter only the HTTP requests, as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将仅过滤HTTP请求，如下所示：
- en: '[PRE39]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We continue in the `same __call__` function by defining the `event` object
    to pass to the webhook subscribers:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续在`same __call__`函数中定义要传递给webhook订阅者的`event`对象：
- en: '[PRE40]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we iterate the calls over the URLs by running the `send_event_to_url`
    coroutine, as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过运行`send_event_to_url`协程来遍历URL调用，如下所示：
- en: '[PRE41]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We finalize the method by returning the modified `receive` function to the
    application:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过将修改后的`receive`函数返回给应用程序来最终化该方法：
- en: '[PRE42]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We have just defined the middleware that will make the calls.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们刚刚定义了将执行调用的中间件。
- en: 'Now we need to import the `WebhookSenderMiddleWare` middleware in the application.
    We can do this inside `main.py` as follows:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要在应用程序中导入`WebhookSenderMiddleWare`中间件。我们可以在`main.py`中这样做：
- en: '[PRE43]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The application will now include our middleware to handle the webhook callbacks.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用程序现在将包括我们的中间件来处理webhook回调。
- en: That is all you need to implement a complete webhook within your FastAPI application.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你在FastAPI应用程序中实现完整webhook所需的所有内容。
- en: Documenting the webhook
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录webhook
- en: It is important to provide API users with documentation on how the webhook functions.
    FastAPI allows us to document a webhook in the OpenAPI documentation.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 向API用户提供关于webhook如何工作的文档是很重要的。FastAPI允许我们在OpenAPI文档中记录webhook。
- en: 'To accomplish this, you need to create a function with an empty body and declare
    it as a webhook endpoint. You can do it in `main.py` as well:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，你需要创建一个空体的函数，并将其声明为webhook端点。你可以在`main.py`中这样做：
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can also provide an example of the body content by adding specifications
    to the `Event` class in the `middleware/webhook.py` module, as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在`middleware/webhook.py`模块中的`Event`类中添加规范来提供一个示例的正文内容，如下所示：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: $ python ./http_server.py
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: $ python ./http_server.py
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
