- en: Chapter 1. Sockets, IPv4, and Simple Client/Server Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章：套接字、IPv4和简单的客户端/服务器编程
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下菜谱：
- en: Printing your machine's name and IPv4 address
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印你的机器名称和IPv4地址
- en: Retrieving a remote machine's IP address
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取远程机器的IP地址
- en: Converting an IPv4 address to different formats
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将IPv4地址转换为不同的格式
- en: Finding a service name, given the port and protocol
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据端口号和协议查找服务名
- en: Converting integers to and from host to network byte order
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将整数从主机字节序转换为网络字节序，反之亦然
- en: Setting and getting the default socket timeout
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和获取默认套接字超时
- en: Handling socket errors gracefully
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优雅地处理套接字错误
- en: Modifying a socket's send/receive buffer size
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改套接字的发送/接收缓冲区大小
- en: Changing a socket to the blocking/non-blocking mode
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将套接字改为阻塞/非阻塞模式
- en: Reusing socket addresses
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新使用套接字地址
- en: Printing the current time from the Internet time server
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从互联网时间服务器打印当前时间
- en: Writing a SNTP client
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写SNTP客户端
- en: Writing a simple echo client/server application
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写简单的回声客户端/服务器应用程序
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'This chapter introduces Python''s core networking library through some simple
    recipes. Python''s `socket` module has both class-based and instances-based utilities.
    The difference between a class-based and instance-based method is that the former
    doesn''t need an instance of a socket object. This is a very intuitive approach.
    For example, in order to print your machine''s IP address, you don''t need a socket
    object. Instead, you can just call the socket''s class-based methods. On the other
    hand, if you need to send some data to a server application, it is more intuitive
    that you create a socket object to perform that explicit operation. The recipes
    presented in this chapter can be categorized into three groups as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过一些简单的菜谱介绍了Python的核心网络库。Python的`socket`模块既有基于类的工具，也有基于实例的工具。基于类的和基于实例的方法之间的区别在于前者不需要套接字对象的实例。这是一个非常直观的方法。例如，为了打印你的机器的IP地址，你不需要套接字对象。相反，你只需调用套接字的基于类的方法。另一方面，如果你需要向服务器应用程序发送一些数据，创建一个套接字对象来执行该显式操作会更直观。本章中提供的菜谱可以分为以下三个组：
- en: In the first few recipes, the class-based utilities have been used in order
    to extract some useful information about host, network, and any target service.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前几个菜谱中，已经使用了基于类的工具来提取有关主机、网络和任何目标服务的有用信息。
- en: After that, some more recipes have been presented using the instance-based utilities.
    Some common socket tasks, including manipulating the socket timeout, buffer size,
    blocking mode, and so on, have been demonstrated.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，使用基于实例的工具提供了一些更多的菜谱。演示了一些常见的套接字任务，包括操作套接字超时、缓冲区大小、阻塞模式等等。
- en: Finally, both class-based and instance-based utilities have been used to construct
    some clients, which perform some practical tasks, for example, synchronizing the
    machine time with an Internet server or writing a generic client/server script.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，使用基于类的和基于实例的工具构建了一些客户端，它们执行一些实际的任务，例如将机器时间与互联网服务器同步或编写通用的客户端/服务器脚本。
- en: You can use these demonstrated approaches to write your own client/server application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些演示的方法来编写你自己的客户端/服务器应用程序。
- en: Printing your machine's name and IPv4 address
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印你的机器名称和IPv4地址
- en: Sometimes, you need to quickly discover some information about your machine,
    for example, the host name, IP address, number of network interfaces, and so on.
    This is very easy to achieve using Python scripts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要快速查找有关你的机器的一些信息，例如主机名、IP地址、网络接口数量等等。使用Python脚本实现这一点非常简单。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You need to install Python on your machine before you start coding. Python
    comes preinstalled in most of the Linux distributions. For Microsoft Windows operating
    system, you can download binaries from the Python website: [http://www.python.org/download/](http://www.python.org/download/)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前，你需要在你的机器上安装Python。Python在大多数Linux发行版中都是预安装的。对于Microsoft Windows操作系统，你可以从Python网站下载二进制文件：[http://www.python.org/download/](http://www.python.org/download/)
- en: 'You may consult the documentation of your OS to check and review your Python
    setup. After installing Python on your machine, you can try opening the Python
    interpreter from the command line by typing `python`. This will show the interpreter
    prompt, `>>>`, which should be similar to the following output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查阅你操作系统的文档，检查和审查你的Python设置。在你机器上安装Python之后，你可以通过在命令行中键入`python`来尝试打开Python解释器。这将显示解释器提示符`>>>`，应该类似于以下输出：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: As this recipe is very short, you can try this in the Python interpreter interactively.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个菜谱非常简短，您可以在Python解释器中交互式地尝试它。
- en: 'First, we need to import the Python `socket` library with the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用以下命令导入Python的`socket`库：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we call the `gethostname()` method from the `socket` library and store
    the result in a variable as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`socket`库中的`gethostname()`方法，并将结果存储在变量中，如下所示：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The entire activity can be wrapped in a free-standing function, `print_machine_info()`,
    which uses the built-in socket class methods.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 整个活动可以封装在一个独立的函数`print_machine_info()`中，它使用内置的socket类方法。
- en: We call our function from the usual Python `__main__` block. During runtime,
    Python assigns values to some internal variables such as `__name__`. In this case,
    `__name__` refers to the name of the calling process. When running this script
    from the command line, as shown in the following command, the name will be `__main__`,
    but it will be different if the module is imported from another script. This means
    that when the module is called from the command line, it will automatically run
    our `print_machine_info` function; however, when imported separately, the user
    will need to explicitly call the function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从通常的Python `__main__`块调用我们的函数。在运行时，Python将值分配给一些内部变量，例如`__name__`。在这种情况下，`__name__`指的是调用进程的名称。当从命令行运行此脚本时，如以下命令所示，名称将是`__main__`，但如果模块是从另一个脚本导入的，则名称将不同。这意味着当模块从命令行调用时，它将自动运行我们的`print_machine_info`函数；然而，当单独导入时，用户需要显式调用该函数。
- en: 'Listing 1.1 shows how to get our machine info, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.1显示了如何获取我们的机器信息，如下所示：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In order to run this recipe, you can use the provided source file from the
    command line as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行这个菜谱，您可以使用提供的源文件从命令行如下操作：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On my machine, the following output is shown:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，以下输出如下：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This output will be different on your machine depending on the system's host
    configuration.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出将取决于您机器的系统主机配置而有所不同。
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The import socket statement imports one of Python''s core networking libraries.
    Then, we use the two utility functions, `gethostname()` and `gethostbyname(host_name)`.
    You can type `help(socket.gethostname)` to see the online help information from
    within the command line. Alternately, you can type the following address in your
    web browser at [http://docs.python.org/3/library/socket.html](http://docs.python.org/3/library/socket.html).
    You can refer to the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`import socket`语句导入Python的核心网络库之一。然后，我们使用两个实用函数，`gethostname()`和`gethostbyname(host_name)`。您可以在命令行中输入`help(socket.gethostname)`来查看在线帮助信息。或者，您可以在您的网络浏览器中输入以下地址：[http://docs.python.org/3/library/socket.html](http://docs.python.org/3/library/socket.html)。您可以参考以下命令：'
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first function takes no parameter and returns the current or localhost name.
    The second function takes a single `hostname` parameter and returns its IP address.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数不接受任何参数，并返回当前或本地主机名。第二个函数接受一个`hostname`参数，并返回其IP地址。
- en: Retrieving a remote machine's IP address
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取远程机器的IP地址
- en: Sometimes, you need to translate a machine's hostname into its corresponding
    IP address, for example, a quick domain name lookup. This recipe introduces a
    simple function to do that.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您需要将一台机器的主机名转换为其对应的IP地址，例如，进行快速域名查找。这个菜谱介绍了一个简单的函数来完成这个任务。
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: If you need to know the IP address of a remote machine, you can use a built-in
    library function, `gethostbyname()`. In this case, you need to pass the remote
    hostname as its parameter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要知道远程机器的IP地址，您可以使用内置库函数`gethostbyname()`。在这种情况下，您需要将远程主机名作为其参数传递。
- en: In this case, we need to call the `gethostbyname()` class function. Let's have
    a look inside this short code snippet.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要调用`gethostbyname()`类函数。让我们看看这个简短代码片段的内部。
- en: 'Listing 1.2 shows how to get a remote machine''s IP address as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.2显示了如何获取远程机器的IP地址，如下所示：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you run the preceding code it gives the following output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行前面的代码，它将给出以下输出：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe wraps the `gethostbyname()` method inside a user-defined function
    called `get_remote_machine_info()`. In this recipe, we introduced the notion of
    exception handling. As you can see, we wrapped the main function call inside a
    `try-except` block. This means that if some error occurs during the execution
    of this function, this error will be dealt with by this `try-except` block.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将`gethostbyname()`方法封装在一个用户定义的函数`get_remote_machine_info()`中。在这个配方中，我们介绍了异常处理的概念。正如你所看到的，我们将主要函数调用封装在一个`try-except`块中。这意味着如果在执行此函数期间发生某些错误，此错误将由这个`try-except`块处理。
- en: 'For example, let''s change the `remote_host` value and replace [www.python.org](http://www.python.org)
    with something non-existent, for example, `www.pytgo.org`. Now run the following
    command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们更改`remote_host`值，并将[www.python.org](http://www.python.org)替换为不存在的某个内容，例如`www.pytgo.org`。现在运行以下命令：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `try-except` block catches the error and shows the user an error message
    that there is no IP address associated with the hostname, `www.pytgo.org`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`try-except`块捕获错误并向用户显示错误消息，指出没有与主机名`www.pytgo.org`关联的IP地址。'
- en: Converting an IPv4 address to different formats
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将IPv4地址转换为不同的格式
- en: When you would like to deal with low-level network functions, sometimes, the
    usual string notation of IP addresses are not very useful. They need to be converted
    to the packed 32-bit binary formats.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要处理低级网络功能时，有时，IP地址的常规字符串表示法并不很有用。它们需要转换为32位的打包二进制格式。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The Python socket library has utilities to deal with the various IP address
    formats. Here, we will use two of them: `inet_aton()` and `inet_ntoa()`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Python套接字库有处理各种IP地址格式的实用工具。在这里，我们将使用其中的两个：`inet_aton()`和`inet_ntoa()`。
- en: Let us create the `convert_ip4_address()` function, where `inet_aton()` and
    `inet_ntoa()` will be used for the IP address conversion. We will use two sample
    IP addresses, `127.0.0.1` and `192.168.0.1`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`convert_ip4_address()`函数，其中将使用`inet_aton()`和`inet_ntoa()`进行IP地址转换。我们将使用两个示例IP地址，`127.0.0.1`和`192.168.0.1`。
- en: 'Listing 1.3 shows `ip4_address_conversion` as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.3显示了`ip4_address_conversion`如下：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, if you run this recipe, you will see the following output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行这个配方，你会看到以下输出：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, the two IP addresses have been converted from a string to a
    32-bit packed format using a `for-in` statement. Additionally, the Python `hexlify`
    function is called from the `binascii` module. This helps to represent the binary
    data in a hexadecimal format.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，两个IP地址已经使用`for-in`语句从字符串转换为32位打包格式。此外，还调用了来自`binascii`模块的Python `hexlify`函数。这有助于以十六进制格式表示二进制数据。
- en: Finding a service name, given the port and protocol
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据端口和协议查找服务名称
- en: If you would like to discover network services, it may be helpful to determine
    what network services run on which ports using either the TCP or UDP protocol.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要发现网络服务，确定使用TCP或UDP协议在哪些端口上运行哪些网络服务可能会有所帮助。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you know the port number of a network service, you can find the service name
    using the `getservbyport()` socket class function from the socket library. You
    can optionally give the protocol name when calling this function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道网络服务的端口号，你可以使用套接字库中的`getservbyport()`套接字类函数来查找服务名称。在调用此函数时，你可以选择性地提供协议名称。
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let us define a `find_service_name()` function, where the `getservbyport()`
    socket class function will be called with a few ports, for example, `80, 25`.
    We can use Python's `for-in` loop construct.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个`find_service_name()`函数，其中将使用`getservbyport()`套接字类函数调用几个端口，例如`80, 25`。我们可以使用Python的`for-in`循环结构。
- en: 'Listing 1.4 shows `finding_service_name` as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.4显示了`finding_service_name`如下：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you run this script, you will see the following output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此脚本，你会看到以下输出：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, `for-in` statement is used to iterate over a sequence of variables.
    So for each iteration we use one IP address to convert them in their packed and
    unpacked format.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，使用`for-in`语句遍历一系列变量。因此，对于每次迭代，我们使用一个IP地址，以打包和未打包的格式转换它们。
- en: Converting integers to and from host to network byte order
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将整数从主机字节序转换为网络字节序以及反向转换
- en: If you ever need to write a low-level network application, it may be necessary
    to handle the low-level data transmission over the wire between two machines.
    This operation requires some sort of conversion of data from the native host operating
    system to the network format and vice versa. This is because each one has its
    own specific representation of data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要编写一个低级网络应用程序，可能需要处理两个机器之间通过线缆的低级数据传输。这种操作需要将数据从本地主机操作系统转换为网络格式，反之亦然。这是因为每个都有自己的数据特定表示。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Python's socket library has utilities for converting from a network byte order
    to host byte order and vice versa. You may want to become familiar with them,
    for example, `ntohl()`/`htonl()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Python的socket库提供了从网络字节序转换为主机字节序以及相反方向的工具。你可能需要熟悉它们，例如，`ntohl()`/`htonl()`。
- en: Let us define the `convert_integer()` function, where the `ntohl()`/`htonl()`
    socket class functions are used to convert IP address formats.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个`convert_integer()`函数，其中使用`ntohl()`/`htonl()` socket类函数来转换IP地址格式。
- en: 'Listing 1.5 shows `integer_conversion` as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.5显示了`integer_conversion`如下：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you run this recipe, you will see the following output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个菜谱，你会看到以下输出：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here, we take an integer and show how to convert it between network and host
    byte orders. The `ntohl()` socket class function converts from the network byte
    order to host byte order in a long format. Here, `n` represents network and `h`
    represents host; `l` represents long and `s` represents short, that is 16-bit.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们取一个整数并展示如何将其在网络字节序和主机字节序之间转换。`ntohl()` socket类函数将网络字节序从长格式转换为主机字节序。在这里，`n`代表网络，`h`代表主机；`l`代表长，`s`代表短，即16位。
- en: Setting and getting the default socket timeout
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和获取默认socket超时
- en: Sometimes, you need to manipulate the default values of certain properties of
    a socket library, for example, the socket timeout.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要操作socket库某些属性的默认值，例如，socket超时。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: You can make an instance of a socket object and call a `gettimeout()` method
    to get the default timeout value and the `settimeout()` method to set a specific
    timeout value. This is very useful in developing custom server applications.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个socket对象实例，并调用`gettimeout()`方法来获取默认超时值，以及调用`settimeout()`方法来设置特定的超时值。这在开发自定义服务器应用程序时非常有用。
- en: We first create a socket object inside a `test_socket_timeout()` function. Then,
    we can use the getter/setter instance methods to manipulate timeout values.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在`test_socket_timeout()`函数内部创建一个socket对象。然后，我们可以使用getter/setter实例方法来操作超时值。
- en: 'Listing 1.6 shows `socket_timeout` as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.6显示了`socket_timeout`如下：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After running the preceding script, you can see how this modifies the default
    socket timeout as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的脚本后，你可以看到以下修改默认socket超时的方式：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this code snippet, we have first created a socket object by passing the socket
    family and socket type as the first and second arguments of the socket constructor.
    Then, you can get the socket timeout value by calling `gettimeout()` and alter
    the value by calling the `settimeout()` method. The timeout value passed to the
    `settimeout()` method can be in seconds (non-negative float) or `None`. This method
    is used for manipulating the blocking-socket operations. Setting a timeout of
    `None` disables timeouts on socket operations.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们首先通过将socket家族和socket类型作为socket构造函数的第一个和第二个参数传递来创建一个socket对象。然后，你可以通过调用`gettimeout()`来获取socket超时值，并通过调用`settimeout()`方法来更改该值。传递给`settimeout()`方法的超时值可以是秒（非负浮点数）或`None`。此方法用于操作阻塞-socket操作。将超时设置为`None`将禁用socket操作的超时。
- en: Handling socket errors gracefully
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优雅地处理socket错误
- en: In any networking application, it is very common that one end is trying to connect,
    but the other party is not responding due to networking media failure or any other
    reason. The Python socket library has an elegant method of handing these errors
    via the `socket.error` exceptions. In this recipe, a few examples are presented.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何网络应用程序中，一端尝试连接，而另一端由于网络媒体故障或其他原因没有响应是非常常见的情况。Python的socket库通过`socket.error`异常提供了一个优雅的方法来处理这些错误。在这个菜谱中，展示了几个示例。
- en: How to do it...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let us create a few try-except code blocks and put one potential error type
    in each block. In order to get a user input, the `argparse` module can be used.
    This module is more powerful than simply parsing command-line arguments using
    `sys.argv`. In the try-except blocks, put typical socket operations, for example,
    create a socket object, connect to a server, send data, and wait for a reply.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些 try-except 代码块，并在每个块中放入一个潜在的错误类型。为了获取用户输入，可以使用 `argparse` 模块。此模块比仅使用
    `sys.argv` 解析命令行参数更强大。在 try-except 块中，可以放置典型的套接字操作，例如创建套接字对象、连接到服务器、发送数据和等待回复。
- en: The following recipe illustrates the concepts in a few lines of code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码展示了如何用几行代码说明这些概念。
- en: 'Listing 1.7 shows `socket_errors` as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.7 展示了 `socket_errors` 如下：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In Python, passing command-line arguments to a script and parsing them in the
    script can be done using the `argparse` module. This is available in Python 2.7\.
    For earlier versions of Python, this module is available separately in **Python
    Package Index** (**PyPI**). You can install this via `easy_install` or `pip`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，可以使用 `argparse` 模块将命令行参数传递给脚本并在脚本中解析它们。这个模块在 Python 2.7 中可用。对于更早的
    Python 版本，此模块可以在 **Python 包索引**（**PyPI**）中单独安装。你可以通过 `easy_install` 或 `pip` 来安装它。
- en: 'In this recipe, three arguments are set up: a hostname, port number, and filename.
    The usage of this script is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，设置了三个参数：主机名、端口号和文件名。此脚本的用法如下：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you try with a non-existent host, this script will print an address error
    as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用一个不存在的宿主，此脚本将打印出如下地址错误：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If there is no service on a specific port and if you try to connect to that
    port, then this will throw a connection timeout error as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果特定端口没有服务，并且你尝试连接到该端口，那么这将引发连接超时错误，如下所示：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will return the following error since the host, [www.python.org](http://www.python.org),
    is not listening on port 8080:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于主机 [www.python.org](http://www.python.org) 没有监听 8080 端口，这将返回以下错误：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, if you send an arbitrary request to a correct request to a correct
    port, the error may not be caught in the application level. For example, running
    the following script returns no error, but the HTML output tells us what''s wrong
    with this script:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你向正确的端口发送一个任意请求，错误可能不会被应用程序级别捕获。例如，运行以下脚本不会返回错误，但 HTML 输出告诉我们这个脚本有什么问题：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding example, four try-except blocks have been used. All blocks
    use `socket.error` except the second block, which uses `socket.gaierror`. This
    is used for address-related errors. There are two other types of exceptions: `socket.herror`
    is used for legacy C API, and if you use the `settimeout()` method in a socket,
    `socket.timeout` will be raised when a timeout occurs on that socket.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，使用了四个 try-except 块。除了第二个块使用 `socket.gaierror` 外，所有块都使用 `socket.error`。`socket.gaierror`
    用于地址相关错误。还有两种其他类型的异常：`socket.herror` 用于旧版 C API，如果你在套接字上使用 `settimeout()` 方法，当该套接字发生超时时，将引发
    `socket.timeout`。
- en: Modifying socket's send/receive buffer sizes
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改套接字的发送/接收缓冲区大小
- en: The default socket buffer size may not be suitable in many circumstances. In
    such circumstances, you can change the default socket buffer size to a more suitable
    value.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 默认套接字缓冲区大小在很多情况下可能不合适。在这种情况下，可以将默认套接字缓冲区大小更改为更合适的值。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let us manipulate the default socket buffer size using a socket object's `setsockopt()`
    method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用套接字对象的 `setsockopt()` 方法来调整默认套接字缓冲区大小。
- en: 'First, define two constants: `SEND_BUF_SIZE`/`RECV_BUF_SIZE` and then wrap
    a socket instance''s call to the `setsockopt()` method in a function. It is also
    a good idea to check the value of the buffer size before modifying it. Note that
    we need to set up the send and receive buffer size separately.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义两个常量：`SEND_BUF_SIZE`/`RECV_BUF_SIZE`，然后在函数中包装套接字实例对 `setsockopt()` 方法的调用。在修改之前检查缓冲区大小也是一个好主意。请注意，我们需要分别设置发送和接收缓冲区大小。
- en: 'Listing 1.8 shows how to modify socket send/receive buffer sizes as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.8 展示了如何修改套接字的发送/接收缓冲区大小如下：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you run the preceding script, it will show the changes in the socket''s
    buffer size. The following output may be different on your machine depending on
    your operating system''s local settings:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的脚本，它将显示套接字缓冲区大小的变化。以下输出可能因操作系统的本地设置而异：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You can call the `getsockopt()` and `setsockopt()` methods on a socket object
    to retrieve and modify the socket object''s properties respectively. The `setsockopt()`
    method takes three arguments: `level`, `optname`, and `value`. Here, `optname`
    takes the option name and `value` is the corresponding value of that option. For
    the first argument, the needed symbolic constants can be found in the socket module
    (`SO_*etc.`).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在套接字对象上调用`getsockopt()`和`setsockopt()`方法来分别检索和修改套接字对象的属性。`setsockopt()`方法接受三个参数：`level`、`optname`和`value`。在这里，`optname`接受选项名称，`value`是相应选项的值。对于第一个参数，所需的符号常量可以在套接字模块（`SO_*etc.`）中找到。
- en: Changing a socket to the blocking/non-blocking mode
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将套接字转换为阻塞/非阻塞模式
- en: By default, TCP sockets are placed in a blocking mode. This means the control
    is not returned to your program until some specific operation is complete. For
    example, if you call the `connect()` API, the connection blocks your program until
    the operation is complete. On many occasions, you don't want to keep your program
    waiting forever, either for a response from the server or for any error to stop
    the operation. For example, when you write a web browser client that connects
    to a web server, you should consider a stop functionality that can cancel the
    connection process in the middle of this operation. This can be achieved by placing
    the socket in the non-blocking mode.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，TCP套接字被置于阻塞模式。这意味着控制权不会返回到你的程序，直到某个特定操作完成。例如，如果你调用`connect()` API，连接会阻塞你的程序直到操作完成。在许多情况下，你不想让程序永远等待，无论是等待服务器的响应还是等待任何错误来停止操作。例如，当你编写一个连接到Web服务器的Web浏览器客户端时，你应该考虑一个可以在操作过程中取消连接过程的功能。这可以通过将套接字置于非阻塞模式来实现。
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let us see what options are available under Python. In Python, a socket can
    be placed in the blocking or non-blocking mode. In the non-blocking mode, if any
    call to API, for example, `send()` or `recv()`, encounters any problem, an error
    will be raised. However, in the blocking mode, this will not stop the operation.
    We can create a normal TCP socket and experiment with both the blocking and non-blocking
    operations.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Python中可用的选项。在Python中，套接字可以被置于阻塞或非阻塞模式。在非阻塞模式下，如果任何API调用，例如`send()`或`recv()`，遇到任何问题，将会引发错误。然而，在阻塞模式下，这不会停止操作。我们可以创建一个普通的TCP套接字，并实验阻塞和非阻塞操作。
- en: In order to manipulate the socket's blocking nature, we need to create a socket
    object first.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了操纵套接字的阻塞特性，我们首先需要创建一个套接字对象。
- en: We can then call `setblocking(1)` to set up blocking or `setblocking(0)` to
    unset blocking. Finally, we bind the socket to a specific port and listen for
    incoming connections.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以调用`setblocking(1)`来设置阻塞或`setblocking(0)`来取消阻塞。最后，我们将套接字绑定到特定端口并监听传入的连接。
- en: 'Listing 1.9 shows how the socket changes to blocking or non-blocking mode as
    follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.9显示了套接字如何转换为阻塞或非阻塞模式，如下所示：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you run this recipe, it will launch a trivial server that has the blocking
    mode enabled as shown in the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个菜谱，它将启动一个具有阻塞模式启用的简单服务器，如下面的命令所示：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we enable blocking on a socket by setting the value `1` in the
    `setblocking()` method. Similarly, you can unset the value `0` in this method
    to make it non-blocking.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们通过在`setblocking()`方法中将值设置为`1`来在套接字上启用阻塞。同样，你可以在该方法中将值`0`取消设置，使其变为非阻塞。
- en: This feature will be reused in some later recipes, where its real purpose will
    be elaborated.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性将在一些后续的菜谱中重用，其真正目的将在那里详细阐述。
- en: Reusing socket addresses
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复使用套接字地址
- en: You want to run a socket server always on a specific port even after it is closed
    intentionally or unexpectedly. This is useful in some cases where your client
    program always connects to that specific server port. So, you don't need to change
    the server port.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望套接字服务器始终在特定的端口上运行，即使它在有意或意外关闭后也是如此。在某些情况下，如果你的客户端程序始终连接到该特定服务器端口，这很有用。因此，你不需要更改服务器端口。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'If you run a Python socket server on a specific port and try to rerun it after
    closing it once, you won''t be able to use the same port. It will usually throw
    an error like the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个特定的端口上运行Python套接字服务器，并在关闭后尝试重新运行它，你将无法使用相同的端口。它通常会抛出如下错误：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The remedy to this problem is to enable the socket reuse option, `SO_REUSEADDR`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是为套接字启用重用选项`SO_REUSEADDR`。
- en: After creating a socket object, we can query the state of address reuse, say
    an old state. Then, we call the `setsockopt()` method to alter the value of its
    address reuse state. Then, we follow the usual steps of binding to an address
    and listening for incoming client connections. In this example, we catch the `KeyboardInterrupt`
    exception so that if you issue *Ctrl* + *C*, then the Python script gets terminated
    without showing any exception message.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建套接字对象后，我们可以查询地址重用的状态，比如说一个旧状态。然后，我们调用`setsockopt()`方法来改变其地址重用状态。然后，我们遵循绑定到地址和监听传入客户端连接的常规步骤。在这个例子中，我们捕获`KeyboardInterrupt`异常，这样如果您按下*Ctrl*
    + *C*，Python脚本将不会显示任何异常消息而终止。
- en: 'Listing 1.10 shows how to reuse socket addresses as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.10显示了如何如下重用套接字地址：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output from this recipe will be similar to the following command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的输出将类似于以下命令：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You may run this script from one console window and try to connect to this server
    from another console window by typing `telnet localhost 8282`. After you close
    the server program, you can rerun it again on the same port. However, if you comment
    out the line that sets the `SO_REUSEADDR`, the server will not run for the second
    time.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从一个控制台窗口运行此脚本，并尝试从另一个控制台窗口通过键入`telnet localhost 8282`连接到该服务器。在关闭服务器程序后，您可以在同一端口上再次运行它。然而，如果您注释掉设置`SO_REUSEADDR`的行，服务器将无法再次运行。
- en: Printing the current time from the Internet time server
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从互联网时间服务器打印当前时间
- en: Many programs rely on the accurate machine time, such as the `make` command
    in UNIX. Your machine time may be different and need synchronizing with another
    time server in your network.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序依赖于准确的机器时间，例如UNIX中的`make`命令。您的机器时间可能不同，需要与网络中的另一个时间服务器同步。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to synchronize your machine time with one of the Internet time servers,
    you can write a Python client for that. For this, `ntplib` will be used. Here,
    the client/server conversation will be done using **Network Time Protocol** (**NTP**).
    If `ntplib` is not installed on your machine, you can get it from `PyPI` with
    the following command using `pip` or `easy_install`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将您的机器时间与互联网上的一个时间服务器同步，您可以编写一个Python客户端。为此，将使用`ntplib`。在这里，客户端/服务器对话将使用**网络时间协议**（**NTP**）进行。如果您的机器上未安装`ntplib`，您可以使用以下命令通过`pip`或`easy_install`从`PyPI`获取它：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We create an instance of `NTPClient` and then we call the `request()` method
    on it by passing the NTP server address.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`NTPClient`实例，然后通过传递NTP服务器地址来调用其上的`request()`方法。
- en: 'Listing 1.11shows how to print the current time from the Internet time server
    is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.11显示了如何如下从互联网时间服务器打印当前时间：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In my machine, this recipe shows the following output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，此菜谱显示了以下输出：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here, an NTP client has been created and an NTP request has been sent to one
    of the Internet NTP servers, `pool.ntp.org`. The `ctime()` function is used for
    printing the response.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，已经创建了一个NTP客户端，并向互联网NTP服务器之一`pool.ntp.org`发送了一个NTP请求。使用`ctime()`函数来打印响应。
- en: Writing a SNTP client
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写SNTP客户端
- en: Unlike the previous recipe, sometimes, you don't need to get the precise time
    from the NTP server. You can use a simpler version of NTP called simple network
    time protocol.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的菜谱不同，有时您不需要从NTP服务器获取精确的时间。您可以使用NTP的一个更简单的版本，称为简单网络时间协议。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let us create a plain SNTP client without using any third-party library.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个不使用任何第三方库的纯SNTP客户端。
- en: 'Let us first define two constants: `NTP_SERVER` and `TIME1970\. NTP_SERVER`
    is the server address to which our client will connect, and `TIME1970` is the
    reference time on January 1, 1970 (also called *Epoch*). You may find the value
    of the Epoch time or convert to the Epoch time at [http://www.epochconverter.com/](http://www.epochconverter.com/).
    The actual client creates a UDP socket (`SOCK_DGRAM`) to connect to the server
    following the UDP protocol. The client then needs to send the SNTP protocol data
    (`''\x1b'' + 47 * ''\0''`) in a packet. Our UDP client sends and receives data
    using the `sendto()` and `recvfrom()` methods.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义两个常量：`NTP_SERVER`和`TIME1970`。`NTP_SERVER`是我们客户端将要连接的服务器地址，而`TIME1970`是1970年1月1日的参考时间（也称为*纪元*）。您可以在[http://www.epochconverter.com/](http://www.epochconverter.com/)找到纪元时间的值或将其转换为纪元时间。实际的客户端创建一个UDP套接字（`SOCK_DGRAM`）来遵循UDP协议连接到服务器。然后，客户端需要发送SNTP协议数据（`'\x1b'
    + 47 * '\0'`）在一个数据包中。我们的UDP客户端使用`sendto()`和`recvfrom()`方法发送和接收数据。
- en: When the server returns the time information in a packed array, the client needs
    a specialized `struct` module to unpack the data. The only interesting data is
    located in the 11th element of the array. Finally, we need to subtract the reference
    value, `TIME1970`, from the unpacked value to get the actual current time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器以打包数组的形式返回时间信息时，客户端需要一个专门的`struct`模块来解包数据。有趣的数据位于数组的第11个元素。最后，我们需要从解包值中减去参考值`TIME1970`以获取实际当前时间。
- en: 'Listing 1.11 shows how to write an SNTP client as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.11展示了如何编写一个SNTP客户端，如下所示：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This recipe prints the current time from the Internet time server received
    with the SNTP protocol as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方打印从互联网时间服务器通过SNTP协议接收的当前时间，如下所示：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This SNTP client creates a socket connection and sends the protocol data. After
    receiving the response from the NTP server (in this case, `0.uk.pool.ntp.org`),
    it unpacks the data with `struct`. Finally, it subtracts the reference time, which
    is January 1, 1970, and prints the time using the `ctime()` built-in method in
    the Python time module.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此SNTP客户端创建一个套接字连接并发送协议数据。在接收到NTP服务器（在这种情况下，`0.uk.pool.ntp.org`）的响应后，它使用`struct`解包数据。最后，它减去参考时间，即1970年1月1日，并使用Python时间模块的内置方法`ctime()`打印时间。
- en: Writing a simple echo client/server application
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个简单的回显客户端/服务器应用程序
- en: After testing with basic socket APIs in Python, let us create a socket server
    and client now. Here, you will have the chance to utilize your basic knowledge
    gained in the previous recipes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Python的基本套接字API进行测试后，我们现在创建一个套接字服务器和客户端。在这里，你将有机会利用你在前面的配方中获得的基本知识。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this example, a server will echo whatever it receives from the client. We
    will use the Python `argparse` module to specify the TCP port from a command line.
    Both the server and client script will take this argument.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，服务器将回显从客户端接收到的任何内容。我们将使用Python的`argparse`模块从命令行指定TCP端口。服务器和客户端脚本都将接受此参数。
- en: First, we create the server. We start by creating a TCP socket object. Then,
    we set the reuse address so that we can run the server as many times as we need.
    We bind the socket to the given port on our local machine. In the listening stage,
    we make sure we listen to multiple clients in a queue using the backlog argument
    to the `listen()` method. Finally, we wait for the client to be connected and
    send some data to the server. When the data is received, the server echoes back
    the data to the client.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建服务器。我们首先创建一个TCP套接字对象。然后，我们设置地址重用，以便我们可以根据需要多次运行服务器。我们将套接字绑定到我们本地机器上的指定端口。在监听阶段，我们确保使用`listen()`方法的backlog参数来监听队列中的多个客户端。最后，我们等待客户端连接并发送一些数据到服务器。当数据被接收时，服务器将数据回显给客户端。
- en: 'Listing 1.13a shows how to write a simple echo client/server application as
    follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.13a展示了如何编写一个简单的回显客户端/服务器应用程序，如下所示：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: On the client-side code, we create a client socket using the port argument and
    connect to the server. Then, the client sends the message, `Test message. This
    will be echoed` to the server, and the client immediately receives the message
    back in a few segments. Here, two try-except blocks are constructed to catch any
    exception during this interactive session.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端代码中，我们使用端口号创建一个客户端套接字并连接到服务器。然后，客户端向服务器发送消息“Test message. This will be echoed”，并且客户端立即以几个段的形式接收到消息。在这里，构建了两个try-except块来捕获此交互会话中的任何异常。
- en: 'Listing 1-13b shows the echo client as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1-13b展示了回显客户端，如下所示：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In order to see the client/server interactions, launch the following server
    script in one console:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看客户端/服务器交互，在一个控制台中启动以下服务器脚本：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, run the client from another terminal as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从另一个终端运行客户端，如下所示：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Upon connecting to the localhost, the client server will also print the following
    message:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端连接到localhost时，服务器也会打印以下消息：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
