- en: Chapter 5.  Developing RESTful APIs with Flask
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 使用Flask开发RESTful API
- en: 'In this chapter, we will start working with Flask and its Flask-RESTful extension;
    we will also create a RESTful Web API that performs CRUD operations on a simple
    list. We will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始使用Flask及其Flask-RESTful扩展；我们还将创建一个执行简单列表的CRUD操作的RESTful Web API。我们将：
- en: Design a RESTful API that performs CRUD operations in Flask with the Flask-RESTful
    extension
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个使用Flask和Flask-RESTful扩展执行CRUD操作的RESTful API
- en: Understand the tasks performed by each HTTP method
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解每个HTTP方法执行的任务
- en: Set up the virtual environment with Flask and its Flask-RESTful extension
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flask及其Flask-RESTful扩展设置虚拟环境
- en: Declare status codes for the responses
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明响应的状态码
- en: Create the model to represent a resource
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建表示资源的模型
- en: Use a dictionary as a repository
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字典作为存储库
- en: Configure output fields for serialized responses
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置序列化响应的输出字段
- en: Work with resourceful routing on top of Flask pluggable views
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Flask的可插拔视图之上进行资源路由
- en: Configure resource routing and endpoints
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置资源路由和端点
- en: Make HTTP requests to the Flask API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向Flask API发送HTTP请求
- en: Work with command-line tools to interact with the Flask API
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行工具与Flask API交互
- en: Work with GUI tools to interact with the Flask API
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GUI工具与Flask API交互
- en: Designing a RESTful API to interact with a simple data source
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个与简单数据源交互的RESTful API
- en: Imagine that we have to configure the messages to be displayed in an OLED display
    wired to an **IoT** (**Internet of Things**) device, the IoT device is capable
    of running Python 3.5, Flask, and other Python packages. There is a team that
    is writing code that retrieves string messages from a dictionary and displays
    them in the OLED display wired to the IoT device. We have to start working on
    a mobile app and a website that has to interact with a RESTful API to perform
    CRUD operations with string messages.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们必须配置要显示在连接到**物联网**（**Internet of Things**）设备的OLED显示屏上的消息，该物联网设备能够运行Python
    3.5、Flask和其他Python包。有一个团队正在编写代码，从字典中检索字符串消息并在连接到物联网设备的OLED显示屏上显示它们。我们必须开始开发一个移动应用和网站，该应用和网站需要与RESTful
    API交互以执行字符串消息的CRUD操作。
- en: We don't need an ORM because we won't persist the string messages on a database.
    We will just work with an in-memory dictionary as our data source. It is one of
    the requirements for this RESTful API. In this case, the RESTful web service will
    be running on the IoT device, that is, we will run the Flask development server
    on the IoT device.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要ORM，因为我们不会将字符串消息持久化到数据库中。我们只需使用内存中的字典作为我们的数据源。这是此RESTful API的要求之一。在这种情况下，RESTful网络服务将在物联网设备上运行，即我们将在物联网设备上运行Flask开发服务器。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We will definitely lose scalability for our RESTful API because we have the
    in-memory data source in the server, and therefore, we cannot run the RESTful
    API in another IoT device. However, we will work with another example related
    to a more complex data source that will be able to scale in the RESTful way later.
    The first example is going to allow us to understand how Flask and Flask-RESTful
    work together with a very simple in-memory data source.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定会失去RESTful API的可扩展性，因为我们服务器中有内存数据源，因此，我们无法在另一个物联网设备上运行RESTful API。然而，我们将与另一个示例合作，该示例涉及更复杂的数据源，该数据源将能够以后以RESTful方式扩展。第一个示例将使我们了解Flask和Flask-RESTful如何与一个非常简单的内存数据源一起工作。
- en: We have chosen Flask because it is more lightweight than Django, we don't need
    to configure an ORM and we want to start running the RESTful API on the IoT device,
    as soon as possible, to allow all the teams to interact with it. We will code
    the website with Flask too, and therefore, we want to use the same web micro-framework
    to power the website and the RESTful web service.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择Flask，因为它比Django更轻量级，我们不需要配置ORM，我们希望尽快在物联网设备上运行RESTful API，以便所有团队都能与之交互。我们也将使用Flask编写网站，因此，我们希望使用相同的Web微框架来驱动网站和RESTful网络服务。
- en: There are many extensions available for Flask that makes it easier to perform
    specific tasks with the Flask micro-framework. We will take advantage of Flask-RESTful,
    an extension that will allow us to encourage best practices while building our
    RESTful API. In this case, we will work with a Python dictionary as the data source.
    As previously explained, we will work with more complex data sources in the forthcoming
    examples.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Flask有许多可用的扩展，使得使用Flask微框架执行特定任务变得更容易。我们将利用Flask-RESTful扩展，这将允许我们在构建RESTful
    API时鼓励最佳实践。在这种情况下，我们将使用Python字典作为数据源。如前所述，在未来的示例中，我们将使用更复杂的数据源。
- en: 'First, we must specify the requirements for our main resource: a message. We
    need the following attributes or fields for a message:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须指定我们主要资源（消息）的要求。对于消息，我们需要以下属性或字段：
- en: An integer identifier
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数标识符
- en: A string message
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串消息
- en: A duration in seconds that indicates the time the message has to be printed
    on the OLED display
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示消息在OLED显示屏上打印时间的秒数
- en: A creation date and time-the timestamp will be added automatically when adding
    a new message to the collection
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建日期和时间——当向集合添加新消息时，时间戳将自动添加
- en: A message category description, such as "Warning" and "Information"
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个消息类别描述，例如“警告”和“信息”
- en: An integer counter that indicates the times the message has been printed in
    the OLED display
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示消息在OLED显示屏上打印次数的整数计数器
- en: A `bool` value indicating whether the message was printed at least once on the
    OLED display
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示消息是否至少在OLED显示屏上打印过一次的布尔值
- en: The following table shows the HTTP verbs, the scope, and the semantics for the
    methods that our first version of the API must support. Each method is composed
    by an HTTP verb and a scope and all the methods have a well-defined meaning for
    all the messages and collections. In our API, each message has its own unique
    URL.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了我们的API第一版必须支持的HTTP动词、作用域和语义。每个方法由一个HTTP动词和一个作用域组成，并且所有方法对所有消息和集合都有一个明确的含义。在我们的API中，每个消息都有自己的唯一URL。
- en: '| **HTTP verb** | **Scope** | **Semantics** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP动词** | **作用域** | **语义** |'
- en: '| `GET` | Collection of messages | Retrieve all the stored messages in the
    collection, sorted by their name in ascending order |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 消息集合 | 获取集合中存储的所有消息，按名称升序排序 |'
- en: '| `GET` | Message | Retrieve a single message |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 消息 | 获取单个消息 |'
- en: '| `POST` | Collection of messages | Create a new message in the collection
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 消息集合 | 在集合中创建一个新的消息 |'
- en: '| `PATCH` | Message | Update a field for an existing message |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 消息 | 更新现有消息的字段 |'
- en: '| `DELETE` | Message | Delete an existing message |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 消息 | 删除现有的消息 |'
- en: Understanding the tasks performed by each HTTP method
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解每个HTTP方法执行的任务
- en: Let's consider that `http://localhost:5000/api/messages/` is the URL for the
    collection of messages. If we add a number to the preceding URL, we identify a
    specific message whose id is equal to the specified numeric value. For example,
    `http://localhost:5000/api/messsages/6` identifies the message whose id is equal
    to `6`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑`http://localhost:5000/api/messages/`是消息集合的URL。如果我们向前面的URL添加一个数字，我们就能识别一个特定的消息，其id等于指定的数值。例如，`http://localhost:5000/api/messsages/6`标识了id等于`6`的消息。
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We want our API to be able to differentiate collections from a single resource
    of the collection in the URLs. When we refer a collection, we will use a slash
    (`/`) as the last character for the URL, as in `http://localhost:5000/api/messages/`.
    When we refer to a single resource of the collection we won't use a slash (`/`)
    as the last character for the URL, as in `http://localhost:5000/api/messages/6`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的API能够在URL中区分集合和集合的单个资源。当我们引用集合时，我们将使用斜杠（`/`）作为URL的最后一个字符，如`http://localhost:5000/api/messages/`。当我们引用集合的单个资源时，我们不会在URL的最后一个字符使用斜杠（`/`），如`http://localhost:5000/api/messages/6`。
- en: We have to compose and send an HTTP request with the `POST` HTTP verb and the
    `http://localhost:5000/api/messages/` request URL to create a new message. In
    addition, we have to provide the JSON key-value pairs with the field names and
    the values to create the new message. As a result of the request, the server will
    validate the provided values for the fields, make sure that it is a valid message,
    and persist it in the messages dictionary.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用`POST` HTTP动词和请求URL `http://localhost:5000/api/messages/`来编写并发送一个HTTP请求以创建一条新消息。此外，我们必须提供包含字段名称和值的JSON键值对以创建新消息。作为请求的结果，服务器将验证提供的字段值，确保它是一个有效的消息，并将其持久化到消息字典中。
- en: 'The server will return a `201 Created` status code and a JSON body with the
    recently added message serialized to JSON, including the assigned id that was
    automatically generated by the server to the message object:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将返回一个`201 Created`状态码和一个包含最近添加的消息序列化为JSON的JSON体，包括服务器自动生成并分配给消息对象的ID：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have to compose and send an HTTP request with the `GET` HTTP verb and the
    `http://localhost:5000/api/messages/{id}` request URL to retrieve the message
    whose id matches the specified numeric value in the place where `{id}` is written.
    For example, if we use the request URL `http://localhost:5000/api/messages/82`,
    the server will retrieve the game whose id matches 82\. As a result of the request,
    the server will retrieve a message with the specified id from the dictionary.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用`GET` HTTP动词和请求URL `http://localhost:5000/api/messages/{id}`来编写并发送一个HTTP请求，以检索与在
    `{id}` 处写入的指定数值匹配的消息。例如，如果我们使用请求URL `http://localhost:5000/api/messages/82`，服务器将检索ID匹配82的游戏。作为请求的结果，服务器将从字典中检索具有指定ID的消息。
- en: 'If a message is found, the server will serialize the message object into JSON
    and return a `200 OK` status code and a JSON body with the serialized message
    object. If no message matches the specified id or primary key, the server will
    return a `404 Not Found` status:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到消息，服务器将序列化消息对象为JSON，并返回一个`200 OK`状态码和一个包含序列化消息对象的JSON体。如果没有找到与指定ID或主键匹配的消息，服务器将返回一个`404
    Not Found`状态：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have to compose and send an HTTP request with the `PATCH` HTTP verb and the
    `http://localhost:5000/api/messages/{id}` request URL to update one or more fields
    for the message whose id matches the specified numeric value in the place where
    `{id}` is written. In addition, we have to provide the JSON key-value pairs with
    the field names to be updated and their new values. As a result of the request,
    the server will validate the provided values for the fields, update these fields
    on the message that matches the specified id, and update the message in the dictionary,
    if it is a valid message.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用`PATCH` HTTP动词和请求URL `http://localhost:5000/api/messages/{id}`来编写并发送一个HTTP请求以更新与在
    `{id}` 处写入的指定数值匹配的消息的一个或多个字段。此外，我们必须提供包含要更新的字段名称及其新值的JSON键值对。作为请求的结果，服务器将验证提供的字段值，更新与指定ID匹配的消息上的这些字段，并在字典中更新消息，如果它是有效的消息。
- en: 'The server will return a `200 OK` status code and a JSON body with the recently
    updated game serialized to JSON. If we provide invalid data for the fields to
    be updated, the server will return a `400 Bad Request` status code. If the server
    doesn''t find a message with the specified id, the server will return just a `404
    Not Found` status:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将返回一个`200 OK`状态码和一个包含最近更新的游戏序列化为JSON的JSON体。如果我们为要更新的字段提供无效数据，服务器将返回一个`400
    Bad Request`状态码。如果服务器找不到具有指定ID的消息，服务器将仅返回一个`404 Not Found`状态：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The PATCH method will allow us to easily update two fields for a message: the
    integer counter, that indicates the times the message has been printed and the
    bool value, that specifies whether the message was printed at least once.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: PATCH方法将使我们能够轻松地更新消息的两个字段：表示消息被打印次数的整数计数器，以及指定消息是否至少被打印一次的布尔值。
- en: 'We have to compose and send an HTTP request with the `DELETE` HTTP verb and
    the `http://localhost:5000/api/messages/{id}` request URL to remove the message
    whose id matches the specified numeric value in the place where `{id}` is written.
    For example, if we use the request URL `http://localhost:5000/api/messages/15`,
    the server will delete the message whose `id` matches `15`. As a result of the
    request, the server will retrieve a message with the specified id from the dictionary.
    If a message is found, the server will request the dictionary to delete the entry
    associated with this message object and return a `204 No Content` status code.
    If no message matches the specified id, the server will return a `404 Not Found`
    status:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用`DELETE` HTTP动词和`http://localhost:5000/api/messages/{id}`请求URL来组合和发送一个HTTP请求，以删除与在`{id}`位置指定的数值匹配的消息。例如，如果我们使用请求URL
    `http://localhost:5000/api/messages/15`，服务器将删除`id`匹配`15`的消息。请求的结果是，服务器将从字典中检索具有指定`id`的消息。如果找到消息，服务器将请求字典删除与该消息对象关联的条目，并返回`204
    No Content`状态码。如果没有找到与指定`id`匹配的消息，服务器将返回`404 Not Found`：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Setting up a virtual environment with Flask and Flask-RESTful
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flask和Flask-RESTful设置虚拟环境
- en: In [Chapter 1](ch01.html "Chapter 1. Developing RESTful APIs with Django") *,*
    *Developing RESTful APIs with Django*, we learned that, throughout this book,
    we were going to work with the lightweight virtual environments introduced in
    Python 3.4 and improved in Python 3.4\. Now, we will follow the steps to create
    a new lightweight virtual environment to work with Flask and Flask-RESTful. It
    is highly recommended to read *[Chapter 1](ch01.html "Chapter 1. Developing RESTful
    APIs with Django"),* *Developing RESTful APIs with Django*, in case you don't
    have experience with lightweight virtual environments in Python. The chapter includes
    all the detailed explanations of the effects of the steps we are going to follow.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 使用Django开发RESTful API") "*使用Django开发RESTful API*"中，我们了解到，在本书中，我们将使用Python
    3.4中引入并改进的轻量级虚拟环境。现在，我们将按照步骤创建一个新的轻量级虚拟环境，以便使用Flask和Flask-RESTful。如果你没有Python中轻量级虚拟环境的经验，强烈建议阅读*[第1章](ch01.html
    "第1章. 使用Django开发RESTful API")*，*使用Django开发RESTful API*。该章节包含了我们将要遵循的步骤的所有详细解释。
- en: 'First, we have to select the target folder or directory for our virtual environment.
    We will use the following path in the example for macOS and Linux. The target
    folder for the virtual environment will be the `PythonREST/Flask01` folder within
    our home directory. For example, if our home directory in macOS or Linux is `/Users/gaston`,
    the virtual environment will be created within `/Users/gaston/PythonREST/Flask01`.
    You can replace the specified path with your desired path in each command, as
    shown:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须选择我们的虚拟环境的目标文件夹或目录。在示例中，我们将使用以下路径。虚拟环境的目标文件夹将是我们主目录中的`PythonREST/Flask01`文件夹。例如，如果我们的macOS或Linux中的主目录是`/Users/gaston`，虚拟环境将在`/Users/gaston/PythonREST/Flask01`中创建。您可以在每个命令中将指定的路径替换为您想要的路径，如下所示：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will use the following path in the example for Windows. The target folder
    for the virtual environment will be the `PythonREST\Flask01` folder within our
    user profile folder. For example, if our user profile folder is `C:\Users\Gaston`,
    the virtual environment will be created within `C:\Users\gaston\PythonREST\Flask01`.
    You can replace the specified path with your desired path in each command, as
    shown:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们将使用以下路径。虚拟环境的目标文件夹将是我们用户配置文件中的`PythonREST\Flask01`文件夹。例如，如果我们的用户配置文件是`C:\Users\Gaston`，虚拟环境将在`C:\Users\gaston\PythonREST\Flask01`中创建。您可以在每个命令中将指定的路径替换为您想要的路径，如下所示：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Open a Terminal in macOS or Linux and execute the following command to create
    a virtual environment:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS或Linux中打开终端并执行以下命令以创建虚拟环境：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In Windows, execute the following command to create a virtual environment:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，执行以下命令以创建虚拟环境：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding command doesn't produce any output. Now that we have created a
    virtual environment, we will run a platform-specific script to activate it. After
    we activate the virtual environment, we will install packages that will only be
    available in this virtual environment.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令不会产生任何输出。现在我们已经创建了虚拟环境，我们将运行一个特定平台的脚本以激活它。激活虚拟环境后，我们将安装只在此虚拟环境中可用的包。
- en: 'If your Terminal is configured to use the `bash` shell in macOS or Linux, run
    the following command to activate the virtual environment. The command also works
    for the `zsh` shell:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的终端配置为在 macOS 或 Linux 中使用 `bash` shell，请运行以下命令来激活虚拟环境。该命令也适用于 `zsh` shell：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If your Terminal is configured to use either the `csh` or `tcsh` shell, run
    the following command to activate the virtual environment:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的终端配置为使用 `csh` 或 `tcsh` shell，请运行以下命令来激活虚拟环境：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If your Terminal is configured to use either the `fish` shell, run the following
    command to activate the virtual environment:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的终端配置为使用 `fish` shell，请运行以下命令来激活虚拟环境：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In Windows, you can run either a batch file in the Command Prompt or a Windows
    PowerShell script to activate the virtual environment. If you prefer the Command
    Prompt, run the following command in the Windows command line to activate the
    virtual environment:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，您可以在命令提示符中运行批处理文件或 Windows PowerShell 脚本来激活虚拟环境。如果您更喜欢命令提示符，请在 Windows
    命令行中运行以下命令来激活虚拟环境：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you prefer the Windows PowerShell, launch it and run the following commands
    to activate the virtual environment. However, note that you should have the scripts
    execution enabled in Windows PowerShell to be able to run the script:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢 Windows PowerShell，启动它并运行以下命令来激活虚拟环境。但是请注意，您应该在 Windows PowerShell 中启用脚本执行才能运行脚本：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After you activate the virtual environment, the Command Prompt will display
    the virtual environment root folder name, enclosed in parenthesis, as a prefix
    for the default prompt, to remind us that we are working in the virtual environment.
    In this case, we will see (`Flask01`) as a prefix for the Command Prompt because
    the root folder for the activated virtual environment is `Flask01`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 激活虚拟环境后，命令提示符将显示虚拟环境根文件夹名称，用括号括起来，作为默认提示的前缀，以提醒我们我们正在虚拟环境中工作。在这种情况下，我们将看到 (`Flask01`)
    作为命令提示符的前缀，因为激活的虚拟环境的根文件夹是 `Flask01`。
- en: 'We have created and activated a virtual environment. Now it is time to run
    the commands that will be the same for macOS, Linux, or Windows; we must run the
    following command to install Flask-RESTful with pip. Flask is a dependency for
    Flask-RESTful, and therefore, pip will install it automatically, too:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已创建并激活了虚拟环境。现在是时候运行将在 macOS、Linux 或 Windows 上相同的命令了；我们必须运行以下命令使用 pip 安装 Flask-RESTful。Flask
    是 Flask-RESTful 的依赖项，因此 pip 也会自动安装它：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The last lines for the output will indicate all the packages that have been
    successfully installed, including `flask-restful` and `Flask`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示所有成功安装的包，包括 `flask-restful` 和 `Flask`：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Declaring status codes for the responses
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明响应的状态码
- en: Neither Flask nor Flask-RESTful includes the declaration of variables for the
    different HTTP status codes. We don't want to return numbers as status codes.
    We want our code to be easy to read and understand, and therefore, we will use
    descriptive HTTP status codes. We will borrow the code that declares useful functions
    and variables related to HTTP status codes from the `status.py` file included
    in Django REST Framework, that is, the framework we have been using in the preceding
    chapters.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是 Flask 还是 Flask-RESTful 都没有包含不同 HTTP 状态码的变量声明。我们不希望返回数字作为状态码。我们希望我们的代码易于阅读和理解，因此，我们将使用描述性的
    HTTP 状态码。我们将从 Django REST Framework 包含的 `status.py` 文件中借用声明与 HTTP 状态码相关的有用函数和变量的代码，即我们在前几章中使用过的框架。
- en: 'First, create a folder named `api` within the root folder for the recently
    created virtual environment, and then create a new `status.py` file within the
    `api` folder. The following lines show the code that declares functions and variables
    with descriptive HTTP status codes in the `api/models.py` file borrowed from the
    `rest_framework.status` module. We don''t want to reinvent the wheel, and the
    module provides everything we need to work with HTTP status codes in our Flask-based
    API. The code file for the sample is included in the `restful_python_chapter_05_01`
    folder:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在最近创建的虚拟环境的根目录下创建一个名为 `api` 的文件夹，然后在 `api` 文件夹中创建一个新的 `status.py` 文件。以下行展示了从
    `rest_framework.status` 模块借用的 `api/models.py` 文件中声明的具有描述性 HTTP 状态码的函数和变量的代码。我们不希望重新发明轮子，该模块提供了我们在基于
    Flask 的 API 中处理 HTTP 状态码所需的一切。示例代码文件包含在 `restful_python_chapter_05_01` 文件夹中：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The code declares five functions that receive the HTTP status code in the code
    argument and determine which of the following categories the status code belongs
    to: informational, success, redirect, client error, or server error categories.
    We will use the previous variables when we have to return a specific status code.
    For example, in case we have to return a `404 Not Found` status code, we will
    return `status.HTTP_404_NOT_FOUND`, instead of just `404`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了五个函数，这些函数接收HTTP状态码作为`code`参数，并确定状态码属于以下哪个类别：信息性、成功、重定向、客户端错误或服务器错误类别。当我们需要返回特定的状态码时，我们将使用前面的变量。例如，如果我们需要返回`404
    Not Found`状态码，我们将返回`status.HTTP_404_NOT_FOUND`，而不是仅仅`404`。
- en: Creating the model
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'Now, we will create a simple `MessageModel` class that we will use to represent
    messages. Remember that we won''t be persisting the model in the database, and
    therefore, in this case, our class will just provide the required attributes and
    no mapping information. Create a new `models.py` file in the `api` folder. The
    following lines show the code that creates a `MessageModel` class in the `api/models.py`
    file. The code file for the sample is included in the `restful_python_chapter_05_01`
    folder:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个简单的`MessageModel`类，我们将使用它来表示消息。请记住，我们不会在数据库中持久化模型，因此在这种情况下，我们的类将只提供所需的属性而没有映射信息。在`api`文件夹中创建一个新的`models.py`文件。以下行显示了在`api/models.py`文件中创建`MessageModel`类的代码。示例的代码文件包含在`restful_python_chapter_05_01`文件夹中：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `MessageModel` class just declares a constructor, that is, the `__init__`
    method. This method receives many arguments and then uses them to initialize the
    attributes with the same names: `message`, `duration`, `creation_date`, and `message_category`.
    The `id` attribute is set to 0, `printed_times` is set to `0`, and `printed_once`
    is set to `False`. We will automatically increment the identifier for each new
    message generated with API calls.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageModel`类仅声明了一个构造函数，即`__init__`方法。此方法接收许多参数，然后使用它们来初始化具有相同名称的属性：`message`、`duration`、`creation_date`和`message_category`。`id`属性设置为0，`printed_times`设置为`0`，`printed_once`设置为`False`。我们将自动通过API调用为每个新生成的消息递增标识符。'
- en: Using a dictionary as a repository
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字典作为存储库
- en: Now, we will create a `MessageManager` class that we will use to persist the
    `MessageModel` instances in an in-memory dictionary. Our API methods will call
    methods for the `MessageManager` class to retrieve, insert, update, and delete
    `MessageModel` instances. Create a new `api.py` file in the `api` folder. The
    following lines show the code that creates a `MessageManager` class in the `api/api.py`
    file. In addition, the following lines declare all the `imports` we will need
    for all the code we will write in this file. The code file for the sample is included
    in the `restful_python_chapter_05_01` folder.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个`MessageManager`类，我们将使用它将`MessageModel`实例持久化到内存字典中。我们的API方法将调用`MessageManager`类的相关方法来检索、插入、更新和删除`MessageModel`实例。在`api`文件夹中创建一个新的`api.py`文件。以下行显示了在`api/api.py`文件中创建`MessageManager`类的代码。此外，以下行声明了我们将需要用于此文件中所有代码的所有`导入`。示例的代码文件包含在`restful_python_chapter_05_01`文件夹中。
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `MessageManager` class declares a `last_id` class attribute and initializes
    it to 0\. This class attribute stores the last id that has been generated and
    assigned to a `MessageModel` instance stored in a dictionary. The constructor,
    that is, the `__init__` method, creates and initializes the `messages` attribute
    as an empty dictionary.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageManager`类声明了一个`last_id`类属性，并将其初始化为0。这个类属性存储了最后生成的并分配给存储在字典中的`MessageModel`实例的id。构造函数，即`__init__`方法，创建并初始化`messages`属性为一个空字典。'
- en: 'The code declares the following three methods for the class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码为该类声明了以下三个方法：
- en: '`insert_message`: This method receives a recently created `MessageModel` instance
    in the `message` argument. The code increases the value for the `last_id` class
    attribute and then assigns the resulting value to the id for the received message.
    The code uses `self.__class__` to reference the type of the current instance.
    Finally, the code adds the `message` as a value to the key identified with the
    generated id, `last_id`, in the `self.messages` dictionary.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert_message`：此方法接收一个最近创建的`MessageModel`实例，作为`message`参数。代码增加`last_id`类属性的值，然后将结果值分配给接收到的消息的id。代码使用`self.__class__`来引用当前实例的类型。最后，代码将`message`作为值添加到由生成的id，即`last_id`，标识的`self.messages`字典中的键。'
- en: '`get_message`: This method receives the `id` of the message that has to be
    retrieved from the `self.messages` dictionary. The code returns the value related
    to the key that matches the received `id` in the `self.messages` dictionary that
    we are using as our data source.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_message`: 此方法接收要从中检索的 `self.messages` 字典中消息的 `id`。代码返回与接收到的 `id` 匹配的键在
    `self.messages` 字典中我们用作数据源的相关值。'
- en: '`delete_message`: This method receives the `id` of the message that has to
    be removed from the `self.messages` dictionary. The code deletes the key-value
    pair whose key matches the received id in the `self.messages` dictionary that
    we are using as our data source.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete_message`: 此方法接收要从中移除的 `self.messages` 字典中消息的 `id`。代码删除了与接收到的 `id` 匹配的键值对，该键值对位于我们用作数据源的
    `self.messages` 字典中。'
- en: We don't need a method to update a message because we will just make changes
    to the attributes of the `MessageModel` instance that is already stored in the
    `self.messages` dictionary. The value stored in the dictionary is a reference
    to the `MessageModel` instance that we are updating, and therefore, we don't need
    to call a specific method to update the instance in the dictionary. However, in
    case we were working with a database, we would need to call an update method for
    our ORM or data repository.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要一个更新消息的方法，因为我们只需更改已存储在 `self.messages` 字典中的 `MessageModel` 实例的属性。字典中存储的值是对我们正在更新的
    `MessageModel` 实例的引用，因此我们不需要调用特定的方法来更新字典中的实例。然而，如果我们正在与数据库一起工作，我们需要调用我们的ORM或数据仓库的更新方法。
- en: Configuring output fields
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置输出字段
- en: Now, we will create a `message_fields` dictionary that we will use to control
    the data that we want Flask-RESTful to render in our response, when we return
    `MessageModel` instances. Open the previously created `api/api.py` file and add
    the following lines. The code file for the sample is included in the `restful_python_chapter_05_01`
    folder.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个 `message_fields` 字典，我们将使用它来控制我们想要Flask-RESTful在响应中渲染的数据。打开之前创建的 `api/api.py`
    文件，并添加以下行。示例的代码文件包含在 `restful_python_chapter_05_01` 文件夹中。
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We declared the `message_fields` dictionary (`dict`) with key-value pairs of
    strings and classes declared in the `flask_restful.fields` module. The keys are
    the names of the attributes we want to render from the `MessageModel` class and
    the values are the classes that format and return the value for the field. In
    the previous code, we worked with the following classes, that format and return
    the value for the specified field in the key:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了 `message_fields` 字典（`dict`），其中包含 `flask_restful.fields` 模块中声明的字符串和类的键值对。键是我们想要从
    `MessageModel` 类中渲染的属性名称，值是格式化和返回字段值的类。在前面的代码中，我们使用了以下类，这些类格式化和返回键中指定的字段值：
- en: '`field.Integer`: Outputs an integer value.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`field.Integer`: 输出一个整数值。'
- en: '`fields.Url`: Generates a string representation of a URL. By default, this
    class generates a relative URI for the resource that is being requested. The code
    specifies `''message_endpoint''` for the `endpoint` argument. This way, the class
    will use the specified endpoint name. We will declare this endpoint later in the
    `api.py` file. We don''t want to include the hostname in the generated URI, and
    therefore, we use the default value for the `absolute` bool attribute, which is
    `False`.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.Url`: 生成一个URL的字符串表示。默认情况下，此类为请求的资源生成相对URI。代码指定了 `''message_endpoint''`
    作为 `endpoint` 参数。这样，该类将使用指定的端点名称。我们将在 `api.py` 文件中稍后声明此端点。我们不希望在生成的URI中包含主机名，因此我们使用
    `absolute` 布尔属性的默认值，即 `False`。'
- en: '`fields.DateTime`: Outputs a formatted `datetime` string in UTC, in the default
    RFC 822 format.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.DateTime`: 输出UTC格式的格式化 `datetime` 字符串，默认采用RFC 822格式。'
- en: '`fields.Boolean`: Generates a string representation of a bool value.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.Boolean`: 生成一个布尔值的字符串表示。'
- en: The `'uri'` field uses `fields.Url` and it is related to the specified endpoint
    instead of being associated to an attribute of the `MessageModel` class. It is
    the only case in which the specified field name doesn't have an attribute in the
    `MessageModel` class. The other strings specified as keys indicate all the attributes
    we want to be rendered in the output when we use the `message_fields` dictionary
    to make up the final serialized response output.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`''uri''` 字段使用 `fields.Url`，它与指定的端点相关联，而不是与 `MessageModel` 类的属性相关联。这是唯一一个指定的字段名在
    `MessageModel` 类中没有属性的情况。其他指定为键的字符串表示我们在使用 `message_fields` 字典来构建最终的序列化响应输出时想要渲染的所有属性。'
- en: After we declared the `message_fields` dictionary, the next line of code creates
    an instance of the previously created `MessageManager` class named `message_manager`.
    We will use this instance to create, retrieve, and delete `MessageModel` instances.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们声明了`message_fields`字典之后，下一行代码创建了一个名为`message_manager`的之前创建的`MessageManager`类实例。我们将使用此实例来创建、检索和删除`MessageModel`实例。
- en: Working with resourceful routing on top of Flask pluggable views
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Flask可插拔视图之上进行资源路由操作
- en: Flask-RESTful uses resources built on top of Flask pluggable views as the main
    building block for a RESTful API. We just need to create a subclass of the `flask_restful.Resource`
    class and declare the methods for each supported HTTP verb. A subclass of `flask_restful.Resource`
    represents a RESTful resource and therefore, we will have to declare one class
    to represent the collection of messages and another one to represent the message
    resource.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-RESTful使用基于Flask可插拔视图的资源作为构建RESTful API的主要构建块。我们只需要创建一个`flask_restful.Resource`类的子类，并声明每个支持的HTTP动词的方法。`flask_restful.Resource`的子类代表RESTful资源，因此，我们将必须声明一个类来表示消息集合，另一个类来表示消息资源。
- en: 'First, we will create a `Message` class that we will use to represent the message
    resource. Open the previously created `api/api.py` file and add the following
    lines. The code file for the sample is included in the `restful_python_chapter_05_01`
    folder, as shown:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个`Message`类，我们将使用它来表示消息资源。打开之前创建的`api/api.py`文件，并添加以下行。示例代码文件包含在`restful_python_chapter_05_01`文件夹中，如下所示：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Message` class is a subclass of `flask_restful.Resource` and declares
    the following three methods, that will be called when the HTTP method with the
    same name arrives as a request on the represented resource:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message`类是`flask_restful.Resource`的子类，并声明了以下三个方法，当在表示的资源上接收到与同名HTTP方法请求时将被调用：'
- en: '`get`: This method receives the id of the message that has to be retrieved
    in the `id` argument. The code calls the `self.abort_if_message_doesnt_exist`
    method to abort in case there is no message with the requested id. In case the
    message exists, the code returns the `MessageModel` instance whose `id` that matches
    the specified `id` returned by the `message_manager.get_message` method. The `get`
    method uses the `@marshal_with` decorator with `message_fields` as an argument.
    The decorator will take the `MessageModel` instance and apply the field filtering
    and output formatting specified in `message_fields`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`: 此方法通过`id`参数接收要检索的消息的ID。代码调用`self.abort_if_message_doesnt_exist`方法，如果请求的ID没有消息则终止。如果消息存在，代码将返回由`message_manager.get_message`方法返回的与指定`id`匹配的`MessageModel`实例。`get`方法使用`@marshal_with`装饰器，并将`message_fields`作为参数。装饰器将获取`MessageModel`实例，并应用`message_fields`中指定的字段过滤和输出格式。'
- en: '`delete`: This method receives the id of the message that has to be deleted
    in the `id` argument. The code calls the `self.abort_if_message_doesnt_exist`
    method to abort, in case there is no message with the requested id. In case the
    [PRE20] [PRE21]'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`: 此方法通过`id`参数接收要删除的消息的ID。代码调用`self.abort_if_message_doesnt_exist`方法以终止，如果请求的ID没有消息。如果存在[PRE20]
    [PRE21]'
- en: return message
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: return message
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: return marshal(message, resource_fields), status.HTTP_200_OK
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: return marshal(message, resource_fields), status.HTTP_200_OK
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'class MessageList(Resource):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'class MessageList(Resource):'
- en: '@marshal_with(message_fields)'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@marshal_with(message_fields)'
- en: 'def get(self):'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def get(self):'
- en: return [v for v in message_manager.messages.values()]
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return [v for v in message_manager.messages.values()]
- en: '@marshal_with(message_fields)'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@marshal_with(message_fields)'
- en: 'def post(self):'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def post(self):'
- en: parser = reqparse.RequestParser()
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: parser = reqparse.RequestParser()
- en: parser.add_argument('message', type=str, required=True, help='Message cannot
    be blank!')
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: parser.add_argument('message', type=str, required=True, help='消息不能为空！')
- en: parser.add_argument('duration', type=int, required=True, help='Duration cannot
    be blank!')
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: parser.add_argument('duration', type=int, required=True, help='持续时间不能为空！')
- en: parser.add_argument('message_category', type=str, required=True, help='Message
    category cannot be blank!')
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: parser.add_argument('message_category', type=str, required=True, help='消息类别不能为空！')
- en: args = parser.parse_args()
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: args = parser.parse_args()
- en: message = MessageModel(
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: message = MessageModel(
- en: message=args['message'],
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: message=args['message'],
- en: duration=args['duration'],
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: duration=args['duration'],
- en: creation_date=datetime.now(utc),
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: creation_date=datetime.now(utc),
- en: message_category=args['message_category']
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: message_category=args['message_category']
- en: )
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: message_manager.insert_message(message)
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: message_manager.insert_message(message)
- en: return message, status.HTTP_201_CREATED
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return message, status.HTTP_201_CREATED
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: app = Flask(__name__)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: app = Flask(__name__)
- en: api = Api(app)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: api = Api(app)
- en: api.add_resource(MessageList, '/api/messages/')
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: api.add_resource(MessageList, '/api/messages/')
- en: api.add_resource(Message, '/api/messages/<int:id>', endpoint='message_endpoint')
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: api.add_resource(Message, '/api/messages/<int:id>', endpoint='message_endpoint')
- en: 'if __name__ == ''__main__'':'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: app.run(debug=True)
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: app.run(debug=True)
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: api.add_resource(MessageList, '/api/messages/')
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: api.add_resource(MessageList, '/api/messages/')
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: api.add_resource(Message, '/api/messages/<int:id>', endpoint='message_endpoint')
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: api.add_resource(Message, '/api/messages/<int:id>', endpoint='message_endpoint')
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: python api/api.py
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: python api/api.py
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '* 在 http://127.0.0.1:5000/ 上运行（按CTRL+C退出）'
- en: '* Restarting with stat'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '* 使用stat重启'
- en: '* Debugger is active!'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '* 调试器处于活动状态！'
- en: '* Debugger pin code: 294-714-594'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '* 调试器密码：294-714-594'
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'if __name__ == ''__main__'':'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: app.run(host='0.0.0.0', debug=True)
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: app.run(host='0.0.0.0', debug=True)
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: pip install --upgrade httpie
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: pip install --upgrade httpie
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: http POST :5000/api/messages/ message='Welcome to IoT' duration=10 message_category='Information'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: http POST :5000/api/messages/ message='欢迎来到物联网' duration=10 message_category='信息'
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'curl -iX POST -H "Content-Type: application/json" -d ''{"message":"Welcome
    to IoT", "duration":10, "message_category": "Information"}'' :5000/api/messages/'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 'curl -iX POST -H "Content-Type: application/json" -d ''{"message":"测量环境温度",
    "duration":10, "message_category": "信息"}'' :5000/api/messages/'
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '{'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"message": "Welcome to IoT",'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"message": "欢迎来到物联网",'
- en: '"duration": 10,'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"duration": 10,'
- en: '"message_category": "Information"'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"message_category": "信息"'
- en: '}'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: HTTP/1.0 201 CREATED
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.0 201 CREATED
- en: 'Content-Length: 245'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 'Content-Length: 245'
- en: 'Content-Type: application/json'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 'Content-Type: application/json'
- en: 'Date: Wed, 20 Jul 2016 04:43:24 GMT'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 'Date: Wed, 20 Jul 2016 04:43:24 GMT'
- en: 'Server: Werkzeug/0.11.10 Python/3.5.1'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'Server: Werkzeug/0.11.10 Python/3.5.1'
- en: '{'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"creation_date": "Wed, 20 Jul 2016 04:43:24 -0000",'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '"creation_date": "Wed, 20 Jul 2016 04:43:24 -0000",'
- en: '"duration": 10,'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '"duration": 10,'
- en: '"id": 1,'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '"id": 1,'
- en: '"message": "Welcome to IoT",'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '"message": "欢迎来到物联网",'
- en: '"message_category": "Information",'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '"message_category": "信息",'
- en: '"printed_once": false,'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '"printed_once": false,'
- en: '"printed_times": 0,'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '"printed_times": 0,'
- en: '"uri": "/api/messages/1"'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '"uri": "/api/messages/1"'
- en: '}'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: http POST :5000/api/messages/ message='Measuring ambient temperature' duration=5
    message_category='Information'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: http POST :5000/api/messages/ message='测量环境温度' duration=5 message_category='信息'
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'curl -iX POST -H "Content-Type: application/json" -d ''{"message":"Measuring
    ambient temperature", "duration":5, "message_category": "Information"}'' :5000/api/messages/'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 'curl -iX POST -H "Content-Type: application/json" -d ''{"message":"测量环境温度",
    "duration":5, "message_category": "信息"}'' :5000/api/messages/'
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '{'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"message": "Measuring ambient temperature",'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"message": "测量环境温度",'
- en: '"duration": 5,'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"duration": 5,'
- en: '"message_category": "Information"'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"message_category": "信息"'
- en: '}'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: HTTP/1.0 201 CREATED
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.0 201 CREATED
- en: 'Content-Length: 259'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 'Content-Length: 259'
- en: 'Content-Type: application/json'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'Content-Type: application/json'
- en: 'Date: Wed, 20 Jul 2016 18:27:05 GMT'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'Date: Wed, 20 Jul 2016 18:27:05 GMT'
- en: 'Server: Werkzeug/0.11.10 Python/3.5.1'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 'Server: Werkzeug/0.11.10 Python/3.5.1'
- en: '{'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"creation_date": "Wed, 20 Jul 2016 18:27:05 -0000",'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '"creation_date": "Wed, 20 Jul 2016 18:27:05 -0000",'
- en: '"duration": 5,'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '"duration": 5,'
- en: '"id": 2,'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '"id": 2,'
- en: '"message": "Measuring ambient temperature",'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '"message": "测量环境温度",'
- en: '"message_category": "Information",'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '"message_category": "信息",'
- en: '"printed_once": false,'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '"printed_once": false,'
- en: '"printed_times": 0,'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '"printed_times": 0,'
- en: '"uri": "/api/messages/2"'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '"uri": "/api/messages/2"'
- en: '}'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: http :5000/api/messages/
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: http :5000/api/messages/
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: curl -iX GET -H :5000/api/messages/
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: curl -iX GET -H :5000/api/messages/
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: HTTP/1.0 200 OK
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.0 200 OK
- en: 'Content-Length: 589'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'Content-Length: 589'
- en: 'Content-Type: application/json'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 'Content-Type: application/json'
- en: 'Date: Wed, 20 Jul 2016 05:32:28 GMT'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 'Date: Wed, 20 Jul 2016 05:32:28 GMT'
- en: 'Server: Werkzeug/0.11.10 Python/3.5.1'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 'Server: Werkzeug/0.11.10 Python/3.5.1'
- en: '['
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '['
- en: '{'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"creation_date": "Wed, 20 Jul 2016 05:32:06 -0000",'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '"creation_date": "Wed, 20 Jul 2016 05:32:06 -0000",'
- en: '"duration": 10,'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '"duration": 10,'
- en: '"id": 1,'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '"id": 1,'
- en: '"message": "Welcome to IoT",'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '"message": "欢迎来到物联网",'
- en: '"message_category": "Information",'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '"message_category": "信息",'
- en: '"printed_once": false,'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '"printed_once": false,'
- en: '"printed_times": 0,'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '"printed_times": 0,'
- en: '"uri": "/api/messages/1"'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '"uri": "/api/messages/1"'
- en: '},'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '{'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"creation_date": "Wed, 20 Jul 2016 05:32:18 -0000",'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '"creation_date": "Wed, 20 Jul 2016 05:32:18 -0000",'
- en: '"duration": 5,'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '"duration": 5,'
- en: '"id": 2,'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '"id": 2,'
- en: '"message": "Measuring ambient temperature",'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '"message": "测量环境温度",'
- en: '"message_category": "Information",'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '"message_category": "信息",'
- en: '"printed_once": false,'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '"printed_once": false,'
- en: '"printed_times": 0,'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '"printed_times": 0,'
- en: '"uri": "/api/messages/2"'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '"uri": "/api/messages/2"'
- en: '}'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ']'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '[PRE42]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 127.0.0.1 - - [20/Jul/2016 02:32:06] "POST /api/messages/ HTTP/1.1" 201 -
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 127.0.0.1 - - [20/Jul/2016 02:32:06] "POST /api/messages/ HTTP/1.1" 201 -
- en: 127.0.0.1 - - [20/Jul/2016 02:32:18] "POST /api/messages/ HTTP/1.1" 201 -
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 127.0.0.1 - - [20/Jul/2016 02:32:18] "POST /api/messages/ HTTP/1.1" 201 -
- en: 127.0.0.1 - - [20/Jul/2016 02:32:28] "GET /api/messages/ HTTP/1.1" 200 -
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 127.0.0.1 - - [20/Jul/2016 02:32:28] "GET /api/messages/ HTTP/1.1" 200 -
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: http :5000/api/messages/800
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: http :5000/api/messages/800
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: curl -iX GET :5000/api/messages/800
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: curl -iX GET :5000/api/messages/800
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: HTTP/1.0 404 NOT FOUND
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.0 404 NOT FOUND
- en: 'Content-Length: 138'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 'Content-Length: 138'
- en: 'Content-Type: application/json'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 'Content-Type: application/json'
- en: 'Date: Wed, 20 Jul 2016 18:08:04 GMT'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：Wed, 20 Jul 2016 18:08:04 GMT
- en: 'Server: Werkzeug/0.11.10 Python/3.5.1'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 'Server: Werkzeug/0.11.10 Python/3.5.1'
- en: '{'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"message": "Message 800 doesn''t exist. You have requested this URI [/api/messages/800]
    but did you mean /api/messages/<int:id> ?"'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '"message": "消息 800 不存在。您请求了这个 URI [/api/messages/800]，但您是指 /api/messages/<int:id>
    吗？"'
- en: '}'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: http PATCH :5000/api/messages/2 printed_once=true printed_times=1
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: http PATCH :5000/api/messages/2 printed_once=true printed_times=1
- en: '[PRE47]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'curl -iX PATCH -H "Content-Type: application/json" -d ''{"printed_once":"true",
    "printed_times":1}'' :5000/api/messages/2'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 'curl -iX PATCH -H "Content-Type: application/json" -d ''{"printed_once":"true",
    "printed_times":1}'' :5000/api/messages/2'
- en: '[PRE48]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: HTTP/1.0 200 OK
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.0 200 OK
- en: 'Content-Length: 231'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 'Content-Length: 231'
- en: 'Content-Type: application/json'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 'Content-Type: application/json'
- en: 'Date: Wed, 20 Jul 2016 18:28:01 GMT'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：Wed, 20 Jul 2016 18:28:01 GMT
- en: 'Server: Werkzeug/0.11.10 Python/3.5.1'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 'Server: Werkzeug/0.11.10 Python/3.5.1'
- en: '{'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"creation_date": "Wed, 20 Jul 2016 18:27:05 -0000",'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '"creation_date": "Wed, 20 Jul 2016 18:27:05 -0000",'
- en: '"duration": 0,'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '"duration": 0,'
- en: '"id": 2,'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '"id": 2,'
- en: '"message": "Measuring ambient temperature",'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '"message": "测量环境温度",'
- en: '"message_category": "Information",'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '"message_category": "Information",'
- en: '"printed_once": true,'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '"printed_once": true,'
- en: '"printed_times": 1,'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '"printed_times": 1,'
- en: '"uri": "/api/messages/2"'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '"uri": "/api/messages/2"'
- en: '}'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE49]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: http DELETE :5000/api/messages/2
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: http DELETE :5000/api/messages/2
- en: '[PRE50]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: curl -iX DELETE :5000/api/messages/2
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: curl -iX DELETE :5000/api/messages/2
- en: '[PRE51]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: HTTP/1.0 204 NO CONTENT
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.0 204 NO CONTENT
- en: 'Content-Length: 0'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 'Content-Length: 0'
- en: 'Content-Type: application/json'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 'Content-Type: application/json'
- en: 'Date: Wed, 20 Jul 2016 18:50:12 GMT'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：Wed, 20 Jul 2016 18:50:12 GMT
- en: 'Server: Werkzeug/0.11.10 Python/3.5.1'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 'Server: Werkzeug/0.11.10 Python/3.5.1'
- en: '[PRE52]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '{'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"message": "Measuring distance",'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '"message": "测量距离",'
- en: '"duration": 5,'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '"duration": 5,'
- en: '"message_category": "Information"'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '"message_category": "Information"'
- en: '}'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The following screenshot shows the request body in Postman:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 Postman 中的请求体：
- en: '![Working with GUI tools - Postman and others](img/image_05_004.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![使用 GUI 工具 - Postman 及其他](img/image_05_004.jpg)'
- en: 'We followed the necessary steps to create an HTTP POST request with a JSON
    body that specifies the necessary key-value pairs to create a new game. Click
    **Send** and Postman will display the Status (**201 Created**), the time it took
    for the request to be processed and the response body with the recently added
    game formatted as JSON with syntax highlighting (**Pretty** view). The following
    screenshot shows the JSON response body in Postman for the HTTP POST request:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循了必要的步骤来创建一个带有 JSON 体的 HTTP POST 请求，该请求指定了创建新游戏所需的关键字段值对。点击**发送**，Postman
    将显示状态（**201 已创建**），请求处理所需的时间以及以格式化 JSON 并具有语法高亮（**美化**视图）的响应体。以下截图显示了 Postman
    中 HTTP POST 请求的 JSON 响应体：
- en: '![Working with GUI tools - Postman and others](img/image_05_005.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![使用 GUI 工具 - Postman 及其他](img/image_05_005.jpg)'
- en: Tip
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If we want to compose and send an HTTP PATCH request for our API with Postman,
    it is necessary to follow the previously explained steps to provide JSON data
    within the request body.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用 Postman 为我们的 API 编写并发送 HTTP PATCH 请求，必须遵循之前解释的步骤，在请求体中提供 JSON 数据。
- en: Click or tap on the value for the url field in the JSON response body-`/api/messages/2`.
    You will notice that the value will be underlined when you hover the mouse pointer
    over it. Postman will automatically generate a `GET` request to `localhost:5000/api/messages/2`.
    Click **Send** to run it and retrieve the recently added message. The field is
    useful to browse the API with a tool such as Postman.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 点击或轻触 JSON 响应体中 url 字段的值 -`/api/messages/2`。当您将鼠标指针悬停在它上面时，您会注意到值会被下划线。Postman
    将自动生成一个到 `localhost:5000/api/messages/2` 的 `GET` 请求。点击**发送**来运行它并检索最近添加的消息。该字段对于使用
    Postman 等工具浏览 API 很有用。
- en: Because we made the necessary changes to generate an externally visible Flask
    development server, we can also use apps that can compose and send HTTP requests
    from mobile devices to work with the RESTful API. For example, we can work with
    the iCurlHTTP App on iOS devices such as iPad Pro and iPhone. In Android devices,
    we can work with the previously introduced HTTP Request App.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对生成外部可见的 Flask 开发服务器进行了必要的更改，我们还可以使用能够从移动设备编写并发送 HTTP 请求的应用程序来与 RESTful
    API 一起工作。例如，我们可以在 iPad Pro 和 iPhone 等iOS设备上使用 iCurlHTTP 应用程序。在 Android 设备上，我们可以使用之前介绍的
    HTTP Request 应用程序。
- en: 'The following screenshot shows the results of composing and sending the following
    HTTP request with the iCurlHTTP App: `GET http://192.168.2.3:5000/api/messages/`.
    Remember that you have to perform the previously explained configurations in your
    LAN and router to be able to access the Flask development server from other devices
    connected to your LAN. In this case, the IP assigned to the computer running the
    Flask Web server is `192.168.2.3`, and therefore, you must replace this IP with
    the IP assigned to your development computer.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了使用iCurlHTTP App组合和发送以下HTTP请求的结果：`GET http://192.168.2.3:5000/api/messages/`。请记住，你必须在你的LAN和路由器中执行之前解释的配置，才能从连接到你的LAN的其他设备访问Flask开发服务器。在这种情况下，运行Flask
    Web服务器的计算机分配的IP地址是`192.168.2.3`，因此，你必须将此IP替换为分配给你的开发计算机的IP地址。
- en: '![Working with GUI tools - Postman and others](img/image_05_006.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![使用GUI工具 - Postman和其他工具](img/image_05_006.jpg)'
- en: Test your knowledge
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: Flask-RESTful uses which of the following as the main building block for a RESTful
    API?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flask-RESTful使用以下哪个作为构建RESTful API的主要构建块？
- en: Resources built on top of Flask pluggable views
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于Flask可插拔视图构建的资源
- en: Statuses built on top of Flask resource views.
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于Flask资源视图构建的状态。
- en: Resources built on top of Flask pluggable controllers.
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于Flask可插拔控制器的资源。
- en: In order to be able to process an HTTP POST request on a resource, we must declare
    a method with the following name in a subclass of `flask_restful.Resource`.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够处理资源上的HTTP POST请求，我们必须在`flask_restful.Resource`的子类中声明一个具有以下名称的方法。
- en: '`post_restful`'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`post_restful`'
- en: '`post_method`'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`post_method`'
- en: '`post`'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`post`'
- en: In order to be able to process an HTTP `GET` request on a resource, we must
    declare a method with the following name in a subclass of `flask_restful.Resource`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够处理资源上的HTTP `GET`请求，我们必须在`flask_restful.Resource`的子类中声明一个具有以下名称的方法。
- en: '`get_restful`'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get_restful`'
- en: '`get_method`'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get_method`'
- en: '`get`'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get`'
- en: 'A subclass of `flask_restful.Resource` represents:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`flask_restful.Resource`的子类表示：'
- en: '`A controller resource.`'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`一个控制器资源。`'
- en: '`A RESTful resource.`'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`一个RESTful资源。`'
- en: '` A single RESTful HTTP verb.`'
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`一个单一的RESTful HTTP动词。`'
- en: 'If we use the `@marshal_with` decorator with `message_fields` as an argument,
    the decorator will:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们使用`@marshal_with`装饰器并将`message_fields`作为参数，装饰器将：
- en: Apply the field filtering and output formatting specified in `message_fields`
    to the appropriate instance.
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`message_fields`中指定的字段过滤和输出格式应用于适当的实例。
- en: Apply the field filtering specified in `message_fields` to the appropriate instance,
    without considering output formatting.
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`message_fields`中指定的字段过滤应用于适当的实例，不考虑输出格式。
- en: Apply the output formatting specified in `message_fields` to the appropriate
    instance, without considering field filtering.
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`message_fields`中指定的输出格式应用于适当的实例，不考虑字段过滤。
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we designed a RESTful API to interact with a simple dictionary
    that acted as a data repository and perform CRUD operations with messages. We
    defined the requirements for our API and we understood the tasks performed by
    each HTTP method. We set up a virtual environment with Flask and Flask-RESTful.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设计了一个RESTful API来与一个简单的字典交互，该字典充当数据存储库，并使用消息执行CRUD操作。我们定义了我们API的要求，并理解了每个HTTP方法执行的任务。我们使用Flask和Flask-RESTful设置了虚拟环境。
- en: We created a model to represent and persist messages. We learned to configure
    serialization of messages into JSON representations with the features included
    in Flask-RESTful. We wrote classes that represent resources and process the different
    HTTP requests and we configured the URL patterns to route URLs to classes.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个模型来表示和持久化消息。我们学会了使用Flask-RESTful中包含的功能配置消息的序列化为JSON表示。我们编写了代表资源并处理不同HTTP请求的类，并配置了URL模式以将URL路由到类。
- en: Finally, we started Flask development server and we used command-line tools
    to compose and send HTTP requests to our RESTful API and analyzed how each HTTP
    request was processed in our code. We also worked with GUI tools to compose and
    send HTTP requests.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们启动了Flask开发服务器，并使用命令行工具来组合和发送HTTP请求到我们的RESTful API，并分析了我们的代码中如何处理每个HTTP请求。我们还使用GUI工具来组合和发送HTTP请求。
- en: Now that we understand the basics of the combination of Flask and Flask-RESTful
    to create RESTful APIs, we will expand the capabilities of the RESTful Web API
    by taking advantage of advanced features included in Flask-RESTful and related
    ORMs, which is what we are going to discuss in the next chapter.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何结合 Flask 和 Flask-RESTful 创建 RESTful API 的基础知识，我们将通过利用 Flask-RESTful
    和相关 ORM 包含的高级功能来扩展 RESTful Web API 的功能，这正是我们将在下一章中讨论的内容。
