- en: Chapter 14. Extensions in C/C++, System Calls, and C/C++ Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。C/C++扩展，系统调用和C/C++库
- en: Now that we know a bit more about performance and multiprocessing, we will explain
    another subject that is at least somewhat performance-related—the usage of C and/or
    C++ extensions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对性能和多处理有了更多了解，我们将解释另一个至少与性能有关的主题——使用C和/或C++扩展。
- en: There are multiple reasons to consider C/C++ extensions. Having existing libraries
    available is an important one, but truthfully, the most important reason is performance.
    In [Chapter 12](ch12.html "Chapter 12. Performance – Tracking and Reducing Your
    Memory and CPU Usage"), *Performance – Tracking and Reducing Your Memory and CPU
    Usage*, we saw that the `cProfile` module is about 10 times faster than the `profile`
    module, which indicates that at least some C extensions are faster than their
    pure Python equivalents. This chapter will not focus on performance that much,
    however. The goal here is interaction with non-Python libraries. Any performance
    improvement will just be a completely unintentional side effect.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个原因需要考虑C/C++扩展。拥有现有库可用是一个重要原因，但实际上，最重要的原因是性能。在[第12章](ch12.html "第12章。性能-跟踪和减少内存和CPU使用情况")中，*性能-跟踪和减少内存和CPU使用情况*，我们看到`cProfile`模块大约比`profile`模块快10倍，这表明至少一些C扩展比它们的纯Python等效快。然而，本章不会太注重性能。这里的目标是与非Python库的交互。任何性能改进只会是一个完全无意的副作用。
- en: 'We will discuss the following options in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下选项：
- en: Ctypes for handling foreign (C/C++) functions and data from Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于处理Python中的外部（C/C++）函数和数据的Ctypes
- en: '**CFFI** (short for **C Foreign Function Interface**), similar to `ctypes`
    but with a slightly different approach'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CFFI**（**C Foreign Function Interface**的缩写），类似于`ctypes`但是有稍微不同的方法'
- en: Writing native C/C++ to extend Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本机C/C++扩展Python
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Before you start with this chapter, it is important to note that this chapter
    will require a working compiler that plays nicely with your Python interpreter.
    Unfortunately, these vary from platform to platform. While generally easy enough
    for most Linux distributions, this can be a big challenge on Windows. With OS
    X, it's generally easy enough provided you install the correct tools.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本章之前，重要的是要注意，本章将需要一个与你的Python解释器良好配合的工作编译器。不幸的是，这些因平台而异。虽然对于大多数Linux发行版来说通常很容易，但在Windows上可能是一个很大的挑战。对于OS
    X来说，通常很容易，只要你安装了正确的工具。
- en: 'The generic building instructions are always available in the Python manual:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通用的构建说明始终可以在Python手册中找到：
- en: '[https://docs.python.org/3.5/extending/building.html](https://docs.python.org/3.5/extending/building.html)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3.5/extending/building.html](https://docs.python.org/3.5/extending/building.html)'
- en: Do you need C/C++ modules?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你需要C/C++模块吗？
- en: In almost all cases, I'm inclined to say that you don't need C/C++ modules.
    If you are really strapped for best performance, then there are almost always
    highly optimized libraries available that fit your purpose. There are some cases
    where native C/C++ (or just "not Python") is a requirement. If you need to communicate
    directly with hardware that has specific timings, then Python might just not do
    the trick for you. Generally, however, that kind of communication should be left
    to a driver that takes care of the specific timings. Regardless, even if you will
    never write one of these modules yourself, you might still need to know how they
    work when you are debugging a project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有情况下，我倾向于说你不需要C/C++模块。如果你真的需要最佳性能，那么几乎总是有高度优化的库可用来满足你的目的。有一些情况下，需要本机C/C++（或者只是“不是Python”）。如果你需要直接与具有特定时间的硬件通信，那么Python可能对你来说行不通。然而，一般来说，这种通信应该留给负责特定时间的驱动程序。无论如何，即使你永远不会自己编写这些模块之一，当你调试项目时，你可能仍然需要知道它们的工作原理。
- en: Windows
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows
- en: 'For Windows, the general recommendation is Visual Studio. The specific version
    depends on your Python version:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows，一般建议使用Visual Studio。具体的版本取决于你的Python版本：
- en: 'Python 3.2 and lower: Microsoft Visual Studio 2008'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.2及更低版本：Microsoft Visual Studio 2008
- en: 'Python 3.3 and 3.4: Microsoft Visual Studio 2010'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.3和3.4：Microsoft Visual Studio 2010
- en: 'Python 3.5 and 3.6: Microsoft Visual Studio 2015'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.5和3.6：Microsoft Visual Studio 2015
- en: 'The specifics of installing Visual Studio and compiling Python modules fall
    a bit outside of the scope of this book. Luckily, the Python documentation has
    some documentation available to get you started:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Visual Studio和编译Python模块的具体细节有点超出了本书的范围。幸运的是，Python文档中有一些文档可以帮助你入门：
- en: '[https://docs.python.org/3.5/extending/windows.html](https://docs.python.org/3.5/extending/windows.html)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3.5/extending/windows.html](https://docs.python.org/3.5/extending/windows.html)'
- en: OS X
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OS X
- en: For a Mac, the process is mostly straightforward, but there are a few tips specific
    to OS X.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Mac，这个过程大多是直接的，但是有一些特定于OS X的技巧。
- en: 'First, install Xcode through the Mac App Store. Once you have done that, you
    should be able to run the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过Mac App Store安装Xcode。一旦你这样做了，你应该能够运行以下命令：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next up is the fun part. Because OS X comes with a bundled Python version (which
    is generally out of date), I would recommend installing a new Python version through
    Homebrew instead. The most up-to-date instructions for installing Homebrew can
    be found on the Homebrew homepage ([http://brew.sh/](http://brew.sh/)), but the
    gist of installing Homebrew is this command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是有趣的部分。因为OS X带有捆绑的Python版本（通常已过时），我建议通过Homebrew安装一个新的Python版本。安装Homebrew的最新说明可以在Homebrew主页上找到（[http://brew.sh/](http://brew.sh/)），但安装Homebrew的要点是这个命令：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After that, make sure you check whether everything is set up correctly using
    the `doctor` command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，确保使用`doctor`命令检查一切是否设置正确：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When all of this is done, simply install Python through Homebrew and make sure
    you use that Python release when executing your scripts:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有这些都完成时，只需通过Homebrew安装Python，并确保在执行脚本时使用该Python版本：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Also ensure that the Python process is in `/usr/local/bin`, that is, the homebrewed
    version. The regular OS X version would be in `/usr/bin/` instead.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 还要确保Python进程在`/usr/local/bin`中，也就是自制版本。常规的OS X版本将在`/usr/bin/`中。
- en: Linux/Unix
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux/Unix
- en: The installation for Linux/Unix systems greatly depends on the distribution,
    but it is generally simple to do.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Linux/Unix系统的安装在很大程度上取决于发行版，但通常很简单。
- en: 'For Fedora, Red Hat, Centos, and other systems that use `yum` as the package
    manager, use these lines:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用`yum`作为软件包管理器的Fedora、Red Hat、Centos和其他系统，请使用以下命令：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For Debian, Ubuntu, and other systems that use `apt` as the package manager,
    use the following line:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用`apt`作为软件包管理器的Debian、Ubuntu和其他系统，请使用以下命令：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that Python 3.5 is not available everywhere yet, so you might need Python
    3.4 instead.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Python 3.5并不是随处都可用的，所以您可能需要使用Python 3.4。
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For most systems, to get help with the installation, a web search along the
    lines of `<operating system> python.h` should do the trick.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数系统，要获取安装帮助，可以通过类似`<操作系统> python.h`的网页搜索来解决问题。
- en: Calling C/C++ with ctypes
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ctypes调用C/C++
- en: The `ctypes` library makes it easily possible to call functions from C libraries,
    but you do need to be careful with memory access and data types. Python is generally
    very lenient in memory allocation and type casting; C is, most definitely, not
    that forgiving.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctypes`库使得从C库调用函数变得非常容易，但您需要小心内存访问和数据类型。Python在内存分配和类型转换方面通常非常宽容；C则绝对不是那么宽容。'
- en: Platform-specific libraries
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定于平台的库
- en: Even though all platforms will have a standard C library available somewhere,
    the location and the method of calling it differs per platform. For the purpose
    of having a simple environment that is easily accessible to most people, I will
    assume the use of an Ubuntu (virtual) machine. If you don't have a native Ubuntu
    available, you can easily run it through VirtualBox on Windows, Linux, and OS
    X.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有平台都将在某个地方提供标准的C库，但其位置和调用方法因平台而异。为了拥有一个对大多数人来说易于访问的简单环境，我将假设使用Ubuntu（虚拟）机器。如果您没有本机Ubuntu可用，您可以在Windows、Linux和OS
    X上通过VirtualBox轻松运行它。
- en: Since you will often want to run examples on your native system instead, we
    will first show the basics of loading `printf` from the standard C library.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您通常希望在本机系统上运行示例，我们将首先展示从标准C库中加载`printf`的基础知识。
- en: Windows
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows
- en: 'One problem of calling C functions from Python is that the default libraries
    are platform-specific. While the following example will work just fine on Windows
    systems, it won''t run on other platforms:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python调用C函数的一个问题是默认库是特定于平台的。虽然以下示例在Windows系统上可以正常运行，但在其他平台上则无法运行：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Because of these limitations, not all examples can work for every Python version
    and distribution without requiring manual compilation. The basic premise of calling
    functions from external libraries functions is to simply access their names as
    properties of the `ctypes` import. There is a difference, however; on Windows,
    the modules will generally be auto-loaded, while on Linux/Unix systems, you will
    need to load them manually.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些限制，不是所有示例都可以在每个Python版本和发行版上工作，而不需要手动编译。从外部库调用函数的基本前提是简单地将它们的名称作为`ctypes`导入的属性来访问。然而，有一个区别；在Windows上，模块通常会自动加载，而在Linux/Unix系统上，您需要手动加载它们。
- en: Linux/Unix
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux/Unix
- en: 'Calling standard system libraries from Linux/Unix does require manual loading,
    but it''s nothing too involved luckily. Fetching the `printf` function from the
    standard C library is quite simple:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从Linux/Unix调用标准系统库确实需要手动加载，但幸运的是这并不太复杂。从标准C库中获取`printf`函数非常简单：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: OS X
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OS X
- en: 'For OS X, explicit loading is also required, but beyond that, it is quite similar
    to how everything works on regular Linux/Unix systems:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于OS X，也需要显式加载，但除此之外，它与常规Linux/Unix系统上的所有工作方式非常相似：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Making it easy
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使其变得简单
- en: 'Besides the way libraries are loaded, there are more differences—unfortunately—but
    these examples at least give you the standard C library. It allows you to call
    functions such as `printf` straight from your C implementation. If, for some reason,
    you have trouble loading the right library, there is always the `ctypes.util.find_library`
    function. As always, I recommend explicit over implicit declarations, but things
    can be made easier using this function. Let''s illustrate a run on an OS X system:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了加载库的方式不同之外，还有更多的差异，但这些示例至少给出了标准的C库。它允许您直接从C实现中调用诸如`printf`之类的函数。如果由于某种原因，您在加载正确的库时遇到问题，总是可以使用`ctypes.util.find_library`函数。我始终建议显式声明而不是隐式声明，但使用这个函数可以使事情变得更容易。让我们在OS
    X系统上进行一次运行：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Calling functions and native types
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用函数和本机类型
- en: 'Calling a function through `ctypes` is nearly as simple as calling native Python
    functions. The notable difference is the arguments and return statements. These
    should be converted to native C variables:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ctypes`调用函数几乎和调用本机Python函数一样简单。显著的区别在于参数和返回语句。这些应该转换为本机C变量：
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These examples will assume that you have `libc` in your scope from one of the
    examples in the previous paragraphs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例将假定您在前几段中的一个示例中已经将`libc`纳入了范围。
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, to call the `printf` function you *must*—and I cannot stress
    this enough—convert your values from Python to C explicitly. While it might appear
    to work without this initially, it really doesn''t:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，要调用`printf`函数，您*必须*——我无法再次强调这一点——将您的值从Python显式转换为C。虽然最初可能看起来可以工作，但实际上并不行：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to use the `faulthandler` module from [Chapter 11](ch11.html "Chapter 11. Debugging
    – Solving the Bugs"), *Debugging – Solving the Bugs* to debug segfaults.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住使用[第11章](ch11.html "第11章。调试-解决错误")中的`faulthandler`模块，*调试-解决错误*来调试段错误。
- en: Another thing to note from the example is that `ctypes.sizeof(spam)` returns
    `5` instead of `4`. This is caused by the trailing null character, which C strings
    require. This is visible in the raw property of the C string. Without it, the
    `printf` function won't know where the string will end.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中需要注意的另一件事是 `ctypes.sizeof(spam)` 返回 `5` 而不是 `4`。这是由 C 字符串所需的尾随空字符引起的。这在
    C 字符串的原始属性中是可见的。如果没有它，`printf` 函数就不知道字符串在哪里结束。
- en: 'To pass along other types (such as integers) towards `libc` functions, we have
    to use some conversion as well. In some cases, it is optional:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其他类型（如整数）传递给 `libc` 函数，我们也必须进行一些转换。在某些情况下，这是可选的：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But not in all cases, so it''s definitely recommended that you convert your
    values explicitly in all cases:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但并非所有情况都是如此，因此强烈建议您在所有情况下明确转换您的值：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It''s important to note that even though these values are usable as native
    C types, they are still mutable through the `value` attribute:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，即使这些值可以用作本机 C 类型，它们仍然可以通过 `value` 属性进行更改：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: However, this is not the case if the original object was immutable, which is
    a very important distinction to make. The `create_string_buffer` object creates
    a mutable string object, whereas `c_wchar_p`, `c_char_p`, and `c_void_p` create
    references to the actual Python string. Since strings are immutable in Python,
    these values are also immutable. You can still change the `value` property, but
    it will only assign a new string. Actually, passing one of these to a C function
    that mutates the internal value will cause problems.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果原始对象是不可变的，情况就不同了，这是一个非常重要的区别。`create_string_buffer` 对象创建一个可变的字符串对象，而 `c_wchar_p`、`c_char_p`
    和 `c_void_p` 创建对实际 Python 字符串的引用。由于字符串在 Python 中是不可变的，这些值也是不可变的。你仍然可以更改 `value`
    属性，但它只会分配一个新的字符串。实际上，将其中一个传递给会改变内部值的 C 函数会导致问题。
- en: The only values that should convert to C without any issues are integers, strings,
    and bytes, but I personally recommend that you always convert all of your values
    so that you are certain of which type you will get and how to treat it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 应该毫无问题地转换为 C 的唯一值是整数、字符串和字节，但我个人建议你始终转换所有的值，这样你就可以确定你将得到哪种类型以及如何处理它。
- en: Complex data structures
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂的数据结构
- en: 'We have already seen that we can''t just pass along Python values to C, but
    what if we need more complex objects? That is, not just bare values that are directly
    translatable to C but complex objects containing multiple values. Luckily, we
    can easily create (and access) C structures using `ctypes`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们不能简单地将 Python 值传递给 C，但如果我们需要更复杂的对象呢？也就是说，不仅仅是直接可转换为 C 的裸值，而是包含多个值的复杂对象。幸运的是，我们可以很容易地使用
    `ctypes` 创建（和访问）C 结构：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Arrays
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: Within Python, we generally use a list to represent a collection of objects.
    These are very convenient in that you can easily add and remove values. Within
    C, the default collection object is the array, which is just a block of memory
    with a fixed size.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们通常使用列表来表示对象的集合。这些非常方便，因为你可以很容易地添加和删除值。在 C 中，默认的集合对象是数组，它只是一个具有固定大小的内存块。
- en: The size of the block in bytes is decided by multiplying the number of items
    with the size of the type. In the case of a `char`, this is `8` bits, so if you
    wish to store `100` chars, you would have `100 * 8 bits = 800 bits = 100 bytes`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以字节为单位的块的大小是通过将项数乘以类型的大小来决定的。在 `char` 的情况下，这是 `8` 位，所以如果你想存储 `100` 个字符，你将有 `100
    * 8 位 = 800 位 = 100 字节`。
- en: 'This is literally all it is—a block of memory—and the only reference you receive
    from C is a pointer to the memory address where the block of memory begins. Since
    the pointer does have a type, `char*` in this case, C will know how many bytes
    to jump ahead when trying to access a different item. Effectively, when trying
    to access item 25 in a `char` array, you simply need to do `array_pointer + 25
    * sizeof(char)`. This has a convenient shortcut: `array_pointer[25]`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上就是一个内存块，C 给你的唯一引用是指向内存块起始地址的指针。由于指针有类型，在这种情况下是 `char*`，C 就知道在尝试访问不同项时需要跳过多少字节。实际上，在尝试访问
    `char` 数组中的第 25 项时，你只需要执行 `array_pointer + 25 * sizeof(char)`。这有一个方便的快捷方式：`array_pointer[25]`。
- en: Note that C does not store the number of items in the array, so even though
    our array has only 100 items, it won't block us from doing `array_pointer[1000]`
    and reading other (random) memory.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，C 不会存储数组中的项数，因此即使我们的数组只有 100 项，我们也可以执行 `array_pointer[1000]` 并读取其他（随机）内存。
- en: 'If you take all of that into account, it is definitely usable, but mistakes
    are quickly made and C is unforgiving. No warnings, just crashes and strangely
    behaving code. Beyond that, let''s see how easily we can declare an array with
    `ctypes`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑了所有这些，它绝对是可用的，但错误很快就会发生，而且 C 是不可原谅的。没有警告，只有崩溃和奇怪的行为代码。除此之外，让我们看看我们如何使用
    `ctypes` 轻松地声明一个数组：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, because of the fixed sizes and the requirement of declaring
    the type before using it, its usage is slightly awkward. However, it does function
    as you would expect, and the values are initialized to zero by default. Obviously,
    this can be combined with the previously discussed structures as well:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，由于固定的大小和在使用之前声明类型的要求，它的使用略显笨拙。然而，它确实像你期望的那样运行，并且这些值默认初始化为零。显然，这也可以与先前讨论的结构相结合：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Even though you cannot simply append to these arrays to resize them, they are
    actually resizable with a few constraints. Firstly, the new array needs to be
    larger than the original array. Secondly, the size needs to be specified in bytes,
    not items. To illustrate, we have this example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你不能简单地追加这些数组来调整它们的大小，但它们实际上是可调整大小的，有一些限制。首先，新数组的大小需要大于原始数组。其次，大小需要以字节为单位指定，而不是项数。举个例子，我们有这个例子：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Gotchas with memory management
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理的注意事项
- en: 'Besides the obvious memory allocation issues and mixing mutable and immutable
    objects, there is one more strange memory mutability issue:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了明显的内存分配问题和混合可变和不可变对象之外，还有一个奇怪的内存可变性问题：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Why didn't we get `2, 3, 4, 5, 0, 1`? The problem is that these objects are
    copied to a temporary buffer variable. In the meantime, the values of that object
    are being changed because it contains separate objects internally. After that,
    the object is transferred back, but the values have already changed, giving the
    incorrect results.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们没有得到`2, 3, 4, 5, 0, 1`？问题在于这些对象被复制到一个临时缓冲变量中。与此同时，该对象的值正在发生变化，因为它在内部包含了单独的对象。之后，对象被传回，但值已经改变，导致了不正确的结果。
- en: CFFI
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CFFI
- en: 'The `CFFI` library offers options very similar to `ctypes`, but it''s a bit
    more direct. Unlike the `ctypes` library, a C compiler is really a necessity for
    `CFFI`. With it comes the opportunity to directly call your C compiler in a very
    easy way:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`CFFI`库提供了与`ctypes`非常相似的选项，但它更直接一些。与`ctypes`库不同，C编译器对于`CFFI`来说确实是必需的。它带来了直接以非常简单的方式调用你的C编译器的机会：'
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Okay… so that looks a bit weird right? We had to define how the `printf` function
    looks and specify the arguments to `printf` with a valid C type declaration. Getting
    back to the declarations, however, instead of `None` to `ffi.dlopen`, you can
    also specify the library you wish to load. If you remember the `ctypes.util.find_library`
    function, you can use that again in this case:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧...看起来有点奇怪对吧？我们不得不定义`printf`函数的外观，并用有效的C类型声明指定`printf`的参数。然而，回到声明，而不是`None`到`ffi.dlopen`，你也可以指定你希望加载的库。如果你记得`ctypes.util.find_library`函数，你可以在这种情况下再次使用它：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: But it still won't make its definitions readily available for you. The function
    definitions are still required to make sure that everything works as you would
    like it to.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但它仍然不会为你提供其定义。函数定义仍然是必需的，以确保一切都按照你希望的方式工作。
- en: Complex data structures
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂的数据结构
- en: 'The `CFFI` definitions are somewhat similar to the `ctypes` definitions, but
    instead of having Python emulating C, it''s just plain C that is accessible from
    Python. In reality, it''s just a small syntactical difference. Whereas `ctypes`
    is a library for accessing C from Python while remaining as close to the Python
    syntax as possible, `CFFI` uses plain C syntax to access C systems, which actually
    removes some confusion for people experienced with C. I personally find `CFFI`
    easier to use because I know what is actually happening, whereas I am not always
    a 100% certain with `ctypes`. Let''s repeat the `Vertex` and `Point` example with
    CFFI:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`CFFI`的定义与`ctypes`的定义有些相似，但不是让Python模拟C，而是直接从Python访问纯C。实际上，这只是一个小的语法差异。而`ctypes`是一个用于从Python访问C的库，同时尽可能接近Python语法，`CFFI`使用纯C语法来访问C系统，这实际上消除了一些对于熟悉C的人的困惑。我个人发现`CFFI`更容易使用，因为我知道实际发生了什么，而对于`ctypes`，我并不总是100%确定。让我们用CFFI重复`Vertex`和`Point`的例子：'
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, the mutable variable issues remain but the code is just as usable.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，可变变量问题仍然存在，但代码仍然是可以使用的。
- en: Arrays
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'Allocation memory for new variables is almost trivial with `CFFI`. The previous
    paragraph showed you an example of array allocation; let''s see the possibilities
    of array definitions now:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CFFI`为新变量分配内存几乎是微不足道的。前面的段落向你展示了数组分配的一个例子；现在让我们看看数组定义的可能性：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this case, you might wonder why the slice includes both the start and the
    stop. This is actually a requirement for `CFFI`. Not always problematic but a
    tad annoying nonetheless. Currently, however, it's unavoidable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可能会想知道为什么切片包括起始和结束。这实际上是`CFFI`的要求。并不总是有问题，但仍然有点烦人。然而，目前，这是不可避免的。
- en: ABI or API?
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ABI还是API？
- en: As always, there are some caveats—unfortunately. The examples so far have partially
    used the ABI, which loads the binary structures from the libraries. With the standard
    C library, this is generally safe; with other libraries, it generally isn't. The
    difference between the API and the ABI is that the latter calls the functions
    at a binary level, directly addressing memory, directly calling memory locations,
    and expecting them to be functions. Effectively, it's the difference between `ffi.dlopen`
    and `ffi.cdef`. Here, the `dlopen` is not always safe but `cdef` is, because it
    passes a compiler instead of just guessing how to call a method.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，还有一些注意事项——不幸的是。到目前为止的例子部分使用了ABI，它从库中加载二进制结构。对于标准C库，这通常是安全的；对于其他库，通常不是。API和ABI之间的区别在于后者在二进制级别调用函数，直接寻址内存，直接调用内存位置，并期望它们是函数。实际上，这是`ffi.dlopen`和`ffi.cdef`之间的区别。在这里，`dlopen`并不总是安全的，但`cdef`是安全的，因为它传递了一个编译器，而不仅仅是猜测如何调用一个方法。
- en: CFFI or ctypes?
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CFFI还是ctypes？
- en: This really depends on what you are looking for. If you have a C library that
    you simply need to call and you don't need anything special, then `ctypes` is
    most likely the better choice. If you're actually writing your own C library and
    trying to link it, well, `CFFI` is probably a more convenient option. If you're
    not familiar with the C programming language, then I would definitely recommend
    `ctypes`. Alternatively, you'll find `CFFI` to be a more convenient option.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上取决于你在寻找什么。如果你有一个C库，只需要调用而且不需要任何特殊的东西，那么`ctypes`很可能是更好的选择。如果你实际上正在编写自己的C库并尝试链接它，那么`CFFI`可能是一个更方便的选择。如果你不熟悉C编程语言，那么我肯定会推荐`ctypes`。或者，你会发现`CFFI`是一个更方便的选择。
- en: Native C/C++ extensions
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地C/C++扩展
- en: The libraries that we have used so far only showed us how to access a C/C++
    library within our Python code. Now we are going to look at the other side of
    the story—how C/C++ functions/modules within Python are actually written and how
    modules such as `cPickle` and `cProfile` are created.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的库只是向我们展示了如何在我们的Python代码中访问C/C++库。现在我们将看看故事的另一面——实际上是如何编写Python中的C/C++函数/模块以及如何创建`cPickle`和`cProfile`等模块。
- en: A basic example
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个基本的例子
- en: 'Before we can actually start with writing and using native C/C++ extensions,
    we have a few prerequisites. First of all, we need the compiler and Python headers;
    the instructions in the beginning of this chapter should have taken care of this
    for us. After that, we need to tell Python what to compile. The `setuptools` package
    mostly takes care of this, but we do need to create a `setup.py` file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际开始编写和使用本地C/C++扩展之前，我们有一些先决条件。首先，我们需要编译器和Python头文件；本章开头的说明应该已经为我们处理了这些。之后，我们需要告诉Python要编译什么。`setuptools`包大部分会处理这个问题，但我们确实需要创建一个`setup.py`文件：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This tells Python that we have an `Extension` object named `Spam` that will
    be based on `spam.c`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Python我们有一个名为`Spam`的`Extension`对象，它将基于`spam.c`。
- en: 'Now, let''s write a function in C that sums all perfect squares (`2*2`, `3*3`,
    and so on) up to a given number. The Python code will look like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在C中编写一个函数，它将对给定数字之前的所有完全平方数（`2*2`，`3*3`等）进行求和。Python代码将如下所示：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The raw C version of this code would look something like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的原始C版本看起来像这样：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And the Python C version looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Python C版本看起来像这样：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It looks quite complicated, but it''s really not that hard. There is just a
    lot of overhead in this case because we only have a single function. Generally,
    you would have several functions, in which case you only need to expand the `spam_methods`
    array and create the functions. The next paragraph will explain the code in more
    detail, but first let''s look at how to run our first example. We need to build
    and install the module:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很复杂，但实际上并不难。在这种情况下，只是有很多额外的开销，因为我们只有一个函数。通常情况下，你会有几个函数，这种情况下你只需要扩展`spam_methods`数组并创建函数。下一段将更详细地解释代码，但首先让我们看一下如何运行我们的第一个示例。我们需要构建并安装模块：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let''s create a little test script to time the difference between the
    Python version and the C version:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个小的测试脚本来测试Python版本和C版本之间的差异：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And now let''s execute it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们执行它：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Perfect! Exactly the same results but more than 200 times faster!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！完全相同的结果，但速度快了200多倍！
- en: C is not Python – size matters
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C不是Python-大小很重要
- en: 'The Python language makes programming so easy that you might forget about the
    underlying data structures at times; with C, you can''t afford to do that. Just
    take our example from the previous chapter but with different parameters:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Python语言使编程变得如此简单，以至于你有时可能会忘记底层数据结构；而在C中，你不能这样做。只需拿我们上一章的示例，但使用不同的参数：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It's still very fast, but what happened to the numbers? The Python and C versions
    give different results, `1953214233` versus `10543148825`. This is caused by integer
    overflows in C. Whereas Python numbers can essentially have any size, with C,
    a regular number has a fixed size. How much you get depends on the type you use
    (`int`, `long`, and so on) and your architecture (32-bit, 64-bit, and so on),
    but it's definitely something to be careful with. It might be hundreds of times
    faster in some cases, but that is meaningless if the results are incorrect.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 它仍然非常快，但数字发生了什么？Python和C版本给出了不同的结果，`1953214233`与`10543148825`。这是由C中的整数溢出引起的。而Python数字基本上可以有任何大小，而C中，常规数字有固定的大小。你得到多少取决于你使用的类型（`int`，`long`等）和你的架构（32位，64位等），但这绝对是需要小心的事情。在某些情况下，它可能快上数百倍，但如果结果不正确，那就毫无意义了。
- en: 'We can increase the size a bit, of course. This makes it better:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以稍微增加一点大小。这样会更好：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we test it now, we realize that it works great:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在测试它，我们会发现它运行得很好：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Unless we make the number even larger:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们使数字更大：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'So how can you fix this? The simple answer is that you can''t. The complex
    answer is that you can if you use a different data type to store your data. The
    C language by itself doesn''t have the "big number support" that Python has. Python
    supports infinitely large numbers by combining several regular numbers in the
    actual memory. Within C, there are no commonly available provisions for this,
    so there is simply no easy way to get this working. But we can check for errors
    instead:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你该如何解决这个问题呢？简单的答案是你不能。复杂的答案是，如果你使用不同的数据类型来存储你的数据，你是可以的。C语言本身并没有Python所具有的“大数支持”。Python通过在实际内存中组合几个常规数字来支持无限大的数字。在C中，没有常见的这种支持，因此没有简单的方法来使其工作。但我们可以检查错误：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that this only works for `PyObject*`, which means it doesn't work for internal
    C overflows. But you can, of course, just keep the original Python long around
    and perform operations on that instead. So, you do have big number support in
    C without too much effort.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这仅适用于`PyObject*`，这意味着它不适用于内部C溢出。但你当然可以保留原始的Python长整型并对其执行操作。因此，你可以在C中轻松获得大数支持。
- en: The example explained
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例解释
- en: 'We have seen the results from our example, but if you''re not familiar with
    the Python C API, you might be confused as to why the function parameters look
    the way they do. The basic calculations within `spam_sum_of_squares` are identical
    to the regular C `sum_of_squares` function, but there are a few small differences.
    Firstly, the type definition for a function using the Python C API should look
    something like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了我们示例的结果，但如果你不熟悉Python C API，你可能会对为什么函数参数看起来像这样感到困惑。`spam_sum_of_squares`中的基本计算与常规C`sum_of_squares`函数是相同的，但有一些小的不同。首先，使用Python
    C API定义函数的类型应该看起来像这样：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: static
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态
- en: This means that the function is `static`. A function that's static can be called
    only from the same translation unit within the compiler. This effectively results
    in a function that cannot be linked from other modules, which allows the compiler
    to optimize a bit further. Since functions in C are global by default, this can
    be very useful to prevent collisions. Just to be sure, however, we have prefixed
    the function name with `spam_` to indicate that this function comes from the `spam`
    module.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着函数是`static`。静态函数只能从编译器内的同一翻译单元中调用。这实际上导致了一个函数，不能从其他模块链接，这允许编译器进一步优化。由于C中的函数默认是全局的，这可以非常有用地防止冲突。但为了确保，我们已经在函数名前加上了`spam_`前缀，以表明这个函数来自`spam`模块。
- en: Be careful not to confuse the word `static` here with the `static` before a
    variable. They are completely different beasts. A `static` variable means that
    the variable that will exist for the entire runtime of the program instead of
    the runtime of just the function.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要小心，不要将此处的`static`与变量前面的`static`混淆。它们是完全不同的东西。`static`变量意味着该变量将存在于整个程序的运行时间，而不仅仅是函数的运行时间。
- en: PyObject*
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PyObject*
- en: The `PyObject` type is the basic type for Python data types, which means that
    all Python objects can be cast to `PyObject*` (the `PyObject` pointer). Effectively,
    it only tells the compiler what kind of properties to expect, which can be used
    later for type identification and memory management. Instead of direct access
    to `PyObject*`, it is generally a better idea to use the available macros, such
    as `Py_TYPE(some_object)`. Internally, this expands to `(((PyObject*)(o))->ob_type)`,
    which is why the macro is generally a better idea. Besides being unreadable, a
    typo can easily happen.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`PyObject`类型是Python数据类型的基本类型，这意味着所有Python对象都可以转换为`PyObject*`（`PyObject`指针）。实际上，它只告诉编译器期望的属性类型，这些属性可以在以后用于类型识别和内存管理。而不是直接访问`PyObject*`，通常最好使用可用的宏，例如`Py_TYPE(some_object)`。在内部，这会扩展为`(((PyObject*)(o))->ob_type)`，这就是为什么宏通常是一个更好的主意。除了难以阅读之外，很容易出现拼写错误。'
- en: 'The list of properties is long and depends greatly on the type of object. For
    those, I would like to refer to the Python documentation:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 属性列表很长，且在很大程度上取决于对象的类型。对于这些，我想参考Python文档：
- en: '[https://docs.python.org/3/c-api/typeobj.html](https://docs.python.org/3/c-api/typeobj.html)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/c-api/typeobj.html](https://docs.python.org/3/c-api/typeobj.html)'
- en: The entire Python C API could fill a book of its own, but it is luckily well
    documented within the Python manual. The usage, on the other hand, might be less
    obvious.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 整个Python C API可以填满一本书，但幸运的是在Python手册中有很好的文档。然而，使用可能不太明显。
- en: Parsing arguments
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析参数
- en: 'With regular C and Python, you specify the arguments explicitly, since variable-sized
    arguments are a bit tricky with C. This is because they need to be parsed separately.
    `PyObject* args` is the reference to objects containing the actual values. To
    parse these, you need to know how many and which type of variables to expect.
    In the example, we used the `PyArg_ParseTuple` function, which parses the arguments
    as positional arguments only, but it is quite easily possible to parse named arguments
    as well using `PyArg_ParseTupleAndKeywords` or `PyArg_VaParseTupleAndKeywords`.
    The difference between the last two is that the first one uses a variable number
    of arguments to specify the destination and the latter uses a `va_list` to set
    the values to. But first, let''s analyze the code from the actual example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常规的C和Python，您需要明确指定参数，因为使用C处理可变大小的参数有点棘手。这是因为它们需要被单独解析。`PyObject* args`是包含实际值的对象的引用。要解析这些，您需要知道期望的变量数量和类型。在示例中，我们使用了`PyArg_ParseTuple`函数，它只解析位置参数，但很容易使用`PyArg_ParseTupleAndKeywords`或`PyArg_VaParseTupleAndKeywords`解析命名参数。最后两者之间的区别在于第一个使用可变数量的参数来指定目的地，而后者使用`va_list`来设置值。但首先，让我们分析一下实际示例中的代码：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We know that `args` is the object containing the reference to the actual arguments.
    The `"i"` is a format string, which in this case will try to parse a single integer.
    And `&n` tells the function to store the value at the memory address of the `n`
    variable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`args`是包含对实际参数的引用的对象。`"i"`是一个格式字符串，在这种情况下将尝试解析一个整数。`&n`告诉函数将值存储在`n`变量的内存地址。
- en: The format string is the important part here. Depending on the character, you
    get a different data type, but there are many; `i` specifies a regular integer,
    and `s` converts your variable to a c-string (actually a `char*`, which is a null-terminated
    character array). It should be noted that this function is, luckily, smart enough
    to take overflows into consideration as well.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串在这里是重要的部分。根据字符的不同，您会得到不同的数据类型，但有很多；`i`指定一个常规整数，`s`将您的变量转换为c字符串（实际上是一个`char*`，它是一个以空字符结尾的字符数组）。值得注意的是，这个函数很幸运地足够聪明，可以考虑到溢出。
- en: 'Parsing multiple arguments is quite similar; you simply need to add multiple
    characters to the format string and multiple destination variables:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 解析多个参数非常类似；您只需要向格式字符串添加多个字符和多个目标变量：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The version with keyword arguments is similar but requires a few more code
    changes as the list of methods needs to be informed that the function takes keyword
    arguments. Otherwise, the `kwargs` parameter would never arrive:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 带有关键字参数的版本类似，但需要进行一些代码更改，因为方法列表需要被告知函数接受关键字参数。否则，`kwargs`参数将永远不会到达：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that this still supports normal arguments, but keyword arguments are also
    supported now.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这仍然支持普通参数，但现在也支持关键字参数。
- en: C is not Python – errors are silent or lethal
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C不是Python-错误是沉默的或致命的
- en: 'As we saw in the previous example, integer overflows are not something you
    will generally notice, and unfortunately there''s no good cross-platform way to
    catch them. However, those are actually the easier errors to handle; the worst
    one is generally memory management. With Python, if you get an error, you will
    get an exception that you can catch. But with C, you can''t really handle it gracefully.
    Take a division by zero for example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的例子中看到的，整数溢出通常不容易注意到，而且不幸的是，没有很好的跨平台方法来捕获它们。然而，这些通常是更容易处理的错误；最糟糕的错误通常是内存管理。使用Python，如果出现错误，您将得到一个可以捕获的异常。但是在C中，您实际上无法优雅地处理它。例如，以零除：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is simple enough to catch with `try: ... except ZeroDivisionError: ...`.
    With C on the other hand, if you get a bad error, it will kill your entire process.
    But debugging C code is what C compilers have debuggers for, and to find the cause
    of the error, you can use the `faulthandler` module discussed in [Chapter 11](ch11.html
    "Chapter 11. Debugging – Solving the Bugs"), *Debugging – Solving the Bugs*. Right
    now, let''s see how we can properly throw errors from C. Let''s use the `spam`
    module from earlier, but for brevity, we will omit the rest of the C code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '这很容易通过`try: ... except ZeroDivisionError: ...`捕获。另一方面，对于C来说，如果出现严重错误，它将终止整个进程。但是，调试C代码是C编译器具有调试器的功能，为了找到错误的原因，您可以使用[第11章](ch11.html
    "第11章。调试-解决错误")中讨论的`faulthandler`模块，*调试-解决错误*。现在，让我们看看如何可以正确地从C中抛出错误。让我们使用之前的`spam`模块，但为了简洁起见，我们将省略其余的C代码：'
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here is the execution:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是执行过程：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The syntax is slightly different—`PyErr_SetString` instead of `raise`—but it's
    the same basic principle, luckily.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 语法略有不同——`PyErr_SetString`而不是`raise`——但基本原理是相同的，幸运的是。
- en: Calling Python from C – handling complex types
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从C调用Python-处理复杂类型
- en: 'We have seen how to call C functions from Python, but now let''s try Python
    from C and back. Instead of using the readily available `sum` function, we will
    build one of our own with a callback and handling of any type of iterable. While
    this sounds simple enough, it does actually require a bit of type meddling as
    you can only expect `PyObject*` as arguments. This is contrary to the simple types,
    such as integers, chars, and strings, which are immediately converted to the native
    Python version:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何从Python调用C函数，但现在让我们尝试从C返回Python。我们将构建一个自己的回调函数，并处理任何类型的可迭代对象，而不是使用现成的`sum`函数。虽然这听起来足够简单，但实际上确实需要一些类型干涉，因为你只能期望`PyObject*`作为参数。这与简单类型相反，例如整数、字符和字符串，它们会立即转换为本机Python版本：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Make sure you note the `PyDECREF` calls, which ensure that you don't leak these
    objects. Without them, the objects will stay in use and the Python interpreter
    won't be able to clear them.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您注意`PyDECREF`调用，这样可以确保您不会泄漏这些对象。如果没有它们，对象将继续使用，Python解释器将无法清除它们。
- en: 'This function is callable in three different ways:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以以三种不同的方式调用：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Another important issue is that even though we catch overflow errors when converting
    to `long long int`, this code is still not safe. If we sum even two very large
    numbers (close to the `long long int` limit), we will still have an overflow:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要问题是，即使我们在转换为`long long int`时捕获了溢出错误，这段代码仍然不安全。如果我们甚至对两个非常大的数字求和（接近`long
    long int`限制），我们仍然会发生溢出：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned the most important aspects of writing code that
    uses `ctypes`, `CFFI`, and how to extend the Python functionality using native
    C. These topics can be extensive enough to fill books on their own, but you should
    have a grasp of the most important topics now. Even though you are able to create
    C/C++ extensions now, I still recommend that you avoid these as much as possible.
    This is because bugs are so easily made by not being careful enough. It is actually
    likely that at least some of the examples given in this chapter contain bugs when
    it comes to memory management and can crash your Python interpreter when given
    the wrong input. Unfortunately, this is a side effect of C. A tiny mistake can
    have a huge impact.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了使用`ctypes`、`CFFI`编写代码以及如何使用本机C扩展Python功能的最重要方面。这些主题本身就足够广泛，可以填满一本书，但是现在您应该掌握了最重要的主题。即使您现在能够创建C/C++扩展，我仍然建议您尽量避免这样做。这是因为不够小心很容易出现错误。实际上，至少本章中的一些示例在内存管理方面可能存在错误，并且在给出错误输入时可能会使您的Python解释器崩溃。不幸的是，这是C的副作用。一个小错误可能会产生巨大的影响。
- en: While building the examples in this chapter, you may have noticed that we used
    a `setup.py` file and imported from the `setuptools` library. This is what the
    next chapter will cover—packaging your code into an installable Python library
    and distributing it on the Python package index.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建本章中的示例时，您可能已经注意到我们使用了一个`setup.py`文件，并从`setuptools`库导入。下一章将涵盖这一点——将您的代码打包成可安装的Python库，并在Python软件包索引上进行分发。
