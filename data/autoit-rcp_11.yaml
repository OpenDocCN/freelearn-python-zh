- en: Chapter 11. Time in the Zone
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 时间在时区中
- en: Time calculations are fun, interesting, and tedious at the same time. Fun, when
    you first learn to read time, interesting, when you learn about daylight saving
    and tedious, when a customer complains about not able to schedule meetings across
    time zones through your web application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 时间计算既有趣又有趣味性，同时也令人厌烦。当你第一次学会读时间时很有趣，当你了解夏令时时很有趣，当客户抱怨无法通过你的Web应用程序安排跨时区的会议时就很烦人。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Working with time, date, and calendar
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理时间、日期和日历
- en: Comparing and combining dates, and date arithmetic
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较和组合日期，以及日期算术
- en: Formatting and parsing dates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期的格式化和解析
- en: Dealing with time zone calculations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理时区计算
- en: Automating invoicing based on time zone
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于时区自动处理发票
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '*"If you love life, don''t waste time, for time is what life is made up of."
                                                                                 
                   --Bruce Lee.*'
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"如果你热爱生命，就不要浪费时间，因为生命就是由时间构成的。" —— 李小龙*'
- en: 'Time is the measure of all things. We have so many things to do in life, and
    yet the irony is we have so much less time on our hands. These days, we plan for
    time intuitively: what time should I travel at to avoid traffic, what''s my deadline
    for this task among many other things, and so on. Businesses plan their activities
    for the complete year even before the calendar begins.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 时间是衡量一切的标准。我们生活中有很多事情要做，然而讽刺的是，我们手头的时间却如此之少。如今，我们直观地规划时间：我应该什么时间出行以避开交通，这项任务的截止日期是什么，以及其他许多事情。企业甚至在日历开始之前就计划了全年的活动。
- en: Time calculations are almost everywhere. Want to schedule a meeting with your
    colleague in Australia? Get the time zone right, work on a good time for you and
    your colleague, and then schedule it. Want to write code to perform a task for
    your customer when the time is right? Manage time objects in the database and
    keep track of all the tasks for your users. Even in the Hollywood movie, *National
    Treasure*, Nicholas Cage had to depend on time zone calculations to get to the
    next clue that took him closer to the treasure.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 时间计算无处不在。你想和你的澳大利亚同事安排会议吗？确保时区正确，找到一个对你和你的同事都合适的时间，然后安排它。你想编写代码在正确的时间为客户执行任务吗？管理数据库中的时间对象并跟踪所有用户的任务。即使在好莱坞电影《国家宝藏》中，尼古拉斯·凯奇也必须依赖时区计算来找到让他更接近宝藏的下一个线索。
- en: Essentially, you can't run away from time calculations wherever you are and
    whatever you do. In this chapter, we will work with `date` and `time` objects
    in Python. We will also learn how to perform arithmetic operations on dates and
    work with time zone calculations. We will also learn how to automate a business
    process based on users' time zone.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，无论你在哪里做什么，都无法逃避时间计算。在本章中，我们将使用Python中的`date`和`time`对象。我们还将学习如何在日期上执行算术运算以及处理时区计算。我们还将学习如何根据用户的时区自动处理业务流程。
- en: 'During the course of this chapter, we will majorly use built-in Python modules.
    The following built-in modules will be used in this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们将主要使用内置的Python模块。本章将使用以下内置模块：
- en: '`datetime` ([https://docs.python.org/2/library/datetime.html](https://docs.python.org/2/library/datetime.html))'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`datetime` ([https://docs.python.org/2/library/datetime.html](https://docs.python.org/2/library/datetime.html))'
- en: '`calendar` ([https://docs.python.org/2/library/calendar.html](https://docs.python.org/2/library/calendar.html))'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calendar` ([https://docs.python.org/2/library/calendar.html](https://docs.python.org/2/library/calendar.html))'
- en: 'We will also use this external module to work with time zones:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用这个外部模块来处理时区：
- en: '`pytz` ([http://pytz.sourceforge.net/](http://pytz.sourceforge.net/))'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytz` ([http://pytz.sourceforge.net/](http://pytz.sourceforge.net/))'
- en: The `pytz` library brings the Olson timezone database into Python. It allows
    accurate and cross-platform timezone calculations in Python 2\. It also helps
    in performing calculations with respect to daylight savings.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytz` 库将Olson时区数据库引入Python。它允许在Python 2中进行准确和跨平台的时区计算。它还有助于进行夏令时的计算。'
- en: 'Before we get into the recipes, let''s check if we have the relevant modules
    in our Python installation and also install the ones we need in this chapter.
    We start by creating a virtual environment for this chapter and activating it:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入食谱之前，让我们检查一下我们的Python安装中是否有相关的模块，以及在本章中安装我们需要的模块。我们首先为这一章创建一个虚拟环境并激活它：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s install the `pytz` module in our virtual environment using Python
    `pip`. Once we install the module, we will move ahead to the first recipe and
    start working with `time` and `date` objects:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 Python 的 `pip` 在我们的虚拟环境中安装 `pytz` 模块。一旦我们安装了模块，我们将继续进行第一个菜谱，并开始处理 `time`
    和 `date` 对象：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Working with time, date, and calendar
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理时间、日期和日历
- en: In this recipe, we will use built in Python modules and we don't need to install
    anything explicitly. So let's get started.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用内置的 Python 模块，我们不需要明确安装任何东西。所以让我们开始吧。
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Go to your favorite editor, create a file named `time_ex.py`, and write the
    following code in the Python file:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往您最喜欢的编辑器，创建一个名为 `time_ex.py` 的文件，并在 Python 文件中编写以下代码：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we run the preceding Python code, we will see the following output. Observe
    how we created a given time object using Python and retrieved the *hour, minute,
    second,* and *microsecond* details for the given time object:'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们运行前面的 Python 代码，我们将看到以下输出。观察我们是如何使用 Python 创建给定的时间对象，并检索给定时间对象的 *小时、分钟、秒*
    和 *微秒* 详细信息：
- en: '![How to do it...](img/image_12_001.jpg)'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/image_12_001.jpg)'
- en: 'Python''s `Time` class has some more attributes that can be effectively used
    for time calculations. For instance, in the following code snippet, I can get
    the valid time range for a given day:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 的 `Time` 类有一些可以用于时间计算的属性。例如，在以下代码片段中，我可以获取给定一天的有效时间范围：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the preceding code snippet can be seen in the following screenshot.
    Observe how we get the first and the last available time for the day:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前一个代码片段的输出可以在以下截图中看到。观察我们是如何获取一天中最早和最晚可用时间：
- en: '![How to do it...](img/image_12_002.jpg)'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/image_12_002.jpg)'
- en: 'Neat! Now, let''s look at the `date` object. The following Python code gets
    today''s date for you. We also retrieve the `year`, `month`, and `day` attributes
    with the following code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 棒极了！现在，让我们看看 `date` 对象。以下 Python 代码为您获取今天的日期。我们还可以使用以下代码检索 `year`、`month` 和
    `day` 属性：
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the preceding code snippet is shown in the following screenshot:'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前一个代码片段的输出显示在以下截图：
- en: '![How to do it...](img/image_12_003.jpg)'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/image_12_003.jpg)'
- en: 'Ok, cool! We can also create a new `date` object or modify an existing one
    with Python''s `date()` and `replace()` methods. The following code demonstrates
    how to use these methods:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，酷！我们还可以使用 Python 的 `date()` 和 `replace()` 方法创建一个新的 `date` 对象或修改现有的一个。以下代码演示了如何使用这些方法：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output of the preceding snippet is as follows:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前一个代码片段的输出如下：
- en: '![How to do it...](img/image_12_004.jpg)'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/image_12_004.jpg)'
- en: 'Fantastic! Let''s move ahead and see if we can work with months or even years.
    With Python, it''s very easy to work with the whole calendar. The following code
    prints out the calendar for the complete year on the console. In this case, it
    returns the calendar for the year 2017\. Let me check my birthday... oh it''s
    on Tuesday this year and I have to go to the office:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太棒了！让我们继续前进，看看我们是否可以处理月份甚至年份。使用 Python，处理整个日历非常容易。以下代码在控制台上打印出整年的日历。在这种情况下，它返回
    2017 年的日历。让我检查一下我的生日...哦，今年我的生日在星期二，我必须去办公室：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of the preceding code snippet is shown in the following screenshot. The
    first screenshot returns the complete calendar for the year 2017:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前一个代码片段的输出显示在以下截图。第一个截图返回了 2017 年的完整日历：
- en: '![How to do it...](img/image_12_005.jpg)'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/image_12_005.jpg)'
- en: 'The following screenshot only returns the calendar for the eleventh month of
    2017, that is, November 2017:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图仅返回 2017 年的第 11 个月份的日历，即 2017 年 11 月：
- en: '![How to do it...](img/image_12_006.jpg)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/image_12_006.jpg)'
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we started working with `time` objects. We created a `time`
    object with the `datetime.time()` method that takes hour, minute, and second as
    input parameters. We also read the time object with `hour`, `minute`, and `second` attributes,
    and got the earliest and latest times of the day with `datetime.time.min` and
    `datetime.time.max` attributes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们开始处理 `time` 对象。我们使用 `datetime.time()` 方法创建了一个 `time` 对象，该方法接受小时、分钟和秒作为输入参数。我们还通过
    `hour`、`minute` 和 `second` 属性读取时间对象，并使用 `datetime.time.min` 和 `datetime.time.max`
    属性获取一天中的最早和最晚时间。
- en: Next, we moved onto working with dates using the `datetime.date()` method. We
    got today's date with the `datetime.date()` method and printed the year, month,
    and day for today with the `today.year`, `today.month`, and `today.day` attributes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `datetime.date()` 方法开始处理日期。我们使用 `datetime.date()` 方法获取今天的日期，并使用 `today.year`、`today.month`
    和 `today.day` 属性打印今天的年、月和日。
- en: We also created a new date with the `datetime.date()` method by passing the
    `year`, `month`, and `day` as parameters. Once the `date` object was available,
    we used it to get the new date with the `replace()` method. We passed `year` and
    `month` as parameters to the `replace()` method to create the new `date` object.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 `datetime.date()` 方法通过传递 `year`、`month` 和 `day` 作为参数创建了一个新的日期。一旦有了 `date`
    对象，我们就使用 `replace()` 方法来获取新的日期。我们将 `year` 和 `month` 作为参数传递给 `replace()` 方法来创建新的
    `date` 对象。
- en: We also worked with the `calendar` object in this section. We used the `calendar`
    module available in Python installation for this purpose. First, we instantiated
    the `TextCalendar` class to create a text calendar object. Later, we used this
    object to print the calendar for the year 2017 on the console with `pryear()`
    method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们还处理了 `calendar` 对象。我们使用 Python 安装中可用的 `calendar` 模块来完成此目的。首先，我们实例化了 `TextCalendar`
    类来创建一个文本日历对象。然后，我们使用这个对象通过 `pryear()` 方法在控制台上打印 2017 年的日历。
- en: We could also show the calendar for just the month of November for the year,
    2017, using the `prmonth()` method. Nice!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `prmonth()` 方法仅显示 2017 年 11 月的日历。太棒了！
- en: Comparing and combining the date and time objects, and date arithmetic
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较和组合日期和时间对象，以及日期算术
- en: Creating `date` objects and using them is great, but the tasks we need to perform
    for business use cases are often related to comparing or calculating differences
    in the date and time objects. In this recipe, we will learn how to perform these
    operations in Python. It is, however, important to note a major change that we
    will see in this recipe. In the last recipe, we worked with the time and date
    objects independently. But Python's `datetime` module provides a great benefit,
    in the sense that we get to work on objects that include both date and time attributes.
    You will see this difference in the How to do it section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `date` 对象并使用它们是很好的，但我们需要执行的业务用例中的任务通常与比较或计算日期和时间对象的差异有关。在这个菜谱中，我们将学习如何在 Python
    中执行这些操作。然而，需要注意的是，在这个菜谱中我们将看到一个主要的变化。在上一个菜谱中，我们独立地处理时间和日期对象。但 Python 的 `datetime`
    模块提供了很大的便利，从某种意义上说，我们可以处理包含日期和时间属性的多个对象。你将在“如何做”部分看到这个差异。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will work with the `datetime` Python module that we used
    for the last couple of examples. We don't have any new installations to be done
    for this recipe.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 `datetime` Python 模块，这是我们之前几个示例中使用的。对于这个菜谱，我们不需要进行任何新的安装。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by getting the difference between two datetime objects. The following
    code does this operation and calculates the difference between two `datetime`
    objects. Though this operation only tells you the difference in seconds, you can
    also use these to get the difference in months or years. In the following screenshot,
    notice how `datetime.now()` returns a string with both today''s date and the current
    time. It is important to understand that we are working on an object that comprises
    the date and time attributes. If you think about it, in the actual world also,
    when we have to calculate the time difference between two events, working on the
    date and time objects together will be the most useful to us. Even if we independently
    work on the date object or the time object, we will end up performing the same
    calculation that we will perform with the datetime object, so imagine the benefits
    we get with this approach:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先获取两个 datetime 对象之间的差异。以下代码执行此操作并计算两个 `datetime` 对象之间的差异。尽管这个操作只告诉你秒数的差异，但你也可以使用这些来获取月份或年份的差异。在下面的屏幕截图中，注意
    `datetime.now()` 返回一个包含今天日期和当前时间的字符串。重要的是要理解我们正在处理一个包含日期和时间属性的多个对象。如果你这么想，在现实世界中，当我们需要计算两个事件之间的时间差异时，同时处理日期和时间对象将对我们最有用。即使我们独立地处理日期对象或时间对象，我们最终也会执行与使用
    datetime 对象相同的计算，所以想象一下这种方法带来的好处：
- en: '[PRE7]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of the preceding code snippet is shown in the following screenshot.
    See how we get the difference between the datetime objects in seconds:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前一个代码片段的输出显示在下面的屏幕截图中。看看我们是如何获取两个 datetime 对象之间的秒数的差异：
- en: '![How to do it...](img/image_12_007.jpg)'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/image_12_007.jpg)'
- en: This is fine, but you may ask what happens if the difference in the `datetime`
    objects is negative. In this example, if we calculate `now_1 - now_2`, we get
    a high number and not the actual difference. For this, we have a nice trick to
    get the difference between two `datetime` objects. We can use `(now_1 - now_2).total_seconds()`
    to get the negative value, that is, `-5` seconds.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这很好，但你可能会问，如果`datetime`对象之间的差异是负数会发生什么。在这个例子中，如果我们计算`now_1 - now_2`，我们会得到一个很大的数字，而不是实际的差异。为此，我们有一个很好的技巧来获取两个`datetime`对象之间的差异。我们可以使用`(now_1
    - now_2).total_seconds()`来获取负值，即`-5`秒。
- en: 'OK, now let''s move forward to perform more calculations on the `datetime`
    objects. For instance, how about getting the time from the past or into the future?
    The following code helps us perform these operations; see how we got the date
    and time at this moment and also could return the date and time for the next day,
    that is, tomorrow:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在让我们继续对`datetime`对象进行更多计算。例如，从过去或未来获取时间怎么样？以下代码帮助我们执行这些操作；看看我们是如何获取当前日期和时间的，以及如何返回明天的日期和时间：
- en: '[PRE8]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一段代码的输出如下：
- en: '![How to do it...](img/image_12_008.jpg)'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/image_12_008.jpg)'
- en: 'If we want to get the time in the past, we could do it in the same way as shown
    in the following code snippet:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要获取过去的时间，我们可以用以下代码片段中的方式来做：
- en: '[PRE9]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The output of the preceding code is shown in the following screenshot. Note
    that we asked for a past date, which is 365 days back. However, it shows November
    28, 2015\. Why? Shouldn't it show the same day? Oh, of course, 2016 was a leap
    year!
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一段代码的输出在以下屏幕截图中展示。注意，我们请求的是一个过去的日期，即365天前。然而，它显示的是2015年11月28日。为什么？难道不应该显示同一天吗？哦，当然，2016年是闰年！
- en: '![How to do it...](img/image_12_009.jpg)'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/image_12_009.jpg)'
- en: 'OK, now we''re comfortable working with getting the difference or adding time
    to `date` and `time` objects. But we also often need to compare between times,
    right? Let''s learn this with the help of a code snippet. The following Python
    code compares `time` and `date` objects separately:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在我们熟悉了如何获取`date`和`time`对象之间的差异或添加时间。但我们也经常需要比较时间，对吧？让我们通过一个代码片段来学习这一点。以下Python代码分别比较了`time`和`date`对象：
- en: '[PRE10]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of the preceding piece of code can be seen in the following screenshot:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一段代码的输出可以在以下屏幕截图中看到：
- en: '![How to do it...](img/image_12_010.jpg)'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/image_12_010.jpg)'
- en: 'As we saw in the previous recipe, you also feel the need to combine your `time`
    objects with the `date` objects. For instance, you have developed your program
    for a use case where you want to compare `time` objects and take some action.
    But you may end up doing the date comparison also since the `time` objects you
    are comparing fall on different dates. Since you''re already aware how easy it
    is to work with `datetime` objects, you may want to combine your `time` and `date`
    objects into a single `datetime` object and easily work on them. We can easily
    achieve this in Python; the following code demonstrates combining independent
    times and dates to `datetime` objects:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在前面的菜谱中看到的，你也觉得需要将你的`time`对象与`date`对象结合起来。例如，你为某个用例开发了你的程序，你想要比较`time`对象并采取一些行动。但你也可能最终需要进行日期比较，因为你要比较的`time`对象在不同的日期上。既然你已经知道如何轻松地处理`datetime`对象，你可能想要将你的`time`和`date`对象组合成一个单一的`datetime`对象，并轻松地处理它们。我们可以很容易地在Python中实现这一点；以下代码演示了如何将独立的时间和日期组合到`datetime`对象中：
- en: '[PRE11]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the preceding piece of code is:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一段代码的输出如下：
- en: '![How to do it...](img/image_12_011.jpg)'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/image_12_011.jpg)'
- en: How it works...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the last section, we worked on `time`, `date`, and `calendar` objects independently.
    In this recipe, we started working on the complete `datetime` object.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们独立地处理了`time`、`date`和`calendar`对象。在本菜谱中，我们开始处理完整的`datetime`对象。
- en: In the first code example of this recipe, we calculated the difference between
    the `datetime` objects. We could easily do that with the same subtraction (`-`)
    operator we're used to. That means the `__sub__()` method has been overridden
    for the `datetime` class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱的第一个代码示例中，我们计算了`datetime`对象之间的差异。我们可以用我们熟悉的相同减法(`-`)运算符轻松做到这一点。这意味着`__sub__()`方法已被`datetime`类覆盖。
- en: Then, in the second and third code snippets, we used the `timedelta()` method
    to get to the future `datetime` objects or move in the past. The `timedelta()`
    method supports conveniently named attributes such as `days` or `hours` to shift
    the current `datetime` objects to the past or future. We get to the past with
    `- timedelta()` and move ahead with `+ timedelta()` operations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第二个和第三个代码片段中，我们使用了`timedelta()`方法来获取未来的`datetime`对象或移动到过去。`timedelta()`方法支持方便命名的属性，如`days`或`hours`，可以将当前的`datetime`对象移动到过去或未来。我们使用`-
    timedelta()`到达过去，使用`+ timedelta()`操作前进。
- en: Next, we understood how to compare the `datetime` objects. This was again simply
    done like any other Python object. In Python, we check if an integer is less than
    or greater than another integer with the `<` and `>` operators, respectively.
    Same is the case with the `datetime` objects. We simply use these operators to
    compare even the `datetime` objects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们了解了如何比较`datetime`对象。这同样像任何其他Python对象一样简单完成。在Python中，我们使用`<`和`>`运算符分别检查一个整数是否小于或大于另一个整数。对于`datetime`对象也是如此。我们只需使用这些运算符来比较即使是`datetime`对象。
- en: Finally, we looked at the use case where we needed to work on `date` and `time`
    objects to get the difference or compare them. For this, we wrote a Python code
    to combine the `date` and `time` objects and used the `datetime.combine()` method.
    This made sure that the comparison or the difference operation can be easily done
    on the `datetime` objects instead of doing them individually on `date` or `time`
    objects and then merging the results.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了需要处理`date`和`time`对象以获取差异或比较它们的使用场景。为此，我们编写了Python代码来组合`date`和`time`对象，并使用了`datetime.combine()`方法。这确保了比较或差异操作可以轻松地在`datetime`对象上执行，而不是在单独的`date`或`time`对象上执行然后合并结果。
- en: Formatting and parsing dates
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期和时间的格式化与解析
- en: In all the recipes so far, we performed multiple operations on the `date` or
    `time` objects. But the objects themselves are represented in certain formats.
    For instance, by default, the `date()` object is represented in a YYYY-MM-DD format
    and the `time()` object is represented in a HH:MM:SS format. While these representations
    are good, we can't always use these formats for representing data to the users
    on a website or while scheduling meetings from a web page.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在迄今为止的所有菜谱中，我们对`date`或`time`对象执行了多次操作。但对象本身是以特定格式表示的。例如，默认情况下，`date()`对象以YYYY-MM-DD格式表示，而`time()`对象以HH:MM:SS格式表示。虽然这些表示方式很好，但我们不能总是使用这些格式来向用户在网站上表示数据或从网页安排会议。
- en: In this section, we quickly look at the different formats in which the `date`
    and `time` objects can be manifested to the users.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们快速查看`date`和`time`对象可以呈现给用户的不同格式。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we end up using the same `datetime` module that gets packaged
    with the default Python installation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们最终使用了与默认Python安装捆绑的相同`datetime`模块。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s get started with something we know. The following Python code will print
    the date and time in ISO format. This format is the most used format around the
    world and is universally acceptable:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从我们已知的内容开始。以下Python代码将以ISO格式打印日期和时间。这种格式是全球最常用的格式，并且被普遍接受：
- en: '[PRE12]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, as you would have already imagined, this format is not quite readable.
    For instance, it reads the month in digits (11 for November) and returns the time
    even till microseconds (which I don''t think is very useful). How about formats
    where we solve these issues and make the date more readable? Yes, we can easily
    do that with the following code snippet. In this code, with the help of certain
    format specifiers such as `''%b''`, we manage to make the month readable:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，正如你可能已经想象到的，这种格式并不太易读。例如，它以数字形式读取月份（11代表11月）并返回时间，甚至精确到微秒（我认为这并不非常有用）。那么，有没有格式可以解决这些问题，使日期更易读呢？是的，我们可以通过以下代码片段轻松实现这一点。在这个代码中，借助某些格式说明符，例如`'%b'`，我们成功使月份变得可读：
- en: '[PRE13]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You must have seen some web applications using Unix timestamp or epochs to store
    time. Even though this is a nice way to store objects, you still need to represent
    the actual time or date to the user in the format she understands.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你一定见过一些使用Unix时间戳或纪元的Web应用程序来存储时间。尽管这是一种存储对象的好方法，但你仍然需要以用户理解的方式表示实际的时间或日期。
- en: Unix time, also known as POSIX time or epoch time, is a system for describing
    times defined as seconds that have elapsed since Thursday, January 01, 1970, 00:00:00
    UTC. Unix timestamps are useful as they represent time independent of time zones.
    For example, a Unix time can represent 1:00 pm in London and 8:00 am in New York.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unix 时间，也称为 POSIX 时间或纪元时间，是一种描述时间的系统，定义为自 1970 年 1 月 1 日星期四 00:00:00 UTC 以来经过的秒数。Unix
    时间戳很有用，因为它们代表与时区无关的时间。例如，Unix 时间可以表示伦敦的下午 1:00 和纽约的上午 8:00。
- en: 'The following code snippets show how to convert timestamps to `datetime` objects
    and vice versa:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何将时间戳转换为 `datetime` 对象，反之亦然：
- en: '[PRE14]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Another fun representation of the `datetime` objects can be to show the date
    from the *n*^(th) day from when the world began. For instance, can you print the
    date for the 1000^(th) day after Jan 1, 0001? It is the date corresponding to
    the propletic Gregorian calendar where 01/01/01 has an ordinal 1:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`datetime` 对象的另一种有趣表示方式是显示从世界开始以来的第 *n* 天的日期。例如，你能打印出 0001 年 1 月 1 日之后的第 1000
    天的日期吗？这是与儒略日历相对应的日期，其中 01/01/01 的序数为 1：'
- en: '[PRE15]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you run the preceding Python code snippet, you will be able to see the desired
    objects as in the following screenshot:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您运行前面的 Python 代码片段，您将能够看到如下截图中的所需对象：
- en: '![How to do it...](img/image_12_012.jpg)'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/image_12_012.jpg)'
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we looked at the various ways of representing `datetime` objects.
    In the first example, we printed the date and time in ISO format. This is the
    most used format and you can read more about the ISO format at [https://en.wikipedia.org/wiki/ISO_8601](https://en.wikipedia.org/wiki/ISO_8601).
    As you can see, we need not use a new method for this representation; we simply
    used `datetime.today()` to get the date in ISO format.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们探讨了表示 `datetime` 对象的各种方法。在第一个示例中，我们以 ISO 格式打印了日期和时间。这是最常用的格式，您可以在 [https://en.wikipedia.org/wiki/ISO_8601](https://en.wikipedia.org/wiki/ISO_8601)
    上了解更多关于 ISO 格式的信息。如您所见，我们不需要使用新方法来表示这一点；我们只是简单地使用 `datetime.today()` 来获取 ISO 格式的日期。
- en: In the second example, we looked at defining our own format for representing
    the date in the string format. We took the help of format specifiers, such as
    `%a`, `%b`, and `%d` to work with date and `%H`, `%M`, and `%S` to work with time.
    We specified the format in the `format` variable and used it to pass it to `strftime()`
    method that formatted the ISO `datetime` object to our custom String format.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们探讨了定义字符串格式中表示日期的自定义格式。我们使用了格式说明符，如 `%a`、`%b` 和 `%d` 来处理日期，以及 `%H`、`%M`
    和 `%S` 来处理时间。我们在 `format` 变量中指定了格式，并使用它将其传递给 `strftime()` 方法，该方法将 ISO `datetime`
    对象格式化为我们的自定义字符串格式。
- en: The next two examples helped us convert a Unix timestamp or an epoch to a `datetime`
    object and vice versa. For the first use case, we use the `datetime.fromtimestamp(<unixtimestamp>)`
    method to convert a Unix time stamp to a `datetime` object, and in the successive
    example, we converted a `datetime` object to a Unix timestamp with the `strftime()`
    method. The Unix time (1284101485) used in this example is the number of seconds
    that have elapsed since January 01, 1970.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下两个示例帮助我们将 Unix 时间戳或纪元转换为 `datetime` 对象，反之亦然。对于第一个用例，我们使用 `datetime.fromtimestamp(<unixtimestamp>)`
    方法将 Unix 时间戳转换为 `datetime` 对象，在随后的示例中，我们使用 `strftime()` 方法将 `datetime` 对象转换为 Unix
    时间戳。本例中使用的 Unix 时间（1284101485）是自 1970 年 1 月 1 日以来的秒数。
- en: In the last and interesting example, we get the date and time in a Gregorian
    calendar ordinal format with `fromordinal()` method. You will not use this method,
    in all likelihood, but I have included it in this chapter as an interesting date
    format for you to know.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个有趣示例中，我们使用 `fromordinal()` 方法获取公历日历的日期和时间。您很可能不会使用此方法，但我将其包含在本章中，以便您了解一个有趣的日期格式。
- en: Dealing with time zone calculations
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理时区计算
- en: One of the trickiest calculations that you will have to perform on `date` or
    `time` objects is the one that involves time zones. Your colleague works in San
    Francisco and you are in Sydney, how do you plan to do a conference call? When
    you set up a meeting, you should be aware of your colleague's time zone, else
    you may set up a meeting for 8 pm Sydney time while for your colleague in San
    Francisco, it is already past midnight. Time zone calculations are often tedious
    and need to be handled cautiously while developing business applications. Let's
    see how Python can help us in this regard.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`date`或`time`对象上必须执行的最复杂的计算之一就是涉及时区的计算。你的同事在旧金山工作，而你则在悉尼，你打算如何安排电话会议？当你安排会议时，你应该意识到你同事的时区，否则你可能会为悉尼时间晚上8点安排会议，而对你同事在旧金山来说，这已经是午夜之后了。时区计算通常很繁琐，在开发商业应用程序时需要谨慎处理。让我们看看Python如何在这方面帮助我们。
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will use the `pytz` module that we installed at the beginning
    of this chapter. In fact, the Python standard library doesn't have a time zone
    library, but we can completely rely on the modules contributed by the Python community
    for our needs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将使用我们在本章开头安装的`pytz`模块。实际上，Python标准库没有时区库，但我们可以完全依赖Python社区贡献的模块来满足我们的需求。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'You need to perform the following steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要执行以下步骤：
- en: Let's get started with a trivial operation of getting the local time in UTC.
    **UTC** stands for **Universal Time Converter**, a worldwide standard for regulating
    clocks and time measurements. UTC is also popularly known as Greenwich Mean Time
    (GMT).
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从获取UTC时间的简单操作开始。**UTC**代表**通用时间转换器**，是全球调节时钟和时间测量的标准。UTC也普遍被称为格林尼治标准时间（GMT）。
- en: '[PRE16]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of the preceding code snippet is shown in the following screenshot.
    Look at how my local time is +5:30 hours ahead of UTC:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一段代码片段的输出显示在下述屏幕截图中。看看我的本地时间比协调世界时（UTC）快5小时30分钟：
- en: '![How to do it...](img/image_12_013.jpg)'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/image_12_013.jpg)'
- en: 'OK, this is nice. So, you can convert your local time to UTC, but this is not
    always enough. Your customers (for whom you develop the application) can be from
    anywhere in the world. Their accounts also need to be managed with respect to
    their time zones and local times. Let''s see how we can figure out the local time
    for a user in a given time zone:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，这很好。所以，你可以将你的本地时间转换为UTC，但这并不总是足够的。你的客户（为你的应用程序开发）可能来自世界各地。他们的账户也需要根据他们的时区和本地时间进行管理。让我们看看我们如何确定给定时区的用户本地时间：
- en: '[PRE17]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output of the preceding piece of code is shown in the following screenshot.
    Observe how we converted a local UTC time to **Eastern Standard Time** (**EST**)
    by getting the eastern time zone. In fact, UTC works out to be the best way to
    convert time across time zones:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一段代码的输出显示在下述屏幕截图中。观察我们是如何通过获取东部时区将本地UTC时间转换为**东部标准时间**（**EST**）的。实际上，UTC是跨时区转换时间的最佳方式：
- en: '![How to do it...](img/image_12_014.jpg)'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/image_12_014.jpg)'
- en: 'Performing arithmetic calculations on `datetime` objects with time zone information
    is also trivial in Python. Look at the following code and see how we perform arithmetic
    operations on `date` objects:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python中对带有时区信息的`datetime`对象执行算术计算也是简单的。看看以下代码，看看我们是如何在`date`对象上执行算术运算的：
- en: '[PRE18]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, if we run this piece of code on our Python interpreter, we get the following
    output:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果我们在这个Python解释器上运行这段代码，我们会得到以下输出：
- en: '![How to do it...](img/image_12_015.jpg)'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/image_12_015.jpg)'
- en: 'We can''t finish any topic on time zones without really talking about this,
    can we? Yes, how do we deal with daylight savings in time zone calculations? Thanks
    to Benjamin Franklin for the gift he gave to the world on daylight savings. Let''s
    understand this with the help of a code example:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在讨论时区时，如果不真正谈论这一点，怎么能算完成呢？对吧？是的，我们如何在时区计算中处理夏令时？感谢本杰明·富兰克林为世界带来的夏令时礼物。让我们通过一个代码示例来理解这一点：
- en: '[PRE19]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you run the code snippet, you''d see two `datetime` objects represented
    in the String format. The first one takes care of the daylight savings and the
    second one disregards it. November 6, 2016 is when the daylight savings ended
    this year in the eastern time zone and the clock moved backwards:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你运行代码片段，你会看到两个以字符串格式表示的`datetime`对象。第一个考虑了夏令时，而第二个则不考虑。2016年11月6日是今年东部时区结束夏令时，时钟往回拨：
- en: '![How to do it...](img/image_12_016.jpg)'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/image_12_016.jpg)'
- en: 'Lastly, there are a few helper methods that are available in the `pytz` module
    that are often useful, for instance, getting the time zones for a given country
    based on the ISO country code, or simply getting the country name from the ISO
    country code. Let''s look at the following examples:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`pytz` 模块中还有一些有用的辅助方法，例如，根据 ISO 国家代码获取给定国家的时区，或者简单地从 ISO 国家代码中获取国家名称。让我们看看以下示例：
- en: '[PRE20]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output of the preceding code snippet can be viewed in the following screenshot:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码片段的输出可以在以下屏幕截图中进行查看：
- en: '![How to do it...](img/image_12_017.jpg)'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/image_12_017.jpg)'
- en: How it works...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we looked at the various ways of working with time zones, which
    are integral to date-time calculations. In the first code example of this recipe,
    we calculate the current local time with `datetime.now()` and then got the same
    local time in UTC with `datetime.utcnow()`. The `utcnow()` method becomes very
    handy when we have to store date/time objects in the database for further processing,
    such as scheduling events.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们探讨了处理时区的各种方法，这对于日期时间计算至关重要。在这个配方的第一个代码示例中，我们使用 `datetime.now()` 计算当前本地时间，然后使用
    `datetime.utcnow()` 获取相同的 UTC 本地时间。`utcnow()` 方法在需要将日期时间对象存储到数据库以进行进一步处理时（例如安排事件）变得非常有用。
- en: Next, we looked at how to switch to a different time zone and retrieve the local
    time in that time zone. The `pytz` class has a simple attribute, `utc`, to set
    the time zone to UTC; we used it to set our current time zone to UTC. Later we
    used the `timezone()` method of the `pytz` module to switch to the eastern time
    zone with `timezone('US/Eastern')`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了如何切换到不同的时区并检索该时区的本地时间。`pytz` 类有一个简单的属性 `utc`，用于将时区设置为 UTC；我们使用它将当前时区设置为
    UTC。稍后，我们使用 `pytz` 模块的 `timezone()` 方法通过 `timezone('US/Eastern')` 切换到东部时区。
- en: 'In all the recipes before this one, we created a `datetime` object with the
    `datetime()` method; in this recipe also, we used the `datetime` method but with
    the `tzinfo` parameter in this way: `datetime(YYYY, MM, DD, HH, MM, SS, tzinfo=<timezone>)`.
    The `tzinfo` parameter makes sure to add the time zone information to the `datetime`
    object, which is important while performing calculations across time zones.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前的所有配方中，我们都是使用 `datetime()` 方法创建 `datetime` 对象；在这个配方中，我们也使用了 `datetime` 方法，但这次使用了
    `tzinfo` 参数，如下所示：`datetime(YYYY, MM, DD, HH, MM, SS, tzinfo=<timezone>)`。`tzinfo`
    参数确保将时区信息添加到 `datetime` 对象中，这在跨时区进行计算时非常重要。
- en: 'The `datetime` class has another convenient method that will represent the
    `datetime` object to a time zone of our choice: the `astimezone()` method. Using
    this method, we converted the UTC `datetime` object to eastern time with this
    code, `loc_dt.astimezone(eastern)`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`datetime` 类还有一个方便的方法，可以将 `datetime` 对象表示为我们选择的时区：`astimezone()` 方法。使用此方法，我们使用以下代码将
    UTC `datetime` 对象转换为东部时间：`loc_dt.astimezone(eastern)`。'
- en: Finally, we created a custom string format to represent the eastern time with
    the `strftime(format)` method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `strftime(format)` 方法创建了一个自定义字符串格式来表示东部时间。
- en: We can also add or remove time/days during the time zone calculations like we
    did with `datetime` objects. In the third code sample of this recipe, we switched
    to the Australia/Sydney time zone and created a `datetime` object for this time
    zone; this operation returned us the local time in Sydney. With the help of the `timedelta()`
    method, we then removed ten minutes from the local time with `local - timedelta(mins=10)`
    and also added 18 hours to the time with `local + timedelta(hours=18)`. This way,
    we could access the time from the past or in the future. Think of it as time travel.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在时区计算中添加或删除时间/天数，就像我们在 `datetime` 对象中所做的那样。在这个配方的第三个代码示例中，我们切换到澳大利亚/悉尼时区并创建了一个该时区的
    `datetime` 对象；这个操作返回了悉尼的本地时间。借助 `timedelta()` 方法，我们随后从本地时间中减去十分钟，使用 `local - timedelta(mins=10)`，并且通过
    `local + timedelta(hours=18)` 向时间中添加了18小时。这样，我们就可以访问过去或未来的时间。把它想象成时间旅行。
- en: In the fourth code snippet, we understood how to work with daylight savings.
    To understand this, we created a `datetime` object without any time zone information
    and assigned it to the `dt` variable. We also created a time zone object for eastern
    time with the code, `eastern = timezone('US/Eastern')`. We then used the `localize()`
    method on the time zone object to convert the `dt` object to eastern time. Here
    is where we add another parameter, `is_dst`, to the `localize(is_dst=<True/False>)`
    method to return the local time in eastern time zone, with or without considering
    daylight savings.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四个代码片段中，我们了解了如何处理夏令时。为了理解这一点，我们创建了一个没有任何时区信息的`datetime`对象，并将其分配给`dt`变量。我们还使用代码`eastern
    = timezone('US/Eastern')`创建了一个东部时区的时区对象。然后我们使用时区对象的`localize()`方法将`dt`对象转换为东部时间。在这里，我们向`localize(is_dst=<True/False>)`方法添加了另一个参数`is_dst`，以返回东部时区的本地时间，考虑或不考虑夏令时。
- en: In 2016, November 6 was the day when the clock moved backwards at 2 am. So,
    in our example, when we queried for 1:30 am eastern time with `is_dst=True`, it
    returned time in **Eastern Daylight Time** (**EDT**), which is four hours behind
    **Coordinated Universal Time** (UTC-0400 hours). When we queried for the same
    time with `is_dst=False`, it returns the time in EST, which is UTC-0500 hours.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在2016年，11月6日是时钟在凌晨2点倒回的那一天。所以，在我们的例子中，当我们用`is_dst=True`查询东部时间1:30 am时，它返回的是**东部夏令时**（**EDT**），比**协调世界时**（UTC-0400小时）慢四小时。当我们用`is_dst=False`查询同一时间时，它返回的是EST，即UTC-0500小时。
- en: In the last example of this recipe, we looked at a few useful helper methods
    provided by the `pytz` module. For instance, `pytz.country_timezones['au']` returned
    all the time zones available in Au (Australia) and `pytz.country_names['gb']`
    returned the name of the country, that is, Britain (UK), based on the ISO country
    code `gb`. You will realize the utility of these libraries when you actually solve
    some of the time zone problems.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱的最后一个例子中，我们查看了一些`pytz`模块提供的有用辅助方法。例如，`pytz.country_timezones['au']`返回了在澳大利亚（Au）中所有可用的时区，而`pytz.country_names['gb']`根据ISO国家代码`gb`返回了国家名称，即英国（UK）。当你实际解决一些时区问题时，你会意识到这些库的实用性。
- en: Automating invoicing based on user time zone
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据用户时区自动化发票
- en: Jacob is a Finance Manager at Anzee Corporation in North America and is responsible
    for customer invoicing. Anzee Corporation provides a **Software as a Service**
    (**SaaS**) platform to its customers and charges customers based on the platform
    usage. Anzee's customers have raised complaints regarding incorrect monthly invoices.
    In their words, "*Invoices for the previous month are available on the 1^(st)
    day of the next month, which is fine, but a part of our usage is not accounted
    for. This messes up our accounting.*"
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 雅各布是北美安齐公司（Anzee Corporation）的财务经理，负责客户发票工作。安齐公司为其客户提供**软件即服务**（**SaaS**）平台，并按平台使用情况向客户收费。安齐的客户对错误的月度发票提出了投诉。他们表示，“*上个月的发票在次月的1号可用，这没问题，但我们的部分使用情况没有被计入。这搞砸了我们的会计工作。*”
- en: Currently, Jacob generates invoices in a manual way by getting the data for
    customer's payments and platform usage from the platform's database records. With
    an increasing number of customers each month, Jacob realizes that the manual process
    is going to be laborious and time consuming. He also wants someone to look at
    the issue the customers are complaining about. Can we help Jacob?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，雅各布通过从平台数据库记录中获取客户支付和平台使用数据来手动生成发票。随着每月客户数量的增加，雅各布意识到手动流程将会非常耗时费力。他还希望有人能关注客户投诉的问题。我们能帮助雅各布吗？
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we''ll use all the built-in Python modules that we''ve used
    in the previous recipes as well as install the `fpdf` module for generating the
    PDF invoice to solve Jacob''s need for an automated way to prepare invoices for
    his customers. We install the module using Python `pip`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用在之前菜谱中用过的所有内置Python模块，以及安装`fpdf`模块来生成PDF发票，以满足雅各布为客户准备发票的自动化需求。我们使用Python
    `pip`来安装该模块：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's get started by looking at the database records. Anzee Corporation uses
    MongoDB to store the records of customer payments and charges for the month. For
    this example, lets assume, the payment records of Anzee Corporation are stored
    in JSON format.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从查看数据库记录开始。安齐公司使用MongoDB来存储客户支付和月度费用的记录。在这个例子中，假设安齐公司的支付记录以JSON格式存储。
- en: We use a `users` document that contains the list of all the users with fields
    such as `id`, `name`, `city`, and `timezone`, like any other user table would.
    It also maintains the records of all the payments done by the users in `payments`,
    which contains the `id` of the user who paid for the platform services, the amount
    paid, and the date on which the amount is paid.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用一个`users`文档，其中包含所有用户的列表，具有`id`、`name`、`city`和`timezone`等字段，就像任何其他用户表一样。它还在`payments`中维护用户的所有支付记录，其中包含为平台服务付费的用户ID、支付金额和支付金额的日期。
- en: 'The timestamp for all the payments done is in the UTC format. Like payments,
    it also maintains the `usage` records that again contain the user ID of the person
    who used the platform, the amount she was charged for the usage, and the time
    at which she was charged:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有支付的日期时间戳都是UTC格式。像支付一样，它还维护了`usage`记录，这些记录再次包含使用该平台的人的用户ID、她因使用而支付的费用以及她被收费的时间：
- en: '[PRE22]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'OK cool, now that we have all the data, let''s work on writing the code to
    generate our invoice. We start by writing methods to get the payments and usages
    for the users for a given month. The following code snippet does this task for
    us:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，很酷，现在我们有了所有数据，让我们着手编写生成我们发票的代码。我们首先编写方法来获取给定月份用户的支付和用量。以下代码片段为我们完成这项任务：
- en: '[PRE23]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, let''s write the code to generate a PDF invoice in an automated manner,
    as Jacob wanted for his platform. We use the `fpdf` module for this purpose. The
    following code generates the invoice:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们编写代码以自动生成PDF发票，正如雅各布为他自己的平台所希望的那样。我们为此目的使用`fpdf`模块。以下代码生成了发票：
- en: '[PRE24]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we run the preceding code snippet in entirety, we get the generated invoice,
    which looks like the following screenshot:![How to do it...](img/image_12_018.jpg)
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们完整地运行前面的代码片段，我们将得到生成的发票，其外观如下所示：![如何操作...](img/image_12_018.jpg)
- en: OK, this is cool! We could generate the invoice like Jacob expected. We are
    now able to save a lot of time for him by automating the complete process. But
    then he also wanted us to look at the customer complaints regarding the invoice
    not containing accurate information. Let's see what could have happened.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，这很酷！我们能够像雅各布期望的那样生成发票。我们现在能够通过自动化整个过程为他节省大量时间。但随后他希望我们查看有关发票不包含准确信息的客户投诉。让我们看看可能发生了什么。
- en: Now, Anzee Corporation stores all the transactions and usage timestamps in UTC
    so that it becomes very easy for them to retrieve the time and show it to the
    user based on the user's time zone. So when we look up all records to get the
    transactions in that month for the invoice, we're looking at the UTC timestamps
    and not the time in the user's time zones.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，Anzee公司存储所有交易和用量时间戳为UTC，这样他们就可以很容易地检索时间并根据用户的时区向用户展示。因此，当我们查找该月的所有记录以获取发票中的交易时，我们查看的是UTC时间戳，而不是用户的时区时间。
- en: For instance, if you look deeper into the JSON data, there is a mention of another
    payment made by `John`, user ID `12`, which has a `created_at` timestamp as `2016-12-01T01:00:00.141Z`.
    This time may not fall under the month of November from a UTC perspective, but
    the user who made the payment belongs to the US/Eastern time zone. So, 1 am on
    December 1, 2016 in UTC is actually 8 pm on November 30 in the Eastern time zone.
    Obviously, the user doesn't find his payment featuring in the invoice.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，如果你深入查看JSON数据，会提到约翰（John）用户ID为12的另一次支付，其`created_at`时间戳为`2016-12-01T01:00:00.141Z`。从UTC的角度来看，这个时间可能不属于11月份，但进行支付的用户属于美国/东部时区。因此，2016年12月1日凌晨1点UTC实际上是11月30日下午8点东部时区。显然，用户没有在他的发票中看到他的支付。
- en: 'The following code snippet solves the problem by generating invoices based
    on the user time zones:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段通过根据用户时区生成发票来解决该问题：
- en: '[PRE25]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output for the preceding code snippet is shown in the following screenshot.
    See how the payments column now reflects the correct data and includes the $5
    payment done at 8 pm on November 30, 2016, taking the total to *$12 + $5 = $17*:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面代码片段的输出显示在以下屏幕截图。看看现在支付列如何反映了正确的数据，并包括2016年11月30日下午8点进行的5美元支付，总额达到*$12 + $5
    = $17*：
- en: '![How to do it...](img/image_12_019.jpg)'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/image_12_019.jpg)'
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We first looked at automating the invoice generation for Jacob. We parsed the
    JSON data for all the users and calculated the payments and usage for all the
    users for the month of November.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先研究了为雅各布自动化发票生成的方法。我们解析了所有用户的JSON数据，并计算了11月份所有用户的支付和用量。
- en: We developed `get_payments(user_id, month)` and `get_usage(user_id, month)`
    to go through the `payments` and `usage` records and picked the records for the
    month of November. We did this by working on the `created_at` JSON strings and
    converting them to date/time objects, with `dt = datetime.strptime(u["created_at"],
    '%Y-%m-%dT%H:%M:%S.%fZ')`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发了`get_payments(user_id, month)`和`get_usage(user_id, month)`函数，用于遍历`payments`和`usage`记录，并选择了11月份的记录。我们通过处理`created_at`
    JSON字符串并将它们转换为日期/时间对象来实现这一点，使用`dt = datetime.strptime(u["created_at"], '%Y-%m-%dT%H:%M:%S.%fZ')`。
- en: But as we understood in the previous section, just converting the string to
    a timestamp didn't help, as we didn't consider the time with respect to the user's
    time zone. For this, we used the date/time object, `dt`, to convert it to the
    UTC time zone with `dt.replace(tzinfo=pytz.UTC)`, and then converted `dt` to reflect
    the time in the user's time zone with the `dt.astimezone(timezone(<>))` method.
    This way, we could get the payment time in the user's time zone and the invoice
    data reflected correct figures for the month of November.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如我们在上一节中理解的，仅仅将字符串转换为时间戳并没有帮助，因为我们没有考虑到用户的时区。为此，我们使用日期/时间对象`dt`，通过`dt.replace(tzinfo=pytz.UTC)`将其转换为UTC时区，然后使用`dt.astimezone(timezone(<>))`方法将`dt`转换为反映用户时区的时间。这样，我们就可以获取用户时区的支付时间，并且发票数据正确反映了11月份的数据。
- en: Next, we created HTML content for the invoice by adding the appropriate username,
    time of invoice, and stored this in the `html` variable. Later, we created a `MyFPDF`
    class that inherited `FPDF` and `HTMLMixin` classes from the `fpdf` module. The
    `MyFPDP` class was then used to create a `pdf` object, which represented an empty
    PDF file object. We added a page to the `pdf` object with the `add_page()` method
    and updated it with HTML content (our invoice content) with the `write_html(html)`
    method. Eventually, we dumped the `pdf` object with all the data on the disk with
    the `output(<filename>)` method.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过添加适当的用户名、发票时间和存储在`html`变量中，创建了发票的HTML内容。随后，我们创建了一个名为`MyFPDF`的类，它从`fpdf`模块继承了`FPDF`和`HTMLMixin`类。然后，我们使用`MyFPDP`类创建了一个`pdf`对象，它代表了一个空的PDF文件对象。我们使用`add_page()`方法向`pdf`对象添加了一页，并使用`write_html(html)`方法用HTML内容（我们的发票内容）更新了它。最终，我们使用`output(<filename>)`方法将包含所有数据的`pdf`对象输出到磁盘上。
- en: There's more...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are many other interesting use cases with time and time zone operations
    in Python. It can get tricky if not used well, as we saw in our last examples.
    As a general guideline, I recommend you to:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，有许多其他有趣的用例涉及时间和时区操作。如果不正确使用，可能会变得复杂，正如我们在上一个示例中看到的那样。作为一个一般性的指导原则，我建议您：
- en: Always use `datetime` objects that are time zone aware. You will never go wrong
    with this approach. It will always serve you as a reminder.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是使用时区感知的`datetime`对象。这种方法永远不会出错。它将始终作为您的提醒。
- en: Return the `datetime` in an ISO format that also returns you the time zone information
    for the given object.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以ISO格式返回给定对象的时区信息。
- en: Hope you liked this chapter and enjoyed the examples! Stay tuned.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您喜欢这一章，并享受了这些示例！请继续关注。
