- en: 3\. Manipulating a Database with SQLAlchemy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 使用 SQLAlchemy 操作数据库
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够：
- en: Use the pgAdmin tool to manage a database
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 pgAdmin 工具管理数据库
- en: Manipulate a database using SQLAlchemy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SQLAlchemy 操作数据库
- en: Create database tables using Flask-Migrate
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Flask-Migrate 创建数据库表
- en: Persist data into a database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据持久化到数据库中
- en: Hash confidential password data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对机密密码数据进行哈希处理
- en: This chapter covers using SQLAlchemy to access a database, including building
    a model, encrypting the password, ensuring each email is unique, and then saving
    the recipe data in the database.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了使用 SQLAlchemy 访问数据库，包括构建模型、加密密码、确保每个电子邮件地址唯一，然后将食谱数据保存到数据库中。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we were only storing our data in application memory.
    While it is easy to code that way, the data will be gone once the server restarts.
    That is obviously not ideal because we would expect the data to be persisted even
    after a server restart or application migration and suchlike. Therefore, in this
    chapter, we will talk about persisting data in a database. We will begin by installing
    the Postgres database on our local machine. Then, we will create a database using
    pgAdmin and interact with it using the **ORM** (**Object Relational Mapping**)
    package, SQLAlchemy. ORM allows us to interact with a database by means of an
    object instead of an SQL query. After that, we will define the user and recipe
    models, link them up, and use Flask-Migrate to create the corresponding tables
    in the database. Once that part is complete, we will go through exercises to understand
    the utilization of SQLAlchemy in the Python console. Lastly, we will add the resource
    for users so that new users can be created through an API.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们只是在应用程序内存中存储我们的数据。虽然这样做编码起来很容易，但一旦服务器重启，数据就会消失。这显然不是理想的，因为我们期望数据在服务器重启或应用程序迁移等情况下仍然持久化。因此，在本章中，我们将讨论在数据库中持久化数据。我们首先将在本地机器上安装
    Postgres 数据库。然后，我们将使用 pgAdmin 创建数据库，并使用 SQLAlchemy 的 **ORM**（**对象关系映射**）包与之交互。ORM
    允许我们通过对象而不是 SQL 查询与数据库交互。之后，我们将定义用户和食谱模型，将它们链接起来，并使用 Flask-Migrate 在数据库中创建相应的表。一旦这部分完成，我们将通过练习来理解
    SQLAlchemy 在 Python 控制台中的使用。最后，我们将添加用户资源，以便可以通过 API 创建新用户。
- en: Databases
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库
- en: You have probably heard of the term database before. It is basically a data
    storage system. But why do we need a system to store data? Why can't we just store
    everything in a text file and save that in the folder system? Apparently, a database
    does more than just storing data. It classifies and organizes data and helps to
    store it with less redundancy. It also makes data easier to maintain, making it
    more it secure and consistent. A database is usually managed by a **database management
    system** (**DBMS**)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前听说过数据库这个词。它基本上是一个数据存储系统。但为什么我们需要一个系统来存储数据？为什么我们不能只是将所有内容存储在文本文件中，然后保存在文件夹系统中？显然，数据库的功能不仅仅是存储数据。它对数据进行分类和组织，并帮助以更少的冗余存储数据。它还使数据更容易维护，使其更安全、更一致。数据库通常由一个**数据库管理系统**（**DBMS**）管理
- en: Database Management System
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库管理系统
- en: A DBMS is an application that maneuvers and manages a database. It facilitates
    communication between the users and the database. Users can create, use, and maintain
    the database using this application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: DBMS 是一个操作和管理数据库的应用程序。它促进了用户与数据库之间的通信。用户可以使用此应用程序创建、使用和维护数据库。
- en: A DBMS is crucial for data security and integrity. Popular database software
    and DBMSs include PostgreSQL, MySQL, Microsoft SQL Server, MariaDB, and Oracle
    Database. Most DBMSs use **structured query language** (**SQL**) to insert and
    extract data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: DBMS 对于数据安全和完整性至关重要。流行的数据库软件和 DBMS 包括 PostgreSQL、MySQL、Microsoft SQL Server、MariaDB
    和 Oracle 数据库。大多数 DBMS 使用**结构化查询语言**（**SQL**）来插入和提取数据。
- en: In this book, we will be using PostgreSQL as our backend database system. And
    we will also use pgAdmin, which is a tool for managing PostgreSQL. PostgreSQL
    is a powerful, open-source object-relational database management system with a
    15-year history. It is well recognized as a result of its stability and data integrity.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用 PostgreSQL 作为我们的后端数据库系统。我们还将使用 pgAdmin，这是一个用于管理 PostgreSQL 的工具。PostgreSQL
    是一个拥有 15 年历史的强大、开源的对象关系型数据库管理系统。由于其稳定性和数据完整性，它得到了广泛的认可。
- en: SQL
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL
- en: '**SQL** is a language that was specifically invented to manage and maneuver
    data. It can be classified further into the following types:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQL** 是一种专门为管理和操作数据而发明的语言。它可以进一步分为以下类型：'
- en: '`SELECT column1, column2 FROM table WHERE conditions`, it can query against
    the table and extracts data (`column1, column2`) that satisfies a certain condition.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT column1, column2 FROM table WHERE conditions`，它可以查询表并提取满足一定条件的数据（`column1,
    column2`）。'
- en: '`INSERT`, `UPDATE`, and `DELETE`.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSERT`、`UPDATE` 和 `DELETE`。'
- en: '**Data Control Language** (**DCL**) for controlling data access.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据控制语言**（**DCL**）用于控制数据访问。'
- en: Although we have introduced a number of different languages here, the good thing
    is that we don't need to learn all of them. In fact, we are not going to query
    our database using SQL. We will just need to code in Python, and the ORM package
    will convert our Python code to SQL behind the scenes. It's a whole lot easier
    to work with databases nowadays.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里介绍了许多不同的语言，但好事是我们不需要学习所有这些。事实上，我们不会使用 SQL 查询我们的数据库。我们只需要用 Python 编码，ORM
    包将在幕后将我们的 Python 代码转换为 SQL。现在与数据库一起工作要容易得多。
- en: ORM
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ORM
- en: '**Object Relational Mapping** (**ORM**) is a programming technique that allows
    the developer to map objects in the programming language to the data model in
    a database. There is no longer any need to use SQL to interact with a database.
    The benefit of this is that developers can code in their own programming language
    and it will work on different types of databases.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象关系映射**（**ORM**）是一种编程技术，允许开发者在编程语言中将对象映射到数据库中的数据模型。不再需要使用 SQL 与数据库交互。这种技术的优点是，开发者可以用自己的编程语言进行编码，并且它可以在不同类型的数据库上工作。'
- en: 'The mapping works along the following lines:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 映射工作如下：
- en: Class in Python = the table schema in the database
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 中的类 = 数据库中的表架构
- en: Attributes in a class = fields in the table schema
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类中的属性 = 表架构中的字段
- en: Objects = rows of data in the table
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象 = 表中的数据行
- en: SQLAlchemy is the most popular ORM in the Python community. Next, let's delves
    further by attempting to create a database.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 是 Python 社区中最受欢迎的 ORM。接下来，让我们进一步深入，尝试创建一个数据库。
- en: 'Exercise 18: Setting Up a Smilecook Database'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习18：设置 Smilecook 数据库
- en: 'Most applications nowadays require a database to store and manage data. Our
    application, Smilecook, is no exception. It is a recipe-sharing platform and is
    open to the public. Obviously, it will have to store the user data and recipe
    data. In this exercise, we will create the database administrator and set up the
    database for our Smilecook application:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在大多需要数据库来存储和管理数据。我们的应用程序 Smilecook 也不例外。它是一个食谱分享平台，对公众开放。显然，它将需要存储用户数据和食谱数据。在这个练习中，我们将创建数据库管理员并为我们的
    Smilecook 应用程序设置数据库：
- en: 'To start with, we will create a role. A role is simply a concept that PostgreSQL
    uses to manage access. We can consider that as a user here. *Right-click* on **PostgreSQL
    11** under **Servers**, select **Create**, and then **Login/Group Role…**:![Figure
    3.1: Selecting Login/Group Role…'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个角色。角色是 PostgreSQL 用于管理访问的一个简单概念。在这里，我们可以将其视为用户。在 **Servers** 下的 **PostgreSQL
    11** 上**右键单击**，选择 **Create**，然后选择 **Login/Group Role…**：![图3.1：选择登录/组角色…
- en: '](img/C15309_03_01.jpg)'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图3.4：使用创建的账户登录数据库](img/C15309_03_01.jpg)'
- en: 'Figure 3.1: Selecting Login/Group Role…'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.1：选择登录/组角色…
- en: 'Fill in the login name, which will be used later for connecting to the database:![Figure
    3.2: Filling in the login name'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写登录名，稍后将用于连接到数据库：![图3.2：填写登录名
- en: '](img/C15309_03_02.jpg)'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图3.4：使用创建的账户登录数据库](img/C15309_03_02.jpg)'
- en: 'Figure 3.2: Filling in the login name'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.2：填写登录名
- en: 'Then, select **Definition** and set the password. Click **Save**:![Figure 3.3:
    Setting the password'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择 **Definition** 并设置密码。点击 **Save**：![图3.3：设置密码
- en: '](img/C15309_03_03.jpg)'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图3.4：使用创建的账户登录数据库](img/C15309_03_03.jpg)'
- en: 'Figure 3.3: Setting the password'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.3：设置密码
- en: 'Now, go to **Privileges**, and select **Yes** for **Can login?**. This will
    allow us to log in to the database using this account:![Figure 3.4: Logging in
    to the database using the account created'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到 **Privileges**，并选择 **Yes** 以允许 **Can login**？这将允许我们使用此账户登录到数据库：![图3.4：使用创建的账户登录数据库](img/C15309_03_04.jpg)
- en: '](img/C15309_03_04.jpg)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图3.4：使用创建的账户登录数据库](img/C15309_03_04.jpg)'
- en: 'Figure 3.4: Logging in to the database using the account created'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.4：使用创建的账户登录数据库
- en: '*Right-click* on **Databases**, and create a database from there:![Figure 3.5:
    Creating the database'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**右键单击** **Databases**，并从那里创建数据库：![图3.5：创建数据库'
- en: '](img/C15309_03_05.jpg)'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图3.4：使用创建的账户登录数据库](img/C15309_03_05.jpg)'
- en: 'Figure 3.5: Creating the database'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.5：创建数据库
- en: 'Name the database `smilecook`, and set the role that we have just created to
    **Owner**. Click **Save**:![Figure 3.6: Naming the database and setting the role'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据库命名为`smilecook`，并将我们刚刚创建的角色设置为**所有者**。点击**保存**：![图3.6：命名数据库和设置角色
- en: '](img/C15309_03_06.jpg)'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_03_06.jpg)'
- en: 'Figure 3.6: Naming the database and setting the role'
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.6：命名数据库和设置角色
- en: Now we have created the Smilecook database, but it is empty at the moment. In
    the next exercise, we will use Flask-SQLAlchemy and Flask-Migrate to create our
    database tables. You will notice that there is no SQL query involved.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了Smilecook数据库，但目前它是空的。在下一个练习中，我们将使用Flask-SQLAlchemy和Flask-Migrate来创建我们的数据库表。你会注意到其中没有涉及SQL查询。
- en: Defining Our Models
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义我们的模型
- en: 'Before we go into the implementation, we need to first define and understand
    the fields that we will be working with. We will cover two essential models: **User**
    and **Recipe**. Models are like schemas in the database. A model is a class and
    can be instantiated. It contains attributes that correspond to fields in database
    schemas.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入实现之前，我们需要首先定义和了解我们将要工作的字段。我们将涵盖两个基本模型：**User**和**Recipe**。模型在数据库中类似于模式。一个模型是一个类，可以被实例化。它包含与数据库模式中的字段相对应的属性。
- en: '**The user model**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户模型**'
- en: 'The user model will be mapped to the user table in the database. The fields
    and methods we defined for our user model are as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 用户模型将被映射到数据库中的用户表。我们为我们的用户模型定义的字段和方法如下：
- en: '`id`: The identity of a user.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：用户的标识。'
- en: '`username`: The username of the user. The maximum length allowed is 80 characters.
    It can''t be null and is a unique field.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username`：用户的用户名。允许的最大长度是80个字符。它不能为空，并且是一个唯一字段。'
- en: '`email`: The user''s email. The maximum length allowed is 200\. It can''t be
    blank and is a unique field.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`：用户的电子邮件。允许的最大长度是200。它不能为空，并且是一个唯一字段。'
- en: '`password`: The user''s password. The maximum length allowed is 200.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password`：用户的密码。允许的最大长度是200。'
- en: '`is_active`: This is to indicate whether the account is activated by email.
    It is a Boolean field with a default value of `False`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_active`：这是用来表示账户是否通过电子邮件激活。它是一个布尔字段，默认值为`False`。'
- en: '`recipes`: This doesn''t create a field in the database table. This is just
    to define the relationship with the recipe model. So, subsequently, we can get
    all recipes using `user.recipes`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recipes`：这不会在数据库表中创建一个字段。这只是为了定义与菜谱模型的关系。因此，我们可以使用`user.recipes`获取所有菜谱。'
- en: '`created_at`: The creation time of the user.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created_at`：用户的创建时间。'
- en: '`updated_at`: The last update time of the user.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updated_at`：用户的最后更新时间。'
- en: 'We are also going to define three methods in the user model:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在用户模型中定义三个方法：
- en: '`get_by_username`: This method is used for searching the user by username.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_by_username`：这个方法用于通过用户名搜索用户。'
- en: '`get_by_email`: This method is used for searching the user by email.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_by_email`：这个方法用于通过电子邮件搜索用户。'
- en: '`save`: This is to persist the data to the database.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save`：这是为了将数据持久化到数据库中。'
- en: '**The recipe model**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**菜谱模型**'
- en: 'The recipe model will be mapped to the user table in the database. The fields
    we defined for our recipe model are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 菜谱模型将被映射到数据库中的用户表。我们为我们的菜谱模型定义的字段如下：
- en: '`id`: The identity of a recipe.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：菜谱的标识。'
- en: '`name`: The name of the recipe. The maximum length allowed is 100 characters.
    It can''t be null.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：菜谱的名称。允许的最大长度是100个字符。它不能为空。'
- en: '`description`: The description of the recipe. The maximum length allowed is
    200\.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：菜谱的描述。允许的最大长度是200。'
- en: '`num_of_servings`: The number of servings. This needs to be an integer.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_of_servings`：份量数量。这需要是一个整数。'
- en: '`cook_time`: The cooking time in minutes. This field only accepts an integer.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cook_time`：烹饪时间（分钟）。此字段只接受整数。'
- en: '`directions`: The directions of the recipe. This can have a maximum length
    of 1,000.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directions`：菜谱的说明。这个字段的最大长度为1,000。'
- en: '`is_publish`: This is to indicate whether the recipe has been published. It
    is set to `False` by default.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_publish`：这是用来表示菜谱是否已发布。默认设置为`False`。'
- en: '`created_at`: The creation time of the recipe.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created_at`：菜谱的创建时间。'
- en: '`updated_at`: The last update time of the recipe.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updated_at`：菜谱的最后更新时间。'
- en: 'With the model designs in our mind, we are now ready to use these models in
    our next exercise. Before that, let''s also just briefly understand some of the
    key packages that we will be using. These are as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们心中有了模型设计之后，我们现在准备在下一个练习中使用这些模型。在此之前，让我们也简要了解一下我们将要使用的一些关键包。这些包如下：
- en: 'Flask-SQLAlchemy: This is a very popular ORM package that allows us to access
    objects rather than database tables for data. With ORM, we do not need to rely
    on SQL anymore.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask-SQLAlchemy：这是一个非常流行的ORM软件包，它允许我们访问对象而不是数据库表来处理数据。使用ORM，我们不再需要依赖SQL。
- en: 'Flask-Migrate: This is a package for database migration; it works on top of
    Alembic.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask-Migrate：这是一个数据库迁移软件包；它基于Alembic。
- en: 'Psycopg2-binary: This is the adapter for the Postgres database.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Psycopg2-binary：这是Postgres数据库的适配器。
- en: 'Passlib: This is a password hashing library for Python.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Passlib：这是一个Python密码散列库。
- en: 'Exercise 19: Installing Packages and Defining Models'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习19：安装软件包和定义模型
- en: 'This exercise is designed to install the necessary packages and define the
    user and recipe models. The user and recipe models are going to be Python classes;
    there will not be any SQL coding in this exercise. We want to show you how we
    can interact with the database by simply coding in Python:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习旨在安装必要的软件包并定义用户和食谱模型。用户和食谱模型将是Python类；本练习中不会涉及任何SQL编码。我们想通过简单的Python编码向您展示如何与数据库交互：
- en: 'We will add the required packages in the `requirements.txt` file. If you remember,
    by putting the package name and version in `requirements.txt`, we can install
    them in the Python virtual environment by using a single `pip` command:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`requirements.txt`文件中添加所需的软件包。如果您还记得，通过在`requirements.txt`中放置软件包名称和版本，我们可以通过单个`pip`命令在Python虚拟环境中安装它们：
- en: '[PRE0]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can run the following `pip install` command to install the necessary packages:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过以下`pip install`命令安装必要的软件包：
- en: '[PRE1]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The installation result will be shown onscreen:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装结果将在屏幕上显示：
- en: '[PRE2]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a `Config.py` file and type in the following code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Config.py`文件并输入以下代码：
- en: '[PRE3]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can set `DEBUG = True` here for debugging purposes. As regards `SQLALCHEMY_DATABASE_URI`,
    this is the path of the database. Please replace the username and password with
    the one we created for the `pgAdmin`. Also, replace the database name as well.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在这里设置`DEBUG = True`以进行调试。至于`SQLALCHEMY_DATABASE_URI`，这是数据库的路径。请将用户名和密码替换为我们为`pgAdmin`创建的。同时，也请替换数据库名称。
- en: 'Now, create `extensions.py` under the Smilecook project and type in the following
    code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在Smilecook项目下创建`extensions.py`并输入以下代码：
- en: '[PRE4]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create `user.py` under the folder models and type in the following code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`models`文件夹下创建`user.py`并输入以下代码：
- en: '[PRE5]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Replace `recipe.py` with the following code. We are adding the import `db`
    statement here and have also modified the `Recipe` class. The code related to
    `recipe_list` is still valid here, so we are retaining that part of the code:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`recipe.py`替换为以下代码。我们在这里添加了`import db`语句，并且也修改了`Recipe`类。与`recipe_list`相关的代码仍然有效，因此我们保留了这部分代码：
- en: '[PRE6]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, rewrite `app.py` with the following code. We are structuring our code in
    a more proper way, making it more readable and maintainable. First, import the
    required packages at the beginning of the code file.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，用以下代码重写`app.py`。我们以更合适的方式组织代码，使其更易于阅读和维护。首先，在代码文件的开头导入所需的软件包。
- en: Note
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE7]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Use the `create_app()` function to create the Flask app. This will invoke `register_extensions(app)`
    to initialize SQLAlchemy and set up Flask-Migrate. It will then invoke `register_resources(app)`
    to set up resource routing:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`create_app()`函数创建Flask应用程序。这将调用`register_extensions(app)`以初始化SQLAlchemy并设置Flask-Migrate。然后它将调用`register_resources(app)`来设置资源路由：
- en: '[PRE8]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, use `app = create_app()` to create the Flask app, and use `app.run()`
    to start the application:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`app = create_app()`创建Flask应用程序，并使用`app.run()`启动应用程序：
- en: '[PRE9]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Save `app.py` and *right-click* on it to run the application. Flask will then
    be started up and run on the localhost (**127.0.0.1**) on port 5000:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`app.py`并在其上右键单击以运行应用程序。然后Flask将在本地主机（**127.0.0.1**）的5000端口启动并运行：
- en: '![Figure 3.7: Flask started on localhost'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7：在本地主机上启动Flask]'
- en: '](img/C15309_03_07.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C15309_03_07.jpg](img/C15309_03_07.jpg)'
- en: 'Figure 3.7: Flask started on localhost'
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.7：在本地主机上启动Flask
- en: We have successfully installed the necessary ORM-related packages, and defined
    the user and recipe models. Having first installed the packages, we ran the installation
    in our virtual environment. We created `config.py`, `extensions.py`, and `user.py`
    files and replaced `app.py`. Finally, we restructured our Flask app and saw how
    well it runs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功安装必要的ORM相关软件包，并定义了用户和食谱模型。首先安装软件包后，我们在虚拟环境中运行了安装。我们创建了`config.py`、`extensions.py`和`user.py`文件，并替换了`app.py`。最后，我们对Flask应用程序进行了重构，并看到了它运行得有多好。
- en: 'Exercise 20: Using Flask-Migrate to Build a Database Upgrade Script'
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习20：使用Flask-Migrate构建数据库升级脚本
- en: 'Having successfully understood how to work with our two main models, user and
    recipe, we have now built the perfect foundation. The next step is execution.
    We will use Flask-Migrate to build a script to create the user and recipe tables:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 成功理解如何使用我们的两个主要模型，用户和食谱后，我们现在已经建立了完美的基础。下一步是执行。我们将使用 Flask-Migrate 来构建一个脚本来创建用户和食谱表：
- en: 'Use the following command in the Terminal to initialize our database. This
    will create a migration repository:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中使用以下命令初始化我们的数据库。这将创建一个迁移存储库：
- en: '[PRE10]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should see the following onscreen:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该在屏幕上看到以下内容：
- en: '[PRE11]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should now see the following new files in PyCharm:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您现在应该在 PyCharm 中看到以下新文件：
- en: '![Figure 3.8: New folders in PyCharm'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.8：PyCharm 中的新文件夹'
- en: '](img/C15309_03_08.jpg)'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_03_08.jpg)'
- en: 'Figure 3.8: New folders in PyCharm'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3.8：PyCharm 中的新文件夹
- en: 'Now, run the `flask db migrate` command to create the database and tables.
    There is no need for us to use SQL here:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行 `flask db migrate` 命令来创建数据库和表。我们在这里不需要使用 SQL：
- en: '[PRE12]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Flask-Migrate detected two objects (`user` and `recipe`) and created two corresponding
    tables for them:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Flask-Migrate检测到两个对象（`user` 和 `recipe`）并为它们创建了相应的两个表：
- en: '[PRE13]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, please check `/migrations/versions/a6d248ab7b23_.py` under the `versions`
    folder. This file is created by Flask-Migrate. Note that you may get a different
    revision ID here. Please review the file before you run the flask `db` upgrade
    command. That''s because, sometimes, it may not detect every change you make to
    your models:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，请检查 `versions` 文件夹下的 `/migrations/versions/a6d248ab7b23_.py`。此文件由 Flask-Migrate
    创建。请注意，您在这里可能得到不同的修订 ID。请在运行 flask `db` upgrade 命令之前查看该文件。因为有时它可能无法检测到您对模型所做的每个更改：
- en: '[PRE14]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There are two functions in this autogenerated file; one is upgraded, and this
    is to add the new recipe and user to the table, while the other one is downgraded,
    which is to go back to the previous version.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此自动生成的文件中有两个函数；一个是升级的，用于将新的食谱和用户添加到表中，另一个是降级的，用于回到上一个版本。
- en: 'We will then execute the `flask db upgrade` command, which will upgrade our
    database to conform with the latest specification in our models:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将执行 `flask db upgrade` 命令，这将使我们的数据库符合模型中最新规范：
- en: '[PRE15]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This command will invoke `upgrade()` to upgrade the database:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将调用 `upgrade()` 来升级数据库：
- en: '[PRE16]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In the future, whenever we need to upgrade the database, we can just call `flask
    db migrate` and `flask db upgrade`.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在未来，无论何时我们需要升级数据库，我们只需调用 `flask db migrate` 和 `flask db upgrade`。
- en: 'Check the database tables in `pgAdmin`. Now, we can see whether the tables
    have been created in the database. Go to **smilecook** >> **Schemas** >> **Tables
    to verify**:![Figure 3.9: Checking the database tables'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `pgAdmin` 中检查数据库表。现在，我们可以查看表是否已在数据库中创建。转到 **smilecook** >> **Schemas** >>
    **Tables to verify**：![图 3.9：检查数据库表
- en: '](img/C15309_03_09.jpg)'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_03_09.jpg)'
- en: 'Figure 3.9: Checking the database tables'
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3.9：检查数据库表
- en: If you see the recipe and user tables in our **Smilecook** database, this means
    you have successfully created them in Python without any SQL. Isn't that cool?!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在我们的 **Smilecook** 数据库中看到食谱和用户表，这意味着您已成功在 Python 中创建它们，而没有使用任何 SQL。这不是很酷吗？!
- en: Next, we will try our hand at database insertion. Let's look at the following
    exercise.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试数据库插入。让我们看看以下练习。
- en: 'Exercise 21: Applying Database Insertion'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 21：应用数据库插入
- en: 'This exercise is designed for us to test database insertion. We will first
    create a user, and then create two recipes under that user:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习是为了让我们测试数据库插入。我们首先创建一个用户，然后在该用户下创建两个食谱：
- en: 'Import modules in the Python console. Open the Python console at the bottom
    of PyCharm and type in the following code to import the necessary classes:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Python 控制台中导入模块。在 PyCharm 底部打开 Python 控制台，并输入以下代码以导入必要的类：
- en: '[PRE17]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create our first `user` object and save that to the database by typing in the
    following code in the Python console:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的第一个 `user` 对象，并将其保存到数据库中，请在 Python 控制台中输入以下代码：
- en: '[PRE18]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, check the `user` details. Please note that the ID of the user has already
    been assigned to `1`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查 `user` 的详细信息。请注意，用户的 ID 已经被分配为 `1`：
- en: '[PRE19]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Since the user is persisted in the database, we will verify that there:![Figure
    3.10: Verifying the user in the database'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于用户已保存在数据库中，我们将验证那里：![图 3.10：在数据库中验证用户
- en: '](img/C15309_03_10.jpg)'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_03_10.jpg)'
- en: 'Figure 3.10: Verifying the user in the database'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3.10：在数据库中验证用户
- en: 'We can see a record there in the `user` table:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在 `user` 表中看到一条记录：
- en: '![Figure 3.11: Record in the user table'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![图 3.11：用户表中的记录'
- en: '](img/C15309_03_11.jpg)'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_03_11.jpg)'
- en: 'Figure 3.11: Record in the user table'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3.11：用户表中的记录
- en: 'Next, we will create two recipes using the following code. One thing to note
    is that the `user_id` attribute of the recipe is set to `user.id`. This is to
    indicate that the recipe was created by the user `Jack`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用以下代码创建两个菜谱。需要注意的是，菜谱的 `user_id` 属性被设置为 `user.id`。这是为了表明菜谱是由用户 `Jack`
    创建的：
- en: '[PRE20]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will then check whether the two recipes have been created in the database:![Figure
    3.12: Checking whether the two recipes have been created'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将检查是否在数据库中创建了两个菜谱：![图 3.12：检查两个菜谱是否已创建
- en: '](img/C15309_03_12.jpg)'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C15309_03_12.jpg](img/C15309_03_12.jpg)'
- en: 'Figure 3.12: Checking whether the two recipes have been created'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3.12：检查两个菜谱是否已创建
- en: 'We will search for the user with the username `jack` in the database and get
    all the recipes created by that user in their object attribute, `recipes`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在数据库中搜索用户名为 `jack` 的用户，并获取该用户创建的所有菜谱，这些菜谱存储在他们的对象属性 `recipes` 中：
- en: '[PRE21]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will get a list of two recipes:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将获取两个菜谱的列表：
- en: '[PRE22]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can display the details of the recipes using the `for` loop. We get the
    recipe name using `recipe.name`, while we get the user''s name using `recipe.user.username`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `for` 循环来显示菜谱的详细信息。我们通过 `recipe.name` 获取菜谱名称，而通过 `recipe.user.username`
    获取用户的名称：
- en: '[PRE23]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should see the following result on the screen:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该在屏幕上看到以下结果：
- en: '[PRE24]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You have just learned how to command your application using the Python console.
    You have just created the user and recipe models and saved them in the database.
    The entire process is SQL-free, as you can see. Let's do an activity to reinforce
    your knowledge.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学会了如何使用 Python 控制台来命令你的应用程序。你已经创建了用户和菜谱模型，并将它们保存在数据库中。整个过程是无 SQL 的，正如你所看到的。让我们通过一个活动来巩固你的知识。
- en: 'Activity 5: Creating a User and a Recipe'
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 5：创建用户和菜谱
- en: 'In this activity, we will test our APIs by running a few more test cases. We
    want to create a new user, `Peter`, and create two recipes under him in the database.
    Let''s see if you know how to write the code for that in the Python interactive
    console:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将通过运行一些额外的测试用例来测试我们的 API。我们想要创建一个新用户 `Peter`，并在数据库中为他创建两个菜谱。让我们看看你是否知道如何在
    Python 交互控制台中编写这段代码：
- en: Import the `User` and `Recipe` classes and create the Flask app using the Python
    console.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `User` 和 `Recipe` 类，并使用 Python 控制台创建 Flask 应用程序。
- en: Create a new user, `Peter`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新用户，`Peter`。
- en: Create two recipes and assign `Peter` as the author.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个菜谱并将 `Peter` 设为作者。
- en: Note
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 302.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 302 页找到。
- en: If you can see that the data has successfully been created in the database,
    congratulations – you already know how to use Python console to interact with
    the database! Next, we will implement a user registration feature.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到数据已成功创建在数据库中，恭喜你——你已经知道如何使用 Python 控制台与数据库进行交互！接下来，我们将实现用户注册功能。
- en: Password Hashing
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码哈希
- en: 'Hashing is a one-way mathematical function. It requires little computing power
    to convert a plaintext string to its hash value (hashes). However, it will require
    a huge amount of computing power to retrieve the original string from the hash
    value (it''s almost impossible). Therefore, we call it a one-way function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是一种单向数学函数。将明文字符串转换为哈希值（哈希）需要很少的计算能力。然而，要从哈希值中检索原始字符串则需要巨大的计算能力（几乎是不可能的）。因此，我们称它为单向函数：
- en: '![Figure 3.13: Workings of the hash function'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.13：哈希函数的工作原理'
- en: '](img/C15309_03_13.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C15309_03_13.jpg](img/C15309_03_13.jpg)'
- en: 'Figure 3.13: Workings of the hash function'
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3.13：哈希函数的工作原理
- en: With this property, a hash function is perfect for a hashing password. We will
    hash the user's password into hashes before we save it to the database so that
    it is unrecognizable and irreversible. And next time, when the user logs in, what
    the platform does is to convert the input the password to its hash value, and
    then compare that with the hash value stored in the database. That way, we can
    perform a password comparison without leaking the sensitive password information
    to others.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这一特性，哈希函数非常适合用于密码哈希。在我们将其保存到数据库之前，我们将用户的密码哈希化，使其不可识别且不可逆。下次用户登录时，平台所做的是将输入的密码转换为它的哈希值，然后将其与数据库中存储的哈希值进行比较。这样，我们就可以在不向他人泄露敏感密码信息的情况下执行密码比较。
- en: 'Exercise 22: Implement the User Registration Feature and Hash the User''s Password'
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 22：实现用户注册功能并哈希用户密码
- en: 'In this exercise, we will work on the user registration feature. We will also
    implement two functions for hashing the user''s password:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将处理用户注册功能。我们还将实现两个用于哈希用户密码的函数：
- en: 'Create `utils.py` under the application project folder and type in the following
    code. The code is to hash the password. We do not want to store plaintext passwords
    in our database on account of security concerns. Therefore, we will use the `passlib`
    modules for hashing. We defined two methods here:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序项目文件夹下创建`utils.py`，并输入以下代码。这段代码用于哈希密码。由于安全考虑，我们不希望在数据库中存储明文密码。因此，我们将使用`passlib`模块进行哈希。我们在这里定义了两种方法：
- en: '[PRE25]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `hash_password(password)` function is for password hashing and `check_password(password,
    hashed)` is for user authentication. It hashes the user-input password and compares
    that with the one we saved in the database.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`hash_password(password)`函数用于密码哈希，`check_password(password, hashed)`用于用户认证。它将用户输入的密码进行哈希处理，并将其与我们保存在数据库中的密码进行比较。'
- en: 'Create `user.py` in the `resources` folder, and then type in the following
    code. We will first import the necessary modules and implement the `Post` method
    in `UserListResource`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resources`文件夹中创建`user.py`，然后输入以下代码。我们首先导入必要的模块并在`UserListResource`中实现`Post`方法：
- en: '[PRE26]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When there is a client request hitting `http://localhost/users` with the HTTP
    `POST` method, the application will get the JSON formatted data in the request.
    There should be a username, email, and password.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当客户端请求以HTTP `POST`方法击中`http://localhost/users`时，应用程序将获取请求中的JSON格式数据。应该有一个用户名、电子邮件和密码。
- en: 'Check whether the user already exists in the database by means of `User.get_by_user(username)`.
    If such an entry is found, that means the user has already registered and we will
    simply return an error message. We will also perform the same check on `email`
    as well:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`User.get_by_user(username)`检查用户是否已存在于数据库中。如果找到这样的条目，这意味着用户已经注册，我们将简单地返回一个错误消息。我们也会对`email`进行相同的检查：
- en: '[PRE27]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once all the validations are passed, go ahead and create the user in the database.
    The password will be hashed, and the user object will be created. The user object
    will then be saved to the database using `user.save()`. Finally, the user details
    are returned in JSON format, with an `HTTP` status code of `201`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有验证都通过，就可以在数据库中创建用户。密码将被哈希，然后创建用户对象。然后使用`user.save()`将用户对象保存到数据库中。最后，以JSON格式返回用户详细信息，并带有`HTTP`状态码`201`：
- en: '[PRE28]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add user resource routing to `app.py`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户资源路由添加到`app.py`：
- en: '[PRE29]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Replace `from models.user import User` in `app.py` with `from resources.user
    import UserListResource`. The user model is already imported in `resources.user`,
    so there is no need to reimport that again. Please add `api.add_resource(UserListResource,
    '/users')` to the code as well.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将`app.py`中的`from models.user import User`替换为`from resources.user import UserListResource`。用户模型已经在`resources.user`中导入，因此不需要再次导入。请将`api.add_resource(UserListResource,
    '/users')`也添加到代码中。
- en: 'Run the application. Flask will then be started up and run on localhost (`127.0.0.1`)
    on port `5000`:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行应用程序。Flask将在本地主机（`127.0.0.1`）的`5000`端口上启动并运行：
- en: '![Figure 3.14: Flask started on localhost'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图3.14：Flask在本地主机上启动'
- en: '](img/C15309_03_07.jpg)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_03_07.jpg)'
- en: 'Figure 3.14: Flask started on localhost'
  id: totrans-201
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.14：Flask在本地主机上启动
- en: So, we have just finished the password hashing exercise. From now on, whenever
    there is a new user registered in our Smilecook application, their password will
    be hashed and stored safely in the database. Let's test and see whether that is
    the case in our next exercise.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们刚刚完成了密码哈希练习。从现在起，每当有新用户在我们的Smilecook应用程序中注册时，他们的密码将被哈希并安全地存储在数据库中。让我们在下一个练习中测试一下这是否如此。
- en: Note
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The reason why we are not discussing the recipe resource here is that there
    will be an author ID in the recipe. The author ID will be a foreign key that links
    to the user model. We will talk about the user login function in our next chapter.
    Only after that can we get the user ID and finish the recipe resource.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不讨论食谱资源的原因是，食谱中会有一个作者ID。作者ID将是一个外键，它将链接到用户模型。我们将在下一章中讨论用户登录功能。只有在那之后，我们才能获取用户ID并完成食谱资源。
- en: 'Exercise 23: Testing the Application in Postman'
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习23：在Postman中测试应用程序
- en: 'In this exercise, we are going to test the application in Postman. We will
    first register a user account and make sure the user data is stored in the database.
    We also need to verify that the password is hashed. Having created a user, now
    let''s test our API endpoint here:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将测试Postman中的应用程序。我们首先注册一个用户账户，并确保用户数据已存储在数据库中。我们还需要验证密码是否已哈希。创建用户后，现在让我们测试我们的API端点：
- en: Click on the **Collections** tab in Postman.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Postman中点击**集合**选项卡。
- en: Create a new collection, and name it `User`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的集合，并将其命名为`User`。
- en: Create a new request, `UserList`, under that collection. You can do this by
    clicking on the `User` collection.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该集合下创建一个新的请求，`UserList`。你可以通过点击`User`集合来完成此操作。
- en: Edit the `POST`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`POST`。
- en: Type in `http://localhost:5000/users` in the URL field.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在URL字段中输入`http://localhost:5000/users`。
- en: Go to the **Body** Tab, select **raw** as the datatype, and then select **JSON
    (application/json)** as the data format.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**主体**选项卡，将数据类型选择为**raw**，然后选择数据格式为**JSON (application/json)**。
- en: 'Insert the following user details and then save.:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入以下用户详细信息并保存：
- en: '[PRE30]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Click **Send**. The result can be seen in the following screenshot:![Figure
    3.15: Creating a user with an existing username'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送**。结果如下所示截图：![图3.15：使用现有用户名创建用户
- en: '](img/C15309_03_15.jpg)'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_03_15.jpg)'
- en: 'Figure 3.15: Creating a user with an existing username'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.15：使用现有用户名创建用户
- en: You will then see the following data returned; the HTTP status is **400 BAD
    REQUEST**. We can also see the error message in the **Body** field showing that
    the username has been registered.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到以下返回的数据；HTTP状态为**400 BAD REQUEST**。我们还可以在**主体**字段中看到错误消息，显示用户名已被注册。
- en: 'Create another user with the details shown in the following code:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码创建另一个具有以下详细信息的用户：
- en: '[PRE31]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The result can be seen in the following screenshot:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果如下所示截图：
- en: '![Figure 3.16: Creating another user'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图3.16：创建另一个用户'
- en: '](img/C15309_03_16.jpg)'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_03_16.jpg)'
- en: 'Figure 3.16: Creating another user'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.16：创建另一个用户
- en: Now, the second account has been successfully created.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，第二个账户已成功创建。
- en: 'Check the data in the database as follows:![Figure 3.17: Checking the data
    in the database'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式检查数据库中的数据：![图3.17：检查数据库中的数据
- en: '](img/C15309_03_17.jpg)'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_03_17.jpg)'
- en: 'Figure 3.17: Checking the data in the database'
  id: totrans-228
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.17：检查数据库中的数据
- en: Now, we can see a new user record created in the database table. And you can
    see that the password is hashed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到数据库表中创建了一个新的用户记录。并且你可以看到密码已被哈希。
- en: By doing this testing exercise, we can be assured that our user registration
    workflow is functioning well. And, most importantly, user passwords are kept as
    the hash value in the database. That is a much safer way to store a password,
    as even the database administrator can't see it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进行此测试练习，我们可以确保我们的用户注册工作流程运行良好。最重要的是，用户密码以哈希值的形式保存在数据库中。这是一种更安全的存储密码的方式，即使数据库管理员也无法看到它。
- en: 'Activity 6: Upgrading and Downgrading a Database'
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动6：升级和降级数据库
- en: 'In this activity, we will upgrade and downgrade our database to simulate a
    scenario where we need to add an attribute under the `user` class, but later we
    change our mind and need to remove it. The following are the high-level steps
    that we need to perform in order to complete this activity:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此活动中，我们将升级和降级数据库以模拟我们需要在`user`类下添加属性的场景，但后来我们改变了主意，需要删除它。以下是我们完成此活动所需执行的高级步骤：
- en: Add a new attribute to the `user` class. This attribute should be called `bio`
    and will be a string that represents information about the user.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`user`类添加一个新属性。此属性应命名为`bio`，它将是一个表示用户信息的字符串。
- en: Run the `flask db migrate` command to create the database and tables.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`flask db migrate`命令以创建数据库和表。
- en: Now, check `/migrations/versions/6971bd62ec60_.py` under the `versions` folder.
    This file is created by Flask-Migrate.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查`versions`文件夹下的`/migrations/versions/6971bd62ec60_.py`。此文件由Flask-Migrate创建。
- en: Execute the `flask db upgrade` command to upgrade our database to conform with
    the latest specification in our models.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`flask db upgrade`命令以将我们的数据库升级到符合我们模型中最新的规范。
- en: Check whether the new field is created in the database.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查新字段是否已创建在数据库中。
- en: Run the `downgrade` command to remove the new field.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`downgrade`命令以删除新字段。
- en: Check whether the field has been removed.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查字段是否已被删除。
- en: Note
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 303.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第303页找到。
- en: If you see that the new field has been removed, that means you have successfully
    downgraded the database in Python without writing any SQL. And don't forget to
    delete the user model's bio attribute in models/user.py, also delete the script
    that we created which is `a6d248ab7b23.py` in migrations/versions folder. You
    have just learned a very useful skill that you will probably need frequently in
    the future. One tip for you is that you should back up your database prior to
    any database schema update. This is to ensure the data won't get lost.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到新字段已被删除，这意味着你已经在Python中成功降级了数据库，而没有编写任何SQL。别忘了删除models/user.py中用户模型的bio属性，也删除我们在migrations/versions文件夹中创建的脚本`a6d248ab7b23.py`。你刚刚学会了一个非常有用的技能，你将来可能会经常用到。给你一个提示，你应该在数据库模式更新之前备份你的数据库。这是为了确保数据不会丢失。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built the Postgres database locally and learned how to use
    the pgAdmin tool to manage it. Then, through the SQLAlchemy module, we developed
    an object library to manipulate the database. This is much easier than using SQL
    syntax directly. And, as long as we define the relationship between models, we
    can easily get the information we want. This results in higher code readability,
    fewer lines of code, and the elimination of repetitive SQL. We then use Flask-Migrate
    to build all the data tables. Then, when we migrate the database in the future,
    we simply need two commands – `flask db migrate` and `flask db upgrade`; it's
    simple and easy. Although Flask-Migrate can help us to set up and migrate a database
    more easily, in a production environment, performing this kind of migration still
    requires extra due diligence. We should always back up the database to safeguard
    our precious data.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在本地构建了Postgres数据库，并学习了如何使用pgAdmin工具来管理它。然后，通过SQLAlchemy模块，我们开发了一个对象库来操作数据库。这比直接使用SQL语法要容易得多。而且，只要我们定义了模型之间的关系，我们就可以轻松地获取我们想要的信息。这导致代码可读性更高，代码行数更少，并消除了重复的SQL。然后，我们使用Flask-Migrate构建所有数据表。然后，当我们将来迁移数据库时，我们只需要两个命令——`flask
    db migrate`和`flask db upgrade`；这很简单，也很容易。尽管Flask-Migrate可以帮助我们更轻松地设置和迁移数据库，但在生产环境中，执行此类迁移仍然需要额外的谨慎。我们应该始终备份数据库以保护我们宝贵的数据。
- en: During development, we should frequently test our code to make sure it is behaving
    as expected. We shouldn't wait till the end to perform big-bang testing. We can
    unit test our functions and API endpoints, once they are complete. Using the Python
    console to perform this kind of simple test is recommended. Iteratively testing
    our application can also foster the best programming practice. This forces us
    to think about how we can structure our code in an elegant manner and avoid technical
    debt accumulation.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我们应该经常测试我们的代码以确保其按预期行为。我们不应该等到最后才进行大范围测试。一旦完成，我们可以对函数和API端点进行单元测试。使用Python控制台进行此类简单测试是推荐的。迭代测试我们的应用程序也可以培养最佳编程实践。这迫使我们思考如何以优雅的方式组织代码并避免技术债务的积累。
- en: Finally, we created an API for user registration. In the next chapter, we will
    work on user login and recipe creation for authenticated users.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为用户注册创建了一个API。在下一章中，我们将致力于为认证用户开发用户登录和食谱创建功能。
