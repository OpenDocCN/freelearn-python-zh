- en: General Traits of Good Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 良好代码的一般特征
- en: This is a book about software construction with Python. Good software is built
    from a good design. By saying things such as clean code, one might think that
    we will explore good practices that relate only to the implementation details
    of the software, instead of its design. However, this assumption would be wrong
    since the code is not something different from the design—the code is the design.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一本关于Python软件构建的书。优秀的软件建立在良好的设计基础上。说到干净的代码之类的话，人们可能会认为我们将探讨只与软件的实现细节相关的良好实践，而不是其设计。然而，这种假设是错误的，因为代码并不是与设计不同的东西——代码就是设计。
- en: The code is probably the most detailed representation of the design. In the
    first two chapters, we discussed why structuring the code in a consistent way
    was important, and we have seen idioms for writing more compact and idiomatic
    code. Now it's time to understand that clean code is that, and much more—the ultimate
    goal is to make the code as robust as possible, and to write it in a way that
    minimizes defects or makes them utterly evident, should they occur.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能是设计最详细的表现。在前两章中，我们讨论了为什么以一致的方式构建代码很重要，并且我们已经看到了编写更紧凑和成语化代码的习惯用法。现在是时候理解干净的代码就是这样，而且更多——最终目标是尽可能使代码健壮，并以最小化缺陷的方式编写代码，或者使它们完全显而易见，如果它们发生了。
- en: This chapter and the next one are focused on design principles at a higher level
    of abstraction. These ideas not only relate to Python in particular but are instead
    general principles of software engineering.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和下一章侧重于更高层次的抽象设计原则。这些想法不仅与特定的Python相关，而且是软件工程的一般原则。
- en: In particular, for this chapter, we will review different principles that make
    for good software design. Good-quality software should be built around these ideas,
    and they will serve as design tools. This does not mean that all of them should
    always be applied; in fact, some of them represent different points of view (such
    is the case with the **Design by Contract** (**DbC**) approach, as opposed to
    defensive programming). Some of them depend on the context and are not always
    applicable.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是对于本章，我们将回顾构建良好软件设计的不同原则。高质量的软件应该围绕这些想法构建，并且它们将作为设计工具。这并不意味着所有这些原则都应该始终应用；事实上，其中一些代表不同的观点（这就是**按合同设计**（**DbC**）方法与防御性编程相对立的情况）。其中一些取决于上下文，不一定适用于所有情况。
- en: A high-quality code is a concept that has multiple dimensions. We can think
    of this similarly to how we think about the quality attributes of a software architecture.
    For example, we want our software to be secure and to have good performance, reliability,
    and maintainability, just to name a few.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 高质量的代码是一个具有多个维度的概念。我们可以将其类比为我们思考软件架构的质量属性。例如，我们希望我们的软件安全并且具有良好的性能、可靠性和可维护性，仅举几例。
- en: 'The goals of this chapter are as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标如下：
- en: To understand the concepts behind robust software
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解健壮软件背后的概念
- en: To learn how to deal with erroneous data during the workflow of the application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在应用程序的工作流程中处理错误数据
- en: To design maintainable software that can easily be extended and adapted to new
    requirements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计可维护的软件，可以轻松扩展和适应新的需求
- en: To design reusable software
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计可重用的软件
- en: To write effective code that will keep the productivity of the development team
    high
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写有效的代码，保持开发团队的生产力高
- en: Design by contract
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按合同设计
- en: Some parts of the software we are working on are not meant to be called directly
    by users, but instead by other parts of the code. Such is the case when we divide
    the responsibilities of the application into different components or layers, and
    we have to think about the interaction between them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在处理的软件的某些部分并不是直接由用户调用的，而是由代码的其他部分调用的。当我们将应用程序的责任划分为不同的组件或层时，我们必须考虑它们之间的交互。
- en: We will have to encapsulate some functionality behind each component, and expose
    an interface to clients who are going to use that functionality, namely an **Application
    Programming Interface** (**API**). The functions, classes, or methods we write
    for that component have a particular way of working under certain considerations
    that, if they are not met, will make our code crash. Conversely, clients calling
    that code expect a particular response, and any failure of our function to provide
    this would represent a defect.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不将一些功能封装在每个组件后面，并向将使用该功能的客户端公开一个接口，即**应用程序编程接口**（**API**）。我们为该组件编写的函数、类或方法在特定考虑下有一种特定的工作方式，如果不满足这些条件，我们的代码将崩溃。相反，调用该代码的客户端期望特定的响应，我们的函数未能提供这一点将代表一个缺陷。
- en: That is to say that if, for example, we have a function that is expected to
    work with a series of parameters of type integers, and some other function invokes
    our passing strings, it is clear that it should not work as expected, but in reality,
    the function should not run at all because it was called incorrectly (the client
    made a mistake). This error should not pass silently.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，例如，如果我们有一个函数，预期与一系列整数类型的参数一起工作，并且另一个函数调用我们传递字符串，很明显它不应该按预期工作，但实际上，函数根本不应该运行，因为它被错误调用了（客户端犯了一个错误）。这个错误不应该悄无声息地通过。
- en: Of course, when designing an API, the expected input, output, and side-effects
    should be documented. But documentation cannot enforce the behavior of the software
    at runtime. These rules, what every part of the code expects in order to work
    properly and what the caller is expecting from them, should be part of the design,
    and here is where the concept of a **contract** comes into place.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计API时，预期的输入、输出和副作用应该有文档记录。但文档无法强制软件在运行时的行为。这些规则，代码的每个部分期望为了正常工作而满足的条件，以及调用者对它们的期望，应该成为设计的一部分，这就是**合同**的概念所在。
- en: The idea behind the DbC is that instead of implicitly placing in the code what
    every party is expecting, both parties agree on a contract that, if violated,
    will raise an exception, clearly stating why it cannot continue.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: DbC背后的想法是，与其在代码中隐含地放置每个参与方的期望，不如让双方就一个合同达成一致，如果违反了合同，就会引发异常，清楚地说明为什么不能继续。
- en: 'In our context, a contract is a construction that enforces some rules that
    must be honored during the communication of software components. A contract entails
    mainly preconditions and postconditions, but in some cases, invariants, and side-effects
    are also described:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的上下文中，合同是一种强制执行软件组件通信过程中必须遵守的规则的构造。合同主要包括前置条件和后置条件，但在某些情况下，还描述了不变量和副作用：
- en: '**Preconditions**: We can say that these are all the checks code will do before
    running. It will check for all the conditions that have to be made before the
    function can proceed. In general, it''s implemented by validating the data set
    provided in the parameters passed, but nothing should stop us from running all
    sorts of validations (for example, validating a set in a database, a file, another
    method that was called before, and so on) if we consider that their side-effects
    are overshadowed by the importance of such a validation. Notice that this imposes
    a constraint on the caller.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前置条件**：我们可以说这些是代码在运行之前进行的所有检查。它将检查函数可以继续进行之前必须满足的所有条件。一般来说，它是通过验证传递的参数中提供的数据集来实现的，但如果我们认为它们的副作用被这样的验证的重要性所掩盖，那么没有什么可以阻止我们运行各种验证（例如，验证数据库中的一个集合，一个文件，之前调用的另一个方法等）。请注意，这对调用者施加了约束。'
- en: '**Postconditions**: The opposite of preconditions, here, the validations are
    done after the function call is returned. Postcondition validations are run to
    validate what the caller is expecting from this component.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后置条件**：与前置条件相反，在函数调用返回后进行验证。后置条件验证用于验证调用者对该组件的期望。'
- en: '**Invariants**: Optionally, it would be a good idea to document, in the docstring
    of a function, the invariants, the things that are kept constant while the code
    of the function is running, as an expression of the logic of the function to be
    correct.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不变量**：可选地，在函数的文档字符串中记录不变量是一个好主意，这些不变量在函数运行时保持不变，作为函数逻辑正确性的表达。'
- en: '**Side-effects**: Optionally, we can mention any side-effects of our code in
    the docstring.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**副作用**：可选地，我们可以在文档字符串中提及代码的任何副作用。'
- en: While conceptually all of these items form part of the contract for a software
    component, and this is what should go to the documentation of such piece, only
    the first two (preconditions and postconditions) are to be enforced at a low level
    (code).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在概念上，所有这些项目都构成了软件组件的合同的一部分，这也是应该放入这样一块文档的内容，但只有前两个（前置条件和后置条件）需要在低级别（代码）上执行。
- en: The reason why we would design by contract is that if errors occur, they must
    be easy to spot (and by noticing whether it was either the precondition or postcondition
    that failed, we will find the culprit much easily) so that they can be quickly
    corrected. More importantly, we want critical parts of the code to avoid being
    executed under the wrong assumptions. This should help to clearly mark the limits
    for the responsibilities and errors if they occur, as opposed to something saying—this
    part of the application is failing... But the caller code provided the wrong arguments,
    so where should we apply the fix?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以要通过合同设计，是因为如果出现错误，它们必须很容易被发现（通过注意是前置条件还是后置条件失败，我们将更容易地找到罪魁祸首），以便可以快速纠正。更重要的是，我们希望代码的关键部分避免在错误的假设下执行。这应该有助于清楚地标记责任的界限和错误的发生，而不是说——应用程序的这一部分出现了问题...但是调用者提供了错误的参数，那么我们应该在哪里应用修复？
- en: The idea is that preconditions bind the client (they have an obligation to meet
    them if they want to run some part of the code), whereas postconditions bind the
    component in question to some guarantees that the client can verify and enforce.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是，前置条件约束了客户端（如果他们想要运行代码的某个部分，他们就有义务满足这些条件），而后置条件约束了相关组件对客户端可以验证和执行的某些保证。
- en: This way, we can quickly identify responsibilities. If the precondition fails,
    we know it is due to a defect on the client. On the other hand, if the postcondition
    check fails, we know the problem is in the routine or class (supplier) itself.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以快速确定责任。如果前置条件失败，我们知道这是客户端的缺陷。另一方面，如果后置条件检查失败，我们知道问题出现在例程或类（供应商）本身。
- en: Specifically regarding preconditions, it is important to highlight that they
    can be checked at runtime, and if they occur, the code that is being called should
    not be run at all (it does not make sense to run it because its conditions do
    not hold, and further more, doing so might end up making things worse).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是关于前置条件，重要的是要强调它们可以在运行时进行检查，如果发生，被调用的代码就不应该运行（因为它的条件不成立，而且这样做可能会使情况变得更糟）。
- en: Preconditions
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前置条件
- en: Preconditions are all of the guarantees a function or method expects to receive
    in order to work correctly. In general programming terms, this usually means to
    provide data that is properly formed, for example, objects that are initialized,
    non-null values, and many more. For Python, in particular, being dynamically typed,
    this also means that sometimes we need to check for the exact type of data that
    are provided. This is not exactly the same as type checking, the kind `mypy` would
    do this, but rather verify for exact values that are needed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前置条件是函数或方法期望接收的所有保证，以便正确工作。在一般的编程术语中，这通常意味着提供正确形式的数据，例如初始化的对象，非空值等。对于Python来说，特别是由于其动态类型，这也意味着有时我们需要检查所提供的数据的确切类型。这与类型检查并不完全相同，`mypy`会执行此操作，而是验证所需的确切值。
- en: Part of these checks can be detected early on by using static analysis tools,
    such as `mypy`, which we already introduced in [Chapter 1](bba62a64-dfe9-478f-9b33-6c3240d75f59.xhtml), *Introduction,
    Code Formatting, and Tools*, but these checks are not enough. A function should
    have proper validation for the information that it is going to handle.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用静态分析工具，例如`mypy`，可以尽早地检测到这些检查中的一部分，但这些检查还不够。函数应该对其要处理的信息进行适当的验证。
- en: Now, this poses the question of where to place the validation logic, depending
    on whether we let the clients validate all the data before calling the function,
    or allow this one to validate everything that it received prior running its own
    logic. The former corresponds to a tolerant approach (because the function itself
    is still allowing any data, potentially malformed data as well), whereas the latter
    corresponds to a demanding approach.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这就引出了一个问题，即根据我们是让客户在调用函数之前验证所有数据，还是允许函数在运行自己的逻辑之前验证接收到的所有数据的地方放置验证逻辑。前者对应于宽容的方法（因为函数本身仍然允许任何数据，可能是格式不正确的数据），而后者对应于严格的方法。
- en: For the purposes of this analysis, we prefer a demanding approach when it comes
    to DbC, because it is usually the safest choice in terms of robustness, and usually
    the most common practice in the industry.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析的目的，我们更喜欢在DbC方面采取严格的方法，因为这通常是在健壮性方面最安全的选择，也是行业中最常见的做法。
- en: Regardless of the approach we decide to take, we should always keep in mind
    the non-redundancy principle, which states that the enforcement of each precondition
    for a function should be done by only one of the two parts of the contract, but
    not both. This means that we put the validation logic on the client, or we leave
    it to the function itself, but in no cases should we duplicate it (which also
    relates to the DRY principle, which we will discuss later on in this chapter).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们决定采取哪种方法，我们都应该始终牢记非冗余原则，即函数的每个前置条件的执行应该由合同的两个部分中的一个来完成，而不是两者都完成。这意味着我们将验证逻辑放在客户端上，或者我们将其留给函数本身，但在任何情况下都不应该重复（这也与DRY原则有关，我们将在本章后面讨论）。
- en: Postconditions
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后置条件
- en: Postconditions are the part of the contract that is responsible for enforcing
    the state after the method or function has returned.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 后置条件是合同的一部分，负责在方法或函数返回后强制执行状态。
- en: Assuming that the function or method has been called with the correct properties
    (that is, with its preconditions met), then the postconditions will guarantee
    that certain properties are preserved.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设函数或方法已经以正确的属性被调用（也就是说，满足了其前置条件），那么后置条件将保证某些属性得到保持。
- en: The idea is to use postconditions to check and validate for everything that
    a client might need. If the method executed properly, and the postcondition validations
    pass, then any client calling that code should be able to work with the returned
    object without problems, as the contract has been fulfilled.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是使用后置条件来检查和验证客户可能需要的一切。如果方法执行正确，并且后置条件验证通过，那么调用该代码的任何客户端应该能够无问题地使用返回的对象，因为合同已经履行。
- en: Pythonic contracts
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python的合同
- en: At the time of writing this book, a PEP-316, named Programming by Contract for
    Python, is deferred. This doesn't mean that we cannot implement it in Python,
    because, as introduced at the beginning of the chapter, this is a general design
    principle.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，名为PEP-316的Python合同编程被推迟。这并不意味着我们不能在Python中实现它，因为正如在本章开头介绍的那样，这是一个通用的设计原则。
- en: Probably the best way to enforce this is by adding control mechanisms to our
    methods, functions, and classes, and if they rail raise a `RuntimeError` exception
    or `ValueError`. It's hard to devise a general rule for the correct type of exception,
    as that would pretty much depend on the application in particular. These previously
    mentioned exceptions are the most common types of exception, but if they don't
    fit accurately with the problem, creating a custom exception would be the best
    choice.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最好的执行方法是通过向我们的方法、函数和类添加控制机制，如果它们失败会引发`RuntimeError`异常或`ValueError`。很难为正确的异常类型制定一般规则，因为这在很大程度上取决于特定的应用。前面提到的这些异常是最常见的异常类型，但如果它们不能准确地解决问题，创建自定义异常将是最佳选择。
- en: We would also like to keep the code as isolated as possible. That is, the code
    for the preconditions in one part, the one for the postconditions in another,
    and the core of the function separated. We could achieve this separation by creating
    smaller functions, but in some cases implementing a decorator would be an interesting
    alternative.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望尽可能地保持代码的隔离。也就是说，前置条件的代码在一个部分，后置条件的代码在另一个部分，函数的核心分开。我们可以通过创建更小的函数来实现这种分离，但在某些情况下，实现装饰器可能是一个有趣的选择。
- en: Design by contract – conclusions
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按合同设计-结论
- en: The main value of this design principle is to effectively identify where the
    problem is. By defining a contract, when something fails at runtime it will be
    clear what part of the code is broken, and what broke the contract.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计原则的主要价值在于有效地确定问题所在。通过定义合同，当运行时出现问题时，清楚地知道代码的哪一部分出了问题，以及是什么破坏了合同。
- en: As a result of following this principle, the code will be more robust. Each
    component is enforcing its own constraints and maintaining some invariants, and
    the program can be proven correct as long as these invariants are preserved.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这一原则的结果是代码将更加健壮。每个组件都在强制执行自己的约束并保持一些不变量，只要这些不变量得到保持，程序就可以被证明是正确的。
- en: It also serves the purpose of clarifying the structure of the program better.
    Instead of trying to run ad hoc validations, or trying to surmount all possible
    failure scenarios, the contracts explicitly specify what each function or method
    expects to work properly, and what is expected from them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有助于更好地澄清程序的结构。与其试图运行临时验证，或者试图克服所有可能的失败场景，合同明确指定了每个函数或方法期望正常工作的内容，以及对它们的期望。
- en: Of course, following these principles also adds extra work, because we are not
    just programming the core logic of our main application, but also the contracts.
    In addition, we might also want to consider adding unit tests for these contracts
    as well. However, the quality gained by this approach pays off in the long run;
    hence, it is a good idea to implement this principle for critical components of
    the application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，遵循这些原则也会增加额外的工作，因为我们不仅仅是在编写主要应用程序的核心逻辑，还有合同。此外，我们可能还希望考虑为这些合同添加单元测试。然而，这种方法所获得的质量在长远来看是值得的；因此，对应用程序的关键组件实施这一原则是一个好主意。
- en: Nonetheless, for this method to be effective, we should carefully think about
    what are we willing to validate, and this has to be a meaningful value. For example,
    it would not make much sense to define contracts that only check for the correct
    data types of the parameters provided to a function. Many programmers would argue
    that this would be like trying to make Python a statically-typed language. Regardless
    of this, tools such as Mypy, in combination with the use of annotations, would
    serve this purpose much better and with less effort. With that in mind, design
    contracts so that there is actually value on them, checking, for example, the
    properties of the objects being passed and returned, the conditions they have
    to hold, and so on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了使这种方法有效，我们应该仔细考虑我们愿意验证什么，这必须是一个有意义的值。例如，定义仅检查传递给函数的参数的正确数据类型的合同并没有太多意义。许多程序员会认为这就像试图使Python成为一种静态类型的语言。不管怎样，工具如Mypy，结合注释的使用，会更好地实现这一目的，而且付出的努力更少。考虑到这一点，设计合同以便它们确实有价值，例如检查传递和返回的对象的属性，它们必须满足的条件等等。
- en: Defensive programming
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防御性编程
- en: Defensive programming follows a somewhat different approach than DbC; instead
    of stating all conditions that must be held in a contract, that if unmet will
    raise an exception and make the program fail, this is more about making all parts
    of the code (objects, functions, or methods) able to protect themselves against
    invalid inputs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 防御性编程与DbC有些不同的方法；它不是陈述必须在合同中保持的所有条件，如果不满足将引发异常并使程序失败，而是更多地使代码的所有部分（对象、函数或方法）能够保护自己免受无效输入的影响。
- en: Defensive programming is a technique that has several aspects, and it is particularly
    useful if it is combined with other design principles (this means that the fact
    that it follows a different philosophy than DbC does not mean that it is a case
    of either one or the other—it could mean that they might complement each other).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 防御性编程是一种具有多个方面的技术，如果与其他设计原则结合使用，尤其有用（这意味着它遵循与DbC不同的哲学，并不意味着要么是这种情况，要么是那种情况——它可能意味着它们可以互补）。
- en: The main ideas on the subject of defensive programming are how to handle errors
    for scenarios that we might expect to occur, and how to deal with errors that
    should never occur (when impossible conditions happen). The former will fall into
    error handling procedures, while the latter will be the case for assertions, both
    topics we will be exploring in the following sections.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 防御性编程的主要思想是如何处理我们可能预期发生的情况的错误，以及如何处理不应该发生的错误（当发生不可能的情况时）。前者将属于错误处理程序，而后者将是断言的情况，这两个主题我们将在接下来的部分中探讨。
- en: Error handling
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: In our programs, we resort to error handling procedures for situations that
    we anticipate as prone to cause errors. This is usually the case for data input.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，我们会采用错误处理程序来处理我们预期会导致错误的情况。这通常是数据输入的情况。
- en: The idea behind error handling is to gracefully respond to these expected errors
    in an attempt to either continue our program execution or decide to fail if the
    error turns out to be insurmountable.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理的理念是优雅地响应这些预期的错误，试图要么继续我们的程序执行，要么决定失败，如果错误被证明是无法克服的。
- en: 'There are different approaches by which we can handle errors on our programs,
    but not all of them are always applicable. Some of these approaches are as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过不同的方法处理程序中的错误，但并非所有方法都总是适用。以下是其中一些方法：
- en: Value substitution
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值替换
- en: Error logging
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误日志记录
- en: Exception handling
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: Value substitution
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值替换
- en: In some scenarios, when there is an error and there is a risk of the software
    producing an incorrect value or failing entirely, we might be able to replace
    the result with another, safer value. We call this value substitution, since we
    are in fact replacing the actual erroneous result for a value that is to be considered
    non-disruptive (it could be a default, a well-known constant, a sentinel value,
    or simply something that does not affect the result at all, like returning zero
    in a case where the result is intended to be applied to a sum).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，当出现错误并且软件有可能产生不正确的值或完全失败时，我们可能能够用另一个更安全的值替换结果。我们称这种值替换，因为我们实际上是用一个被认为是非破坏性的值（可以是默认值、众所周知的常量、哨兵值，或者简单地是根本不影响结果的东西，比如在结果意图应用于求和的情况下返回零）来替换实际错误的结果。
- en: Value substitution is not always possible, however. This strategy has to be
    carefully chosen for cases where the substituted value is actually a safe option.
    Making this decision is a trade-off between robustness and correctness. A software
    program is robust when it does not fail, even in the presence of an erroneous
    scenario. But this is not correct either.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非总是可能进行值替换。这种策略必须在替换值实际上是安全选项的情况下谨慎选择。做出这个决定是在健壮性和正确性之间进行权衡。当软件程序在错误场景中甚至不会失败时，它是健壮的。但这也不正确。
- en: This might not be acceptable for some kinds of software. If the application
    is critical, or the data being handled is too sensitive, this is not an option,
    since we cannot afford to provide users (or other parts of the application) with
    erroneous results. In these cases, we opt for correctness, rather than let the
    program explode when yielding the wrong results.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些类型的软件来说，这可能是不可接受的。如果应用程序很关键，或者正在处理的数据太敏感，这不是一个选择，因为我们不能提供给用户（或应用程序的其他部分）错误的结果。在这些情况下，我们选择正确性，而不是在产生错误结果时让程序崩溃。
- en: 'A slightly different, and safer, version of this decision is to use default
    values for data that is not provided. This can be the case for parts of the code
    that can work with a default behavior, for example, default values for environment
    variables that are not set, for missing entries in configuration files, or for
    parameters of functions. We can find examples of Python supporting this throughout
    different methods of its API, for example, dictionaries have a `get` method, whose
    (optional) second parameter allows you to indicate a default value:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个决定的一个稍微不同、更安全的版本是对未提供的数据使用默认值。这可能是代码的一部分可以使用默认行为的情况，例如，未设置的环境变量的默认值，配置文件中缺少的条目，或者函数的参数。我们可以在Python的API的不同方法中找到支持这一点的例子，例如，字典有一个`get`方法，它的（可选的）第二个参数允许您指定一个默认值：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Environment variables have a similar API:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量具有类似的API：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In both previous examples, if the second parameter is not provided, `None`
    will be returned, because it''s the default value those functions are defined
    with. We can also define default values for the parameters of our own functions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的两个例子中，如果未提供第二个参数，将返回`None`，因为这是这些函数定义的默认值。我们也可以为我们自己函数的参数定义默认值：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In general, replacing missing parameters with default values is acceptable,
    but substituting erroneous data with legal close values is more dangerous and
    can mask some errors. Take this criterion into consideration when deciding on
    this approach.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，用默认值替换缺失的参数是可以接受的，但用合法的接近值替换错误数据更加危险，可能会掩盖一些错误。在决定采用这种方法时，要考虑这个标准。
- en: Exception handling
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: In the presence of incorrect or missing input data, sometimes it is possible
    to correct the situation with some examples such as the ones mentioned in the
    previous section. In other cases, however, it is better to stop the program from
    continuing to run with the wrong data than to leave it computing under erroneous
    assumptions. In those cases, failing and notifying the caller that something is
    wrong is a good approach, and this is the case for a precondition that was violated,
    as we saw in DbC.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在存在不正确或缺失的输入数据的情况下，有时可以通过一些在前一节中提到的示例来纠正情况。然而，在其他情况下，最好是阻止程序继续以错误的数据运行，而不是让它在错误的假设下进行计算。在这些情况下，失败并通知调用者出现问题是一个很好的方法，这就是我们在DbC中看到的违反的前提条件的情况。
- en: Nonetheless, erroneous input data is not the only possible way in which a function
    can go wrong. After all, functions are not just about passing data around; they
    also have side-effects and connect to external components.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，错误的输入数据并不是函数出错的唯一可能方式。毕竟，函数不仅仅是传递数据；它们还具有副作用并连接到外部组件。
- en: It could be possible that a fault in a function call is due to a problem on
    one of these external components, and not in our function itself. If that is the
    case, our function should communicate this properly. This will make it easier
    to debug. The function should clearly, and unambiguously notify the rest of the
    application about errors that cannot be ignored so that they can be addressed
    accordingly.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是函数调用中的错误是由于这些外部组件中的一个问题，而不是我们函数本身。如果是这种情况，我们的函数应该适当地进行通信。这将使调试变得更容易。函数应该清楚、明确地通知应用程序的其他部分有关无法忽略的错误，以便可以相应地进行处理。
- en: The mechanism for accomplishing this is an exception. It is important to emphasize
    that this is what exceptions should be used for—clearly announcing an exceptional
    situation, not altering the flow of the program according to business logic.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的机制是异常。重要的是要强调异常应该用于清楚地宣布异常情况，而不是根据业务逻辑改变程序的流程。
- en: If the code tries to use exceptions to handle expected scenarios or business
    logic, the flow of the program will become harder to read. This will lead to a
    situation where exceptions are used as a sort of `go-to` statement, that (to make
    things worse) could span multiple levels on the call stack (up to caller functions),
    violating the encapsulation of the logic into its correct level of abstraction.
    The case could get even worse if these `except` blocks are mixing business logic
    with truly exceptional cases that the code is trying to defend against; in that
    case, it will be harder to distinguish between the core logic we have to maintain
    and errors to be handled.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码尝试使用异常来处理预期的场景或业务逻辑，程序的流程将变得更难阅读。这将导致一种情况，即异常被用作一种`go-to`语句，这可能会跨越调用堆栈的多个级别（直到调用者函数），违反了将逻辑封装到其正确抽象级别的封装。如果这些`except`块混合了业务逻辑和代码试图防御的真正异常情况，情况可能会变得更糟；在这种情况下，将更难区分我们必须维护的核心逻辑和需要处理的错误。
- en: Do not use exceptions as a `go-to` mechanism for business logic. Raise exceptions
    when there is actually something wrong with the code that callers need to be aware
    of.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将异常用作业务逻辑的“go-to”机制。只有在代码出现实际问题需要调用者知道时才引发异常。
- en: This last concept is an important one; exceptions are usually about notifying
    the caller about something that is amiss. This means that exceptions should be
    used carefully because they weaken encapsulation. The more exceptions a function
    has, the more the caller function will have to anticipate, therefore knowing about
    the function it is calling. And if a function raises too many exceptions, this
    means that is not so context-free, because every time we want to invoke it, we
    will have to keep all of its possible side-effects in mind.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的概念是一个重要的概念；异常通常是关于通知调用者有什么问题。这意味着异常应该谨慎使用，因为它们削弱了封装性。一个函数有越多的异常，调用函数就必须预期越多，因此了解它正在调用的函数。如果一个函数引发了太多的异常，这意味着它不是那么无上下文的，因为每次我们想要调用它，我们都必须牢记它可能产生的所有副作用。
- en: This can be used as a heuristic to tell when a function is not cohesive enough
    and has too many responsibilities. If it raises too many exceptions, it could
    be a sign that it has to be broken down into multiple, smaller ones.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以作为一种启发式方法，用来判断一个函数是否不够内聚，责任太多。如果它引发了太多的异常，这可能意味着它必须被拆分成多个更小的函数。
- en: Here are some recommendations that relate to exceptions in Python.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与Python中异常相关的一些建议。
- en: Handle exceptions at the right level of abstraction
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在正确的抽象级别处理异常
- en: Exceptions are also part of the principal functions that do one thing, and one
    thing only. The exception the function is handling (or raising) has to be consistent
    with the logic encapsulated on it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 异常也是主要函数的一部分，只做一件事。函数处理（或引发）的异常必须与其封装的逻辑一致。
- en: 'In this example, we can see what we mean by mixing different levels of abstractions.
    Imagine an object that acts as a transport for some data in our application. It
    connects to an external component where the data is going to be sent upon decoding.
    In the following listing, we will focus on the `deliver_event` method:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到我们所说的混合不同抽象级别是什么意思。想象一个对象，它作为我们应用程序中一些数据的传输器。它连接到一个外部组件，在那里数据将在解码后被发送。在下面的清单中，我们将专注于`deliver_event`方法：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For our analysis, let's zoom in and focus on how the `deliver_event()` method
    handles exceptions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的分析，让我们放大并关注`deliver_event()`方法如何处理异常。
- en: What does `ValueError` have to do with `ConnectionError`? Not much. By looking
    at these two highly different types of error, we can get an idea of how responsibilities
    should be divided. The `ConnectionError` should be handled inside the `connect`
    method. This will allow a clear separation of behavior. For example, if this method
    needs to support retries, that would be a way of doing it. Conversely, `ValueError`
    belongs to the `decode` method of the event. With this new implementation, this
    method does not need to catch any exception—the exceptions it was worrying about
    before are either handled by internal methods or deliberately left to be raised.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValueError`与`ConnectionError`有什么关系？不多。通过查看这两种非常不同的错误，我们可以了解责任应该如何划分。`ConnectionError`应该在`connect`方法内处理。这将允许行为的清晰分离。例如，如果这个方法需要支持重试，那将是一种方法。相反，`ValueError`属于事件的`decode`方法。通过这种新的实现，这个方法不需要捕获任何异常——它以前担心的异常要么由内部方法处理，要么故意留待抛出。'
- en: 'We should separate these fragments into different methods or functions. For
    connection management, a small function should be enough. This function will be
    in charge of trying to establish the connection, catching exceptions (should they
    occur), and logging them accordingly:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将这些片段分开成不同的方法或函数。对于连接管理，一个小函数就足够了。这个函数将负责尝试建立连接，捕获异常（如果发生），并相应地记录它们：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we will call this function in our method. As for the `ValueError` exception
    on the event, we could separate it with a new object and do composition, but for
    this limited case it would be overkill, so just moving the logic to a separate
    method would be enough. With these two considerations in place, the new version
    of the method looks much more compact and easier to read:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在我们的方法中调用这个函数。至于事件中的`ValueError`异常，我们可以用一个新对象分开它，并进行组合，但对于这个有限的情况来说，这将是过度的，所以只需将逻辑移到一个单独的方法中就足够了。有了这两个考虑，方法的新版本看起来更加简洁和易于阅读：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Do not expose tracebacks
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要暴露tracebacks
- en: This is a security consideration. When dealing with exceptions, it might be
    acceptable to let them propagate if the error is too important, and maybe even
    let the program fail if this is the decision for that particular scenario and
    correctness was favored over robustness.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个安全考虑。在处理异常时，如果错误太重要，甚至让程序失败，如果这是特定情况的决定，并且正确性优先于健壮性。
- en: When there is an exception that denotes a problem, it's important to log in
    with as much detail as possible (including the traceback information, message,
    and all we can gather) so that the issue can be corrected efficiently. At the
    same time, we want to include as much detail as possible for ourselves—we definitely
    don't want any of this becoming visible to users.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当有一个表示问题的异常时，重要的是要尽可能详细地记录（包括traceback信息、消息和我们能收集到的所有信息），以便能够有效地纠正问题。同时，我们希望为自己包含尽可能多的细节——我们绝对不希望任何这些对用户可见。
- en: In Python, tracebacks of exceptions contain very rich and useful debugging information.
    Unfortunately, this information is also very useful for attackers or malicious
    users who want to try and harm the application, not to mention that the leak would
    represent an important information disclosure, jeopardizing the intellectual property
    of your organization (parts of the code will be exposed).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，异常的回溯包含非常丰富和有用的调试信息。不幸的是，这些信息对于想要尝试损害应用程序的攻击者或恶意用户也非常有用，更不用说泄漏将代表重要的信息披露，危及您的组织的知识产权（代码的部分将被公开）。
- en: If you choose to let exceptions propagate, make sure not to disclose any sensitive
    information. Also, if you have to notify users about a problem, choose generic
    messages (such as Something went wrong, or Page not found). This is a common technique
    used in web applications that display generic informative messages when an HTTP
    error occurs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择让异常传播，请确保不要披露任何敏感信息。此外，如果必须通知用户有问题，请选择通用消息（例如出现了一些问题，或找不到页面）。这是Web应用程序中常用的技术，当发生HTTP错误时显示通用的信息性消息。
- en: Avoid empty except blocks
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免空的except块
- en: This was even referred to as the most diabolical Python anti-pattern (REAL 01).
    While it is good to anticipate and defend our programs against some errors, being
    too defensive might lead to even worse problems. In particular, the only problem
    with being too defensive is that there is an empty `except` block that silently
    passes without doing anything.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至被称为最邪恶的Python反模式（REAL 01）。虽然预期并保护我们的程序免受一些错误的影响是好的，但过于防御可能会导致更严重的问题。特别是，过于防御的唯一问题是有一个空的`except`块，它会悄悄地通过而不做任何事情。
- en: 'Python is so flexible that it allows us to write code that can be faulty and
    yet, will not raise an error, like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Python非常灵活，可以让我们编写可能有错误但不会引发错误的代码，就像这样：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The problem with this is that it will not fail, ever. Even when it should. It
    is also non-Pythonic if you remember from the zen of Python that errors should
    never pass silently.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的问题是它永远不会失败。即使应该失败也是如此。如果您还记得Python之禅，错误永远不应该悄悄地传递，这也是不符合Python风格的。
- en: If there is a true exception, this block of code will not fail, which might
    be what we wanted in the first place. But what if there is a defect? We need to
    know if there is an error in our logic to be able to correct it. Writing blocks
    such as this one will mask problems, making things harder to maintain.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有真正的异常，这段代码将不会失败，这可能是我们最初想要的。但是如果有缺陷呢？我们需要知道我们的逻辑中是否存在错误，以便进行更正。编写这样的代码块将掩盖问题，使维护变得更加困难。
- en: 'There are two alternatives:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种选择：
- en: Catch a more specific exception (not too broad, such as an `Exception`). In
    fact, some linting tools and IDEs will warn you in some cases when the code is
    handling too broad an exception.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获更具体的异常（不要太宽泛，例如`Exception`）。实际上，一些代码检查工具和集成开发环境在代码处理过于宽泛的异常时会在某些情况下发出警告。
- en: Do some actual error handling on the `except` block.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`except`块上进行一些实际的错误处理。
- en: The best thing to do would be to apply both items simultaneously.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是同时应用这两个项目。
- en: Handling a more specific exception (for example, `AttributeError` or `KeyError`)
    will make the program more maintainable because the reader will know what to expect,
    and can get an idea of the why of it. It will also leave other exceptions free
    to be raised, and if that happens, this probably means a bug, only this time it
    can be discovered.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 处理更具体的异常（例如`AttributeError`或`KeyError`）将使程序更易于维护，因为读者将知道可以预期什么，并且可以了解原因。这也将使其他异常可以自由地被引发，如果发生这种情况，这可能意味着一个错误，只是这一次可以被发现。
- en: Handling the exception itself can mean multiple things. In its simplest form,
    it could be just about logging the exception (make sure to use `logger.exception`
    or `logger.error` to provide the full context of what happened). Other alternatives
    could be to return a default value (substitution, only that in this case after
    detecting an error, not prior to causing it), or raising a different exception.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异常本身可能意味着多种情况。在其最简单的形式中，可能只是记录异常（确保使用`logger.exception`或`logger.error`提供发生的完整上下文）。其他替代方案可能是返回默认值（替换，只是在检测到错误后，而不是在引起错误之前），或引发不同的异常。
- en: If you choose to raise a different exception, to include the original exception
    that caused the problem, which leads us to the next point.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择引发不同的异常，以包括导致问题的原始异常，这将引出我们下一个要点。
- en: Include the original exception
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包括原始异常
- en: As part of our error handling logic, we might decide to raise a different one,
    and maybe even change its message. If that is the case, it is recommended to include
    the original exception that led to that.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们的错误处理逻辑的一部分，我们可能决定引发不同的异常，甚至可能更改其消息。如果是这种情况，建议包括导致该异常的原始异常。
- en: In Python 3 (PEP-3134), we can now use the `raise <e> from <original_exception>`
    syntax. When using this construction, the original traceback will be embedded
    into the new exception, and the original exception will be set in the `__cause__`
    attribute of the resulting one.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3（PEP-3134）中，我们现在可以使用`raise <e> from <original_exception>`语法。使用此结构时，原始的回溯将嵌入到新的异常中，并且原始异常将设置在生成的异常的`__cause__`属性中。
- en: 'For example, if we desire to wrap default exceptions with custom ones internally
    to our project, we could still do that while including information about the root
    exception:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们希望在项目内部使用自定义异常包装默认异常，我们仍然可以这样做，同时包含有关根异常的信息：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Always use the `raise <e> from <o>` syntax when changing the type of the exception.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改异常类型时，始终使用`raise <e> from <o>`语法。
- en: Using assertions in Python
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中使用断言
- en: Assertions are to be used for situations that should never happen, so the expression
    on the `assert` statement has to mean an impossible condition. Should this condition
    happen, it means there is a defect in the software.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 断言用于永远不应该发生的情况，因此`assert`语句中的表达式必须表示一个不可能的条件。如果发生这种情况，这意味着软件中存在缺陷。
- en: In contrast with the error handling approach, here there is (or should not be)
    a possibility of continuing the program. If such an error occurs, the program
    must stop. It makes sense to stop the program because, as commented before, we
    are in the presence of a defect, so there is no way to move forward by releasing
    a new version of the software that corrects this defect.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与错误处理方法相比，这里没有（或不应该有）继续程序的可能性。如果发生这样的错误，程序必须停止。停止程序是有道理的，因为正如前面所述，我们面临的是一个缺陷，因此无法通过发布修复此缺陷的新软件版本来继续前进。
- en: The idea of using assertions is to prevent the program from causing further
    damage if such an invalid scenario is presented. Sometimes, it is better to stop
    and let the program crash, rather than let it continue processing under the wrong
    assumptions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用断言的想法是防止程序在出现无效场景时造成进一步的损害。有时，最好是停止并让程序崩溃，而不是让它在错误的假设下继续处理。
- en: 'For this reason, assertions should not be mixed with the business logic, or
    used as control flow mechanisms for the software. The following example is a bad
    idea:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，断言不应与业务逻辑混合，也不应作为软件的控制流机制使用。以下示例是一个坏主意：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Do not catch the `AssertionError` exception.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不要捕获`AssertionError`异常。
- en: Make sure that the program terminates when an assertion fails.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 确保程序在断言失败时终止。
- en: Include a descriptive error message in the assertion statement and log the errors
    to make sure that you can properly debug and correct the problem later on.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在断言语句中包含描述性错误消息，并记录错误，以确保您可以正确调试和纠正问题。
- en: Another important reason why the previous code is a bad idea is that besides
    catching `AssertionError`, the statement in the assertion is a function call.
    Function calls can have side-effects, and they aren't always repeatable (we don't
    know if calling `condition.holds()` again will yield the same result). Moreover,
    if we stop the debugger at that line, we might not be able to conveniently see
    the result that causes the error, and, again, even if we call that function again,
    we don't know if that was the offending value.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码之所以是一个坏主意的另一个重要原因是，除了捕获`AssertionError`之外，断言中的语句是一个函数调用。函数调用可能会产生副作用，并且它们并不总是可重复的（我们不知道再次调用`condition.holds()`是否会产生相同的结果）。此外，如果我们在那一行停止调试器，我们可能无法方便地看到导致错误的结果，而且即使我们再次调用该函数，我们也不知道那是否是有问题的值。
- en: 'A better alternative requires fewer lines of code and provides more useful
    information:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的替代方案需要更少的代码行，并提供更多有用的信息：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Separation of concerns
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关注点的分离
- en: This is a design principle that is applied at multiple levels. It is not just
    about the low-level design (code), but it is also relevant at a higher level of
    abstraction, so it will come up later when we talk about architecture.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个应用在多个层次的设计原则。它不仅仅是关于低级设计（代码），而且在更高的抽象层次上也是相关的，因此当我们谈论架构时，它将在后面出现。
- en: Different responsibilities should go into different components, layers, or modules
    of the application. Each part of the program should only be responsible for a
    part of the functionality (what we call its concerns) and should know nothing
    about the rest.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的责任应该放在应用程序的不同组件、层或模块中。程序的每个部分应该只负责一部分功能（我们称之为其关注点），并且对其余部分一无所知。
- en: The goal of separating concerns in software is to enhance maintainability by
    minimizing ripple effects. A **ripple** effect means the propagation of a change
    in the software from a starting point. This could be the case of an error or exception
    triggering a chain of other exceptions, causing failures that will result in a
    defect on a remote part of the application. It can also be that we have to change
    a lot of code scattered through multiple parts of the code base, as a result of
    a simple change in a function definition.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 软件中关注点的分离旨在通过最小化连锁效应来增强可维护性。**连锁**效应意味着软件中变化的传播从一个起点开始。这可能是错误或异常触发一系列其他异常的情况，导致失败，从而导致应用程序的远程部分出现缺陷。也可能是我们不得不改变散布在代码库多个部分的大量代码，因为函数定义的简单更改的结果。
- en: Clearly, we do not want these scenarios to happen. The software has to be easy
    to change. If we have to modify or refactor some part of the code that has to
    have a minimal impact on the rest of the application, the way to achieve this
    is through proper encapsulation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不希望发生这些情况。软件必须易于更改。如果我们必须修改或重构代码的某个部分，这对应用程序的其余部分的影响应该最小化，实现这一点的方法是通过适当的封装。
- en: In a similar way, we want any potential errors to be contained so that they
    don't cause major damage.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们希望任何潜在错误都能被包含，以免造成重大损害。
- en: This concept is related to the DbC principle in the sense that each concern
    can be enforced by a contract. When a contract is violated, and an exception is
    raised as a result of such a violation, we know what part of the program has the
    failure, and what responsibilities failed to be met.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念与DbC原则相关，因为每个关注点都可以通过合同来执行。当合同被违反，并且由于这种违反而引发异常时，我们知道程序的哪一部分出现了故障，以及未能满足的责任是什么。
- en: Despite this similarity, separation of concerns goes further. We normally think
    of contracts between functions, methods, or classes, and while this also applies
    to responsibilities that have to be separated, the idea of separation of concerns
    also applies to Python modules, packages, and basically any software component.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这种相似性，关注点的分离更进一步。我们通常认为函数、方法或类之间存在合同，虽然这也适用于需要分离的责任，但关注点分离的想法也适用于Python模块、包，基本上适用于任何软件组件。
- en: Cohesion and coupling
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内聚和耦合
- en: These are important concepts for good software design.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是良好软件设计的重要概念。
- en: On the one hand, **cohesion** means that objects should have a small and well-defined
    purpose, and they should do as little as possible. It follows a similar philosophy
    as Unix commands that do only one thing and do it well. The more cohesive our
    objects are, the more useful and reusable they become, making our design better.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，内聚意味着对象应该有一个小而明确定义的目的，并且它们应该尽可能少地做事情。它遵循与Unix命令相似的哲学，即只做一件事，并且做得很好。我们的对象越内聚，它们就越有用和可重用，使我们的设计变得更好。
- en: 'On the other hand, **coupling** refers to the idea of how two or more objects
    depend on each other. This dependency poses a limitation. If two parts of the
    code (objects or methods) are too dependent on each other, they bring with them
    some undesired consequences:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，耦合指的是两个或多个对象彼此依赖的概念。这种依赖性带来了一些不希望的后果：
- en: '**No code reuse**: If one function depends too much on a particular object,
    or takes too many parameters, it''s coupled with this object, which means that
    it will be really difficult to use that function in a different context (in order
    to do so, we will have to find a suitable parameter that complies with a very
    restrictive interface)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有代码重用：如果一个函数过于依赖特定对象，或者需要太多参数，它就与这个对象耦合，这意味着在不同的上下文中使用该函数将非常困难（为了这样做，我们必须找到一个适合的参数，符合非常严格的接口）
- en: '**Ripple effects**: Changes in one of the two parts will certainly impact the
    other, as they are too close'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连锁反应：两个部分中的一个发生变化肯定会影响另一个，因为它们太接近了
- en: '**Low level of abstraction**: When two functions are so closely related, it
    is hard to see them as different concerns resolving problems at different levels
    of abstraction'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象水平低：当两个函数如此紧密相关时，很难将它们视为解决不同抽象水平问题的不同关注点
- en: 'Rule of thumb: Well-defined software will achieve high cohesion and low coupling.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 经验法则：定义良好的软件将实现高内聚和低耦合。
- en: Acronyms to live by
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生活中的缩写
- en: In this section, we will review some principles that yield some good design
    ideas. The point is to quickly relate to good software practices by acronyms that
    are easy to remember, working as a sort of mnemonic rule. If you keep these words
    in mind, you will be able to associate them with good practices more easily, and
    finding the right idea behind a particular line of code that you are looking at
    will be faster.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将回顾一些原则，这些原则产生了一些良好的设计思想。重点是通过易于记忆的缩写快速与良好的软件实践联系起来，作为一种记忆规则。如果你记住这些词，你将更容易将它们与良好的实践联系起来，并且更快地找到你正在查看的特定代码行背后的正确思想。
- en: These are by no means formal or academic definitions, but more like empirical
    ideas that emerged from years of working in the software industry. Some of them
    do appear in books, as they were coined by important authors (see the references
    to investigate them in more detail), and others have their roots probably in blog
    posts, papers, or conference talks.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绝不是正式或学术定义，而更像是从多年的软件行业工作中产生的经验性想法。其中一些出现在书籍中，因为它们是由重要的作者创造的（请参考参考文献以了解更多细节），其他可能源于博客文章、论文或会议演讲。
- en: DRY/OAOO
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DRY/OAOO
- en: The ideas of **Don't Repeat Yourself** (**DRY**) and **Once and Only Once**
    (**OAOO**) are closely related, so they were included together here. They are
    self-explanatory, you should avoid duplication at all costs.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 不要重复自己（DRY）和一次且仅一次（OAOO）的想法是密切相关的，因此它们被放在一起。它们是不言自明的，你应该尽量避免重复。
- en: Things in the code, knowledge, have to be defined only once and in a single
    place. When you have to make a change in the code, there should be only one rightful
    location to modify. Failure to do so is a sign of a poorly designed system.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的事物、知识，必须只定义一次，并且在一个地方。当你需要对代码进行更改时，应该只有一个正确的位置进行修改。否则这是一个设计不良的系统的迹象。
- en: 'Code duplication is a problem that directly impacts maintainability. It is
    very undesirable to have code duplication because of its many negative consequences:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重复是直接影响可维护性的问题。代码重复是非常不希望的，因为它有许多负面后果：
- en: '**It''s error prone**: When some logic is repeated multiple times throughout
    the code, and this needs to change, it means we depend on efficiently correcting
    all the instances with this logic, without forgetting of any of them, because
    in that case there will be a bug.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这容易出错：当某个逻辑在代码中多次重复出现，并且需要更改时，这意味着我们依赖于有效地纠正所有具有这种逻辑的实例，而不会忘记其中任何一个，因为在这种情况下将会出现错误。
- en: '**It''s expensive**: Linked to the previous point, making a change in multiple
    places takes much more time (development and testing effort) than if it was defined
    only once. This will slow the team down.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这很昂贵：与前一点相关，对多个位置进行更改需要更多的时间（开发和测试工作），而不是只定义一次。这将拖慢团队的速度。
- en: '**It''s unreliable**: Also linked to the first point, when multiple places
    need to be changed for a single change in the context, you rely on the person
    who wrote the code to remember all the instances where the modification has to
    be made. There is no single source of truth.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可靠：也与第一点相关，当一个上下文需要在多个位置进行更改时，你依赖于编写代码的人记住所有需要进行修改的实例。没有一个真正的信息来源。
- en: Duplication is often caused by ignoring (or forgetting) that code represents
    knowledge. By giving meaning to certain parts of the code, we are identifying
    and labeling that knowledge.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 重复通常是由于忽视（或遗忘）代码代表知识而引起的。通过赋予代码的某些部分意义，我们正在识别和标记这些知识。
- en: 'Let''s see what this means with an example. Imagine that, in a study center,
    students are ranked by the following criteria: 11 points per exam passed, minus
    five points per exam failed, and minus two per year in the institution. The following
    is not actual code, but just a representation of how this might be scattered in
    a real code base:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看这意味着什么。想象一下，在一个学习中心，学生根据以下标准排名：通过考试得11分，未通过考试扣5分，每在该机构学习一年扣2分。以下不是实际代码，而只是对这在真实代码库中可能如何分散的一种表示：
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice how the lambda which is in the key of the sorted function represents
    some valid knowledge from the domain problem, yet it doesn't reflect it (it doesn't
    have a name, a proper and rightful location, there is no meaning assigned to that
    code, nothing). This lack of meaning in the code leads to the duplication we find
    when the score is printed out while listing the raking.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意排序函数中的lambda表示领域问题的一些有效知识，但它并没有反映出来（它没有名称，没有适当和合适的位置，没有赋予代码任何含义）。代码中的这种缺乏含义导致了我们在列出排名时发现的重复。
- en: 'We should reflect our knowledge of our domain problem in our code, and our
    code will then be less likely to suffer from duplication and will be easier to
    understand:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在我们的代码中反映我们对领域问题的了解，这样我们的代码就不太可能遭受重复，并且更容易理解。
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A fair disclaimer: this is just an analysis of one of the traits of code duplication.
    In reality, there are more cases, types, and taxonomies of code duplication, entire
    chapters could be dedicated to this topic, but here we focus on one particular
    aspect to make the idea behind the acronym clear.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 公平的免责声明：这只是对代码重复的一个特征进行分析。实际上，代码重复有更多的情况、类型和分类，整个章节都可以专门讨论这个主题，但在这里我们专注于一个特定的方面，以使首字母缩略词背后的思想清晰明了。
- en: 'In this example, we have taken what is probably the simplest approach to eliminating
    duplication: creating a function. Depending on the case, the best solution would
    be different. In some cases, there might be an entirely new object that has to
    be created (maybe an entire abstraction was missing). In other cases, we can eliminate
    duplication with a context manager. Iterators or generators (described in [Chapter
    7](32503c77-5ff2-4d35-af0e-8d9300cfa357.xhtml), *Using Generators*) could also
    help to avoid repetition in the code, and decorators (explained in [Chapter 5](f5d9c7e4-4092-48de-a22c-564df482b021.xhtml), *Using
    Decorators to Improve Our Code), *will also help.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们采取了可能是消除重复最简单的方法：创建一个函数。根据情况，最好的解决方案可能是不同的。在某些情况下，可能需要创建一个全新的对象（也许整个抽象缺失）。在其他情况下，我们可以使用上下文管理器消除重复。迭代器或生成器（在[第7章](32503c77-5ff2-4d35-af0e-8d9300cfa357.xhtml)中描述，*使用生成器*）也可以帮助避免代码中的重复，装饰器（在[第5章](f5d9c7e4-4092-48de-a22c-564df482b021.xhtml)中解释，*使用装饰器改进我们的代码*）也会有所帮助。
- en: Unfortunately, there is no general rule or pattern to tell you which of the
    features of Python are the most suitable to address code duplication, but hopefully,
    after seeing the examples in this book, and how the elements of Python are used,
    the reader will be able to develop his/her own intuition.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有一般规则或模式可以告诉你Python的哪些特性最适合解决代码重复的问题，但希望在看到本书中的例子以及Python元素的使用后，读者将能够发展自己的直觉。
- en: YAGNI
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAGNI
- en: '**YAGNI** (short for **You Ain''t Gonna Need It**) is an idea you might want
    to keep in mind very often when writing a solution if you do not want to over-engineer
    it.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**YAGNI**（**You Ain''t Gonna Need It**的缩写）是一个想法，当你写解决方案时，如果你不想过度设计，你可能经常要记住这个想法。'
- en: We want to be able to easily modify our programs, so we want to make them future-proof.
    In line with that, many developers think that they have to anticipate all future
    requirements and create solutions that are very complex, and so create abstractions
    that are hard to read, maintain, and understand. Sometime later, it turns out
    that those anticipated requirements do not show up, or they do but in a different
    way (surprise!), and the original code that was supposed to handle precisely that
    does not work. The problem is that now it is even harder to refactor and extend
    our programs. What happened was that the original solution did not handle the
    original requirements correctly, and neither do the current ones, simply because
    it is the wrong abstraction.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够轻松修改我们的程序，所以我们希望使它们具有未来的可扩展性。与此一致，许多开发人员认为他们必须预测所有未来的需求，并创建非常复杂的解决方案，因此创建了难以阅读、维护和理解的抽象。后来，事实证明那些预期的需求没有出现，或者以不同的方式出现（惊喜！），原来应该精确处理的原始代码也无法工作。问题是，现在更难重构和扩展我们的程序。发生的是，原始解决方案没有正确处理原始需求，当前的需求也没有，只是因为它是错误的抽象。
- en: Having maintainable software is not about anticipating future requirements (do
    not do futurology!). It is about writing software that only addresses current
    requirements in such a way that it will be possible (and easy) to change later
    on. In other words, when designing, make sure that your decisions don't tie you
    down, and that you will be able to keep on building, but do not build more than
    what's necessary.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有可维护的软件并不是关于预测未来的需求（不要进行未来学！）。它是关于编写只以一种可能（和容易）后续更改的方式来满足当前需求的软件。换句话说，在设计时，确保你的决定不会束缚你，你将能够继续构建，但不要构建比必要的更多。
- en: KIS
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: KIS
- en: '**KIS **(stands for **Keep It Simple**) relates very much to the previous point.
    When you are designing a software component, avoid over-engineering it; ask yourself
    if your solution is the minimal one that fits the problem.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**KIS**（**Keep It Simple**的缩写）与前面的观点非常相关。当你设计软件组件时，避免过度设计；问问自己你的解决方案是否是最小的，适合问题的解决方案。'
- en: 'Implement minimal functionality that correctly solves the problem and does
    not complicate your solution more than is necessary. Remember: the simpler the
    design, the more maintainable it will be.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 实现最小功能，正确解决问题，不要使解决方案变得比必要的更复杂。记住：设计越简单，维护性就越强。
- en: This design principle is an idea we will want to keep in mind at all levels
    of abstraction, whether we are thinking of a high-level design, or addressing
    a particular line of code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计原则是一个我们在所有抽象层面都要记住的想法，无论是高层设计还是处理特定行代码。
- en: At a high-level, think on the components we are creating. Do we really need
    all of them? Does this module actually require being utterly extensible right
    now? Emphasize the last part—maybe we want to make that component extensible,
    but now is not the right time, or it is not appropriate to do so because we still
    do not have enough information to create the proper abstractions, and trying to
    come up with generic interfaces at this point will only lead to even worse problems.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，考虑我们正在创建的组件。我们真的需要它们吗？这个模块现在实际上需要完全可扩展吗？强调最后一部分——也许我们想要使该组件可扩展，但现在不是正确的时间，或者现在还不适合这样做，因为我们仍然没有足够的信息来创建适当的抽象，试图在这一点上提出通用接口只会导致更糟糕的问题。
- en: In terms of code, keeping it simple usually means using the smallest data structure
    that fits the problem. You will most likely find it in the standard library.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，保持简单通常意味着使用最适合问题的最小数据结构。您很可能会在标准库中找到它。
- en: 'Sometimes, we might over-complicate code, creating more functions or methods
    than what''s necessary. The following class creates a namespace from a set of
    keyword arguments that have been provided, but it has a rather complicated code
    interface:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能会过于复杂化代码，创建比必要更多的函数或方法。以下类从一组提供的关键字参数创建一个命名空间，但它的代码接口相当复杂：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Having an extra class method for initializing the object doesn''t seem really
    necessary. Then, the iteration, and the call to `setattr` inside it, make things
    even more strange, and the interface that is presented to the user is not very
    clear:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 添加额外的类方法来初始化对象似乎并不是真正必要的。然后，迭代和其中的`setattr`调用使事情变得更加奇怪，向用户呈现的接口也不是很清晰：
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The user has to know of the existence of this other method, which is not convenient.
    It would be better to keep it simple, and just initialize the object as we initialize
    any other object in Python (after all, there is a method for that) with the `__init__` method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 用户必须知道存在这种方法，这并不方便。保持简单，就像初始化Python中的任何其他对象一样（毕竟，有一个方法可以做到）使用`__init__`方法会更好：
- en: '[PRE15]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Remember the zen of Python: simple is better than complex.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 记住Python的禅意：简单胜于复杂。
- en: EAFP/LBYL
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EAFP/LBYL
- en: '**EAFP** (stands for **Easier to Ask Forgiveness than Permission**), while **LBYL** (stands
    for **Look Before You Leap**).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**EAFP**（代表**宁愿请求宽恕，而不是事先征得许可**），而**LBYL**（代表**先看后跳**）。'
- en: The idea of EAFP is that we write our code so that it performs an action directly,
    and then we take care of the consequences later in case it doesn't work. Typically,
    this means try running some code, expecting it to work, but catching an exception
    if it doesn't, and then handling the corrective code on the except block.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: EAFP的理念是，我们编写代码以便直接执行操作，然后在以后处理后果，以防它不起作用。通常，这意味着尝试运行一些代码，期望它能够工作，但如果它不起作用，则捕获异常，然后在except块中处理纠正代码。
- en: 'This is the opposite of **LBYL**. As its name says, in the look before you
    leap approach, we first check what we are about to use. For example, we might
    want to check if a file is available before trying to operate with it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**LBYL**的相反。正如其名称所示，在先看后跳的方法中，我们首先检查我们将要使用的内容。例如，我们可能希望在尝试操作文件之前检查文件是否可用：
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This might be good for other programming languages, but it is not the Pythonic
    way of writing code. Python was built with ideas such as EAFP, and it encourages
    you to follow them (remember, explicit is better than implicit). This code would
    instead be rewritten like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能对其他编程语言有好处，但这不是编写代码的Pythonic方式。Python是建立在EAFP等思想上的，并鼓励您遵循它们（记住，显式胜于隐式）。这段代码将被重写如下：
- en: '[PRE17]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Prefer EAFP over LBYL.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 更喜欢EAFP而不是LBYL。
- en: Composition and inheritance
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合和继承
- en: In object-oriented software design, there are often discussions as to how to
    address some problems by using the main ideas of the paradigm (polymorphism, inheritance,
    and encapsulation).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的软件设计中，通常会讨论如何使用该范式的主要思想（多态性、继承和封装）来解决一些问题。
- en: Probably the most commonly used of these ideas is inheritance—developers often
    start by creating a class hierarchy with the classes they are going to need and
    decide the methods each one should implement.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些想法中最常用的可能是继承——开发人员通常首先创建一个类层次结构，其中包含他们将需要的类，并决定每个类应该实现哪些方法。
- en: While inheritance is a powerful concept, it does come with its perils. The main
    one is that every time we extend a base class, we are creating a new one that
    is tightly coupled with the parent. As we have already discussed, coupling is
    one of the things we want to reduce to a minimum when designing software.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然继承是一个强大的概念，但它也有其危险。主要的危险是，每次我们扩展一个基类，我们都会创建一个与父类紧密耦合的新类。正如我们已经讨论过的，耦合是我们在设计软件时要尽量减少的事情之一。
- en: One of the main uses developers relate inheritance with is code reuse. While
    we should always embrace code reuse, it is not a good idea to force our design
    to use inheritance to reuse code just because we get the methods from the parent
    class for free. The proper way to reuse code is to have highly cohesive objects
    that can be easily composed and that could work on multiple contexts.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员将继承与代码重用联系在一起的主要用途之一。虽然我们应该始终支持代码重用，但强制设计使用继承来重用代码并不是一个好主意，只是因为我们可以免费从父类获取方法。重用代码的正确方法是拥有高度内聚的对象，这些对象可以很容易地组合，并且可以在多个上下文中工作。
- en: When inheritance is a good decision
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当继承是一个好决定时
- en: We have to be careful when creating a derived class, because this is a double-edged
    sword—on the one hand, it has the advantage that we get all the code of the methods
    from the parent class for free, but on the other hand, we are carrying all of
    them to a new class, meaning that we might be placing too much functionality in
    a new definition.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建派生类时，我们必须小心，因为这是一把双刃剑——一方面，它的优势是我们可以免费获得父类方法的所有代码，但另一方面，我们将所有这些代码都放入一个新的定义中，这意味着我们可能在新定义中放入了太多的功能。
- en: 'When creating a new subclass, we have to think if it is actually going to use
    all of the methods it has just inherited, as a heuristic to see if the class is
    correctly defined. If instead, we find out that we do not need most of the methods,
    and have to override or replace them, this is a design mistake that could be caused
    by several reasons:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一个新的子类时，我们必须考虑它是否实际上会使用它刚刚继承的所有方法，这是一个判断类是否正确定义的启发法。如果相反，我们发现我们不需要大多数方法，并且必须重写或替换它们，这是一个设计错误，可能由多种原因引起：
- en: The superclass is vaguely defined and contains too much responsibility, instead
    of a well-defined interface
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超类定义模糊，并包含太多责任，而不是一个明确定义的接口
- en: The subclass is not a proper specialization of the superclass it is trying to
    extend
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类不是它试图扩展的超类的适当专门化
- en: A good case for using inheritance is the type of situation when you have a class
    that defines certain components with its behavior that are defined by the interface
    of this class (its public methods and attributes), and then you need to specialize
    this class in order to create objects that do the same but with something else
    added, or with some particular parts of its behavior changed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承的一个很好的情况是，当你有一个类，它定义了某些组件及其行为，这些行为由这个类的接口（公共方法和属性）定义，然后你需要专门化这个类，以创建做同样事情但添加了其他东西，或者改变了一些特定部分行为的对象。
- en: You can find examples of good uses of inheritance in the Python standard library
    itself. For example, in the `http.server` package ([https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler](https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler)),
    we can find a base class such as `BaseHTTPRequestHandler`, and subclasses such
    as `SimpleHTTPRequestHandler` that extend this one by adding or changing part
    of its base interface.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python标准库中，你可以找到继承的良好用例。例如，在`http.server`包中（[https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler](https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler)），我们可以找到一个名为`BaseHTTPRequestHandler`的基类，以及像`SimpleHTTPRequestHandler`这样的子类，它们通过添加或更改其基本接口来扩展这个基类。
- en: Speaking of interface definition, this is another good use for inheritance.
    When we want to enforce the interface of some objects, we can create an abstract
    base class that does not implement the behavior itself, but instead just defines
    the interface—every class that extends this one will have to implement these to
    be a proper subtype.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到接口定义，这是继承的另一个很好的用途。当我们想要强制一些对象的接口时，我们可以创建一个抽象基类，它本身不实现行为，而是只定义接口——每个扩展这个类的类都必须实现这些接口才能成为一个合适的子类型。
- en: Finally, another good case for inheritance is exceptions. We can see that the
    standard exception in Python derives from `Exception`. This is what allows you
    to have a generic clause such as `except Exception:`, which will catch every possible
    error. The important point is the conceptual one, they are classes derived from `Exception`
    because they are more specific exceptions. This also works in well-known libraries
    such as `requests`, for instance, in which an `HTTPError` is `RequestException`,
    which in turn is an `IOError`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，继承的另一个很好的用例是异常。我们可以看到Python中的标准异常派生自`Exception`。这就是允许你有一个通用的子句，比如`except
    Exception:`，它将捕获每一个可能的错误。重要的一点是概念上的，它们是从`Exception`派生的类，因为它们是更具体的异常。这也适用于知名的库，比如`requests`，其中`HTTPError`是`RequestException`，而`RequestException`又是`IOError`。
- en: Anti-patterns for inheritance
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承的反模式
- en: If the previous section had to be summarized into a single word, it would be specialization*. *The
    correct use for inheritance is to specialize objects and create more detailed
    abstractions starting from base ones.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的部分必须总结成一个单词，那就是专门化。继承的正确用法是专门化对象，并从基本对象开始创建更详细的抽象。
- en: The parent (or base) class is part of the public definition of the new derived
    class. This is because the methods that are inherited will be part of the interface
    of this new class. For this reason, when we read the public methods of a class,
    they have to be consistent with what the parent class defines.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 父类（或基类）是新派生类的公共定义的一部分。这是因为继承的方法将成为这个新类的接口的一部分。因此，当我们阅读一个类的公共方法时，它们必须与父类定义的一致。
- en: For example, if we see that a class derived from `BaseHTTPRequestHandler` implements
    a method named `handle()`, it would make sense because it is overriding one of
    the parents. If it had any other method whose name relates to an action that has
    to do with an HTTP request, then we could also think that is correctly placed
    (but we would not think that if we found something called `process_purchase()` on
    that class).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们看到一个从`BaseHTTPRequestHandler`派生的类实现了一个名为`handle()`的方法，这是有意义的，因为它是覆盖父类的一个方法。如果它有任何其他方法，其名称与与HTTP请求相关的操作有关，那么我们也可以认为它被正确放置（但如果我们在该类中找到名为`process_purchase()`的内容，我们就不会这样认为）。
- en: The previous illustration might seem obvious, but it is something that happens
    very often, especially when developers try to use inheritance with the sole goal
    of reusing code. In the next example, we will see a typical situation that represents
    a common anti-pattern in Python—there is a domain problem that has to be represented,
    and a suitable data structure is devised for that problem, but instead of creating
    an object that uses such a data structure, the object becomes the data structure
    itself.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子可能看起来很明显，但这种情况经常发生，特别是当开发人员试图使用继承来重用代码时。在下一个例子中，我们将看到一个典型的情况，代表了Python中的一个常见反模式——需要表示一个领域问题，并为该问题设计一个合适的数据结构，但是不是创建一个使用这样的数据结构的对象，而是对象本身成为数据结构。
- en: Let's see these problems more concretely through an example. Imagine we have
    a system for managing insurance, with a module in charge of applying policies
    to different clients. We need to keep in memory a set of customers that are being
    processed at the time in order to apply those changes before further processing
    or persistence. The basic operations we need are to store a new customer with
    its records as satellite data, apply a change on a policy, or edit some of the
    data, just to name a few. We also need to support a batch operation, that is,
    when something on the policy itself changes (the one this module is currently
    processing), we have to apply these changes overall to customers on the current
    transaction.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子更具体地看看这些问题。假设我们有一个管理保险的系统，其中一个模块负责将策略应用于不同的客户。我们需要在内存中保存一组正在处理的客户，以便在进一步处理或持久化之前应用这些更改。我们需要的基本操作是存储一个新客户及其记录作为卫星数据，对策略进行更改，或编辑一些数据，仅举几例。我们还需要支持批量操作，也就是说，当策略本身发生变化（这个模块当前正在处理的策略），我们必须将这些更改应用到当前交易中的所有客户。
- en: 'Thinking in terms of the data structure we need, we realize that accessing
    the record for a particular customer in constant time is a nice trait. Therefore,
    something like `policy_transaction[customer_id]` looks like a nice interface.
    From this, we might think that a subscriptable object is a good idea, and further
    on, we might get carried away into thinking that the object we need is a dictionary:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们需要的数据结构的角度来思考，我们意识到以恒定时间访问特定客户的记录是一个很好的特性。因此，像`policy_transaction[customer_id]`这样的接口看起来很不错。从这里，我们可能会认为可订阅的对象是一个好主意，进一步地，我们可能会陷入认为我们需要的对象是一个字典：
- en: '[PRE18]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With this code, we can get information about a policy for a customer by its
    identifier:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们可以通过其标识符获取有关客户的策略的信息：
- en: '[PRE19]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Sure, we achieved the interface we wanted in the first place, but at what cost?
    Now, this class has a lot of extra behavior from carrying out methods that weren''t
    necessary:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们在第一次实现中实现了我们想要的接口，但是代价是什么？现在，这个类有了很多额外的行为，执行了不必要的方法：
- en: '[PRE20]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are (at least) two major problems with this design. On the one hand, the
    hierarchy is wrong. Creating a new class from a base one conceptually means that
    it's a more specific version of the class it's extending (hence the name). How
    is it that a `TransactionalPolicy` is a dictionary? Does this make sense? Remember,
    this is part of the public interface of the object, so users will see this class,
    their hierarchy, and will notice such an odd specialization, as well as its public
    methods.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计至少存在两个主要问题。一方面，层次结构是错误的。从基类创建一个新类在概念上意味着它是类的更具体的版本（因此得名）。`TransactionalPolicy`怎么会是一个字典呢？这有意义吗？请记住，这是对象的公共接口的一部分，所以用户会看到这个类，它们的层次结构，并且会注意到这样一个奇怪的特化，以及它的公共方法。
- en: This leads us to the second problem—coupling. The interface of the transactional
    policy now includes all methods from a dictionary. Does a transactional policy
    really need methods such as `pop()` or `items()`? However, there they are. They
    are also public, so any user of this interface is entitled to call them, with
    whatever undesired side-effect they may carry. More on this point—we don't really
    gain much by extending a dictionary. The only method it actually needs to update
    for all customers affected by a change in the current policy (`change_in_policy()`)
    is not on the base class, so we will have to define it ourselves either way.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们来到第二个问题——耦合。交易策略的接口现在包括了字典的所有方法。交易策略真的需要`pop()`或`items()`这样的方法吗？然而，它们在那里。它们也是公共的，因此任何使用此接口的用户都有权调用它们，无论它们可能带来什么不希望的副作用。更进一步——通过扩展字典，我们并没有真正获得太多好处。它实际上需要更新的唯一方法是当前策略变化对所有受影响的客户进行更新（`change_in_policy()`），而这个方法不在基类中，因此我们无论如何都必须自己定义它。
- en: This is a problem of mixing implementation objects with domain objects. A dictionary
    is an implementation object, a data structure, suitable for certain kinds of operation,
    and with a trade-off like all data structures. A transactional policy should represent
    something in the domain problem, an entity that is part of the problem we are
    trying to solve.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将实现对象与领域对象混合的问题。字典是一个实现对象，一个数据结构，适用于某些操作，并且像所有数据结构一样具有权衡。交易策略应该代表领域问题中的某个实体，这是我们试图解决的问题的一部分。
- en: Hierarchies like this one are incorrect, and just because we get a few magic
    methods from a base class (to make the object subscriptable by extending a dictionary)
    is not reason enough to create such an extension. Implementation classes should
    be extending solely when creating other, more specific, implementation classes.
    In other words, extend a dictionary if you want to create another (more specific,
    or slightly modified) dictionary. The same rule applies to classes of the domain
    problem.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的层次结构是不正确的，仅仅因为我们从基类获得了一些魔术方法（通过扩展字典使对象可订阅）并不足以创建这样的扩展。实现类应该仅在创建其他更具体的实现类时才进行扩展。换句话说，如果要创建另一个（更具体或稍微修改的）字典，才应该扩展字典。相同的规则适用于领域问题的类。
- en: 'The correct solution here is to use composition. `TransactionalPolicy` is not
    a dictionary—it uses a dictionary. It should store a dictionary in a private attribute,
    and implement `__getitem__()` by proxying from that dictionary and then only implementing
    the rest of the public method it requires:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的正确解决方案是使用组合。`TransactionalPolicy`不是一个字典——它使用一个字典。它应该在一个私有属性中存储一个字典，并通过代理从该字典实现`__getitem__()`，然后只实现它所需的其余公共方法：
- en: '[PRE21]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This way is not only conceptually correct, but also more extensible. If the
    underlying data structure (which, for now, is a dictionary) is changed in the
    future, callers of this object will not be affected, so long as the interface
    is maintained. This reduces coupling, minimizes ripple effects, allows for better
    refactoring (unit tests ought not to be changed), and makes the code more maintainable.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式不仅在概念上是正确的，而且更具扩展性。如果底层数据结构（目前是字典）在将来发生变化，只要保持接口不变，对象的调用者就不会受到影响。这减少了耦合，最小化了涟漪效应，允许更好的重构（单元测试不应该被改变），并使代码更易于维护。
- en: Multiple inheritance in Python
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的多重继承
- en: Python supports multiple inheritance. As inheritance, when improperly used,
    leads to design problems, you could also expect that multiple inheritance will
    also yield even bigger problems when it's not correctly implemented.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Python支持多重继承。继承，当使用不当时，会导致设计问题，你也可以期望多重继承在实现不正确时也会产生更大的问题。
- en: Multiple inheritance is, therefore, a double-edged sword. It can also be very
    beneficial in some cases. Just to be clear, there is nothing wrong with multiple
    inheritance—the only problem it has is that when it's not implemented correctly,
    it will multiply the problems.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，多重继承是一把双刃剑。在某些情况下，它也可能非常有益。只要清楚，多重继承并没有什么问题——它唯一的问题是，当它没有正确实现时，它会放大问题。
- en: Multiple inheritance is a perfectly valid solution when used correctly, and
    this opens up new patterns (such as the adapter pattern we discussed in [Chapter
    9](dee5b4ed-34cd-4077-a5b4-83d4853e6e56.xhtml)*, Common Design Patterns)* and
    mixins.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确使用时，多重继承是一个完全有效的解决方案，并且这为新模式（例如我们在[第9章](dee5b4ed-34cd-4077-a5b4-83d4853e6e56.xhtml)*，常见设计模式中讨论的适配器模式）和混入打开了新的可能性。
- en: One of the most powerful applications of multiple inheritance is perhaps that
    which enables the creation of mixins. Before exploring mixins, we need to understand
    how multiple inheritance works, and how methods are resolved in a complex hierarchy.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承最强大的应用之一可能是它使混入的创建成为可能。在探索混入之前，我们需要了解多重继承的工作原理，以及如何在复杂的继承结构中解析方法。
- en: Method Resolution Order (MRO)
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法解析顺序（MRO）
- en: Some people don't like multiple inheritance because of the constraints it has
    in other programming languages, for instance, the so-called diamond problem. When
    a class extends from two or more, and all of those classes also extend from other
    base classes, the bottom ones will have multiple ways to resolve the methods coming
    from the top-level classes. The question is, which of these implementations is
    used?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人不喜欢多重继承，因为它在其他编程语言中有一些限制，例如所谓的菱形问题。当一个类从两个或更多类继承，并且所有这些类也从其他基类继承时，底层类将有多种方法来解析来自顶层类的方法。问题是，哪个实现会被使用？
- en: Consider the following diagram, which has a structure with multiple inheritance.
    The top-level class has a class attribute and implements the `__str__` method.
    Think of any of the concrete classes, for example, `ConcreteModuleA12`—it extends
    from `BaseModule1` and `BaseModule2`, and each one of them will take the implementation
    of `__str__` from `BaseModule`. Which of these two methods is going to be the
    one for `ConcreteModuleA12`?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下具有多重继承结构的图表。顶层类具有一个类属性并实现`__str__`方法。想象任何具体类，例如`ConcreteModuleA12`——它从`BaseModule1`和`BaseModule2`扩展，并且它们中的每一个都将从`BaseModule`中获取`__str__`的实现。这两种方法中的哪一个将成为`ConcreteModuleA12`的方法？
- en: '![](assets/7ff9f78e-eb12-431a-a8fb-307882151e49.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7ff9f78e-eb12-431a-a8fb-307882151e49.png)'
- en: 'With the value of the class attribute, this will become evident:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有了类属性的值，这将变得明显：
- en: '[PRE22]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let''s test this to see what method is being called:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试一下调用了哪个方法：
- en: '[PRE24]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There is no collision. Python resolves this by using an algorithm called **C3
    linearization** or MRO, which defines a deterministic way in which methods are
    going to be called.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 没有冲突。Python通过使用称为**C3线性化**或MRO的算法来解决这个问题，该算法定义了方法将被调用的确定性方式。
- en: 'In fact, we can specifically ask the class for its resolution order:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以明确地询问类的解析顺序：
- en: '[PRE25]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Knowing about how the method is going to be resolved in a hierarchy can be used
    to our advantage when designing classes because we can make use of mixins.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 了解在继承结构中方法将如何解析可以在设计类时对我们有利，因为我们可以利用混入。
- en: Mixins
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混入
- en: A mixin is a base class that encapsulates some common behavior with the goal
    of reusing code. Typically, a mixin class is not useful on its own, and extending
    this class alone will certainly not work, because most of the time it depends
    on methods and properties that are defined in other classes. The idea is to use
    mixin classes along with other ones, through multiple inheritance, so that the
    methods or properties used on the mixin will be available.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 混入是一个封装了一些常见行为的基类，其目标是重用代码。通常，混入类本身并不实用，仅扩展这个类肯定不会起作用，因为大多数情况下它依赖于其他类中定义的方法和属性。想法是通过多重继承将混入类与其他类一起使用，以便混入中使用的方法或属性可用。
- en: 'Imagine we have a simple parser that takes a string and provides iteration
    over it by its values separated by hyphens (-):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们有一个简单的解析器，它接受一个字符串，并通过破折号(-)分隔的值提供迭代：
- en: '[PRE26]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is quite straightforward:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常直观：
- en: '[PRE27]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'But now we want the values to be sent in upper-case, without altering the base
    class. For this simple example, we could just create a new class, but imagine
    that a lot of classes are already extending from `BaseTokenizer`, and we don''t
    want to replace all of them. We can mix a new class into the hierarchy that handles
    this transformation:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们希望将值发送为大写，而不改变基类。对于这个简单的例子，我们可以创建一个新类，但想象一下，许多类已经从`BaseTokenizer`扩展了，我们不想替换所有这些类。我们可以将一个新类混合到处理这种转换的层次结构中：
- en: '[PRE28]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The new `Tokenizer` class is really simple. It doesn't need any code because
    it takes advantage of the mixin. This type of mixing acts as a sort of decorator.
    Based on what we just saw, `Tokenizer` will take `__iter__` from the mixin, and
    this one, in turn, delegates to the next class on the line (by calling `super()`),
    which is the `BaseTokenizer`, but it converts its values to uppercase, creating
    the desired effect.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`Tokenizer`类非常简单。它不需要任何代码，因为它利用了mixin。这种混合类型充当一种装饰器。根据我们刚才看到的，`Tokenizer`将从mixin中获取`__iter__`，而这个mixin又通过调用`super()`委托给了下一行中的类（即`BaseTokenizer`），但它将其值转换为大写，从而产生了期望的效果。
- en: Arguments in functions and methods
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和方法中的参数
- en: In Python, functions can be defined to receive arguments in several different
    ways, and these arguments can also be provided by callers in multiple ways.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，函数可以以多种不同的方式定义接收参数，并且这些参数也可以由调用者以多种方式提供。
- en: There is also an industry-wide set of practices for defining interfaces in software
    engineering that closely relates to the definition of arguments in functions.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中也有一套行业标准的接口定义实践，这与函数中参数的定义密切相关。
- en: In this section, we will first explore the mechanics of arguments in Python
    functions and afterwards review the general principles of software engineering
    that relate to good practices on this subject to finally relate both concepts.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先探讨Python函数中参数的机制，然后回顾与这些概念相关的软件工程的一般原则，最后将这两个概念联系起来。
- en: How function arguments work in Python
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中函数参数的工作原理
- en: First, we will explore the particularities of how arguments are passed to functions
    in Python, and then we will review the general theory of good software engineering
    practices that relate to these concepts.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探讨Python中函数参数传递的特殊性，然后我们将回顾与这些概念相关的良好软件工程实践的一般理论。
- en: By first understanding the possibilities that Python offers for handling parameters,
    we will be able to assimilate general rules more easily, and the idea is that
    after having done so, we can easily draw conclusions on what good patterns or
    idioms are when handling arguments. Then, we can identify in which scenarios the
    Pythonic approach is the correct one, and in which cases we might be abusing the
    features of the language.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 通过首先了解Python处理参数的可能性，我们将能够更容易地吸收一般规则，而且我们的想法是在这样做之后，我们可以很容易地得出关于处理参数时的良好模式或习惯用法的结论。然后，我们可以确定在哪些情况下Pythonic方法是正确的，在哪些情况下我们可能滥用了语言的特性。
- en: How arguments are copied to functions
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数如何被复制到函数中
- en: The first rule in Python is that all arguments are passed by a value. Always.
    This means that when passing values to functions, they are assigned to the variables
    on the signature definition of the function to be later used on it. You will notice
    that a function changing arguments might depend on the type arguments—if we are
    passing `mutable` objects, and the body of the function modifies this, then, of
    course, we have side-effect that they will have been changed by the time the function
    returns.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的第一条规则是所有参数都是按值传递的。总是。这意味着当将值传递给函数时，它们被分配给函数签名定义中的变量，以便以后在函数中使用。您会注意到函数更改参数可能取决于参数的类型
    - 如果我们传递`mutable`对象，并且函数的主体修改了它，那么当函数返回时，它们的值已经被改变了。
- en: 'In the following we can see the difference:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中我们可以看到区别：
- en: '[PRE29]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This might look like an inconsistency, but it's not. When we pass the first
    argument, a string, this is assigned to the argument on the function. Since string
    objects are immutable, a statement like `"argument += <expression>"` will in fact
    create the new object, `"argument + <expression>"`, and assign that back to the
    argument. At that point, an `argument` is just a local variable inside the scope
    of the function and has nothing to do with the original one in the caller.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一个不一致，但实际上并不是。当我们传递第一个参数，一个字符串，这个参数被分配给函数中的参数。由于字符串对象是不可变的，类似`"argument
    += <expression>"`这样的语句实际上会创建一个新对象`"argument + <expression>"`，并将其分配回参数。在那一点上，`argument`只是函数范围内的一个局部变量，与调用者原始的变量无关。
- en: On the other hand, when we pass `list`, which is a `mutable` object, then that
    statement has a different meaning (it's actually equivalent to calling `.extend()`
    on that `list`). This operator acts by modifying the `list` in-place over a variable
    that holds a reference to the original `list` object, hence modifying it.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们传递`list`，这是一个`mutable`对象时，那个语句的意义就不同了（实际上等同于在那个`list`上调用`.extend()`）。这个操作符通过在一个保存对原始`list`对象的引用的变量上就地修改`list`，从而修改它。
- en: We have to be careful when dealing with these types of parameter because it
    can lead to unexpected side-effects. Unless you are absolutely sure that it is
    correct to manipulate mutable arguments in this way, we would recommend avoiding
    it and going for alternatives without these problems.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理这些类型的参数时，我们必须小心，因为它可能导致意想不到的副作用。除非你绝对确定以这种方式操纵可变参数是正确的，我们建议避免这样做，并选择没有这些问题的替代方案。
- en: Don't `mutate` function arguments. In general, try to avoid side-effects in
    functions as much as possible.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 不要`mutate`函数参数。一般来说，尽量避免函数中的副作用。
- en: Arguments in Python can be passed by position, as in many other programming
    languages, but also by keyword. This means that we can explicitly tell the function
    which values we want for which of its parameters. The only caveat is that after
    a parameter is passed by keyword, the rest that follow must also be passed this
    way, otherwise, `SyntaxError` will be raised.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的参数可以按位置传递，就像许多其他编程语言一样，但也可以按关键字传递。这意味着我们可以明确告诉函数我们想要哪些参数的值。唯一的注意事项是在通过关键字传递参数之后，其后的参数也必须以这种方式传递，否则将引发`SyntaxError`。
- en: Variable number of arguments
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变数量的参数
- en: Python, as well as other languages, has built-in functions and constructions
    that can take a variable number of arguments. Consider for example string interpolation
    functions (whether it be by using the `%` operator or the `format` method for
    strings), which follow a similar structure to the `printf` function in C, a first
    positional parameter with the string format, followed by any number of arguments
    that will be placed on the markers of that formatting string.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Python以及其他语言都有内置函数和结构，可以接受可变数量的参数。例如，考虑字符串插值函数（无论是使用`%`运算符还是字符串的`format`方法），它们遵循与C语言中的`printf`函数类似的结构，首先是字符串格式的第一个位置参数，然后是任意数量的参数，这些参数将放置在格式化字符串的标记上。
- en: Besides taking advantage of these functions that are available in Python, we
    can also create our own, which will work in a similar fashion. In this section,
    we will cover the basic principles of functions with a variable number of arguments,
    along with some recommendations, so that in the next section, we can explore how
    to use these features to our advantage when dealing with common problems, issues,
    and constraints that functions might have if they have too many arguments.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 除了利用Python中可用的这些函数之外，我们还可以创建自己的函数，其工作方式类似。在本节中，我们将介绍具有可变数量参数的函数的基本原则，以及一些建议，以便在下一节中，我们可以探索如何在处理函数可能具有太多参数的常见问题、问题和约束时，如何利用这些功能。
- en: For a variable number of positionalarguments, the star symbol (`*`) is used,
    preceding the name of the variable that is packing those arguments. This works
    through the packing mechanism of Python.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可变数量的位置参数，使用星号（`*`）作为变量名的前缀，用于打包这些参数。这通过Python的打包机制实现。
- en: 'Let''s say there is a function that takes three positional arguments. In one
    part of the code, we conveniently happen to have the arguments we want to pass
    to the function inside a list, in the same order as they are expected by the function.
    Instead of passing them one by one by the position (that is, `list[0]` to the
    first element, `list[1]` to the second, and so on), which would be really un-Pythonic,
    we can use the packing mechanism and pass them all together in a single instruction:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个函数需要三个位置参数。在代码的某个部分，我们恰好有一个列表中我们想要传递给函数的参数，顺序与函数期望的顺序相同。我们可以使用打包机制，一次性将它们全部传递给一个指令，而不是一个一个地按位置传递（即`list[0]`到第一个元素，`list[1]`到第二个元素，依此类推），这样做真的不符合Python的风格。
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The nice thing about the packing mechanism is that it also works the other
    way around. If we want to extract the values of a list to variables, by their
    respective position, we can assign them like this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 打包机制的好处在于它也可以反过来使用。如果我们想要按照它们各自的位置从列表中提取变量的值，我们可以这样赋值：
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Partial unpacking is also possible. Let''s say we are just interested in the
    first values of a sequence (this can be a list, tuple, or something else), and
    after some point we just want the rest to be kept together. We can assign the
    variables we need and leave the rest under a packaged list. The order in which
    we unpack is not limited. If there is nothing to place in one of the unpacked
    subsections, the result will be an empty list. The reader is encouraged to try
    examples such as those presented in the following listing on a Python terminal,
    and also to explore that unpacking works with generators as well:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 部分解包也是可能的。假设我们只对序列的第一个值感兴趣（可以是列表、元组或其他内容），并且在某个点之后，我们只想保留其余的部分在一起。我们可以分配我们需要的变量，然后将其余部分放在一个打包的列表下。解包的顺序没有限制。如果没有东西放在其中一个解包的子部分中，结果将是一个空列表。鼓励读者在Python终端上尝试以下清单中呈现的示例，并且还要探索解包也适用于生成器：
- en: '[PRE32]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'One of the best uses for unpacking variables can be found in iteration. When
    we have to iterate over a sequence of elements, and each element is, in turn,
    a sequence, it is a good idea to unpack at the same time each element is being
    iterated over. To see an example of this in action, we are going to pretend that
    we have a function that receives a list of database rows, and that it is in charge
    of creating users out of that data. The first implementation takes the values
    to construct the user with from the position of each column in the row, which
    is not idiomatic at all. The second implementation uses unpacking while iterating:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 解包变量的最佳用途之一可以在迭代中找到。当我们必须迭代一系列元素，并且每个元素依次是一个序列时，同时进行解包是一个很好的主意。为了看到这种情况的示例，我们假装有一个函数接收一个数据库行的列表，并且负责从这些数据中创建用户。第一个实现从行中每列的位置获取值来构造用户，这一点根本不符合惯例。第二个实现在迭代时使用了解包：
- en: '[PRE33]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that the second version is much easier to read. In the first version
    of the function (`bad_users_from_rows`), we have data expressed in the form `row[0]`,
    `row[1]`, and `row[2]`, which doesn't tell us anything about what they are. On
    the other hand, variables such as `user_id`, `first_name`, and `last_name` speak
    for themselves.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第二个版本要容易阅读得多。在函数的第一个版本（`bad_users_from_rows`）中，我们的数据以`row[0]`、`row[1]`和`row[2]`的形式表示，这并没有告诉我们它们是什么。另一方面，像`user_id`、`first_name`和`last_name`这样的变量就不言自明了。
- en: We can leverage this kind of functionality to our advantage when designing our
    own functions.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这种功能来设计我们自己的函数时获得优势。
- en: 'An example of this that we can find in the standard library lies in the `max`
    function, which is defined as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的一个例子可以在标准库中找到，就在`max`函数中，它的定义如下：
- en: '[PRE34]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There is a similar notation, with two stars (`**`) for keyword arguments. If
    we have a dictionary and we pass it with a double star to a function, what it
    will do is pick the keys as the name for the parameter, and pass the value for
    that `key` as the `value` for that parameter in that function.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种类似的表示法，使用两个星号（`**`）用于关键字参数。如果我们有一个字典，并且将其带有双星号传递给函数，它将使用键作为参数的名称，并将该键的值作为该函数中该参数的值。
- en: 'For instance, check this out:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看这个：
- en: '[PRE35]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It is the same as the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下内容相同：
- en: '[PRE36]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Conversely, if we define a function with a parameter starting with two-star
    symbols, the opposite will happen—keyword-provided parameters will be packed into
    a dictionary:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果我们定义一个以两个星号符号开头的参数的函数，将会发生相反的情况——通过关键字提供的参数将被打包成一个字典：
- en: '[PRE37]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The number of arguments in functions
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数中的参数数量
- en: In this section, we agree on the idea that having functions or methods that
    take too many arguments is a sign of bad design (a code smell). Then, we propose
    ways of dealing with this issue.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们同意函数或方法接受太多参数是糟糕设计的迹象（代码异味）。然后，我们提出了处理这个问题的方法。
- en: The first alternative is a more general principle of software design—**reification**
    (creating a new object for all of those arguments that we are passing, which is
    probably the abstraction we are missing). Compacting multiple arguments into a
    new object is not a solution specific to Python, but rather something that we
    can apply in any programming language.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选择是软件设计的一个更一般的原则——**具体化**（为我们传递的所有参数创建一个新对象，这可能是我们缺少的抽象）。将多个参数压缩成一个新对象并不是Python特有的解决方案，而是我们可以在任何编程语言中应用的东西。
- en: Another option would be to use the Python-specific features we saw in the previous
    section, making use of variable positional and keyword arguments to create functions
    that have a dynamic signature. While this might be a Pythonic way of proceeding,
    we have to be careful not to abuse the feature, because we might be creating something
    that is so dynamic that it is hard to maintain. In this case, we should take a
    look at the body of the function. Regardless of the signature, and whether the
    parameters seem to be correct, if the function is doing too many different things
    responding to the values of the parameters, then it is a sign that it has to be
    broken down into multiple smaller functions (remember, functions should do one
    thing, and one thing only!).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用我们在前一节中看到的Python特定特性，利用可变位置和关键字参数创建具有动态签名的函数。虽然这可能是一种Pythonic的做法，但我们必须小心不要滥用这个特性，因为我们可能会创建一些非常动态的东西，很难维护。在这种情况下，我们应该看一下函数的主体。无论签名如何，以及参数是否正确，如果函数对参数的值做出了太多不同的反应，那么这就是它必须被分解成多个更小的函数的迹象（记住，函数应该只做一件事！）。
- en: Function arguments and coupling
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数参数和耦合
- en: The more arguments a function signature has, the more likely this one is going
    to be tightly coupled with the caller function.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 函数签名的参数越多，这个函数与调用函数的耦合性就越高。
- en: Let's say we have two functions, `f1`, and `f2`, and the latter takes five parameters.
    The more parameters `f2` takes, the more difficult it would be for anyone trying
    to call that function to gather all that information and pass it along so that
    it can work properly.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个函数，`f1`和`f2`，后者接受五个参数。`f2`接受的参数越多，任何试图调用该函数并收集所有信息并正确传递的人都会变得更加困难。
- en: 'Now, `f1` seems to have all of this information because it can call it correctly.
    From this, we can derive two conclusions: first, `f2` is probably a leaky abstraction,
    which means that since `f1` knows everything that `f2` requires, it can pretty
    much figure out what it is doing internally and will be able to do it by itself.
    So, all in all, `f2` is not abstracting that much. Second, it looks like `f2`
    is only useful to `f1`, and it is hard to imagine using this function in a different
    context, making it harder to reuse.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`f1`似乎有了所有这些信息，因为它可以正确地调用它。由此，我们可以得出两个结论：首先，`f2`可能是一个泄漏的抽象，这意味着由于`f1`知道`f2`需要的一切，它几乎可以弄清楚它在内部做什么，并且能够自己做到。总而言之，`f2`并没有那么抽象。其次，看起来`f2`只对`f1`有用，很难想象在不同的上下文中使用这个函数，这使得它更难以重用。
- en: When functions have a more general interface and are able to work with higher-level
    abstractions, they become more reusable.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数具有更一般的接口并且能够使用更高级的抽象时，它们变得更具重用性。
- en: This applies to all sort of functions and object methods, including the `__init__`
    method for classes. The presence of a method like this could generally (but not
    always) mean that a new higher-level abstraction should be passed instead, or
    that there is a missing object.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于所有类型的函数和对象方法，包括类的`__init__`方法。这样的方法的存在通常（但并非总是）意味着应该传递一个新的更高级的抽象，或者缺少一个对象。
- en: If a function needs too many parameters to work properly, consider it a code
    smell.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数需要太多参数才能正常工作，那就应该考虑它是代码异味。
- en: In fact, this is such a design problem that static analysis tools such as `pylint`
    (discussed in [Chapter 1](bba62a64-dfe9-478f-9b33-6c3240d75f59.xhtml), *Introduction,
    Code Formatting, and Tools*) will, by default, raise a warning about when they
    encounter such a case. When this happens, don't suppress the warning—refactor
    it instead.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这是一个设计问题，静态分析工具（如`pylint`）（在[第1章](bba62a64-dfe9-478f-9b33-6c3240d75f59.xhtml)中讨论，*介绍、代码格式和工具*）会默认发出警告。当发生这种情况时，不要压制警告，而是进行重构。
- en: Compact function signatures that take too many arguments
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压缩函数签名，接受太多参数
- en: Suppose we find a function that requires too many parameters. We know that we
    cannot leave the code base like that, and a refactor is imperative. But, what
    are the options?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们发现一个函数需要太多参数。我们知道我们不能让代码库保持这样，重构是必不可少的。但是，有哪些选择呢？
- en: Depending on the case, some of the following rules might apply. This is by no
    means extensive, but it does provide an idea of how to solve some scenarios that
    occur quite often.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 根据情况，以下规则可能适用。这绝不是详尽无遗的，但它确实提供了解决一些经常发生的情况的想法。
- en: 'Sometimes, there is an easy way to change parameters if we can see that most
    of them belong to a common object. For example, consider a function call like
    this one:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果我们发现大部分参数属于一个公共对象，改变参数可能是一种简单的方法。例如，考虑这样一个函数调用：
- en: '[PRE38]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, the function might or might not take additional arguments, but something
    is really obvious here: all of the parameters depend upon `request`, so why not
    pass the `request` object instead? This is a simple change, but it significantly
    improves the code. The correct function call should be `track_request(request)`—not
    to mention that, semantically, it also makes much more sense.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个函数可能会或可能不会接受额外的参数，但有一点非常明显：所有的参数都依赖于`request`，那么为什么不直接传递`request`对象呢？这是一个简单的改变，但它显著改进了代码。正确的函数调用应该是`track_request(request)`——更不用说，从语义上讲，这也更有意义。
- en: While passing around parameters like this is encouraged, in all cases where
    we pass mutable objects to functions, we must be really careful about side-effects.
    The function we are calling should not make any modifications to the object we
    are passing because that will mutate the object, creating an undesired side-effect.
    Unless this is actually the desired effect (in which case, it must be made explicit),
    this kind of behavior is discouraged. Even when we actually want to change something
    on the object we are dealing with, a better alternative would be to copy it and
    return a (new) modified version of it.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然鼓励传递参数，但在所有传递可变对象给函数的情况下，我们必须非常小心副作用。我们调用的函数不应对我们传递的对象进行任何修改，因为那样会改变对象，产生不希望的副作用。除非这实际上是期望的效果（在这种情况下，必须明确说明），否则不鼓励这种行为。即使我们实际上想要改变我们正在处理的对象上的某些东西，更好的选择是复制它并返回（新的）修改后的版本。
- en: Work with immutable objects, and avoid side-effects as much as possible.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不可变对象，并尽量避免副作用。
- en: 'This brings us to a similar topic: grouping parameters. In the previous example,
    the parameters were already grouped, but the group (in this case, the request
    object) was not being used. But other cases are not as obvious as that one, and
    we might want to group all the data in the parameters in a single object that
    acts as a container. Needless to say, this grouping has to make sense. The idea
    here is to *reify*: create the abstraction that was missing from our design.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们带到一个类似的话题：参数分组。在前面的例子中，参数已经被分组了，但这个组（在这种情况下是请求对象）并没有被使用。但其他情况并不像那个例子那么明显，我们可能希望将所有数据在参数中分组到一个充当容器的单个对象中。不用说，这种分组必须是有意义的。这里的想法是*实体化*：创建我们设计中缺失的抽象。
- en: If the previous strategies don't work, as a last resort we can change the signature
    of the function to accept a variable number of arguments. If the number of arguments
    is too big, using `*args` or `**kwargs` will make things harder to follow, so
    we have to make sure that the interface is properly documented and correctly used,
    but in some cases this is worth doing.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前的策略不起作用，作为最后的手段，我们可以改变函数的签名以接受可变数量的参数。如果参数数量太多，使用`*args`或`**kwargs`会使事情变得更难以理解，因此我们必须确保接口被正确记录和正确使用，但在某些情况下这是值得做的。
- en: It's true that a function defined with `*args` and `**kwargs` is really flexible
    and adaptable, but the disadvantage is that it loses its signature, and with that,
    part of its meaning, and almost all of its legibility. We have seen examples of
    how names for variables (including function arguments) make the code much easier
    to read. If a function will take any number of arguments (positional or keyword),
    we might find out that when we want to take a look at that function in the future,
    we probably won't know exactly what it was supposed to do with its parameters,
    unless it has a very good docstring.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义为`*args`和`**kwargs`确实非常灵活和适应性强，但缺点是它失去了它的签名，以及部分意义，几乎所有的可读性。我们已经看到了变量（包括函数参数）的命名如何使代码更容易阅读的例子。如果一个函数将接受任意数量的参数（位置或关键字），我们可能会发现，当我们想在将来查看该函数时，我们可能不会完全知道它应该如何处理它的参数，除非它有一个非常好的文档字符串。
- en: Final remarks on good practices for software design
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于软件设计的最终建议
- en: A good software design involves a combination of following good practices of
    software engineering and taking advantage of most of the features of the language.
    There is a great value in using everything that Python has to offer, but there
    is also a great risk of abusing this and trying to fit complex features into simple
    designs.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的软件设计涉及遵循软件工程的良好实践和充分利用语言的大部分特性的结合。充分利用Python所提供的一切是非常有价值的，但也存在滥用的风险，试图将复杂的特性适应简单的设计。
- en: In addition to this general principle, it would be good to add some final recommendations.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个一般原则，最好还要添加一些最终建议。
- en: Orthogonality in software
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件中的正交性
- en: 'This word is very general and can have multiple meanings or interpretations.
    In math, orthogonal means that two elements are independent. If two vectors are
    orthogonal, their scalar product is zero. It also means they are not related at
    all: a change in one of them doesn''t affect the other one at all. That''s the
    way we should think about our software.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这个词非常一般，可能有多种含义或解释。在数学中，正交意味着两个元素是独立的。如果两个向量正交，它们的数量积为零。这也意味着它们根本没有关系：其中一个的变化不会对另一个产生任何影响。这就是我们应该思考我们的软件的方式。
- en: Changing a module, class, or function should have no impact on the outside world
    to that component that is being modified. This is of course highly desirable,
    but not always possible. But even for cases where it's not possible, a good design
    will try to minimize the impact as much as possible. We have seen ideas such as
    separation of concerns, cohesion, and isolation of components.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 更改模块、类或函数不应对正在修改的组件的外部世界产生影响。这当然是非常理想的，但并非总是可能的。但即使在不可能的情况下，良好的设计也会尽量减少影响。我们已经看到了关注点分离、内聚性和组件隔离等概念。
- en: In terms of the runtime structure of software, orthogonality can be interpreted
    as the fact that makes changes (or side-effects) local. This means, for instance,
    that calling a method on an object should not alter the internal state of other
    (unrelated) objects. We have already (and will continue to do so) emphasized in
    this book the importance of minimizing side-effects in our code.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件的运行时结构方面，正交性可以被解释为使改变（或副作用）局部化的事实。这意味着，例如，调用对象的方法不应该改变其他（无关的）对象的内部状态。我们已经（并将继续这样做）在本书中强调了在我们的代码中最小化副作用的重要性。
- en: In the example with the mixin class, we created a `tokenizer` object that returned
    an iterable. The fact that the `__iter__` method returned a new generator increases
    the chances that all three classes (the base, the mixing, and the concrete class)
    are orthogonal. If this had returned something in concrete (a list, let's say),
    this would have created a dependency on the rest of the classes, because when
    we changed the list to something else, we might have needed to update other parts
    of the code, revealing that the classes were not as independent as they should
    be.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在混合类的示例中，我们创建了一个返回可迭代对象的`tokenizer`对象。`__iter__`方法返回一个新的生成器增加了这三个类（基类、混合类和具体类）都是正交的可能性。如果这返回了一个具体的东西（比如一个列表），这将在一定程度上创建了对其余类的依赖，因为当我们将列表更改为其他东西时，我们可能需要更新代码的其他部分，这表明这些类并不像它们应该的那样独立。
- en: 'Let''s show you a quick example. Python allows passing functions by parameter
    because they are just regular objects. We can use this feature to achieve some
    orthogonality. We have a function that calculates a price, including taxes and
    discounts, but afterward we want to format the final price that''s obtained:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给你一个快速的例子。Python允许通过参数传递函数，因为它们只是常规对象。我们可以利用这个特性来实现一些正交性。我们有一个计算价格的函数，包括税金和折扣，但之后我们想要格式化获得的最终价格：
- en: '[PRE39]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Notice that the top-level function is composing two orthogonal functions. One
    thing to notice is how we calculate the price, which is how the other one is going
    to be represented. Changing one does not change the other. If we don''t pass anything
    in particular, it will use string conversion as the default representation function,
    and if we choose to pass a custom function, the resulting string will change.
    However, changes in `show_price` do not affect `calculate_price`. We can make
    changes to either function, knowing that the other one will remain as it was:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，顶层函数正在组合两个正交函数。需要注意的一件事是我们如何计算价格，这也是另一个函数将被表示的方式。改变一个不会改变另一个。如果我们没有特别传递任何内容，它将使用字符串转换作为默认表示函数，如果我们选择传递自定义函数，结果字符串将改变。但是，对`show_price`的更改不会影响`calculate_price`。我们可以对任一函数进行更改，知道另一个函数将保持原样：
- en: '[PRE40]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There is an interesting quality aspect that relates to orthogonality. If two
    parts of the code are orthogonal, it means one can change without affecting the
    other. This implies that the part that changed has unit tests that are also orthogonal
    to the unit tests of the rest of the application. Under this assumption, if those
    tests pass, we can assume (up to a certain degree) that the application is correct
    without needing full regression testing.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 正交性与质量有关。如果代码的两部分是正交的，这意味着一个可以更改而不影响另一个。这意味着更改的部分具有单元测试，这些单元测试也与应用程序的其余部分的单元测试正交。在这种假设下，如果这些测试通过，我们可以假设（在一定程度上）应用程序是正确的，而不需要进行完整的回归测试。
- en: More broadly, orthogonality can be thought of in terms of features. Two functionalities
    of the application can be totally independent so that they can be tested and released
    without having to worry that one might break the other (or the rest of the code,
    for that matter). Imagine that the project requires a new authentication mechanism
    (`oauth2`, let's say, but just for the sake of the example), and at the same time
    another team is also working on a new report. Unless there is something fundamentally
    wrong in that system, neither of those features should impact the other. Regardless
    of which one of those gets merged first, the other one should not be affected
    at all.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 更广泛地说，正交性可以从功能的角度来考虑。应用程序的两个功能可以是完全独立的，以至于它们可以在不必担心一个可能破坏另一个（或代码的其余部分）的情况下进行测试和发布。想象一下，项目需要一个新的身份验证机制（比如`oauth2`，只是举例说明），与此同时另一个团队也在开发一个新的报告。除非系统中有根本性的问题，这两个功能都不应该相互影响。无论哪一个先合并，另一个都不应该受到任何影响。
- en: Structuring the code
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织代码
- en: The way code is organized also impacts the performance of the team and its maintainability.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的组织方式也影响团队的性能和可维护性。
- en: In particular, having large files with lots of definitions (classes, functions,
    constants, and so on) is a bad practice and should be discouraged. This doesn't
    mean going to the extreme of placing one definition per file, but a good code
    base will structure and arrange components by similarity.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，拥有大量定义（类、函数、常量等）的大文件是一种不好的做法，应该予以反对。这并不意味着要极端地将一个定义放在一个文件中，但一个良好的代码库将通过相似性来结构和安排组件。
- en: Luckily, most of the time, changing a large file into smaller ones is not a
    hard task in Python. Even if multiple other parts of the code depend on definitions
    made on that file, this can be broken down into a package, and will maintain total
    compatibility. The idea would be to create a new directory with a `__init__.py`
    file on it (this will make it a Python package). Alongside this file, we will
    have multiple files with all the particular definitions each one requires (fewer
    functions and classes grouped by a certain criterion). Then, the `__init__.py`
    file will import from all the other files the definitions it previously had (which
    is what guarantees its compatibility). Additionally, these definitions can be
    mentioned in the `__all__` variable of the module to make them exportable.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在Python中，大文件转换为小文件通常并不困难。即使代码的多个其他部分依赖于该文件中的定义，也可以将其拆分为一个包，并保持完全兼容。这个想法是创建一个新的目录，并在其中放置一个`__init__.py`文件（这将使它成为一个Python包）。除了这个文件，我们还将有多个文件，其中包含每个文件所需的所有特定定义（按某种标准分组的较少函数和类）。然后，`__init__.py`文件将从所有其他文件中导入先前具有的定义（这就是保证其兼容性的内容）。此外，这些定义可以在模块的`__all__`变量中提及，以便导出它们。
- en: 'There are many advantages of this. Other than the fact that each file will
    be easier to navigate, and things will be easier to find, we could argue that
    it will be more efficient because of the following reasons:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做有很多好处。除了每个文件更容易浏览，事物更容易找到之外，我们还可以认为它将更有效，因为有以下原因：
- en: It contains fewer objects to parse and load into memory when the module is imported
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当模块被导入时，它包含较少的对象需要解析和加载到内存中
- en: The module itself will probably be importing fewer modules because it needs
    fewer dependencies, like before
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块本身可能会导入较少的模块，因为它需要较少的依赖，就像以前一样
- en: 'It also helps to have a convention for the project. For example, instead of
    placing `constants` in all of the files, we can create a file specific to the
    constant values to be used in the project, and import it from there:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 项目还有一个约定也是有帮助的。例如，我们可以创建一个特定于项目中要使用的常量值的文件，而不是在所有文件中放置`constants`，然后从那里导入它：
- en: '[PRE41]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Centralizing information like this makes it easier to reuse code and helps to
    avoid inadvertent duplication.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样集中信息使得代码更容易重用，并有助于避免无意中的重复。
- en: More details about separating modules and creating Python packages will be discussed
    in [Chapter 10](87530c54-bf97-48c2-a557-de448cd690d4.xhtml), *Clean Architecture*,
    when we explore this in the context of software architecture.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 有关分离模块和创建Python包的更多细节将在[第10章](87530c54-bf97-48c2-a557-de448cd690d4.xhtml) *清晰架构*中讨论，当我们在软件架构的背景下探讨这个问题时。
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have explored several principles to achieve a clean design.
    Understanding that the code is part of the design is key to achieving high-quality
    software. This and the following chapter are focused precisely on that.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了几个实现清晰设计的原则。理解代码是设计的一部分是实现高质量软件的关键。这一章和下一章都专注于这一点。
- en: With these ideas, we can now construct more robust code. For example, by applying
    DbC, we can create components that are guaranteed to work under their constraints.
    More importantly, if errors occur, this will not happen out of the blue, but instead,
    we will have a clear idea of who the offender is and which part of the code broke
    the contract. This compartmentalization is clear to effective debugging.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些想法，我们现在可以构建更健壮的代码。例如，通过应用契约设计，我们可以创建保证在其约束下工作的组件。更重要的是，如果出现错误，这不会突然发生，而是我们将清楚地知道是谁犯了错，以及代码的哪一部分违反了契约。这种分隔清晰有助于有效的调试。
- en: Along similar lines, each component can be made more robust if it defends itself
    from malicious intent or incorrect input. Although this idea goes in a different
    direction from design by contract, it might complement it very well. Defensive
    programming is a good idea, especially for critical parts of the application.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似的情况下，如果每个组件都能够防御恶意意图或不正确的输入，那么它们就可以变得更加健壮。虽然这个想法与契约设计有所不同，但它可能会很好地补充它。防御性编程是一个好主意，特别是对于应用程序的关键部分。
- en: For both approaches (design by contract and defensive programming), it's important
    to correctly handle assertions. Keep in mind how they should be used in Python,
    and don't use assertions as part of the control flow logic of the program. Don't
    catch this exception, either.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 对于契约设计和防御性编程，正确处理断言是很重要的。牢记它们在Python中应该如何使用，并且不要将断言用作程序的控制流逻辑的一部分。也不要捕获这个异常。
- en: Speaking of exceptions, it's important to know how and when to use them, and
    the most important concept here is to avoid using exception as a control flow
    (go-to) kind of construction.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 说到异常，重要的是要知道何时以及如何使用它们，这里最重要的概念是避免将异常用作控制流（类似于go-to）的构造。
- en: 'We have explored a recurrent topic in object-oriented design: deciding between
    using inheritance or composition. The main lesson here is not to use one over
    the other, but to use whichever option is better; we should also avoid some common
    anti-patterns, which we might often see in Python (especially given its highly
    dynamic nature).'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了面向对象设计中一个经常出现的话题：在继承和组合之间做出决定。这里的主要教训不是要使用其中一个，而是要使用更好的选项；我们还应该避免一些常见的反模式，在Python中我们经常会看到这些（特别是考虑到它的高度动态性）。
- en: Finally, we discussed the number of arguments in functions, along with heuristics
    for a clean design, always with the particularities of Python in mind.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了函数中参数的数量，以及关于清晰设计的启发式方法，始终牢记Python的特殊性。
- en: These concepts are fundamental design ideas that lay the foundations for what's
    coming in the next chapter. We need to first understand these ideas so that we
    can move on to more advanced topics, such as SOLID principles.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念是奠定下一章内容基础的基本设计理念。我们需要首先理解这些想法，以便能够继续进行更高级的主题，比如SOLID原则。
- en: References
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Here is a list of information you can refer to:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些你可以参考的信息清单：
- en: '*Object-Oriented Software Construction, Second Edition*, written by Bertrand
    Meyer'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*面向对象的软件构造，第二版*，作者Bertrand Meyer'
- en: '*The Pragmatic Programmer: From Journeyman to Master*, by Andrew Hunt and David
    Thomas published by Addison-Wesley, 2000.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实用程序员：从熟练工到大师*，作者Andrew Hunt和David Thomas，Addison-Wesley出版，2000年。'
- en: '*PEP-316*: Programming by Contract for Python ([https://www.python.org/dev/peps/pep-0316/](https://www.python.org/dev/peps/pep-0316/))'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-316*: Python的契约式编程 ([https://www.python.org/dev/peps/pep-0316/](https://www.python.org/dev/peps/pep-0316/))'
- en: '*REAL 01*: The Most Diabolical Python Antipattern: [https://realpython.com/blog/python/the-most-diabolical-python-antipattern/](https://realpython.com/blog/python/the-most-diabolical-python-antipattern/)'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*REAL 01*: 最邪恶的Python反模式：[https://realpython.com/blog/python/the-most-diabolical-python-antipattern/](https://realpython.com/blog/python/the-most-diabolical-python-antipattern/)'
- en: '*PEP-3134:* Exception Chaining and Embedded Tracebacks ([https://www.python.org/dev/peps/pep-3134/](https://www.python.org/dev/peps/pep-3134/))'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-3134:* 异常链接和嵌入式回溯 ([https://www.python.org/dev/peps/pep-3134/](https://www.python.org/dev/peps/pep-3134/))'
- en: '*Idiomatic Python: EAFP versus LBYL* ([https://blogs.msdn.microsoft.com/pythonengineering/2016/06/29/idiomatic-python-eafp-versus-lbyl/](https://blogs.msdn.microsoft.com/pythonengineering/2016/06/29/idiomatic-python-eafp-versus-lbyl/))'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python的成语风格：EAFP vs. LBYL* ([https://blogs.msdn.microsoft.com/pythonengineering/2016/06/29/idiomatic-python-eafp-versus-lbyl/](https://blogs.msdn.microsoft.com/pythonengineering/2016/06/29/idiomatic-python-eafp-versus-lbyl/))'
- en: '*Composition vs. Inheritance: How to Choose?* ([https://www.thoughtworks.com/insights/blog/composition-vs-inheritance-how-choose](https://www.thoughtworks.com/insights/blog/composition-vs-inheritance-how-choose))'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组合 vs. 继承：如何选择？* ([https://www.thoughtworks.com/insights/blog/composition-vs-inheritance-how-choose](https://www.thoughtworks.com/insights/blog/composition-vs-inheritance-how-choose))'
- en: Python HTTP ([https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler](https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler))
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python HTTP ([https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler](https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler))
- en: Source reference for exceptions in the `requests` library ([http://docs.python-requests.org/en/master/_modules/requests/exceptions/](http://docs.python-requests.org/en/master/_modules/requests/exceptions/))
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requests`库中异常的源参考 ([http://docs.python-requests.org/en/master/_modules/requests/exceptions/](http://docs.python-requests.org/en/master/_modules/requests/exceptions/))'
- en: '*Code Complete: A Practical Handbook of Software Construction, Second Edition*,
    written by Steve McConnell'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Code Complete: 软件构造的实用手册，第二版*，作者Steve McConnell'
