- en: Advanced Introduction to Concurrent and Parallel Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发和并行编程的高级介绍
- en: This first chapter of *Mastering Concurrency in Python* will provide an overview
    of what concurrent programming is (in contrast to sequential programming). We
    will briefly discuss the differences between a program that can be made concurrent
    and one that cannot. We will go over the history of concurrent engineering and
    programming, and we will provide a number of examples of how concurrent programming
    is used in the present day. Finally, we will give a brief introduction to the
    approach that will be taken in this book, including an outline of the chapter
    structure and detailed instructions for how to download the code and create a
    working Python environment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python并发编程大师*的第一章将概述并发编程是什么（与顺序编程相对）。我们将简要讨论可以并发进行的程序与不能并发进行的程序之间的区别。我们将回顾并发工程和编程的历史，并提供许多并发编程在当今如何使用的例子。最后，我们将简要介绍本书的方法，包括章节结构的概述和如何下载代码并创建工作的Python环境的详细说明。'
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The concept of concurrency
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发的概念
- en: Why some programs cannot be made concurrent, and how to differentiate them from
    programs that can
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么有些程序不能并发进行，以及如何区分它们与可以并发进行的程序
- en: 'The history of concurrency in computer science: how it is used in the industry
    today, and what can be expected in the future'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机科学中的并发历史：它如何在当今的工业中使用，以及未来可以期待什么
- en: The specific topics that will be covered in each section/chapter of the book
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书中每个部分/章节将涵盖的具体主题
- en: How to set up a Python environment, and how to check out/download code from
    GitHub
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置Python环境，以及如何从GitHub检出/下载代码
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Check out the following video to see the Code in Action: [http://bit.ly/2TAMAeR](http://bit.ly/2TAMAeR)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[http://bit.ly/2TAMAeR](http://bit.ly/2TAMAeR)
- en: What is concurrency?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是并发？
- en: It is estimated that the amount of data that needs to be processed by computer
    programs doubles every two years. The **International Data Corporation** (**IDC**),
    for example, estimates that, by 2020, there will be 5,200 GBof data for every
    person on earth. With this staggering volume of data come insatiable demands for
    computing power, and, while numerous computing techniques are being developed
    and utilized every day, concurrent programming remains one of the most prominent
    ways to effectively and accurately process data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 据估计，计算机程序需要处理的数据量每两年翻一番。例如，**国际数据公司**（**IDC**）估计，到2020年，地球上每个人将有5200GB的数据。随着这一庞大的数据量，对计算能力的需求是无止境的，虽然每天都在开发和利用大量的计算技术，但并发编程仍然是处理数据的一种最显著的有效和准确的方式之一。
- en: While some might be intimidated when the word concurrency appears, the notion
    behind it is quite intuitive, and it is very common, even in a non-programming
    context. However, this is not to say that concurrent programs are as simple as
    sequential ones; they are indeed more difficult to write and understand. Yet,
    once a correct and effective concurrent structure is achieved, significant improvement
    in execution time will follow, as you will see later on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当一些人看到并发这个词时可能会感到害怕，但它背后的概念是非常直观的，甚至在非编程的情境中也是非常常见的。然而，这并不是说并发程序像顺序程序一样简单；它们确实更难编写和理解。然而，一旦实现了正确和有效的并发结构，执行时间将显著改善，这一点稍后你会看到。
- en: Concurrent versus sequential
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发与顺序
- en: 'Perhaps the most obvious way to understand concurrent programming is to compare
    it to sequential programming. While a sequential program is in one place at a
    time, in a concurrent program, different components are in independent, or semi-independent,
    states. This means that components in different states can be executed independently,
    and therefore at the same time (as the execution of one component does not depend
    on the result of another). The following diagram illustrates the basic differences
    between these two types:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 也许理解并发编程最明显的方法是将其与顺序编程进行比较。在顺序程序中，一次只能在一个地方，而在并发程序中，不同的组件处于独立或半独立的状态。这意味着处于不同状态的组件可以独立执行，因此可以同时执行（因为一个组件的执行不依赖于另一个的结果）。以下图表说明了这两种类型之间的基本区别：
- en: '![](assets/e13fba95-51d1-4592-9127-d6badfac52f1.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e13fba95-51d1-4592-9127-d6badfac52f1.png)'
- en: Difference between concurrent and sequential programs
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 并发和顺序程序之间的区别
- en: One immediate advantage of concurrency is an improvement in execution time.
    Again, since some tasks are independent and can therefore be completed at the
    same time, less time is required for the computer to execute the whole program.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 并发的一个直接优势是执行时间的改善。同样，由于一些任务是独立的，因此可以同时完成，计算机执行整个程序所需的时间更少。
- en: Example 1 – checking whether a non-negative number is prime
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例1 - 检查非负数是否为质数
- en: 'Let''s consider a quick example. Suppose that we have a simple function that
    checks whether a non-negative number is prime, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个快速的例子。假设我们有一个简单的函数，检查非负数是否为质数，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Also, suppose that we have a list of significantly large integers (*10^(13)*
    to *10^(13) + 500*), and we want to check whether each of them is prime by using
    the preceding function:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，假设我们有一个显著大的整数列表（*10^(13)*到*10^(13)+500*），我们想要使用前面的函数检查它们是否是质数：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A sequential approach would be to simply pass one number after another to the
    `is_prime()` function, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个顺序的方法是简单地将一个接一个的数字传递给`is_prime()`函数，如下所示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Copy the code or download it from the GitHub repository and run it (using the `python
    example1.py` command). The first section of your output will be something similar
    to the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 复制代码或从GitHub存储库下载并运行它（使用`python example1.py`命令）。你的输出的第一部分将类似于以下内容：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can see that the program took around `3.41` seconds to process all of the
    numbers; we will come back to this number soon. For now, it will also be beneficial
    for us to check how hard the computer was working while running the program. Open
    an Activity Monitor application in your operating system, and run the Python script
    again; the following screenshot shows my results:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到程序处理所有数字大约需要`3.41`秒；我们很快会回到这个数字。现在，对于我们来说，检查计算机在运行程序时的工作情况也是有益的。在操作系统中打开一个Activity
    Monitor应用程序，然后再次运行Python脚本；以下截图显示了我的结果：
- en: '![](assets/0af96196-064d-4b33-a79a-046f76aecc67.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0af96196-064d-4b33-a79a-046f76aecc67.png)'
- en: Activity Monitor showing computer performance
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Activity Monitor显示计算机性能
- en: Evidently, the computer was not working too hard, as it was nearly 83% idle.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，计算机并没有工作太辛苦，因为它几乎闲置了83%。
- en: 'Now, let''s see if concurrency can actually help us to improve our program.
    The `is_prime()` function contains a lot of heavy computation, and therefore it
    is a good candidate for concurrent programming. Since the process of passing one
    number to the `is_prime()` function is independent from passing another, we could
    potentially apply concurrency to our program, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看并发是否真的可以帮助我们改进程序。`is_prime()`函数包含大量的重型计算，因此它是并发编程的一个很好的候选对象。由于将一个数字传递给`is_prime()`函数的过程与传递另一个数字是独立的，我们可以潜在地将并发应用到我们的程序中，如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Roughly speaking, we are splitting the tasks into different, smaller chunks,
    and running them at the same time. Don't worry about the specifics of the code
    for now, as we will discuss this use of a pool of processes in greater detail
    later on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 粗略地说，我们将任务分割成不同的、更小的块，并同时运行它们。现在不要担心代码的具体细节，因为我们稍后将更详细地讨论使用进程池的情况。
- en: 'When I executed the function, the execution time was noticeably better, and
    the computer also used more of its resources, being only 37% idle:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我执行该函数时，执行时间明显更好，计算机也更多地利用了它的资源，只有37%的空闲时间：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output of the Activity Monitor application will look something like the
    following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Activity Monitor应用程序的输出将类似于以下内容：
- en: '![](assets/d867c9d5-476c-4d5f-9550-b59eb6471e49.png)Activity Monitor showing
    computer performance'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/d867c9d5-476c-4d5f-9550-b59eb6471e49.png)Activity Monitor显示计算机性能'
- en: Concurrent versus parallel
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发与并行
- en: At this point, if you have had some experience in parallel programming, you
    might be wondering whether concurrency is any different from parallelism. The
    key difference between concurrent and parallel programming is that, while in parallel
    programs there are a number of processing flows (mainly CPUs and cores) working
    independently all at once, there might be different processing flows (mostly threads)
    accessing and using **a shared resource** at the same time in concurrent programs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果您有一些并行编程的经验，您可能会想知道并发是否与并行有所不同。并发和并行编程之间的关键区别在于，虽然在并行程序中有许多处理流（主要是CPU和核心）可以独立工作，但在并发程序中，可能有不同的处理流（主要是线程）同时访问和使用**共享资源**。
- en: Since this shared resource can be read and overwritten by any of the different
    processing flows, some form of coordination is required at times, when the tasks
    that need to be executed are not entirely independent from one another. In other
    words, it is important for some tasks to be executed after the others, to ensure
    that the programs will produce the correct results.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个共享资源可以被不同的处理流程读取和覆盖，有时需要一定形式的协调，当需要执行的任务并不完全独立时。换句话说，有些任务重要的是在其他任务之后执行，以确保程序会产生正确的结果。
- en: '![](assets/3a74c04d-99d1-41ff-9230-39671a2e0688.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3a74c04d-99d1-41ff-9230-39671a2e0688.png)'
- en: Difference between concurrency and parallelism
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 并发与并行的区别
- en: 'The preceding figure illustrates the difference between concurrency and parallelism:
    while in the upper section, parallel activities (in this case, cars) that do not
    interact with each other can run at the same time, in the lower section, some
    tasks have to wait for others to finish before they can be executed.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上图说明了并发和并行的区别：在上部分，不相互交互的并行活动（在本例中是汽车）可以同时运行，而在下部分，一些任务必须等待其他任务完成后才能执行。
- en: We will look at more examples of these distinctions later on.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将看更多这些区别的例子。
- en: A quick metaphor
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个快速的比喻
- en: Concurrency is a quite difficult concept to fully grasp immediately, so let's
    consider a quick metaphor, in order to make concurrency and its differences from
    parallelism easier to understand.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是一个很难立即完全理解的概念，所以让我们考虑一个快速的比喻，以便更容易理解并发及其与并行的区别。
- en: Although some neuroscientists might disagree, let's briefly assume that different
    parts of the human brain are responsible for performing separate, exclusive body
    part actions and activities. For example, the left hemisphere of the brain controls
    the right side of the body, and hence, the right hand (and vice versa); or, one
    part of the brain might be responsible for writing, while another solely processes
    speaking.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一些神经科学家可能会有不同看法，让我们简要假设人脑的不同部分负责执行独立的身体部位动作和活动。例如，大脑的左半球控制身体的右侧，因此控制右手（反之亦然）；或者，大脑的一部分可能负责写作，而另一部分则专门处理说话。
- en: Now, let's consider the first example, specifically. If you want to move your
    left hand, the right side of your brain (and only the right side) has to process
    that command to move, which means that the left side of your brain is *free* to
    process other information. So, it is possible to move and use the left and right
    hands at the same time, in order to do different things. Similarly, it is possible
    to be writing *and* talking at the same time.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们具体考虑第一个例子。如果您想移动您的左手，大脑的右侧（只有右侧）必须处理移动的命令，这意味着左侧的大脑是*空闲*的，可以处理其他信息。因此，可以同时移动和使用左手和右手，以执行不同的事情。同样，可以同时写作*和*说话。
- en: 'That is parallelism: where different processes don''t interact with, and are
    independent of, each other. Remember that concurrency is not quite like parallelism.
    Even though there are instances where processes are executed together, concurrency
    also involves sharing the same resources. If parallelism is similar to using your
    left and right hands for independent tasks at the same time, concurrency can be
    associated with juggling, where the two hands perform different tasks simultaneously,
    but they also interact with the same object (in this case, the juggling balls),
    and some form of coordination between the two hands is therefore required.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是并行性：不同的进程不相互交互，彼此独立。请记住，并发并不完全像并行。尽管有一些情况下进程是一起执行的，但并发也涉及共享相同的资源。如果并行类似于同时使用左手和右手进行独立任务，那么并发可以与杂耍相关联，两只手同时执行不同的任务，但它们也与同一个对象（在这种情况下是杂耍球）进行交互，并且因此需要两只手之间的某种协调。
- en: Not everything should be made concurrent
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不是所有的事情都应该并发进行
- en: 'Not all programs are created equal: some can be made parallel or concurrent
    relatively easily, while others are **inherently sequential,** and thus cannot
    be executed concurrently, or in parallel. An extreme example of the former is **embarrassingly
    parallel** programs, which can be divided into different parallel tasks, between
    which there is little or no dependency or need for communication.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的程序都是平等的：有些可以相对容易地并行或并发执行，而其他一些则是固有的顺序，因此不能并发执行或并行执行。前者的一个极端例子是令人尴尬的并行程序，可以将其分成不同的并行任务，这些任务之间几乎没有依赖性或需要通信。
- en: Embarrassingly parallel
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 令人尴尬的并行
- en: A common example of an embarrassingly parallel program is the 3D video rendering
    handled by a graphics processing unit, where each frame or pixel can be processed
    with no interdependency. Password cracking is another embarrassingly parallel
    task that can easily be distributed on CPU cores. In a later chapter, we will
    tackle a number of similar problems, including image processing and web scraping,
    which can be made concurrent/parallel intuitively, resulting in significantly
    improved execution times.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的令人尴尬的并行程序的例子是由图形处理单元处理的3D视频渲染，其中每个帧或像素都可以在没有相互依赖的情况下进行处理。密码破解是另一个可以轻松分布在CPU核心上的令人尴尬的并行任务。在后面的章节中，我们将解决许多类似的问题，包括图像处理和网络抓取，这些问题可以直观地进行并发/并行处理，从而显著提高执行时间。
- en: Inherently sequential
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固有的顺序
- en: 'In opposition to embarrassingly parallel tasks, the execution of some tasks
    depends heavily on the results of others. In other words, those tasks are not
    independent, and thus, cannot be made parallel or concurrent. Furthermore, if
    we were to try to implement concurrency into those programs, it could cost us
    more execution time to produce the same results. Let''s go back to our prime-checking
    example from earlier; the following is the output that we saw:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与令人尴尬的并行任务相反，一些任务的执行严重依赖于其他任务的结果。换句话说，这些任务不是独立的，因此不能并行或并发执行。此外，如果我们试图将并发性引入这些程序，可能会花费更多的执行时间来产生相同的结果。让我们回到之前的素数检查示例；以下是我们看到的输出：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Pay close attention, and you will see that the two results from the two methods
    are not identical; the primes in the second result list are **out of order**.
    (Recall that, in the second method, to apply concurrency we specified splitting
    the tasks into different groups to be executed simultaneously, and the order of
    the results we obtained is the order in which each task finished being executed.)
    This is a direct result of using concurrency in our second method: we split the
    tasks to be executed by the program into different groups, and our program processed
    the tasks in these groups at the same time.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，你会发现两种方法得到的结果并不相同；第二个结果列表中的素数是无序的。（回想一下，在第二种方法中，为了应用并发，我们指定将任务分成不同的组同时执行，我们获得的结果的顺序是每个任务完成执行的顺序。）这是我们第二种方法中使用并发的直接结果：我们将要执行的任务分成不同的组，并且我们的程序同时处理了这些组中的任务。
- en: Since tasks across different groups were executed simultaneously, there were
    tasks that were behind other tasks in the input list, and yet were executed before
    those other tasks. For example, the number `10000000000183` was behind the number `10000000000129`
    in our input list, but was processed prior to, and therefore in front of, the
    number `10000000000129` in our output list. In fact, if you execute the program
    again and again, the second result will vary in almost every run.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不同组的任务同时执行，存在一些任务在输入列表中落后于其他任务，但在输出列表中却先于其他任务执行。例如，数字10000000000183在我们的输入列表中落后于数字10000000000129，但在输出列表中却在数字10000000000129之前被处理。实际上，如果你一遍又一遍地执行程序，第二个结果几乎每次都会有所不同。
- en: Evidently, this situation is not desirable if the result we'd like to obtain
    needs to be in the order of the input we originally had. Of course, in this example,
    we can simply modify the result by using some form of sorting, but it will cost
    us extra execution time in the end, which might make it even more expensive than
    the original sequential approach.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果我们希望获得的结果需要按照我们最初的输入顺序，那么这种情况是不可取的。当然，在这个例子中，我们可以通过使用某种形式的排序来简单修改结果，但最终会花费我们额外的执行时间，这可能使其比原始的顺序方法更昂贵。
- en: 'A concept that is commonly used to illustrate the innate sequentiality of some
    tasks is pregnancy: the number of women will never reduce the length of pregnancy.
    As opposed to parallel or concurrent tasks, where an increase in the number of
    processing entities will improve the execution time, adding more processors in
    inherently sequential tasks will not. Famous examples of inherent sequentiality
    include iterative algorithms: Newton''s method, iterative solutions to the three-body
    problem, or iterative numerical approximation methods.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 用来说明某些任务的固有顺序性的常用概念是怀孕：女性的数量永远不会减少怀孕的时间。与并行或并发任务相反，在固有顺序任务中增加处理实体的数量不会改善执行时间。固有顺序性的著名例子包括迭代算法：牛顿法、三体问题的迭代解、或迭代数值逼近方法。
- en: Example 2 – inherently sequential tasks
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 例2 - 固有顺序任务
- en: 'Let us consider a quick example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个快速的例子：
- en: Computing *f^(1000)(3)*, with *f(x) = x² - x + 1*, and *f^(n + 1)(x) = f(f^n(x))*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 计算*f^(1000)(3)*，其中*f(x) = x² - x + 1*，*f^(n + 1)(x) = f(f^n(x))*。
- en: With complicated functions like *f* (where it is relatively difficult to find
    a general form of *f^n(x)*), the only obviously reasonable way to compute *f^(1000)**(3)*
    or similar values is to iteratively compute *f²(3) = f( f(3))*,* f³(3) = f( f²(3))*,
    *...* ,* f^(999)(3) = f( f^(998)(3))*, and, finally, *f^(1000)**(3) = f( f^(999)(3)**)*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像*f*这样复杂的函数（其中找到*f^n(x)*的一般形式相对困难），计算*f^(1000)**(3)*或类似值的唯一合理的方法是迭代计算*f²(3)
    = f( f(3))*, *f³(3) = f( f²(3))*, *...* ,*f^(999)(3) = f( f^(998)(3))*, 最后，*f^(1000)**(3)
    = f( f^(999)(3)**)*。
- en: 'Since it will take significant time to actually compute *f^(1000)**(3)*, even
    when using a computer, we will only consider *f^(20)(3)* in our code (my laptop
    actually started heating up after *f^(25)(3)*):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用计算机，实际计算*f^(1000)**(3)*也需要很长时间，因此我们的代码中只考虑*f^(20)(3)*（我的笔记本电脑在计算*f^(25)(3)*后实际上开始发热）：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run it (or use `python example2.py`); the following code shows the output I
    received:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它（或使用`python example2.py`）；以下代码显示了我收到的输出：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, if we were to attempt to apply concurrency to this script, the only possible
    way would be through a `for` loop. One solution might be as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试将并发应用于此脚本，唯一可能的方法是通过`for`循环。一个解决方案可能如下：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output I received is shown as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我收到的输出如下所示：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Even though both methods produced the same result, the concurrent method took
    almost twice as long as the sequential method. This is due to the fact that every
    time a new thread (from `ThreadPoolExecutor`) was spawned, the function `conconcurrent_f()`,
    inside that thread, needed to wait for the variable `result` to be processed by
    the previous thread completely, and the program as a whole was thus executed in
    a sequential manner, nonetheless.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管两种方法都产生了相同的结果，但并发方法所花费的时间几乎是顺序方法的两倍。这是因为每次生成新线程（来自`ThreadPoolExecutor`）时，该线程内的函数`conconcurrent_f()`都需要等待变量`result`被前一个线程完全处理，因此整个程序仍然以顺序方式执行。
- en: So, while there was no actual concurrency involved in the second method, the
    overhead cost of spawning new threads contributed to the significantly worse execution
    time. This is one example of inherently sequential tasks, where concurrency or
    parallelism should not be applied to attempt an improvement in execution time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然第二种方法中实际上没有涉及并发，但生成新线程的开销导致了明显更差的执行时间。这是固有的顺序任务的一个例子，其中不应该尝试应用并发或并行来改善执行时间。
- en: I/O bound
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I/O绑定
- en: Another way to think about sequentiality is the concept (in computer science)
    of a condition called I/O bound, in which the time it takes to complete a computation
    is mainly determined by the time spent waiting for **input/output** (**I/O**)
    operations to be completed. This condition arises when the rate at which data
    is requested is slower than the rate at which it is consumed, or, in short, more
    time is spent requesting data than processing it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考顺序性的方式是计算机科学中称为I/O绑定的条件：计算完成所花费的时间主要由等待输入/输出（I/O）操作完成的时间决定。当请求数据的速率慢于消耗数据的速率时，或者简而言之，花费在请求数据上的时间比处理数据的时间更多时，就会出现这种情况。
- en: In an I/O bound state, the CPU must stall its operation, waiting for data to
    be processed. This means that, even if the CPU gets faster at processing data,
    processes tend to not increase in speed in proportion to the increased CPU speed,
    since they get more I/O-bound. With faster computation speed being the primary
    goal of new computer and processor designs, I/O bound states are becoming undesirable,
    yet more and more common, in programs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在I/O绑定状态下，CPU必须暂停其操作，等待数据被处理。这意味着，即使CPU在处理数据方面变得更快，由于它们更多地受到I/O绑定的影响，进程的速度不会与CPU速度的增加成比例地提高。随着更快的计算速度成为新计算机和处理器设计的主要目标，I/O绑定状态变得不受欢迎，但在程序中变得越来越常见。
- en: As you have seen, there are a number of situations in which the application
    of concurrent programming results in decreased processing speed, and they should
    thus be avoided. It is therefore important for us to not see concurrency as a
    golden ticket that can produce unconditionally better execution times, and to
    understand the differences between the structures of programs that benefit from
    concurrency and programs that do not.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，有许多情况下，并发编程的应用会导致处理速度下降，因此应该避免。因此，对我们来说，重要的是不将并发视为可以产生无条件更好执行时间的黄金票据，并理解受益于并发和不受益于并发的程序结构之间的差异。
- en: The history, present, and future of concurrency
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发的历史、现在和未来
- en: In the following sub-topics, we will discuss the past, present, and future of
    concurrency.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的子主题中，我们将讨论并发的过去、现在和未来。
- en: The field of concurrent programming has enjoyed significant popularity since
    the early days of computer science. In this section, we will discuss how concurrent
    programming started and evolved throughout its history, its current usage in the
    industry, and some predictions regarding how concurrency will be used in the future.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 自计算机科学的早期以来，并发编程领域就一直备受关注。在本节中，我们将讨论并发编程的起源和发展历程，以及它在工业中的当前使用情况，以及一些关于并发性将来如何使用的预测。
- en: The history of concurrency
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发性的历史
- en: The concept of concurrency has been around for quite some time. The idea developed
    from early work on railroads and telegraphy in the nineteenth and early twentieth centuries,
    and some terms have even survived to this day (such as **semaphore**, which indicates
    a variable that controls access to a shared resource in concurrent programs).
    Concurrency was first applied to address the question of how to handle multiple
    trains on the same railroad system, in order to avoid collisions and maximize
    efficiency, and how to handle multiple transmissions over a given set of wires
    in early telegraphy.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 并发性的概念已经存在了相当长的时间。这个想法起源于19世纪和20世纪初对铁路和电报的早期工作，并且一些术语甚至一直延续至今（比如**信号量**，它表示并发程序中控制对共享资源访问的变量）。并发性首先被应用于解决如何处理同一铁路系统上的多列火车，以避免碰撞并最大化效率，以及如何处理早期电报中给定一组电线上的多次传输。
- en: A significant portion of the theoretical groundwork for concurrent programming
    was actually laid in the 1960s. The early algorithmic language ALGOL 68, which
    was first developed in 1959, includes features that support concurrent programming.
    The academic study of concurrency officially started with a seminal paper in 1965
    from Edsger Dijkstra, who was a pioneer in computer science, best known for the
    path-finding algorithm that was named after him.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程的理论基础在20世纪60年代实际上已经奠定了。早期的算法语言ALGOL 68于1959年首次开发，包括支持并发编程的特性。并发性的学术研究正式始于1965年的一篇开创性论文，作者是计算机科学先驱Edsger
    Dijkstra，他以其命名的路径查找算法而闻名。
- en: That seminal paper is considered the first paper in the field of concurrent
    programming, in which Dijkstra identified and solved the mutual exclusion problem.
    Mutual exclusion, which is a property of concurrency control that prevents race
    conditions (which we will discuss later on), went on to become one of the most
    discussed topics in concurrency.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 那篇开创性的论文被认为是并发编程领域的第一篇论文，Dijkstra在其中确定并解决了互斥问题。互斥是并发控制的一个属性，它可以防止竞争条件（我们稍后会讨论），后来成为并发中最受讨论的话题之一。
- en: Yet, there was no considerable interest after that. From around 1970 to early
    2000, processors were said to double in executing speed every 18 months. During
    this period, programmers did not need to concern themselves with concurrent programming,
    as all they had to do to have their programs run faster was wait. However, in
    the early 2000s, a paradigm shift in the processor business took place; instead
    of making increasingly big and fast processors for computers, manufacturers started
    focusing on smaller, slower processors, which were put together in groups. This
    was when computers started to have multicore processors.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在那之后并没有太多的兴趣。从1970年左右到2000年初，处理器据说每18个月执行速度翻倍。在这段时间内，程序员不需要关注并发编程，因为他们只需要等待程序运行得更快。然而，在2000年初，处理器业务发生了一场范式转变；制造商开始专注于更小、更慢的处理器，这些处理器被组合在一起。这是计算机开始拥有多核处理器的时候。
- en: Nowadays, an average computer has more than one core. So, if a programmer writes
    all of their programs to be non-concurrent in any way, they will find that their
    programs utilize only one core or one thread to process data, while the rest of
    the CPU sits idle, doing nothing (as we saw in the *Example 1 – Checking whether
    a non-negative number is prime *section). This is one reason for the recent push
    in concurrent programming.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，一台普通的计算机拥有多个核心。因此，如果程序员以任何方式编写所有的程序都不是并发的话，他们会发现他们的程序只利用一个核心或一个线程来处理数据，而CPU的其余部分则闲置不做任何事情。这也是最近推动并发编程的一个原因。
- en: 'Another reason for the increasing popularity of concurrency is the growing
    field of graphical, multimedia, and web-based application development, in which
    the application of concurrency is widely used to solve complex and meaningful
    problems. For example, concurrency is a major player in web development: each
    new request made by a user typically comes in as its own process (this is called
    multiprocessing; see [Chapter 6](eed3a259-04e1-4778-809e-570f7e0b20ce.xhtml), *Working
    with Processes in Python*) or asynchronously coordinated with other requests (this
    is called asynchronous programming; see [Chapter 9](803de08e-7eb5-410b-811b-316754d2a28f.xhtml),
    *Introduction to Asynchronous Programming*); if any of those requests need to
    access a shared resource (a database, for example) where data can be changed,
    concurrency should be taken into consideration.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 并发性日益增长的另一个原因是图形、多媒体和基于网络的应用程序开发领域的不断扩大，其中并发性的应用被广泛用于解决复杂和有意义的问题。例如，并发性在Web开发中扮演着重要角色：用户发出的每个新请求通常都作为自己的进程（这称为多进程；参见[第6章](eed3a259-04e1-4778-809e-570f7e0b20ce.xhtml)，*在Python中处理进程*）或与其他请求异步协调（这称为异步编程；参见[第9章](803de08e-7eb5-410b-811b-316754d2a28f.xhtml)，*异步编程简介*）；如果其中任何请求需要访问共享资源（例如数据库），并发性应该被考虑进去。
- en: The present
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在
- en: Considering the present day, where an explosive growth the internet and data
    sharing happens every second, concurrency is more important than ever. The current
    use of concurrent programming emphasizes correctness, performance, and robustness.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到现在，互联网和数据共享的爆炸性增长每秒都在发生，因此并发性比以往任何时候都更加重要。当前并发编程的使用强调正确性、性能和稳健性。
- en: Some concurrent systems, such as operating systems or database management systems,
    are generally designed to operate indefinitely, including automatic recovery from
    failure, and not terminate unexpectedly. As mentioned previously, concurrent systems
    use shared resources, and thus they require some form of **semaphore** in their
    implementation, to control and coordinate access to those resources.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一些并发系统，如操作系统或数据库管理系统，通常被设计为无限运行，包括从故障中自动恢复，并且不会意外终止。如前所述，并发系统使用共享资源，因此它们在实现中需要某种形式的**信号量**来控制和协调对这些资源的访问。
- en: 'Concurrent programming is quite ubiquitous in the field of software development.
    Following are a few examples where concurrency is present:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程在软件开发领域非常普遍。以下是一些并发存在的示例：
- en: 'Concurrency plays an important role in most common programming languages: C++,
    C#, Erlang, Go, Java, Julia, JavaScript, Perl, Python, Ruby, Scala, and so on.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发在大多数常见的编程语言中都扮演着重要角色：C++、C#、Erlang、Go、Java、Julia、JavaScript、Perl、Python、Ruby、Scala等等。
- en: Again, since almost every computer today has more than one core in its CPU,
    desktop applications need to be able to take advantage of that computing power,
    in order to provide truly well-designed software.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次，由于几乎每台计算机今天都在其CPU中有多个核心，桌面应用程序需要能够利用这种计算能力，以提供真正设计良好的软件。
- en: '![](assets/5989c0ae-f5e5-40f8-b2b8-457e95038501.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5989c0ae-f5e5-40f8-b2b8-457e95038501.png)'
- en: Multicore processors used in MacBook Pro computers
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: MacBook Pro电脑使用的多核处理器
- en: The iPhone 4S, which was released in 2011, has a dual-core CPU, so mobile development
    also has to stay connected to concurrent applications.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2011年发布的iPhone 4S具有双核CPU，因此移动开发也必须与并发应用程序保持连接。
- en: As for video games, two of the biggest players on the current market are the
    Xbox 360, which is a multi-CPU system, and Sony's PS3, which is essentially a
    multicore system.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至于视频游戏，目前市场上最大的两个参与者是多CPU系统的Xbox 360和本质上是多核系统的索尼PS3。
- en: Even the current iteration of the $35 Raspberry Pi is built around a quad-core
    system.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使是当前的35美元的树莓派也是基于四核系统构建的。
- en: It is estimated that on average, Google processes over 40,000 search queries
    every second, which equates to over 3.5 billion searches per day, and 1.2 trillion
    searches per year, worldwide. Apart from having massive machines with incredible
    processing power, concurrency is the best way to handle that amount of data requests.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 据估计，谷歌平均每秒处理超过40,000个搜索查询，相当于每天超过35亿次搜索，全球每年处理1.2万亿次搜索。除了拥有处理能力惊人的大型机器外，并发性是处理如此大量数据请求的最佳方式。
- en: A large percentage of today's data and applications are stored in the cloud.
    Since computing instances on the cloud are relatively small in size, almost every
    web application is therefore forced to be concurrent, processing different small
    jobs simultaneously. As it gains more customers and has to process more requests,
    a well-designed web application can simply utilize more servers while keeping
    the same logic; this corresponds to the property of robustness that we mentioned
    earlier.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，大部分数据和应用程序存储在云中。由于云上的计算实例相对较小，几乎每个网络应用都被迫采用并发处理，同时处理不同的小任务。随着获得更多客户并需要处理更多请求，设计良好的网络应用可以简单地利用更多服务器，同时保持相同的逻辑；这对应了我们之前提到的鲁棒性属性。
- en: Even in the increasingly popular fields of artificial intelligence and data
    science, major advances have been made, in part due to the availability of high-end
    graphics cards (GPUs), which are used as parallel computing engines. In every
    notable competition on the biggest data science website ([https://www.kaggle.com/](https://www.kaggle.com/)),
    almost all prize-winning solutions feature some form of GPU usage during the training
    process. With the sheer amount of data that big data models have to comb through,
    concurrency provides an effective solution. Some AI algorithms are even designed
    to break their input data down into smaller portions and process them independently,
    which is a perfect opportunity to apply concurrency in order to achieve better
    model-training time.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在人工智能和数据科学这些日益流行的领域，也取得了重大进展，部分原因是高端图形卡（GPU）的可用性，它们被用作并行计算引擎。在最大的数据科学网站（[https://www.kaggle.com/](https://www.kaggle.com/)）的每一次显著竞赛中，几乎所有获奖解决方案在训练过程中都使用了某种形式的GPU。由于大数据模型需要处理大量数据，因此并发提供了一种有效的解决方案。一些人工智能算法甚至被设计成将输入数据分解成较小的部分并独立处理，这是应用并发以实现更好的模型训练时间的绝佳机会。
- en: The future
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来
- en: In this day and age, computer/internet users expect instant output, no matter
    what applications they are using, and developers often find themselves struggling
    with the problem of providing better speed for their applications. In terms of
    usage, concurrency will continue to be one of the main players in the field of
    programming, providing unique and innovative solutions to those problems. As mentioned
    earlier, whether it be video game design, mobile apps, desktop software, or web
    development, concurrency is, and will be, omnipresent in the near future.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今这个时代，无论用户使用什么应用程序，计算机/互联网用户都期望即时输出，开发人员经常发现自己在努力解决为其应用程序提供更快速度的问题。在使用方面，并发性将继续成为编程领域的主要参与者之一，为这些问题提供独特和创新的解决方案。如前所述，无论是视频游戏设计、移动应用、桌面软件还是Web开发，未来并发性都将无处不在。
- en: Given the need for concurrency support in applications, some might argue that
    concurrent programming will also become more standard in academia. Even though
    specific topics in concurrency and parallelism are being covered in computer science
    courses, in-depth, complex subjects on concurrent programming (both theoretical
    and applied subjects) will be implemented in undergraduate and graduate courses,
    to better prepare students for the industry, where concurrency is being used every
    day. Computer science courses on building concurrent systems, studying data flows,
    and analyzing concurrent and parallel structures will only be the beginning.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于应用程序对并发支持的需求，有人可能会认为并发编程在学术界也将变得更加标准。尽管计算机科学课程中涵盖了并发和并行主题，但深入的、复杂的并发编程课题（理论和应用课题）将被纳入本科和研究生课程中，以更好地为学生们未来在行业中的工作做准备，因为并发在日常中被广泛使用。计算机科学课程将涉及构建并发系统、研究数据流以及分析并发和并行结构，这只是一个开始。
- en: 'Others might have a more skeptical view of the future of concurrent programming.
    Some say that concurrency is really about dependency analysis: a sub-field of
    compiler theory that analyzes execution-order constraints between statements/instructions,
    and determines whether it is safe for a program to **reorder** or **parallelize**
    its statements. Furthermore, since only a very small number of programmers truly
    understand concurrency and all of its intricacies, there will be a push for compilers,
    along with support from the operating system, to take on the responsibility of
    actually implementing concurrency into the programs they compile on their own.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 其他人可能对并发编程的未来持更为怀疑的观点。有人说，并发实际上是关于依赖分析的：这是编译器理论的一个子领域，分析语句/指令之间的执行顺序约束，并确定程序是否安全地重新排序或并行化其语句。此外，由于真正理解并发及其复杂性的程序员数量很少，将会有一种推动力，即编译器以及操作系统的支持，来承担实际将并发实现到它们自己编译的程序中的责任。
- en: Specifically, in the future programmers will not have to concern themselves
    with the concepts and problems of concurrent programming, nor should they. An
    algorithm implemented on the compiler-level should look at the program being compiled,
    analyze the statements and instructions, produce a dependency graph to determine
    the optimal order of execution for those statements and instructions, and apply
    concurrency/parallelism where it is appropriate and efficient. In short, the combination
    of the low number of programmers understanding and being able to effectively work
    with concurrent systems and the possibility of automating the design of concurrency
    will lead to a decrease in interest in concurrent programming.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，未来程序员将不必关心并发编程的概念和问题，也不应该。在编译器级别实现的算法应该查看正在编译的程序，分析语句和指令，生成依赖图以确定这些语句和指令的最佳执行顺序，并在适当和有效的地方应用并发/并行。简而言之，程序员对并发系统的理解和有效工作的数量较少，以及自动化设计并发的可能性，将导致对并发编程的兴趣减少。
- en: 'In the end, only time will tell what the future holds for concurrent programming.
    We programmers can only look at how concurrency is currently being used in the
    real world, and determine whether it is worth learning or not: which, as we have
    seen in this case, it is. Furthermore, even though there are strong connections
    between designing concurrent programs and dependency analysis, I personally see
    concurrent programming as a more intricate and involved process, which might be
    very difficult to achieve through automation.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，只有时间才能告诉我们并发编程的未来会是什么样子。我们程序员只能看看并发目前在现实世界中是如何被使用的，并确定是否值得学习：正如我们在这个案例中所看到的那样。此外，尽管设计并发程序与依赖分析之间存在着紧密的联系，但我个人认为并发编程是一个更为复杂和深入的过程，可能很难通过自动化实现。
- en: Concurrent programming is indeed extremely complicated and very hard to get
    right, but that also means the knowledge gained through the process will be beneficial
    and useful to any programmer, and I see that as a good enough reason to learn
    about concurrency. The ability to analyze the problems of program speedup, restructure
    your programs into different independent tasks, and coordinate those tasks to
    use the same resources, are the main skills that programmers build while working
    with concurrency, and knowledge of these topics will help them with other programming
    problems, as well.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程确实非常复杂，很难做到完美，但这也意味着通过这个过程获得的知识将对任何程序员都是有益的，我认为这已经足够好的理由来学习并发。分析程序加速的问题、将程序重构为不同的独立任务，并协调这些任务使用相同的资源，是程序员在处理并发时所建立的主要技能，对这些主题的了解也将帮助他们解决其他编程问题。
- en: A brief overview of mastering concurrency in Python
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python并发编程的简要概述
- en: Python is one of the most popular programming languages out there, and for good
    reason. The language comes with numerous libraries and frameworks that facilitate
    high-performance computing, whether it be software development, web development,
    data analysis, or machine learning. Yet, there have been discussions among developers
    criticizing Python, which often revolve around the **Global Interpreter Lock**
    **(GIL)** and the difficulty of implementing concurrent and parallel programs
    that it leads to.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Python是最受欢迎的编程语言之一，而且理由充分。该语言配备了许多库和框架，可以促进高性能计算，无论是软件开发、网站开发、数据分析还是机器学习。然而，开发人员之间一直在讨论Python的问题，其中经常涉及全局解释器锁（GIL）以及实现并发和并行程序所带来的困难。
- en: While concurrency and parallelism do behave differently in Python than in other
    common programming languages, it is still possible for programmers to implement
    Python programs that run concurrently or in parallel, and achieve significant
    speedup for their programs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在Python中，并发和并行的行为与其他常见的编程语言有所不同，但程序员仍然可以实现并发或并行运行的Python程序，并为其程序实现显著的加速。
- en: '*Mastering Concurrency in Python* will serve as a comprehensive introduction
    to various advanced concepts in concurrent engineering and programming in Python.
    This book will also provide a detailed overview of how concurrency and parallelism
    are being used in real-world applications. It is a perfect blend of theoretical
    analyses and practical examples, which will give you a full understanding of the
    theories and techniques regarding concurrent programming in Python.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 《Python并发编程大师》将作为Python中并发工程和编程中各种高级概念的全面介绍。本书还将详细介绍并发和并行在现实应用中的使用情况。它是理论分析和实际示例的完美结合，将使您充分了解Python中并发编程的理论和技术。
- en: This book will be divided into six main sections. It will start with the idea
    behind concurrency and concurrent programming—the history, how it is being used
    in the industry today, and finally, a mathematical analysis of the speedup that
    concurrency can potentially provide. Additionally, the last section in this chapter
    (which is our next section) will cover instructions for how to follow the coding
    examples in this book, including setting up a Python environment on your own computer,
    downloading/cloning the code included in this book from GitHub, and running each
    example from your computer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将分为六个主要部分。它将从并发和并发编程背后的理念开始——历史，它如何在当今的工业中使用，最后，对并发可能提供的加速的数学分析。此外，本章的最后一节（也是我们的下一节）将介绍如何按照本书中的编码示例，包括在自己的计算机上设置Python环境，从GitHub下载/克隆本书中包含的代码，并在计算机上运行每个示例的说明。
- en: 'The next three sections will cover three of the main implementation approaches
    in concurrent programming: threads, processes, and asynchronous I/O, respectively.
    These sections will include theoretical concepts and principles for each of these
    approaches, the syntax and various functionalities that the Python language provides
    to support them, discussions of best practices for their advanced usage, and hands-on
    projects that directly apply these concepts to solve real-world problems.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三节将分别涵盖并发编程中的三种主要实现方法：线程、进程和异步I/O。这些部分将包括每种方法的理论概念和原则，Python语言提供的语法和各种功能来支持它们，以及它们高级用法的最佳实践讨论，并且直接应用这些概念来解决现实问题的实践项目。
- en: 'Section five will introduce readers to some of the most common problems that
    engineers and programmers face in concurrent programming: deadlock, starvation,
    and race conditions. Readers will learn about the theoretical foundations and
    causes for each problem, analyze and replicate each of them in Python, and finally
    implement potential solutions. The last chapter in this section will discuss the
    aforementioned GIL, which is specific to the Python language. It will cover the
    GIL''s integral role in the Python ecosystem, some challenges that the GIL poses
    for concurrent programming, and how to implement effective workarounds.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第五节将向读者介绍工程师和程序员在并发编程中面临的一些常见问题：死锁、饥饿和竞争条件。读者将了解每个问题的理论基础和原因，在Python中分析和复制每个问题，并最终实现潜在的解决方案。本节的最后一章将讨论前面提到的GIL，这是Python语言特有的。它将涵盖GIL在Python生态系统中的重要作用，GIL对并发编程提出的一些挑战，以及如何实现有效的解决方法。
- en: In the last section of the book, we will be working on various advanced applications
    of concurrent Python programming. These applications will include the design of
    lock-free and lock-based concurrent data structures, memory models and operations
    on atomic types, and how to build a server that supports concurrent request processing
    from scratch. The section will also cover the the best practices when testing,
    debugging, and scheduling concurrent Python applications.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在书的最后一节中，我们将致力于并发Python编程的各种高级应用。这些应用将包括无锁和有锁并发数据结构的设计，内存模型和原子类型的操作，以及如何从头开始构建支持并发请求处理的服务器。本节还将涵盖在测试、调试和调度并发Python应用程序时的最佳实践。
- en: Throughout this book, you will be building essential skills for working with
    concurrent programs, just through following the discussions, the example code,
    and the hands-on projects. You will understand the fundamentals of the most important
    concepts in concurrent programming, how to implement them in Python programs,
    and how to apply that knowledge to advanced applications. By the end of *Mastering
    Concurrency in Python*, you will have a unique combination of extensive theoretical
    knowledge regarding concurrency, and practical know-how of the various applications
    of concurrency in the Python language.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，您将通过讨论、示例代码和实践项目来建立处理并发程序的基本技能。您将了解并发编程中最重要的概念的基础知识，如何在Python程序中实现它们，以及如何将这些知识应用于高级应用。通过《Python并发编程大师》，您将具备关于并发的广泛理论知识和在Python语言中并发应用的实际知识的独特组合。
- en: Why Python?
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Python？
- en: As mentioned previously, one of the difficulties that developers face while
    working with concurrency in the Python programming language (specifically, CPython—a
    reference implementation of Python written in C) is its GIL. The GIL is a mutex
    that protects access to Python objects, preventing multiple threads from executing
    Python byte codes at once. This lock is necessary mainly because CPython's memory
    management is not thread-safe. CPython uses reference counting to implement its
    memory management. This results in the fact that multiple threads can access and
    execute Python code simultaneously; this situation is undesirable, as it can cause
    an incorrect handling of data, and we say that this type of memory management
    is not thread-safe. To address this problem, the GIL is, as the name suggests,
    a lock that allows only one thread to access Python code and objects. However,
    this also means that, to implement multithreading programs in CPython, developers
    need to be aware of the GIL and work around it. That is why many have problems
    with implementing concurrent systems in Python.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，开发者在使用Python编程语言（特别是CPython——用C编写的Python的参考实现）进行并发编程时面临的困难之一是其GIL。GIL是一个互斥锁，用于保护对Python对象的访问，防止多个线程同时执行Python字节码。这个锁主要是因为CPython的内存管理不是线程安全的。CPython使用引用计数来实现其内存管理。这导致多个线程可以同时访问和执行Python代码；这种情况是不希望发生的，因为它可能导致数据处理不正确，我们称这种内存管理方式不是线程安全的。为了解决这个问题，GIL是一个锁，如其名，只允许一个线程访问Python代码和对象。然而，这也意味着，要在CPython中实现多线程程序，开发者需要意识到GIL并绕过它。这就是为什么许多人在Python中实现并发系统时会遇到问题。
- en: So, why use Python for concurrency at all? Even though the GIL prevents multithreaded
    CPython programs from taking full advantage of multiprocessor systems in certain
    situations, most blocking or long-running operations, such as I/O, image processing,
    and NumPy number crunching, happen outside the GIL. Therefore, the GIL only becomes
    a potential bottleneck for multithreaded programs that spend significant time
    inside the GIL. As you will see in future chapters, multithreading is only a form
    of concurrent programming, and, while the GIL poses some challenges for multithreaded
    CPython programs that allow more than one thread to access shared resources, other
    forms of concurrent programming do not have this problem. For example, multiprocessing
    applications that do not share any common resources among processes, such as I/O,
    image processing, or NumPy number crunching, can work seamlessly with the GIL.
    We will discuss the GIL and its place in the Python ecosystem in greater depth
    in [Chapter 15](0e30892f-4bb1-4196-93c5-5df1d57428b8.xhtml), *The Global Interpret
    Lock*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么要在Python中使用并发？尽管GIL在某些情况下阻止多线程的CPython程序充分利用多处理器系统，但大多数阻塞或长时间运行的操作，如I/O、图像处理和NumPy数值计算，都发生在GIL之外。因此，GIL只对在GIL内花费大量时间的多线程程序造成潜在瓶颈。正如您将在未来的章节中看到的，多线程只是一种并发编程形式，而且，虽然GIL对允许多个线程访问共享资源的多线程CPython程序提出了一些挑战，但其他形式的并发编程并没有这个问题。例如，不共享任何公共资源的多进程应用程序，如I/O、图像处理或NumPy数值计算，可以与GIL无缝配合。我们将在[第15章](0e30892f-4bb1-4196-93c5-5df1d57428b8.xhtml)中更深入地讨论GIL及其在Python生态系统中的位置，*全局解释锁*。
- en: Aside from that, Python has been gaining increasing popularity from the programming
    community. Due to its user-friendly syntax and overall readability, more and more
    people have found it relatively straightforward to use Python in their development,
    whether it is beginners learning a new programming language, intermediate users
    looking for the advanced functionalities of Python, or experienced programmers
    using Python to solve complex problems. It is estimated that the development of
    Python code can be up to 10 times faster than C/C++ code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Python在编程社区中的受欢迎程度不断增加。由于其用户友好的语法和整体可读性，越来越多的人发现在开发中使用Python相对来说相对简单，无论是初学者学习新的编程语言，中级用户寻找Python的高级功能，还是经验丰富的程序员使用Python解决复杂问题。据估计，Python代码的开发速度可能比C/C++代码快10倍。
- en: The large number of developers using Python has resulted in a strong, ever-growing
    support community. Libraries and packages in Python are being developed and released
    every day, tackling different problems and technologies. Currently, the Python
    language supports an incredibly wide range of programming—namely, software development,
    desktop GUIs, video game design, web and internet development, and scientific
    and numeric computing. In recent years, Python has also been growing as one of
    the top tools in data science, big data, and machine learning, competing with
    the long-time player in the field, R.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python的开发者数量的增加导致了一个强大且不断增长的支持社区。Python中的库和包每天都在不同的问题和技术上进行开发和发布。目前，Python语言支持非常广泛的编程范围，包括软件开发、桌面GUI、视频游戏设计、Web和互联网开发，以及科学和数值计算。近年来，Python还作为数据科学、大数据和机器学习领域的顶尖工具之一不断增长，与该领域的长期参与者R竞争。
- en: The sheer number of development tools available in Python has encouraged more
    developers to start programming with Python, making Python even more popular and
    easy to use; I call this *the vicious circle of Python*. David Robinson, chief
    data scientist at DataCamp, wrote a blog ([https://stackoverflow.blog/2017/09/06/incredible-growth-python/](https://stackoverflow.blog/2017/09/06/incredible-growth-python/))
    about the incredible growth of Python, and called it the most popular programming
    language.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Python开发工具的数量之多鼓励了更多的开发者开始使用Python进行编程，使Python变得更加流行和易于使用；我称之为*Python的恶性循环*。DataCamp的首席数据科学家大卫·罗宾逊在博客中写道（[https://stackoverflow.blog/2017/09/06/incredible-growth-python/](https://stackoverflow.blog/2017/09/06/incredible-growth-python/)），Python的增长令人难以置信，并称其为最受欢迎的编程语言。
- en: However, Python is slow, or at least slower than other popular programming languages.
    This is due to the fact that Python is a dynamically typed, interpreted language,
    where values are stored not in dense buffers, but in scattered objects. This is
    a direct result of Python's readability and user-friendliness. Luckily, there
    are various options regarding how to make your Python program run faster, and
    concurrency is one of the most complex of them; that is what we are going to master
    throughout this book.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python很慢，或者至少比其他流行的编程语言慢。这是因为Python是一种动态类型的解释语言，其中值不是存储在密集的缓冲区中，而是存储在分散的对象中。这直接是Python易读性和用户友好性的结果。幸运的是，有各种选项可以让您的Python程序运行得更快，而并发是其中最复杂的之一；这就是我们将在本书中掌握的内容。
- en: Setting up your Python environment
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置您的Python环境
- en: Before we move any further, let's go through a number of specifications regarding
    how to set up the necessary tools that you will be using throughout this book.
    In particular, we will discuss the process of obtaining a Python distribution
    for your system and an appropriate development environment, as well as how to
    download the code used in the examples included in the chapters of this book.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步进行之前，让我们了解一些关于如何设置本书中将要使用的必要工具的规范。特别是，我们将讨论如何为您的系统获取Python发行版以及适当的开发环境的过程，以及如何下载本书各章中包含的示例中使用的代码。
- en: General setup
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般设置
- en: 'Let''s look at the process of obtaining a Python distribution for your system
    and an appropriate development environment:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何为您的系统获取Python发行版以及适当的开发环境的过程：
- en: Any developer can obtain their own Python distribution from [https://www.python.org/downloads/](https://www.python.org/downloads/).
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何开发人员都可以从[https://www.python.org/downloads/](https://www.python.org/downloads/)获取他们自己的Python发行版。
- en: Even though both Python 2 and Python 3 are being supported and maintained, throughout
    this book we will be using Python 3.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管Python 2和Python 3都得到支持和维护，但在本书中，我们将使用Python 3。
- en: The choice of an **integrated development environment** (**IDE**) is flexible
    for this book. Although it is technically possible to develop Python applications
    using a minimal text editor, such as Notepad or TextEdit, it is usually much easier
    to read and write code with IDEs designed specifically for Python. These include
    IDLE ([https://docs.python.org/3/library/idle.html](https://docs.python.org/3/library/idle.html)),
    PyCharm ([https://www.jetbrains.com/pycharm/](https://www.jetbrains.com/pycharm/)),
    Sublime Text ([https://www.sublimetext.com/](https://www.sublimetext.com/)), and Atom
    ([https://atom.io/](https://atom.io/)).
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于本书来说，选择一个**集成开发环境**（**IDE**）是灵活的。虽然从技术上讲，可以使用最小的文本编辑器（如记事本或TextEdit）开发Python应用程序，但使用专门为Python设计的IDE通常更容易阅读和编写代码。这些包括IDLE（[https://docs.python.org/3/library/idle.html](https://docs.python.org/3/library/idle.html)）、PyCharm（[https://www.jetbrains.com/pycharm/](https://www.jetbrains.com/pycharm/)）、Sublime
    Text（[https://www.sublimetext.com/](https://www.sublimetext.com/)）和Atom（[https://atom.io/](https://atom.io/)）。
- en: Downloading example code
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载示例代码
- en: 'To obtain the code used throughout this book, you can download a repository
    from GitHub, which includes all of the example and project code covered in this
    book:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取本书中使用的代码，您可以从GitHub下载存储库，其中包括本书中涵盖的所有示例和项目代码：
- en: First, visit [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python).
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，访问[https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)。
- en: 'To download the repository, simply click on the Clone or download button in
    the top right corner of your window. Choose Download ZIP to download the compressed
    repository to your computer:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要下载存储库，只需单击窗口右上角的“克隆或下载”按钮。选择“下载ZIP”以将压缩的存储库下载到您的计算机：
- en: '![](assets/32dd5eb5-da0f-42df-83fa-0505eaeb467f.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/32dd5eb5-da0f-42df-83fa-0505eaeb467f.png)
- en: Click on Download ZIP to download the repository
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“下载ZIP”以下载存储库
- en: Uncompress the downloaded file to create the folder that we are looking for.
    The folder should have the name `Mastering-Concurrency-in-Python`.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解压下载的文件以创建我们正在寻找的文件夹。文件夹的名称应为“Mastering-Concurrency-in-Python”。
- en: Separate folders, titled `ChapterXX`, are inside the folder, indicating the
    chapter that covers the code in that folder. For example, the `Chapter03` folder
    contains the example and project code covered in [Chapter 3](b2db614b-1859-4a86-91d8-f9383c12f4e9.xhtml),
    *Working with Threads in Python*. In each subfolder, there are various Python
    scripts; as you go through each code example in the book, you will know which
    script to run at a specific point in each chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹内有各自命名为“ChapterXX”的文件夹，表示该文件夹中代码所涵盖的章节。例如，“Chapter03”文件夹包含了[第3章](b2db614b-1859-4a86-91d8-f9383c12f4e9.xhtml)中涵盖的示例和项目代码，*在Python中使用线程*。在每个子文件夹中，有各种Python脚本；当您在本书中阅读每个代码示例时，您将知道在每个章节的特定时点运行哪个脚本。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You have now been introduced to the concept of concurrent and parallel programming.
    It is about designing and structuring programming commands and instructions, so
    that different sections of the program can be executed in an efficient order,
    while sharing the same resources. Since time is saved when some commands and instructions
    are executed at the same time, concurrent programming provides significant improvements
    in program execution time, as compared to traditional sequential programming.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经了解了并发和并行编程的概念。它涉及设计和构造编程命令和指令，以便程序的不同部分可以以有效的顺序执行，同时共享相同的资源。由于当一些命令和指令同时执行时可以节省时间，因此与传统的顺序编程相比，并发编程在程序执行时间上提供了显着的改进。
- en: However, various factors need to be taken into consideration while designing
    a concurrent program. While there are specific tasks that can easily be broken
    down into independent sections that can be executed in parallel (embarrassingly
    parallel tasks), others require different forms of coordination between the program
    commands, so that shared resources are used correctly and efficiently. There are
    also inherently sequential tasks, in which no concurrency and parallelism can
    be applied to achieve program speedup. You should know the fundamental differences
    between these tasks, so that you can design your concurrent programs appropriately.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在设计并发程序时需要考虑各种因素。虽然有些特定任务可以很容易地分解成可以并行执行的独立部分（尴尬并行任务），但其他任务需要不同形式的协调，以便正确高效地使用共享资源。还有固有的顺序任务，无法应用并发和并行来实现程序加速。您应该了解这些任务之间的基本区别，以便适当地设计并发程序。
- en: 'Recently, there was a paradigm shift that facilitated the implementation of
    concurrency into most aspects of the programming world. Now, concurrency can be
    found almost everywhere: desktop and mobile applications, video games, web and
    internet development, AI, and so on. Concurrency is still growing, and it is expected
    to keep growing in the future. It is therefore crucial for any experienced programmer
    to understand concurrency and its relevant concepts, and to know how to integrate
    those concepts into their applications.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，出现了一种范式转变，促进了并发在编程世界的大多数方面的实现。现在，几乎可以在任何地方找到并发：桌面和移动应用程序，视频游戏，Web和互联网开发，人工智能等等。并发仍在增长，并且预计将来会继续增长。因此，任何有经验的程序员都必须了解并发及其相关概念，并知道如何将这些概念集成到他们的应用程序中，这是至关重要的。
- en: Python, on the other hand, is one of the most (if not the most) popular programming
    languages. It provides powerful options in most sub-fields of programming. The
    combination of concurrency and Python is therefore one of the topics most worth
    learning and mastering in programming.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Python是最受欢迎的编程语言之一（如果不是最受欢迎的）。它在大多数编程子领域提供了强大的选项。因此，并发和Python的结合是编程中最值得学习和掌握的主题之一。
- en: In the next chapter, on Amdahl's Law, we will discuss how significant the improvements
    in speedup that concurrency provides for our programs are. We will analyze the
    formula for Amdahl's Law, discussing its implications and considering Python examples.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Amdahl定律，以了解并发为我们的程序提供的加速改进有多重要。我们将分析Amdahl定律的公式，讨论其含义，并考虑Python示例。
- en: Questions
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the idea behind concurrency, and why is it useful?
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发的概念是什么，为什么它有用？
- en: What are the differences between concurrent programming and sequential programming?
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发编程和顺序编程之间有什么区别？
- en: What are the differences between concurrent programming and parallel programming?
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发编程和并行编程之间有什么区别？
- en: Can every program be made concurrent or parallel?
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个程序都可以做成并发或并行吗？
- en: What are embarrassingly parallel tasks?
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是尴尬并行任务？
- en: What are inherently sequential tasks?
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是固有的顺序任务？
- en: What does I/O bound mean?
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O绑定是什么意思？
- en: How is concurrent processing currently being used in the real world?
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前在现实世界中如何使用并发处理？
- en: Further reading
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information you can refer to the following links:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参考以下链接：
- en: '*Python Parallel Programming Cookbook*, by Giancarlo Zaccone, Packt Publishing
    Ltd, 2015'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python并行编程食谱*，作者：Giancarlo Zaccone，Packt Publishing Ltd，2015'
- en: '*Learning Concurrency in Python: Build highly efficient, robust, and concurrent
    applications* (2017), by Forbes, Elliot'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习Python并发：构建高效、健壮和并发的应用*（2017），作者：Forbes, Elliot'
- en: '"The historical roots of concurrent engineering fundamentals." *IEEE Transactions
    on Engineering Management* 44.1 (1997): 67-78, by Robert P. Smith'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《并发工程基础的历史根源》*IEEE工程管理交易* 44.1（1997）：67-78，作者：Robert P. Smith
- en: '*Programming language pragmatics*, Morgan Kaufmann, 2000, by Michael Lee Scott'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编程语言实用性*，Morgan Kaufmann，2000，作者：Michael Lee Scott'
