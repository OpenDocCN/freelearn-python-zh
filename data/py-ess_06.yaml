- en: Chapter 6. More Complex Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。更复杂的数据类型
- en: We'll look at a number of built-in and standard library collection types. These
    collections offer more features than the simple tuple collection. We'll look at
    the `for` and `while` statements which allow us to process the individual items
    of a collection.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨许多内置和标准库集合类型。这些集合提供了比简单元组集合更多的功能。我们将探讨`for`和`while`语句，这些语句允许我们处理集合的各个项。
- en: We'll look at some functions which we can use to work with collections of data;
    these include the `map()`, `filter()`, and `functools.reduce()` functions. By
    using these, we don't need to write an explicit `for` statement to process a collection.
    We'll also look at more specific kinds of reductions such as `max()`, `min()`,
    `len()`, and `sum()`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨一些我们可以用来处理数据集合的函数；这些包括`map()`、`filter()`和`functools.reduce()`函数。通过使用这些函数，我们不需要编写显式的`for`语句来处理集合。我们还将探讨更具体的归约类型，如`max()`、`min()`、`len()`和`sum()`。
- en: We'll also look at the `break` and `continue` statements; these modify a `for`
    or `while` loop to allow skipping items or exiting before the loop has processed
    all items. This is a fundamental change in the semantics of a collection-processing
    statement.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨`break`和`continue`语句；这些语句修改`for`或`while`循环，允许跳过项或在循环处理所有项之前退出。这是集合处理语句语义的一个基本变化。
- en: The concepts of mutability and immutability are part of understanding how an
    object behaves. The built-in types in this chapter are all mutable. This is quite
    different from the way that immutable objects like strings and tuples behave.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 可变性和不可变性是理解对象行为的一部分。本章中的内置类型都是可变的。这与不可变对象（如字符串和元组）的行为方式大不相同。
- en: The mutability and immutability distinction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变性和不可变性之间的区别
- en: In [Chapter 2](ch02.html "Chapter 2. Simple Data Types"), *Simple Data Types*,
    we looked at the immutability issue. This is an important characteristic of Python
    objects. We'll need to look at some more aspects of mutability in [Chapter 7](ch07.html
    "Chapter 7. Basic Function Definitions"), *Basic Function Definitions*. We'll
    look at how we can create our own mutable classes in [Chapter 11](ch11.html "Chapter 11. Class
    Definitions"), *Class Definitions*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。简单数据类型")中，我们探讨了不可变性问题。这是Python对象的一个重要特性。我们需要在[第7章](ch07.html
    "第7章。基本函数定义")中探讨更多关于可变性的方面，*基本函数定义*。我们将在[第11章](ch11.html "第11章。类定义")中探讨如何创建我们自己的可变类，*类定义*。
- en: 'We''ve seen that Python''s various classes include those which create mutable
    objects and those which create immutable objects. The immutable classes include
    all of the number classes, strings, bytes, and tuples. The `tuple (247, 83, 148)`
    object cannot be changed: we cannot assign a new value to an item with an index
    of 1\.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，Python的各种类包括创建可变对象和不可变对象的类。不可变类包括所有的数字类、字符串、字节和元组。`tuple (247, 83, 148)`对象不能被更改：我们无法将新值赋给索引为1的项。
- en: 'A `tuple` object has the structure of `Sequence`: we can extract items based
    on their position. However, we cannot change the internal state of a `tuple` object.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`tuple`对象具有`Sequence`的结构：我们可以根据它们的位位置提取项。然而，我们无法改变`tuple`对象的内部状态。'
- en: A `list` is also a subclass of the `Sequence` class. We can, however, change
    the state of a `list` object without creating a new `list` instance.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`也是`Sequence`类的子类。然而，我们可以改变`list`对象的状态，而无需创建新的`list`实例。'
- en: The abstract base class definitions for `Sequence` and `MutableSequence` are
    in the `collections.abc` module. The documentation for this module shows how the
    various complex types relate to each other.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sequence`和`MutableSequence`的抽象基类定义在`collections.abc`模块中。该模块的文档显示了各种复杂类型之间的关系。'
- en: While some of the features of `list` and `tuple` are similar, they address different
    use cases. The benefits of immutability are simplicity, reduced storage demands,
    and higher-performance for some kinds of processing. The benefit mutability is
    that a single object can undergo an internal state change.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`list`和`tuple`的一些功能相似，但它们针对不同的使用场景。不可变性的好处是简单性、减少存储需求以及某些类型处理的高性能。可变性的好处是单个对象可以经历内部状态的变化。
- en: Using the list collection
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用列表集合
- en: 'Python''s `list` collection is its built-in mutable sequence. We can create
    list objects easily using a literal display that simply provides expressions enclosed
    in `[]`. It looks like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`list`集合是其内置的可变序列。我们可以通过使用简单的显示来轻松创建列表对象，该显示仅提供用`[]`括起来的表达式。它看起来是这样的：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As with tuples, the items are identified by their position in the `list` collection.
    Positions are numbered from the left starting from zero. Positions are also numbered
    from the right, using negative numbers. The last value in a list is at position
    -1, the next-to-last value at position -2.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与元组一样，项目通过它们在`list`集合中的位置来识别。位置从左开始编号，从零开始。位置也可以用负数从右编号。列表中的最后一个值在位置-1，倒数第二个值在位置-2。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Index values begin with zero. Index position 0 is the first item. Index values
    can be done in reverse with negative numbers. Index position -1 is the last item.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 索引值从零开始。索引位置0是第一个项目。索引值可以用负数反向进行。列表中的最后一个值在位置-1，倒数第二个值在位置-2。
- en: We can also create lists using the `list()` function. This will convert many
    kinds of collections into `list` objects. Used without arguments, `list()` creates
    an empty `list` just like `[]`. Since the `list()` function is so versatile at
    converting collections into `list` objects, we'll use it much more in later chapters.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`list()`函数来创建列表。这将把许多种类的集合转换为`list`对象。不带参数使用`list()`会创建一个空的`list`，就像`[]`一样。由于`list()`函数在将集合转换为`list`对象方面非常灵活，我们将在后面的章节中更多地使用它。
- en: 'We can update a `list` collection using methods like `append()`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`append()`等方法更新`list`集合：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, the value of `fib_list[-1]` is the last element in the list,
    and `fib_list[-2]` is the penultimate value. The expression creates a new number,
    which can be appended to the `fib_list` object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`fib_list[-1]`的值是列表中的最后一个元素，而`fib_list[-2]`是倒数第二个值。这个表达式创建了一个新数字，可以追加到`fib_list`对象中。
- en: 'We can manipulate a single element in a list using a subscription, such as
    those shown in the previous example. The value in the `[]` must be a single integer,
    which identifies an item in the list. It looks like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用索引来操作列表中的单个元素，例如前一个示例中所示。`[]`中的值必须是一个整数，用于标识列表中的项。它看起来是这样的：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The item in position two (the third item in the list) has a value of 3.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 位置二的项（列表中的第三项）的值为3。
- en: 'We can extract a sublist using slicing notation. A slicing uses a multi-part
    value in the `[]`. The result of a slicing is always a list built from the original
    list object. There are several ways to specify slicings, we''ll show a number
    of examples:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用切片符号提取子列表。切片使用`[]`中的多部分值。切片的结果始终是从原始列表对象构建的列表。有几种指定切片的方法，我们将展示一些示例：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first slicing, `[2:5]`, starts at the index of 2 and stops just before the
    index of 5\. This means that the index values of 2, 3, and 4 are sliced out of
    the original list. Since lists are indexed from zero, an index of 2 is the third
    position in the list. It's essential to think of a slicing as a "half-open" interval.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个切片`[2:5]`从索引2开始，并在索引5之前停止。这意味着2、3和4的索引值被从原始列表中切片出来。由于列表从零开始索引，索引2是列表中的第三个位置。将切片视为“半开”区间是至关重要的。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Most of Python uses "half-open" intervals.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Python使用“半开”区间。
- en: When we write the slice expression `[a:b]`, position *a* is included while position
    *b* is not included. This slice specifies all index values, *i*, such that ![Using
    the list collection](img/B03671_06_01.jpg). There are ![Using the list collection](img/B03671_06_02.jpg)
    values in the slice.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写切片表达式`[a:b]`时，位置*a*是包含的，而位置*b*是不包含的。这个切片指定了所有满足![使用列表集合](img/B03671_06_01.jpg)的索引值*i*。切片中有![使用列表集合](img/B03671_06_02.jpg)个值。
- en: The second slicing, `[2:]`, omits the ending, which means that it starts at
    an index of 2 and includes all items to the end of the list.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个切片`[2:]`省略了结束位置，这意味着它从索引2开始，并包括列表末尾的所有项目。
- en: The third slicing, `[:-1]`, omits the starting position, which means that it
    starts at an index of 0\. The ending is given as -1, the last item in the list.
    Since slicings stop short of the given final position, this slicing will omit
    the last item from the list.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个切片`[:-1]`省略了起始位置，这意味着它从索引0开始。结束位置给出为-1，即列表中的最后一个项目。由于切片在给定的最终位置之前停止，这个切片将省略列表中的最后一个项目。
- en: We can use `[:]` as a degenerate case where the start and end are both omitted.
    This works very well when making a shallow copy of an entire `list` object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`[:]`作为一个退化情况，其中起始和结束都被省略。这在制作整个`list`对象的浅拷贝时非常有效。
- en: 'Slicings can be extended to include a third parameter. This allows us to specify
    a *start*, *stop*, and a *step* value. We can do things like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 切片可以扩展到包括第三个参数。这允许我们指定一个*起始*、*停止*和一个*步长*值。我们可以这样做：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the first example, the start and stop are omitted, so we''ll use the entire
    list. The step value is 2, so we''ll extract a new list using the even-numbered
    indexes: 0, 2, 4, …, and so on.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，省略了起始和停止，所以我们将使用整个列表。步长值是2，所以我们将使用偶数索引提取一个新的列表：0、2、4、……等等。
- en: 'In the second example, we provided a start and a step value. This will begin
    with index 1, and increment by 2\. It will extract a list built from the odd-numbered
    indices: 1, 3, 5, …, and so on.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们提供了一个起始和步长值。这将从索引1开始，每次增加2。它将提取由奇数索引组成的列表：1、3、5、……等等。
- en: We can use a negative step value to visit a list in reverse order. This can
    be confusing, but it works very nicely.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用负步长值以相反的顺序遍历列表。这可能会令人困惑，但它工作得非常好。
- en: List objects have a few operators, including `+` and `*`. We'll also look at
    the various kinds of list assignment statements we can use that involve slicing
    expressions on the left side of the assignment statement. These can mutate a list
    by changing some of the values.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表对象有几个运算符，包括`+`和`*`。我们还将查看我们可以使用的各种列表赋值语句，这些语句涉及赋值语句左侧的切片表达式。这些可以通过改变一些值来改变列表。
- en: Using list operators
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用列表运算符
- en: 'We can use the `+` operator to concatenate two list objects: `[1, 1] + [2,
    3, 5]` for example. If we want to extend a list, we can use this augmented assignment
    statement:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`+`运算符连接两个列表对象，例如`[1, 1] + [2, 3, 5]`。如果我们想扩展列表，我们可以使用这个扩展赋值语句：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that we had to create a singleton `list` collection so that the `+` operator
    would concatenate the new `list` to an existing `list`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不得不创建一个单例`list`集合，这样`+`运算符才能将新的`list`连接到现有的`list`上。
- en: Since a `list` object is mutable, this `+=` assignment will update a `list`
    object; it is extended with the new `list` collection. Contrast this with a `tuple`,
    where a new `tuple` must be created from the two original tuples, and assigned
    to the variable.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`list`对象是可变的，这个`+=`赋值将更新`list`对象；它通过添加新的`list`集合来扩展。这与`tuple`形成对比，在`tuple`中必须从两个原始`tuple`创建一个新的`tuple`，并将其赋给变量。
- en: In [Chapter 5](ch05.html "Chapter 5. Logic, Comparisons, and Conditions"), *Logic,
    Comparisons, and Conditions*, we noted that sequences like `list` and `tuple`
    are compared item-by-item. This means that `[1, 1, 2] < [1, 2]` will be `True`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。逻辑、比较和条件")中，我们注意到像`list`和`tuple`这样的序列是逐项比较的。这意味着`[1, 1,
    2] < [1, 2]`将会是`True`。
- en: 'Lists and other sequences also support the `in` operator. We can ask if a specific
    value is in a `list` collection. We can also confirm that a given value is not
    in a `list` collection. These are simple Boolean expressions that look like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和其他序列也支持`in`运算符。我们可以询问特定值是否在`list`集合中。我们还可以确认给定值是否不在`list`集合中。这些是简单的布尔表达式，看起来像这样：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We've used the `in` operator to confirm that the value 13 is in the `fib_list`
    variable and the value 12 is not in that `list` object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`in`运算符来确认值13在`fib_list`变量中，而值12不在那个`list`对象中。
- en: Mutating a list with subscripts
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用下标修改列表
- en: 'We can change an item in a `list` collection using a subscription or slicing
    on the left side of an assignment statement. A subscription uses `[]` and a single
    integer value to identify an item within a `list`. We can replace an item like
    this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用赋值语句左侧的订阅或切片来更改`list`集合中的项目。订阅使用`[]`和单个整数值来标识列表中的项目。我们可以这样替换一个项目：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will replace the item at index 0 (the first item) with a value of 1\. If
    we mention an index value which is not in the list, an `IndexError` will be raised.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用值1替换索引0（第一个项目）。如果我们提到一个不在列表中的索引值，将会引发`IndexError`。
- en: 'We can replace any simple slice of a list with a different list. The replacement
    list does not have to be the same size. Indeed, it can be an empty list, which
    will effectively remove items from the list. Here''s an example where we mutate
    a long slice by providing a shorter replacement:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用不同的列表替换列表的任何简单切片。替换列表不必与原列表大小相同。实际上，它可以是空列表，这将有效地从列表中删除项目。以下是一个通过提供较短的替换来修改长切片的例子：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ve specified a slicing which contains three items—index values of 2, 3,
    and 4—and replaced these items with a list that has only a single item. The resulting
    list will look like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了一个包含三个项目——索引值2、3和4——的切片，并用只有一个项目的列表替换了这些项目。结果列表将看起来像这样：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Positions 0 and 1 remain untouched. Also positions from 5 to the end of the
    original list are also left untouched.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 位置0和1保持不变。同样，位置从5到原始列表的末尾也保持不变。
- en: We can replace an extended slicing—one that includes a step value—but the replacement
    must be the same size. If we don't provide the proper number of replacement values,
    we'll get a `ValueError` exception.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以替换一个扩展切片——包括一个步长值——但替换的大小必须相同。如果我们没有提供正确的替换值数量，我们将得到一个`ValueError`异常。
- en: Mutating a list with method functions
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用方法函数修改列表
- en: We can mutate a `list` object with any of a large number of method functions.
    The mutator methods of a list almost always return a value of `None`. With the
    exception of the `pop()` method, mutators don't return a meaningful value.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用大量方法函数中的任何一个来修改`list`对象。列表的修改方法几乎总是返回`None`值。除了`pop()`方法外，修改方法不返回有意义的值。
- en: There are also method functions which provide information about a list; these
    must return a value. We'll look at access-only method functions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 还有提供有关列表信息的方法函数；这些函数必须返回一个值。我们将查看只读方法函数。
- en: 'The mutator methods of a list include `append()`, `clear()`, `extend()`, `insert()`,
    `pop()`, `remove()`, `reverse()`, and `sort()`. Here are some examples:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的修改方法包括`append()`、`clear()`、`extend()`、`insert()`、`pop()`、`remove()`、`reverse()`和`sort()`。以下是一些示例：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We've shown our initial list with six items. We extended the list with a second
    list that has two more items, `[21, 34]`. The result is a single list composed
    of the two original lists.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了包含六个项的初始列表。我们使用一个包含两个额外项的第二个列表扩展了列表，即`[21, 34]`。结果是两个原始列表组成的单个列表。
- en: The `insert()` method has a value and a position. In this example, both were
    zero. When we use `help(list.insert)` we see that the index position is the first
    argument value. The value to be inserted before that position is provided as the
    second argument value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()`方法有一个值和一个位置。在这个例子中，两者都是零。当我们使用`help(list.insert)`时，我们看到索引位置是第一个参数值。要插入该位置之前的位置的值作为第二个参数值提供。'
- en: When we remove an item from a list, we provide the item value to remove. For
    very large lists, this may involve a significant amount of time searching for
    the required item.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从列表中移除一个项时，我们提供要移除的项值。对于非常大的列表，这可能涉及大量的时间来搜索所需的项。
- en: The `pop()` method does two things. It removes an item by position, and returns
    that item as the result value. The default position is the last item, -1\. We
    can also remove items from the beginning of a list, using index position 0.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop()`方法做两件事。它通过位置移除一个项，并将该项作为结果值返回。默认位置是最后一个项，-1。我们也可以使用索引位置0从列表的开始移除项。'
- en: We can also use the `del` statement to remove items from a list. The statement
    `del fib_list[0]` will remove the first item from a list.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`del`语句从列表中移除项。语句`del fib_list[0]`将从列表中移除第一个项。
- en: We haven't shown the `reverse()` and `sort()` methods which change the order
    of the items in the list. The `sort()` method can be quite a bit more sophisticated
    than these methods. We'll look into sorting in [Chapter 8](ch08.html "Chapter 8. More
    Advanced Functions"), *More Advanced Functions*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有展示`reverse()`和`sort()`方法，这些方法会改变列表中项的顺序。`sort()`方法可能比这些方法更复杂。我们将在[第8章](ch08.html
    "第8章。更高级的功能")*更高级的功能*中探讨排序。
- en: We didn't give an example of the `clear()` method. This removes all of the items
    from the list.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有给出`clear()`方法的示例。这个方法会从列表中移除所有项。
- en: Note that, with the exception of `pop()`, we must explicitly request a display
    of the `fib_list` object to see any output from Python's REPL. These mutator methods
    only return a value of `None`. It's too common a mistake to see `a = a.append(x)`;
    this statement always sets the variable `a` to `None`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了`pop()`之外，我们必须明确请求显示`fib_list`对象，才能看到Python的REPL的任何输出。这些修改方法只返回`None`值。看到`a
    = a.append(x)`是一个常见的错误；这个语句总是将变量`a`设置为`None`。
- en: Accessing a list
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问列表
- en: As shown previously, we can access a list using a subscription as well as a
    slicing. A subscription gives us a single item. A slicing, on the other hand,
    makes a shallow copy of the items in the original list.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以使用索引或切片来访问列表。索引给我们一个单独的项。另一方面，切片会创建原始列表中项的浅拷贝。
- en: 'The method functions for accessing a list include `count()`, `index()`, and
    `copy()`. Here are some examples to show how these functions work:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 访问列表的方法函数包括`count()`、`index()`和`copy()`。以下是一些示例，以展示这些函数的工作方式：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `count()` method counts all the items which are equal to the given value.
    In this case, there were two items equal to 1 in the list. If the given value
    is not found in the list, the count will be zero.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`count()`方法计算所有与给定值相等的项的数量。在这种情况下，列表中有两个值等于1。如果给定值在列表中找不到，计数将为零。'
- en: The `index()` method locates the given item value, and returns the index position
    of that value in the list. If the value does not exist, a `ValueError` exception
    is raised.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`index()`方法定位给定的项值，并返回该值在列表中的索引位置。如果该值不存在，将引发`ValueError`异常。'
- en: The `copy()` method of a list object does the same thing as the empty slicing.
    The expressions, `fib_list[:]` and `fib_list.copy()`, are both copies of the original
    list.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表对象的`copy()`方法与空切片做同样的事情。表达式`fib_list[:]`和`fib_list.copy()`都是原始列表的副本。
- en: Using collection functions
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用集合函数
- en: Python offers a number of functions which work with any kind of collection.
    These include `sorted()`, `max()`, `min()`, and `sum()`. We also have some higher-order
    functions, `map()`, `filter()`, and the entire `itertools` module. We'll address
    additional higher-order functions in [Chapter 8](ch08.html "Chapter 8. More Advanced
    Functions"), *More Advanced Functions*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一系列与任何类型的集合一起工作的函数。这些包括`sorted()`、`max()`、`min()`和`sum()`。我们还有一些高阶函数，如`map()`、`filter()`以及整个`itertools`模块。我们将在[第8章](ch08.html
    "第8章。更高级的函数")中讨论更多的高阶函数，*更高级的函数*。
- en: The `sorted()` function returns a sorted list from a collection. It transforms
    the given collection into a `list` collection as part of the sorting process.
    If the collection doesn't define the proper iterator methods, it can't be easily
    sorted by using this function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted()`函数从集合中返回一个排序后的列表。在排序过程中，它将给定的集合转换为`list`集合。如果集合没有定义适当的迭代方法，则无法使用此函数轻松排序。'
- en: 'The `max()` and `min()` functions reduce a collection to a single value: either
    the largest or the smallest value in the collection. This reduction presumes that
    the items can be meaningfully compared. Consider a `tuple` that has mixed values
    in it:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()`和`min()`函数将集合简化为单个值：集合中的最大值或最小值。这种简化假设项目可以有意义地比较。考虑一个包含混合值的`tuple`：'
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can't meaningfully evaluate `max()` or `min()` on a collection of mixed values
    like this. The functions will be forced to compare a tuple of numbers against
    a string. This will raise a `TypeError` exception.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法有意义地评估这种混合值集合的`max()`或`min()`。函数将被迫比较一个数字元组与一个字符串。这将引发`TypeError`异常。
- en: 'The `sum()` function reduces a collection of numbers to a single value. It
    can be used on almost any kind of object that implements the `+` operator; we
    can amalgamate a list of lists to create a very long list. Here''s an example
    of using these collection functions with a simple `set` object:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum()`函数将数字集合简化为单个值。它可以用于几乎任何实现了`+`操作符的对象；我们可以合并一个列表的列表来创建一个非常长的列表。以下是一个使用这些集合函数与简单的`set`对象一起使用的示例：'
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We've created a set with four integers in it. When we evaluate the `sorted()`
    function, we get a `list` object which contains the items sorted into ascending
    order. When we evaluate `max()` or `min()` functions, we get the largest or smallest
    value in the collection. The `sum()` function adds up the values in the set collection.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个包含四个整数的集合。当我们评估`sorted()`函数时，我们得到一个包含按升序排序的项的`list`对象。当我们评估`max()`或`min()`函数时，我们得到集合中的最大值或最小值。`sum()`函数将集合中的值相加。
- en: Using the set collection
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用集合
- en: 'All of the collections we''ve looked at previously have been sequences: `str`,
    `bytes`, `tuple`, and `list` have items which can be accessed by their position
    within the collection. A `set` collection is an unordered collection where items
    are present or absent.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前查看的所有集合都已经是序列：`str`、`bytes`、`tuple`和`list`都有可以通过其在集合中的位置访问的项。`set`集合是一个无序集合，其中项是存在或不存在。
- en: Items in a `set` collection must be immutable; they must provide a proper hash
    value as well as an equality test. This means that we can create sets of numbers,
    strings, and tuples. We can't easily create a set of lists or a set of sets.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`集合中的元素必须是不可变的；它们必须提供适当的哈希值以及等价性测试。这意味着我们可以创建包含数字、字符串和元组的集合。我们无法轻松地创建包含列表或集合的集合。'
- en: The syntax of a `set` display is a sequence of expressions wrapped in `{}`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`显示的语法是一系列用`{}`括起来的表达式。'
- en: 'Here''s an example `set` built using numbers:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用数字构建的示例`set`：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We've created a `set` object by enclosing the values in `{}`. This syntax looks
    very similar to the syntax for creating `list` or `tuple`. Note that the elements
    in the `set` collection are displayed in a different order. There's no guarantee
    what the order will be; different implementations may show different orders.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将值包围在 `{}` 中创建了一个 `set` 对象。这种语法与创建 `list` 或 `tuple` 的语法非常相似。请注意，`set` 集合中的元素显示的顺序不同。顺序没有保证；不同的实现可能显示不同的顺序。
- en: It's important to note that we tried to include two instances of the integer
    1 in the `set` collection. Since an item is either present in the `set` collection
    or absent, the item cannot be included a second time. Duplicate items are silently
    ignored.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们试图在 `set` 集合中包含两个整数 1 的实例。由于一个项目要么存在于 `set` 集合中，要么不存在，因此项目不能被包含第二次。重复的项目会被静默忽略。
- en: 'We can also create a `set` collection by applying the `set()` function to a
    collection of values. We can create a `set` collection from a `list` or `tuple`
    collection. We can also create a `set` collection from a simple string: each individual
    character will become an item in the resulting set. We can use `set([1, 1, 3,
    5, 8])` to apply the `set()` function to a literal list object.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过将 `set()` 函数应用于值集合来创建一个 `set` 集合。我们可以从一个 `list` 或 `tuple` 集合中创建一个 `set`
    集合。我们还可以从一个简单的字符串中创建一个 `set` 集合：每个单独的字符将成为结果集合中的一个项目。我们可以使用 `set([1, 1, 3, 5,
    8])` 来将 `set()` 函数应用于一个字面列表对象。
- en: The syntax `{}`, interestingly, does not create an empty `set`. This actually
    creates an empty `dict` class. To create an empty `set`, we must use the `set()`
    function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，语法 `{}` 并不创建一个空的 `set`。这实际上创建了一个空的 `dict` 类。要创建一个空的 `set`，我们必须使用 `set()`
    函数。
- en: 'We have a fairly large number of operators for set objects. In addition to
    the operators, we also have a large number of method functions. These can be categorized
    as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为集合对象提供了相当多的运算符。除了运算符之外，我们还有大量的方法函数。这些可以按以下方式分类：
- en: '**Mutators**: These modify a `set` object'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修改器**：这些修改 `set` 对象'
- en: '**Accessors**: These access a list and return a fact about that `set` object.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问器**：这些访问列表并返回关于该 `set` 对象的事实。'
- en: The mutator methods of a `set` collection almost always return a value of `None`.
    With the exception of the `pop()` method, mutators don't return a value. The accessors,
    which provide information about a list, must return a value. We'll look at the
    operators first.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 集合的修改方法几乎总是返回 `None` 的值。除了 `pop()` 方法外，修改方法不返回值。提供列表信息的访问器必须返回一个值。我们首先看看运算符。'
- en: Using set operators
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用集合运算符
- en: Sets have a large number of operators which closely parallel mathematical operators
    for sets. The mapping leverages the bit-oriented operators; it interprets them
    to mean set membership instead of bits in an integer value.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 集合有许多运算符，这些运算符与数学运算符非常相似。映射利用了位运算符；它将它们解释为集合成员资格而不是整数值中的位。
- en: 'We have the following operators: `|`, `&`, `-`, and `^`, which stand for union
    (![Using set operators](img/B03671_06_03.jpg)), intersection (![Using set operators](img/B03671_06_04.jpg)),
    difference (![Using set operators](img/B03671_06_05.jpg)), and symmetric difference
    (![Using set operators](img/B03671_06_06.jpg)).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下运算符：`|`、`&`、`-` 和 `^`，分别代表并集 ![使用集合运算符](img/B03671_06_03.jpg)、交集 ![使用集合运算符](img/B03671_06_04.jpg)、差集
    ![使用集合运算符](img/B03671_06_05.jpg) 和对称差集 ![使用集合运算符](img/B03671_06_06.jpg)。
- en: 'Examples of these two sets are:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个集合的例子如下：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Each set is built by splitting a string into individual space-separated words.
    The results contain the proper elements; the order, however, may vary. Here are
    examples of each of the operators:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集合都是通过将字符串分割成单独的空格分隔的单词来构建的。结果包含正确的元素；然而，顺序可能会变化。以下是每个运算符的示例：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The union operator creates a new set with elements that are drawn from both
    sets. We could say that the union of `a | b` creates a set of elements, {*x*},
    where each element is either an element of *a* **or** an element of *b*. There's
    a tidy parallel between the concept of the Boolean **or** operator and the set
    union.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 并集运算符创建了一个新的集合，其中的元素来自两个集合。我们可以说 `a | b` 的并集创建了一个包含元素的集合，{*x*}，其中每个元素要么是 *a*
    的元素 **或者** 是 *b* 的元素。布尔 **或** 运算符的概念与集合并集之间有一个整洁的平行关系。
- en: The intersection operator, `a & b`, finds the items which are an element of
    *a* **and** an element of *b*. Again, there's a close parallel between the Boolean
    **and** operator and set intersection.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 交集运算符 `a & b` 找到既是 *a* 的元素又是 *b* 的元素。再次强调，布尔 **与** 运算符与集合交集之间有一个紧密的平行关系。
- en: The set difference operator will remove items from the left set which are in
    the right set. We could say that the resulting elements are elements of *a* and
    not elements of *b*. There's no commonly-used Boolean operator which parallels
    the definition of set difference.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 集合差集运算符将从左侧集合中移除右侧集合中的项目。我们可以这样说，结果元素是*a*的元素而不是*b*的元素。没有常用的布尔运算符与集合差集的定义相对应。
- en: The symmetric difference operators are the items unique to both sets; the common
    items have been removed. This corresponds to the **exclusive or** Boolean operation.
    We could say that the result is members of *a* or members of *b* but not members
    of both sets.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对称差集运算符是两个集合中独有的项目；公共的项目已被移除。这对应于**异或**布尔运算。我们可以这样说，结果是属于*a*或属于*b*但不属于两个集合中的成员。
- en: Mutating a set with method functions
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用方法函数突变集合
- en: 'Sets have some mutators which parallel those of a `list` collection. These
    methods include `add()`, `remove()`, `discard()`, and `clear()`. Since the methods
    are mutators, they do not return a useful value. The `add()` method parallels
    `list.append()`: it adds a single item to the set.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 集合有一些突变函数与`list`集合的突变函数平行。这些方法包括`add()`、`remove()`、`discard()`和`clear()`。由于这些方法是突变函数，它们不会返回有用的值。`add()`方法与`list.append()`平行：它向集合中添加一个单独的项目。
- en: The `remove()` and `discard()` methods will remove an item from a set; the `remove()`
    method will raise an exception if the item is not in the set, the `discard()`
    method always succeeds, even if the item is not in the set. The `clear()` method
    discards all items from the set.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()`和`discard()`方法将从集合中移除一个项目；如果项目不在集合中，`remove()`方法将引发异常，而`discard()`方法总是成功，即使项目不在集合中。`clear()`方法将丢弃集合中的所有项目。'
- en: 'We can, for example, update our `fib_set` variable like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以这样更新我们的`fib_set`变量：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We've located the largest value in the set, and assigned this to the `f_n` variable.
    We used the set difference operator to create a new set without the maximum value.
    When we evaluate `max()` on this new set, we'll get the next-to-largest value.
    Finally, we mutated the set with the `add()` method to insert a value into the
    set.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经找到了集合中的最大值，并将其分配给`f_n`变量。我们使用了集合差集运算符来创建一个不包含最大值的新的集合。当我们对这个新集合使用`max()`函数时，我们会得到次大的值。最后，我们使用`add()`方法突变集合以向集合中插入一个值。
- en: 'The set difference operator, `-`, does not mutate the set: like all arithmetic
    operators, it creates a new object from the operands. The `add()` method, however,
    does mutate the given set.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 集合差集运算符`-`不会改变集合：像所有算术运算符一样，它从操作数创建一个新的对象。然而，`add()`方法会改变给定的集合。
- en: Note that Fibonacci numbers aren't the best use of a `set` collection. The first
    two Fibonacci numbers are both one.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，斐波那契数并不是`set`集合的最佳用途。前两个斐波那契数都是1。
- en: The `pop()` method is unique; it is a mutator which also returns a value. The
    value popped from the set will be selected arbitrarily. There's no easy way to
    predict which item will be removed and returned.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop()`方法独特；它是一个既会突变又会返回值的突变函数。从集合中弹出的值将被任意选择。没有简单的方法可以预测哪个项目将被移除并返回。'
- en: 'Each of the operators has a method function that matches the operator. The
    following operators: `|`, `&`, `-`, and `^` correspond to the `update()`, `intersection()`,
    `difference()`, and `symmetric_difference()` methods. We can write `a | b` or
    we can write `a.update(b)`. Both have the same results.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运算符都有一个与运算符匹配的方法函数。以下运算符：`|`、`&`、`-`和`^`对应于`update()`、`intersection()`、`difference()`和`symmetric_difference()`方法。我们可以写`a
    | b`，或者我们可以写`a.update(b)`。两者都有相同的结果。
- en: Using augmented assignment with sets
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用扩展赋值与集合
- en: 'The augmented assignment statements also work well with sets. We can use `|=`,
    `&=`, `-=`, and `^=`, to update a set based on elements from another set. For
    example, consider this statement:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展赋值语句也与集合很好地工作。我们可以使用`|=`, `&=`, `-=`, 和 `^=`来根据另一个集合中的元素更新一个集合。例如，考虑这个语句：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `words` set will be mutated to include all the items from the `more` set.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`words`集合将被突变以包含`more`集合中的所有项目。'
- en: Each of the augmented assignment statements also has a corresponding update
    method. The method names for these mutators are `update()`, `intersection_update()`,
    `difference_update()`, and `symmetric_difference_update()`. These methods are
    mutators which match the augmented assignment statements.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每个扩展赋值语句都有一个相应的更新方法。这些突变函数的方法名是`update()`、`intersection_update()`、`difference_update()`和`symmetric_difference_update()`。这些方法是突变函数，与扩展赋值语句相匹配。
- en: Accessing a set with operators and method functions
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用运算符和方法函数访问集合
- en: There are a few operators which count as set accessors. Perhaps the most fundamental
    method for accessing a set is the `in` operator; this will check to see if a particular
    element exists in a set.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个算子可以算作集合访问器。也许访问集合最基本的方法是`in`运算符；这将检查特定元素是否存在于集合中。
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The comparison operators for sets implement basic set theory operations. When
    we use `<`, `<=`, `>`, or `>=` between two sets, we''re doing subset and superset
    comparisons. For example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的比较运算符实现了基本的集合理论操作。当我们使用`<`、`<=`、`>`或`>=`在两个集合之间时，我们正在进行子集和超集比较。例如：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the first case, the set `{'I'}` is a proper subset of the set in the words
    variable. In the second case, the improper subset comparison was `True`, because
    the two sets are actually equal.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，集合`{'I'}`是`words`变量中集合的一个真子集。在第二种情况下，不正确的子集比较是`True`，因为这两个集合实际上是相等的。
- en: We also have method functions that match the various comparison operators. We
    can use `isdisjoint()`, `issubset()`, and `issuperset()` in addition to the `!=`,
    `<`, and `>` operators.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有与各种比较运算符匹配的方法函数。我们可以使用`isdisjoint()`、`issubset()`和`issuperset()`，以及`!=`、`<`和`>`运算符。
- en: There's little practical difference between `item in set` and `{item} <= set`.
    It's also true that `set–{item} != set` would be true when the given `item` is
    in the `set`. These mathematical equivalences are interesting, but often involve
    extra computation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`item in set`和`{item} <= set`之间几乎没有实际区别。当给定的`item`在`set`中时，`set–{item} != set`也会成立。这些数学等价性很有趣，但通常涉及额外的计算。
- en: Mappings
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: Python has a number of mapping collections. A mapping is an association between
    a key and a value. The built-in mapping collection is the `dict` class. The other
    mappings are defined in the `collections` library, and must be imported.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Python有几个映射集合。映射是键和值之间的关联。内置的映射集合是`dict`类。其他映射在`collections`库中定义，并且必须导入。
- en: Items that are keys within a mapping must be immutable; they must provide a
    proper hash value as well as a matching equality test. The values within a mapping
    have no restrictions; they can be mutable or immutable. The order of the keys
    is not maintained by the `dict` class.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 映射中的键必须是不可变的；它们必须提供适当的哈希值以及匹配的相等性测试。映射中的值没有限制；它们可以是可变的或不可变的。键的顺序由`dict`类不维护。
- en: We can create a simple `dict` display using `{}`; each key and value are separated
    by the `:` character.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`{}`创建一个简单的`dict`显示；每个键和值都由冒号`:`字符分隔。
- en: 'Here''s an example of a simple mapping:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单映射的例子：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We've created a simple mapping with keys that are all integers, and values which
    are a mixture of Boolean and `None` values.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的映射，其键都是整数，值是布尔值和`None`值的混合。
- en: 'We can also create a dictionary using the `dict()` function. This function
    can build a dictionary from a variety of sources. We can provide an existing dictionary
    as an argument; the `dict()` function will make a shallow copy of that source
    dictionary. We can provide a sequence of `(key, value)` two-tuples. It would look
    like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`dict()`函数创建字典。这个函数可以从各种来源构建字典。我们可以提供一个现有的字典作为参数；`dict()`函数将制作该源字典的浅拷贝。我们可以提供一个`(key,
    value)`二元组的序列。它看起来像这样：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This example created a dictionary from a list of `(key, value)` two-tuples.
    The resulting dictionary object that's created will match the literal display
    shown in the preceding example.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子从一个`(key, value)`二元组列表中创建了一个字典。创建的字典对象将与前面示例中显示的文本显示相匹配。
- en: We can also create dictionaries with string keys using the `dict()` function.
    When we provide keyword arguments, they become the keys.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`dict()`函数创建具有字符串键的字典。当我们提供关键字参数时，它们成为键。
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It's important to repeat the observation that the order of the keys in a built-in
    `dict` object is not defined.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要重复指出，内置`dict`对象中键的顺序是没有定义的。
- en: 'We can also build a dictionary from a set of keys, providing a single default
    value. We can do this as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从一个键集合中构建一个字典，提供一个默认值。我们可以这样做：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We've used the `range()` function to iterate through a series of numbers which
    start with two and end just before ten. These numbers are then used to create
    keys for a dictionary. The value associated with each key is the default of `None`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了`range()`函数来遍历一系列从2开始，到10之前结束的数字。这些数字随后被用来为字典创建键。与每个键关联的值是`None`的默认值。
- en: Using dictionary operators
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字典运算符
- en: 'All Python mappings, including the built-in `dict`, use a key in [] to get,
    set, and delete items. The syntax looks like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Python映射，包括内置的`dict`，都使用[]中的键来获取、设置和删除项。语法看起来像这样：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We've provided literal strings to show how we can get an item, set an item,
    and use the `del` statement to delete an item.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了字面字符串来展示如何获取一个项，设置一个项，以及使用`del`语句删除一个项。
- en: Note that dictionary comparisons are difficult to define in a general way. It's
    not perfectly clear if an ordering comparison should compare only the keys, only
    the values, or a combination of keys and values. Consequently, only `==` and `!=`
    comparisons among dictionaries are defined.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在一般意义上定义字典比较是困难的。不清楚顺序比较应该只比较键，只比较值，还是键和值的组合。因此，只有定义了字典之间的`==`和`!=`比较。
- en: Using dictionary mutators
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字典修改器
- en: We can use `dict[key]` on the left side of an assignment statement to modify
    a dictionary. This will insert the given key and value if the key does not exist;
    if the key already exists, it will change the value associated with the key.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在赋值语句的左侧使用`dict[key]`来修改字典。如果键不存在，这将插入给定的键和值；如果键已经存在，它将更改与该键关联的值。
- en: We also have a number of methods that we can use to mutate a dictionary object.
    These methods include `clear()`, `pop()`, `popitem()`, `setdefault()`, and `update()`
    to modify a dictionary object.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有许多可以用来修改字典对象的方法。这些方法包括`clear()`、`pop()`、`popitem()`、`setdefault()`和`update()`来修改字典对象。
- en: The `clear()` and `update()` methods don't return a useful value. The `clear()`
    method will empty the dictionary. The `update()` method will fold additional data
    into an existing dictionary. This method will accept the same variety of arguments
    as the `dict()` function that creates a dictionary. The first positional argument
    can be a dictionary object or a sequence of `(key, value)` two-tuples. Additionally,
    we can provide any number of keyword arguments; the keywords will become keys
    in the updated dictionary.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`clear()`和`update()`方法不返回有用的值。`clear()`方法将清空字典。`update()`方法将额外数据折叠到现有字典中。此方法可以接受与创建字典的`dict()`函数相同的各种参数。第一个位置参数可以是字典对象或`(key,
    value)`二元组的序列。此外，我们可以提供任意数量的关键字参数；关键字将成为更新字典中的键。'
- en: 'Here are two examples that show some of the different ways in which the `update()`
    method can be used:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个示例，展示了`update()`方法可以使用的不同方式：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We've updated the `cadaeic` dictionary object using another dictionary with
    two items. Then we applied further updates using a sequence of `(key, value)`
    two-tuples. The second example also included an additional keyword argument, which
    inserted the key `'weary'` into the dictionary.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用另一个包含两个条目的字典更新了`cadaeic`字典对象。然后我们使用一系列`(key, value)`二元组来应用进一步的更新。第二个示例还包括了一个额外的关键字参数，它将键`'weary'`插入到字典中。
- en: The `setdefault()` method function is an interesting special case. This is a
    variation on the `get()` accessor. The `get()` method (and the `pop()` method)
    has a provision for a default value. The `setdefault()` method doesn't merely
    return the default value if the key is missing—paralleling what `get()` does.
    The `setdefault()` method updates the dictionary to be sure that the default value
    is now in the dictionary. All subsequent `setdefault()` or `get()` methods will
    find the key in the dictionary.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`setdefault()`方法函数是一个有趣的特殊情况。这是`get()`访问器的变体。`get()`方法（以及`pop()`方法）有一个默认值的条款。`setdefault()`方法不仅仅在键缺失时返回默认值——类似于`get()`的行为。`setdefault()`方法更新字典以确保默认值现在在字典中。所有随后的`setdefault()`或`get()`方法都将找到字典中的键。'
- en: 'The sequence of operations might look something like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 操作序列可能看起来像这样：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We've created an empty dictionary and assigned it to the `counter` variable.
    When we use `counter.setdefault('a',0)`, we'll get the value associated with a
    key of `'a'`, or we'll get the default value of zero. In addition to returning,
    the default value will also be used to update the dictionary, assuring that there
    is a value associated with the given key.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个空字典并将其分配给`counter`变量。当我们使用`counter.setdefault('a',0)`时，我们将得到与键`'a'`关联的值，或者我们将得到默认值零。除了返回之外，默认值还将用于更新字典，确保给定的键有一个关联的值。
- en: We can then do a simple, easy-to-understand `counter['a'] += 1` knowing that
    the key, `'a'`, has a value in the dictionary. Either the key already existed,
    and the `setdefault()` function did nothing or the key did not exist, and the
    `setdefault()` function provided that default value.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行一个简单、易于理解的`counter['a'] += 1`操作，知道键`'a'`在字典中有一个值。要么键已经存在，`setdefault()`函数没有做任何事情，要么键不存在，`setdefault()`函数提供了那个默认值。
- en: 'Since `setdefault()` returns a value, we can optimize this into something like
    this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`setdefault()`返回一个值，我们可以将其优化为类似以下内容：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This `setdefault()` process is so common that there are two closely-related
    classes in `collections`. The `defaultdict` class simply treats all `get()` operations
    like `setdefault()`. The `Counter` class will implicitly do the `count[key]+=1`
    process for any iterable, building on the `defaultdict` class.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`setdefault()`过程非常常见，因此在`collections`中有两个密切相关类。`defaultdict`类简单地将所有`get()`操作视为`setdefault()`。`Counter`类将隐式地对任何可迭代对象执行`count[key]+=1`过程，基于`defaultdict`类。
- en: There are two variations on the `pop()` method. The typical implementation of
    `pop()` will remove a given key and return the value associated with that key.
    Beyond this, the `popitem()` method will remove and return one `(key, value)`
    pair from a dictionary. The pair will be chosen arbitrarily. In both cases, the
    dictionary is updated to remove the value.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop()`方法有两种变体。典型的`pop()`实现将删除指定的键并返回与该键关联的值。除此之外，`popitem()`方法将从一个字典中删除并返回一个`(key,
    value)`对。这对将被任意选择。在这两种情况下，字典都会更新以删除值。'
- en: Using methods for accessing items in a mapping
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用访问映射中项的方法
- en: We have a number of methods to access items in a mapping. First and foremost,
    we have the `dict[key]` construct which locates the value associated with the
    given key. If the key does not exist, the `KeyError` exception is raised.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法可以访问映射中的项。首先，我们有一个`dict[key]`构造，它定位与给定键关联的值。如果键不存在，将引发`KeyError`异常。
- en: The `get()` method will also return the value associated with a key in the dictionary.
    The `get()` method can also provide a default value. We can use `cadaeic.get("word",4)`
    to locate the key (`"word"` in this example). If the key is not found the default,
    `4`, is returned.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`方法也会返回字典中与键关联的值。`get()`方法还可以提供一个默认值。我们可以使用`cadaeic.get("word",4)`来定位键（在这个例子中是`"word"`）。如果找不到键，则返回默认值`4`。'
- en: The `copy()` method returns a shallow copy of the dictionary. We can do `a=dict(d)`
    or `a= d.copy()` to make a new dictionary, which is a copy of an original dictionary.
    Both are equivalent.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy()`方法返回字典的浅拷贝。我们可以通过`a=dict(d)`或`a= d.copy()`来创建一个新的字典，它是原始字典的副本。两者是等效的。'
- en: 'There are three methods which expose important features of a mapping:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法可以公开映射的重要功能：
- en: '`keys()` is the sequence of keys from the mapping. By default, this is used
    when converting a mapping to another collection. If we use `set(cadaeic)` or `list(cadaiec)`,
    we''ll see just the key values in the set or list object. The value of `sorted(cadaeic)`
    is the same as `sorted(cadaeic.keys())`.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keys()`是从映射中获取的键序列。默认情况下，在将映射转换为另一个集合时使用。如果我们使用`set(cadaeic)`或`list(cadaeic)`，我们将看到集合或列表对象中仅有的键值。`sorted(cadaeic)`的值与`sorted(cadaeic.keys())`相同。'
- en: '`values()` is the sequence of values from the mapping.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values()`是从映射中获取的值序列。'
- en: '`items()` is the sequence of `(key, value)` pairs from the mapping. This list
    of two-tuples can be used to rebuild the dictionary. If we use `tuple(cadaeic.items())`,
    we''ve created a tuple of two-tuples. This tuple is immutable, and can be used
    as a key to another mapping or as an item in a set. This is a way of "freezing"
    a dictionary to create an immutable copy.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`items()`是从映射中获取的`(key, value)`对序列。这个由两个元组组成的列表可以用来重建字典。如果我们使用`tuple(cadaeic.items())`，我们就创建了一个两个元组的元组。这个元组是不可变的，可以用作另一个映射的键或集合中的项。这是一种“冻结”字典以创建不可变副本的方法。'
- en: Using extensions from the collections module
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`collections`模块的扩展
- en: 'The *Python Standard Library* includes the `collections` module. This module
    offers us a number of alternatives to the built-in collections. This module has
    the following additional collections:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python标准库*包括`collections`模块。此模块为我们提供了对内置集合的多种替代方案。此模块具有以下附加集合：'
- en: We can import the `namedtuple` function and use this to create variations on
    the basic `tuple` that includes named attributes in addition to attributes identified
    by their positional index.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以导入`namedtuple`函数并使用它来创建基于基本`tuple`的变体，该变体包括除了通过位置索引识别的属性之外还有命名属性。
- en: The `deque` class defines a double-ended queue, like a `list` collection that
    can perform fast `append()` and `pop()` functions on either end. A subset of the
    features of this class will create single-ended stack (LIFO) or queue (FIFO) structures.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deque`类定义了一个双端队列，类似于可以快速在两端执行`append()`和`pop()`函数的`list`集合。这个类的一些功能可以创建单端栈（后进先出，LIFO）或队列（先进先出，FIFO）结构。'
- en: In some cases, we can use a `ChainMap` instead of merging mappings, via `update()`.
    The result is a view of multiple mappings rather than a single, updated mapping.
    This can be built very quickly; a search takes longer than a single mapping.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可以使用`ChainMap`而不是通过`update()`合并映射。结果是多个映射的视图，而不是单个更新后的映射。这可以非常快速地构建；搜索比单个映射要长。
- en: An `OrderedDict` mapping is a mapping which maintains the order in which the
    keys were created.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderedDict`映射是一个维护键创建顺序的映射。'
- en: The `defaultdict` class is a subclass of the built-in `dict` that uses a factory
    function to provide values for missing keys.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultdict`类是内置`dict`的子类，它使用工厂函数为缺失的键提供值。'
- en: The `Counter` class is a `dict` subclass that counts objects to create frequency
    tables. It is also used as a more sophisticated data structure called a multiset
    or bag.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Counter`类是一个`dict`子类，用于计数对象以创建频率表。它也被用作更复杂的数据结构，称为多重集或包。'
- en: 'We can create letter frequencies using a `Counter` class quite simply. A `Counter`
    will count the occurrences of items in the sequence. Given a string, which is
    an iterable sequence of characters, creating a `Counter` leads directly to a frequency
    table. Here''s an example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Counter`类非常简单地创建字母频率。`Counter`会计算序列中项的出现次数。给定一个字符串，它是一个字符的可迭代序列，创建一个`Counter`可以直接得到一个频率表。以下是一个示例：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We've imported the `Counter` class from the `collections` module. We've also
    set a variable, `text`, to a piece of a poem by Mike Keith. For more of this poem,
    see [http://www.cadaeic.net/naraven.htm](http://www.cadaeic.net/naraven.htm).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已从`collections`模块中导入了`Counter`类。我们还设置了一个变量`text`，它包含迈克·基思的一首诗的一部分。要了解更多关于这首诗的信息，请参阅[http://www.cadaeic.net/naraven.htm](http://www.cadaeic.net/naraven.htm)。
- en: We created a `Counter` object using the string of characters as the source.
    A `Counter` object will iterate through each item in the sequence, counting the
    number of occurrences of that item. When we use the `most_common()` method, we'll
    see the five most common items in the collection. If we were to simply print the
    value of the `freq` variable, we'd see all of the character frequencies.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用字符串作为来源创建了一个`Counter`对象。`Counter`对象将遍历序列中的每个项，计算该项的出现次数。当我们使用`most_common()`方法时，我们将看到集合中最常见的五个项。如果我们简单地打印`freq`变量的值，我们将看到所有字符的频率。
- en: Each of these collections offers unique features. If the built-in `dict`, `list`,
    or `tuple` doesn't meet our needs, one of these additional collections may be
    more suitable for the problem we're tying to solve.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些集合中的每一个都提供了独特的功能。如果内置的`dict`、`list`或`tuple`不能满足我们的需求，这些额外的集合中可能有一个更适合我们试图解决的问题。
- en: Processing collections with the for statement
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`for`语句处理集合
- en: The `for` statement is an extremely versatile way to process every item in a
    collection. We do this by defining a target variable, a source of items, and a
    suite of statements. The `for` statement will iterate through the source of items,
    assigning each item to the target variable, and also execute the suite of statements.
    All of the collections in Python provide the necessary methods, which means that
    we can use *anything* as the source of items in a `for` statement.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句是一种非常灵活的方式来处理集合中的每个项。我们通过定义一个目标变量、项的来源和一系列语句来实现这一点。`for`语句将遍历项的来源，将每个项分配给目标变量，并执行一系列语句。Python中的所有集合都提供了必要的方法，这意味着我们可以将*任何东西*用作`for`语句中项的来源。'
- en: 'Here''s some sample data that we''ll work with. This is part of Mike Keith''s
    poem, *Near a Raven*. We''ll remove the punctuation to make the text easier to
    work with:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们将要处理的示例数据。这是迈克·基思的诗《近乌鸦》的一部分。我们将移除标点符号，以便更容易处理文本：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This will put the original text, with uppercase and lowercase and punctuation
    into the `text` variable. We used some method functions from [Chapter 2](ch02.html
    "Chapter 2. Simple Data Types"), *Simple Data Types*, to remove the common punctuation
    marks and return a version of the entire string entirely composed of lowercase
    letters.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把原始文本（包括大写、小写和标点符号）放入 `text` 变量中。我们使用了 [第 2 章](ch02.html "第 2 章。简单数据类型") 中的一些方法函数，*简单数据类型*，来删除常见的标点符号，并返回一个完全由小写字母组成的整个字符串版本。
- en: 'When we use `text.split()`, we get a sequence of individual words. The `for`
    loop can iterate through this sequence of words so that we can process each one.
    The syntax looks like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `text.split()` 时，我们得到一系列单独的单词。`for` 循环可以遍历这个单词序列，以便我们可以逐个处理。语法看起来像这样：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We've created an empty dictionary, and assigned it to the `cadaeic` variable.
    The expression in the `for` loop, `text.split()`, will create a sequence of substrings.
    Each of these substrings will be assigned to the `word` variable. The `for` loop
    body—a single assignment statement—will be executed once for each value assigned
    to `word`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个空字典，并将其分配给 `cadaeic` 变量。`for` 循环中的表达式 `text.split()` 将创建一个子字符串序列。这些子字符串中的每一个都将分配给
    `word` 变量。`for` 循环体——一个单独的赋值语句——将为分配给 `word` 的每个值执行一次。
- en: 'The resulting dictionary might look like this (irrespective of ordering):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 结果字典可能看起来像这样（不考虑顺序）：
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There's no guaranteed order for mappings or sets. Your results may differ slightly.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 映射或集合没有保证的顺序。你的结果可能会有所不同。
- en: In addition to iterating over a sequence, we can also iterate over the keys
    in a dictionary.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 除了遍历序列之外，我们还可以遍历字典中的键。
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When we use `sorted()` on a `tuple` or a `list`, an interim list is created
    with sorted items. When we apply `sorted()` to a mapping, the sorting applies
    to the keys of the mapping, creating a sequence of sorted keys. This loop will
    print a list in alphabetical order of the various *pilish* words used in this
    poem.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 `tuple` 或 `list` 上使用 `sorted()` 时，会创建一个包含排序项的临时列表。当我们对映射应用 `sorted()` 时，排序应用于映射的键，创建一个排序键的序列。这个循环将按字母顺序打印出这首诗中使用的各种
    *pilish* 单词的列表。
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Pilish is a subset of English where the word lengths are important: they''re
    used as mnemonic aids.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Pilish 是英语的一个子集，其中单词长度很重要：它们被用作记忆辅助工具。
- en: A `for` statement corresponds to the "for all" logical quantifier, ![Processing
    collections with the for statement](img/B03671_06_12.jpg). At the end of a simple
    `for` loop we can assert that all items in the source collection have been processed.
    In order to build the "there exists" quantifier, ![Processing collections with
    the for statement](img/B03671_06_13.jpg), we can either use the `while` statement,
    or the `break` statement inside the body of a `for` statement.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 语句对应于“对所有”逻辑量词，![使用 for 语句处理集合](img/B03671_06_12.jpg)。在一个简单的 `for` 循环结束时，我们可以断言源集合中的所有项目都已处理。为了构建“存在”量词，![使用
    for 语句处理集合](img/B03671_06_13.jpg)，我们可以使用 `while` 语句，或者在 `for` 语句体中使用 `break` 语句。'
- en: Using literal lists in a for statement
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 for 语句中使用字面值列表
- en: 'We can apply the `for` statement to a sequence of literal values. One of the
    most common ways to present literals is as a `tuple`. It might look like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `for` 语句应用于字面值序列。表示字面值最常见的方式之一是作为 `tuple`。它可能看起来像这样：
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will assign three different values to the `scheme` variable. For each of
    those values, it will evaluate the `do_something()` function.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为 `scheme` 变量分配三个不同的值。对于这些值中的每一个，它都会评估 `do_something()` 函数。
- en: From this, we can see that, strictly-speaking, the `()` are not required to
    delimit a `tuple` object. If the sequence of values grows, however, and we need
    to span more than one physical line, we'll want to `add ()`, making the `tuple`
    literal more explicit.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们可以看出，严格来说，括号 `()` 不是必需的，不能限定 `tuple` 对象。然而，如果值的序列增长，并且我们需要跨越多个物理行，我们就会想要
    `add ()`，使 `tuple` 字面量更加明确。
- en: Using the range() and enumerate() functions
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 range() 和 enumerate() 函数
- en: The `range()` object will provide a sequence of numbers, often used in a `for`
    loop. The `range()` object is iterable, it's not itself a sequence object. It's
    a generator, which will produce items when required. If we use `range()` outside
    a `for` statement, we need to use a function like `list(range(x))` or `tuple(range(a,b))`
    to consume all of the generated values and create a new sequence object.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`range()`对象将提供一个数字序列，通常用于`for`循环中。`range()`对象是可迭代的，它本身不是一个序列对象。它是一个生成器，当需要时会产生项。如果我们不在`for`语句中使用`range()`，我们需要使用像`list(range(x))`或`tuple(range(a,b))`这样的函数来消耗所有生成的值并创建一个新的序列对象。'
- en: 'The `range()` object has three commonly-used forms:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`range()`对象有三种常用的形式：'
- en: '`range(n)` produces ascending numbers including 0 but not including `n` itself.
    This is a half-open interval. We could say that `range(n)` produces numbers, *x*,
    such that ![Using the range() and enumerate() functions](img/B03671_06_07.jpg).
    The expression `list(range(5))` returns `[0, 1, 2, 3, 4]`. This produces *n* values
    including 0 and *n* - 1.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range(n)`生成包括0但不包括`n`本身的递增数字。这是一个半开区间。我们可以说`range(n)`生成数字，*x*，如下所示![使用range()和enumerate()函数](img/B03671_06_07.jpg)。表达式`list(range(5))`返回`[0,
    1, 2, 3, 4]`。这产生*n*个值，包括0和*n* - 1。'
- en: '`range(a,b)` produces ascending numbers starting from `a` but not including
    `b`. The expression `tuple(range(-1,3))` will return `(-1, 0, 1, 2)`. This produces
    *b* - *a* values including *a* and *b* - 1.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range(a,b)`生成从`a`开始的递增数字，但不包括`b`。表达式`tuple(range(-1,3))`将返回`(-1, 0, 1, 2)`。这会产生*b*
    - *a*个值，包括*a*和*b* - 1。'
- en: '`range(x,y,z)` produces ascending numbers in the sequence ![Using the range()
    and enumerate() functions](img/B03671_06_08.jpg). This produces (*y*-*x*)//*z*
    values.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range(x,y,z)`生成如![使用range()和enumerate()函数](img/B03671_06_08.jpg)所示的递增数字序列。这产生(*y*-*x*)/*z*个值。'
- en: 'We can use the `range()` object like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用`range()`对象：
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, we've used a `range()` object to produce values, *n*, such
    that ![Using the range() and enumerate() functions](img/B03671_06_09.jpg).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`range()`对象来生成值，*n*，如下所示![使用range()和enumerate()函数](img/B03671_06_09.jpg)。
- en: 'We use the `range()` object to generate the index values for all items in a
    list:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`range()`对象来生成列表中所有项的索引值：
- en: '[PRE36]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We've used the `range()` function to generate values between 0 and the length
    of the sequence object named `some_list`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用`range()`函数来生成名为`some_list`的序列对象之间的值，从0开始到其长度。
- en: 'The `for` statement allows multiple target variables. The rules for multiple
    target variables are the same as for a multiple variable assignment statement:
    a sequence object will be decomposed and items assigned to each variable. Because
    of that, we can leverage the `enumerate()` function to iterate through a sequence
    and assign the index values at the same time. It looks like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句允许多个目标变量。多个目标变量的规则与多个变量赋值语句相同：一个序列对象将被分解，并将项分配给每个变量。正因为如此，我们可以利用`enumerate()`函数遍历一个序列，并同时分配索引值。它看起来像这样：'
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `enumerate()` function is a generator function which iterates through the
    items in source sequence and yields a sequence of two-tuple pairs with the index
    and the item. Since we've provided two variables, the two-tuple is decomposed
    and assigned to each variable.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate()`函数是一个生成器函数，它遍历源序列中的项，并产生一个包含索引和项的两个元组对的序列。由于我们提供了两个变量，两个元组被分解并分配给每个变量。'
- en: There are numerous use cases for this multiple-assignment `for` loop. We often
    have list-of-tuples data structures that can be handled very neatly with this
    multiple-assignment feature. In [Chapter 8](ch08.html "Chapter 8. More Advanced
    Functions"), *More Advanced Functions*, we'll look at a number of these design
    patterns.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个多赋值`for`循环有无数的使用场景。我们经常有列表-元组数据结构，可以用这个多赋值特性非常整洁地处理。在[第8章](ch08.html "第8章。更高级的函数")中，我们将探讨这些设计模式中的许多。
- en: Iterating with the while statement
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用while语句进行迭代
- en: The `while` statement is a more general iteration than the `for` statement.
    We'll use a `while` loop in two situations. We'll use this in cases where we don't
    have a finite collection to impose an upper bound on the loop's iteration; we
    may suggest an upper bound in the `while` clause itself. We'll also use this when
    writing a "search" or "there exists" kind of loop; we aren't processing all items
    in a collection.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`语句比`for`语句更通用。我们将在两种情况下使用`while`循环。在没有有限集合来对循环迭代施加上限的情况下，我们将使用它；我们可以在`while`子句本身中建议上限。我们还将使用它来编写“搜索”或“存在”类型的循环；我们不是在处理集合中的所有项目。'
- en: A desktop application that accepts input from a user, for example, will often
    have a `while` loop. The application runs until the user decides to quit; there's
    no upper bound on the number of user interactions. For this, we generally use
    a `while True:` loop. Infinite iteration is recommended.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个接受用户输入的桌面应用程序通常会使用`while`循环。应用程序会一直运行，直到用户决定退出；用户交互的数量没有上限。为此，我们通常使用`while
    True:`循环。建议使用无限迭代。
- en: 'If we want to write a character-mode user interface, we could do it like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想编写一个字符模式用户界面，我们可以这样做：
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will iterate until the `quit_received` variable is set to `True`. This
    will process indefinitely; there's no upper boundary on the number of iterations.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这将一直迭代，直到`quit_received`变量被设置为`True`。这将无限期地处理；迭代次数没有上限。
- en: 'This `process()` function might use some kind of command processing. This should
    include a statement like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`process()`函数可能使用某种命令处理。这应该包括如下语句：
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When the user enters `"quit"`, the `process()` function will return `True`.
    This will be assigned to the `quit_received` variable. The `while` expression,
    `not quit_received`, will become `False`, and the loop ends.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入`"quit"`时，`process()`函数将返回`True`。这将分配给`quit_received`变量。`while`表达式`not
    quit_received`将变为`False`，循环结束。
- en: A "there exists" loop will iterate through a collection, stopping at the first
    item that meets certain criteria. This can look complex because we're forced to
    make two details of loop processing explicit.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: “存在”循环将遍历一个集合，在遇到满足某些标准的第一个项目时停止。这看起来可能很复杂，因为我们被迫明确地处理循环处理的两个细节。
- en: 'Here''s an example of searching for the first value that meets a condition.
    This example assumes that we have a function, `condition()`, which will eventually
    be `True` for some number. Here''s how we can use a `while` statement to locate
    the minimum for which this function is `True`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个搜索第一个满足条件的值的例子。此示例假设我们有一个函数`condition()`，该函数最终会对某些数字为`True`。以下是我们可以如何使用`while`语句定位此函数为`True`的最小值：
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `while` statement will terminate when `n == 101` or the `condition(n)` is
    `True`. If this expression is `False`, we can advance the `n` variable to the
    next value in the sequence of values. Since we're iterating through the values
    in order from the smallest to the largest, we know that `n` will be the smallest
    value for which the `condition()` function is true.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当`n == 101`或`condition(n)`为`True`时，`while`语句将终止。如果此表达式为`False`，我们可以将`n`变量推进到值序列中的下一个值。由于我们按顺序从最小到最大迭代值，我们知道`n`将是`condition()`函数为真的最小值。
- en: At the end of the `while` statement we have included a formal assertion that
    either `n` is 101 or the `condition()` function is `True` for the given value
    of `n`. Writing an assertion like this can help in design as well as debugging
    because it will often summarize the loop invariant condition.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`语句的末尾，我们包含了一个正式的断言，即`n`是101或对于给定的`n`值，`condition()`函数为`True`。编写这样的断言可以帮助设计以及调试，因为它通常会总结循环不变条件。
- en: We can also write this kind of loop using the `break` statement in a `for` loop,
    something we'll look at in the next section.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`for`循环中的`break`语句编写这种类型的循环，我们将在下一节中探讨。
- en: The continue and break statements
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`continue`和`break`语句'
- en: The `continue` statement is helpful for skipping items without writing deeply-nested
    `if` statements. The effect of executing a `continue` statement is to skip the
    rest of the loop's suite. In a `for` loop, this means that the next item will
    be taken from the source iterable. In a `while` loop, this must be used carefully
    to avoid an otherwise infinite iteration.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`语句对于跳过项目而不编写深层嵌套的`if`语句非常有用。执行`continue`语句的效果是跳过循环体中的其余部分。在`for`循环中，这意味着下一个项目将从源可迭代对象中取出。在`while`循环中，必须小心使用，以避免无限迭代。'
- en: 'We might see file processing that looks like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会看到类似这样的文件处理：
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this loop, we're relying on the way files act like sequences of individual
    lines. For each line in the file, we've stripped whitespace from the input line,
    and assigned the resulting string to the `clean` variable. If the length of this
    string is zero, the line was entirely whitespace, and we'll continue the loop
    with the next line. The `continue` statement skips the remaining statements in
    the body of the loop.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个循环中，我们依赖于文件表现得像一系列单独的行的方式。对于文件中的每一行，我们都从输入行中删除了空格，并将结果字符串分配给 `clean` 变量。如果这个字符串的长度为零，则该行完全由空格组成，我们将继续循环到下一行。`continue`
    语句跳过了循环体内的剩余语句。
- en: 'We''ll partition the line into three pieces: a portion in front of any `"#"`,
    the `"#"` (if present), and the portion after any `"#"`. We''ve assigned the `"#"`
    character and any text after the `"#"` character to the same easily-ignored variable,
    `_`, because we don''t have any use for these two results of the `partition()`
    method. We can then strip any trailing whitespace from the string assigned to
    the `data` variable. If the resulting string has a length of zero, then the line
    is entirely filled with `"#"` and any trailing comment text. Since there''s no
    useful data, we can continue the loop, ignoring this line of input.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将行分成三部分：任何 `"#"` 前的部分，`"#"`（如果存在），以及任何 `"#"` 后的部分。我们将 `"#"` 字符和任何 `"#"` 后面的文本分配给同一个容易忽略的变量
    `_`，因为我们不需要这两个 `partition()` 方法的输出结果。然后我们可以从分配给 `data` 变量的字符串中删除任何尾随空格。如果结果字符串的长度为零，则该行完全由
    `"#"` 和任何尾随注释文本组成。由于没有有用的数据，我们可以继续循环，忽略这一行输入。
- en: If the line passes the two `if` conditions, we can process the resulting data.
    By using the `continue` statement, we have avoided complex-looking, deeply-nested
    `if` statements. We'll examine files in detail in [Chapter 10](ch10.html "Chapter 10. Files,
    Databases, Networks, and Contexts"), *Files, Databases, Networks, and Contexts*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该行通过了两个 `if` 条件，我们可以处理结果数据。通过使用 `continue` 语句，我们避免了看起来复杂、深度嵌套的 `if` 语句。我们将在
    [第 10 章](ch10.html "第 10 章。文件、数据库、网络和上下文") *文件、数据库、网络和上下文* 中详细检查文件。
- en: It's important to note that a `continue` statement must always be part of the
    suite inside an `if` statement, inside a `for` or `while` loop. The condition
    on that `if` statement becomes a filter condition that applies to the collection
    of data being processed. `continue` always applies to the innermost loop.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`continue` 语句必须始终是 `if` 语句内部、`for` 或 `while` 循环内部的代码块的一部分。那个 `if` 语句的条件成为一个过滤条件，应用于正在处理的数据集合。`continue`
    总是应用于最内层的循环。
- en: Breaking early from a loop
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提前退出循环
- en: The `break` statement is a profound change in the semantics of the loop. An
    ordinary `for` statement can be summarized by "for all." We can comfortably say
    that "for all items in a collection, the suite of statements was processed."
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 语句是循环语义的一个重大变化。一个普通的 `for` 语句可以总结为“对所有”。我们可以舒适地说，“对于集合中的所有项目，都处理了语句块。”'
- en: When we use a `break` statement, a loop is no longer summarized by "for all."
    We need to change our perspective to "there exists". A `break` statement asserts
    that at least one item in the collection matches the condition that leads to the
    execution of the `break` statement.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `break` 语句时，循环不再总结为“对所有”。我们需要改变我们的视角到“存在”。`break` 语句断言集合中至少有一个项目与导致执行
    `break` 语句的条件匹配。
- en: 'Here''s a simple example of a `break` statement:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 `break` 语句的简单示例：
- en: '[PRE42]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We've written a loop that is bound by ![Breaking early from a loop](img/B03671_06_10.jpg).
    This loop includes a `break` statement, so it will not process all values of `n`.
    Instead, it will determine the smallest value of `n`, for which `n` is equal to
    the sum of its factors. Since the loop doesn't examine all values, it shows that
    at least one such number exists within the given range.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一个受 ![提前退出循环](img/B03671_06_10.jpg) 限制的循环。这个循环包含一个 `break` 语句，因此它不会处理 `n`
    的所有值。相反，它会确定 `n` 的最小值，对于这个值，`n` 等于其因子的和。由于循环没有检查所有值，这表明在给定范围内至少存在这样一个数。
- en: We've used a nested loop to determine the factors of the number `n`. This nested
    loop creates a sequence, `factors`, for all values of `x` in the range ![Breaking
    early from a loop](img/B03671_06_11.jpg), such that `x,` is a factor of the number
    `n`. This inner loop doesn't have a `break` statement, so we are sure it examines
    all values in the given range.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用嵌套循环来确定数字 `n` 的因子。这个嵌套循环为范围 ![从循环中提前退出](img/B03671_06_11.jpg) 内的所有 `x` 值创建了一个序列
    `factors`，使得 `x` 是数字 `n` 的一个因子。这个内部循环没有 `break` 语句，所以我们确信它会检查给定范围内的所有值。
- en: The least value for which this is true is the number six.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条件成立的最小值是数字六。
- en: It's important to note that a `break` statement must always be part of the suite
    inside an `if` statement inside a `for` or `while` loop. If the break isn't in
    an `if` suite, the loop will always terminate while processing the first item.
    The condition on that `if` statement becomes the "where exists" condition that
    summarizes the loop as a whole. Clearly, multiple `if` statements with multiple
    `break` statements mean that the overall loop can have a potentially confusing
    and difficult-to-summarize post-condition.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`break` 语句必须始终是 `for` 或 `while` 循环内部 `if` 语句集中的部分。如果 `break` 不在 `if`
    语句集中，循环将在处理第一个项目时始终终止。该 `if` 语句的条件成为总结整个循环的“存在条件”。
- en: Using the else clause on a loop
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在循环中使用 `else` 子句
- en: 'Python''s `else` clause can be used on a `for` or `while` statement as well
    as on an `if` statement. The `else` clause executes after the loop body if there
    was no `break` statement executed. To see this, here''s a contrived example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `else` 子句也可以用在 `for` 或 `while` 语句以及 `if` 语句上。如果循环体中没有执行 `break` 语句，则
    `else` 子句将执行。为了说明这一点，这里有一个人为的例子：
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `for` statement here will iterate over a short list of literal values. When
    a specific target value has been found, a message is printed. Then, the `break`
    statement will end the loop, avoiding the `else` clause.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `for` 语句将遍历一个短列表的文本值。当找到特定的目标值时，会打印一条消息。然后，`break` 语句将结束循环，避免执行 `else` 子句。
- en: 'When we run this, we''ll see three lines of output, like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，我们会看到三行输出，如下所示：
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The value of three isn't shown, nor is the "Found Nothing" message in the `else`
    clause.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 三的值没有显示，也没有在 `else` 子句中显示的“未找到任何内容”消息。
- en: If we change the target value in the `if` statement from two to a value that
    won't be seen (for example, zero or four), then the output will change. If the
    `break` statement is not executed, then the `else` clause will be executed.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `if` 语句中的目标值从二更改为不会出现的值（例如，零或四），那么输出将改变。如果 `break` 语句没有执行，那么 `else` 子句将被执行。
- en: The idea here is to allow us to write contrasting `break` and non-`break` suites
    of statements. An `if` statement suite that includes a `break` statement can do
    some processing in the suite before the `break` statement ends the loop. An `else`
    clause allows some processing at the end of the loop when none of the `break`-related
    suites statements were executed.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是允许我们编写包含 `break` 和非 `break` 语句的对比语句集。包含 `break` 语句的 `if` 语句集可以在 `break`
    语句结束循环之前在语句集中进行一些处理。`else` 子句允许在循环结束时进行一些处理，当没有执行任何与 `break` 相关的语句集时。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'We''ve looked at three mutable collections: lists, sets and dictionaries. The
    built-in dictionary class is only one of many mappings available in Python, the
    others are defined in the collections module of the standard library. The list
    allows us to collect items which are identified by their positions in the list.
    The set allows us to collect a set of unique items, in which each item is simply
    identified by itself. A mapping allows us to identify items by a key.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了三种可变集合：列表、集合和字典。Python 中内置的字典类只是众多映射中的一种，其他映射定义在标准库的 collections 模块中。列表允许我们收集通过列表中位置标识的项。集合允许我们收集一组唯一的项，其中每个项仅通过自身来标识。映射允许我们通过键来标识项。
- en: For sets, each item must be immutable. For mappings, the object used as a key
    must be immutable. This means that numbers, strings, and tuples are often used
    as mapping keys.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于集合，每个项必须是不可变的。对于映射，用作键的对象必须是不可变的。这意味着数字、字符串和元组通常用作映射键。
- en: We've looked at the `for` statement, which is the primary way we'll process
    the individual items in a collection. A simple `for` statement assures us that
    our processing has been done for all items in the collection. We've also looked
    at the general purpose `while` loop.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了`for`语句，这是我们处理集合中各个项目的主要方式。一个简单的`for`语句确保我们的处理已经针对集合中的所有项目完成。我们还探讨了通用的`while`循环。
- en: In [Chapter 7](ch07.html "Chapter 7. Basic Function Definitions"), *Basic Function
    Definitions*, we'll look at how we can define our own functions. We'll also look
    at the wide variety of ways we can evaluate a function in Python.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。基本函数定义")，*基本函数定义*中，我们将探讨如何定义我们自己的函数。我们还将了解在Python中评估函数的多种方法。
