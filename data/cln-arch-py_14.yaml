- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: 'Legacy to Clean: Refactoring Python for Maintainability'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从遗留系统到清洁：重构Python以提高可维护性
- en: While previous chapters demonstrated Clean Architecture principles through greenfield
    development, real-world systems often present a different challenge. Existing
    applications, built under time pressure or before architectural best practices
    were established, frequently violate Clean Architecture’s fundamental principles.
    Their domain logic becomes tangled with frameworks, business rules mix with infrastructure
    concerns, and dependencies flow in all directions. Yet these systems often serve
    critical business needs and cannot simply be replaced.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前几章通过绿地开发演示了清洁架构原则，但现实世界中的系统往往面临不同的挑战。在时间压力下构建或在架构最佳实践建立之前构建的现有应用程序，通常违反清洁架构的基本原则。它们的领域逻辑与框架纠缠在一起，业务规则与基础设施关注点混合，依赖关系流向四面八方。然而，这些系统通常满足关键业务需求，不能简单地被替换。
- en: Through our exploration of Clean Architecture transformation, we’ll discover
    how to systematically evolve legacy systems while maintaining their business value.
    We’ll see how Clean Architecture’s explicit boundaries and dependency rules provide
    clear guidance for improving existing systems, even under real-world constraints.
    You’ll learn how to identify architectural violations, establish clean boundaries
    incrementally, and maintain system stability during transformation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们对清洁架构转型的探索，我们将发现如何系统地演变遗留系统，同时保持其商业价值。我们将看到清洁架构的明确边界和依赖规则如何提供清晰的指导，以改善现有系统，即使在现实世界的约束下。您将学习如何识别架构违规，逐步建立清洁边界，并在转型过程中保持系统稳定性。
- en: By the end of this chapter, you’ll understand how to apply Clean Architecture
    principles to legacy systems through staged implementation. You’ll be able to
    evaluate existing systems through Clean Architecture’s lens and implement bounded
    transformations that respect business constraints while maintaining system stability.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解如何通过分阶段实施将清洁架构原则应用于遗留系统。您将能够通过清洁架构的视角评估现有系统，并实施尊重业务约束的同时保持系统稳定性的有界转型。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Evaluating and planning architectural transformation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估和规划架构转型
- en: Progressive Clean Architecture implementation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渐进式清洁架构实现
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples presented in this chapter and throughout the rest of the book
    are tested with Python 3.13\. For brevity, most code examples in the chapter are
    only partially implemented. Complete versions of all examples can be found in
    the book’s accompanying GitHub repository at [https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和本书其余部分提供的代码示例均使用Python 3.13进行测试。为了简洁，本章中的大多数代码示例仅部分实现。所有示例的完整版本可以在本书配套的GitHub仓库[https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python)中找到。
- en: Evaluating and planning architectural transformation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估和规划架构转型
- en: Improving maintainability and reducing risk in complex applications requires
    a systematic approach to architectural evolution. Applications with tangled dependencies
    and blurred responsibilities consume disproportionate maintenance effort. Feature
    additions that should take days stretch into weeks; bug fixes trigger unexpected,
    persistent failures; and developer onboarding becomes painfully slow. These symptoms
    don’t just reflect technical issues; they also have direct business impacts that
    need addressing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂应用程序中提高可维护性和降低风险需要一种系统性的架构演变方法。具有纠缠依赖关系和模糊责任的应用程序消耗了不成比例的维护工作量。原本只需几天就能完成的特性添加扩展到几周；错误修复触发意外的、持续的故障；开发者入职变得痛苦缓慢。这些症状不仅反映了技术问题；它们还直接影响了业务，需要解决。
- en: Throughout previous chapters, we’ve seen how Clean Architecture naturally minimizes
    maintenance burdens through clear boundaries and explicit dependencies. Now, we
    can apply this same architectural lens to evaluate existing systems, identifying
    where violations occur and how to address them systematically. This doesn’t mean
    forcing an ideal Clean Architecture onto legacy systems all at once but, rather,
    taking a balanced, incremental approach that respects business constraints while
    progressively improving the system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了清洁架构如何通过清晰的边界和显式的依赖关系自然地最小化维护负担。现在，我们可以应用相同的架构视角来评估现有系统，确定违规发生的地方以及如何系统地解决它们。这并不意味着一次性将理想的清洁架构强加于遗留系统，而是采取一种平衡的、渐进的方法，在尊重商业约束的同时，逐步改进系统。
- en: By analyzing legacy code through Clean Architecture principles, we can uncover
    natural system boundaries waiting to be established, domain concepts ready to
    be isolated, and interfaces eager to emerge. This evaluation forms the foundation
    for our transformation strategy, guiding decisions about what to change, when
    to change it, and how to minimize risk throughout the process. With each incremental
    improvement, we reduce both the maintenance burden and the instability associated
    with future changes, creating measurable business value beyond the technical improvements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将遗留代码通过清洁架构原则进行分析，我们可以揭示自然系统边界，等待建立，领域概念准备隔离，接口渴望出现。这种评估构成了我们转型策略的基础，指导关于改变什么、何时改变以及如何在整个过程中最小化风险的决策。随着每次增量改进，我们减少维护负担和与未来变化相关的稳定性，创造了超越技术改进的可衡量商业价值。
- en: Evaluating through a Clean Architecture lens
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过清洁架构视角进行评估
- en: Transforming an existing system begins with evaluating its current state with
    respect to Clean Architecture principles. This evaluation isn’t about documenting
    every detail, but rather aims at identifying key architectural violations and
    gauging their business impact. Since wholesale transformation introduces unacceptable
    risk, we need a balanced approach that provides enough understanding to inform
    stakeholder discussions while enabling meaningful progress. This measured assessment
    creates the foundation for deeper collaborative analysis once initial stakeholder
    support is secured.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将现有系统转换为符合清洁架构原则的系统，首先需要评估其当前状态。这种评估并非关于记录每个细节，而是旨在识别关键架构违规并评估其商业影响。由于全面转型会引入不可接受的风险，我们需要一种平衡的方法，既提供足够的信息来指导利益相关者的讨论，又能够实现有意义的进展。这种谨慎的评估为在获得初始利益相关者支持后进行更深入的协作分析奠定了基础。
- en: Conducting preliminary architectural analysis
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进行初步架构分析
- en: Before engaging stakeholders, we need to conduct a targeted preliminary architectural
    analysis focused on identifying key technical issues that can be effectively communicated
    to non-technical audiences. This initial assessment isn’t exhaustive but provides
    enough insight to illustrate architectural problems in business-relevant terms.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在与利益相关者接触之前，我们需要进行一次有针对性的初步架构分析，重点是识别可以有效地传达给非技术受众的关键技术问题。这种初步评估并非详尽无遗，但提供了足够的洞察力，以业务相关的术语说明架构问题。
- en: 'A focused preliminary analysis might include:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 焦点的初步分析可能包括：
- en: '**Architectural inventory**: Identify major components and their interactions,
    creating a baseline understanding without documenting every detail.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**架构清单**：识别主要组件及其交互，创建一个无需记录每个细节的基准理解。'
- en: '**Dependency mapping**: Sketch high-level dependency flows that reveal the
    most problematic circular dependencies and framework coupling that violates Clean
    Architecture’s principles.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖映射**：绘制高级依赖流程图，揭示最成问题的循环依赖和违反清洁架构原则的框架耦合。'
- en: '**Framework penetration assessment**: Spotlight examples where framework code
    has significantly permeated business logic, focusing on areas with visible impact
    on maintenance or flexibility.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架渗透评估**：聚焦于框架代码显著渗透业务逻辑的例子，重点关注对维护或灵活性有可见影响的区域。'
- en: '**Domain logic dispersion**: Identify a few clear examples where business rules
    are fragmented across the codebase, particularly those affecting functionality
    that changes frequently.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域逻辑分散**：识别一些清晰的例子，其中业务规则在代码库中分散，特别是那些影响功能频繁变化的部分。'
- en: 'For example, in analyzing a Python e-commerce system, we might discover that
    Django models contain critical business rules, validation logic is duplicated
    across multiple views, and payment processing code directly references native
    database queries. This preliminary analysis provides concrete examples that non-technical
    stakeholders can understand: *When we need to change how pricing works, we currently
    have to modify code in seven different places across three different modules*.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在分析一个Python电子商务系统时，我们可能会发现Django模型包含关键的业务规则，验证逻辑在多个视图中重复，支付处理代码直接引用了原生数据库查询。这种初步分析提供了非技术利益相关者可以理解的实例：*当我们需要更改定价方式时，我们目前必须修改三个不同模块中的七个不同地方的代码*。
- en: This analysis serves as a communication tool, translated into business impact
    terms like increased time-to-market, elevated bug rates, and diminished ability
    to respond to changing requirements. By framing architectural issues in business
    terms before beginning the transformation, we create the foundation for stakeholder
    support and appropriate resource allocation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分析作为一种沟通工具，被翻译成业务影响术语，如缩短上市时间、提高错误率以及降低应对变化需求的能力。在开始转型之前，用业务术语来界定架构问题，我们为利益相关者的支持以及适当的资源分配奠定了基础。
- en: This preliminary architectural assessment serves as an entry point for transformation,
    not an exhaustive blueprint. Focus on identifying just enough specific violations
    to engage stakeholders with credible examples that illustrate business impact.
    Resist the temptation to diagram every relationship at this stage. Your understanding
    will deepen substantially during the collaborative domain analysis that follows.
    The goal is to gather sufficient evidence to make the case for transformation
    while setting the stage for deeper exploration with stakeholders.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种初步的架构评估是转型的起点，而不是详尽的蓝图。专注于识别足够的具体违规行为，以便通过有说服力的例子来吸引利益相关者，这些例子可以说明业务影响。在这一阶段，抵制绘制每个关系的诱惑。在随后的协作领域分析中，你的理解将大大加深。目标是收集足够的证据来支持转型的案例，同时为与利益相关者进行更深入的探索做好准备。
- en: Building stakeholder alignment
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立利益相关者的一致性
- en: With the preliminary architectural analysis complete and key issues identified,
    the next step is communicating these findings to stakeholders and securing initial
    buy-in for transformation. This initial engagement isn’t about getting final approval
    for specific changes, but rather aims to build shared awareness of architectural
    issues and establish support for a more collaborative discovery process. The insights
    gained from our analysis must now be translated into business-impact terms that
    resonate with different stakeholder groups, creating the foundation for the deeper
    collaborative analysis that will follow.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成初步的架构分析和确定关键问题后，下一步是将这些发现传达给利益相关者，并确保对转型获得初步的支持。这次初步接触不是为了获得对特定变更的最终批准，而是旨在建立对架构问题的共同认识，并建立对更协作的发现过程的支持。从我们的分析中获得的认识现在必须被翻译成与不同利益相关者群体产生共鸣的业务影响术语，为随后的更深入协作分析奠定基础。
- en: 'The first step is involving the right stakeholders:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是涉及正确的利益相关者：
- en: '**Engineering teams** who understand the technical details and implementation
    constraints'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工程团队**，他们理解技术细节和实施限制'
- en: '**Product owners** who can articulate business priorities and validate the
    value of architectural changes'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品负责人**，他们能够阐述业务优先级并验证架构变更的价值'
- en: '**Operations personnel** who manage system deployment and reliability concerns'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运维人员**，他们管理系统部署和可靠性问题'
- en: '**End users** who can share pain points related to system stability and feature
    delivery'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终用户**，他们可以分享与系统稳定性和功能交付相关的痛点'
- en: The scope of stakeholder involvement should correspond directly to the scale
    of transformation planned. Smaller refactorings might only require coordination
    with your immediate team, while system-wide architectural overhauls may need engagement
    all the way up to the CTO or VP of Engineering.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 利益相关者参与的范围应直接对应于计划转型的规模。较小的重构可能只需要与你的直接团队协调，而系统级的架构改造可能需要从CTO或工程副总裁那里获得参与。
- en: 'Once you have stakeholders aligned around a shared transformation vision, the
    next critical step is establishing baseline measurements that will track progress
    and demonstrate value. These metrics create accountability and provide clear evidence
    of improvement throughout the transformation journey:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦利益相关者就共享的转型愿景达成一致，下一步关键步骤是建立基线测量，这将跟踪进度并展示价值。这些指标创造了问责制，并在转型旅程的整个过程中提供了改进的明确证据：
- en: '**Maintenance metrics**: time spent on bug fixes, feature delivery lead time'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护指标**：修复错误所花费的时间，功能交付的领先时间'
- en: '**Quality indicators**: defect rates, test coverage, static analysis scores'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量指标**：缺陷率，测试覆盖率，静态分析得分'
- en: '**Team effectiveness**: developer onboarding time, deployment frequency'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队效率**：开发者入职时间，部署频率'
- en: '**Business outcomes**: customer satisfaction, feature adoption rates'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务成果**：客户满意度，功能采用率'
- en: These metrics serve multiple purposes throughout the transformation. Initially,
    they justify the effort and help secure leadership support. As work progresses,
    they validate effectiveness and highlight areas needing adjustment. They also
    help define what *done* means for the transformation, recognizing that the goal
    is sustainable improvement rather than architectural perfection. Most importantly,
    metrics translate technical improvements into business value language, creating
    a feedback loop that keeps the transformation aligned with both technical goals
    and business priorities.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指标在整个转型过程中发挥着多重作用。最初，它们证明了努力的合理性并有助于获得领导层的支持。随着工作的推进，它们验证了有效性并突出了需要调整的领域。它们还帮助定义了转型中“完成”的含义，认识到目标是可持续的改进而不是架构的完美。最重要的是，指标将技术改进转化为业务价值语言，创建了一个反馈循环，使转型与技术和业务优先事项保持一致。
- en: Deeper domain analysis
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入的领域分析
- en: Business domains naturally evolve over time, making architectural transformation
    an ideal opportunity to realign systems with current business needs. After securing
    initial stakeholder support, the next step is deepening our understanding through
    collaborative domain discovery techniques. This phase connects our technical insights
    with business domain knowledge, identifying meaningful boundaries while solidifying
    stakeholder buy-in through active involvement. Where our preliminary analysis
    focused on technical issues, collaborative discovery bridges these findings with
    evolving business requirements, ensuring the transformed system not only has better
    architecture but also better serves current needs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 业务领域自然会随着时间的推移而演变，使架构转型成为重新调整系统以适应当前业务需求的一个理想机会。在获得初始利益相关者支持后，下一步是通过协作领域发现技术深化我们的理解。这一阶段将我们的技术洞察与业务领域知识联系起来，确定有意义的边界，并通过积极参与巩固利益相关者的支持。在我们初步分析侧重于技术问题时，协作发现将这些建议与不断发展的业务需求联系起来，确保转型后的系统不仅具有更好的架构，而且更好地满足当前需求。
- en: 'Several collaborative approaches can help bridge technical understanding with
    domain expertise:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 几种协作方法可以帮助弥合技术理解与领域专业知识之间的差距：
- en: '**Event storming workshops** to map business processes and domain events ([https://www.eventstorming.com/](https://www.eventstorming.com/))'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件风暴研讨会**用于映射业务流程和领域事件 ([https://www.eventstorming.com/](https://www.eventstorming.com/))'
- en: '**Domain storytelling sessions** where stakeholders narrate key workflows ([https://domainstorytelling.org/](https://domainstorytelling.org/))'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域故事讲述会**，其中利益相关者讲述关键工作流程 ([https://domainstorytelling.org/](https://domainstorytelling.org/))'
- en: '**Context mapping exercises** to identify system boundaries and integration
    points ([https://contextmapper.org/](https://contextmapper.org/))'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文映射练习**用于识别系统边界和集成点 ([https://contextmapper.org/](https://contextmapper.org/))'
- en: 'Among these approaches, **event storming** stands out as particularly valuable
    for Clean Architecture transformations. It brings together stakeholders in facilitated
    workshops to validate domain understanding and identify architectural boundaries.
    Participants use color-coded sticky notes on a shared modeling space, creating
    a visual timeline of business processes. The color coding intentionally maps to
    Clean Architecture layers: orange domain events represent core entities at the
    center of the architecture, blue commands align with use cases in the Application
    layer, and purple business rules reflect domain rules that remain independent
    of external concerns. Typical domain events include *Order Placed*, while commands
    might include actions like *Process Payments*. This visual approach makes architectural
    boundaries tangible to all stakeholders, helping identify natural separation points
    when transforming legacy systems. While specific color schemes may vary between
    teams, maintaining a consistent visual language is what matters most.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些方法中，**事件风暴**在清洁架构转型中特别有价值。它通过促进研讨会将利益相关者聚集在一起，以验证领域理解和识别架构边界。参与者使用共享建模空间上的彩色便签，创建业务流程的可视化时间线。颜色编码有意映射到清洁架构层：橙色领域事件代表架构中心的实体，蓝色命令与应用层中的用例对齐，紫色业务规则反映了独立于外部关注点的领域规则。典型的领域事件包括*订单已放置*，而命令可能包括如*处理支付*等操作。这种视觉方法使架构边界对所有利益相关者都变得具体，有助于在改造遗留系统时识别自然分离点。虽然具体的颜色方案可能在团队之间有所不同，但保持一致的视觉语言最为重要。
- en: '![Figure 11.1: Event storming visualization for an e-commerce system, showing
    domain events, commands, actors, and potential bounded contexts](img/B31577_11_1.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1：电子商务系统的事件风暴可视化，展示了领域事件、命令、演员和潜在的边界上下文](img/B31577_11_1.png)'
- en: 'Figure 11.1: Event storming visualization for an e-commerce system, showing
    domain events, commands, actors, and potential bounded contexts'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：电子商务系统的事件风暴可视化，展示了领域事件、命令、演员和潜在的边界上下文
- en: This collaborative approach builds directly on the domain modeling principles
    from [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor091), applying them to discover
    boundaries in existing systems. The same concepts of Entities, Value Objects,
    and Aggregates now help identify what the legacy system *should* have separated
    but didn’t. For example, an event storming session might reveal that the *Order
    Processing* domain contains distinct events like *Order Placed*, *Payment Approved*,
    *Inventory Reserved*, and *Shipment Created*. Be sure to separate business concerns
    that could be cleanly divided into discrete use cases rather than handled by a
    monolithic Order Controller.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种协作方法直接基于[*第 4 章*](Chapter_04.xhtml#_idTextAnchor091)中的领域建模原则，将它们应用于发现现有系统中的边界。现在，实体、值对象和聚合的概念有助于识别遗留系统*应该*分离但未分离的内容。例如，一个事件风暴会议可能会揭示*订单处理*领域包含如*订单已放置*、*支付已批准*、*库存已预留*和*已创建发货*等独特事件。务必将业务关注点分离成独立的用例，而不是由一个庞大的订单控制器处理。
- en: The resulting visual artifacts serve as powerful communication tools, helping
    stakeholders see how architectural boundaries translate to business benefits like
    faster delivery or reduced errors. This shared language often reveals insights
    that technical analysis alone would miss, such as Order and Payment processing
    having different change patterns that indicate natural separation points. With
    these boundaries identified through stakeholder collaboration, we can move from
    discovery to action, translating insights into a prioritized roadmap for architectural
    improvement.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 结果生成的视觉工件作为强大的沟通工具，帮助利益相关者看到架构边界如何转化为业务效益，如更快的交付或减少错误。这种共享语言通常揭示出仅通过技术分析无法发现的见解，例如订单和支付处理具有不同的变化模式，这表明了自然的分离点。通过利益相关者的协作确定了这些边界后，我们可以从发现转向行动，将见解转化为优先级路线图，以改进架构。
- en: Creating a staged implementation roadmap
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建分阶段实施路线图
- en: With architectural boundaries identified and prioritized based on business value,
    the focus now shifts to tactical execution planning. Transforming legacy systems
    isn’t just about knowing what to change, it’s about organizing the work into manageable,
    low-risk increments that maintain system stability while progressively improving
    architecture.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了基于业务价值的架构边界并进行了优先级排序后，现在的重点转向战术执行规划。改造遗留系统不仅仅是知道要改变什么，而是将工作组织成可管理的、低风险的增量，在保持系统稳定性的同时逐步改进架构。
- en: Effective transformation planning requires breaking down the work into distinct
    stages with clear deliverables. Rather than overwhelming teams with a massive
    refactoring effort, a staged implementation creates natural checkpoints to validate
    progress, gather feedback, and adjust course as needed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的转型规划需要将工作分解为具有明确交付成果的独立阶段。而不是用大量的重构工作压倒团队，分阶段实施创建自然检查点以验证进度、收集反馈并根据需要调整方向。
- en: '![Figure 11.2: Clean Architecture transformation stages showing progression
    from foundation to optimization](img/B31577_11_2.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2：干净的架构转型阶段，展示了从基础到优化的进展](img/B31577_11_2.png)'
- en: 'Figure 11.2: Clean Architecture transformation stages showing progression from
    foundation to optimization'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：干净的架构转型阶段，展示了从基础到优化的进展
- en: The **foundation stage** establishes core domain concepts and abstractions that
    serve as building blocks for later work. This often begins with creating clean
    entity models alongside existing implementations and defining interfaces for repositories
    and services. By starting with these core elements, teams establish a clear target
    architecture while minimizing initial changes to the running system.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础阶段**建立核心领域概念和抽象，这些抽象是后续工作的基石。这通常从创建与现有实现并行的干净实体模型和定义仓库和服务接口开始。通过从这些核心元素开始，团队在最小化对运行系统初始更改的同时，确立了一个清晰的架构目标。'
- en: As the foundation takes shape, the **interface stage** focuses on implementing
    adapters that bridge the clean core and external concerns. This includes building
    repository implementations that work with existing databases, creating service
    adapters for third-party integrations, and developing controllers that translate
    between frameworks and the domain. These adapters create a protective layer around
    the emerging Clean Architecture.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当基础形成时，**接口阶段**专注于实现适配器，以连接干净的核和外部关注点。这包括构建与现有数据库协同工作的仓库实现，创建第三方集成的服务适配器，以及开发在框架和领域之间进行转换的控制器。这些适配器在新兴的干净架构周围创建了一个保护层。
- en: The **integration stage** gradually migrates existing functionality to the new
    architecture. Teams replace direct database access with repository implementations,
    substitute hard-coded business rules with domain services, and integrate new components
    with legacy systems through appropriate adapters. This stage often progresses
    feature by feature or domain by domain, allowing for controlled, incremental changes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成阶段**逐步将现有功能迁移到新架构。团队用仓库实现替换直接数据库访问，用领域服务替换硬编码的业务规则，并通过适当的适配器将新组件与遗留系统集成。这一阶段通常按功能或领域逐步进行，允许进行可控的增量更改。'
- en: Finally, the **optimization stage** refines and enhances the architecture based
    on real-world experience. Teams address performance considerations in repository
    implementations, expand test coverage, and improve error handling and resilience
    patterns. This stage acknowledges that the target architecture isn’t achieved
    in one pass, but rather through continuous refinement.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**优化阶段**基于实际经验对架构进行精炼和增强。团队在仓库实现中解决性能考虑因素，扩展测试覆盖率，并改进错误处理和弹性模式。这一阶段认识到目标架构不是一蹴而就的，而是通过持续精炼实现的。
- en: Throughout this staged approach, the baseline metrics established earlier serve
    a crucial role in validating progress and communicating the transformation’s impact.
    By tracking metrics such as maintenance time, defect rates, and feature delivery
    speed before, during, and after each transformation stage, teams can demonstrate
    tangible improvements and adjust their approach based on actual results rather
    than assumptions. These metrics also help teams identify when they’ve reached
    acceptable levels of architectural improvement, allowing organizations to balance
    architectural refinement with ongoing business needs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个分阶段方法中，之前建立的基线指标在验证进度和传达转型影响方面发挥着至关重要的作用。通过在每次转型阶段之前、期间和之后跟踪维护时间、缺陷率和功能交付速度等指标，团队可以展示可衡量的改进，并根据实际结果而不是假设调整他们的方法。这些指标还有助于团队确定何时达到可接受的架构改进水平，使组织能够在架构精炼和持续业务需求之间取得平衡。
- en: Approaches for doing the transformation work
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行转型工作的方法
- en: 'The execution complexity of architectural transformation requires careful logistics
    planning beyond the technical aspects. Teams must decide how to organize the work
    alongside ongoing feature development and maintenance. Several approaches are
    worth considering:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 架构转型的执行复杂性需要仔细的物流规划，而不仅仅是技术方面。团队必须决定如何将工作组织与持续的特性开发和维护相结合。以下几种方法值得考虑：
- en: '**Dedicated transformation iterations** allocate specific sprint cycles exclusively
    to architectural work. This approach provides focused time for complex refactoring
    but may delay feature delivery. It works well for components that need significant
    changes but which can be completed within one or two iterations.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专门的转型迭代**将特定的冲刺周期专门用于架构工作。这种方法为复杂的重构提供了专注的时间，但可能会延迟特性交付。它适用于需要重大更改但可以在一两个迭代内完成的组件。'
- en: '**Parallel transformation tracks** create dedicated teams focused on architectural
    improvements while other teams continue feature development. This approach maintains
    delivery velocity but requires careful coordination to prevent conflicts. It’s
    particularly effective for larger systems where transformation will span multiple
    quarters.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行转型轨道**创建专注于架构改进的专门团队，同时其他团队继续特性开发。这种方法保持了交付速度，但需要仔细协调以防止冲突。它特别适用于将跨越多个季度的更大系统。'
- en: '**Opportunity-based transformation** integrates architectural improvements
    with feature work in related areas. As new features touch a component, teams refactor
    it toward Clean Architecture. This approach minimizes isolated refactoring risk
    but makes progress dependent on feature priorities and may result in uneven transformation.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于机会的转型**将架构改进与相关领域的特性工作相结合。随着新特性触及某个组件，团队将其重构为Clean Architecture。这种方法最小化了孤立重构的风险，但使进度依赖于特性优先级，可能会导致转型不均衡。'
- en: Most successful transformations combine these approaches based on business priorities
    and team structure. Critical components might warrant dedicated efforts, while
    less frequently changed areas can evolve through opportunity-based transformation.
    The key is to explicitly plan how each component will be transformed rather than
    assume a one-size-fits-all approach.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最成功的转型通常根据业务优先级和团队结构结合这些方法。关键组件可能需要专门的努力，而变化较少的区域可以通过基于机会的转型进行演变。关键是明确规划每个组件的转型方式，而不是假设一种一刀切的方法。
- en: Navigating the in-flight transformation
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导航飞行中的转型过程
- en: 'During transformation, the system will temporarily contain a mixture of old
    and new architectural approaches. Careful planning of these transitional states
    is crucial to maintain system stability. For each component being transformed,
    the plan should address:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在转型期间，系统将暂时包含旧的和新的架构方法混合。对这些过渡状态的仔细规划对于保持系统稳定性至关重要。对于每个正在转型的组件，计划应解决：
- en: '**Parallel operation strategy**: How old and new implementations will coexist'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行操作策略**：旧实现和新实现将如何共存'
- en: '**Verification approach**: Methods to confirm functional equivalence'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证方法**：确认功能等效性的方法'
- en: '**Cutover criteria**: Clear conditions for switching to the new implementation'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切换标准**：切换到新实现的明确条件'
- en: '**Rollback procedures**: Safety mechanisms if issues emerge'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回滚程序**：出现问题时采取的安全机制'
- en: Comprehensive testing strategies are essential during these transitions. Regression
    test suites validate that new implementations maintain existing functionality,
    while interface compatibility tests ensure that transformed components correctly
    integrate with the broader system. **Feature flags** provide an effective cutover
    mechanism, allowing teams to selectively enable new implementations for specific
    users or scenarios while maintaining the ability to instantly revert if issues
    arise.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些过渡期间，全面的测试策略是必不可少的。回归测试套件验证新实现是否保持了现有功能，而接口兼容性测试确保转型后的组件能够正确地与更广泛系统集成。**特性标志**提供了一个有效的切换机制，允许团队为特定用户或场景选择性地启用新实现，同时保持出现问题时能够立即回滚的能力。
- en: It’s important to recognize that while this section outlines a general approach
    to transformation planning, every legacy system presents unique challenges based
    on its size, complexity, technology stack, and business constraints. The scale
    of work will differ dramatically between systems, and teams should adapt these
    guidelines to their specific circumstances. Additional research into techniques
    specific to your technology stack or domain will help you tailor this approach
    to your needs. The key is to maintain a pragmatic mindset, taking Clean Architecture
    principles as a guide rather than a rigid prescription.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到，虽然本节概述了转型规划的一般方法，但每个遗留系统都基于其规模、复杂性、技术堆栈和业务约束而具有独特的挑战。系统的工作规模将在不同系统之间有显著差异，团队应将这些指南适应到他们特定的环境中。对特定于你的技术堆栈或领域的技术的进一步研究将帮助你根据你的需求调整这种方法。关键是保持实用心态，将Clean
    Architecture原则作为指南而不是僵化的规定。
- en: With a comprehensive transformation plan that addresses both the technical changes
    and their implementation logistics, teams are well-positioned to begin the actual
    transformation work. The subsequent sections will explore concrete techniques
    for implementing these plans, starting with establishing core domain boundaries
    and progressively refactoring toward a Clean Architecture.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个全面转型计划中，既解决了技术变化也解决了其实施物流，团队有很好的位置开始实际转型工作。接下来的章节将探讨实施这些计划的具体技术，从建立核心领域边界开始，逐步重构到Clean
    Architecture。
- en: Progressive Clean Architecture implementation
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐步Clean Architecture实施
- en: With our evaluation complete and transformation strategy established, we now
    turn to practical implementation. This section demonstrates how to progressively
    transform a legacy system through carefully staged improvements that deliver the
    greatest architectural value. Rather than attempting to cover the transformation
    process exhaustively, which would require a book of its own, we’ll highlight strategic
    refactoring patterns that establish Clean Architecture boundaries incrementally
    while maintaining system stability.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成评估并建立转型策略后，我们现在转向实际实施。本节演示了如何通过精心分阶段改进，逐步将遗留系统转化为具有最大架构价值的系统。我们不会试图全面覆盖转型过程，因为这需要一本自己的书，我们将突出战略重构模式，这些模式在保持系统稳定性的同时，逐步建立Clean
    Architecture的边界。
- en: The following examples, drawn from an order processing system rather than our
    previous task management application, illustrate how to apply Clean Architecture
    principles to legacy code in a practical manner. Each implementation stage builds
    on the previous one, gradually moving from tangled dependencies toward clean separation
    of concerns, from establishing domain boundaries to creating interfaces that bridge
    old and new architectures.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例，来自一个订单处理系统而非我们之前的任务管理应用，展示了如何以实用方式将Clean Architecture原则应用于遗留代码。每个实现阶段都建立在之前的基础上，逐渐从复杂的依赖关系转向清晰的关注点分离，从建立领域边界到创建连接新旧架构的接口。
- en: Initial system analysis
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始系统分析
- en: In this hypothetical scenario, you find yourself responsible for an order processing
    subsystem that has evolved over several years. What started as a simple Flask
    application for managing customer orders has grown to include payment processing
    and basic order fulfillment. While functionally complete, the codebase exhibits
    significant technical debt, with tangled dependencies, blurred responsibilities,
    and architectural inconsistencies that make even simple changes risky and time-consuming.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个假设场景中，你发现自己负责一个经过数年演变的订单处理子系统。最初是一个简单的Flask应用程序，用于管理客户订单，后来发展到包括支付处理和基本订单履行。虽然功能上完整，但代码库显示出显著的技术债务，包括复杂的依赖关系、模糊的责任和架构不一致，使得即使是简单的更改也变得风险和耗时。
- en: 'The team faces recurring issues that highlight the architectural problems:
    a simple change to the order calculation logic requires modifications in three
    different files; adding a new payment method takes three weeks instead of three
    days; and every deployment comes with the fear of unexpected side effects. Most
    telling, new developers need months to become productive, frequently breaking
    functionality in seemingly unrelated areas when making changes.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 团队面临反复出现的问题，这些问题突出了架构问题：对订单计算逻辑的简单更改需要在三个不同的文件中进行修改；添加新的支付方式需要三周而不是三天；每次部署都伴随着意外副作用的风险。最值得注意的是，新开发人员需要数月时间才能变得高效，在做出更改时，经常在看似无关的领域破坏功能。
- en: Building on the preliminary architectural analysis and domain discovery phases
    described in the first section of this chapter, we’ve identified key architectural
    issues to address in our transformation. Let’s begin by examining the current
    state of the system through the lens of Clean Architecture, identifying specific
    violations and architectural boundaries that need reinforcement.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章第一部分描述的初步架构分析和领域发现阶段的基础上，我们已确定在转型过程中需要解决的关键架构问题。让我们首先通过Clean Architecture的视角来审视系统的当前状态，识别需要加强的具体违规和架构边界。
- en: 'Let’s examine one such file that handles order creation—a central piece of
    the system’s functionality and a prime candidate for our transformation efforts:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一个处理订单创建的文件，这是系统功能的核心部分，也是我们转型努力的理想候选：
- en: '[PRE0]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The beginning of this file already reveals several architectural issues. The
    route handler imports SQLite and requests directly, establishing hard dependencies
    on these specific implementations. The `get_db_connection` function creates a
    direct connection to a specific database, with no abstraction layer. These structural
    choices violate Clean Architecture’s Dependency Rule by allowing outer-layer concerns
    (web framework, database) to penetrate into business logic.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的开头已经揭示了几个架构问题。路由处理程序直接导入SQLite并请求，建立了对这些特定实现的硬依赖。`get_db_connection`函数直接连接到特定数据库，没有抽象层。这些结构选择违反了Clean
    Architecture的依赖规则，允许外层关注点（Web框架、数据库）渗透到业务逻辑。
- en: 'Continuing down the `create_order` function, let’s examine how the route handler
    processes orders:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 继续向下查看`create_order`函数，让我们看看路由处理程序是如何处理订单的：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This middle section demonstrates several Clean Architecture violations. Core
    business logic like inventory checking and price calculation is mixed directly
    with database access. The payment processing logic makes direct HTTP calls to
    an external service, creating a hard dependency that would be difficult to test
    or change. These implementation details should be hidden behind interfaces, in
    accordance with Clean Architecture principles, not exposed directly in business
    logic.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分演示了几个Clean Architecture的违规。核心业务逻辑，如库存检查和价格计算，直接与数据库访问混合。支付处理逻辑直接对外部服务进行HTTP调用，创建了一个难以测试或更改的硬依赖。这些实现细节应该隐藏在接口后面，符合Clean
    Architecture原则，而不是直接暴露在业务逻辑中。
- en: 'Finally, closing out the `create_order` function, we complete the order processing:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`create_order`函数中结束，我们完成了订单处理：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code analysis reveals fundamental architectural problems throughout this
    handler. Direct SQL statements are intertwined with business logic, HTTP responses,
    and external service calls, which are all crammed into a single function with
    no separation of concerns. This structure violates the Single Responsibility Principle
    we discussed in [*Chapter 2*](Chapter_02.xhtml#_idTextAnchor040) and makes changes
    extremely risky, as modifications in one area frequently affect seemingly unrelated
    functionality.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分析揭示了整个处理程序中的基本架构问题。直接SQL语句与业务逻辑、HTTP响应和外部服务调用交织在一起，所有这些都挤在一个单一函数中，没有关注点的分离。这种结构违反了我们[*第2章*](Chapter_02.xhtml#_idTextAnchor040)中讨论的单一职责原则，使得更改极具风险，因为一个区域的修改经常会影响看似无关的功能。
- en: The system lacks the rich domain model we established in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor091)
    as orders and products exist only as database records and dictionaries rather
    than as proper entities with encapsulated behavior and business rules.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 系统缺乏我们在[*第4章*](Chapter_04.xhtml#_idTextAnchor091)中建立的丰富领域模型，因为订单和产品仅作为数据库记录和字典存在，而不是具有封装行为和业务规则的正确实体。
- en: '![Figure 11.3: Entangled responsibilities in the current order processing handler](img/B31577_11_3.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3：当前订单处理程序中的纠缠责任](img/B31577_11_3.png)'
- en: 'Figure 11.3: Entangled responsibilities in the current order processing handler'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：当前订单处理程序中的纠缠责任
- en: '*Figure 11.3* illustrates how a single Flask route handler encompasses multiple
    responsibilities that should be separated according to Clean Architecture principles.
    The business logic is directly connected to infrastructure concerns such as database
    connections and external APIs, violating the Dependency Rule we explored in [*Chapter
    1*](Chapter_01.xhtml#_idTextAnchor015).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.3*展示了单个Flask路由处理程序如何包含多个应该根据Clean Architecture原则分离的责任。业务逻辑直接连接到基础设施关注点，如数据库连接和外部API，违反了我们[*第1章*](Chapter_01.xhtml#_idTextAnchor015)中探讨的依赖规则。'
- en: 'Based on our analysis, we’ve identified key architectural issues to address
    in our transformation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的分析，我们已确定在转型中需要解决的关键架构问题：
- en: '**Boundary violations**: The route handler crosses multiple architectural boundaries,
    mixing web, business logic, and infrastructure concerns'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边界违规**：路由处理程序跨越多个架构边界，混合了Web、业务逻辑和基础设施关注点'
- en: '**Missing domain model**: We need to establish proper domain entities like
    Order and Product as the core of our system'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺少领域模型**：我们需要建立适当的领域实体，如订单和产品，作为我们系统的核心'
- en: '**Dependency inversion needed**: Direct infrastructure dependencies should
    be replaced with abstractions following the principles from [*Chapter 2*](Chapter_02.xhtml#_idTextAnchor040)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖反转需求**：应使用来自[*第2章*](Chapter_02.xhtml#_idTextAnchor040)的原则替换直接的基础设施依赖'
- en: '**Interface separation required**: Clear interfaces between architectural layers
    will help maintain proper boundaries'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口分离要求**：在架构层之间保持清晰的接口将有助于维护适当的边界'
- en: There are key architectural issues in our order creation process; we can see
    a system that evolved without architectural guidance. Business logic, data access,
    and external services are tightly coupled, with no clear boundaries between concerns.
    The system works, but its structure makes it increasingly difficult to maintain,
    extend, or test.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的订单创建过程中存在关键架构问题；我们可以看到一个在没有架构指导的情况下演化的系统。业务逻辑、数据访问和外部服务紧密耦合，没有明确的关注点边界。系统可以工作，但其结构使得维护、扩展或测试变得越来越困难。
- en: With this understanding of the current system, we’re now ready to begin our
    transformation journey. We’ll start by establishing a clean domain model in the
    next section, creating proper boundaries between layers as we progressively refactor
    toward a Clean Architecture.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对当前系统的理解，我们现在准备开始我们的转型之旅。我们将在下一节中建立一个干净的领域模型，在逐步重构向Clean Architecture过渡的过程中创建适当的层间边界。
- en: 'Stage 1: establishing domain boundaries'
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阶段1：建立领域边界
- en: Having analyzed our legacy system, we begin our transformation by establishing
    a clean domain model that will serve as our architectural foundation. Starting
    with the Domain layer provides a stable core around which we can progressively
    rebuild the outer layers of our system.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析了我们的遗留系统之后，我们开始通过建立一个干净的领域模型来启动我们的转型，这个模型将作为我们的架构基础。从领域层开始提供了一个稳定的内核，我们可以围绕它逐步重建系统的外部层。
- en: 'In our order processing system, we need to extract the implicit domain concepts
    buried in our database queries and controller logic. The most critical entities
    in our system appear to be:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的订单处理系统中，我们需要从数据库查询和控制器逻辑中提取隐藏的领域概念。我们系统中最重要的实体似乎如下：
- en: '**Order**: The central business entity'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订单**：中心业务实体'
- en: '**Customer**: The buyer placing the order'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户**：下订单的买家'
- en: '**Product**: Items being purchased'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品**：被购买的项目'
- en: '**OrderItem**: The association between orders and products'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订单项**：订单和产品之间的关联'
- en: 'Let’s begin by implementing the `Order` entity and its related value objects:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现`Order`实体及其相关的值对象开始：
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we’ve defined an `OrderStatus` enum to replace the string constants previously
    used throughout the code. We’ve also created an `OrderItem` value object to represent
    the relationship between orders and products. This approach aligns with the value
    object pattern we explored in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor091),
    creating immutable objects that represent important domain concepts.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个`OrderStatus`枚举来替换之前在代码中使用的字符串常量。我们还创建了一个`OrderItem`值对象来表示订单和产品之间的关系。这种方法与我们探索的值对象模式一致，创建了代表重要领域概念的不可变对象。
- en: 'Now let’s implement the `Order` entity itself:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来实现`Order`实体本身：
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our `Order` entity now properly encapsulates core business concepts that were
    previously scattered throughout the codebase. We’ve implemented methods that enforce
    business rules, such as validating state transitions when marking an order as
    paid. These validations were previously buried in controller logic but now reside
    in their proper home within the entity itself.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Order`实体现在正确地封装了之前在代码库中分散的核心业务概念。我们实现了强制执行业务规则的方法，例如在标记订单为已支付时验证状态转换。这些验证之前被埋藏在控制器逻辑中，但现在位于实体本身的适当位置。
- en: 'We need to create the remaining domain entities to complete our core model:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建剩余的领域实体以完成我们的核心模型：
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Product` entity now encapsulates inventory management logic that was previously
    spread across controller methods. It enforces business rules such as preventing
    negative stock or excessive withdrawals. This is an example of the *tell, don’t
    ask* principle that helps maintain domain integrity.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product` 实体现在封装了之前分散在控制器方法中的库存管理逻辑。它强制执行诸如防止库存为负或过度提取等业务规则。这是*告诉，不要询问*原则的一个例子，有助于维护领域完整性。'
- en: 'With our core domain entities defined, we need to create abstractions for the
    supporting services and repositories. Following the Dependency Inversion Principle
    we’ll define interfaces that the domain needs without coupling to specific implementations:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了我们的核心领域实体之后，我们需要为支持服务和存储库创建抽象。遵循依赖倒置原则，我们将定义领域需要的接口，而不与特定实现耦合：
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This abstract `OrderRepository` defines the operations our Domain layer needs
    without specifying how they’re implemented. We’ll create similar interfaces for
    `ProductRepository` and other necessary repositories. These abstractions are a
    crucial element of Clean Architecture, as they allow our Domain layer to remain
    independent of specific persistence mechanisms.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个抽象的`OrderRepository`定义了我们的领域层需要的操作，而不指定它们是如何实现的。我们将为`ProductRepository`和其他必要的存储库创建类似的接口。这些抽象是Clean
    Architecture的关键元素，因为它们允许我们的领域层保持对特定持久机制的不依赖。
- en: 'If you recall the task management system from previous chapters, we established
    similar repository interfaces such as `TaskRepository` in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor123).
    Both follow the same pattern: defining abstract methods that domain components
    require without specifying implementation details. This consistency demonstrates
    how Clean Architecture’s principles apply across different domains and applications,
    creating a reliable pattern for maintaining proper boundaries.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得前几章中的任务管理系统，我们建立了类似的存储库接口，如[*第5章*](Chapter_05.xhtml#_idTextAnchor123)中的`TaskRepository`。两者遵循相同的模式：定义领域组件需要的抽象方法，而不指定实现细节。这种一致性展示了Clean
    Architecture的原则如何应用于不同的领域和应用，创建了一个维护适当边界的可靠模式。
- en: 'Next, let’s define service interfaces for external operations like payments
    and notifications:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义外部操作如支付和通知的服务接口：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With these core domain components defined, we’ve created a clean foundation
    for our system. The business rules and concepts that were previously scattered
    across controllers and utility functions now have a proper home in a well-structured
    domain model. This transformation provides several immediate benefits:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了这些核心领域组件之后，我们为我们的系统创建了一个干净的基础。之前分散在控制器和实用函数中的业务规则和概念现在有了结构良好的领域模型中的适当归宿。这种转型提供了几个直接的好处：
- en: '**Business rules centralization**: Rules like *cannot mark a non-CREATED order
    as PAID* are now explicitly defined in the domain model'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务规则集中化**：如*不能将非CREATED订单标记为PAID*之类的规则现在在领域模型中明确定义'
- en: '**Improved testability**: Domain entities and services can be tested in isolation
    without requiring database connections or web frameworks'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高可测试性**：领域实体和服务可以在不要求数据库连接或Web框架的情况下独立测试'
- en: '**Clearer boundaries**: The separation between core business concepts and infrastructure
    concerns is now explicit'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更清晰的边界**：核心业务概念和基础设施关注之间的分离现在是明确的'
- en: '**Richer domain model**: We’ve moved from anemic database records to a rich
    domain model with behavior'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更丰富的领域模型**：我们已经从贫血数据库记录转变为具有行为的丰富领域模型'
- en: 'Let’s take a moment to review this new Domain layer:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间来回顾这个新的领域层：
- en: '![Figure 11.4: The newly established domain model with clean boundaries](img/B31577_11_4.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4：新建立的具有清晰边界的领域模型](img/B31577_11_4.png)'
- en: 'Figure 11.4: The newly established domain model with clean boundaries'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：新建立的具有清晰边界的领域模型
- en: 'This diagram illustrates our first major transformation step: establishing
    a proper Domain layer with clean boundaries. We’ve created entities, value objects,
    and service interfaces that encapsulate our core business concepts and rules.
    Comparing this with *Figure 11.2*, we can see significant progress toward untangling
    the responsibilities that were previously mixed in our legacy controller implementation.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此图说明了我们的第一个主要转型步骤：建立一个具有清晰边界的适当领域层。我们创建了实体、值对象和服务接口，它们封装了我们的核心业务概念和规则。与*图11.2*相比，我们可以看到在解开之前在我们遗留控制器实现中混合的责任方面取得了重大进展。
- en: Incremental integration strategies
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增量集成策略
- en: In real-world transformations, a common pitfall is attempting to implement the
    entire Clean Architecture in isolation before integration. This *big bang release*
    approach introduces significant risk since by the time integration occurs, the
    production system may have evolved substantially, creating complex merge conflicts
    and unexpected behavior changes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的转型中，一个常见的陷阱是在集成之前孤立地尝试实现整个Clean Architecture。这种“大爆炸”发布方法引入了重大风险，因为到集成发生时，生产系统可能已经发生了重大变化，创造了复杂的合并冲突和意外的行为变化。
- en: 'To mitigate this risk, several incremental integration strategies can be employed:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这种风险，可以采用几种增量集成策略：
- en: '**Adapter pattern**: Create adapters that bridge legacy components and new
    domain entities, allowing them to coexist within the running system. This enables
    gradual adoption without disrupting existing functionality.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配器模式**：创建适配器，将旧组件和新领域实体连接起来，允许它们在运行系统中共存。这使渐进式采用成为可能，而不会破坏现有功能。'
- en: '**Parallel implementation**: Implement new functionality using Clean Architecture
    alongside legacy code, with feature flags controlling which implementation handles
    requests. This provides an easy rollback mechanism if issues arise.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行实现**：使用Clean Architecture在旧代码旁边实现新功能，使用功能标志控制哪个实现处理请求。如果出现问题，这提供了一个简单的回滚机制。'
- en: '**Strangler Fig pattern**: Incrementally replace pieces of the legacy application
    while maintaining the same external interfaces, gradually supplanting the old
    implementation until it can be safely removed ([https://martinfowler.com/bliki/StranglerFigApplication.html](https://martinfowler.com/bliki/StranglerFigApplication.html)).'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Strangler Fig模式**：在保持相同外部接口的同时，逐步替换旧应用程序的部分，逐渐取代旧实现，直到它可以安全地被移除([https://martinfowler.com/bliki/StranglerFigApplication.html](https://martinfowler.com/bliki/StranglerFigApplication.html))。'
- en: '**Shadow mode**: Run new implementations alongside the production code by use
    of a proxy that duplicates all requests. This gives the new implementation the
    opportunity to process its copy of the request and we compare the outputs with
    the legacy system. This validates behavior without affecting users.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**影子模式**：通过使用代理来复制所有请求，在运行代码旁边运行新的实现。这给新实现提供了处理其请求副本的机会，我们比较输出与旧系统。这验证了行为而不影响用户。'
- en: 'Throughout this incremental transformation, comprehensive **regression testing**
    is absolutely essential. Before making any architectural changes, establish a
    thorough test suite that captures existing system behavior. These tests serve
    multiple purposes:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个增量转型过程中，全面的**回归测试**绝对至关重要。在做出任何架构更改之前，建立一个彻底的测试套件，以捕获现有系统行为。这些测试具有多重目的：
- en: They verify that refactoring hasn’t broken existing functionality
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们验证重构没有破坏现有功能
- en: They document current system behavior for reference
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们记录当前系统行为以供参考
- en: They provide confidence to stakeholders that the transformation is proceeding
    safely
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们向利益相关者提供信心，表明转型正在安全进行
- en: As we discussed in [*Chapter 8*](Chapter_08.xhtml#_idTextAnchor192), testing
    provides crucial safety nets during architectural transformation. For our order
    processing system, we would establish **end-to-end tests** that verify complete
    order flows before beginning our transformation, then supplement these with more
    granular tests as we establish clean architectural boundaries.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第8章*](Chapter_08.xhtml#_idTextAnchor192)中讨论的那样，测试在架构转型期间提供了关键的安全网。对于我们的订单处理系统，我们将在开始转型之前建立**端到端测试**，以验证完整的订单流程，然后随着我们建立干净的架构边界，补充更多更细粒度的测试。
- en: By adopting these incremental strategies and prioritizing regression testing,
    we can transform our system while maintaining stability and continuing to deliver
    business value. In the next section, we’ll begin implementing the production integration
    approach described above, building on our domain model by implementing the Interface
    Adapters layer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用这些增量策略并优先考虑回归测试，我们可以在保持稳定性和继续交付业务价值的同时转型我们的系统。在下一节中，我们将开始实施上述的生产集成方法，通过实现接口适配器层来构建我们的领域模型。
- en: 'Stage 2: Interface layer implementation'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二阶段：接口层实现
- en: 'With our domain entities and interfaces established, we now face a critical
    transition challenge: integrating this clean foundation with our existing codebase.
    Unlike greenfield development, transformation requires us to evolve our system
    incrementally while maintaining continuous operation. The **Interface layer**
    provides our first opportunity to bridge old and new architectures.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立了领域实体和接口之后，我们现在面临一个关键的过渡挑战：将这个清洁基础与我们的现有代码库集成。与绿色场开发不同，转型需要我们逐步演进我们的系统，同时保持持续运行。**接口层**为我们提供了第一个连接新旧架构的机会。
- en: Identifying transformation boundaries
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定转型边界
- en: 'The first step in our transformation is identifying viable seams where we can
    introduce clean interfaces without overly disrupting the existing system. Looking
    back at our legacy controller, the order creation process stands out as a natural
    boundary:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们转型的第一步是确定可行的接缝，在这些接缝中我们可以引入清洁接口而不过度破坏现有系统。回顾我们的遗留控制器，订单创建过程作为一个自然的边界脱颖而出：
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This controller method represents a self-contained workflow with clear inputs
    and outputs, making it an ideal candidate for our initial transformation. Before
    modifying this code, we need to establish comprehensive test coverage that captures
    its current behavior. These tests will serve as our safety net during refactoring,
    ensuring we maintain functionality while improving architecture:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制器方法代表了一个自包含的工作流程，具有清晰的输入和输出，使其成为我们初始转型的理想候选。在修改此代码之前，我们需要建立全面的测试覆盖率，以捕捉其当前的行为。这些测试将在重构期间作为我们的安全网，确保我们在改进架构的同时保持功能：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With tests in place, we can begin implementing the Interface layer components
    that will bridge our clean domain model and the existing infrastructure.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试到位后，我们可以开始实施接口层组件，这些组件将连接我们的清洁领域模型和现有基础设施。
- en: Implementing repository adapters
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实施仓库适配器
- en: Our first step is creating **repository adapters** that satisfy our clean domain
    interfaces while interacting with the existing database schema. This crucial component
    bridges our domain entities and legacy infrastructure.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是创建满足我们的清洁领域接口同时与现有数据库模式交互的**仓库适配器**。这个关键组件连接了我们的领域实体和遗留基础设施。
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This repository adapter plays a vital role in our transformation strategy. You
    may recall from [*Chapter 6*](Chapter_06.xhtml#_idTextAnchor144) that we introduced
    similar repository implementations for our task management system. Like those
    examples, this adapter implements our clean `OrderRepository` interface (from
    *Stage 1*) while handling the details of our existing database schema. The adapter
    translates between domain entities and database records, managing the impedance
    mismatch between our rich domain model and the flat relational structure.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个仓库适配器在我们的转型策略中扮演着至关重要的角色。您可能还记得，在[*第6章*](Chapter_06.xhtml#_idTextAnchor144)中，我们为我们的任务管理系统引入了类似的仓库实现。与这些示例类似，这个适配器实现了我们的清洁`OrderRepository`接口（来自*阶段1*），同时处理我们现有数据库模式的细节。适配器在领域实体和数据库记录之间进行转换，管理我们丰富的领域模型和平坦的关系结构之间的阻抗不匹配。
- en: We would also implement a similar `SQLiteProductRepository` that follows the
    same pattern, implementing a clean domain interface while interacting with the
    existing database schema. These repository implementations handle all database
    access details, connection management, and error handling, providing a clean interface
    to the rest of our architecture.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将实现一个类似的`SQLiteProductRepository`，它遵循相同的模式，实现清洁领域接口同时与现有数据库模式交互。这些仓库实现处理所有数据库访问细节、连接管理和错误处理，为我们的其余架构提供干净的接口。
- en: Additionally, we would implement adapters for external services like payment
    processing. These service adapters would follow the same pattern, implementing
    our clean domain interfaces while encapsulating the details of external service
    interactions. For brevity, we won’t show these implementations here, but the complete
    code is available in the book’s GitHub repository.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将实现支付处理等外部服务的适配器。这些服务适配器将遵循相同的模式，实现我们的清洁领域接口，同时封装外部服务交互的细节。为了简洁，我们在此不展示这些实现，但完整的代码可在本书的GitHub仓库中找到。
- en: With these infrastructure adapters in place, we now have a bridge between our
    clean domain model and the legacy infrastructure. This enables us to implement
    use cases that work with proper domain entities while seamlessly interacting with
    the existing database and external services via interfaces versus interacting
    directly with concrete implementations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些基础设施适配器到位后，我们现在在我们的干净领域模型和遗留基础设施之间有一个桥梁。这使得我们能够实现与适当领域实体一起工作的用例，同时通过接口而不是直接与具体实现交互，无缝地与现有的数据库和外部服务进行交互。
- en: Building clean use cases
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建干净的用例
- en: 'Now that we have repository and service adapters that connect to our existing
    infrastructure, we can implement the use cases that orchestrate our business logic.
    In [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor123), we established that use cases
    serve as application-specific business rules that coordinate domain entities to
    fulfill specific user requirements. Following this pattern, let’s look at the
    order creation use case that will replace our tangled legacy implementation:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了连接到我们现有基础设施的存储库和服务适配器，我们可以实现编排我们业务逻辑的用例。在[*第5章*](Chapter_05.xhtml#_idTextAnchor123)中，我们确立用例作为特定于应用的业务规则，协调领域实体以满足特定的用户需求。遵循这个模式，让我们看看将取代我们混乱的遗留实现的订单创建用例：
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `execute` method of our use case begins by creating an `Order` entity and
    adds items to it, checking inventory availability in the process. Note how it
    works with proper domain entities rather than raw database records.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用例中的`execute`方法首先创建一个`Order`实体，并向其中添加项目，在此过程中检查库存的可用性。注意它如何与适当的领域实体而不是原始数据库记录一起工作。
- en: 'Let’s now examine the remainder of the `execute` method:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来检查`execute`方法的剩余部分：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The second half of our `execute` method continues the order creation process
    by handling payment processing, updating the order status, and saving the completed
    order.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute`方法的下半部分通过处理支付处理、更新订单状态和保存完成的订单来继续订单创建过程。'
- en: 'This use case demonstrates Clean Architecture’s separation of concerns in action.
    It orchestrates the order creation process by:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用例展示了清洁架构在分离关注点方面的实际应用。它通过以下方式编排订单创建过程：
- en: Creating an `Order` entity with basic information
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含基本信息的`Order`实体
- en: Adding items to the order, checking inventory
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向订单中添加项目，检查库存
- en: Processing payment
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理支付
- en: Updating the order status and saving it
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新订单状态并保存
- en: Each step interacts with the domain model through well-defined interfaces, without
    knowledge of the underlying infrastructure. The use case depends on abstract `OrderRepository`,
    `ProductRepository`, and `PaymentService` interfaces, not on concrete implementations.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 每一步都通过定义良好的接口与领域模型进行交互，而不了解底层基础设施。用例依赖于抽象的`OrderRepository`、`ProductRepository`和`PaymentService`接口，而不是具体实现。
- en: Notice how the business rules are now explicit and centralized in this use case.
    Inventory checking, payment processing, and order status management all flow through
    a clean, organized process rather than being scattered across controller methods
    and utility functions. This clarity makes the code more maintainable and adaptable
    to changing requirements.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在业务规则在这个用例中是如何明确和集中的。库存检查、支付处理和订单状态管理都通过一个干净、有序的过程进行，而不是分散在控制器方法和实用函数中。这种清晰性使得代码更易于维护和适应变化的需求。
- en: Implementing clean controllers
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现干净的控制器
- en: 'With our repositories and use cases in place, we now implement **controllers**
    that bridge our web framework and application core. As we established in [*Chapter
    6*](Chapter_06.xhtml#_idTextAnchor144), controllers serve as translation layers
    at the boundary of our architecture, converting external request formats into
    inputs our use cases can process. These controllers maintain the separation between
    our application core and delivery mechanisms, ensuring that web-specific concerns
    don’t penetrate our Clean Architecture:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的存储库和用例到位后，我们现在实现**控制器**，这些控制器连接我们的Web框架和应用核心。正如我们在[*第6章*](Chapter_06.xhtml#_idTextAnchor144)中确立的，控制器在架构的边界处充当翻译层，将外部请求格式转换为用例可以处理的输入。这些控制器保持了应用核心和交付机制之间的分离，确保Web特定的关注点不会渗透到我们的清洁架构中：
- en: '[PRE13]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This controller shows Clean Architecture boundaries at work, functioning as
    a translation layer between external requests and our domain operations. The heart
    of this controller is the single line `order = self.create_use_case.execute(request)`,
    which represents the critical boundary between our Interface layer and application
    core. Notice how the controller doesn’t reference Flask, HTTP status codes, or
    JSON formatting. These web-specific concerns are handled at the framework boundary,
    maintaining a clean separation between our application logic and delivery mechanism.
    This framework independence allows our controller to remain focused on its core
    responsibility, transforming external requests into domain operations and translating
    results back to a format suitable for the caller.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制器展示了清洁架构边界在工作中的情况，作为外部请求和我们的领域操作之间的转换层。这个控制器的核心是一行代码`order = self.create_use_case.execute(request)`，它代表了我们的接口层和应用核心之间的关键边界。注意控制器没有引用Flask、HTTP状态码或JSON格式化。这些特定于Web的关注点在框架边界处处理，保持我们的应用逻辑和交付机制之间的清晰分离。这种框架独立性使得我们的控制器能够专注于其核心责任，将外部请求转换为领域操作，并将结果转换回适合调用者的格式。
- en: 'Stage 3: integration strategy: bridging legacy and clean implementations'
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3阶段：集成策略：连接遗留和清洁实现
- en: 'Now comes the crucial step: integrating our clean implementation with the existing
    system. Rather than immediately replacing the entire legacy route handler, we’ll
    modify it to delegate to our clean controller using the adapter pattern:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是关键步骤：将我们的清洁实现与现有系统集成。而不是立即替换整个遗留路由处理程序，我们将修改它，使用适配器模式委托给我们的清洁控制器：
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The key portion of this modification is the feature flag conditional. When `USE_CLEAN_ARCHITECTURE`
    is enabled, we delegate order processing to our new controller, which then invokes
    the clean use case. This creates a controlled pathway into our Clean Architecture
    implementation without disturbing the existing code path. The feature flag gives
    us a simple mechanism to toggle between implementations, either globally or for
    specific requests.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这次修改的关键部分是功能标志条件。当`USE_CLEAN_ARCHITECTURE`被启用时，我们将订单处理委托给我们的新控制器，然后调用清洁用例。这创建了一个受控的路径进入我们的清洁架构实现，而不会干扰现有的代码路径。功能标志为我们提供了一个简单的机制，可以在实现之间切换，无论是全局的还是针对特定请求的。
- en: 'This modified route handler demonstrates several key transformation patterns:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修改后的路由处理程序展示了几个关键转型模式：
- en: '**Feature flag control**: We use a configuration setting to determine which
    implementation processes the request, allowing us to gradually transition traffic.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能标志控制**：我们使用配置设置来确定哪个实现过程处理请求，这使我们能够逐步过渡流量。'
- en: '**Consistent interfaces**: Both implementations produce identical response
    formats, ensuring a seamless transition from the user’s perspective.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致的接口**：两种实现产生相同的响应格式，确保从用户的角度看无缝过渡。'
- en: '**Incremental migration**: The legacy code remains fully functional, serving
    as a fallback if issues arise with the clean implementation.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渐进式迁移**：遗留代码保持完全功能，作为清洁实现出现问题时的一种回退。'
- en: '**Exception translation**: We map domain-specific exceptions to appropriate
    HTTP responses at the framework boundary.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常转换**：我们在框架边界将领域特定异常映射到适当的HTTP响应。'
- en: When integrating with specific frameworks like Flask, we must attend to framework-specific
    details at the system boundaries. In the case of Flask, we need to configure our
    dependency injection container, register our Clean Architecture components, and
    establish the feature flagging mechanism. We create a central configuration point
    that instantiates all necessary components (repositories, services, use cases,
    and controllers) and wires them together according to Clean Architecture’s dependency
    rules. This configuration happens at application startup, keeping all framework-specific
    initialization code at the system’s edge where it belongs. We saw this in action
    in our task management application in [*Chapter 7*](Chapter_07.xhtml#_idTextAnchor168).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当与特定框架（如Flask）集成时，我们必须在系统边界处关注框架特定的细节。在Flask的情况下，我们需要配置我们的依赖注入容器，注册我们的清洁架构组件，并建立功能标志机制。我们创建一个中央配置点，实例化所有必要的组件（存储库、服务、用例和控制器），并根据清洁架构的依赖规则将它们连接起来。这个配置发生在应用程序启动时，将所有特定于框架的初始化代码保持在系统的边缘，这是它应该所在的位置。我们在我们的任务管理应用程序中看到了这一点在[*第7章*](Chapter_07.xhtml#_idTextAnchor168)中的实际应用。
- en: Incremental transformation approach
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渐进式转型方法
- en: During this transformation process, comprehensive testing is absolutely essential.
    We leverage our regression test suite to ensure that refactoring hasn’t broken
    existing functionality. These tests verify both the legacy implementation and
    our new Clean Architecture components, providing confidence that the transformation
    maintains functional parity.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个转型过程中，全面的测试绝对是必不可少的。我们利用我们的回归测试套件来确保重构没有破坏现有的功能。这些测试验证了遗留实现和我们的新Clean Architecture组件，提供了信心，即转型保持了功能一致性。
- en: Each step of our transformation is carefully validated before proceeding to
    the next. We don’t move forward until we’ve verified that our changes maintain
    system behavior and stability. This incremental approach minimizes risk and allows
    us to deliver value continuously throughout the transformation process.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一步之前，我们会对转型的每一步进行仔细验证。我们不会继续前进，直到我们已经验证我们的更改保持了系统行为和稳定性。这种增量方法最小化了风险，并允许我们在转型过程中持续交付价值。
- en: At a high level, our approach aligns with the Strangler Fig pattern ([https://martinfowler.com/bliki/StranglerFigApplication.html](https://martinfowler.com/bliki/StranglerFigApplication.html)),
    where we gradually replace pieces of the legacy application while maintaining
    the same external interfaces. This approach minimizes risk by allowing incremental
    validation and rollback if needed.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，我们的方法与Strangler Fig模式([https://martinfowler.com/bliki/StranglerFigApplication.html](https://martinfowler.com/bliki/StranglerFigApplication.html))相一致，其中我们逐步替换遗留应用程序的部分，同时保持相同的外部接口。这种方法通过允许增量验证并在需要时回滚来最小化风险。
- en: '![Figure 11.5: Current system architecture showing parallel implementations](img/B31577_11_5.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图11.5：当前系统架构，显示并行实现](img/B31577_11_5.png)'
- en: 'Figure 11.5: Current system architecture showing parallel implementations'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：当前系统架构，显示并行实现
- en: '*Figure 11.5* illustrates our current architectural state, with both legacy
    and clean implementations coexisting in the system. The legacy components represent
    the tangled, unstructured code that directly mixes business logic with infrastructure
    concerns. In contrast, the Clean Architecture implementation shows proper separation
    of concerns with distinct layers and well-defined interfaces.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.5*展示了我们当前的架构状态，系统中同时存在遗留和干净实现。遗留组件代表直接将业务逻辑与基础设施关注点混合在一起的混乱、无结构的代码。相比之下，Clean
    Architecture实现显示了适当的关注点分离，具有不同的层和定义良好的接口。'
- en: 'Through this incremental implementation approach, we’ve made significant progress
    in our transformation journey:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种增量实施方法，我们在转型之旅中取得了重大进展：
- en: We’ve established a clean domain model with proper entities and value objects
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们建立了一个干净的领域模型，具有适当的实体和值对象
- en: We’ve implemented repository adapters that bridge our domain model and the existing
    database
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了仓库适配器，它们连接我们的领域模型和现有的数据库
- en: We’ve created use cases that orchestrate the business logic using our domain
    model
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了使用我们的领域模型编排业务逻辑的用例
- en: We’ve built controllers that translate between web requests and our domain language
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们构建了控制器，它们可以在网络请求和我们的领域语言之间进行转换
- en: We’ve integrated our clean implementation alongside the legacy code using the
    adapter pattern
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用适配器模式将我们的干净实现与遗留代码集成
- en: Through this incremental implementation approach, we’ve demonstrated how to
    transform a legacy system using Clean Architecture principles while maintaining
    system stability and functionality throughout the process.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种增量实施方法，我们展示了如何使用Clean Architecture原则将遗留系统进行转型，同时在整个过程中保持系统稳定性和功能。
- en: 'Stage 4: optimization stage'
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4阶段：优化阶段
- en: While our example has focused primarily on the foundation, interface, and integration
    stages, a complete transformation would eventually include an optimization stage.
    This final phase typically involves performance tuning, expanded test coverage,
    and improved error-handling patterns based on real-world usage.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的示例主要关注基础、接口和集成阶段，但完整的转型最终将包括一个优化阶段。这个最终阶段通常涉及性能调整、扩展测试覆盖范围以及基于实际使用情况改进的错误处理模式。
- en: Rather than providing detailed examples of this stage, we’ll note that optimization
    should be approached with the same incremental mindset. Teams should prioritize
    optimizations that deliver the greatest business value, gradually removing feature
    flags as clean implementations prove stable, and ultimately decommissioning legacy
    code paths entirely.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是提供这个阶段的详细示例，我们将指出，优化应以相同的增量心态来对待。团队应优先考虑能带来最大商业价值的优化，随着干净实现的稳定证明，逐步移除特性标志，并最终完全退役遗留代码路径。
- en: The optimization stage acknowledges that architectural transformation is not
    a one-time effort but rather a continuous refinement process that balances technical
    excellence with business priorities. Teams should define clear metrics for when
    *good enough* has been achieved, avoiding the trap of endless perfectionism.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 优化阶段承认，架构转型不是一个一次性努力，而是一个持续精炼的过程，它平衡了技术卓越与业务优先级。团队应定义明确的指标，以确定何时已达到“足够好”，避免陷入无尽完美主义的陷阱。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve explored how to apply Clean Architecture principles to
    legacy systems through systematic transformation. We began by examining how to
    evaluate existing systems through Clean Architecture’s lens, identifying architectural
    violations, and creating a staged approach to transformation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何通过系统性的转型将Clean Architecture原则应用于遗留系统。我们首先通过Clean Architecture的视角评估现有系统，识别架构违规，并创建了一个分阶段的转型方法。
- en: We established a framework for building stakeholder alignment by translating
    technical debt into business impact terms and gathering deeper domain understanding
    through collaborative techniques like event storming. This collaborative approach
    directly informed our staged implementation plan, grounding our architectural
    decisions in business priorities.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将技术债务转化为业务影响术语，并通过协作技术如事件风暴来收集更深入的领域理解，建立了一个构建利益相关者一致性的框架。这种协作方法直接指导了我们的分阶段实施计划，将我们的架构决策建立在业务优先级的基础上。
- en: Through our order processing example, we demonstrated a progressive implementation
    approach that maintains system stability while establishing clean architectural
    boundaries. We started with the Domain layer, creating proper entities and value
    objects that encapsulate business rules previously scattered throughout the codebase.
    We then implemented repository interfaces that protect our domain from infrastructure
    details, followed by use cases that orchestrate business operations.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的订单处理示例，我们展示了一种渐进式实施方法，在建立清晰的架构边界的同时保持系统稳定性。我们首先从领域层开始，创建了适当的实体和价值对象，它们封装了代码库中之前分散的业务规则。然后我们实现了仓库接口，保护我们的领域免受基础设施细节的影响，接着是使用案例，它们协调业务操作。
- en: The Interface Adapters layer provided a bridge between our clean implementation
    and legacy code, enabling incremental adoption through feature flags and adapter
    patterns. This staged approach allowed us to validate our transformation while
    minimizing risk, demonstrating how Clean Architecture can be applied pragmatically
    to real-world systems.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接口适配层在我们干净的实现和遗留代码之间架起了一座桥梁，通过特性标志和适配器模式实现增量采用。这种分阶段的方法允许我们在最小化风险的同时验证我们的转型，展示了如何将Clean
    Architecture实际应用于现实世界系统。
- en: By following these transformation patterns, you can systematically improve architectural
    quality in existing systems, reducing maintenance costs and increasing adaptability
    while continuing to deliver business value. This approach embodies Clean Architecture’s
    core principles while recognizing the practical constraints of evolving production
    systems.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些转型模式，您可以系统地提高现有系统的架构质量，降低维护成本，提高适应性，同时继续提供商业价值。这种方法体现了Clean Architecture的核心原则，同时认识到不断发展的生产系统的实际限制。
- en: Further reading
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Working Effectively with Legacy Code* ([https://www.oreilly.com/library/view/working-effectively-with/0131177052/](https://www.oreilly.com/library/view/working-effectively-with/0131177052/))
    by Michael Feathers. Provides techniques for working with existing codebases,
    including strategies for safely introducing tests and making incremental improvements.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《与遗留代码有效协作》*（[https://www.oreilly.com/library/view/working-effectively-with/0131177052/](https://www.oreilly.com/library/view/working-effectively-with/0131177052/))，作者：迈克尔·费思。提供了与现有代码库协作的技术，包括安全引入测试和进行增量改进的策略。'
- en: '*Event Storming* ([https://www.eventstorming.com](https://www.eventstorming.com)).
    A great resource for learning more about and planning event storming sessions.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*事件风暴法* ([https://www.eventstorming.com](https://www.eventstorming.com)). 一个学习更多关于事件风暴会议并规划会议的绝佳资源。'
