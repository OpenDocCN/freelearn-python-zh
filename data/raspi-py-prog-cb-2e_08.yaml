- en: Chapter 8. Creating Projects with the Raspberry Pi Camera Module
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。使用Raspberry Pi摄像头模块创建项目
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting started with the Raspberry Pi camera module
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用Raspberry Pi摄像头模块
- en: Using the camera with Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python使用摄像头
- en: Generating a time-lapse video
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成延时视频
- en: Creating a stop frame animation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建定格动画
- en: Making a QR code reader
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作QR码阅读器
- en: Discovering and experimenting with OpenCV
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索和实验OpenCV
- en: Color detection with OpenCV
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenCV进行颜色检测
- en: Performing motion tracking with OpenCV
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenCV进行运动跟踪
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The Raspberry Pi camera module is a special add-on of the Raspberry Pi that
    makes use of the **Camera Serial Interface** (**CSI**) **connector**. This connects
    directly to the GPU core of the Raspberry Pi processor, allowing images to be
    captured directly on the unit.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi摄像头模块是Raspberry Pi的一个特殊附加组件，它利用**摄像头串行接口**（**CSI**）**连接器**。它直接连接到Raspberry
    Pi处理器的GPU核心，允许直接在单元上捕获图像。
- en: We shall create a basic **graphical user interface** (**GUI**) using the `tkinter`
    library we used in [Chapter 3](ch03.html "Chapter 3. Using Python for Automation
    and Productivity"), *Using Python for Automation and Productivity*, and [Chapter
    4](ch04.html "Chapter 4. Creating Games and Graphics"), *Creating Games and Graphics*.
    This will form the basis of the following three examples where we extend the GUI
    with additional controls so that we can put the camera to various uses for a range
    of different projects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在[第3章](ch03.html "第3章。使用Python进行自动化和生产率")和[第4章](ch04.html "第4章。创建游戏和图形")中使用的`tkinter`库创建一个基本的**图形用户界面**（**GUI**）。这些章节分别是《使用Python进行自动化和生产率》和《创建游戏和图形》。这将构成以下三个示例的基础，在这些示例中，我们将通过添加额外的控件来扩展GUI，以便我们可以将相机用于各种不同的项目。
- en: Finally, we set up the powerful **Open Computer Vision** (**OpenCV**) library
    to perform some advanced image processing. We will learn the basics of OpenCV
    and use it to track objects based on their color or detect movement.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将设置功能强大的**开放计算机视觉**（**OpenCV**）库以执行一些高级图像处理。我们将学习OpenCV的基础知识，并使用它根据颜色跟踪对象或检测运动。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This chapter uses the Raspberry Pi camera module, which is available from most
    retailers listed in the *Makers, hobbyists, and Raspberry Pi specialists* section
    of the [Appendix](apa.html "Appendix A. Hardware and Software List"), *Hardware
    and Software List*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用Raspberry Pi摄像头模块，该模块可在[附录](apa.html "附录A。硬件和软件列表")中列出的大多数零售商处获得，该附录位于*Makers,
    hobbyists, and Raspberry Pi specialists*部分，即《硬件和软件列表》。
- en: Getting started with the Raspberry Pi camera module
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Raspberry Pi摄像头模块
- en: 'We will start by installing and setting up the Raspberry Pi camera module;
    then we will create a small camera GUI that enables us to preview and take photos.
    The first GUI we will create is shown in the following image:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先安装和设置Raspberry Pi摄像头模块；然后我们将创建一个小的相机GUI，使我们能够预览和拍照。我们将创建的第一个GUI如图所示：
- en: '![Getting started with the Raspberry Pi camera module](img/6623OT_08_001.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用Raspberry Pi摄像头模块](img/6623OT_08_001.jpg)'
- en: A basic camera GUI for the Raspberry Pi camera module
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi摄像头模块的基本相机GUI
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The Raspberry Pi camera module consists of a camera mounted on a small **Printed
    Circuit Board** (**PCB**) attached to a small ribbon cable. The ribbon cable can
    be attached directly to the CSI port of the Raspberry Pi board (marked as **S5**,
    the port is located between the USB and the HDMI port on the Raspberry Pi). The
    following image shows the Raspberry Pi camera module:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi摄像头模块由一个安装在小型**印刷电路板**（**PCB**）上的摄像头组成，该电路板通过小型扁平电缆连接。扁平电缆可以直接连接到Raspberry
    Pi板的CSI端口（标记为**S5**，该端口位于Raspberry Pi上的USB和HDMI端口之间）。以下图像显示了Raspberry Pi摄像头模块：
- en: '![Getting ready](img/6623OT_08_002.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/6623OT_08_002.jpg)'
- en: The Raspberry Pi camera module
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi摄像头模块
- en: 'The Raspberry Pi Foundation provides detailed instructions (and a video) on
    how to install the camera at [http://www.raspberrypi.org/archives/3890](http://www.raspberrypi.org/archives/3890);
    carry out the following steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi基金会提供了有关如何在[http://www.raspberrypi.org/archives/3890](http://www.raspberrypi.org/archives/3890)安装摄像头的详细说明（以及视频）；执行以下步骤：
- en: First, fit the camera as shown in the following image (ensure that you have
    disconnected the Raspberry Pi from any power sources first):![Getting ready](img/6623OT_08_003.jpg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将相机安装如图所示（确保您首先已将Raspberry Pi从任何电源断开）：![准备工作](img/6623OT_08_003.jpg)
- en: The ribbon connector for the camera module is located next to the HDMI socket
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 摄像头模块的接插件位于 HDMI 插座旁边
- en: To fit the ribbon cable into the CSI socket, you need to gently lift up and
    loosen the tab of the ribbon socket. Insert the ribbon into the slot with the
    metal contacts facing towards the HDMI port. Take care not to bend or fold the
    ribbon cable, and ensure that it is seated firmly and level in the socket before
    pushing the tab back into place.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要将扁平电缆插入 CSI 插座，您需要轻轻抬起并松开扁平电缆插座的卡扣。将扁平电缆插入带有金属触点的插槽中，面向 HDMI 端口。注意不要弯曲或折叠扁平电缆，确保它在插座中牢固且水平，然后再将卡扣推回原位。
- en: Finally, enable the camera. You can do this via the Raspberry Pi Configuration
    GUI on the Raspbian desktop (open this via the **Interfaces** menu).![Getting
    ready](img/6623OT_08_004.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，启用摄像头。您可以通过 Raspbian 桌面上的 Raspberry Pi 配置 GUI 来完成此操作（通过 **接口** 菜单打开）。![准备中](img/6623OT_08_004.jpg)
- en: Enable the Raspberry Pi camera via the Interfaces tab in the Raspberry Pi Configuration
    screen
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过 Raspberry Pi 配置屏幕中的 **接口** 选项卡启用 Raspberry Pi 摄像头
- en: Alternatively, you can do this via the command line, using `raspi-config`. Use
    `sudo raspi-config` to run it, find the menu entry for **Enable Camera**, and
    enable it. You will be prompted to reboot afterwards.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以通过命令行使用 `raspi-config` 来完成此操作。使用 `sudo raspi-config` 来运行它，找到 **启用摄像头**
    的菜单项，并启用它。之后，您将被提示重新启动。
- en: How to do it…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: You can use two programs that are also installed as part of the upgrade—`raspivid`
    and `raspistill`—to test the camera.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用作为升级部分安装的两个程序——`raspivid` 和 `raspistill`——来测试摄像头。
- en: 'To take a single picture, use the following command (`-t 0` takes the picture
    immediately):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要拍摄一张照片，请使用以下命令（`-t 0` 立即拍照）：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To take a short, 10-second video in the H.264 format, use the following command
    (the `-t` value is in milliseconds):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要以 H.264 格式拍摄一个短的视频，时长为 10 秒，请使用以下命令（`-t` 值以毫秒为单位）：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The full documentation of the camera and the `raspivid` and `raspistill` utilities
    is available on the Raspberry Pi site at [http://www.raspberrypi.org/wp-content/uploads/2013/07/RaspiCam-Documentation.pdf](http://www.raspberrypi.org/wp-content/uploads/2013/07/RaspiCam-Documentation.pdf).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像头和 `raspivid`、`raspistill` 工具的完整文档可在 Raspberry Pi 网站上找到，链接为 [http://www.raspberrypi.org/wp-content/uploads/2013/07/RaspiCam-Documentation.pdf](http://www.raspberrypi.org/wp-content/uploads/2013/07/RaspiCam-Documentation.pdf)。
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'To get more information on each of the programs, you can use the `less` command
    to view the instructions (use `q` to quit) as shown:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关每个程序的信息，您可以使用 `less` 命令查看说明（使用 `q` 退出）如下所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each command provides full control of the camera settings, such as exposure,
    white balance, sharpness, contrast, brightness, and the resolution.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令都提供了对摄像头设置的全面控制，例如曝光、白平衡、锐度、对比度、亮度和分辨率。
- en: Using the camera with Python
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 操作摄像头
- en: The camera module on the Raspberry Pi is more than just a standard webcam. Since
    we have full access to the controls and settings from within our own programs,
    it allows us to take control and create our own camera applications.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 上的摄像头模块不仅仅是一个标准网络摄像头。由于我们能够从自己的程序中完全访问控制和设置，它允许我们掌握控制权并创建自己的摄像头应用程序。
- en: In this chapter, we will use the Python module called `picamera` created by
    Dave Hughes to control the camera module, which performs all the functions `raspivid`
    and `raspistill` support.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用由 Dave Hughes 创建的名为 `picamera` 的 Python 模块来控制摄像头模块，该模块执行 `raspivid`
    和 `raspistill` 所支持的所有功能。
- en: See [http://picamera.readthedocs.org](http://picamera.readthedocs.org) for additional
    documentation and lots of useful examples.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [http://picamera.readthedocs.org](http://picamera.readthedocs.org) 以获取更多文档和大量有用的示例。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The Raspberry Pi camera module should be connected and installed as detailed
    in the previous section.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 摄像头模块应按照上一节中的详细说明连接和安装。
- en: In addition, we will also need to install the Python 3 Pillow Library (the details
    of how to do this have been covered in the *Displaying photo information in an
    application* recipe in [Chapter 3](ch03.html "Chapter 3. Using Python for Automation
    and Productivity"), *Using Python for Automation and Productivity*).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要安装 Python 3 Pillow 库（如何在 [第 3 章](ch03.html "第 3 章。使用 Python 进行自动化和生产率")的
    *在应用程序中显示照片信息* 菜谱中完成此操作的详细信息已涵盖），*使用 Python 进行自动化和生产率*。
- en: 'Now, install `picamera` for Python 3 using the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令为 Python 3 安装 `picamera`：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How to do it…
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create the following `cameraGUI.py` script that shall contain the main class
    for the GUI:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下`cameraGUI.py`脚本，该脚本应包含GUI的主类：
- en: '[PRE4]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, create the following `cameraGUI1normal.py` file to use the GUI:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建以下`cameraGUI1normal.py`文件以使用GUI：
- en: '[PRE5]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the example with the following command:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行示例：
- en: '[PRE6]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: In the `cameraGUI.py` file, we use a class called `SET` to contain the settings
    for the application (you will see in the following example why this is particularly
    helpful and allows us to keep all of the references to the settings in one place).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cameraGUI.py`文件中，我们使用一个名为`SET`的类来包含应用程序的设置（你将在下面的示例中看到为什么这特别有用，并允许我们将所有对设置的引用都放在一个地方）。
- en: We will define a base class called `cameraGUI` (so we can attach `Tkinter` objects
    to it), which inherits a `TK.Frame` class. The `cameraGUI` class will contain
    all the methods to create the Tkinter application, including laying out the controls
    and providing all the required functions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个名为`cameraGUI`的基类（这样我们就可以将其附加到Tkinter对象上），它继承自`TK.Frame`类。`cameraGUI`类将包含创建Tkinter应用程序所需的所有方法，包括布局控件和提供所有必需的函数。
- en: 'We define the following three utility functions for the class to use:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为该类定义了以下三个实用函数：
- en: '`run()`: This function will allow us to send commands to be run on the command
    line using `subprocess.call` (we will use `subprocess.call` in the following examples
    to perform video encoding and other applications).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run()`: 此函数将允许我们使用`subprocess.call`在命令行上发送要运行的命令（我们将在下面的示例中使用`subprocess.call`来执行视频编码和其他应用程序）。'
- en: '`getTKImage()`: This function will allow us to create a `TK.PhotoImage` object
    suitable to display on the Tkinter canvas. The Tkinter canvas is unable to directly
    display JPG images, so we use the **Pillow library** (**PIL**) to resize it for
    display and convert it into a **PPM** file (the **Portable PixMap** format, which
    supports more colors than GIF). Since this conversion and resize process can take
    a few seconds, we will use GIF images to provide a quick camera preview images.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getTKImage()`: 此函数将允许我们创建一个适合在Tkinter画布上显示的`TK.PhotoImage`对象。Tkinter画布无法直接显示JPG图像，因此我们使用**Pillow库**（**PIL**）将其调整大小以进行显示，并将其转换为**PPM**文件（**可移植像素图**格式，支持比GIF更多的颜色）。由于此转换和调整大小过程可能需要几秒钟，我们将使用GIF图像来提供快速的相机预览图像。'
- en: '`timestamp()`: This function will allow us to generate a timestamp string that
    we can use to automatically name any images we take.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timestamp()`: 此函数将允许我们生成一个时间戳字符串，我们可以使用它来自动命名我们拍摄的任何图像。'
- en: 'Within the class initializer (`__init__()`), we define all the control variables,
    generate all the GUI objects and controls we want to use, and use the `grid()`
    functions to position the objects. The layout of the GUI is shown in the following
    image:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在类初始化器（`__init__()`）中，我们定义所有控制变量，生成我们想要使用的所有GUI对象和控件，并使用`grid()`函数定位对象。GUI布局如图所示：
- en: '![How it works…](img/6623OT_08_005.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/6623OT_08_005.jpg)'
- en: The layout of the camera GUI
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 相机GUI布局
- en: 'We define the following control variables:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义以下控制变量：
- en: '`self.previewUpdate`: This is linked to the status of the **Preview** checkbox
    (`previewChk`)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.previewUpdate`: 这与**预览**复选框（`previewChk`）的状态相关联'
- en: '`self.filename`: This is linked to text displayed by the `labelFilename` widget'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.filename`: 这与`labelFilename`小部件显示的文本相关联'
- en: We also link the **Shutter** button (`shutterBtn`) to `self.shutter()`, which
    will be called whenever the **Shutter** button is pressed, and the **Exit** button
    (`exitBtn`) to the `self.exit()` function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将**快门**按钮（`shutterBtn`）链接到`self.shutter()`，每当按下**快门**按钮时，都会调用此函数，并将**退出**按钮（`exitBtn`）链接到`self.exit()`函数。
- en: Finally, in the `__init__()` function, we call `self.preview()`, which will
    ensure that **Camera GUI** takes a picture and displays it as soon as the application
    has started.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`__init__()`函数中，我们调用`self.preview()`，这将确保**相机GUI**在应用程序启动后立即拍照并显示。
- en: When the **Shutter** button is pressed, `self.shutter()` is called. This calls
    `this.btnState("disabled")` to disable the **Shutter** button while we are taking
    new pictures. This prevents any pictures being taken while the camera is already
    in use. When the rest of the actions have been completed, `this.btnState("active")`
    is used to re-enable the button.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下**快门**按钮时，会调用`self.shutter()`。这会调用`this.btnState("disabled")`来禁用**快门**按钮，在我们拍摄新照片时，这将防止拍摄任何照片。当其他操作完成时，使用`this.btnState("active")`来重新启用按钮。
- en: The `self.shutter()` function will call either the `self.normal()` or `self.preview()`
    function, depending on the status of the **Preview** checkbox (by getting the
    value of `self.previewUpdate`).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.shutter()`函数将根据**预览**复选框的状态（通过获取`self.previewUpdate`的值）调用`self.normal()`或`self.preview()`函数。'
- en: The `cameraGUI.camCapture()` function uses `pycamera` to create a camera object,
    set the resolution, and capture an image using the required filename. The `self.preview()`
    function takes an image called `PREVIEW_FILE` with a resolution of `PV_SIZE` as
    defined in the `SET` class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`cameraGUI.camCapture()`函数使用`pycamera`创建摄像头对象，设置分辨率，并使用所需的文件名捕获图像。`self.preview()`函数使用在`SET`类中定义的`PV_SIZE`分辨率的一个名为`PREVIEW_FILE`的图像。'
- en: Next, `self.updateDisp(PREVIEW_FILE)` is called and will use `cameraGUI.getTKImage()`
    to open the generated `PREVIEW.gif` file as a `TK.PhotoImage` object and apply
    it to the `Canvas` object in the GUI. We now call `self.update()`, which is a
    function inherited from the `TK.Frame` class; `self.update()` will allow the Tkinter
    display to be updated (in this case, with the new image). Finally, the `self.preview()`
    function will also call `self.msg()`, which will update the `self.filename` value
    with the filename of the image being displayed (`PREVIEW.gif`). Again, this also
    uses `self.update()` to update the display.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调用`self.updateDisp(PREVIEW_FILE)`，它将使用`cameraGUI.getTKImage()`打开生成的`PREVIEW.gif`文件作为`TK.PhotoImage`对象，并将其应用到GUI中的`Canvas`对象上。现在我们调用`self.update()`，这是一个从`TK.Frame`类继承来的函数；`self.update()`将允许Tkinter显示更新（在这种情况下，使用新图像）。最后，`self.preview()`函数也会调用`self.msg()`，这将更新`self.filename`值，以显示的图像文件名（`PREVIEW.gif`）为准。同样，这也使用`self.update()`来更新显示。
- en: If the **Preview** checkbox is unchecked, then the `self.shutter()` function
    will call `self.normal()`. However, this time it will take a much larger 2,592
    x 1,944 (5 megapixel) JPG image with the filename set to the latest `<timestamp>`
    value obtained from `self.timestamp()`. The resultant image is also resized and
    converted to a PPM image so it can be loaded as a `TK.PhotoImage` object that
    will be displayed in the application window.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**预览**复选框未选中，那么`self.shutter()`函数将调用`self.normal()`。然而，这次它将捕获一个更大的2,592 x
    1,944（500万像素）JPG图像，文件名设置为从`self.timestamp()`获取的最新`<timestamp>`值。生成的图像也将被调整大小并转换为PPM图像，以便它可以作为`TK.PhotoImage`对象加载，并在应用程序窗口中显示。
- en: There's more…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The camera application makes use of class structures to organize the code and
    make it easy to extend. In the following sections, we explain the types of methods
    and functions we have defined to allow this.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像头应用程序使用类结构来组织代码并使其易于扩展。在接下来的章节中，我们将解释我们定义的方法和函数类型，以允许这样做。
- en: The Raspberry Pi can also make use of standard USB cameras or webcams. Alternatively,
    we can use additional Video4Linux drivers to allow the camera module to work like
    a standard webcam.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派还可以使用标准的USB摄像头或网络摄像头。或者，我们可以使用额外的Video4Linux驱动程序，使摄像头模块像标准网络摄像头一样工作。
- en: Class member and static functions
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类成员和静态函数
- en: The `cameraGUI` class has two types of function defined. First, we define some
    static methods (`run()`, `getTKImage()`, and `timestamp()`). These methods are
    tied to the class rather than to a specific instance; this means that we can use
    them without referring to a particular `cameraGUI` object but to the class itself.
    This is useful to define utility functions that are related to the class, since
    they may be useful in other parts of the program as well and may not need to access
    the data/objects contained within a `cameraGUI` object. The functions can be called
    using `cameraGUI.run("command")`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`cameraGUI`类定义了两种类型的函数。首先，我们定义了一些静态方法（`run()`、`getTKImage()`和`timestamp()`）。这些方法与类相关联，而不是与特定实例相关联；这意味着我们可以使用它们而不需要引用特定的`cameraGUI`对象，而是直接引用类本身。这很有用，因为可以定义与类相关的实用函数，因为它们可能在程序的其它部分也有用，并且可能不需要访问`cameraGUI`对象中的数据/对象。这些函数可以通过`cameraGUI.run("command")`来调用。'
- en: Next, we define the class member functions that, as in the previous classes
    we have used, include a reference to `self`. This means that they are only accessible
    to instances of the class (objects of the type `cameraGUI`) and can use the data
    contained within the object (using the `self` reference).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义类成员函数，就像我们在之前的类中使用的那样，包括对`self`的引用。这意味着它们只能由类的实例（`cameraGUI`类型的对象）访问，并且可以使用对象内部包含的数据（使用`self`引用）。
- en: Using a USB webcam instead
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用USB网络摄像头代替
- en: The Raspberry Pi camera module is not the only way you can add a camera to the
    Raspberry Pi; in most cases, you can use a USB webcam as well. The current Raspberry
    Pi Raspbian image should detect the most common webcam devices automatically when
    you plug them in; however, the support can vary.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派摄像头模块并不是唯一可以添加摄像头到树莓派的方法；在大多数情况下，你也可以使用USB摄像头。当前的树莓派Raspbian镜像应该会在你插入时自动检测到最常见的摄像头设备；然而，支持可能会有所不同。
- en: 'To determine if your webcam has been detected, check to see if the following
    device file has been created on your system by running the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定你的摄像头是否已被检测到，请运行以下命令检查系统上是否已创建以下设备文件：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If detected successfully, you will see `/dev/video0` or something similar, which
    is the reference you will use to access your webcam.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果检测成功，你将看到`/dev/video0`或类似的内容，这将是你用来访问摄像头的参考。
- en: 'Install a suitable image capture program, such as `fswebcam`, using the following
    command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令安装一个合适的图像捕捉程序，例如`fswebcam`：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can test it with the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令进行测试：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Or alternatively, you can test it using `dd` as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用以下方式使用`dd`进行测试：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Webcams can require additional power from the USB ports of the Raspberry Pi;
    if you get errors, you may find that using a powered USB hub helps. For a list
    of supported devices and for troubleshooting, see the Raspberry Pi wiki page at
    [http://elinux.org/RPi_USB_Webcams](http://elinux.org/RPi_USB_Webcams).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像头可能需要从树莓派的USB端口获取额外的电源；如果你遇到错误，你可能发现使用带电源的USB集线器有帮助。有关支持的设备列表和故障排除信息，请参阅树莓派维基页面[http://elinux.org/RPi_USB_Webcams](http://elinux.org/RPi_USB_Webcams)。
- en: 'In the previous example, change the following functions in the `cameraGUI`
    class as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，按照以下方式修改`cameraGUI`类中的以下函数：
- en: Remove `camCapture()` and remove `import picamera as picam` from the start of
    the file.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件开头移除`camCapture()`和`import picamera as picam`。
- en: 'Within `normal()`, replace `cameraGUI.camCapture(name,SET.NORM_SIZE)` with
    the following:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`normal()`函数中，将`cameraGUI.camCapture(name,SET.NORM_SIZE)`替换为以下内容：
- en: '[PRE11]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Within `preview()`, replace `cameraGUI.camCapture(SET.PREVIEW_FILE,SET.PV_SIZE)`
    with the following:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`preview()`函数中，将`cameraGUI.camCapture(SET.PREVIEW_FILE,SET.PV_SIZE)`替换为以下内容：
- en: '[PRE12]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Within the `SET` class, define the following variables:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SET`类中，定义以下变量：
- en: '[PRE13]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By making the previous changes to the `cameraGUI` class, the connected USB webcam
    will take the images instead.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对`cameraGUI`类进行之前的修改，连接的USB摄像头将负责捕捉图像。
- en: Additional drivers for the Raspberry Pi camera
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 树莓派摄像头的额外驱动程序
- en: Video4Linux drivers are available for the Raspberry Pi camera module. While
    these additional drivers are not quite official yet, it is likely that they will
    be included in the Raspbian image when they are. For more details, see [http://www.linux-projects.org/uv4l/](http://www.linux-projects.org/uv4l/).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Video4Linux驱动程序适用于树莓派摄像头模块。虽然这些额外的驱动程序还不是官方的，但它们很可能在它们成为官方时被包含在Raspbian镜像中。有关更多详细信息，请参阅[http://www.linux-projects.org/uv4l/](http://www.linux-projects.org/uv4l/)。
- en: The driver will allow you to use the camera module like you would a USB webcam,
    as a `/dev/video*` device, although you will not need this for the examples in
    this chapter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序将允许你像使用USB摄像头一样使用摄像头模块，作为一个`/dev/video*`设备，尽管在本章的示例中你可能不需要这样做。
- en: 'Perform the following steps to install the additional drivers:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来安装额外的驱动程序：
- en: 'First, download the `apt` keys and add the source to the `apt` sources list.
    You can do this with the following commands:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，下载`apt`密钥并将源添加到`apt`源列表中。你可以使用以下命令完成此操作：
- en: '[PRE14]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following into the file (on a single line):'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到文件中（单行）：
- en: '[PRE15]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Install the drivers with the following commands:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装驱动程序：
- en: '[PRE16]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To use the `uv4l` driver, load it using the following command (on a single
    line):'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`uv4l`驱动程序，使用以下命令加载它（单行）：
- en: '[PRE17]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The Raspberry Pi will then be accessible through `/dev/video0` (depending on
    whether you have other video devices installed). It can be used with standard
    webcam programs.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过`/dev/video0`（取决于你是否安装了其他视频设备）访问树莓派。它可以与标准的摄像头程序一起使用。
- en: See also
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For more examples on using the Tkinter library, see [Chapter 3](ch03.html "Chapter 3. Using
    Python for Automation and Productivity"), *Using Python for Automation and Productivity*,
    and [Chapter 4](ch04.html "Chapter 4. Creating Games and Graphics"), *Creating
    Games and Graphics*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用Tkinter库的更多示例，请参阅第3章[使用Python进行自动化和生产力](ch03.html "Chapter 3. Using Python
    for Automation and Productivity")，*使用Python进行自动化和生产力*，以及第4章[创建游戏和图形](ch04.html
    "Chapter 4. Creating Games and Graphics")，*创建游戏和图形*。
- en: Generating a time-lapse video
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成时间间隔视频
- en: Having a camera attached to a computer provides us with a great way to take
    pictures at controlled intervals and automatically process them into a video to
    create a time-lapse sequence. The `pycamera` Python module has a special `capture_continuous()`
    function that will create a series of images. For the time-lapse video, we will
    specify the time between each image and the total number of images that need to
    be taken. To help the user, we will also calculate the overall duration of the
    video to provide an indication of how long it will take.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将相机连接到计算机为我们提供了一个在可控间隔拍照并自动将它们处理成视频以创建时间间隔序列的绝佳方式。`pycamera` Python 模块有一个特殊的
    `capture_continuous()` 函数，可以创建一系列图像。对于时间间隔视频，我们将指定每张图像之间的时间和需要拍摄的总图像数。为了帮助用户，我们还将计算视频的总时长，以提供所需时间的指示。
- en: 'We shall add to our previous GUI interface to provide controls to run time
    lapses and also automatically generate a video clip from the results. The GUI
    will now look similar to the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向之前的 GUI 界面添加控件以运行时间间隔，并自动从结果生成视频剪辑。GUI 现在看起来类似于以下截图：
- en: '![Generating a time-lapse video](img/6623OT_08_006.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![生成时间间隔视频](img/6623OT_08_006.jpg)'
- en: The time-lapse application
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 时间间隔应用程序
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need everything set up as it was for the previous example, including
    the `cameraGUI.py` file that we created in the same directory and `pycamera`,
    which we installed. We shall also use `mencoder`, which will allow us to take
    the time-lapse images and combine them into a video clip.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要设置与上一个示例相同，包括在同一目录中创建的 `cameraGUI.py` 文件和安装的 `pycamera`。我们还将使用 `mencoder`，这将允许我们将时间间隔图像组合成视频剪辑。
- en: 'To install `mencoder`, use `apt-get`, as shown in the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `mencoder`，使用 `apt-get`，如下所示：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: An explanation of the command-line options can be found in the `mencoder` man
    pages.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行选项的解释可以在 `mencoder` 的 man 页面中找到。
- en: How to do it…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create `timelapseGUI.py` in the same directory as `cameraGUI.py` by performing
    the following steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在与 `cameraGUI.py` 相同的目录下创建 `timelapseGUI.py`，按照以下步骤操作：
- en: 'Start by importing the supporting modules (including `cameraGUI`) as shown
    in the following code snippet:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入支持模块（包括 `cameraGUI`），如下所示：
- en: '[PRE19]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Extend the `cameraGUI.SET` class with settings for the time lapse and encoding
    as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `cameraGUI.SET` 类扩展为以下时间间隔和编码设置：
- en: '[PRE20]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Extend the main `cameraGUI` class with an additional function to perform the
    time lapse as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下方式扩展主 `cameraGUI` 类以执行时间间隔的附加功能：
- en: '[PRE21]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the extra controls for the time-lapse GUI as shown in the following code
    snippet:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码片段中所示的时间间隔 GUI 的额外控件：
- en: '[PRE22]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add supporting functions to calculate the settings and handle the time lapse
    as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下支持函数来计算设置和处理时间间隔：
- en: '[PRE23]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add supporting functions to handle and generate the time-lapse video as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加支持函数来处理和生成时间间隔视频，如下所示：
- en: '[PRE24]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, create the following `cameraGUI2timelapse.py` script to use the GUI:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建以下 `cameraGUI2timelapse.py` 脚本来使用 GUI：
- en: '[PRE25]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We import `timelapseGUI` instead of `cameraGUI`; this will add the `timelapseGUI`
    module to the `cameraGUI` script.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 `timelapseGUI` 而不是 `cameraGUI`；这将把 `timelapseGUI` 模块添加到 `cameraGUI` 脚本中。
- en: 'Run the example with the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行示例：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `timelapseGUI.py` script allows us to take the classes defined in `cameraGUI.py`
    and extend them. The previous `cameraGUI` class inherits all of the content of
    the `TK.Frame` class, and using the same technique we can also inherit the `SET`
    and `cameraGUI` classes in our application.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`timelapseGUI.py` 脚本允许我们使用 `cameraGUI.py` 中定义的类并扩展它们。之前的 `cameraGUI` 类继承了 `TK.Frame`
    类的所有内容，通过使用相同的技巧，我们也可以在我们的应用程序中继承 `SET` 和 `cameraGUI` 类。'
- en: We add some additional settings to the `SET` class to provide the settings for
    `mencoder` (to encode the video).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `SET` 类添加一些额外的设置，以提供 `mencoder`（用于编码视频）的设置。
- en: 'We shall extend the basic `cameraGUI` class by inheriting from `camGUI.cameraGUI`
    and defining a new version of `__init__()` for the class. Using `super()`, we
    can include the functionality from the original `__init__()` function and then
    define the extra controls we want to add to the GUI. The extended GUI is shown
    in the following screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过从 `camGUI.cameraGUI` 继承并定义类的新版本 `__init__()` 来扩展基本的 `cameraGUI` 类。使用 `super()`，我们可以包含原始
    `__init__()` 函数的功能，然后定义我们想要添加到 GUI 中的额外控件。扩展后的 GUI 如下截图所示：
- en: '![How it works…](img/6623OT_08_007.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/6623OT_08_007.jpg)'
- en: The time-lapse GUI layout that extends the base camera GUI
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展基本相机GUI的时间流逝GUI布局
- en: 'We define the following control variables:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义以下控制变量：
- en: '`self.numImageTL`: This is linked to the value of the `numImgSpn` spinbox control
    to specify the number of images we want to take in our time lapse (and also provide
    the `numimages` value for `camTimelapse`).'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.numImageTL`: 这与`numImgSpn`微调框控制器的值相关联，用于指定我们想要在时间流逝中拍摄的照片数量（并为`camTimelapse`提供`numimages`值）。'
- en: '`self.peroidTL`: This is linked to the value of the `peroidSpn` spinbox control;
    it determines how many seconds there should be between the time-lapse images (and
    also provides the `timedelay` value for `camTimelapse`).'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.peroidTL`: 这与`peroidSpn`微调框控制器的值相关联；它决定了时间流逝图像之间应该有多少秒（并为`camTimelapse`提供`timedelay`值）。'
- en: '`self.totalTimeTL`: This is linked to the `totalTime` label object. It is calculated
    using the number of images and the `timedelay` time between each to indicate how
    long the time lapse will run for.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.totalTimeTL`: 这与`totalTime`标签对象相关联。它通过图像数量和每张图像之间的`timedelay`时间来计算，以指示时间流逝将运行多长时间。'
- en: '`self.genVideoTL`: This controls the state of the `genChk` checkbox control.
    It is used to determine whether the video has been generated after the time-lapse
    images have been taken.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.genVideoTL`: 这控制着`genChk`复选框控件的状态。它用于确定在拍摄时间流逝图像之后是否已生成视频。'
- en: We link both of the spinbox controls to `self.calcTLTotalTime()` so that when
    they are changed, the `totalTimeTL` value is also updated (although it is not
    called if they are edited directly). We link `genChk` to `self.genVideoChk()`
    and `TLBtn` to `self.timelapse()`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将两个微调框控制器链接到`self.calcTLTotalTime()`，以便当它们被更改时，`totalTimeTL`值也会更新（尽管如果它们被直接编辑则不会调用）。我们将`genChk`链接到`self.genVideoChk()`，将`TLBtn`链接到`self.timelapse()`。
- en: Finally, we specify the positions of the controls using `grid()` and set some
    defaults for the time-lapse settings.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`grid()`指定控件的位置，并为时间流逝设置一些默认值。
- en: The `self.genVideoChk()` function is called when the `genChk` checkbox is ticked
    or cleared. This allows us to inform the user of the effect that this checkbox
    has by generating a pop-up message box to say if the video will be generated at
    the end of the time lapse or if just images will be created.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当`genChk`复选框被勾选或清除时，会调用`self.genVideoChk()`函数。这允许我们通过生成一个弹出消息框来告知用户此复选框的效果，说明视频是否将在时间流逝结束时生成，或者只是创建图像。
- en: When the **TL GO!** button is pressed (`TLBtn`), `self.timelapse()` is called;
    this will disable the **Shutter** and **TL GO!** buttons (since we have also extended
    the `self.btnState()` function). The `self.timelapse()` function will also set
    the `self.tstamp` value so the same timestamp can be used for the images and the
    resulting video file (if generated).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下**TL GO!**按钮（`TLBtn`）时，会调用`self.timelapse()`；这将禁用**快门**和**TL GO!**按钮（因为我们还扩展了`self.btnState()`函数）。`self.timelapse()`函数还将设置`self.tstamp`值，以便可以使用相同的时间戳用于图像和生成的视频文件（如果生成）。
- en: 'The time lapse is run using the `camTimelapse()` function as shown in the following
    code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 时间流逝是通过`camTimelapse()`函数运行的，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We create a new `PiCamera` object, set the image resolution, and start a `for…in`
    loop for `capture_continuous()`. Each time an image is taken, we print the filename
    and then wait for the required `timedelay` value. Finally, when the required number
    of images have been taken, we break out of the loop and continue.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的`PiCamera`对象，设置图像分辨率，并启动一个`for…in`循环用于`capture_continuous()`。每次拍摄图像时，我们打印文件名，然后等待所需的`timedelay`值。最后，当拍摄了所需数量的图像时，我们退出循环并继续。
- en: Once this is complete, we check the value of `self.genVideoTL` to determine
    if we want to generate the video (which is handled by `genTLVideo()`).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们检查`self.genVideoTL`的值以确定是否要生成视频（由`genTLVideo()`处理）。
- en: 'To generate the video, we first run the following command to create an `image_list.txt`
    file of the images:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成视频，我们首先运行以下命令以创建一个包含图像的`image_list.txt`文件：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then we run `mencoder` with the suitable settings (see the `mencoder` man pages
    for what each item does) to create an MPEG4-encoded (8 Mbps) AVI file with 24
    `frames per second (fps)` from the list of time-lapse images. The equivalent command
    (defined by `ENC_PROG`) is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用合适的设置运行`mencoder`（参见`mencoder`手册页面了解每个项目的作用）来创建一个从时间流逝图像列表中生成的MPEG4编码（8
    Mbps）AVI文件，每秒24帧（fps）。等效命令（由`ENC_PROG`定义）如下：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Tip
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Long commands can be split into several lines on the command terminal by using
    the `\` character. This allows you to continue writing the command on another
    line, only executing it when you finish a line without the `\` character.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令终端中，可以使用`\`字符将长命令拆分为多行。这允许你在另一行继续编写命令，只有在你完成一行且没有`\`字符时才会执行该命令。
- en: There's more…
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This chapter uses methods such as class inheritance and function overriding
    to structure and reuse our code in a number of different ways. When used correctly,
    these methods could enable us to design complex systems in a logical and flexible
    way.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用类继承和函数重写等方法以多种不同的方式组织和重用我们的代码。当正确使用时，这些方法可以让我们以逻辑和灵活的方式设计复杂的系统。
- en: 'Additionally, when generating your own time-lapse sequences, you can opt to
    switch off the LED on the camera module or make use of the low-light version of
    the Raspberry Pi camera: the NoIR camera.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在生成自己的延时摄影序列时，你可以选择关闭相机模块上的LED灯或使用树莓派相机的低光版本：NoIR相机。
- en: Class inheritance and function overriding
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类继承和函数重写
- en: In the previous example, we used some clever coding in order to reuse our original
    `cameraGUI` class and create a plugin file that extends its features.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了一些巧妙的编码来重用我们的原始`cameraGUI`类并创建一个扩展其功能的插件文件。
- en: 'The class name does not have to be the same as `cameraGUI` (we just use it
    in this case so we can swap out the additional GUI components just by changing
    the file we import). In fact, we could define one basic class that contains several
    general functions and then extend the class by inheritance into a number of subclasses;
    here, each subclass defines specific behaviors, functions, and data. The extending
    and structuring of the subclasses is shown in the following diagram:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 类名不必与`cameraGUI`相同（我们只是在这个例子中使用它，这样我们就可以通过更改导入的文件来替换额外的GUI组件）。实际上，我们可以定义一个包含几个通用函数的基本类，然后通过继承将其扩展到多个子类中；在这里，每个子类定义特定的行为、函数和数据。子类的扩展和结构在以下图中显示：
- en: '![Class inheritance and function overriding](img/6623OT_08_008.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![类继承和函数重写](img/6623OT_08_008.jpg)'
- en: This diagram shows how classes can be extended and structured
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示了类如何扩展和结构化
- en: To illustrate this, we will take a non-code example in which we have written
    a general recipe for preparing a cake. You can then extend the `basicCake` recipe
    by inheriting all the `basicCake` elements and add some additional steps (equivalent
    code functions) to perhaps add icing/frosting on top to make an `icedCake(basicCake)`
    class. We did this with our `SET` class by adding additional items to an existing
    class (we just chose not to change the name).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们将举一个非代码示例，其中我们编写了一个制作蛋糕的通用食谱。然后你可以通过继承所有`basicCake`元素来扩展`basicCake`食谱，并添加一些额外的步骤（相当于代码函数），例如在顶部添加糖霜/奶油霜以制作`icedCake(basicCake)`类。我们通过向现有类添加额外项（我们只是选择不更改名称）来这样做我们的`SET`类。
- en: We can also add in some additional elements to the existing steps (add some
    currants at the `addIngredients` step and create `currantCake(basicCake)`). We
    have done this using the `super()` function in our code by adding additional parts
    to the `__init__()` function. For example, we would use `super(basicCake.self).addIngredients()`
    to include all the steps in the `addIngredients()` function defined in the `basicCake`
    class, and then add an extra step to include currants. The advantage is if we
    then change the basic cake ingredients, it will also flow through to all the other
    classes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向现有步骤添加一些额外的元素（在`addIngredients`步骤中添加一些葡萄干并创建`currantCake(basicCake)`）。我们通过在代码中使用`super()`函数，通过向`__init__()`函数添加额外部分来实现这一点。例如，我们会使用`super(basicCake.self).addIngredients()`来包含在`basicCake`类中定义的`addIngredients()`函数中的所有步骤，然后添加一个额外的步骤来包含葡萄干。优点是，如果我们随后更改基本蛋糕的成分，它也会影响到所有其他类。
- en: You could even override some of the original functions by replacing them with
    new ones; for instance, you could replace the original recipe for `basicCake`
    with one to make `chocolateCake(basicCake)` while still using the same instructions
    to cook, and so on. We can do this by defining replacement functions with the
    same names without using `super()`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以通过用新函数替换它们来覆盖一些原始函数；例如，你可以用制作`chocolateCake(basicCake)`的食谱替换原始的`basicCake`食谱，同时仍然使用相同的烹饪说明，等等。我们可以通过定义具有相同名称的替换函数来实现这一点，而不使用`super()`。
- en: Using structured design in this way can become very powerful since we can easily
    create many variants of the same sort of object but have all the common elements
    defined in the same place. This has many advantages when it comes to testing,
    developing, and maintaining large and complex systems. The key here is to take
    an overall view of your project and try to identify the common elements before
    you begin. You will find that the better the structure you have, the easier it
    is to develop and improve it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用结构化设计可以变得非常强大，因为我们可以轻松地创建许多相同类型对象的变体，但所有公共元素都定义在同一个地方。这在测试、开发和维护大型复杂系统时具有许多优点。关键在于在开始之前对整个项目有一个全面的了解，并尝试识别公共元素。你会发现，你拥有的结构越好，开发和改进它就越容易。
- en: For more information on this, it is worth reading up on object-oriented design
    methods and how to use **Unified Modelling Language** (**UML**) to help you describe
    and understand your system.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这方面的更多信息，值得阅读关于面向对象设计方法和如何使用**统一建模语言**（**UML**）来帮助您描述和理解您的系统的内容。
- en: Disabling the camera LED
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禁用摄像头LED
- en: If you want to create time-lapse videos at night or next to windows, you may
    notice that the red camera LED (which lights up for every shot) adds unwanted
    light or reflections. Fortunately, the camera LED can be controlled through the
    GPIO. The LED is controlled using `GPIO.BCM` Pin 5; unfortunately, there isn't
    an equivalent `GPIO.BOARD` pin number for it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在夜间或靠近窗户时创建时间流逝视频，你可能注意到红色摄像头LED（每次拍摄都会点亮）会添加不需要的光线或反射。幸运的是，可以通过GPIO控制摄像头LED。LED是通过`GPIO.BCM`引脚5控制的；不幸的是，没有与之等效的`GPIO.BOARD`引脚编号。
- en: 'To add it to a Python script, use the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其添加到Python脚本中，请使用以下代码：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Alternatively, you could use the LED for something else, for example, as an
    indicator as part of a delay timer that provides a countdown and warning that
    the camera is about to take an image.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以将LED用于其他用途，例如，作为延迟计时器的一部分的指示器，该计时器提供倒计时和警告，表明相机即将拍照。
- en: Pi NoIR – taking night shots
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pi NoIR – 拍摄夜景
- en: There is also a variant of the Raspberry Pi camera module available called **Pi
    NoIR**. This version of the camera is the same as the original, except that the
    internal infrared filter has been removed. Among other things, this allows you
    to use infrared lighting to illuminate areas at night time (just like most night
    security cameras do) and see everything that is happening in the dark!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种名为**Pi NoIR**的Raspberry Pi摄像头模块的变体。这种摄像头的版本与原始版本相同，只是内部的红外滤光片已被移除。除此之外，这允许你在夜间使用红外灯光照亮区域（就像大多数夜间安全摄像头一样），并看到在黑暗中发生的一切！
- en: '*The MagPi* Issue 18 ([https://www.raspberrypi.org/magpi/](https://www.raspberrypi.org/magpi/))
    has published an excellent feature explaining the other uses of the Pi NoIR camera
    module.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*《The MagPi》* 第18期 ([https://www.raspberrypi.org/magpi/](https://www.raspberrypi.org/magpi/))
    发布了一篇出色的特色文章，解释了Pi NoIR摄像头模块的其他用途。'
- en: Creating a stop frame animation
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建定格动画
- en: Stop frame (or stop motion) animation is the process of taking a series of still
    images of items, while making very small movements (typically of an easily moveable
    object such as a doll or plasticine model) in each frame. When the frames are
    assembled into a video, the small movements combine to produce an animation.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 定格动画（或逐帧动画）是拍摄一系列静态图像的过程，同时在每个帧中进行非常小的移动（通常是易于移动的对象，如娃娃或塑料模型）。当这些帧组合成视频时，小的移动组合起来产生动画。
- en: '![Creating a stop frame animation](img/6623OT_08_009.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![创建定格动画](img/6623OT_08_009.jpg)'
- en: Multiple images can be combined into an animation
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将多张图片组合成动画
- en: Traditionally, such animations were made by taking hundreds or even thousands
    of individual photos on a film camera (such as a Cine Super 8 movie camera) and
    then sending the film off to be developed and playing back the results some weeks
    later. Despite the inspiring creations by Nick Park at Aardman Animations, including
    Wallace and Gromit (which are full-length, stop frame animation films), this was
    a hobby that was a little out of reach for most.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，这类动画是通过在电影摄像机（如Cine Super 8电影摄像机）上拍摄数百甚至数千张单独的照片来制作的，然后将胶片寄出进行冲洗，并在几周后播放结果。尽管Aardman
    Animations的Nick Park创作了一些鼓舞人心的作品，包括《华莱士和吉姆》系列（这是全长的定格动画电影），但对于大多数人来说，这仍然是一项有点难以触及的爱好。
- en: In the modern digital age, we can take multiple images quickly and easily with
    the luxury of reviewing the results almost instantly. Now anyone can try their
    hand at their own animated masterpieces with very little cost or effort.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代数字时代，我们可以快速轻松地拍摄多张照片，并且几乎可以立即查看结果。现在任何人都可以尝试制作自己的动画杰作，成本或努力都非常低。
- en: We will extend our original **Camera GUI** with some extra features that will
    allow us to create our own stop frame animations. It will allow us to take images
    and try them out in a sequence before generating a finished video for us.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展我们的原始**Camera GUI**类，添加一些额外功能，这将使我们能够创建自己的停止帧动画。它将允许我们在生成最终视频之前，先以序列的形式拍摄图像并尝试它们。
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: The software setup for this example will be the same as the previous time-lapse
    example. Again, we will need `mencoder` to be installed and we need the `cameraGUI.py`
    file in the same directory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的软件设置将与之前的延时摄影示例相同。同样，我们需要安装`mencoder`，并且需要在同一目录中包含`cameraGUI.py`文件。
- en: 'You will also need something to animate, ideally something you can put in different
    poses, like the two dolls shown in the following image:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一些可以动画化的东西，理想情况下是你可以将其置于不同姿势的东西，就像以下图像中显示的两个娃娃一样：
- en: '![Getting ready](img/6623OT_08_010.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/6623OT_08_010.jpg)'
- en: Two potential stars for our stop frame animation
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们停止帧动画的两个潜在明星
- en: How to do it…
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create `animateGUI.py` in the same directory as `cameraGUI.py` by performing
    the following steps:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤在`cameraGUI.py`同一目录中创建`animateGUI.py`：
- en: 'Start by importing the supporting modules (including `cameraGUI`), as shown
    in the following code:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入支持模块（包括`cameraGUI`），如下所示：
- en: '[PRE31]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Extend the `cameraGUI.SET` class with settings for the image size and encoding
    as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下扩展`cameraGUI.SET`类，以设置图像大小和编码：
- en: '[PRE32]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Extend the main `cameraGUI` class with the functions required for the animation
    as follows:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下扩展主`cameraGUI`类，以添加动画所需的函数：
- en: '[PRE33]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add functions to list the images that were taken and remove them from the list
    using the following code snippet:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段向列表中添加函数以列出已拍摄的照片，并从列表中删除它们：
- en: '[PRE34]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Include functions to perform the test animation using the image list as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含以下使用图像列表执行测试动画的函数：
- en: '[PRE35]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, create the following `cameraGUI3animate.py` file to use the GUI:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建以下`cameraGUI3animate.py`文件以使用GUI：
- en: '[PRE36]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run the example with the following command:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行示例：
- en: '[PRE37]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works…
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Once again, we create a new class based on the original `cameraGUI` class.
    This time, we define the following GUI with six extra controls:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们基于原始`cameraGUI`类创建了一个新类。这次，我们定义了以下具有六个额外控件的GUI：
- en: '![How it works…](img/6623OT_08_011.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/6623OT_08_011.jpg)'
- en: The animation GUI layout
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 动画GUI布局
- en: We create a listbox control (`imageListbox`) that will contain a list of the
    `.jpg` images in the current directory (`self.theList`). This control has a vertical
    scroll bar (`yscroll`) linked to it to allow easy scrolling of the list, and `selectmode=TK.EXTENDED`
    is used to allow multiple selections using *Shift* and *Ctrl* (for block and group
    selections).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个列表框控件（`imageListbox`），它将包含当前目录（`self.theList`）中的`.jpg`图像列表。此控件有一个与之链接的垂直滚动条（`yscroll`），以便轻松滚动列表，并且使用`selectmode=TK.EXTENDED`允许使用*Shift*和*Ctrl*（用于块和组选择）进行多选。
- en: Next, we add a **Trim** button (`timeBtn`) that will call `self.trim()`. This
    will remove any items that have not been selected in the list. We use `curselection()`
    to get a list of the currently selected items from the `imageListbox` control.
    The `curselection()` function normally returns a list of indexes that are numerical
    strings, so we use `map(int,...)` to convert the result into a list of integers.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个**Trim**按钮（`timeBtn`），它将调用`self.trim()`。这将删除列表中未选中的任何项目。我们使用`curselection()`从`imageListbox`控件获取当前选中的项目列表。`curselection()`函数通常返回一个索引列表，这些索引是数值字符串，因此我们使用`map(int,...)`将结果转换为整数列表。
- en: We use this list to get all the indexes that have not been selected using our
    utility `diff(a,b)` function. The function compares a full list of indexes against
    the selected ones and returns any that haven't been selected.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用此列表通过我们的实用程序`diff(a,b)`函数获取所有未选中的索引。该函数将完整的索引列表与选中的索引进行比较，并返回任何未选中的索引。
- en: The `self.trim()` function uses `os.rename()` to change the filename extensions
    from `.jpg` to `.jpg.bak` for all the non-selected images. We could delete them
    using `os.remove()`, but we only really want to rename them to stop them from
    appearing in the list and final video. The list is repopulated using `self.updateList()`,
    which updates `self.theList` with a list of all the `.jpg` files available.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.trim()`函数使用`os.rename()`将所有非选中图片的文件扩展名从`.jpg`更改为`.jpg.bak`。我们可以使用`os.remove()`删除它们，但我们真正想要的是将它们重命名以防止它们出现在列表和最终视频中。列表通过`self.updateList()`重新填充，该函数更新`self.theList`为所有可用的`.jpg`文件列表。'
- en: We add a scale control (`speedScale`) that is linked to `self.speed` and is
    used to control the playback speed of the animation test. As earlier, we add a
    **Generate** button (`genBtn`) that calls `self.generate()`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个与`self.speed`链接的刻度控制（`speedScale`），用于控制动画测试的播放速度。同样，我们添加了一个**Generate**按钮（`genBtn`），它调用`self.generate()`。
- en: Finally, we add the **Animate** button (`animateBtn`). The text for the button
    is linked to `self.btnAniTxt` (making it easy to change within our program), and
    when pressed, the button calls `self.animate()`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了**Animate**按钮（`animateBtn`）。按钮的文本链接到`self.btnAniTxt`（这使得在程序中更改它变得容易），当按下时，按钮调用`self.animate()`。
- en: Note
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We override the original `shutter()` function from the original `cameraGUI`
    script by adding a call to `self.updateList()`. This ensures that after an image
    has been taken, the list of images is updated with the new image automatically.
    Again, we use `super()` to ensure that the original functionality is also performed.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加对`self.updateList()`的调用覆盖了原始`cameraGUI`脚本中的原始`shutter()`函数。这确保了在拍摄完一张图片后，图像列表会自动更新为新图片。再次使用`super()`确保也执行了原始功能。
- en: The `animate()` function (called by clicking on the **Animate** button) allows
    us to test a selection of images to see whether they will make a good animation
    or not. When the button is clicked on, we change the text of the button to **STOP**,
    the `self.animating` flag to **True** (to indicate that the animation mode is
    running), and call `doAnimate()`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`animate()` 函数（通过点击**Animate**按钮调用）允许我们测试一系列图片，看看它们是否能够制作出好的动画。当按钮被点击时，我们将按钮的文本改为**STOP**，将`self.animating`标志设置为**True**（表示动画模式正在运行），并调用`doAnimate()`。'
- en: The `doAnimate()` function first gets a list of currently selected images in
    the `imageListbox` control, generates a list of `TK.PhotoImage` objects, and attaches
    them to the `self.canvas` object in the GUI. However, if only one image has been
    selected, we display it directly using `self.updateDisp()`. Alternatively, if
    no images have been selected, it will try to use them all (unless the list is
    empty, in which case it will inform the user that there are no images to animate).
    When we have more than one `TK.PhotoImage` object linked to the canvas, we can
    loop through them using the `cycleImages()` function.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`doAnimate()` 函数首先获取`imageListbox`控件中当前选中的图片列表，生成一系列`TK.PhotoImage`对象，并将它们附加到GUI中的`self.canvas`对象。然而，如果只选中了一张图片，我们将直接使用`self.updateDisp()`显示它。或者，如果没有选中任何图片，它将尝试使用所有图片（除非列表为空，在这种情况下，它将通知用户没有图片可以动画化）。当我们有多个`TK.PhotoImage`对象链接到画布时，我们可以使用`cycleImages()`函数遍历它们。'
- en: The `TK.PhotoImage` objects are all created with their states set to `TK.HIDDEN`,
    which means they are not visible on the canvas. To produce the animation effect,
    the `cycleImages()` function will set each image to `TK.NORMAL` and then `TK.HIDDEN`
    again, allowing each frame to be displayed for 1 divided by `self.speed` (the
    fps value set by the Scale control) seconds before showing the next.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`TK.PhotoImage`对象都创建时其状态设置为`TK.HIDDEN`，这意味着它们在画布上不可见。为了产生动画效果，`cycleImages()`函数将每个图像设置为`TK.NORMAL`，然后再次设置为`TK.HIDDEN`，使得每个帧在显示下一帧之前显示1除以`self.speed`（由Scale控件设置的fps值）秒。'
- en: The `cycleImages()` function will perform the animation as long as `self.animating`
    is **True**, that is, until the `animateBtn` object is clicked on again.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`cycleImages()`函数将在`self.animating`为**True**时执行动画，也就是说，直到再次点击`animateBtn`对象。'
- en: Once the user is happy with their animation, they can generate the video using
    the **Generate** button (`genBtn`). The `generate()` function will call `mencoder`
    to generate the final video of all the images in the `imageListbox` control.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户对他们的动画满意，他们可以使用**Generate**按钮（`genBtn`）生成视频。`generate()`函数将调用`mencoder`生成`imageListbox`控件中所有图片的最终视频。
- en: If you really want to get into producing animations, you should consider adding
    some extra features to help you, such as the ability to duplicate and reorder
    frames. You may want to add some manual adjustments for the camera to avoid white
    balance and lighting fluctuations caused by the automatic settings of the camera.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想从事动画制作，你应该考虑添加一些额外的功能来帮助你，例如能够复制和重新排列帧的能力。你可能还想为相机添加一些手动调整，以避免由相机自动设置引起的白平衡和光照波动。
- en: There's more…
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The camera module is ideal for close-up photography due to its small size and
    ability to be remotely controlled. By using small lenses or adding hardware controls,
    you could make a purpose-built animation machine.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其小型尺寸和远程控制能力，相机模块非常适合近距离摄影。通过使用小镜头或添加硬件控制，你可以制作一个专用的动画机。
- en: Improving the focus
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提高焦点
- en: 'The Raspberry Pi camera lens has been designed mainly for middle to long distance
    photography, and it therefore has trouble focusing on objects that are closer
    than 25 cm (10 inches). However, using some basic lenses, we can adjust the effective
    focal length and make it more suitable for macro photography. You can use add-on
    lenses that are available for mobile phones or credit card-style magnifier lenses
    to adjust the focus, as shown in the following images:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派相机的镜头主要是为中等到长距离摄影设计的，因此它难以聚焦于25厘米（10英寸）以内的物体。然而，使用一些基本镜头，我们可以调整有效焦距，使其更适合微距摄影。你可以使用适用于手机的附加镜头或信用卡式放大镜镜头来调整焦点，如下面的图片所示：
- en: '![Improving the focus](img/6623OT_08_012.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![提高焦点](img/6623OT_08_012.jpg)'
- en: An add-on macro lens (right) and a credit card magnifier (left) can improve
    the focus of close-up items
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一个附加的宏观镜头（右）和一个信用卡放大镜（左）可以提高近距离物品的焦点
- en: Creating a hardware shutter
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建硬件快门
- en: 'Of course, while it is useful to have a display available to review the images
    taken, it is often useful to be able to simply press a physical button to take
    an image. Fortunately, this is just a matter of attaching a button (and resistor)
    to a GPIO pin, as we have done previously (see the *Responding to a button* recipe
    in [Chapter 6](ch06.html "Chapter 6. Using Python to Drive Hardware"), *Using
    Python to Drive Hardware*), and creating suitable GPIO control code to call our
    `cameraGUI.camCapture()` function. The code for this is as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，虽然有一个可用的显示屏来查看拍摄的照片是有用的，但通常能够简单地按下一个物理按钮来拍摄照片也很方便。幸运的是，这只是一个将按钮（和电阻）连接到GPIO引脚的问题，就像我们之前做的那样（参见第6章中的*响应按钮*配方，*使用Python驱动硬件*），并创建适当的GPIO控制代码来调用我们的`cameraGUI.camCapture()`函数。代码如下：
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The previous code will take a picture when the button is pressed. The following
    diagram shows the connections and circuit diagram required to achieve this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被按下时，前面的代码将拍摄照片。以下图示显示了实现这一功能的连接和电路图：
- en: '![Creating a hardware shutter](img/6623OT_08_013.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![创建硬件快门](img/6623OT_08_013.jpg)'
- en: The button (and 1K ohm resistor) should be connected between pins 12 and 6 (GND)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮（以及1K欧姆电阻）应该连接在12号引脚和6号引脚（GND）之间
- en: You don't even have to stop here since you can add buttons and switches for
    any of the controls or settings for the camera if you want to. You can even use
    other hardware (such as infrared sensors and so on) to trigger the camera to take
    an image or video.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至不需要停止在这里，因为如果你想要的话，可以为相机上的任何控制或设置添加按钮和开关。你甚至可以使用其他硬件（如红外传感器等）来触发相机拍摄照片或视频。
- en: Making a QR code reader
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作二维码读取器
- en: You have probably seen QR codes in various places, and perhaps even used a few
    to pick up links from posters or adverts. However, they can be far more useful
    if you make your own. The following example discusses how we can use the Raspberry
    Pi to read QR codes and the hidden content (or even link to an audio file or video).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在各种地方见过二维码，也许甚至使用过几个来从海报或广告中获取链接。然而，如果你自己制作，它们可以变得更有用。以下示例讨论了我们可以如何使用树莓派来读取二维码和隐藏的内容（或者甚至链接到音频文件或视频）。
- en: 'This could be used to create your own personalized Raspberry Pi QR code jukebox,
    perhaps as an aid for children to provide solutions to math problems, or even
    to play an audio file of you reading your kid''s favorite book as they follow
    along page by page. The following screenshot is an example of a QR code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用来创建你自己的个性化树莓派二维码音乐盒，也许作为帮助儿童解决数学问题的辅助工具，或者甚至在他们一页一页地跟随时播放你阅读孩子最喜欢的书籍的音频文件。以下截图是一个二维码的示例：
- en: '![Making a QR code reader](img/6623OT_08_014.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![制作 QR 码阅读器](img/6623OT_08_014.jpg)'
- en: You can use QR codes to make magical self-reading books
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 QR 码制作神奇的自读书籍
- en: Getting ready
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This example requires a setup similar to the previous examples (except we won't
    need `mencoder` this time). We will need to install **ZBar**, which is a cross-platform
    QR code and barcode reader, and **flite** (a text-to-speech utility that we used
    in [Chapter 6](ch06.html "Chapter 6. Using Python to Drive Hardware"), *Using
    Python to Drive Hardware*).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例需要与之前的示例类似的设置（除了这次我们不需要 `mencoder`）。我们需要安装 **ZBar**，这是一个跨平台的 QR 码和条形码阅读器，以及
    **flite**（一个文本到语音工具，我们在第 6 章[使用 Python 驱动硬件](ch06.html "第 6 章。使用 Python 驱动硬件")中使用过，*使用
    Python 驱动硬件*）。
- en: 'To install ZBar and flite, use `apt-get` as shown in the following command:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 ZBar 和 flite，请使用以下命令中的 `apt-get`：
- en: '[PRE39]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Tip
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There are Python 2.7 libraries available for Zbar, but they are not currently
    compatible with Python 3\. Zbar also includes a real-time scanner (`zbarcam`)
    that uses video input to detect barcodes and QR codes automatically. Unfortunately,
    this isn't compatible with the Raspberry Pi camera either.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有适用于 Zbar 的 Python 2.7 库，但它们目前与 Python 3 不兼容。Zbar 还包括一个实时扫描器（`zbarcam`），它使用视频输入自动检测条形码和
    QR 码。不幸的是，这与 Raspberry Pi 相机也不兼容。
- en: This isn't a big problem for us since we can use the `zbarimg` program directly
    to detect the QR codes from images taken with `picamera`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说这不是大问题，因为我们可以直接使用 `zbarimg` 程序从 `picamera` 拍摄的图像中检测 QR 码。
- en: Once you have the software installed, you will need some QR codes to scan (see
    the *There's more…* section in *Generating QR codes*) and some suitably named
    MP3 files (these could be recordings of you reading the pages of a book or music
    tracks).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完软件后，您将需要一些 QR 码来扫描（请参阅 *生成 QR 码* 部分的 *更多内容…*），以及一些合适的 MP3 文件（这些可以是您阅读书籍页面的录音或音乐曲目）。
- en: How to do it…
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create the following `qrcodeGUI.py` script in the same directory as `cameraGUI.py`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在与 `cameraGUI.py` 相同的目录中创建以下 `qrcodeGUI.py` 脚本：
- en: '[PRE40]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, create a copy of `cameraGUItimelapse.py` or `cameraGUIanimate.py` and
    call it `cameraGUIqrcode.py`. Again, make sure you import the new file for the
    GUI using the following code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建 `cameraGUItimelapse.py` 或 `cameraGUIanimate.py` 的副本，并将其命名为 `cameraGUIqrcode.py`。再次确保您使用以下代码导入新的
    GUI 文件：
- en: '[PRE41]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The GUI with QR code will look as shown in the following screenshot:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 QR 码的 GUI 将看起来如下截图所示：
- en: '![How to do it…](img/6623OT_08_015.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/6623OT_08_015.jpg)'
- en: The QR code GUI
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: QR 码图形用户界面
- en: How it works…
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: The new `qrcodeGUI.py` file adds the **Read** and **Play** checkbox controls
    and a button control to start scanning for QR codes. When **QR GO!** is clicked
    on, `self.qrGet()` will start a cycle of taking images and checking the result
    with `zbarimg`. If `zbarimg` finds a QR code in the image, then the scanning will
    stop and the result will be displayed. Otherwise, it will continue to scan until
    the **STOP** button is clicked on. While the scanning is taking place, the text
    for `QRBtn` is changed to **STOP**.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `qrcodeGUI.py` 文件添加了 **读取** 和 **播放** 复选框控件以及一个按钮控件来开始扫描 QR 码。当点击 **QR GO!**
    时，`self.qrGet()` 将启动一个循环，通过 `zbarimg` 拍摄图像并检查结果。如果 `zbarimg` 在图像中找到 QR 码，则扫描将停止，并将结果显示出来。否则，它将继续扫描，直到点击
    **停止** 按钮。在扫描过程中，`QRBtn` 的文本将更改为 **停止**。
- en: 'In order to capture the output of `zbarimg`, we have to change how we run the
    command slightly. To do this, we define `run_p()`, which uses the following code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获 `zbarimg` 的输出，我们需要稍微改变运行命令的方式。为此，我们定义 `run_p()`，它使用以下代码：
- en: '[PRE42]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This returns `stdout` as part of the `proc` object, which contains the output
    of the `zbarimg` program. We then extract the resulting QR code that was read
    from the image (if one was found).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `stdout` 作为 `proc` 对象的一部分返回，其中包含 `zbarimg` 程序的输出。然后我们从图像中提取读取到的结果 QR 码（如果找到了）。
- en: When **Read** is selected, `flite` is used to read out the QR code, and if **Play**
    is selected, `omxplayer` is used to play the file (assuming the QR code contains
    a suitable link).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择 **读取** 时，使用 `flite` 读取 QR 码，如果选择 **播放**，则使用 `omxplayer` 播放文件（假设 QR 码包含合适的链接）。
- en: For the best results, it is recommended that you take a preview shot first to
    ensure that you have lined up the target QR code correctly before running the
    QR scanner.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳结果，建议您先拍摄一个预览照片，以确保在运行 QR 扫描器之前正确对齐目标 QR 码。
- en: '![How it works…](img/6623OT_08_016.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/6623OT_08_016.jpg)'
- en: Example QR code page markers (page001.mp3 and page002.mp3)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 QR 码页面标记（page001.mp3 和 page002.mp3）
- en: The previous QR codes contain `page001.mp3` and `page002.mp3`. These QR codes
    allow us to play files with the same name if placed in the same directory as our
    script. You can generate your own QR codes by following the instructions in the
    *There's more…* section in this recipe.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的二维码包含 `page001.mp3` 和 `page002.mp3`。这些二维码允许我们在与脚本相同的目录下播放同名文件。您可以通过遵循本食谱中
    *还有更多…* 部分的说明来生成您自己的二维码。
- en: You could even use the book's ISBN barcode to select a different directory of
    MP3s based on the barcode read; the barcode allows you to reuse the same set of
    page-numbered QR codes for any book you like.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以使用书的ISBN条形码根据读取的条形码选择不同的MP3目录；条形码允许您为任何喜欢的书籍重用同一组编号的二维码。
- en: There's more…
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: To make use of the previous example, you can use the example in the next section
    to generate a range of QR codes to use.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用前面的示例，您可以使用下一节的示例生成一系列二维码以供使用。
- en: Generating QR codes
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成二维码
- en: You can create QR codes using **PyQRCode** (see [https://pypi.python.org/pypi/PyQRCode](https://pypi.python.org/pypi/PyQRCode)
    for more information).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 **PyQRCode**（更多信息请参阅 [https://pypi.python.org/pypi/PyQRCode](https://pypi.python.org/pypi/PyQRCode)）来创建二维码。
- en: 'You can install PyQRCode using the PIP Python manager as follows (see the *Getting
    ready* section of the *Displaying photo information in an application* recipe
    in [Chapter 3](ch03.html "Chapter 3. Using Python for Automation and Productivity"),
    *Using Python for Automation and Productivity*):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令通过PIP Python管理器安装PyQRCode（请参阅[第3章](ch03.html "第3章。使用Python进行自动化和生产率")中
    *显示应用程序中的照片信息* 食谱的 *准备就绪* 部分，*使用Python进行自动化和生产率*）：
- en: '[PRE43]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To encode QR codes in the PNG format, PyQrCode uses PyPNG ([https://github.com/drj11/pypng](https://github.com/drj11/pypng)),
    which can be installed with the following command:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要将二维码编码为PNG格式，PyQrCode使用PyPNG ([https://github.com/drj11/pypng](https://github.com/drj11/pypng))，可以使用以下命令安装：
- en: '[PRE44]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Use the following `generateQRCodes.py` script to generate QR codes to link
    to files, such as the `page001.mp3` and `page002.mp3` files that you have recorded:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下 `generateQRCodes.py` 脚本生成二维码以链接到文件，例如您已记录的 `page001.mp3` 和 `page002.mp3`
    文件：
- en: '[PRE45]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Run this code using the following command:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行此代码：
- en: '[PRE46]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The previous code will create a set of QR codes that can be used to activate
    the required MP3 file and read the page out loud (or play the file that you have
    linked to it).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将创建一组二维码，可用于激活所需的MP3文件并大声读出页面（或播放您链接到它的文件）。
- en: See also
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The **Open Source Computer Vision** (**OpenCV**) project is a very powerful
    image and video processing engine; more details are available at [http://opencv.org](http://opencv.org).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**开源计算机视觉**（**OpenCV**）项目是一个非常强大的图像和视频处理引擎；更多详细信息请参阅 [http://opencv.org](http://opencv.org)。'
- en: By combining the camera with OpenCV, the Raspberry Pi is able to recognize and
    interact with its environment.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将摄像头与OpenCV结合，Raspberry Pi能够识别并与其环境交互。
- en: An excellent example of this is Samuel Matos's RS4 OpenCV Self-balancing Robot
    ([http://roboticssamy.blogspot.pt](http://roboticssamy.blogspot.pt)) that can
    seek out and respond to various custom signs; the camera module can be used to
    navigate and control the robot.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个优秀例子是Samuel Matos的RS4 OpenCV自平衡机器人([http://roboticssamy.blogspot.pt](http://roboticssamy.blogspot.pt))，它可以寻找并响应各种自定义标志；摄像头模块可用于导航和控制机器人。
- en: Discover and experiment with OpenCV
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索和实验OpenCV
- en: The OpenCV library is an extensive library aimed at providing real-time computer
    vision processing across multiple platforms. Essentially, if you want to do any
    serious image processing, object recognition, or analysis, then OpenCV is a perfect
    place to get started.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV库是一个旨在为多个平台提供实时计算机视觉处理的广泛库。本质上，如果您想进行任何严肃的图像处理、物体识别或分析，那么OpenCV是您开始的地方。
- en: Fortunately, the latest release of OpenCV (version 3) has added support for
    interfacing via Python 3\. Although performing real-time video processing can
    often require a computer with a powerful CPU, it will run on relativity limited
    devices such as the original Raspberry Pi (version 1). Using the more powerful
    Raspberry Pi 2 is highly recommended for the following recipes.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，OpenCV（版本3）的最新版本已添加了对通过Python 3进行接口的支持。尽管进行实时视频处理通常需要具有强大CPU的计算机，但它可以在相对有限的设备上运行，例如原始的Raspberry
    Pi（版本1）。强烈推荐使用更强大的Raspberry Pi 2来运行以下食谱。
- en: The concepts and underlying methods behind image and video processing can get
    rather complicated. This first recipe shall demonstrate how to work with OpenCV
    and most importantly provide an easy way to visualize various stages that may
    be used for processing images.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图像和视频处理背后的概念和底层方法可能相当复杂。本食谱将演示如何使用OpenCV，更重要的是提供一个简单的方法来可视化可能用于处理图像的各种阶段。
- en: '![Discover and experiment with OpenCV](img/6623OT_08_017.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![探索和实验OpenCV](img/6623OT_08_017.jpg)'
- en: When performing tests with the camera ensure you have suitable test subjects
    available
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行相机测试时，请确保您有合适的测试对象可用
- en: Getting ready
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The OpenCV library is written in C++ and needs to be compiled before we can
    use it on the Raspberry Pi. To do this, we will need to install all the required
    packages and then download a release from the OpenCV Git repository. OpenCV can
    require around 2.5 GB of space while it compiles; however, a standard installation
    of Raspbian from NOOBS can use around 5.5 GB. This means there may be insufficient
    space available on an 8 GB SD card. It may be possible to squeeze OpenCV onto
    a smaller SD card (by installing a custom Raspbian image or utilizing a USB flash
    device); however, to avoid complications, it is recommended you use at least a
    16 GB SD card to compile and install OpenCV on.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV库是用C++编写的，在我们能够在Raspberry Pi上使用它之前，需要对其进行编译。为此，我们需要安装所有必需的包，然后从OpenCV
    Git仓库下载一个发布版本。OpenCV在编译时可能需要大约2.5GB的空间；然而，从NOOBS安装的标准Raspbian版本大约需要5.5GB。这意味着在8GB
    SD卡上可能空间不足。可能可以将OpenCV压缩到更小的SD卡上（通过安装自定义的Raspbian镜像或利用USB闪存设备）；然而，为了避免复杂问题，建议您至少使用16GB
    SD卡来编译和安装OpenCV。
- en: Additionally, while the majority of recipes in this book can be run using SSH
    and X11-forwarding over a network connection, the OpenCV display window appears
    to function far more effectively if you are connected to a local screen (via HDMI)
    and controlled directly with a local input devices.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，虽然这本书中的大多数菜谱都可以通过网络连接使用SSH和X11转发来运行，但如果您连接到本地屏幕（通过HDMI）并直接使用本地输入设备，OpenCV显示窗口似乎功能更为有效。
- en: 'Installing OpenCV is quite a long process, but I feel the results are well
    worth the effort:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 安装OpenCV是一个相当漫长的过程，但我认为结果是值得努力的：
- en: 'Ensure that the Raspberry Pi is as up to date as possible, using the following
    commands:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Raspberry Pi尽可能更新，使用以下命令：
- en: '[PRE47]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And perform a reboot to apply the changes:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并执行重启以应用更改：
- en: '[PRE48]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Before we compile OpenCV, we need to install a number of dependencies to support
    the build process:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们编译OpenCV之前，我们需要安装一些依赖项以支持构建过程：
- en: '[PRE49]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We also need to install a number of supporting libraries and packages used
    by OpenCV (we may not use all of these, but they form part of the build process).
    These will also provide support for a wide range of image and video formats from
    within OpenCV:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要安装OpenCV使用的许多支持库和包（我们可能不会使用所有这些，但它们是构建过程的一部分）。这些也将为OpenCV内提供的广泛图像和视频格式提供支持：
- en: '[PRE50]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can also install NumPy, which is very useful when manipulating image arrays
    within OpenCV, **Automatically Tuned Linear Algebra Software** (**ATLAS**), and
    GFortran for additional mathematic functionality:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以安装NumPy，这在OpenCV中操作图像数组时非常有用，**自动调优线性代数软件**（**ATLAS**），以及GFortran以提供额外的数学功能：
- en: '[PRE51]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now that we have the supporting packages, we can download OpenCV and OpenCV
    Contributed (extra modules) directly from GitHub. We will also create a build
    location ready for the next step:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了支持包，我们可以直接从GitHub下载OpenCV和OpenCV贡献（额外模块）。我们还将创建一个用于下一步的构建位置：
- en: '[PRE52]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: You can download the latest version using the following links and
    selecting a specific release tag; however, you may find you require additional
    dependencies or modules for the package to compile successfully. Ensure you select
    the same release for OpenCV and the contributed modules.'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意**：您可以使用以下链接下载最新版本，并选择特定的发布标签；然而，您可能需要额外的依赖项或模块才能成功编译该软件包。请确保您选择与OpenCV和贡献模块相同的发布版本。'
- en: '[https://github.com/Itseez/opencv/](https://github.com/Itseez/opencv/)'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/Itseez/opencv/](https://github.com/Itseez/opencv/)'
- en: '[https://github.com/Itseez/opencv_contrib/](https://github.com/Itseez/opencv_contrib/)'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/Itseez/opencv_contrib/](https://github.com/Itseez/opencv_contrib/)'
- en: 'The `make` file can be created using the following commands. This takes around
    10 minutes to finish (see the following screenshot):'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`make`文件可以使用以下命令创建。这大约需要10分钟才能完成（见以下截图）：'
- en: '[PRE53]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![Getting ready](img/6623OT_08_018.jpg)'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_08_018.jpg)'
- en: Ensure that the Python 2.7 and Python 3 sections match this screenshot
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保 Python 2.7 和 Python 3 部分与这个截图匹配
- en: We are now ready to compile OpenCV; be warned this will take a considerable
    amount of time to complete. Fortunately, if you have to stop the process or if
    there is a problem, you can resume the `make` command, checking and skip ping
    any components that have already been completed. To restart the `make` from the
    start, use `make clean` to clear the build and start afresh.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以编译 OpenCV 了；请注意，这个过程可能需要相当长的时间才能完成。幸运的是，如果你需要停止这个过程或者出现问题时，你可以继续执行 `make`
    命令，检查并跳过任何已经完成的组件。要从头开始重新启动 `make`，请使用 `make clean` 清除构建并重新开始。
- en: Note
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: By using all four processing cores on the Raspberry Pi 2, the build
    time can be reduced to just over an hour. Use the `–j4` switch to enable the four
    cores, which will allow multiple jobs to be run during the build process.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：通过使用 Raspberry Pi 2 的所有四个处理核心，构建时间可以缩短到一小时以上。使用 `–j4` 开关来启用四个核心，这将允许在构建过程中运行多个作业。'
- en: The build can take almost three hours to complete. If you have the Raspbian
    desktop loaded or you are running other tasks in the background, it is recommended
    you log out to the command line and stop any additional jobs, otherwise the process
    may take even longer to complete.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程可能需要近三个小时才能完成。如果你已经加载了 Raspbian 桌面或者你在后台运行其他任务，建议你注销到命令行并停止任何额外的作业，否则这个过程可能需要更长的时间才能完成。
- en: 'For a Raspberry Pi 1, use a single-threaded `make` job with the following command:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Raspberry Pi 1，使用以下命令使用单线程的 `make` 作业：
- en: '[PRE54]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'For a Raspberry Pi 2, enable up to four simultaneous jobs by using the following
    command:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Raspberry Pi 2，使用以下命令启用最多四个同时作业：
- en: '[PRE55]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '![Getting ready](img/6623OT_08_019.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_08_019.jpg)'
- en: A completed build should look like this
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的构建应该看起来像这样
- en: 'With OpenCV compiled successfully, it can be installed:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 编译成功后，可以安装：
- en: '[PRE56]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now that is all completed, we can quickly test that OpenCV is now available
    to use with Python 3\. Run the following command to open the Python 3 terminal:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有这些都已完成，我们可以快速测试 OpenCV 是否现在可以通过 Python 3 使用。运行以下命令以打开 Python 3 终端：
- en: '[PRE57]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'At the Python 3 terminal, enter the following:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3 终端中输入以下内容：
- en: '[PRE58]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This will display the version of the OpenCV you have just installed!
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示你刚刚安装的 OpenCV 版本！
- en: Note
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: The OpenCV library is updated regularly, which can cause problems
    with the build process. Therefore, if you have issues, the Py Image Search website
    ([http://www.pyimagesearch.com](http://www.pyimagesearch.com)) is an excellent
    resource that contains the latest guides and video tutorials for installing OpenCV
    on the Raspberry Pi.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：OpenCV 库会定期更新，这可能会在构建过程中引起问题。因此，如果你遇到问题，Py Image Search 网站 ([http://www.pyimagesearch.com](http://www.pyimagesearch.com))
    是一个极好的资源，它包含了在 Raspberry Pi 上安装 OpenCV 的最新指南和视频教程。'
- en: How to do it…
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'For our first OpenCV test, we will use it to display a captured image. Create
    the following `openimage.py` file:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个 OpenCV 测试，我们将使用它来显示捕获的图像。创建以下 `openimage.py` 文件：
- en: '[PRE59]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Ensure before you run the script, that you capture an image to display using
    the following command:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行脚本之前，请确保使用以下命令捕获要显示的图像：
- en: '[PRE60]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Run the script with the following command:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行脚本：
- en: '[PRE61]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works…
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The simple test program starts by importing OpenCV (`cv2`) and loading the image
    using `cv2.imread()`. We then use `cv2.imshow()` to display our image (`img`)
    in an image box with the title `'Frame'`. We then wait for a press of any key
    (`cv2.waitKey(0)`) before closing the display window.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的测试程序首先通过导入 OpenCV (`cv2`) 和使用 `cv2.imread()` 加载图像。然后我们使用 `cv2.imshow()` 在一个带有标题
    `'Frame'` 的图像框中显示我们的图像 (`img`)。然后我们等待按下任意键 (`cv2.waitKey(0)`) 才关闭显示窗口。
- en: '![How it works…](img/6623OT_08_020.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/6623OT_08_020.jpg)'
- en: The image is displayed in a standard frame as a grayscale image
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图像以灰度图像的形式显示在标准框架中
- en: Color detection with OpenCV
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenCV 进行颜色检测
- en: We shall begin experimenting with OpenCV by performing some basic operations
    on live image data. In this recipe, we shall perform some basic image processing
    to allow detection of different colored objects and track their location on screen.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在实时图像数据上执行一些基本操作来开始使用 OpenCV 进行实验。在这个菜谱中，我们将执行一些基本的图像处理，以便检测不同颜色的物体并跟踪它们在屏幕上的位置。
- en: Getting ready
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In addition to the setup from the previous recipe, you will need a suitable
    colored object to track. For example, a small colored ball, a suitable colored
    mug, or a pencil with a square of colored paper taped to it is ideal. The example
    should allow you to detect the location (indicated by a color spot) of blue, green,
    red, magenta (pink) or yellow objects.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前的配方设置外，您还需要一个合适的彩色物体来跟踪。例如，一个小彩球、一个合适的彩色杯子，或者一个贴有彩色纸片的铅笔是理想的。示例应该允许您检测蓝色、绿色、红色、洋红色（粉红色）或黄色物体的位置（由颜色点指示）。
- en: '![Getting ready](img/6623OT_08_021.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_08_021.jpg)'
- en: We can use OpenCV to detect colored objects in an image
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 OpenCV 在图像中检测彩色物体
- en: How to do it…
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create the following `opencv_display.py` script:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下 `opencv_display.py` 脚本：
- en: '[PRE62]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Create the following `opencv_color_detect.py` script in the same directory
    as `opencv_display.py`:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在与 `opencv_display.py` 相同的目录中创建以下 `opencv_color_detect.py` 脚本：
- en: '[PRE63]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To run the example, use the following command:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例，请使用以下命令：
- en: '[PRE64]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Use the *M* key to cycle through the available display modes, the *C* key to
    change the particular color we want to detect (blue, green, red, magenta or yellow),
    and the *I* key to display information about the detected contours and hierarchy
    data.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *M* 键在可用的显示模式之间循环，使用 *C* 键更改我们想要检测的特定颜色（蓝色、绿色、红色、洋红色或黄色），并使用 *I* 键显示检测到的轮廓和层次结构数据的详细信息。
- en: '![How to do it…](img/6623OT_08_022.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/6623OT_08_022.jpg)'
- en: The raw image (top left) is processed with Blur (top right), Threshold (bottom
    left) and Contour (bottom right) operations.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 原始图像（左上角）经过模糊（右上角）、阈值（左下角）和轮廓（右下角）操作处理。
- en: How it works…
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The first script (`opencv_display.py`) provides us with a common base for running
    our OpenCV examples from. The script consists of two functions, `begin_capture()`
    and `show_images()`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个脚本（`opencv_display.py`）为我们提供了一个运行OpenCV示例的通用基础。该脚本包含两个函数，`begin_capture()`
    和 `show_images()`。
- en: The `begin_capture()` function sets up the PiCamera to take continuous frames
    (at 50 fps and a resolution of 640x480), converting them into a raw image format
    suitable for OpenCV to process. We use relatively low resolution images here since
    we do not need a lot of detail to perform the kind of processing we are aiming
    for. In fact, the smaller the images the less memory they use and the less intensive
    the processing that we need to perform is.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin_capture()` 函数设置 PiCamera 以连续捕获帧（50 fps 和 640x480 分辨率），并将它们转换为适合 OpenCV
    处理的原始图像格式。我们在这里使用相对较低的分辨率图像，因为我们不需要很多细节来执行我们旨在进行的处理。实际上，图像越小，它们使用的内存越少，我们需要的处理强度也越低。'
- en: By using the `camera.capture_continuous()` function of the PiCamera library,
    we will get an image frame ready for us to process. We shall pass each new frame
    to the `process_image()` function, which will be provided by the `opencv_color_detect.py`
    file along with any captured key presses (to allow the user a little control).
    The `process_image()` function (which we will go through in further detail later
    on) returns two arrays (images and text).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 PiCamera 库的 `camera.capture_continuous()` 函数，我们将获得一个准备好的图像帧供我们处理。我们将每个新帧传递给
    `process_image()` 函数，该函数将由 `opencv_color_detect.py` 文件提供，包括任何捕获的按键（以使用户获得一些控制）。`process_image()`
    函数（我们将在稍后详细介绍）返回两个数组（图像和文本）。
- en: We pass both the images and text arrays to the `show_images()` function, along
    with the selected `MODE` (which is controlled by the user pressing the `M` key
    to cycle through them). Within the `show_images()` function we use the text for
    the given MODE and use `putText()` to add it to the image we are displaying (again,
    whichever image corresponds to the selected `MODE`). Finally, we display the image
    in a separate window using `cv2.imshow()`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将图像和文本数组传递给 `show_images()` 函数，以及选定的 `MODE`（用户通过按 `M` 键循环选择）。在 `show_images()`
    函数中，我们使用给定的 MODE 的文本，并使用 `putText()` 将其添加到我们正在显示的图像中（再次强调，对应于所选的 `MODE`）。最后，我们使用
    `cv2.imshow()` 在单独的窗口中显示图像。
- en: '![How it works…](img/6623OT_08_023.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/6623OT_08_023.jpg)'
- en: The raw image is displayed by the script (including the tracking marker)
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本显示原始图像（包括跟踪标记）
- en: All the real fun is contained within the `opencv_color_detect.py` script, which
    performs all the required image processing to our raw video stream. The aim is
    to simplify the source image and then identify the middle of any area that matches
    our required color.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 所有真正的乐趣都包含在 `opencv_color_detect.py` 脚本中，该脚本执行所有必要的图像处理以处理我们的原始视频流。目标是简化源图像，然后识别任何匹配所需颜色的区域的中心。
- en: Tip
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Note**: The script purposely retains each stage of the processing so you
    can see the effect of each step on the previous image yourself. This is by far
    the best way to understand how we can go from a standard video image to something
    that the computer is able to comprehend. To achieve this, we use an array to collect
    the images as we produce them (using `images.append()` to add each new image and
    we use a *Pythonic* way to refer to the last item in an array, the `[-1]` notation.
    In other programming languages this would produce an error, but with Python it
    is perfectly acceptable to use negative numbers to count backwards from the end
    of an array (so it follows -1 is the first item from the end of the array, and
    -2 would be the second from the end).'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：脚本故意保留了每个处理阶段，以便您可以自己看到每个步骤对前一个图像的影响。这是迄今为止理解我们如何从标准视频图像到计算机能够理解的内容的最好方式。为了实现这一点，我们使用数组收集我们生成的图像（使用`images.append()`添加每个新图像，并使用一种*Pythonic*的方式来引用数组中的最后一个元素，即`[-1]`表示法。在其他编程语言中，这会产生错误，但Python中使用负数从数组的末尾向前计数是完全可接受的，因此-1是数组末尾的第一个元素，-2将是第二个从末尾开始）。'
- en: 'The `process_image()` image function shall produce four different images (which
    we provide references to in our `images` array). In the first image we simply
    keep a copy of our raw image (displayed as `0: Raw Image [Color]`). Since this
    is a full color untouched image, this shall be the image with which we shall show
    the location of the detected object (this is added at the end of function).'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_image()`图像函数应生成四个不同的图像（我们在`images`数组中提供了对这些图像的引用）。在第一张图像中，我们只是保留了我们原始图像的副本（显示为`0:
    Raw Image [Color]`）。由于这是一个未受干扰的全彩图像，因此这将是我们要展示检测到的对象位置的图像（这将在函数末尾添加）。'
- en: 'The next image we produce is a blurred version of the original (displayed as
    `1: with Blur…[Color]`) by using the `cv2.blur()` function with the `BLUR` tuple
    to specify the amount on the (*x,y*) axes. By slightly blurring the image, we
    hope to eliminate any unnecessary detail or erroneous noise in the image; this
    is ideal since we are only interested in large blocks of color, so fine detail
    is irrelevant.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '我们生成的下一张图像是原始图像（显示为`1: with Blur…[Color]`）的模糊版本，通过使用`cv2.blur()`函数和`BLUR`元组来指定在(*x,y*)轴上的模糊量。通过轻微模糊图像，我们希望消除图像中的任何不必要的细节或错误噪声；这是理想的，因为我们只对大块的颜色感兴趣，所以细微的细节是不相关的。'
- en: The third image (displayed as `2:with Threshold…[color]`) is the result of applying
    the given upper and lower threshold using the `cv2.inRange()` function. This produces
    a simple black and white image, where any parts of the image that are between
    the upper and lower color thresholds are displayed in white. Hopefully, you will
    be able to clearly see your test object as you move it in front of the camera
    as a large white patch. You can check this image to ensure that your background
    is not confused with your target object. If the threshold image is mostly white
    then try a different color target, moving the camera to a different location,
    or adjusting the colors used in the threshold arrays (`THRESH_LOW/HI`).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 第三张图像（显示为`2:with Threshold…[color]`）是使用`cv2.inRange()`函数应用给定的高阈值和低阈值的结果。这产生了一个简单的黑白图像，其中任何位于上下颜色阈值之间的图像部分都以白色显示。希望您能够在将测试对象移到相机前时清楚地看到它作为一个大块白色区域。您可以检查这张图像，以确保您的背景不会与目标对象混淆。如果阈值图像主要是白色，则尝试不同的颜色目标，将相机移到不同的位置，或调整阈值数组中使用的颜色（`THRESH_LOW/HI`）。
- en: Note
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: The color mapping used in this example is OpenCV''s **BGR** format. This
    means that the pixel colors are stored as an array of three integers, for Blue,
    Green, and Red. The color thresholds are therefore specified in this format; this
    is contrary to the more typical RGB color format used for example in HTML web
    colors.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本例中使用的颜色映射是OpenCV的**BGR**格式。这意味着像素颜色以三个整数的数组形式存储，分别代表蓝色、绿色和红色。因此，颜色阈值以这种格式指定；这与HTML网页颜色中更典型的RGB颜色格式相反。
- en: The last image provides the final piece of the puzzle; displayed as `3:with
    Contours...[color]`, it shows the result of the `cv2.findContours()` function.
    OpenCV will calculate the contours in the image. This will discover all the edges
    of the shapes that were in the threshold image and return them in a list (contours).
    Each individual contour is an array of the (*x,y*) coordinates of the boundary
    points of each shape in the image.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一张图像提供了拼图的最后一部分；显示为`3:with Contours...[color]`，它显示了`cv2.findContours()`函数的结果。OpenCV将在图像中计算轮廓。这将发现阈值图像中的所有形状边缘，并将它们作为一个列表（轮廓）返回。每个单独的轮廓是图像中每个形状边界点的(*x,y*)坐标数组。
- en: Tip
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Note**: The contours are applied directly to the supplied image by the `cv2.findContours()`
    function, which is why we make a copy of the threshold image (using `images[-1].copy()`)
    so we can see both steps in our process. We also use `cv2.CHAIN_APPROX_SIMPLE`,
    which attempts to simplify the stored coordinates so any points that aren''t needed
    are skipped (for example, any along a straight line can be removed as long as
    we have the start and end points). Alternatively, we could use `cv2.CHAIN_APPROX_NONE`,
    which keeps all the points.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：`cv2.findContours()`函数直接将轮廓应用于提供的图像，这就是为什么我们制作阈值图像的副本（使用`images[-1].copy()`），这样我们就可以看到我们过程中的两个步骤。我们还使用`cv2.CHAIN_APPROX_SIMPLE`，它试图简化存储的坐标，因此可以跳过任何不需要的点（例如，任何沿直线上的点可以删除，只要我们有起点和终点）。或者，我们也可以使用`cv2.CHAIN_APPROX_NONE`，它保留所有点。'
- en: We can use the list of contours to determine the area of each; in our case,
    we are most interested in the largest one (which will hopefully contain the object
    we are tracking as the largest area of the image that has colors within the given
    thresholds). We shall use `cv2.contourArea()` on each contour discovered to calculate
    the area and keep whichever one ends up being the largest.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用轮廓列表来确定每个轮廓的面积；在我们的案例中，我们最感兴趣的是最大的一个（它可能包含我们正在跟踪的对象，作为图像中具有给定阈值的颜色区域的最大面积）。我们将使用`cv2.contourArea()`对每个发现的轮廓进行面积计算，并保留最终面积最大的那个。
- en: Finally, we can list the moments, which are a list of numbers that provide a
    mathematical approximation of the shape. The moments provide us with a simple
    calculation to obtain the centroid of the shape. The centroid is like the *center
    of mass* of the shape; for example, if it was made out of a flat solid piece of
    material, it would be the point at which you could balance it on the end of your
    finger.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以列出矩度，它们是一系列数字，提供了形状的数学近似。矩度为我们提供了一个简单的计算方法，以获得形状的重心。重心就像形状的*质心*；例如，如果它是由一块平板固体材料制成，那么它将是你可以将其放在手指尖上平衡的点。
- en: '*cx, cy = M[''m10''] / M[''m00''], M[''m01''] / M[''m00''])*'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '*cx, cy = M[''m10''] / M[''m00''], M[''m01''] / M[''m00''])*'
- en: We display a small marker (consisting of the upper and lower threshold colors)
    using the calculated coordinates to indicate the detected location of the object.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用计算出的坐标显示一个小标记（由上、下阈值颜色组成），以指示检测到的物体位置。
- en: '![How it works…](img/6623OT_08_024.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/6623OT_08_024.jpg)'
- en: The location of the object is marked with a colored spot as it tracked within
    the image
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 物体的位置在图像中跟踪时用彩色点标记
- en: For additional information about OpenCV's contours and moments, see OpenCV-Python
    Tutorials ([http://goo.gl/eP9Cn3](http://goo.gl/eP9Cn3)).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 关于OpenCV的轮廓和矩度的更多信息，请参阅OpenCV-Python教程([http://goo.gl/eP9Cn3](http://goo.gl/eP9Cn3))。
- en: There's more…
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: This recipe allows us to track an object by detecting the required colors within
    the camera frame, which will provide a relative *x* and *y* position of the object.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方允许我们通过检测摄像头帧内的所需颜色来跟踪对象，这将提供对象的相对*x*和*y*位置。
- en: We can mount the Raspberry Pi camera on a movable platform, for example a rover/bug
    robot platform (like the ones described in [Chapter 9](ch09.html "Chapter 9. Building
    Robots")) or by using a servo-controlled tilt and pan camera mount (as shown in
    the following image).
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将树莓派摄像头安装在可移动平台上，例如一个漫游/昆虫机器人平台（如第9章中描述的[第9章](ch09.html "第9章。构建机器人")），或者使用伺服控制的倾斜和旋转摄像头支架（如图所示）。
- en: '![There''s more…](img/6623OT_08_025.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/6623OT_08_025.jpg)'
- en: The Raspberry Pi camera can be controlled using a servo mount
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派摄像头可以通过伺服支架进行控制
- en: By combining the camera input and the object coordinates, we can make the Raspberry
    Pi track the object wherever it goes. If we detect that the object has moved to
    one side of the camera frame, we can use the Raspberry Pi hardware control to
    re-center the object within the camera frame (either by steering the robot or
    tilting and panning the camera).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合摄像头输入和物体坐标，我们可以让树莓派追踪物体无论它去哪里。如果我们检测到物体已经移动到摄像头框架的一侧，我们可以使用树莓派硬件控制将物体重新定位在摄像头框架内（通过控制机器人或倾斜和移动摄像头）。
- en: '![There''s more…](img/6623OT_08_026.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容…](img/6623OT_08_026.jpg)'
- en: The object has been detected in the top-right of the screen, so turn the camera
    to the right and up to follow the object
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 物体已经在屏幕的右上角被检测到，所以将摄像头转向右边和上方以追踪物体
- en: Performing motion tracking with OpenCV
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenCV进行运动追踪
- en: While it is useful to be able to track objects of a specific color, sometimes
    we are just interested in the actual motion taking place. This is particularly
    true when the objects we wish to track could blend in with the background.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然能够追踪特定颜色的物体很有用，但有时我们只是对实际的运动过程感兴趣。这尤其适用于我们希望追踪的物体可能融入背景的情况。
- en: Note
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: Security cameras often use IR detectors to act as triggers; however,
    these rely upon detecting a change in detected heat across the sensor. This means
    they will not work if the object does not give off additional heat relative to
    the background and they will not track the direction of the motion.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：安全摄像头通常使用红外探测器作为触发器；然而，这些依赖于检测传感器上检测到的热量的变化。这意味着如果物体相对于背景没有发出额外的热量，它们将无法工作，并且它们不会追踪运动的方向。'
- en: '[https://learn.adafruit.com/pir-passive-infrared-proximity-motion-sensor/how-pirs-work](https://learn.adafruit.com/pir-passive-infrared-proximity-motion-sensor/how-pirs-work)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.adafruit.com/pir-passive-infrared-proximity-motion-sensor/how-pirs-work](https://learn.adafruit.com/pir-passive-infrared-proximity-motion-sensor/how-pirs-work)'
- en: The following recipe will demonstrate how OpenCV can be used to detect motion
    and also provide a record of where the object has been over a period of time.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 以下食谱将演示如何使用OpenCV检测运动，并提供物体在一段时间内移动的记录。
- en: '![Performing motion tracking with OpenCV](img/6623OT_08_027.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![使用OpenCV进行运动追踪](img/6623OT_08_027.jpg)'
- en: The motion of an object within the frame is traced on screen, allowing the pattern
    of movement to be recorded and studied
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 框架内物体的运动在屏幕上被追踪，允许记录并研究运动模式
- en: Getting ready
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: The following script will allow us to track an object and display its path on
    the screen. For this task, I have volunteered our family tortoise; however, any
    object that moves can be used.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本将使我们能够追踪一个物体并在屏幕上显示其路径。为此任务，我自愿选择了我们家的家龟；然而，任何移动的物体都可以使用。
- en: '![Getting ready](img/6623OT_08_028.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/6623OT_08_028.jpg)'
- en: Our tortoise made an excellent test subject; it was very interesting to see
    where she wandered during the day
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的乌龟是一个出色的测试对象；看到她在白天四处游荡非常有趣
- en: The setup in this case works particularly well for the following reasons. Firstly,
    since the tortoise is of a similar color to the background we can't use the previous
    method of color detection (unless we stuck some markers on her). Secondly, the
    tortoise house has a useful shelf above it, allowing the Raspberry Pi and camera
    to be mounted directly above it. Finally, the enclosure is artificially lit, so
    other than the movement of the tortoise, the image observed should remain relatively
    constant during our testing. When performing this task with external factors such
    as natural light, you may find that they interfere with the moment detection (making
    it difficult to determine what is changes due to movement compared to changes
    in the environment – see the *There's more...* section for tips on overcoming
    this).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，设置效果特别好的原因如下。首先，由于乌龟的颜色与背景相似，我们无法使用之前的方法进行颜色检测（除非我们在她身上贴上一些标记）。其次，乌龟的笼子上方有一个有用的架子，允许树莓派和摄像头直接安装在上方。最后，笼子是人工照明的，所以在我们的测试期间，除了乌龟的运动外，观察到的图像应该保持相对稳定。当使用外部因素，如自然光进行此任务时，你可能会发现它们会干扰运动检测（使得很难确定变化是由于运动还是环境变化——参见*更多内容*部分以获取克服此问题的技巧）。
- en: The rest of the setup will be the same as the previous OpenCV recipe (see *Color
    detection with OpenCV*).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的设置将与之前的OpenCV食谱相同（参见*使用OpenCV进行颜色检测*）。
- en: How to do it…
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Create the following script, called `opencv_detect_motion.py`:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下脚本，命名为`opencv_detect_motion.py`：
- en: '[PRE65]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, find the following line in the `opencv_display.py` file (from the previous
    recipe):'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `opencv_display.py` 文件中找到以下行（来自前面的食谱）：
- en: '[PRE66]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'to the following:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 变更为以下：
- en: '[PRE67]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To run the example, use the following command:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行示例，请使用以下命令：
- en: '[PRE68]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Use the *M* key to cycle through the available display modes, the *G* key to
    toggle gray scale mode, the *I* key to display information about the detected
    contours and hierarchy data, and the *B* key to reset the image we set as the
    background.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *M* 键在可用的显示模式之间循环，使用 *G* 键切换灰度模式，使用 *I* 键显示检测到的轮廓和层次结构数据的信息，使用 *B* 键重置我们设置为背景的图像。
- en: How it works…
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The principle behind this motion detection method is elegantly simple. First,
    we take an initial image as our golden image (where no moment is taking place);
    we shall treat this as our static background. Now we simply compare any subsequent
    image to this original background image. If there is any significant difference
    from the first image, we assume the difference is due to movement. Once we have
    detected motion, we will then generate a trace of the movement over time and display
    it on the frame.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这种运动检测方法背后的原理简洁而优雅。首先，我们将初始图像作为我们的金图像（此时没有动作发生）；我们将将其视为我们的静态背景。现在我们只需将任何后续图像与这个原始背景图像进行比较。如果与第一幅图像有任何显著差异，我们假设差异是由于运动引起的。一旦我们检测到运动，我们将在帧上生成运动轨迹并显示它。
- en: '![How it works…](img/6623OT_08_029.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/6623OT_08_029.jpg)'
- en: The golden image (right) is a gray-scale version of the raw image (left) with
    a Gaussian blur applied
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 金图像（右侧）是原始图像（左侧）的灰度版本，并应用了高斯模糊。
- en: When the script is run we ensure that the reset flag is set to `True`, which
    ensures we use the first image captured as the golden image (also, if the user
    presses *R* we allow the golden image to be refreshed with a new image). We also
    detect if the user presses *G*, which will switch between processing the image
    in grayscale or in color. The default is grayscale since this is more efficient
    to process and the colors do not matter when detecting motion (but it is interesting
    to see the result of the same processing when the images are still in color too).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本运行时，我们确保重置标志设置为 `True`，这确保我们使用捕获的第一幅图像作为金图像（此外，如果用户按下 *R*，我们允许金图像通过新图像刷新）。我们还检测用户是否按下
    *G*，这将切换在灰度或彩色中处理图像。默认是灰度，因为这种处理更有效，颜色在检测运动时并不重要（但看到图像仍然为彩色时的相同处理结果也很有趣）。
- en: Just like the previous recipe, we will keep a copy of each image to allow better
    understanding of each stage in the process. The first image that is displayed
    is `0:Raw Image`, which is a direct copy of the camera image (we will overlay
    the detected motion on this image).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 就像前面的食谱一样，我们将保留每个图像的副本，以便更好地理解过程中的每个阶段。首先显示的图像是 `0:原始图像`，它是相机图像的直接副本（我们将在该图像上叠加检测到的运动）。
- en: In the next image, `1:with Gaussian Blur…`, we use `cv2.GaussianBlur(raw_image,
    GAUSSIAN, 0)`, providing a smoothed out version of the original (hopefully removing
    Gaussian noise from the image). Like the `blur` function, we provide the image
    to be processed and the *x,y* magnitudes (which for the Gaussian algorithm have
    to be positive and odd).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一张图像中，`1:with Gaussian Blur…`，我们使用 `cv2.GaussianBlur(raw_image, GAUSSIAN,
    0)`，提供原始图像的平滑版本（希望从图像中去除高斯噪声）。像 `blur` 函数一样，我们提供要处理的图像和 *x,y* 放大值（对于高斯算法，这些值必须是正数且为奇数）。
- en: Note
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: You can compare the Gaussian Blur with the standard blur method by inserting
    the following code (just before the Gaussian Blur section) and cycling between
    the modes:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以通过插入以下代码（在高斯模糊部分之前）并在模式之间循环来比较高斯模糊与标准模糊方法：
- en: '[PRE69]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The background image is set using this blurred image (if it has not been set
    previously or it has been reset).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此模糊图像设置背景图像（如果之前尚未设置或已重置）。
- en: We use `cv2.absdiff(imageBG,images[-1])` to determine what differences there
    are between the `imageBG` (the original background image) and the latest Gaussian
    blurred image to provide `2:with image delta...`.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `cv2.absdiff(imageBG,images[-1])` 来确定 `imageBG`（原始背景图像）和最新高斯模糊图像之间的差异，以提供
    `2:with image delta...`。
- en: '![How it works…](img/6623OT_08_030.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/6623OT_08_030.jpg)'
- en: This image (inverted here to make it clearer) shows the difference from the
    golden image. The tortoise has moved near the middle of the image
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图像（在此处反转以使其更清晰）显示了与金图像的差异。乌龟移动到了图像的中间附近
- en: Next, we apply a binary threshold mask (displayed as `3:with threshold mask…`),
    which will set any pixel between the upper (255) and lower (25) threshold to 255,
    resulting in a black and white image displaying the main areas of movement.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应用二值阈值掩码（显示为`3:with threshold mask…`），这将设置介于上限（255）和下限（25）之间的任何像素为255，从而得到一个显示主要运动区域的黑白图像。
- en: '![How it works…](img/6623OT_08_031.jpg)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/6623OT_08_031.jpg)'
- en: A threshold filter is applied to the delta image, highlighting the largest changes
    in the image
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 对差分图像应用阈值滤波器，突出显示图像中的最大变化。
- en: Now, we dilate the threshold image (displayed as `4:with dilation…`) using `cv2.dilate(images[-1],
    None, iterations=3)`. The `dilate` operation works by growing the white section
    of the image by a pixel in each iteration. By using `None` as the second parameter,
    we are setting the kernel to use a default value (alternatively, an array of 0s
    and 1s can be used to fully control how the dilation is applied).
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用`cv2.dilate(images[-1], None, iterations=3)`对阈值图像（显示为`4:with dilation…`）进行膨胀。`dilate`操作通过在每次迭代中使图像的白色部分增长一个像素来实现。通过将`None`作为第二个参数，我们设置内核使用默认值（或者，可以使用由0s和1s组成的数组来完全控制膨胀的应用方式）。
- en: '![How it works…](img/6623OT_08_032.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/6623OT_08_032.jpg)'
- en: The dilated image grows the spots of detected movement
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 膨胀图像使检测到的运动点增长。
- en: We use the `cv2.contours()` function, like we did in the previous recipe, to
    detect the outline of the detected shapes; the result is displayed as `5:with
    contours…`. We must convert the image to grayscale, if it isn't already, since
    this function works best with a binary image (an image that is black and white).
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`cv2.contours()`函数，就像在之前的食谱中做的那样，来检测检测到的形状的轮廓；结果显示为`5:with contours…`。如果图像还不是灰度图，我们必须将其转换为灰度图，因为该函数最适合二值图像（黑白图像）。
- en: '![How it works…](img/6623OT_08_033.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/6623OT_08_033.jpg)'
- en: The area of the contours are calculated and used to determine the location of
    the main area of movement
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 计算轮廓的面积并用于确定主要运动区域的定位。
- en: As before, we calculate the area of each contour and discover which is the largest
    by using `cv2.contourAera()`. Then we determine the coordinates of the middle
    of the selected contour by finding the moments (via `cv2.moments()`). Finally,
    we add these coordinates to the moment array so we can display a trace of the
    detected movement on our original image.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们计算每个轮廓的面积，并使用`cv2.contourArea()`找出最大的轮廓。然后，我们通过找到矩（通过`cv2.moments()`）来确定所选轮廓中心的坐标。最后，我们将这些坐标添加到矩数组中，以便在原始图像上显示检测到的运动的轨迹。
- en: Additionally, to trace relatively slow-moving objects we can also average several
    of the detected coordinates to provide a smoother trace of movement.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了追踪相对缓慢移动的物体，我们还可以平均几个检测到的坐标，以提供更平滑的运动轨迹。
- en: As mentioned at the start, external factors can interfere with this simple algorithm
    where even subtle changes in the environment can cause errors in the movement
    detection. Fortunately, techniques such as applying long term averaging to the
    background image (rather than a single onetime snapshot) will cause any gradual
    changes, such as lighting, to be incorporated into the background image.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如开头所述，外部因素可能会干扰这个简单的算法，即使是环境中的细微变化也可能导致运动检测错误。幸运的是，通过将长期平均应用于背景图像（而不是单次快照），可以将任何逐渐变化，如光照，纳入背景图像中。
- en: There's more…
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Although we have only briefly touched on a small aspect of the OpenCV library,
    it should be clear that it is perfect for use with the Raspberry Pi. We have seen
    OpenCV provides some very powerful processing with relative ease and the Raspberry
    Pi (particularly the Raspberry Pi model 2) is an ideal platform on which to run
    it.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们只是简要地触及了OpenCV库的一个小方面，但应该很清楚，它非常适合与树莓派一起使用。我们已经看到OpenCV提供了相对容易的非常强大的处理能力，而树莓派（尤其是树莓派2型）是运行它的理想平台。
- en: As you can imagine, it simply isn't practical to cover everything OpenCV is
    able to do within a few examples, but I hope it has at least whetted your appetite
    (and provided you with a ready-to-go setup from which you can experiment with
    and create your own projects).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，仅仅通过几个示例来涵盖OpenCV能够做到的所有事情并不实际，但我希望这至少已经激起了你的兴趣（并且为你提供了一个现成的设置，你可以从中进行实验并创建自己的项目）。
- en: 'Fortunately, not only are there lots of tutorials and guides available online,
    but there are also several books that cover OpenCV in great detail; in particular,
    the following Packt books are recommended:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，不仅网上有大量的教程和指南，还有几本书详细介绍了OpenCV；特别是以下Packt出版的书籍被推荐：
- en: '*OpenCV Computer Vision with Python* by *Joseph Howse*'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用Python的OpenCV计算机视觉》* 由 *约瑟夫·豪斯* 编著'
- en: '*Raspberry Pi Computer Vision Programming* by *Ashwin Pajankar*'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《树莓派计算机视觉编程》* 由 *阿什温·帕贾卡尔* 编著'
- en: In the last two examples, I've attempted to keep the code as brief as possible
    while ensuring it is easy to observe the inner workings behind the recipe. It
    should be very easy to adapt them or add your own simply by importing different
    modules with your own `process_images()` function in.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两个例子中，我尽量使代码尽可能简短，同时确保易于观察背后的工作原理。通过导入不同的模块以及使用你自己的 `process_images()` 函数，应该非常容易对其进行修改或添加。
- en: 'For more ideas and projects, there is an excellent list on the following site:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多想法和项目，以下网站上有一个非常优秀的列表：
- en: '[http://www.intorobotics.com/20-hand-picked-raspberry-pi-tutorials-in-computer-vision/](http://www.intorobotics.com/20-hand-picked-raspberry-pi-tutorials-in-computer-vision/)'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.intorobotics.com/20-hand-picked-raspberry-pi-tutorials-in-computer-vision/](http://www.intorobotics.com/20-hand-picked-raspberry-pi-tutorials-in-computer-vision/)'
