- en: The Artisan Gateway Service
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工匠网关服务
- en: In order to implement the end user and Gateway-daemon communications, we need
    to examine and make some decisions on several operational aspects of the daemon –
    how it's going to work, how data gets sent and received, and how that data is
    acted upon. In this chapter, we'll examine that in detail, and write code to implement
    processes based on those decisions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现最终用户和网关守护程序之间的通信，我们需要详细研究并就守护程序的几个运行方面进行一些决策-它将如何工作，数据如何发送和接收，以及如何对这些数据进行操作。在本章中，我们将对此进行详细研究，并编写代码来实现基于这些决策的过程。
- en: 'The chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Defining what the data structure (messages) being sent back and forth looks
    like, and what it needs to provide, including a signed-message implementation
    that should work no matter what mechanism is used to send the data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义来回发送的数据结构（消息）的样子，以及它需要提供的内容，包括一个签名消息实现，无论使用何种机制发送数据，都应该起作用
- en: 'Examining two fundamental options for sending and receiving data: message queues
    and web services'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查发送和接收数据的两个基本选项：消息队列和Web服务
- en: How messages will be handled, independently of the transmission mechanism
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息将如何处理，独立于传输机制
- en: The basic structures needed to implement a message-queue-based transmission
    mechanism
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现基于消息队列的传输机制所需的基本结构
- en: What variations would be encountered (and how to deal with them) in a web-service-based
    approach
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基于Web服务的方法中会遇到什么变化（以及如何处理）
- en: What the traffic to and from the Artisan Gateway will look like
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工匠网关的进出流量将是什么样子
- en: A minimal integration of those traffic patterns into existing data objects'
    current processes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些流量模式最小集成到现有数据对象的当前流程中
- en: Overview and goal
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述和目标
- en: 'In the context of the `hms_sys` system, the Artisan Gateway has been only loosely
    defined thus far – it''s been described as acting as a central contact point for
    communication between Artisans and the Central Office, especially with respect
    to the `Product` and `Order` objects – what its role is, in effect. The specifics
    of how it works, and when, haven''t really been touched upon, though at least
    some of the latter are probably very obvious, following a simple rule that might
    be stated as changes made (by whomever) need to propagate to all relevant parties
    as soon as is feasible. Those changes are largely dependent on who is making them.
    At a minimum, the following processes feel likely:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在“hms_sys”系统的背景下，工匠网关迄今为止只是宽泛地定义了它的作用-它被描述为在工匠和中央办公室之间的通信的中央联系点，特别是关于“产品”和“订单”对象的-它的作用是什么。它的工作方式和何时工作的具体细节还没有被触及，尽管至少后者可能是非常明显的，遵循一个简单的规则，即所做的更改（由谁）需要尽快传播到所有相关方。这些更改在很大程度上取决于谁在进行更改。至少，以下过程可能会出现：
- en: Artisans can create new `Product` data
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工匠可以创建新的“产品”数据
- en: Artisans can update current `Product` data
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工匠可以更新当前的“产品”数据
- en: Artisans can delete a `Product` outright
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工匠可以直接删除“产品”
- en: Central Office staff can mark a `Product` as available – which is just a specialized
    variant of a `Product` update process
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中央办公室工作人员可以标记“产品”为可用-这只是“产品”更新过程的一个专门变体
- en: Central Office staff can also make content changes to Products – also an update
    variant – with some constraints on what can be altered
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中央办公室工作人员也可以对产品进行内容更改-这也是一种更新变体-对可以更改的内容有一些限制
- en: Customer end users can indirectly create `Order` objects, which need to propagate
    out to Artisans in some fashion
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终用户可以间接创建“订单”对象，需要以某种方式传播给工匠
- en: Artisans can update Orders as part of the process of fulfilling them
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工匠可以在履行过程中更新订单
- en: All of these processes are variants of CRUD operations on the `Product` and/or
    `Order` objects, and will probably not need much more functionality than is already
    provided by the `_create` or `_update` methods of the related classes within each
    subsystem. They should cover most, perhaps all, of how the data changes are actually
    stored.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些过程都是对“产品”和/或“订单”对象的CRUD操作的变体，可能不需要比每个子系统中相关类的_create或_update方法提供的功能更多。它们应该涵盖实际存储数据更改的大部分，也许全部。
- en: 'The transmission of those data changes, no matter what the timing or protocol
    ends up looking like, has some common factors as well, with a process that will
    need to handle the role-specific variations of the following steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据更改的传输，无论最终的时间或协议是什么样子，都有一些共同因素，需要处理以下步骤的特定变体：
- en: A data change (create, update, or delete) is made locally, in one of the user-level
    applications
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地进行数据更改（创建、更新或删除）
- en: The data change is validated, to assure that the data is well formed and conforms
    to data-structure requirements
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证数据更改，以确保数据格式良好并符合数据结构要求
- en: The data change is stored locally (if applicable)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据更改在本地存储（如果适用）
- en: The data change is serialized and transmitted to the Artisan Gateway service,
    where whatever actions need to be undertaken are executed
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据更改被序列化并传输到工匠网关服务，执行需要进行的任何操作
- en: These steps do not address the possibility of conflicting changes, such as an
    Artisan and someone in the Central Office making different changes to the same
    data in the same data-change timeframe. A strategy for dealing with that possibility
    may not even be necessary, depending on the specific data-change business rules
    in play, but will have to be examined as well.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤并未解决冲突更改的可能性，例如工匠和中央办公室的某人在相同的数据更改时间段内对相同数据进行不同更改的可能性。处理这种可能性的策略可能甚至不是必要的，取决于正在进行的具体数据更改业务规则，但也必须进行检查。
- en: That leaves only the decision about the transmission method itself to be made.
    Since the individual users that will be making changes to data are not expected
    to be in the same physical location, we need a network-transmission protocol of
    some sort – a web service or message-queue-based process, as discussed in [Chapter
    15](26ce9de7-eb44-4e33-afa2-fccb17e75aa8.xhtml), *Anatomy of a Service*. A web
    service, if it were written from scratch, would probably be a significantly larger
    undertaking, potentially requiring code to handle authentication, authorization,
    and processes for handling specific HTTP methods and tying them to specific CRUD
    operations against individual data object types. There's enough complexity between
    those alone to warrant looking at an existing service-capable framework, such
    as Flask or Django, rather than writing (and having to test) all of the relevant
    code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这只留下了关于传输方法本身的决定。由于预计进行数据更改的个别用户不会在同一物理位置，我们需要某种网络传输协议 - 一种Web服务或基于消息队列的过程，如[第15章](26ce9de7-eb44-4e33-afa2-fccb17e75aa8.xhtml)中讨论的那样，*服务的解剖*。如果从头开始编写Web服务，可能需要进行大量工作，可能需要编写处理身份验证、授权和处理特定HTTP方法并将它们与特定CRUD操作绑定到个别数据对象类型的代码。这些单独之间的复杂性足以值得查看现有的服务框架，如Flask或Django，而不是编写（并且必须测试）所有相关代码。
- en: 'Given that the system only needs to be concerned with the seven actions identified
    earlier (Artisan: create, update, or delete Products, and so on), it feels simpler
    to write those seven functions, and allow messages in a queue-based protocol to
    simply call them when necessary. The potential concerns around authentication
    and authorization can be mitigated significantly by assigning each Artisan its
    own distinct queue, and perhaps signing each message originating with an Artisan.
    Between those two approaches, an Artisan''s identity can be determined simply
    by the fact that a message is coming in from a given queue that''s associated
    with them. Coupling that with a signature on each message, as long as it can be
    generated by the Artisan''s application and verified by the Artisan Gateway service
    without transmitting any secret data with the message, provides a reasonably robust
    authentication mechanism. Authorization concerns in this context are nearly trivial –
    any given channel, given that it can be associated with a user type, or even a
    specific user, can simply be allowed access to (and thus execution of) the operations
    that are relevant to that user or type only.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到系统只需要关注之前确定的七个操作（工匠：创建、更新或删除产品等），编写这七个函数并允许队列协议中的消息在必要时调用它们会更简单。通过为每个工匠分配一个独特的队列，并可能为每个工匠发出的每条消息签名，可以显著减轻围绕身份验证和授权的潜在问题。通过这两种方法，可以简单地通过来自与他们相关联的特定队列的消息来确定工匠的身份。再加上每条消息上的签名，只要它可以由工匠的应用程序生成并由工匠网关服务验证，而不会在消息中传输任何秘密数据，就提供了一个相当健壮的身份验证机制。在这种情况下，授权问题几乎微不足道
    - 任何给定的通道，只要它可以与用户类型或甚至特定用户关联，就可以简单地允许访问（从而执行）与该用户或类型相关的操作。
- en: 'At a high level, the data flows for Artisan/Product operations, no matter which
    transmission mechanism is selected, would look like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，无论选择哪种传输机制，工匠/产品操作的数据流都会如下所示：
- en: '![](assets/34162167-3cac-4fc6-8676-1552cfd5f1bf.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/34162167-3cac-4fc6-8676-1552cfd5f1bf.png)'
- en: 'Where:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在哪里：
- en: The various messages (**Create Product**, **Update Product**, and **Delete Product**)
    with their respective **{payload}** data (or a **{product_id}** for deletion operations)
    are created by the local **Artisan Application**, transmitted to the **Artisan
    Gateway** service
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种消息（**创建产品**、**更新产品**和**删除产品**）及其各自的**{payload}**数据（或删除操作的**{product_id}**）由本地**工匠应用程序**创建，并传输到**工匠网关**服务
- en: Those messages are read, validated, and used to determine which service method
    (`artisan_create_product`, and so on) should be called
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些消息被读取、验证，并用于确定应调用哪个服务方法（`artisan_create_product`等）
- en: The relevant method deals with whatever data storage is needed in the **Artisan
    Gateway Datastore** during execution
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关方法处理执行期间**工匠网关数据存储**中所需的任何数据存储
- en: Similar data flows would exist for all of the operations that Central Office
    users could execute against `Product` objects, and for `Artisan` and `Order` object
    interactions, at a minimum. In addition, there may well be related operations
    that need to be made available for more specific data-object operations in more
    specific Central Office roles. The Central Office staff will need to be able to
    manage `Artisan` objects, at a minimum, and maybe `Order` objects as well.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的数据流也将存在于中央办公室用户可以对`产品`对象执行的所有操作，以及`工匠`和`订单`对象的交互，至少是这样。此外，可能还需要为更具体的中央办公室角色中更具体的数据对象操作提供相关操作。中央办公室工作人员将需要能够管理`工匠`对象，至少可能还有`订单`对象。
- en: Iteration stories
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代故事
- en: 'Although there are at least *some* aspects of many of these stories that rely
    on some UI implementation that hasn''t been examined yet, there are non-UI functional
    aspects to each of them that can be usefully examined and worked. With that in
    mind, the stories relevant for this iteration, at least initially, are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多这些故事的*某些*方面依赖于尚未被检查的一些UI实现，但每个故事都有一些非UI功能方面可以被有用地检查和处理。考虑到这一点，至少在最初，本次迭代相关的故事如下：
- en: As an Artisan, I need to be able to send data changes to the Artisan Gateway
    so that those changes can be propagated and acted upon as needed
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名工匠，我需要能够将数据更改发送到工匠网关，以便这些更改可以根据需要传播和执行
- en: As a Central Office user, I need to be able to send data changes to the Artisan
    Gateway so that those changes can be propagated and acted upon as needed
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为中央办公室用户，我需要能够将数据更改发送到工匠网关，以便这些更改可以根据需要传播和执行
- en: As an Artisan Manager, I need to be able to create `Artisan` objects so that
    I can manage Artisans
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan经理，我需要能够创建“Artisan”对象，以便我可以管理Artisans
- en: As an Artisan Manager, I need to be able to delete `Artisan` objects so that
    I can manage Artisans
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan经理，我需要能够删除“Artisan”对象，以便我可以管理Artisans
- en: As an Artisan Manager, I need to be able to update `Artisan` objects so that
    I can manage Artisans
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan经理，我需要能够更新“Artisan”对象，以便我可以管理Artisans
- en: As an Artisan, I need to be able to create `Product` objects so that I can manage
    my Product offerings
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan，我需要能够创建“产品”对象，以便我可以管理我的产品供应
- en: As an Artisan, I need to be able to delete `Product` objects so that I can manage
    my Product offerings
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan，我需要能够删除“产品”对象，以便我可以管理我的产品供应
- en: As an Artisan, I need to be able to update `Order` objects so that I can indicate
    to the Central Office when my part of an Order is fulfilled
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan，我需要能够更新“订单”对象，以便我可以指示中央办公室何时完成订单的我的部分
- en: As an Artisan, I need to be able to update `Product` objects so that I can manage
    my Product offerings
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan，我需要能够更新“产品”对象，以便我可以管理我的产品供应
- en: As an Artisan, I need to be able to update my own `Artisan` object so that I
    can manage my information at HMS Central Office
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan，我需要能够更新自己的“Artisan”对象，以便我可以在HMS中央办公室管理我的信息
- en: As a Product Manager, I need to be able to activate `Product` objects so that
    I can manage Product availability
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为产品经理，我需要能够激活“产品”对象，以便我可以管理产品的可用性
- en: As a Product Manager, I need to be able to deactivate `Product` objects so that
    I can manage Product availability
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为产品经理，我需要能够停用“产品”对象，以便我可以管理产品的可用性
- en: As a Product Manager, I need to be able to update `Product` objects so that
    I can manage Product information that an Artisan can't
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为产品经理，我需要能够更新“产品”对象，以便我可以管理Artisan无法管理的产品信息
- en: As any user sending messages across, to, or from the Artisan Gateway service,
    I need those messages to be signed so that they can be validated before being
    acted upon
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为向Artisan Gateway服务发送消息的任何用户，我需要这些消息被签名，以便在执行之前可以验证
- en: 'With the exception of the last item, these have been grouped more or less in
    the order that they would need to be executed in a real use case: Central Office
    users (acting as Artisan Managers) would need to create objects representing Artisans
    before those Artisans could be expected to do anything, and Artisans have to be
    able to create `Product` objects before Central Office users (acting as Product
    Managers) could be expected to do anything with those objects.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最后一项之外，这些项或多或少地按照在实际用例中需要执行的顺序进行了分组：中央办公室用户（充当Artisan经理）需要创建代表Artisans的对象，然后才能期望Artisans做任何事情，Artisans必须能够创建“产品”对象，然后才能期望中央办公室用户（充当产品经理）对这些对象做任何事情。
- en: Messages
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息
- en: 'Before taking a serious look at the transmission-mechanism options, it would
    be beneficial to have a solid definition of what, exactly, constitutes a message
    being transmitted. At a minimum, given what the data flows coming into the Artisan
    Gateway service look like, and with some idea of what the actual data for a typical
    data object being transmitted entails, it''s apparent that a message needs to
    be able to handle structured data. Internally, that''s probably best represented
    by a `dict`, if only because they are easy to serialize and un-serialize into
    at least two different formats that are easily transmissible: JSON and YAML. We''ve
    already established data dictionary structures for the objects whose state data
    can be stored. A `Product`, for example, from an Artisan''s perspective, whose
    data dictionary has been rendered into JSON looks like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在认真考虑传输机制选项之前，有必要明确定义传输的消息是什么。至少，考虑到Artisan Gateway服务中的数据流的情况，以及典型数据对象的实际数据是什么，显然消息需要能够处理结构化数据。在内部，这可能最好由“dict”表示，因为它们易于序列化和反序列化为至少两种易于传输的不同格式：JSON和YAML。我们已经为可以存储状态数据的对象建立了数据字典结构。例如，从Artisan的角度来看，已经将数据字典渲染为JSON的“产品”看起来是这样的：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This provides all of the data needed for any create or update operation of a
    `Product` initiated by an Artisan, but doesn't specify what operation needs to
    be performed with the data. It also doesn't have any signature data associated
    with it, which we'll want to provide to complete the last of the iteration stories
    noted earlier. Both of those items, operation and signature, need to be added
    to the message, but not to the message data, so that creating an instance of the
    `Product` object on the receiving end doesn't have to deal with removing non-product
    data from the incoming data structure.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了由Artisan发起的任何创建或更新“产品”的操作所需的所有数据，但没有指定需要对数据执行什么操作。它也没有与之关联的签名数据，我们希望提供以完成前面提到的迭代故事的最后一部分。这两个项目，操作和签名，都需要添加到消息中，但不需要添加到消息数据中，这样在接收端创建“产品”对象的实例就不必处理从传入数据结构中删除非产品数据。
- en: 'In the context of a message, they are both metadata: data about the data, in
    this case describing what is to be done with the real data, and what signature
    should be used to verify the integrity of the message. A more complete message,
    intended to update an existing product (providing a description and summary, and
    making the item available) would look something like this (assuming that all product-data
    is transmitted during an update operation):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在消息的上下文中，它们都是元数据：关于数据的数据，本例中描述了对真实数据的操作以及应该使用什么签名来验证消息的完整性。一个更完整的消息，旨在更新现有产品（提供描述和摘要，并使该项目可用），看起来可能是这样的（假设在更新操作期间传输了所有产品数据）：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That data structure as an output goal gives us enough information to implement
    a `DaemonMessage` class to represent any message going to or coming from the Artisan
    Gateway service. `DaemonMessage` is a concrete class, and lives in the `hms_core.daemons`
    module. It starts with a typical class declaration, and has a class constant defined
    that will be used later for encoding string values into byte values, in both instance
    and class methods:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输出目标的数据结构为我们提供了足够的信息来实现一个`DaemonMessage`类，以表示发送到或从Artisan Gateway服务接收的任何消息。`DaemonMessage`是一个具体的类，位于`hms_core.daemons`模块中。它以典型的类声明开始，并定义了一个类常量，稍后将用于将字符串值编码为字节值，无论是在实例方法还是类方法中：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Most of the properties of `DaemonMessage` follow the standard getter, setter,
    and deleter method/property-declaration pattern we''ve been using so far. One
    of them, the `signature` property, needs to return a calculated value every time
    it''s called, and simply has a getter method definition – `_get_signature`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`DaemonMessage`的大多数属性遵循我们迄今为止一直在使用的标准getter、setter和deleter方法/属性声明模式。其中一个属性`signature`需要在每次调用时返回一个计算出的值，并且只有一个getter方法定义
    - `_get_signature`：'
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `_get_signature` method has several noteworthy aspects in its implementation.
    First, since a signature should only be available if there is data to sign, and
    a signing key value to sign the data with, it actively checks for those values,
    raising `RuntimeError` if either is not set. Secondly, its return value has to
    ensure that hashes of the data structure will always be the same for the same
    data structure. Python's `dict` data structures do not guarantee the same sequence
    of keys across multiple `dict` values, even if the same keys exist across them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`_get_signature`方法在其实现中有几个值得注意的方面。首先，由于只有在有数据要签名和有签名密钥值要对数据进行签名时，签名才应该可用，因此它积极地检查这些值，如果没有设置任何一个，则引发`RuntimeError`。其次，其返回值必须确保数据结构的哈希始终对于相同的数据结构而言是相同的。Python的`dict`数据结构不能保证在多个`dict`值之间具有相同的键序列，即使它们之间存在相同的键。'
- en: Since the hashing mechanism requires a `bytes` value, and rendering a `dict`
    into `bytes` (using a `str()` conversion as an intermediate translation mechanism)
    will not always return the same `bytes` sequence to be hashed, some mechanism
    for ensuring the instance's `data dict` is always rendered into a consistent `str`/`bytes` sequence
    is needed. Since the value going into the hashing process for generating the signature
    could start as a string, and since `json.dumps` provides a mechanism for recursively
    sorting the output's keys, that was a quick and simple solution.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于哈希机制需要一个`bytes`值，并且将`dict`渲染为`bytes`（使用`str()`转换作为中间转换机制）不会始终返回相同的`bytes`序列进行哈希处理，因此需要一些机制来确保实例的`data
    dict`始终被渲染为一致的`str`/`bytes`序列。由于用于生成签名的哈希处理的值可能以字符串形式开始，并且`json.dumps`提供了递归排序输出键的机制，这是一个快速简单的解决方案。
- en: The selection of `json.dumps` was made based on simplicity and convenience.
    It might be better in the long run to create an `OrderedDict` instance (from the
    `collections` module), add each element, in order, to the new instance, then hash
    the string value of that instead. If nothing else, that would alleviate any potential
    concerns with data structures to be hashed containing values that cannot be serialized
    into JSON. Another option would be to hash a YAML value instead, since it deals
    with data types that aren't directly serialize-able in a cleaner fashion.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`json.dumps`是基于简单性和便利性。从长远来看，创建一个`OrderedDict`实例（来自`collections`模块），按顺序将每个元素添加到新实例中，然后对其字符串值进行哈希处理可能更好。如果没有其他选择，这将消除任何可能存在的数据结构问题，这些数据结构包含无法序列化为JSON的值。另一个选择是对YAML值进行哈希处理，因为它以更清晰的方式处理无法直接序列化的数据类型。
- en: The property setter and deleter methods are typical-enough implementations that
    they don't warrant much in the way of explanation, though the setter method corresponding
    to the operation property (`_set_operation`) checks the incoming value against
    a limited set of options.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 属性setter和deleter方法的实现都很典型，不需要太多解释，尽管与operation属性对应的setter方法（`_set_operation`）会检查传入的值是否在有限的选项集合中。
- en: 'One significant deviation from the typical properties pattern we''ve used so
    far is that `DaemonMessage` exposes most of its properties as settable and deletable.
    The rationale behind that decision is that it seems likely that the `data`, `operation`,
    and `signing_key` values of a message may not all be known when the message first
    needs to be created, or they may even need to be altered before the message is
    being sent by some other process. Allowing them to be set or deleted on the fly
    alleviates any such concerns in later implementations that use instances of `DaemonMessage`.
    In combination with the on-the-fly, calculated-value implementation of signature
    (and its checking for required property-values before returning), this allows
    as much flexibility as we should need later, while still preserving the type-
    and value-checking of those properties:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，与我们迄今为止使用的典型属性模式相比，`DaemonMessage`的一个重要偏差是，它将大部分属性公开为可设置和可删除的。这一决定背后的理由是，当消息首次需要创建时，可能并不知道`data`、`operation`和`signing_key`的所有值，甚至在消息被其他进程发送之前可能需要对它们进行修改。允许在运行时设置或删除它们可以减轻后续使用`DaemonMessage`实例的任何此类问题。结合在运行时计算值的签名实现（并在返回之前检查所需的属性值），这样可以在以后提供我们所需的灵活性，同时仍保留这些属性的类型和值检查：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Accordingly, the initialization of a `DaemonMessage` doesn''t require any of
    those properties to be supplied to construct an instance, but it allows all of
    them:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`DaemonMessage`的初始化不需要提供这些属性中的任何一个来构造实例，但允许提供所有属性：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Since the purpose of the `DaemonMessage` class is to provide a simple, consistent
    way to generate messages serialized into JSON, and that requires a `dict` value
    to serialize from, we provide methods to do both:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`DaemonMessage`类的目的是提供一种简单、一致的方式来生成序列化为JSON的消息，并且这需要从`dict`值进行序列化，因此我们提供了相应的方法：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Similarly, we''ll need a way to unserialize messages from JSON, with an intermediate
    from dictionary method. These are implemented as class methods, allowing a message
    instance to be created and validated with a signing key. The critical aspects
    of that functionality all reside in the `from_message_dict` class method:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们需要一种方法来从JSON中反序列化消息，使用中间的从字典方法。这些都是作为类方法实现的，允许创建消息实例并使用签名密钥进行验证。该功能的关键方面都驻留在`from_message_dict`类方法中：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Typical type- and value-checking is performed against the incoming arguments
    first:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先对传入的参数执行典型的类型和值检查：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A new `DaemonMessage` instance is created from the data and operation values
    of the incoming `message_dict`, and from the `signing_key` argument after ensuring
    that all data is present and well formed:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从传入的`message_dict`的数据和操作值以及`signing_key`参数创建一个新的`DaemonMessage`实例，确保所有数据都存在且格式良好：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once the new `DaemonMessage` instance exists, provided that its data has the
    same keys and values, and that the local `signing_key` used to generate the signature
    is the same as the `signing_key` that was used to create the original message
    before it was transmitted, the signature values of both messages should be identical.
    If they aren''t, then there is something suspect with the message. There are not
    many possible causes for a signature failure:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦存在新的`DaemonMessage`实例，只要其数据具有相同的键和值，并且用于生成签名的本地`signing_key`与用于在传输之前创建原始消息的`signing_key`相同，则两条消息的签名值应该是相同的。如果不是，则消息存在可疑情况。签名失败的可能原因并不多：
- en: The `data` in the message has gotten corrupted/altered in some fashion
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息中的数据以某种方式损坏/更改
- en: The local and remote `signing_key` values are different
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地和远程的`signing_key`值不同
- en: 'In either case, no action should be taken – either the data itself is suspect,
    or the authenticity of the message cannot be verified. In any signature-failure
    condition, we raise a custom error, `InvalidMessageError`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，都不应采取任何行动 - 要么数据本身存在可疑情况，要么无法验证消息的真实性。在任何签名失败的情况下，我们会引发一个自定义错误，`InvalidMessageError`：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The conversion from a JSON-serialized message to a `DaemonMessage` instance
    simply decodes the incoming JSON, then feeds the resultant `dict` data structure
    into `from_message_dict`, returning the resultant object:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将JSON序列化消息转换为`DaemonMessage`实例的过程只是解码传入的JSON，然后将结果`dict`数据结构输入到`from_message_dict`中，返回结果对象：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Serializing messages to and from JSON doesn't impact our options for how the
    Artisan Gateway service actually transmits those messages. Both of the options
    mentioned, web service and message queue approaches, can handle JSON message formats –
    so this message strategy is *very* portable in that respect.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将消息序列化为JSON格式并不影响Artisan Gateway服务实际传输这些消息的选项。提到的两种选项，即Web服务和消息队列方法，都可以处理JSON消息格式
    - 因此在这方面，这种消息策略非常便携。
- en: The signing process of `DaemonMessage` relies heavily on the idea of creating
    and managing signing keys for messages – messages cannot be sent or read without
    them – and there are some significant considerations that should be discussed
    before moving on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`DaemonMessage`的签名过程严重依赖于创建和管理消息的签名密钥的想法 - 没有它们，消息无法发送或读取 - 在继续之前应该讨论一些重要的考虑因素。'
- en: 'Like any cryptographic process, hash-based signatures rely on a secret value
    (`signing_key`, in this case) that has to be created and secured. With respect
    to creating a `signing_key`, there are several factors to bear in mind, but the
    two most significant areas follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何加密过程一样，基于哈希的签名依赖于必须创建和保护的秘密值（在本例中为`signing_key`）。在创建`signing_key`方面，有几个因素需要牢记，但最重要的两个领域如下：
- en: The longer the value is, the harder it will be to crack
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值越长，破解的难度就越大
- en: The more varied the characters in it are, the harder it will be to crack
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含的字符越多，破解的难度就越大
- en: 'The math underlying these is fairly straightforward: it takes less time to
    iterate over 10 values than it does over 100, so the more variations that are
    possible in a secret value of any kind, the longer it will take to iterate over
    them all. The number of possible values can be expressed mathematically as (the
    number of values per character)^((the number of characters in the string)), so
    a 128-character `signature_key`, with 255 possible characters would entail 255^(128)
    possible values, or about 1.09 × 10^(308) combinations that would have to be checked
    to guarantee the calculation of a `signature_key` of that size and scope. At one
    billion such calculations per second, or about 3.15 × 10^(16) calculations per
    year, it''s still technically/mathematically possible to crack such a `signing_key`,
    but assuming that the hashing algorithm doesn''t have any significant flaws that
    can be exploited, it''s impractical, at best.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些底层的数学原理相当简单：迭代10个值所需的时间比迭代100个值所需的时间少，因此任何类型的秘密值中可能的变化越多，迭代所有这些值所需的时间就越长。可能值的数量可以用数学方式表示为（每个字符的值的数量）^（字符串中的字符数量），因此一个具有255个可能字符的128字符`signature_key`将涉及255^(128)个可能值，或大约1.09
    × 10^(308)个组合，必须检查以保证计算出这样大小和范围的`signature_key`。每秒进行十亿次这样的计算，或者每年进行约3.15 × 10^(16)次计算，从技术上/数学上讲，仍然可能破解这样的`signing_key`，但假设哈希算法没有任何可以利用的重大缺陷，这在实际上是不切实际的。
- en: 'The creation of a `signature_key` of whatever length is desired is fairly straightforward.
    Python''s `os` module provides a function, `urandom`, that returns a character
    sequence (as a `bytes` object) suitable for cryptographic use, and of whatever
    length is desired, so generation of even a very long key is as simple as calling
    the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建所需长度的`signature_key`相当简单。Python的`os`模块提供了一个名为`urandom`的函数，返回一个适用于加密使用的字符序列（作为`bytes`对象），并且可以是任意长度，因此生成一个非常长的密钥就像调用以下内容一样简单：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The results can be converted to a hexadecimal string value for storage, if
    needed, and converted back from that hexadecimal string with `bytes.fromhex()`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，结果可以转换为十六进制字符串值进行存储，并使用`bytes.fromhex()`从该十六进制字符串转换回来。
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Securing secret values is usually concerned with some combination of the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 保护机密值通常涉及以下某种组合：
- en: Assuring that they are encrypted at rest, so that even if the data store that
    secrets reside in is compromised, the secrets themselves cannot be easily used
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保它们在静止状态下加密，这样即使存储机密的数据存储被破坏，机密本身也不能轻易使用。
- en: Assuring that they are encrypted in motion, to prevent man-in-the-middle exploits
    from being able to access easily usable keys
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保它们在传输中加密，以防止中间人利用漏洞轻松访问可用的密钥。
- en: Changing (rotating) them on a reasonably frequent basis, to reduce the likelihood
    that a captured secret can be compromised before it's no longer useful
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期更改（轮换）它们，以减少捕获的机密可能在不再有用之前被破坏的可能性。
- en: The creation and management of `signing_key` values for Artisans (and perhaps
    for Central Office-to-Artisan communications as well), and the possibility of
    implementing some sort of key-rotation process will be examined in more detail
    in [Chapter 17](b21d33e8-90c4-4a67-af0e-9fc0211d8e3a.xhtml), *Handling Service
    Transactions*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对Artisans的`signing_key`值的创建和管理（也许还包括与中央办公室到Artisan的通信），以及实施某种密钥轮换过程的可能性将在[第17章](b21d33e8-90c4-4a67-af0e-9fc0211d8e3a.xhtml)
    *处理服务事务*中进行更详细的检查。
- en: Ensuring that they are encrypted in motion could be a significant factor in
    deciding how messages will be transmitted, though. In-flight encryption will require
    the creation of an encryption certificate for either a web-service or locally
    hosted message-queue implementation. A message-queue approach may allow a private
    certificate to be used, while a web service might require a certificate from a
    public Certificate Authority.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 确保它们在传输中加密可能是决定如何传输消息的一个重要因素。在传输中加密将需要为Web服务或本地托管的消息队列实施创建加密证书。消息队列方法可能允许使用私有证书，而Web服务可能需要来自公共证书颁发机构的证书。
- en: Encryption in motion should always be implemented when transmitting any secret
    information, and a `signing_key` definitely falls into that category!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输任何机密信息时，始终应实施传输中的加密，而`signing_key`显然属于该类别！
- en: Encryption at rest feels like it might be overkill for a system of this scope,
    though it could be implemented in code with libraries such as PyCrypto, and/or
    by configuring the MongoDB engine to use its Encrypted Storage Engine (available
    in MongoDB Enterprise). It would also add more complexity to the system than seems
    warranted at this point, including (again) key-creation and management.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 静止状态下的加密感觉对于这种范围的系统可能有些过度，尽管可以使用PyCrypto等库在代码中实现，或者通过配置MongoDB引擎使用其加密存储引擎（在MongoDB
    Enterprise中可用）。这也会给系统增加比目前似乎合理的更多复杂性，包括（再次）密钥的创建和管理。
- en: Deciding on a message-transmission mechanism
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定消息传输机制
- en: 'With the structure of the messages being passed now resolved, it''s a good
    time to take a deeper look at the options for how those messages could be transmitted.
    Ultimately, a decision needs to be made regarding how to implement a process to
    deal with the stories:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 随着现在传递的消息结构得到解决，现在是深入研究如何传输这些消息的选项的好时机。最终，需要就如何实施处理故事的流程做出决定：
- en: As an Artisan, I need to be able to send Product and Order data changes to the
    Artisan Gateway so that those changes can be propagated and acted upon as needed
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan，我需要能够将产品和订单数据更改发送到Artisan网关，以便根据需要传播和采取行动。
- en: As a Central Office user, I need to be able to send Artisan and Product data
    changes to the Artisan Gateway so that those changes can be propagated and acted
    upon as needed
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为中央办公室用户，我需要能够将Artisan和产品数据更改发送到Artisan网关，以便根据需要传播和采取行动。
- en: 'Of the two options discussed earlier (web service or message-queue-based implementations),
    using message queues feels like a better fit:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前讨论的两个选项（基于Web服务或消息队列的实现）中，使用消息队列似乎更合适：
- en: 'Given the limited number of operations expected, a queue-based approach would
    involve less development effort, and probably less complexity than a web-service
    implementation:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到预期的操作数量有限，基于队列的方法将涉及较少的开发工作，可能比基于Web服务的实现更少复杂。
- en: There's no need to handle any of the protocol-level details (HTTP methods, variations
    of data-payload structures, and so on) that would have to be dealt with in implementing
    a web service
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需处理任何协议级别的细节（HTTP方法，数据有效载荷结构的变化等），这些都需要在实现Web服务时处理。
- en: There's no need to write a full-blown HTTP server (either from the ground up,
    or using one of the server classes provided by the `http.server` package), or
    to integrate functionality/code with any of several web-framework options (Flask,
    or the Django REST Framework, for example)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需编写完整的HTTP服务器（从头开始，或使用`http.server`包提供的服务器类之一），或将功能/代码与几种Web框架选项（例如Flask或Django
    REST框架）集成。
- en: 'Messages can be sent and will simply wait in their queues until they are retrieved
    and acted upon, so:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息可以被发送并简单地等待在其队列中，直到它们被检索并采取行动，所以：
- en: All end users can continue to use their applications without interruption so
    long as the queue server is accessible
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要队列服务器可访问，所有最终用户都可以继续使用其应用程序而不会中断。
- en: The Artisan Gateway itself could be taken down (for maintenance, updating, or
    even to be moved to a different server) at any point
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Artisan网关本身随时可能被关闭（进行维护、更新，甚至移动到不同的服务器上）。
- en: 'There are some caveats/trade-offs to this approach, though:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这种方法也有一些注意事项/权衡：
- en: Messages that contain conflicting data changes, though they will still be retrieved
    and processed, could require additional manual attention to reconcile those changes.
    The same thing could happen in a web-service context, but it's at least somewhat
    more likely with message queues.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含冲突数据更改的消息，尽管它们仍将被检索和处理，但可能需要额外的手动注意来协调这些更改。在Web服务上下文中也可能发生同样的事情，但在消息队列中更有可能发生。
- en: Message-retrieval, as an active process over a network, could take somewhat
    longer than simply reading an incoming request made directly to the Artisan Gateway.
    As a result, service throughput may be impacted, but even if a complete message-operation
    cycle took 10 seconds, that would allow for 360 operations per hour (over 8,600
    operations per day, or 3,1000,000 over the course of a year), assuming they were
    not performed in parallel.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个在网络上进行的主动过程，消息检索可能比直接读取发送到工匠网关的传入请求需要更长的时间。因此，服务吞吐量可能会受到影响，但即使完整的消息操作周期需要10秒，也可以允许每小时进行360次操作（每天超过8,600次操作，或者一年内超过3,100,000次操作），假设它们不是并行执行的。
- en: If the message-queue provider goes down, preventing messages from being delivered
    in the first place, that could interrupt end user application usage.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果消息队列提供程序崩溃，导致消息无法首先被传递，这可能会中断最终用户的应用程序使用。
- en: 'Allocation of message queues will have to be given some consideration:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须对消息队列的分配进行一些考虑：
- en: If each Artisan has their own queues, into and out of the Artisan Gateway, at
    least some data about those queues has to be stored and managed, and each Artisan-to-Gateway
    queue will have to be checked individually
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果每个工匠都有自己的队列，进入和离开工匠网关，那么至少需要存储和管理有关这些队列的一些数据，并且必须单独检查每个工匠到网关的队列。
- en: If all Artisans share one inbound queue to the Artisan Gateway, identification
    of which Artisan a given message originated with will have to be implemented for
    each operation
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所有工匠共享一个到工匠网关的入站队列，那么对于每个操作，都必须实现消息的来源是哪个工匠。
- en: Since there is no implicit response requirement in the message protocol to indicate
    that it has been acted upon (or couldn't be because of an error), any response
    to a message that needs to be sent to a user will have to be actively/independently
    sent.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于消息协议中没有隐含的响应要求来指示消息是否已被执行（或者由于错误而无法执行），因此需要发送给用户的消息的任何响应都必须被主动/独立地发送。
- en: As an Artisan, I need a message queue created for and assigned to me so that
    I can send my data changes to the Artisan Gateway.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个工匠，我需要为自己创建一个消息队列，并将其分配给我，以便我可以将我的数据更改发送到工匠网关。
- en: Message-queue implementation with RabbitMQ
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RabbitMQ进行消息队列实现
- en: The `hms_sys` projects will use RabbitMQ as its message-queue provider. RabbitMQ
    is actively maintained, and is a zero-cost solution, with paid support and consultation
    options, making it a good low-budget choice. Additionally, there is a ready-to-roll
    Python library, `pika` (installed with `pip install pika`) that provides all the
    critical functionality needed to send and receive messages from a RabbitMQ server,
    without having to get too far into the weeds implementing a solution from scratch.
    The makers of RabbitMQ, Pivotal Software, also offer a commercial version that
    includes additional management features along with support agreements.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`hms_sys`项目将使用RabbitMQ作为其消息队列提供程序。RabbitMQ得到积极维护，并且是一种零成本解决方案，同时还提供付费支持和咨询选项，这使其成为一个很好的低预算选择。此外，还有一个名为`pika`的Python库（使用`pip
    install pika`进行安装），它提供了从RabbitMQ服务器发送和接收消息所需的所有关键功能，而无需深入实现一个解决方案。RabbitMQ的制造商Pivotal
    Software还提供了一个商业版本，其中包括额外的管理功能以及支持协议。'
- en: There are other options available for message-queue implementations, including
    cloud-based solutions from Amazon (SQS), Microsoft (Azure Service Bus), and Google
    (Cloud Pub/Sub), all of which have corresponding Python libraries available for
    use. Locally installable options include Apache Kafka and ActiveMQ, and Kestrel.
    There is also a general-purpose AMQP library available (`amqp`) that should allow
    connection to and interaction with any message queue service that uses at least
    a basic AMQP protocol.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列实现还有其他选项，包括来自亚马逊（SQS）、微软（Azure Service Bus）和谷歌（Cloud Pub/Sub）的基于云的解决方案，所有这些解决方案都有相应的Python库可供使用。可在本地安装的选项包括Apache
    Kafka和ActiveMQ，以及Kestrel。还有一个通用的AMQP库（`amqp`）可供使用，应该允许连接和与使用至少基本AMQP协议的任何消息队列服务进行交互。
- en: 'Sending a message to a RabbitMQ instance with `pika` is fairly straightforward.
    Here''s a simple example, using the `DaemonMessage` class to generate and sign
    messages:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pika`向RabbitMQ实例发送消息相当简单。以下是一个简单的示例，使用`DaemonMessage`类生成和签署消息：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since we''re transmitting a `DaemonMessage`, we need to generate a signing
    key and message data:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在传输`DaemonMessage`，我们需要生成签名密钥和消息数据：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we create the message:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建消息：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we establish a connection to the RabbitMQ server:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们建立与RabbitMQ服务器的连接：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then the message is sent, and the connection is closed:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后发送消息，并关闭连接：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Executing this script doesn''t generate any output, but verification that the
    message has been sent can be performed with the `rabbitmqctl` command-line tool:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此脚本不会生成任何输出，但可以使用`rabbitmqctl`命令行工具来验证消息是否已发送：
- en: '![](assets/c817168b-6d30-4c6e-ae3e-b6afc0782782.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c817168b-6d30-4c6e-ae3e-b6afc0782782.png)'
- en: 'Running the script a second time, and then the `rabbitmqctl list_queues` tool,
    shows another message ready and waiting in the queue:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行脚本，然后使用`rabbitmqctl list_queues`工具，可以看到另一条消息已准备好在队列中等待：
- en: '![](assets/1cea8516-8d32-4bfe-bf16-3e6b40d4d652.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1cea8516-8d32-4bfe-bf16-3e6b40d4d652.png)'
- en: 'RabbitMQ requires the provision of a channel (or perhaps queue name is as good
    a description) that provides organizational grouping for messages on the server,
    and that we''ll consider using to segregate messages by specific Artisans later
    on. Consider the following queue-name declarations:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ需要提供一个通道（或者也许队列名称是对服务器上的消息进行组织分组的一个很好的描述），我们将考虑稍后使用特定工匠按特定Artisans对消息进行分隔。考虑以下队列名称声明：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, the preceding queue-name declarations are changed to the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，前面的队列名称声明更改为以下内容：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we review the queues and message counts with `rabbitmqctl list_queues`,
    we see that a new queue (`queue_name`) has appeared, with one message in it:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`rabbitmqctl list_queues`审查队列和消息计数时，我们看到出现了一个新队列（`queue_name`），其中有一条消息：
- en: '![](assets/0c45be17-bafa-44ee-904b-0353ab8c6c29.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0c45be17-bafa-44ee-904b-0353ab8c6c29.png)'
- en: 'Reading messages from a queue is a bit more complex, but not significantly
    so. An example script to read the messages sent to our queue by the previous runs
    of the `rabbitmq-sender.py` script starts much the same way:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从队列中读取消息要复杂一些，但并不显著。一个示例脚本，用于读取先前运行的`rabbitmq-sender.py`脚本发送到我们队列的消息，开始方式基本相同：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We need to use the same signing-key value, otherwise the messages being retrieved
    won''t be allowed to be read:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用相同的签名密钥值，否则将无法读取检索到的消息：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Message-handling is dealt with by providing a callback function that accepts
    all of the message properties that are returned by the process of fetching a message
    from the queue:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供一个回调函数来处理消息处理，该回调函数接受从队列中获取消息的过程返回的所有消息属性：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It''s important that we wrap functionality for message-handling in a `try` ... `except`
    block, so that if something does go awry during the message-handling process,
    it doesn''t kill the main message-polling loop that we''ll set up later. In this
    case, at least one error could be raised: the `InvalidMessageError` error we defined
    earlier—it gets thrown if a `DaemonMessage` cannot be created because of an invalid
    signature:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们将消息处理功能封装在`try`...`except`块中，这样如果在消息处理过程中出现问题，它不会终止我们稍后设置的主要消息轮询循环。在这种情况下，至少可能会引发一个错误：我们之前定义的`InvalidMessageError`错误
    - 如果由于无效签名而无法创建`DaemonMessage`，则会引发该错误：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The processes for creating a connection, and associating a channel or queue
    name to it, are the same:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 创建连接的过程，以及将通道或队列名称与其关联的过程是相同的：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this case, though, we''re consuming messages, rather than sending them,
    so we need to set that up:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在消费消息，而不是发送消息，所以我们需要设置好：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we can start listening for messages:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以开始监听消息：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'On execution, this script sets up its own event loop, listening for messages
    on the queue/channel specified. This is approximately equivalent to the event
    loop that `BaseDaemon.main` requires of derived daemon classes, though an actual
    daemon implementation might not use it. As soon as this script is run, it reads
    and outputs the content of the two messages sent earlier by the first script:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行时，此脚本设置自己的事件循环，监听指定的队列/通道上的消息。这大致相当于`BaseDaemon.main`要求派生守护程序类的事件循环，尽管实际的守护程序实现可能不使用它。一旦运行此脚本，它就会读取并输出先前由第一个脚本发送的两条消息的内容：
- en: '![](assets/aee59828-f4b3-49d9-a3b2-341dd020bd5c.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aee59828-f4b3-49d9-a3b2-341dd020bd5c.png)'
- en: This also allows us to verify that the signatures of the two messages, with
    identical content and using the same signing key, are identical. This is expected
    behavior, given that message data and the signing key input did not change between
    sending the two messages.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这也使我们能够验证具有相同内容并使用相同签名密钥的两条消息的签名是相同的。鉴于发送两条消息之间的消息数据和签名密钥输入没有更改，这是预期的行为。
- en: 'Imagine we change the signing key:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们更改了签名密钥：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then rerun the same script; we get different results from our message listener:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后重新运行相同的脚本；我们从消息监听器中得到不同的结果：
- en: '![](assets/018a6a4a-3292-475b-8a5a-c12c3829351f.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/018a6a4a-3292-475b-8a5a-c12c3829351f.png)'
- en: This serves as additional verification that the message-signing process will
    work as expected: Not allowing messages with invalid signatures to be created,
    and thus not being acted upon.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这作为额外的验证，消息签名过程将按预期工作：不允许创建具有无效签名的消息，因此不会被执行。
- en: 'That message-handling functionality, with one minor change, can serve as the
    basis for the `main` loop of the main class for the Artisan Gateway:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 该消息处理功能，经过一些小的更改，可以作为Artisan Gateway的主类的`main`循环的基础：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We still need a message-handling function, but now it''s defined as a method
    of the service class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要一个消息处理功能，但现在它被定义为服务类的一个方法：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `main` loop of the `ArtisanGatewayDaemon` class can start as a simple re-casting
    of the original functionality from the receiver script:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArtisanGatewayDaemon`类的`main`循环可以作为接收器脚本的原始功能的简单重新转换开始：'
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Initially, just to establish that the functionality needed is viable, we''ll
    use the same `signing_key`, `connection`, and `channel` values established earlier.
    Eventually, these will depend on configuration values – specifying the signing
    key, or at least where or how to get it – and depending on whether the final implementation
    goes down the path of having individual Artisan queues, there might be several
    queue-names/channels, or just the one. For now, having just the one that was used
    in the earlier script allows us to establish basic queue-reading functionality:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，为了建立所需的功能是可行的，我们将使用之前建立的相同的`signing_key`，`connection`和`channel`值。最终，这些将取决于配置值
    - 指定签名密钥，或者至少在哪里或如何获取它 - 并且取决于最终实现是否沿着拥有单独的工匠队列的路径，可能会有几个队列名称/通道，或者只有一个。目前，只有在先前脚本中使用的一个允许我们建立基本的队列读取功能：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The base structure of the loop that `main` executes is similar to the structure
    of the main loop from the `testdaemon` of [Chapter 15](26ce9de7-eb44-4e33-afa2-fccb17e75aa8.xhtml), *Anatomy
    of a Service* – so long as the class' internal `_running` flag is `True`, the
    loop continues, performing the queue check and processing incoming messages. Once
    the loop is terminated, whether by the `stop` method of the class or by one of
    the signals that was registered during the execution of `BaseDaemon.__init__`
    by `ArtisanGatewayDaemon.__init__`, control exits and the `cleanup` method of
    the class is called before it terminates completely.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 执行的循环的基本结构类似于[第15章](26ce9de7-eb44-4e33-afa2-fccb17e75aa8.xhtml)中 `testdaemon`
    的主循环的结构，只要类的内部 `_running` 标志为 `True`，循环就会继续，执行队列检查和处理传入的消息。一旦循环终止，无论是通过类的 `stop`
    方法还是通过在 `BaseDaemon.__init__` 的执行期间由 `ArtisanGatewayDaemon.__init__` 注册的信号之一，控制都会退出，并在完全终止之前调用类的
    `cleanup` 方法。'
- en: 'The primary difference, as should be expected, is what actually happens during
    each iteration through the loop. In this case, the `channel` is polled for the
    next available message, and if one is detected, it''s read, converted to a `DaemonMessage`,
    acknowledged, and handed off to the message-handler method defined earlier. It
    requires the same sort of `connection` and `channel`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的区别，正如预期的那样，是在每次循环迭代中实际发生的事情。在这种情况下，`channel` 被轮询以获取下一个可用消息，如果检测到一个消息，它将被读取，转换为
    `DaemonMessage`，然后被确认，并交给之前定义的消息处理方法。它需要相同类型的 `connection` 和 `channel`：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once those are established, the `main` loop is very straightforward:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些都建立好了，`main` 循环就非常简单：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In order to test this, a quick, basic configuration file was assembled, mostly
    for logging information, and an instance of the new class was created with that
    configuration and started. The log output from startup to shutdown, including
    sending a good message, a bad message, then another good message, shows that everything
    operates as expected:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，快速创建了一个基本的配置文件，主要用于记录信息，并创建了一个具有该配置的新类的实例，并启动了它。从启动到关闭的日志输出，包括发送一个好消息，一个坏消息，然后又一个好消息，显示一切都按预期运行：
- en: '![](assets/47cc5788-d105-4bb8-94a2-f2549d060e10.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/47cc5788-d105-4bb8-94a2-f2549d060e10.png)'
- en: 'The quick, basic configuration for this daemon instance is very simple:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个守护程序实例的快速基本配置非常简单：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The queue parameters should reside in the configuration file as well, and be
    acquired by the daemon instance. The additional configuration values end up looking
    like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 队列参数也应该驻留在配置文件中，并由守护程序实例获取。附加的配置值最终看起来像这样：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The process for loading those values involves the addition of some instance
    properties that mostly follow the normal pattern in use thus far:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 加载这些值的过程涉及添加一些实例属性，这些属性大多遵循到目前为止使用的正常模式：
- en: '`connection_params`: A dict value whose values are retrieved from the connection
    section of the config file that is used to create the RabbitMQ connection'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connection_params`：一个字典值，其值从配置文件的连接部分中检索，用于创建RabbitMQ连接'
- en: '`queue_name`: A string, it is the queue-name/channel that the instance will
    listen to'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queue_name`：一个字符串，它是实例将要监听的队列名称/通道'
- en: '`signing_key`: A `bytes` or `str` value, it is the signing key that the instance
    will use to create `DaemonMessage` instances sent on or received from its queue'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signing_key`：一个 `bytes` 或 `str` 值，它是实例将用于创建发送到其队列上或从其队列上接收的 `DaemonMessage`
    实例的签名密钥'
- en: 'Actually getting and storing those values involves nothing more than adding
    to the `_on_configuration_loaded` method of the class. Originally, all it did
    was call the same method of the `BaseDaemon` parent class in order to set up logging
    capabilities, and that remains the same:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 实际获取和存储这些值只需要在类的 `_on_configuration_loaded` 方法中添加。最初，它所做的只是调用 `BaseDaemon` 父类的相同方法，以建立日志功能，这一点保持不变：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Queue-specific items are retrieved next. Although there''s no expectation at
    this point that other queue systems will be needed, we can''t rule out that possibility
    in the future, so the code starts with the assumption that we''ll want to allow
    for that in the future:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来检索特定于队列的项目。尽管目前没有预期会需要其他队列系统，但我们不能排除将来可能需要的可能性，因此代码从允许将来允许这种可能性的假设开始：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The signing key is also in the configuration file, so acquiring and storing
    it comes next:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 签名密钥也在配置文件中，因此接下来是获取和存储它：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: At least for the time being, that takes care of all of the configuration needed
    to remove the hardcoded values that were in use in main, while keeping the class
    functional. Execution of a variant of the original message-sending script (in
    `scratch-space/rabbitmq-sender-daemon-queue.py` of the chapter code) showed that
    the daemon still functioned as expected with these changes – listening for and
    acting upon valid messages.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 至少目前为止，这样做就足以处理掉主要部分中使用的硬编码值，同时保持类的功能。对原始消息发送脚本的变体（在本章代码的 `scratch-space/rabbitmq-sender-daemon-queue.py`
    中）的执行显示，守护程序仍然按预期运行，监听并对有效消息进行操作。
- en: Handling messages
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理消息
- en: 'In order to actually do something with the data of a message, we''ll need to
    define what a well-formed command message actually looks like, implement methods
    to execute the commands that are allowed, and implement functionality that knows
    how to call those methods, given a well-formed and verified message to do so.
    The first item from that list is quite simple, but could have a lot of different
    valid implementation patterns. Consider that, at this point, we''re allowed to
    transmit four different operation actions by `DaemonMessage`: `''create''`, `''update''`,
    `''delete''`, and `''response''`. These operation actions correspond directly
    to standard CRUD operations, except for the `''response''` value, though even
    that is, perhaps, roughly equivalent to a `read` operation. For any given data
    object type, those operations would, respectively, need to execute the same processes:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际处理消息的数据，我们需要定义一个格式良好的命令消息实际上是什么样子，实现可以执行允许的命令的方法，并实现知道如何调用这些方法的功能，给定一个格式良好且经过验证的消息来执行。列表中的第一项非常简单，但可能有许多不同的有效实现模式。考虑到，此时，我们可以通过`DaemonMessage`传输四种不同的操作动作：`'create'`、`'update'`、`'delete'`和`'response'`。这些操作动作直接对应于标准的CRUD操作，除了`'response'`值，即使那个值，也可能大致相当于`read`操作。对于任何给定的数据对象类型，这些操作分别需要执行相同的过程：
- en: Create a new instance of the relevant class, populated with state data from
    the message, using the `from_data_dict` class method (or a new equivalent class
    method, perhaps), and `save` the new instance
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建相关类的新实例，并使用`from_data_dict`类方法（或者可能是一个新的等效类方法）填充来自消息的状态数据，并`save`新实例
- en: Retrieve an existing instance of the relevant class, using the `get` class method,
    update any of that instance's state data with new values from the message (which
    would probably benefit from having a new method created, perhaps `update_from_message`),
    and `save` the instance
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`get`类方法检索相关类的现有实例，使用消息中的新值更新该实例的任何状态数据（这可能会受益于创建一个新方法，例如`update_from_message`），并`save`该实例
- en: Find and delete the instance specified by the message data with the `delete`
    class method
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`delete`类方法查找并删除消息数据指定的实例
- en: Retrieve and return the data dict representation of the instance specified by
    the message data, using the `get` class method to perform the retrieval, and the
    `to_data_dict` method of the found instance to generate the data structure of
    the message
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`get`类方法检索消息数据指定的实例的数据字典表示，并使用`to_data_dict`方法生成找到实例的数据结构的消息
- en: 'The daemon, then, needs to have as many as 16 `{action}_{object}` methods,
    one for each action/object combination, just to ensure that all of the combinations
    are accounted for. For each object type (Artisans, Customers, Orders, and Products),
    the set of methods would look something like this (the method names are self-explanatory):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 守护程序需要有多达16个`{action}_{object}`方法，每种操作/对象组合都需要一个，以确保所有组合都被考虑到。对于每种对象类型（工匠、顾客、订单和产品），方法集看起来会像这样（方法名称不言自明）：
- en: '`create_artisan`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_artisan`'
- en: '`update_artisan`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_artisan`'
- en: '`delete_artisan`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete_artisan`'
- en: '`response_artisan`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`response_artisan`'
- en: 'The one critical piece of data that isn''t yet accounted for, and is needed
    to determine which of those methods to execute on receipt of a command message,
    is the object type. The `DaemonMessage` class doesn''t have a specific property
    for object types, because the initial thought was that doing so could needlessly
    limit future uses of it to messages that have both an `operation` and an object
    type. Revising `DaemonMessage` to allow an object-type specification wouldn''t
    be difficult. It would involve little more than adding an optional property, allowing
    another optional argument in the `__init__` method, and any other methods that
    call it, and accounting for it in the dictionary output methods. Going to those
    lengths, though, seems unnecessary: the messages themselves, as structured data,
    can just as easily contain the necessary data. As an example, consider a "create
    Artisan" message that looks like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 尚未考虑的一个关键数据，需要确定在接收命令消息时执行哪些方法，就是对象类型。`DaemonMessage`类没有特定的属性用于对象类型，因为最初的想法是这样做可能会不必要地限制将来对同时具有`operation`和对象类型的消息的使用。修改`DaemonMessage`以允许对象类型的指定并不困难。这只需要添加一个可选属性，允许`__init__`方法中的另一个可选参数，并在调用它的任何其他方法中考虑它。然而，采取这些措施似乎是不必要的：结构化数据的消息本身可以很容易地包含必要的数据。例如，考虑一个看起来像这样的“创建工匠”消息：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If any command message has an operation and indicates in its data an object
    type (the `target` value) with the properties to be used in the operation as a
    standard structure, that would work just as well. Similar data structures will
    also work for update operations:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何命令消息具有操作并且在其数据中指示对象类型（`target`值）以及要在操作中使用的属性作为标准结构，那将同样有效。类似的数据结构也适用于更新操作：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For delete operations:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于删除操作：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As well as for response operations:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以及响应操作：
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Determining which method to call based on the message''s operation and `data.target`
    values is simply a long chain of `if…elif…else` decisions:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 根据消息的操作和`data.target`值确定调用哪个方法只是一长串`if…elif…else`决策：
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Since we''ll need the target (for decision-making later) and the properties
    (to pass as arguments to the method), get those first:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们以后需要目标（用于决策）和属性（作为方法的参数传递），所以首先获取它们：
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Each combination of `operation` and `target` looks very much like the others.
    Starting with `create` operations:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 每种`operation`和`target`的组合看起来都非常相似。从`create`操作开始：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If the target is one of the known, allowed types, then we can just call the
    appropriate method:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标是已知的、允许的类型之一，那么我们可以直接调用适当的方法：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If the `target` is not known, we want to throw an error:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`target`是未知的，我们希望抛出一个错误：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The other operations work much the same way – `update` operations, for example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 其他操作也基本相同 - 例如`update`操作：
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `delete` and `response` operations are similar enough that there''s little
    point in reproducing them here, but they are present in the code. Finally, we
    also capture cases where the operation isn''t recognized, and raise an error in
    those cases as well:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`和`response`操作相似到足以没有必要在这里重复，但它们在代码中是存在的。最后，我们还捕获操作未被识别的情况，并在这些情况下引发错误：'
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The actual operation methods are, as a result of the data object design/structure
    and the structure of the incoming messages, relatively simple. Creation of an
    `Artisan`, for example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据对象设计/结构和传入消息的结构，实际操作方法相对简单。例如，创建`Artisan`：
- en: '[PRE52]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Update of an `Artisan`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`Artisan`：
- en: '[PRE53]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Deletion of an `Artisan`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`Artisan`：
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`Artisan` response:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Artisan`响应：'
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Queues and related Artisan properties
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列和相关的Artisan属性
- en: Since Artisans will communicate with the Gateway over specific queues, and those
    queues have to be identified and consistently associated with their respective
    Artisans, we'll need to have mechanisms in the various code bases to store queue
    identifiers, and to associate them with their Artisan owners.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 由于工匠将通过特定队列与网关通信，并且这些队列必须被识别并与它们各自的工匠保持一致关联，我们需要在各种代码库中有机制来存储队列标识，并将它们与其工匠所有者关联。
- en: 'The queue specifications themselves can be implemented simply by adding a property
    (`queue_id`) to the `Artisan` objects'' classes. Since the Artisan objects at
    both the Gateway service and Artisan application will make use of `queue_id`,
    it makes sense to implement that in the `hms_core.business_objects.BaseArtisan`
    class, where it will be inherited everywhere it''s needed. The property getter
    and deleter methods are typical implementations, as is the `property` declaration,
    though it follows a read-only property pattern. The setter method is pretty typical
    also:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 队列规范本身可以通过向`Artisan`对象的类添加一个属性（`queue_id`）来简单实现。由于网关服务和Artisan应用中的Artisan对象都将使用`queue_id`，因此在`hms_core.business_objects.BaseArtisan`类中实现这一点是有意义的，在那里它将被继承到需要的所有地方。属性的获取器和删除器方法是典型的实现，`property`声明也是如此，尽管它遵循只读属性模式。设置器方法也是非常典型的：
- en: '[PRE56]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Artisans will also need to keep track of a signing key property that is unique
    to each Artisan, but exists in both the local `Artisan` objects at the Artisan
    Application side of the message-transmission process and at the Artisan Gateway
    side. Signing keys, as `bytes` values, may not be easily stored in their native
    value types, though: `bytes` values are not natively JSON-serializable, which
    is problematic for the local Artisan data storage already implemented, and could
    be problematic for the MongoDB storage in use elsewhere.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 工匠还需要跟踪每个工匠独有的签名密钥属性，但存在于消息传输过程的Artisan应用端和Artisan网关端的本地`Artisan`对象中。签名密钥作为`bytes`值，可能不容易以其原生值类型存储：`bytes`值在本地Artisan数据存储中已经实现，可能对其他地方使用的MongoDB存储也有问题，因为`bytes`值不是本地JSON可序列化的。
- en: 'Fortunately, the `bytes` type provides instance and class methods to serialize
    and unserialize values to and from hexadecimal string values. Serializing a byte''s
    value is as simple as calling the `hex()` method of the value, and creating a
    bytes value from a hex string is accomplished by calling `bytes.fromhex(hex_string)`.
    A simple example of a complete serialization/unserialization of a bytes value
    using `hex()`/`fromhex()` shows that the value is preserved as needed:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`bytes`类型提供了实例和类方法，用于将值序列化和反序列化为十六进制字符串值。序列化字节值只需调用值的`hex()`方法，从十六进制字符串创建字节值则通过调用`bytes.fromhex(hex_string)`来实现。使用`hex()`/`fromhex()`完整序列化/反序列化字节值的简单示例显示了该值按需保留：
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output of this code will look like the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出将如下所示：
- en: '![](assets/6e5794ea-6adf-401d-91a9-7782d7c5fd24.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6e5794ea-6adf-401d-91a9-7782d7c5fd24.png)'
- en: 'The corresponding property of the Artisan classes (`signing_key`) follows the
    typical read-only property structure too, and apart from its setter method, is
    nothing unusual. The setter method has to allow both raw `bytes` values and hex
    string representations of `bytes` values, and *stores* a `bytes` value:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Artisan类的相应属性（`signing_key`）也遵循典型的只读属性结构，并且除了其设置器方法外，没有什么不同。设置器方法必须允许原始`bytes`值和`bytes`值的十六进制字符串表示，并*存储*`bytes`值：
- en: '[PRE58]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If it''s passed a string, it tries to convert that using `bytes.fromhex()`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递了一个字符串，它会尝试使用`bytes.fromhex()`进行转换：
- en: '[PRE59]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'It also enforces a minimum length of the signing key, arbitrarily set to `64`
    bytes (512 bits):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 它还强制签名密钥的最小长度，任意设置为`64`字节（512位）：
- en: '[PRE60]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The corresponding final `Artisan` objects have to account for these new properties
    in their `to_data_dict` methods and `__init__` methods. The `to_data_dict` changes
    look the same – using `hms_core.co_objects.Artisan` as an example, and showing
    the new properties added to the end of the dict result returned, they end up looking
    like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的最终`Artisan`对象必须在它们的`to_data_dict`方法和`__init__`方法中考虑这些新属性。`to_data_dict`的更改看起来是一样的
    - 以`hms_core.co_objects.Artisan`为例，并显示添加到返回的dict结果的新属性，它们最终看起来像这样：
- en: '[PRE61]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The changes to the `__init__` methods vary somewhat: since the new `queue_id`
    and `signing_key` properties are assigned as `BaseArtisan.__init__` executes,
    that method has to actually call the deleter and setter methods:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__`方法的更改有所不同：因为新的`queue_id`和`signing_key`属性是在`BaseArtisan.__init__`执行时分配的，所以该方法必须实际调用删除器和设置器方法：'
- en: '[PRE62]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Since `queue_id` and `signing_key` are technically required properties, if time
    allowed, moving them into the required-arguments portion of the `__init__` signature,
    between `address` and `company_name`, would be the right thing to do. In this
    case, it's more a matter of space constraints than time, so they're being added
    into the signature at an easy location to deal with instead, rather than having
    to review, modify, and reshow all of the various `BaseArtisan.__init__` calls
    that already exist in the code. They'll still work as required properties, though,
    since the setter methods won't accept the default `None` values, and they're being
    called without the sort of checking that `company_name` and `website` use.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`queue_id`和`signing_key`在技术上是必需的属性，如果时间允许，将它们移动到`__init__`签名的必需参数部分，位于`address`和`company_name`之间，将是正确的做法。在这种情况下，更多的是空间限制而不是时间，因此它们被添加到签名中的一个易于处理的位置，而不是不得不审查、修改和重新显示代码中已经存在的各种`BaseArtisan.__init__`调用。但是，它们仍将作为必需属性工作，因为setter方法不会接受默认的`None`值，并且它们被调用而不使用`company_name`和`website`使用的检查。
- en: 'The `__init__` methods of `co_objects.Artisan` and `artisan_objects.Artisan`
    only have to be updated to include the new arguments in their signatures and pass
    those along to their `BaseArtisan.__init__` calls. The revisions to `co_objects.Artisan.__init__`
    look like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`co_objects.Artisan`和`artisan_objects.Artisan`的`__init__`方法只需要更新以包括它们签名中的新参数，并将这些参数传递给它们的`BaseArtisan.__init__`调用。对`co_objects.Artisan.__init__`的修订如下：'
- en: '[PRE63]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Requirements for a web-service-based daemon
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Web服务的守护程序的要求
- en: If we were to pursue a web-service-based implementation for the Artisan Gateway
    instead, there are several common factors, and a few hurdles that would have to
    be overcome. Arguably the most significant hurdle would be in implementing the
    full set of `HTTP` methods – `POST`, `GET`, `PUT`, and `DELETE` – the official
    and standards-compliant methods that correspond to the `Create`, `Read`, `Update`,
    and `Delete` CRUD operations we're expecting to use.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要改为使用基于Web服务的实现来实现Artisan网关，有一些共同因素和一些必须克服的障碍。可以说，最重要的障碍将是实现完整的`HTTP`方法
    - `POST`，`GET`，`PUT`和`DELETE` - 官方和符合标准的方法，对应于我们期望使用的`Create`，`Read`，`Update`和`Delete`
    CRUD操作的方法。
- en: 'If the medium that commands are transmitted in is to remain the serialized
    and signature-bearing message output of the `DaemonMessage` class, we''d need
    to be able to pass a complete, signed message in at least two different ways:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令传输的介质仍然是`DaemonMessage`类的序列化和带签名的消息输出，我们需要能够以至少两种不同的方式传递完整的签名消息：
- en: 'In a query string format for the `GET` and `DELETE` operations: GET isn''t
    intended to support the same sort of payload capabilities that `POST` and `PUT`
    methods allow, and though there doesn''t seem to be any official stance as to
    whether `DELETE` should or should not support it, it''s probably safest to assume
    that it won''t, and write code accordingly.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`GET`和`DELETE`操作的查询字符串格式：GET并不打算支持`POST`和`PUT`方法允许的相同类型的有效负载功能，尽管似乎没有任何官方立场表明`DELETE`是否应该支持它，但最安全的做法可能是假设它不会，并相应地编写代码。
- en: 'In as many as two different payload formats for POST and PUT operations. Thus
    far, we haven''t addressed any of the Product data in any detail; even if there
    is no requirement to support the transmission of product images, it''s just a
    matter of time until one would surface. The `HTTP POST` and `PUT` operations allow
    a payload to be sent in the request body, and allow that payload to be sent in
    two different formats (encodings) in a standard web form request context:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在POST和PUT操作的两种不同有效负载格式中。到目前为止，我们还没有详细讨论任何产品数据；即使没有要求支持产品图像的传输，也只是时间问题。`HTTP
    POST`和`PUT`操作允许在请求体中发送有效负载，并允许以两种不同格式（编码）发送有效负载在标准Web表单请求上下文中：
- en: As a key-value string list that looks very much like the equivalent in a `GET`
    request
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个键值字符串列表，看起来非常像`GET`请求中的等效内容
- en: As a more detailed encoding, where each field in the request has the same name
    and data as the key-value list, but also allows fields to specify that they contain
    specific data types – Files, for example, with other data, such as the filename
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为更详细的编码，请求中的每个字段都具有与键值列表相同的名称和数据，但还允许字段指定它们包含特定的数据类型 - 例如，文件，以及其他数据，例如文件名
- en: 'The latter encoding is seen in web pages that allow file uploads as an `enctype="multipart/form-data"`
    attribute in the relevant `<form>` tag. Submitting such a form, with two files
    included in the payload, will generate an `HTTP` request that might look something
    like this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 后一种编码在允许文件上传的Web页面中看到，作为相关`<form>`标记中的`enctype="multipart/form-data"`属性。提交这样的表单，包括有效负载中的两个文件，将生成一个类似于以下内容的`HTTP`请求：
- en: '![](assets/0cb06097-c8d9-4427-a023-f4fdc885b6b5.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0cb06097-c8d9-4427-a023-f4fdc885b6b5.png)'
- en: 'In this example:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中：
- en: '`{field-separator}` is a random string that uniquely identifies the beginning
    of each field''s dataset'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{field-separator}`是一个随机字符串，唯一标识每个字段数据集的开始'
- en: '`{content-length}` is the total size of the payload'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{content-length}`是有效负载的总大小'
- en: '`{field-name}` is the name of the field whose data is wrapped in the section'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{field-name}`是其数据包含在该部分中的字段的名称'
- en: '`{field-value}` is text data from a field that is not a file-upload field'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{field-value}`是不是文件上传字段的字段中的文本数据'
- en: '`{file-name}` is the name of the file being uploaded, as it existed on the
    client machine'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{file-name}`是正在上传的文件的名称，就像它在客户端机器上存在的那样'
- en: '`{MIME-type}` is an indicator of the type of file being transmitted, for example
    `image/png`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{MIME-type}`是正在传输的文件类型的指示器，例如`image/png`'
- en: '`{file-data}` is the data of the file corresponding to the field'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{file-data}`是与字段对应的文件的数据'
- en: In order to support a payload with just these three chunks of data, we'd have
    to find or create code that can reliably parse out each data section and handle
    each data chunk that gets spat back out. While there is at least one such library,
    `requests-toolbelt`, there are known issues with it in certain core Python versions
    (3.3.0 and 3.3.1), so it may or may not be a viable option depending on what Python
    version is in play. Writing (and testing) code from scratch to deal with `multipart/form-data`
    payloads would be a time-consuming process at best.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持仅具有这三个数据块的有效负载，我们必须找到或创建能够可靠解析出每个数据部分并处理每个被吐出的数据块的代码。虽然至少有一个这样的库，`requests-toolbelt`，但在某些核心Python版本（3.3.0和3.3.1）中已知存在问题，因此它可能是一个可行的选择，具体取决于所使用的Python版本。从头开始编写（和测试）处理`multipart/form-data`有效负载的代码将是一个耗时的过程。
- en: Assuming that all of that is dealt with, although it's not difficult to write
    network listeners that would be able to capture and handle an incoming request,
    that too could involve a fair chunk of time, particularly on the testing side
    of things, just to be able to reliably (and provably) handle incoming requests.
    In a web service scenario, it would almost certainly be a better option to start
    with one of the well-established web application packages that already deals with
    all of those needs and requirements, and write code that simply maps incoming
    requests to the handler methods, in much the same way that the message-queue implementation
    does. On the plus side, the signed messages should be usable in that context,
    and the underlying operation methods would likely not have to be modified to any
    significant degree.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 假设所有这些都已经处理，虽然编写能够捕获和处理传入请求的网络监听器并不困难，但这也可能需要相当长的时间，特别是在测试方面，只是为了能够可靠（并可证明地）处理传入请求。在Web服务场景中，几乎肯定最好的选择是从已经处理所有这些需求和要求的成熟的Web应用程序包中开始，并编写代码，简单地将传入请求映射到处理程序方法，就像消息队列实现所做的那样。好的一面是，签名消息应该可以在这种情况下使用，并且底层操作方法可能不需要进行任何重大修改。
- en: Traffic to and from the service
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与服务之间的流量
- en: The message-receiving aspect of the communication chain by the service is already
    in place, in the `main` method of `ArtisanGateway`, but no message-sending functionality
    has been implemented yet, apart from the bits and pieces focused around message
    generation. Each data object type, when modified, created, or deleted, is going
    to need to send a relevant command message to its counterpart subsystem. For example,
    if an Artisan creates a new Product, the act of creating that `Product` object
    needs to send a "create product" message to the Gateway service. Likewise, if
    a change is made to a Product by Central Office staff, the Gateway service needs
    to send an "update product" message to the appropriate Artisan Application instance.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的通信链的消息接收方面已经就位，在`ArtisanGateway`的`main`方法中，但除了围绕消息生成的一些部分之外，还没有实现消息发送功能。每种数据对象类型在修改、创建或删除时都需要向其对应的子系统发送相关的命令消息。例如，如果Artisan创建了一个新的产品，创建该`Product`对象的行为需要向Gateway服务发送一个“创建产品”消息。同样，如果中央办公室工作人员对产品进行了更改，Gateway服务需要向适当的Artisan应用程序实例发送一个“更新产品”消息。
- en: 'On the Artisan Application side of those scenarios, all of the queue parameters
    needed to send any message are going to be constant. They will always send messages
    to the same queue server, on the same port, using the same connection and channel.
    Rather than requiring all of the message-queue settings to be passed to all of
    the various data objects during initialization, which could complicate them significantly,
    and make the code difficult to deal with if a different message-transport mechanism
    were needed later on, we can create another class that contains all of those and
    provides a method for sending arbitrary messages to the queue server: `RabbitMQSender`.
    In the process of defining that class, we can also leverage certain aspects of
    Python class/instance relationships to make the creation of sender instances considerably
    easier:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些场景的Artisan应用程序方面，发送任何消息所需的所有队列参数将是恒定的。它们将始终将消息发送到相同的队列服务器，使用相同的端口，使用相同的连接和通道。与其在初始化期间将所有消息队列设置传递给各种数据对象，这可能会显着复杂化它们，并且如果以后需要不同的消息传输机制，会使代码难以处理，不如创建另一个包含所有这些设置并提供向队列服务器发送任意消息的方法的类：`RabbitMQSender`。在定义该类的过程中，我们还可以利用Python类/实例关系的某些方面，使得创建发送方实例变得更加容易：
- en: An instance of a Python class that has defined class attributes also has instance
    attributes with the same name and value. That is, if `RabbitMQSender` has a class
    attribute named `_host`, with a value of localhost, all instances of `RabbitMQSender`
    will, when created, have a `_host` attribute with the same localhost value.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了类属性的Python类的实例也具有相同名称和值的实例属性。也就是说，如果`RabbitMQSender`有一个名为`_host`的类属性，值为localhost，那么创建的所有`RabbitMQSender`实例都将具有相同的localhost值的`_host`属性。
- en: Changing an instance attribute's value will have no effect on the class attribute's
    value.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改实例属性的值不会影响类属性的值。
- en: Changing a class attribute's value will also change the corresponding instance
    values, provided that they haven't been explicitly set in those instances. So,
    if an instance of `RabbitMQSender` is created, then `RabbitMQSender._host` is
    changed, and the `_host` value of the instance will be updated accordingly.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改类属性的值也会更改相应的实例值，前提是它们没有在这些实例中被明确设置。因此，如果创建了`RabbitMQSender`的一个实例，然后更改了`RabbitMQSender._host`，那么实例的`_host`值将相应更新。
- en: Taken together, and with some caution in design when applied, these allow `RabbitMQSender`
    to be defined so that the *class* can be configured, allowing a usable instance
    of the class to be created with nothing more than the most basic of calls, along
    the lines of `my_sender = RabbitMQSender()`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 综合考虑，并在应用设计时谨慎，这些允许定义`RabbitMQSender`，以便*类*可以配置，允许使用类的可用实例仅需最基本的调用，如`my_sender
    = RabbitMQSender()`。
- en: If a different message-transport mechanism were to be needed later, it would
    probably be a good idea to introduce a layer of abstraction that `RabbitMQSender`
    would derive from – `BaseMessageSender`, perhaps – that would require the message-sending
    method and all of the relevant transport-mechanism properties. That would provide
    a common interface for all transport mechanisms, and make it a lot easier to switch
    between them if/as needed.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以后需要不同的消息传输机制，引入`RabbitMQSender`将从`BaseMessageSender`派生的抽象层可能是一个好主意 - 或许需要该消息发送方法和所有相关的传输机制属性。这将为所有传输机制提供一个公共接口，并且如果/当需要时，更容易地在它们之间切换。
- en: '`RabbitMQSender`, then, starts as a typical class-definition, with the various
    connection properties and any other message-transmission constants defined as
    protected class attributes:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`RabbitMQSender`从典型的类定义开始，其中各种连接属性和其他消息传输常量被定义为受保护的类属性：
- en: '[PRE64]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The properties that correspond to those have only getter methods, so that they
    cannot be easily/accidentally altered:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 与之对应的属性只有getter方法，因此它们不能轻易/意外地被更改：
- en: '[PRE65]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'They are associated with property names in a typical read-only property structure:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 它们与典型的只读属性结构中的属性名称相关联：
- en: '[PRE66]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `connection` and `channel` properties follow a typical lazy-instantiation
    pattern, being created on the first request for either of them, and are also exposed
    as read-only properties:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`connection`和`channel`属性遵循典型的延迟实例化模式，当第一次请求它们时创建，并且也作为只读属性公开：'
- en: '[PRE67]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'There are no property-setter or -deleter methods needed, nor is there any functionality
    needed in `__init__` for the class. All of an instance''s properties will effectively
    refer back to the class attribute values, which can be set with a single class
    method call:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要属性设置器或删除器方法，也不需要类的`__init__`功能。实例的所有属性将有效地引用类属性值，可以通过单个类方法调用进行设置：
- en: '[PRE69]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In the context of an Artisan Application, all that needs to be done to preconfigure all
    instances of `RabbitMQSender` is to call `RabbitMQSender.configure` with the appropriate
    settings, probably taken from the configuration file of the Artisan Application
    instance:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在Artisan应用程序的上下文中，预配置所有`RabbitMQSender`实例所需的一切就是使用适当的设置调用`RabbitMQSender.configure`，可能来自Artisan应用程序实例的配置文件：
- en: '[PRE70]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Finally, the process of sending messages is provided by a single method:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，发送消息的过程由一个单一方法提供：
- en: '[PRE71]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: On the Artisan Application side of the message-transfer processes, the creation
    of a `RabbitMQSender` instance and calling its `send_message` method should take
    care of the actual message transmission we'll need. On the Artisan Gateway side,
    when sending messages to Artisan Application instances, the process will be similar –
    simplified in some ways, possibly not needing the `RabbitMQSender` (or an equivalent)
    class, or perhaps needing a similar variant in order to better handle multiple
    outgoing queues. We'll integrate the Artisan-side processes and examine the Gateway
    needs in more detail in [Chapter 17](b21d33e8-90c4-4a67-af0e-9fc0211d8e3a.xhtml), *Handling
    Service Transactions*.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在消息传输过程的Artisan应用程序端，创建`RabbitMQSender`实例并调用其`send_message`方法应该处理我们需要的实际消息传输。在Artisan
    Gateway端，当向Artisan应用程序实例发送消息时，该过程将类似 - 在某些方面简化，可能不需要`RabbitMQSender`（或等效）类，或者可能需要类似的变体以更好地处理多个传出队列。我们将集成Artisan端的流程，并在[第17章](b21d33e8-90c4-4a67-af0e-9fc0211d8e3a.xhtml)中更详细地研究网关的需求，*处理服务事务*。
- en: Impacts on testing and deployment
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和部署的影响
- en: At this point in the iteration, apart from standard unit-testing for various
    properties and methods that aren't involved in any message transmission, there's
    not much that can be done from a testing standpoint. We have yet to integrate
    messaging with data changes, which we'll examine in [Chapter 17](b21d33e8-90c4-4a67-af0e-9fc0211d8e3a.xhtml), *Handling
    Service Transactions*, and without a complete send-and-receive process available,
    in either direction, there's not much that can be done, even from a manual-testing
    perspective, that hasn't already been explored.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代的这一点上，除了对各种属性和方法进行标准单元测试之外，这些属性和方法并未涉及任何消息传输，从测试的角度来看，没有太多可以做的。我们还没有将消息传递与数据更改集成在一起，我们将在[第17章](b21d33e8-90c4-4a67-af0e-9fc0211d8e3a.xhtml)中进行研究，*处理服务事务*，而且在任何方向上，没有完整的发送和接收过程可用，即使从手动测试的角度来看，也没有太多可以做的，这已经被探索过了。
- en: It also feels premature to work out any deployment details for the Artisan Gateway
    daemon just yet, for similar reasons, though at this point, it feels like a very
    basic `setup.py/Makefile` arrangement will probably handle everything we'll need.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为Artisan Gateway守护程序制定任何部署细节似乎为时过早，出于类似的原因，尽管在这一点上，似乎一个非常基本的`setup.py/Makefile`安排可能会处理我们需要的一切。
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Although we now have all the foundations needed to work through and close the
    14 stories that the iteration stated with, only three are even potentially closed:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们现在已经拥有了完成迭代所需的所有基础，但只有三个故事甚至有可能关闭：
- en: As an Artisan, I need to be able to send data changes to the Artisan Gateway
    so that those changes can be propagated and acted upon as needed
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个工匠，我需要能够将数据更改发送到Artisan Gateway，以便根据需要传播和采取行动
- en: As a Central Office user, I need to be able to send data changes to the Artisan
    Gateway so that those changes can be propagated and acted upon as needed
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为中央办公室用户，我需要能够将数据更改发送到Artisan Gateway，以便根据需要传播和采取行动
- en: As any user sending messages across to or from the Artisan Gateway service,
    I need those messages to be signed so that they can be validated before being
    acted upon
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为向Artisan Gateway服务发送消息的任何用户，我需要这些消息被签名，以便在执行之前可以验证。
- en: Those foundations include, however, a functional (if untested) Artisan Gateway
    daemon/service, a mechanism for generating command messages that can be acted
    upon by that service and the remote applications, and the basic processes for
    actually transmitting those command messages. Between those accomplishments, the
    odds are good that we've actually closed these three stories, but until they are
    tested, we cannot prove that they can be.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些基础包括一个功能齐全（尚未经过测试）的Artisan Gateway守护程序/服务，一种生成可以被该服务和远程应用程序执行的命令消息的机制，以及实际传输这些命令消息的基本流程。在这些成就之间，很有可能我们已经完成了这三个故事，但在它们经过测试之前，我们无法证明它们可以被执行。
- en: The requisite testing to prove closure, and the balance of the stories still
    to be implemented, all rely on integrating the various CRUD operations at the
    data-object level in the Artisan and Central Office applications with the requisite
    messaging to propagate those data changes to the Artisan Gateway, and (where needed)
    from the Gateway to the remote Artisan and Central Office applications, which
    we'll address in the next chapter.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明闭环的必要测试，以及尚未实施的故事的平衡，都依赖于在Artisan和中央办公室应用程序的数据对象级别集成各种CRUD操作，并通过必要的消息传播这些数据更改到Artisan
    Gateway，以及（如果需要）从网关到远程Artisan和中央办公室应用程序的传播，这将在下一章中讨论。
