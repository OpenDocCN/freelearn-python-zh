- en: Chapter 6. Securing Your App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章。保护您的应用程序
- en: We have a mostly functioning blog app, but it is missing some crucial features,
    such as user login, registration, and adding and editing posts from the browser.
    The user login functionality can be created in many different ways, so each of
    the sections demonstrates mutually exclusive methods to create logins. The first
    way is directly using the browser's cookies, and the second way is using a Flask
    extension named **Flask Login**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个大部分功能正常的博客应用，但缺少一些关键功能，比如用户登录、注册以及从浏览器添加和编辑帖子。用户登录功能可以通过许多不同的方式创建，因此每个部分演示了创建登录的互斥方法。第一种方法是直接使用浏览器的cookies，第二种方法是使用名为**Flask
    Login**的Flask扩展。
- en: Setting up
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: 'Before we jump right into making a user authentication system, there is a lot
    of setup code. To run any type of authentication, our app will need the following
    elements common to all:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们立即开始创建用户认证系统之前，需要进行大量的设置代码。为了运行任何类型的认证，我们的应用程序将需要以下所有常见的元素：
- en: First, the user models will need proper password hashing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，用户模型将需要适当的密码哈希
- en: Second, a login form and a registration form will be needed to validate user
    input
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，需要登录表单和注册表单来验证用户输入
- en: Third, a login view and a registration view with templates for each will be
    needed
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，需要登录视图和注册视图以及每个视图的模板
- en: Fourth, various social logins need to be set up in order to tie them into the
    login system when it is implemented
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，需要设置各种社交登录，以便在实施登录系统时将它们与登录系统绑定
- en: Updating the models
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新模型
- en: Until now, our users had their passwords stored as a plain text in the database.
    This is a major security flaw. If any malicious user were to gain access to the
    data in the database, they could log in to any account. The fallout of such a
    breach would be greater than our site. Large amounts of people on the Internet
    use a common password for many sites.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们的用户的密码以明文形式存储在数据库中。这是一个重大的安全漏洞。如果任何恶意用户能够访问数据库中的数据，他们可以登录到任何账户。这样的违规行为的后果将比我们的网站更大。互联网上有很多人在许多网站上使用相同的密码。
- en: If an attacker had access to an e-mail and password combination, it is very
    likely that this information could be used to log in to a Facebook account or
    even a bank account.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者能够获得电子邮件和密码的组合，很可能可以使用这些信息登录到Facebook账户甚至银行账户。
- en: To protect our user passwords, they will be encrypted with a one-way encryption
    method named a **hashing algorithm**. A one-way encryption means that after information
    is encrypted, the original information cannot be regained from the result. However,
    given the same data, the hashing algorithm will always produce the same result.
    The data given to the hashing algorithm can be anything from a text file to a
    movie file. In this case, the data is just a string of characters. With this functionality,
    our passwords can be stored as **hashes** (data that has been hashed). Then, when
    a user enters their password in the login or registration page, the text entered
    for the password will be sent through the same hashing algorithm, and the stored
    hash and the entered hash will be verified.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护我们用户的密码，它们将使用一种名为**哈希算法**的单向加密方法进行加密。单向加密意味着在信息加密后，无法从结果中恢复原始信息。然而，对于相同的数据，哈希算法将始终产生相同的结果。提供给哈希算法的数据可以是从文本文件到电影文件的任何内容。在这种情况下，数据只是一串字符。有了这个功能，我们的密码可以被存储为**哈希值**（已经被哈希过的数据）。然后，当用户在登录或注册页面输入他们的密码时，输入的文本密码将通过相同的哈希算法发送，然后验证存储的哈希和输入的哈希是否匹配。
- en: 'There are many hashing algorithms, most of which are not secure because they
    are easy to **brute force**. Hackers continuously try sending data through a hashing
    algorithm until something matches. To best protect the user passwords, bcrypt
    will be our hashing algorithm of choice. **Bcrypt** is purposely designed to be
    inefficient and slow (milliseconds vs. microseconds) for the computer to process,
    thereby making it harder to brute force. To add bcrypt to our project, the package
    **Flask Bcrypt** will need to be installed as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多哈希算法，其中大多数都不安全，因为它们很容易被**暴力破解**。黑客不断尝试将数据通过哈希算法，直到有匹配的数据。为了最好地保护用户密码，bcrypt将是我们选择的哈希算法。**Bcrypt**被特意设计成对计算机来说是低效和慢的（毫秒级对比微秒级），从而使其更难以被暴力破解。要将bcrypt添加到我们的项目中，需要安装**Flask
    Bcrypt**包，方法如下：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is the second Flask extension that will be initialized on the `app` object,
    the other being the SQLAlchemy object. The `db` object was stored in the `models.py`
    file, but there is no obvious place to initialize Flask Bcrypt. To hold all future
    extensions, add the file named `extensions.py` in the same directory as the `__init__.py`
    file. Inside, Flask Bcrypt will have to be initialized:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个将在`app`对象上初始化的Flask扩展，另一个是SQLAlchemy对象。`db`对象存储在`models.py`文件中，但没有明显的地方来初始化Flask
    Bcrypt。为了保存所有未来的扩展，需要在与`__init__.py`文件相同的目录中添加名为`extensions.py`的文件。在其中，需要初始化Flask
    Bcrypt：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is then added to the `app` object:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其添加到`app`对象中：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Bcrypt is now ready to use. To have our `User` object use bcrypt, we will add
    two methods that set the password and check if a string matches the stored hash:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Bcrypt现在已经准备好使用。为了让我们的`User`对象使用bcrypt，我们将添加两个方法来设置密码并检查字符串是否与存储的哈希匹配：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, our `User` models can store passwords securely. Next, our login process
    needs to use these methods to create new users and check passwords.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`User`模型可以安全地存储密码。接下来，我们的登录过程需要使用这些方法来创建新用户和检查密码。
- en: Creating the forms
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建表单
- en: 'Three forms are required: a login form, a registration form, and a form for
    our **post creation** page. The login form will have username and password fields:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 需要三种表单：登录表单、注册表单和**发布创建**页面的表单。登录表单将包含用户名和密码字段：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Along with the normal validations, our `LoginForm` method will also check whether
    the username passed exists and will use the `check_password()` method to check
    the hashes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了正常的验证外，我们的`LoginForm`方法还将检查传递的用户名是否存在，并使用`check_password()`方法来检查哈希值。
- en: Protecting your form from spam with reCAPTCHA
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用reCAPTCHA保护您的表单免受垃圾邮件攻击
- en: The registration form will have a username field, a password field with a confirmation
    field, and a special field named a reCAPTCHA field. A CAPTCHA is a special field
    on a web form that checks whether whoever is entering data into the form is actually
    a person, or an automated program that is spamming your site. reCAPTCHA is simply
    one implementation of a CAPTCHA. reCAPTCHA has been integrated into WTForms as
    it is the most popular implementation on the Web.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表单将包含用户名字段、带有确认字段的密码字段和名为reCAPTCHA字段的特殊字段。CAPTCHA是Web表单上的一个特殊字段，用于检查输入表单数据的人是否真的是一个人，还是一个正在向您的站点发送垃圾邮件的自动化程序。reCAPTCHA只是CAPTCHA的一种实现。reCAPTCHA已经集成到WTForms中，因为它是Web上最流行的实现。
- en: To use reCAPTCHA, you will need a reCAPTCHA login from [https://www.google.com/recaptcha/intro/index.html](https://www.google.com/recaptcha/intro/index.html).
    As reCAPTCHA is a Google product, you can log in with your Google account.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用reCAPTCHA，您需要从[https://www.google.com/recaptcha/intro/index.html](https://www.google.com/recaptcha/intro/index.html)获取reCAPTCHA登录。由于reCAPTCHA是Google产品，您可以使用Google账户登录。
- en: Once you log in, it will ask you to add a site. In this case, any name will
    do, but the domain field must have `localhost` as an entry. Once you deploy your
    site, your domain must also be added to this list.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，它将要求您添加一个站点。在这种情况下，任何名称都可以，但域字段必须包含`localhost`。一旦部署您的站点，您的域也必须添加到此列表中。
- en: 'Now that you have added a site, dropdowns with instructions on server and client
    integration will appear. The given `script` tag will need to be added to the templates
    of our login and registration views when we create them. What WTForms needs from
    this page are the keys, as shown in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经添加了一个站点，下拉菜单中将显示有关服务器和客户端集成的说明。当我们创建登录和注册视图时，给定的`script`标签将需要添加到我们的模板中。WTForms需要从此页面获取的是如下截图中显示的密钥：
- en: '![Protecting your form from spam with reCAPTCHA](img/B03929_06_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![使用reCAPTCHA保护您的表单免受垃圾邮件攻击](img/B03929_06_01.jpg)'
- en: Remember to never show these keys to public. As these keys are only registered
    to `localhost`, they can be shown here without recourse.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 记住永远不要向公众展示这些密钥。由于这些密钥仅注册给`localhost`，因此可以在此处显示而不会受到影响。
- en: 'Add these keys to the `config` object in the `config.py` file so that WTForms
    can access them as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些密钥添加到`config.py`文件中的`config`对象中，以便WTForms可以访问它们，如下所示：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is our registration form:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的注册表单：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The post creation form will just contain a text input for the title and a text
    area input for the post content:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 帖子创建表单将只包含标题的文本输入和帖子内容的文本区域输入：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Creating views
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建视图
- en: 'In the previous chapter, the index view containing the redirect to the blog
    home was stored in the `create_app` function. That was alright for one view. Now,
    this section is going to add many views on the base URL of the site. As such,
    we need a new controller in `controllers/main.py`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，包含重定向到博客主页的索引视图存储在`create_app`函数中。这对于一个视图来说是可以的。现在，本节将在站点的基本URL上添加许多视图。因此，我们需要在`controllers/main.py`中添加一个新的控制器：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The login and registration views will create our form objects and pass them
    to the templates. For now, the login form will not do anything if the data passed
    validates. The actual login functionality will be added in the next section. However,
    the registration view will create a new user if the data passes validation. Along
    with the login and registration views, there needs to be a logout view, which
    will do nothing for now as well.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 登录和注册视图将创建我们的表单对象并将它们传递给模板。目前，如果传递的数据验证通过，登录表单将不执行任何操作。实际的登录功能将在下一节中添加。但是，如果数据通过验证，注册视图将创建一个新用户。除了登录和注册视图之外，还需要一个注销视图，目前也不会执行任何操作。
- en: 'In the `main.py` controller, add the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.py`控制器中，添加以下内容：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `login.html` and `register.html` templates used in the preceding code (placed
    in the `templates/main` folder) can be made with the `form` macro created in [Chapter
    3](ch03.html "Chapter 3. Creating Views with Templates"), *Creating Views with
    Templates*, but the `script` tag from reCAPTCHA cannot be added to `register.html`
    yet.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中使用的`login.html`和`register.html`模板（放置在`templates/main`文件夹中）可以使用[第3章](ch03.html
    "第3章。使用模板创建视图")中创建的`form`宏来创建，但是reCAPTCHA的`script`标签尚不能添加到`register.html`中。
- en: 'First, there needs to be a way for our child templates to add new JavaScript
    files to the `base.html` template. There also needs to be a way for our views
    to flash messages to the user with the Flask `flash` function. A new content block
    has to be added to the `base.html` file along with a loop over the messages:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的子模板需要一种方法来向`base.html`模板添加新的JavaScript文件。还需要一种方法让我们的视图使用Flask的`flash`函数向用户闪现消息。在`base.html`文件中还需要添加一个新的内容块以及对消息的循环：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Your login page should now resemble the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您的登录页面现在应该类似于以下内容：
- en: '![Creating views](img/B03929_06_02.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![创建视图](img/B03929_06_02.jpg)'
- en: 'Your registration page should look like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您的注册页面应该如下所示：
- en: '![Creating views](img/B03929_06_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![创建视图](img/B03929_06_03.jpg)'
- en: 'Now we need to create the post creation and editing page so something can be
    secured. The two pages will need to transform the text area field into a **WYSIWYG**
    (short for **What You See Is What You Get**) editor to handle wrapping the post
    text in HTML. In the `blog.py` controller, add the following views:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建帖子创建和编辑页面，以便可以进行安全保护。这两个页面将需要将文本区域字段转换为**所见即所得**（**WYSIWYG**）编辑器，以处理将帖子文本包装在HTML中。在`blog.py`控制器中，添加以下视图：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This functionality is much like the code used to add new comments. The data
    of the text field is set in the view because there is no easy way to set the contents
    of `TextAreaField` inside a template.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能与用于添加新评论的代码非常相似。文本字段的数据在视图中设置，因为没有简单的方法在模板中设置`TextAreaField`的内容。
- en: 'The `new.html` template will need a JavaScript file for the WYSIWYG editor.
    **CKEditor** is very simple to install and use. Now, our `new.html` file can be
    created as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`new.html` 模板将需要一个用于所见即所得编辑器的 JavaScript 文件。**CKEditor** 安装和使用非常简单。现在，我们的 `new.html`
    文件可以按以下方式创建：'
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is all that is needed to have the user''s input stored as HTML in the
    database. Because we passed the safe filter in our post template, the HTML code
    appears correctly on our post pages. The `edit.html` template is similar to the
    `new.html` template. The only difference is the `form` opening tag and the creation
    of the `title` field:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是将用户输入存储为 HTML 在数据库中所需的全部内容。因为我们在帖子模板中传递了安全过滤器，所以 HTML 代码在我们的帖子页面上显示正确。`edit.html`
    模板类似于 `new.html` 模板。唯一的区别是 `form` 开放标签和创建 `title` 字段：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `post.html` template will need a button for authors to link them to the
    edit page:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`post.html` 模板将需要一个按钮，以将作者链接到编辑页面：'
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When we are able to detect the current user, the edit button will only be shown
    to the user who created the post.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们能够检测到当前用户时，编辑按钮将只显示给创建帖子的用户。
- en: Social logins
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 社交登录
- en: Integrating alternative login and registration options into your site becomes
    more important as time goes on. Every month, there is another announcement that
    passwords have been stolen from a popular website. Implementing the following
    login options means that our site's database never stores a password for that
    user.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，将替代登录和注册选项集成到您的网站变得越来越重要。每个月都会有另一个公告称密码已从热门网站中被盗。实现以下登录选项意味着我们网站的数据库永远不会为该用户存储密码。
- en: Verification is handled by a large brand name company, which the user already
    places their trust in. By using social logins, the amount of trust a user has
    to place in the website they are using is much lower. Your login process also
    becomes much shorter for the user, decreasing the barrier to entry to your app.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 验证由一个大型品牌公司处理，用户已经对其信任。通过使用社交登录，用户对其所使用的网站的信任程度要低得多。您的登录流程也变得更短，降低了用户使用您的应用的门槛。
- en: Socially authenticated users act as normal users, and unlike the password-based
    login methods, they all can be used in tandem.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 社交认证用户表现为普通用户，与基于密码的登录方法不同，它们可以同时使用。
- en: OpenID
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenID
- en: '**OpenID** is an open protocol that allows users on one site to be authenticated
    by any third-party site that implements the protocol, which are called **Relaying
    Parties** (**RPs**). An OpenID login is represented as a URL from one of the RPs,
    typically the profile page of the website.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenID** 是一种开放协议，允许在一个站点上的用户由实现该协议的任何第三方站点进行身份验证，这些站点被称为 **Relaying Parties**
    (**RPs**)。OpenID 登录表示为来自其中一个 RP 的 URL，通常是网站的个人资料页面。'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To know a full list of sites that use OpenID and how to use each, go to [http://openid.net/get-an-openid/](http://openid.net/get-an-openid/).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解使用 OpenID 的所有网站列表以及如何使用每个网站，转到 [http://openid.net/get-an-openid/](http://openid.net/get-an-openid/)。
- en: 'To add OpenID to Flask, a Flask extension named **Flask-OpenID** will be needed:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 OpenID 添加到 Flask，需要一个名为 **Flask-OpenID** 的 Flask 扩展：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our app will need a couple of things to implement OpenID:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将需要一些东西来实现 OpenID：
- en: A new form object
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新的表单对象
- en: The form validation on the login and registration pages
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录和注册页面的表单验证
- en: A callback after the form submission to log the user in or create a new user
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单提交后的回调以登录用户或创建新用户
- en: 'In the `extensions.py` file, the OpenID object can be initialized as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `extensions.py` 文件中，可以按以下方式初始化 OpenID 对象：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `__init__.py` file, the `oid` object is registered to the `app` object:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `__init__.py` 文件中，将 `oid` 对象注册到 `app` 对象：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The new `form` object will only need the URL of the RP:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `form` 对象只需要 RP 的 URL：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On the login and registration views, `OpenIDForm()` will be initialized, and
    if the data is valid, a login request will be sent:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在登录和注册视图上，将初始化 `OpenIDForm()`，如果数据有效，将发送登录请求：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Both the views have the new decorator `@oid.loginhandler`, which tells Flask-OpenID
    to listen for authentication information coming back from the RP. With OpenID,
    logging in and registering are the same. It is possible to create a user from
    the login form and to log in from the registration form. The same field appears
    on both pages to avoid user confusion.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 两个视图都有新的装饰器 `@oid.loginhandler`，告诉 Flask-OpenID 监听来自 RP 的身份验证信息。使用 OpenID，登录和注册是相同的。可以从登录表单创建用户，也可以从注册表单登录。两个页面上都出现相同的字段，以避免用户混淆。
- en: 'To handle the user creation and login, a new function in the `extensions.py`
    file is needed:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理用户创建和登录，需要在 `extensions.py` 文件中创建一个新函数：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This function is called after every successful response from the RP. If the
    login is successful and a user object does not exist for the identity, this function
    creates a new `User` object. If one already exists, the upcoming authentication
    methods will log the user in. OpenID does not require all possible information
    to be returned, so it is possible that rather than a full name, only an e-mail
    will be returned. This is why the username can be the nickname, full name, or
    e-mail. The `db` and `User` object are imported inside the function to avoid cyclical
    imports from the `models.py` file importing the `bcrypt` object.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每次从 RP 收到成功响应后都会调用此函数。如果登录成功并且不存在与该身份对应的用户对象，则此函数将创建一个新的 `User` 对象。如果已经存在，则即将到来的身份验证方法将登录用户。OpenID
    不需要返回所有可能的信息，因此可能只会返回电子邮件而不是全名。这就是为什么用户名可以是昵称、全名或电子邮件的原因。在函数内导入 `db` 和 `User`
    对象，以避免从导入 `bcrypt` 对象的 `models.py` 文件中导入循环导入。
- en: Facebook
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Facebook
- en: 'To log in with Facebook, and later Twitter, a protocol named **OAuth** is used.
    Our app will not use OAuth directly, instead another Flask extension will be used
    named **Flask OAuth**:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Facebook 登录，以及后来的 Twitter，使用名为 **OAuth** 的协议。我们的应用程序不会直接使用 OAuth，而是将使用另一个名为
    **Flask OAuth** 的 Flask 扩展：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To use Facebook login, our app needs to define a Facebook OAuth object with
    our app's keys. Define a view that redirects the user to the login authorization
    process on Facebook's server, and a function on the Facebook method to load the
    `auth` token from the login process.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Facebook登录，我们的应用程序需要使用我们应用程序的密钥定义一个Facebook OAuth对象。定义一个视图，将用户重定向到Facebook服务器上的登录授权过程，并在Facebook方法上定义一个函数，从登录过程中加载`auth`令牌。
- en: First, a Facebook app needs to be created at [http://developers.facebook.com](http://developers.facebook.com).
    Once you create a new app, look for the panel that lists your app's id and secret
    key.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要在[http://developers.facebook.com](http://developers.facebook.com)创建一个Facebook应用。创建新应用后，查找列出应用程序ID和密钥的面板。
- en: '![Facebook](img/B03929_06_04.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![Facebook](img/B03929_06_04.jpg)'
- en: 'Use these values while adding the following code to `extensions.py`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在`extensions.py`中添加以下代码时使用这些值：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the Facebook developer interface, be sure to add a new authorized website
    as `http://localhost:5000/` or the login will not work. In the `main.py` controller,
    add the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Facebook开发者界面中，请确保添加新的授权网站为`http://localhost:5000/`，否则登录将无法工作。在`main.py`控制器中，添加以下代码：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first route, `facebook_login`, is just a redirect to the login process
    on Facebook''s website. The `facebook_authorized` view receives the response from
    Facebook''s servers and, just like the OpenID process, either creates a new user
    or logs the user in. Now to start the process, add the following link to the registration
    and login templates:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个路由`facebook_login`只是重定向到Facebook网站上的登录过程。`facebook_authorized`视图接收来自Facebook服务器的响应，并且与OpenID过程一样，要么创建一个新用户，要么登录用户。现在，要开始这个过程，向注册和登录模板添加以下链接：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Twitter
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Twitter
- en: 'The Twitter login process is very similar. To create a Twitter app and receive
    your keys, go to [https://apps.twitter.com/](https://apps.twitter.com/). In `extensions.py`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter登录过程非常相似。要创建Twitter应用并获取您的密钥，请转到[https://apps.twitter.com/](https://apps.twitter.com)。在`extensions.py`中：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the `main.py` controller, add the following views:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.py`控制器中，添加以下视图：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These views perform the same function as their Facebook counterparts. Finally,
    in the register and login templates, add the following link to start the login
    process:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些视图执行与它们的Facebook对应项相同的功能。最后，在注册和登录模板中，添加以下链接以开始登录过程：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using the session
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用会话
- en: One way to create authentication in Flask is to use the `session` object. The
    `session` object is an object in Flask that creates an easy way for the server
    to store information in the user's browser with cookies. The stored data is cryptographically
    signed with the app's secret key. If the user attempts to modify the cookie, then
    the sign will no longer be valid and the cookie will not be read.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flask中创建身份验证的一种方法是使用`session`对象。`session`对象是Flask中的一个对象，它为服务器提供了一种使用cookie在用户浏览器中存储信息的简单方式。存储的数据使用应用程序的密钥进行加密签名。如果用户尝试修改cookie，则签名将不再有效，cookie将无法读取。
- en: 'The session object has the same API as a `dict` object. To add data to it,
    simply use this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 会话对象具有与`dict`对象相同的API。要向其中添加数据，只需使用此代码：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To retrieve data, use this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索数据，请使用此代码：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To log a user in, a username key will be added to the session and set to the
    username of the current user.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要登录用户，将用户名键添加到会话中，并设置为当前用户的用户名。
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To log the user out, the key can be popped from the session:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要注销用户，可以从会话中弹出密钥：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To check whether a user is currently logged in, the view can test if the username
    key exists in the session. Consider the following new post view:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查用户当前是否已登录，视图可以测试会话中是否存在用户名键。考虑以下新帖子视图：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Some of our templates will need access to the current user object. At the start
    of every request, our `blog` blueprint can check whether the username is in the
    session. If so, add the `User` object to the `g` object, which is accessible through
    the templates.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一些模板将需要访问当前用户对象。在每个请求开始时，我们的`blog`蓝图可以检查会话中是否存在用户名。如果是，则将`User`对象添加到`g`对象中，通过模板可以访问。
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Our login check can be changed to:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的登录检查可以更改为：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Also, the edit button on the post page should only appear when the current
    user is the author:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，帖子页面上的编辑按钮只有在当前用户是作者时才会出现：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The edit page itself should also perform the following check:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑页面本身还应执行以下检查：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now our app has a fully featured login system with a traditional username and
    password combination and many social logins as well. However, there are some features
    that are not covered in this system. For example, what if we wanted some users
    to be able to only comment while giving others permission to create posts? Also,
    our login system does not implement a `Remember Me` function. To cover this functionality,
    we will refactor our app to use a Flask extension named **Flask Login** instead
    of directly using the session.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序具有一个功能齐全的登录系统，具有传统的用户名和密码组合以及许多社交登录。但是，此系统中还有一些功能未涵盖。例如，如果我们希望一些用户只能评论而给其他人创建帖子的权限呢？此外，我们的登录系统没有实现`记住我`功能。为了覆盖这些功能，我们将重构我们的应用程序，使用名为**Flask登录**的Flask扩展，而不是直接使用会话。
- en: Flask Login
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask登录
- en: 'To start using Flask Login, it needs to be downloaded first:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Flask登录，首先需要下载它：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The main Flask Login object is the `LoginManager` object. Like the other Flask
    extensions, initialize the `LoginManager` object in `extensions.py`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的Flask登录对象是`LoginManager`对象。像其他Flask扩展一样，在`extensions.py`中初始化`LoginManager`对象：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There are some configuration options that need to be changed on the object:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些需要在对象上更改的配置选项：
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding configuration values define which view should be treated as the
    login page and what the message to the user while logging in should look like.
    Setting the option `session_protection` to `strong` better protects against malicious
    users tampering with their cookies. When a tampered cookie is identified, the
    session object for that user is deleted and the user is forced to log back in.
    The `load_user` function takes an id and returns the `User` object. It's for Flask
    Login to check whether an id identifies the correct user object.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置值定义了哪个视图应该被视为登录页面，以及用户在登录时应该看到什么样的消息。将选项`session_protection`设置为`strong`可以更好地防止恶意用户篡改他们的cookie。当检测到篡改的cookie时，该用户的会话对象将被删除，并强制用户重新登录。`load_user`函数接受一个id并返回`User`对象。这是为了让Flask
    Login检查id是否标识了正确的用户对象。
- en: The `User` model needs to be updated to include some methods for Flask Login.
    First is `is_authenticated` to check whether the `User` object has been logged
    in. Next is `is_active,` which checks whether the user has gone through some sort
    of activation process, such as an e-mail confirmation. Otherwise, it allows site
    administrators to ban a user without deleting their data. Then, `is_anonymous`
    checks whether this user is anonymous and not logged in. Finally, a `get_id` function
    returns a unique `unicode` identifier for that `User` object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`模型需要更新，包括一些用于Flask Login的方法。首先是`is_authenticated`，用于检查`User`对象是否已登录。接下来是`is_active`，用于检查用户是否已经通过某种激活过程，比如电子邮件确认。否则，它允许网站管理员封禁用户而不删除他们的数据。然后，`is_anonymous`用于检查这个用户是否是匿名用户且未登录。最后，`get_id`函数返回该`User`对象的唯一`unicode`标识符。'
- en: 'This app will use a simple implementation for this functionality:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序将使用一个简单的实现方式：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In Flask Login, every user on the site inherits from some user object. By default,
    they inherit an `AnonymousUserMixin` object. If your site needs some functionality
    with anonymous users, you can create a class that inherits from `AnonymousUserMixin`
    and set it as the default user class with the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flask Login中，站点上的每个用户都继承自某个用户对象。默认情况下，它们继承自`AnonymousUserMixin`对象。如果您的站点需要一些匿名用户的功能，可以创建一个从`AnonymousUserMixin`继承的类，并将其设置为默认用户类，如下所示：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To better understand the concept of **mixins**, visit [https://en.wikipedia.org/wiki/Mixin](https://en.wikipedia.org/wiki/Mixin).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地理解**混入**的概念，请访问[https://en.wikipedia.org/wiki/Mixin](https://en.wikipedia.org/wiki/Mixin)。
- en: 'To log in a user with Flask Login, use:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Flask Login登录用户，使用：
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Flask Login then takes care of all of the session handling. To have the user
    be remembered, add `remember=True`, to the `login_user` call. A checkbox can be
    added to the login form to give users the choice:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Flask Login会处理所有的会话处理。要让用户被记住，添加`remember=True`到`login_user`调用中。可以在登录表单中添加复选框，让用户选择：
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the login view, add this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在登录视图中，添加这个：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To log the current user out, use the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要注销当前用户，使用以下命令：
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To protect a view from unauthorized users and send them to the login page,
    add the `login_required` decorator as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要保护视图不被未经授权的用户访问并将他们发送到登录页面，需要添加`login_required`装饰器如下：
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Flask Login also provides a proxy to the logged in user with `current_user`.
    This proxy is available in views and templates alike. So, in our blog controller,
    the custom `before_request` handler can be deleted, and our calls to `g.current_user`
    should be replaced with `current_user`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Flask Login还提供了一个代理，用于表示已登录用户的`current_user`。这个代理在视图和模板中都可用。因此，在我们的博客控制器中，可以删除自定义的`before_request`处理程序，并且我们对`g.current_user`的调用应该替换为`current_user`。
- en: 'Now, with Flask Login, our app''s login system is more Pythonic and secure.
    There is one last feature to implement: user roles and permissions.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用Flask Login，我们应用程序的登录系统更加符合Python的风格和安全。还有一个最后的功能要实现：用户角色和权限。
- en: User roles
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户角色
- en: To add user permissions to our application, our `User` model will need a many-to-many
    relationship to a `Role` object, and it will need another Flask extension named
    **Flask Principal**.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要向我们的应用程序添加用户权限，我们的`User`模型将需要与`Role`对象的多对多关系，并且还需要另一个名为**Flask Principal**的Flask扩展。
- en: 'With our code from [Chapter 2](ch02.html "Chapter 2. Creating Models with SQLAlchemy"),
    *Creating Models with SQLAlchemy*, adding a many-to-many relationship to the `User`
    object is easy:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们从[第2章](ch02.html "第2章. 使用SQLAlchemy创建模型")中的代码，*使用SQLAlchemy创建模型*，向`User`对象添加一个多对多的关系很容易：
- en: '[PRE47]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'From the command line, populate the roles table with three roles: admin, poster,
    and default. These will act as the main permissions for Flask Principal.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行中，使用以下命令填充角色表格，包括三个角色：admin，poster和default。这些将作为Flask Principal的主要权限。
- en: Flask Principal works around the idea of an identity. Something in the application,
    a `User` object in our case, has an identity associated with it. The identity
    provides `Need` objects, which at their core are just named tuples. `Needs` define
    what the identity can do. Permissions are initialized with `Need`, and they define
    what `Need` objects a resource needs to be accessed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Flask Principal围绕着身份的概念展开。应用程序中的某个东西，在我们的例子中是一个`User`对象，与之关联了一个身份。身份提供`Need`对象，它们本质上只是命名元组。`Needs`定义了身份可以做什么。权限是用`Need`初始化的，并且它们定义了资源需要访问的`Need`对象。
- en: 'Flask Principal provides two convenient `Need` objects: `UserNeed` and `RoleNeed`,
    which are exactly what is needed for our app. In `extensions.py`, Flask Principal
    will be initialized and our `RoleNeed` objects will be created:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Flask Principal提供了两个方便的`Need`对象：`UserNeed`和`RoleNeed`，这正是我们应用程序所需要的。在`extensions.py`中，Flask
    Principal将被初始化，并且我们的`RoleNeed`对象将被创建：
- en: '[PRE48]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Flask Principal requires a function that adds `Need` objects to it after the
    identity has changed. Because this function requires access to the `app` object,
    this function will reside in the `__init__.py` file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Flask Principal需要一个函数，在身份发生变化后向其中添加`Need`对象。因为这个函数需要访问`app`对象，所以这个函数将驻留在`__init__.py`文件中：
- en: '[PRE49]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now when the identity is changed, it will add a `UserNeed` and all of the `RoleNeed`
    objects as well. The identity changes when the user logs in or logs out:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当身份发生变化时，它将添加一个`UserNeed`和所有的`RoleNeed`对象。当用户登录或注销时，身份发生变化：
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When the user logs in, their identity will trigger the `on_identity_loaded`
    method, and set their `Need` objects up. Now if we had a page that we wanted only
    posters to have access to:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登录时，他们的身份将触发“on_identity_loaded”方法，并设置他们的“Need”对象。现在，如果我们有一个页面，我们只想让发布者访问：
- en: '[PRE51]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We could also replace our user check in the same view with a `UserNeed` check
    as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在同一个视图中用“UserNeed”检查替换我们的用户检查，如下所示：
- en: '[PRE52]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Visit the documentation of Flask Principal at [https://pythonhosted.org/Flask-Principal/](https://pythonhosted.org/Flask-Principal/)
    to understand how to create much more complex `Need` objects.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://pythonhosted.org/Flask-Principal/](https://pythonhosted.org/Flask-Principal/)上的Flask
    Principal文档，了解如何创建更复杂的“Need”对象。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Our users now have secure logins, multiple login and registration options, and
    explicit access permissions. Our app has everything that is needed to be a full-fledged
    blog app. In the next chapter, the book will stop following this example application
    in order to introduce a technology called **NoSQL**.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户现在拥有安全登录、多重登录和注册选项，以及明确的访问权限。我们的应用程序具备成为一个完整的博客应用程序所需的一切。在下一章中，本书将停止跟随这个示例应用程序，以介绍一种名为**NoSQL**的技术。
