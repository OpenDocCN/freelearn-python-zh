- en: Chapter 10. Other Testing Tools and Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。其他测试工具和技术
- en: '*We''ve covered the core elements of testing in Python, but there are a number
    of peripheral methods and tools that will make your life easier. In this chapter,
    we''ll go over several of them in brief.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们已经涵盖了Python测试的核心元素，但还有一些外围方法和工具可以使你的生活更轻松。在本章中，我们将简要介绍其中的一些。*'
- en: 'In this chapter, we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Discuss code coverage, and learn about `coverage.py`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论代码覆盖率，并了解`coverage.py`
- en: Discuss continuous integration, and learn about buildbot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论持续集成，并了解buildbot
- en: Learn how to integrate automated testing into popular version control systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何将自动化测试集成到流行的版本控制系统
- en: So let's get on with it!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们继续吧！
- en: Code coverage
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: Tests tell you when the code you're testing doesn't work the way you thought
    it would, but they don't tell you a thing about the code that you're not testing.
    They don't even tell you that the code you're not testing isn't being tested.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 测试告诉你当你测试的代码没有按预期工作时的信息，但它们不会告诉你关于你未测试的代码的任何信息。它们甚至不会告诉你你未测试的代码没有被测试。
- en: Code coverage is a technique, which can be used to address that shortcoming.
    A code coverage tool watches while your tests are running, and keeps track of
    which lines of code are (and aren't) executed. After the tests have run, the tool
    will give you a report describing how well your tests cover the whole body of
    code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是一种技术，可以用来解决这一不足。代码覆盖率工具在测试运行时进行监控，并跟踪哪些代码行被（和没有被）执行。测试运行完毕后，该工具将给出一份报告，描述你的测试如何覆盖整个代码库。
- en: It's desirable to have the coverage approach 100%, as you probably figured out
    already. Be careful not to focus on the coverage number too intensely though,
    it can be a bit misleading. Even if your tests execute every line of code in the
    program, they can easily not test everything that needs to be tested. That means
    you can't take 100% coverage as certain proof that your tests are complete. On
    the other hand, there are times when some code really, truly doesn't need to be
    covered by the tests—some debugging support code, for example—and so less than
    100% coverage can be completely acceptable.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经想到的，希望覆盖率接近100%。但请注意，不要过于关注覆盖率数字，它可能会有些误导。即使你的测试执行了程序中的每一行代码，它们也可能没有测试到需要测试的所有内容。这意味着你不能将100%的覆盖率作为测试完整的确定性证据。另一方面，有时某些代码确实不需要被测试覆盖——例如一些调试支持代码——因此低于100%的覆盖率可能是完全可接受的。
- en: Code coverage is a tool to give you insight into what your tests are doing,
    and what they may be overlooking. It's not the definition of a good test suite.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是一个工具，可以帮助你了解你的测试正在做什么，以及它们可能忽略什么。它并不是良好测试套件的定义。
- en: coverage.py
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: coverage.py
- en: We're going to be working with a module called `coverage.py`, which is—unsurprisingly—a
    code coverage tool for Python.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为`coverage.py`的模块，这并不令人惊讶，它是一个Python的代码覆盖率工具。
- en: 'Since `coverage.py` isn''t built in to Python, we''ll need to download and
    install it. You can download the latest version from the Python Package Index
    at [http://pypi.python.org/pypi/coverage](http://pypi.python.org/pypi/coverage).
    As before, users of Python 2.6 or later can install the package by unpacking the
    archive, changing to the directory, and typing:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`coverage.py`不是Python内置的，我们需要下载并安装它。你可以从Python包索引[http://pypi.python.org/pypi/coverage](http://pypi.python.org/pypi/coverage)下载最新版本。与之前一样，Python
    2.6或更高版本的用户可以通过解压存档、切换到目录并键入以下命令来安装该包：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Users of older versions of Python need write permission to the system-wide
    `site-packages` directory, which is part of the Python installation. Anybody who
    has such permission can install coverage by typing:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Python旧版本的用户需要具有对系统级`site-packages`目录的写入权限，这是Python安装的一部分。任何拥有此类权限的人都可以通过键入以下命令来安装coverage：
- en: '`$ python setup.py install`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ python setup.py install`'
- en: At the time of this writing, Windows users also had the option of downloading
    a Windows installer file from the Python Package Index and running it to install
    `coverage.py`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Windows用户还可以从Python包索引下载Windows安装程序文件，并运行它来安装`coverage.py`。
- en: We'll walk through the steps of using `coverage.py` here, but if you want more
    information you can find it on the `coverage.py` home page at [http://nedbatchelder.com/code/coverage/](http://nedbatchelder.com/code/coverage/).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里介绍使用`coverage.py`的步骤，但如果你需要更多信息，可以在`coverage.py`的主页[http://nedbatchelder.com/code/coverage/](http://nedbatchelder.com/code/coverage/)上找到。
- en: Time for action – using coverage.py
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候使用coverage.py了
- en: We'll create a little `toy` code module with tests, and then apply `coverage.py`
    to find out how much of the code the tests actually use.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个包含测试的`toy`代码模块，然后应用`coverage.py`来找出测试实际上使用了多少代码。
- en: Place the following test code into `test_toy.py`. There are several problems
    with these tests, which we'll discuss later, but they ought to run.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试代码放入`test_toy.py`。这些测试有几个问题，我们稍后会讨论，但它们应该能运行。
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Put the following code into `toy.py`. Notice the `if __name__ == '__main__'`
    clause at the bottom. We haven't dealt with one of those in a while, so I'll remind
    you that the code inside that block runs doctest if we were to run the module
    with `python toy.py`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码放入`toy.py`。注意底部的`if __name__ == '__main__'`子句。我们已经有一段时间没有处理这样的子句了，所以我将提醒你，如果我们用`python
    toy.py`运行模块，该块内的代码将运行doctest。
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Go ahead and run Nose. It should find them, run them, and report that all is
    well. The problem is, some of the code isn't ever tested.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续运行Nose。它应该能找到它们，运行它们，并报告一切正常。问题是，有些代码从未被测试过。
- en: Let's run it again, only this time we'll tell Nose to use `coverage.py` to measure
    coverage while it's running the tests.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次运行它，但这次我们将告诉Nose在运行测试时使用`coverage.py`来测量覆盖率。
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Time for action – using coverage.py](img/8846_10_01.jpg)'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 - 使用coverage.py](img/8846_10_01.jpg)'
- en: '*What just happened?*'
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In step 1, we have a couple of `TestCase` classes with some very basic tests
    in them. These tests wouldn't be much use in a real world situation, but all we
    need them for is to illustrate how the code coverage tool works.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们有两个包含一些非常基础测试的`TestCase`类。这些测试在现实世界中的情况下可能没什么用，但我们只需要它们来展示代码覆盖率工具是如何工作的。
- en: In step 2, we have the code that satisfies the tests from step 1\. Like the
    tests themselves, this code wouldn't be much use, but it serves as an illustration.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们有满足第一步测试的代码。就像测试本身一样，这段代码可能没什么用，但它起到了示范的作用。
- en: 'In step 4, we passed `--with-coverage` and `--cover-erase` as command line
    parameters when we ran Nose. What did they do? Well, `--with-coverage` is pretty
    straightforward: it told Nose to look for `coverage.py` and to use it while the
    tests execute. That''s just what we wanted. The second parameter, `--cover-erase`,
    tells Nose to forget about any coverage information that was acquired during previous
    runs. By default, coverage information is aggregated across all of the uses of
    `coverage.py`. This allows you to run a set of tests using different testing frameworks
    or mechanisms, and then check the cumulative coverage. You still want to erase
    the data from previous test runs at the beginning of that process, though, and
    the `--cover-erase` command line is how you tell Nose to tell `coverage.py` that
    you''re starting anew.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四步中，我们在运行Nose时传递了`--with-coverage`和`--cover-erase`作为命令行参数。它们做了什么？好吧，`--with-coverage`相当直接：它告诉Nose在测试执行时查找`coverage.py`并使用它。这正是我们想要的。第二个参数`--cover-erase`告诉Nose忘记在之前的运行中获取的任何覆盖率信息。默认情况下，覆盖率信息是跨所有`coverage.py`的使用汇总的。这允许你使用不同的测试框架或机制运行一系列测试，然后检查累积覆盖率。然而，你仍然希望在开始这个过程时清除之前测试运行的数据，`--cover-erase`命令行就是告诉Nose告诉`coverage.py`你正在重新开始的方法。
- en: What the coverage report tells us is that 9/12 (in other words, 75%) of the
    executable statements in the toy module were executed during our tests, and that
    the missing lines were line 16 and a lines 19 through 20\. Looking back at our
    code, we see that line 16 is the `__repr__` method. We really should have tested
    that, so the coverage check has revealed a hole in our tests that we should fix.
    Lines 19 and 20 are just code to run doctest, though. They're not something that
    we ought to be using under normal circumstances, so we can just ignore that coverage
    hole.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率报告告诉我们，在玩具模块中，9/12（换句话说，75%）的可执行语句在我们的测试中得到了执行，而缺失的行是第16行和第19到第20行。回顾我们的代码，我们看到第16行是`__repr__`方法。我们真的应该测试那个，所以覆盖率检查揭示了我们的测试中的一个漏洞，我们应该修复它。第19和第20行只是运行doctest的代码。它们不是我们在正常情况下应该使用的东西，所以我们可以忽略那个覆盖率漏洞。
- en: Code coverage can't detect problems with the tests themselves, in most cases.
    In the above test code, the test for the `timestwo` method violates the isolation
    of units and invokes two different methods of `example_class`. Since one of the
    methods is the constructor, this may be acceptable, but the coverage checker isn't
    in a position to even see that there might be a problem. All it saw was more lines
    of code being covered. That's not a problem— it's how a coverage checker ought
    to work— but it's something to keep in mind. Coverage is useful, but high coverage
    doesn't equal good tests.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，代码覆盖率无法检测测试本身的问题。在上面的测试代码中，对`timestwo`方法的测试违反了单元隔离，调用了`example_class`的两个不同方法。由于其中一个方法是构造函数，这可能是可以接受的，但覆盖率检查器甚至无法看到可能存在问题的迹象。它只看到了更多被覆盖的代码行。这不是问题——这正是覆盖率检查器应该工作的方式——但这是需要记住的。覆盖率是有用的，但高覆盖率并不等于好的测试。
- en: Pop quiz – code coverage
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答——代码覆盖率
- en: What does a high coverage percentage mean?
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高覆盖率百分比意味着什么？
- en: If your boss asks you for a quantifiable measure of test quality, will you use
    the coverage percentage?
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的老板要求您提供一个测试质量的量化指标，您会使用覆盖率百分比吗？
- en: What is the most useful information on the coverage report?
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖率报告中最重要的信息是什么？
- en: Have a go hero – checking coverage in earlier chapters
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 勇敢的尝试者——检查前面章节的覆盖率
- en: Go back through the code from earlier chapters and use code coverage to check
    for things that should have been tested, but weren't. Try it on some of your own
    tested code too.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 回过头来查看前面章节的代码，并使用代码覆盖率检查应该被测试但未被测试的事情。也尝试在您自己的测试代码上试试。
- en: Version control hooks
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制钩子
- en: Most version control systems have the ability to run a program that you've written
    in response to various events, as a way of customizing the version control system's
    behavior. These programs are commonly called hooks.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数版本控制系统都有运行您编写的程序的能力，以响应各种事件，作为定制版本控制系统行为的一种方式。这些程序通常被称为钩子。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Version control systems are programs for keeping track of changes to a source
    code tree, even when those changes are made by different people. In a sense, they
    provide an universal undo history and change log for the whole project, going
    all the way back to the moment you started using the version control system. They
    also make it much easier to combine work done by different people into a single,
    unified entity, and to keep track of different editions of the same project.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制系统是跟踪源代码树变更的程序，即使这些变更是由不同的人进行的。从某种意义上说，它们为整个项目提供了一个通用的撤销历史和变更日志，一直追溯到您开始使用版本控制系统的那一刻。它们还使得将不同人完成的工作合并成一个单一、统一实体变得容易得多，并且可以跟踪同一项目的不同版本。
- en: You can do all kinds of things by installing the right hook programs, but we'll
    only focus on one use. We can make the version control program automatically run
    our tests, when we commit a new version of the code to the version control repository.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过安装正确的钩子程序，您可以做各种事情，但我们将只关注一种用途。我们可以让版本控制系统在将代码的新版本提交到版本控制存储库时自动运行我们的测试。
- en: This is a fairly nifty trick, because it makes it difficult for test-breaking
    bugs to get into the repository unnoticed. Somewhat like code coverage, though
    there's potential for trouble if it becomes a matter of policy rather than simply
    being a tool to make your life easier.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当巧妙的技巧，因为它使得测试破坏性错误在不知不觉中进入存储库变得困难。虽然它与代码覆盖率类似，但如果它变成政策问题而不是仅仅作为一个使您生活更轻松的工具，那么就存在潜在的问题。
- en: In most systems, you can write the hooks such that it's impossible to commit
    code that breaks tests. That may sound like a good idea at first, but it's really
    not. One reason for this is that one of the major purposes of a version control
    system is communication between developers, and interfering with that tends to
    be unproductive in the long run. Another reason is that it prevents anybody from
    committing partial solutions to problems, which means that things tend to get
    dumped into the repository in big chunks. Big commits are a problem because they
    make it hard to keep track of what changed, which adds to the confusion. There
    are better ways to make sure you always have a working codebase socked away somewhere,
    such as version control branches.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数系统中，你可以编写钩子，使得无法提交破坏测试的代码。这听起来可能是个好主意，但实际上并不是。其中一个原因是，版本控制系统的主要目的之一是开发者之间的沟通，而干扰这一点在长期来看往往是不
    productive 的。另一个原因是，它阻止任何人提交问题的部分解决方案，这意味着事情往往会以大块的形式被提交到仓库中。大提交是一个问题，因为它们使得跟踪发生了什么变得困难，这增加了混乱。有更好的方法来确保你总是有一个工作代码库保存在某个地方，比如版本控制分支。
- en: Bazaar
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bazaar
- en: B azaar is a distributed version control system, which means that it is capable
    of operating without a central server or master copy of the source code. One consequence
    of the distributed nature of Bazaar is that each user has their own set of hooks,
    which can be added, modified, or removed without involving anyone else. Bazaar
    is available on the Internet at [http://bazaar-vcs.org/](http://bazaar-vcs.org/).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Bazaar 是一个分布式版本控制系统，这意味着它能够在没有中央服务器或源代码主副本的情况下运行。Bazaar 分布式特性的一个后果是，每个用户都有自己的钩子集，可以在不涉及任何其他人的情况下添加、修改或删除。Bazaar
    可在互联网上找到，网址为 [http://bazaar-vcs.org/](http://bazaar-vcs.org/)。
- en: If you don't have Bazaar already installed, and don't plan on using it, you
    can skip this section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装 Bazaar，并且不打算使用它，你可以跳过这一部分。
- en: Time for action – installing Nose as a Bazaar post-commit hook
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 安装 Nose 作为 Bazaar 的后提交钩子
- en: Bazaar hooks go in your `plugins` directory. On Unix-like systems, that's `~/.bazaar/plugins/`,
    while on Windows it's `C:\Documents and Settings\<username>\Application Data\Bazaar\<version>\plugins\`.
    In either case, you may have to create the `plugins` subdirectory, if it doesn't
    already exist.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bazaar 钩子放在你的 `plugins` 目录中。在类 Unix 系统上，这是 `~/.bazaar/plugins/`，而在 Windows 上是
    `C:\Documents and Settings\<username>\Application Data\Bazaar\<version>\plugins\`。在任一情况下，你可能需要创建
    `plugins` 子目录，如果它尚未存在的话。
- en: 'Place the following code into a file called `run_nose.py` in the `plugins`
    directory. Bazaar hooks are written in Python:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码放入 `plugins` 目录下的一个名为 `run_nose.py` 的文件中。Bazaar 钩子是用 Python 编写的：
- en: '[PRE4]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Make a new directory in your working files, and put the following code into
    it in a file called `test_simple.py`. These simple (and silly) tests are just
    to give Nose something to do, so that we can see that the hook is working.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的工作文件中创建一个新的目录，并将以下代码放入该目录下，文件名为 `test_simple.py`。这些简单的（而且有些愚蠢的）测试只是为了给 Nose
    些事情做，这样我们就可以看到钩子是否在正常工作。
- en: '[PRE5]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Still in the same directory as `test_simple.py`, run the following commands
    to create a new repository and commit the tests to it. The output you see might
    differ in details, but it should be quite similar overall.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `test_simple.py` 所在的目录下，运行以下命令以创建一个新的仓库并将测试提交到其中。你看到的输出可能细节上有所不同，但总体上应该是相当相似的。
- en: '[PRE6]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Time for action – installing Nose as a Bazaar post-commit hook](img/8846_10_02.jpg)'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 - 安装 Nose 作为 Bazaar 的后提交钩子](img/8846_10_02.jpg)'
- en: Notice that there's a Nose test report after the commit notification. From now
    on, any time you commit to a Bazaar repository, Nose will search for and run whatever
    tests it can find within that repository.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在提交通知之后会有一个 Nose 测试报告。从现在开始，每次你向 Bazaar 仓库提交时，Nose 都会搜索并运行该仓库内能找到的任何测试。
- en: '*What just happened?*'
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Bazaar hooks are written in Python, so we've written our hook as a function
    called `run_nose`. Our `run_nose` function checks to make sure that the repository
    which we're working on is local, and then it changes directories into the repository
    and runs nose. We registered `run_nose` as a hook by calling `branch.Branch.hooks.install_named_hook`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Bazaar 的钩子是用 Python 编写的，因此我们编写了一个名为 `run_nose` 的函数作为钩子。我们的 `run_nose` 函数会检查我们正在工作的仓库是否是本地的，然后它会切换到仓库目录并运行
    nose。我们通过调用 `branch.Branch.hooks.install_named_hook` 将 `run_nose` 注册为一个钩子。
- en: Mercurial
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mercurial
- en: Like Bazaar, Mercurial is a distributed version control system, with hooks that
    are managed by each user individually. Mercurial's hooks themselves, though, take
    a rather different form. You can find Mercurial on the web at [http://www.selenic.com/mercurial/](http://www.selenic.com/mercurial/).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 Bazaar，Mercurial 也是一个分布式版本控制系统，其钩子由每个用户单独管理。然而，Mercurial 的钩子本身采取了相当不同的形式。你可以在网上找到
    Mercurial，网址为 [http://www.selenic.com/mercurial/](http://www.selenic.com/mercurial/).
- en: If you don't have Mercurial installed and don't plan to use it, you can skip
    this section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有安装 Mercurial，并且不打算使用它，你可以跳过这一部分。
- en: Mercurial hooks can go in several different places. The two most useful are
    in your personal configuration file and in your repository configuration file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Mercurial 钩子可以放在几个不同的地方。最有用的是你的个人配置文件和你的存储库配置文件。
- en: Your personal configuration file is `~/.hgrc` on Unix-like systems, and `%USERPROFILE%\Mercurial.ini`
    (which usually means `c:\Documents and Settings\<username>\Mercurial.ini`) on
    Windows-based systems.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你的个人配置文件在类 Unix 系统上是 `~/.hgrc`，在基于 Windows 的系统上是 `%USERPROFILE%\Mercurial.ini`（通常意味着
    `c:\Documents and Settings\<username>\Mercurial.ini`）。
- en: Your repository configuration file is stored in a subdirectory of the repository,
    specifically `.hg/hgrc`, on all systems.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你的存储库配置文件存储在存储库的子目录中，具体为所有系统上的 `.hg/hgrc`。
- en: Time for action – installing Nose as a Mercurial post-commit hook
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 将 Nose 作为 Mercurial post-commit 钩子安装
- en: 'We''ll use the repository configuration file to store the hook, which means
    that the first thing we have to do is have a repository to work with. Make a new
    directory at a convenient place and execute the following command in it:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用存储库配置文件来存储钩子，这意味着我们首先要做的是拥有一个可以工作的存储库。在方便的地方创建一个新的目录，并在其中执行以下命令：
- en: '[PRE7]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'One side-effect of that command is that a `.hg` subdirectory got created. Change
    to that directory, and then create a text file called `hgrc` containing the following
    text:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该命令的一个副作用是创建了一个 `.hg` 子目录。切换到该目录，然后创建一个名为 `hgrc` 的文本文件，包含以下文本：
- en: '[PRE8]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Back in the repository directory (i.e. the parent of the `.hg` directory),
    we need some tests for Nose to run. Create a file called `test_simple.py` containing
    the following (admittedly silly) tests:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到存储库目录（即 `.hg` 目录的父目录），我们需要为 Nose 运行一些测试。创建一个名为 `test_simple.py` 的文件，包含以下（诚然有些愚蠢）的测试：
- en: '[PRE9]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the following commands to add the test file and commit it to the repository:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以添加测试文件并将其提交到存储库：
- en: '[PRE10]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Time for action – installing Nose as a Mercurial post-commit hook](img/8846_10_03.jpg)'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 – 将 Nose 作为 Mercurial post-commit 钩子安装](img/8846_10_03.jpg)'
- en: Notice that the commit triggered a run-through of the tests. Since we put the
    hook in the repository configuration file, it will only take effect on commits
    to this repository. If we'd instead put it into your personal configuration file,
    it would be called when you committed to *any* repository.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到提交触发了测试的运行。由于我们将钩子放入了存储库配置文件，它只会在提交到这个存储库时生效。如果我们将其放入你的个人配置文件，它将在你提交到 *任何*
    存储库时被调用。
- en: '*What just happened?*'
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: Mercurial's hooks are commands, just like you would enter into your operating
    systems command shell (also known as a DOS prompt on Windows). We just had to
    edit Mercurial's configuration file and tell it which command to run. Since we
    wanted it to run our Nose test suite when we commit, we set the commit hook to
    `nosetests`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Mercurial 的钩子是命令，就像你会在你的操作系统命令壳（在 Windows 上也称为 DOS 提示符）中输入的命令一样。我们只需编辑 Mercurial
    的配置文件，并告诉它要运行哪个命令。由于我们希望它在提交时运行我们的 Nose 测试套件，我们将提交钩子设置为 `nosetests`。
- en: Git
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git
- en: Git is a distributed version control system. Similar to Bazaar and Mercurial,
    it allows every user to control their own hooks, without involving other developers
    or server administrators.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Git 是一个分布式版本控制系统。类似于 Bazaar 和 Mercurial，它允许每个用户控制自己的钩子，而不涉及其他开发者或服务器管理员。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Git hooks are stored in the `.git/hooks/` subdirectory of the repository, each
    in its own file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Git 钩子存储在存储库的 `.git/hooks/` 子目录中，每个钩子都有自己的文件。
- en: If you don't have Git installed, and don't plan to use it, you can skip this
    section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有安装 Git，并且不打算使用它，你可以跳过这一部分。
- en: Time for action – installing Nose as a Git post-commit hook
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 将 Nose 作为 Git post-commit 钩子安装
- en: 'The hooks are stored in a subdirectory of a Git repository, so the first thing
    that we need to do is initialize a repository. Make a new directory for the Git
    repository and execute the following command inside of it:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 钩子存储在Git仓库的子目录中，因此我们首先需要做的事情是初始化一个仓库。为Git仓库创建一个新的目录，并在其中执行以下命令：
- en: '[PRE11]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Git hooks are executable programs, so they can be written in any language. To
    run Nose, it makes sense to use a shell script (on Unix-like systems) or batch
    file (on Windows) for the hook. If you're using a Unix-like system, place the
    following two lines into a file called post-commit in the `.git/hooks/` subdirectory,
    and then use the `chmod +x post-commit` command to make it executable.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Git钩子是可执行程序，因此可以用任何语言编写。要运行Nose，使用shell脚本（在类Unix系统中）或批处理文件（在Windows中）作为钩子是有意义的。如果你使用的是类Unix系统，将以下两行放入`.git/hooks/`子目录中的名为`post-commit`的文件中，然后使用`chmod
    +x post-commit`命令使其可执行。
- en: '[PRE12]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you're using a Windows system, place the following lines inside a file called
    `post-commit.bat` in the `.git\hooks\` subdirectory.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用的是Windows系统，将以下行放入`.git\hooks\`子目录中名为`post-commit.bat`的文件中。
- en: '[PRE13]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We need to put some test code in the repository directory (that is, the parent
    of the `.git` directory), so that Nose has something to do. Place the following
    (useless) code into a file called `test_simple.py`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在仓库目录中放置一些测试代码（即`.git`目录的父目录），这样Nose才有事情可做。将以下（无用的）代码放入一个名为`test_simple.py`的文件中：
- en: '[PRE14]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the following commands to add the test file and commit it to the repository:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令将测试文件添加并提交到仓库中：
- en: '[PRE15]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Time for action – installing Nose as a Git post-commit hook](img/8846_10_04.jpg)'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 – 将Nose作为Git后提交钩子安装](img/8846_10_04.jpg)'
- en: Notice that the commit triggered an execution of Nose and printed out the test
    results.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，这次提交触发了Nose的执行并打印出了测试结果。
- en: Because each repository has its own hooks, only the repositories that were specifically
    configured to run Nose will do so.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为每个仓库都有自己的钩子，只有那些特别配置为运行Nose的仓库才会这样做。
- en: '*What just happened?*'
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Git finds its hooks by looking for programs with specific names, so we could
    have used any programming language to write our hook, as long as we could give
    the program the right name. However, all that we want is to run the `nosetests`
    command, so that we can use a simple shell script or batch file. All this simple
    program does is invoke the `nosetests` program, and then terminate.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Git通过查找具有特定名称的程序来查找其钩子，因此我们可以用任何编程语言编写我们的钩子，只要我们能给程序正确的名称。然而，我们只想运行`nosetests`命令，因此我们可以使用简单的shell脚本或批处理文件。这个简单的程序所做的只是调用`nosetests`程序，然后终止。
- en: Darcs
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Darcs
- en: Darcs is a distributed version control system. Each user has control over their
    own set of hooks.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Darcs是一个分布式版本控制系统。每个用户都控制着自己的钩子集。
- en: If you don't have Darcs installed, and you don't plan to use it, you can skip
    this section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有安装Darcs，并且你也不打算使用它，你可以跳过这一部分。
- en: Time for action – installing Nose as a Darcs post-record hook
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 将Nose作为Darcs后记录钩子安装
- en: 'Each local repository has its own set of hooks, so the first thing we need
    to do is create a repository. Make a directory to work in, and execute the following
    command in it:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个本地仓库都有自己的钩子集，因此我们首先需要做的事情是创建一个仓库。创建一个工作目录，并在其中执行以下命令：
- en: '[PRE16]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We need to put some test code in the repository directory so that Nose has something
    to do. Place the following (useless) code into a file called `test_simple.py`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在仓库目录中放置一些测试代码，这样Nose才有事情可做。将以下（无用的）代码放入一个名为`test_simple.py`的文件中。
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the following command to add the test file to the repository:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令将测试文件添加到仓库中：
- en: '[PRE18]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Darcs hooks are identified using command line options. In this case, we want
    to run `nosetests` after we tell Darcs to record changes, so we use the following
    command:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Darcs钩子使用命令行选项进行标识。在这种情况下，我们想在告诉Darcs记录更改后运行`nosetests`，所以我们使用以下命令：
- en: '[PRE19]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Time for action – installing Nose as a Darcs post-record hook](img/8846_10_05.jpg)'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 – 将Nose作为Darcs后记录钩子安装](img/8846_10_05.jpg)'
- en: Notice that Darcs ran our test suite once it was done recording the changes,
    and reported the results to us.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，Darcs在完成记录更改后运行了我们的测试套件，并将结果报告给了我们。
- en: 'That''s well and good, but Darcs doesn''t remember that we want `nosetests`
    to be a post-record hook. As far as it''s concerned, that was a one-time deal.
    Fortunately, we can tell it otherwise. Create a file called `defaults` in the
    `_darcs/prefs/` subdirectory, and place the following text into it:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然如此，但 Darcs 并没有记住我们想要 `nosetests` 成为记录后的钩子。就它而言，那是一次性的交易。幸运的是，我们可以告诉它不同。在 `_darcs/prefs/`
    子目录中创建一个名为 `defaults` 的文件，并将以下文本放入其中：
- en: '[PRE20]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now if we change the code and record again, `nosetests` should run without
    us specifically asking for it. Make the following change to `test_simple.py`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在如果我们更改代码并再次记录，`nosetests` 应该会自动运行，而无需我们特别请求。请对 `test_simple.py` 文件进行以下更改：
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the following command to record the change and run the tests:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以记录更改并运行测试：
- en: '[PRE22]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![Time for action – installing Nose as a Darcs post-record hook](img/8846_10_06.jpg)'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![执行动作时间 - 安装 Nose 作为 Darcs 后记录钩子](img/8846_10_06.jpg)'
- en: If you want to skip the tests for a commit, you can pass the `--no-posthook`
    command line option when you record your changes.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想跳过提交的测试，可以在记录更改时传递 `--no-posthook` 命令行选项。
- en: '*What just happened?*'
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Darcs hooks are specified as command line options, so when we issue the `record`
    command we need to specify a program to run as a hook. Since we don't want to
    do that manually every time we record changes, we make use of Darcs' ability to
    accept additional command line options in its configuration file. This allows
    us to make running `nosetests` as a hook into the default behavior.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Darcs 钩子指定为命令行选项，因此当我们发出 `record` 命令时，我们需要指定一个作为钩子运行的程序。由于我们不希望在每次记录更改时都手动执行，我们利用
    Darcs 在其配置文件中接受额外命令行选项的能力。这使得将运行 `nosetests` 作为钩子变为默认行为。
- en: Subversion
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Subversion
- en: Unlike the other version control systems that we've discussed, Subversion is
    a centralized one. There is a single server tasked with keeping track of everybody's
    changes, which also handles running hooks. This means that there is a single set
    of hooks that applies to everybody, probably under control of a system administrator.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们讨论过的其他版本控制系统不同，Subversion 是一个集中式的系统。有一个单独的服务器负责跟踪每个人的更改，同时也处理运行钩子。这意味着有一个适用于所有人的单一套钩子，可能由系统管理员控制。
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Subversion hooks are stored in files in the `hooks/` subdirectory of the server's
    repository.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Subversion 钩子存储在服务器仓库的 `hooks/` 子目录中的文件中。
- en: If you don't have Subversion and don't plan on using it, you can skip this section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有 Subversion 并且不打算使用它，可以跳过这一部分。
- en: Time for action – installing Nose as a Subversion post-commit hook
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行动作时间 - 安装 Nose 作为 Subversion 后提交钩子
- en: Because Subversion operates on an centralized, client-server architecture, we'll
    need both the client and server set up for this example. They can both be on the
    same computer, but they'll need to be in different directories.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Subversion 在集中式客户端-服务器架构上运行，因此我们需要为这个示例设置客户端和服务器。它们可以位于同一台计算机上，但它们需要位于不同的目录中。
- en: 'First we need a server. You can create one by making a new directory called
    `svnrepo` and executing the following command:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一个服务器。你可以通过创建一个名为 `svnrepo` 的新目录并执行以下命令来创建一个：
- en: '[PRE23]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we need to configure the server to accept commits from us. To do this,
    we open up the file called `conf/passwd` and add the following line at the bottom:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要配置服务器以接受我们的提交。为此，我们打开名为 `conf/passwd` 的文件，并在底部添加以下行：
- en: '[PRE24]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then we need to edit `conf/svnserve.conf`, and change the line reading `# password-db
    = passwd` to `password-db = passwd`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要编辑 `conf/svnserve.conf` 文件，并将读取 `# password-db = passwd` 的行更改为 `password-db
    = passwd`。
- en: 'The Subversion server needs to be running, before we can interact with it.
    This is done by making sure that we''re in the `svnrepo` directory and then running
    the following command:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们能够与之交互之前，Subversion 服务器需要运行。这是通过确保我们位于 `svnrepo` 目录中，然后运行以下命令来完成的：
- en: '[PRE25]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next we need to import some test code into the Subversion repository. Make
    a directory and place the following (simple and silly) code into it in a file
    called `test_simple.py`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将一些测试代码导入到 Subversion 仓库中。创建一个目录，并在其中创建一个名为 `test_simple.py` 的文件，并将以下（简单而愚蠢）的代码放入其中：
- en: '[PRE26]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can perform the import by executing:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以通过执行以下命令来执行导入：
- en: '[PRE27]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That command is likely to print out a gigantic, scary message about remembering
    passwords. In spite of the warnings, just say `yes`.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该命令可能会打印出一个巨大、令人恐惧的消息，关于记住密码。尽管有警告，但只需说“是”。
- en: 'Now that we''ve got the code imported, we need to check out a copy of it to
    work on. We can do this with the following command:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经导入代码，我们需要检出它的一个副本来工作。我们可以使用以下命令来完成：
- en: '[PRE28]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: From here on in this example, we'll assume that the Subversion server is running
    in a Unix-like environment (the clients might be running on Windows, we don't
    care). The reason for this, is that the details of the post-commit hook are significantly
    different on systems that don't have a Unix style shell scripting language, although
    the concepts remain the same.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从现在起，在这个示例中，我们将假设 Subversion 服务器正在 Unix-like 环境中运行（客户端可能运行在 Windows 上，我们不在乎）。这样做的原因是，在那些没有
    Unix 风格的 shell 脚本语言的系统上，post-commit 钩子的细节有显著不同，尽管概念保持不变。
- en: The following code goes into a file called `hooks/post-commit` inside the subversion
    server's repository. (The `svn update` and `svn checkout` lines have been wrapped
    around to fit on the page. In actual use, this wrapping should not be present.)
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码将放入 subversion 服务器仓库中的 `hooks/post-commit` 文件。(`svn update` 和 `svn checkout`
    行已被包装以适应页面。在实际使用中，这种包装不应存在。)
- en: '[PRE29]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Use the `chmod +x post-commit` command to make the hook executable.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `chmod +x post-commit` 命令使钩子可执行。
- en: Change to the `svn` directory created by the checkout in step 5, and edit `test_simple.py`
    to make one of the tests fail. We do this because if the tests all pass, Subversion
    won't show us anything to indicate that they were run at all. We only get feedback
    if they fail.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到步骤 5 中创建的 `svn` 目录，并编辑 `test_simple.py` 使其中一个测试失败。我们这样做是因为如果所有测试都通过，Subversion
    不会显示任何信息来表明它们已经运行。只有在它们失败时我们才会得到反馈。
- en: '[PRE30]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now commit the changes using the following command:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在请使用以下命令提交更改：
- en: '[PRE31]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![Time for action – installing Nose as a Subversion post-commit hook](img/8846_10_07.jpg)'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![执行时间 – 将 Nose 作为 Subversion 提交后钩子安装](img/8846_10_07.jpg)'
- en: Notice that the commit triggered the execution of Nose, and that if any of the
    tests fail, Subversion shows us the errors.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到提交触发了 Nose 的执行，并且如果任何测试失败，Subversion 会显示错误。
- en: Because Subversion has one central set of hooks, they apply automatically to
    anybody who uses the repository.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Subversion 只有一套中央钩子，所以它们会自动应用于使用仓库的任何人。
- en: '*What just happened?*'
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Subversion hooks are run on the server. Subversion locates its hooks by looking
    for programs with specific names, so we needed to create a program called `post-commit`
    to be the post-commit hook. We could have used any programming language to write
    the hook, as long as the program had the right name, but we chose to use shell
    scripting language, for simplicity's sake.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Subversion 钩子在服务器上运行。Subversion 通过查找具有特定名称的程序来定位其钩子，因此我们需要创建一个名为 `post-commit`
    的程序作为 post-commit 钩子。我们可以使用任何编程语言来编写钩子，只要程序有正确的名称即可，但我们选择使用 shell 脚本语言，以简化操作。
- en: Pop quiz – version control hooks
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答 – 版本控制钩子
- en: In what ways can hooking your automated tests into your version control system
    help you?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的自动化测试钩入版本控制系统有哪些方式可以帮助你？
- en: What are a couple of the things you could do with version control hooks, but
    shouldn't?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以用版本控制钩子做哪些事情，但又不应该做？
- en: What is the biggest difference between hooks in distributed version control
    systems, and hooks in centralized version control systems?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分布式版本控制系统中的钩子和集中式版本控制系统中的钩子之间最大的区别是什么？
- en: Automated continuous integration
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化持续集成
- en: Automated continuous integration tools are a step beyond using a version control
    hook to run your tests when you commit code to the repository. Instead of running
    your test suite once, an automated continuous integration system compiles your
    code (if need be) and runs your tests many times, in many different environments.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化持续集成工具是在使用版本控制钩子将测试运行在提交代码到仓库时之上的一步。而不是运行一次测试套件，自动化持续集成系统会编译你的代码（如果需要的话）并在许多不同的环境中多次运行你的测试。
- en: An automated continuous integration system might, for example, run your tests
    under Python versions 2.4, 2.5, and 2.6 on each of Windows, Linux, and Mac OS
    X. This not only lets you know about errors in your code, but also about unexpected
    problems caused by the external environment. It's nice to know when that last
    patch broke the program on Windows, even though it worked like a charm on your
    Linux box.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个自动化的持续集成系统可能会在 Windows、Linux 和 Mac OS X 的每个系统上运行 Python 2.4、2.5 和 2.6 版本的测试。这不仅让你知道代码中的错误，还能让你知道由外部环境引起的意外问题。知道最后一个补丁在
    Windows 上破坏了程序，尽管在你的 Linux 系统上运行得很好，这很令人欣慰。
- en: Buildbot
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Buildbot
- en: Buildbot is a popular automated continuous integration tool. Using Buildbot,
    you can create a network of 'build slaves' that will check your code each time
    you commit to you commit it to your repository. This network can be quite large,
    and it can be distributed around the Internet, so Buildbot works even for projects
    with lots of developers spread around the world.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Buildbot 是一种流行的自动化持续集成工具。使用 Buildbot，您可以创建一个 'build slaves' 的网络，每次您将代码提交到您的仓库时，它都会检查您的代码。这个网络可以相当大，并且可以分布在整个互联网上，因此
    Buildbot 即使对于分布在世界各地的众多开发者项目也能正常工作。
- en: Buildbot's home page is at [http://buildbot.net/](http://buildbot.net/). Following
    links from that site, you can find the manual and download the latest version
    of the tool. Glossing over details that we've discussed several times before,
    installation requires you to unpack the archive, and then run the commands `python
    setup.py build`, and `python setup.py install --user`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Buildbot 的主页位于 [http://buildbot.net/](http://buildbot.net/)。通过该网站的链接，您可以找到手册并下载工具的最新版本。忽略我们之前讨论过的细节，安装需要您解压存档，然后运行命令
    `python setup.py build` 和 `python setup.py install --user`。
- en: Buildbot operates in one of two modes, termed `buildmaster` and `buildslave`.
    A buildmaster manages a network of buildslaves, while the buildslaves run the
    tests in their assorted environments.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Buildbot 以两种模式之一运行，称为 `buildmaster` 和 `buildslave`。buildmaster 管理一组 buildslaves，而
    buildslaves 在它们各自的环境中运行测试。
- en: Time for action – using Buildbot with Bazaar
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 使用 Buildbot 与 Bazaar
- en: 'To set up a buildmaster, create a directory for it to operate in and then run
    the command:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置 buildmaster，创建一个用于其操作的目录，然后运行以下命令：
- en: '[PRE32]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: where `<directory>` is the directory you just created for buildbot to work in.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中 `<directory>` 是您为 buildbot 工作而创建的目录。
- en: 'Similarly, to set up a buildslave, create a directory for it to operate in
    and then run the command:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，要设置 buildslave，创建一个用于其操作的目录，然后运行以下命令：
- en: '[PRE33]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: where `<directory>` is the directory you just created for the buildbot to work
    in, `<host:port>` are the internet host and port where the buildmaster can be
    found, and `<name>` and `<password>` are the login information that identifies
    this buildslave to the buildmaster. All of this information (except the directory)
    is determined by the operator of the buildmaster.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中 `<directory>` 是您为 buildbot 工作而创建的目录，`<host:port>` 是 buildmaster 可找到的互联网主机和端口，而
    `<name>` 和 `<password>` 是识别此 buildslave 给 buildmaster 的登录信息。所有这些信息（除了目录外）都由 buildmaster
    的操作员确定。
- en: You should edit `<directory>/info/admin` and `<directory>/info/host` to contain
    the email address you want associated with this buildslave and a description of
    the buildslave's operating environment, respectively.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该编辑 `<directory>/info/admin` 和 `<directory>/info/host`，分别包含您希望与该 buildslave
    关联的电子邮件地址和 buildslave 运行环境的描述。
- en: 'On both the buildmaster and the buildslave, you''ll need to start up the buildbot
    background process. To do this, use the command:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 buildmaster 和 buildslave 上，您都需要启动 buildbot 背景进程。为此，请使用以下命令：
- en: '[PRE34]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Configuring a buildmaster is a significant topic in itself (and one that we''
    won''t be addressing in detail). It''s fully described in Buildbot''s own documentation.
    We will provide a simple configuration file, though, for reference and quick setup.
    This particular configuration file assumes that you''re using Bazaar, but it is
    not significantly different for other version control systems. The following goes
    in the master `<directory>/master.cfg` file:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 buildmaster 是一个重要的话题（并且我们不会详细讨论）。它已在 Buildbot 的自身文档中完全描述。不过，我们将提供一个简单的配置文件，供参考和快速设置。这个特定的配置文件假设您正在使用
    Bazaar，但对于其他版本控制系统来说并没有显著差异。以下内容应放入主 `<directory>/master.cfg` 文件中：
- en: '[PRE35]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To make effective use of that Buildbot config, you also need to install a version
    control hook that notifies Buildbot of changes. Generically, this can be done
    by calling the `buildbot sendchange` command from the hook, but there''s a nicer
    way to tie in with Bazaar: copy the `contrib/bzr_buildbot.py` file from the buildbot
    distribution archive into your Bazaar plugins directory, and then edit the `locations.conf`
    file, which you should find right next to the `plugins` directory. Add the following
    entry to `locations.conf`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了有效地使用 Buildbot 配置，您还需要安装一个版本控制钩子，以便通知 Buildbot 发生了更改。通常，这可以通过从钩子调用 `buildbot
    sendchange` 命令来完成，但与 Bazaar 集成有更优雅的方法：将 buildbot 发行存档中的 `contrib/bzr_buildbot.py`
    文件复制到您的 Bazaar 插件目录中，然后编辑 `locations.conf` 文件，您应该可以在 `plugins` 目录旁边找到它。将以下条目添加到
    `locations.conf`：
- en: '[PRE36]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You'll need to add similar entries for each repository that you want to be connected
    to buildbot.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你需要为每个你想连接到 buildbot 的仓库添加类似的条目。
- en: Once you have the buildmaster and buildslaves configured, and have hooked buildbot
    into your version control system, and have started the buildmaster and buildslaves,
    you're in business.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你配置了 buildmaster 和 buildslaves，并将 buildbot 集成到你的版本控制系统，并启动了 buildmaster 和
    buildslaves，你就可以开始工作了。
- en: '*What just happened?*'
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We just set up Buildbot to run our tests, whenever it notices that our source
    code has been unchanged for two hours.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚设置了 Buildbot 来运行我们的测试，每当它注意到我们的源代码两小时没有变化时。
- en: 'We told it to run the tests by adding a build step that runs nosetests:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加一个运行 nosetests 的构建步骤来告诉它运行测试：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We told it to wait for the source code to be unchanged for two hours by adding
    a build scheduler:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加一个构建调度器来告诉它等待源代码两小时不变：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You''ll be able to see a report of the Buildbot status in your web browser,
    by navigating to the `buildbotURL` that you configured in the `master.cfg` file.
    One of the most useful reports is the so-called ''waterfall'' view. If the most
    recent commit passes the tests, you should see something similar to this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在浏览器中导航到你在 `master.cfg` 文件中配置的 `buildbotURL` 来查看 Buildbot 状态的报告。其中最有用的报告之一是所谓的“瀑布”视图。如果最近的提交通过了测试，你应该会看到类似这样的内容：
- en: '![What just happened?](img/8846_10_08.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/8846_10_08.jpg)'
- en: 'On the other hand, when the commit fails to pass the tests, you''ll see something
    more like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当提交未能通过测试时，你会看到更类似于以下的内容：
- en: '![What just happened?](img/8846_10_09.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/8846_10_09.jpg)'
- en: Either way, you'll also see a history of earlier versions, and whether or not
    they passed the tests, as well as who made the changes, when, and what the output
    of the test command looked like.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，你也会看到早期版本的历史记录，以及它们是否通过了测试，以及谁做了更改，何时更改，以及测试命令的输出看起来像什么。
- en: Pop quiz – Buildbot
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验 – Buildbot
- en: What kind of projects benefit most from Buildbot and other such tools?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种项目最能从 Buildbot 和其他此类工具中受益？
- en: When is it better to use Buildbot, as opposed to just running Nose from a version
    control hook?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下使用 Buildbot 比仅仅通过版本控制钩子运行 Nose 更好？
- en: When is it worse?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下更糟？
- en: Aside from running tests, what sort of tasks would Buildbot be useful for?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了运行测试之外，Buildbot 还可以用于哪些任务？
- en: Have a go hero
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来试试英雄
- en: 'This is an open-ended assignment: take what you''ve learned and put it to use.
    Try a small project first (but make it test-driven), with tests integrated into
    your version control system. Once you have an implementation, use code coverage
    to help you have a comprehensive test suite. If it makes sense for your project,
    use Buildbot.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个开放式的任务：将你所学的知识应用到实践中。先尝试一个小项目（但让它成为测试驱动的），将测试集成到你的版本控制系统中。一旦你有了一个实现，使用代码覆盖率来帮助你拥有一个全面的测试套件。如果你的项目适用，可以使用
    Buildbot。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned a lot in this chapter about code coverage and plugging our tests
    into the other automation systems that we use while writing software.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们关于代码覆盖率以及将我们的测试集成到我们在编写软件时使用的其他自动化系统中学到了很多。
- en: 'Specifically, we covered:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了：
- en: What code coverage is, and what it can tell us about our tests
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码覆盖率是什么，以及它能够告诉我们关于测试的什么信息
- en: How to run Nose automatically when our version control software detects changes
    in the source code
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们的版本控制软件检测到源代码有变化时，如何自动运行 Nose
- en: How to set up the Buildbot automated continuous integration system
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置 Buildbot 自动持续集成系统
- en: Now that we've learned about code coverage, version control hooks, and automated
    continuous integration, you're ready to tackle more or less anything. Congratulations!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了代码覆盖率、版本控制钩子和自动化持续集成，你准备好应对更多或更少的事情了。恭喜你！
