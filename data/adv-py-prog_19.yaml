- en: '*Chapter 16*: The Factory Pattern'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第16章*: 工厂模式'
- en: '**Design patterns** are reusable programming solutions that have been used
    in various real-world contexts and have proved to produce the expected results.
    In this chapter, we will learn about one of the most common design patterns: the
    factory design pattern. As we will see later, this pattern makes it easier to
    track which objects are created within a program, thus separating the code that
    creates an object from the code that uses it. We will study the factory design
    pattern''s two forms: the **factory method** and the **abstract method**.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计模式**是可重用的编程解决方案，已在各种实际应用场景中使用，并已被证明能够产生预期的结果。在本章中，我们将学习最常见的设计模式之一：工厂设计模式。正如我们稍后将看到的，这种模式使得跟踪程序中创建的对象变得更加容易，从而将创建对象的代码与使用它的代码分离。我们将研究工厂设计模式的两种形式：**工厂方法**和**抽象方法**。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding design patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解设计模式
- en: Implementing the factory method
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现工厂方法
- en: Applying the abstract factory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用抽象工厂
- en: By the end of this chapter, we will have gained a deep understanding of the
    factory design pattern and its benefits via a hands-on example.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将通过一个实际案例，深入理解工厂设计模式及其益处。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter16](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter16).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter16](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter16)找到。
- en: Understanding design patterns
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解设计模式
- en: 'Design patterns are shared among programmers and continue to be improved over
    time. This topic is popular thanks to the book by Erich Gamma, Richard Helm, Ralph
    Johnson, and John Vlissides, titled *Design Patterns: Elements of Reusable Object-Oriented
    Software*.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式在程序员之间共享，并且随着时间的推移不断得到改进。这个主题之所以受欢迎，得益于Erich Gamma、Richard Helm、Ralph Johnson和John
    Vlissides合著的书籍，书名为《设计模式：可重用面向对象软件元素》。
- en: Gang of Four
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 四人帮
- en: The book by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides is
    also called the *Gang of Four* book for short (or the *GOF* book for an even shorter
    name).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides合著的书籍也简称为*四人帮*书籍（或简称为*GOF*书籍）。
- en: Generally, a design pattern helps the programmer create a commonly used implementation
    pattern, especially in **object-oriented programming** (**OOP**). The benefits
    of viewing applications from the design pattern's perspective are plenty. First,
    it narrows down the most effective ways of building a given application and the
    necessary steps to do it. Second, you could consult existing examples of the same
    design pattern to improve your application. Overall, design patterns are highly
    useful guidelines in software engineering.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，设计模式帮助程序员创建常用的实现模式，尤其是在**面向对象编程**（**OOP**）中。从设计模式的角度看待应用程序的好处很多。首先，它缩小了构建特定应用程序的最有效方法和必要的步骤。其次，你可以参考相同设计模式的现有示例来改进你的应用程序。总的来说，设计模式是软件工程中非常有用的指导方针。
- en: 'There are several categories of design patterns that are used in OOP, depending
    on the type of problem they address and/or the types of solutions they help us
    build. In their book, the *Gang of Four* presents 23 design patterns, split into
    three categories: **creational**, **structural**, and **behavioral**.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们解决的问题类型和/或帮助构建的解决方案类型，在面向对象编程（OOP）中使用了多种设计模式类别。在他们的书中，“四人帮”提出了23种设计模式，分为三个类别：**创建型**、**结构型**和**行为型**。
- en: '`__init__()` function, is not convenient.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()`函数，不太方便。'
- en: Important Note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: See [https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html)
    for a quick overview of object classes and the special `__init__()` method that
    Python uses to initialize a new class instance.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解对象类和Python用于初始化新类实例的特殊`__init__()`方法的快速概述，请参阅[https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html)。
- en: 'We will start with the first creational design pattern from the *Gang of Four*
    book: the **factory design pattern**. In the factory design pattern, a **client**
    (meaning client code) asks for an object without knowing where the object is coming
    from (that is, which class is used to generate it). The idea behind a factory
    is to simplify the object creation process. It is easier to track which objects
    are created if this is done through a central function, compared to letting a
    client create objects using a direct class instantiation. A factory reduces the
    complexity of maintaining an application by decoupling the code that creates an
    object from the code that uses it.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 *Gang of Four* 书中的第一个创建型设计模式开始：**工厂设计模式**。在工厂设计模式中，**客户端**（意味着客户端代码）请求一个对象，而不知道这个对象是从哪里来的（也就是说，使用了哪个类来生成它）。工厂背后的想法是简化对象创建过程。如果通过一个中央函数来完成，那么跟踪哪些对象被创建比让客户端使用直接类实例化来创建对象要容易得多。工厂通过解耦创建对象的代码和使用它的代码来降低维护应用程序的复杂性。
- en: 'Factories typically come in two forms: the **factory method**, which is a method
    (or simply a function for a Python developer) that returns a different object
    per input parameter, and the **abstract factory**, which is a group of factory
    methods that are used to create a family of related objects.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂通常有两种形式：**工厂方法**，这是一个方法（对于 Python 开发者来说，简单地说就是一个函数），它根据输入参数返回不同的对象，以及**抽象工厂**，它是一组用于创建相关对象族的工厂方法。
- en: That is all the theory we need to get started. In the next section, we will
    discuss the factory method.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们开始所需的所有理论。在下一节中，我们将讨论工厂方法。
- en: Implementing the factory method
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现工厂方法
- en: The factory method is based on a single function that's written to handle our
    object creation task. We execute it, passing a parameter that provides information
    about what we want. As a result, the object we wanted is created.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法基于一个单一的功能，该功能被编写来处理我们的对象创建任务。我们执行它，传递一个参数，提供我们想要的信息。结果，我们想要的那个对象就被创建了。
- en: Interestingly, when we use the factory method, we don't need to know any details
    about how the resulting object is implemented and where it is coming from. First,
    we will discuss some real-life applications that use the factory method and then
    implement an example application that processes XML and JSON files.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，当我们使用工厂方法时，我们不需要了解关于结果对象实现细节和来源的任何信息。首先，我们将讨论一些使用工厂方法的现实生活应用，然后实现一个示例应用程序，该应用程序处理
    XML 和 JSON 文件。
- en: Real-world examples
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真实世界的例子
- en: An example of the factory method pattern that's used in real life is in the
    context of a plastic toy construction kit. The molding material that's used to
    construct plastic toys is the same, but different toys (different figures or shapes)
    can be produced using the right plastic molds. This is like having a factory method
    in which the input is the name of the toy that we want (for example, `duck` or
    `car`) and the output (after the molding) is the plastic toy that was requested.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 真实生活中使用的工厂方法模式的例子是在塑料玩具构建套件的上下文中。用于构建塑料玩具的成型材料是相同的，但可以使用正确的塑料模具生产不同的玩具（不同的形状或形状）。这就像有一个工厂方法，其中输入是我们想要的玩具名称（例如，`duck`
    或 `car`），输出（成型后）是我们请求的塑料玩具。
- en: In the software world, the *Django* web framework uses the factory method pattern
    to create the fields of a web form. The `forms` module, which is included in Django,
    supports the ability to create different kinds of fields (for example, `CharField`,
    `EmailField`, and so on). Parts of their behavior can be customized using attributes
    such as `max_length` or `required` ([j.mp/djangofac](http://j.mp/djangofac)).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件世界中，*Django* 网络框架使用工厂方法模式来创建网页表单的字段。Django 包含的 `forms` 模块支持创建不同类型的字段（例如，`CharField`、`EmailField`
    等）。它们的行为部分可以通过 `max_length` 或 `required` 等属性进行自定义 ([j.mp/djangofac](http://j.mp/djangofac))。
- en: 'Consider the following example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code could be written by a developer for a form (the `PersonForm`
    form, which contains the `name` and `birth_date` fields) as part of a Django application's
    UI code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以由一个开发者编写，作为 Django 应用程序 UI 代码的一部分，用于表单（包含 `name` 和 `birth_date` 字段的 `PersonForm`
    表单）。
- en: Use cases
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: If you realize that you cannot track the objects that are created by your application
    because the code that creates them is in many different places instead of in a
    single function/method, you should consider using the factory method pattern.
    The factory method centralizes object creation and tracking your objects becomes
    much easier. Note that it is absolutely fine to create more than one factory method,
    and this is how it is typically done in practice. Each factory method logically
    groups objects that have similarities. For example, one factory method might be
    responsible for connecting you to different databases (MySQL and SQLite), another
    factory method might be responsible for creating the geometrical object that you've
    requested (circle and triangle), and so on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你意识到你无法追踪应用程序创建的对象，因为创建它们的代码分布在许多不同的地方而不是一个单独的函数/方法中，你应该考虑使用工厂方法模式。工厂方法集中化对象创建，跟踪对象变得容易得多。请注意，创建多个工厂方法是绝对可以的，这也是实践中通常的做法。每个工厂方法逻辑上分组具有相似性的对象。例如，一个工厂方法可能负责连接到不同的数据库（MySQL和SQLite），另一个工厂方法可能负责创建你请求的几何对象（圆形和三角形），等等。
- en: The factory method is also useful when you want to decouple object creation
    from object usage. We are not coupled/bound to a specific class when creating
    an object; we just provide partial information about what we want by calling a
    function. This means that introducing changes to the function is easy and does
    not require any changes to be made to the code that uses it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要将对象创建与对象使用解耦时，工厂方法也很有用。在创建对象时，我们并不绑定到特定的类；我们只是通过调用一个函数来提供关于我们想要什么的部分信息。这意味着引入对函数的更改很容易，并且不需要对其使用的代码进行任何更改。
- en: 'Another use case worth mentioning is related to improving the performance and
    memory usage of an application. A factory method can improve performance and memory
    usage by creating new objects only if it is necessary. When we create objects
    using a direct class instantiation, extra memory is allocated every time a new
    object is created (unless the class uses caching internally, which is usually
    not the case). We can see that, in practice, in the following code (in the `id.py`
    file), it creates two instances of the same class, `A`, and uses the `id()` function
    to compare their **memory addresses**. These addresses are also printed in the
    output so that we can inspect them. The fact that the memory addresses are different
    means that two distinct objects are created, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得提到的用例是与提高应用程序的性能和内存使用相关。工厂方法可以通过仅在必要时创建新对象来提高性能和内存使用。当我们使用直接类实例化创建对象时，每次创建新对象都会分配额外的内存（除非类内部使用缓存，这通常不是情况）。我们可以在以下代码（在`id.py`文件中）中看到这一点，它创建了两个相同类`A`的实例，并使用`id()`函数来比较它们的**内存地址**。这些地址也打印在输出中，以便我们可以检查它们。内存地址不同的事实意味着创建了两个不同的对象，如下所示：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Executing the `python id.py` command on my computer results in the following
    output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的电脑上执行`python id.py`命令会产生以下输出：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that the addresses that you see if you execute the file are not the same
    as the ones I can see because they depend on the current memory layout and allocation.
    But the result must be the same: the two addresses should be different. There''s
    one exception that happens if you write and execute the code in the Python **Read-Eval-Print
    Loop** (**REPL**) – or, simply put, the interactive prompt – but that''s a REPL-specific
    optimization that does not happen normally.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你执行文件时看到的地址与我看到的地址不同，因为它们取决于当前的内存布局和分配。但结果必须相同：这两个地址应该是不同的。有一个例外，如果你在Python
    **读取-评估-打印循环**（**REPL**）中编写和执行代码——简单来说，就是交互式提示符——但这是一种REPL特定的优化，通常不会发生。
- en: Implementing the factory method
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现工厂方法
- en: 'Data comes in many forms. There are two main file categories for storing/retrieving
    data: human-readable files and binary files. Examples of human-readable files
    include XML, RSS/Atom, YAML, and JSON. Examples of binary files include the `.sq3`
    file format that''s used by SQLite and the `.mp3` audio file format, which is
    used to listen to music.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 数据以多种形式存在。存储/检索数据的主要文件类别有两种：可读文件和二进制文件。可读文件的例子包括XML、RSS/Atom、YAML和JSON。二进制文件的例子包括SQLite使用的`.sq3`文件格式和用于听音乐的`.mp3`音频文件格式。
- en: 'In this example, we will focus on two popular human-readable formats: **XML**
    and **JSON**. Although human-readable files are generally slower to parse than
    binary files, they make data exchange, inspection, and modification much easier.
    For this reason, it is advised that you work with human-readable files unless
    other restrictions do not allow it (mainly unacceptable performance and proprietary
    binary formats).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将关注两种流行的人可读格式：**XML** 和 **JSON**。尽管人可读文件通常比二进制文件解析速度慢，但它们使数据交换、检查和修改变得容易得多。因此，建议除非有其他限制（主要是不可接受的性能和专有二进制格式），否则您应使用人可读文件。
- en: In this case, we have some input data stored in an XML file and a JSON file,
    and we want to parse them and retrieve some information. At the same time, we
    want to centralize the client's connection to those (and all future) external
    services. We will use the factory method to solve this problem. This example focuses
    only on XML and JSON but adding support for more services should be straightforward.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一些输入数据存储在 XML 文件和 JSON 文件中，我们想要解析它们并检索一些信息。同时，我们想要集中管理客户端对这些（以及所有未来的）外部服务的连接。我们将使用工厂方法来解决这个问题。此示例仅关注
    XML 和 JSON，但添加对更多服务的支持应该是直接的。
- en: First, let's take a look at the data files.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下数据文件。
- en: 'The JSON file, `movies.json`, which can be found in the `data` subfolder of
    this chapter''s code folder, is an example of a dataset containing information
    about American movies (title, year, director name, genre, and so on). This is
    a big file but here is a portion of its content to illustrate how its content
    is organized:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 文件 `movies.json` 可以在本章代码文件夹的 `data` 子文件夹中找到，是一个包含有关美国电影（标题、年份、导演姓名、类型等）信息的示例数据集。这是一个大文件，但这里展示其内容的一部分以说明其组织方式：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The XML file, `person.xml`, is based on a Wikipedia example ([j.mp/wikijson](http://j.mp/wikijson))
    and contains information about individuals (`firstName`, `lastName`, `gender`,
    and so on), as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: XML 文件 `person.xml` 基于维基百科示例 ([j.mp/wikijson](http://j.mp/wikijson))，包含有关个人（`firstName`、`lastName`、`gender`
    等）的信息，如下所示：
- en: 'We start with the enclosing tag of the `persons` XML container:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从 `persons` XML 容器的封装标签开始：
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, an XML element representing a person''s data code is presented, as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，展示了一个代表个人数据代码的 XML 元素，如下所示：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'An XML element representing another person''s data must then be provided:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须提供另一个代表另一个人数据的 XML 元素：
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'An XML element representing a third person''s data is then shown:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后展示了一个代表第三个人数据的 XML 元素：
- en: '[PRE7]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we must close the XML container:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须关闭 XML 容器：
- en: '[PRE8]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will use two libraries that are part of the Python distribution for working
    with JSON and XML, `json` and `xml.etree.ElementTree`, as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 Python 分发的一部分库来处理 JSON 和 XML，即 `json` 和 `xml.etree.ElementTree`，如下所示：
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `JSONDataExtractor` class parses the JSON file and has a `parsed_data()`
    method that returns all the data as a dictionary (`dict`). The property decorator
    is used to make `parsed_data()` appear as a normal attribute instead of a method,
    as follows:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`JSONDataExtractor` 类解析 JSON 文件，并有一个 `parsed_data()` 方法，该方法返回所有数据作为一个字典（`dict`）。属性装饰器用于使
    `parsed_data()` 看起来像一个普通属性而不是一个方法，如下所示：'
- en: '[PRE10]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `XMLDataExtractor` class parses the XML file and has a `parsed_data()`
    method that returns all the data as a list of `xml.etree.Element`, as follows:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`XMLDataExtractor` 类解析 XML 文件，并有一个 `parsed_data()` 方法，该方法返回所有数据作为一个 `xml.etree.Element`
    列表，如下所示：'
- en: '[PRE11]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `dataextraction_factory()` function is a factory method. It returns an
    instance of `JSONDataExtractor` or `XMLDataExtractor`, depending on the extension
    of the input file path, as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dataextraction_factory()` 函数是一个工厂方法。它根据输入文件路径的扩展名返回 `JSONDataExtractor` 或
    `XMLDataExtractor` 的实例，如下所示：'
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `extract_data_from()` function is a wrapper of `dataextraction_factory()`.
    It adds exception handling, as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`extract_data_from()` 函数是 `dataextraction_factory()` 的包装器。它添加了异常处理，如下所示：'
- en: '[PRE13]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `main()` function demonstrates how the factory method design pattern can
    be used. The first part makes sure that exception handling is effective, as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main()` 函数演示了如何使用工厂方法设计模式。第一部分确保异常处理有效，如下所示：'
- en: '[PRE14]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next part shows how to work with the JSON files using the factory method.
    Based on the parsing, the title, year, director name, and genre of the movie can
    be shown (when the value is not empty), as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来部分展示了如何使用工厂方法处理 JSON 文件。基于解析，可以显示电影标题、年份、导演姓名和类型（当值为非空时），如下所示：
- en: '[PRE15]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The final part shows you how to work with the XML files using the factory method.
    XPath is used to find all the person elements that have `Liar` as the last name
    (using `liars = xml_data.findall(f".//person[lastName=''Liar'']")`). For each
    matched person, their basic name and phone number information is shown, as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的部分展示了如何使用工厂方法来处理XML文件。XPath用于找到所有姓氏为`Liar`的人元素（使用`liars = xml_data.findall(f".//person[lastName='Liar']")`）。对于每个匹配的人，他们的基本姓名和电话号码信息如下所示：
- en: '[PRE16]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is the summary of the implementation (you can find the code in the `factory_method.py`
    file):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是实现总结（你可以在`factory_method.py`文件中找到代码）：
- en: We start by importing the modules we need (`json` and `ElementTree`).
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导入所需的模块（`json`和`ElementTree`）。
- en: We define the JSON data extractor class (`JSONDataExtractor`).
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了JSON数据提取器类（`JSONDataExtractor`）。
- en: We define the XML data extractor class (`XMLDataExtractor`).
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了XML数据提取器类（`XMLDataExtractor`）。
- en: We add the factory function, `dataextraction_factory()`, to get the right data
    extractor class.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了工厂函数`dataextraction_factory()`，以获取正确的数据提取器类。
- en: We also add our wrapper for handling exceptions – the `extract_data_from()`
    function.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还添加了我们的异常处理包装器——`extract_data_from()`函数。
- en: 'Finally, we have the `main()` function, followed by Python''s conventional
    trick for calling it when invoking this file from the command line. The following
    are the aspects of the `main` function:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有`main()`函数，随后是Python从命令行调用此文件时的传统技巧。以下是`main`函数的方面：
- en: We try to extract data from a SQL file (`data/person.sq3`) to show how the exception
    is handled.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们尝试从SQL文件（`data/person.sq3`）中提取数据以展示如何处理异常。
- en: We extract data from a JSON file and parse the result.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从JSON文件中提取数据并解析结果。
- en: We extract data from an XML file and parse the result.
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从XML文件中提取数据并解析结果。
- en: The following is the type of output (for the different cases) you will get by
    calling the `python factory_method.py` command.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通过调用`python factory_method.py`命令获得的输出类型（对于不同的情况）：
- en: 'First, there is an exception message that you''ll see when you try to access
    a SQLite (`.sq3`) file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当你尝试访问SQLite（`.sq3`）文件时，你会看到一个异常消息：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we get the following result from processing the `movies` file (JSON):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从处理`movies`文件（JSON）中得到了以下结果：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we get this result from processing the `person` XML file to find the
    people whose last name is `Liar`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们从处理`person` XML文件以找到姓氏为`Liar`的人的过程中得到了这个结果：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that although `JSONDataExtractor` and `XMLDataExtractor` have the same
    interfaces, what is returned by `parsed_data()` is not handled uniformly. Different
    Python code must be used to work with each **data extractor**. Although it would
    be nice to be able to use the same code for all extractors, this is not realistic
    for the most part, unless we use some kind of common mapping for the data, which
    is often provided by external data providers. A useful exercise would be to assume
    that you can use the same code to handle the XML and JSON files and see what changes
    are required to support a third format, such as SQLite. Find a SQLite file or
    create your own and try it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管`JSONDataExtractor`和`XMLDataExtractor`具有相同的接口，但`parsed_data()`返回的内容处理并不统一。必须使用不同的Python代码来处理每个**数据提取器**。虽然能够使用相同的代码处理所有提取器听起来很理想，但在大多数情况下这是不现实的，除非我们使用某种类型的数据通用映射，这通常由外部数据提供商提供。一个有用的练习是假设你可以使用相同的代码来处理XML和JSON文件，并查看需要哪些更改来支持第三种格式，例如SQLite。找到一个SQLite文件或创建自己的，并尝试它。
- en: 'At this point, we have learned about the factory method, which, again, is the
    first form of the factory design pattern. In the next section, we will talk about
    the second: the abstract factory design pattern.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了工厂方法，它再次是工厂设计模式的第一种形式。在下一节中，我们将讨论第二种：抽象工厂设计模式。
- en: Applying the abstract factory
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用抽象工厂
- en: The abstract factory design pattern is a generalization of the factory method.
    An abstract factory is a (logical) group of factory methods, where each factory
    method is responsible for generating a different kind of object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂设计模式是工厂方法的泛化。抽象工厂是一组（逻辑）工厂方法，其中每个工厂方法负责生成不同类型的对象。
- en: In this section, we are going to discuss some examples, use cases, and a possible
    implementation of this pattern.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些示例、用例以及该模式的可能实现。
- en: Real-world examples
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界示例
- en: The abstract factory is used in car manufacturing. The same machinery is used
    for stamping the parts (doors, panels, hoods, fenders, and mirrors) of different
    car models. The model that is assembled by the machinery is configurable and easy
    to change at any time.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂在汽车制造中得到了应用。相同的机器用于不同汽车模型的零件（车门、面板、引擎盖、挡泥板和镜子）的冲压。由机器组装的模型是可配置的，并且可以随时轻松更改。
- en: In the software category, the `factory_boy` ([https://github.com/FactoryBoy/factory_boy](https://github.com/FactoryBoy/factory_boy))
    package provides an abstract factory implementation for creating Django models
    in tests. It is used to create instances of models that support **test-specific
    attributes**. This is important because, this way, your tests become readable,
    and you avoid sharing unnecessary code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件类别中，`factory_boy` ([https://github.com/FactoryBoy/factory_boy](https://github.com/FactoryBoy/factory_boy))
    包为测试中创建Django模型提供了一个抽象工厂实现。它用于创建支持**特定于测试的属性**的模型实例。这很重要，因为这样，你的测试就会变得可读，并且你可以避免共享不必要的代码。
- en: Important Note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Django models are special classes that are used by the framework to help store
    and interact with data in the database (tables). See the Django documentation
    ([https://docs.djangoproject.com](https://docs.djangoproject.com)) for more details.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Django模型是特殊的类，框架使用这些类来帮助存储和与数据库（表）中的数据进行交互。有关更多详细信息，请参阅Django文档（[https://docs.djangoproject.com](https://docs.djangoproject.com)）。
- en: Use cases
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: Since the abstract factory pattern is a generalization of the factory method
    pattern, it offers the same benefits, it makes tracking an object creation easier,
    it decouples object creation from object usage, and it gives us the potential
    to improve the memory usage and performance of our application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于抽象工厂模式是工厂方法模式的泛化，它提供了相同的优势，它使得跟踪对象创建变得更容易，它将对象创建与对象使用解耦，并且它为我们提供了改进应用程序内存使用和性能的潜力。
- en: 'But a question is raised: *How do we know when to use the factory method versus
    using an abstract factory?* The answer is that we usually start with the factory
    method, which is simpler. If we find out that our application requires many factory
    methods, which it makes sense to combine to create a family of objects, we end
    up with an abstract factory.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，一个问题被提了出来：*我们如何知道何时使用工厂方法，而不是使用抽象工厂？* 答案是，我们通常从工厂方法开始，因为它更简单。如果我们发现我们的应用程序需要许多工厂方法，而这些方法合在一起创建一个对象家族是有意义的，那么我们最终会得到一个抽象工厂。
- en: A benefit of the abstract factory that is usually not very visible from a user's
    point of view when they're using the factory method is that we can modify the
    behavior of our application dynamically (at runtime) by changing the active factory
    method. The classic example is the ability to change the look and feel of an application
    (for example, Apple-like, Windows-like, and so on) for the user while the application
    is in use, without the need to terminate it and start it again.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂的一个好处通常在用户使用工厂方法时并不明显，那就是我们可以通过更改活动工厂方法来动态（在运行时）修改应用程序的行为。一个经典的例子是在应用程序使用期间，无需终止并重新启动应用程序，就可以更改应用程序的外观和感觉（例如，类似苹果、类似Windows等）。
- en: Implementing the abstract factory pattern
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现抽象工厂模式
- en: To demonstrate the abstract factory pattern, I will reuse one of my favorite
    examples, which is included in the book *Python 3 Patterns, Recipes, and Idioms*,
    by Bruce Eckel. Imagine that we are creating a game, or we want to include a mini-game
    as part of our application to entertain our users. We want to include at least
    two games – one for children and one for adults. We will decide which game to
    create and launch at runtime, based on user input. An abstract factory takes care
    of the game creation part.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示抽象工厂模式，我将重复使用我最喜欢的例子之一，这个例子包含在Bruce Eckel所著的《Python 3 Patterns, Recipes,
    and Idioms》一书中。想象一下，我们正在创建一个游戏，或者我们想在应用程序中包含一个迷你游戏来娱乐用户。我们希望包含至少两个游戏——一个针对儿童和一个针对成人。我们将根据用户输入在运行时决定创建和启动哪个游戏。抽象工厂负责游戏创建部分。
- en: 'Let''s start with the kid''s game. It is called *FrogWorld*. The main hero
    is a frog who enjoys eating bugs. Every hero needs a good name, and in our case,
    the name is given by the user at runtime. The `interact_with()` method is used
    to describe how the frog interacts with an obstacle (for example, a bug, a puzzle,
    and other frogs), as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从儿童游戏开始。它被称为*FrogWorld*。主要英雄是一只喜欢吃虫子的青蛙。每个英雄都需要一个好的名字，在我们的例子中，这个名字是在运行时由用户提供的。`interact_with()`
    方法用于描述青蛙如何与障碍物（例如，虫子、谜题和其他青蛙）互动，如下所示：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There can be many different kinds of obstacles but for our example, an obstacle
    can only be a bug. When the frog encounters a bug, only one action is supported.
    It eats it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在许多不同种类的障碍，但在我们的例子中，障碍只能是一个虫子。当青蛙遇到虫子时，只支持一个动作。它会吃掉它：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `FrogWorld` class is an abstract factory. Its main responsibilities are
    creating the main character and the obstacle(s) in the game. Keeping the creation
    methods separate and their names generic (for example, `make_character()` and
    `make_obstacle()`) allows us to change the active factory (and therefore the active
    game) dynamically without making any code changes. In a statically typed language,
    the abstract factory would be an abstract class/interface with empty methods,
    but in Python, this is not required because the types are checked at runtime ([j.mp/ginstromdp](http://j.mp/ginstromdp)).
    The code is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrogWorld`类是一个抽象工厂。其主要职责是创建游戏中的主要角色和障碍物。将创建方法分开并使用通用的名称（例如，`make_character()`和`make_obstacle()`）允许我们动态地更改活动工厂（因此是活动游戏），而无需对代码进行任何更改。在静态类型语言中，抽象工厂将是一个抽象类/接口，具有空方法，但在Python中，这不是必需的，因为类型是在运行时检查的（[j.mp/ginstromdp](http://j.mp/ginstromdp)）。代码如下：'
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The *WizardWorld* game is similar. The only difference is that the wizard battles
    against monsters such as orcs instead of eating bugs!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*WizardWorld*游戏类似。唯一的区别是巫师与怪物（如兽人）战斗，而不是吃虫子！'
- en: 'Here is the definition of the `Wizard` class, which is similar to the `Frog`
    one:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`Wizard`类的定义，它与`Frog`类类似：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, the definition of the `Ork` class is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，下面是`Ork`类的定义：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also need to define the `WizardWorld` class, similar to the `FrogWorld`
    one that we have discussed; the obstacle, in this case, is an `Ork` instance:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要定义与`FrogWorld`类似的`WizardWorld`类；在这种情况下，障碍是一个`Ork`实例：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `GameEnvironment` class is the main entry point of our game. It accepts
    the factory as input and uses it to create the world of the game. The `play()`
    method initiates the interaction between the created hero and the obstacle, as
    follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameEnvironment`类是我们游戏的入口点。它接受工厂作为输入，并使用它来创建游戏的世界。`play()`方法启动创建的英雄与障碍之间的交互，如下所示：'
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `validate_age()` function prompts the user to give a valid age. If the
    age is not valid, it returns a tuple with the first element set to `False`. If
    the age is fine, the first element of the tuple is set to `True`. This is where
    we care about the second element of the tuple, which is the age given by the user,
    as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate_age()`函数提示用户输入一个有效的年龄。如果年龄无效，它返回一个元组，第一个元素设置为`False`。如果年龄有效，元组的第一个元素设置为`True`。这就是我们关注元组的第二个元素的地方，即用户给出的年龄，如下所示：'
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Last but not least comes the `main()` function. It asks for the user''s name
    and age, and decides which game should be played, given the age of the user, as
    follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是`main()`函数。它会询问用户的姓名和年龄，并根据用户的年龄决定应该玩哪个游戏，如下所示：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is a summary of the implementation we just discussed (see the
    complete code in the `abstract_factory.py` file):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们刚刚讨论的实现总结（请参阅`abstract_factory.py`文件中的完整代码）：
- en: First, we define the `Frog` and `Bug` classes for the FrogWorld game.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们为FrogWorld游戏定义`Frog`和`Bug`类。
- en: We add the `FrogWorld` class, where we use our `Frog` and `Bug` classes.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了`FrogWorld`类，其中我们使用了我们的`Frog`和`Bug`类。
- en: We define the `Wizard` and `Ork` classes for the WizardWorld game.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为WizardWorld游戏定义`Wizard`和`Ork`类。
- en: We add the `WizardWorld` class, where we use our `Wizard` and `Ork` classes.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了`WizardWorld`类，其中我们使用了我们的`Wizard`和`Ork`类。
- en: We define the `GameEnvironment` class.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义`GameEnvironment`类。
- en: We add the `validate_age()` function.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了`validate_age()`函数。
- en: 'Finally, we have the `main()` function, followed by the conventional trick
    for calling it. The following are the aspects of this function:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有`main()`函数，然后是调用它的传统技巧。以下是这个函数的各个方面：
- en: We get the user's input for their name and age.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们获取用户输入的姓名和年龄。
- en: We decide which game class to use based on the user's age.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们根据用户的年龄决定使用哪个游戏类。
- en: We instantiate the right game class, and then the `GameEnvironment` class.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们实例化正确的游戏类，然后是`GameEnvironment`类。
- en: We call `play()` on the environment object to play the game.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在环境对象上调用`play()`来玩游戏。
- en: Let's call this program using the `python abstract_factory.py` command and see
    some sample output.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`python abstract_factory.py`命令运行这个程序，并查看一些示例输出。
- en: 'The sample output for a teenager is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 青少年的示例输出如下：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The sample output for an adult is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 成年人的示例输出如下：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Try extending the game to make it more complete. You can go as far as you want;
    create many obstacles, many enemies, and whatever else you like.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试扩展游戏使其更加完整。你可以做到你想做的程度；创建许多障碍、许多敌人以及你喜欢的任何其他东西。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use the factory method and the abstract factory
    design patterns. Both patterns are used when we want to track object creation,
    decouple object creation from object usage, or even improve the performance and
    resource usage of an application. Improving performance was not demonstrated in
    this chapter. You may consider trying it as a good exercise.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用工厂方法和抽象工厂设计模式。这两种模式在我们想要跟踪对象创建、将对象创建与对象使用解耦，甚至提高应用程序的性能和资源使用时都会用到。本章没有演示性能改进。你可以考虑将其作为一个好的练习尝试一下。
- en: The factory method design pattern is implemented as a single function that doesn't
    belong to any class and is responsible for creating a single kind of object (a
    shape, a connection point, and so on). We saw how the factory method relates to
    toy construction, mentioned how it is used by Django to create different form
    fields, and discussed other possible use cases for it. As an example, we implemented
    a factory method that provided access to XML and JSON files.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法设计模式作为一个不属于任何类的单一函数实现，负责创建单一类型的对象（如形状、连接点等）。我们看到了工厂方法与玩具建造的关系，提到了它如何被Django用于创建不同的表单字段，并讨论了它的其他可能用例。作为一个例子，我们实现了一个工厂方法，它提供了访问XML和JSON文件的功能。
- en: The abstract factory design pattern is implemented as several factory methods
    that belong to a single class and are used to create a family of related objects
    (the parts of a car, the environment of a game, and so forth). We mentioned how
    the abstract factory is related to car manufacturing, how the `django_factory`
    package for Django makes use of it to create clean tests, and then we covered
    its common use cases. Our implementation example of the abstract factory was a
    mini-game that shows how we can use many related factories in a single class.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂设计模式通过几个属于单个类的工厂方法实现，用于创建一系列相关对象（如汽车的部件、游戏环境等）。我们提到了抽象工厂与汽车制造的关系，说明了Django的`django_factory`包如何利用它来创建干净的测试，然后我们讨论了它的常见用例。我们的抽象工厂实现示例是一个小型游戏，展示了我们如何在单个类中使用许多相关工厂。
- en: In the next chapter, we will discuss the builder pattern, which is another creational
    pattern that can be used for fine-tuning the creation of complex objects.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论建造者模式，这是另一种可以用于微调复杂对象创建的创建型模式。
- en: Questions
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the high-level benefits of using the factory pattern?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用工厂模式有哪些高级好处？
- en: What are the two forms of the factory pattern and their main differences?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工厂模式有两种形式，它们的主要区别是什么？
- en: How should we decide which form of the factory pattern we should use when building
    an application?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建应用程序时，我们应该如何决定使用工厂模式的哪种形式？
