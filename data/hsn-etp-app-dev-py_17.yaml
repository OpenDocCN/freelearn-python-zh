- en: Assessment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章
- en: Answer 1
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案1
- en: Concatenation of a `byte` type, which is an immutable type, and a `str` type
    isn't permissible in the Python 3 standard; any attempt to concatenate these two
    types will raise `TypeError`*.*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3标准中，不允许将不可变类型的`byte`类型和`str`类型进行连接；任何尝试连接这两种类型的操作都会引发`TypeError`错误。
- en: Answer 2
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案2
- en: The type-hinting support introduced in Python 3 is only intended to provide
    greater clarity in documenting the methods and the parameters and doesn't enforce
    any standards on the operations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3中引入的类型提示支持只旨在提供对方法和参数进行更清晰的文档记录，并不强制执行任何操作标准。
- en: Answer 3
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案3
- en: Beyond the functional and nonfunctional requirements, a software requirements
    specification document also specifies other requirements, such as UI, performance,
    business, and market requirements.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 除了功能性和非功能性需求外，软件需求规格说明文档还指定了其他要求，如UI、性能、业务和市场需求。
- en: Answer 4
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案4
- en: 'The various kinds of requirements are categorized as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 各种类型的需求被分类如下：
- en: '**Must-have requirements:** These are requirements that must be present inside
    a system. If any are missing, their absence will affect a critical functionality
    in the system.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**必须要求：**这些是必须存在于系统中的要求。如果缺少任何一个，其缺失将影响系统中的关键功能。'
- en: '**Should-have requirements:** These are requirements that, if present, will
    enhance the functionality of the application.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应该要求：**这些要求如果存在，将增强应用程序的功能。'
- en: '**Could-have requirements:** These are requirements that are noncritical in
    nature. If they are missing, they won''t have any impact on the application''s
    functionality.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可选要求：**这些要求在性质上是非关键的。如果缺少它们，不会对应用程序的功能产生任何影响。'
- en: '**Requirements wish list:** These are requirements that the stakeholders might
    want to see in future updates of the application.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需求愿望清单：**这些是利益相关者可能希望在应用程序的未来更新中看到的要求。'
- en: Answer 5
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案5
- en: Once the software requirements specification document has been generated, the
    next steps in the process include the design phase of the software. In the design
    phase, the structure of the software application is decided upon and decisions
    are made regarding the possible technology stacks that might be used to build
    the software.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了软件需求规格说明文档，流程的下一步包括软件的设计阶段。在设计阶段，决定软件应用程序的结构，并就可能使用的技术栈做出决策。
- en: Chapter 2
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章
- en: Answer 1
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案1
- en: The chain of responsibility pattern inside Python allows us to build an application
    with loose coupling in mind. This is achieved by passing a received request through
    a chain of objects inside the software.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的责任链模式允许我们构建一个考虑松散耦合的应用程序。这是通过将接收到的请求通过软件内的一系列对象链传递实现的。
- en: 'The following code snippet shows the implementation of the chain of responsibility
    pattern inside Python:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了在Python中实现责任链模式的方法：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Answer 2
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案2
- en: The `__new__` method is the first method that's called when a new instance of
    an object needs to be created, whereas the  `__init__` method is run only when
    the newly created instance of the object needs to be initialized. In the normal
    flow of class instance creation, the `__new__` method will always be executed
    first and should only be overridden when the developer wants to gain control over
    the creation of new instances. This method should then be followed by a call to
    the` __init__` method, which will be called once the instance has been created
    and will need to be initialized.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`__new__`方法是在需要创建对象的新实例时调用的第一个方法，而`__init__`方法仅在需要初始化对象的新创建实例时运行。在类实例创建的正常流程中，`__new__`方法将始终首先执行，并且只有在开发人员希望控制新实例的创建时才应该被重写。然后应调用`__init__`方法，该方法将在实例创建后调用，并且需要进行初始化。'
- en: Answer 3
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案3
- en: 'It''s quite easy to define a new abstract class using the ABC metaclass. The
    following code snippet shows an example of achieving this kind of behavior:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ABC元类很容易定义一个新的抽象类。以下代码片段展示了实现这种行为的示例：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Chapter 3
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章
- en: Answer 1
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案1
- en: 'The normalization of the schema inside a DBMS provides a number of benefits,
    such as the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: DBMS中模式的规范化提供了许多好处，例如：
- en: Improved overall organization of the relationships
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进关系的整体组织
- en: Reduction in storage of redundant data
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少冗余数据的存储
- en: Improved consistency of the data inside the database
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进数据库中数据的一致性
- en: Better indexing of the data, which improves access to the data
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好地索引数据，提高对数据的访问
- en: Answer 2
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案2
- en: The lazy loading in SQLAlchemy provides the developer with an option to use
    the *select* or *joined* modes, in which the lazy loading can be performed. When
    the developer goes with the *select* mode of loading the data, the loading of
    the datasets happens through the emission of SQL `SELECT` statements, which load
    the data on a per-requirement basis.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy中的延迟加载为开发人员提供了使用*select*或*joined*模式进行延迟加载的选项。当开发人员选择*select*模式加载数据时，数据集的加载通过发出SQL
    `SELECT`语句进行，这样可以根据需求加载数据。
- en: When using *joined,* the related datasets are loaded all at once through the
    emission of SQL `JOIN` statements. This technique is also known as joined eager
    loading.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用*joined*时，相关数据集通过发出SQL `JOIN`语句一次性加载。这种技术也被称为连接式急加载。
- en: Answer 3
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案3
- en: There are multiple ways through which we can maintain the integrity of data
    as we perform data updates. One of the easiest methods for this that we can implement
    is through the use of transactions, which allow us to make a number of updates
    in an atomic transaction, where either all of the updates in the transaction are
    applied or none are applied.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行数据更新时，我们可以通过多种方式来保持数据的完整性。其中一种最简单的方法是通过使用事务来实现，这允许我们在原子事务中进行多个更新，其中要么应用所有更新，要么不应用任何更新。
- en: In the case that one of the updates inside the transaction fails, the previously
    applied updates inside the transaction are rolled back as well, thereby maintaining
    a consistent state of relations across the database.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在事务中的更新失败时，之前应用的事务中的更新也会被回滚，从而保持数据库中关系的一致状态。
- en: Answer 4
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案4
- en: 'The different levels of caching that can be implemented with a database are
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在数据库中实现的不同级别的缓存如下：
- en: '**Caching at database level:** When we cache at the database level, we usually
    utilize the built-in functionality of the database, which caches the datasets
    that are being frequently used by maintaining the query caches.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库级缓存：** 当我们在数据库级缓存时，通常利用数据库的内置功能，通过维护查询缓存来缓存频繁使用的数据集。'
- en: '**Caching at block level:** Caching at the block level happens at the application
    level, where we cache the data fetched by the ORM layer into a memory-based data
    store so as to avoid running a database query every time a certain result is asked
    for.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块级缓存：** 块级缓存发生在应用程序级别，我们将ORM层获取的数据缓存到基于内存的数据存储中，以避免每次请求特定结果时运行数据库查询。'
- en: '**Caching at the user level:** When caching at the user level, the non-security-critical
    data is cached at the client side through the use of session cookies or local
    storage.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户级缓存：** 在用户级缓存时，非安全关键数据通过会话cookie或本地存储在客户端缓存。'
- en: Chapter 4
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章
- en: Answer 1
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案1
- en: 'Python has two different ways in which it allows us to build applications that
    can process requests concurrently. These are listed as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Python有两种不同的方式允许我们构建能够并发处理请求的应用程序。具体如下：
- en: '**Multiprocessing:** The Python multiprocessing module allows the developer
    to launch multiple processes to handle the workloads in parallel'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多进程：** Python的多进程模块允许开发人员启动多个进程以并行处理工作负载'
- en: '**Multithreading:** The Python multithreading module allows the developer to
    execute multiple threads, which can be used to handle the concurrent workloads'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多线程：** Python多线程模块允许开发人员执行多个线程，可用于处理并发工作负载'
- en: Answer 2
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案2
- en: When the thread that has acquired a lock terminates abruptly, there are multiple
    possible scenarios based on how the lock was acquired.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当获得锁的线程突然终止时，根据获得锁的方式，可能会出现多种情况。
- en: If the lock was acquired through the use of a `with` statement in Python, then
    the lock will be released as soon as the thread terminates.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果锁是通过Python中的`with`语句获得的，那么一旦线程终止，锁就会被释放。
- en: If the lock was acquired inside the `try-except-final` approach, then the lock
    will be freed as the exception propagates to the final statement.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果锁是在`try-except-final`方法中获取的，那么当异常传播到最终语句时，锁将被释放。
- en: If the lock was acquired without any kind of safety procedure, an abrupt termination
    of the thread will cause a deadlock because the lock has not been freed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果锁是在没有任何安全程序的情况下获得的，线程的突然终止将导致死锁，因为锁没有被释放。
- en: Answer 3
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案3
- en: Usually, when the main program receives a termination signal, the signal is
    also propagated to its threads; otherwise, a thread can be marked as a daemon
    thread so that its execution is terminated with the main program.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当主程序接收到终止信号时，信号也会传播到其线程；否则，线程可以被标记为守护线程，以便其执行随主程序终止而终止。
- en: Another way to achieve this is through the use of flags, which a thread can
    check at regular intervals. If the flag is set, then the thread starts with the
    termination.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现方式是通过标志，线程可以定期检查。如果标志被设置，线程就会开始终止。
- en: Answer 4
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案4
- en: The sharing of state between different processes can be achieved through the
    use of pipes, which can help the processes communicate with each other.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不同进程之间的状态共享可以通过使用管道来实现，这可以帮助进程彼此通信。
- en: Answer 5
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案5
- en: In Python, we have multiple ways of creating process pools for the distribution
    of the tasks. We can create these pools manually—as shown in the example in the
    *Synchronization of processes* section in this chapter—or we can utilize the provided
    `ProcessPoolExecutor` from the `concurrent.futures` library.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们有多种方法来创建进程池以分发任务。我们可以手动创建这些池——就像本章*进程同步*部分中的示例所示——或者我们可以利用`concurrent.futures`库中提供的`ProcessPoolExecutor`。
- en: Chapter 5
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章
- en: Answer 1
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案1
- en: For handling requests through the use of multiple application instances, we
    use the concept of horizontal scaling, where we launch more than one instance
    of the same application behind a load balancer. The load balancer is then responsible
    for distributing the incoming requests across this pool of application instances.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过多个应用程序实例处理请求，我们使用水平扩展的概念，其中我们在负载均衡器后启动多个相同应用程序的实例。负载均衡器负责在这些应用程序实例池中分发传入的请求。
- en: Answer 2
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案2
- en: The process pools can be implemented through the use of `ProcessPoolExecutor`
    from the `concurrent.futures` library in Python. An example of how to use `ProcessPoolExecutor`
    to distribute the requests over a pool can be seen in the *Using thread pools
    for handling incoming connections* section of this chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过Python中的`concurrent.futures`库中的`ProcessPoolExecutor`来实现进程池。如何使用`ProcessPoolExecutor`在本章的*使用线程池处理传入连接*部分中有示例。
- en: Answer 3
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案3
- en: 'It is completely possible to have a program that combines the use of multiprocessing
    and multithreading. The following snippet of code shows this implementation:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可以编写一个同时使用多进程和多线程的程序。以下代码片段显示了这种实现方式：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding way of achieving this is valid and can be easily implemented without
    any issues, though you might find that it has a limited number of use cases, and
    its use will be limited by the implementation of the GIL.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现方式是有效的，并且可以轻松实现而不会出现任何问题，尽管您可能会发现它的使用案例有限，并且其使用将受到GIL实现的限制。
- en: Answer 4
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案4
- en: A simple example of implementing a socket server is shown in the *Implementing
    a simple socket server with AsyncIO* section of this chapter. Another way is to
    implement a fully functional web server through the use of AsyncIO is by using
    the `aiohttp` framework, which provides an AIO-based HTTP server.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的*使用AsyncIO实现简单的套接字服务器*部分展示了实现套接字服务器的简单示例。另一种通过使用`aiohttp`框架实现完全功能的Web服务器的方法是使用基于AIO的HTTP服务器。
- en: Chapter 6
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: Answer 1
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案1
- en: In addition to the generic `View` class that we saw during this chapter, Flask
    also provides another prebuilt pluggable view class known as `MethodView`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在本章中看到的通用`View`类之外，Flask还提供了另一个预构建的可插拔视图类，称为`MethodView`。
- en: Answer 2
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案2
- en: Yes, it's possible for us to remove the foreign key constraint for the role
    table from the user table and keep the relationship there. But whenever we need
    to store the data, we will need to manually insert the required object for the
    role object inside the user table.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以删除用户表中对角色表的外键约束，并保持关系。但是每当我们需要存储数据时，我们将需要在用户表中手动插入角色对象所需的对象。
- en: Answer 3
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案3
- en: 'There are a number of alternatives to Gunicorn to serve a Flask-based Python
    application, such as the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多替代方案可用于为基于Flask的Python应用程序提供服务，例如以下内容：
- en: uWSGI
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uWSGI
- en: Twisted web
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扭曲的网络
- en: '`mod_wsgi`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mod_wsgi`'
- en: Gevent
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gevent
- en: Answer 4
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案4
- en: 'Increasing the number of Gunicorn workers is very simple. All we need to do
    is to add the `-w <worker count>` parameter in the command to set the number of
    Gunicorn workers, as shown in the following example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 增加Gunicorn工作进程的数量非常简单。我们只需要在命令中添加`-w <worker count>`参数来设置Gunicorn工作进程的数量，如下例所示：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Chapter 7
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: Answer 1
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案1
- en: 'The use of CDN does improve the loading performance of a web page. This is
    because of the way the browser caches the content from a given URL. Sometimes,
    we can gain the following benefits when we use an existing CDN to serve some of
    the content:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CDN确实可以提高网页的加载性能。这是因为浏览器缓存来自给定URL的内容的方式。有时，当我们使用现有的CDN来提供一些内容时，我们可以获得以下好处：
- en: For some of the frontend libraries that are common, there is a chance that the
    libraries are already cached by the user's browser while they visited some other
    website, which include the content from the CDN. This helps us to avoid redownloading
    those libraries and reduces the bandwidth usage and improves the loading speed
    of the page.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一些常见的前端库，有可能用户的浏览器已经缓存了这些库，因为他们访问了其他网站，其中包括来自CDN的内容。这有助于我们避免重新下载这些库，减少带宽使用，并提高页面的加载速度。
- en: CDNs can also route the request to the servers based on the user geography so
    that the content is downloaded with the least possible latency, thereby improving
    the loading speed of the page.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDN还可以根据用户地理位置将请求路由到服务器，以便以最小的延迟下载内容，从而提高页面的加载速度。
- en: Answer 2
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案2
- en: To make the browser use the existing connections, we can utilize a concept called
    `KeepAlive`. When the `KeepAlive` headers are set in a request, the connection
    that is used to make the request is kept open by the server for a fixed amount
    of time in the hope that the same connection can be used for working on another
    request, avoiding the cost of the initial connection setup for every other request.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让浏览器使用现有的连接，我们可以利用一个叫做`KeepAlive`的概念。当请求中设置了`KeepAlive`头时，服务器会保持用于发出请求的连接打开一段固定的时间，希望可以在另一个请求中继续使用相同的连接，避免为每个请求进行初始连接设置的成本。
- en: Answer 3
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案3
- en: The JavaScript API provides a very handy method known as `removeKey(key)`, which
    can be used to remove a particular key from the local/session storage of the browser.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript API提供了一个非常方便的方法，称为`removeKey(key)`，可以用来从浏览器的本地/会话存储中删除特定的键。
- en: Chapter 8
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章
- en: Answer 1
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案1
- en: 'The major difference between a unit test and a functional test is the scope
    of testing, as described in the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试和功能测试之间的主要区别是测试的范围，如下所述：
- en: '**Unit test:** A unit test usually focuses on the testing of individual components
    in a software that could be factored to a single function or a method of a class'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试：**单元测试通常侧重于测试软件中的单个组件，这些组件可以被分解为单个函数或类的方法。'
- en: '**Functional test:** Functional tests are also known as integration tests and
    usually test a specific functionality of the system that may encompass the interaction
    of multiple components with each other, along with their interaction with the
    external environment, such as database systems.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试：**功能测试也称为集成测试，通常测试系统的特定功能，可能涉及多个组件之间的交互，以及它们与外部环境（如数据库系统）的交互。'
- en: Answer 2
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案2
- en: 'A test suite is a collection of test cases that needs to be run on a specific
    program. Writing a test suite using Python''s `unittest` library is quite easy
    to achieve. For example, if you''ve written a few test cases, such as `TestTextInput`,
    `TestTextUppercase`, and `TestTextEncode`, we can combine them into a test suite
    by using the following code snippet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件是需要在特定程序上运行的一系列测试用例。使用Python的`unittest`库编写测试套件非常容易实现。例如，如果您编写了一些测试用例，比如`TestTextInput`、`TestTextUppercase`和`TestTextEncode`，我们可以使用以下代码片段将它们组合成一个测试套件：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Answer 3
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案3
- en: The purpose of fixtures inside Pytest is to provide a fixed and stable environment
    over which the tests cases can execute. These fixtures are responsible for initializing
    the environment by setting up the required variables or interfaces that may be
    required for a test to execute.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest中fixture的目的是提供一个固定和稳定的环境，以便测试用例可以执行。这些fixture负责通过设置所需的变量或接口来初始化环境，以便测试执行。
- en: Another advantage of using a fixture is its reusability, which allows the same
    fixture to be used for multiple tests without any issue.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用fixture的另一个优点是它的可重用性，允许同一个fixture在多个测试中使用而没有任何问题。
- en: Answer 4
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案4
- en: 'The fixture scopes in Pytest describe how often a fixture will be called. The
    fixtures have a lot of different scopes that can be applied to them, as shown
    in the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest中的fixture作用域描述了fixture将被调用的频率。fixture有许多不同的作用域可以应用于它们，如下所示：
- en: '**Function scope:** Fixture is run once per test'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数作用域：**Fixture在每个测试中运行一次'
- en: '**Class scope:** Fixture is run once per class'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类作用域：**Fixture在每个类中运行一次'
- en: '**Module scope:** Fixture is run once per module'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块作用域：**Fixture在每个模块中运行一次'
- en: '**Session scope:** Fixture is run once per test session'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话作用域：**Fixture在每个测试会话中运行一次'
- en: Chapter 9
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章
- en: Answer 1
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案1
- en: 'There are multiple factors that can be a cause of performance bottlenecks inside
    an application, including the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序内部可能导致性能瓶颈的多个因素，包括以下内容：
- en: Inadequate planning of hardware resources required to run an application
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不足的硬件资源规划，以运行应用程序
- en: Poor choice of algorithms for implementing a functionality in the application
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中实施功能的算法选择不当
- en: Improperly implemented database relations with a lot of redundancy
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库关系实施不当，存在大量冗余
- en: Not implementing proper caching for frequently accessed data
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未对频繁访问的数据实施适当的缓存
- en: Answer 2
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案2
- en: 'Time profiling on a method in Python helps us to understand how much time was
    taken by the method to execute. Based on the requirements, there are several different
    ways through which we can run a time profile on a method, as shown in the following
    lost:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Python中方法的时间分析有助于我们了解方法执行所需的时间。根据要求，我们可以通过几种不同的方式对方法进行时间分析，如下所示：
- en: '**Using the** `timeit` **module:** The `timeit` module provides us with a functionality
    that we can use to find out the time it takes for a script or a method to execute.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用**`timeit`**模块：**`timeit`模块提供了一个功能，可以用来找出脚本或方法执行所需的时间。'
- en: '**Using the** `time` **module:** We can also use the `time` module to help
    us measure the runtime of a method in Python. We can do this through the creation
    of decorators, which can help in the profiling of the method runtime.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用**`time`**模块：**我们还可以使用`time`模块来帮助我们测量Python中方法的运行时间。我们可以通过创建装饰器来实现这一点，这可以帮助我们对方法的运行时间进行分析。'
- en: '**Using the** `cProfile` **module:** The `cProfile` module allows us to profile
    the runtime of the different steps inside a Python program.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用**`cProfile`**模块：**`cProfile`模块允许我们对Python程序内部的不同步骤进行性能分析。'
- en: Answer 3
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案3
- en: Although Python is a garbage-collected language with no direct access to memory
    pointers, the typical memory leaks possible through illegal pointer operations
    can hardly happen. But there's another way through which the Python program can
    continue to consume more and more memory without releasing it. When the program
    forgets to dereference the objects once they're no longer in use, this may cause
    new objects to be allocated without the garbage collection of objects that are
    no longer in use taking place.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Python是一种具有垃圾回收功能且没有直接访问内存指针的语言，但通过非法指针操作可能导致的典型内存泄漏几乎不会发生。但还有另一种方式，即Python程序可以继续消耗更多内存而不释放它。当程序忘记在对象不再使用时取消引用这些对象时，可能会导致分配新对象而不进行不再使用对象的垃圾回收。
- en: Answer 4
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案4
- en: The API response from an application can be profiled by measuring the average
    time taken for an API to return a response over a fixed set of executions. This
    can be measured in multiple ways that may involve the use of the `timeit` or `time`
    modules from the Python standard library.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的API响应可以通过测量API返回响应所需的平均时间来进行性能分析，这可以通过多种方式进行测量，可能涉及使用Python标准库中的`timeit`或`time`模块。
- en: Answer 5
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案5
- en: The design patterns can have an important role in the performance of the application,
    and an incorrect design pattern can have a performance penalty on the application
    performance. For example, consider the allocation of an object that may be used
    implement logging throughout an application. If this logger object allocation
    needs to happen separately for every individual module or class, then we might
    be wasting quite a lot of resources to allocate an object when it could have been
    shared across the different modules.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式在应用程序性能中起着重要作用，不正确的设计模式可能会对应用程序性能造成影响。例如，考虑分配一个对象来实现应用程序中的日志记录。如果这个日志记录对象分配需要在每个单独的模块或类中进行，那么我们可能会浪费大量资源来分配一个对象，而这个对象本可以在不同模块之间共享。
- en: Chapter 10
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章
- en: Answer 1
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案1
- en: 'There are a number of issues that make security an application hard these days.
    These issues include the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有许多问题使得应用程序的安全性变得困难。这些问题包括以下内容：
- en: The rise in sophisticated attacks that are hard to mitigate
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难以应对的复杂攻击
- en: The increase in the rise of 0-day vulnerabilities that have not been patched
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未被修补的0-day漏洞的增加
- en: More and more state-sponsored attacks that target multiple vulnerabilities of
    a system and are usually hard to trace
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 越来越多的国家支持的攻击针对系统的多个漏洞，通常很难追踪
- en: An ever-increasing number of devices coming online without proper security in
    place, making them vulnerable to being used in DDoS attacks
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 越来越多的设备上线而没有适当的安全措施，使它们容易受到DDoS攻击的利用
- en: Answer 2
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案2
- en: An XSS—or cross-site scripting—attack is when an attacker injects a malicious
    script inside a trusted website. When the page with the malicious script is loaded,
    it causes the client system to be compromised by the attacker.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: XSS（或跨站脚本）攻击是指攻击者在受信任的网站中注入恶意脚本。当加载带有恶意脚本的页面时，它会导致客户端系统受到攻击者的威胁。
- en: Answer 3
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案3
- en: A DoS—or denial of service—attack is used by an attacker to make a service or
    resource unavailable to its users by flooding the system with superfluous requests,
    which causes the system to queue up those requests causing a disruption in the
    service.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: DoS（或拒绝服务）攻击是攻击者用来通过向系统发送多余的请求来使服务或资源对其用户不可用的一种方式，这会导致系统排队这些请求并造成服务中断。
- en: 'The attack can be mitigated through the use of different techniques, implemented
    at different levels, such as the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在不同级别实施不同的技术来减轻攻击，例如：
- en: Adding a firewall rule to deny traffic from a given untrusted source
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加防火墙规则以拒绝来自给定不受信任来源的流量
- en: Using services from the cloud security providers, who can analyze the incoming
    traffic and block it before it reaches the application infrastructure, helping
    to mitigate the DoS attack
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用云安全提供商的服务，可以分析传入流量并在到达应用程序基础设施之前阻止它，有助于减轻DoS攻击
- en: Configuring the infrastructure to sink the traffic to a node where there is
    no application running, or by rerouting ...
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置基础设施以将流量引导到没有运行应用程序的节点，或者重新路由...
- en: Answer 4
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案4
- en: 'There are lot of possible mistakes that can compromise the security of the
    application, such as the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多可能的错误可能会危及应用程序的安全性，例如：
- en: Using insecure third-party libraries inside an application, which may contain
    security vulnerabilities
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序内部使用不安全的第三方库，可能包含安全漏洞
- en: Not filtering the user-provided input to the application
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不过滤用户提供的应用程序输入
- en: Storing security-sensitive data unencrypted inside an application
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序内部以未加密的方式存储安全敏感数据
- en: Not implementing proper restrictions to control access to the internal infrastructure
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不实施适当的限制以控制对内部基础设施的访问
- en: Chapter 11
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章
- en: Answer 1
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案1
- en: The major difference between service-oriented architecture and microservices
    architecture is the fact that, in a service-oriented architecture, the application
    consists of different services, each providing the functionality to work on one
    of the business domains of an organization. These services communicate with each
    other through the use of the enterprise service bus, which routes the messages
    from one service to another while also providing a common format for message exchange.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 面向服务的架构和微服务架构之间的主要区别在于，在面向服务的架构中，应用程序由不同的服务组成，每个服务提供组织业务领域之一的功能。这些服务通过企业服务总线进行通信，该总线将消息从一个服务路由到另一个服务，同时提供消息交换的通用格式。
- en: In the case of microservices, the application will consist of a number of small
    microservices, where each microservice is responsible for providing only a single
    functionality that may not map to a complete domain of an organization and may
    just be a subset of larger problem domain. These microservices communicate with
    each other through the use of APIs exposed by the individual microservices or
    through the use of stateless message routers that allow the delivery of messages
    from one service to another.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务的情况下，应用程序将由许多小型微服务组成，每个微服务负责提供仅限于单一功能的功能，可能无法映射到组织的完整领域，可能只是更大问题领域的子集。这些微服务通过各自微服务公开的API或通过无状态消息路由器进行通信，允许消息从一个服务传递到另一个服务。
- en: Answer 2
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案2
- en: 'To ensure that a microservice-based application has a high uptime, we can make
    use of the following techniques:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保基于微服务的应用程序具有高的正常运行时间，我们可以使用以下技术：
- en: Not using a single storage for all of the microservices
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用单一存储来存储所有微服务
- en: Running multiple instances of the same microservice behind the load balancer
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在负载均衡器后运行同一微服务的多个实例
- en: Using API gateways to provide graceful degradation in a service where the client
    still receives a response when a critical service has failed
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用API网关在关键服务失败时提供优雅降级的服务，使客户端仍然在服务失败时收到响应
- en: Answer 3
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案3
- en: 'The use of service-level agreements—or SLAs—provides a number of guarantees,
    such as the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务级别协议（SLA）提供了许多保证，例如：
- en: A guarantee about the API stability of a service
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对服务的API稳定性的保证
- en: A guarantee about the uptime of a service
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对服务正常运行时间的保证
- en: A guarantee of the expected response times of a service
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对服务的预期响应时间的保证
- en: A guarantee of the request rate limitation implemented by a service
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对服务实施的请求速率限制的保证
- en: Answer 4
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案4
- en: The API gateways can communicate directly with the service registry through
    the use of the SDK provided by the service registry or through the use of the
    APIs exposed by the service registry. This allows the API gateway to automatically
    fetch the correct location for a given service from the service registry.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: API网关可以通过服务注册表提供的SDK或通过服务注册表公开的API与服务注册表直接通信。这允许API网关自动从服务注册表中获取给定服务的正确位置。
- en: Answer 5
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案5
- en: Asynchronous communication inside microservices can be implemented through the
    use of stateless message brokers. To implement asynchronous communication, some
    microservices act as producers and send a message to the message-broker queue.
    Then, other microservices may consume that message, process it, and send a response
    back to the microservice that sent the message. The response is then processed
    by the callback that was set by the requesting microservice. This is how the asynchronous
    communication between the microservices is established.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务内部的异步通信可以通过使用无状态消息代理来实现。要实现异步通信，一些微服务充当生产者，并将消息发送到消息代理队列。然后，其他微服务可能会消费该消息，处理它，并将响应发送回发送消息的微服务。然后，由请求微服务设置的回调函数来处理响应。这就是微服务之间的异步通信建立的方式。
- en: Chapter 12
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章
- en: Answer 1
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案1
- en: 'The integration tests for microservices are written in mostly the same way
    as those for monolithic applications, with the following few differences:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的集成测试基本上与单片应用程序的测试方式相同，只有以下几点不同：
- en: If the microservice needs to communicate with some another external microservice,
    then the integration test might need to have the external service set up so as
    to properly execute the test case
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果微服务需要与另一个外部微服务通信，则集成测试可能需要设置外部服务，以便正确执行测试用例
- en: The components that comprise the individual service should be set up for all
    of the microservices in place in the infrastructure—for example, a database that
    accompanies a particular microservice that is needed for testing purposes
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组成单个服务的各个组件应该为基础设施中的所有微服务设置好，例如，伴随特定微服务的数据库需要用于测试目的
- en: Answer 2
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案2
- en: The tracing of a monolithic application differs from that of a microservice-based
    application in the way that the tracing of a monolithic application involves understanding
    the flow of the request from one component to another inside the application.
    In contrast, tracing a microservices-based application involves understanding
    how the request flows not only inside a particular microservice, but also from
    one microservice to another.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用程序的跟踪与基于微服务的应用程序的跟踪不同，单体应用程序的跟踪涉及理解请求从应用程序内的一个组件到另一个组件的流程。相反，跟踪基于微服务的应用程序涉及理解请求不仅在特定微服务内的流动，还涉及请求从一个微服务到另一个微服务的流动。
- en: Answer 3
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案3
- en: 'There are multiple tools that are available for tracing within the microservice
    architecture, as shown in the following list:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个可用于微服务架构内跟踪的工具，如下列表所示：
- en: Jaeger
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jaeger
- en: Zipkin
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zipkin
- en: Appdash
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Appdash
- en: Answer 4
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案4
- en: For tracing the individual components inside a microservice, we can utilize
    one of the functionalities provided by Jaeger known as spans. An example of how
    to use spans can be seen at [https://github.com/jaegertracing/jaeger-client-python](https://github.com/jaegertracing/jaeger-client-python).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪微服务内的各个组件，我们可以利用Jaeger提供的功能之一，称为spans。如何使用spans的示例可以在[https://github.com/jaegertracing/jaeger-client-python](https://github.com/jaegertracing/jaeger-client-python)中看到。
- en: Chapter 13
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章
- en: Answer 1
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案1
- en: 'There are a number of advantages that are provided by a move to serverless
    architecture, such as the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移到无服务器架构提供了许多优势，例如：
- en: Reduced development effort through the integration of third-party services
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过集成第三方服务减少开发工作量
- en: Less operational complexity, because now the organization doesn't need to take
    care of the infrastructure
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作复杂性减少，因为现在组织不需要关心基础设施
- en: Improved security, since the individual functions execute in their own separate
    containers, which helps us to keep the different functions from interfering with
    each other
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进的安全性，因为各个功能在它们自己独立的容器中执行，这有助于我们保持不同功能之间不会相互干扰
- en: Improved scalability of the application
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的可扩展性得到改善
- en: Answer 2
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案2
- en: The use of **Backend as a Service** (**BaaS**) helps in the creation of applications
    by providing common set of functionality through the integration of the APIs.
    These services are hosted by a third-party provider,thereby reducing the effort
    that the application developers will have to expend in rebuilding them in their
    application from scratch.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**后端即服务**（**BaaS**）有助于通过集成API提供的常见功能来创建应用程序。这些服务由第三方提供商托管，从而减少了应用程序开发人员在从头开始重建它们的应用程序中所需的工作量。
- en: Answer 3
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案3
- en: The API gateway in a serverless architecture maps the API endpoints to a function
    in the backend. These API endpoints can then be called by the clients when a particular
    event occurs, invoking the backend function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器架构中的API网关将API端点映射到后端的一个功能。当特定事件发生时，客户端可以调用这些API端点，从而调用后端功能。
- en: Answer 4
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案4
- en: 'There are certain reasons why an application cannot be ported successfully
    to a serverless architecture. These reasons are as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些原因导致应用无法成功迁移到无服务器架构。这些原因如下：
- en: The use of a technology stack that may not be supported by the serverless infrastructure
    provider
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无服务器基础设施提供商不支持的技术堆栈
- en: Applications that need to store the state of the request processing to generate
    correct results
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要存储请求处理状态以生成正确结果的应用程序
- en: A tightly coupled code base that makes it hard to define individual methods
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码基础紧密耦合，很难定义个别方法
- en: Some components of the application taking an extremely long time to execute
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的某些组件执行时间非常长
- en: Chapter 14
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章
- en: Answer 1
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案1
- en: 'The use of blue–green deployments provides us with the following set of benefits:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用蓝绿部署为我们提供了以下一系列好处：
- en: The ability to switch the application from one version to another instantly
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够立即将应用程序从一个版本切换到另一个版本
- en: The ability to easily roll back the application from a newer version to an older
    version in case the new version experiences some critical functionality bugs
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新版本遇到一些关键功能错误时，能够轻松将应用程序从新版本回滚到旧版本
- en: A reduction in downtime related to application upgrades
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与应用程序升级相关的停机时间减少
- en: Answer 2
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案2
- en: 'Using a canary deployment can help in the testing of an application in the following
    ways:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Canary部署可以帮助测试应用程序的以下方式：
- en: The application is tested with a small sample of real-world requests, which
    may help expose any unidentified bugs in the application
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序经过一小部分真实请求的测试，这可能有助于暴露应用程序中的任何未识别的错误
- en: Canary deployment gives us the ability to run the new version of the application
    along with the older version so as to compare the responses provided by the APIs
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Canary部署使我们能够同时运行应用程序的新版本和旧版本，以便比较API提供的响应
- en: Answer 3
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案3
- en: Using virtual machines for running microservices-based applications can cause
    increased overhead for running the microservice instances because of the higher
    requirements incurred by a virtual machine. In addition, the use of virtual machines
    limits the number of services that can coexist on the same infrastructure because
    a virtual machine is comparably heavier to run than containers, which utilize
    operating-system functionality to keep the programs isolated.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟机运行基于微服务的应用程序可能会导致微服务实例的开销增加，因为虚拟机的要求更高。此外，使用虚拟机会限制可以共存在同一基础设施上的服务数量，因为虚拟机比容器更重，容器利用操作系统功能来保持程序隔离。
- en: Answer 4
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案4
- en: The deployments in the hybrid cloud model can be handled in the same way that
    they are handled in the public or private clouds. The difference arises when the
    application needs to be scaled. In this case, when using the hybrid cloud approach,
    an organization can pool the resources from the public cloud based on the scaling
    necessity and can then run some parts of their application in the public cloud
    and the others in the private cloud.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 混合云模型中的部署可以以与公共或私有云中处理的方式进行处理。区别在于应用程序需要进行扩展时。在这种情况下，使用混合云方法时，组织可以根据扩展的需求从公共云中汇集资源，然后在公共云中运行其应用程序的某些部分，而在私有云中运行其他部分。
- en: Chapter 15
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章
- en: Answer 1
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案1
- en: The point-to-point integration of the enterprise applications requires a connector
    to be built for every pair of applications that needs to integrate. This creates
    a complex infrastructure that can be hard to manage as well as scale if new applications
    are introduced into the environment.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序的点对点集成需要为需要集成的每对应用程序构建连接器。这将创建一个复杂的基础设施，如果引入新应用程序，可能难以管理和扩展。
- en: Answer 2
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案2
- en: The enterprise service bus is responsible for helping different services inside
    an infrastructure connect to each other through the use of message-passing mechanisms.
    The ESB provides connectors for the applications through which the applications
    can connect to the ESB and send messages to the ESB.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 企业服务总线负责通过消息传递机制帮助基础设施内的不同服务相互连接。ESB为应用程序提供连接器，应用程序可以通过这些连接器连接到ESB并向ESB发送消息。
- en: The ESB then assumes responsibility for routing these messages to the correct
    service that they are intended for, thereby promoting communication between the
    two services inside an infrastructure.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，ESB负责将这些消息路由到它们预期的正确服务，从而促进基础设施内两个服务之间的通信。
- en: Answer 3
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案3
- en: 'The different types of patterns that facilitate the approach of EAI are as
    follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: EAI的不同类型的模式如下：
- en: Mediation pattern
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调解模式
- en: Federation pattern
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联邦模式
- en: Chapter 16
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章
- en: Answer 1
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案1
- en: The point-to-point integration of different microservices is hard to achieve
    because of the different technology stacks that may be used by a particular microservice
    that is present in the infrastructure. This may cause individual connectors to
    be built for every pair of microservices in order to translate the data format
    of one microservice to another.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基础设施中可能使用特定微服务的不同技术堆栈，因此很难实现不同微服务的点对点集成。这可能导致为每对微服务构建单独的连接器，以将一个微服务的数据格式转换为另一个微服务的数据格式。
- en: Another bottleneck happens because of the scalability of these services, since
    now the connectors have to connect every single instance of the deployed microservice.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个瓶颈是由于这些服务的可伸缩性，现在连接器必须连接部署的每个单个微服务实例。
- en: Answer 2
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案2
- en: The enterprise service bus has been replaced with stateless message routers
    with the advent of microservice architecture, where these routers can be scaled
    up individually and implement message routing for the wide number of microservices
    that might be running inside an infrastructure.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 随着微服务架构的出现，企业服务总线已被无状态消息路由器所取代，这些路由器可以单独扩展，并为可能在基础设施内运行的大量微服务实现消息路由。
- en: Answer 3
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案3
- en: The message brokers inside a microservice architecture provide high availability
    by replicating message queues between the multiple instances of the message broker
    that might be running. This allows the routers to take the place of a failing
    router and keep communication inside the infrastructure intact.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构中的消息代理通过在多个消息代理实例之间复制消息队列来提供高可用性。这允许路由器取代失败的路由器，并保持基础设施内的通信完整。
