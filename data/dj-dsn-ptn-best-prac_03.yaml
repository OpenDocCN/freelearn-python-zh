- en: Chapter 3. Models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。模型
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: The importance of models
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型的重要性
- en: Class diagrams
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类图
- en: Model structural patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型结构模式
- en: Model behavioral patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型行为模式
- en: Migrations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移
- en: M is bigger than V and C
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: M比V和C更大
- en: In Django, models are classes that provide an object-oriented way of dealing
    with databases. Typically, each class refers to a database table and each attribute
    refers to a database column. You can make queries to these tables using an automatically
    generated API.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中，模型是提供与数据库打交道的面向对象方式的类。通常，每个类都指的是一个数据库表，每个属性都指的是一个数据库列。你可以使用自动生成的API对这些表进行查询。
- en: Models can be the base for many other components. Once you have a model, you
    can rapidly derive model admins, model forms, and all kinds of generic views.
    In each case, you would need to write a line of code or two, just so that it does
    not seem too magical.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 模型可以成为许多其他组件的基础。一旦你有了一个模型，你就可以快速地派生模型管理员、模型表单和各种通用视图。在每种情况下，你都需要写一两行代码，这样它就不会显得太神奇。
- en: 'Also, models are used in more places than you would expect. This is because
    Django can be run in several ways. Some of the entry points of Django are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，模型的使用范围比你想象的要广。这是因为Django可以以多种方式运行。Django的一些入口点如下：
- en: The familiar web request-response flow
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉的Web请求-响应流程
- en: Django interactive shell
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django交互式shell
- en: Management commands
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理命令
- en: Test scripts
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试脚本
- en: Asynchronous task queues such as Celery
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如Celery之类的异步任务队列
- en: In almost all these cases, the model modules would get imported (as a part of
    `django.setup()`). Hence, it is best to keep your models free from any unnecessary
    dependencies or to import any other Django components such as views.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有这些情况下，模型模块都会被导入（作为`django.setup()`的一部分）。因此，最好让你的模型摆脱任何不必要的依赖，或者导入其他Django组件，如视图。
- en: In short, designing your models properly is quite important. Now let's get started
    with the SuperBook model design.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，正确设计你的模型非常重要。现在让我们开始SuperBook模型设计。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**The Brown Bag Lunch**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**午餐袋**'
- en: '*Author''s Note: The progress of the* *SuperBook project will appear in a box
    like this. You may skip the box but you will miss the insights, experiences, and
    drama of working in a web application project.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*作者注：SuperBook项目的进展将出现在这样的一个框中。你可以跳过这个框，但你会错过在Web应用项目中工作的见解、经验和戏剧。'
- en: Steve's first week with his client, the **SuperHero Intelligence and Monitoring**
    or **S.H.I.M**. for short, was a mixed bag. The office was incredibly futuristic
    but getting anything done needed a hundred approvals and sign-offs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫与他的客户**超级英雄情报和监控**或**S.H.I.M**。简称，度过了一个波澜起伏的第一周。办公室非常 futurist，但要做任何事情都需要一百个批准和签字。
- en: Being the lead Django developer, Steve had finished setting up a mid-sized development
    server hosting four virtual machines over two days. The next morning, the machine
    itself had disappeared. A washing machine-sized robot nearby said that it had
    been taken to the forensic department due to unapproved software installations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为首席Django开发人员，史蒂夫在两天内完成了设置一个中型开发服务器，托管了四台虚拟机。第二天早上，机器本身已经消失了。附近一个洗衣机大小的机器人说，它被带到了法证部门，因为未经批准的软件安装。
- en: The CTO, Hart was, however, of great help. He asked the machine to be returned
    in an hour with all the installations intact. He had also sent pre-approvals for
    the SuperBook project to avoid any such roadblocks in future.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，CTO哈特非常乐意帮忙。他要求机器在一个小时内归还，并保持所有安装完好。他还发送了对SuperBook项目的预批准，以避免将来出现任何类似的障碍。
- en: Later that afternoon, Steve was having a brown-bag lunch with him. Dressed in
    a beige blazer and light blue jeans, Hart arrived well in time. Despite being
    taller than most people and having a clean-shaven head, he seemed cool and approachable.
    He asked if Steve had checked out the previous attempt to build a superhero database
    in the sixties.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那天下午，史蒂夫和他一起吃了午餐。哈特穿着米色西装外套和浅蓝色牛仔裤，准时到达。尽管比大多数人高，头发光秃秃的，他看起来很酷，很平易近人。他问史蒂夫是否看过上世纪六十年代尝试建立超级英雄数据库的尝试。
- en: '"Oh yes, the Sentinel project, right?" said Steve. "I did. The database seemed
    to be designed as an Entity-Attribute-Value model, something that I consider an
    anti-pattern. Perhaps they had very little idea about the attributes of a superhero
    those days." Hart almost winced at the last statement. In a slightly lowered voice,
    he said, "You are right, I didn''t. Besides, they gave me only two days to design
    the whole thing. I believe there was literally a nuclear bomb ticking somewhere."'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '"哦，是哨兵项目，对吧？"史蒂夫说。 "我看过。数据库似乎被设计为实体-属性-值模型，我认为这是一种反模式。也许他们当时对超级英雄的属性知之甚少。"哈特几乎在最后一句话上略显不悦。他声音稍微低了一些，说："你说得对，我没看过。而且，他们只给了我两天的时间来设计整个东西。我相信当时确实有一个核弹在某个地方滴答作响。"'
- en: Steve's mouth was wide open and his sandwich had frozen at its entrance. Hart
    smiled. "Certainly not my best work. Once it crossed about a billion entries,
    it took us days to run any kind of analysis on that damn database. SuperBook would
    zip through that in mere seconds, right?"
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫张大了嘴，他的三明治在嘴里僵住了。哈特微笑着说："当然不是我的最佳作品。一旦超过了大约十亿条目，我们花了几天时间才能对那该死的数据库进行任何分析。SuperBook会在短短几秒钟内完成，对吧？"
- en: Steve nodded weakly. He had never imagined that there would be around a billion
    superheroes in the first place.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫微弱地点了点头。他从未想象过第一次会有大约十亿个超级英雄。
- en: The model hunt
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型搜索
- en: 'Here is a first cut at identifying the models in SuperBook. Typical to an early
    attempt, we have represented only the essential models and their relationships
    in the form of a class diagram:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对SuperBook中模型的第一次识别。典型的早期尝试，我们只表示了基本模型及其关系，以类图的形式：
- en: '![The model hunt](img/6644_03_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![模型搜索](img/6644_03_01.jpg)'
- en: Let's forget models for a moment and talk in terms of the objects we are modeling.
    Each user has a profile. A user can make several comments or several posts. A
    **Like** can be related to a single user/post combination.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时忘记模型，用我们建模的对象来谈论。每个用户都有一个个人资料。用户可以发表多条评论或多篇文章。**喜欢**可以与单个用户/帖子组合相关联。
- en: Drawing a class diagram of your models like this is recommended. Some attributes
    might be missing at this stage but you can detail them later. Once the entire
    project is represented in the diagram, it makes separating the apps easier.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 建议绘制类图来描述您的模型。在这个阶段可能会缺少一些属性，但您可以稍后详细说明。一旦整个项目在图表中表示出来，就会更容易分离应用程序。
- en: 'Here are some tips to create this representation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建此表示形式的一些提示：
- en: Boxes represent entities, which become models.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方框表示实体，这些实体将成为模型。
- en: Nouns in your write-up typically end up as entities.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的写作中的名词通常最终成为实体。
- en: 'Arrows are bi-directional and represent one of the three types of relationships
    in Django: one-to-one, one-to-many (implemented with Foreign Keys), and many-to-many.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头是双向的，代表Django中三种关系类型之一：一对一，一对多（使用外键实现），和多对多。
- en: The field denoting the one-to-many relationship is defined in the model on the
    **Entity-relationship model** (**ER-model**). In other words, the star is where
    the Foreign Key gets declared.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**实体-关系模型**（**ER模型**）的模型中定义了表示一对多关系的字段。换句话说，星号是声明外键的地方。
- en: 'The class diagram can be mapped into the following Django code (which will
    be spread across several apps):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 类图可以映射到以下Django代码（将分布在几个应用程序中）：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Later, we will not reference the `User` directly but use the more general `settings.AUTH_USER_MODEL`
    instead.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将不直接引用`User`，而是使用更一般的`settings.AUTH_USER_MODEL`。
- en: Splitting models.py into multiple files
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将models.py拆分为多个文件
- en: Like most components of Django, a large `models.py` file can be split up into
    multiple files within a package. A **package** is implemented as a directory,
    which can contain multiple files, one of which must be a specially named file
    called `__init__.py`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与Django的大多数组件一样，可以将大型的`models.py`文件拆分为包内的多个文件。**包**被实现为一个目录，其中可以包含多个文件，其中一个必须是一个名为`__init__.py`的特殊命名文件。
- en: 'All definitions that can be exposed at package level must be defined in `__init__.py`
    with global scope. For example, if we split `models.py` into individual classes,
    in corresponding files inside `models` subdirectory such as `postable.py`, `post.py`,
    and `comment.py`, then the `__init__.py` package will look like:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在包级别公开的所有定义都必须在`__init__.py`中以全局范围定义。例如，如果我们将`models.py`拆分为单独的类，放在`models`子目录内的相应文件中，如`postable.py`，`post.py`和`comment.py`，那么`__init__.py`包将如下所示：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now you can import `models.Post` as before.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以像以前一样导入`models.Post`。
- en: Any other code in the `__init__.py` package will be run when the package is
    imported. Hence, it is the ideal place for any package-level initialization code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__.py`包中的任何其他代码在导入包时都会运行。因此，这是任何包级别初始化代码的理想位置。'
- en: Structural patterns
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构模式
- en: This section contains several design patterns that can help you design and structure
    your models.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含几种设计模式，可以帮助您设计和构造模型。
- en: Patterns – normalized models
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式 - 规范化模型
- en: '**Problem**: By design, model instances have duplicated data that cause data
    inconsistencies.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：按设计，模型实例具有导致数据不一致的重复数据。'
- en: '**Solution**: Break down your models into smaller models through normalization.
    Connect these models with logical relationships between them.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：通过规范化将模型分解为较小的模型。使用这些模型之间的逻辑关系连接这些模型。'
- en: Problem details
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题细节
- en: 'Imagine if someone designed our Post table (omitting certain columns) in the
    following way:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果有人以以下方式设计我们的Post表（省略某些列）：
- en: '| Superhero Name | Message | Posted on |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 超级英雄名称 | 消息 | 发布于 |'
- en: '| --- | --- | --- |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Captain Temper | Has this posted yet? | 2012/07/07 07:15 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 阿尔法队长 | 是否已发布？ | 2012/07/07 07:15 |'
- en: '| Professor English | It should be ''Is'' not ''Has''. | 2012/07/07 07:17 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 英语教授 | 应该是''Is''而不是''Has''。 | 2012/07/07 07:17 |'
- en: '| Captain Temper | Has this posted yet? | 2012/07/07 07:18 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 阿尔法队长 | 是否已发布？ | 2012/07/07 07:18 |'
- en: '| Capt. Temper | Has this posted yet? | 2012/07/07 07:19 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 阿尔法队长 | 是否已发布？ | 2012/07/07 07:19 |'
- en: I hope you noticed the inconsistent superhero naming in the last row (and captain's
    consistent lack of patience).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您注意到了最后一行中不一致的超级英雄命名（以及队长一贯的缺乏耐心）。
- en: If we were to look at the first column, we are not sure which spelling is correct—*Captain
    Temper* or *Capt. Temper*. This is the kind of data redundancy we would like to
    eliminate through normalization.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看第一列，我们不确定哪种拼写是正确的—*Captain Temper*还是*Capt. Temper*。这是我们希望通过规范化消除的数据冗余。
- en: Solution details
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案细节
- en: Before we take a look at the fully normalized solution, let's have a brief primer
    on database normalization in the context of Django models.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看完全规范化的解决方案之前，让我们简要介绍一下Django模型的数据库规范化的概念。
- en: Three steps of normalization
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规范化的三个步骤
- en: Normalization helps you efficiently store data. Once your models are fully normalized,
    they will not have redundant data, and each model should contain data that is
    only logically related to it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 规范化有助于您高效地存储数据。一旦您的模型完全规范化，它们将不会有冗余数据，每个模型应该只包含与其逻辑相关的数据。
- en: 'To give a quick example, if we were to normalize the Post table so that we
    can unambiguously refer to the superhero who posted that message, then we need
    to isolate the user details in a separate table. Django already creates the user
    table by default. So, you only need to refer to the ID of the user who posted
    the message in the first column, as shown in the following table:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 举个快速的例子，如果我们要规范化Post表，以便我们可以明确地引用发布该消息的超级英雄，那么我们需要将用户详细信息隔离在一个单独的表中。Django已经默认创建了用户表。因此，您只需要在第一列中引用发布消息的用户的ID，如下表所示：
- en: '| User ID | Message | Posted on |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 用户ID | 消息 | 发布于 |'
- en: '| --- | --- | --- |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 12 | Has this posted yet? | 2012/07/07 07:15 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 是否已发布？ | 2012/07/07 07:15 |'
- en: '| 8 | It should be ''Is'' not ''Has''. | 2012/07/07 07:17 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 应该是''Is''而不是''Has''。 | 2012/07/07 07:17 |'
- en: '| 12 | Has this posted yet? | 2012/07/07 07:18 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 这个帖子发出来了吗？ | 2012/07/07 07:18 |'
- en: '| 12 | Has this posted yet? | 2012/07/07 07:19 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 这个帖子发出来了吗？ | 2012/07/07 07:19 |'
- en: Now, it is not only clear that there were three messages posted by the same
    user (with an arbitrary user ID), but we can also find that user's correct name
    by looking up the user table.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不仅清楚地知道有三条消息是由同一用户（具有任意用户ID）发布的，而且我们还可以通过查找用户表找到该用户的正确姓名。
- en: Generally, you will design your models to be in their fully normalized form
    and then selectively denormalize them for performance reasons. In databases, **Normal
    Forms** are a set of guidelines that can be applied to a table to ensure that
    it is normalized. Commonly found normal forms are first, second, and third normal
    forms, although they could go up to the fifth normal form.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您将设计您的模型以达到其完全规范化的形式，然后出于性能原因选择性地对其进行去规范化。在数据库中，**正常形式**是一组可应用于表以确保其规范化的准则。通常的正常形式有第一、第二和第三正常形式，尽管它们可以达到第五正常形式。
- en: In the next example, we will normalize a table and create the corresponding
    Django models. Imagine a spreadsheet called *'Sightings'* that lists the first
    time someone spots a superhero using a power or superhuman ability. Each entry
    mentions the known origins, super powers, and location of first sighting, including
    latitude and longitude.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将规范化一个表并创建相应的Django模型。想象一个名为*'Sightings'*的电子表格，列出了第一次有人发现超级英雄使用力量或超人能力的时间。每个条目都提到已知的起源、超能力和第一次目击的位置，包括纬度和经度。
- en: '| Name | Origin | Power | First Used At (Lat, Lon, Country, Time) |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 名字 | 起源 | 力量 | 第一次使用地点（纬度、经度、国家、时间） |'
- en: '| --- | --- | --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Blitz | Alien | FreezeFlight | +40.75, -73.99; USA; 2014/07/03 23:12+34.05,
    -118.24; USA; 2013/03/12 11:30 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 突袭 | 外星人 | 冻结飞行 | +40.75, -73.99; 美国; 2014/07/03 23:12+34.05, -118.24; 美国;
    2013/03/12 11:30 |'
- en: '| Hexa | Scientist | TelekinesisFlight | +35.68, +139.73; Japan; 2010/02/17
    20:15+31.23, +121.45; China; 2010/02/19 20:30 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 十六进制 | 科学家 | 念力飞行 | +35.68, +139.73; 日本; 2010/02/17 20:15+31.23, +121.45;
    中国; 2010/02/19 20:30 |'
- en: '| Traveller | Billionaire | Time travel | +43.62, +1.45, France; 2010/11/10
    08:20 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 旅行者 | 亿万富翁 | 时空旅行 | +43.62, +1.45, 法国; 2010/11/10 08:20 |'
- en: The preceding geographic data has been extracted from [http://www.golombek.com/locations.html](http://www.golombek.com/locations.html).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的地理数据已从[http://www.golombek.com/locations.html](http://www.golombek.com/locations.html)中提取。
- en: First normal form (1NF)
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第一正常形式（1NF）
- en: 'To confirm to the first normal form, a table must have:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要符合第一正常形式，表必须具有：
- en: No attribute (cell) with multiple values
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有具有多个值的属性（单元格）
- en: A primary key defined as a single column or a set of columns (composite key)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义为单列或一组列（复合键）的主键
- en: Let's try to convert our spreadsheet into a database table. Evidently, our *'Power'*
    column breaks the first rule.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将我们的电子表格转换为数据库表。显然，我们的*'Power'*列违反了第一条规则。
- en: The updated table here satisfies the first normal form. The primary key (marked
    with a *) is a combination of *'Name'* and *'Power'*, which should be unique for
    each row.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里更新的表满足了第一正常形式。主键（用*标记）是*'Name'*和*'Power'*的组合，对于每一行来说应该是唯一的。
- en: '| Name* | Origin | Power* | Latitude | Longitude | Country | Time |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 名字* | 起源 | 力量* | 纬度 | 经度 | 国家 | 时间 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| Blitz | Alien | Freeze | +40.75170 | -73.99420 | USA | 2014/07/03 23:12 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 突袭 | 外星人 | 冻结 | +40.75170 | -73.99420 | 美国 | 2014/07/03 23:12 |'
- en: '| Blitz | Alien | Flight | +40.75170 | -73.99420 | USA | 2013/03/12 11:30 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 突袭 | 外星人 | 飞行 | +40.75170 | -73.99420 | 美国 | 2013/03/12 11:30 |'
- en: '| Hexa | Scientist | Telekinesis | +35.68330 | +139.73330 | Japan | 2010/02/17
    20:15 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 十六进制 | 科学家 | 念力 | +35.68330 | +139.73330 | 日本 | 2010/02/17 20:15 |'
- en: '| Hexa | Scientist | Flight | +35.68330 | +139.73330 | Japan | 2010/02/19 20:30
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 十六进制 | 科学家 | 飞行 | +35.68330 | +139.73330 | 日本 | 2010/02/19 20:30 |'
- en: '| Traveller | Billionaire | Time travel | +43.61670 | +1.45000 | France | 2010/11/10
    08:20 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 旅行者 | 亿万富翁 | 时空旅行 | +43.61670 | +1.45000 | 法国 | 2010/11/10 08:20 |'
- en: Second normal form or 2NF
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第二正常形式或2NF
- en: The second normal form must satisfy all the conditions of the first normal form.
    In addition, it must satisfy the condition that all non-primary key columns must
    be dependent on the entire primary key.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第二正常形式必须满足第一正常形式的所有条件。此外，它必须满足所有非主键列都必须依赖于整个主键的条件。
- en: In the previous table, notice that *'Origin'* depends only on the superhero,
    that is, '*Name*'. It doesn't matter which *Power* we are talking about. So, *Origin*
    is not entirely dependent on the composite primary key—*Name* and *Power*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中，注意*'Origin'*只取决于超级英雄，即*'Name'*。我们谈论的*Power*无关紧要。因此，*Origin*并不完全依赖于复合主键—*Name*和*Power*。
- en: 'Let''s extract just the origin information into a separate table called ''*Origins*''
    as shown here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将起源信息提取到一个名为*'Origins'*的单独表中，如下所示：
- en: '| Name* | Origin |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 名字* | 起源 |'
- en: '| --- | --- |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Blitz | Alien |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 突袭 | 外星人 |'
- en: '| Hexa | Scientist |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 十六进制 | 科学家 |'
- en: '| Traveller | Billionaire |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 旅行者 | 亿万富翁 |'
- en: 'Now our *Sightings* table updated to be compliant to the second normal form
    looks like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们更新为符合第二正常形式的*Sightings*表如下：
- en: '| Name* | Power* | Latitude | Longitude | Country | Time |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 名字* | 力量* | 纬度 | 经度 | 国家 | 时间 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| Blitz | Freeze | +40.75170 | -73.99420 | USA | 2014/07/03 23:12 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 突袭 | 冻结 | +40.75170 | -73.99420 | 美国 | 2014/07/03 23:12 |'
- en: '| Blitz | Flight | +40.75170 | -73.99420 | USA | 2013/03/12 11:30 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 突袭 | 飞行 | +40.75170 | -73.99420 | 美国 | 2013/03/12 11:30 |'
- en: '| Hexa | Telekinesis | +35.68330 | +139.73330 | Japan | 2010/02/17 20:15 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 十六进制 | 念力 | +35.68330 | +139.73330 | 日本 | 2010/02/17 20:15 |'
- en: '| Hexa | Flight | +35.68330 | +139.73330 | Japan | 2010/02/19 20:30 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 十六进制 | 飞行 | +35.68330 | +139.73330 | 日本 | 2010/02/19 20:30 |'
- en: '| Traveller | Time travel | +43.61670 | +1.45000 | France | 2010/11/10 08:20
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 旅行者 | 时空旅行 | +43.61670 | +1.45000 | 法国 | 2010/11/10 08:20 |'
- en: Third normal form or 3NF
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第三正常形式或3NF
- en: In third normal form, the tables must satisfy the second normal form and should
    additionally satisfy the condition that all non-primary key columns must be directly
    dependent on the entire primary key and must be independent of each other.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三范式中，表必须满足第二范式，并且还必须满足所有非主键列必须直接依赖于整个主键并且彼此独立的条件。
- en: Think about the *Country* column for a moment. Given the *Latitude* and *Longitude*,
    you can easily derive the *Country* column. Even though the country where a superpowers
    was sighted is dependent on the *Name*-*Power* composite primary key it is only
    indirectly dependent on them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 想一下*国家*列。根据*纬度*和*经度*，您可以很容易地推导出*国家*列。尽管超级能力出现的国家取决于*名称*-*能力*复合主键，但它只间接依赖于它们。
- en: 'So, let''s separate the location details into a separate Countries table as
    follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将位置细节分离到一个单独的国家表中，如下所示：
- en: '| Location ID | Latitude* | Longitude* | Country |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 位置ID | 纬度* | 经度* | 国家 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1 | +40.75170 | -73.99420 | USA |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 1 | +40.75170 | -73.99420 | 美国 |'
- en: '| 2 | +35.68330 | +139.73330 | Japan |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 2 | +35.68330 | +139.73330 | 日本 |'
- en: '| 3 | +43.61670 | +1.45000 | France |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 3 | +43.61670 | +1.45000 | 法国 |'
- en: 'Now our *Sightings* table in its third normal form looks like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的*Sightings*表在第三范式中看起来像这样：
- en: '| User ID* | Power* | Location ID | Time |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 用户ID* | 能力* | 位置ID | 时间 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 2 | Freeze | 1 | 2014/07/03 23:12 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 冰冻 | 1 | 2014/07/03 23:12 |'
- en: '| 2 | Flight | 1 | 2013/03/12 11:30 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 飞行 | 1 | 2013/03/12 11:30 |'
- en: '| 4 | Telekinesis | 2 | 2010/02/17 20:15 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 念力 | 2 | 2010/02/17 20:15 |'
- en: '| 4 | Flight | 2 | 2010/02/19 20:30 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 飞行 | 2 | 2010/02/19 20:30 |'
- en: '| 7 | Time travel | 3 | 2010/11/10 08:20 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 时间旅行 | 3 | 2010/11/10 08:20 |'
- en: As before, we have replaced the superhero's name with the corresponding *User
    ID* that can be used to reference the user table.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们已经用对应的*用户ID*替换了超级英雄的名字，这可以用来引用用户表。
- en: Django models
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Django模型
- en: 'We can now take a look at how these normalized tables can be represented as
    Django models. Composite keys are not directly supported in Django. The solution
    used here is to apply the surrogate keys and specify the `unique_together` property
    in the `Meta` class:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看一下这些规范化表如何表示为Django模型。Django不直接支持复合键。这里使用的解决方案是应用代理键，并在`Meta`类中指定`unique_together`属性：
- en: '[PRE2]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Performance and denormalization
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 性能和去规范化
- en: Normalization can adversely affect performance. As the number of models increase,
    the number of joins needed to answer a query also increase. For instance, to find
    the number of superheroes with the Freeze capability in USA, you will need to
    join four tables. Prior to normalization, any information can be found by querying
    a single table.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 规范化可能会对性能产生不利影响。随着模型数量的增加，回答查询所需的连接数量也会增加。例如，要找到在美国具有冰冻能力的超级英雄数量，您将需要连接四个表。在规范化之前，可以通过查询单个表找到任何信息。
- en: You should design your models to keep the data normalized. This will maintain
    data integrity. However, if your site faces scalability issues, then you can selectively
    derive data from those models to create denormalized data.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该设计您的模型以保持数据规范化。这将保持数据完整性。但是，如果您的网站面临可扩展性问题，那么您可以有选择地从这些模型中派生数据，以创建去规范化的数据。
- en: Tip
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best Practice**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Normalize while designing but denormalize while optimizing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 设计时规范化，优化时去规范化。
- en: For instance, if counting the sightings in a certain country is very common,
    then add it as an additional field to the `Location` model. Now, you can include
    the other queries using Django (**object-relational mapping**) **ORM**, unlike
    a cached value.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果在某个特定国家中计算目击事件是非常常见的，那么将其作为`Location`模型的一个附加字段。现在，您可以使用Django的ORM包括其他查询，而不是使用缓存值。
- en: However, you need to update this count each time you add or remove a sighting.
    You need to add this computation to the `save` method of *Sighting*, add a signal
    handler, or even compute using an asynchronous job.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您需要在每次添加或删除一个目击事件时更新这个计数。您需要将这个计算添加到*Sighting*的`save`方法中，添加一个信号处理程序，或者甚至使用异步作业进行计算。
- en: If you have a complex query spanning several tables, such as a count of superpowers
    by country, then you need to create a separate denormalized table. As before,
    we need to update this denormalized table every time the data in your normalized
    models changes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个跨多个表的复杂查询，比如按国家统计超能力的数量，那么您需要创建一个单独的去规范化表。与以前一样，每当规范化模型中的数据发生更改时，我们都需要更新这个去规范化表。
- en: Denormalization is surprisingly common in large websites because it is tradeoff
    between speed and space. Today, space is cheap but speed is crucial to user experience.
    So, if your queries are taking too long to respond, then you might want to consider
    it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 去规范化在大型网站中非常常见，因为它是速度和空间之间的权衡。如今，空间是廉价的，但速度对用户体验至关重要。因此，如果您的查询响应时间过长，那么您可能需要考虑去规范化。
- en: Should we always normalize?
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我们是否总是要规范化？
- en: Too much normalization is not necessarily a good thing. Sometimes, it can introduce
    an unnecessary table that can complicate updates and lookups.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 过度规范化并不一定是件好事。有时，它可能会引入一个不必要的表，从而使更新和查找变得复杂。
- en: For example, your *User* model might have several fields for their home address.
    Strictly speaking, you can normalize these fields into an *Address* model. However,
    in many cases, it would be unnecessary to introduce an additional table to the
    database.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您的*用户*模型可能有几个字段用于他们的家庭地址。严格来说，您可以将这些字段规范化为一个*地址*模型。但是，在许多情况下，引入一个额外的表到数据库中可能是不必要的。
- en: Rather than aiming for the most normalized design, carefully weigh each opportunity
    to normalize and consider the tradeoffs before refactoring.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与其追求最规范化的设计，不如在重构之前仔细权衡每个规范化的机会并考虑权衡。
- en: Pattern – model mixins
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式-模型混合
- en: '**Problem**: Distinct models have the same fields and/or methods duplicated
    violating the DRY principle.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：不同的模型具有相同的字段和/或重复的方法，违反了DRY原则。'
- en: '**Solution**: Extract common fields and methods into various reusable model
    mixins.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：将常见字段和方法提取到各种可重用的模型混合中。'
- en: Problem details
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题细节
- en: While designing models, you might find certain common attributes or behaviors
    shared across model classes. For example, a `Post` and `Comment` model needs to
    keep track of its `created` date and `modified` date. Manually copy-pasting the
    fields and their associated method is not a very DRY approach.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计模型时，您可能会发现某些共享模型类之间共享的常见属性或行为。例如，“帖子”和“评论”模型需要跟踪其“创建”日期和“修改”日期。手动复制字段及其关联方法并不是一种非常DRY的方法。
- en: Since Django models are classes, object-oriented approaches such as composition
    and inheritance are possible solutions. However, compositions (by having a property
    that contains an instance of the shared class) will need an additional level of
    indirection to access fields.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Django模型是类，因此可以使用面向对象的方法，如组合和继承。但是，组合（通过具有包含共享类实例的属性）将需要额外的间接级别来访问字段。
- en: 'Inheritance can get tricky. We can use a common base class for `Post` and `Comments`.
    However, there are three kinds of inheritance in Django: **concrete**, **abstract**,
    and **proxy**.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 继承可能会变得棘手。我们可以为“帖子”和“评论”使用一个共同的基类。但是，在Django中有三种继承方式：**具体**，**抽象**和**代理**。
- en: Concrete inheritance works by deriving from the base class just like you normally
    would in Python classes. However, in Django, this base class will be mapped into
    a separate table. Each time you access base fields, an implicit join is needed.
    This leads to horrible performance.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 具体继承通过从基类派生，就像在Python类中通常做的那样。但是，在Django中，这个基类将被映射到一个单独的表中。每次访问基本字段时，都需要隐式连接。这会导致性能恶化。
- en: Proxy inheritance can only add new behavior to the parent class. You cannot
    add new fields. Hence, it is not very useful for this situation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 代理继承只能向父类添加新行为。您不能添加新字段。因此，对于这种情况，它并不是非常有用。
- en: Finally, we are left with abstract inheritance.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们剩下了抽象继承。
- en: Solution details
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案细节
- en: Abstract base classes are elegant solutions used to share data and behavior
    among models. When you define an abstract class, it does not create any corresponding
    table in the database. Instead, these fields are created in the derived non-abstract
    classes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象基类是用于在模型之间共享数据和行为的优雅解决方案。当您定义一个抽象类时，它不会在数据库中创建任何相应的表。相反，这些字段将在派生的非抽象类中创建。
- en: Accessing abstract base class fields doesn't need a `JOIN` statement. The resulting
    tables are also self-contained with managed fields. Due to these advantages, most
    Django projects use abstract base classes to implement common fields or methods.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 访问抽象基类字段不需要“JOIN”语句。由于这些优势，大多数Django项目使用抽象基类来实现常见字段或方法。
- en: 'Limitations of abstract models are as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象模型的局限性如下：
- en: They cannot have a Foreign Key or many-to-many field from another model
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不能有来自另一个模型的外键或多对多字段
- en: They cannot be instantiated or saved
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不能被实例化或保存
- en: They cannot be directly used in a query since it doesn't have a manager
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不能直接在查询中使用，因为它没有一个管理器
- en: 'Here is how the post and comment classes can be initially designed with an
    abstract base class:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何最初设计帖子和评论类的抽象基类：
- en: '[PRE7]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To turn a model into an abstract base class, you will need to mention `abstract
    = True` in its inner `Meta` class. Here, `Postable` is an abstract base class.
    However, it is not very reusable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要将模型转换为抽象基类，您需要在其内部“Meta”类中提到“abstract = True”。在这里，“Postable”是一个抽象基类。但是，它并不是非常可重用的。
- en: In fact, if there was a class that had just the `created` and `modified` field,
    then we can reuse that timestamp functionality in nearly any model needing a timestamp.
    In such cases, we usually define a model mixin.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果有一个只有“创建”和“修改”字段的类，那么我们可以在几乎任何需要时间戳的模型中重用该时间戳功能。在这种情况下，我们通常定义一个模型混合。
- en: Model mixins
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模型混合
- en: Model mixins are abstract classes that can be added as a parent class of a model.
    Python supports multiple inheritances, unlike other languages such as Java. Hence,
    you can list any number of parent classes for a model.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 模型混合是可以添加为模型的父类的抽象类。Python支持多重继承，不像其他语言如Java。因此，您可以为模型列出任意数量的父类。
- en: Mixins ought to be orthogonal and easily composable. Drop in a mixin to the
    list of base classes and they should work. In this regard, they are more similar
    in behavior to composition rather than inheritance.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 混合类应该是正交的并且易于组合。将混合类放入基类列表中，它们应该可以工作。在这方面，它们更类似于组合而不是继承的行为。
- en: Smaller mixins are better. Whenever a mixin becomes large and violates the Single
    Responsibility Principle, consider refactoring it into smaller classes. Let a
    mixin do one thing and do it well.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 较小的混合类更好。每当混合类变得庞大并违反单一责任原则时，考虑将其重构为较小的类。让混合类只做一件事，并且做得很好。
- en: 'In our previous example, the model mixin used to update the `created` and `modified`
    time can be easily factored out, as shown in the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，用于更新“创建”和“修改”时间的模型混合可以很容易地被分解，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have two base classes now. However, the functionality is clearly separated.
    The mixin can be separated into its own module and reused in other contexts.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个基类。但是，功能明显分开。混合类可以分离到自己的模块中，并在其他上下文中重用。
- en: Pattern – user profiles
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式 - 用户配置文件
- en: '**Problem**: Every website stores a different set of user profile details.
    However, Django''s built-in `User` model is meant for authentication details.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：每个网站存储不同的用户配置文件详细信息。但是，Django内置的“User”模型是用于身份验证详细信息的。'
- en: '**Solution**: Create a user profile class with a one-to-one relation with the
    user model.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：创建一个用户配置文件类，与用户模型有一对一的关系。'
- en: Problem details
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题细节
- en: Out of the box, Django provides a pretty decent `User` model. You can use it
    when you create a super user or log in to the admin interface. It has a few basic
    fields, such as full name, username, and e-mail.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了一个相当不错的“User”模型。您可以在创建超级用户或登录到管理界面时使用它。它有一些基本字段，如全名，用户名和电子邮件。
- en: However, most real-world projects keep a lot more information about users, such
    as their address, favorite movies, or their superpower abilities. From Django
    1.5 onwards, the default `User` model can be extended or replaced. However, official
    docs strongly recommend storing only authentication data even in a custom user
    model (it belongs to the `auth` app, after all).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数现实世界的项目都会保存更多关于用户的信息，比如他们的地址、喜欢的电影，或者他们的超能力。从Django 1.5开始，默认的`User`模型可以被扩展或替换。然而，官方文档强烈建议即使在自定义用户模型中也只存储认证数据（毕竟它属于`auth`应用）。
- en: Certain projects need multiple types of users. For example, SuperBook can be
    used by superheroes and non-superheroes. There might be common fields and some
    distinctive fields based on the type of user.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 某些项目需要多种类型的用户。例如，SuperBook可以被超级英雄和非超级英雄使用。根据用户类型，可能会有共同的字段和一些特殊的字段。
- en: Solution details
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案细节
- en: 'The officially recommended solution is to create a user profile model. It should
    have a one-to-one relation with your user model. All the additional user information
    is stored in this model:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 官方推荐的解决方案是创建一个用户配置模型。它应该与用户模型有一对一的关系。所有额外的用户信息都存储在这个模型中：
- en: '[PRE9]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is recommended that you set the `primary_key` explicitly to `True` to prevent
    concurrency issues in some database backends such as PostgreSQL. The rest of the
    model can contain any other user details, such as birthdate, favorite color, and
    so on.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您将`primary_key`显式设置为`True`，以防止一些数据库后端（如PostgreSQL）中的并发问题。模型的其余部分可以包含任何其他用户详细信息，例如出生日期、喜欢的颜色等。
- en: While designing the profile model, it is recommended that all the profile detail
    fields must be nullable or contain default values. Intuitively, we can understand
    that a user cannot fill out all his profile details while signing up. Additionally,
    we will ensure that the signal handler also doesn't pass any initial parameters
    while creating the profile instance.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计配置模型时，建议所有配置详细字段都必须是可空的或包含默认值。直观地，我们可以理解用户在注册时无法填写所有配置详细信息。此外，我们还将确保信号处理程序在创建配置实例时也不传递任何初始参数。
- en: Signals
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 信号
- en: Ideally, every time a user model instance is created, a corresponding user profile
    instance must be created as well. This is usually done using signals.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，每次创建用户模型实例时，都必须创建一个相应的用户配置实例。这通常是使用信号来完成的。
- en: 'For example, we can listen for the `post_save` signal from the user model using
    the following signal handler:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以监听用户模型的`post_save`信号，使用以下信号处理程序：
- en: '[PRE10]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the profile model has passed no additional initial parameters except
    for the user instance.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，配置模型除了用户实例之外，没有传递任何额外的初始参数。
- en: Previously, there was no specific place for initializing the signal code. Typically,
    they were imported or implemented in `models.py` (which was unreliable). However,
    with app-loading refactor in Django 1.7, the application initialization code location
    is well defined.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，没有特定的位置来初始化信号代码。通常它们被导入或实现在`models.py`中（这是不可靠的）。然而，随着Django 1.7中的应用加载重构，应用初始化代码的位置得到了明确定义。
- en: 'First, create a `__init__.py` package for your application to mention your
    app''s `ProfileConfig`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为您的应用创建一个`__init__.py`包，以提及您的应用的`ProfileConfig`：
- en: '[PRE11]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, subclass the `ProfileConfig` method in `app.py` and set up the signal
    in the `ready` method:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`app.py`中对`ProfileConfig`方法进行子类化，并在`ready`方法中设置信号：
- en: '[PRE12]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With your signals set up, accessing `user.profile` should return a `Profile`
    object to all users, even the newly created ones.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好信号后，访问`user.profile`应该会返回一个`Profile`对象给所有用户，甚至是新创建的用户。
- en: Admin
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 管理员
- en: 'Now, a user''s details will be in two different places within the admin: the
    authentication details in the usual user admin page and the same user''s additional
    profile details in a separate profile admin page. This gets very cumbersome.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用户的详细信息将在管理员中的两个不同位置：通常用户管理员页面中的认证详细信息和同一用户的额外配置详细信息在单独的配置管理员页面中。这变得非常繁琐。
- en: 'For convenience, the profile admin can be made inline to the default user admin
    by defining a custom `UserAdmin` as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，可以通过定义自定义的`UserAdmin`将配置管理员内联到默认的用户管理员中：
- en: '[PRE13]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Multiple profile types
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多种配置类型
- en: Assume that you need several kinds of user profiles in your application. There
    needs to be a field to track which type of profile the user has. The profile data
    itself needs to be stored in separate models or a unified model.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的应用程序需要几种不同类型的用户配置。需要有一个字段来跟踪用户拥有的配置类型。配置数据本身需要存储在单独的模型或统一的模型中。
- en: An aggregate profile approach is recommended since it gives the flexibility
    to change the profile types without loss of profile details and minimizes complexity.
    In this approach, the profile model contains a superset of all profile fields
    from all profile types.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用聚合配置方法，因为它可以灵活地更改配置类型而不会丢失配置详细信息，并且可以最小化复杂性。在这种方法中，配置模型包含来自所有配置类型的所有配置字段的超集。
- en: 'For example, SuperBook will need a `SuperHero` type profile and an `Ordinary`
    (non-superhero) profile. It can be implemented using a single unified profile
    model as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，SuperBook将需要一个`SuperHero`类型的配置和一个`Ordinary`（非超级英雄）配置。可以使用单一统一的配置模型来实现如下：
- en: '[PRE14]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We grouped the profile details into several abstract base classes to separate
    concerns. The `BaseProfile` class contains all the common profile details irrespective
    of the user type. It also has a `user_type` field that keeps track of the user's
    active profile.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将配置详细信息分组到几个抽象基类中以分离关注点。`BaseProfile`类包含所有用户类型无关的公共配置详细信息。它还有一个`user_type`字段，用于跟踪用户的活动配置。
- en: The `SuperHeroProfile` class and `OrdinaryProfile` class contain the profile
    details specific to superhero and non-hero users respectively. Finally, the `profile`
    class derives from all these base classes to create a superset of profile details.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`SuperHeroProfile`类和`OrdinaryProfile`类包含特定于超级英雄和非英雄用户的配置详细信息。最后，`profile`类从所有这些基类派生，以创建配置详细信息的超集。'
- en: 'Some details to take care of while using this approach are as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这种方法时需要注意的一些细节如下：
- en: All profile fields that belong to the class or its abstract bases classes must
    be nullable or with defaults.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属于类或其抽象基类的所有配置文件字段必须是可空的或具有默认值。
- en: This approach might consume more database space per user but gives immense flexibility.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法可能会消耗更多的数据库空间，但提供了巨大的灵活性。
- en: The active and inactive fields for a profile type need to be managed outside
    the model. Say, a form to edit the profile must show the appropriate fields based
    on the currently active user type.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件类型的活动和非活动字段需要在模型之外进行管理。比如，编辑配置文件的表单必须根据当前活动用户类型显示适当的字段。
- en: Pattern – service objects
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式 - 服务对象
- en: '**Problem**: Models can get large and unmanageable. Testing and maintenance
    get harder as a model does more than one thing.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：模型可能会变得庞大且难以管理。随着模型的功能变得多样化，测试和维护变得更加困难。'
- en: '**Solution**: Refactor out a set of related methods into a specialized `Service`
    object.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：将一组相关方法重构为专门的`Service`对象。'
- en: Problem details
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题细节
- en: Fat models, thin views is an adage commonly told to Django beginners. Ideally,
    your views should not contain anything other than presentation logic.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Django初学者来说，经常听到的一句话是“模型臃肿，视图薄”。理想情况下，您的视图除了呈现逻辑之外不应包含任何其他内容。
- en: However, over time pieces of code that cannot be placed anywhere else tend to
    go into models. Soon, models become a dump yard for the code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着时间的推移，无法放置在其他位置的代码片段往往会进入模型。很快，模型就成了代码的垃圾场。
- en: 'Some of the tell-tale signs that your model can use a `Service` object are
    as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一些表明您的模型可以使用`Service`对象的迹象如下：
- en: Interactions with external services, for example, checking whether the user
    is eligible to get a `SuperHero` profile with a web service.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与外部服务的交互，例如使用Web服务检查用户是否有资格获得`SuperHero`配置文件。
- en: Helper tasks that do not deal with the database, for example, generating a short
    URL or random captcha for a user.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不涉及数据库的辅助任务，例如为用户生成短网址或随机验证码。
- en: Involves a short-lived object without a database state, for example, creating
    a JSON response for an AJAX call.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 涉及没有数据库状态的短暂对象，例如为AJAX调用创建JSON响应。
- en: Long-running tasks involving multiple instances such as Celery tasks.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 涉及多个实例的长时间运行任务，例如Celery任务。
- en: Models in Django follow the Active Record pattern. Ideally, they encapsulate
    both application logic and database access. However, keep the application logic
    minimal.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Django中的模型遵循Active Record模式。理想情况下，它们封装了应用程序逻辑和数据库访问。但是，要保持应用程序逻辑最小化。
- en: While testing, if we find ourselves unnecessarily mocking the database even
    while not using it, then we need to consider breaking up the model class. A `Service`
    object is recommended in such situations.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试过程中，如果我们发现自己在不使用数据库的情况下不必要地模拟数据库，那么我们需要考虑拆分模型类。在这种情况下，建议使用`Service`对象。
- en: Solution details
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案细节
- en: Service objects are plain old Python objects (POPOs) that encapsulate a 'service'
    or interactions with a system. They are usually kept in a separate file named
    `services.py` or `utils.py`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 服务对象是封装“服务”或与系统交互的普通Python对象（POPOs）。它们通常保存在名为`services.py`或`utils.py`的单独文件中。
- en: 'For example, checking a web service is sometimes dumped into a model method
    as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有时将检查Web服务转储到模型方法中，如下所示：
- en: '[PRE15]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This method can be refactored to use a service object as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将此方法重构为使用服务对象，如下所示：
- en: '[PRE16]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The service object can be now defined in `services.py` as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在`services.py`中定义服务对象，如下所示：
- en: '[PRE17]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In most cases, methods of a `Service` object are stateless, that is, they perform
    the action solely based on the function arguments without using any class properties.
    Hence, it is better to explicitly mark them as static methods (as we have done
    for `is_hero`).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`Service`对象的方法是无状态的，即它们仅基于函数参数执行操作，而不使用任何类属性。因此，最好明确将它们标记为静态方法（就像我们为`is_hero`所做的那样）。
- en: Consider refactoring your business logic or domain logic out of models into
    service objects. This way, you can use them outside your Django application as
    well.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑将业务逻辑或领域逻辑从模型中重构到服务对象中。这样，您也可以在Django应用程序之外使用它们。
- en: 'Imagine there is a business reason to blacklist certain users from becoming
    superhero types based on their username. Our service object can be easily modified
    to support this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个业务原因，根据用户名将某些用户列入黑名单，以防止他们成为超级英雄类型。我们的服务对象可以很容易地修改以支持这一点：
- en: '[PRE18]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Ideally, service objects are self-contained. This makes them easy to test without
    mocking, say, the database. They can be also easily reused.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，服务对象是自包含的。这使它们易于在没有模拟的情况下进行测试，比如数据库。它们也可以很容易地被重用。
- en: In Django, time-consuming services are executed asynchronously using task queues
    such as Celery. Typically, the `Service` Object actions are run as Celery tasks.
    Such tasks can be run periodically or after a delay.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中，使用诸如Celery之类的任务队列异步执行耗时服务。通常，`Service`对象操作作为Celery任务运行。此类任务可以定期运行或延迟运行。
- en: Retrieval patterns
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索模式
- en: This section contains design patterns that deal with accessing model properties
    or performing queries on them.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含处理访问模型属性或对其执行查询的设计模式。
- en: Pattern – property field
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式 - 属性字段
- en: '**Problem**: Models have attributes that are implemented as methods. However,
    these attributes should not be persisted to the database.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：模型具有实现为方法的属性。但是，这些属性不应持久存储到数据库中。'
- en: '**Solution**: Use the property decorator on such methods.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：对这些方法使用property装饰器。'
- en: Problem details
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题细节
- en: Model fields store per-instance attributes, such as first name, last name, birthday,
    and so on. They are also stored in the database. However, we also need to access
    some derived attributes, such as full name or age.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 模型字段存储每个实例的属性，例如名字、姓氏、生日等。它们也存储在数据库中。但是，我们还需要访问一些派生属性，例如全名或年龄。
- en: They can be easily calculated from the database fields, hence need not be stored
    separately. In some cases, they can just be a conditional check such as eligibility
    for offers based on age, membership points, and active status.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以很容易地从数据库字段中计算出来，因此不需要单独存储。在某些情况下，它们只是一个条件检查，比如基于年龄、会员积分和活跃状态的优惠资格。
- en: 'A straightforward way to implement this is to define functions, such as `get_age`
    similar to the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的一个直接方法是定义函数，比如`get_age`，类似于以下内容：
- en: '[PRE19]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Calling `profile.get_age()` would return the user's age by calculating the difference
    in the years adjusted by one based on the month and date.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`profile.get_age()`将返回用户的年龄，通过计算根据月份和日期调整的年份差。
- en: However, it is much more readable (and Pythonic) to call it `profile.age`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，调用`profile.age`更可读（和Pythonic）。
- en: Solution details
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案细节
- en: 'Python classes can treat a function as an attribute using the `property` decorator.
    Django models can use it as well. In the previous example, replace the function
    definition line with:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Python类可以使用`property`装饰器将函数视为属性。Django模型也可以使用它。在前面的例子中，用以下内容替换函数定义行：
- en: '[PRE20]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, we can access the user's age with `profile.age`. Notice that the function's
    name is shortened as well.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过`profile.age`访问用户的年龄。注意函数的名称也被缩短了。
- en: An important shortcoming of a property is that it is invisible to the ORM, just
    like model methods are. You cannot use it in a `QuerySet` object. For example,
    this will not work, `Profile.objects.exclude(age__lt=18)`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的一个重要缺点是它对ORM是不可见的，就像模型方法一样。你不能在`QuerySet`对象中使用它。例如，这样是行不通的，`Profile.objects.exclude(age__lt=18)`。
- en: It might also be a good idea to define a property to hide the details of internal
    classes. This is formally known as the **Law of Demeter**. Simply put, the law
    states that you should only access your own direct members or "use only one dot".
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 也许定义一个属性来隐藏内部类的细节是一个好主意。这在正式上被称为**迪米特法则**。简单来说，这个法则规定你只能访问自己的直接成员或者“只使用一个点”。
- en: For example, rather than accessing `profile.birthdate.year`, it is better to
    define a `profile.birthyear` property. It helps you hide the underlying structure
    of the `birthdate` field this way.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，与其访问`profile.birthdate.year`，最好定义一个`profile.birthyear`属性。这样可以帮助隐藏`birthdate`字段的底层结构。
- en: Tip
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best Practice**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Follow the law of Demeter, and use only one dot when accessing a property.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循迪米特法则，在访问属性时只使用一个点。
- en: An undesirable side effect of this law is that it leads to the creation of several
    wrapper properties in the model. This could bloat up models and make them hard
    to maintain. Use the law to improve your model's API and reduce coupling wherever
    it makes sense.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个法则的一个不良副作用是它会导致模型中创建几个包装属性。这可能会使模型变得臃肿并且难以维护。在合适的地方使用这个法则来改进你的模型API并减少耦合是更可读（和Pythonic）的。
- en: Cached properties
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓存属性
- en: Each time we call a property, we are recalculating a function. If it is an expensive
    calculation, we might want to cache the result. This way, the next time the property
    is accessed, the cached value is returned.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用属性时，我们都在重新计算一个函数。如果这是一个昂贵的计算，我们可能希望缓存结果。这样，下次访问属性时，将返回缓存的值。
- en: '[PRE21]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The cached value will be saved as a part of the Python instance. As long as
    the instance exists, the same value will be returned.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存的值将作为Python实例的一部分保存。只要实例存在，就会返回相同的值。
- en: As a failsafe mechanism, you might want to force the execution of the expensive
    operation to ensure that stale values are not returned. In such cases, set a keyword
    argument such as `cached=False` to prevent returning the cached value.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种保险机制，你可能希望强制执行昂贵操作以确保不返回陈旧的值。在这种情况下，设置一个关键字参数，比如`cached=False`来防止返回缓存的值。
- en: Pattern – custom model managers
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式 - 自定义模型管理器
- en: '**Problem**: Certain queries on models are defined and accessed repeatedly
    throughout the code violating the DRY principle.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：模型上的某些查询在整个代码中被定义和访问，违反了DRY原则。'
- en: '**Solution**: Define custom managers to give meaningful names to common queries.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：定义自定义管理器来为常见查询提供有意义的名称。'
- en: Problem details
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题细节
- en: Every Django model has a default manager called `objects`. Invoking `objects.all()`,
    will return all the entries for that model in the database. Usually, we are interested
    in only a subset of all entries.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Django模型都有一个名为`objects`的默认管理器。调用`objects.all()`，将返回数据库中该模型的所有条目。通常，我们只对所有条目的一个子集感兴趣。
- en: 'We apply various filters to find out the set of entries we need. The criterion
    to select them is often our core business logic. For example, we can find the
    posts accessible to the public by the following code:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用各种过滤器来找到我们需要的条目集。选择它们的标准通常是我们的核心业务逻辑。例如，我们可以通过以下代码找到对公众可访问的帖子：
- en: '[PRE22]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This criterion might change in the future. Say, we might want to also check
    whether the post was marked for editing. This change might look like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标准可能会在未来发生变化。比如，我们可能还想检查帖子是否被标记为编辑。这个变化可能看起来像这样：
- en: '[PRE23]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: However, this change needs to be made everywhere a public post is needed. This
    can get very frustrating. There needs to be only one place to define such commonly
    used queries without 'repeating oneself'.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个变化需要在需要公共帖子的每个地方进行。这可能会变得非常令人沮丧。需要有一个地方来定义这样的常用查询，而不是“重复自己”。
- en: Solution details
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案细节
- en: '`QuerySets` are an extremely powerful abstraction. They are lazily evaluated
    only when needed. Hence, building longer `QuerySets` by method-chaining (a form
    of fluent interface) does not affect the performance.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuerySets`是一个非常强大的抽象。它们只在需要时进行延迟评估。因此，通过方法链接（一种流畅接口的形式）构建更长的`QuerySets`不会影响性能。'
- en: In fact, as more filtering is applied, the result dataset shrinks. This usually
    reduces the memory consumption of the result.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，随着应用更多的过滤，结果数据集会变小。这通常会减少结果的内存消耗。
- en: 'A model manager is a convenient interface for a model to get its `QuerySet`
    object. In other words, they help you use Django''s ORM to access the underlying
    database. In fact, managers are implemented as very thin wrappers around a `QuerySet`
    object. Notice the identical interface:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 模型管理器是模型获取其`QuerySet`对象的便捷接口。换句话说，它们帮助你使用Django的ORM来访问底层数据库。事实上，管理器实际上是围绕`QuerySet`对象实现的非常薄的包装器。注意相同的接口：
- en: '[PRE24]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The default manager created by Django, `objects`, has several methods, such
    as `all`, `filter`, or `exclude` that return `QuerySets`. However, they only form
    a low-level API to your database.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Django创建的默认管理器`objects`有几个方法，比如`all`、`filter`或`exclude`，它们返回`QuerySets`。然而，它们只是对数据库的低级API。
- en: Custom managers are used to create a domain-specific, higher-level API. This
    is not only more readable but less affected by implementation details. Thus, you
    are able to work at a higher level of abstraction closely modeled to your domain.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义管理器用于创建特定领域的高级API。这不仅更易读，而且不受实现细节的影响。因此，你能够在更高层次上工作，与你的领域紧密建模。
- en: 'Our previous example for public posts can be easily converted into a custom
    manager as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的公共帖子示例可以很容易地转换为自定义管理器，如下所示：
- en: '[PRE25]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This convenient shortcut for creating a custom manager from a `QuerySet` object
    appeared in Django 1.7\. Unlike other previous approaches, this `PostManager`
    object is chainable like the default `objects` manager.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方便的快捷方式用于从`QuerySet`对象创建自定义管理器，出现在Django 1.7中。与以往的方法不同，这个`PostManager`对象可以像默认的`objects`管理器一样进行链式操作。
- en: 'It sometimes makes sense to replace the default `objects` manager with our
    custom manager, as shown in the following code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，用我们的自定义管理器替换默认的`objects`管理器是有意义的，就像下面的代码所示：
- en: '[PRE26]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'By doing this, to access `public_posts` our code gets considerably simplified
    to the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们的代码可以更简化地访问`public_posts`如下：
- en: '[PRE27]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Since the returned value is a `QuerySet`, they can be further filtered:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 由于返回的值是一个`QuerySet`，它们可以进一步过滤：
- en: '[PRE28]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`QuerySets` have several interesting properties. In the next few sections,
    we can take a look at some common patterns that involve combining `QuerySets`.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuerySets`有几个有趣的属性。在接下来的几节中，我们可以看一下涉及组合`QuerySets`的一些常见模式。'
- en: Set operations on QuerySets
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对QuerySets进行集合操作
- en: 'True to their name (or the latter half of their name), `QuerySets` support
    a lot of (mathematical) set operations. For the sake of illustration, consider
    two `QuerySets` that contain the user objects:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 忠于它们的名字（或名字的后半部分），`QuerySets`支持许多（数学）集合操作。为了举例说明，考虑包含用户对象的两个`QuerySets`：
- en: '[PRE29]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Some set operations that you can perform on them are as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对它们执行的一些集合操作如下：
- en: '**Union**: This combines and removes duplicates. Use `q1` | `q2` to get [`<User:
    a>`, `<User: b>`, `<User: c>`, `<User: d>`]'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并集**：这将组合并移除重复项。使用`q1` | `q2`得到[`<User: a>`, `<User: b>`, `<User: c>`, `<User:
    d>`]'
- en: '**Intersection**: This finds common items. Use `q1` and `q2` to get [`<User:
    c>`]'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交集**：这找到共同的项目。使用`q1`和`q2`得到[`<User: c>`]'
- en: '**Difference**: This removes elements in second set from first. There is no
    logical operator for this. Instead use `q1.exclude(pk__in=q2)` to get [`<User:
    a>`, `<User: b>`]'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**差集**：这将从第一个集合中移除第二个集合中的元素。没有逻辑运算符。而是使用`q1.exclude(pk__in=q2)`得到[`<User: a>`,
    `<User: b>`]'
- en: 'The same operations can be done using the `Q` objects:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Q`对象也可以执行相同的操作：
- en: '[PRE30]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that the difference is implemented using `&` (AND) and `~` (Negation).
    The `Q` objects are very powerful and can be used to build very complex queries.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，差异是使用`&`（AND）和`~`（Negation）实现的。`Q`对象非常强大，可以用来构建非常复杂的查询。
- en: However, the `Set` analogy is not perfect. `QuerySets`, unlike mathematical
    sets, are ordered. So, they are closer to Python's list data structure in that
    respect.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Set`的类比并不完美。`QuerySets`与数学集合不同，是有序的。因此，在这方面它们更接近于Python的列表数据结构。
- en: Chaining multiple QuerySets
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 链式多个QuerySets
- en: So far, we have been combining `QuerySets` of the same type belonging to the
    same base class. However, we might need to combine `QuerySets` from different
    models and perform operations on them.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经组合了属于同一基类的相同类型的`QuerySets`。然而，我们可能需要组合来自不同模型的`QuerySets`并对它们执行操作。
- en: 'For example, a user''s activity timeline contains all their posts and comments
    in reverse chronological order. The previous methods of combining `QuerySets`
    won''t work. A naïve solution would be to convert them to lists, concatenate,
    and sort them, like this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，用户的活动时间线包含了他们所有的帖子和评论，按照时间顺序排列。以前的组合`QuerySets`的方法不起作用。一个天真的解决方案是将它们转换为列表，连接并对它们进行排序，就像这样：
- en: '[PRE31]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Unfortunately, this operation has evaluated the lazy `QuerySets` object. The
    combined memory usage of the two lists can be overwhelming. Besides, it can be
    quite slow to convert large `QuerySets` into lists.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个操作已经评估了惰性的`QuerySets`对象。两个列表的组合内存使用可能会很大。此外，将大型的`QuerySets`转换为列表可能会相当慢。
- en: 'A much better solution uses iterators to reduce the memory consumption. Use
    the `itertools.chain` method to combine multiple `QuerySets` as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案使用迭代器来减少内存消耗。使用`itertools.chain`方法来组合多个`QuerySets`如下：
- en: '[PRE32]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Once you evaluate a `QuerySet`, the cost of hitting the database can be quite
    high. So, it is important to delay it as long as possible by performing only operations
    that will return `QuerySets` unevaluated.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦评估了`QuerySet`，命中数据库的成本可能会相当高。因此，通过只执行将返回未评估的`QuerySets`的操作，尽可能地延迟它是很重要的。
- en: Tip
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Keep `QuerySets` unevaluated as long as possible.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能保持`QuerySets`未评估。
- en: Migrations
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移
- en: Migrations help you to confidently make changes to your models. Introduced in
    Django 1.7, migrations are an essential and easy-to-use parts of a development
    workflow.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移帮助你自信地对模型进行更改。在Django 1.7中引入的迁移是开发工作流程中必不可少且易于使用的部分。
- en: 'The new workflow is essentially as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 新的工作流程基本上如下：
- en: 'The first time you define your model classes, you will need to run:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一次定义模型类时，你需要运行：
- en: '[PRE33]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will create migration scripts in `app/migrations` folder.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在`app/migrations`文件夹中创建迁移脚本。
- en: 'Run the following command `i`n the same (development) environment:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同（开发）环境中运行以下命令：
- en: '[PRE34]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will apply the model changes to the database. Sometimes, questions are
    asked to handle the default values, renaming, and so on.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把模型更改应用到数据库中。有时会有关于处理默认值、重命名等问题的提问。
- en: Propagate the migration scripts to other environments. Typically, your version
    control tool, for example Git, will take care of this. As the latest source is
    checked out, the new migration scripts will also appear.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将迁移脚本传播到其他环境。通常情况下，您的版本控制工具，例如Git，会处理这个问题。当最新的源代码被检出时，新的迁移脚本也会出现。
- en: 'Run the following command in these environments to apply the model changes:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些环境中运行以下命令以应用模型更改：
- en: '[PRE35]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Whenever you make changes to the models classes, repeat steps 1-5.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论何时您对模型类进行更改，都要重复步骤1-5。
- en: If you omit the app label in the commands, Django will find unapplied changes
    in every app and migrate them.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在命令中省略了应用标签，Django将会在每个应用中找到未应用的更改并进行迁移。
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Model design is hard to get it right. Yet, it is fundamental to Django development.
    In this chapter, we looked at several common patterns when working with models.
    In each case, we looked at the impact of the proposed solution and various tradeoffs.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 模型设计很难做到完美。然而，对于Django开发来说，这是基础性的。在本章中，我们看了几种处理模型时常见的模式。在每种情况下，我们都看了提议解决方案的影响以及各种权衡。
- en: In the next chapter, we will examine the common design patterns we encounter
    when working with views and URL configurations.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究在处理视图和URL配置时遇到的常见设计模式。
