- en: Appendix
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: About
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于
- en: This section is included to assist the students to perform the activities in
    the book. It includes detailed steps that are to be performed by the students
    to achieve the objectives of the activities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含帮助学生执行书中活动的说明。它包括学生为实现活动目标需要执行的详细步骤。
- en: '1: Your First Step'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '1: 第一步'
- en: 'Activity 1: Sending Requests to Our APIs Using Postman'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：使用Postman向我们的API发送请求
- en: '**Solution**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: First, we will get all of the recipes. Select `GET` as our `HTTP` method in
    the drop-down list.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将获取所有食谱。在下拉列表中选择我们的`HTTP`方法为**GET**。
- en: Enter the request URL `http://localhost:5000/recipes`.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入请求URL `http://localhost:5000/recipes`。
- en: 'Click the **Send** button. The result can be seen in the following screenshot:![Figure
    1.14: Getting all the recipes'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Send**按钮。结果可以在下述屏幕截图查看：![图1.14：获取所有食谱
- en: '](img/C15309_01_14.jpg)'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_01_14.jpg)'
- en: 'Figure 1.14: Getting all the recipes'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.14：获取所有食谱
- en: In the HTTP response, you will see the HTTP status **200 OK** in the top-right
    corner of the response panel. That means the request has been successful. The
    time next to it shows **7ms**, which is the time spent on the request. And the
    size of the response, including the header and body, is **322** bytes. The details
    of the recipes, in JSON format, are shown in the Body panel.
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在HTTP响应中，你将在响应面板右上角看到HTTP状态**200 OK**。这意味着请求已成功。旁边的显示**7ms**，这是请求花费的时间。响应的大小，包括头和体，是**322**字节。食谱的详细信息以JSON格式显示在Body面板中。
- en: Next, we are going to use the POST method to create a recipe. We will send an
    HTTP `http://localhost:5000/recipes`.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用POST方法创建一个食谱。我们将发送HTTP `http://localhost:5000/recipes`。
- en: Create a new tab next to the Get Request Tab by clicking on the `http://localhost:5000/recipes`
    as the request URL.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击`http://localhost:5000/recipes`作为请求URL，在Get请求标签旁边创建一个新标签页。
- en: Select the Body Tab. Also, select the **raw** radio button.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Body**标签页。同时，选择**raw**单选按钮。
- en: 'Choose **JSON (application/json)** in the right drop-down menu. Type the following
    data in JSON format in the **Body** content area. Click the **Send** button:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧下拉菜单中选择**JSON (application/json)**。在**Body**内容区域以JSON格式输入以下数据。点击**Send**按钮：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The result can be seen in the following screenshot:'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果显示在下述屏幕截图：
- en: '![Figure 1.15: Creating a recipe'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.15：创建食谱'
- en: '](img/C15309_01_15.jpg)'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_01_15.jpg)'
- en: 'Figure 1.15: Creating a recipe'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.15：创建食谱
- en: You should see the following information in the HTTP response in the Postman
    interface, Status **201** OK, meaning the creation has been successful and we
    can see our new recipe in JSON format. You will also notice that the ID assigned
    to the recipe is **3**.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该在Postman界面中的HTTP响应中看到以下信息，状态**201** OK，表示创建成功，我们可以看到我们的新食谱以JSON格式显示。你还会注意到分配给食谱的ID是**3**。
- en: Now, get all the recipes from the server application again. We want to see if
    we have three recipes there now. In the history panel, select our previous request
    that gets all recipes, clicks on it, and resends.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次从服务器应用程序获取所有食谱。我们想看看现在是否有三个食谱。在历史面板中，选择我们之前获取所有食谱的请求，点击它，并重新发送。
- en: 'In response, we can see that there are three recipes. They are shown in the
    following screenshot:'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 响应中，我们可以看到有三个食谱。它们显示在下述屏幕截图：
- en: '![Figure 1.16: Getting all the recipes from the server application'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.16：从服务器应用程序获取所有食谱'
- en: '](img/C15309_01_16.jpg)'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_01_16.jpg)'
- en: 'Figure 1.16: Getting all the recipes from the server application'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.16：从服务器应用程序获取所有食谱
- en: Then, modify the recipe that we have just created. To do this, create a new
    tab next to the **Get** Request Tab by clicking on the **+** button. Select **PUT**
    as the HTTP method.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，修改我们刚刚创建的食谱。为此，通过点击**+**按钮在**Get**请求标签旁边创建一个新标签页。选择**PUT**作为HTTP方法。
- en: Type in `http://localhost:5000/recipes/3` as the request URL.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`http://localhost:5000/recipes/3`作为请求URL输入。
- en: Select the **Body** Tab and then select the **raw** radio button.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Body**标签页，然后选择**raw**单选按钮。
- en: 'Choose `JSON (application/json)` in the right drop-down menu. Type the following
    data in JSON format in the **Body** content area. Click **Send**:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧下拉菜单中选择`JSON (application/json)`。在**Body**内容区域以JSON格式输入以下数据。点击**Send**：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result is shown in the following screenshot:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果显示在下述屏幕截图：
- en: '![Figure 1.17: Modifying the recipe'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.17：修改食谱'
- en: '](img/C15309_01_17.jpg)'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_01_17.jpg)'
- en: 'Figure 1.17: Modifying the recipe'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.17：修改食谱
- en: In the HTTP response, you will see the **200 OK** HTTP status, meaning the update
    has been successful. You can also see the time spent on the request in milliseconds.
    You should also see the size of the response (header and body). The content of
    the response is in JSON format. We can see our updated recipe here in JSON format.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在HTTP响应中，您将看到**200 OK**的HTTP状态，表示更新已成功。您还可以看到请求花费的时间（以毫秒为单位）。您还应看到响应的大小（头和体）。响应内容以JSON格式。我们可以在JSON格式中看到我们的更新后的食谱。
- en: Next, we will see if we can look for a recipe using its ID. We only want to
    see the recipe with ID **3** in the response. To do this, create a new tab next
    to the **Get Request** Tab by clicking on the **+** button.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将看看是否可以使用其ID来查找食谱。我们只想在响应中看到ID为**3**的食谱。为此，通过点击**+**按钮在**获取请求**标签旁边创建一个新标签页。
- en: Select `http://localhost:5000/recipes/3` as the request URL.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将请求URL选择为`http://localhost:5000/recipes/3`。
- en: 'Click **Send**. The result is shown in the following screenshot:![Figure 1.18:
    Looking for the recipe with ID'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送**。结果如下截图所示：![图1.18：查找具有ID的食谱
- en: '](img/C15309_01_18.jpg)'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.18：查找具有ID的食谱](img/C15309_01_18.jpg)'
- en: 'Figure 1.18: Looking for the recipe with ID'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.18：查找具有ID的食谱
- en: We can see in the response that only the recipe with ID **3** is returned. It
    has the modified details that we just set as well.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在响应中看到只返回了ID为**3**的食谱。它包含了我们刚刚设置的修改后的详细信息。
- en: 'When we search for a recipe that doesn''t exist, we will see the following
    response, with a message `http://localhost:5000/recipes/101` endpoint. The result
    is shown in the following screenshot:![Figure 1.19: Response showing "recipe not
    found"'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们搜索一个不存在的食谱时，我们将看到以下响应，其中包含消息`http://localhost:5000/recipes/101`端点。结果如下截图所示：![图1.19：显示“食谱未找到”的响应
- en: '](img/C15309_01_19.jpg)'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.19：显示“食谱未找到”的响应](img/C15309_01_19.jpg)'
- en: 'Figure 1.19: Response showing "recipe not found"'
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.19：显示“食谱未找到”的响应
- en: 'Activity 2: Implement and Test the delete_recipe Function'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动二：实现和测试delete_recipe函数
- en: '**Solution**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'The `delete_recipe` function removes a recipe from the memory. Use `recipe
    = next((recipe for recipe in recipes if recipe[''id''] == recipe_id), None)` to
    get the recipe with the specific ID:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`delete_recipe`函数从内存中删除食谱。使用`recipe = next((recipe for recipe in recipes if
    recipe[''id''] == recipe_id), None)`获取具有特定ID的食谱：'
- en: '[PRE2]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Similar to the `update_recipe` function shown in earlier, if you can't find
    the recipe, then return "`recipe not found`" together with HTTP status `NOT_FOUND`.
    Otherwise, we will go ahead and remove the recipe with the given ID from our recipe
    collection with HTTP status `204 No Content`
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前显示的`update_recipe`函数类似，如果您找不到食谱，则返回与HTTP状态`NOT_FOUND`一起的"`recipe not found`"。否则，我们将继续从我们的食谱集合中删除具有给定ID的食谱，HTTP状态为`204
    No Content`
- en: Once the code is done, *right-click* on the `app.py` file and click `run` to
    start the application. The Flask server will start up, and our application is
    ready to be tested.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码完成后，在`app.py`文件上**右键单击**并点击**运行**以启动应用程序。Flask服务器将启动，我们的应用程序准备进行测试。
- en: 'Use httpie or curl to delete the recipe with `ID = 1`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用httpie或curl删除ID为`1`的食谱：
- en: '[PRE3]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Following is the `curl` version of the command which does the same thing.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是与之前相同的命令的`curl`版本。
- en: '[PRE4]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `@app.route(''/recipes/<int:recipe_id>'', methods=[''DELETE''])` route
    will catch the client request and invoke the `delete_recipe(recipe_id)` function.
    The function will look for recipes with the `recipe_id` ID and, if it finds one,
    it will delete it. In response, we can see that the deletion has been successful.
    And we see that the HTTP status is `204 NO CONTENT`:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`@app.route(''/recipes/<int:recipe_id>'', methods=[''DELETE''])`路由将捕获客户端请求并调用`delete_recipe(recipe_id)`函数。该函数将查找具有`recipe_id`
    ID的食谱，如果找到，则将其删除。响应中我们可以看到删除操作已成功。并且我们看到HTTP状态是`204 NO CONTENT`：'
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Lastly, use Postman to delete the recipe with `ID = 2`. For that, create a new
    tab next to the **Get Request** Tab by clicking on the **+** button.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用Postman删除ID为`2`的食谱。为此，通过点击**+**按钮在**获取请求**标签旁边创建一个新标签页。
- en: Select `HTTP` method. Type in `http://localhost:5000/recipes/2` as the request
    URL.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**HTTP**方法。输入`http://localhost:5000/recipes/2`作为请求URL。
- en: 'Click **Send**. The result is shown in the following screenshot:![Figure 1.20:
    Deleting the recipe'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送**。结果如下截图所示：![图1.20：删除食谱
- en: '](img/C15309_01_20.jpg)'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.20：删除食谱](img/C15309_01_20.jpg)'
- en: 'Figure 1.20: Deleting the recipe'
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.20：删除食谱
- en: And then we can see the response with the HTTP status **204 NO CONTENT**. That
    means the recipe was successfully removed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以看到带有HTTP状态**204 NO CONTENT**的响应。这意味着食谱已被成功删除。
- en: '2: Starting to Build Our Project'
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2：开始构建我们的项目
- en: 'Activity 3: Testing the APIs Using Postman'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动3：使用Postman测试API
- en: '**Solution**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: First, build a client request that asks for a new recipe. Then, make use of
    the collection function in Postman to make the testing more efficient.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，构建一个客户端请求，请求一个新的食谱。然后，利用Postman中的集合功能使测试更高效。
- en: Click on the **Collection** tab and then create a new collection by clicking
    on **+**.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**集合**标签页，然后通过点击**+**创建一个新的集合。
- en: Type in **Smilecook** as the name and click **Create**.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入**Smilecook**作为名称并点击**创建**。
- en: '*Right-click* on **...** next to **Smilecook**, create a new folder under **Smilecook**,
    and type **Recipe** in the name field.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Smilecook**旁边的**...**上**右键单击**，在**Smilecook**下创建一个新的文件夹，并在名称字段中输入**Recipe**。
- en: '*Right-click* on **Recipe** to create a new request. Then, set the name to
    **RecipeList** and save it under the **Recipe** collection.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**食谱**上**右键单击**以创建一个新的请求。然后，将名称设置为**RecipeList**，并将其保存到**食谱**集合下。
- en: Select `http://localhost:5000/recipes` in the request URL field.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在请求URL字段中选择`http://localhost:5000/recipes`。
- en: 'Now, go to the `body` field:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到`body`字段：
- en: '[PRE6]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Save** and send the recipe. The result is shown in the following screenshot:![Figure
    2.10: Creating our first recipe by sending the details in JSON format'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**保存**并发送食谱。结果如下截图所示：![图2.10：通过发送JSON格式的详细信息创建我们的第一个食谱'
- en: '](img/C15309_02_10.jpg)'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_02_10.jpg)'
- en: 'Figure 2.10: Creating our first recipe by sending the details in JSON format'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.10：通过发送JSON格式的详细信息创建我们的第一个食谱
- en: In the HTTP response, you will see the HTTP status **201 Created**, meaning
    that the request was successful, and, in the body, you should see the same recipe
    that we just created. The ID of the recipe should be 1.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在HTTP响应中，您将看到HTTP状态**201 已创建**，表示请求成功，并且在正文中，您应该看到我们刚刚创建的相同食谱。食谱的ID应该是1。
- en: 'Create the second recipe by sending over a client request. Next, we will create
    our second recipe by sending the following details in JSON format:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过发送客户端请求创建第二个食谱。接下来，我们将通过以下JSON格式的详细信息创建第二个食谱：
- en: '[PRE7]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Click **Send**. The result is shown in the following screenshot:![Figure 2.11:
    Creating our second recipe by sending the details in JSON format'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送**。结果如下截图所示：![图2.11：通过发送JSON格式的详细信息创建我们的第二个食谱
- en: '](img/C15309_02_11.jpg)'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_02_11.jpg)'
- en: 'Figure 2.11: Creating our second recipe by sending the details in JSON format'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.11：通过发送JSON格式的详细信息创建我们的第二个食谱
- en: In the HTTP response, you will see the HTTP status **201 Created**, meaning
    that the request was successful, and, in the body, you should see the same recipe
    that we just created. The ID of the recipe should be 2.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在HTTP响应中，您将看到HTTP状态**201 已创建**，表示请求成功，并且在正文中，您应该看到我们刚刚创建的相同食谱。食谱的ID应该是2。
- en: So far, we have created two recipes. Let's retrieve these recipes using Postman
    and confirm whether the two recipes are in the application memory.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了两个食谱。让我们使用Postman检索这些食谱，并确认这两个食谱是否在应用程序内存中。
- en: Create a new request under the **Recipe** folder, name it **RecipeList**, and
    then save it.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**食谱**文件夹下创建一个新的请求，命名为**RecipeList**，然后保存。
- en: Select the **RecipeList** that we just created (the one with the HTTP method
    set to GET).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们刚刚创建的**RecipeList**（HTTP方法设置为GET）。
- en: Type `http://localhost:5000/recipes` in the request URL. Then, click `ID = 1`
    to published.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在请求URL中输入`http://localhost:5000/recipes`。然后，点击`ID = 1`以发布。
- en: Create a new request under the **Recipe** folder, and name it **RecipePublish**,
    and then save it.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**食谱**文件夹下创建一个新的请求，命名为**RecipePublish**，然后保存。
- en: Click on the **RecipePublish** request that we just created (the one with the
    HTTP method set to GET).
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击我们刚刚创建的**RecipePublish**请求（HTTP方法设置为GET）。
- en: 'Select `http://localhost:5000/recipes/1/publish` in the request URL. Then,
    click **Save** and send the request. The result is shown in the following screenshot:![Figure
    2.13: Retrieving the published recipe'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在请求URL中选择`http://localhost:5000/recipes/1/publish`。然后，点击**保存**并发送请求。结果如下截图所示：![图2.13：检索已发布的食谱
- en: '](img/C15309_02_13.jpg)'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_02_13.jpg)'
- en: 'Figure 2.13: Retrieving the published recipe'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.13：检索已发布的食谱
- en: In the HTTP response, you will see the HTTP status **204 NO CONTENT**, meaning
    that the request has been successfully published and that no data has been returned
    in the response body.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在HTTP响应中，您将看到HTTP状态**204 无内容**，表示请求已成功发布，并且响应正文中没有返回数据。
- en: 'Retrieve all the recipes using Postman again. Select `RecipeList` (`GET`) from
    the left-hand panel and send the request. The result is shown in the following
    screenshot:![Figure 2.14: Retrieving all the recipes using Postman'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用 Postman 获取所有食谱。从左侧面板中选择 `RecipeList` (`GET`) 并发送请求。结果如下截图所示：![图 2.14：使用
    Postman 获取所有食谱](img/C15309_02_14.jpg)
- en: '](img/C15309_02_14.jpg)'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_02_14.jpg)'
- en: 'Figure 2.14: Retrieving all the recipes using Postman'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2.14：使用 Postman 获取所有食谱
- en: In the HTTP response, you will see the HTTP status `localhost:5000/recipes/1`.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 HTTP 响应中，您将看到 `localhost:5000/recipes/1`。
- en: Create a new request under the `http://localhost:5000/recipes/1` in the request
    URL.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在请求 URL 下的 `http://localhost:5000/recipes/1` 下创建一个新的请求。
- en: 'Now, go to the **Body** tab and select raw, choose **JSON (application/json)**
    from the drop-down menu, and insert the following code into the body field. This
    is the modified recipe:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到 **主体** 选项卡，选择原始，从下拉菜单中选择 **JSON (application/json)**，并将以下代码插入到主体字段中。这是修改后的食谱：
- en: '[PRE8]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Save** and send it. The result is shown in the following screenshot:![Figure
    2.15: Modifying the recipe with ID 1'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**保存**并发送它。结果如下截图所示：![图 2.15：修改 ID 为 1 的食谱](img/C15309_02_14.jpg)'
- en: '](img/C15309_02_15.jpg)'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_02_15.jpg)'
- en: 'Figure 2.15: Modifying the recipe with ID 1'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2.15：修改 ID 为 1 的食谱
- en: In the HTTP response, you will see the HTTP status **200 OK**, meaning that
    the modification was successful. The body should contain the updated details of
    recipe 1 in JSON format. We will retrieve the recipe with ID 1.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 HTTP 响应中，您将看到 HTTP 状态 **200 OK**，表示修改成功。正文应包含以 JSON 格式更新的食谱 1 的详细信息。我们将检索
    ID 为 1 的食谱。
- en: Create a new request under the `http://localhost:5000/recipes/1` in the request
    URL.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在请求 URL 下的 `http://localhost:5000/recipes/1` 下创建一个新的请求。
- en: '**Save** and send it. The result is shown in the following screenshot:![Figure
    2.16: Retrieving the recipe with ID 1'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**保存**并发送它。结果如下截图所示：![图 2.16：检索 ID 为 1 的食谱](img/C15309_02_16.jpg)'
- en: '](img/C15309_02_16.jpg)'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_02_16.jpg)'
- en: 'Figure 2.16: Retrieving the recipe with ID 1'
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2.16：检索 ID 为 1 的食谱
- en: In the HTTP response, you will see the HTTP status `recipe 1` in JSON format.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 响应中，您将看到以 JSON 格式的 `recipe 1`。
- en: 'Activity 4: Implementing the Delete Recipe Function'
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 4：实现删除食谱功能
- en: '**Solution**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Add the `delete` function to `RecipeResource`. Implement the `delete` method
    by following the sample code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `delete` 函数添加到 `RecipeResource`。通过以下示例代码实现 `delete` 方法：
- en: '[PRE9]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The third method we built here has been deleted. We do this by locating the
    recipe with the respective recipe ID and then remove it from the recipe list.
    Finally, we return the HTTP status **204 NO CONTENT**.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里我们构建的第三个方法已被删除。我们通过定位具有相应食谱 ID 的食谱并将其从食谱列表中删除来实现这一点。最后，我们返回 HTTP 状态 **204
    无内容**。
- en: '*Right-click* on the `app.py` file and click **run** to start the application.
    The Flask server will start up and our application will be ready for testing.
    Now, create the first recipe using Postman. We will build a client request that
    asks for a new recipe.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `app.py` 文件并单击 **运行** 以启动应用程序。Flask 服务器将启动，我们的应用程序将准备好测试。现在，使用 Postman
    创建第一个食谱。我们将构建一个客户端请求，请求一个新的食谱。
- en: 'First, select the **RecipeList POST** request. Now, send the request by clicking
    the **Send** button, as shown in the following screenshot:![Figure 2.17: Creating
    the first recipe using Postman'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，选择 **RecipeList POST** 请求。现在，通过单击以下截图所示的 **发送** 按钮发送请求：![图 2.17：使用 Postman
    创建第一个食谱](img/C15309_02_17.jpg)
- en: '](img/C15309_02_17.jpg)'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_02_17.jpg)'
- en: 'Figure 2.17: Creating the first recipe using Postman'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2.17：使用 Postman 创建第一个食谱
- en: Now, we will delete a recipe using Postman. To do that, delete the recipe with
    ID 1.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用 Postman 删除一个食谱。为此，删除 ID 为 1 的食谱。
- en: Create a new request under the **Recipe** folder. Then, set the **Request Name**
    to **Recipe** and **save** it.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Recipe** 文件夹下创建一个新的请求。然后，将 **请求名称** 设置为 **Recipe** 并 **保存**。
- en: 'Change the `HTTP` method to `DELETE` and type `http://localhost:5000/recipes/1`
    in the request URL. Then, save and send the request. The result is shown in the
    following screenshot:![Figure 2.18: Deleting a recipe using Postman'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `HTTP` 方法更改为 `DELETE` 并在请求 URL 中输入 `http://localhost:5000/recipes/1`。然后，保存并发送请求。结果如下截图所示：![图
    2.18：使用 Postman 删除食谱](img/C15309_02_18.jpg)
- en: '](img/C15309_02_18.jpg)'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_02_18.jpg)'
- en: 'Figure 2.18: Deleting a recipe using Postman'
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2.18：使用 Postman 删除食谱
- en: 'In the HTTP response, you will see the HTTP status `RecipeResource` class in
    this activity:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 响应中，您将看到 `RecipeResource` 类在此活动中的状态：
- en: '![Figure 2.19: The method that we built for the RecipeResource class'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.19：为 RecipeResource 类构建的方法](img/C15309_02_17.jpg)'
- en: '](img/C15309_02_19.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C15309_02_19.jpg)'
- en: 'Figure 2.19: The method that we built for the RecipeResource class'
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '![图 2.19：为 RecipeResource 类构建的方法'
- en: '3: Manipulating a Database with SQLAlchemy'
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3：使用 SQLAlchemy 操作数据库
- en: 'Activity 5: Creating a User and a Recipe'
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动五：创建用户和菜谱
- en: '**Solution**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Open the Python console at the bottom of PyCharm and type in the following
    code to import the necessary modules and classes:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PyCharm 底部的 Python 控制台中输入以下代码以导入必要的模块和类：
- en: '[PRE10]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a `user` object and save that to the database by typing in the following
    code in the Python console:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Python 控制台中输入以下代码创建一个 `user` 对象并将其保存到数据库中：
- en: '[PRE11]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we will create two recipes using the following code. One thing to note
    is the fact that the `user_id` attribute of the recipe is set to `user.id`. This
    is to indicate that the recipe was created by the user `Peter`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用以下代码创建两个菜谱。需要注意的是，菜谱的 `user_id` 属性被设置为 `user.id`。这是为了表明菜谱是由用户 `Peter`
    创建的：
- en: '[PRE12]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can see a new record there in the `user` table:![Figure 3.18: New record
    in the user table'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在 `user` 表中看到一条新记录：![图 3.18：用户表中的新记录
- en: '](img/C15309_03_18.jpg)'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C15309_03_18.jpg]'
- en: 'Figure 3.18: New record in the user table'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: '![图 3.18：用户表中的新记录'
- en: 'We will then check whether the two recipes have been created in the database![Figure
    3.19: Checking whether the two recipes have been created'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将检查两个菜谱是否已在数据库中创建![图 3.19：检查两个菜谱是否已创建
- en: '](img/C15309_03_19.jpg)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C15309_03_19.jpg]'
- en: ':'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ':'
- en: 'Figure 3.19: Checking whether the two recipes have been created'
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '![图 3.19：检查两个菜谱是否已创建'
- en: 'Activity 6: Upgrading and Downgrading a Database'
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动六：升级和降级数据库
- en: '**Solution**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Add a new attribute to the `user` class:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `user` 类添加一个新属性：
- en: '[PRE13]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, run the `flask db migrate` command to create the database and tables:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行 `flask db migrate` 命令来创建数据库和表：
- en: '[PRE14]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Flask-Migrate detected the new column and created a script for that:'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Flask-Migrate 检测到新列并为此创建了脚本：
- en: '[PRE15]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, check `/migrations/versions/6971bd62ec60_.py` under the `versions` folder.
    This file is created by Flask-Migrate. Note that you may get a different revision
    ID here. Please review the file before you run the `flask db upgrade` command.
    That''s because, sometimes, it may not detect every change you make to your models:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查 `versions` 文件夹下的 `/migrations/versions/6971bd62ec60_.py`。此文件由 Flask-Migrate
    创建。请注意，您可能在这里获得不同的修订ID。请在运行 `flask db upgrade` 命令之前检查该文件。这是因为有时它可能无法检测到您对模型所做的每个更改：
- en: '[PRE16]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There are two functions in this autogenerated file; one is upgraded, and this
    is to add the new recipe and user to the table, while the other is downgraded,
    which is to go back to the previous version.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个自动生成的文件中有两个函数；一个用于升级，这是为了将新的菜谱和用户添加到表中，另一个用于降级，即回到之前的版本。
- en: 'We will then execute the `flask db upgrade` command, which will upgrade our
    database to conform with the latest specification in our models:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将执行 `flask db upgrade` 命令，这将使我们的数据库升级以符合模型中的最新规范：
- en: '[PRE17]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This command will invoke `upgrade()` to upgrade the database:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将调用 `upgrade()` 来升级数据库：
- en: '[PRE18]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Check whether the new field is created in the database. Go to **smilecook**
    >> **Schemas** >> **Tables** >> **user** >> **Properties to verify**:![Figure
    3.20: Checking whether the new field has been created in the database'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查新字段是否已在数据库中创建。转到 **smilecook** >> **Schemas** >> **Tables** >> **user** >>
    **Properties** 进行验证：![图 3.20：检查新字段是否已在数据库中创建
- en: '](img/C15309_03_20.jpg)'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C15309_03_20.jpg]'
- en: 'Figure 3.20: Checking whether the new field has been created in the database'
  id: totrans-162
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '![图 3.20：检查新字段是否已在数据库中创建'
- en: 'Run the `downgrade` command to remove the new field:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `downgrade` 命令删除新字段：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This command will invoke `downgrade()` to downgrade the database:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将调用 `downgrade()` 来降级数据库：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Check whether the field has been removed. Go to **smilecook** → **Schemas**
    → **Tables** → **user** → **Properties to verify**:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 检查字段是否已被删除。转到 **smilecook** → **Schemas** → **Tables** → **user** → **Properties**
    进行验证：
- en: '![Figure 3.21: Checking whether the field has been removed from the database'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.21：检查字段是否已从数据库中删除'
- en: '](img/C15309_03_21.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C15309_03_21.jpg]'
- en: 'Figure 3.21: Checking whether the field has been removed from the database'
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '![图 3.21：检查字段是否已从数据库中删除'
- en: '4: Authenticated Services and Security with JWTs'
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4：使用 JWTs 进行认证服务和安全性
- en: 'Activity 7: Implementing Access Control on the publish/unpublish Recipe Function'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动七：在发布/取消发布菜谱功能上实现访问控制
- en: '**Solution**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Modify the `put` method in `RecipePublishResource` to restrict access to only
    authenticated users. In `resources/token.py`, add the `@jwt_required` decorator
    on top of the `RecipePublishResource.put` method. Use the `get_jwt_identity()`
    function to identify whether the authenticated user is the owner of the recipe:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`RecipePublishResource`中的`put`方法，以限制只有认证用户才能访问。在`resources/token.py`中，在`RecipePublishResource.put`方法上方添加`@jwt_required`装饰器。使用`get_jwt_identity()`函数来识别认证用户是否是食谱的所有者：
- en: '[PRE21]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is to publish the recipe. Only users who have logged in can publish their
    own recipes. The method will perform various checks to make sure the user has
    published privileges. It will return **204 NO_CONTENT** once the recipe is published.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是为了发布食谱。只有已登录的用户可以发布他们自己的食谱。该方法将执行各种检查以确保用户有发布权限。一旦食谱发布，它将返回**204 NO_CONTENT**。
- en: 'Modify the `delete` method in `RecipePublishResource`. Only an authenticated
    user can unpublish the recipe:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`RecipePublishResource`中的`delete`方法。只有认证用户才能取消发布食谱：
- en: '[PRE22]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This unpublishes the recipe. Similar to the previous code, only a user who has
    logged in can unpublish their own recipe. It will return the **status** code **204
    NO_CONTENT** once the recipe is published.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将取消发布食谱。类似于之前的代码，只有已登录的用户可以取消发布他们自己的食谱。一旦食谱发布，它将返回**状态码** **204 NO_CONTENT**。
- en: Log in to the user account and get the access token. Select the **POST** token
    request that we created previously.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录用户账户并获取访问令牌。选择我们之前创建的**POST**令牌请求。
- en: 'Check the **raw** radio button and select **JSON (application/json)** from
    the drop-down menu. Type in the following JSON content in the **Body** field:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**raw**单选按钮，并从下拉菜单中选择**JSON (application/json)**。在**Body**字段中输入以下JSON内容：
- en: '[PRE23]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Click **Send** to log in to the account. The result is shown in the following
    screenshot:![Figure 4.20: Log in to the user account'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Send**以登录账户。结果如下所示：![图4.20：登录用户账户
- en: '](img/C15309_04_20.jpg)'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_04_20.jpg)'
- en: 'Figure 4.20: Log in to the user account'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.20：登录用户账户
- en: You will see the HTTP **status** code **200 OK**, meaning the login is successful.
    And we can see the **access token** and **refresh token** in the response body.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将看到HTTP **状态码** **200 OK**，表示登录成功。我们可以在响应体中看到**访问令牌**和**刷新令牌**。
- en: Publish the recipe with `id = 3` in the state that the user has logged in. Select
    **PUT RecipePublish**.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户登录状态下发布`id = 3`的食谱。选择**PUT RecipePublish**。
- en: Go to the `Bearer {token}` in the **VALUE** field, where token is the JWT token
    we got in our previous step.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**VALUE**字段中的`Bearer {token}`，其中token是我们之前步骤中获得的JWT令牌。
- en: 'Click **Send** to publish the recipe. The result is shown in the following
    screenshot:![Figure 4.21: Publishing the recipe'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Send**以发布食谱。结果如下所示：![图4.21：发布食谱
- en: '](img/C15309_04_21.jpg)'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_04_21.jpg)'
- en: 'Figure 4.21: Publishing the recipe'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.21：发布食谱
- en: You will then see the response, the HTTP **status** code **204** meaning the
    recipe has been published successfully.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，您将看到响应，HTTP **状态码** **204**表示食谱已成功发布。
- en: 'Finally, try to get all published recipes. Select **GET RecipeList** request,
    then click **Send** to get all published recipe details. The result is shown in
    the following screenshot:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，尝试获取所有已发布的食谱。选择**GET RecipeList**请求，然后点击**Send**以获取所有已发布食谱的详细信息。结果如下所示：
- en: '![Figure 4.22: Retrieving all published recipes'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.22：检索所有已发布的食谱'
- en: '](img/C15309_04_22.jpg)'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_04_22.jpg)'
- en: 'Figure 4.22: Retrieving all published recipes'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.22：检索所有已发布的食谱
- en: You will then see the response, the HTTP **status** code **200** meaning the
    request is successfully, and you can see there is one published recipe that we
    created is returned.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，您将看到响应，HTTP **状态码** **200**表示请求成功，您可以看到我们创建的一个已发布的食谱被返回。
- en: Unpublish the recipe with `id = 3` in the state that the user has logged in.
    Create a new request under the **Recipe** folder, and name it **RecipePublish**,
    and then save it.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户登录状态下取消发布`id = 3`的食谱。在**Recipe**文件夹下创建一个新的请求，命名为**RecipePublish**，然后保存。
- en: Click on the **RecipePublish** request that we just created (the one with the
    HTTP method set to **GET**).
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击我们刚刚创建的**RecipePublish**请求（HTTP方法设置为**GET**）。
- en: Select `http://localhost:5000/recipes/3/publish` in the request URL.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在请求URL中选择`http://localhost:5000/recipes/3/publish`。
- en: Go to the `Bearer {token}` in the **VALUE** field, where token is the JWT token
    we got in *step 5*.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**VALUE**字段中的`Bearer {token}`，其中token是我们第5步中获得的JWT令牌。
- en: '**Save** and **Send** the request to unpublish. The result is shown in the
    following screenshot:![Figure 4.23: Unpublishing the recipe'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**保存** 并 **发送** 取消发布的请求。结果如下所示：![图 4.23：取消发布菜谱'
- en: '](img/C15309_04_23.jpg)'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C15309_04_23.jpg]'
- en: 'Figure 4.23: Unpublishing the recipe'
  id: totrans-204
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.23：取消发布菜谱
- en: '5: Validating APIs Using marshmallow'
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5：使用 marshmallow 验证 API
- en: 'Activity 8: Serializing the recipe Object Using marshmallow'
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动八：使用 marshmallow 序列化菜谱对象
- en: '**Solution**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Modify the recipe schema to include all attributes except for `email`. In `schemas/recipe.py`,
    modify `only=[''id'', ''username''] to exclude=(''email'', )`. This way, we will
    be showing everything except for the user''s email address. Besides, if we have
    a new attribute for the `recipe` object in the future (for example, a `user avatar`
    URL), we won''t need to modify the schema again because it will show everything:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改菜谱模式以包含除 `email` 之外的所有属性。在 `schemas/recipe.py` 中，将 `only=['id', 'username']`
    修改为 `exclude=('email', )`。这样，我们将显示除用户的电子邮件地址之外的所有内容。此外，如果我们将来为 `recipe` 对象添加新的属性（例如，`user
    avatar` URL），我们就不需要再次修改模式，因为它将显示所有内容：
- en: '[PRE24]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Modify the `get` method in `RecipeResource` to serialize the `recipe` object
    into JSON format using the recipe schema:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `RecipeResource` 中的 `get` 方法，使用菜谱模式将 `recipe` 对象序列化为 JSON 格式：
- en: '[PRE25]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is mainly to modify the code to use `recipe_schema.dump(recipe).data` to
    return the recipe details by using the recipe schema.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这主要是为了修改代码以使用 `recipe_schema.dump(recipe).data` 通过菜谱模式返回菜谱详情。
- en: 'Right-click on it to run the application. Flask will then be started up and
    run on the localhost (`127.0.0.1`) at port `5000`:![Figure 5.18: Run Flask on
    the localhost'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击以运行应用程序。Flask 将启动并在本地主机（`127.0.0.1`）的端口 `5000` 上运行：![图 5.18：在本地主机上运行 Flask
- en: '](img/C15309_05_18.jpg)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C15309_05_18.jpg]'
- en: 'Figure 5.18: Run Flask on the localhost'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.18：在本地主机上运行 Flask
- en: 'Test the implementation by getting one specific published recipe in Postman.
    Select the `http://localhost:5000/recipes/4` in **Enter request URL**. Click **Send**
    to get specific recipe details. The result is shown in the following screenshot:![Figure
    5.19: Select the GET Recipe request and send the request'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 Postman 获取一个特定的已发布菜谱来测试实现。在 **输入请求 URL** 中选择 `http://localhost:5000/recipes/4`。点击
    **发送** 以获取特定的菜谱详情。结果如下所示：![图 5.19：选择 GET 菜谱请求并发送请求
- en: '](img/C15309_05_19.jpg)'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C15309_05_19.jpg]'
- en: 'Figure 5.19: Select the GET Recipe request and send the request'
  id: totrans-218
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.19：选择 GET 菜谱请求并发送请求
- en: You will then see the return response. The HTTP status code `created_at`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到返回的响应。HTTP 状态码 `created_at`。
- en: '6: Email Confirmations'
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6：电子邮件确认
- en: 'Activity 9: Testing the Complete User Registration and Activation Workflow'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动九：测试完整的用户注册和激活工作流程
- en: '**Solution**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: We will first register a new user through Postman. Click on the **Collections**
    tab and choose the **POST UserList** request.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先通过 Postman 注册一个新用户。点击 **集合** 选项卡并选择 **POST UserList** 请求。
- en: Select the **Body** tab and then select the **raw** radio button and choose
    **JSON (application/json)** from the drop-down list.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **主体** 选项卡，然后选择 **原始** 单选按钮，并从下拉列表中选择 **JSON (application/json)**。
- en: 'Put in the following user details (in JSON format) in the **Body** field. Change
    the username and password to the appropriate one:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **主体** 字段中输入以下用户详情（JSON 格式）。将用户名和密码更改为适当的值：
- en: '[PRE26]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Send the request. You should see the following output:![Figure 6.10: Registering
    a user through Postman'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求。你应该看到以下输出：![图 6.10：通过 Postman 注册用户
- en: '](img/C15309_06_10.jpg)'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C15309_06_10.jpg]'
- en: 'Figure 6.10: Registering a user through Postman'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.10：通过 Postman 注册用户
- en: You should see the new user details (**ID = 4**) in the response, with **HTTP
    status 201 OK**. That means the new user was created successfully in the backend.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该在响应中看到新的用户详情（**ID = 4**），HTTP 状态为 **201 OK**。这意味着新用户在后台已成功创建。
- en: Log in through the API and click on the **Collections** tab. Then, select the
    **POST Token** request we created before.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 API 登录并点击 **集合** 选项卡。然后，选择我们之前创建的 **POST Token** 请求。
- en: Now, click on the **Body** tab. Check the **raw** radio button and select **JSON(application/json)**
    from the drop-down menu.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击 **主体** 选项卡。检查 **原始** 单选按钮，并从下拉菜单中选择 **JSON(application/json)**。
- en: 'Type in the following JSON content (email and password) in the **Body** field:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **主体** 字段中输入以下 JSON 内容（电子邮件和密码）：
- en: '[PRE27]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Send the request. You should see the following output:![Figure 6.11: Sending
    the request using JSON'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求。你应该看到以下输出：![图 6.11：使用 JSON 发送请求
- en: '](img/C15309_06_11.jpg)'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C15309_06_11.jpg]'
- en: 'Figure 6.11: Sending the request using JSON'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.11：使用 JSON 发送请求
- en: You should get a message saying the user account is not activated yet, with
    **HTTP status 403 Forbidden**. This is expected behavior because our application
    would require the user to activate the account first.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该收到一条消息，说明用户账户尚未激活，HTTP 状态为 **403 禁止**。这是预期行为，因为我们的应用程序会要求用户首先激活账户。
- en: 'Please check your mailbox for the activation email. There should be a link
    there for you to activate the user''s account. Click on that link to activate
    the account. It should look as follows:![Figure 6.12: Activation mail'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请检查您的邮箱以获取激活邮件。那里应该有一个链接供您激活用户账户。点击该链接以激活账户。它应该看起来如下：![图 6.12：激活邮件
- en: '](img/C15309_06_12.jpg)'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_06_12.jpg)'
- en: 'Figure 6.12: Activation mail'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.12：激活邮件
- en: Log in again after the account is activated. Click on the **Collections** tab.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 账户激活后，请重新登录。点击**收藏**标签页。
- en: 'Select the **POST Token** request that we created earlier and send the request.
    You''ll see the following:![Figure 6.13: After activating the account, select
    the POST Token request'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们之前创建的 **POST Token** 请求并发送请求。您将看到以下内容：![图 6.13：激活账户后，选择 POST 令牌请求
- en: '](img/C15309_06_13.jpg)'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_06_13.jpg)'
- en: 'Figure 6.13: After activating the account, select the POST Token request'
  id: totrans-245
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.13：激活账户后，选择 POST 令牌请求
- en: You should see the access token and the refresh token in the response, with
    HTTP status **200 OK**. That means the login was successful.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在响应中看到访问令牌和刷新令牌，HTTP 状态为 **200 OK**。这意味着登录成功。
- en: 'Activity 10: Creating the HTML Format User Account Activation Email'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 10：创建 HTML 格式用户账户激活邮件
- en: '**Solution**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Click `Mailgun` dashboard, then add the email of our new user to the authorized
    recipient list on the right. `Mailgun` will then send a confirmation email to
    that email address:![Figure 6.14: Sending a confirmation email to our new user'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `Mailgun` 控制台，然后在右侧将我们新用户的电子邮件添加到授权收件人列表中。`Mailgun` 将然后向该电子邮件地址发送确认邮件：![图
    6.14：向我们的新用户发送确认邮件
- en: '](img/C15309_06_14.jpg)'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_06_14.jpg)'
- en: 'Figure 6.14: Sending a confirmation email to our new user'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.14：向我们的新用户发送确认邮件
- en: Note
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Since we are using the sandbox version of `Mailgun`, there is a limitation on
    sending out emails to external email addresses. These emails have to be added
    to the authorized recipient list first.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们使用的是 `Mailgun` 的沙盒版本，向外部电子邮件地址发送电子邮件有限制。这些电子邮件必须首先添加到授权收件人列表中。
- en: 'Check the mailbox of the new user, and click **I Agree**. This will be as shown
    in the following screenshot:![Figure 6.15: The mailbox of a new user with an email
    from Mailgun'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查新用户的邮箱，并点击**我同意**。这将在以下屏幕截图中显示：![图 6.15：新用户邮箱中的 Mailgun 邮件
- en: '](img/C15309_06_15.jpg)'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_06_15.jpg)'
- en: 'Figure 6.15: The mailbox of a new user with an email from Mailgun'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.15：新用户邮箱中的 Mailgun 邮件
- en: 'On the confirmation page, click **yes** to activate the account. The screen
    will appear as follows:![Figure 6.16: Activation complete message'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在确认页面上，点击**是**以激活账户。屏幕将显示如下：![图 6.16：激活完成消息
- en: '](img/C15309_06_16.jpg)'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_06_16.jpg)'
- en: 'Figure 6.16: Activation complete message'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.16：激活完成消息
- en: 'HTML template code is provided by `Mailgun` out of the box. We can find it
    under **Sending > Templates**. There, click **Create Message Template** and select
    **Action template**. We will find a template for a confirmation email and preview
    it:![Figure 6.17: Previewing the confirm email address template'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Mailgun` 默认提供 HTML 模板代码。我们可以在**发送 > 模板**下找到它。在那里，点击**创建消息模板**并选择**操作模板**。我们将找到一个确认邮件模板并预览它：![图
    6.17：预览确认邮件地址模板'
- en: '](img/C15309_06_17.jpg)'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_06_17.jpg)'
- en: 'Figure 6.17: Previewing the confirm email address template'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.17：预览确认邮件地址模板
- en: Then, create a **templates** folder under our project. We will put all the HTML
    templates in this folder going forward. Inside the **templates** folder, create
    a subfolder, **email**, for email-related HTML templates.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在我们项目的**templates**文件夹下创建一个**templates**文件夹。从现在起，我们将把所有的 HTML 模板放在这个文件夹中。在**templates**文件夹内部，为与电子邮件相关的
    HTML 模板创建一个子文件夹，**email**。
- en: 'Now, create a template file, `confirmation.html`, and paste the sample HTML
    code from `Mailgun` in *step 4*. Take a look at the sample HTML code from `Mailgun`
    that follows:![Figure 6.18: Sample HTML code from Mailgun'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个模板文件，`confirmation.html`，并将 `Mailgun` 在 *步骤 4* 中的示例 HTML 代码粘贴进去。看看以下
    `Mailgun` 的示例 HTML 代码：![图 6.18：来自 Mailgun 的示例 HTML 代码
- en: '](img/C15309_06_18.jpg)'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_06_18.jpg)'
- en: 'Figure 6.18: Sample HTML code from Mailgun'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.18：来自 Mailgun 的示例 HTML 代码
- en: Note
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Please note that we need to change the [http://www.mailgun.com](http://www.mailgun.com)
    link to `{{link}}`. This placeholder will be replaced programmatically with the
    account activation link.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，我们需要将[http://www.mailgun.com](http://www.mailgun.com)链接更改为`{{link}}`。此占位符将被程序性地替换为账户激活链接。
- en: 'Import the `render_template` function from Flask by entering the following
    line of code in `resources/user.py`:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resources/user.py`中通过输入以下代码行从Flask导入`render_template`函数：
- en: '[PRE28]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `send_mail` method. The HTML code can be rendered using the `render_template`
    function. You can see that the `link = link` parameter here is to replace the
    `{{link}}` placeholder in the HTML template with the actual account validation
    link:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`send_mail`方法中。可以使用`render_template`函数渲染HTML代码。你可以看到这里的`link = link`参数是为了将HTML模板中的`{{link}}`占位符替换为实际的账户验证链接：
- en: '[PRE29]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Register a new account using Postman:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Postman注册新账户：
- en: '[PRE30]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 备注
- en: Please note that the email address was validated in `Mailgun` beforehand.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，在`Mailgun`中事先验证了电子邮件地址。
- en: 'The output will be as follows:'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 6.19: Registering a new account using Postman'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.19：使用Postman注册新账户'
- en: '](img/C15309_06_19.jpg)'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_06_19.jpg)'
- en: 'Figure 6.19: Registering a new account using Postman'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.19：使用Postman注册新账户
- en: 'The account activation email will then be received in HTML format. The output
    is shown in the following screenshot:![Figure 6.20: Account confirmation email'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 账户激活邮件将以HTML格式接收。输出如下截图所示：![图6.20：账户确认邮件
- en: '](img/C15309_06_20.jpg)'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_06_20.jpg)'
- en: 'Figure 6.20: Account confirmation email'
  id: totrans-283
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.20：账户确认邮件
- en: '7: Working with Images'
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7：处理图像
- en: 'Activity 11: Implementing the Recipe Cover Image Upload Function'
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动11：实现食谱封面图像上传功能
- en: '**Solution**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Add the `cover_image` attribute to the User model in `models/recipe.py`:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`models/recipe.py`模型中添加`cover_image`属性：
- en: '[PRE31]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `cover_image` attribute will contain the image filename as a string, with
    a maximum length of 100 characters.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`cover_image`属性将包含图像文件名作为字符串，最大长度为100个字符。'
- en: 'Use the flask db migrate command to generate a database table update script:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`flask db migrate`命令生成数据库表更新脚本：
- en: '[PRE32]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You will see that a new column, `''recipe.cover_image''`, has been detected:'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到检测到一个新列，`'recipe.cover_image'`：
- en: '[PRE33]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Check the script at `/migrations/versions/xxxxxxxxxx_.py`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/migrations/versions/xxxxxxxxxx_.py`检查脚本：
- en: '[PRE34]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: From its content, we can see that two functions have been generated in the script.
    The `upgrade` function is used to add the new `cover_image` column to the database
    table, while the `downgrade` function is used to remove the `cover_image` column
    so that it goes back to its original state.
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从其内容中，我们可以看到脚本中生成了两个函数。`upgrade`函数用于将新的`cover_image`列添加到数据库表中，而`downgrade`函数用于删除`cover_image`列，使其恢复到原始状态。
- en: 'Run the `flask db upgrade` command to update the database and reflect the change
    in the **User** model:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`flask db upgrade`命令以更新数据库并反映**User**模型中的更改：
- en: '[PRE35]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After running the preceding command, we should see the following output:'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行上述命令后，我们应该看到以下输出：
- en: '[PRE36]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Check the new `cover_image` column in pgAdmin:![Figure 7.10: The cover_image
    column in pgAdmin'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在pgAdmin中检查新的`cover_image`列：![图7.10：pgAdmin中的cover_image列
- en: '](img/C15309_07_10.jpg)'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_07_10.jpg)'
- en: 'Figure 7.10: The cover_image column in pgAdmin'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.10：pgAdmin中的cover_image列
- en: This confirms that the new `cover_image` column has been added to the recipe
    table.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这确认了新的`cover_image`列已添加到食谱表中。
- en: 'In `schemas/recipe.py`, import the `url_for` package and add the `cover_url`
    attribute and the `dump_cover_url` method:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`schemas/recipe.py`中，导入`url_for`包并添加`cover_url`属性和`dump_cover_url`方法：
- en: '[PRE37]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the `default-recipe-cover.jpg` image to `static/images`:'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将`default-recipe-cover.jpg`图像添加到`static/images`：
- en: '![Figure 7.11: Folder structure after adding default-recipe-cover.jpg'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.11：添加default-recipe-cover.jpg后的文件夹结构'
- en: '](img/C15309_07_11.jpg)'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_07_11.jpg)'
- en: 'Figure 7.11: Folder structure after adding default-recipe-cover.jpg'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.11：添加`default-recipe-cover.jpg`后的文件夹结构
- en: 'In `resources/recipe.py`, add the import `os`, `image_set`, and `save_image`
    functions:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resources/recipe.py`中，添加导入`os`、`image_set`和`save_image`函数：
- en: '[PRE38]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In `resources/recipe.py`, add the `RecipeCoverUpload` resource to upload the
    recipe cover to the recipes folder:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resources/recipe.py`中，添加`RecipeCoverUpload`资源以将食谱封面上传到食谱文件夹：
- en: '[PRE39]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `@jwt_required` decorator before the `PUT` method states that the method
    can only be called after the user logs in. In the `PUT` method, we are trying
    to get the cover image file in `request.files`. Then, we are trying to verify
    whether it exists and whether the file extension is permitted.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PUT`方法之前的`@jwt_required`装饰器表示该方法只能在用户登录后调用。在`PUT`方法中，我们试图在`request.files`中获取封面图片文件。然后，我们试图验证它是否存在以及文件扩展名是否允许。'
- en: 'After that, we retrieved the recipe object using `recipe_id`. First, we check
    whether a user has the right to modify the recipe. If the user has the right to,
    we will go ahead and modify the cover image of the recipe:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们使用`recipe_id`检索菜谱对象。首先，我们检查用户是否有修改菜谱的权限。如果有，我们将继续修改菜谱的封面图片：
- en: '[PRE40]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we use the `save_image` function to save the uploaded image and set the
    `recipe.cover_image = filename`. Finally, we save the recipe using `recipe.save()`
    and return the image URL with an HTTP status code of **200**:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`save_image`函数保存上传的图像并将`recipe.cover_image = filename`设置为菜谱的封面图像。最后，我们使用`recipe.save()`保存菜谱，并返回带有HTTP状态码**200**的图像URL：
- en: '[PRE41]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In `app.py`, import RecipeCoverUploadResource:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.py`中导入`RecipeCoverUploadResource`：
- en: '[PRE42]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In `app.py`, link `RecipeCoverUploadResource` to the route, that is, `/recipes/<int:recipe_id>/cover`:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.py`中，将`RecipeCoverUploadResource`链接到路由，即`/recipes/<int:recipe_id>/cover`：
- en: '[PRE43]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, we have created the function for uploading the recipe cover image. Let's
    move on and test it.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了上传菜谱封面图像的功能。让我们继续并测试它。
- en: 'Activity 12: Testing the Image Upload Function'
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动十二：测试图像上传功能
- en: '**Solution**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Log in to the user account using Postman. Click on the **Collections** tab
    and select the **POST Token** request. Then, click the **Send** button. The result
    can be seen in the following screenshot:![Figure 7.12: Sending a POST Token request'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Postman登录用户账户。点击**集合**选项卡并选择**POST令牌**请求。然后，点击**发送**按钮。结果可以在以下屏幕截图中查看：![图7.12：发送POST令牌请求
- en: '](img/C15309_07_12.jpg)'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_07_12.jpg)'
- en: 'Figure 7.12: Sending a POST Token request'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.12：发送POST令牌请求
- en: Send a client request to our API to create a recipe and click on the **Collections**
    tab.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向我们的API发送创建菜谱的客户端请求并点击**集合**选项卡。
- en: 'Select the `Authorization` in the `Bearer {token}` in the **VALUE** field,
    where the token is the access token we retrieved in the previous step. Then, click
    the **Send** button. The result can be seen in the following screenshot:![Figure
    7.13: Sending a client request to our API to create a recipe'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**值**字段中的`Bearer {token}`中选择`Authorization`，其中令牌是我们上一步中检索到的访问令牌。然后，点击**发送**按钮。结果可以在以下屏幕截图中查看：![图7.13：向我们的API发送客户端请求以创建菜谱
- en: '](img/C15309_07_13.jpg)'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_07_13.jpg)'
- en: 'Figure 7.13: Sending a client request to our API to create a recipe'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.13：向我们的API发送客户端请求以创建菜谱
- en: Upload the recipe images. Click on the `Recipe` folder to create a new request.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传菜谱图片。点击`Recipe`文件夹以创建新的请求。
- en: Set the `RecipeCoverUpload` and save it in the `Recipe` folder.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`RecipeCoverUpload`并将其保存在`Recipe`文件夹中。
- en: Select `PUT` as the HTTP method and type in `http://localhost:5000/recipes/<recipe_id>/cover`
    as the request URL (replace `<recipe_id>` with the recipe ID we got from the previous
    step).
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将HTTP方法选择为`PUT`，并在请求URL中输入`http://localhost:5000/recipes/<recipe_id>/cover`（将`<recipe_id>`替换为我们上一步中获取的菜谱ID）。
- en: Select the `Authorization` in the `Bearer {token}` in the **VALUE** field, where
    the token is the access token we retrieved in the previous step.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**值**字段中的`Bearer {token}`中选择`Authorization`，其中令牌是我们上一步中检索到的访问令牌。
- en: Select the **Body** tab. Then, select the form-data radio button and type cover
    into **KEY**.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**主体**选项卡。然后，选择表单数据单选按钮，并在**键**中输入封面。
- en: Choose **File** in the drop-down menu next to **KEY** and select the image file
    to upload.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**键**旁边的下拉菜单中选择**文件**，并选择要上传的图片文件。
- en: 'Click the **Save** button and then the **Send** button. The result can be seen
    in the following screenshot:![Figure 7.14: Uploading a recipe image'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**按钮然后点击**发送**按钮。结果可以在以下屏幕截图中查看：![图7.14：上传菜谱图片
- en: '](img/C15309_07_14.jpg)'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_07_14.jpg)'
- en: 'Figure 7.14: Uploading a recipe image'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.14：上传菜谱图片
- en: 'Check whether the image has been compressed in PyCharm. We can see from the
    application log in PyCharm that the file size has been reduced by `97%`:![Figure
    7.15: Checking whether the images are compressed in PyCharm'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PyCharm中检查图像是否已压缩。我们可以从PyCharm中的应用日志中看到文件大小已减少`97%`：![图7.15：检查在PyCharm中图像是否已压缩
- en: '](img/C15309_07_15.jpg)'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_07_15.jpg)'
- en: 'Figure 7.15: Checking whether the images are compressed in PyCharm'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.15：在PyCharm中检查图片是否已压缩
- en: 'Check the uploaded image in `static/images/recipes`:![Figure 7.16: Checking
    the uploaded image in the path'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`static/images/recipes`中检查上传的图片：![图7.16：检查路径中的上传图片
- en: '](img/C15309_07_16.jpg)'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_07_16.jpg)'
- en: 'Figure 7.16: Checking the uploaded image in the path'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.16：检查上传的图片在路径中
- en: 'Get the recipe back and confirm that the `cover_url` attribute is populated.
    Now, click on the `http://localhost:5000/recipes/5` into the **URL** field. You
    may replace the recipe ID, that is, 5, with any ID that is appropriate. Then,
    click the **Send** button. The result can be seen in the following screenshot:![Figure
    7.17: Getting the recipe back and confirming that the cover_url attribute is populated'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取食谱并确认`cover_url`属性已填充。现在，将`http://localhost:5000/recipes/5`点击到**URL**字段中。你可以用任何合适的ID替换食谱ID，即5。然后，点击**发送**按钮。结果如下截图所示：![图7.17：获取食谱并确认cover_url属性已填充
- en: '](img/C15309_07_17.jpg)'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_07_17.jpg)'
- en: 'Figure 7.17: Getting the recipe back and confirming that the cover_url attribute
    is populated'
  id: totrans-351
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.17：获取食谱并确认cover_url属性已填充
- en: Congratulations! We have tested the recipe cover image upload function. It works
    great!
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经测试了食谱封面图片上传功能。它运行得很好！
- en: '8: Pagination, Searching, and Ordering'
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8：分页、搜索和排序
- en: 'Activity 13: Implementing Pagination on the User-Specific Recipe Retrieval
    API'
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动13：在用户特定食谱检索API上实现分页
- en: '**Solution**'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Modify the code in the `get_all_by_user` method under `models/recipe.py`, as
    follows:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`models/recipe.py`下的`get_all_by_user`方法中的代码，如下所示：
- en: '[PRE44]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Import `RecipePaginationSchema` into `resources/user.py`:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`RecipePaginationSchema`导入到`resources/user.py`中：
- en: '[PRE45]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Declare the `recipe_pagination_schema` attribute in `resources/user.py`:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resources/user.py`中声明`recipe_pagination_schema`属性：
- en: '[PRE46]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here, we''ve added the `@user_kwargs` decorator to `UserRecipeListResource.get`.
    It takes a few parameters, including `page`, `per_page`, and `visibility`:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们向`UserRecipeListResource.get`方法添加了`@user_kwargs`装饰器。它包含一些参数，包括`page`、`per_page`和`visibility`：
- en: '[PRE47]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Modify the `UserRecipeListResource.get` method in `resources/user.py`:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`resources/user.py`中的`UserRecipeListResource.get`方法：
- en: '[PRE48]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `Recipe.get_all_by_user` method gets the paginated recipes by a particular
    author, and then lets `recipe_pagination_schema` serialize the paginated object
    and return it.
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Recipe.get_all_by_user`方法通过特定作者获取分页食谱，然后让`recipe_pagination_schema`序列化分页对象并返回。'
- en: 'Activity 14: Testing Pagination on the User-Specific Recipe Retrieval API'
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动14：测试用户特定食谱检索API上的分页
- en: '**Solution**'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Get all the recipes under John using Postman, page by page, with a page size
    of two. First, click on the `UserRecipeList` request.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Postman分页，每页两个，逐页获取John的所有食谱。首先，点击`UserRecipeList`请求。
- en: Type `http://localhost:5000/{username}/recipes` into the `{username}` here should
    be the same as the one we inserted in the previous exercise. In our case, it will
    be `john`.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此处输入`http://localhost:5000/{username}/recipes`，这里的`{username}`应与我们在前面的练习中插入的相同。在我们的例子中，它将是`john`。
- en: Select the `per_page`, `2`).
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`per_page`，即`2`）。
- en: 'Send the request. The result is shown in the following screenshot:![Figure
    8.9: Getting all the recipes under John using Postman'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求。结果如下截图所示：![图8.9：使用Postman获取John的所有食谱
- en: '](img/C15309_08_09.jpg)'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_08_09.jpg)'
- en: 'Figure 8.9: Getting all the recipes under John using Postman'
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.9：使用Postman获取John的所有食谱
- en: In the details of the recipe, we can see that there are links with the URLs
    of the `first`, `last`, and `next` pages. We can't see the **prev** page here
    because we are on the first page. There is a total of four pages, and we have
    two records per page. We can also see the sorted recipe details in the HTTP response.
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在食谱的详细信息中，我们可以看到有带有`first`、`last`和`next`页面URL的链接。因为我们处于第一页，所以我们看不到**prev**页面。总共有四页，每页有两个记录。我们还可以在HTTP响应中看到排序后的食谱详情。
- en: 'Click the next URL in links to query for the next two records in Postman with
    the request URL populated (`http://localhost:5000/users/john/recipes?per_page=2&page=2`).
    Then, we just need to click on **Send** to send the request. The result is shown
    in the following screenshot:![Figure 8.10: Querying for the next two records in
    Postman with the request URL populated'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击链接中的下一个URL，在Postman中查询下一个两个记录，请求URL已填写（`http://localhost:5000/users/john/recipes?per_page=2&page=2`）。然后，我们只需点击**发送**来发送请求。结果如下截图所示：![图8.10：在Postman中查询已填写请求URL的下一个两个记录
- en: '](img/C15309_08_10.jpg)'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_08_10.jpg)'
- en: 'Figure 8.10: Querying for the next two records in Postman with the request
    URL populated'
  id: totrans-378
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.10：在Postman中使用请求URL查询下两条记录
- en: From the result, we can see that there are links to the `first`, `last`, `next`,
    and `prev` pages. We can also see that we are currently on page two. All the recipe
    data is there as well.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中，我们可以看到有链接到`first`、`last`、`next`和`prev`页面。我们还可以看到我们目前在第2页。所有的配方数据都在那里。
- en: 'Activity 15: Searching for Recipes with Specific Ingredients'
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动15：搜索含有特定配料的食谱
- en: '**Solution**'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'First, in `models/recipe.py`, add the `ingredients` attribute to the `Recipe`
    model:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`models/recipe.py`中，将`ingredients`属性添加到`Recipe`模型中：
- en: '[PRE49]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Run the following command to generate a database migration script:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以生成数据库迁移脚本：
- en: '[PRE50]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You will see that a new column called `recipe.ingredients` has been detected:'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到检测到一个名为`recipe.ingredients`的新列：
- en: '[PRE51]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Check the content in `/migrations/versions/0876058ed87e_.py`, which is the
    database migration script that was generated in the previous step:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`/migrations/versions/0876058ed87e_.py`中的内容，这是上一步中生成的数据库迁移脚本：
- en: '[PRE52]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we can see that two functions have been generated in the script. The `upgrade`
    function is used to add the new column, `ingredients`, to the recipe table, whereas
    the `downgrade` function is used to remove the `ingredients` column so that it
    goes back to its original state.
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到脚本中生成了两个函数。`upgrade`函数用于将新列`ingredients`添加到配方表中，而`downgrade`函数用于删除`ingredients`列，使其恢复到原始状态。
- en: 'Run the following `flask db upgrade` command to update the database schema:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下`flask db upgrade`命令以更新数据库模式：
- en: '[PRE53]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You will see the following output:'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE54]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In `schemas/recipe.py`, add the `ingredients` attribute to `RecipeSchema`:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`schemas/recipe.py`中，将`ingredients`属性添加到`RecipeSchema`：
- en: '[PRE55]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Modify the `RecipeResource.patch` method in `resources/recipe.py` to be able
    to update `ingredients`:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`resources/recipe.py`中的`RecipeResource.patch`方法，以便能够更新`ingredients`：
- en: '[PRE56]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Modify the `Recipe.get_all_published` method in `models/recipe.py` so that
    it gets all the published recipes that it can through the ingredients:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`models/recipe.py`中的`Recipe.get_all_published`方法，使其通过配料获取所有已发布的配方：
- en: '[PRE57]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`Right-click` on it to run the application. Flask will then start up and run
    on `localhost` (`127.0.0.1`) at port `5000`:![Figure 8.11: Running Flask on the
    localhost'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`右键单击`它以运行应用程序。Flask将启动并在`localhost`（`127.0.0.1`）的端口`5000`上运行：![图8.11：在本地主机上运行Flask'
- en: '](img/C15309_03_07.jpg)'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C15309_03_07.jpg](img/C15309_03_07.jpg)'
- en: 'Figure 8.11: Running Flask on the localhost'
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.11：在本地主机上运行Flask
- en: 'Log in to a user account and create two recipes by running the following `httpie`
    command in the PyCharm console. The `{token}` placeholder should be replaced with
    the access token:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录用户账户，并在PyCharm控制台中运行以下`httpie`命令创建两个配方。应将`{token}`占位符替换为访问令牌：
- en: '[PRE58]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Publish these two recipes by using the following `httpie` command:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下`httpie`命令发布这两个食谱：
- en: '[PRE59]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Search for recipes that contain the `eggs` string in the name, description,
    or ingredients. Click on the `RecipeList` request and select the `q`, `eggs`)
    and send the request. The result is shown in the following screenshot:![Figure
    8.12: Searching for the eggs ingredient by sending a request'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索名称、描述或配料中包含`eggs`字符串的食谱。点击`RecipeList`请求并选择`q`、`eggs`)并发送请求。结果如下截图所示：![图8.12：通过发送请求搜索鸡蛋配料
- en: '](img/C15309_08_12.jpg)'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C15309_08_12.jpg](img/C15309_08_12.jpg)'
- en: 'Figure 8.12: Searching for the eggs ingredient by sending a request'
  id: totrans-410
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.12：通过发送请求搜索鸡蛋配料
- en: From the preceding search result, we can see that there is a recipe with eggs
    in the ingredients.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的搜索结果中，我们可以看到有一个配料中含有鸡蛋的配方。
- en: '9: Building More Features'
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9: 构建更多功能'
- en: 'Activity 16: Getting Cache Data after Updating Recipe Details'
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动16：更新食谱详情后的缓存数据获取
- en: '**Solution**'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Get all the recipe data back, click on `RecipeList` and send the request. The
    result is shown in the following screenshot:![Figure 9.15: Get the recipe data
    back and send the request'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所有配方数据，点击`RecipeList`并发送请求。结果如下截图所示：![图9.15：获取配方数据并发送请求
- en: '](img/C15309_09_15.jpg)'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C15309_09_15.jpg](img/C15309_09_15.jpg)'
- en: 'Figure 9.15: Get the recipe data back and send the request'
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.15：获取配方数据并发送请求
- en: 'Log in to your account, click on the **Collections** tab and select the **POST**
    **Token** request. Then, send the request. The result is shown in the following
    screenshot:![Figure 9.16: Select the POST Token request and send it'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录您的账户，点击**收藏集**标签并选择**POST** **令牌**请求。然后，发送请求。结果如下截图所示：![图9.16：选择POST令牌请求并发送它
- en: '](img/C15309_09_16.jpg)'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_09_16.jpg)'
- en: 'Figure 9.16: Select the POST Token request and send it'
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.16：选择POST Token请求并发送
- en: Modify a recipe record using the `PATCH` method. First, select the `PATCH Recipe`
    request.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`PATCH`方法修改食谱记录。首先，选择`PATCH Recipe`请求。
- en: Now select the `Bearer {token}`; the token should be the access token.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在选择`Bearer {token}`；该令牌应该是访问令牌。
- en: 'Select the `num_of_servings` to `5`, and `cook_time` to `50`:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`num_of_servings`为`5`，以及`cook_time`为`50`：
- en: '[PRE60]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Send the request. The result is shown in the following screenshot:![Figure
    9.17: Modifying a recipe record using the PATCH method'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求。结果如下截图所示：![图9.17：使用PATCH方法修改食谱记录
- en: '](img/C15309_09_17.jpg)'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_09_17.jpg)'
- en: 'Figure 9.17: Modifying a recipe record using the PATCH method'
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.17：使用PATCH方法修改食谱记录
- en: Get all the recipe data back again, click on `RecipeList`.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次获取所有食谱数据，点击`RecipeList`。
- en: 'Send the request. The result is shown in the following screenshot:![Figure
    9.18: Get all the recipe data back again'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求。结果如下截图所示：![图9.18：再次获取所有食谱数据
- en: '](img/C15309_09_18.jpg)'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_09_18.jpg)'
- en: 'Figure 9.18: Get all the recipe data back again'
  id: totrans-431
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.18：再次获取所有食谱数据
- en: We can see that when we get all the recipe details again, the details are not
    updated, which will cause the user to see the wrong information.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当我们再次获取所有食谱详情时，详情没有更新，这将导致用户看到错误的信息。
- en: 'Activity 17: Adding Multiple Rate-Limit Restrictions'
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动17：添加多个速率限制限制
- en: '**Solution**'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'In `resources/user.py`, import `limiter` from `extensions`:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resources/user.py`中，从`extensions`导入`limiter`：
- en: '[PRE61]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In `UserRecipeListResource`, put the `limiter.limit` function in the `decorators`
    attribute:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UserRecipeListResource`中，将`limiter.limit`函数放入`decorators`属性：
- en: '[PRE62]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Comment out the whitelist in `app.py`:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.py`中注释掉白名单：
- en: '[PRE63]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In PyCharm, to comment out a line of code, if you are using Mac, you can use
    *Command + /*, and if you are using Windows, you can use *Ctrl + /*.
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在PyCharm中，如果您使用的是Mac，可以使用*Command + /*来注释掉一行代码，如果您使用的是Windows，可以使用*Ctrl + /*。
- en: 'When we are done, click **Run** to start the Flask application; then, we are
    ready to test it:![Figure 9.19: Starting the Flask application'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们完成时，点击**运行**以启动Flask应用程序；然后，我们就可以开始测试它：![图9.19：启动Flask应用程序
- en: '](img/C15309_09_19.jpg)'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_09_19.jpg)'
- en: 'Figure 9.19: Starting the Flask application'
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.19：启动Flask应用程序
- en: Get all the recipes for a user and check the rate limit information in the response
    header. First, click on `UserRecipeList` and send the request.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户的全部食谱并检查响应头中的速率限制信息。首先，点击`UserRecipeList`并发送请求。
- en: 'Then, select the **Header** tab in **Response**. The result is shown in the
    following screenshot:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在**响应**的**头部**选项卡中选择**头部**。结果如下截图所示：
- en: '![Figure 9.20: Checking the rate limit information in the response header'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.27：在Postman中添加更多环境变量'
- en: '](img/C15309_09_20.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_09_20.jpg)'
- en: 'Figure 9.20: Checking the rate limit information in the response header'
  id: totrans-449
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.20：检查响应头中的速率限制信息
- en: In the HTTP response, we can see that the rate limit for this endpoint is three,
    while we only have two remaining request quotas. The limit is going to be reset
    in 60 seconds.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP响应中，我们可以看到此端点的速率限制为三个，而我们只剩下两个剩余的请求数额。限制将在60秒后重置。
- en: '10: Deployment'
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10：部署
- en: 'Activity 18: Changing access_token to a Variable in Postman'
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动18：在Postman中将access_token更改为变量
- en: '**Solution**'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Perform user login and get the access token. Use the **POST Token** request
    to get the access token. You should see the following output:![Figure 10.26: Performing
    user login to get an access token'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行用户登录并获取访问令牌。使用**POST Token**请求获取访问令牌。您应该看到以下输出：![图10.26：执行用户登录以获取访问令牌
- en: '](img/C15309_10_29.jpg)'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_10_29.jpg)'
- en: 'Figure 10.29: Performing user login to get an access token'
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.29：执行用户登录以获取访问令牌
- en: 'Click `access_token` variable. The value is the access token we obtained in
    the previous step. Then, click **Update**:![Figure 10.27: Adding more environment
    variables in Postman'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`access_token`变量。其值是我们上一步获得的访问令牌。然后，点击**更新**：![图10.27：在Postman中添加更多环境变量
- en: '](img/C15309_10_30.jpg)'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_10_30.jpg)'
- en: 'Figure 10.30: Adding more environment variables in Postman'
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.30：在Postman中添加更多环境变量
- en: 'Select the `Bearer {{access_token}}`, which is the environment variable we
    added in the previous step, and then send the request. You should see the following
    output:![Figure 10.28: Using more environment variables in Postman](img/C15309_10_31.jpg)'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Bearer {{access_token}}`，这是我们之前步骤中添加的环境变量，然后发送请求。您应该看到以下输出：![图10.28：在Postman中使用更多环境变量](img/C15309_10_31.jpg)
- en: 'Figure 10.31: Using more environment variables in Postman'
  id: totrans-461
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.31：在Postman中使用更多环境变量
