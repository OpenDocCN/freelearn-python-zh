- en: Chapter 5. Advanced Django in PTVS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：PTVS中的高级Django
- en: Once we look at how a Django development environment in Visual Studio with PTVS
    is set up, we can start analyzing some powerful libraries for Django and how to
    use them in Visual Studio. Over the years, lots of developers have created powerful
    libraries and tools for Django that speed up various aspects of the development
    cycle. We are going to take a closer look at some of them here to see how they
    integrate in Visual Studio and PTVS.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们查看在Visual Studio中使用PTVS设置的Django开发环境，我们就可以开始分析一些强大的Django库以及如何在Visual Studio中使用它们。多年来，许多开发者为Django创建了强大的库和工具，以加快开发周期的各个方面。我们将在这里更详细地研究其中的一些，看看它们如何在Visual
    Studio和PTVS中集成。
- en: 'In this chapter, we will analyze two libraries that are useful for a Django
    developer in two different aspects: automatizing tasks using the Fabric library,
    and managing model migrations on Django with South.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将分析两个对Django开发者有用的库，从两个不同的角度：使用Fabric库自动化任务，以及使用South管理Django的模型迁移。
- en: Library management
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库管理
- en: We have already learned how to install new packages in PTVS using the GUI tools
    that it provides. Now, we will learn more about the criteria for choosing one
    package index over another; in other words, when to choose `easy_install` over
    `pip`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何在PTVS中使用它提供的GUI工具安装新的软件包。现在，我们将了解如何选择一个软件包索引而不是另一个；换句话说，何时选择`easy_install`而不是`pip`。
- en: 'Generally speaking, using `pip` is much better than using `easy_install`, and
    there are major reasons for this. As Ian Bicking, the creator of `pip`, wrote
    in his own introduction to `pip`, the advantages are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，使用`pip`比使用`easy_install`要好得多，这有主要的原因。正如`pip`的创造者Ian Bicking在他自己的`pip`介绍中写的，优势如下：
- en: All packages are downloaded before installation. As a result, partially completed
    installation doesn't occur.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在安装之前，所有软件包都会被下载。因此，不会发生部分完成的安装。
- en: Care is taken when presenting useful output on the console.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制台上呈现有用的输出时需要小心。
- en: The reasons for actions are being tracked. For instance, if a package is being
    installed, `pip` keeps track of why that package was required.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在跟踪操作的原因。例如，如果正在安装软件包，`pip`会跟踪为什么需要该软件包。
- en: Error messages should be useful.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误信息应该是有用的。
- en: The code is relatively concise and cohesive, making it easier to use programmatically.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码相对简洁且结构紧凑，使得程序化使用更加容易。
- en: Packages don't have to be installed as egg archives; they can be installed flat
    (while keeping the egg metadata).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件包不必作为egg存档安装；它们可以平装安装（同时保留egg元数据）。
- en: Native support is available for other version control systems (`Git`, `Mercurial`,
    and `Bazaar`).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他版本控制系统（`Git`、`Mercurial`和`Bazaar`）都提供了原生支持。
- en: Uninstallation of packages is easy.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件包的卸载很容易。
- en: It is simple to define, has fixed sets of requirements, and reliably reproduces
    a set of packages.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义简单，有固定的需求集合，并且可靠地重现一组软件包。
- en: It may seem that there are no reasons to choose `easy_install` over `pip`. However,
    this is where careful consideration is needed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来没有理由选择`easy_install`而不是`pip`。然而，这正是需要仔细考虑的地方。
- en: 'There is a caveat that makes the choice really hard for Windows environments:
    some libraries or dependencies are written in Python C, which is a way for Python
    to call libraries written in C/C++. To compile these libraries on your Windows
    machine, you have to install the exact same version of the original compiler that
    has been used to compile to the original interpreter. For example, you will need
    the C++ compiler of Visual Studio 2008 if you use Python 2.7 or Visual Studio
    2010 for Python 3.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个注意事项使得Windows环境的选择变得非常困难：一些库或依赖项是用Python C编写的，这是Python调用用C/C++编写的库的一种方式。要在您的Windows机器上编译这些库，您必须安装与编译原始解释器相同的原始编译器的确切版本。例如，如果您使用Python
    2.7，则需要Visual Studio 2008的C++编译器；如果您使用Python 3，则需要Visual Studio 2010。
- en: This is due to a long tradition where Python extension modules must be built
    with the same compiler version (more specifically, a CRT version) as Python itself,
    which is mentioned at [https://mail.python.org/pipermail/python-list/2010-April/573606.html](https://mail.python.org/pipermail/python-list/2010-April/573606.html).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为有一个长期的传统，即Python扩展模块必须使用与Python本身相同的编译器版本（更具体地说，是CRT版本）来构建，这在[https://mail.python.org/pipermail/python-list/2010-April/573606.html](https://mail.python.org/pipermail/python-list/2010-April/573606.html)中提到。
- en: Using the `easy_install` package installer, the precompiled packages are downloaded
    and installed into the system's `site-packages` folder.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`easy_install`包安装程序，预编译的包将被下载并安装到系统的`site-packages`文件夹中。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A rule of thumb: if the library you are trying to install on your Windows machine
    has Python C extensions in it, it''s far better to choose `easy_install`. For
    all other cases, `pip` is way better.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经验法则：如果您试图在Windows机器上安装的库包含Python C扩展，那么选择`easy_install`会更好。对于所有其他情况，`pip`要好得多。
- en: If you don't know what kind of library you are importing, you should go with
    `pip`. If it encounters a problem during the compilation process of the installation,
    you can uninstall the library and reinstall it using `easy_install`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道您正在导入的库的类型，您应该选择`pip`。如果在安装过程中遇到编译问题，您可以卸载库并使用`easy_install`重新安装。
- en: Generally, most libraries that have low-level capabilities (for example, cryptography,
    graphics, and mathematical functions) and interaction with other software (for
    example, drivers) use Python C extensions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，大多数具有底层功能（例如，加密、图形和数学函数）以及与其他软件（例如，驱动程序）交互的库（例如，加密、图形和数学函数）都使用Python C扩展。
- en: The Fabric library – the deployment and development task manager
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fabric库 – 部署和开发任务管理器
- en: Fabric is a Python library and a command-line tool that allows execution in
    application deployment and administration tasks. Essentially, Fabric is a tool
    that allows the developer to execute arbitrary Python functions via the command
    line and also a set of functions in order to execute shell commands on remote
    servers via SSH. Combining these two things together offers developers a powerful
    way to administrate the application workflow without having to remember the series
    of commands that need to be executed on the command line.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric是一个Python库和命令行工具，允许在应用程序部署和管理任务中执行。本质上，Fabric是一个允许开发者通过命令行执行任意Python函数的工具，同时也提供了一套函数，以便通过SSH在远程服务器上执行shell命令。将这两者结合起来，为开发者提供了一种无需记住在命令行上需要执行的命令序列的强大方式来管理应用程序工作流程。
- en: The library documentation can be found at [http://fabric.readthedocs.org/](http://fabric.readthedocs.org/).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 库文档可以在[http://fabric.readthedocs.org/](http://fabric.readthedocs.org/)找到。
- en: Installing the library in PTVS is straightforward. Like all other libraries,
    to insert this library into a Django project, right-click on the **Python 2.7**
    node in **Python Environments** of the **Solution Explorer** window. Then, select
    the **Install Python Package** entry.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在PTVS中安装库很简单。像所有其他库一样，要将此库插入Django项目，在**解决方案资源管理器**窗口的**Python环境**中的**Python
    2.7**节点上右键单击。然后，选择**安装Python包**条目。
- en: '![The Fabric library – the deployment and development task manager](img/8687OS_05_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Fabric库 – 部署和开发任务管理器](img/8687OS_05_01.jpg)'
- en: The Python environment contextual menu
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Python环境上下文菜单
- en: 'Clicking on it brings up the **Install Python Package** modal window as shown
    in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 点击它将弹出**安装Python包**的模态窗口，如下截图所示：
- en: '![The Fabric library – the deployment and development task manager](img/8687OS_05_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Fabric库 – 部署和开发任务管理器](img/8687OS_05_02.jpg)'
- en: It's important to use `easy_install` to download from the Python package index.
    This will bring the precompiled versions of the library into the system instead
    of the plain Python C libraries that have to be compiled on the system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`easy_install`从Python包索引下载非常重要。这将把库的预编译版本带入系统，而不是需要在系统上编译的纯Python C库。
- en: Once the package is installed in the system, you can start creating tasks that
    can be executed outside your application from the command line. First, create
    a configuration file, `fabfile.py`, for Fabric. This file contains the tasks that
    Fabric will execute.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦包在系统中安装，您就可以开始创建可以在命令行外执行的任务。首先，为Fabric创建一个配置文件，`fabfile.py`。此文件包含Fabric将执行的任务。
- en: '![The Fabric library – the deployment and development task manager](img/8687OS_05_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Fabric库 – 部署和开发任务管理器](img/8687OS_05_03.jpg)'
- en: 'The previous screenshot shows a really simple task: it prints out the string
    `hello world` once it''s executed. You can execute it from the command prompt
    by using the Fabric command `fab`, as shown in the following screenshot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了一个非常简单的任务：一旦执行，它将打印出字符串`hello world`。您可以通过使用Fabric命令`fab`从命令提示符执行它，如下截图所示：
- en: '![The Fabric library – the deployment and development task manager](img/8687OS_05_04.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![Fabric库 – 部署和开发任务管理器](img/8687OS_05_04.jpg)'
- en: Now that you know that the system is working fine, you can move on to the juicy
    part where you can make some tasks that interact with a remote server through
    `ssh`. Create a task that connects to a remote machine and find out the type of
    OS that runs on it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道系统运行良好，你可以继续到更有趣的部分，在那里你可以创建一些通过 `ssh` 与远程服务器交互的任务。创建一个连接到远程机器并找出其上运行的操作系统类型的任务。
- en: '![The Fabric library – the deployment and development task manager](img/8687OS_05_05.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![The Fabric library – the deployment and development task manager](img/8687OS_05_05.jpg)'
- en: The env object provides a way to add credentials to Fabric in a programmatic
    way
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: env 对象提供了一种以编程方式向 Fabric 添加凭据的方法
- en: We have defined a Python function, `host_type`, that runs a POSIX command, `uname
    –s`, on the remote. We also set up a couple of variables to tell Fabric which
    is the remote machine we are connecting to, i.e. `env.hosts`, and the password
    that has to be used to access that machine, i.e. `env.password`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个 Python 函数 `host_type`，它在远程上运行 POSIX 命令 `uname –s`。我们还设置了一些变量来告诉 Fabric
    我们连接到哪台远程机器，即 `env.hosts`，以及访问该机器所需的密码，即 `env.password`。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's never a good idea to put plain passwords into the source code, as is shown
    in the preceding screenshot example.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将明文密码放入源代码中，就像前一个屏幕截图示例中所示，从来都不是一个好主意。
- en: 'Now, we can execute the `host_type` task in the command line as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在命令行中执行 `host_type` 任务，如下所示：
- en: '![The Fabric library – the deployment and development task manager](img/8687OS_05_06.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![The Fabric library – the deployment and development task manager](img/8687OS_05_06.jpg)'
- en: The Fabric library connects to the remote machine with the information provided
    and executes the command on the server. Then, it brings back the result of the
    command itself in the output part of the response.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 库使用提供的信息连接到远程机器，并在服务器上执行命令。然后，它在响应的输出部分返回命令的结果。
- en: 'We can also create tasks that accept parameters from the command line. Create
    a task that echoes a message on the remote machine, starting with a parameter
    as shown in the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建接受命令行参数的任务。创建一个在远程机器上回显消息的任务，从以下屏幕截图中的参数开始：
- en: '![The Fabric library – the deployment and development task manager](img/8687OS_05_07.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![The Fabric library – the deployment and development task manager](img/8687OS_05_07.jpg)'
- en: 'The following are two examples of how the task can be executed:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何执行任务的两个示例：
- en: '![The Fabric library – the deployment and development task manager](img/8687OS_05_08.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![The Fabric library – the deployment and development task manager](img/8687OS_05_08.jpg)'
- en: 'We can also create a helper function that executes an arbitrary command on
    the remote machine as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个辅助函数，在远程机器上执行任意命令，如下所示：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We are also able to upload a file into the remote server by using `put`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用 `put` 命令将文件上传到远程服务器：
- en: '![The Fabric library – the deployment and development task manager](img/8687OS_05_09.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![The Fabric library – the deployment and development task manager](img/8687OS_05_09.jpg)'
- en: 'The first argument of `put` is the local file you want to upload and the second
    one is the destination folder''s filename. Let''s see what happens:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`put` 命令的第一个参数是你想要上传的本地文件，第二个参数是目标文件夹的文件名。让我们看看会发生什么：'
- en: '![The Fabric library – the deployment and development task manager](img/8687OS_05_10.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![The Fabric library – the deployment and development task manager](img/8687OS_05_10.jpg)'
- en: Deploying process with Fabric
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Fabric 的部署过程
- en: The possibilities of using Fabric are really endless, since the tasks can be
    written in plain Python language. This provides the opportunity to automate many
    operations and focus more on the development instead of focusing on how to deploy
    your code to servers to maintain them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Fabric 的可能性真的是无限的，因为任务可以用纯 Python 语言编写。这提供了自动化许多操作的机会，并使我们能够更多地关注开发，而不是关注如何将代码部署到服务器上以维护它们。
- en: South – the database deployment library
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: South – 数据库部署库
- en: Developed by the Python community, South is a Django library that brings schema
    migration to Django applications. The South library's main objective is to provide
    a simple, stable, and database-independent migration layer to prevent all the
    hassles of schema changes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Python 社区开发，South 是一个 Django 库，它将模式迁移引入 Django 应用程序。South 库的主要目标是提供一个简单、稳定且数据库无关的迁移层，以防止所有模式更改的麻烦。
- en: 'The key features of South are as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: South 的关键特性如下：
- en: '**Automatic migration creation**: South can detect what''s changed in your
    application model by analyzing your `model.py` files and automatically creating
    the migration code—basically the SQL commands for the database you are using—that
    matches the changes in the models.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动迁移创建**：South 可以通过分析你的 `model.py` 文件来检测应用程序模型中的更改，并自动创建迁移代码——基本上是针对你使用的数据库的
    SQL 命令，以匹配模型中的更改。'
- en: '**Database independence**: South is database agnostic, supporting different
    database backends. Currently, South supports PostgreSQL, MySQL, SQLite, Microsoft
    SQL Server, Oracle, and Firebird (beta support).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库独立性**：South 对数据库不可知，支持不同的数据库后端。目前，South 支持 PostgreSQL、MySQL、SQLite、Microsoft
    SQL Server、Oracle 和 Firebird（beta 支持）。'
- en: '**App-savvy**: South knows and works with the concept of Django applications,
    allowing developers to use migrations on only some of the applications and not
    on the whole project.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用智能**：South 了解并使用 Django 应用程序的概念，允许开发者仅对某些应用程序而不是整个项目使用迁移。'
- en: '**VCS-proof**: South will notice when someone else commits migrations to the
    same application and can check if there are conflicts.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制友好**：South 会注意到其他人向同一应用程序提交迁移，并可以检查是否存在冲突。'
- en: Why use South with Django
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要在 Django 中使用 South
- en: One of the most interesting parts of Django is its **Object-relational mapping**
    (**ORM**), which creates a consistent abstraction of the database structure. This
    is a very powerful tool that allows programmers to focus on the Python code. Django
    takes good care of the database structure management only for new models (for
    example, when creating them). It doesn't have an out-of-the-box solution to manage
    updates in the models that can be applied to existing database schemas.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Django 最有趣的部分之一是其 **对象关系映射**（**ORM**），它创建了一个一致的数据库结构抽象。这是一个非常强大的工具，允许程序员专注于
    Python 代码。Django 只为新模型（例如，在创建它们时）妥善处理数据库结构管理。它没有现成的解决方案来管理可以应用于现有数据库模式的模型更新。
- en: It's usually a painful operation to change the model during the application
    lifecycle. Technically, when changing the schema of the model or when migrating
    the schema, whether you are modifying a field or adding another one, the database
    structure needs to be recreated. This means that all the data of that model is
    lost, or a manual migration needs to be done to move the data from the old version
    of the tables to the new one on the database. This is especially time consuming
    if you have to align that database from a development server environment to a
    production server environment.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序生命周期中更改模型通常是一个痛苦的操作。技术上，当更改模型的模式或进行模式迁移时，无论你是修改字段还是添加另一个字段，都需要重新创建数据库结构。这意味着该模型的所有数据都会丢失，或者需要手动迁移来将数据从旧版本的表移动到数据库中的新版本。如果你需要将数据库从开发服务器环境对齐到生产服务器环境，这尤其耗时。
- en: Installing South
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 South
- en: 'Let''s see how to bring South into PTVS. Like other Python libraries, we can
    install it from the **Solution Explorer** window by right-clicking on the environment
    of your choice (Python 2.7) and selecting **Install Python Package** to bring
    up the following installation dialog box:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将 South 引入 PTVS。和其他 Python 库一样，我们可以通过在选择的（Python 2.7）环境上右键点击并通过选择**安装
    Python 包**来从**解决方案资源管理器**窗口中安装它，从而弹出以下安装对话框：
- en: '![Installing South](img/8687OS_05_11.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![安装 South](img/8687OS_05_11.jpg)'
- en: As stated in the South documentation, you have to use the `easy_install` **Python
    Package Index**; be sure to select it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如 South 文档所述，你必须使用 `easy_install` **Python 包索引**；务必选择它。
- en: Once the package is installed, it's important to make sure that it's activated
    in the settings file. To do so, add `south` at the end of the code for `Installed_Apps`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了包，确保在设置文件中激活它很重要。为此，在 `Installed_Apps` 代码的末尾添加 `south`。
- en: '![Installing South](img/8687OS_05_12.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![安装 South](img/8687OS_05_12.jpg)'
- en: Be sure that the "south" library is the last in the "Installed_Apps" section
    in Settings.py
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在 Settings.py 的 "Installed_Apps" 部分中 "south" 库是最后一个。
- en: South needs to be the last package of the list due to the fact that when Django
    executes the library, all the models of the Django project are already created
    and are discoverable by South.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于当 Django 执行库时，所有 Django 项目的模型都已经创建并且可以被 South 发现，因此 South 需要成为列表中的最后一个包。
- en: 'To test if everything is working, navigate to the Django shell and try to import
    the library. Ordinary Python developers will go to the command line and run the
    `manage.py` shell, but in PTVS, there''s a panel for this. To open it, quickly
    right-click on the **Django** project entry in the **Solution Explorer** window
    and select the **Open Django** **Shell** option in **Django**:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试一切是否正常工作，导航到Django壳并尝试导入库。普通的Python开发者会去命令行并运行`manage.py` shell，但在PTVS中有一个面板可以这样做。要打开它，在**解决方案资源管理器**窗口中快速右键单击**Django**项目条目，然后在**Django**中选择**打开Django**
    **Shell**选项：
- en: '![Installing South](img/8687OS_05_13.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![安装South](img/8687OS_05_13.jpg)'
- en: 'This opens a new **Django Management Console** panel, which is basically a
    REPL but with Django integration. From here, it''s possible to see if the South
    library is working correctly by trying to import the library:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个新的**Django管理控制台**面板，它基本上是一个REPL，但集成了Django。从这里，你可以通过尝试导入库来检查South库是否工作正常：
- en: '![Installing South](img/8687OS_05_14.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![安装South](img/8687OS_05_14.jpg)'
- en: IntelliSense is active in the Django shell, so if you see **south** appear,
    then everything is working fine.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliSense在Django壳中是激活的，所以如果你看到**south**出现，那么一切正常。
- en: 'To finish the initialization process, run `sync_db` for South to create the
    migration-tracking tables. This can also be done from the Django contextual menu
    as seen earlier: just select the **Django Sync DB** command in the **Django**
    menu.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成初始化过程，运行`sync_db`以创建迁移跟踪表。这也可以像之前看到的那样从Django上下文菜单中完成：只需在**Django**菜单中选择**Django
    Sync DB**命令。
- en: '![Installing South](img/8687OS_05_15.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![安装South](img/8687OS_05_15.jpg)'
- en: As shown in the preceding screenshot, this starts the synchronization process
    of the current models in your application on South.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一张截图所示，这将在South中启动您应用程序当前模型同步的过程。
- en: Schema migration with South
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用South的架构迁移
- en: 'Now that we have `south` installed and working in our solution, let''s try
    to create something to test the migration. Create a new application in your project
    and call it `south2ptvs` by using the **Django app** command in the **Add** menu,
    as shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将`south`安装并在我解决方案中工作，让我们尝试创建一些东西来测试迁移。在项目中使用**Django应用**命令在**添加**菜单中创建一个新的应用，并将其命名为`south2ptvs`，如下截图所示：
- en: '![Schema migration with South](img/8687OS_05_16.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![使用South的架构迁移](img/8687OS_05_16.jpg)'
- en: 'Don''t forget to register the new application in the `settings.py` file, and
    make sure that `south` remains as the last entry of the `Installed_Apps` section:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`settings.py`文件中注册新的应用，并确保`south`仍然是`Installed_Apps`部分的最后一个条目：
- en: '![Schema migration with South](img/8687OS_05_17.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![使用South的架构迁移](img/8687OS_05_17.jpg)'
- en: 'Then, open the `models.py` file of the newly created application in which we
    are going to define our testing model:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开新创建的应用中我们将定义测试模型的`models.py`文件：
- en: '![Schema migration with South](img/8687OS_05_18.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![使用South的架构迁移](img/8687OS_05_18.jpg)'
- en: Instead of using the standard Django `sync_db` command to create the schema
    of the model in the database, let's set up a migration for the model `Knight`.
    This operation will be the entry point for the entire migration history of the
    model.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用标准的Django `sync_db`命令来创建数据库中模型的架构，而是为`Knight`模型设置一个迁移。这个操作将是模型整个迁移历史的入口点。
- en: 'Navigate to the command line and execute the initialization migration by executing
    the following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到命令行，通过执行以下命令来执行初始化迁移：
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will execute South''s `schemamigration` command on the `south2pvts` application
    for the initialization process. Here is what is going to happen:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`south2pvts`应用上执行South的`schemamigration`命令以进行初始化过程。以下是将要发生的事情：
- en: '![Schema migration with South](img/8687OS_05_19.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![使用South的架构迁移](img/8687OS_05_19.jpg)'
- en: We have successfully created the migration file but haven't applied it to `db`.
    Since **South** works on one application at a time, the migration file in which
    the information of the migration is stored is created inside the `south2ptvs`
    folder.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功创建了迁移文件，但还没有将其应用到`db`上。由于**South**一次只处理一个应用，存储迁移信息的迁移文件被创建在`south2ptvs`文件夹中。
- en: '![Schema migration with South](img/8687OS_05_20.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![使用South的架构迁移](img/8687OS_05_20.jpg)'
- en: The content of the migrations folder in the Django app
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Django应用中迁移文件夹的内容
- en: The migration files are plain files written in Python. They can be edited, but
    you should do it with caution and only do so when necessary.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移文件是纯Python编写的普通文件。它们可以编辑，但你应该谨慎操作，并且只有在必要时才这样做。
- en: 'The only thing left to do is to apply the migration to the database by calling
    the South library''s `migrate` command on the app with the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情是将迁移应用到数据库，通过在应用程序上调用South库的`migrate`命令，使用以下命令：
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Schema migration with South](img/8687OS_05_21.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![使用South进行模式迁移](img/8687OS_05_21.jpg)'
- en: Execution of South's migration command
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 执行South的迁移命令
- en: This will finalize the migration; now our model is ready to be modified. Future
    updates to the model can be easily applied to the database by South using migrations.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将最终化迁移；现在我们的模型已准备好进行修改。未来的模型更新可以通过South使用迁移轻松地应用到数据库。
- en: 'Update the model by adding a new field as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式添加新字段以更新模型：
- en: '![Schema migration with South](img/8687OS_05_22.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![使用South进行模式迁移](img/8687OS_05_22.jpg)'
- en: So, now we have to create a new migration file and then apply it to the database.
    To create the migration file, use the `schemamigration` command again as shown
    in the following command. However, instead of the `–-initial` parameter, use `–-auto`,
    since a migration is already defined in the model.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们必须创建一个新的迁移文件并将其应用到数据库。要创建迁移文件，再次使用`schemamigration`命令，如下所示。但是，不要使用`–-initial`参数，因为模型中已经定义了迁移。
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Schema migration with South](img/8687OS_05_23.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![使用South进行模式迁移](img/8687OS_05_23.jpg)'
- en: 'To obtain the result of the migration file creation state to apply the migration
    to `db`, just run the following `migrate` command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取创建迁移文件的状态并将迁移应用到`db`，只需运行以下`migrate`命令：
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Schema migration with South](img/8687OS_05_24.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![使用South进行模式迁移](img/8687OS_05_24.jpg)'
- en: 'If we register the model in the admin interface, we can go to the admin section
    of our website and see if the new field appears in the model:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在管理界面中注册模型，我们可以进入我们网站的行政部分，查看新字段是否出现在模型中：
- en: '![Schema migration with South](img/8687OS_05_25.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![使用South进行模式迁移](img/8687OS_05_25.jpg)'
- en: Since the migrations are stored on the files, you can apply the changes on the
    remote server by just copying the migration files to the server and then applying
    the migration on the remote system (maybe with Fabric).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于迁移存储在文件中，您只需将迁移文件复制到服务器，然后在远程系统上应用迁移即可（可能使用Fabric）。
- en: For more details and insights into this powerful tool, visit the official documentation
    website for South at [http://south.readthedocs.org/](http://south.readthedocs.org/).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多细节和见解，请访问South的官方文档网站[http://south.readthedocs.org/](http://south.readthedocs.org/)。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a more in-depth look into how to deal with third-party
    Python libraries in PTVS, the main differences between the `pip` and `easy_install`
    package indexes, and how they deal with precompiled libraries written with Python
    C extensions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更深入地探讨了如何在PTVS中处理第三方Python库，`pip`和`easy_install`包索引之间的主要区别，以及它们如何处理使用Python
    C扩展编写的预编译库。
- en: We also looked into two popular and powerful Django open source libraries, Fabric
    and South, which add remote task management and schema migrations to your Django
    projects.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了两个流行的Django开源库，Fabric和South，它们为您的Django项目添加了远程任务管理和模式迁移功能。
- en: In the next chapter, we will introduce IPython and its graphic power in Visual
    Studio in order to cover the topic of IronPython and its integration with the
    .NET framework.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍IPython及其在Visual Studio中的图形功能，以便涵盖IronPython及其与.NET框架集成的主题。
