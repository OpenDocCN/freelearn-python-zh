- en: Layout Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局管理
- en: In this chapter, we will explore how to arrange widgets within widgets to create
    a Python GUI. Learning about the fundamentals of GUI layout design will allow
    us to create great-looking GUIs. There are certain techniques that will help us
    achieve this layout design.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何在控件内排列控件以创建Python GUI。了解GUI布局设计的基本原理将使我们能够创建外观出色的GUI。有一些技术将帮助我们实现这种布局设计。
- en: The grid layout manager is one of the most important layout tools that we will
    be using, and is built into `tkinter`. We can very easily create menu bars, tabbed
    controls (that is, Notebooks), and many more widgets using `tkinter`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 网格布局管理器是我们将要使用的重要布局工具之一，它内置在`tkinter`中。我们可以非常容易地创建菜单栏、标签控件（即Notebooks）以及许多其他控件。
- en: By completing this chapter, you will learn how to arrange your widgets to make
    your GUI look truly great! Learning layout management is fundamental to GUI design,
    even if you use other programming languages – but Python truly rocks!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成本章，你将学习如何排列你的控件，使你的GUI看起来真正出色！了解布局管理对于GUI设计至关重要，即使你使用其他编程语言——但Python确实很棒！
- en: 'The following screenshot provides an overview of the Python modules that will
    be used in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图提供了本章将使用的Python模块的概述：
- en: '![](img/697a7f34-0bda-4913-92e2-73841c18c2b5.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/697a7f34-0bda-4913-92e2-73841c18c2b5.png)'
- en: 'In this chapter, we will lay out our GUI using Python 3.7 and above. We will
    provide the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Python 3.7及以上版本来布局我们的GUI。我们将提供以下菜谱：
- en: Arranging several labels within a label frame widget
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标签框架控件内排列多个标签
- en: Using padding to add space around widgets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用填充在控件周围添加空间
- en: How widgets dynamically expand the GUI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控件如何动态扩展GUI
- en: Aligning GUI widgets by embedding frames within frames
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在框架内嵌入框架来对齐GUI控件
- en: Creating menu bars
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建菜单栏
- en: Creating tabbed widgets
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建标签控件
- en: Using the grid layout manage
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网格布局管理
- en: Arraning several labels within a label frame widget
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在标签框架控件内排列多个标签
- en: The `LabelFrame` widget allows us to design our GUI in an organized fashion.
    We are still using the grid layout manager as our main layout design tool, but
    by using `LabelFrame` widgets, we get much more control over our GUI's design.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`LabelFrame`控件允许我们以有组织的方式设计我们的GUI。我们仍然使用网格布局管理器作为我们的主要布局设计工具，但通过使用`LabelFrame`控件，我们可以对我们的GUI设计有更多的控制。'
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start by adding more widgets to our GUI. We will make the GUI fully
    functional in upcoming recipes. Here, we will start to use the `LabelFrame` widget.
    We will reuse the GUI from the *Adding several widgets to a loop* recipe in [Chapter
    1](504fcb9a-0f3f-4872-b8cd-6c3dde0f511a.xhtml), *Creating the GUI Form and Adding
    Widgets*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先向我们的GUI添加更多控件。我们将在后续的菜谱中使GUI完全功能化。在这里，我们将开始使用`LabelFrame`控件。我们将重用[第1章](504fcb9a-0f3f-4872-b8cd-6c3dde0f511a.xhtml)中“向循环添加多个控件”菜谱的GUI。
- en: How to do it…
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open `GUI_adding_widgets_in_loop.py` from [Chapter 1](504fcb9a-0f3f-4872-b8cd-6c3dde0f511a.xhtml),
    *Creating the GUI Form and Adding Widgets*, and save the module as `GUI_LabelFrame_column_one.py`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[第1章](504fcb9a-0f3f-4872-b8cd-6c3dde0f511a.xhtml)的“创建GUI表单和添加控件”部分打开`GUI_adding_widgets_in_loop.py`，并将其模块保存为`GUI_LabelFrame_column_one.py`。
- en: 'Create a `ttk.LabelFrame` and position it in the grid:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ttk.LabelFrame`并将其放置在网格中：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create three `ttk` Labels, set their text attributes, and position them in
    the grid:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个`ttk`标签，设置它们的文本属性，并将它们放置在网格中：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding instructions produce the following code from the `GUI_LabelFrame_column_one.py`
    file:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述指令将生成`GUI_LabelFrame_column_one.py`文件中的以下代码：
- en: '![](img/2b30dd20-6b15-4895-b960-1eadd4a9c33a.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2b30dd20-6b15-4895-b960-1eadd4a9c33a.png)'
- en: 'Run the code. It will result in the following GUI:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。它将产生以下GUI：
- en: '![](img/589c7484-9fa0-417b-8c5f-c97360513856.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/589c7484-9fa0-417b-8c5f-c97360513856.png)'
- en: Uncomment line 111 and notice the different alignment of `LabelFrame`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 取消注释第111行并注意`LabelFrame`的不同对齐方式。
- en: 'In addition, we can easily align the labels vertically by changing our code.
    To do this perform the following steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过更改代码轻松地垂直对齐标签。为此，请执行以下步骤：
- en: Open `GUI_LabelFrame_column_one.py` and save the module as `GUI_LabelFrame_column_one_vertical.py`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_LabelFrame_column_one.py`并将其模块保存为`GUI_LabelFrame_column_one_vertical.py`。
- en: 'Change the column and row values, as follows:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更改列和行值：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only change we had to make was in the column and row numbering.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一需要更改的是列和行编号。
- en: 'Run the `GUI_LabelFrame_column_one_vertical.py` file. Now the GUI label frame
    will look as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `GUI_LabelFrame_column_one_vertical.py` 文件。现在 GUI 标签框架将如下所示：
- en: '![](img/818d35aa-5c7b-4628-bf32-6f897673cd02.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/818d35aa-5c7b-4628-bf32-6f897673cd02.png)'
- en: Now let's go behind the scenes to understand the code better.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解代码，以便更好地理解。
- en: How it works…
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In line 109, we create our first `ttk LabelFrame` widget and assign the resulting
    instance to the `buttons_frame` variable. The parent container is `win`, which
    is our main window.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 109 行，我们创建了第一个 `ttk LabelFrame` 小部件，并将结果实例分配给 `buttons_frame` 变量。父容器是 `win`，即我们的主窗口。
- en: In lines 114 to 116, we create labels and place them into a `LabelFrame`. `buttons_frame`
    is the parent of the labels. We use the important grid layout tool to arrange
    the labels within `LabelFrame`. The column and row properties of this layout manager
    give us the power to control our GUI layout.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 114 到 116 行，我们创建了标签并将它们放置到 `LabelFrame` 中。`buttons_frame` 是标签的父容器。我们使用重要的网格布局工具在
    `LabelFrame` 内排列标签。这个布局管理器的列和行属性赋予我们控制 GUI 布局的能力。
- en: The parent of our labels is the `buttons_frame` instance variable of `LabelFrame`,
    not the `win` instance variable of the main window. We can see the beginning of
    a layout hierarchy here.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们标签的父容器是 `LabelFrame` 的 `buttons_frame` 实例变量，而不是主窗口的 `win` 实例变量。我们可以看到布局层次结构的开始。
- en: We can see how easy it is to change our layout via the column and row properties.
    Note how we change the column to 0, and how we layer our labels vertically by
    numbering the row values sequentially.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，通过列和行属性，改变我们的布局是多么容易。注意我们如何将列设置为0，以及我们如何通过按顺序编号行值来垂直堆叠我们的标签。
- en: The name **ttk** stands for **themed tk**. The tk-themed widget set was introduced
    in Tk 8.5.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**ttk** 的名字代表 **主题化的 tk**。Tk 主题小部件集是在 Tk 8.5 中引入的。'
- en: We've successfully learned how to arrange several labels within a `LableFrame`
    widget.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地学习了如何在 `LableFrame` 小部件内排列几个标签。
- en: See also…
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见...
- en: In the *Aligning GUI widgets by embedding frames within frames* recipe, we will
    embed `LabelFrame` widgets within `LabelFrame` widgets, nesting them to control
    our GUI layout.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *通过在框架内嵌入框架对齐 GUI 小部件* 菜谱中，我们将 `LabelFrame` 小部件嵌入到 `LabelFrame` 小部件中，嵌套它们以控制我们的
    GUI 布局。
- en: Now let's move on to the next recipe.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱。
- en: Using padding to add space around widgets
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用填充在小部件周围添加空间
- en: Our GUI is coming along nicely. Next, we will improve the visual aspects of
    our widgets by adding a little space around them so that they can breathe.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 GUI 进行得很顺利。接下来，我们将通过在小部件周围添加一些空间来改善小部件的视觉外观，以便它们可以呼吸。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: While `tkinter` might have had a reputation for creating not-so-pretty GUIs,
    this has dramatically changed since version 8.5.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `tkinter` 可能一直以创建不太美观的 GUI 而闻名，但自 8.5 版本以来，这一情况发生了戏剧性的变化。
- en: 'To better understand the major improvements to Tk, the following is a quote
    from the official website; you can find it at the following link: [https://tkdocs.com/tutorial/onepage.html](https://tkdocs.com/tutorial/onepage.html):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 Tk 的主要改进，以下是从官方网站摘录的一段话；您可以在以下链接中找到它：[https://tkdocs.com/tutorial/onepage.html](https://tkdocs.com/tutorial/onepage.html)：
- en: '"*This tutorial is designed to help people get up to speed quickly with building
    mainstream desktop graphical user interfaces with Tk, and in particular Tk 8.5
    and 8.6\. Tk 8.5 was an incredibly significant milestone release and a significant
    departure from the older versions of Tk which most people know and recognize.*"'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '"*本教程旨在帮助人们快速掌握使用 Tk 构建主流桌面图形用户界面，特别是 Tk 8.5 和 8.6。Tk 8.5 是一个具有里程碑意义的重大版本发布，与大多数人所知和认可的
    Tk 旧版本有显著的不同。*"'
- en: You just have to know how to use the tools and techniques that are available.
    That's what we will do next.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需知道如何使用可用的工具和技术。这就是我们接下来要做的。
- en: '`tkinter` version 8.6 ships with Python 3.7\. There''s no need to install anything
    other than Python in order to use it.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`tkinter` 版本 8.6 与 Python 3.7 一起发布。为了使用它，除了 Python 之外，无需安装任何其他东西。'
- en: A simple way of adding spacing around widgets will be shown first, and then
    we will use a loop to achieve the same thing in a much better way.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先展示一种在小部件周围添加间距的简单方法，然后我们将使用循环以更好的方式实现相同的效果。
- en: Our `LabelFrame` looks a bit tight as it blends into the main window toward
    the bottom. Let's fix this now.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `LabelFrame` 在向底部融入主窗口时看起来有点紧凑。现在让我们修复这个问题。
- en: How to do it…
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to add padding around the widgets:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在小部件周围添加填充：
- en: Open `GUI_LabelFrame_column_one.py` and save it as `GUI_add_padding.py`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_LabelFrame_column_one.py` 并将其保存为 `GUI_add_padding.py`。
- en: 'Add `padx` and `pady` to the grid method:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`padx`和`pady`添加到网格方法中：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the code. Now our `LabelFrame` has some breathing space. We can see this
    in the following screenshot:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。现在我们的`LabelFrame`周围有一些空间。这可以在下面的屏幕截图中看到：
- en: '![](img/90c5377e-da9d-433c-8ee5-d9d059432e52.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/90c5377e-da9d-433c-8ee5-d9d059432e52.png)'
- en: 'We can use a loop to add space around the labels contained within `LabelFrame`.
    Follow these steps to do so:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用循环来添加`LabelFrame`内包含的标签周围的空间。按照以下步骤操作：
- en: Open `GUI_add_padding.py` and save it as `GUI_add_padding_loop.py`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_add_padding.py`并将其保存为`GUI_add_padding_loop.py`。
- en: 'Add the following loop below the creation of the three Labels:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建三个标签之后添加以下循环：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding instructions produce the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上述指令生成以下代码：
- en: '![](img/7962c5d3-4a95-49cb-b3c8-356f64794399.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7962c5d3-4a95-49cb-b3c8-356f64794399.png)'
- en: 'Run the `GUI_add_padding_loop.py` file code. Now the labels within the `LabelFrame`
    widget have some space around them too:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`GUI_add_padding_loop.py`文件代码。现在`LabelFrame`小部件周围的标签也有了一些空间：
- en: '![](img/61fdfc0b-4c66-4681-9e4f-099e12d39d50.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/61fdfc0b-4c66-4681-9e4f-099e12d39d50.png)'
- en: 'To see this effect better, let''s do the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地看到这个效果，让我们做以下操作：
- en: Open `GUI_add_padding_loop.py` and save it as `GUI_long_label.py`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_add_padding_loop.py`并将其保存为`GUI_long_label.py`。
- en: 'Change the text of `Label1`, like so:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变`Label1`的文本，如下所示：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the code. This will generate what''s shown in the following screenshot,
    which shows our GUI. Note how there is now space to the right of the long label,
    next to the dots. The last dot doesn''t touch `LabelFrame`, which it otherwise
    would have without the added space:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。这将生成以下屏幕截图所示的内容，显示了我们的GUI。注意现在在长标签旁边有空间，紧挨着点。最后一个点没有接触到`LabelFrame`，如果没有添加空间，它本会这样接触：
- en: '![](img/1d66daea-012e-476f-9bdd-6015b0ea20c9.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1d66daea-012e-476f-9bdd-6015b0ea20c9.png)'
- en: 'We can also remove the `LabelFrame` name to see the effect `padx` has on the
    position of our labels. Let''s get started:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以移除`LabelFrame`的名称来查看`padx`对我们标签位置的影响。让我们开始吧：
- en: Open `GUI_add_padding_loop.py` and save it as `GUI_LabelFrame_no_name.py`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_add_padding_loop.py`并将其保存为`GUI_LabelFrame_no_name.py`。
- en: 'When creating the button, set the text attribute to an empty string:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建按钮时，将文本属性设置为空字符串：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the code. By setting the `text` attribute to an empty string, we remove
    the name that was previously displayed for `LabelFrame`. This can be seen in the
    following screenshot:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。通过将`text`属性设置为空字符串，我们移除了之前显示在`LabelFrame`上的名称。这可以在下面的屏幕截图中看到：
- en: '![](img/337c2988-38a6-49d1-8a72-ca53d1956d1a.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/337c2988-38a6-49d1-8a72-ca53d1956d1a.png)'
- en: Now let's go behind the scenes to understand the code better.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解代码。
- en: How it works…
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In `tkinter`, adding space horizontally and vertically is done by using the
    built-in `padx` and `pady` attributes. These can be used to add space around many
    widgets, improving horizontal and vertical alignments, respectively. We hard-coded
    `20` pixels of space to the left and right of `LabelFrame`, and we added `40`
    pixels to the top and bottom of the frame. Now our `LabelFrame` stands out better
    than it did before.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tkinter`中，通过使用内置的`padx`和`pady`属性来水平垂直添加空间。这些属性可以用来在许多小部件周围添加空间，分别改善水平和垂直对齐。我们将`20`像素的空间硬编码到`LabelFrame`的左右两侧，并在框架的上下两侧添加了`40`像素的空间。现在我们的`LabelFrame`比之前更加突出。
- en: The `grid_configure()` function allows us to modify the UI elements before the
    main loop displays them. So, instead of hard-coding values when we first create
    a widget, we can work on our layout and then arrange spacing toward the end of
    our file, just before the GUI is created. This is a neat technique to know about.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`grid_configure()`函数允许我们在主循环显示UI元素之前修改UI元素。因此，当我们首次创建小部件时，我们不必硬编码值，我们可以先处理布局，然后在文件末尾，在创建GUI之前安排间距。这是一个值得了解的技巧。'
- en: The `winfo_children()` function returns a list of all the children belonging
    to the `buttons_frame` variable. This allows us to loop through them and assign
    the padding to each label.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`winfo_children()`函数返回属于`buttons_frame`变量的所有子元素的列表。这允许我们遍历它们并将填充分配给每个标签。'
- en: One thing to notice is that the spacing to the right of the labels isn't really
    visible. This is because the title of `LabelFrame` is longer than the names of
    the labels. We suggest you experiment with this by making the label names longer.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到的一点是，标签右侧的间距实际上并不明显。这是因为`LabelFrame`的标题比标签的名称长。我们建议您通过使标签名称更长来实验一下。
- en: We've successfully learned how to add space around widgets using padding. Now
    let's move on to the next recipe.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何使用填充在控件周围添加空间。现在让我们继续下一个菜谱。
- en: Dynamically expanding the GUI using widgets
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用小部件动态扩展GUI
- en: You may have noticed from the previous screenshots and by running the preceding
    code that the widgets can extend themselves to take up as much space as they need
    in order to visually display their text.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，从之前的截图和运行前面的代码中，小部件可以扩展自己，以占据它们需要的空间来视觉上显示它们的文本。
- en: Java introduced the concept of dynamic GUI layout management. In comparison,
    visual development IDEs, such as VS.NET, lay out the GUI in a visual manner, and
    basically hard-code the x and y coordinates of the UI elements.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Java引入了动态GUI布局管理的概念。相比之下，像VS.NET这样的可视化开发IDE以可视化的方式布局GUI，并且基本上硬编码了UI元素的x和y坐标。
- en: Using `tkinter`, this dynamic capability creates both an advantage and a little
    bit of a challenge because, sometimes, our GUI dynamically expands when we would
    like it not to be so dynamic! Well, we are dynamic Python programmers, so we can
    figure out how to make the best use of this fantastic behavior!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`tkinter`，这种动态能力既带来了一些优势，也带来了一点挑战，因为有时我们希望GUI不这么动态扩展时，它却会动态扩展！嗯，我们是动态的Python程序员，所以我们可以找出如何充分利用这种出色的行为！
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: At the beginning of the previous recipe, *Using padding to add space around
    widgets*, we added a `LabelFrame` widget. This moved some of our controls to the
    center of column `0`. We might not want this modification in our GUI layout. We
    will explore some ways to solve this in this recipe.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱的开始部分，*使用填充在控件周围添加空间*，我们添加了一个`LabelFrame`小部件。这将一些控件移动到了列`0`的中心。我们可能不希望我们的GUI布局有这种修改。我们将在这个菜谱中探讨一些解决方法。
- en: First, let's take a look at the subtle details that are going on in our GUI
    layout in order to understand it better.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们仔细观察一下我们的GUI布局中正在进行的微妙细节，以便更好地理解它。
- en: We are using the `grid` layout manager widget, which places our widgets in a
    zero-based grid. This is very similar to an Excel spreadsheet or a database table.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`grid`布局管理器小部件，它将我们的小部件放置在一个基于零的网格中。这非常类似于Excel电子表格或数据库表。
- en: 'The following is an example of a grid layout manager with two rows and three
    columns:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个具有两行和三列的网格布局管理器示例：
- en: '| Row 0; Col 0 | Row 0; Col 1 | Row 0; Col 2 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 行0；列0 | 行0；列1 | 行0；列2 |'
- en: '| Row 1; Col 0 | Row 1; Col 1 | Row 1; Col 2 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 行1；列0 | 行1；列1 | 行1；列2 |'
- en: Using the grid layout manager, the width of any given column is determined by
    the longest name or widget in that column. This, in turn, affects all of the rows.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网格布局管理器，任何给定列的宽度由该列中最长名称或小部件决定。这反过来又影响所有行。
- en: By adding our `LabelFrame` widget and giving it a title that is longer than
    a hard-coded size widget, we dynamically move those widgets to the center of column
    0\. By doing so, we are adding space on the left- and right-hand side of those
    widgets.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加我们的`LabelFrame`小部件并给它一个比硬编码大小小部件更长的标题，我们动态地将这些小部件移动到列0的中心。这样做，我们在这些小部件的左右两侧添加了空间。
- en: Incidentally, because we used the sticky property for the `Checkbutton` and
    `ScrolledText` widgets, those remain attached to the left-hand side of the frame.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，因为我们使用了`Checkbutton`和`ScrolledText`小部件的粘性属性，所以它们仍然附着在框架的左侧。
- en: Let's take a look at the screenshot from the first recipe in this chapter, *Arranging
    several labels within a label frame widget*, in more detail.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看本章第一个菜谱*在标签框架小部件内排列几个标签*的截图。
- en: 'Since the text property of `LabelFrame`, which is displayed as the title of
    `LabelFrame`, is longer than both our `Enter a name:` label and the text box entry
    below it, those two widgets are dynamically centered within the new width of column
    0, as shown in the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`LabelFrame`的文本属性（作为`LabelFrame`的标题显示），比我们的`输入一个名字：`标签和下面的文本框输入都要长，因此这两个小部件在新的列0宽度内动态居中，如下面的截图所示：
- en: '![](img/9968bf9b-acca-401d-b6c7-46b30443f209.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9968bf9b-acca-401d-b6c7-46b30443f209.png)'
- en: Notice how both the label and the entry below it are no longer positioned on
    the left but have been moved to the center within the grid column.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，下面的标签和输入框不再位于左侧，而是已经移动到网格列的中心。
- en: 'We added the following code to `GUI_LabelFrame_no_name.py` to create a `LabelFrame`
    and then placed labels in this frame to stretch both the `Label` frame and the
    widgets contained therein:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `GUI_LabelFrame_no_name.py` 添加了以下代码以创建一个 `LabelFrame`，然后在这个框架中放置标签以拉伸 `Label`
    框架及其包含的小部件：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Checkbutton` and `Radiobutton` widgets in column `0` did not get centered
    because we used the `sticky=tk.W` attribute when we created those widgets.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这些小部件时，我们使用了 `sticky=tk.W` 属性，因此列 `0` 中的 `Checkbutton` 和 `Radiobutton` 小部件没有居中。
- en: For the `ScrolledText` widget, we also used `sticky=tk.WE`, which binds the
    widget to both the west (the left) and east (the right) side of the frame.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `ScrolledText` 小部件，我们也使用了 `sticky=tk.WE`，这将小部件绑定到框架的西边（左边）和东边（右边）。
- en: The `sticky` attribute is available in `tkinter` and aligns widgets within the
    `grid` control.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`sticky` 属性在 `tkinter` 中可用，并在 `grid` 控制中定位小部件。'
- en: How to do it…
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to complete this recipe:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此配方：
- en: Open `GUI_arranging_labels.py` and save it as `GUI_remove_sticky.py`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_arranging_labels.py` 并将其保存为 `GUI_remove_sticky.py`。
- en: Remove the `sticky` attribute from the `ScrolledText` widget and observe the
    effect this change has.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `ScrolledText` 小部件中移除 `sticky` 属性并观察这种变化带来的效果。
- en: 'The preceding instructions produce the following code. Notice how the original
    `src.grid(...)` is now commented out and the new `src.grid(...)` no longer has
    the `sticky` attribute:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上述指令生成以下代码。注意原始的 `src.grid(...)` 现在已被注释掉，新的 `src.grid(...)` 不再具有 `sticky` 属性：
- en: '![](img/0d4e7aa9-a676-4021-8a85-060b5a690434.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d4e7aa9-a676-4021-8a85-060b5a690434.png)'
- en: 'Run the code. Now our GUI has a new space around the `ScrolledText` widget,
    both on the left- and right-hand sides. Because we used the `columnspan=3` property,
    our `ScrolledText` widget still spans all three columns. This is shown in the
    following screenshot:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。现在我们的 GUI 在 `ScrolledText` 小部件的左右两侧都出现了一个新的空间。因为我们使用了 `columnspan=3` 属性，所以
    `ScrolledText` 小部件仍然跨越了所有三个列。这在下图中可以显示：
- en: '![](img/dc8b8ec3-9633-4623-ada6-a36d76a20d83.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc8b8ec3-9633-4623-ada6-a36d76a20d83.png)'
- en: Using `columnspan` is necessary to arrange our GUI in the way we desire it to
    look.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `columnspan` 是为了以我们期望的方式排列我们的 GUI。
- en: 'Let''s take a look at how *not* using the `columnspan` attribute could screw
    up our nice GUI design by doing the following modifications:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看不使用 `columnspan` 属性会如何通过以下修改破坏我们漂亮的 GUI 设计：
- en: Open `GUI_remove_sticky.py` and save it as `GUI_remove_columnspan.py`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_remove_sticky.py` 并将其保存为 `GUI_remove_columnspan.py`。
- en: If we remove `columnspan=3`, we'll get the GUI that's shown in the following
    screenshot, which is not what we want. Now `ScrolledText` only occupies column
    0 and, because of its size, stretches the layout.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们移除 `columnspan=3`，我们将得到下图中显示的 GUI，这不是我们想要的。现在 `ScrolledText` 只占用列 0，并且由于其大小，拉伸了布局。
- en: 'Run the `GUI_remove_columnspan.py` file and observe the output:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `GUI_remove_columnspan.py` 文件并观察输出：
- en: '![](img/670f41ab-d0a3-4d62-941c-0dc7e6156e8e.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/670f41ab-d0a3-4d62-941c-0dc7e6156e8e.png)'
- en: 'One way to get our layout back to where it was before adding `LabelFrame` is
    to adjust the grid column position. Let''s get started:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将布局恢复到添加 `LabelFrame` 之前的一种方法是通过调整网格列位置。让我们开始吧：
- en: Open `GUI_remove_columnspan.py` and save it as `GUI_LabelFrame_column_one.py`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_remove_columnspan.py` 并将其保存为 `GUI_LabelFrame_column_one.py`。
- en: 'Change the column value from `0` to `1`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将列值从 `0` 更改为 `1`：
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the code. Now our GUI will look as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。现在我们的 GUI 将如下所示：
- en: '![](img/c840f608-2cf3-49b9-a2e8-ddbe621ea47c.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c840f608-2cf3-49b9-a2e8-ddbe621ea47c.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码，以更好地理解。
- en: How it works…
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Because we are still using individual widgets, our layout can get messed up.
    By moving the column value of `LabelFrame` from `0` to `1`, we were able to get
    the controls back to where they used to be and where we prefer them to be. The
    left-most label, text, `Checkbutton`, `ScrolledText`, and `Radiobutton` widgets
    are now located where we intended them to be. The second label and the `Entry`
    text located in column `1` aligned themselves to the center of the length of the
    **Labels in a Frame** widget, so we basically moved our alignment challenge one
    column to the right. It is not so visible now because the size of the **Choose
    a number:** label is almost the same as the size of the **Labels in a Frame**
    title, and so the column's width was already close to the new width that was generated
    by `LabelFrame`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们仍在使用单个小部件，我们的布局可能会变得混乱。通过将 `LabelFrame` 的列值从 `0` 更改为 `1`，我们能够将控件恢复到它们原来的位置，以及我们希望它们所在的位置。最左边的标签、文本、`Checkbutton`、`ScrolledText`
    和 `Radiobutton` 小部件现在位于我们打算它们所在的位置。第二个标签和位于列 `1` 的 `Entry` 文本自动对齐到框架内 `Labels
    in a Frame` 小部件长度的中心，所以我们基本上将我们的对齐挑战向右移动了一列。现在它不太明显，因为 **Choose a number:** 标签的大小几乎与
    **Labels in a Frame** 标题的大小相同，因此列的宽度已经接近由 `LabelFrame` 生成的新的宽度。
- en: There's more…
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the next recipe, *Aligning GUI widgets by embedding frames within frames*,
    we will embed frames within frames to avoid the accidental misalignment of widgets
    we just experienced in this recipe.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，*通过在框架内嵌入框架对齐 GUI 小部件*，我们将嵌入框架以避免在本菜谱中刚刚经历的意外小部件错位。
- en: We've successfully learned how to dynamically expand the GUI using widgets.
    Now let's move on to the next recipe.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何使用小部件动态扩展 GUI。现在让我们继续下一个菜谱。
- en: Aligning GUI widgets by embedding frames within frames
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过在框架内嵌入框架来对齐 GUI 小部件
- en: We'll have better control of our GUI layout if we embed frames within frames.
    This is what we will do in this recipe.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在框架内嵌入框架，我们将更好地控制我们的 GUI 布局。这正是本菜谱中我们将要做的。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The dynamic behavior of Python and its GUI modules can create challenges when
    we want to make our GUI really look the way we want it to. In this recipe, we
    will embed frames within frames to get more control of our layout. This will establish
    a stronger hierarchy among the different UI elements, making the visual appearance
    easier to achieve.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要使我们的 GUI 真的看起来像我们想要的样子时，Python 的动态行为及其 GUI 模块可能会带来挑战。在本菜谱中，我们将嵌入框架以获得更多对布局的控制。这将在不同
    UI 元素之间建立更强的层次结构，使视觉外观更容易实现。
- en: We will continue using the GUI we created in the previous recipe, *Dynamically
    expanding the GUI using widgets*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用在前一个菜谱中创建的 GUI，*使用小部件动态扩展 GUI*。
- en: Here, we will create a top-level frame that will contain other frames and widgets.
    This will help us get our GUI layout just the way we want.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个顶层框架，它将包含其他框架和小部件。这将帮助我们获得我们想要的 GUI 布局。
- en: To do so, we will have to embed our current controls within a central frame
    called `ttk.LabelFrame`. This frame, `ttk.LabelFrame`, is the child of the main
    parent window, and all the controls will be the children of this `ttk.LabelFrame`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们必须在名为 `ttk.LabelFrame` 的中央框架中嵌入我们的当前控件。这个框架，`ttk.LabelFrame`，是主父窗口的子框架，所有的控件都将成为这个
    `ttk.LabelFrame` 的子框架。
- en: So far, we have assigned all the widgets to our main GUI frame directly. Now
    we will only assign `LabelFrame` to our main window. After that, we will make
    this `LabelFrame` the parent container for all the widgets.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已直接将所有小部件分配给我们的主 GUI 框架。现在，我们只将 `LabelFrame` 分配给我们的主窗口。之后，我们将使这个 `LabelFrame`
    成为所有小部件的父容器。
- en: 'This creates the following hierarchy in our GUI layout:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这就在我们的 GUI 布局中创建了以下层次结构：
- en: '![](img/d9721932-d117-4ac0-aaaf-1ca4e44f01c9.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9721932-d117-4ac0-aaaf-1ca4e44f01c9.png)'
- en: In the preceding diagram, `win` is the variable that holds a reference to our
    main GUI `tkinter` window frame, `mighty` is the variable that holds a reference
    to our `LabelFrame` and is a child of the main window frame (`win`), and `Label`
    and all the other widgets are now placed into the `LabelFrame` container (`mighty`).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，`win` 是一个变量，它保存着我们主 GUI `tkinter` 窗口框架的引用，`mighty` 是一个变量，它保存着我们 `LabelFrame`
    的引用，并且是主窗口框架（`win`）的子框架，而 `Label` 和所有其他小部件现在都放置在 `LabelFrame` 容器（`mighty`）中。
- en: How to do it…
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to complete this recipe:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成本菜谱：
- en: Open `GUI_LabelFrame_column_one.py` and save it as `GUI_embed_frames.py`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_LabelFrame_column_one.py` 并将其保存为 `GUI_embed_frames.py`。
- en: 'Add the following code toward the top of our Python module:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 Python 模块顶部添加以下代码：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, we will modify the following controls to use `mighty` as the parent, replacing
    `win`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改以下控件以使用 `mighty` 作为父级，替换 `win`。
- en: 'Change the Label parent from `win` to `mighty`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标签的父级从 `win` 更改为 `mighty`：
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the `GUI_embed_frames.py` file. This results in the GUI shown in the following
    screenshot:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `GUI_embed_frames.py` 文件。这将在以下屏幕截图中显示 GUI：
- en: '![](img/26eecbb3-1217-40be-b292-464b0b37ea4f.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26eecbb3-1217-40be-b292-464b0b37ea4f.png)'
- en: 'Note how all the widgets are now contained in the **Mighty Python** `LabelFrame`,
    which surrounds all of them with a barely visible thin line. Next, we can reset
    the **Labels in a Frame** widget to the left without messing up our GUI layout:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在所有小部件都包含在 **Mighty Python** 的 `LabelFrame` 中，它用几乎看不见的细线包围了它们。接下来，我们可以将 **Frame
    中的标签** 小部件重置为左对齐，而不会破坏我们的 GUI 布局：
- en: Open `GUI_embed_frames.py` and save it as `GUI_embed_frames_align.py`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_embed_frames.py` 并将其保存为 `GUI_embed_frames_align.py`。
- en: 'Change `column` to `0`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `column` 更改为 `0`：
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the `GUI_embed_frames_align.py` file. This results in the GUI shown in
    the following screenshot:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `GUI_embed_frames_align.py` 文件。这将在以下屏幕截图中显示 GUI：
- en: '![](img/aa170b34-aab9-4104-ba2b-b0cea80fb244.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa170b34-aab9-4104-ba2b-b0cea80fb244.png)'
- en: Oops – maybe not. While our frame-within-another-frame aligned nicely to the
    left, it pushed our top widgets to the center (the default setting).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀——可能不是这样。虽然我们的框架内的框架向左对齐得很好，但它将我们的顶部小部件推到了中心（默认设置）。
- en: 'To align them to the left, we have to force our GUI layout by using the `sticky`
    property. By assigning it `''W''` (west), we can force the widget to be left-aligned.
    Perform the following steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将它们左对齐，我们必须通过使用 `sticky` 属性强制我们的 GUI 布局。通过将其分配为 `'W'`（西），我们可以强制小部件左对齐。执行以下步骤：
- en: Open `GUI_embed_frames_align.py` and save it as `GUI_embed_frames_align_west.py`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_embed_frames_align.py` 并将其保存为 `GUI_embed_frames_align_west.py`。
- en: 'Add the `sticky` attribute to the label:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为标签添加 `sticky` 属性：
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the code. This gives us the following GUI:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。这给我们以下 GUI：
- en: '![](img/54f6b619-92dc-42da-9e7e-1f75cb2f88a8.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54f6b619-92dc-42da-9e7e-1f75cb2f88a8.png)'
- en: 'Let''s align the `Entry` widget in column `0` to the left:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 `Entry` 小部件在列 `0` 中左对齐：
- en: Open `GUI_embed_frames_align_west.py` and save it as `GUI_embed_frames_align_entry_west.py`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_embed_frames_align_west.py` 并将其保存为 `GUI_embed_frames_align_entry_west.py`。
- en: 'Use the `sticky` attribute to align the Entry left:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `sticky` 属性将输入框左对齐：
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the `GUI_embed_frames_align_entry_west.py` file. Now both the label and
    the entry are aligned toward the west (left):'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `GUI_embed_frames_align_entry_west.py` 文件。现在标签和输入框都向西方（左侧）对齐：
- en: '![](img/e592b996-0339-4ed6-a87f-640ea41863b9.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e592b996-0339-4ed6-a87f-640ea41863b9.png)'
- en: Now let's go behind the scenes to understand the code better.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解代码以更好地理解。
- en: How it works…
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Note how we aligned the label, but not the text box below it. We have to use
    the `sticky` property for all the controls we want to left-align. We can do that
    in a loop by using the `winfo_children()` and `grid_configure(sticky='W')` properties,
    as we did in the *Using padding to add space around widgets* recipe of this chapter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何对齐标签，但没有对下面的文本框进行对齐。我们必须对所有想要左对齐的控件使用 `sticky` 属性。我们可以通过使用 `winfo_children()`
    和 `grid_configure(sticky='W')` 属性在循环中做到这一点，就像我们在本章的 *使用填充在控件周围添加空间* 菜单中做的那样。
- en: The `winfo_children()` function returns a list of all the children belonging
    to the parent. This allows us to loop through all the widgets and change their
    properties.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`winfo_children()` 函数返回属于父级的所有子项的列表。这允许我们遍历所有小部件并更改它们的属性。'
- en: Using `tkinter` to force the naming to the left, right, top, or bottom is very
    similar to Java's West, East, North, and South, which are abbreviated to `'W'`,
    `'E'`, and so on. We can also use `tk.W` instead of `'W'`. This requires that
    we import the `tkinter` module aliased as `tk`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `tkinter` 强制将命名设置为左、右、上或下，这与 Java 的 West、East、North 和 South 非常相似，它们被缩写为 `'W'`、`'E'`
    等等。我们也可以使用 `tk.W` 而不是 `'W'`。这要求我们导入别名为 `tk` 的 `tkinter` 模块。
- en: 'In a previous recipe, we combined `''W''` and `''E''` to make our `ScrolledText`
    widget attach itself both to the left- and right-hand sides of its container.
    The result of combining `''W''` and `''E''` was `''WE''`. We can add more combinations
    as well: `''NSE''` will stretch our widget to the top, bottom, and right-hand
    side. If we only have one widget in our form, for example, a button, we can make
    it fill in the entire frame by using all the options, that is, `''NSWE''`. We
    can also use tuple syntax: `sticky=(tk.N, tk.S, tk.W, tk.E)`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们将 `'W'` 和 `'E'` 结合起来，使我们的 `ScrolledText` 小部件同时附着到其容器的左侧和右侧。将 `'W'`
    和 `'E'` 结合的结果是 `'WE'`。我们还可以添加更多的组合：`'NSE'` 将使我们的小部件扩展到顶部、底部和右侧。如果我们表单中只有一个小部件，例如一个按钮，我们可以使用所有选项使其填充整个框架，即
    `'NSWE'`。我们还可以使用元组语法：`sticky=(tk.N, tk.S, tk.W, tk.E)`。
- en: To obviate the influence that the length of our **Labels in a Frame** `LabelFrame`
    has on the rest of our GUI layout, we must not place this `LabelFrame` into the
    same `LabelFrame` as the other widgets. Instead, we need to assign it directly
    to the main GUI form (`win`).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除我们框架中的 **标签** `LabelFrame` 的长度对我们 GUI 布局其余部分的影响，我们不得将此 `LabelFrame` 放入与其他小部件相同的
    `LabelFrame` 中。相反，我们需要将其直接分配给主 GUI 表单 (`win`)。
- en: We've successfully learned how to align the GUI widget by embedding frames with
    frames. Now let's move on to the next recipe.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何通过嵌套框架来对齐 GUI 小部件。现在让我们继续进行下一个菜谱。
- en: Creating menu bars
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建菜单栏
- en: In this recipe, we will add a menu bar to our main window, add menus to the
    menu bar, and then add menu items to the menus.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将向主窗口添加菜单栏，向菜单栏添加菜单，然后向菜单添加菜单项。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start by learning how to add a menu bar, several menus, and a few menu
    items. In the beginning, clicking on a menu item will have no effect. We will
    add functionality to the menu items later, for example, closing the main window
    when clicking the Exit menu item and displaying a Help | About dialog.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习如何添加菜单栏、几个菜单和几个菜单项。一开始，点击菜单项不会有任何效果。我们将在稍后为菜单项添加功能，例如，当点击退出菜单项时关闭主窗口，并显示帮助
    | 关于对话框。
- en: We will continue to extend the GUI we created in the previous recipe, *Aligning
    GUI widgets by embedding frames within frames*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续扩展我们在上一个菜谱中创建的 GUI，即 *通过在框架内嵌套框架对齐 GUI 小部件*。
- en: How to do it…
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a menu bar, follow these steps:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建菜单栏，请按照以下步骤操作：
- en: Open `GUI_embed_frames_align_entry_west.py` and save it as `GUI_menubar_file.py`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_embed_frames_align_entry_west.py` 并将其保存为 `GUI_menubar_file.py`。
- en: 'Import the `Menu` class from `tkinter`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `tkinter` 导入 `Menu` 类：
- en: '[PRE14]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we will create the menu bar. Add the following code toward the bottom
    of the module, just above where we created the main event loop:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建菜单栏。在模块底部，在创建主事件循环之前添加以下代码：
- en: '[PRE15]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding instructions produce the following code from the `GUI_menubar_file.py`
    file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上述指令从 `GUI_menubar_file.py` 文件生成了以下代码：
- en: '![](img/da98614c-5f97-42bf-82a7-f38e7f5181b6.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da98614c-5f97-42bf-82a7-f38e7f5181b6.png)'
- en: In line 119, we are calling the constructor of the imported `Menu` module class
    and passing in our main GUI instance, `win`. We save an instance of the `Menu`
    object in the `menu_bar` variable. In line 120, we configure our GUI to use our
    newly created `Menu` as the menu for our GUI.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 119 行，我们调用导入的 `Menu` 模块类的构造函数，并传入我们的主 GUI 实例 `win`。我们将 `Menu` 对象的实例保存在 `menu_bar`
    变量中。在第 120 行，我们配置我们的 GUI 使用我们新创建的 `Menu` 作为 GUI 的菜单。
- en: To make this work, we also have to add the menu to the menu bar and give it
    a label.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其工作，我们还需要将菜单添加到菜单栏，并给它一个标签。
- en: 'The menu item was already added to the menu, but we still have to add the menu
    to the menu bar:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 菜单项已经被添加到菜单中，但我们仍然需要将菜单添加到菜单栏中：
- en: '[PRE16]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Running the preceding code adds a menu bar with a menu that has a menu item.
    This is shown in the following screenshot:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行上述代码添加了一个带有菜单项的菜单栏。这在上面的屏幕截图中有显示：
- en: '![](img/6a0adda3-0f87-4ccd-8f15-1f69030c28f7.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a0adda3-0f87-4ccd-8f15-1f69030c28f7.png)'
- en: If this `tkinter` menu bar syntax seems a little bit confusing, don't worry.
    This is just the syntax of `tkinter` for creating a menu bar. It isn't very Pythonic.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个 `tkinter` 菜单栏语法看起来有点复杂，不要担心。这只是 `tkinter` 创建菜单栏的语法。它并不非常 Pythonic。
- en: 'Next, we''ll add a second menu item to the first menu that we added to the
    menu bar. This can be done by performing the following steps:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向第一个菜单添加第二个菜单项，该菜单已添加到菜单栏中。可以通过以下步骤完成：
- en: Open `GUI_menubar_file.py` and save it as `GUI_menubar_exit.py`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_menubar_file.py` 并将其保存为 `GUI_menubar_exit.py`。
- en: 'Add the Exit menu item:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加退出菜单项：
- en: '[PRE17]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Running the preceding code produces the following result, that is, `GUI_menubar_exit.py`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下结果，即`GUI_menubar_exit.py`：
- en: '![](img/e7a9db04-5c15-4377-9072-97ab9a4a1021.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7a9db04-5c15-4377-9072-97ab9a4a1021.png)'
- en: 'We can add separator lines between the menu items by adding a line of code
    in-between the existing menu items. This can be done by performing the following
    steps:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在现有菜单项之间添加一行代码来在菜单项之间添加分隔线。这可以通过以下步骤完成：
- en: Open `GUI_menubar_exit.py` and save it as `GUI_menubar_separator.py`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_menubar_exit.py`并将其保存为`GUI_menubar_separator.py`。
- en: 'Add a separator, as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个分隔线，如下所示：
- en: '[PRE18]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the preceding code. In the following screenshot, we can see that a separator
    line has been added in-between our two menu items:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码。在以下屏幕截图中，我们可以看到在两个菜单项之间添加了一条分隔线：
- en: '![](img/fff83e44-5dc7-4130-9ad1-74eb315127bf.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fff83e44-5dc7-4130-9ad1-74eb315127bf.png)'
- en: 'By passing in the `tearoff` property to the constructor of the menu, we can
    remove the first dashed line that, by default, appears above the first menu item
    in a menu. This can be done by performing the following steps:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`tearoff`属性传递给菜单的构造函数，我们可以移除默认情况下出现在菜单第一个菜单项上方的第一条虚线。这可以通过以下步骤完成：
- en: Open `GUI_menubar_separator.py` and save it as `GUI_menubar_tearoff.py`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_menubar_separator.py`并将其保存为`GUI_menubar_tearoff.py`。
- en: 'Set the `tearoff` attribute to `0`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`tearoff`属性设置为`0`：
- en: '[PRE19]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the preceding code. In the following screenshot, the dashed line no longer
    appears, and our GUI looks so much better:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码。在以下屏幕截图中，虚线不再出现，我们的GUI看起来好多了：
- en: '![](img/b12cde19-95bf-4853-b0f9-a12b0ce98605.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b12cde19-95bf-4853-b0f9-a12b0ce98605.png)'
- en: Next, we'll add a second menu, `Help`, which will be placed horizontally, to
    the right of the first menu. We'll give it one menu item, named `About`, and add
    this second menu to the menu bar.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加第二个菜单，名为`Help`，它将水平放置在第一个菜单的右侧。我们将给它一个名为`About`的菜单项，并将这个第二个菜单添加到菜单栏中。
- en: '**File** and **Help | About** are very common Windows GUI layouts we are all
    familiar with, and we can create these same menus using Python and `tkinter`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件**和**帮助 | 关于**是我们都非常熟悉的常见Windows GUI布局，我们可以使用Python和`tkinter`创建相同的菜单：'
- en: Open `GUI_menubar_tearoff.py` and save it as `GUI_menubar_help.py`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_menubar_tearoff.py`并将其保存为`GUI_menubar_help.py`。
- en: 'Add a second menu with a menu item:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个带有菜单项的第二个菜单：
- en: '[PRE20]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding instructions produce the following code, which can be found in
    the `GUI_menubar_help.py` file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的说明会产生以下代码，该代码可以在`GUI_menubar_help.py`文件中找到：
- en: '![](img/b1ae02a1-4572-45af-81bf-019732b4cce2.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1ae02a1-4572-45af-81bf-019732b4cce2.png)'
- en: 'Run the preceding code. As shown in the following screenshot, we have a second
    menu with a menu item in the menu bar:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码。如图所示，我们有一个带有菜单栏的第二个菜单项：
- en: '![](img/e1c5042f-9250-4409-9e29-637a6c019e3d.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1c5042f-9250-4409-9e29-637a6c019e3d.png)'
- en: 'At this point, our GUI has a menu bar and two menus that contain some menu
    items. Clicking on them doesn''t do much until we add some commands. That''s what
    we will do next. Perform the following actions, above the code for the creation
    of the menu bar:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的GUI有一个菜单栏和两个包含一些菜单项的菜单。点击它们并不会做太多，直到我们添加一些命令。这就是我们接下来要做的。在创建菜单栏的代码上方执行以下操作：
- en: Open `GUI_menubar_help.py` and save it as `GUI_menubar_exit_quit.py`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_menubar_help.py`并将其保存为`GUI_menubar_exit_quit.py`。
- en: 'Create a `quit` function:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`quit`函数：
- en: '[PRE21]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we''ll bind the **File | Exit** menu item to this function by adding
    the following command to the menu item:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过向菜单项添加以下命令将`File | Exit`菜单项绑定到该函数：
- en: '[PRE22]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding instructions produce the following code, which can be found in
    the `GUI_menubar_exit_quit.py` file:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的说明会产生以下代码，该代码可以在`GUI_menubar_exit_quit.py`文件中找到：
- en: '![](img/800f8cd8-f832-4a8f-ad1f-d7167af5cb04.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/800f8cd8-f832-4a8f-ad1f-d7167af5cb04.png)'
- en: 'Run the code and click the Exit menu item. The following GUI shows the output
    of the code we run:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并点击退出菜单项。以下GUI显示了我们所运行代码的输出：
- en: '![](img/090f67fe-7bd9-4c69-b822-4deac2e6b4d0.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/090f67fe-7bd9-4c69-b822-4deac2e6b4d0.png)'
- en: When we click the **Exit** menu item, our application will indeed exit.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击**退出**菜单项时，我们的应用程序确实会退出。
- en: Now let's go behind the scenes to understand the code better.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works…
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: First, we call the `tkinter` constructor of the `Menu` class. Then, we assign
    the newly created menu to our main GUI window. This, in fact, becomes the menu
    bar. We save a reference to it in the instance variable named `menu_bar`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用`Menu`类的`tkinter`构造函数。然后，我们将新创建的菜单分配给我们的主GUI窗口。实际上，这变成了菜单栏。我们将其引用保存在名为`menu_bar`的实例变量中。
- en: Next, we create a menu and add two menu items to the menu. The `add_cascade()`
    method aligns the menu items one below the other, in a vertical layout.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个菜单并添加两个菜单项到菜单中。`add_cascade()`方法将菜单项一个接一个地排列，形成一个垂直布局。
- en: Then, we add a separator line between the two menu items. This is generally
    used to group related menu items (hence the name).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在两个菜单项之间添加一条分隔线。这通常用于将相关的菜单项分组（因此得名）。
- en: Finally, we disable the `tearoff` dashed line to make our menu look much better.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们禁用`tearoff`虚线，使我们的菜单看起来更好。
- en: Without disabling this default feature, the user can tear off the menu from
    the main window. I find this capability of little value. Feel free to play around
    with it by double-clicking the dashed line (before disabling this feature). If
    you are using a Mac, this feature might not be enabled; if so, you don't have
    to worry about it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在不禁用此默认功能的情况下，用户可以撕下菜单从主窗口。我发现这个功能价值不大。您可以自由地通过双击虚线（在禁用此功能之前）来尝试它。如果您使用的是Mac，这个功能可能没有被启用；如果是这样，您不必担心。
- en: We then add a second menu to the menu bar. We can keep on adding menus using
    this technique.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着在菜单栏中添加第二个菜单。我们可以继续使用这种技术添加菜单。
- en: Next, we create a function to quit our GUI application cleanly. How we quit
    a running Python application is the recommended Pythonic way to end the main event
    loop.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个函数来干净地退出我们的GUI应用程序。如何退出正在运行的Python应用程序是推荐的方式来结束主事件循环。
- en: We bind the function we created to the menu item, which is the standard way
    of binding a function to a menu item, using `command` attribute of `tkinter`.
    Whenever we want our menu items to actually do something, we have to bind each
    of them to a function.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们创建的函数绑定到菜单项上，这是将函数绑定到菜单项的标准方式，使用`tkinter`的`command`属性。每次我们想让我们的菜单项真正做些什么时，我们必须将它们中的每一个绑定到一个函数上。
- en: We are using a recommended Python naming convention by preceding our quit function
    with one single underscore. This indicates that this is a private function that
    can't be called by the clients of our code.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循推荐的Python命名约定，在退出函数前加一个单下划线，这表示这是一个私有函数，不能被我们的代码客户端调用。
- en: There's more…
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: We will add the **Help | About** functionality in [Chapter 3](ad17a5cd-0b92-4796-96b8-35151c3bbf44.xhtml),
    *Look and Feel Customization*, which introduces message boxes and much more.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](ad17a5cd-0b92-4796-96b8-35151c3bbf44.xhtml)中添加**帮助 | 关于**功能，*外观定制*，它介绍了消息框以及更多内容。
- en: We've successfully learned how to create menu bars. Now let's move on to the
    next recipe.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地学习了如何创建菜单栏。现在让我们继续到下一个菜谱。
- en: Creating tabbed widgets
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建标签式小部件
- en: In this recipe, we will create tabbed widgets to further organize our expanding
    GUI written in `tkinter`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建标签式小部件来进一步组织我们用`tkinter`编写的扩展GUI。
- en: Getting ready
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To improve our Python GUI using tabs, we will start at the beginning, using
    as little code as possible. In this recipe, we will create a simple GUI and then
    add widgets from the previous recipes, placing them in this new tabbed layout.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进我们的Python GUI使用标签，我们将从最基础开始，尽可能少地使用代码。在这个菜谱中，我们将创建一个简单的GUI，然后从之前的菜谱中添加小部件，将它们放置在这个新的标签布局中。
- en: How to do it…
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to create *Tab* controls, which in `tkinter` are called
    `Notebook`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建*标签*控件，在`tkinter`中称为`Notebook`：
- en: Create a new Python module and name it `GUI_tabbed.py`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python模块，并将其命名为`GUI_tabbed.py`。
- en: 'At the top of the module, import `tkinter`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模块顶部，导入`tkinter`：
- en: '[PRE23]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create an instance of the `Tk` class:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Tk`类的实例：
- en: '[PRE24]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add a title via the `title` attribute:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`title`属性添加标题：
- en: '[PRE25]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create `tabControl` using the `ttk` `Notebook`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ttk`的`Notebook`创建`tabControl`：
- en: '[PRE26]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the tab to `tabControl`:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标签添加到`tabControl`：
- en: '[PRE27]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Use `pack` to make the control visible inside the GUI:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pack`使控件在GUI中可见：
- en: '[PRE28]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding instructions produce the following code, which can be found in
    the `GUI_tabbed.py` file:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 上述指令生成以下代码，可以在`GUI_tabbed.py`文件中找到：
- en: '![](img/12d3f1af-2862-47b7-88f7-f42ee3dc492e.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/12d3f1af-2862-47b7-88f7-f42ee3dc492e.png)'
- en: 'Run the preceding code. The following screenshot shows the GUI after running
    the code:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行上述代码。以下截图显示了运行代码后的GUI：
- en: '![](img/31b9d3e2-f357-46c3-a477-fcd4d6a84bc1.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31b9d3e2-f357-46c3-a477-fcd4d6a84bc1.png)'
- en: This widget adds another very powerful tool to our GUI design toolkit. It comes
    with its own limitations, all of which can be seen in this recipe (for example,
    we can neither reposition the GUI nor does it show the entire GUI title).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此小部件为我们GUI设计工具包添加了另一个非常强大的工具。它带有自己的限制，所有这些限制都可以在本菜谱中看到（例如，我们无法重新定位GUI，它也不显示整个GUI标题）。
- en: 'While we used the grid layout manager for simpler GUIs in the previous recipes,
    we can use a simpler layout manager: `pack` is one of them.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在前面的菜谱中使用了网格布局管理器来简化GUI，但我们可以使用一个更简单的布局管理器：`pack` 就是其中之一。
- en: 'In the preceding code, we pack the `tabControl` and `ttk.Notebook` widgets
    into the main GUI form, expanding the notebook-tabbed control to fill in all the
    sides. We can add a second tab to our control and click between them by performing
    the following steps:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将 `tabControl` 和 `ttk.Notebook` 小部件打包到主GUI表单中，将笔记本标签式控制扩展到填充所有侧面。我们可以通过以下步骤向我们的控制中添加第二个标签页并在这两者之间点击：
- en: Open `GUI_tabbed.py` and save it as `GUI_tabbed_two.py`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_tabbed.py` 并将其保存为 `GUI_tabbed_two.py`。
- en: 'Add a second tab:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第二个标签：
- en: '[PRE29]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the preceding code. In the following screenshot, we have two tabs. Click
    on Tab 2 to give it focus:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码。在下面的屏幕截图中，我们有两个标签页。点击标签2以使其获得焦点：
- en: '![](img/d4b7c673-6726-42a2-b445-1889d574c4d0.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4b7c673-6726-42a2-b445-1889d574c4d0.png)'
- en: 'We would really like to see our window''s title; to do this, we have to add
    a widget to one of our tabs. The widget has to be wide enough to expand our GUI
    dynamically so as to display our window title. Follow these steps to do so:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常希望看到窗口的标题；为此，我们必须向我们的标签之一添加一个小部件。这个小部件必须足够宽，以便动态扩展我们的GUI以显示窗口标题。按照以下步骤操作：
- en: Open `GUI_tabbed_two.py` and save it as `GUI_tabbed_two_mighty.py`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_tabbed_two.py` 并将其保存为 `GUI_tabbed_two_mighty.py`。
- en: 'Add a `LabelFrame` and a `Label`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `LabelFrame` 和一个 `Label`：
- en: '[PRE30]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run the preceding code. As shown in the following screenshot, we have **Mighty
    Python** inside **Tab 1**. This expands our GUI, but the added widgets aren''t
    large enough to make the GUI title visible:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码。如以下屏幕截图所示，我们在**标签1**内看到 **Mighty Python**。这扩展了我们的GUI，但添加的小部件不够大，无法使GUI标题可见：
- en: '![](img/4a51da43-5e68-42f9-8289-5d63622945ee.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a51da43-5e68-42f9-8289-5d63622945ee.png)'
- en: 'After adding a second label plus some spacing around them, we stretch the layout
    enough so we can see our GUI title again:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加第二个标签以及它们周围的一些间距后，我们将布局拉伸足够长，以便再次看到我们的GUI标题：
- en: Open `GUI_tabbed_two_mighty.py` and save it as `GUI_tabbed_two_mighty_labels.py`.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_tabbed_two_mighty.py` 并将其保存为 `GUI_tabbed_two_mighty_labels.py`。
- en: 'Add a second label and spacing via a loop:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过循环添加第二个标签和一些间距：
- en: '[PRE31]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the preceding code. The following screenshot shows the output from running
    this code, which can also be found in the `GUI_tabbed_two_mighty_labels.py` file:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码。下面的屏幕截图显示了运行此代码的输出，该输出也可以在 `GUI_tabbed_two_mighty_labels.py` 文件中找到：
- en: '![](img/ca8a9263-f524-4ab6-95b4-edf0d889840c.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca8a9263-f524-4ab6-95b4-edf0d889840c.png)'
- en: We can keep placing all the widgets we have created so far into our newly created
    tab controls.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将迄今为止创建的所有小部件都放置到我们新创建的标签页控制中。
- en: You can download the code from [https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Third-Edition](https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Third-Edition).
    Try to create the tabbed GUI yourself. We have created and aligned all of the
    widgets in the previous recipes, but without placing them onto two different tabs.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Third-Edition](https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Third-Edition)
    下载代码。尝试自己创建标签式GUI。我们在前面的菜谱中创建并排列了所有小部件，但尚未将它们放置在两个不同的标签页上。
- en: 'Look at the `GUI_tabbed_all_widgets.py` file:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 `GUI_tabbed_all_widgets.py` 文件：
- en: '![](img/929ce7d1-3c99-43d1-be2c-75236bc872a7.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](img/929ce7d1-3c99-43d1-be2c-75236bc872a7.png)'
- en: 'As you can see, all the widgets reside inside **Tab 1**. Let''s move some of
    them to **Tab 2**:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有小部件都位于**标签1**内。让我们将其中一些移动到**标签2**：
- en: 'Create a second `LabelFrame`, which will be the container of the widgets we
    will be relocating to **Tab 2**:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个 `LabelFrame`，它将成为我们将要重新定位到**标签2**的小部件的容器：
- en: '[PRE32]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we move the `Check` and `Radio` buttons to **Tab 2** by specifying the
    new parent container, which is a new variable that we name `mighty2`. The following
    is an example that we will apply to all the controls that relocate to Tab 2:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将`Check`和`Radio`按钮移动到**标签2**，通过指定新的父容器，即我们命名为`mighty2`的新变量。以下是我们将应用于所有移动到标签2的控制的一个示例：
- en: '[PRE33]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the `GUI_tabbed_all_widgets_both_tabs.py` file. The following screenshot
    shows the output we receive after running the preceding code:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`GUI_tabbed_all_widgets_both_tabs.py`文件。下面的截图显示了运行前面代码后的输出：
- en: '![](img/bb8e64c8-e598-4af3-ad59-85aa3779589e.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb8e64c8-e598-4af3-ad59-85aa3779589e.png)'
- en: 'We can now click on Tab 2 and see our relocated widgets:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以点击标签2并看到我们重新定位的小部件：
- en: '![](img/3aa893f1-d0e4-40aa-aa61-a9d70c849c6b.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3aa893f1-d0e4-40aa-aa61-a9d70c849c6b.png)'
- en: After running the preceding code, our GUI looks different. Tab 1 has fewer widgets
    than it had before when it contained all of our previously created widgets.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行前面的代码后，我们的GUI看起来不同。标签1比之前包含所有之前创建的小部件时少。
- en: 'Clicking the relocated `Radiobutton` no longer has any effect, so we will change
    their actions to renaming the text attribute, from the title of the `LabelFrame`
    widget to the name the `Radiobuttons` display. When we click the **Gold** `Radiobutton`,
    we no longer set the background of the frame to the color gold. Instead, we replace
    the `LabelFrame` text title. Python''s **The Snake** now becomes **Gold**:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 点击重新定位的`Radiobutton`不再有任何效果，因此我们将它们的动作更改为重命名文本属性，从`LabelFrame`小部件的标题更改为`Radiobuttons`显示的名称。当我们点击**金色**`Radiobutton`时，我们不再将框架的背景设置为金色。相反，我们替换`LabelFrame`的文本标题。Python的**蛇**现在变为**金色**：
- en: '[PRE34]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now selecting any of the `RadioButton` widgets will change the name of the `LabelFrame`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在选择任何`RadioButton`小部件都会更改`LabelFrame`的名称。
- en: 'Run the `GUI_tabbed_all_widgets_both_tabs_radio.py` file. The following screenshot
    shows the output of running the code in this file:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`GUI_tabbed_all_widgets_both_tabs_radio.py`文件。下面的截图显示了运行此文件中代码的输出：
- en: '![](img/630e8e72-9a73-4be2-8afd-19def398719e.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/630e8e72-9a73-4be2-8afd-19def398719e.png)'
- en: 'Notice how the label frame is now titled Blue. Clicking on the Gold radio button
    changes this title to Gold, as shown in the following screenshot:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意标签框架现在被命名为蓝色。点击金色单选按钮会将标题更改为金色，如下面的截图所示：
- en: '![](img/476fb400-d1bc-4636-9587-2e39b0b0db04.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/476fb400-d1bc-4636-9587-2e39b0b0db04.png)'
- en: Now let's go behind the scenes to understand the code better.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码以更好地理解它。
- en: How it works…
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: On executing the code to create Tab 1, it is created but without any information
    in it. We then created a second tab, Tab 2\. After creating the second tab, we
    moved some of the widgets that originally resided in **Tab 1** to **Tab 2**. Adding
    tabs is another excellent way to organize our ever-increasing GUI. This is a nice
    way to handle the complexity of our GUI design. We can arrange widgets in groups,
    where they naturally belong, and free our users from clutter by using tabs.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行创建标签1的代码时，它被创建，但没有包含任何信息。然后我们创建了一个第二个标签，标签2。在创建第二个标签后，我们将原本位于**标签1**中的某些小部件移动到了**标签2**。添加标签是组织我们不断增加的GUI的另一种绝佳方式。这是一种处理GUI设计复杂性的好方法。我们可以将小部件分组排列，使它们自然地属于一组，并通过使用标签来让用户摆脱杂乱。
- en: 'In `tkinter`, creating tabs is done via the `Notebook` widget, which is the
    tool that allows us to add tabbed controls. The `tkinter notebook` widget, like
    so many other widgets, comes with additional properties that we can use and configure.
    An excellent place to start exploring the additional capabilities of the `tkinter`
    widgets at our disposal is the official website: [https://docs.python.org/3.1/library/tkinter.ttk.html#notebook](https://docs.python.org/3.1/library/tkinter.ttk.html#notebook).'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tkinter`中，创建标签是通过`Notebook`小部件完成的，这是允许我们添加标签控制的工具。与许多其他小部件一样，`tkinter notebook`小部件附带了一些额外的属性，我们可以使用和配置。探索我们可用的`tkinter`小部件的额外功能的一个绝佳起点是官方网站：[https://docs.python.org/3.1/library/tkinter.ttk.html#notebook](https://docs.python.org/3.1/library/tkinter.ttk.html#notebook)。
- en: We've successfully learned how to create tabbed widgets. Now let's move on to
    the next recipe.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何创建标签小部件。现在让我们继续下一个菜谱。
- en: Using the grid layout manager
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网格布局管理器
- en: The grid layout manager is one of the most useful layout tools at our disposal.
    While layout tools such as `pack` are simple and easy to use, `grid` gives us
    a lot of control over our layout – especially when we combine `grid` with embedded
    `frames`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 网格布局管理器是我们可用的最有用的布局工具之一。虽然`pack`等布局工具简单易用，但`grid`为我们提供了对布局的更多控制——尤其是在我们将`grid`与嵌入式`frames`结合使用时。
- en: We have already used it in many recipes, for example, because it is just so
    powerful.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在许多菜谱中使用了它，例如，因为它真的很强大。
- en: Getting ready…
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作…
- en: In this recipe, we will review some grid layout manager techniques. We have
    already used them, but we will explore them in more detail here.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将回顾一些网格布局管理器技术。我们已经在使用它们，但我们将在这里更详细地探讨它们。
- en: How to do it…
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: In this chapter, we have created rows and columns, which is the database approach
    to GUI design (MS Excel does the same). We hard-coded the first rows. However,
    if we forget to specify where we went the next row to reside, `tkinter` fills
    this in without us even noticing.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了行和列，这是GUI设计的数据库方法（MS Excel也这样做）。我们硬编码了第一行。然而，如果我们忘记指定下一行应该在哪里，`tkinter`会自动填充，甚至我们都没有注意到。
- en: 'To observe this, let''s take the code from a recipe we previously worked on:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了观察这一点，让我们从我们之前工作过的菜谱中取代码：
- en: Open `GUI_tabbed_all_widgets_both_tabs_radio.py`.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_tabbed_all_widgets_both_tabs_radio.py`。
- en: 'Comment out the `scr.grid` line, as follows:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`scr.grid`行注释掉，如下所示：
- en: '![](img/2a75b0df-329d-48f9-8ae7-761cc986003f.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/2a75b0df-329d-48f9-8ae7-761cc986003f.png)'
- en: '`tkinter` automatically adds the missing row to where we didn''t specify any
    particular row.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`tkinter`会自动将缺失的行添加到我们没有指定任何特定行的位置。'
- en: Run the code and notice how our radio buttons suddenly ended up in the middle
    of the Text widget!
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意我们的单选按钮突然出现在文本小部件的中间！
- en: '![](img/7bfd0117-139a-42dd-b996-36d9c9ed67d4.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/7bfd0117-139a-42dd-b996-36d9c9ed67d4.png)'
- en: Now let's go behind the scenes to understand the code better.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解代码，以便更好地理解。
- en: How it works…
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We laid out the `Entry` widgets on row 1\. However, we forgot to specify the
    row for our `ScrolledText` widget, which we reference via the `scr` variable.
    Then, we added the `Radiobutton` widgets we want to be laid out in row `3`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在行1上布局了`Entry`小部件。然而，我们忘记指定我们的`ScrolledText`小部件所在的行，我们通过`scr`变量引用它。然后，我们添加了想要布局在行`3`的`Radiobutton`小部件。
- en: This works nicely because `tkinter` automatically incremented the row position
    for our `ScrolledText` widget so it used the next highest row number, which was
    row `2`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，因为`tkinter`自动增加了我们的`ScrolledText`小部件的行位置，使其使用下一个最高的行号，即行`2`。
- en: Looking at our code and not realizing that we forgot to explicitly position
    our `ScrolledText` widget to row `2`, we might think nothing resides there.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 看着我们的代码，没有意识到我们忘记明确地将我们的`ScrolledText`小部件定位到行`2`，我们可能会认为那里没有任何内容。
- en: Due to this, we might try the following. If we set the `curRad` variable to
    use row `2`, we might get an unpleasant surprise, as shown in the final screenshot
    in the *How to do it...* section of this recipe.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，我们可能会尝试以下方法。如果我们将`curRad`变量设置为使用行`2`，我们可能会在菜谱的*如何做到这一点…*部分的最终截图中获得一个不愉快的惊喜。
- en: Now let's go behind the scenes to understand the code better.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解代码，以便更好地理解。
- en: Note how our row of `RadioButton`(s) suddenly ended up in the middle of our
    `ScrolledText` widget! This is definitely not what we intended our GUI to look
    like!
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的`RadioButton`(s)行突然出现在我们的`ScrolledText`小部件的中间！这绝对不是我们想要我们的GUI看起来像的！
- en: If we forget to explicitly specify the row number, by default, `tkinter` will
    use the next available row.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忘记明确指定行号，默认情况下，`tkinter`将使用下一个可用的行。
- en: 'We also used the `columnspan` property to make sure our widgets did not get
    limited to just one column, as shown in the following screenshot:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了`columnspan`属性来确保我们的小部件不会仅限于一个列，如下面的截图所示：
- en: '![](img/2a28b974-ee31-4563-bab1-a5a28a5aa813.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/2a28b974-ee31-4563-bab1-a5a28a5aa813.png)'
- en: The preceding screenshot shows how we made sure that our `ScrolledText` widget
    spans all the columns in our GUI.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图展示了我们如何确保我们的`ScrolledText`小部件横跨GUI中的所有列。
