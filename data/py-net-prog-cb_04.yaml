- en: Chapter 4. Programming with HTTP for the Internet
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章：使用 HTTP 编程 Internet
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Downloading data from an HTTP server
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 HTTP 服务器下载数据
- en: Serving HTTP requests from your machine
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从你的机器上服务 HTTP 请求
- en: Extracting cookie information after visiting a website
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问网站后提取 cookie 信息
- en: Submitting web forms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交网页表单
- en: Sending web requests through a proxy server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过代理服务器发送 Web 请求
- en: Checking whether a web page exists with the HEAD request
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HEAD 请求检查网页是否存在
- en: Spoofing Mozilla Firefox in your client code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端代码中伪造 Mozilla Firefox
- en: Saving bandwidth in web requests with the HTTP compression
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTTP 压缩在 Web 请求中节省带宽
- en: Writing an HTTP fail-over client with resume and partial downloading
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带有恢复和部分下载的 HTTP 失效客户端编写
- en: Writing a simple HTTPS server code with Python and OpenSSL
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 和 OpenSSL 编写简单的 HTTPS 服务器代码
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter explains Python HTTP networking library functions with a few third-party
    libraries. For example, the `requests` library deals with the HTTP requests in
    a nicer and cleaner way. The `OpenSSL` library is used in one of the recipes to
    create a SSL-enabled web server.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了 Python HTTP 网络库函数和一些第三方库。例如，`requests` 库以一种更优雅、更简洁的方式处理 HTTP 请求。在其中一个菜谱中使用了
    `OpenSSL` 库来创建一个启用 SSL 的 Web 服务器。
- en: Many common HTTP protocol features have been illustrated in a few recipes, for
    example, the web form submission with `POST`, manipulating header information,
    use of compression, and so on.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个菜谱中已经展示了许多常见的 HTTP 协议功能，例如，使用 `POST` 提交网页表单，操作头部信息，使用压缩等。
- en: Downloading data from an HTTP server
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 HTTP 服务器下载数据
- en: You would like to write a simple HTTP client to fetch some data from any web
    server using the native HTTP protocol. This can be the very first steps towards
    creating your own HTTP browser.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要编写一个简单的 HTTP 客户端，从任何 Web 服务器使用本机 HTTP 协议获取一些数据。这可能是创建你自己的 HTTP 浏览器的第一步。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Let us access [www.python.org](http://www.python.org) with our Pythonic minimal
    browser that uses Python's `httplib`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Python 的 `httplib` 创建的 Pythonic 最小浏览器访问 [www.python.org](http://www.python.org)。
- en: 'Listing 4.1 explains the following code for a simple HTTP client:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 解释了以下简单 HTTP 客户端的代码：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This recipe will by default fetch a page from [www.python.org](http://www.python.org).
    You can run this recipe with or without the host and path arguments. If this script
    is run, it will show the following output:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱默认会从 [www.python.org](http://www.python.org) 获取页面。你可以带或不带主机和路径参数运行此菜谱。如果运行此脚本，它将显示以下输出：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you run this recipe with an invalid path, it will show the following server
    response:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用无效的路径运行此菜谱，它将显示以下服务器响应：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe defines an `HTTPClient` class that fetches data from the remote
    host. It is built using Python's native `httplib` library. In the `fetch()` method,
    it uses the `HTTP()` function and other auxiliary functions to create a dummy
    HTTP client, such as `putrequest()` or `putheader()`. It first puts the `GET/path`
    string that is followed by setting up a user agent, which is the name of the current
    script (`__file__`).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱定义了一个 `HTTPClient` 类，用于从远程主机获取数据。它是使用 Python 的本机 `httplib` 库构建的。在 `fetch()`
    方法中，它使用 `HTTP()` 函数和其他辅助函数创建一个虚拟 HTTP 客户端，例如 `putrequest()` 或 `putheader()`。它首先放置
    `GET/path` 字符串，然后设置用户代理，即当前脚本的名称 (`__file__`)。
- en: The main request `getreply()`method is put inside a try-except block. The response
    is retrieved from the `getfile()` method and the stream's content is read.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 主要请求 `getreply()` 方法被放置在一个 try-except 块中。响应从 `getfile()` 方法检索，并读取流的内容。
- en: Serving HTTP requests from your machine
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从你的机器上服务 HTTP 请求
- en: You would like to create your own web server. Your web server should handle
    client requests and send a simple `hello` message.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要创建自己的 Web 服务器。你的 Web 服务器应该处理客户端请求并发送一个简单的 `hello` 消息。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Python ships with a very simple web server that can be launched from the command
    line as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python 随带一个非常简单的 Web 服务器，可以从命令行启动，如下所示：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will launch an HTTP web server on port `8080`. You can access this web
    server from your browser by typing `http://localhost:8080`. This will show the
    contents of the current directory from where you run the preceding command. If
    there is any web server index file, for example, `index.html`, inside that directory,
    your browser will show the contents of `index.html`. However, if you like to have
    full control over your web server, you need to launch your customized HTTP server..
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在端口 `8080` 上启动一个HTTP网络服务器。你可以通过在浏览器中输入 `http://localhost:8080` 来访问这个网络服务器。这将显示运行前面命令的当前目录的内容。如果该目录中包含任何网络服务器索引文件，例如
    `index.html`，则你的浏览器将显示 `index.html` 的内容。然而，如果你想要完全控制你的网络服务器，你需要启动你的自定义HTTP服务器...
- en: 'Listing 4.2 gives the following code for the custom HTTP web server:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2给出了自定义HTTP服务器的以下代码：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following screenshot shows a simple HTTP server:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了一个简单的HTTP服务器：
- en: '![How to do it...](img/3463OS_04_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3463OS_04_01.jpg)'
- en: 'If you run this web server and access the URL from a browser, this will send
    the one line text `Hello from server!` to the browser, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个网络服务器并通过浏览器访问URL，这将向浏览器发送一行文本 `Hello from server!`，如下所示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created the `CustomHTTPServer` class inherited from the `HTTPServer`
    class. In the constructor method, the `CustomHTTPServer` class sets up the server
    address and port received as a user input. In the constructor, our web server's
    `RequestHandler` class has been set up. Every time a client is connected, the
    server handles the request according to this class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了从 `HTTPServer` 类继承的 `CustomHTTPServer` 类。在构造方法中，`CustomHTTPServer`
    类设置了从用户输入接收的服务器地址和端口。在构造方法中，我们的网络服务器的 `RequestHandler` 类已经设置。每当有客户端连接时，服务器都会根据这个类来处理请求。
- en: The `RequestHandler` defines the action to handle the client's `GET` request.
    It sends an HTTP header (code 200) with a success message **Hello from server!**
    using the `write()` method.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestHandler` 定义了处理客户端 `GET` 请求的动作。它使用 `write()` 方法发送一个带有成功消息 **Hello from
    server!** 的HTTP头（代码200）。'
- en: Extracting cookie information after visiting a website
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问网站后提取cookie信息
- en: Many websites use cookies to store their various information on to your local
    disk. You would like to see this cookie information and perhaps log in to that
    website automatically using cookies.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网站使用cookie在本地磁盘上存储它们的各种信息。你希望看到这些cookie信息，也许可以使用cookie自动登录到该网站。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let us try to pretend to log in to a popular code-sharing website, [www.bitbucket.org](http://www.bitbucket.org).
    We would like to submit the login information on the login page, [https://bitbucket.org/account/signin/?next=/](https://bitbucket.org/account/signin/?next=/).
    The following screenshot shows the login page:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假装登录到一个流行的代码共享网站，[www.bitbucket.org](http://www.bitbucket.org)。我们希望在登录页面
    [https://bitbucket.org/account/signin/?next=/](https://bitbucket.org/account/signin/?next=/)
    上提交登录信息。下面的截图显示了登录页面：
- en: '![How to do it...](img/3463OS_04_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3463OS_04_02.jpg)'
- en: So, we note down the form element IDs and decide which fake values should be
    submitted. We access this page the first time, and the next time, we access the
    home page to observe what cookies have been set up.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们记录下表单元素的ID，并决定应该提交哪些假值。我们第一次访问这个页面，然后下次访问主页以观察已经设置了哪些cookie。
- en: 'Listing 4.3 explains extracting cookie information as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3如下解释了如何提取cookie信息：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Running this recipe results in the following output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个菜谱会产生以下输出：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We have used Python''s `cookielib` and set up a cookie jar, `cj`. The login
    data has been encoded using `urllib.urlencode`. `urllib2` has a `build_opener()`
    method, which takes the predefined cookie jar with an instance of `HTTPCookieProcessor()`
    and returns a URL opener. We call this opener twice: once for the login page and
    once for the home page of the website. It seems that only one cookie, `bb_session`,
    was set with the set-cookie directive present in the page header. More information
    about `cookielib` can be found on the official Python documentation site at [http://docs.python.org/2/library/cookielib.html](http://docs.python.org/2/library/cookielib.html).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了Python的`cookielib`并设置了一个cookie存储，`cj`。登录数据已经使用`urllib.urlencode`进行了编码。`urllib2`有一个`build_opener()`方法，它接受一个包含`HTTPCookieProcessor()`实例的预定义cookie存储，并返回一个URL打开器。我们调用这个打开器两次：一次用于登录页面，一次用于网站的首页。看起来只有`bb_session`一个cookie通过页面头部的set-cookie指令被设置。有关`cookielib`的更多信息可以在官方Python文档网站上找到，网址为[http://docs.python.org/2/library/cookielib.html](http://docs.python.org/2/library/cookielib.html)。
- en: Submitting web forms
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交网络表单
- en: During web browsing, we submit web forms many times in a day. Now, you would
    like do that using the Python code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络浏览过程中，我们每天会多次提交网络表单。现在，你希望通过Python代码来完成这项操作。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'This recipe uses a third-party Python module called `requests`. You can install
    the compatible version of this module by following the instructions from [http://docs.python-requests.org/en/latest/user/install/](http://docs.python-requests.org/en/latest/user/install/).
    For example, you can use `pip` to install `requests` from the command line as
    follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用名为`requests`的第三方Python模块。你可以通过遵循[http://docs.python-requests.org/en/latest/user/install/](http://docs.python-requests.org/en/latest/user/install/)中的说明来安装此模块的兼容版本。例如，你可以使用`pip`从命令行安装`requests`，如下所示：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let us submit some fake data to register with [www.twitter.com](http://www.twitter.com).
    Each form submission has two methods: `GET` and `POST`. The less sensitive data,
    for example, search queries, are usually submitted by `GET` and the more sensitive
    data is sent via the `POST` method. Let us try submitting data with both of them.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提交一些假数据以在[www.twitter.com](http://www.twitter.com)注册。每个表单提交都有两种方法：`GET`和`POST`。不太敏感的数据，例如搜索查询，通常通过`GET`提交，而更敏感的数据则通过`POST`方法发送。让我们尝试使用这两种方法提交数据。
- en: 'Listing 4.4 explains the submit web forms, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4如下解释了提交网络表单：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you run this script, you will see the following output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此脚本，你将看到以下输出：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe uses a third-party module, `requests`. It has convenient wrapper
    methods, `get()` and `post()`, that do the URL encoding of data and submit forms
    properly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用第三方模块`requests`。它有方便的包装方法`get()`和`post()`，这些方法可以对数据进行URL编码并正确提交表单。
- en: In this recipe, we created a data payload with a username, password, and e-mail
    for creating the Twitter account. When we first submit the form with the `GET`
    method, the Twitter website returns an error saying that the page only supports
    `POST`. After we submit the data with `POST`, the page processes it. We can confirm
    this from the header data.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们创建了一个包含用户名、密码和电子邮件以创建Twitter账户的数据负载。当我们第一次使用`GET`方法提交表单时，Twitter网站返回一个错误，表示该页面只支持`POST`。在提交数据后，页面会处理它。我们可以从头部数据中确认这一点。
- en: Sending web requests through a proxy server
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过代理服务器发送网络请求
- en: You would like to browse web pages through a proxy. If you have configured your
    browser with a proxy server and that works, you can try this recipe. Otherwise,
    you can use any of the public proxy servers available on the Internet.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望通过代理服务器浏览网页。如果你已经配置了浏览器使用代理服务器并且它工作正常，你可以尝试这个方法。否则，你可以使用互联网上可用的任何公共代理服务器。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: You need to have access to a proxy server. You can find a free proxy server
    by searching on Google or on any other search engine. Here, for the sake of demonstration,
    we have used `165.24.10.8`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要访问一个代理服务器。你可以在Google或任何其他搜索引擎上搜索以找到免费代理服务器。在这里，为了演示，我们使用了`165.24.10.8`。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let us send our HTTP request through a public domain proxy server.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过公共域名代理服务器发送我们的HTTP请求。
- en: 'Listing 4.5 explains proxying web requests across a proxy server as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.5如下解释了通过代理服务器代理网络请求：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you run this script, it will show the following output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此脚本，它将显示以下输出：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This is a short recipe where we access the social code-sharing site, [www.github.com](http://www.github.com),
    with a public proxy server found on Google search. The proxy address argument
    has been passed to the `urlopen()` method of `urllib`. We print the HTTP header
    of response to show that the proxy settings work here.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简短的食谱，我们在Google搜索中找到的公共代理服务器上，使用社交代码共享网站[www.github.com](http://www.github.com)进行访问。代理地址参数已传递给`urllib`的`urlopen()`方法。我们打印出响应的HTTP头信息，以显示代理设置在这里是有效的。
- en: Checking whether a web page exists with the HEAD request
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`HEAD`请求检查网页是否存在
- en: You would like to check the existence of a web page without downloading the
    HTML content. This means that we need to send a `get HEAD` request with a browser
    client. According to Wikipedia, the `HEAD` request asks for the response identical
    to the one that would correspond to a `GET` request, but without the response
    body. This is useful for retrieving meta-information written in response headers,
    without having to transport the entire content.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望在不下载HTML内容的情况下检查网页的存在。这意味着我们需要使用浏览器客户端发送一个`get HEAD`请求。根据维基百科，`HEAD`请求请求的响应与`GET`请求对应的响应相同，但不包括响应体。这对于检索响应头中编写的元信息很有用，而无需传输整个内容。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We would like to send a `HEAD` request to [www.python.org](http://www.python.org).
    This will not download the content of the homepage, rather it checks whether the
    server returns one of the valid responses, for example, `OK`, `FOUND`, `MOVED
    PERMANENTLY`, and so on.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望向[www.python.org](http://www.python.org)发送一个`HEAD`请求。这不会下载主页的内容，而是检查服务器是否返回了有效的响应之一，例如`OK`、`FOUND`、`MOVED
    PERMANENTLY`等。
- en: 'Listing 4.6 explains checking a web page with the `HEAD` request as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6解释了如何使用`HEAD`请求检查网页，如下所示：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Running this script shows the success or error if the page is found by the
    `HEAD` request as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本将显示如果使用`HEAD`请求找到页面，则会显示成功或错误信息：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We used the `HTTPConnection()` method of `httplib`, which can make a `HEAD`
    request to a server. We can specify the path if necessary. Here, the `HTTPConnection()`
    method checks the home page or path of [www.python.org](http://www.python.org).
    However, if the URL is not correct, it can't find the return response inside the
    accepted list of return codes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`httplib`的`HTTPConnection()`方法，它可以向服务器发送`HEAD`请求。如果需要，我们可以指定路径。在这里，`HTTPConnection()`方法检查了[www.python.org](http://www.python.org)的主页或路径。然而，如果URL不正确，它无法在接受的返回代码列表中找到返回的响应。
- en: Spoofing Mozilla Firefox in your client code
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的客户端代码中欺骗Mozilla Firefox
- en: From your Python code, you would like to pretend to the web server that you
    are browsing from Mozilla Firefox.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的Python代码中，你希望让网络服务器认为你正在使用Mozilla Firefox进行浏览。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: You can send the custom user-agent values in the HTTP request header.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在HTTP请求头中发送自定义的用户代理值。
- en: 'Listing 4.7 explains spoofing Mozilla Firefox in your client code as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.7解释了如何在客户端代码中欺骗Mozilla Firefox，如下所示：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you run this script, you will see the following output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个脚本，你将看到以下输出：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We used the `build_opener()` method of `urllib2` to create our custom browser
    whose user-agent string has been set up as `Mozilla/5.0 (Windows NT 5.1; rv:20.0)
    Gecko/20100101 Firefox/20.0`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`urllib2`的`build_opener()`方法来创建我们的自定义浏览器，其用户代理字符串已设置为`Mozilla/5.0 (Windows
    NT 5.1; rv:20.0) Gecko/20100101 Firefox/20.0`。
- en: Saving bandwidth in web requests with the HTTP compression
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Web请求中使用HTTP压缩来节省带宽
- en: You would like to give your web server users better performance in downloading
    web pages. By compressing HTTP data, you can speed up the serving of web contents.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望为你的网络服务器用户在下载网页时提供更好的性能。通过压缩HTTP数据，你可以加快Web内容的提供速度。
- en: How to do it...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let us create a web server that serves contents after compressing it to the
    `gzip` format.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个网络服务器，它在将内容压缩为`gzip`格式后提供服务。
- en: 'Listing 4.8 explains the HTTP compression as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.8解释了HTTP压缩，如下所示：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can run this script and see the `Compressed Hello World!` text (as a result
    of the HTTP compression) on your browser screen when accessing `http://localhost:8800`
    as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行这个脚本，并在访问`http://localhost:8800`时在你的浏览器屏幕上看到`Compressed Hello World!`文本（这是HTTP压缩的结果）：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following screenshot illustrates serving compressed content by a web server:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了由网络服务器提供的压缩内容：
- en: '![How to do it...](img/3463OS_04_03.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/3463OS_04_03.jpg)'
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We created a web server by instantiating the `HTTPServer` class from the `BaseHTTPServer`
    module. We attached a custom request handler to this server instance, which compresses
    every client response using a `compress_buffer()` method. A predefined HTML content
    has been supplied to the clients.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过从`BaseHTTPServer`模块实例化`HTTPServer`类来创建了一个网络服务器。我们向这个服务器实例附加了一个自定义请求处理器，该处理器使用`compress_buffer()`方法压缩每个客户端响应。已经向客户端提供了预定义的HTML内容。
- en: Writing an HTTP fail-over client with resume and partial downloading
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python和OpenSSL编写具有恢复和部分下载功能的HTTP故障转移客户端
- en: You would like to create a fail-over client that will resume downloading a file
    if it fails for any reason in the first instance.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想创建一个故障转移客户端，如果第一次尝试下载失败，它将重新下载文件。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let us download the Python 2.7 code from [www.python.org](http://www.python.org).
    A `resume_download()` file will resume any unfinished download of that file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从[www.python.org](http://www.python.org)下载Python 2.7代码。一个`resume_download()`文件将恢复该文件的任何未完成下载。
- en: 'Listing 4.9 explains resume downloading as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.9解释了恢复下载如下：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Running this script will result in the following output:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本将产生以下输出：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a custom URL opener class inheriting from the `FancyURLopener`
    method of `urllib`, but `http_error_206()` is overridden where partial content
    is downloaded. So, our method checks the existence of the target file and if it
    is not present, it tries to download with the custom URL opener class.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个继承自`urllib`模块的`FancyURLopener`方法的自定义URL打开器类，但覆盖了`http_error_206()`，以便下载部分内容。因此，我们的方法检查目标文件是否存在，如果不存在，它将尝试使用自定义URL打开器类下载。
- en: Writing a simple HTTPS server code with Python and OpenSSL
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python和OpenSSL编写简单的HTTPS服务器代码
- en: You need a secure web server code written in Python. You already have your SSL
    keys and certificate files ready with you.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个用Python编写的安全网络服务器代码。你已经准备好了你的SSL密钥和证书文件。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install the third-party Python module, `pyOpenSSL`. This can be
    grabbed from PyPI ([https://pypi.python.org/pypi/pyOpenSSL](https://pypi.python.org/pypi/pyOpenSSL)).
    Both on Windows and Linux hosts, you may need to install some additional packages,
    which are documented at [http://pythonhosted.org//pyOpenSSL/](http://pythonhosted.org//pyOpenSSL/).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装第三方Python模块`pyOpenSSL`。这可以从PyPI([https://pypi.python.org/pypi/pyOpenSSL](https://pypi.python.org/pypi/pyOpenSSL))获取。在Windows和Linux主机上，你可能需要安装一些额外的包，这些包在[http://pythonhosted.org//pyOpenSSL/](http://pythonhosted.org//pyOpenSSL/)上有文档说明。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: After placing a certificate file on the current working folder, we can create
    a web server that makes use of this certificate to serve encrypted content to
    the clients.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前工作文件夹放置证书文件后，我们可以创建一个使用此证书为客户端提供加密内容的网络服务器。
- en: 'Listing 4.10 explains the code for a secure HTTP server as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.10解释了以下安全HTTP服务器的代码：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you run this script, it will result in the following output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此脚本，它将产生以下输出：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: If you notice the previous recipes that create the web server, there is not
    much difference in terms of the basic procedure. The main difference is in applying
    the SSL `Context()` method with the `SSLv23_METHOD` argument. We have created
    the SSL socket with the Python OpenSSL third-party module's `Connection()` class.
    This class takes this context object along with the address family and socket
    type.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了创建网络服务器的先前菜谱，在基本程序方面没有太大区别。主要区别在于使用带有`SSLv23_METHOD`参数的SSL `Context()`方法。我们已经使用Python
    OpenSSL第三方模块的`Connection()`类创建了SSL套接字。这个类接受这个上下文对象以及地址族和套接字类型。
- en: The server's certificate file is kept in the current directory, and this has
    been applied with the context object. Finally, the server has been activated with
    the `server_activate()` method.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器证书文件保存在当前目录中，并且已经通过上下文对象应用。最后，服务器通过`server_activate()`方法被激活。
