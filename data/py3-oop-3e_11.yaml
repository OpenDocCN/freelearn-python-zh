- en: Python Design Patterns II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python设计模式II
- en: 'In this chapter, we will be introduced to several more design patterns. Once
    again, we''ll cover the canonical examples as well as any common alternative implementations
    in Python. We''ll be discussing the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍更多设计模式。我们将再次涵盖标准的示例，以及Python中任何常见的替代实现。我们将讨论以下内容：
- en: The adapter pattern
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器模式
- en: The facade pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观模式
- en: Lazy initialization and the flyweight pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载和享元模式
- en: The command pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式
- en: The abstract factory pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: The composition pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合模式
- en: The adapter pattern
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器模式
- en: Unlike most of the patterns we reviewed in the previous chapter, the adapter
    pattern is designed to interact with existing code. We would not design a brand
    new set of objects that implement the adapter pattern. Adapters are used to allow
    two preexisting objects to work together, even if their interfaces are not compatible.
    Like the display adapters that allow you to plug your Micro USB charging cable
    into a USB-C phone, an adapter object sits between two different interfaces, translating
    between them on the fly. The adapter object's sole purpose is to perform this
    translation. Adapting may entail a variety of tasks, such as converting arguments
    to a different format, rearranging the order of arguments, calling a differently
    named method, or supplying default arguments.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章中我们审查的大多数模式不同，适配器模式旨在与现有代码交互。我们不会设计一套全新的对象来实现适配器模式。适配器用于允许两个预存在的对象协同工作，即使它们的接口不兼容。就像允许您将Micro
    USB充电线插入USB-C手机的显示适配器一样，适配器对象位于两个不同接口之间，在运行时进行转换。适配器对象的唯一目的是执行这种转换。适配可能涉及各种任务，例如将参数转换为不同的格式、重新排列参数的顺序、调用不同名称的方法或提供默认参数。
- en: 'In structure, the adapter pattern is similar to a simplified decorator pattern.
    Decorators typically provide the same interface that they replace, whereas adapters
    map between two different interfaces. This is depicted in UML form in the following
    diagram:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构上，适配器模式类似于简化的装饰器模式。装饰器通常提供与它们替换的相同接口，而适配器在两个不同的接口之间进行映射。这在下图中以UML形式表示：
- en: '![](img/bef847c5-155c-4661-91f7-b48a291ce802.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bef847c5-155c-4661-91f7-b48a291ce802.png)'
- en: Here, **Interface1 **is expecting to call a method called **make_action(some,
    arguments)**. We already have this perfect **Interface2** class that does everything
    we want (and to avoid duplication, we don't want to rewrite it!), but it provides
    a method called **different_action(other, arguments)** instead. The **Adapter**
    class implements the **make_action** interface and maps the arguments to the existing
    interface.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**Interface1**期望调用一个名为**make_action(some, arguments)**的方法。我们已经有了一个完美的**Interface2**类，它做了一切我们想要的事情（为了避免重复，我们不想重写它！），但它提供了一个名为**different_action(other,
    arguments)**的方法。**Adapter**类实现了**make_action**接口，并将参数映射到现有接口。
- en: The advantage here is that the code that maps from one interface to another
    is all in one place. The alternative would be really ugly; we'd have to perform
    the translation in multiple places whenever we need to access this code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的优势在于，将一个接口映射到另一个接口的代码都集中在一个地方。另一种选择会非常丑陋；每次我们需要访问此代码时，我们都必须在多个地方执行转换。
- en: 'For example, imagine we have the following preexisting class, which takes a
    string date in the format `YYYY-MM-DD` and calculates a person''s age on that
    date:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象我们有一个以下预存在的类，它接受一个格式为`YYYY-MM-DD`的字符串日期，并计算该日期上一个人的年龄：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a pretty simple class that does what it's supposed to do. But we have
    to wonder what the programmer was thinking, using a specifically formatted string
    instead of using Python's incredibly useful built-in `datetime` library. As conscientious
    programmers who reuse code whenever possible, most of the programs we write will
    interact with `datetime` objects, not strings.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的类，它做了它应该做的事情。但我们必须想知道程序员在做什么，使用特定格式的字符串而不是使用Python极其有用的内置`datetime`库。作为尽可能重用代码的负责任程序员，我们编写的多数程序都将与`datetime`对象交互，而不是字符串。
- en: We have several options to address this scenario. We could rewrite the class
    to accept `datetime` objects, which would probably be more accurate anyway. But
    if this class had been provided by a third party and we don't know how to or can't
    change its internal structure, we need an alternative. We could use the class
    as it is, and whenever we want to calculate the age on a `datetime.date` object,
    we could call `datetime.date.strftime('%Y-%m-%d')` to convert it to the proper
    format. But that conversion would be happening in a lot of places, and worse,
    if we mistyped the `%m` as `%M`, it would give us the current minute instead of
    the  month entered. Imagine if you wrote that in a dozen different places only
    to have to go back and change it when you realized your mistake. It's not maintainable
    code, and it breaks the DRY principle.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法来解决这个问题。我们可以重写这个类以接受`datetime`对象，这可能是更准确的方法。但如果这个类是由第三方提供的，我们不知道如何或不能改变其内部结构，我们需要一个替代方案。我们可以使用这个类原样，每当我们要在`datetime.date`对象上计算年龄时，我们可以调用`datetime.date.strftime('%Y-%m-%d')`将其转换为正确的格式。但这个转换会在很多地方发生，更糟糕的是，如果我们错误地将`%m`误写为`%M`，它将给出当前的分钟而不是输入的月份。想象一下，如果你在十几个不同的地方都写了这个，然后意识到错误时不得不回去更改它。这不是可维护的代码，它违反了DRY原则。
- en: 'Instead, we can write an adapter that allows a normal date to be plugged into
    a normal `AgeCalculator` class, as shown in the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以编写一个适配器，允许将普通日期插入到普通的`AgeCalculator`类中，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This adapter converts `datetime.date` and `datetime.time` (they have the same
    interface to `strftime`) into a string that our original `AgeCalculator` can use.
    Now we can use the original code with our new interface. I changed the method
    signature to `get_age` to demonstrate that the calling interface may also be looking
    for a different method name, not just a different type of argument.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此适配器将`datetime.date`和`datetime.time`（它们具有相同的`strftime`接口）转换为我们的原始`AgeCalculator`可以使用的一个字符串。现在我们可以使用原始代码和我们的新接口。我将方法签名更改为`get_age`，以表明调用接口也可能在寻找不同的方法名，而不仅仅是不同类型的参数。
- en: 'Creating a class as an adapter is the usual way to implement this pattern,
    but, as usual, there are other ways to do it in Python. Inheritance and multiple
    inheritance can be used to add functionality to a class. For example, we could
    add an adapter on the `date` class so that it works with the original `AgeCalculator`
    class, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将类作为适配器是实现此模式的一种常见方式，但通常，在Python中还有其他方法可以实现。继承和多继承可以用来向类添加功能。例如，我们可以在`date`类上添加一个适配器，使其与原始的`AgeCalculator`类一起工作，如下所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It''s code like this that makes one wonder whether Python should even be legal.
    We have added a `split` method to our subclass that takes a single argument (which
    we ignore) and returns a tuple of year, month, and day. This works flawlessly
    with the original `AgeCalculator` class because the code calls `strip` on a specially
    formatted string, and `strip`, in that case, returns a tuple of year, month, and
    day. The `AgeCalculator` code only cares if `strip` exists and returns acceptable
    values; it doesn''t care if we really passed in a string. The following code really
    works:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这种代码让人怀疑Python是否应该合法。我们已经在我们的子类中添加了一个`split`方法，它接受一个单一参数（我们忽略它）并返回一个包含年、月和日的元组。这个方法与原始的`AgeCalculator`类完美配合，因为代码在一个特殊格式的字符串上调用`strip`，在这种情况下，`strip`返回一个包含年、月和日的元组。`AgeCalculator`代码只关心`strip`是否存在并返回可接受值；它不关心我们是否真的传递了一个字符串。以下代码确实有效：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It works but it's a stupid idea. In this particular instance, such an adapter
    would be hard to maintain. We'd soon forget why we needed to add a `strip` method
    to a `date` class. The method name is ambiguous. That can be the nature of adapters,
    but creating an adapter explicitly instead of using inheritance usually clarifies
    its purpose.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以工作，但这是个愚蠢的想法。在这个特定的情况下，这样的适配器很难维护。我们很快就会忘记为什么需要在`date`类中添加一个`strip`方法。方法名不明确。这可能就是适配器的本质，但明确创建适配器而不是使用继承通常可以更清晰地说明其目的。
- en: Instead of inheritance, we can sometimes also use monkey-patching to add a method
    to an existing class. It won't work with the `datetime` object, as it doesn't
    allow attributes to be added at runtime.  In normal classes, however, we can just
    add a new method that provides the adapted interface that is required by calling
    code. Alternatively, we could extend or monkey-patch the `AgeCalculator` itself
    to replace the `calculate_age` method with something more amenable to our needs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了继承之外，我们有时也可以使用猴子补丁向现有类添加方法。它不会与`datetime`对象一起工作，因为它不允许在运行时添加属性。然而，在正常类中，我们只需添加一个新方法，该方法提供所需的适配接口，供调用代码使用。或者，我们也可以扩展或猴子补丁`AgeCalculator`本身，用更符合我们需求的方法替换`calculate_age`方法。
- en: Finally, it is often possible to use a function as an adapter; this doesn't
    obviously fit the actual design of the adapter pattern, but if we recall that
    functions are essentially objects with a `__call__` method, it becomes an obvious
    adapter adaptation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通常可以使用一个函数作为适配器；这显然不符合适配器模式的设计，但如果我们回想一下函数本质上是有`__call__`方法的对象，它就变成了一个明显的适配器适配。
- en: The facade pattern
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观模式
- en: 'The facade pattern is designed to provide a simple interface to a complex system
    of components. For complex tasks, we may need to interact with these objects directly,
    but there is often a *typical* usage for the system for which these complicated
    interactions aren''t necessary. The facade pattern allows us to define a new object
    that encapsulates this typical usage of the system. Any time we want access to
    common functionality, we can use the single object''s simplified interface. If
    another part of the project needs access to more complicated functionality, it
    is still able to interact with the system directly. The UML diagram for the facade
    pattern is really dependent on the subsystem, but in a cloudy way, it looks like
    this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式旨在为复杂组件系统提供一个简单的接口。对于复杂任务，我们可能需要直接与这些对象交互，但系统通常有一个*典型*的使用方式，这些复杂的交互并不必要。外观模式允许我们定义一个新的对象，该对象封装了系统的这种典型用法。任何想要访问常用功能的时候，我们都可以使用这个单一对象的简化接口。如果项目的另一个部分需要访问更复杂的功能，它仍然可以直接与系统交互。外观模式的UML图很大程度上取决于子系统，但以模糊的方式，它看起来是这样的：
- en: '![](img/900379e3-b9e5-4451-b8ed-abcf6451c417.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/900379e3-b9e5-4451-b8ed-abcf6451c417.png)'
- en: A facade is, in many ways, like an adapter. The primary difference is that a
    facade tries to abstract a simpler interface out of a complex one, while an adapter
    only tries to map one existing interface to another.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，外观模式就像一个适配器。主要区别在于，外观模式试图从一个复杂的接口中抽象出一个更简单的接口，而适配器只试图将一个现有的接口映射到另一个接口。
- en: Let's write a simple facade for an email application. The low-level library
    for sending email in Python, as we saw in [Chapter 7](b70c8ea0-4778-4005-af13-bdae3d90d2c6.xhtml),
    *Python Object-Oriented Shortcuts*, is quite complicated. The two libraries for
    receiving messages are even worse.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的电子邮件应用外观。在[第7章](b70c8ea0-4778-4005-af13-bdae3d90d2c6.xhtml)“Python面向对象快捷方式”中，我们看到的Python发送电子邮件的低级库相当复杂。接收消息的两个库甚至更糟糕。
- en: 'It would be nice to have a simple class that allows us to send a single email,
    and list the emails currently in the inbox on an IMAP or POP3 connection. To keep
    our example short, we''ll stick with IMAP and SMTP: two totally different subsystems
    that happen to deal with email. Our facade performs only two tasks: sending an
    email to a specific address, and checking the inbox on an IMAP connection. It
    makes some common assumptions about the connection, such as that the host for
    both SMTP and IMAP is at the same address, that the username and password for
    both is the same, and that they use standard ports. This covers the case for many
    email servers, but if a programmer needs more flexibility, they can always bypass
    the facade and access the two subsystems directly.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个简单的类，可以让我们发送一封电子邮件，并在IMAP或POP3连接上列出当前收件箱中的电子邮件，那就太好了。为了使我们的例子简短，我们将坚持使用IMAP和SMTP：两个完全不同的子系统，但恰好都处理电子邮件。我们的外观只执行两个任务：将电子邮件发送到特定的地址，并在IMAP连接上检查收件箱。它对连接做了一些常见的假设，例如SMTP和IMAP的主机地址相同，用户名和密码相同，并且使用标准端口。这适用于许多电子邮件服务器，但如果程序员需要更多的灵活性，他们可以始终绕过外观直接访问两个子系统。
- en: 'The class is initialized with the hostname of the email server, a username,
    and a password to log in:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类初始化时需要提供电子邮件服务器的域名、用户名和登录密码：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `send_email` method formats the email address and message, and sends it using
    `smtplib`. This isn''t a complicated task, but it requires quite a bit of fiddling to
    massage the *natural* input parameters that are passed into the facade to the
    correct format to enable `smtplib` to send the message, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_email` 方法格式化电子邮件地址和消息，并使用 `smtplib` 发送。这不是一个复杂的任务，但需要对传递到门面（facade）的自然输入参数进行相当多的调整，以便将它们转换为正确的格式，从而使得
    `smtplib` 能够发送消息，如下所示：'
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `if` statement at the beginning of the method is catching whether or not
    the `username` is the entire *from* email address or just the part on the left-hand
    side of the `@` symbol; different hosts treat the login details differently.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 方法开头处的 `if` 语句检测 `username` 是否是整个 *from* 电子邮件地址，或者是 `@` 符号左侧的部分；不同的主机对登录细节的处理方式不同。
- en: 'Finally, the code to get the messages currently in the inbox is a royal mess.
    The IMAP protocol is painfully over-engineered, and the `imaplib` standard library
    is only a thin layer over the protocol. But we get to simplify it, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，获取当前收件箱中消息的代码是一团糟。IMAP 协议过度设计，而 `imaplib` 标准库只是协议的一个薄层。但我们能够简化它，如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, if we add all this together, we have a simple facade class that can send
    and receive messages in a fairly straightforward manner; much simpler than if
    we had to interact with these complex libraries directly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们把这些加在一起，我们就有一个简单的门面类，可以以相当直接的方式发送和接收消息；比直接与这些复杂的库交互简单得多。
- en: Although it is rarely mentioned by name in the Python community, the facade
    pattern is an integral part of the Python ecosystem. Because Python emphasizes
    language readability, both the language and its libraries tend to provide easy-to-comprehend
    interfaces to complicated tasks. For example, `for` loops, `list` comprehensions,
    and generators are all facades into a more complicated iterator protocol. The
    `defaultdict` implementation is a facade that abstracts away annoying corner cases
    when a key doesn't exist in a dictionary. The third-party **requests** library
    is a powerful facade over less readable libraries for HTTP requests, which are
    themselves a facade over managing the text-based HTTP protocol yourself.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 Python 社区中很少被提及，但门面模式是 Python 生态系统的一个基本组成部分。因为 Python 强调语言的可读性，所以语言及其库都倾向于提供易于理解的接口来处理复杂任务。例如，`for`
    循环、`list` 推导和生成器都是更复杂迭代协议的门面。`defaultdict` 实现是一个门面，它抽象掉了当字典中不存在键时的讨厌的边缘情况。第三方
    **requests** 库是一个强大的门面，它覆盖了更难以阅读的 HTTP 请求库，而后者本身又是管理基于文本的 HTTP 协议的门面。
- en: The flyweight pattern
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 享元模式
- en: The flyweight pattern is a memory optimization pattern. Novice Python programmers
    tend to ignore memory optimization, assuming the built-in garbage collector will
    take care of them. This is usually perfectly acceptable, but when developing larger
    applications with many related objects, paying attention to memory concerns can
    have a huge payoff.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 享元模式是一种内存优化模式。新手 Python 程序员往往忽略内存优化，认为内置的垃圾回收器会处理这些。这通常完全可行，但当开发具有许多相关对象的大型应用程序时，关注内存问题可以带来巨大的回报。
- en: The flyweight pattern ensures that objects that share a state can use the same
    memory for that shared state. It is normally implemented only after a program
    has demonstrated memory problems. It may make sense to design an optimal configuration
    from the beginning in some situations, but bear in mind that premature optimization
    is the most effective way to create a program that is too complicated to maintain.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 享元模式确保共享状态的对象可以使用相同的内存来存储该共享状态。它通常只在程序已经显示出内存问题时才实现。在某些情况下，从一开始就设计最优配置可能是有意义的，但请记住，过早优化是创建难以维护的程序的最有效方式。
- en: 'Let''s have a look at the following UML diagram for the flyweight pattern:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下关于享元模式的 UML 图：
- en: '![](img/fac04995-3717-4ad7-b0bb-2c2e85f65770.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fac04995-3717-4ad7-b0bb-2c2e85f65770.png)'
- en: Each **Flyweight** has no specific state. Any time it needs to perform an operation
    on **SpecificState**, that state needs to be passed into the **Flyweight** by
    the calling code. Traditionally, the factory that returns a flyweight is a separate
    object; its purpose is to return a flyweight for a given key identifying that
    flyweight. It works like the singleton pattern we discussed in [Chapter 10](345fe617-9a90-4c59-9355-e7076759f9a4.xhtml),
    *Python Design Patterns I*; if the flyweight exists, we return it; otherwise,
    we create a new one. In many languages, the factory is implemented, not as a separate
    object, but as a static method on the `Flyweight` class itself.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个**享元**都没有特定的状态。任何需要在对**具体状态**执行操作时，都需要由调用代码将此状态传递给**享元**。传统上，返回享元的工厂是一个单独的对象；其目的是为给定键标识的享元返回享元。它的工作方式类似于我们在第10章中讨论的单例模式；如果享元存在，我们返回它；否则，我们创建一个新的。在许多语言中，工厂不是作为一个单独的对象实现，而是作为`Flyweight`类本身的静态方法实现。
- en: Think of an inventory system for car sales. Each individual car has a specific
    serial number and is a specific color. But most of the details about that car
    are the same for all cars of a particular model. For example, the Honda Fit DX
    model is a bare-bones car with few features. The LX model has A/C, tilt, cruise,
    and power windows and locks. The Sport model has fancy wheels, a USB charger,
    and a spoiler. Without the flyweight pattern, each individual car object would
    have to store a long list of which features it did and did not have. Considering
    the number of cars Honda sells in a year, this would add up to a huge amount of
    wasted memory.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下汽车销售的库存系统。每辆单独的汽车都有一个特定的序列号和特定的颜色。但关于那辆汽车的大部分细节对于同一型号的所有汽车都是相同的。例如，本田飞度DX型号是一款功能简单的汽车。LX型号配备了空调、倾斜、定速巡航和电动门窗锁。运动型号配备了花哨的轮子、USB充电器和尾翼。如果没有使用享元模式，每辆单独的汽车对象都必须存储一个长长的列表，列出它有哪些功能和没有哪些功能。考虑到本田每年销售的汽车数量，这将导致大量的内存浪费。
- en: Using the flyweight pattern, we can instead have shared objects for the list
    of features associated with a model, and then simply reference that model, along
    with a serial number and color, for individual vehicles. In Python, the flyweight
    factory is often implemented using that funky `__new__` constructor, similar to
    what we did with the singleton pattern.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用享元模式，我们可以为与型号相关的功能列表拥有共享对象，然后只需简单地引用该型号，以及序列号和颜色，用于单个车辆。在Python中，享元工厂通常使用那个奇特的`__new__`构造函数实现，类似于我们之前在单例模式中使用的。
- en: Unlike the singleton pattern, which only needs to return one instance of the
    class, we need to be able to return different instances depending on the keys.
    We could store the items in a dictionary and look them up based on the key. This
    solution is problematic, however, because the item will remain in memory as long
    as it is in the dictionary. If we sold out of LX model Fits, the Fit flyweight
    would no longer be necessary, yet it would still be in the dictionary. We could
    clean this up whenever we sell a car, but isn't that what a garbage collector
    is for?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与只返回一个类实例的单例模式不同，我们需要能够根据键返回不同的实例。我们可以在字典中存储项目并基于键查找它们。然而，这个解决方案是有问题的，因为项目将保留在内存中，只要它在字典中。如果我们卖完了LX型号的飞度，飞度享元就不再必要了，但它仍然会在字典中。我们可以在卖掉汽车时清理它，但这不就是垃圾收集器的作用吗？
- en: We can solve this by taking advantage of Python's `weakref` module. This module
    provides a `WeakValueDictionary` object, which basically allows us to store items
    in a dictionary without the garbage collector caring about them. If a value is
    in a weak referenced dictionary and there are no other references to that object
    stored anywhere in the application (that is, we sold out of LX models), the garbage
    collector will eventually clean up for us.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过利用Python的`weakref`模块来解决这个问题。此模块提供了一个`WeakValueDictionary`对象，它基本上允许我们在不关心垃圾收集器的情况下将项目存储在字典中。如果一个值在弱引用字典中，并且没有其他引用存储在应用程序的任何地方（也就是说，我们卖完了LX型号），垃圾收集器最终会为我们清理。
- en: 'Let''s build the factory for our car flyweights first, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先构建我们的汽车享元工厂，如下所示：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Basically, whenever we construct a new flyweight with a given name, we first
    look up that name in the weak referenced dictionary; if it exists, we return that
    model; if not, we create a new one. Either way, we know the `__init__` method
    on the flyweight will be called every time, regardless of whether it is a new
    or existing object. Our `__init__` method can therefore look like the following
    code snippet:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，每当我们使用给定的名称构建一个新的飞weight时，我们首先在弱引用字典中查找该名称；如果存在，我们返回该模型；如果不存在，我们创建一个新的。无论哪种方式，我们知道在飞weight上每次都会调用`__init__`方法，无论它是新对象还是现有对象。因此，我们的`__init__`方法可以像以下代码片段那样：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `if` statement ensures that we only initialize the object the first time
    `__init__` is called. This means we can call the factory later with just the model
    name and get the same flyweight object back. However, because the flyweight will
    be garbage-collected if no external references to it exist, we must be careful
    not to accidentally create a new flyweight with null values.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句确保我们只在第一次调用`__init__`时初始化对象。这意味着我们可以在稍后仅使用模型名称调用工厂，并获取相同的飞weight对象。然而，因为如果不存在外部引用，飞weight将被垃圾回收，我们必须小心不要意外地使用空值创建一个新的飞weight。'
- en: 'Let''s add a method to our flyweight that hypothetically looks up a serial
    number on a specific model of vehicle, and determines whether it has been involved
    in any accidents. This method needs access to the car''s serial number, which
    varies from car to car; it cannot be stored with the flyweight. Therefore, this
    data must be passed into the method by the calling code, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在飞weight中添加一个方法，这个方法假设性地查找特定车型上的序列号，并确定它是否参与过任何事故。此方法需要访问汽车的序列号，该序列号因车而异；它不能与飞weight一起存储。因此，这些数据必须通过调用代码以如下方式传递到方法中：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can define a class that stores the additional information, as well as a
    reference to the flyweight, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个类来存储额外的信息，以及飞weight的引用，如下所示：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also keep track of the available models, as well as the individual cars
    on the lot, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以按照以下方式跟踪可用的模型，以及场地上单独的汽车：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s demonstrate the weak referencing at work in the following code
    snippet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在以下代码片段中演示弱引用的工作原理：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `id` function tells us the unique identifier for an object. When we call
    it a second time, after deleting all references to the LX model and forcing garbage
    collection, we see that the ID has changed. The value in the `CarModel __new__`
    factory dictionary was deleted and a fresh one was created. If we then try to
    construct a second `CarModel` instance, however, it returns the same object (the
    IDs are the same), and, even though we did not supply any arguments in the second
    call, the `air` variable is still set to `True`. This means the object was not
    initialized the second time, just as we designed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`函数告诉我们对象的唯一标识符。当我们删除所有对LX模型的引用并强制进行垃圾回收后再次调用它，我们会看到ID已更改。`CarModel __new__`工厂字典中的值已被删除，并创建了一个新的。然而，如果我们尝试构建第二个`CarModel`实例，它将返回相同的对象（ID相同），尽管我们在第二次调用中没有提供任何参数，`air`变量仍然设置为`True`。这意味着对象第二次没有被初始化，正如我们设计的。'
- en: Obviously, using the flyweight pattern is more complicated than just storing
    features on a single car class. When should we choose to use it? The flyweight
    pattern is designed for conserving memory; if we have hundreds of thousands of
    similar objects, combining similar properties into a flyweight can have an enormous
    impact on memory consumption.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，使用飞weight模式比仅在单个汽车类上存储特征要复杂得多。我们应该在什么情况下选择使用它？飞weight模式是为了节省内存；如果我们有成千上万的相似对象，将相似属性组合到飞weight中可以在内存消耗上产生巨大的影响。
- en: It is common for programming solutions that optimize CPU, memory, or disk space
    to result in more complicated code than their unoptimized brethren. It is therefore
    important to weigh up the trade-offs when deciding between code maintainability
    and optimization. When choosing optimization, try to use patterns such as flyweight
    to ensure that the complexity introduced by optimization is confined to a single
    (well-documented) section of the code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于优化CPU、内存或磁盘空间的编程解决方案，通常会导致比未优化的版本更复杂的代码。因此，在决定代码可维护性和优化之间权衡时，非常重要。在选择优化时，尽量使用如飞weight之类的模式，以确保优化引入的复杂性仅限于代码的一个（良好文档化的）部分。
- en: If you have a lot of Python objects in one program, one of the quickest ways
    to save memory is through the use of `__slots__`. The `__slots__` magic method
    is beyond the scope of this book, but there is plenty of information available
    if you check online. If you are still low on memory, flyweight may be a reasonable
    solution.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个程序中有许多Python对象，通过使用`__slots__`来节省内存是一种快速的方法。`__slots__`魔法方法超出了本书的范围，但如果你在网上查找，会有很多信息。如果你仍然内存不足，轻量级模式可能是一个合理的解决方案。
- en: The command pattern
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令模式
- en: The command pattern adds a level of abstraction between actions that must be
    done and the object that invokes those actions, normally at a later time. In the
    command pattern, client code creates a `Command` object that can be executed at
    a later date. This object knows about a receiver object that manages its own internal
    state when the command is executed on it. The `Command` object implements a specific
    interface (typically, it has an `execute` or `do_action` method, and also keeps
    track of any arguments required to perform the action. Finally, one or more `Invoker`
    objects execute the command at the correct time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式在必须执行的动作和执行这些动作的对象之间添加了一个抽象层，通常在稍后的时间执行。在命令模式中，客户端代码创建一个可以在以后执行的`Command`对象。该对象了解当命令在其上执行时，它将管理自己的内部状态。`Command`对象实现了一个特定的接口（通常，它有一个`execute`或`do_action`方法，并跟踪执行动作所需的任何参数。最后，一个或多个`Invoker`对象在正确的时间执行命令。
- en: 'Here''s the UML diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个UML图：
- en: '![](img/e52cf46a-6bfd-4406-ad35-8d763854b323.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e52cf46a-6bfd-4406-ad35-8d763854b323.png)'
- en: A common example of the command pattern is actions on a graphical window. Often,
    an action can be invoked by a menu item on the menu bar, a keyboard shortcut,
    a toolbar icon, or a context menu. These are all examples of `Invoker` objects.
    The actions that actually occur, such as `Exit`, `Save`, or `Copy`, are implementations
    of `CommandInterface`. A GUI window to receive exit, a document to receive save,
    and `ClipboardManager` to receive copy commands, are all examples of possible
    `Receivers`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式的一个常见例子是在图形窗口上的操作。通常，一个动作可以通过菜单栏上的菜单项、键盘快捷键、工具栏图标或上下文菜单来调用。这些都是`Invoker`对象的例子。实际发生的动作，如`Exit`、`Save`或`Copy`，是`CommandInterface`的实现。用于接收退出命令的GUI窗口、用于接收保存命令的文档和用于接收复制命令的`ClipboardManager`都是可能的`Receivers`的例子。
- en: 'Let''s implement a simple command pattern that provides commands for `Save`
    and `Exit` actions. We''ll start with some modest receiver classes, themselves
    with the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个简单的命令模式，为`Save`和`Exit`操作提供命令。我们将从一些简单的接收器类开始，它们本身具有以下代码：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These mock classes model objects that would likely be doing a lot more in a
    working environment. The window would need to handle mouse movement and keyboard
    events, and the document would need to handle character insertion, deletion, and
    selection. But for our example, these two classes will do what we need.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模拟类模拟了在正常环境中可能会做很多事情的对象。窗口需要处理鼠标移动和键盘事件，文档需要处理字符插入、删除和选择。但在我们的例子中，这两个类将完成我们需要的功能。
- en: 'Now let''s define some invoker classes. These will model toolbar, menu, and
    keyboard events that can happen; again, they aren''t actually hooked up to anything,
    but we can see how they are decoupled from the command, receiver, and client code
    in the following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一些调用者类。这些类将模拟工具栏、菜单和键盘事件，它们实际上并没有连接到任何东西，但我们可以从以下代码片段中看到它们是如何与命令、接收器和客户端代码解耦的：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice how the various action methods each call the `execute` method on their
    respective commands? This code doesn't show the `command` attribute being set
    on each object. They could be passed into the `__init__` function, but because
    they may be changed (for example, with a customizable keybinding editor), it makes
    more sense to set the attributes on the objects afterwards.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到各种动作方法是如何分别调用它们各自命令的`execute`方法的吗？这段代码没有显示在每个对象上设置`command`属性。它们可以被传递到`__init__`函数中，但由于它们可能会改变（例如，使用可定制的键绑定编辑器），在对象之后设置属性更合理。
- en: 'Now, let''s hook up the commands themselves with the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用以下代码将命令本身连接起来：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These commands are straightforward; they demonstrate the basic pattern, but
    it is important to note that we can store state and other information with the
    command if necessary. For example, if we had a command to insert a character,
    we could maintain state for the character currently being inserted.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令很简单；它们展示了基本模式，但重要的是要注意，如果需要，我们可以将状态和其他信息存储在命令中。例如，如果我们有一个插入字符的命令，我们可以维护当前正在插入的字符的状态。
- en: 'Now all we have to do is hook up some client and test code to make the commands
    work. For basic testing, we can just include the following code at the end of
    the script:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要连接一些客户端和测试代码，以便使命令生效。对于基本测试，我们只需在脚本的末尾包含以下代码即可：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, we create two receivers and two commands. Then, we create several of
    the available invokers and set the correct command on each of them. To test, we
    can use `python3``-i``filename.py` and run code such as `exit_menu.click()`, which
    will end the program, or `save_keystroke.keystroke()`, which will save the fake
    file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建两个接收器和两个命令。然后，我们创建几个可用的调用者，并将正确的命令设置在每个调用者上。为了测试，我们可以使用 `python3 -i filename.py`
    并运行如 `exit_menu.click()` 这样的代码，这将结束程序，或者 `save_keystroke.keystroke()`，这将保存假文件。
- en: Unfortunately, the preceding examples do not feel terribly Pythonic. They have
    a lot of "boilerplate code" (code that does not accomplish anything, but only
    provides structure to the pattern), and the `Command` classes are all eerily similar
    to each other. Perhaps we could create a generic command object that takes a function
    as a callback?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，前面的例子并不觉得特别像 Python。它们有很多“样板代码”（不完成任何事情，但只为模式提供结构的代码），并且 `Command` 类彼此之间非常相似。也许我们可以创建一个通用的命令对象，它接受一个函数作为回调？
- en: 'In fact, why bother? Can we just use a function or method object for each command?
    Instead of an object with an `execute()` method, we can write a function and use
    that as the command directly. The following is a common paradigm for the command
    pattern in Python:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，为什么麻烦呢？我们能否为每个命令直接使用一个函数或方法对象？而不是一个带有 `execute()` 方法的对象，我们可以编写一个函数并将其直接用作命令。以下是在
    Python 中命令模式的常见范式：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that looks a lot more like Python. At first glance, it looks like we've
    removed the command pattern altogether, and we've tightly connected the `menu_item`
    and `Window` classes. But if we look closer, we find there is no tight coupling
    at all. Any callable can be set up as the command on `MenuItem`, just as before.
    And the `Window.exit` method can be attached to any invoker. Most of the flexibility
    of the command pattern has been maintained. We have sacrificed complete decoupling
    for readability, but this code is, in my opinion, and that of many Python programmers,
    more maintainable than the fully abstracted version.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来更像是 Python。乍一看，我们好像完全去除了命令模式，并且将 `menu_item` 和 `Window` 类紧密连接在一起。但如果我们仔细观察，会发现实际上并没有紧密耦合。任何可调用的对象都可以设置为
    `MenuItem` 上的命令，就像之前一样。而且 `Window.exit` 方法可以附加到任何调用者上。命令模式的多数灵活性都得到了保持。我们为了可读性牺牲了完全解耦，但在我看来，以及许多
    Python 程序员的看法，这段代码比完全抽象化的版本更容易维护。
- en: 'Of course, since we can add a `__call__` method to any object, we aren''t restricted
    to functions. The previous example is a useful shortcut when the method being
    called doesn''t have to maintain state, but in more advanced usage, we can use
    the following code as well:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于我们可以向任何对象添加一个 `__call__` 方法，我们并不局限于函数。在需要调用的方法不需要维护状态时，前面的例子是一个有用的快捷方式，但在更高级的使用中，我们也可以使用以下代码：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we have something that looks like the first command pattern, but a bit
    more idiomatic. As you can see, making the invoker call a callable instead of
    a `command` object with an execute method has not restricted us in any way. In
    fact, it's given us more flexibility. We can link to functions directly when that
    works, yet we can build a complete callable `command` object when the situation
    calls for it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一种看起来像是第一个命令模式的东西，但稍微更符合习惯。正如你所见，使调用者调用可调用对象而不是带有执行方法的 `command` 对象并没有以任何方式限制我们。事实上，它给了我们更多的灵活性。当直接链接函数有效时，我们可以直接链接到函数，而当情况需要时，我们也可以构建一个完整的可调用
    `command` 对象。
- en: The command pattern is often extended to support undoable commands. For example,
    a text program may wrap each insertion in a separate command with not only an
    `execute` method, but also an `undo` method that will delete that insertion. A
    graphics program may wrap each drawing action (rectangle, line, freehand pixels,
    and so on) in a command that has an `undo` method that resets the pixels to their
    original state. In such cases, the decoupling of the command pattern is much more
    obviously useful, because each action has to maintain enough of its state to undo
    that action at a later date.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式通常被扩展以支持可撤销的命令。例如，一个文本程序可能会将每个插入操作包裹在一个单独的命令中，不仅包含一个`execute`方法，还包含一个`undo`方法，该方法将删除该插入操作。一个图形程序可能会将每个绘图操作（矩形、线条、自由手绘像素等）包裹在一个具有`undo`方法的命令中，该命令将像素重置到原始状态。在这种情况下，命令模式的解耦显然更有用，因为每个操作都必须保持足够的状态，以便在以后的时间点撤销该操作。
- en: The abstract factory pattern
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: The abstract factory pattern is normally used when we have multiple possible
    implementations of a system that depend on some configuration or platform issue.
    The calling code requests an object from the abstract factory, not knowing exactly
    what class of object will be returned. The underlying implementation returned
    may depend on a variety of factors, such as current locale, operating system,
    or local configuration.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式通常用于当我们有多个可能的系统实现，这些实现依赖于某些配置或平台问题时。调用代码从抽象工厂请求一个对象，并不知道将返回什么类的对象。返回的底层实现可能取决于各种因素，如当前区域设置、操作系统或本地配置。
- en: Common examples of the abstract factory pattern include code for operating-system-independent
    toolkits, database backends, and country-specific formatters or calculators. An
    operating-system-independent GUI toolkit might use an abstract factory pattern
    that returns a set of WinForm widgets under Windows, Cocoa widgets under Mac,
    GTK widgets under Gnome, and QT widgets under KDE. Django provides an abstract
    factory that returns a set of object relational classes for interacting with a
    specific database backend (MySQL, PostgreSQL, SQLite, and others) depending on
    a configuration setting for the current site. If the application needs to be deployed
    in multiple places, each one can use a different database backend by changing
    only one configuration variable. Different countries have different systems for
    calculating taxes, subtotals, and totals on retail merchandise; an abstract factory
    can return a particular tax calculation object.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式的常见例子包括操作系统无关的工具包代码、数据库后端、以及特定国家的格式化器或计算器。一个操作系统无关的GUI工具包可能会使用抽象工厂模式，在Windows下返回一组WinForm小部件，在Mac下返回Cocoa小部件，在Gnome下返回GTK小部件，在KDE下返回QT小部件。Django提供了一个抽象工厂，根据当前站点的配置设置返回一组用于与特定数据库后端（MySQL、PostgreSQL、SQLite等）交互的对象关系类。如果应用程序需要部署在多个地方，每个地方都可以通过只更改一个配置变量来使用不同的数据库后端。不同的国家有不同的系统来计算零售商品的税费、小计和总计；抽象工厂可以返回特定的税费计算对象。
- en: 'The UML class diagram for an abstract factory pattern is hard to understand
    without a specific example, so let''s turn things around and create a concrete
    example first. In our example, we''ll create a set of formatters that depend on
    a specific locale and help us format dates and currencies. There will be an abstract
    factory class that picks the specific factory, as well as a couple of example
    concrete factories, one for France and one for the USA. Each of these will create
    formatter objects for dates and times, which can be queried to format a specific
    value. This is depicted in the following diagram:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 没有具体示例，抽象工厂模式的UML类图很难理解，所以让我们先反过来创建一个具体的例子。在我们的例子中，我们将创建一组依赖于特定区域设置的格式化器，帮助我们格式化日期和货币。将有一个抽象工厂类来选择特定的工厂，以及几个具体的示例工厂，一个用于法国，一个用于美国。每个这些都将创建日期和时间的格式化器对象，可以查询以格式化特定值。这将在以下图中表示：
- en: '![](img/f5f237a6-54d7-45f3-9978-66742550e887.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f5f237a6-54d7-45f3-9978-66742550e887.png)'
- en: Comparing that image to the earlier, simpler text shows that a picture is not
    always worth a thousand words, especially considering we haven't even allowed
    for factory selection code here.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将该图像与早期的简单文本进行比较表明，一张图片并不总是值一千个字，尤其是考虑到我们甚至没有考虑到工厂选择代码。
- en: 'Of course, in Python, we don''t have to implement any interface classes, so
    we can discard `DateFormatter`, `CurrencyFormatter`, and `FormatterFactory`. The
    formatting classes themselves are pretty straightforward, if verbose, shown here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在Python中，我们不需要实现任何接口类，因此我们可以丢弃`DateFormatter`、`CurrencyFormatter`和`FormatterFactory`。如果详细说明，格式化类本身相当直接，如下所示：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'These classes use some basic string manipulation to try to turn a variety of
    possible inputs (integers, strings of different lengths, and others) into the
    following formats:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类使用一些基本的字符串操作来尝试将各种可能的输入（整数、不同长度的字符串等）转换为以下格式：
- en: '|  | **USA** | **France** |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|  | **USA** | **France** |'
- en: '| **Date** | mm-dd-yyyy | dd/mm/yyyy |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **日期** | mm-dd-yyyy | dd/mm/yyyy |'
- en: '| **Currency** | $14,500.50 | 14 500€50 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **货币** | $14,500.50 | 14 500€50 |'
- en: There could obviously be more validation on the input in this code, but let's
    keep it simple for this example.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在这个代码中对输入进行更多的验证是有可能的，但为了这个示例，我们还是让它保持简单。
- en: 'Now that we have the formatters set up, we just need to create the formatter
    factories, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了格式化器，我们只需要创建格式化器工厂，如下所示：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we set up the code that picks the appropriate formatter. Since this is
    the kind of thing that only needs to be set up once, we could make it a singleton–except
    singletons aren''t very useful in Python. Let''s just make the current formatter
    a module-level variable instead:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们设置代码来选择合适的格式化器。由于这类事情只需要设置一次，我们可以将其做成单例——但单例在Python中并不很有用。让我们只是将当前的格式化器作为一个模块级变量：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, we hardcode the current country code; in practice, it would
    likely introspect the locale, the operating system, or a configuration file to
    choose the code. This example uses a dictionary to associate the country codes
    with factory classes. Then, we grab the correct class from the dictionary and
    instantiate it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们硬编码了当前的国家代码；在实际应用中，它可能会检查区域设置、操作系统或配置文件来选择代码。这个示例使用字典将国家代码与工厂类关联起来。然后，我们从字典中获取正确的类并实例化它。
- en: 'It is easy to see what needs to be done when we want to add support for more
    countries: create the new formatter classes and the abstract factory itself. Bear
    in mind that `Formatter` classes might be reused; for example, Canada formats
    its currency the same way as the USA, but its date format is more sensible than
    its Southern neighbor.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要为更多国家添加支持时，很容易看出需要做什么：创建新的格式化器类和抽象工厂本身。记住，`Formatter`类可能会被重用；例如，加拿大和美国的货币格式相同，但它的日期格式比其南部的邻国更合理。
- en: Abstract factories often return a singleton object, but this is not required.
    In our code, it's returning a new instance of each formatter every time it's called.
    There's no reason the formatters couldn't be stored as instance variables and
    the same instance returned for each factory.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂通常返回一个单例对象，但这不是必需的。在我们的代码中，每次调用时它都会返回每个格式化器的新实例。没有必要将格式化器存储为实例变量，并为每个工厂返回相同的实例。
- en: 'Looking back at these examples, we see that, once again, there appears to be
    a lot of boilerplate code for factories that just doesn''t feel necessary in Python.
    Often, the requirements that might call for an abstract factory can be more easily
    fulfilled by using a separate module for each factory type (for example: the USA
    and France), and then ensuring that the correct module is being accessed in a
    factory module. The package structure for such modules might look like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾这些示例，我们看到，同样，似乎又有大量的样板代码用于工厂，这在Python中似乎并不必要。通常，可能需要抽象工厂的要求可以通过为每个工厂类型使用单独的模块（例如：美国和法国）来更容易地满足，并确保在工厂模块中访问正确的模块。这样的模块的包结构可能看起来像这样：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The trick is that `__init__.py` in the `localize` package can contain logic
    that redirects all requests to the correct backend. There are a variety of ways
    this might be done.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 技巧在于`localize`包中的`__init__.py`可以包含逻辑，将所有请求重定向到正确的后端。这可以通过多种方式实现。
- en: 'If we know that the backend is never going to change dynamically (that is,
    without a program restart), we can just put some `if` statements in `__init__.py`
    that check the current country code, and use the (normally unacceptable) `from``.backends.USA``import``*`
    syntax to import all variables from the appropriate backend. Or, we could import
    each of the backends and set a `current_backend` variable to point at a specific
    module, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道后端永远不会动态更改（即，无需程序重启），我们可以在`__init__.py`中放置一些`if`语句来检查当前国家代码，并使用（通常不可接受的）`from``.backends.USA``import``*`语法从适当的后端导入所有变量。或者，我们可以导入每个后端并设置一个`current_backend`变量来指向特定的模块，如下所示：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Depending on which solution we choose, our client code would have to call either
    `localize.format_date` or `localize.current_backend.format_date` to get a date
    formatted in the current country's locale. The end result is much more Pythonic
    than the original abstract factory pattern and, in typical usage, is just as flexible.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们选择的解决方案，我们的客户端代码可能需要调用`localize.format_date`或`localize.current_backend.format_date`来获取当前国家地区的日期格式。最终结果比原始的抽象工厂模式更加Pythonic，并且在典型使用中，它同样灵活。
- en: The composite pattern
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合模式
- en: The composite pattern allows complex tree-like structures to be built from simple
    components. These components, called composite objects, are able to behave sort
    of like a container and sort of like a variable, depending on whether they have
    child components. Composite objects are container objects, where the content may
    actually be another composite object.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式允许从简单的组件构建复杂的树状结构。这些组件被称为组合对象，它们能够根据是否有子组件而表现得像容器或变量。组合对象是容器对象，其内容实际上可能是另一个组合对象。
- en: 'Traditionally, each component in a composite object must be either a leaf node
    (that cannot contain other objects) or a composite node. The key is that both
    composite and leaf nodes can have the same interface. The following UML diagram is
    very simple:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，复合对象中的每个组件必须是叶节点（不能包含其他对象）或组合节点。关键是组合和叶节点可以具有相同的接口。以下UML图非常简单：
- en: '![](img/9fa1eb55-b038-4c5b-b10c-c5f34bf86e4d.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9fa1eb55-b038-4c5b-b10c-c5f34bf86e4d.png)'
- en: 'This simple pattern, however, allows us to create complex arrangements of elements,
    all of which satisfy the interface of the component object. The following diagram
    depicts a concrete instance of such a complicated arrangement:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个简单的模式允许我们创建复杂的元素排列，所有这些元素都满足组件对象的接口。以下图展示了这样一个复杂排列的具体实例：
- en: '![](img/99c562f9-c96b-4219-874e-c832fc7aa6ea.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/99c562f9-c96b-4219-874e-c832fc7aa6ea.png)'
- en: The composite pattern is commonly useful in file/folder-like trees. Regardless
    of whether a node in the tree is a normal file or a folder, it is still subject
    to operations such as moving, copying, or deleting the node. We can create a component
    interface that supports these operations, and then use a composite object to represent
    folders, and leaf nodes to represent normal files.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式在类似文件/文件夹的树中非常常用。无论树中的节点是普通文件还是文件夹，它仍然会受到移动、复制或删除节点的操作的影响。我们可以创建一个支持这些操作的组件接口，然后使用组合对象来表示文件夹，用叶节点来表示普通文件。
- en: 'Of course, in Python, once again, we can take advantage of duck typing to implicitly
    provide the interface, so we only need to write two classes. Let''s define these
    interfaces first in the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在Python中，我们再次可以利用鸭子类型来隐式提供接口，因此我们只需要编写两个类。让我们首先在以下代码中定义这些接口：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For each folder (composite) object, we maintain a dictionary of children. For
    many composite implementations, a list is sufficient, but in this case, a dictionary
    will be useful for looking up children by name. Our paths will be specified as
    node names separated by the `/` character, similar to paths in a Unix shell.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个文件夹（组合）对象，我们维护一个子节点字典。对于许多组合实现，列表就足够了，但在这个情况下，使用字典通过名称查找子节点将是有用的。我们的路径将以节点名称通过`/`字符分隔，类似于Unix
    shell中的路径。
- en: Thinking about the methods involved, we can see that moving or deleting a node
    behaves in a similar way, regardless of whether or not it is a file or folder
    node. Copying, however, has to do a recursive copy for folder nodes, while copying
    a file node is a trivial operation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到涉及的方法，我们可以看到移动或删除节点的方式在是否为文件或文件夹节点的情况下都是相似的。然而，对于文件夹节点，复制操作需要进行递归复制，而复制文件节点则是一个简单的操作。
- en: 'To take advantage of the similar operations, we can extract some of the common
    methods into a parent class. Let''s take that discarded `Component` interface
    and change it to a base class with the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用类似的操作，我们可以将一些公共方法提取到一个父类中。让我们将那个废弃的 `Component` 接口改为一个基类，如下所示：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We've created the `move` and `delete` methods on the `Component` class. Both
    of them access a mysterious `parent` variable that we haven't set yet. The `move`
    method uses a module-level `get_path` function that finds a node from a predefined
    root node, given a path. All files will be added to this root node or a child
    of that node. For the `move` method, the target should be an existing folder,
    or we'll get an error. As in many examples in technical books, error handling
    is woefully absent, to help focus on the principles under consideration.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `Component` 类中创建了 `move` 和 `delete` 方法。这两个方法都访问我们尚未设置的神秘 `parent` 变量。`move`
    方法使用一个模块级别的 `get_path` 函数，根据给定的路径从一个预定义的根节点找到一个节点。所有文件都将添加到这个根节点或该节点的子节点。对于 `move`
    方法，目标应该是一个现有的文件夹，否则我们会得到一个错误。正如技术书籍中的许多例子一样，错误处理严重不足，以帮助集中考虑正在考虑的原则。
- en: 'Let''s set up that mysterious `parent` variable in the folder''s `add_child`
    method, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在文件夹的 `add_child` 方法中设置那个神秘的 `parent` 变量，如下所示：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Well, that was easy enough. Let''s see if our composite file hierarchy is working
    properly with the following code snippet:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这很简单。让我们看看以下代码片段是否可以正确地工作我们的组合文件层次结构：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Yes, we can create folders, add folders to other folders, add files to folders,
    and move them around! What more could we ask for in a file hierarchy?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以创建文件夹，将文件夹添加到其他文件夹中，将文件添加到文件夹中，并且可以在它们之间移动！在文件层次结构中我们还能要求什么更多呢？
- en: Well, we could ask for copying to be implemented, but to conserve trees, let's
    leave that as an exercise.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们可以要求实现复制功能，但为了节省树，让我们将其留作练习。
- en: The composite pattern is extremely useful for a variety of tree-like structures,
    including GUI widget hierarchies, file hierarchies, tree sets, graphs, and HTML
    DOM. It can be a useful pattern in Python when implemented according to the traditional
    implementation, as in the example demonstrated earlier. Sometimes, if only a shallow
    tree is being created, we can get away with a list of lists or a dictionary of
    dictionaries, and do not need to implement custom component, leaf, and composite
    classes. Other times, we can get away with implementing only one composite class,
    and treating leaf and composite objects as a single class. Alternatively, Python's
    duck typing can make it easy to add other objects to a composite hierarchy, as
    long as they have the correct interface.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式对于各种树形结构非常有用，包括GUI小部件层次结构、文件层次结构、树集、图和HTML DOM。当按照传统实现方式在Python中实现时，它可以是一个有用的模式，如前面示例所示。有时，如果我们只创建浅层树，我们可以用列表的列表或字典的字典来应付，而不需要实现自定义的组件、叶子和组合类。在其他时候，我们可以只实现一个组合类，并将叶子和组合对象视为一个类。或者，Python的鸭子类型可以使得将其他对象添加到组合层次结构中变得容易，只要它们具有正确的接口。
- en: Exercises
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Before diving into exercises for each design pattern, take a moment to implement
    the `copy` method for the `File` and `Folder` objects in the previous section.
    The `File` method should be quite trivial; just create a new node with the same
    name and contents, and add it to the new parent folder. The `copy` method on `Folder`
    is quite a bit more complicated, as you first have to duplicate the folder, and
    then recursively copy each of its children to the new location. You can call the
    `copy()` method on the children indiscriminately, regardless of whether each is
    a file or a folder object. This will drive home just how powerful the composite
    pattern can be.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入到每个设计模式的练习之前，花点时间实现上一节中 `File` 和 `Folder` 对象的 `copy` 方法。`File` 的方法应该相当简单；只需创建一个具有相同名称和内容的新的节点，并将其添加到新的父文件夹中。`Folder`
    的 `copy` 方法要复杂得多，因为你首先必须复制文件夹，然后将每个子节点递归地复制到新位置。你可以无差别地调用子节点的 `copy()` 方法，无论它们是文件还是文件夹对象。这将充分展示组合模式有多么强大。
- en: Now, as in the previous chapter, look at the patterns we've discussed and consider
    ideal places where you might implement them. You may want to apply the adapter
    pattern to existing code, as it is usually applicable when interfacing with existing
    libraries, rather than new code. How can you use an adapter to force two interfaces
    to interact with each other correctly?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像上一章一样，看看我们讨论过的模式，并考虑你可能实现它们的理想位置。你可能希望将适配器模式应用于现有代码，因为它通常适用于与现有库接口，而不是新代码。你如何使用适配器来强制两个接口正确地相互交互？
- en: Can you think of a system complex enough to justify using the facade pattern?
    Consider how facades are used in real-life situations, such as the driver-facing
    interface of a car, or the control panel in a factory. It is similar in software,
    except the users of the facade interface are other programmers, rather than people
    trained to use them. Are there complex systems in your latest project that could
    benefit from the facade pattern?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到一个足够复杂的系统，以证明使用外观模式的合理性吗？考虑外观在实际生活中的应用，比如汽车的驾驶员界面，或者工厂的控制面板。在软件中，这类似，只是外观接口的用户是其他程序员，而不是受过培训使用它们的人。在你的最新项目中，有复杂到足以从外观模式中受益的系统吗？
- en: It's possible you don't have any huge, memory-consuming code that would benefit
    from the flyweight pattern, but can you think of situations where it might be
    useful? Anywhere that large amounts of overlapping data need to be processed,
    a flyweight is waiting to be used. Would it be useful in the banking industry?
    In web applications? At what point does adopting the flyweight pattern make sense?
    When is it overkill?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你没有大量消耗内存的代码，但你能想到可能有用的情况吗？任何需要处理大量重叠数据的地方，都可能有享元模式等待被使用。在银行业务中会有用吗？在Web应用程序中呢？在什么情况下采用享元模式是有意义的？什么时候又过度了呢？
- en: What about the command pattern? Can you think of any common (or better yet,
    uncommon) examples of places where the decoupling of action from invocation would
    be useful? Look at the programs you use on a daily basis and imagine how they
    are implemented internally. It's likely that many of them use the command pattern
    for one purpose or another.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，命令模式呢？你能想到任何常见的（或者更好的，不常见的）例子，说明从调用中解耦动作会有用吗？看看你每天使用的程序，想象一下它们是如何内部实现的。很可能其中许多程序出于某种目的使用了命令模式。
- en: The abstract factory pattern, or the somewhat more Pythonic derivatives we discussed,
    can be very useful for creating one-touch-configurable systems. Can you think
    of places where such systems are useful?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式，或者我们讨论过的稍微更Python化的衍生模式，对于创建一键可配置的系统非常有用。你能想到这样的系统在哪些地方有用吗？
- en: Finally, consider the composite pattern. There are tree-like structures all
    around us in programming; some of them, like our file hierarchy example, are blatant;
    others are fairly subtle. What situations might arise where the composite pattern
    would be useful? Can you think of places where you can use it in your own code?
    What if you adapted the pattern slightly; for example, to contain different types
    of leaf or composite nodes for different types of objects?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑组合模式。在编程中，我们周围到处都是树状结构；其中一些，比如我们的文件层次结构示例，很明显；其他则相当微妙。在什么情况下组合模式可能会很有用？你能想到在你的代码中可以使用它的地方吗？如果你稍微调整一下模式；例如，为不同类型的对象包含不同类型的叶节点或组合节点，会怎样？
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went into detail on several more design patterns, covering
    their canonical descriptions as well as alternatives for implementing them in
    Python, which is often more flexible and versatile than traditional object-oriented
    languages. The adapter pattern is useful for matching interfaces, while the facade
    pattern is suited to simplifying them. Flyweight is a complicated pattern and
    only useful if memory optimization is required. In Python, the command pattern
    is often more aptly implemented using first class functions as callbacks. Abstract
    factories allow runtime separation of implementations depending on configuration
    or system information. The composite pattern is used universally for tree-like
    structures.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了几个更多的设计模式，包括它们的规范描述以及如何在Python中实现它们，Python通常比传统的面向对象语言更加灵活和多功能。适配器模式用于匹配接口，而外观模式适合简化它们。享元模式是一个复杂的设计模式，只有在需要内存优化时才有效。在Python中，命令模式通常更合适地通过一等函数作为回调来实现。抽象工厂允许根据配置或系统信息在运行时分离实现。组合模式被普遍用于树状结构。
- en: This is the last of the truly object-oriented chapters in this book, but I've
    thrown in a couple of freebies on topics very dear to my heart. In the next chapter,
    we'll discuss how important it is to test Python programs, and how to do it, focusing
    on object-oriented principles.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书中真正面向对象的章节的最后一章，但我还加入了一些我非常关心的主题的免费内容。在下一章中，我们将讨论测试 Python 程序的重要性以及如何进行测试，重点关注面向对象的原则。
