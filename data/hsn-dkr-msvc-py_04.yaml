- en: Creating a REST Service with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python创建REST服务
- en: Following our example in the last chapter, we split the system designed as a
    monolith into smaller services. In this chapter, we will analyze in detail one
    of the microservices (Thoughts Backend) that we mentioned in the previous chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 按照上一章的示例，我们将设计为单体的系统拆分为更小的服务。在本章中，我们将详细分析上一章中提到的一个微服务（Thoughts后端）。
- en: We will talk about how to develop this microservice as an application using
    Python. This microservice will be ready to interact with other microservices through
    a standard web RESTful interface, making it the foundation for our global microservice
    architecture system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论如何使用Python开发这个微服务作为一个应用程序。这个微服务将准备好通过标准的Web RESTful接口与其他微服务进行交互，这使得它成为我们全局微服务架构系统的基础。
- en: We will discuss different elements such as the API design, the database schema
    that supports it, and how to implement and how to implement the microservice.
    Finally, we'll see how to test the application to be sure that it works correctly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论不同的元素，如API设计，支持它的数据库模式，以及如何实现和如何实现微服务。最后，我们将看到如何测试应用程序，以确保它正常工作。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Analyzing the Thoughts Backend microservice
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析Thoughts后端微服务
- en: Designing the RESTful API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计RESTful API
- en: Defining the database schema
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义数据库模式
- en: Implementing the service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施服务
- en: Testing the code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代码
- en: By the end of the chapter, you'll know how to successfully develop a microservice
    application, including the different stages from design to testing.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将知道如何成功开发一个微服务应用程序，包括从设计到测试的不同阶段。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The Thoughts Backend example can be found here ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter02/ThoughtsBackend](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter02/ThoughtsBackend)).
    Installation and running instructions can be found on its `README.md` file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Thoughts后端示例可以在这里找到([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter02/ThoughtsBackend](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter02/ThoughtsBackend))。安装和运行说明可以在其`README.md`文件中找到。
- en: Analyzing the Thoughts Backend microservice
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析Thoughts后端微服务
- en: 'Let''s remember the diagram of microservices that we created in the last chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们在上一章中创建的微服务图表：
- en: '![](img/f0b5a8c0-862d-494e-bfb4-4077bf0f8dd6.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0b5a8c0-862d-494e-bfb4-4077bf0f8dd6.png)'
- en: 'The diagram shows the different elements for our example system: the two backends,
    users and thoughts, and HTML frontend.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示了我们示例系统的不同元素：两个后端，用户和想法，以及HTML前端。
- en: '**Thoughts Backend** will be responsible for storing new thoughts, retrieving
    the existing ones, and searching the database.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**Thoughts后端**将负责存储新的想法，检索现有的想法，并搜索数据库。'
- en: Understanding the security layer
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解安全层
- en: As the Thoughts Backend is going to be available externally, we need to implement
    a security layer. That means we need to identify the user producing the actions
    and verify their validity. For this service example, we will create a new thought from
    the logged in user, and we will retrieve my thoughts, thoughts created by the
    currently logged user.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Thoughts后端将会对外开放，我们需要实现一个安全层。这意味着我们需要识别产生操作的用户并验证其有效性。在这个服务示例中，我们将从已登录的用户创建一个新的想法，并且我们将检索我的想法，以及当前已登录用户创建的想法。
- en: Note the fact that the user is logged also validates the fact that the user
    exists.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意用户已登录也验证了用户的存在。
- en: This security layer will come in the shape of a header. This header will contain
    information that is signed by the user backend, verifying its origin. It will
    take the form of a **JSON Web Token** (**JWT**), [https://jwt.io/introduction/](https://jwt.io/introduction/),
    which is a standard for this purpose.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个安全层将以一个头部的形式出现。这个头部将包含由用户后端签名的信息，验证其来源。它将采用 **JSON Web Token** (**JWT**)，[https://jwt.io/introduction/](https://jwt.io/introduction/)，这是一个标准的用途。
- en: The JWT itself is encrypted, but the information contained here is mostly only
    relevant for checking the user that was logged.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: JWT本身是加密的，但这里包含的信息大多只与检查已登录的用户相关。
- en: A JWT is not the only possibility for the token, and there are other alternatives
    such as storing the equivalent data in a session cookie or in more secure environments
    using similar modules such as PASETO ([https://github.com/paragonie/paseto](https://github.com/paragonie/paseto)).
    Be sure that you review the security implications of your system, which are beyond
    the scope of this book.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: JWT并不是令牌的唯一可能性，还有其他替代方案，比如将等效数据存储在会话cookie中，或者在更安全的环境中使用类似的模块，比如PASETO ([https://github.com/paragonie/paseto](https://github.com/paragonie/paseto))。确保您审查系统的安全影响，这超出了本书的范围。
- en: This method should be handled by the **Users Backend** team, and get packaged
    so that the other microservices can use it. For this chapter, we will include
    the code in this microservice, but we'll see later how to create it so it's related
    to the Users Backend.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法应该由**用户后端**团队处理，并打包，以便其他微服务可以使用它。在本章中，我们将把代码包含在这个微服务中，但稍后我们将看到如何创建它，使其与用户后端相关联。
- en: If the requests don't have a valid header, the API will return a 401 Unauthorized
    status code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求没有有效的头部，API将返回401未经授权的状态码。
- en: Note that not all API endpoints require authentication. In particular, `search`
    does not need to be logged.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非所有API端点都需要身份验证。特别是`search`不需要登录。
- en: With an understanding of how the authentication system is going to work, we
    can start designing the API interface.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 理解了认证系统的工作原理，我们可以开始设计API接口。
- en: Designing the RESTful API
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计RESTful API
- en: We will follow the principles of RESTful design for our API. This means we will
    use constructed URIs that represent resources and then use the HTTP methods to
    perform actions over these resources.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循RESTful设计原则来设计我们的API。这意味着我们将使用构建的URI来表示资源，然后使用HTTP方法来对这些资源执行操作。
- en: In this example, we will only use the `GET` (to retrieve), `POST` (to create),
    and `DELETE` (to delete) methods as the thoughts are not editable. Remember that
    `PUT` (to overwrite completely) and `PATCH` (to perform a partial update) are
    also available.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将只使用`GET`（检索）、`POST`（创建）和`DELETE`（删除）方法，因为思想是不可编辑的。请记住，`PUT`（完全覆盖）和`PATCH`（执行部分更新）也是可用的。
- en: One of the main properties of RESTful APIs is that requests need to be stateless,
    which means that each request is totally self-contained and can be served by any
    server. All the required data should be either at the client (that will send it
    attached to the request) or in a database (so the server will retrieve it in full).
    This property is a hard requirement when dealing with Docker containers, as they
    can be destroyed and recreated without warning.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API的主要特性之一是请求需要是无状态的，这意味着每个请求都是完全独立的，可以由任何服务器提供。所有必需的数据应该在客户端（将其附加到请求中发送）或数据库中（因此服务器将完全检索它）。当处理Docker容器时，这个属性是一个硬性要求，因为它们可以在没有警告的情况下被销毁和重建。
- en: While it is common to have resources that map directly to rows in a database,
    this is not necessary. The resources can be a composition of different tables,
    part of them, or even represent something different altogether, such as an aggregation
    of data, whether certain conditions are met, or a forecast based on analysis on
    the current data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通常资源直接映射到数据库中的行，但这并非必需。资源可以是不同表的组合，其中的一部分，甚至完全代表不同的东西，例如满足某些条件的数据聚合，或者基于当前数据分析的预测。
- en: Analyze the needs of the service and don't feel constrained by your existing
    database design. Migrating a microservice is a good opportunity to revisit the
    old design decisions and to try to improve the general system. Also, remember
    the Twelve-Factor App principles ([https://12factor.net/](https://12factor.net/))
    for improving the design.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 分析服务的需求，不要受现有数据库设计的限制。迁移微服务是重新审视旧设计决策并尝试改进整个系统的好机会。还要记住十二要素应用原则（[https://12factor.net/](https://12factor.net/)）来改进设计。
- en: It's always good to have a brief reminder about REST before starting an API
    design, so you can check [https://restfulapi.net/](https://restfulapi.net/) for
    a recap.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计API之前，最好先简要回顾一下REST，这样您可以查看[https://restfulapi.net/](https://restfulapi.net/)进行复习。
- en: Specifying the API endpoints
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定API端点
- en: 'Our API interface will be as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API接口将如下：
- en: '|  | **Endpoint** | **Requires authentication** | **Returns** |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|  | **端点** | **需要身份验证** | **返回** |'
- en: '| `GET` | `/api/me/thoughts/` | Yes | List of thoughts of the user |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/me/thoughts/` | 是 | 用户的思想列表 |'
- en: '| `POST` | `/api/me/thoughts/` | Yes | The newly created thought |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/api/me/thoughts/` | 是 | 新创建的思想 |'
- en: '| `GET` | `/api/thoughts/` | No | List of all thoughts |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/thoughts/` | 否 | 所有思想的列表 |'
- en: '| `GET` | `/api/thoughts/X/` | No | The thought with ID `X` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/thoughts/X/` | 否 | ID为`X`的思想 |'
- en: '| `GET` | `/api/thoughts/?search=X` | No | Searches all the thoughts that contain
    `X` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/thoughts/?search=X` | 否 | 搜索包含`X`的所有思想 |'
- en: '| `DELETE` | `/admin/thoughts/X/` | No | Deletes thought with ID `X` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `/admin/thoughts/X/` | 否 | 删除ID为`X`的思想 |'
- en: 'Note there are two elements of the API:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意API有两个元素：
- en: 'A public API, starting with `/api`:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个公共API，以`/api`开头：
- en: An authenticated public API, starting with `/api/me`. The user needs to be authenticated
    to perform these actions. A non-authenticated request will return a 401 Unauthorized
    status code.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个经过身份验证的公共API，以`/api/me`开头。用户需要经过身份验证才能执行这些操作。未经身份验证的请求将返回401未经授权状态码。
- en: A non-authenticated public API, starting with `/api`. Any user, even not authenticated,
    can perform these actions.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个非经过身份验证的公共API，以`/api`开头。任何用户，即使没有经过身份验证，也可以执行这些操作。
- en: An admin API (starting with `/admin`). This won't be exposed publicly. It spares
    the authentication and allows you to do operations that are not designed to be
    done by customers. Clearly labeling with a prefix helps to audit the operations
    and clearly signifies that they should not be available outside of your data center.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个管理员API（以`/admin`开头）。这不会公开。它省去了身份验证，并允许您执行不是为客户设计的操作。明确地使用前缀标记有助于审计操作，并清楚地表明它们不应该在数据中心之外可用。
- en: 'The format of a thought is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 思想的格式如下：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To create one, only the text needs to be sent. The timestamp is set automatically,
    the ID is created automatically, and the username is detected by the authentication
    data.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个，只需要发送文本。时间戳会自动设置，ID会自动创建，用户名会被身份验证数据检测到。
- en: As this is an example, this API is designed to be minimal. In particular, more
    administrator endpoints could be created to effectively impersonate a user and
    allow administrator actions. The `DELETE` action was the first action included
    as a way of cleaning tests.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这只是一个示例，这个API被设计为最小化。特别是，可以创建更多的管理员端点来有效地模拟用户并允许管理员操作。`DELETE`操作是第一个包括的操作，用于清理测试。
- en: 'One final detail: there is some debate over whether it''s best to end URI resources
    with a final slash or not. When working with Flask, though, defining them with
    a slash will return a redirect status code, `308 PERMANENT_REDIRECT`, for a request
    without the proper ending. In any case, try to be consistent to avoid confusion.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个细节：关于是否最好以斜杠结尾URI资源存在一些争论。然而，在使用Flask时，用斜杠定义它们将返回一个重定向状态码，`308 PERMANENT_REDIRECT`，对于没有正确结尾的请求。无论如何，尽量保持一致以避免混淆。
- en: Defining the database schema
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义数据库模式
- en: 'The database schema is simple and inherited from the monolith. We care only
    about the thoughts, stored in the `thought_model` table, so the database structure
    is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库模式简单，继承自单体。我们只关心存储在`thought_model`表中的想法，因此数据库结构如下：
- en: '| **Field** | **Type** | **Comments** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **类型** | **注释** |'
- en: '| `id` | `INTEGER NOT NULL` | Primary key |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `id` | `INTEGER NOT NULL` | 主键 |'
- en: '| `username` | `VARCHAR(50)` |  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `username` | `VARCHAR(50)` |  |'
- en: '| `text` | `VARCHAR(250)` |  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `text` | `VARCHAR(250)` |  |'
- en: '| `timestamp` | `DATETIME` | Creation time |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `timestamp` | `DATETIME` | 创建时间 |'
- en: The thought_model table
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: thought_model表
- en: 'This table is represented in code in the `thoughts_backend/models.py` file,
    described in SQLAlchemy format with the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表在`thoughts_backend/models.py`文件中以SQLAlchemy格式表示，代码如下：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: SQLAlchemy is capable of creating the table for testing purposes or for development
    mode. For this chapter, we defined the database to be SQLite, which stores the
    data in the `db.sqlite3` file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy能够为测试目的或开发模式创建表。在本章中，我们将数据库定义为SQLite，它将数据存储在`db.sqlite3`文件中。
- en: Working with SQLAlchemy
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SQLAlchemy
- en: SQLAlchemy ([https://www.sqlalchemy.org/](https://www.sqlalchemy.org/)) is a
    powerful Python module to work with SQL databases. There are two approaches to
    dealing with databases with a high-level language such as Python. One is keeping
    the low-level approach and doing raw SQL statements, retrieving the data as it
    is in the database. The other is to abstract the database using an **Object-Relational
    Mapper** (**ORM**) and use the interface without getting into the details of how
    it is implemented.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy ([https://www.sqlalchemy.org/](https://www.sqlalchemy.org/))是一个强大的Python模块，用于处理SQL数据库。处理高级语言（如Python）的数据库有两种方法。一种是保持低级方法，使用原始SQL语句，检索数据库中的数据。另一种是使用**对象关系映射器**（**ORM**）来抽象数据库，并在不涉及实现细节的情况下使用接口。
- en: The first approach is well represented by the Python database API specification
    (PEP 249—[https://www.python.org/dev/peps/pep-0249/](https://www.python.org/dev/peps/pep-0249/)),
    which is followed by all major databases, such as `psycopg2` ([http://initd.org/psycopg/](http://initd.org/psycopg/))
    for PostgreSQL. This mainly creates SQL string commands, executes them, and then
    parses the results. This allows us to tailor each query, but it's not very productive
    for common operations that get repeated over and over. PonyORM ([https://ponyorm.org/](https://ponyorm.org/))
    is another example that's not so low level but still aims at replicating the SQL
    syntax and structure.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法由Python数据库API规范（PEP 249—[https://www.python.org/dev/peps/pep-0249/](https://www.python.org/dev/peps/pep-0249/)）很好地代表，所有主要数据库都遵循这一规范，比如`psycopg2`
    ([http://initd.org/psycopg/](http://initd.org/psycopg/))用于PostgreSQL。这主要创建SQL字符串命令，执行它们，然后解析结果。这使我们能够定制每个查询，但对于重复的常见操作来说并不是很高效。PonyORM
    ([https://ponyorm.org/](https://ponyorm.org/))是另一个例子，它不那么低级，但仍旨在复制SQL语法和结构。
- en: For the second approach, the best-known example is probably the Django ORM ([https://docs.djangoproject.com/en/2.2/topics/db/](https://docs.djangoproject.com/en/2.2/topics/db/)).
    It abstracts the database access using defined model python objects. It works
    fantastically well for common operations, but its model assumes that the definition
    of the database is done in our Python code, and mapping legacy databases can be
    very painful. Some complex SQL operations created by the ORM can take a lot of
    time, while a custom-tailored query could save a lot of time. It's also easy to
    perform slow queries without even realizing, just because the tool abstracts us
    so much from the end result.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二种方法，最著名的例子可能是Django ORM ([https://docs.djangoproject.com/en/2.2/topics/db/](https://docs.djangoproject.com/en/2.2/topics/db/))。它使用定义的模型Python对象来抽象数据库访问。对于常见操作，它的工作效果非常好，但它的模型假设数据库的定义是在我们的Python代码中完成的，映射遗留数据库可能非常痛苦。ORM创建的一些复杂SQL操作可能需要很长时间，而定制的查询可以节省大量时间。工具使我们与最终结果的关系如此之远，甚至可能不自觉地执行缓慢的查询。
- en: 'SQLAlchemy ([https://www.sqlalchemy.org/](https://www.sqlalchemy.org/)) is
    quite flexible and can work on both ends of the spectrum. It''s not as straightforward
    or as easy to use as the Django ORM, but it allows us to map existing databases
    into an ORM. This is why we will use it in our example: it can take an existing,
    complicated legacy database and map it, allowing you to perform simple operations
    easily and complicated operations in exactly the way you want.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy ([https://www.sqlalchemy.org/](https://www.sqlalchemy.org/))非常灵活，可以在两端工作。它不像Django
    ORM那样直截了当或易于使用，但它允许我们将现有的数据库映射到ORM。这就是为什么我们会在我们的示例中使用它：它可以接受现有的、复杂的遗留数据库并进行映射，使您可以轻松执行简单的操作和以您想要的方式执行复杂的操作。
- en: Keep in mind that the operations we are going to be using in this book are quite
    simple and SQLAlchemy won't shine particularly in those tasks. But it's an invaluable
    tool if you're planning a complex migration from an old monolith that accesses
    the database through manually written SQL statements, to a newly created microservice.
    If you are already dealing with a complicated database, spending some time learning
    how to use SQLAlchemy will be invaluable. A well-tailored SQLAlchemy definition
    can perform some abstract tasks very efficiently, but it requires good knowledge
    of the tool.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们将在本书中使用的操作非常简单，SQLAlchemy在这些任务中不会特别突出。但是，如果您计划从通过手动编写SQL语句访问数据库的旧单体迁移到新创建的微服务，那么SQLAlchemy是一个无价的工具。如果您已经处理了一个复杂的数据库，花一些时间学习如何使用SQLAlchemy将是非常宝贵的。一个精心设计的SQLAlchemy定义可以非常高效地执行一些抽象任务，但它需要对工具有很好的了解。
- en: The documentation for Flask-SQLAlchemy ([https://flask-sqlalchemy.palletsprojects.com/en/2.x/](https://flask-sqlalchemy.palletsprojects.com/en/2.x/))
    is a good place to start, as it summarizes the main operations, and the main SQLAlchemy
    documentation can be overwhelming at first.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-SQLAlchemy的文档([https://flask-sqlalchemy.palletsprojects.com/en/2.x/](https://flask-sqlalchemy.palletsprojects.com/en/2.x/))是一个很好的起点，因为它总结了主要操作，而主要的SQLAlchemy文档一开始可能会让人感到不知所措。
- en: 'After we define a model, we can perform a query by using the `query` attribute
    in the model and filter accordingly:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义模型之后，我们可以通过模型中的`query`属性执行查询，并相应地进行过滤：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Storing and deleting a row requires the use of the session and then committing
    it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 存储和删除一行需要使用会话，然后提交它：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To see how to configure the database access, check the `thoughts_backend/db.py` file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看如何配置数据库访问，请查看`thoughts_backend/db.py`文件。
- en: Implementing the service
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施服务
- en: To implement this microservice, we will use Flask-RESTPlus ([https://flask-restplus.readthedocs.io/en/stable/](https://flask-restplus.readthedocs.io/en/stable/)).
    This is a Flask ([https://palletsprojects.com/p/flask/](https://palletsprojects.com/p/flask/))
    extension. Flask is a well-known Python microframework for web applications that's
    particularly good at implementing microservices, as it's small, easy to use, and
    compatible with the usual technology stack in terms of web applications, since
    it uses the **Web Server Gateway Interface** (**WSGI**) protocol.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个微服务，我们将使用Flask-RESTPlus（[https://flask-restplus.readthedocs.io/en/stable/](https://flask-restplus.readthedocs.io/en/stable/)）。这是一个Flask（[https://palletsprojects.com/p/flask/](https://palletsprojects.com/p/flask/)）的扩展。Flask是一个著名的Python微框架，特别擅长实现微服务，因为它小巧、易于使用，并且与Web应用程序的常规技术栈兼容，因为它使用**Web服务器网关接口**（**WSGI**）协议。
- en: Introducing Flask-RESTPlus
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Flask-RESTPlus
- en: 'Flask is capable of implementing a RESTful interface, but Flask-RESTPlus adds
    some very interesting capabilities that allow for good developing practices and
    speed of development:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Flask能够实现RESTful接口，但Flask-RESTPlus添加了一些非常有趣的功能，可以支持良好的开发实践和快速开发：
- en: It defines namespaces, which are ways of creating prefixes and structuring the
    code. This helps long-term maintenance and helps with the design when creating
    new endpoints.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了命名空间，这是创建前缀和结构化代码的一种方式。这有助于长期维护，并在创建新的端点时有助于设计。
- en: If you have more than 10 endpoints in a single namespace, it may be a good time
    to consider dividing it. Use one namespace per file, and allow the size of the
    file to hint when it's a good idea to try to make a division.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在单个命名空间中有超过10个端点，那么现在可能是考虑分割它的好时机。使用一个文件一个命名空间，并允许文件大小提示何时是一个尝试进行分割的好时机。
- en: It has a full solution for parsing input parameters. This means that we have
    an easy way of dealing with endpoints that requires several parameters and validates
    them. Using the *Request Parsing* ([https://flask-restplus.readthedocs.io/en/stable/parsing.html](https://flask-restplus.readthedocs.io/en/stable/parsing.html))
    module is similar to using the `argparse` command-line module ([https://docs.python.org/3/library/argparse.html](https://docs.python.org/3/library/argparse.html)) that's
    included in the Python standard library. It allows defining arguments in the body
    of the request, headers, query strings, or even cookies.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个完整的解决方案来解析输入参数。这意味着我们有一种简单的方法来处理需要多个参数并验证它们的端点。使用*请求解析*（[https://flask-restplus.readthedocs.io/en/stable/parsing.html](https://flask-restplus.readthedocs.io/en/stable/parsing.html)）模块类似于使用Python标准库中包含的`argparse`命令行模块（[https://docs.python.org/3/library/argparse.html](https://docs.python.org/3/library/argparse.html)）。它允许在请求体、标头、查询字符串甚至cookie的参数中定义参数。
- en: In the same way, it has a serialization framework for the resulting objects.
    Flask-RESTful calls it **response marshalling** ([https://flask-restplus.readthedocs.io/en/stable/marshalling.html](https://flask-restplus.readthedocs.io/en/stable/marshalling.html)).
    This helps to define objects that can be reused, clarifying the interface and
    simplifying the development. If enabled, it also allows for field masks, which
    return partial objects.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，它还有一个用于生成对象的序列化框架。Flask-RESTful称之为**响应编组**（[https://flask-restplus.readthedocs.io/en/stable/marshalling.html](https://flask-restplus.readthedocs.io/en/stable/marshalling.html)）。这有助于定义可以重复使用的对象，澄清接口并简化开发。如果启用，它还允许字段掩码，返回部分对象。
- en: 'It has full Swagger API documentation support. Swagger ([https://swagger.io/](https://swagger.io/))
    is an open source project to help in the design, implementation, documentation,
    and testing of RESTful API web services, following standard OpenAPI specifications.
    Flask-RESTPlus automatically generates a Swagger specification and self-documenting
    page:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有完整的Swagger API文档支持。Swagger（[https://swagger.io/](https://swagger.io/)）是一个开源项目，用于帮助设计、实现、文档化和测试RESTful
    API Web服务，遵循标准的OpenAPI规范。Flask-RESTPlus自动生成了Swagger规范和自我记录页面：
- en: '![](img/c4c54c31-5d8e-4b11-b13b-9e3d21a30b6c.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4c54c31-5d8e-4b11-b13b-9e3d21a30b6c.png)'
- en: The main Swagger documentation page for the Thoughts Backend API, generated
    automatically
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Thoughts Backend API的主要Swagger文档页面，自动生成
- en: 'Other nice elements of Flask are derived from the fact that it''s a popular
    project and has a lot of supported tools:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Flask的其他好元素源自它是一个受欢迎的项目，并且有很多支持的工具：
- en: We will use the connector for SQLAlchemy, Flask-SQLAlchemy ([https://flask-sqlalchemy.palletsprojects.com/en/2.x/](https://flask-sqlalchemy.palletsprojects.com/en/2.x/)).
    Its documentation covers most of the common cases, while the SQLAlchemy documentation
    is more detailed and can be a bit overwhelming.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用SQLAlchemy的连接器Flask-SQLAlchemy（[https://flask-sqlalchemy.palletsprojects.com/en/2.x/](https://flask-sqlalchemy.palletsprojects.com/en/2.x/)）。它的文档涵盖了大多数常见情况，而SQLAlchemy的文档更详细，可能有点令人不知所措。
- en: To run the tests, the `pytest-flask` module ([https://pytest-flask.readthedocs.io/en/latest/](https://pytest-flask.readthedocs.io/en/latest/))
    creates some fixtures ready to work with a Flask application. We will talk more
    about this in the *Testing the code* section.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要运行测试，`pytest-flask`模块（[https://pytest-flask.readthedocs.io/en/latest/](https://pytest-flask.readthedocs.io/en/latest/)）创建了一些准备与Flask应用程序一起工作的固定装置。我们将在*测试代码*部分更多地谈论这个。
- en: Handling resources
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理资源
- en: 'A typical RESTful application has the following general structure:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的RESTful应用程序具有以下一般结构：
- en: A URL-defined **resource**. This resource allows one or more actions through
    HTTP methods (`GET`, `POST`, and so on).
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个由URL定义的资源。这个资源允许通过HTTP方法（`GET`，`POST`等）执行一个或多个操作。
- en: When each of the actions is called, the framework routes the request until the
    defined code executes the action.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次调用这些操作时，框架都会路由请求，直到定义的代码执行操作。
- en: If there are any input parameters, they'll need to be validated first.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有任何输入参数，它们将首先需要进行验证。
- en: Perform the action and obtain a result value. This action will normally involve
    one or more calls to the database, which will be done in the shape of models.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行操作并获得结果值。此操作通常涉及对数据库的一个或多个调用，这将以模型的形式完成。
- en: Prepare the resulting result value and encode it in a way that's understood
    by the client, typically in JSON.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备结果值并以客户端理解的方式进行编码，通常是JSON格式。
- en: Return the encoded value to the client with the adequate status code.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将编码值返回给客户端，并附上适当的状态码。
- en: Most of these actions are done by the framework. Some configuration work needs
    to be done, but it's where our web framework, Flask-RESTPlus in this example,
    will help the most. In particular, everything but *step 4* will be greatly simplified.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些操作都是由框架完成的。需要进行一些配置工作，但这就是我们的Web框架，例如在这个例子中的Flask-RESTPlus，将提供最大的帮助。特别是除了*步骤4*之外，其他都将大大简化。
- en: 'Let''s take a look at a simple code example (available in GitHub) to describe
    it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的代码示例（在GitHub上可用）来描述它：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This implements the `GET /api/thoughts/X/` action, retrieving a single thought
    by ID.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这实现了`GET /api/thoughts/X/`操作，通过ID检索单个想法。
- en: 'Let''s analyze each of the elements. Note the lines are grouped thematically:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析每个元素。请注意，行是按主题分组的。
- en: 'First, we define the resource by its URL. Note that `api_namespace` sets the
    `api` prefix to the URL, which validates that parameter `X` is an integer:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们通过其URL定义资源。请注意，`api_namespace`设置了URL的`api`前缀，这将验证参数`X`是一个整数：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The class allows you to perform multiple actions on the same resource. In this
    case, we only do one: the `GET` action.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类允许您对同一资源执行多个操作。在这种情况下，我们只执行一个：`GET`操作。
- en: 'Note that the `thought_id` parameter, encoded in the URL, is passed as a parameter
    to the method:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，编码在URL中的`thought_id`参数作为参数传递给该方法：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can now execute the action, which is a search in the database to retrieve
    a single object. Call `ThoughModel` to search for the specified thought. If found,
    it''s returned with a `http.client.OK (200)` status code. If it''s not found,
    an empty result and a `http.client.NOT_FOUND 404` status code is returned:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以执行该操作，这是在数据库中搜索以检索单个对象。调用`ThoughModel`来搜索指定的想法。如果找到，将以`http.client.OK
    (200)`状态代码返回。如果未找到，则返回空结果和`http.client.NOT_FOUND 404`状态代码：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `thought` object is being returned. The `marshal_with` decorator describes
    how the Python object should be serialized into a JSON structure. We''ll see later
    how to configure it:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`thought`对象。`marshal_with`装饰器描述了Python对象应如何序列化为JSON结构。稍后我们将看到如何配置它：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we have some documentation, including the docstring that will be rendered
    by the autogenerated Swagger API:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有一些文档，包括由自动生成的Swagger API呈现的文档字符串：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, most of the actions are configured and performed through Flask-RESTPlus,
    and the bulk of the work as a developer is the meaty *step 4*. There's work to
    do, though, configuring what the expected input parameters are and validating
    them, as well as how to serialize the returning object into proper JSON. We'll
    see how Flask-RESTPlus can help us with that.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，大多数操作都是通过Flask-RESTPlus配置和执行的，作为开发人员的主要工作是肉体的*步骤4*。但是还有一些工作要做，例如配置预期的输入参数并验证它们，以及如何将返回的对象序列化为适当的JSON。我们将看到Flask-RESTPlus如何帮助我们。
- en: Parsing input parameters
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析输入参数
- en: 'The input parameters can take different shapes. When we talk about input parameters,
    we talk mainly about two kinds:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 输入参数可以采用不同的形式。当我们谈论输入参数时，主要谈论两种类型：
- en: 'String query parameters encoded into the URL. These are normally used for the `GET`
    requests, and look like the following:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串查询参数编码到URL中。这些通常用于`GET`请求，看起来像下面这样：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: They are part of the URL and will be stored in any log along the way. The parameters
    are encoded into their own format, called **URL encoding** ([https://www.urlencoder.io/learn/](https://www.urlencoder.io/learn/)).
    You've probably noticed that, for example, an empty space gets transformed to
    `%20`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是URL的一部分，并将存储在沿途的任何日志中。参数被编码为它们自己的格式，称为**URL编码**（[https://www.urlencoder.io/learn/](https://www.urlencoder.io/learn/)）。您可能已经注意到，例如，空格会被转换为`%20`。
- en: Normally, we won't have to decode query parameters manually, as frameworks such
    as Flask do it for us, but the Python standard library has utilities to do so
    ([https://docs.python.org/3/library/urllib.parse.html](https://docs.python.org/3/library/urllib.parse.html)).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不需要手动解码查询参数，因为诸如Flask之类的框架会为我们完成，但是Python标准库具有用于执行此操作的实用程序（[https://docs.python.org/3/library/urllib.parse.html](https://docs.python.org/3/library/urllib.parse.html)）。
- en: Let's look at the body of the HTTP request. This is typically used in the `POST`
    and `PUT` requests. The specific format can be specified using the `Content-Type`
    header. By default, the `Content-Type` header is defined as `application/x-www-form-urlencoded`,
    which encodes it in URL encoding. In modern applications, this is replaced with
    `application/json` to encode them in JSON.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们来看一下HTTP请求的主体。这通常用于`POST`和`PUT`请求。可以使用`Content-Type`头指定特定格式。默认情况下，`Content-Type`头被定义为`application/x-www-form-urlencoded`，它以URL编码的方式进行编码。在现代应用程序中，这被替换为`application/json`以将其编码为JSON。
- en: The body of the requests is not stored in a log. The expectation is that a `GET`
    request produce the same result when called multiple times, that means they are
    idempotent. Therefore, it can be cached by some proxies or other elements. That's
    the reason why your browser asks for confirmation before sending a `POST` request again,
    as this operation may generate different results.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的主体不会存储在日志中。期望是`GET`请求多次调用时产生相同的结果，这意味着它们是幂等的。因此，它可以被一些代理或其他元素缓存。这就是为什么在再次发送`POST`请求之前，您的浏览器会要求确认，因为此操作可能会产生不同的结果。
- en: 'But there are two other places to pass parameters that can also be used:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有另外两个地方可以传递参数：
- en: '**As a part of the URL**: Things such as `thought id` are parameters. Try to
    follow RESTful principles and define your URLs as resources to avoid confusion.
    Query parameters are best left as optional.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为URL的一部分**：像`thought id`这样的东西是参数。尽量遵循RESTful原则，并将URL定义为资源，以避免混淆。查询参数最好留作可选项。'
- en: '**Headers**: Normally, headers give information about metadata, such as the
    format of the request, the expected format, or authentication data. But they need
    to be treated as input parameters as well.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标头**：通常，标头提供有关元数据的信息，例如请求的格式、预期的格式或身份验证数据。但它们也需要被视为输入参数。'
- en: All of these elements are decoded automatically by Flask-RESTPlus, so we don't
    need to deal with encodings and low-level access.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些元素都会被Flask-RESTPlus自动解码，因此我们不需要处理编码和低级访问。
- en: 'Let''s see how this works in our example. This code is extracted from the one
    in GitHub, and shortened to describe the parsing parameters:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这在我们的例子中是如何工作的。这段代码是从GitHub中提取的，并缩短以描述解析参数：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We define a parser in the following lines:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在下面的行中定义了一个解析器：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`authentication_parser` is inherited by `thought_parser` to extend the functionality
    and combine both. Each of the parameters is defined in terms of type and whether
    they are required or not. If a required parameter is missing or another element
    is incorrect, Flask-RESTPlus will raise a `400 BAD_REQUEST` error, giving feedback
    about what went wrong.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`authentication_parser`被`thought_parser`继承，以扩展功能并结合两者。每个参数都根据类型和是否需要来定义。如果缺少必需的参数或其他元素不正确，Flask-RESTPlus将引发`400
    BAD_REQUEST`错误，并提供有关出了什么问题的反馈。'
- en: Because we want to handle the authentication in a slightly different way, we
    label it as not required and allow it to use the default (as created for the framework)
    value of `None`. Note that we specify that the `Authorization` parameter should
    be in the headers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想以稍微不同的方式处理身份验证，我们将其标记为不需要，并允许它使用默认值（由框架创建）`None`。请注意，我们指定`Authorization`参数应该在标头中。
- en: 'The `post` method gets a decorator to show that it expects the `thought_parser` parameter,
    and we parse it with `parse_args`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`post`方法得到一个装饰器，表明它期望`thought_parser`参数，并且我们用`parse_args`解析它：'
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Furthermore, `args` is now a dictionary with all the parameters properly parsed
    and used in the next lines.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`args`现在是一个带有所有参数正确解析并在下一行中使用的字典。
- en: 'In the particular case of the authentication header, there''s a specific function
    to work with that, and it return a `401 UNAUTHORIZED` status code through the
    usage of `abort`. This call immediately stops a request:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在身份验证标头的特定情况下，有一个特定的函数来处理它，并且通过使用`abort`返回`401 UNAUTHORIZED`状态码。这个调用立即停止了一个请求：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We will leave aside for a moment the action to be performed (storing a new thought
    in the database), and focus on the other framework configuration, to serialize
    the result into a JSON object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暂时不考虑要执行的操作（将新的想法存储在数据库中），而是专注于其他框架配置，将结果序列化为JSON对象。
- en: Serializing results
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化结果
- en: We need to return our results. The easiest way to do so is by defining the shape
    the JSON result should have through a serializer or marshalling model ([https://flask-restplus.readthedocs.io/en/stable/marshalling.html](https://flask-restplus.readthedocs.io/en/stable/marshalling.html)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要返回我们的结果。最简单的方法是通过定义JSON结果的形状来实现，通过一个序列化器或编组模型（[https://flask-restplus.readthedocs.io/en/stable/marshalling.html](https://flask-restplus.readthedocs.io/en/stable/marshalling.html)）。
- en: 'A serializer model is defined as a dictionary with the expected fields and
    a field type:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化器模型被定义为一个带有预期字段和字段类型的字典：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The model will take a Python object, and convert each of the attributes into
    the corresponding JSON element, as defined in the field:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型将接受一个Python对象，并将每个属性转换为相应的JSON元素，如字段中所定义的那样：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that `new_thought` is a `ThoughtModel` object, as retrieved by SQLAlchemy.
    We''ll see it in detail next, but for now, it suffices to say that it has all
    the attributes defined in the model: `id`, `username`, `text`, and `timestamp`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`new_thought`是一个`ThoughtModel`对象，由SQLAlchemy检索到。我们将在下面详细介绍它，但现在，可以说它具有模型中定义的所有属性：`id`、`username`、`text`和`timestamp`。
- en: 'Any attribute not present in the memory object will have a value of `None`
    by default. You can change this default to a value that will be returned. You
    can specify a function, so it will be called to retrieve a value when the response
    is generated. This is a way of adding dynamic information to your object:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 内存对象中不存在的任何属性默认值为`None`。您可以将此默认值更改为将返回的值。您可以指定一个函数，因此在生成响应时将调用它来检索值。这是向对象添加动态信息的一种方式：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can also add the name of the attribute to be serialized, in case it''s
    different than the expected outcome, or add a `lambda` function that will be called
    to retrieve the value:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以添加要序列化的属性的名称，以防它与预期的结果不同，或者添加一个将被调用以检索值的`lambda`函数：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For more complex objects, you can nest values like this. Note this defines
    two models from the point of view of the documentation and that each `Nested`
    element creates a new scope. You can also use `List` to add multiple instances
    of the same kind:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的对象，你可以像这样嵌套值。请注意，这从文档的角度定义了两个模型，并且每个`Nested`元素都创建了一个新的作用域。你也可以使用`List`来添加多个相同类型的实例：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Some of the available fields have more options, such as the date format for
    the `DateTime` fields. Check the full field's documentation ([https://flask-restplus.readthedocs.io/en/stable/api.html#models](https://flask-restplus.readthedocs.io/en/stable/api.html#models))
    for more details.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可用字段有更多的选项，比如`DateTime`字段的日期格式。查看完整的字段文档（[https://flask-restplus.readthedocs.io/en/stable/api.html#models](https://flask-restplus.readthedocs.io/en/stable/api.html#models)）以获取更多详细信息。
- en: 'If you return a list of elements, add the `as_list=True` parameter in the `marshal_with`
    decorator:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回一个元素列表，在`marshal_with`装饰器中添加`as_list=True`参数：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `marshal_with` decorator will transform the `result` object from a Python
    object into the corresponding JSON data object.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`marshal_with`装饰器将把`result`对象从Python对象转换为相应的JSON数据对象。'
- en: 'By default, it will return a `http.client.OK (200)` status code, but we can
    return a different status code returning two values: the first is the object to
    `marshal` and the second is the status code. The code parameter in the `marshal_with` decorator is
    used for documentation purposes. Note, in this case, we need to add the specific
    `marshal` call:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它将返回`http.client.OK (200)`状态码，但我们可以返回不同的状态码，返回两个值：第一个是要`marshal`的对象，第二个是状态码。`marshal_with`装饰器中的代码参数用于文档目的。请注意，在这种情况下，我们需要添加特定的`marshal`调用：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The Swagger documentation will display all your used-defined `marshal` objects:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger文档将显示所有您定义的`marshal`对象：
- en: '![](img/1a40a02d-6154-4ae0-877e-48163872898f.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a40a02d-6154-4ae0-877e-48163872898f.png)'
- en: The end of the Swagger page
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger页面的末尾
- en: One inconvenience of Flask-RESTPlus is that to input and output the same objects,
    they need to be defined twice, as the modules for input and output are different.
    This is not the case in some other RESTful frameworks, for example, in the Django
    REST framework ([https://www.django-rest-framework.org/](https://www.django-rest-framework.org/)).
    The maintainers of Flask-RESTPlus are aware of this, and, according to them, they'll
    be integrating an external module, probably `marshmallow` ([https://marshmallow.readthedocs.io/en/stable/](https://marshmallow.readthedocs.io/en/stable/)).
    You can integrate it manually if you like, as Flask is flexible enough to do so,
    take a look at this example ([https://marshmallow.readthedocs.io/en/stable/examples.html#quotes-api-flask-sqlalchemy](https://marshmallow.readthedocs.io/en/stable/examples.html#quotes-api-flask-sqlalchemy)).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-RESTPlus的一个不便之处是，为了输入和输出相同的对象，它们需要定义两次，因为输入和输出的模块是不同的。这在一些其他RESTful框架中并非如此，例如在Django
    REST框架中([https://www.django-rest-framework.org/](https://www.django-rest-framework.org/))。Flask-RESTPlus的维护者们意识到了这一点，并且根据他们的说法，他们将集成一个外部模块，可能是`marshmallow`([https://marshmallow.readthedocs.io/en/stable/](https://marshmallow.readthedocs.io/en/stable/))。如果您愿意，您可以手动集成它，因为Flask足够灵活，可以这样做，看看这个示例([https://marshmallow.readthedocs.io/en/stable/examples.html#quotes-api-flask-sqlalchemy](https://marshmallow.readthedocs.io/en/stable/examples.html#quotes-api-flask-sqlalchemy))。
- en: For more details, you can check the full marshalling documentation at [https://flask-restplus.readthedocs.io/en/stable/marshalling.html](https://flask-restplus.readthedocs.io/en/stable/marshalling.html))
    of Flask-RESTPlus.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，您可以在Flask-RESTPlus的完整编组文档中查看[https://flask-restplus.readthedocs.io/en/stable/marshalling.html](https://flask-restplus.readthedocs.io/en/stable/marshalling.html)。
- en: Performing the action
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行操作
- en: 'Finally, we get to the specific part where the input data is clean and ready
    to use, and we know how to return the result. This part likely involves performing
    some database query or queries and composing the results. Let''s look at the following
    as an example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了输入数据已经清洁并准备好使用的具体部分，我们知道如何返回结果。这部分可能涉及执行一些数据库查询和组合结果。让我们以以下内容作为示例：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see here, after parsing the parameters, we use SQLAlchemy to retrieve
    a query that, if the `search` parameter is present, will apply a filter. We obtain
    all the results with `all()`, returning all the `ThoughtModel` objects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处看到，在解析参数后，我们使用SQLAlchemy检索查询，如果`search`参数存在，将应用过滤器。我们使用`all()`获取所有`ThoughtModel`对象的结果。
- en: Returning the objects marshals (encodes them into JSON) them automatically,
    as we specified in the `marshal_with` decorator.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 返回对象编组(自动将它们编码为JSON)，如我们在`marshal_with`装饰器中指定的那样。
- en: Authenticating the requests
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证请求
- en: The logic for authentication is encapsulated in the `thoughts_backend/token_validation.py`
    file. This contains both the generation and the validation of the header.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证逻辑封装在`thoughts_backend/token_validation.py`文件中。其中包含头部的生成和验证。
- en: 'The following functions generate the `Bearer` token:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数生成`Bearer`令牌：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This generates a JWT payload. It includes `username` to be used as a custom
    value, but it also adds two standard fields, an `exp` expiration date and the `iat` generation
    time of the token.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个JWT有效负载。它包括`username`作为自定义值使用，但它还添加了两个标准字段，即`exp`到期日期和`iat`令牌生成时间。
- en: 'The token is then encoded using the RS256 algorithm, with a private key, and
    returned in the proper format: `Bearer <token>`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用私钥使用RS256算法对令牌进行编码，并以正确的格式返回：`Bearer <token>`。
- en: The reverse action is to obtain the username from an encoded header. The code
    here is longer, as we should account for the different options in which we may
    receive the `Authentication` header. This header comes directly from our public
    API, so we should expect any value and program to be defensively ready for it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 反向操作是从编码的头部获取用户名。这里的代码较长，因为我们应该考虑我们可能收到`Authentication`头部的不同选项。这个头部直接来自我们的公共API，所以我们应该期望任何值并编写程序来做好防御准备。
- en: 'The decoding of the token itself is straightforward, as the `jwt.decode` action
    will do this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌本身的解码很简单，因为`jwt.decode`操作将执行此操作：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'But before arriving at that step, we need to obtain the token and verify that
    the header is valid in multiple cases, so we check first whether the header is
    empty, and whether it has the proper format, extracting the token:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但在到达该步骤之前，我们需要获取令牌并验证多种情况下的头部是否有效，因此我们首先检查头部是否为空，以及是否具有正确的格式，提取令牌：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we decode the token. If the token cannot be decoded with the public key,
    it raises `DecodeError`. The token can also be expired:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们解码令牌。如果无法使用公钥解码令牌，则会引发`DecodeError`。令牌也可能已过期：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, check that it has the expected `exp` and `username` parameters. If any
    of these parameters is missing, that means that the token format, after decoding,
    is incorrect. This may happen when changing the code in different versions:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，检查它是否具有预期的`exp`和`username`参数。如果其中任何一个参数缺失，这意味着令牌在解码后的格式不正确。这可能发生在不同版本中更改代码时。
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If everything goes fine, return the username at the end.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，最后返回用户名。
- en: Each of the possible problems is logged with a different severity. Most common
    occurrences are logged with info- level security, as they are not grave. Things
    such as a format error after the token is decoded may indicate a problem with
    our encoding process.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可能的问题都以不同的严重程度记录。最常见的情况以信息级别的安全性记录，因为它们并不严重。例如，在令牌解码后出现格式错误可能表明我们的编码过程存在问题。
- en: Note that we are using a private/public key schema, instead of a symmetric key
    schema, to encode and decode the tokens. This means that the decoding and encoding
    keys are different.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用的是私钥/公钥架构，而不是对称密钥架构，用于编码和解码令牌。这意味着解码和编码密钥是不同的。
- en: Technically, this is a sign/verification as it is used to generate a signature,
    and not encode/decode, but it's the naming convention used in JWT.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这是一个签名/验证，因为它用于生成签名，而不是编码/解码，但这是JWT中使用的命名约定。
- en: In our microservice structure, only the signing authority requires the private
    key. This increases the security as any key leakage in other services won't be
    able to retrieve a key capable of signing bearer tokens. We'll need to generate
    proper private and public keys, though.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的微服务结构中，只有签名机构需要私钥。这增加了安全性，因为其他服务中的任何密钥泄漏都无法检索到能够签署bearer tokens的密钥。但是，我们需要生成适当的私钥和公钥。
- en: 'To generate a private/public key, run the following command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成私钥/公钥，请运行以下命令：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, to extract the public key, use the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要提取公钥，请使用以下命令：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will generate two files: `key.pem` and `key.pub` with a private/public
    key pair. Reading them in text format will be enough to use them as keys for encoding/decoding
    the JWT token:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成两个文件：`key.pem`和`key.pub`，其中包含私钥/公钥对。以文本格式读取它们就足以将它们用作编码/解码JWT令牌的密钥：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that, for the tests, we generated a **sample key pair** that's attached
    as strings. These keys have been created specifically for this usage and are not
    used anywhere else. Please do not use them anywhere as they are publicly available
    in GitHub.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于测试，我们生成了一个**样本密钥对**，作为字符串附加。这些密钥是专门为此用途创建的，不会在其他任何地方使用。请不要在任何地方使用它们，因为它们在GitHub上是公开可用的。
- en: Be aware that you require a non-encrypted private key, not protected by a password,
    as the JWT module doesn't allow you to add a password. **Do not store production
    secret keys in unprotected files**. In [Chapter 3](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml),
    *Build, Run, and Test Your Service Using Docker*, we'll see how to inject this
    secret using an environment variable, and in [Chapter 11](06d0c451-77f1-4e4a-8d38-3abf112f79fa.xhtml),
    *Handling Change, Dependencies, and Secrets in the System*, we'll see how to properly
    deal with secrets in production environments.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您需要一个非加密的私钥，不受密码保护，因为JWT模块不允许您添加密码。**不要将生产秘钥存储在未受保护的文件中**。在[第3章](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml)中，*使用Docker构建、运行和测试您的服务*，我们将看到如何使用环境变量注入这个秘钥，在[第11章](06d0c451-77f1-4e4a-8d38-3abf112f79fa.xhtml)中，*处理系统中的更改、依赖和秘钥*，我们将看到如何在生产环境中正确处理秘钥。
- en: Testing the code
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码
- en: To test our application, we use the excellent `pytest` framework, which is the
    gold standard in test runners for Python applications.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的应用程序，我们使用了优秀的`pytest`框架，这是Python应用程序的测试运行器的黄金标准。
- en: Basically, `pytest` has a lot of plugins and add-ons to deal with a lot of situations.
    We will be using `pytest-flask`, which helps with running tests for Flask applications.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`pytest`有许多插件和附加组件，可用于处理许多情况。我们将使用`pytest-flask`，它有助于运行Flask应用程序的测试。
- en: 'To run all the tests, just call `pytest` in the command line:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有测试，只需在命令行中调用`pytest`：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that `pytest` has a lot of features available to deal with a lot of situations
    while testing. Things running a subset of matched tests (the `-k` option), running
    the last failed tests (`--lf`), or stopping after the first failure (`-x`) are
    incredibly useful when working with tests. I highly recommend checking its full
    documentation ([https://docs.pytest.org/en/latest/](https://docs.pytest.org/en/latest/))
    and discovering all its possibilities.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`pytest`具有许多可用于处理许多测试情况的功能。在处理测试时，运行匹配测试的子集（`-k`选项）、运行上次失败的测试（`--lf`）或在第一个失败后停止（`-x`）等功能非常有用。我强烈建议查看其完整文档（[https://docs.pytest.org/en/latest/](https://docs.pytest.org/en/latest/)）并发现其所有可能性。
- en: There are also a lot of plugins and extensions for using databases or frameworks,
    reporting code coverage, profiling, BDD, and many others. It is worth finding
    out about them.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多用于使用数据库或框架、报告代码覆盖率、分析、BDD等的插件和扩展。值得了解一下。
- en: We configure the basic usage, including always enabling flags in the `pytest.ini` file
    and the fixtures in `conftest.py`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置了基本用法，包括在`pytest.ini`文件中始终启用标志和在`conftest.py`中的fixtures。
- en: Defining the pytest fixtures
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义pytest fixtures
- en: Fixtures are used in `pytest` to prepare the context in which a test should
    be executed, preparing it and cleaning it at the end. The application fixture
    is expected by `pytest-flask`, as seen in the documentation. The plugin generates
    a `client` fixture that we can use to send requests in test mode. We see this
    fixture in action in the `thoughts_fixture` fixture, which generates three thoughts
    through the API and deletes everything after our test has run.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pytest`中使用fixture来准备测试应该执行的上下文，准备并在结束时清理它。`pytest-flask`需要应用fixture，如文档中所示。该插件生成一个`client`
    fixture，我们可以用它来在测试模式下发送请求。我们在`thoughts_fixture` fixture中看到了这个fixture的使用，它通过API生成三个thoughts，并在我们的测试运行后删除所有内容。
- en: 'The structure, simplified, is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 简化后的结构如下：
- en: 'Generate three thoughts. Store its `thought_id`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成三个thoughts。存储其`thought_id`：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, add `yield thought_ids` to the test:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在测试中添加`yield thought_ids`：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Retrieve all thoughts and delete them one by one:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索所有thoughts并逐个删除它们：
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that we use the `faker` module to generate fake names and text. You can
    check its full documentation at [https://faker.readthedocs.io/en/stable/](https://faker.readthedocs.io/en/stable/).
    It is a great way of generating random values for your tests that avoid reusing `test_user` and
    `test_text` over and over. It also helps to shape your tests, by checking the
    input independently and not blindly copying a placeholder.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`faker`模块生成假姓名和文本。您可以在[https://faker.readthedocs.io/en/stable/](https://faker.readthedocs.io/en/stable/)查看其完整文档。这是一个生成测试随机值的好方法，避免反复使用`test_user`和`test_text`。它还有助于塑造您的测试，通过独立检查输入而不是盲目地复制占位符。
- en: Fixtures can also exercise your API. You can choose a lower-level approach such
    as writing raw information in your database, but using your own defined API is
    a great way of ensuring that you have a complete and useful interface. In our
    example, we added an admin interface that's used to delete thoughts. This is exercised
    throughout the fixture as well as the creation of thoughts for a whole and complete
    interface.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Fixture也可以测试您的API。您可以选择更低级的方法，比如在数据库中编写原始信息，但使用您自己定义的API是确保您拥有完整和有用接口的好方法。在我们的例子中，我们添加了一个用于删除想法的管理员界面。这在整个fixture中都得到了运用，以及为整个和完整的接口创建想法。
- en: This way, we also use tests to validate that we can use our microservice as
    a complete service, without tricking ourselves into hacking our way to perform
    common operations.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们还使用测试来验证我们可以将我们的微服务作为一个完整的服务使用，而不是欺骗自己以执行常见操作。
- en: Also note the usage of the `client` fixture, which is provided by `pytest-flask`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意`client` fixture的使用，这是由`pytest-flask`提供的。
- en: Understanding test_token_validation.py
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解test_token_validation.py
- en: This test file tests the behavior of the `token_validation` module. This module
    covers the generation and validation of the authentication header, so it's important
    to test it thoroughly.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试文件测试了`token_validation`模块的行为。该模块涵盖了认证头的生成和验证，因此对其进行彻底测试非常重要。
- en: 'The tests check that the header can be encoded and decoded with the proper
    keys. It also checks all the different possibilities in terms of invalid inputs:
    different shapes of incorrect formats, invalid decoding keys, or expired tokens.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试检查了头部是否可以使用正确的密钥进行编码和解码。它还检查了在无效输入方面的所有不同可能性：不同形状的不正确格式，无效的解码密钥或过期的令牌。
- en: 'To check for expired tokens, we use two modules: `freezegun`, to make the test
    to retrieve a specific test time ([https://github.com/spulec/freezegun](https://github.com/spulec/freezegun)),
    and `delorean`, to parse dates easily (though, the module is capable of way more;
    check the documentation at [https://delorean.readthedocs.io/en/latest/](https://delorean.readthedocs.io/en/latest/)).
    These two modules are very easy to use and great for testing purposes.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查过期的令牌，我们使用了两个模块：`freezegun`，使测试检索特定的测试时间（[https://github.com/spulec/freezegun](https://github.com/spulec/freezegun)），以及`delorean`，以便轻松解析日期（尽管该模块能够做更多；请查看[https://delorean.readthedocs.io/en/latest/](https://delorean.readthedocs.io/en/latest/)的文档）。这两个模块非常易于使用，非常适合测试目的。
- en: 'For example, this test checks an expired token:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个测试检查了一个过期的令牌：
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note how the freeze time is precisely 1 second after the expiry time of the
    token.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，冻结时间恰好是令牌到期时间后的1秒。
- en: The public and private keys used for tests are defined in the `constants.py` file.
    There's an extra independent public key used to check what happens if you decode
    a token with an invalid public key.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 用于测试的公钥和私钥在`constants.py`文件中定义。还有一个额外的独立公钥用于检查如果使用无效的公钥解码令牌会发生什么。
- en: 'It is worth saying it again: please *do not* use any of these keys. These keys
    are for running tests only and are available to anyone who has access to this
    book.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 值得再次强调：请*不要*使用这些密钥。这些密钥仅用于运行测试，并且可以被任何有权访问本书的人使用。
- en: test_thoughts.py
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: test_thoughts.py
- en: This file checks the defined API interfaces. Each API is tested to perform the
    actions correctly (create a new thought, return thoughts of a user, retrieve all
    thoughts, search through thoughts, and retrieve a thought by ID) as well as some
    error tests (unauthorized requests to create and retrieve thoughts of a user,
    or retrieve a non-existing thought).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件检查了定义的API接口。每个API都经过测试，以正确执行操作（创建新的想法，返回用户的想法，检索所有想法，搜索想法，按ID检索想法），以及一些错误测试（未经授权的请求来创建和检索用户的想法，或检索不存在的想法）。
- en: Here, we use `freezegun` again to determine when the thoughts are created, instead
    of creating them with a timestamp dependent on the time when tests are run.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次使用`freezegun`来确定思想的创建时间，而不是根据测试运行时的时间戳创建它们。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw how to develop a web microservice. We started by designing
    its API following REST principles. Then, we described how to access the schema
    of the database, and how to do it using SQLAlchemy.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们看到了如何开发一个Web微服务。我们首先按照REST原则设计了其API。然后，我们描述了如何访问数据库的模式，并使用SQLAlchemy进行操作。
- en: Then, we learned how to implement it using Flask-RESTPlus. We learned how to
    define the resources being mapped to the API endpoints, how to parse the input
    values, how to process the actions, and then how to return the results using the
    serializer model. We described how the authentication layer works.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了如何使用Flask-RESTPlus来实现它。我们学习了如何定义资源映射到API端点，如何解析输入值，如何处理操作，然后如何使用序列化模型返回结果。我们描述了认证层的工作原理。
- en: We included tests and described how to use the `pytest` fixture to create initial
    conditions for our tests. In the next chapter, we will look at how to containerize
    the service and run it through Docker.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括了测试，并描述了如何使用`pytest` fixture来为我们的测试创建初始条件。在下一章中，我们将学习如何将服务容器化，并通过Docker运行。
- en: Questions
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can you name the characteristics of RESTful applications?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能说出RESTful应用程序的特点吗？
- en: What are the advantages of using Flask-RESTPlus?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Flask-RESTPlus的优势是什么？
- en: Which alternative frameworks to Flask-RESTPlus do you know?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你知道除了Flask-RESTPlus之外的替代框架吗？
- en: Name the Python package used in the tests to fix the time.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试中使用的Python软件包名称来修复时间。
- en: Can you describe the authentication flow?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能描述一下认证流程吗？
- en: Why did we choose SQLAlchemy as a database interface for the example project?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们选择SQLAlchemy作为示例项目的数据库接口？
- en: Further reading
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For an in-depth description of a RESTful design that is not limited to Python,
    you can find more information in *Hands-On RESTful API Design Patterns and Best
    Practices* ([https://www.packtpub.com/gb/application-development/hands-restful-api-design-patterns-and-best-practices](https://www.packtpub.com/gb/application-development/hands-restful-api-design-patterns-and-best-practices)).
    You can learn more about how to use the Flask framework in the book *Flask: Building
    Python Web Services* ([https://www.packtpub.com/gb/web-development/flask-building-python-web-services](https://www.packtpub.com/gb/web-development/flask-building-python-web-services)).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '关于RESTful设计的深入描述，不仅限于Python，您可以在*Hands-On RESTful API Design Patterns and Best
    Practices*中找到更多信息（[https://www.packtpub.com/gb/application-development/hands-restful-api-design-patterns-and-best-practices](https://www.packtpub.com/gb/application-development/hands-restful-api-design-patterns-and-best-practices)）。您可以在书籍*Flask:
    Building Python Web Services*中了解如何使用Flask框架（[https://www.packtpub.com/gb/web-development/flask-building-python-web-services](https://www.packtpub.com/gb/web-development/flask-building-python-web-services)）。'
