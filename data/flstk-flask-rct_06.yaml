- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Working with React Router and Forms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与React Router和表单一起工作
- en: '**React Router** is a library for client- and server-side routing. Imagine
    the usual way websites work; when you click on a link, your browser sends a request
    to the web server, receives a bunch of data, and then takes time to process everything
    before finally displaying the content of the new page.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**React Router**是一个用于客户端和服务器端路由的库。想象一下网站通常是如何工作的；当你点击一个链接时，你的浏览器向web服务器发送一个请求，接收一大堆数据，然后花费时间处理所有这些，最后才最终显示新页面的内容。'
- en: You will get the same experience every time you request a new page from the
    website. With client-side routing, things get way smoother! Instead of going through
    that whole process every time you click a link, your web app can update the URL
    instantly without bothering the server for a new document. This means your web
    app can quickly show you a new part of the app without any delays. This and more
    is what React Router offers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你从网站请求新页面时，你都会获得相同的体验。使用客户端路由，事情会变得非常顺畅！每次你点击链接时，你不必经历整个过程，你的Web应用程序可以立即更新URL，而不必打扰服务器获取新文档。这意味着你的Web应用程序可以快速显示应用程序的新部分，而没有任何延迟。这正是React
    Router所提供的。
- en: In this chapter, we will explore React Router v6 as a magical tool to handle
    navigation. You can also use React Router for data fetching but we will limit
    our scope to component navigation in this book. You will implement simple and
    complex nested routes in React. You will also work with the `useParams` and `useNavigate`
    hooks for dynamic and programmatic routing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索React Router v6作为一个神奇的工具来处理导航。你还可以使用React Router进行数据获取，但我们将本书的范围限制在组件导航。你将在React中实现简单和复杂的嵌套路由。你还将使用`useParams`和`useNavigate`钩子进行动态和程序性路由。
- en: Next, we will delve into form handling in React applications. Forms are vital
    components in any web application. You can’t have a complete soup of web applications
    without forms. Interestingly, we use forms for a variety of purposes that depend
    on the business or project requirements.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨React应用程序中的表单处理。表单是任何Web应用程序中的关键组件。没有表单，你无法拥有一个完整的Web应用程序。有趣的是，我们使用表单来完成各种目的，这些目的取决于业务或项目需求。
- en: In React, forms are used in components to allow activities such as user login,
    registration, search, contact forms, shopping checkout page, event attendees’
    forms, and a host of others. Forms provide a medium for browser-database server
    interactions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，表单用于组件中，以允许用户登录、注册、搜索、联系表单、购物结账页面、活动参与者表单等活动。表单为浏览器-数据库服务器交互提供了一个媒介。
- en: We collect data from users of our applications through a form; sometimes, we
    send users’ data to a database or send/save it to other platforms such as email
    and third-party applications. It all depends on how we intend to handle form data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过表单从我们应用程序的用户那里收集数据；有时，我们将用户数据发送到数据库或发送/保存到其他平台，如电子邮件和第三方应用程序。这完全取决于我们打算如何处理表单数据。
- en: In a nutshell, you will learn how to use form elements to facilitate user interaction
    in your React applications. You will also understand how to leverage React Router,
    a popular routing library for client-side routing.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你将学习如何使用表单元素来促进你的React应用程序中的用户交互。你还将了解如何利用React Router，这是一个流行的客户端路由库。
- en: By the end of this chapter, you will understand how routing works in React applications
    by working with the React Router library to navigate your different application
    endpoints. Finally, you will be able to develop elegant React forms and handle
    users’ information in a React way.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，通过使用React Router库来导航你的不同应用程序端点，你将了解React应用程序中路由是如何工作的。最后，你将能够开发优雅的React表单，并以React的方式处理用户信息。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Routing with React Router
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Router进行路由
- en: Adding React Router in React
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React中添加React Router
- en: Handling dynamic routes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理动态路由
- en: Using forms in React
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React中使用表单
- en: Controlled and uncontrolled form components
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受控和非受控表单组件
- en: Handling user input – `Input field`, `TextArea`, and `Select`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户输入 – `输入字段`、`文本区域`和`选择`
- en: Validating and sanitizing users’ data in React
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React中验证和清理用户数据
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter06](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter06).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter06](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter06)找到。
- en: Due to page constraints, some of the code blocks have been snipped. Please refer
    to GitHub for the complete code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于页面限制，一些代码块已被截断。请参阅GitHub以获取完整代码。
- en: Routing with React Router
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Router进行路由
- en: '**Routing** in a React web application is the ability to navigate seamlessly
    to and from multiple application components, URLs, pages, and resources, both
    internal and external. By default, React doesn’t include page routing in its library.
    And as a matter of fact, React’s main goal is to allow developers to design the
    display of the view of a single-page web application.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由**在React Web应用程序中是指无缝导航到和从多个应用程序组件、URL、页面和资源的能力，无论是内部还是外部。默认情况下，React不包括页面路由在其库中。事实上，React的主要目标是允许开发者设计单页Web应用程序的视图显示。'
- en: We all know web applications require multiple views, hence the need for an external
    library such as React Router to allow for component navigation. Working with a
    large application would require multiple specialized views. This means we have
    to solve the problem of navigation left untreated with the React library, but
    this is where React Router comes in.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道Web应用程序需要多个视图，因此需要像React Router这样的外部库来允许组件导航。处理大型应用程序需要多个专业视图。这意味着我们必须解决React库中未处理的导航问题，但这就是React
    Router发挥作用的地方。
- en: '**React Router** is an open source package that’s used for component-based
    routing in React applications. It is popular among React developers and widely
    used in various React projects. Interestingly, you can use React Router anywhere
    you intend to run React applications: client side with browsers, on a web server
    with NodeJS, and even via mobile applications with React Native.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**React Router**是一个开源包，用于在React应用程序中进行基于组件的路由。它在React开发者中很受欢迎，并在各种React项目中广泛使用。有趣的是，你可以在任何打算运行React应用程序的地方使用React
    Router：客户端使用浏览器、在Web服务器上使用NodeJS，甚至通过React Native在移动应用程序中使用。'
- en: So far, we have kind of taken the *Bizza* application bit by bit, cherry-picking
    the components and their interaction. Now, we are going to move through the pages
    of our projects and link them up with React Router.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已逐步处理了*Bizza*应用程序，挑选组件及其交互。现在，我们将浏览我们项目的页面，并使用React Router将它们链接起来。
- en: React Router is composed of some routing features. These features are the nuts
    and bolts of the inner working of React Router. Knowing them will help us with
    our understanding of React Router. In the following sections, we will explain
    some of the commonly used features of React Router.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: React Router由一些路由功能组成。这些功能是React Router内部工作的螺丝钉。了解它们将有助于我们理解React Router。在以下章节中，我们将解释React
    Router的一些常用功能。
- en: Let’s start with Router, a component that enables navigation and routing within
    a React application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`Router`组件开始，它允许在React应用程序中进行导航和路由。
- en: Routers
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器
- en: 'React Router provides different types of routers that allow you to handle routing
    and navigation in React applications. Each router has its specific use case and
    benefits. We will briefly discuss some of the commonly used React Router routers:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: React Router提供了不同类型的路由器，允许你在React应用程序中处理路由和导航。每个路由器都有其特定的用例和优势。我们将简要讨论一些常用的React
    Router路由器：
- en: '`CreateBrowserRouter`: This is a specialized function in React Router v6 that
    serves as the preferred method for generating a browser router in web projects.
    By utilizing the DOM History API, it efficiently updates the URL and maintains
    the history stack. Moreover, it unlocks access to the v6.4 data APIs, encompassing
    loaders, actions, fetchers, and other React Router functionalities.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateBrowserRouter`：这是React Router v6中的一个专用函数，它作为在Web项目中生成浏览器路由的首选方法。通过利用DOM历史API，它有效地更新URL并维护历史堆栈。此外，它解锁了对v6.4数据API的访问，包括加载器、操作、fetchers和其他React
    Router功能。'
- en: '`RouterProvider`: This component in React Router is designed to supply the
    router instance to all components rendered within its scope. This ensures that
    the router can be utilized for efficient management of the application’s navigation
    and routing needs.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RouterProvider`：这是React Router中的一个组件，旨在为其作用域内渲染的所有组件提供路由实例。这确保了路由可以被用于高效管理应用程序的导航和路由需求。'
- en: The `RouterProvider` component requires a `router` prop as an argument, and
    this prop serves as the router instance that will be distributed to the components
    rendered within `RouterProvider`. It is essential to position `RouterProvider`
    at the highest level in the component tree to ensure that all application components
    can access the router instance effectively.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`RouterProvider` 组件需要一个 `router` 属性作为参数，这个属性作为将要分布到 `RouterProvider` 内渲染的组件中的路由实例。将
    `RouterProvider` 定位在组件树的最顶层是至关重要的，以确保所有应用程序组件都能有效地访问路由实例。'
- en: '`NativeRouter`: This is an interface that is required to run React Router in
    React Native, a routing solution for mobile applications. This is outside the
    scope of this book.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NativeRouter`: 这是一个在 React Native 中运行 React Router 所必需的接口，它是移动应用程序的路由解决方案。这超出了本书的范围。'
- en: Next, we will discuss components in React Router. Components in React Router
    allow you to render the user interface for a specific route within a single-page
    application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论 React Router 中的组件。React Router 中的组件允许您在单页应用程序中渲染特定路由的用户界面。
- en: Components
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件
- en: Components in React Router enable you to create a flexible and dynamic routing
    system within your React applications, making it easier to manage navigation and
    the state as users interact with your UI. We will briefly discuss some of the
    commonly used components.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 中的组件使您能够在 React 应用程序内创建一个灵活且动态的路由系统，这使得管理导航和状态以及用户与您的 UI 交互变得更加容易。我们将简要讨论一些常用组件。
- en: '`Link`: `Link` is a component element that allows users to navigate to another
    component page upon it being clicked. Under the hood, `react-router-dom` renders
    a `<Link>` tag to an anchor element, `<a>`, with a real `href` that directs users
    to the resources it is pointing to.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Link`: `Link` 是一个组件元素，允许用户在点击时导航到另一个组件页面。在底层，`react-router-dom` 将一个 `<Link>`
    标签渲染为一个带有真实 `href` 的锚点元素 `<a>`，该 `href` 将用户引导到它所指向的资源。'
- en: '`NavLink`: This works as a `<Link>` tag but with the added feature of indicating
    an active element in a menu. This is commonly used when you are building a tabbed
    menu and you want to show which part of the menu is currently selected.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NavLink`: 它作为一个 `<Link>` 标签工作，但增加了指示菜单中活动元素的功能。这在构建标签菜单时常用，您想显示当前选中的菜单部分。'
- en: '`Route`: This is used to render the UI in React Router based on the current
    location. `Route` has a path and an element as props. This is how it works: whenever
    the path `Route` component matches the current URL, based on the user click operation,
    it renders its element. This element could be any component in the application.
    We will see a live example shortly.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Route`: 这用于根据当前位置在 React Router 中渲染 UI。`Route` 有一个路径和一个元素作为属性。这是它的工作方式：每当
    `Route` 组件的路径与当前 URL 匹配，基于用户的点击操作，它将渲染其元素。这个元素可以是应用程序中的任何组件。我们很快将看到一个实时示例。'
- en: '`Routes`: This has `Route` as its children. `Routes` works logically in a simple
    way, like `Route`, except that `Route` or a series of `Route` are children of
    `Routes`. So, whenever the path of the UI component changes, `Routes` checks all
    its children `Route` elements to determine the best match for the user request
    or click path and renders that specific UI.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Routes`: 它有 `Route` 作为其子元素。`Routes` 在逻辑上以简单的方式工作，就像 `Route` 一样，只不过 `Route`
    或一系列 `Route` 是 `Routes` 的子元素。因此，每当 UI 组件的路径发生变化时，`Routes` 会检查其所有子 `Route` 元素，以确定用户请求或点击路径的最佳匹配，并渲染该特定
    UI。'
- en: Next, we will discuss hooks in React Router. Hooks provide a mechanism for interacting
    with the router’s state and executing navigation actions directly within your
    components. We will discuss hooks such as `useLocation`, `useParams`, and `useNavigate`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论 React Router 中的钩子。钩子提供了一种与路由状态交互并在组件内直接执行导航操作的机制。我们将讨论 `useLocation`、`useParams`
    和 `useNavigate` 等钩子。
- en: Hooks
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 钩子
- en: 'React Router offers a range of hooks that empower developers with efficient
    ways to manage routing, the state, and navigation within their components. We
    will briefly discuss some of the commonly used hooks:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 提供了一系列钩子，使开发者能够以高效的方式管理组件内的路由、状态和导航。我们将简要讨论一些常用钩子：
- en: '`useLocation`: You can use this hook to perform some side effects whenever
    you need to track changes in the current location. The `useLocation` hook usually
    returns the current location object.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useLocation`: 您可以使用此钩子来在需要跟踪当前位置变化时执行一些副作用。`useLocation` 钩子通常返回当前位置对象。'
- en: '`UseParams`: You can use this hook to get the parameter from the browser through
    the current URL matching `<Route path>`. The `useParams` hook returns an object
    of the key-value pairs of the dynamic params.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UseParams`：您可以使用此钩子通过当前URL匹配`<Route path>`从浏览器获取参数。`useParams`钩子返回一个包含动态参数键值对的对象。'
- en: '`UseNavigate`: You can use this hook to programmatically navigate between different
    routes in your React application without the need for a `history` object or the
    `Link` component.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UseNavigate`：您可以使用此钩子在不使用`history`对象或`Link`组件的情况下，在React应用程序的不同路由之间进行编程式导航。'
- en: Now, it is time to add React Router to our root app and connect our pages.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将React Router添加到我们的根应用程序中，并将我们的页面连接起来。
- en: Adding React Router in React
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React中添加React Router
- en: 'You need to install React Router to use it in your project. We are going to
    build the navigation features for the *Bizza* project to connect different components.
    The navigation tabs will consist of the home, about, speakers, events, sponsors,
    and contact pages. Let’s start coding by entering this command in the project
    directory’s Terminal:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装React Router才能在项目中使用它。我们将为*Bizza*项目构建导航功能，以连接不同的组件。导航标签将包括主页、关于页、演讲者页、活动页、赞助商页和联系页。让我们通过在项目目录的终端中输入以下命令开始编码：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once we have the package installed in the root directory of our project, we
    can create the home, about, speakers, news, and contact pages components.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在项目的根目录中安装了该包，我们就可以创建主页、关于页、演讲者页、新闻页和联系页的组件。
- en: 'Now, we will add content to each of these components:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为这些组件中的每一个添加内容：
- en: 'Inside `src/pages/HomePage/HomePage.js`, add the following code snippet:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`src/pages/HomePage/HomePage.js`内部，添加以下代码片段：
- en: '[PRE1]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside `src/pages/AboutPage/AboutPage.js`, add the following:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`src/pages/AboutPage/AboutPage.js`内部，添加以下内容：
- en: '[PRE2]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Inside `src/pages/SpeakersPage/SpeakersPage.js`, add the following:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`src/pages/SpeakersPage/SpeakersPage.js`内部，添加以下内容：
- en: '[PRE3]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inside `src/pages/EventsPage/EventsPage.js`, add the following:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`src/pages/EventsPage/EventsPage.js`内部，添加以下内容：
- en: '[PRE4]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside `src/pages/SponsorsPage/SponsorsPage.js`, add the following:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`src/pages/SponsorsPage/SponsorsPage.js`内部，添加以下内容：
- en: '[PRE5]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside `src/pages/ContactPage/ContactPage.js`, add the following:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`src/pages/ContactPage/ContactPage.js`内部，添加以下内容：
- en: '[PRE6]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that these components have been set, let’s start implementing the React
    Router functionalities in our application:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些组件已经设置好了，让我们开始在我们的应用程序中实现React Router的功能：
- en: 'Inside `src/index.js`, add the following code:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/index.js`内部，添加以下代码：
- en: '[PRE7]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`createRoot`: Imports the function to create a root React component for rendering'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createRoot`：导入创建用于渲染的根React组件的函数'
- en: '`createBrowserRouter` and `RouterProvider`: Import components and functions
    related to React Router, which provides routing functionality'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createBrowserRouter`和`RouterProvider`：导入与React Router相关的组件和函数，它提供了路由功能'
- en: 'We also need to import all the various components we created earlier. Still
    inside `index.js`, add the following component imports:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要导入我们之前创建的所有各种组件。仍然在`index.js`内部，添加以下组件导入：
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding imports are the various files and components that will be used
    in the application.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述导入是将在应用程序中使用的各种文件和组件。
- en: Please note that all future components that we might want React Router to be
    aware of can be added as part of the imported files and components of the application.
    Next, we will set up the routing configuration.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可能希望React Router了解的所有未来组件都可以作为导入的文件和应用程序的组件添加。接下来，我们将设置路由配置。
- en: Setting up the routing configuration
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置路由配置
- en: In the context of web application development and libraries such as React Router,
    routing configuration refers to the process of setting up rules or mappings that
    define how different URLs (or routes) in a web application should be handled.
    It involves specifying which components or views should be rendered for specific
    URLs, allowing users to navigate through different parts of the application seamlessly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络应用程序开发和如React Router之类的库的背景下，路由配置指的是设置规则或映射的过程，这些规则或映射定义了网络应用程序中不同的URL（或路由）应该如何被处理。这包括指定为特定URL渲染哪些组件或视图，使用户能够无缝地浏览应用程序的不同部分。
- en: With React Router, you can define a list of routes and associate each route
    with a corresponding component to be displayed when the route is matched. These
    routes can be static, dynamic (with placeholders), or nested to create a hierarchical
    structure.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React Router，您可以定义一系列路由，并将每个路由与要显示的相应组件关联起来。这些路由可以是静态的、动态的（带有占位符）或嵌套的，以创建一个层次结构。
- en: 'Let’s put this to practical use. Add the following code to the `index.js` file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些应用到实际中。将以下代码添加到 `index.js` 文件中：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code shows the created `router` object using the `createBrowserRouter`
    function, which defines the routing configuration for the application. This `router`
    object sets up different paths and their corresponding React components to be
    rendered when those paths are matched.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了使用 `createBrowserRouter` 函数创建的 `router` 对象，该函数定义了应用程序的路由配置。这个 `router`
    对象设置了不同的路径及其对应的 React 组件，当这些路径匹配时，将渲染这些组件。
- en: 'What this means is that when a user navigates to different URLs in the application,
    the corresponding components will be rendered based on the defined routes; for
    instance:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当用户在应用程序中导航到不同的 URL 时，将根据定义的路由渲染相应的组件；例如：
- en: Navigating to `/` will render the `HomePage` component
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到 `/` 将渲染 `HomePage` 组件
- en: Navigating to `/about` will render the `AboutPage` component
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到 `/about` 将渲染 `AboutPage` 组件
- en: Likewise, the rest of the components are rendered and displayed based on the
    routes and their corresponding components. The `createRoot()` function from the
    `react-dom` library, `'react-dom/client'`, is used to create a `root` component
    for intended rendering. It is a newer and more efficient alternative to `ReactDOM.render()`.
    The `createRoot()` function takes the target DOM element as an argument and returns
    a `root` component that can be used to render React elements into that target
    element.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，其余的组件也是根据路由及其对应的组件进行渲染和显示的。`react-dom` 库中的 `createRoot()` 函数，`'react-dom/client'`，用于创建一个用于渲染的
    `root` 组件。这是一个较新且更高效的替代方案，用于 `ReactDOM.render()`。`createRoot()` 函数接受一个目标 DOM 元素作为参数，并返回一个可以用于将
    React 元素渲染到该目标元素的 `root` 组件。
- en: In this case, `createRoot(document.getElementById("root"))` creates a `root`
    React component that will render its content inside the `<div>` element with the
    `"root"` ID. In essence, the `createRoot` function is used to create a `Root`
    object and render the `RouterProvider` component into the `root` DOM element.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`createRoot(document.getElementById("root"))` 创建了一个将在具有 `"root"` ID 的
    `<div>` 元素内部渲染其内容的 `root` React 组件。本质上，`createRoot` 函数用于创建 `Root` 对象并将 `RouterProvider`
    组件渲染到 `root` DOM 元素中。
- en: The `RouterProvider` component then renders the `HomePage` component, which
    is the default route for the application. `<RouterProvider router={router} />`
    uses the `RouterProvider` component from React Router. `RouterProvider` takes
    a prop called `router`, and the value of this prop is the previously defined router
    object, which contains the preceding routing configuration. This makes `router`
    available to the entire application, enabling navigation based on the defined
    routes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`RouterProvider` 组件渲染 `HomePage` 组件，这是应用程序的默认路由。`<RouterProvider router={router}
    />` 使用了 React Router 的 `RouterProvider` 组件。`RouterProvider` 接收一个名为 `router` 的属性，该属性的值是之前定义的包含先前路由配置的
    router 对象。这使得 `router` 可用于整个应用程序，并基于定义的路由进行导航。
- en: We’ll add links to routes in the next section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中添加到路由的链接。
- en: Adding links
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加链接
- en: 'Let’s improve the navigation menu by adding links to the elements. To add a
    link to an element, use `<Link to="" >elementName </Link>`. `to=""` allows us
    to insert the navigation path we intend to go to. Let’s see the details of a typical
    link definition:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向元素添加链接来改进导航菜单。要向元素添加链接，请使用 `<Link to="" >elementName </Link>`。`to=""`
    允许我们插入我们打算导航到的导航路径。让我们看看典型链接定义的细节：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Check the GitHub `src/components/Header/Header.jsx` file to learn more about
    the `Link` definition.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 GitHub `src/components/Header/Header.jsx` 文件以了解更多关于 `Link` 定义的信息。
- en: 'The following screenshot shows `HomePage` with a menu and links:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了带有菜单和链接的 `HomePage`：
- en: '![Figure 6.1 – Screenshot showing routes and links](img/Figure_6.1_B18554.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 展示路由和链接的截图](img/Figure_6.1_B18554.jpg)'
- en: Figure 6.1 – Screenshot showing routes and links
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 展示路由和链接的截图
- en: Next, let’s learn how to embed a route into another route so that we have what
    we call a nested route.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何将一个路由嵌入到另一个路由中，以便我们得到所谓的嵌套路由。
- en: Adding a nested route
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加嵌套路由
- en: '**Nested routes** in React Router provide a structured approach to organizing
    routes within your application. They facilitate grouping related routes, streamlining
    navigation between different sections. To implement nested routes, you must utilize
    the children prop on a Route component.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**React Router 中的嵌套路由** 提供了一种在应用程序中组织路由的结构化方法。它们便于对相关路由进行分组，简化不同部分之间的导航。要实现嵌套路由，必须在
    Route 组件上使用 children 属性。'
- en: This prop accepts an array of Route components as its value, defining the child
    routes that will be rendered when the parent route is matched. For instance, consider
    the following code snippet, which demonstrates the creation of a nested route
    for speakers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性接受一个路由组件数组作为其值，定义了当父路由匹配时将渲染的子路由。例如，考虑以下代码片段，它演示了为演讲者创建嵌套路由。
- en: 'Inside `src/index.js`, update the `/speakers` route, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/index.js`内部，更新`/speakers`路由，如下所示：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we have a parent route called `speakers` with the `/speakers`
    path. The child route for `SpeakerDetail` has the `/speakers/:speakerId` path.
    The `:speakerId` placeholder in the path is a dynamic parameter that will be replaced
    with the `:speakerId` value of the speaker when the user navigates to the route.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个名为`speakers`的父路由，路径为`/speakers`。`SpeakerDetail`的子路由路径为`/speakers/:speakerId`。路径中的`:speakerId`占位符是一个动态参数，当用户导航到该路由时，它将被演讲者的`:speakerId`值替换。
- en: 'The `SpeakerDetail` component will be rendered with the detailed information
    of `speakerId` in the URL. Inside `src/pages`, create `SpeakerDetail/SpeakerDetail.js`;
    then, add the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpeakerDetail`组件将使用URL中`speakerId`的详细信息进行渲染。在`src/pages`内部，创建`SpeakerDetail/SpeakerDetail.js`；然后，添加以下代码：'
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following screenshot shows the nested route with `http://localhost:3000/speakers/234`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了带有`http://localhost:3000/speakers/234`的嵌套路由：
- en: '![Figure 6.2 – Screenshot showing the nested route](img/Figure_6.2_B18554.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 展示嵌套路由的截图](img/Figure_6.2_B18554.jpg)'
- en: Figure 6.2 – Screenshot showing the nested route
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 展示嵌套路由的截图
- en: Essentially, nested routes can be used to organize your routes in a way that
    makes sense for your application. They can also be used to make it easier to navigate
    between related routes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，嵌套路由可以用来以对应用程序有意义的方式组织路由。它们还可以用来使在相关路由之间导航更容易。
- en: Next, we will explore how to handle dynamic and programmatic routes with `useParams`
    and `useNavigate`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何使用`useParams`和`useNavigate`处理动态和程序化路由。
- en: Handling dynamic routes
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理动态路由
- en: In web application development, a `speakerId`, `productId`, `postId`, and so
    on to represent the changing value.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序开发中，使用`speakerId`、`productId`、`postId`等来表示变化的值。
- en: 'For instance, let’s consider the preceding speakers route we updated with `/speakers/:speakerId`.
    It is conventional to add a colon in front of a dynamic route, like so: `:speakerId`.
    So, how can we retrieve this value of `speakerId` from the URL? This is where
    the `useParams` hook comes in.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑我们之前更新的带有`/speakers/:speakerId`的演讲者路由。在动态路由前添加冒号是一种惯例，如下所示：`:speakerId`。那么，我们如何从URL中检索这个`speakerId`的值呢？这就是`useParams`钩子的作用所在。
- en: Using useParams
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用useParams
- en: The `useParams` hook in React Router provides access to the dynamic parameters
    extracted from a route. These parameters are the values that correspond to the
    placeholders in the path of a dynamic route.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: React Router中的`useParams`钩子提供了对从路由中提取的动态参数的访问。这些参数是与动态路由路径中的占位符相对应的值。
- en: For instance, in the following code snippet, the `useParams` hook is used to
    retrieve `SpeakerId` from the `/speakers/:speakerId` route. The following code
    shows the code implementation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下代码片段中，使用了`useParams`钩子从`/speakers/:speakerId`路由中检索`SpeakerId`。以下代码展示了代码实现。
- en: 'Update the `SpeakerDetail` component in `src/pages/`, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式更新`src/pages/`中的`SpeakerDetail`组件：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code snippet, we have the `SpeakerDetail` component, which
    is used to display the details of a speaker based on the `speakerId` dynamic parameter
    that was extracted from the URL. The `useParams` hook will return an object that
    contains the dynamic parameters from the route. In this case, the `speakerId`
    property of the object will contain the Speaker ID in the URL.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们有`SpeakerDetail`组件，它用于根据从URL中提取的`speakerId`动态参数显示演讲者的详细信息。`useParams`钩子将返回一个包含路由中动态参数的对象。在这种情况下，对象中的`speakerId`属性将包含URL中的演讲者ID。
- en: 'The following screenshot shows the extracted `speakerId` from the URL:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了从URL中提取的`speakerId`：
- en: "![Figure 6.3 – Screenshot showing the extracted \uFEFFspeakerId](img/Figure_6.3_B18554.jpg)"
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 展示提取的speakerId的截图](img/Figure_6.3_B18554.jpg)'
- en: Figure 6.3 – Screenshot showing the extracted speakerId
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 展示提取的speakerId的截图
- en: The `useParams` hook is a powerful tool that can be used to access the dynamic
    parameters of any route. Next, we will briefly discuss the `useNavigate` hook
    for programmatic navigation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`useParams` 钩子是一个强大的工具，可以用来访问任何路由的动态参数。接下来，我们将简要讨论 `useNavigate` 钩子用于编程导航。'
- en: Using useNavigate
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `useNavigate`
- en: '`useNavigate` is a new hook that was introduced in React Router v6\. It provides
    a way to programmatically navigate or redirect users to different routes within
    a React application. Unlike the `useHistory` hook from previous versions of React
    Router that provided access to the history object, `useNavigate` provides a more
    straightforward and explicit way to navigate between routes.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`useNavigate` 是 React Router v6 中引入的一个新钩子。它提供了一种在 React 应用程序中通过编程方式导航或重定向用户到不同路由的方法。与之前版本中提供对历史对象访问的
    `useHistory` 钩子不同，`useNavigate` 提供了一种更直接和明确的方式来在路由之间导航。'
- en: With `useNavigate`, you can initiate navigation in response to certain events,
    such as a button click, form submission, or any other user action. Instead of
    modifying the URL directly like in React Router v5, you can now use the navigate
    function returned by `useNavigate` to achieve navigation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `useNavigate`，你可以响应某些事件（如按钮点击、表单提交或其他用户操作）来启动导航。与 React Router v5 中直接修改 URL
    不同，你现在可以使用 `useNavigate` 返回的 `navigate` 函数来实现导航。
- en: 'For instance, inside the `src/components/Header/Header.jsx` file, we have the
    following code to show how `useNavigate` is implemented:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 `src/components/Header/Header.jsx` 文件中，我们有以下代码来展示 `useNavigate` 的实现：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding snippet, the `useNavigate` hook is called to get the `navigate`
    function. When the button is clicked, the `handleLoginButtonClick` function is
    executed, which, in turn, calls `navigate('/auth/login')`. This will navigate
    the user to the `'/auth/login'` route programmatically.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，调用了 `useNavigate` 钩子以获取 `navigate` 函数。当按钮被点击时，会执行 `handleLoginButtonClick`
    函数，该函数反过来调用 `navigate('/auth/login')`。这将通过编程方式将用户导航到 `'/auth/login'` 路由。
- en: '`useNavigate` provides a more declarative and concise way to handle navigation
    compared to directly manipulating the history object. It improves the overall
    readability and maintainability of the code when working with React Router v6.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接操作历史对象相比，`useNavigate` 提供了一种更声明性和简洁的方式来处理导航。当使用 React Router v6 时，它提高了代码的可读性和可维护性。
- en: This section wraps up routing with React Router. The subsequent section shifts
    its focus to the realm of managing forms within the React library.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本节总结了 React Router 的路由功能。接下来的部分将重点转向 React 库中表单管理的领域。
- en: Using forms in React
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 React 中使用表单
- en: Conventionally, forms are used to collect user inputs. There is no serious production-grade
    web application without forms. Using forms in React is slightly different from
    using HTML form elements. If you have developed React applications for a while,
    this might not be new to you.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，表单用于收集用户输入。没有表单的严肃生产级 Web 应用程序是不存在的。在 React 中使用表单与使用 HTML 表单元素略有不同。如果你已经开发了一段时间的
    React 应用程序，这可能对你来说并不陌生。
- en: The subtle difference between the elements of React forms and those of normal
    HTML forms is due to the unique way React handles the internal state of forms.
    The HTML DOM manages the internal states of native HTML form elements in a browser
    DOM way. On the other hand, React handles form elements through its components’
    state.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: React 表单元素与普通 HTML 表单元素之间的细微差别是由于 React 处理表单内部状态的独特方式。HTML DOM 以浏览器 DOM 的方式管理原生
    HTML 表单元素的内部状态。另一方面，React 通过其组件的状态来处理表单元素。
- en: So, what is this state all about? The state we are talking about is an object
    that holds user inputs before form submission. Form elements have an internal
    state that prevents data loss before you submit user input across the processing
    channel.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个状态究竟是什么呢？我们所说的状态是一个在表单提交前持有用户输入的对象。表单元素有一个内部状态，它可以防止在将用户输入提交到处理通道之前数据丢失。
- en: Having laid down the background for the internal state management of form elements,
    let’s quickly move on to how React enhances the user experience through its component-based
    approach, enhanced with the VDOM mechanism of React. We are going to develop forms
    in React without the use of any external library; instead, we will focus on pure
    React and leverage its controlled component-based approach in managing form state.
    Right now, we are going to design a simple sign-up form component.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在为表单元素的内部状态管理奠定基础之后，让我们快速了解一下 React 如何通过其基于组件的方法以及 React 的 VDOM 机制来增强用户体验。我们将使用
    React 开发表单，而不使用任何外部库；相反，我们将专注于纯 React，并利用其基于受控组件的方法来管理表单状态。目前，我们将设计一个简单的注册表单组件。
- en: The following snippet shows a `SignUp` form component to help you understand
    how to create a simple form in React.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了一个 `SignUp` 表单组件，以帮助你了解如何在 React 中创建一个简单的表单。
- en: 'Create `SignUp` inside `src/pages/Auth/SignUp.js/` in your project directory:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目目录 `src/pages/Auth/SignUp.js/` 中创建 `SignUp`：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding snippet should look familiar – there’s nothing special here except
    for the `<label>` attribute, `htmlFor`. This is the React way of adding the `for`
    attributes to the form label. The `htmlFor` prop is used to match the corresponding
    ID with input form elements.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段应该看起来很熟悉——这里没有特别之处，除了 `<label>` 属性的 `htmlFor`。这是 React 添加 `for` 属性到表单标签的方式。`htmlFor`
    属性用于将相应的 ID 与输入表单元素匹配。
- en: 'Moving forward, let’s update the router configuration inside `index.js` and
    add the `signup` route. Inside `src/index.js`, add the sign-up path and its associated
    component:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新 `index.js` 中的路由配置，并添加 `signup` 路由。在 `src/index.js` 中，添加注册路径及其相关组件：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following figure shows the output of the signup form code snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了注册表单代码片段的输出：
- en: '![Figure 6.4 – Screenshot showing the rendered signup form](img/Figure_6.4_B18554.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 展示渲染的注册表单截图](img/Figure_6.4_B18554.jpg)'
- en: Figure 6.4 – Screenshot showing the rendered signup form
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 展示渲染的注册表单截图
- en: When you navigate to `http://localhost:3000/auth/signup`, you will see that
    the `SignUp` form component has been rendered. With this, React is just rendering
    the form elements and allowing native browser DOM to carry on as usual with the
    page reload at every form submission. If you fill in the form and click **REGISTER**,
    you will see the page reload effect.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导航到 `http://localhost:3000/auth/signup` 时，你会看到 `SignUp` 表单组件已经被渲染。有了这个，React
    只是渲染表单元素，并允许原生浏览器 DOM 在每次表单提交时继续正常工作。如果你填写表单并点击 **注册**，你会看到页面重新加载的效果。
- en: This is certainly an anti-React design pattern, which means this is not a React
    way of designing form elements. So, what is the React design expectation in building
    an intuitive user form experience? The answer to this is what we will focus on
    in the next section. There, you will learn how you can build engaging and reusable
    forms with all the ingredients of the React sauce.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一种反 React 设计模式，这意味着这不是 React 设计表单元素的方式。那么，在构建直观的用户表单体验方面，React 的设计期望是什么？这个问题的答案就是我们将在下一节中关注的重点。在那里，你将学习如何使用
    React 的所有要素构建引人入胜且可重用的表单。
- en: 'In React, there are two approaches to form components: controlled and uncontrolled
    form components. In the next section, we will dive into this and learn how to
    design form components that enhance smooth interaction with the form elements
    in a React web application project.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，有两种表单组件的方法：受控和不受控表单组件。在下一节中，我们将深入探讨这个问题，并学习如何设计在 React 网络应用程序项目中增强与表单元素交互的表单组件。
- en: Controlled and uncontrolled form components
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 受控和不受控表单组件
- en: So far in this book, we have become familiar with components and how they are
    the building blocks of any React application. When you blend pieces of independently
    designed components, you get either a UI component or a full-fledged React web
    application, depending on what you are working on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们已经熟悉了组件以及它们是如何成为任何 React 应用程序的构建块的。当你将独立设计的组件片段混合在一起时，你会得到一个 UI
    组件或一个完整的 React 网络应用程序，具体取决于你正在做什么。
- en: The component-driven approach of React is not going to change anytime soon.
    Building quality UIs for applications is what React does best. You are going to
    need a high-performant form one way or the other in your career as a developer,
    and React has you covered with two approaches to building air-tight form components
    that prevent data loss and improve user experience regarding form interaction.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: React 的组件驱动方法在不久的将来不会改变。为应用程序构建高质量的 UI 是 React 最擅长的。作为开发者，无论哪种方式，您都需要一个高性能的表单。React
    通过两种构建防漏数据并提高表单交互用户体验的表单组件的方法来满足您的需求。
- en: These two approaches are controlled and uncontrolled form components. Let’s
    start with controlled form components so that we have a sufficient understanding
    of how they are implemented and why they are the React-recommended approach to
    form handling.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法分别是受控和非受控表单组件。让我们从受控表单组件开始，以便我们充分理解它们的实现方式和为什么它们是 React 推荐的表单处理方法。
- en: Controlled form
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受控表单
- en: In terms of a controlled form, a React component maintains the internal state
    of user inputs in the form elements. What do we mean? Essentially, React has an
    in-built event wrapper known as `SyntheticEvent`, a key component of the React
    event system.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在受控表单方面，React 组件维护表单元素中用户输入的内部状态。我们的意思是什么？本质上，React 有一个内置的事件包装器，称为 `SyntheticEvent`，它是
    React 事件系统的一个关键组件。
- en: We spoke a lot about `SyntheticEvent` in [*Chapter 5*](B18554_05.xhtml#_idTextAnchor095),
    *JSX and Displaying Lists in React*, in the *Event handling in React* section.
    In the controlled form approach, the event handler function in controlled form
    components accepts an instance of `SyntheticEvent`, such as `onChange`, `onInput`,
    `onInvalid`, `onReset`, and `onSubmit`, to control the state of form data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第五章*](B18554_05.xhtml#_idTextAnchor095)，*React 中的 JSX 和列表显示*，*React 的事件处理*
    部分详细讨论了 `SyntheticEvent`。在受控表单方法中，受控表单组件的事件处理函数接受 `SyntheticEvent` 的实例，例如 `onChange`、`onInput`、`onInvalid`、`onReset`
    和 `onSubmit`，以控制表单数据的状态。
- en: 'For instance, the `onChange` event listens to the change in the state value
    of the component form: this change could be either a user typing something in
    the form input or trying to replace the value of the form input. The `onChange`
    event is triggered and the state data value is changed appropriately.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`onChange` 事件监听组件表单状态值的变化：这种变化可能是用户在表单输入中输入某些内容或尝试替换表单输入的值。`onChange` 事件被触发，并且相应地更改状态数据值。
- en: 'Let’s explore how event handlers allow us to have controlled form components.
    The following snippet demonstrates a controlled form in React with the relevant
    event handlers to manage `onChange` and `onSubmit` events. Update the `SignUp.js`
    file code to demonstrate the use of event handlers in the form component inside
    `src/pages/Auth/SignUp.js`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索事件处理程序如何使我们拥有受控表单组件。以下代码片段演示了 React 中的受控表单，以及管理 `onChange` 和 `onSubmit`
    事件的相关事件处理程序。更新 `SignUp.js` 文件代码，以在 `src/pages/Auth/SignUp.js` 中的表单组件内演示事件处理程序的使用：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Please refer to GitHub for the full source code. In the preceding snippet, we
    have updated our default form by adding some input attributes to it – that is,
    the `value` and `onChange` events, and set the stage for a controlled form. The
    form input uses `value` to accept the current value as a prop and `onChange` as
    a callback to update the state of the value.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 GitHub 以获取完整的源代码。在前面的代码片段中，我们通过向其添加一些输入属性来更新我们的默认表单——即 `value` 和 `onChange`
    事件，并为受控表单做好了准备。表单输入使用 `value` 作为当前值的属性，并使用 `onChange` 作为回调来更新值的内部状态。
- en: As you already know, user actions such as tapping the keyboard, clicking a button
    on a web page, or mousing over on an HTML element with browsers elicit events.
    But React has what we call Synthetic Events with a couple of instance methods
    and properties to listen for user interactions and emit certain events.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，用户操作，如轻触键盘、点击网页上的按钮或鼠标悬停在 HTML 元素上，都会引发事件。但 React 有我们所说的合成事件，具有一些实例方法和属性，用于监听用户交互并发出某些事件。
- en: Popular among these instances in React are `onChange` and `onClick`. We will
    use more of these. The `onChange` event is triggered whenever there is a change
    in the form’s input element. The `event.target` property of the Web API is used
    to access the value of this change.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，`onChange` 和 `onClick` 是这些实例中比较流行的。我们将使用更多这样的功能。`onChange` 事件会在表单输入元素发生变化时触发。Web
    API 的 `event.target` 属性用于访问这个变化的价值。
- en: 'Furthermore, the `onClick` event gets activated every time an HTML element
    is clicked; for example, when a button is clicked. In our snippet, event handlers
    are specified in the body of the component function: `nameHandler`, `emailHandler`,
    and `passwordHandler`. These event handlers listen to the corresponding value
    changes in the form inputs and control the operation of the form.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`onClick` 事件在每次点击 HTML 元素时都会被激活；例如，当按钮被点击时。在我们的代码片段中，事件处理程序指定在组件函数的主体中：`nameHandler`、`emailHandler`
    和 `passwordHandler`。这些事件处理程序监听表单输入中的相应值变化并控制表单的操作。
- en: 'In the case of `nameHandler`, it listens to what the users type in, accesses
    the value with the use of the `e.target` property, and updates its state with
    `setName()`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `nameHandler` 的情况下，它监听用户输入的内容，使用 `e.target` 属性访问值，并通过 `setName()` 更新其状态：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the form input with the `Name` label, the following was added:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在带有 `Name` 标签的表单输入中，添加了以下内容：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `input` elements for email and password were equally updated with appropriate
    values and `onChange` event handlers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件和密码的 `input` 元素同样更新了适当的值和 `onChange` 事件处理程序。
- en: '`onSubmitHandler()` handles the `onSubmit` event of the form element:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSubmitHandler()` 处理表单元素的 `onSubmit` 事件：'
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`e.preventDefault()` prevents the default reloading behavior of the browser.
    We also output the submitted form data with `alert()`. What are the benefits of
    the controlled form component?'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`e.preventDefault()` 阻止浏览器默认的重新加载行为。我们还使用 `alert()` 输出提交的表单数据。控制表单组件的好处是什么？'
- en: 'There are a few reasons why you would want to use controlled form components:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因会让你想要使用控制表单组件：
- en: React recommends it. It is React’s best-practice way of handling user inputs
    in React.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 推荐这样做。这是 React 处理 React 中用户输入的最佳实践方式。
- en: The components tightly control the behavior of the form, thereby ensuring a
    reactive user and developer experience.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件紧密控制表单的行为，从而确保用户和开发者有反应性的体验。
- en: We get instant feedback from forms since the event handlers listen to form elements
    and emit events appropriately.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于事件处理程序监听表单元素并适当地发出事件，我们从表单中获得即时反馈。
- en: The controlled form component improves the experience with form interaction
    in React applications and it is widely used in the React community. Next, we will
    learn what the uncontrolled form components provide for the React developer community
    and how we can use them.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 控制表单组件提升了 React 应用中表单交互的体验，并且在 React 社区中得到了广泛的应用。接下来，我们将学习未控制表单组件为 React 开发者社区提供了什么，以及我们如何使用它们。
- en: Uncontrolled form
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未控制表单
- en: In an uncontrolled form, native DOM maintains and stores the state of user input
    directly. It does this by storing the values of the form elements in the DOM with
    a reference to the form elements. This is the conventional way HTML form elements
    maintain their internal states.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在未控制表单中，原生 DOM 直接维护和存储用户输入的状态。它是通过在 DOM 中存储表单元素的值并引用表单元素来做到这一点的。这是 HTML 表单元素维护其内部状态的常规方式。
- en: React components simply interact with uncontrolled form elements by maintaining
    references to the underlying form element in the DOM. Let’s replicate our earlier
    signup form and refactor the snippet to use uncontrolled form components.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件通过维护对 DOM 中底层表单元素的引用来简单地与未控制表单元素交互。让我们复制我们之前的注册表单，并重构代码片段以使用未控制表单组件。
- en: 'This snippet uses the `useRef` hook to reference the values of the form elements
    in the DOM:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段使用 `useRef` 钩子来引用 DOM 中表单元素的值：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Please refer to GitHub for the full source code. Let’s briefly explain the preceding
    snippet.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 GitHub 以获取完整的源代码。让我们简要解释前面的代码片段。
- en: In using the uncontrolled form React component, we needed the `useRef` hook
    to access the form elements in the DOM. `import React, { useRef } from 'react';`
    brings React and the `useRef()` hook into scope.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用未控制表单 React 组件时，我们需要 `useRef` 钩子来访问 DOM 中的表单元素。`import React, { useRef }
    from 'react';` 将 React 和 `useRef()` 钩子引入作用域。
- en: 'Then, we created a reference variable to hold the reference of the form element
    in the DOM:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个引用变量来保存 DOM 中表单元素的引用：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `input` tag, we bound the reference variable to the `ref` attribute
    of the input element:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `input` 标签中，我们将引用变量绑定到输入元素的 `ref` 属性：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The same steps were taken for the email and password input elements.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于电子邮件和密码输入元素，采取了相同的步骤。
- en: 'To extract the current value of the form fields, we must use the `current.value`
    property of `useRef` in `onSubmitHandler()`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取表单字段的当前值，我们必须在 `onSubmitHandler()` 中使用 `useRef` 的 `current.value` 属性：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following figure shows the console logs of the uncontrolled form component
    in React:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了React中未受控表单组件的控制台日志：
- en: '![Figure 6.5 – Console log of the uncontrolled form component](img/Figure_6.5_B18554.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 未受控表单组件的控制台日志](img/Figure_6.5_B18554.jpg)'
- en: Figure 6.5 – Console log of the uncontrolled form component
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 未受控表单组件的控制台日志
- en: What are the benefits of the uncontrolled form component?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 未受控表单组件有哪些好处？
- en: 'Interestingly, there are few benefits to using uncontrolled form components,
    even though React recommends the controlled approach. Here are a few benefits
    for consideration in your React project:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然React推荐使用受控方法，但使用未受控表单组件的好处并不多。以下是一些在您的React项目中需要考虑的好处：
- en: In complex React form applications, where re-rendering the form UI with every
    user input could be an expensive DOM operation on the performance of the application.
    Using uncontrolled form components prevents the performance bottlenecks associated
    with component re-rendering of form elements.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在复杂的React表单应用中，每次用户输入都重新渲染表单UI可能会对应用程序的性能造成昂贵的DOM操作。使用未受控表单组件可以防止与表单元素组件重新渲染相关的性能瓶颈。
- en: The uncontrolled form is more appropriate when you need to work with a form
    input of the `file` type in your React application, such as when doing a file
    upload.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要在React应用程序中处理`file`类型的表单输入时，例如进行文件上传，未受控表单更为合适。
- en: The uncontrolled form is quick to use when you are migrating from a legacy non-React
    code base project. Since DOM maintains the state of the form, working with form
    fields from the legacy code base is easier.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您从遗留的非React代码库项目迁移时，未受控表单的使用非常快捷。由于DOM维护表单的状态，因此从遗留代码库中处理表单字段更容易。
- en: 'Now that we have sufficiently examined what an uncontrolled form in React project
    is all about and covered a few of the benefits of using an uncontrolled form,
    let’s dive into a few of the commonly used input elements: `Input`, `TextArea`,
    and `Select`.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经充分了解了React项目中未受控表单的相关内容，并介绍了一些使用未受控表单的好处，让我们深入了解一些常用的输入元素：`Input`、`TextArea`和`Select`。
- en: Handling user input – Input, TextArea, and Select
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理用户输入 – Input、TextArea和Select
- en: Handling React form elements is slightly different from the way non-React applications
    handle user inputs. In this section, we will look at common form elements that
    are used in handling user input while following React best practices.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 处理React表单元素的方式与非React应用程序处理用户输入的方式略有不同。在本节中，我们将查看在遵循React最佳实践的同时处理用户输入时使用的常见表单元素。
- en: Input
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Input
- en: '**Input** fields in the form are the most widely used tags in any web application.
    An input field allows the collection of user data. Input fields have different
    types depending on their purpose in a form. In the controlled input form element,
    the component state is always set using a value or checked attribute on the form
    input field. You also have a callback that listens to the change in value as a
    result of user input.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 表单中的**Input**字段是任何Web应用程序中最广泛使用的标签。输入字段允许收集用户数据。根据在表单中的用途，输入字段有不同的类型。在受控输入表单元素中，组件状态始终通过表单输入字段的值或checked属性来设置。您还有一个回调函数，用于监听用户输入导致的价值变化。
- en: With the input type radio and checkbox, we use the checked attributes. To access
    the value of the input field, we can use `event.target.checked`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单选按钮和复选框的输入类型，我们使用checked属性。要访问输入字段的值，我们可以使用`event.target.checked`。
- en: TextArea
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TextArea
- en: '`Textarea` is a tag that allows users to write multi-line characters of text.
    `Textarea` is usually used to collect user data such as comments or review sections
    in web applications. The `Textarea` element in React works differently. The state
    is set using a value or checked attribute in the form input field, similar to
    a single input field. `textarea` doesn’t have children, which is typical of HTML.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`Textarea`是一个允许用户写入多行文本字符的标签。`Textarea`通常用于收集用户数据，如Web应用程序中的评论或评论部分。React中的`Textarea`元素工作方式不同。状态是通过表单输入字段中的值或checked属性来设置的，类似于单个输入字段。`textarea`没有子元素，这是HTML的典型特征。'
- en: 'You can use a callback to retrieve the change in the state value of the form
    element:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用回调函数来检索表单元素状态值的更改：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Select
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Select
- en: The `select` form element is used in designing a drop-down list. React has its
    unique way of working with `select`. The selected value is set with a value attribute
    on the `select` form element. In React, there is no selected attribute.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`表单元素用于设计下拉列表。React有自己独特的处理`select`的方式。选中值通过`select`表单元素上的`value`属性设置。在React中，没有`selected`属性。'
- en: 'This selection is determined by the set value property on the `select` form
    element. You can use a callback when handling the selected value in the form element:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选择是由`select`表单元素上的`set value`属性决定的。您可以在处理表单元素中的选中值时使用回调函数：
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, we will discuss how React applications handle user data validation and
    how you can sanitize your users’ data when they’re filling in a form element.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论React应用程序如何处理用户数据验证，以及当用户在填写表单元素时，您如何对用户数据进行清理。
- en: Validating and sanitizing users’ data in React
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React中验证和清理用户数据
- en: '**Validation** is a process that ensures user data quality, integrity, and
    an appropriate format that’s expected for a system. You can never trust data provided
    by users of your application blindly. While we expect them to trust our code,
    we can’t reciprocate that trust by not guiding them on how our forms and form
    data should be treated.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**验证**是一个确保用户数据质量、完整性和系统期望的适当格式的过程。您永远不能盲目信任您应用程序用户提供的数据。虽然我们期望他们信任我们的代码，但我们不能通过不指导他们如何处理我们的表单和表单数据来回报这种信任。'
- en: Starting as a junior developer, the phrase *Don’t ever believe a user would
    always do the right thing with your form* will forever ring true. You can never
    trust user data as is. Data that comes from users has to be thoroughly scrutinized
    and cleaned and ensured it is in the desired format.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 从初级开发者开始，短语“永远不要相信用户会始终用你的表单做正确的事”将永远适用。您永远不能信任用户数据原样。来自用户的数据必须经过彻底审查和清理，并确保其处于期望的格式。
- en: Forms fields are the open window into everything you might call the backend
    in web development. So, trusting user input without some rules in place could
    be detrimental to your sanity as a developer and to the healthy condition of your
    web application.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 表单字段是通向您在Web开发中可能称之为后端的一切的开放窗口。因此，在没有规则的情况下信任用户输入可能会对您作为开发者的精神健康以及您Web应用程序的健康状况造成损害。
- en: There are always standard-practice validation rules you can adhere to as a React
    developer. These validation rules guide you and your application against bad actors
    of your application.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 作为React开发者，您始终可以遵循一些标准的验证规则。这些验证规则指导您和您的应用程序避免应用程序中的不良行为者。
- en: 'Let’s take a look at a few validation rules you might want to check off before
    user input data is deposited in your database or any of your backend infrastructure:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在用户输入数据存入您的数据库或任何后端基础设施之前，您可能想要勾选的一些验证规则：
- en: '**Data type**: You need to ascertain the user is putting in the right data
    type for a form field. Are they even filling in anything at all? You need to check.
    For example, in a form field where you are expecting string characters, ensure
    you are not getting numeric data.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据类型**：您需要确认用户是否为表单字段输入了正确的数据类型。他们甚至是否填写了任何内容？您需要检查。例如，在一个期望字符串字符的表单字段中，确保您没有接收到数值数据。'
- en: '**Consistency**: You need to ensure data consistency of user input, and one
    of the ways to be sure you get consistent data is by enforcing validation rules.
    For instance, you might add a regular expression to check that the length of the
    password is not less than 8 characters and that it is mixed with symbols.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：您需要确保用户输入的数据一致性，确保获取一致数据的一种方法是通过强制执行验证规则。例如，您可能添加一个正则表达式来检查密码长度是否不少于8个字符，并且包含符号。'
- en: Alternatively, you might just allow users to select a country they’d like to
    visit from a drop-down list of options rather than asking them to type the name
    of countries they would like to visit. If you do the latter, you will be rudely
    shocked regarding what you will get in return for your benevolence.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，您可能只是允许用户从选项下拉列表中选择他们想要访问的国家，而不是要求他们输入他们想要访问的国家名称。如果您这样做，您将对您的好意得到的回报感到粗鲁的震惊。
- en: '**Data format**: You probably want the date of birth of your application users
    to be in *YYYY-MM-DD* or *DD-MM-YYYY* format. You and I know we can’t leave this
    at the discretion of users!'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据格式**：您可能希望应用程序用户的出生日期以*YYYY-MM-DD*或*DD-MM-YYYY*格式。我和您都知道我们不能将此留给用户的任意选择！'
- en: '**Range and constraint**: You may also want to check data against a certain
    range of parameters or if some data falls within a certain constraint intended.
    So, you need to enforce this with some mechanisms – a regular expression is an
    example of such a mechanism. You should always remember that users are prone to
    making genuine errors as well, even though they don’t mean to act badly.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**范围和约束**：你也可能想要检查数据是否与某些参数范围或某些数据是否落在某些预期约束内。因此，你需要通过一些机制来强制执行这一点 - 正则表达式就是这样的机制之一。你应该始终记住，用户也容易犯真正的错误，即使他们无意于做出不良行为。'
- en: 'That being said, there are two major instances when you will want to enforce
    validation rules in React form design:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在 React 表单设计中，你会在两个主要情况下想要强制执行验证规则：
- en: '**On user input**: As users are interacting with your form elements, you are
    checking for compliance and giving instant feedback. React shines best here with
    a controlled form component that uses a callback to harvest user values and relay
    them to event handlers with the ability to check for errors. We will implement
    this in our sign-up form shortly.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在用户输入时**：当用户与表单元素交互时，你会检查其合规性并提供即时反馈。React 在这里使用受控表单组件表现最佳，该组件使用回调来收集用户值并将它们传递给具有检查错误能力的事件处理器。我们将在我们的注册表单中很快实现这一点。'
- en: '**On user submission**: Form data is subjected to validation when the user
    clicks on the submit button in this instance. This used to be the gold standard
    in the past. However, nowadays, this seems to be happening less in enterprise
    application development due to the arrays of frontend technologies that make instant
    feedback a cool breeze to implement.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在用户提交时**：在这种情况下，当用户点击提交按钮时，表单数据将受到验证。这曾经是过去的黄金标准。然而，如今，由于前端技术的阵列使得即时反馈变得容易实现，这在企业应用开发中似乎发生得越来越少。'
- en: Implementing form validation
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现表单验证
- en: Let’s examine the implementation of form data validation using the React-controlled
    form component.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查使用 React 受控表单组件实现表单数据验证的实现方式。
- en: 'We will start by importing the `useState` and `useEffect` hooks and bringing
    them into scope to manage state and side effects, respectively:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先导入 `useState` 和 `useEffect` 钩子，并将它们引入作用域以分别管理状态和副作用：
- en: '[PRE27]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we must set the state variables as `initialValues`, `formValues`, `formErrors`,
    and `isSubmit`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须设置状态变量为 `initialValues`、`formValues`、`formErrors` 和 `isSubmit`：
- en: '[PRE28]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`initialValues` is declared as an object to hold the initial form input state,
    which is set to empty strings. `useState` takes the `initialValues` variable values
    as the initial state and assigns it to `formValues` so that from the onset, all
    the form input values are empty strings. The initial state of `formErrors` is
    set to an empty object as well and the initial state of `isSubmit` is set to `false`.
    This means no form has been submitted yet.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`initialValues` 被声明为一个对象，用于保存初始表单输入状态，设置为空字符串。`useState` 将 `initialValues`
    变量的值作为初始状态，并将其分配给 `formValues`，这样从开始，所有表单输入值都是空字符串。`formErrors` 的初始状态设置为空对象，`isSubmit`
    的初始状态设置为 `false`。这意味着还没有提交任何表单。'
- en: 'We need an `onChange` function to track changes to form input values. We must
    set `onChangeHandler()`, which takes `e` as a parameter of the event object and
    destructures the `e.target` object, which returns two properties – `name` and
    `value`. The `setFormValues` function accepts all the current `formValues` with
    the `...formValues` spread operator and updates them to the new values:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个 `onChange` 函数来跟踪表单输入值的变化。我们必须设置 `onChangeHandler()`，它接受事件对象的参数 `e` 并解构
    `e.target` 对象，该对象返回两个属性 - `name` 和 `value`。`setFormValues` 函数接受所有当前的 `formValues`，使用
    `...formValues` 扩展运算符，并将它们更新为新值：
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`useEffect()` is used to log successfully submitted values if there are no
    form errors:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect()` 用于在表单没有错误时记录成功提交的值：'
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Next, the rules for form data validation are set with the `validateForm` function.
    This is a simple validation rule that checks whether the `name`, `email`, and
    `password` form inputs are filled in. It also checks whether the right format
    is being used for email using `regex.test()`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `validateForm` 函数设置表单数据验证规则。这是一个简单的验证规则，检查 `name`、`email` 和 `password`
    表单输入是否已填写。它还检查是否使用了正确的格式来处理电子邮件，使用 `regex.test()`。
- en: 'For the password, we must check whether the password is more than 8 characters
    but does not exceed more than 12 characters:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于密码，我们必须检查密码是否超过 8 个字符但不超过 12 个字符：
- en: '[PRE31]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, `onSubmitHandler()` is invoked, which ensures the `setFormErrors()` function
    is run, which takes `validateForm()` as a parameter. If there are no errors in
    the form, `setIsSubmit` is set to `true`, allowing the form to be submitted:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，调用`onSubmitHandler()`，这确保了`setFormErrors()`函数被运行，该函数以`validateForm()`作为参数。如果没有表单错误，`setIsSubmit`被设置为`true`，允许表单提交：
- en: '[PRE32]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here’s the JSX that’s returned from the form component with `onSubmitHandler`
    and each of the errors displayed by the `formErrors` object:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是表单组件返回的JSX，其中包含`onSubmitHandler`以及`formErrors`对象显示的每个错误：
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following figure shows the output for form entries when form fields are
    filled before being submitted:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了在提交前填写表单字段时的表单条目输出：
- en: '![Figure 6.6 – Screenshot of a form with validation rules](img/Figure_6.6_B18554.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – 包含验证规则的表单截图](img/Figure_6.6_B18554.jpg)'
- en: Figure 6.6 – Screenshot of a form with validation rules
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 包含验证规则的表单截图
- en: We added the `formErrors` property to every form element to output an error
    message if an error exists. For instance, `{formErrors.name}` displays an error
    for `name` if a name is not filled in the form.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个表单元素添加了`formErrors`属性，以便在存在错误时输出错误信息。例如，`{formErrors.name}`会在表单中没有填写名称时显示错误。
- en: 'The full code for this validation rule can be found in this book’s GitHub repository:
    https://github.com/PacktPublishing/Full-Stack-Flask-Web-Development-with-React/blob/main/Chapter-06/.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 该验证规则的完整代码可以在本书的GitHub仓库中找到：https://github.com/PacktPublishing/Full-Stack-Flask-Web-Development-with-React/blob/main/Chapter-06/
- en: This wraps up how you can add validation to your React application without the
    use of an external library, thus minimizing the number of potential dependencies
    your application might rely on.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这总结了如何在React应用程序中添加验证而不使用外部库，从而最小化应用程序可能依赖的潜在依赖项数量。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we discussed two vital concepts in React: forms and routing.
    We highlighted the subtle difference in the forms that are set up in non-React
    and React applications. React provides tons of improvement in how it handles form
    elements through the use of controlled and uncontrolled form components to enhance
    the user experience.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了React中的两个重要概念：表单和路由。我们强调了在非React和React应用程序中设置的表单之间的细微差别。React通过使用受控和非受控表单组件来处理表单元素，从而在用户体验方面提供了大量的改进。
- en: Then, we delved into validation concepts and how you can implement validation
    rules in React. We then spoke about React Router. We demonstrated how React Router,
    a third-party library, enables us to navigate complex React applications. We discussed
    the use of `Route`, `Links`, and nested `Routes` and explored how they are used
    in a React project.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们深入探讨了验证概念以及如何在React中实现验证规则。然后，我们讨论了React Router。我们展示了第三方库React Router如何使我们能够导航复杂的React应用程序。我们讨论了`Route`、`Links`和嵌套`Routes`的使用，并探讨了它们在React项目中的应用。
- en: In the next chapter, we will learn about and understand how to implement testing
    in React applications. Testing is an essential part of software development as
    it ensures the components of an application work as they should and that the relevant
    best practices are observed in development.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习并理解如何在React应用程序中实现测试。测试是软件开发的一个基本部分，因为它确保应用程序的组件按预期工作，并且在开发中遵循了相关的最佳实践。
