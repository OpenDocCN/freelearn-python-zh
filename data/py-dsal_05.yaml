- en: Stacks and Queues
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈和队列
- en: In this chapter, we are going to build upon the skills we learned in the last
    chapter in order to create special list implementations. We are still sticking
    to linear structures. We will get to more complex data structures in the coming
    chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将基于上一章学到的技能来创建特殊的列表实现。我们仍然坚持线性结构。我们将在接下来的章节中学习更复杂的数据结构。
- en: 'In this chapter, we are going to look at the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下内容：
- en: Implementing stacks and queues
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现栈和队列
- en: Some applications of stacks and queues
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈和队列的一些应用
- en: Stacks
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈
- en: 'A stack is a data structure that is often likened to a stack of plates. If
    you have just washed a plate, you put it on top of the stack. When you need a
    plate, you take it off the top of the stack. So the last plate to be added to
    the stack will be the first to be removed from the stack. Thus, a stack is a **last
    in, first out** (**LIFO**) structure:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种常被比作盘子堆的数据结构。如果你刚刚洗完一个盘子，你就把它放在栈顶。当你需要盘子时，你就从栈顶取下来。所以最后被添加到栈中的盘子将是第一个被取出的。因此，栈是一种**后进先出**（**LIFO**）的结构：
- en: '![](img/image_05_001.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_001.jpg)'
- en: The preceding figure depicts a stack of plates. Adding a plate to the pile is
    only possible by leaving that plate on top of the pile. To remove a plate from
    the pile of plates means to remove the plate that is on top of the pile.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图展示了盘子堆。向盘子堆中添加盘子只能通过将盘子留在堆顶来实现。从盘子堆中移除盘子意味着移除堆顶的盘子。
- en: 'There are two primary operations that are done on stacks: `push` and `pop`.
    When an element is added to the top of the stack, it is pushed onto the stack.
    When an element is taken off the top of the stack, it is popped off the stack.
    Another operation which is used sometimes is `peek`, which makes it possible to
    see the element on the stack without popping it off.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 栈上执行的两个主要操作是`push`和`pop`。当一个元素被添加到栈顶时，它被推入栈中。当一个元素从栈顶取出时，它被从栈中弹出。有时还会使用另一个操作`peek`，这使得可以在不弹出元素的情况下查看栈上的元素。
- en: 'Stacks are used for a number of things. One very common usage for stacks is
    to keep track of the return address during function calls. Let''s imagine that
    we have the following little program:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 栈被用于许多事情。栈的一个非常常见的用途是在函数调用期间跟踪返回地址。让我们想象一下，我们有一个以下的小程序：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When the program execution gets to the call to `a()`, it first pushes the address
    of the following instruction onto the stack, then jumps to `a`. Inside `a`, `b()`
    is called, but before that, the return address is pushed onto the stack. Once
    in `b()` and the function is done, the return address is popped off the stack,
    which takes us back to `a()`. When `a` has completed, the return address is popped
    off the stack, which takes us back to the `print` statement.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序执行到达对`a()`的调用时，它首先将后续指令的地址推入栈中，然后跳转到`a`。在`a`内部调用`b()`之前，返回地址被推入栈中。一旦进入`b()`并且函数执行完毕，返回地址从栈中弹出，这使我们回到`a()`。当`a`完成时，返回地址从栈中弹出，这使我们回到`print`语句。
- en: 'Stacks are actually also used to pass data between functions. Say you have
    the following function call somewhere in your code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 栈实际上也被用来在函数之间传递数据。比如说，你的代码中某处有一个以下函数调用：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What is going to happen is that `14, ''eggs'', ''ham''` and `''spam''` will
    be pushed onto the stack, one at a time:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将要发生的事情是`14, 'eggs', 'ham'`和`'spam'`将逐个推入栈中：
- en: '![](img/image_05_002.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_002.jpg)'
- en: 'When the code jumps into the function, the values for `a, b, c, d` will be
    popped off the stack. The `spam` element will be popped off first and assigned
    to `d`, then `"ham"` will be assigned to `c`, and so on:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码跳入函数时，`a, b, c, d`的值将从栈中弹出。`spam`元素将首先弹出并赋值给`d`，然后`"ham"`将赋值给`c`，依此类推：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Stack implementation
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈实现
- en: 'Now let us study an implementation of a stack in Python. We start off by creating
    a `node` class, just as we did in the previous chapter with lists:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来研究一下Python中栈的实现。我们首先创建一个`node`类，就像我们在上一章中使用列表时做的那样：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This should be familiar to you by now: a node holds data and a reference to
    the next item in a list. We are going to implement a stack instead of a list,
    but the same principle of nodes linked together still applies.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这应该对你来说很熟悉了：一个节点持有数据并指向列表中的下一个项目。我们将实现一个栈而不是列表，但节点链接在一起的原则仍然适用。
- en: 'Now let us look at the `stack` class. It starts off similar to a singly linked
    list. We need to know the node at the top of the stack. We would also like to
    keep track of the number of nodes in the stack. So we will add these fields to
    our class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 `stack` 类。它开始时类似于一个单链表。我们需要知道栈顶的节点。我们还想跟踪栈中的节点数量。因此，我们将把这些字段添加到我们的类中：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Push operation
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推送操作
- en: 'The `push` operation is used to add an element to the top of the stack. Here
    is an implementation:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`push` 操作用于将元素添加到栈顶。以下是一个实现示例：'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the following figure, there is no existing node after creating our new node.
    Thus `self.top` will point to this new node. The else part of the `if` statement
    guarantees that this happens:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，创建我们的新节点后没有现有的节点。因此 `self.top` 将指向这个新节点。`if` 语句的 else 部分保证了这一点：
- en: '![](img/image_05_003.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_003.jpg)'
- en: 'In a scenario where we have an existing stack, we move `self.top` so that it
    points to the newly created node. The newly created node must have its **next**
    pointer, pointing to the node that used to be the top node on the stack:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有一个现有的栈的场景中，我们将 `self.top` 移动，使其指向新创建的节点。新创建的节点必须有其 **next** 指针，指向原来栈顶的节点：
- en: '![](img/image_05_004.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_004.jpg)'
- en: Pop operation
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹出操作
- en: 'Now we need a `pop` method to remove the top element from the stack. As we
    do so, we need to return the topmost element as well. We will make the stack return
    `None` if there are no more elements:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个 `pop` 方法来从栈中移除顶部元素。当我们这样做时，我们需要返回顶部元素。如果没有更多元素，我们将使栈返回 `None`：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The thing to pay attention to here is the inner `if` statement. If the top
    node has its **next** attribute pointing to another node, then we must set the
    top of the stack to now point to that node:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的地方是内部的 `if` 语句。如果顶部节点有它的 **next** 属性指向另一个节点，那么我们必须将栈顶设置为现在指向那个节点：
- en: '![](img/image_05_005.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_005.jpg)'
- en: 'When there is only one node in the stack, the `pop` operation will proceed
    as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当栈中只有一个节点时，`pop` 操作将按以下方式进行：
- en: '![](img/image_05_006.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_006.jpg)'
- en: 'Removing such a node results in `self.top` pointing to `None`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 移除这样的节点会导致 `self.top` 指向 `None`：
- en: '![](img/image_05_007.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_007.jpg)'
- en: Peek
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看操作
- en: 'As we said earlier, we could also add a `peek` method. This will just return
    the top of the stack without removing it from the stack, allowing us to look at
    the top element without changing the stack itself. This operation is very straightforward.
    If there is a top element, return its data, otherwise return `None` (so that the
    behavior of `peek` matches that of `pop`):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所说，我们也可以添加一个 `peek` 方法。这个方法将只返回栈顶元素而不从栈中移除它，允许我们查看顶部元素而不改变栈本身。这个操作非常直接。如果有顶部元素，返回其数据，否则返回
    `None`（这样 `peek` 的行为就与 `pop` 相匹配）：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Bracket-matching application
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 括号匹配应用
- en: 'Now let us look at an example of how we can use our stack implementation. We
    are going to write a little function that will verify whether a statement containing
    brackets--(, [, or {--is balanced, that is, whether the number of closing brackets
    matches the number of opening brackets. It will also ensure that one pair of brackets
    really is contained in another:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们如何使用我们的栈实现。我们将编写一个小的函数来验证包含括号（`-`，`[` 或 `{`）的语句是否平衡，即闭括号的数量是否与开括号的数量匹配。它还将确保一对括号确实包含在另一个括号中：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our function parses each character in the statement passed to it. If it gets
    an open bracket, it pushes it onto the stack. If it gets a closing bracket, it
    pops the top element off the stack and compares the two brackets to make sure
    their types match: ( should match ), [ should match ], and { should match }. If
    they don''t, we return `False`, otherwise we continue parsing.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能解析传递给它的语句中的每个字符。如果它得到一个开括号，它将其推入栈中。如果它得到一个闭括号，它将栈顶元素弹出并与两个括号进行比较，以确保它们的类型匹配：`(`
    应该匹配 `)`，`[` 应该匹配 `]`，`{` 应该匹配 `}`。如果不匹配，我们返回 `False`，否则我们继续解析。
- en: Once we have got to the end of the statement, we need to do one last check.
    If the stack is empty, then we are fine and we can return `True`. But if the stack
    is not empty, then we have some opening bracket which does not have a matching
    closing bracket and we shall return `False`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们到达语句的末尾，我们需要进行最后的检查。如果栈为空，那么我们就好了，我们可以返回 `True`。但如果栈不为空，那么我们有一些没有匹配闭括号的开括号，我们应该返回
    `False`。
- en: 'We can test the bracket-matcher with the following little code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下简短的代码测试括号匹配器：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Only the first of the three statements should match. And when we run the code,
    we get the following output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 只有三个语句中的第一个应该匹配。当我们运行代码时，我们得到以下输出：
- en: '![](img/image_05_008.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_008.png)'
- en: '`True`, `False`, `False`. The code works. In summary, the `push` and `pop`
    operations of the stack data structure attract a **O**(*1*). The stack data structure
    is simply enough but is used to implement a whole range of functionality in the
    real world. The back and forward buttons on the browser are made possible by stacks.
    To be able to have undo and redo functionality in word processors, stacks are
    also used.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`True`，`False`，`False`。代码是有效的。总之，栈数据结构的`push`和`pop`操作吸引了一个**O**(*1*)。栈数据结构足够简单，但在现实世界中用于实现一系列功能。浏览器的后退和前进按钮就是通过栈实现的。为了在文字处理器中实现撤销和重做功能，栈也被使用。'
- en: Queues
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: Another special type of list is the queue data structure. This data structure
    is no different from the regular queue you are accustomed to in real life. If
    you have stood in line at an airport or to be served your favorite burger at your
    neighborhood shop, then you should know how things work in a queue.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种特殊的列表类型是队列数据结构。这种数据结构与你在现实生活中习惯的普通队列没有区别。如果你曾在机场排队或在你家附近的商店排队等待点你最喜欢的汉堡，那么你应该知道队列是如何工作的。
- en: Queues are also a very fundamental and important concept to grasp since many
    other data structures are built on them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 队列也是一个非常基础且重要的概念，需要掌握，因为许多其他数据结构都是基于它构建的。
- en: 'The way a queue works is that the first person to join the queue usually gets
    served first, all things being equal. The acronym FIFO best explains this. **FIFO**
    stands for **first in, first out**. When people are standing in a queue waiting
    for their turn to be served, service is only rendered at the front of the queue.
    The only time people exit the queue is when they have been served, which only
    occurs at the very front of the queue. By strict definition, it is illegal for
    people to join the queue at the front where people are being served:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 队列的工作方式是，通常第一个加入队列的人会先被服务，在所有条件相同的情况下。缩写FIFO最能解释这一点。**FIFO**代表**先进先出**。当人们排队等待轮到他们被服务时，服务只在前端进行。人们退出队列的唯一时间是当他们被服务，这只会发生在队列的最前端。根据严格的定义，人们加入正在被服务的前端队列是非法的：
- en: '![](img/image_05_009.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_009.jpg)'
- en: To join the queue, participants must first move behind the last person in the
    queue. The length of the queue does not matter. This is the only legal or permitted
    way by which the queue accepts new entrants.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入队列，参与者必须首先移动到队列中最后一个人的后面。队列的长度无关紧要。这是队列接受新成员的唯一合法或允许的方式。
- en: As human as we are, the queues that we form do not conform to strict rules.
    It may have people who are already in the queue deciding to fall out or even have
    others substituting for them. It is not our intent to model all the dynamics that
    happen in a real queue. Abstracting what a queue is and how it behaves enables
    us to solve a plethora of challenges, especially in computing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们人类如此，我们形成的队列并不遵循严格的规则。可能会有已经在队列中的人决定退出，甚至有其他人代替他们。我们并不打算模拟现实中队列发生的所有动态。抽象队列是什么以及它是如何工作的，使我们能够解决许多挑战，尤其是在计算领域。
- en: We shall provide various implementations of a queue but all will revolve around
    the same idea of FIFO. We shall call the operation to add an element to the queue
    enqueue. To remove an element from the queue, we will create a `dequeue` operation.
    Anytime an element is enqueued, the length or size of the queue increases by one.
    Conversely, dequeuing items reduce the number of elements in the queue by one.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供队列的各种实现，但所有实现都将围绕FIFO（先进先出）这一相同理念。我们将把向队列中添加元素的运算称为入队。要从队列中移除元素，我们将创建一个`出队`操作。每次元素入队时，队列的长度或大小增加一。相反，出队项目将队列中的元素数量减少一。
- en: 'To demonstrate the two operations, the following table shows the effect of
    adding and removing elements from a queue:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示两种操作，以下表格显示了向队列中添加和移除元素的效果：
- en: '| **Queue operation** | **Size** | **Contents** | **Operation results** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **队列操作** | **大小** | **内容** | **操作结果** |'
- en: '| `Queue()` | 0 | `[]` | Queue object created |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `Queue()` | 0 | `[]` | 创建队列对象 |'
- en: '| `Enqueue` "Mark" | 1 | `[''mark'']` | Mark added to queue |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `入队` "Mark" | 1 | `[''mark'']` | 将Mark添加到队列中 |'
- en: '| `Enqueue` "John" | 2 | `[''mark'',''john'']` | John added to queue |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `入队` "John" | 2 | `[''mark'',''john'']` | 将John添加到队列中 |'
- en: '| `Size()` | 2 | `[''mark'',''john'']` | Number of items in queue returned
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `Size()` | 2 | `[''mark'',''john'']` | 返回队列中的项目数量 |'
- en: '| `Dequeue()` | 1 | `[''mark'']` | John is dequeued and returned |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `Dequeue()` | 1 | `[''mark'']` | John 被出队并返回 |'
- en: '| `Dequeue()` | 0 | `[]` | Mark is dequeued and returned |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `Dequeue()` | 0 | `[]` | Mark 被出队并返回 |'
- en: List-based queue
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于列表的队列
- en: 'To put into code everything discussed about queues to this point, let''s go
    ahead and implement a very simple queue using Python''s `list` class. This is
    to help us develop quickly and learn about queues. The operations that must be
    performed on the queue are encapsulated in the `ListQueue` class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将关于队列的所有讨论转化为代码，让我们继续使用 Python 的 `list` 类来实现一个非常简单的队列。这是为了帮助我们快速开发并了解队列。必须在队列上执行的操作封装在
    `ListQueue` 类中：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the initialization method `__init__`, the `items` instance variable is set
    to `[]`, which means the queue is empty when created. The size of the queue is
    also set to `zero`. The more interesting methods are the `enqueue` and `dequeue`
    methods.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化方法 `__init__` 中，`items` 实例变量被设置为 `[]`，这意味着队列在创建时是空的。队列的大小也被设置为 `zero`。更有趣的方法是
    `enqueue` 和 `dequeue` 方法。
- en: Enqueue operation
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Enqueue 操作
- en: 'The `enqueue` operation or method uses the `insert` method of the `list` class
    to insert items (or data) at the front of the list:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`enqueue` 操作或方法使用 `list` 类的 `insert` 方法在列表的前端插入项目（或数据）：'
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Do note how we implement insertions to the end of the queue. Index 0 is the
    first position in any list or array. However, in our implementation of a queue
    using a Python list, the array index 0 is the only place where new data elements
    are inserted into the queue. The `insert` operation will shift existing data elements
    in the list by one position up and then insert the new data in the space created
    at index 0\. The following figure visualizes this process:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们是如何实现向队列末尾插入元素的。索引 0 是任何列表或数组中的第一个位置。然而，在我们的使用 Python 列表实现的队列中，数组索引 0 是唯一可以插入新数据元素到队列中的地方。`insert`
    操作会将列表中的现有数据元素向上移动一个位置，然后在索引 0 处创建的空间中插入新数据。以下图示展示了这一过程：
- en: '![](img/image_05_010.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_010.jpg)'
- en: 'To make our queue reflect the addition of the new element, the size is increased
    by one:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的队列反映新元素的添加，大小增加了一个：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We could have used Python's `shift` method on the list as another way of implementing
    the "insert at 0". At the end of the day, an implementation is the overall objective
    of the exercise.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用 Python 列表的 `shift` 方法作为实现“在 0 处插入”的另一种方式。最终，实现是这项练习的整体目标。
- en: Dequeue operation
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dequeue 操作
- en: 'The `dequeue` operation is used to remove items from the queue. With reference
    to the introduction to the topic of queues, this operation captures the point
    where we serve the customer who joined the queue first and also waited the longest:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`dequeue` 操作用于从队列中移除项目。参考队列主题的介绍，这个操作捕捉了我们服务第一个加入队列并等待时间最长的客户这一点：'
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The Python `list` class has a method called `pop()`. The `pop` method does
    the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `list` 类有一个名为 `pop()` 的方法。`pop` 方法执行以下操作：
- en: Removes the last item from the list.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中移除最后一个项目。
- en: Returns the removed item from the list back to the user or code that called
    it.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将从列表中移除的项目返回给调用它的用户或代码。
- en: The last item in the list is popped and saved in the `data` variable. In the
    last line of the method, the data is returned.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的最后一个项目被弹出并保存在 `data` 变量中。在方法的最后一行，数据被返回。
- en: 'Consider the tunnel in the following figure as our queue. To perform a `dequeue`
    operation, the node with data `1` is removed from the front of the queue:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图中的隧道作为我们的队列。为了执行 `dequeue` 操作，数据为 `1` 的节点从队列的前端被移除：
- en: '![](img/image_05_011.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_011.jpg)'
- en: 'The resulting elements in the queue are as shown as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 队列中的结果元素如下所示：
- en: '![](img/image_05_012.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_012.jpg)'
- en: What can we say about the `enqueue` operation? It is highly inefficient in more
    than one way. The method has to first shift all the elements by one space. Imagine
    when there are 1 million elements in a list which need to be shifted around anytime
    a new element is being added to the queue. This will generally make the enqueue
    process very slow for large lists.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `enqueue` 操作有什么可以说的？它在多个方面都效率低下。该方法必须首先将所有元素移动一个空间。想象一下，当列表中有 100 万个元素需要移动时，每次向队列中添加新元素时都需要进行移动。这通常会使大型列表的入队过程变得非常缓慢。
- en: Stack-based queue
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于栈的队列
- en: 'Yet another implementation of a queue is to use two stacks. Once more, the
    Python `list` class will be used to simulate a stack:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 队列的另一种实现是使用两个栈。再次使用 Python 的 `list` 类来模拟栈：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding `queue` class sets the two instance variables to empty lists upon
    initialization. These are the stacks that will help us implement a queue. The
    stacks in this case are simply Python lists that allow us to call `push` and `pop`
    methods on them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`queue`类在初始化时将两个实例变量设置为空列表。这些是帮助我们实现队列的栈。在这种情况下，栈只是允许我们调用`push`和`pop`方法的Python列表。
- en: The `inbound_stack` is only used to store elements that are added to the queue.
    No other operation can be performed on this stack.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`inbound_stack`仅用于存储添加到队列的元素。对此栈不能执行其他操作。'
- en: Enqueue operation
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入队操作
- en: 'The `enqueue` method is what adds elements to the queue:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`enqueue`方法是将元素添加到队列的方法：'
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The method is a simple one that only receives the `data` the client wants to
    append to the queue. This data is then passed to the `append` method of the `inbound_stack`
    in the `queue` class. Furthermore, the `append` method is used to mimic the `push`
    operation, which pushes elements to the top of the stack.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法是简单的，它只接收客户端想要添加到队列中的`data`。然后，这些数据被传递到`queue`类中`inbound_stack`的`append`方法。此外，`append`方法用于模拟`push`操作，该操作将元素推送到栈顶。
- en: 'To `enqueue` data onto the `inbound_stack`, the following code does justice:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据`enqueue`到`inbound_stack`，以下代码是合适的：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A command-line output of the `inbound_stack` inside the queue is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 队列内部`inbound_stack`的命令行输出如下：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Dequeue operation
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 出队操作
- en: 'The `dequeue` operation is a little more involved than its `enqueue` counterpart
    operation. New elements added to our queue end up in the `inbound_stack`. Instead
    of removing elements from the `inbound_stack`, we shift our attention to the `outbound_stack`.
    As we said, elements can be deleted from our queue only through the `outbound_stack`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`dequeue`操作比其`enqueue`对应操作更复杂。添加到我们队列的新元素最终会进入`inbound_stack`。我们不是从`inbound_stack`中删除元素，而是将注意力转向`outbound_stack`。正如我们所说，只能通过`outbound_stack`来删除队列中的元素：'
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `if` statement first checks whether the `outbound_stack` is empty or not.
    If it is not empty, we proceed to remove the element at the front of the queue
    by doing the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句首先检查`outbound_stack`是否为空。如果不为空，我们继续执行以下操作来移除队列前端的元素：'
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If the `outbound_stack` is empty instead, all the elements in the `inbound­_stack`
    are moved to the `outbound_stack` before the front element in the queue is popped
    out:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`outbound_stack`为空，则在从队列前端弹出元素之前，将`inbound_stack`中的所有元素移动到`outbound_stack`：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `while` loop will continue to be executed as long as there are elements
    in the `inbound_stack`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 只要`inbound_stack`中有元素，`while`循环就会继续执行。
- en: The statement `self.inbound_stack.pop()` will remove the latest element that
    was added to the `inbound_stack` and immediately pass the popped data to the `self.outbound_stack.append()`
    method call.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 语句`self.inbound_stack.pop()`将移除最近添加到`inbound_stack`的最新元素，并将其立即传递给`self.outbound_stack.append()`方法调用。
- en: 'Initially, our `inbound_stack` was filled with the elements **5**, **6** and
    **7**:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们的`inbound_stack`被填充了元素**5**、**6**和**7**：
- en: '![](img/image_05_013.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_013.jpg)'
- en: 'After executing the body of the `while` loop, the `outbound_stack` looks like
    this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`while`循环体之后，`outbound_stack`看起来如下：
- en: '![](img/image_05_014.jpg)![](img/image_05_015.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_014.jpg)![图片](img/image_05_015.png)'
- en: 'The last line in the `dequeue` method will return `5` as the result of the
    `pop` operation on the `outbound_stack`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`dequeue`方法中的最后一行将返回`5`作为对`outbound_stack`执行`pop`操作的结果：'
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This leaves the `outbound_stack` with only two elements:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得`outbound_stack`只剩下两个元素：
- en: '![](img/image_05_016.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_016.jpg)'
- en: The next time the `dequeue` operation is called, the `while` loop will not be
    executed because there are no elements in the `outbound_stack`, which makes the
    outer `if` statement fail.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下一次调用`dequeue`操作时，`while`循环将不会执行，因为`outbound_stack`中没有元素，这使得外部的`if`语句失败。
- en: The `pop` operation is called right away in that case so that only the element
    in the queue that has waited the longest is returned.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，立即调用`pop`操作，以便只返回等待时间最长的队列中的元素。
- en: 'A typical run of code to use this queue implementation is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此队列实现的典型代码运行如下：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The code sample adds elements to a queue and prints out the elements within
    the queue. The `dequeue` method is called, after which a change in the number
    of elements is observed when the queue is printed out again.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例向队列中添加元素并打印队列中的元素。调用 `dequeue` 方法后，再次打印队列时观察到元素数量的变化。
- en: Implementing a queue with two stacks is a popular question posed during interviews.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在面试中，使用两个栈实现队列是一个常见的问题。
- en: Node-based queue
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于节点的队列
- en: Using a Python list to implement a queue is a good starter to get the feel of
    how queues work. It is completely possible for us to implement our own queue data
    structure by utilizing our knowledge of pointer structures.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 列表实现队列是一个很好的入门方式，以了解队列的工作原理。我们完全可以通过利用我们对指针结构的了解来实现自己的队列数据结构。
- en: A queue can be implemented using a doubly linked list, and `insertion` and `deletion`
    operations on this data structure have a time complexity of **O**(*1*).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用双向链表实现队列，并且在此数据结构上的 `插入` 和 `删除` 操作的时间复杂度为 **O**(*1*)。
- en: The definition for the `node` class remains the same as the `Node` we defined
    when we touched on doubly linked list, The doubly linked list can be treated as
    a queue if it enables a FIFO kind of data access, where the first element added
    to the list is the first to be removed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`node` 类的定义与我们在讨论双向链表时定义的 `Node` 相同。如果双向链表允许进行 FIFO 类型的数据访问，即首先添加到列表的元素是第一个被移除的，则可以将双向链表视为队列。'
- en: Queue class
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列类
- en: 'The `queue` class is very similar to that of the doubly linked `list` class:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue` 类与双向链表的 `list` 类非常相似：'
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`self.head` and `self.tail` pointers are set to `None` upon creation of an
    instance of the `queue` class. To keep a count of the number of nodes in `Queue`,
    the `count` instance variable is maintained here too and set to `0`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `queue` 类的实例时，将 `self.head` 和 `self.tail` 指针设置为 `None`。为了保持 `Queue` 中节点数量的计数，这里也维护了一个
    `count` 实例变量，并将其设置为 `0`。
- en: Enqueue operation
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入队操作
- en: 'Elements are added to a `Queue` object via the `enqueue` method. The elements
    in this case are the nodes:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `enqueue` 方法将元素添加到 `Queue` 对象中。在这种情况下，元素是节点：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `enqueue` method code is the same code already explained in the `append`
    operation of the doubly linked list. It creates a node from the data passed to
    it and appends it to the tail of the queue, or points both `self.head` and `self.tail`
    to the newly created node if the queue is empty. The total count of elements in
    the queue is increased by the line `self.count += 1.`
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`enqueue` 方法的代码与我们在双向链表的 `append` 操作中解释的代码相同。它从传递给它的数据创建一个节点并将其追加到队列的尾部，或者如果队列是空的，则将
    `self.head` 和 `self.tail` 都指向新创建的节点。通过 `self.count += 1` 这一行，队列中的元素总数增加。'
- en: Dequeue operation
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 出队操作
- en: The other operation that makes our doubly linked list behave as a queue is the
    `dequeue` method. This method is what removes the node at the front of the queue.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的双向链表表现得像队列的另一个操作是 `dequeue` 方法。此方法就是移除队列前端的节点。
- en: 'To remove the first element pointed to by `self.head`, an `if` statement is
    used:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除由 `self.head` 指向的第一个元素，使用一个 `if` 语句：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`current` is initialized by pointing it to `self.head`. If `self.count` is
    1, then it means only one node is in the list and invariably the queue. Thus,
    to remove the associated node (pointed to by `self.head`), the `self.head` and
    `self.tail` variables are set to `None`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`current` 通过将其指向 `self.head` 来初始化。如果 `self.count` 是 1，那么这意味着列表和队列中只有一个节点。因此，为了移除相关的节点（由
    `self.head` 指向），将 `self.head` 和 `self.tail` 变量设置为 `None`。'
- en: If, on the other hand, the queue has many nodes, then the head pointer is shifted
    to point to `self.head`'s next node.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果队列中有许多节点，则头指针会移动以指向 `self.head` 的下一个节点。
- en: After the `if` statement is run, the method returns the node that was pointed
    to by `head`. `self.count` is decremented by one in either way the `if` statement
    execution path flows.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 `if` 语句后，方法返回由 `head` 指向的节点。无论 `if` 语句执行路径如何，`self.count` 都会递减一个。
- en: Equipped with these methods, we have successfully implemented a queue, borrowing
    heavily from the idea of a doubly linked list.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 配备了这些方法，我们已经成功地实现了一个队列，大量借鉴了双向链表的想法。
- en: Remember also that the only things transforming our doubly linked list into
    a queue are the two methods, namely `enqueue` and `dequeue`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，将我们的双向链表转变为队列的只有两个方法，即 `enqueue` 和 `dequeue`。
- en: Application of queues
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列的应用
- en: Queues are used to implement a variety of functionalities in computer land.
    For instance, instead of providing each computer on a network with its own printer,
    a network of computers can be made to share one printer by queuing what each printer
    wants to print. When the printer is ready to print, it will pick one of the items
    (usually called jobs) in the queue to print out.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机领域，队列被用来实现各种功能。例如，而不是为网络上的每一台计算机提供其自己的打印机，可以通过排队每台打印机想要打印的内容，让一组计算机共享一台打印机。当打印机准备好打印时，它会从队列中选择一个项目（通常称为作业）进行打印。
- en: Operating systems also queue processes to be executed by the CPU. Let's create
    an application that makes use of a queue to create a bare-bones media player.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统也会将进程排队以供CPU执行。让我们创建一个利用队列创建基本媒体播放器的应用程序。
- en: Media player queue
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 媒体播放器队列
- en: Most music player software allows users the chance to add songs to a playlist.
    Upon hitting the play button, all the songs in the main playlist are played one
    after the other. The sequential playing of the songs can be implemented with queues
    because the first song to be queued is the first song that is played. This aligns
    with the FIFO acronym. We shall implement our own playlist queue that plays songs
    in the FIFO manner.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数音乐播放器软件都允许用户有机会将歌曲添加到播放列表中。当按下播放按钮时，主播放列表中的所有歌曲会依次播放。由于首先被排队的歌曲是第一个被播放的歌曲，因此可以使用队列来实现歌曲的顺序播放，这与FIFO的缩写相符合。我们将实现我们自己的播放列表队列，以FIFO的方式播放歌曲。
- en: Basically, our media player queue will only allow for the addition of tracks
    and a way to play all the tracks in the queue. In a full-blown music player, threads
    would be used to improve how the queue is interacted with, while the music player
    continues to be used to select the next song to be played, paused, or even stopped.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们的媒体播放器队列只允许添加轨道以及播放队列中所有轨道的方式。在一个完整的音乐播放器中，会使用线程来改善队列的交互方式，同时音乐播放器继续被用来选择下一首将要播放、暂停或甚至停止的歌曲。
- en: 'The `track` class will simulate a musical track:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`track` 类将模拟一个音乐轨道：'
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Each track holds a reference to the title of the song and also the length of
    the song. The length is a random number between 5 and 10\. The random module provides
    the `randint` method to enable us generate the random numbers. The class represents
    any MP3 track or file that contains music. The random length of a track is used
    to simulate the number of seconds it takes to play a song or track.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每个轨道都保存了歌曲标题的引用以及歌曲的长度。长度是介于5到10之间的随机数。随机模块提供了 `randint` 方法，使我们能够生成随机数。这个类代表任何包含音乐的MP3轨道或文件。轨道的随机长度被用来模拟播放一首歌曲或轨道所需的时间。
- en: 'To create a few tracks and print out their lengths, we do the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建几个轨道并打印出它们的长度，我们执行以下操作：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Your output may be different depending on the random length generated for the
    two tracks.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出可能因两个轨道生成的随机长度不同而不同。
- en: 'Now, let''s create our queue. Using inheritance, we simply inherit from the
    `queue` class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的队列。使用继承，我们简单地从 `queue` 类继承：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A call is made to properly initialize the queue by making a call to `super`.
    This class is essentially a queue that holds a number of track objects in a queue.
    To add tracks to the queue, an `add_track` method is created:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `super` 来正确初始化队列，进行调用以创建队列。这个类本质上是一个队列，它在一个队列中持有多个轨道对象。为了向队列中添加轨道，创建了一个
    `add_track` 方法：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The method passes a `track` object to the `enqueue` method of the queue `super`
    class. This will, in effect, create a `Node` using the `track` object (as the
    node's data) and point either the tail, if the queue is not empty, or both head
    and tail, if the queue is empty, to this new node.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将一个 `track` 对象传递给队列的 `super` 类的 `enqueue` 方法。这将实际上使用 `track` 对象（作为节点数据）创建一个
    `Node`，并将队列的尾指针（如果队列不为空）或头尾指针（如果队列为空）指向这个新节点。
- en: 'Assuming the tracks in the queue are played sequentially from the first track
    added to the last (FIFO), then the `play` function has to loop through the elements
    in the queue:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 假设队列中的轨道是按照从第一个添加的轨道到最后的顺序播放（FIFO），那么 `play` 函数必须遍历队列中的元素：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`self.count` keeps count of when a track is added to our queue and when tracks
    have been dequeued. If the queue is not empty, a call to the `dequeue` method
    will return the node (which houses the `track` object) at the front of the queue.
    The `print` statement then accesses the title of the track through the `data`
    attribute of the node. To further simulate the playing of a track, the `time.sleep()`
    method halts program execution till the number of seconds of the track has elapsed:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.count`记录了曲目被添加到我们的队列中和曲目被出队的时间。如果队列不为空，调用`dequeue`方法将返回队列前端的节点（其中包含`track`对象）。然后`print`语句通过节点的`data`属性访问曲目的标题。为了进一步模拟曲目的播放，`time.sleep()`方法使程序执行暂停，直到曲目的秒数已过：'
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The media player queue is made up of nodes. When a track is added to the queue,
    the track is hidden in a newly created node and associated with the data attribute
    of the node. That explains why we access a node''s `track` object through the
    data property of the node which is returned by the call to `dequeue`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体播放器队列由节点组成。当一首曲目被添加到队列中时，该曲目会隐藏在一个新创建的节点中，并与节点的数据属性相关联。这就解释了为什么我们通过调用`dequeue`返回的节点（其中包含`track`对象）的数据属性来访问节点的`track`对象：
- en: '![](img/B05630_05_16.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05630_05_16.jpg)'
- en: You can see, instead of our `node` object just storing just any data, it stores
    tracks in this case.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们的`node`对象不仅仅存储任何数据，在这种情况下，它存储的是曲目。
- en: 'Let''s take our music player for a spin:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来试一下我们的音乐播放器：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We create five track objects with random words as titles:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了五个曲目对象，标题为随机单词：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The output should be different from what you get on your machine due to the
    random length.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于随机长度，输出应该与你在机器上得到的不同。
- en: 'Next, an instance of the `MediaPlayerQueue` class is created:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建了一个`MediaPlayerQueue`类的实例：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The tracks will be added and the output of the `play` function should print
    out the tracks being played in the same order in which we queued them:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 曲目将被添加，`play`函数的输出应该以我们排队相同的顺序打印出正在播放的曲目：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Upon execution of the program, it can be seen that the tracks are played in
    the order in which they were queued. When playing the track, the system also pauses
    for the number of seconds equal to that of the length of the track.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 程序执行后，可以看到曲目是按照它们被加入队列的顺序播放的。在播放曲目时，系统也会暂停与曲目长度相等的秒数。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we used our knowledge of linking nodes together to create other
    data structures, namely stacks and queues. We have seen how these data structures
    closely mimic stacks and queues in the real world. Concrete implementations, together
    with their varying types, have been shown. We later applied the concept of stacks
    and queues to write real-life programs.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们利用将节点链接在一起的知识来创建其他数据结构，即栈和队列。我们看到了这些数据结构如何紧密地模仿现实世界中的栈和队列。展示了具体实现及其不同类型。我们后来将栈和队列的概念应用于编写现实生活中的程序。
- en: We shall consider trees in the next chapter. The major operations on a tree
    will be discussed, likewise the different spheres in which to apply the data structure.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将考虑树。将讨论树上的主要操作，同样也会讨论应用这种数据结构的不同领域。
