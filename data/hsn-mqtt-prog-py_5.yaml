- en: Testing and Improving Our Vehicle Control Solution in Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和改进我们的Python车辆控制解决方案
- en: 'In this chapter, we will use our vehicle control solution with MQTT messages
    and Python code. We will learn how to process commands received in MQTT messages
    with Python code. We will write Python code to compose and send MQTT messages
    with commands. We will work with the blocking and threaded network loops and we
    will understand their difference. Finally, we will take advantage of the last
    will and testament feature. We will take an in-depth look at the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用我们的车辆控制解决方案与MQTT消息和Python代码。我们将学习如何使用Python代码处理接收到的MQTT消息中的命令。我们将编写Python代码来组成和发送带有命令的MQTT消息。我们将使用阻塞和线程化的网络循环，并理解它们的区别。最后，我们将利用遗嘱功能。我们将深入研究以下内容：
- en: Processing commands with Python
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python处理命令
- en: Sending messages with Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python发送消息
- en: Working with the network loop with Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python处理网络循环
- en: Working with last will and testament with Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python处理遗嘱和遗嘱消息
- en: Working with retained last will messages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用保留的遗嘱消息
- en: Understanding blocking and non-blocking code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解阻塞和非阻塞代码
- en: Using the threaded client interface
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程化客户端接口
- en: Processing commands with Python
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python处理命令
- en: 'In [Chapter 4](87908cb8-83ed-4b74-bfc5-dd0c4ddd93aa.xhtml), *Writing Code to
    Control a Vehicle with Python and MQTT Messages*, we coded a solution that was
    capable of processing commands for a vehicle received as MQTT messages with Python
    code. Now, we want to make a vehicle process many commands to check how all the
    pieces work together. We want to execute the following commands:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](87908cb8-83ed-4b74-bfc5-dd0c4ddd93aa.xhtml)中，*使用Python和MQTT消息编写控制车辆的代码*，我们编写了一个能够使用Python代码处理作为MQTT消息接收的车辆命令的解决方案。现在，我们想让车辆处理多条命令，以检查所有部件如何协同工作。我们想执行以下命令：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Make sure the Mosquitto server, or any other MQTT server you might want to use
    for this example, is running.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Mosquitto服务器，或者您可能想要用于此示例的任何其他MQTT服务器正在运行。
- en: Launch MQTT.fx and follow all the steps explained in [Chapter 4](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=129&action=edit#post_107), *Writing
    Code to Control a Vehicle with Python and MQTT Messages*, to configure a connection
    with TLS and TLS authentication, if you didn't establish a previous secure connection
    to the MQTT server with MQTT.fx. Then, click on the Connect button.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 启动MQTT.fx并按照[第4章](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=129&action=edit#post_107)中解释的所有步骤，*使用Python和MQTT消息编写控制车辆的代码*，配置TLS和TLS身份验证的连接，如果您之前没有使用MQTT.fx与MQTT服务器建立安全连接。然后，点击连接按钮。
- en: Click Subscribe and enter `vehicles/vehiclepi01/executedcommands` in the drop-down
    menu on the left-hand side of the Subscribe button. Then, click the Subscribe
    button. MQTT.fx will display a new panel on the left-hand side with the topic
    filter to which we have subscribed with QoS level 0.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 点击订阅并在订阅按钮左侧的下拉菜单中输入`vehicles/vehiclepi01/executedcommands`。然后，点击订阅按钮。MQTT.fx将在左侧显示一个新面板，其中包含我们已订阅的主题过滤器，QoS级别为0。
- en: 'Then, execute the following line to start the vehicle controller example in
    any computer or device that you want to use as the MQTT client that uses Linux
    or macOS:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在任何您想要用作使用Linux或macOS的MQTT客户端的计算机或设备上执行以下命令以启动车辆控制器示例：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In Windows, you must execute the following line:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，您必须执行以下命令：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Keep the code running on your local computer or on the IoT board you have chosen
    to use as the vehicle controller for this example.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 保持代码在您选择用作此示例的车辆控制器的本地计算机或IoT板上运行。
- en: In MQTT.fx, click Publish and enter `vehicles/vehiclepi01/commands` in the drop-down
    menu on the left-hand side of the Publish button. Click QoS 2 because we want
    to use QoS level 2.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在MQTT.fx中，点击发布并在发布按钮左侧的下拉菜单中输入`vehicles/vehiclepi01/commands`。点击QoS 2，因为我们想使用QoS级别2。
- en: 'Enter the following text in the textbox below the Publish button: `{"CMD":
    "LOCK_DOORS"}`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '在发布按钮下方的文本框中输入以下文本：`{"CMD": "LOCK_DOORS"}`'
- en: Then, click the Publish button. MQTT.fx will publish the entered text to the
    specified topic with QoS level 2.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击发布按钮。MQTT.fx将以QoS级别2将输入的文本发布到指定主题。
- en: 'Go to the window in which you can see the output generated by the Python code
    that receives the messages and controls the vehicle. If you are running the code
    on an IoT board, you might be using an SSH terminal or a screen connected to the
    IoT board. If you are running the code on your local computer, go to Terminal
    or Command Prompt, based on the operating system you are using. You will see the
    following output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 转到您可以看到由接收消息并控制车辆的Python代码生成的输出的窗口。如果您在IoT板上运行代码，您可能正在使用SSH终端或连接到IoT板的屏幕。如果您在本地计算机上运行代码，请转到终端或命令提示符，根据您使用的操作系统。您将看到以下输出：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code has received the message with the command, the `Vehicle` instance executed
    the `lock_doors` method, and the output displays the results of executing this
    code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 代码已收到带有命令的消息，`Vehicle`实例执行了`lock_doors`方法，并且输出显示了执行此代码的结果。
- en: 'Go back to MQTT.fx, click Subscribe and you will see a new message has arrived
    in the `vehicles/vehiclepi01/executedcommands` topic with the following payload:
    `{"SUCCESSFULLY_PROCESSED_COMMAND": "LOCK_DOORS"}`. The following screenshot shows
    the received message in MQTT.fx:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '返回到MQTT.fx，点击订阅，您将看到`vehicles/vehiclepi01/executedcommands`主题中已经有一条新消息到达，其有效载荷如下：`{"SUCCESSFULLY_PROCESSED_COMMAND":
    "LOCK_DOORS"}`。以下屏幕截图显示了在MQTT.fx中接收到的消息：'
- en: '![](assets/ca44b769-efda-4736-b925-9e45b6ca3c91.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ca44b769-efda-4736-b925-9e45b6ca3c91.png)'
- en: 'Now, repeat the following procedure for each of the commands included in the
    previously shown list. We want our vehicle control application to process each
    of those commands received in MQTT messages with QoS level 2\. Remove the existing
    text and enter the text for the JSON string in the textbox under the Publish button
    and then click the Publish button. MQTT.fx will publish the entered text to the
    specified topic with QoS level 2:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对先前显示的列表中包含的每个命令重复以下过程。我们希望我们的车辆控制应用程序处理通过MQTT消息接收的每个命令，QoS级别为2。删除现有文本，然后在发布按钮下的文本框中输入JSON字符串的文本，然后单击发布按钮。MQTT.fx将以QoS级别2将输入的文本发布到指定主题：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Go to the window in which you can see the output generated by the Python code
    that receives the messages and controls the vehicle. You will see the following
    output that indicates that all the commands have been received and processed:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 转到您可以看到由接收消息并控制车辆的Python代码生成的输出的窗口。您将看到以下输出，指示所有命令已被接收和处理：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Go back to MQTT.fx, click Subscribe, and you will see a total of 12 messages
    that have arrived in the `vehicles/vehiclepi01/executedcommands` topic. You can
    easily check the contents of the payload for each of the received messages by
    clicking on the panel that represents each of them on the right-hand side of the
    window. The following screenshot shows the last received message in MQTT.fx:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到MQTT.fx，单击订阅，您将看到已到达`vehicles/vehiclepi01/executedcommands`主题的共计12条消息。您可以通过单击窗口右侧代表每条消息的面板来轻松检查每条接收消息的有效负载的内容。以下屏幕截图显示了MQTT.fx中收到的最后一条消息：
- en: '![](assets/92978bdf-384b-4340-b6d1-c49b8db655f5.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/92978bdf-384b-4340-b6d1-c49b8db655f5.png)'
- en: 'Now, we will use the Mosquitto command-line utilities to subscribe to the `vehicles/vehiclepi01/executedcommands`
    topic and publish many MQTT messages with the JSON strings with the commands to
    the `vehicles/vehiclepi01/commands` topic. This time, we will publish the following
    commands:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用Mosquitto命令行实用程序订阅`vehicles/vehiclepi01/executedcommands`主题，并发布许多带有命令的JSON字符串的MQTT消息到`vehicles/vehiclepi01/commands`主题。这次，我们将发布以下命令：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Open another Terminal in macOS or Linux, or another Command Prompt in Windows,
    go to the directory in which Mosquitto is installed, and run the following command.
    Replace `192.168.1.1` with the IP or hostname for the MQTT server. Remember to
    replace `ca.crt`, `board001.crt`, and `board001.key` with the full path to these
    files, created in the `board_certificates` directory. Leave the window opened
    and the utility will display all the messages received in the `vehicles/vehiclepi01/executedcommands`
    topic. The code file for the sample is included in the `mqtt_python_gaston_hillar_05_01`
    folder, in the `script_01.txt` file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS或Linux中打开另一个终端，或者在Windows中打开另一个命令提示符，转到Mosquitto安装的目录，并运行以下命令。将`192.168.1.1`替换为MQTT服务器的IP或主机名。记得将`ca.crt`、`board001.crt`和`board001.key`替换为在`board_certificates`目录中创建的这些文件的完整路径。保持窗口打开，实用程序将显示在`vehicles/vehiclepi01/executedcommands`主题中接收的所有消息。示例的代码文件包含在`mqtt_python_gaston_hillar_05_01`文件夹中的`script_01.txt`文件中：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Open another Terminal in macOS or Linux, or another Command Prompt in Windows,
    go to the directory in which Mosquitto is installed, and run the following commands
    to publish messages with commands to the `vehicles/vehiclepi01/commands` topic
    with QoS level 2\. Make the same replacements previously explained for the `mosquitto_sub`
    command. The code file for the sample is included in the `mqtt_python_gaston_hillar_05_01`
    folder, in the `script_02.txt` file:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS或Linux中打开另一个终端，或者在Windows中打开另一个命令提示符，转到Mosquitto安装的目录，并运行以下命令以使用QoS级别2发布带有命令的消息到`vehicles/vehiclepi01/commands`主题。对于`mosquitto_sub`命令，进行与之前解释的相同替换。示例的代码文件包含在`mqtt_python_gaston_hillar_05_01`文件夹中的`script_02.txt`文件中：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After you run the previous commands, the `VehicleCommandProcessor` class will
    receive these commands and process them. After a few seconds, you will see the
    following output in the window that is executing the `mosquitto_sub` utility:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令后，`VehicleCommandProcessor`类将接收这些命令并处理它们。几秒钟后，您将在执行`mosquitto_sub`实用程序的窗口中看到以下输出：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the MQTT.fx utility will also receive the messages because it stayed
    subscribed to the `vehicles/vehiclepi01/executedcommands` topic.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，MQTT.fx实用程序也将接收消息，因为它保持订阅`vehicles/vehiclepi01/executedcommands`主题。
- en: 'Go to the window in which you can see the output generated by the Python code
    that receives the messages and controls the vehicle. You will see the following
    output, which indicates that all the commands have been received and processed:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 转到您可以看到由接收消息并控制车辆的Python代码生成的输出的窗口。您将看到以下输出，指示所有命令已被接收和处理：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Sending messages with Python
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python发送消息
- en: So far, we have been publishing MQTT messages to control the vehicle with GUI
    and command-line tools. Now, we will write code in Python to publish the commands
    to control each vehicle and check the results of the execution of these commands.
    Of course, GUI utilities, such as MQTT.fx and the Mosquitto command-line utilities,
    are extremely useful. However, after we know that things are working as we expect,
    we can write the necessary code to perform tests in the same programming language
    we are using to run the code on the IoT board.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用GUI和命令行工具发布MQTT消息来控制车辆。现在，我们将编写Python代码来发布控制每辆车的命令，并检查执行这些命令的结果。当然，GUI实用程序，如MQTT.fx和Mosquitto命令行实用程序，非常有用。但是，一旦我们知道事情正在按我们的期望进行，我们可以编写必要的代码以在与我们用于在IoT板上运行代码的相同编程语言中执行测试。
- en: Now, we are going to code a Python client that will publish messages to the
    `vehicles/vehiclepi01/commands` topic and will subscribe to the `vehicles/vehiclepi01/executedcommands`
    topic. We will code both a publisher and a subscriber. This way, we will be able
    to design applications that can talk to IoT devices with MQTT messages, with Python
    as the programming language for the client applications. Specifically, the applications
    will be able to communicate through an MQTT server with Python code in all the
    publisher and subscriber devices.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个Python客户端，它将发布消息到`vehicles/vehiclepi01/commands`主题，并订阅到`vehicles/vehiclepi01/executedcommands`主题。我们将编写发布者和订阅者。这样，我们将能够设计能够通过Python代码与MQTT消息通信的应用程序，Python将作为客户端应用程序的编程语言。具体来说，这些应用程序将能够通过MQTT服务器与所有发布者和订阅者设备中的Python代码进行通信。
- en: We can run the Python client on any other computer or IoT board that is capable
    of executing Python 3.x.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何其他能够执行Python 3.x的计算机或物联网板上运行Python客户端。
- en: In [Chapter 4](87908cb8-83ed-4b74-bfc5-dd0c4ddd93aa.xhtml), *Writing Code to
    Control a Vehicle with Python and MQTT Messages*, we created a Python file named
    `config.py` in the main virtual environment folder. In this file, we defined many
    configuration values that were used to establish a connection with the Mosquitto
    MQTT server. This way, all the configuration values were included in a specific
    Python script. If you need to make changes to this file to configure the application
    that will compose and send commands in MQTT messages to control the vehicle, make
    sure you review the explanations included in [Chapter 4](87908cb8-83ed-4b74-bfc5-dd0c4ddd93aa.xhtml), *Writing
    Code to Control a Vehicle with Python and MQTT Messages.*
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](87908cb8-83ed-4b74-bfc5-dd0c4ddd93aa.xhtml)中，*使用Python和MQTT消息编写控制车辆的代码*，我们在主虚拟环境文件夹中创建了一个名为`config.py`的Python文件。在这个文件中，我们定义了许多配置值，用于与Mosquitto
    MQTT服务器建立连接。这样，所有配置值都包含在一个特定的Python脚本中。如果您需要更改此文件以配置将组成并发送MQTT消息以控制车辆的应用程序，请确保您查看了[第4章](87908cb8-83ed-4b74-bfc5-dd0c4ddd93aa.xhtml)中包含的说明。
- en: 'Now, we will create a new Python file named `vehicle_mqtt_remote_control.py`
    in the main virtual environment folder. We will create many functions that we
    will assign as the callbacks to the events in the MQTT client. In addition, we
    will declare variables, a helper class, and a helper function to make it easy
    to publish a message with a command and the required values for the command. The
    following lines show the code that defines the variables, the helper class, and
    the functions. The code file for the sample is included in the `mqtt_python_gaston_hillar_05_01`
    folder, in the `vehicle_mqtt_remote_control.py` file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在主虚拟环境文件夹中创建一个名为`vehicle_mqtt_remote_control.py`的新的Python文件。我们将创建许多函数，并将它们分配为MQTT客户端中事件的回调函数。此外，我们将声明变量、一个辅助类和一个辅助函数，以便轻松地发布带有命令和所需值的消息。以下行显示了定义变量、辅助类和函数的代码。示例的代码文件包含在`mqtt_python_gaston_hillar_05_01`文件夹中的`vehicle_mqtt_remote_control.py`文件中：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first line imports the variables we have declared in our well-known `config.py`
    file. The code declares the `vehicle_name` variable that saves a string with `"vehiclepi01"`
    and that we can easily replace with the name of the vehicle that we want to control.
    Our main goal is to build and publish command messages to the topic specified
    in the `commands_topic` variable. We will subscribe to the topic specified in
    the `processed_commands_topic` variable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行导入了我们在著名的`config.py`文件中声明的变量。代码声明了`vehicle_name`变量，保存了一个字符串`"vehiclepi01"`，我们可以轻松地用要控制的车辆的名称替换它。我们的主要目标是构建并发布命令消息到`commands_topic`变量中指定的主题。我们将订阅到`processed_commands_topic`变量中指定的主题。
- en: The `LoopControl` class declares a class attribute named `is_last_command_processed`
    initialized to `False`. We will use this class attribute as a flag to control
    the network loop.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoopControl`类声明了一个名为`is_last_command_processed`的类属性，初始化为`False`。我们将使用这个类属性作为控制网络循环的标志。'
- en: The `on_connect` function is the callback that will be executed once a successful
    connection has been established with the MQTT server. The code checks the value
    of the `rc` argument that provides the `CONNACK` code returned by the MQTT server.
    If this value matches `mqtt.CONNACK_ACCEPTED`, it means that the MQTT server accepted
    the connection request, and therefore, the code calls the `client.subscribe` method
    for the MQTT client received in the `client` argument to subscribe to the topic
    name saved in the `processed_commands_topic` with a QoS level of 0.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_connect`函数是一旦与MQTT服务器建立了成功的连接就会执行的回调函数。代码检查`rc`参数的值，该参数提供MQTT服务器返回的`CONNACK`代码。如果此值与`mqtt.CONNACK_ACCEPTED`匹配，则表示MQTT服务器接受了连接请求，因此，代码调用`client.subscribe`方法，为`client`参数中接收到的MQTT客户端订阅了保存在`processed_commands_topic`中的主题名称，QoS级别为0。'
- en: The `on_message` function will be executed each time a new message arrives to
    the topic to which we have subscribed. The function just prints the raw string
    with the payload of the received message. If the payload includes the string saved
    in the `CMD_TURN_OFF_ENGINE` constant, we assume the last command was successfully
    executed and the code sets the `LoopControl.is_last_command_processed` to `True`.
    This way, we will control the network loop based on the feedback provided by the
    vehicle with MQTT messages that indicate the processed commands.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_message`函数将在每次新消息到达我们订阅的主题时执行。该函数只是打印接收到的消息的有效负载的原始字符串。如果有效负载包含在`CMD_TURN_OFF_ENGINE`常量中保存的字符串，则我们假定上一个命令已成功执行，并且代码将`LoopControl.is_last_command_processed`设置为`True`。这样，我们将根据车辆通过MQTT消息指示的已处理命令来控制网络循环。'
- en: The `on_subscribe` function will be called when the subscription has been successfully
    completed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_subscribe`函数将在订阅成功完成时调用。'
- en: 'The next table summarizes the functions that will be called based on the received
    responses from the MQTT server:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了将根据从MQTT服务器接收到的响应调用的函数：
- en: '| **Response from the MQTT server** | **Function that will be called** |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **来自MQTT服务器的响应** | **将被调用的函数** |'
- en: '| `CONNACK` | `on_connnect` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `CONNACK` | `on_connnect` |'
- en: '| `SUBACK` | `on_subscribe` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `SUBACK` | `on_subscribe` |'
- en: '| `PUBLISH` | `on_message` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `PUBLISH` | `on_message` |'
- en: The `build_command_message` function receives the command name, the key, and
    the value that provide the necessary information to build the string with the
    JSON key-value pairs that compose a command in the `command_name`, `key`, and
    `value` arguments. Note that the last two arguments are optional and their default
    value is an empty string. The function creates a dictionary and saves the results
    of serializing the dictionary to a JSON-formatted string in the `command_message`
    local variable. The `COMMAND_KEY` constant is the first key for the dictionary
    and the `command_name` received as an argument, the value that composes the first
    key-value pair. Finally, the function returns the `command_message` string.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`build_command_message`函数接收命令名称、键和值，提供构建包含命令的JSON键值对字符串所需的信息。请注意，最后两个参数是可选的，它们的默认值是空字符串。该函数创建一个字典，并将字典序列化为JSON格式的字符串保存在`command_message`局部变量中。`COMMAND_KEY`常量是字典的第一个键，`command_name`作为参数接收，是组成第一个键值对的值。最后，函数返回`command_message`字符串。'
- en: The `publish_command` function receives the MQTT client, the command name, the
    key, and the value that provide the necessary information to execute the command
    in the `client`, `command_name`, `key`, and `value` arguments. As in the `build_command_message`
    function, the key and value arguments are optional and their default value is
    an empty string. The function calls the previously explained `build_command_message`
    function with the `command_name`, `key`, and `value` arguments it received and
    saves the result in the `command_message` local variable. Then, the code calls
    the `client.publish` method to publish the `command_message` JSON-formatted string
    to the topic name saved in the `commands_topic` variable with a QoS level of 2.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish_command`函数接收MQTT客户端、命令名称、键和值，提供执行命令所需的信息。与`build_command_message`函数一样，键和值参数是可选的，它们的默认值是空字符串。该函数使用接收到的`command_name`、`key`和`value`参数调用先前解释的`build_command_message`函数，并将结果保存在`command_message`局部变量中。然后，代码调用`client.publish`方法，将`command_message`
    JSON格式的字符串发布到`commands_topic`变量中保存的主题名称，QoS级别为2。'
- en: The next line calls the `client.loop` method to ensure communication with the
    MQTT server is carried out and sleeps for one second. This way, the message will
    be published and the application will wait one second.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的一行调用`client.loop`方法，以确保与MQTT服务器的通信进行，并休眠一秒。这样，消息将被发布，应用程序将等待一秒。
- en: Working with the network loop with Python
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python处理网络循环
- en: 'Now, we will use the previously coded `functions` in a `__main__` method that
    will publish many commands included in the MQTT messages that the code that controls
    the vehicle will process. You have to add the next lines to the existing `vehicle_mqtt_remote_control.py`
    Python file. The following lines show the code for the `__main__` method, that
    is, the main block of code. The code file for the sample is included in the `mqtt_python_gaston_hillar_05_01`
    folder, in the `vehicle_mqtt_remote_control.py` file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在`__main__`方法中使用之前编写的`functions`，该方法将发布包含在MQTT消息中的许多命令，以便控制车辆的代码将处理这些命令。您必须将下面的代码添加到现有的`vehicle_mqtt_remote_control.py`
    Python文件中。以下代码显示了`__main__`方法的代码块。示例的代码文件包含在`mqtt_python_gaston_hillar_05_01`文件夹中的`vehicle_mqtt_remote_control.py`文件中：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first lines of code are similar to the first Python example we coded. After
    calling the `client.connect` method, the code calls the `publish_command` command
    many times to build and publish the messages with the commands.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的前几行与我们编写的第一个Python示例类似。调用`client.connect`方法后，代码多次调用`publish_command`命令来构建并发布带有命令的消息。
- en: The `while` loop calls the `client.loop` method to ensure communication with
    the MQTT server is carried out and sleeps for 500 milliseconds, that is, 0.5 seconds.
    After the last command is processed, the `LoopControl.is_last_command_processed`
    class variable is set to `True` and the while loop ends its execution. When this
    happens, the code calls the `client.disconnect` method and finally the `client.loop`
    method to make sure that the disconnect request is processed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环调用`client.loop`方法，以确保与MQTT服务器的通信进行，并休眠500毫秒，即0.5秒。在最后一个命令被处理后，`LoopControl.is_last_command_processed`类变量被设置为`True`，`while`循环结束执行。当这发生时，代码调用`client.disconnect`方法，最后调用`client.loop`方法，以确保断开连接请求被处理。'
- en: If we don't call the `client.loop` method after calling `client.disconnect`,
    the program can finish its execution without sending the request to disconnect
    to the MQTT server. In the next sections, we will work with the last will and
    testament feature and we will note that the ways in which a client is disconnected
    have an important impact on the usage of this feature.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调用`client.disconnect`后不调用`client.loop`方法，程序可能会在不向MQTT服务器发送断开连接请求的情况下结束执行。在接下来的章节中，我们将使用遗嘱功能，并注意客户端断开连接的方式对该功能的使用产生重要影响。
- en: In this case, we don't want the loop to run forever because we have a specific
    goal of composing and sending a set of commands. Once we are sure that the last
    command has been processed, we close the connection with the MQTT server.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不希望循环永远运行，因为我们有一个特定的目标，即组合并发送一组命令。一旦我们确信最后一个命令已被处理，我们就会关闭与MQTT服务器的连接。
- en: Make sure that the code that controls `vehiclepi01` is running, that is, the
    `vehicle_mqtt_client.py` Python script that we coded in [Chapter 4](87908cb8-83ed-4b74-bfc5-dd0c4ddd93aa.xhtml), *Writing
    Code to Control a Vehicle with Python and MQTT Messages*, is running.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 确保控制`vehiclepi01`的代码正在运行，也就是说，我们在[第4章](87908cb8-83ed-4b74-bfc5-dd0c4ddd93aa.xhtml)中编写的`vehicle_mqtt_client.py`
    Python脚本正在运行。
- en: 'Then, execute the following line to start the vehicle remote control example
    on any computer or device that you want to use as the MQTT client and uses Linux
    or macOS:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在任何您想要用作MQTT客户端并且使用Linux或macOS的计算机或设备上执行以下命令来启动车辆远程控制示例：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In Windows, you must execute the following line:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，您必须执行以下命令：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Keep the code running on your local computer or on the IoT board you have chosen
    to use as the vehicle remote control for this example.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 保持代码在您选择用作此示例车辆远程控制的本地计算机或IoT板上运行。
- en: 'Go to the device and window in which you executed the previous Python script,
    named `vehicle_mqtt_remote_control.py`. You will see the following output. The
    Python code will show all the messages received in the `vehicles/vehiclepi01/executedcommands`
    topic. The program will end its execution after the vehicle indicates that it
    has successfully processed the `TURN_OFF_ENGINE` command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 转到执行先前的Python脚本`vehicle_mqtt_remote_control.py`的设备和窗口。您将看到以下输出。Python代码将显示在`vehicles/vehiclepi01/executedcommands`主题中接收到的所有消息。在车辆成功处理`TURN_OFF_ENGINE`命令后，程序将结束执行：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Go to the device and window in which you executed the Python script that controlled
    the vehicle and processed the received commands, that is, `vehicle_mqtt_client.py`.
    You will see the following output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 转到执行控制车辆并处理接收到的命令的Python脚本`vehicle_mqtt_client.py`的设备和窗口。您将看到以下输出：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following screenshot shows two Terminal windows running on a computer with
    macOS. The Terminal on the left-hand side is displaying the messages shown by
    the Python client that publishes commands and works as the remote control for
    the vehicle, that is, the `vehicle_mqtt_remote_control.py` script. The Terminal
    on the right-hand side is displaying the results of running the code for the Python
    client that controls the vehicle and processes the received commands, that is,
    the `vehicle_mqtt_client.py` script:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在macOS计算机上运行的两个终端窗口。左侧的终端显示了由发布命令并作为车辆远程控制器的Python客户端显示的消息，即`vehicle_mqtt_remote_control.py`脚本。右侧的终端显示了控制车辆并处理接收到的命令的Python客户端代码的结果，即`vehicle_mqtt_client.py`脚本：
- en: '![](assets/7335cf47-4c8d-487d-bca1-88ece1b7c706.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7335cf47-4c8d-487d-bca1-88ece1b7c706.png)'
- en: Working with last will and testament with Python
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python处理遗嘱
- en: Now, we will check what happens if the MQTT client that represents our vehicle
    remote control application disconnects unexpectedly from the MQTT server with
    the code we have written so far. Pay attention to all the steps because we will
    manually interrupt the execution of the vehicle remote control program to understand
    a specific problem that we will solve by taking advantage of the last will and
    testament feature.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将检查如果代表我们的车辆远程控制应用程序的MQTT客户端意外断开与我们迄今为止编写的代码所连接的MQTT服务器会发生什么。请注意所有步骤，因为我们将手动中断车辆远程控制程序的执行，以了解我们将利用遗嘱功能解决的特定问题。
- en: 'Execute the following line to start the vehicle remote control example on any
    computer or device that you want to use as the MQTT client and uses Linux or macOS:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何您想要用作MQTT客户端并且使用Linux或macOS的计算机或设备上执行以下命令来启动车辆远程控制示例：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In Windows, you must execute the following line:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，您必须执行以下命令：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Go to the device and window on which you executed the previous Python script,
    named `vehicle_mqtt_remote_control.py`. After you see the following output, press
    *Ctrl* + *C* to interrupt the execution of the script before all the commands
    are processed:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 转到执行先前的Python脚本`vehicle_mqtt_remote_control.py`的设备和窗口。在看到以下输出后，按下*Ctrl* + *C*中断脚本的执行，直到所有命令都被处理：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After you press *Ctrl* + *C*, you will see an output with a traceback similar
    to the following lines:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *C*后，您将看到类似以下行的回溯输出：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We interrupted the connection between the MQTT client that works as a remote
    control for the vehicle and the MQTT server. We didn't wait for all the commands
    to be published and we disconnected the MQTT client unexpectedly from the MQTT
    server. The vehicle doesn't know that the remote control application has been
    interrupted.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中断了作为车辆远程控制器的MQTT客户端与MQTT服务器之间的连接。我们没有等待所有命令被发布，而是意外地将MQTT客户端与MQTT服务器断开连接。车辆不知道远程控制应用程序已中断。
- en: In this case, we used a keyboard shortcut to interrupt the execution of the
    Python program. However, a network failure might be another cause for an unexpected
    disconnection of the MQTT client from the MQTT server.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了一个键盘快捷键来中断Python程序的执行。然而，网络故障可能是MQTT客户端意外与MQTT服务器断开连接的另一个原因。
- en: Of course, we don't want a network failure to leave our vehicle without control,
    and therefore, we want to make sure that the vehicle parks in a safe place if
    the remote control application loses connection with the MQTT server. In this
    case, we want to make sure the vehicle receives a message with the command that
    indicates to the vehicle that it must park in a safe place that is configured
    for the vehicle.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不希望网络故障使我们的车辆失去控制，因此，我们希望确保如果远程控制应用程序与MQTT服务器失去连接，车辆将停放在一个安全的地方。在这种情况下，我们希望确保车辆接收到一条指示车辆必须停放在为车辆配置的安全地点的命令的消息。
- en: In [Chapter 1](d20ae00b-2bb7-4d81-b3eb-5c47215bce1f.xhtml)*, Installing an MQTT
    3.1.1 Mosquitto Server*, we analyzed the fields and flags that compose the payload
    of the `CONNECT` control packet that an MQTT client sends to an MQTT server to
    establish a connection. Now, we will use the appropriate method provided in `paho-mqtt`
    to configure the values for the `Will`, `WillQoS`, `WillRetain`, `WillTopic`,
    and `WillMessage` flags and fields that will allow our MQTT client to take advantage
    of the last will and testament feature of MQTT.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](d20ae00b-2bb7-4d81-b3eb-5c47215bce1f.xhtml)*，安装MQTT 3.1.1 Mosquitto服务器*中，我们分析了组成MQTT客户端发送到MQTT服务器以建立连接的`CONNECT`控制数据包的有效载荷的字段和标志。现在，我们将使用`paho-mqtt`中提供的适当方法来配置`Will`、`WillQoS`、`WillRetain`、`WillTopic`和`WillMessage`标志和字段的值，以使我们的MQTT客户端利用MQTT的遗嘱功能。
- en: 'Open the existing `vehicle_mqtt_remote_control.py` Python file and replace
    the lines that define the `__main__` method with the following code to configure
    the last will message that we want the MQTT server to send to the vehicle if an
    unexpected disconnection occurs. The added lines are highlighted. The code file
    for the sample is included in the `mqtt_python_gaston_hillar_05_02` folder, in
    the `vehicle_mqtt_remote_control.py` file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 打开现有的`vehicle_mqtt_remote_control.py` Python文件，并用以下代码替换定义`__main__`方法的行，以配置我们希望MQTT服务器在发生意外断开连接时发送给车辆的遗嘱消息。添加的行已经突出显示。示例的代码文件包含在`mqtt_python_gaston_hillar_05_02`文件夹中的`vehicle_mqtt_remote_control.py`文件中。
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We added two lines of code before the code calls the `client.connect` method,
    that is, before we send a connection request to the MQTT server. The first line
    calls the `build_command_message` function with `CMD_PARK_IN_SAFE_PLACE` as an
    argument to build the JSON string with the command that makes the vehicle park
    in a safe place, and stores it in the `last_will_payload` variable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码调用`client.connect`方法之前，我们添加了两行代码，即在向MQTT服务器发送连接请求之前。第一行调用`build_command_message`函数，并将`CMD_PARK_IN_SAFE_PLACE`作为参数，以构建使车辆停放在安全地方的命令的JSON字符串，并将其存储在`last_will_payload`变量中。
- en: The next line of code calls the `client.will_set` method that allows us to configure
    the desired values for the `Will`,  `WillQoS`, `WillRetain`, `WillTopic`, and
    `WillMessage` flags and fields that will be used in the CONNECT control packet.
    The code calls this method with `commands_topic`, `last_will_payload`, and `2` 
    as the values for the topic, `payload`, and `qos` arguments. As we don't specify
    a value for the `retain` argument, the method will use its default value, `False`,
    which specifies that the last will message is not going to be a retained message.
    This way, when the next line of code calls the `client.connect` method to request
    the MQTT client to establish a connection to the MQTT server, the `CONNECT` control
    packet will include the appropriate values for the fields and flags to configure
    a last will message with QoS level 2, `commands_topic` as the topic in which the
    message will be published, and `last_will_payload` as the payload for the message.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码调用`client.will_set`方法，允许我们配置`Will`、`WillQoS`、`WillRetain`、`WillTopic`和`WillMessage`标志和字段的期望值，并将其用于CONNECT控制数据包。该代码使用`commands_topic`、`last_will_payload`和`2`作为主题、有效载荷和qos参数的值来调用此方法。由于我们没有为`retain`参数指定值，该方法将使用其默认值`False`，这指定了遗嘱消息不会是保留消息。这样，当下一行代码调用`client.connect`方法请求MQTT客户端与MQTT服务器建立连接时，`CONNECT`控制数据包将包括用于配置遗嘱消息的字段和标志的适当值，QoS级别为2，`commands_topic`作为消息将被发布的主题，`last_will_payload`作为消息的有效载荷。
- en: 'Now, execute the following line to start the vehicle remote control example
    on any computer or device that you want to use as the MQTT client and uses Linux
    or macOS:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在任何您想要用作MQTT客户端并使用Linux或macOS的计算机或设备上执行以下行以启动车辆远程控制示例：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In Windows, you must execute the following line:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，您必须执行以下行：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Go to the device and window in which you executed the previous Python script,
    named `vehicle_mqtt_remote_control.py`. After you see the following output, press
    *Ctrl* + *C* to interrupt the execution of the script before all the commands
    are processed:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 转到您执行之前的Python脚本`vehicle_mqtt_remote_control.py`的设备和窗口。在看到以下输出后，按*Ctrl* + *C*中断脚本的执行，然后再处理所有命令：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After you press *Ctrl* + *C*, you will see an output with a traceback similar
    to the following lines:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *C*后，您将看到类似以下行的输出：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We interrupted the connection between the MQTT client that works as a remote
    control for the vehicle and the MQTT server. We didn't wait for all the commands
    to be published and we disconnected the MQTT client unexpectedly from the MQTT
    server. Thus, the MQTT server publishes the configured last will message that
    the MQTT client, which works as a remote control for the vehicle, has configured
    when it established a connection with the MQTT server. This way, the vehicle receives
    a command to park in a safe place when the connection between the remote control
    application and the MQTT server is lost.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中断了作为车辆远程控制器的MQTT客户端与MQTT服务器之间的连接。我们没有等待所有命令被发布，而是意外地从MQTT服务器断开了MQTT客户端的连接。因此，MQTT服务器会发布配置的遗嘱消息，即当远程控制车辆的MQTT客户端与MQTT服务器建立连接时配置的遗嘱消息。这样，当远程控制应用程序与MQTT服务器之间的连接丢失时，车辆会收到一个命令，要求它停放在一个安全的地方。
- en: 'Go to the device and window in which you executed the Python script that controlled
    the vehicle and processed the received commands, that is, `vehicle_mqtt_client.py`.
    You will see an output similar to the following lines. Note that the last received
    message instructs the vehicle to park in a safe place. This last received message
    is the last will message we configured with the added lines of code in the Python
    script named `vehicle_mqtt_remote_control.py`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 转到您执行控制车辆并处理接收到的命令的Python脚本`vehicle_mqtt_client.py`的设备和窗口。您将看到类似以下行的输出。请注意，最后接收到的消息指示车辆停放在一个安全的地方。这个最后接收到的消息是我们在名为`vehicle_mqtt_remote_control.py`的Python脚本中添加的代码行配置的遗嘱消息。
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following screenshot shows two Terminal windows running on a computer with
    macOS. The Terminal on the left-hand side is displaying the messages shown by
    the Python client that publishes commands and works as the remote control for
    the vehicle, that is, the `vehicle_mqtt_remote_control.py` script. The Terminal
    on the right-hand side is displaying the results of running the code for the Python
    client that controls the vehicle and processes the received commands, that is,
    the `vehicle_mqtt_client.py` script. The interruption of the connection generated
    the MQTT server to publish the configured last will message:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在macOS计算机上运行的两个终端窗口。左侧的终端显示了由发布命令并作为车辆远程控制器工作的Python客户端显示的消息，即`vehicle_mqtt_remote_control.py`脚本。右侧的终端显示了控制车辆并处理接收到的命令的Python客户端代码的结果，即`vehicle_mqtt_client.py`脚本。连接中断导致MQTT服务器发布了配置的最后遗嘱消息：
- en: '![](assets/05a40b9f-167a-48f5-829b-fcbca43e357a.png)You can take advantage
    of the last will and testament feature to indicate to interested clients that
    a specific board, device, or sensor is offline.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/05a40b9f-167a-48f5-829b-fcbca43e357a.png)您可以利用最后遗嘱功能来指示感兴趣的客户端，特定的板、设备或传感器已离线。'
- en: 'Now, execute the following line to start the vehicle remote control example
    on any computer or device that you want to use as the MQTT client and uses Linux
    or macOS:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在任何您想要用作MQTT客户端并使用Linux或macOS的计算机或设备上执行以下命令以启动车辆远程控制示例：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In Windows, you must execute the following line:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，您必须执行以下命令：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Go to the device and window in which you executed the previous Python script,
    named `vehicle_mqtt_remote_control.py`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 转到执行先前Python脚本的设备和窗口，名称为`vehicle_mqtt_remote_control.py`。
- en: This time, keep the code running on your local computer or on the IoT board
    you have chosen to use as the vehicle remote control for this example.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，在您选择用作此示例车辆远程控制的本地计算机或IoT板上保持代码运行。
- en: 'Go to the device and window in which you executed the Python script that controlled
    the vehicle and processed the received commands, that is, `vehicle_mqtt_client.py`.
    You will see the following last lines in the output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 转到执行控制车辆并处理接收到的命令的Python脚本的设备和窗口，即`vehicle_mqtt_client.py`。您将在输出中看到以下最后几行：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this case, the code called the `client.disconnect` method and then the `client.loop`
    method. The MQTT client disconnected from the MQTT server in a normal way, and
    therefore, the last will message with the command to park the vehicle in a safe
    place wasn't published.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，代码调用了`client.disconnect`方法，然后调用了`client.loop`方法。 MQTT客户端以正常方式从MQTT服务器断开连接，因此，带有将车辆停放在安全位置的命令的最后遗嘱消息没有被发布。
- en: It is very important to understand that the configured last will message isn't
    published when the MQTT client disconnects from the MQTT by calling the `client.disconnect`
    method and making sure that the network events are processed. If we want to publish
    a message before a normal disconnection performed with the `client.disconnect`
    method, we must write the necessary code to do so before calling this method.
    In addition, we have to make sure that the network events are processed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要理解，当MQTT客户端通过调用`client.disconnect`方法断开与MQTT的连接并确保网络事件被处理时，配置的最后遗嘱消息不会被发布。如果我们希望在使用`client.disconnect`方法执行正常断开连接之前发布一条消息，我们必须在调用此方法之前编写必要的代码来执行此操作。此外，我们必须确保网络事件被处理。
- en: Working with retained last will messages
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用保留的最后遗嘱消息
- en: Now, we will check what happens when the MQTT client that controls the vehicle
    disconnects unexpectedly from the MQTT server and our vehicle remote control application
    disconnects unexpectedly, too. Pay attention to all the steps because we will
    manually interrupt the execution of both programs to understand a specific problem
    that we will solve by taking advantage of the last will and testament feature
    combined with the retained flag value.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将检查当控制车辆的MQTT客户端意外地与MQTT服务器断开连接时以及我们的车辆远程控制应用程序也意外断开连接时会发生什么。请注意所有步骤，因为我们将手动中断两个程序的执行，以了解我们将利用最后遗嘱功能结合保留标志值来解决的特定问题。
- en: You will have to be quick to run the next steps. Hence, make sure you read all
    the steps and then execute them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须迅速执行接下来的步骤。因此，请确保您阅读所有步骤，然后执行它们。
- en: 'Execute the following line to start the vehicle remote control example on any
    computer or device that you want to use as the MQTT client and uses Linux or macOS:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何您想要用作MQTT客户端并使用Linux或macOS的计算机或设备上执行以下命令以启动车辆远程控制示例：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In Windows, you must execute the following line:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，您必须执行以下命令：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Go to the device and window in which you executed the Python script that controlled
    the vehicle and processed the received commands, that is, `vehicle_mqtt_client.py`.
    After you see the following output, press *Ctrl* + *C* to interrupt the execution
    of the script before all the commands are received:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 转到执行控制车辆并处理接收到的命令的Python脚本的设备和窗口，即`vehicle_mqtt_client.py`。在看到以下输出后，按*Ctrl*
    + *C*中断脚本的执行，然后再接收到所有命令之前：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After you press *Ctrl* + *C*, you will see an output with a traceback similar
    to the following lines:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *C*后，您将看到类似以下行的输出：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We interrupted the connection between the MQTT client that controls the vehicle
    and processes the received commands and the MQTT server. We didn't wait for all
    the commands to be received and we disconnected the MQTT client unexpectedly from
    the MQTT server. The vehicle remote control application doesn't know that the
    remote control application has been interrupted and it waits until the last command
    it sent is processed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中断了控制车辆并处理接收到的命令的MQTT客户端与MQTT服务器之间的连接。我们没有等待所有命令被接收，而是意外地将MQTT客户端与MQTT服务器断开连接。车辆遥控应用程序不知道遥控应用程序已中断，它会等待直到它发送的最后一个命令被处理。
- en: 'Go to the device and window in which you executed the previous Python script,
    named `vehicle_mqtt_remote_control.py`. Press *Ctrl* + *C*  to interrupt the execution
    of the script. After you press *Ctrl* + *C*, you will see an output with a traceback
    similar to the following lines:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 转到您执行先前的Python脚本`vehicle_mqtt_remote_control.py`的设备和窗口。按下*Ctrl* + *C*中断脚本的执行。按下*Ctrl*
    + *C*后，您将看到类似以下行的回溯输出：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Go back to the device and window in which you executed the Python script that
    controlled the vehicle and processed the received commands, that is, `vehicle_mqtt_client.py`.
    Execute the following line to start this script again on any computer or device
    that you want to use as the MQTT client and uses Linux or macOS:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到您执行控制车辆并处理接收到的命令的Python脚本的设备和窗口，即`vehicle_mqtt_client.py`。在任何您想要用作MQTT客户端并且使用Linux或macOS的计算机或设备上执行以下行以重新启动此脚本：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In Windows, you must execute the following line:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，您必须执行以下行：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Wait a few seconds and you will only see the following output that indicates
    the connection to the MQTT server has been accepted. No commands have been received:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几秒钟，您将只看到以下指示已接受与MQTT服务器的连接的输出。没有接收到任何命令：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following screenshot shows two Terminal windows running on a computer with
    macOS. The Terminal on the left-hand side is displaying the messages shown by
    the Python client that publishes commands and works as the remote control for
    the vehicle, that is, the `vehicle_mqtt_remote_control.py` script. The Terminal
    on the right-hand side is displaying the results of running the code for the Python
    client that controls the vehicle and processes the received commands, that is,
    the `vehicle_mqtt_client.py` script after the previously explained interruptions:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在macOS计算机上运行的两个终端窗口。左侧的终端显示了由发布命令并作为车辆遥控的Python客户端显示的消息，即`vehicle_mqtt_remote_control.py`脚本。右侧的终端显示了控制车辆并处理接收到的命令的Python客户端代码的运行结果，即先前解释的中断后的`vehicle_mqtt_client.py`脚本：
- en: '![](assets/f4771d68-6c0b-4a1d-a201-b17583b5f3a5.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f4771d68-6c0b-4a1d-a201-b17583b5f3a5.png)'
- en: When we started the `vehicle_mqtt_client.py` script, the code generated a new
    MQTT client and established a connection with the MQTT server and subscribed to `vehicles/vehiclepi01/commands`.
    The last will message published to this topic when we interrupted the execution
    of the `vehicle_mqtt_remote_control.py` script had been published with the `Retained`
    flag set to `False`, therefore, the message wasn't retained by the MQTT server
    and any new subscription to a topic filter that matches the topic to which the
    retained last will message has been sent doesn't receive it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动`vehicle_mqtt_client.py`脚本时，代码生成了一个新的MQTT客户端，并与MQTT服务器建立了连接，并订阅了`vehicles/vehiclepi01/commands`。当我们中断`vehicle_mqtt_remote_control.py`脚本的执行时，发布到此主题的最后遗嘱消息已经设置为`False`，因此，消息没有被MQTT服务器保留，并且任何新的订阅匹配发送到保留的最后遗嘱消息的主题的主题过滤器的订阅都不会收到它。
- en: 'Open the existing `vehicle_mqtt_remote_control.py` Python file and replace
    the lines that call the `client.will_set` method within the `__main__` method
    with the following code. The code file for the sample is included in the `mqtt_python_gaston_hillar_05_03`
    folder, in the `vehicle_mqtt_remote_control.py` file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 打开现有的`vehicle_mqtt_remote_control.py` Python文件，并用以下代码替换`__main__`方法中调用`client.will_set`方法的行。示例的代码文件包含在`mqtt_python_gaston_hillar_05_03`文件夹中的`vehicle_mqtt_remote_control.py`文件中：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We specified the `True` value for the `retain` argument that, in the previous
    version of the code, used the default `False` value. This way, the last will message
    is going to be a retained message.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`retain`参数指定了`True`值，而在代码的先前版本中使用了默认的`False`值。这样，最后遗嘱消息将成为保留消息。
- en: 'Execute the following line to start the vehicle remote control example on any
    computer or device that you want to use as the MQTT client and uses Linux or macOS:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何您想要用作MQTT客户端并且使用Linux或macOS的计算机或设备上执行以下行以启动车辆遥控示例：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In Windows, you must execute the following line:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，您必须执行以下行：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Go to the device and window in which you executed the Python script that controlled
    the vehicle and processed the received commands, that is, `vehicle_mqtt_client.py`.
    After you see the following output, press *Ctrl* + *C* to interrupt the execution
    of the script before all the commands are received:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 转到您执行控制车辆并处理接收到的命令的Python脚本的设备和窗口，即`vehicle_mqtt_client.py`。在看到以下输出后，按下*Ctrl*
    + *C*中断脚本的执行，直到所有命令都被接收之前：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After you press *Ctrl* + *C*, you will see an output with a traceback similar
    to the following lines:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *C*后，您将看到类似以下行的回溯输出：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We interrupted the connection between the MQTT client that controls the vehicle
    and processes the received commands and the MQTT server. We didn't wait for all
    the commands to be received and we disconnected the MQTT client unexpectedly from
    the MQTT server. The vehicle remote control application doesn't know that the
    remote control application has been interrupted and it waits until the last command
    it sent is processed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中断了控制车辆并处理接收到的命令的MQTT客户端与MQTT服务器之间的连接。我们没有等待所有命令被接收，而是突然断开了MQTT客户端与MQTT服务器的连接。车辆遥控应用程序不知道遥控应用程序已被中断，它会等到发送的最后一个命令被处理。
- en: 'Go to the device and window in which you executed the previous Python script,
    named `vehicle_mqtt_remote_control.py`. Press *Ctrl* + *C* to interrupt the execution
    of the script. After you press *Ctrl* + *C*, you will see an output with a traceback
    similar to the following lines:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 转到您执行先前的Python脚本`vehicle_mqtt_remote_control.py`的设备和窗口。按下*Ctrl* + *C*中断脚本的执行。按下*Ctrl*
    + *C*后，您将看到类似以下行的回溯输出：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Go back to the device and window in which you executed the Python script that
    controlled the vehicle and processed the received commands, that is, `vehicle_mqtt_client.py`.
    Execute the following line to start this script again on any computer or device
    that you want to use as the MQTT client and uses Linux or macOS:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 回到执行控制车辆并处理接收到的命令的Python脚本`vehicle_mqtt_client.py`的设备和窗口。在任何您想要用作MQTT客户端并且使用Linux或macOS的计算机或设备上再次执行以下命令来启动此脚本：
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In Windows, you must execute the following line:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，您必须执行以下命令：
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Wait a few seconds and you will only see the output which indicates the connection
    to the MQTT server has been accepted, and a message, which indicates the retained
    last will message that instructs the vehicle to park in a safe place has been
    received and processed. Hence, the vehicle will be parked in a safe place:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几秒钟，您将只会看到指示已接受与MQTT服务器的连接的输出，并且已接收和处理了指示车辆停放在安全位置的保留的遗嘱消息的输出。因此，车辆将停放在一个安全的地方：
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following screenshot shows two Terminal windows running on a computer with
    macOS. The Terminal on the left-hand side is displaying the messages shown by
    the Python client that publishes commands and works as the remote control for
    the vehicle, that is, the `vehicle_mqtt_remote_control.py` script. The Terminal
    on the right-hand side is displaying the results of running the code for the Python
    client that controls the vehicle and processes the received commands, that is,
    the `vehicle_mqtt_client.py` script after the previously explained interruptions:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在macOS计算机上运行的两个终端窗口。左侧的终端显示了由发布命令并作为车辆远程控制器工作的Python客户端显示的消息，即`vehicle_mqtt_remote_control.py`脚本。右侧的终端显示了运行控制车辆并处理接收到的命令的Python客户端代码的结果，即在先前解释的中断之后的`vehicle_mqtt_client.py`脚本：
- en: '![](assets/ae4b5d8c-cdd0-41f9-8101-75804c384227.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ae4b5d8c-cdd0-41f9-8101-75804c384227.png)'
- en: With the new code, when we started the `vehicle_mqtt_client.py` script, the
    code generated a new MQTT client, established a connection with the MQTT server,
    and subscribed to the `vehicles/vehiclepi01/commands`. The last will message published
    to this topic when we interrupted the execution of the `vehicle_mqtt_remote_control.py`
    script had been published with the `Retained` flag set to `True`, and therefore,
    the message was retained by the MQTT server and any new subscription to a topic
    filter that matches the topic to which the retained last will message has been
    sent receives it. The retained last will message allows us to make sure that the
    message arrives as the first message when a new connection to the MQTT server
    subscribes to a matching topic.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新代码时，当我们启动`vehicle_mqtt_client.py`脚本时，代码生成了一个新的MQTT客户端，与MQTT服务器建立了连接，并订阅了`vehicles/vehiclepi01/commands`。当我们中断`vehicle_mqtt_remote_control.py`脚本的执行时，最后一个遗嘱消息以`Retained`标志设置为`True`发布到此主题，因此，消息被MQTT服务器保留，并且任何新订阅与保留的遗嘱消息匹配的主题过滤器的连接都会接收到它。保留的遗嘱消息允许我们确保消息在新连接到MQTT服务器并订阅匹配主题时作为第一条消息到达。
- en: In this case, we always want to make sure that the vehicle receives the last
    will message if the MQTT client created in the `vehicle_mqtt_client.py` script
    loses the connection with the MQTT server and then establishes a new connection.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们始终希望确保如果`vehicle_mqtt_client.py`脚本中创建的MQTT客户端与MQTT服务器失去连接，然后建立新连接，车辆会收到遗嘱消息。
- en: Understanding blocking and non-blocking code
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解阻塞和非阻塞代码
- en: 'So far, we have been working with blocking calls that processed MQTT-related
    network traffic and dispatched callbacks. Whenever we called the `client.loop`
    method in the previous examples, the method used the default values for the two
    optional arguments: `1` for `timeout` and `1` for `max_packets`. The method blocks
    for up to one second, that is, the value of the `timeout` argument, to handle
    incoming or outgoing data. The method runs with a synchronous execution, and therefore,
    the next line of code won''t be executed until this method returns. We called
    the `client.loop` method in the main thread, and therefore, no other code can
    be executed in this thread while the `client.loop` method is blocking.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理与MQTT相关的网络流量和分发回调的阻塞调用。在以前的示例中，每当我们调用`client.loop`方法时，该方法都会使用两个可选参数的默认值：`timeout`为`1`，`max_packets`为`1`。该方法最多阻塞一秒钟，即`timeout`参数的值，以处理传入或传出的数据。该方法以同步执行，因此，在此方法返回之前，下一行代码不会被执行。我们在主线程中调用了`client.loop`方法，因此，在`client.loop`方法阻塞时，此线程中无法执行其他代码。
- en: In our first example with Python code that created an MQTT client, we called
    the `client.loop_forever` method. This method blocks until the client calls the
    `disconnect` method. The method runs with a synchronous execution, and therefore,
    the next line of code won't be executed until the client calls the `disconnect`
    method. We also called the `client.loop_forever` in the main thread, and therefore,
    no other code can be executed in this thread while the `client.loop_forever` method
    is blocking.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，使用Python代码创建了一个MQTT客户端，我们调用了`client.loop_forever`方法。此方法会阻塞，直到客户端调用`disconnect`方法。该方法以同步执行，因此，在客户端调用`disconnect`方法之前，下一行代码不会被执行。我们还在主线程中调用了`client.loop_forever`，因此，在`client.loop_forever`方法阻塞时，此线程中无法执行其他代码。
- en: One important difference between the loop method and the `loop_forever` method
    is that it is necessary to handle reconnections manually when we work with the
    loop method. The `loop_forever` method automatically handles reconnections to
    the MQTT server.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 循环方法和`loop_forever`方法之间的一个重要区别是，当我们使用循环方法时，需要手动处理重新连接。`loop_forever`方法会自动处理与MQTT服务器的重新连接。
- en: The `paho-mqtt` library provides us with a threaded client interface for the
    network loop that launches another thread that automatically calls the `loop`
    method. This way, it is possible to free up the main thread to run other code.
    The threaded interface is non-blocking and we don't have to worry about repeatedly
    calling the `loop` method. In addition, the threaded interface automatically handles
    reconnections to the MQTT server.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`paho-mqtt`库为我们提供了一个用于网络循环的线程化客户端接口，启动另一个线程自动调用`loop`方法。这样，就可以释放主线程来运行其他代码。线程化接口是非阻塞的，我们不必担心重复调用`loop`方法。此外，线程化接口还会自动处理与MQTT服务器的重新连接。'
- en: Using the threaded client interface
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程化的客户端接口
- en: 'Now, we will write a new version of the vehicle remote control application
    to use the threaded interface, also known as the threaded loop. Open the existing
    `vehicle_mqtt_remote_control.py` Python file and replace the lines that define
    the `publish_command` function with the following lines. The code file for the
    sample is included in the `mqtt_python_gaston_hillar_05_04` folder, in the `vehicle_mqtt_remote_control.py`
    file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写车辆远程控制应用的新版本，以使用线程化接口，也称为线程循环。打开现有的`vehicle_mqtt_remote_control.py`
    Python文件，并用以下行替换定义`publish_command`函数的行。示例的代码文件包含在`mqtt_python_gaston_hillar_05_04`文件夹中的`vehicle_mqtt_remote_control.py`文件中：
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We removed the following line before the call to `time.sleep(1)`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`time.sleep(1)`之前，我们移除了以下行：
- en: '[PRE48]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The threaded loop will automatically call `client.loop` in another thread, and
    therefore, we don't need to include a call to `client.loop` within the `publish_command`
    method anymore.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 线程循环将在另一个线程中自动调用`client.loop`，因此，我们不再需要在`publish_command`方法中包含对`client.loop`的调用。
- en: 'Open the existing `vehicle_mqtt_remote_control.py` Python file and replace
    the lines that define the `__main__` method with the following code to use the
    threaded loop. The added lines are highlighted. The code file for the sample is
    included in the `mqtt_python_gaston_hillar_05_04` folder, in the `vehicle_mqtt_remote_control.py`
    file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 打开现有的`vehicle_mqtt_remote_control.py` Python文件，并用以下代码替换定义`__main__`方法的行，以使用线程循环。添加的行已经突出显示。示例的代码文件包含在`mqtt_python_gaston_hillar_05_04`文件夹中的`vehicle_mqtt_remote_control.py`文件中：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After calling the `client.connect` method, the code calls the `client.loop_start`
    method. This method starts a new thread that processes the MQTT network traffic
    and frees up the main thread.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`client.connect`方法后，代码调用`client.loop_start`方法。该方法会启动一个新线程来处理MQTT网络流量，并释放主线程。
- en: Then, the calls to the edited `publish_command` function do not call `client.loop`
    anymore because the threaded client interface that we started with `client.loop_start`
    will automatically call the loop to process outgoing messages.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编辑后的`publish_command`函数的调用不再调用`client.loop`，因为我们使用`client.loop_start`启动的线程化客户端接口将自动调用循环来处理传出消息。
- en: The `while` loop that checks whether the last command has been processed or
    not every 500 milliseconds doesn't call `client.loop` anymore. Now, there is another
    thread that is calling `client.loop` for us.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 每500毫秒检查最后一条命令是否已经被处理的`while`循环不再调用`client.loop`。现在，有另一个线程在为我们调用`client.loop`。
- en: When the last command is processed, the code calls the `client.disconnect` method
    and finally calls the `client.loop_stop` method to stop the thread that is running
    the threaded client interface. This method will return when the thread is finished.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当最后一条命令被处理时，代码调用`client.disconnect`方法，最后调用`client.loop_stop`方法来停止运行线程化客户端接口的线程。该方法将在线程完成时返回。
- en: 'Execute the following line to start the new version of the vehicle remote control
    example on any computer or device that you want to use as the MQTT client and
    uses Linux or macOS:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何您想要用作MQTT客户端并且使用Linux或macOS的计算机或设备上，执行以下行以启动车辆远程控制示例的新版本：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In Windows, you must execute the following line:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，您必须执行以下行：
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You will note that the timing between the send commands and the processed commands
    is clearer because the time at which the network events are processed is more
    accurate in the new version.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到发送命令和处理命令之间的时间更清晰，因为新版本中处理网络事件的时间更准确。
- en: Test your knowledge
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的知识
- en: 'Let''s see whether you can answer the following questions correctly:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看您是否能正确回答以下问题：
- en: Which of the following methods of the `paho.mqtt.client.Client` instance blocks
    execution and ensures communication with the MQTT server is carried out?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`paho.mqtt.client.Client`实例的以下哪种方法会阻塞执行并确保与MQTT服务器的通信进行？'
- en: '`loop`'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loop`'
- en: '`loop_start`'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loop_start`'
- en: '`blocking_loop`'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阻塞循环
- en: Which of the following methods of the `paho.mqtt.client.Client` instance starts
    a new thread and ensures communication with the MQTT server is carried out?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`paho.mqtt.client.Client`实例的以下哪种方法会启动一个新线程，并确保与MQTT服务器的通信进行？'
- en: '`loop`'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loop`'
- en: '`loop_start`'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loop_start`'
- en: '`non_blocking_loop`'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`non_blocking_loop`'
- en: Which of the following methods of the `paho.mqtt.client.Client` instance configures
    a last will message to be sent to the MQTT server if the client disconnects unexpectedly?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`paho.mqtt.client.Client`实例的以下哪种方法配置了一个遗嘱消息，以便在客户端意外断开连接时发送到MQTT服务器？'
- en: '`last_will_publish`'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`last_will_publish`'
- en: '`last_will_message`'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`last_will_message`'
- en: '`will_set`'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`will_set`'
- en: Which of the following methods of the `paho.mqtt.client.Client` instance stops
    the thread that is running the threaded client interface?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`paho.mqtt.client.Client`实例的以下哪种方法停止运行线程化客户端接口的线程？'
- en: '`loop_end`'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loop_end`'
- en: '`non_blocking_loop_stop`'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`non_blocking_loop_stop`'
- en: '`loop_stop`'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loop_stop`'
- en: Which of the following methods is non-blocking?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪种方法是非阻塞的？
- en: '`loop_start`'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loop_start`'
- en: '`non_blocking_loop`'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`non_blocking_loop`'
- en: '`loop_forever`'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loop_forever`'
- en: The right answers are included in the [Appendix](d9cf708f-f027-4bfa-a2d2-9fd3653165d9.xhtml), *Solutions*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案包含在[附录](d9cf708f-f027-4bfa-a2d2-9fd3653165d9.xhtml)中，*解决方案*。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we processed commands received as JSON strings within MQTT
    messages with Python code. Then, we coded a Python client that composed and published
    messages with commands to work as a remote control application for the vehicle
    controller.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用Python代码处理接收的JSON字符串作为MQTT消息中的命令。然后，我们编写了一个Python客户端，用于组合和发布带有命令的消息，以作为车辆控制器的远程控制应用程序。
- en: We worked with the blocking network loop and then we converted the application
    to use the threaded client interface to avoid blocking the main thread. We took
    advantage of the last will and testament feature to make sure a controlled vehicle
    parks in a safe place whenever a connection is lost. Then, we worked with retained
    last will messages.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了阻塞网络循环，然后将应用程序转换为使用线程化的客户端接口，以避免阻塞主线程。我们利用了遗嘱功能，以确保在连接丢失时受控车辆停在安全位置。然后，我们处理了保留的遗嘱消息。
- en: Now that we understand how to use Python to work with multiple MQTT applications
    that take advantage of advanced features, we will use a cloud-based real-time
    MQTT provider to monitor a surfing completion in which we will need to receive
    and process data from multiple sensors, which is what we are going to discuss
    in [Chapter 6](dc244927-5db3-4108-a486-fa7f17f5f3ba.xhtml), *Monitoring a surfing
    competition with cloud-based real-time MQTT providers and Python*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了如何使用Python来处理利用高级功能的多个MQTT应用程序，我们将使用基于云的实时MQTT提供程序来监视冲浪比赛，我们需要从多个传感器接收和处理数据，这就是我们将在[第6章](dc244927-5db3-4108-a486-fa7f17f5f3ba.xhtml)中讨论的内容，《使用基于云的实时MQTT提供程序和Python监视冲浪比赛》。
