- en: 'Chapter 4. Stacks: LIFO Collections'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：栈：后进先出集合
- en: A **stack** is an abstract data structure that serves as a collection of objects
    that are inserted and removed based on a **last-in first-out** (**LIFO**) principle.
    Accordingly, the two operations that most clearly define a stack structure are
    **push**, which adds objects to the collection, and **pop**, which removes objects
    from the collection. Other common operations include peek, clear, count, empty
    and full, all of which will be examined in the Advanced topics section later in
    this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**栈**是一种抽象数据结构，它作为一个基于**后进先出**（**LIFO**）原则插入和删除对象的集合。因此，最清楚地定义栈结构的是**push**操作，它向集合中添加对象，以及**pop**操作，它从集合中移除对象。其他常见操作包括peek、clear、count、empty和full，所有这些将在本章后面的高级主题部分进行探讨。'
- en: Stacks can be either array-based or linked list-based. And, similar to linked
    lists, stacks can be either sorted or unsorted. Considering the structure of a
    linked list, a linked list-based stack will be more efficient for sorting operations
    than an array-based stack.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 栈可以是基于数组或基于链表的。同样，类似于链表，栈可以是排序的或未排序的。考虑到链表的结构，基于链表的栈在排序操作上比基于数组的栈更有效率。
- en: A stack data structure is well suited for any application that requires the
    ability to add and remove objects only from the tail of a list. A good example
    of this is backtracking along a specified path or series of operations. If the
    application allows for adding or removing data from any point within the collection,
    then a linked list would be a better choice than the data structures we have already
    examined.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 栈数据结构非常适合任何需要仅从列表尾部添加和移除对象的应用程序。一个很好的例子是沿着指定的路径或一系列操作进行回溯。如果应用程序允许在集合的任何位置添加或移除数据，那么与我们已经考察过的数据结构相比，链表将是一个更好的选择。
- en: 'In this chapter we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Definition of a Stack data structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈数据结构的定义
- en: Initializing stacks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化栈
- en: 'Case study: motion planning algorithm'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究：运动规划算法
- en: Stack implementations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈实现
- en: Common stack operations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见栈操作
- en: Array-based stacks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于数组的栈
- en: List-based stacks
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于列表的栈
- en: Searching
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索
- en: Initializing stacks
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化栈
- en: Each language provides varying levels of support for the stack data structure.
    The following are some examples of initializing the collection, adding an object
    to the collection, and then removing the top object from the collection.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每种语言都为栈数据结构提供了不同级别的支持。以下是一些初始化集合、向集合中添加对象以及从集合中移除顶部对象的示例。
- en: '**C#**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: C# provides a concrete implementation of the stack data structure through the
    `Stack<T>` generic class.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: C# 通过 `Stack<T>` 泛型类提供了栈数据结构的具体实现。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Java**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: Java provides a concrete implementation of the stack data structure through
    the `Stack<T>` generic class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Java 通过 `Stack<T>` 泛型类提供了栈数据结构的具体实现。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Objective-C**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: Objective-C does not provide a concrete implementation of the stack data structure,
    but one can be easily creating using the class cluster `NSMutableArray`. Be aware
    that this will create an array-based implementation of the stack, which is generally
    less efficient than a linked list-based implementation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 没有提供栈数据结构的具体实现，但可以通过类簇 `NSMutableArray` 轻易地创建。请注意，这将创建一个基于数组的栈实现，这通常比基于链表的实现效率低。
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: UINavigationController
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UINavigationController
- en: It's not entirely accurate to state that Objective-C does not provide a stack
    data structure. Any amount of iOS programming in Objective-C will immediately
    expose a developer to an implementation of the stack data structure through use
    of the `UINavigationController` class.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 说不提供栈数据结构并不完全准确。任何Objective-C的iOS编程都会立即让开发者通过使用`UINavigationController`类接触到栈数据结构的实现。
- en: The `UINavigationController` class manages the navigation stack, which is an
    array-based stack of view controllers. The class exposes several methods corresponding
    to the basic stack operations. These include `pushViewController:animated:` (*push*),
    `popViewControllerAnimated:` (*pop*), `popToRootViewControllerAnimated:` (*clear*...sort
    of), and `topViewController:` (*peek*). The navigation stack is never *empty*
    unless it is a *nil* object, and it can only be considered *full* when your app
    adds so many view controllers that the device runs out of system resources.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`UINavigationController` 类管理导航堆栈，这是一个基于视图控制器数组的堆栈。该类公开了几个对应于基本堆栈操作的方法。这些包括
    `pushViewController:animated:` (*push*), `popViewControllerAnimated:` (*pop*),
    `popToRootViewControllerAnimated:` (*clear*...sort of), 和 `topViewController:`
    (*peek*)。导航堆栈永远不会是 *empty*，除非它是一个 *nil* 对象，并且只有当你的应用添加了如此多的视图控制器以至于设备耗尽系统资源时，它才能被认为是
    *full*。'
- en: Since this is an array-based implementation, you can get the *count* of the
    stack by simply examining `count` on the collection itself. However, this is not
    a collection class you can use for just any purpose in your application. If you
    need a stack for more general circumstances, you are going to need to build one
    of your own.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个基于数组的实现，你可以通过简单地检查集合本身的 `count` 来获取堆栈的 *count*。然而，这不是你可以用于应用中任何目的的集合类。如果你需要一个适用于更一般情况的堆栈，你需要自己构建一个。
- en: '**Swift**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Like Objective-C, Swift does not provide a concrete implementation of the stack
    data structure, but the Array class does expose some stack-like operations. The
    following example demonstrates the `popLast()` method, which removes and returns
    the last object in the array:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Objective-C 一样，Swift 没有提供堆栈数据结构的具体实现，但 Array 类确实公开了一些类似堆栈的操作。以下示例演示了 `popLast()`
    方法，它移除并返回数组中的最后一个对象：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Stack operations
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆栈操作
- en: Not all implementations of stack data structures expose the same operational
    methods. However, the more common operations should be available or made available
    as needed by the developer. Each of these operations, whether they are part of
    an array-based implementation or a linked list-based one, have an operational
    cost of **O**(*1*).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有堆栈数据结构的实现都公开相同的操作方法。然而，更常见的操作应该可用或根据开发者的需要提供。这些操作中的每一个，无论是基于数组实现还是基于链表实现，都有
    **O**(*1*) 的操作成本。
- en: '**push**: The push operation adds a new object onto the stack by either appending
    to the collection, if it is array-based, or adding a new node to the collection
    if it is linked list-based.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**push**：push 操作通过向集合追加（如果它是基于数组的）或向集合添加新节点（如果它是基于链表的）来将新对象添加到堆栈中。'
- en: '**pop**: The pop operation is the opposite of push. In most implementations,
    the pop operation both removes and returns the top object off the stack to the
    caller.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pop**：pop 操作是 push 的反操作。在大多数实现中，pop 操作既移除也返回堆栈顶部的对象给调用者。'
- en: '**peek**: The peek operation returns the top object off the stack to the caller,
    but does not remove the object from the collection.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**peek**：peek 操作返回堆栈顶部的对象给调用者，但不从集合中移除该对象。'
- en: '**clear**: The clear operation removes all objects from the stack, effectively
    resetting the collection to the empty state.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**clear**：clear 操作从堆栈中移除所有对象，有效地将集合重置为空状态。'
- en: '**count**: The count operation, sometimes referred to as size or length, returns
    the total number of objects in the collection.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**count**：count 操作，有时也称为大小或长度，返回集合中对象的总数。'
- en: '**empty**: The empty operation typically returns a Boolean value denoting whether
    the collection has any objects.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**empty**：empty 操作通常返回一个布尔值，表示集合是否有任何对象。'
- en: '**full**: The full operation typically returns a Boolean value denoting whether
    the collection is at capacity or if there is still room to add more objects.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**full**：full 操作通常返回一个布尔值，表示集合是否已满或是否还有空间添加更多对象。'
- en: 'Case study: motion planning algorithm'
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究：运动规划算法
- en: '**Business problem**: An industrial engineer programs a robotic manufacturing
    device to insert bolts in sequential receptacles on a widget, then attach and
    tighten nuts onto each bolt. The robot carriers a different tool for each operation,
    and can switch between them automatically on command. However, the process of
    switching between tools adds considerable time to the overall workflow, especially
    when the tool is switched back and forth over each bolt. This has been identified
    as a source of inefficiency, and the engineer wants to improve the speed of the
    process, reducing the overall time required to complete each unit.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**商业问题**：一位工业工程师编程一个机器人制造设备，以在部件的顺序接收器中插入螺栓，然后在每个螺栓上安装并拧紧螺母。机器人携带每个操作不同的工具，并且可以在命令下自动在它们之间切换。然而，在工具之间切换的过程增加了整体工作流程的相当多的时间，尤其是在工具在每一个螺栓上反复切换时。这已被确定为效率低下的一个来源，工程师希望提高该过程的速度，减少完成每个单元所需的总时间。'
- en: In order to eliminate the latency introduced by switching between tools repeatedly,
    the engineer decides to program the robot to install all of the bolts first, and
    then switch tools before returning and installing all of the nuts. To further
    improve performance, he does not want the robot to reset to it's original starting
    position, but instead he wants it to retrace it's own steps while installing the
    nuts. By removing the reset before installing the nuts, his workflow eliminates
    two additional traversals across the widget. To accomplish his goals, the engineer
    needs to store the commands used to move the robot across the widget while inserting
    the bolts, and then play them back in reverse order.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除反复切换工具引入的延迟，工程师决定编程机器人先安装所有的螺栓，然后再切换工具，返回并安装所有的螺母。为了进一步提高性能，他不想让机器人重置到它原来的起始位置，而是希望它在安装螺母的同时重走自己的步骤。通过在安装螺母之前移除重置，他的工作流程消除了在部件上跨越的两个额外的遍历。为了实现他的目标，工程师需要存储在插入螺栓时移动机器人跨越部件的命令，然后以相反的顺序播放它们。
- en: Due to the nature of the data and the application, the class that represents
    the commands will need several basic pieces of functionality. First, it requires
    some mechanism for adding and removing commands as part of normal operation, as
    well as the ability to reset the system when the workflow encounters an error.
    In the case of a reset, the class must be able to report the count of commands
    currently waiting to be executed in order to account for inventory loss. Finally,
    the class should be able to easily report when the command list is at capacity
    or when the commands have all been completed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据和应用的本质，表示命令的类将需要几个基本的功能。首先，它需要一个机制来添加和删除命令作为正常操作的一部分，以及在工作流程遇到错误时能够重置系统。在重置的情况下，该类必须能够报告当前等待执行命令的数量，以便计算库存损失。最后，该类应该能够轻松报告当命令列表达到容量或所有命令都已完成时。
- en: '**C#**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'As we have seen in the prior implementation examples, C# conveniently exposes
    a stack data structure through the `Stack<T>` class. There follows an example
    of what a simple implementation in C# might look like:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在先前的实现示例中所看到的，C#通过`Stack<T>`类方便地公开了一个堆栈数据结构。以下是一个简单的C#实现的示例：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our class declares two fields. The first is `_commandStack`, which represents
    our stack data structure and the core of this class. The field is publicly visible
    but can only be modified by the methods within our class. The second field is
    `_capacity`. This field maintains our caller-defined maximum number of commands
    in the collection. Finally, the constructor initializes `_commandStack` and assigns
    `commandCapacity` to `_capacity`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了两个字段。第一个是`_commandStack`，它代表我们的堆栈数据结构，也是这个类的核心。该字段是公开可见的，但只能由我们类中的方法修改。第二个字段是`_capacity`。该字段维护我们的调用者定义的集合中命令的最大数量。最后，构造函数初始化`_commandStack`并将`commandCapacity`分配给`_capacity`。
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our first order of business is to establish some validation for our collection.
    The first validation method, `IsFull()`, checks if our stack has reached it's
    capacity. Since our business rules state that the robot must backtrack through
    all of its commands before it can proceed to a new widget, we will always track
    the number of commands that are being added into our collection. If for whatever
    reason we find that we have exceeded the pre-defined capacity for `_commandStack`,
    something has gone wrong during the previous backtracking operation and must be
    addressed. Therefore, we check that `_commandStack.Count` is greater than or equal
    to `_capacity` and return the value. `IsEmpty()` is the next validation method.
    This method must be called prior to any operations that could attempt to read
    from our stack by *peeking* at the collection. Both of these operations have an
    **O**(*1*) cost.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是验证我们的集合。第一个验证方法`IsFull()`检查我们的栈是否已达到其容量。由于我们的业务规则规定，机器人必须在进入新部件之前回溯所有命令，因此我们将始终跟踪添加到我们的集合中的命令数量。如果由于任何原因我们发现我们已超过预定义的`_commandStack`容量，那么在之前的回溯操作中肯定出了问题，必须解决。因此，我们检查`_commandStack.Count`是否大于或等于`_capacity`并返回该值。`IsEmpty()`是下一个验证方法。在尝试通过*查看*集合读取我们的栈的任何操作之前，必须调用此方法。这两个操作的成本都是**O**(*1*)。
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `PerformCommand(Command)` method provides the *push* functionality of our
    class. It accepts a single parameter of type `Command`, then checks if `_commandStack`
    is full. If it is full, the `PerformCmmand()` method returns `false`. Otherwise,
    we add `command` to our collection by calling the `Stack<T>.Push()` method. Then
    the method returns `true` to the caller. This operation has an **O**(*1*) cost.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`PerformCommand(Command)`方法提供了我们类的*推送*功能。它接受一个类型为`Command`的单个参数，然后检查`_commandStack`是否已满。如果已满，`PerformCommand()`方法返回`false`。否则，我们通过调用`Stack<T>.Push()`方法将`command`添加到我们的集合中。然后方法返回`true`给调用者。此操作的成本是**O**(*1*)。'
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In case the caller has a script of commands that can be executed successively,
    our class includes the `PerformCommands(List<Command>)` class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用者有一个可以连续执行的命令脚本，我们的类包括`PerformCommands(List<Command>)`类。
- en: The `PerformCommands()` method accepts a list of commands, and inserts them
    sequentially into our collection by calling `PerformCommand()`. This operation
    has an **O**(*n*) cost, where *n* is the number of elements in `commands`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`PerformCommands()`方法接受一个命令列表，并通过调用`PerformCommand()`按顺序将它们插入到我们的集合中。此操作的成本是**O**(*n*)，其中*n*是`commands`中的元素数量。'
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `UndoCommand()` method provides the *pop* functionality of our class. It
    takes no parameters, but pops the last `Command` from our stack by calling `Stack<T>.Pop()`.
    The `Pop()` method removes the last `Command` from our `_commandStack` collection
    and returns it. If `_commandStack` is empty, `Pop()` returns a `null` object.
    This behavior actually works to our advantage, at least within the scope of this
    block of code. Since the `UndoCommand()` method is designed to return an instance
    of `Command`, we would be forced to return `null` anyway if `_commandStack` were
    empty. Therefore, it would be a waste of time to first check `IsEmpty()` before
    calling `Pop()`. This operation has an **O**(*1*) cost.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`UndoCommand()`方法提供了我们类的*弹出*功能。它不接受任何参数，但通过调用`Stack<T>.Pop()`从我们的栈中弹出最后一个`Command`。`Pop()`方法从我们的`_commandStack`集合中移除最后一个`Command`并返回它。如果`_commandStack`为空，`Pop()`返回一个`null`对象。这种行为实际上对我们有利，至少在这个代码块的作用域内是这样。由于`UndoCommand()`方法被设计为返回一个`Command`实例，如果`_commandStack`为空，我们无论如何被迫返回`null`。因此，在调用`Pop()`之前首先检查`IsEmpty()`将是浪费时间。此操作的成本是**O**(*1*)。'
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The final pair of methods of our `CommandStack` class, `Reset()` and `TotalCommands()`,
    provide the *clear* functionality and the *count* functionality, respectively.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`CommandStack`类的最后两种方法，`Reset()`和`TotalCommands()`，分别提供了*清晰*的功能和*计数*的功能。
- en: '**Java**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'As seen in the prior implementation examples, Java also exposes a stack data
    structure through the `Stack<E>` class, which is an extension of `Vector<E>` including
    five methods that allow it to operate as a class. However, the Java documentation
    for `Stack<E>` recommends that you should use `Deque<E>` in favor of `Stack<E>`.
    However, since we will be evaluating `Queue<E>` and `Deque<E>` in [Chapter 5](part0033_split_000.html#VF2I1-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 5. Queues: FIFO Collections"), *Queues: FIFO Collections*, we will use
    the `Stack<E>` class here. Here''s an example of what a simple implementation
    in Java might look like:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的实现示例所示，Java 也通过 `Stack<E>` 类公开了一个栈数据结构，它是 `Vector<E>` 的扩展，包括五个方法，允许它作为一个类操作。然而，`Stack<E>`
    的 Java 文档建议您使用 `Deque<E>` 而不是 `Stack<E>`。然而，由于我们将在 [第 5 章](part0033_split_000.html#VF2I1-77f2b5b248f04368a6f723b0e9357ef3
    "第 5 章。队列：FIFO 集合") 中评估 `Queue<E>` 和 `Deque<E>`，即 *队列：FIFO 集合*，因此我们将在此处使用 `Stack<E>`
    类。以下是一个简单的 Java 实现示例：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our class declares three fields. The first is `_commandStack`, which represents
    our stack data structure and the core of this class. The field is private, but
    we also declare a publicly visible getter called `GetCommandStack()`. This is
    necessary because only methods within our class should be able to modify the collection.
    The second field is `_capacity`. This field maintains our caller-defined maximum
    number of commands in the collection. Finally, the constructor initializes `_commandStack`
    and assigns `commandCapacity` to `_capacity`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们类声明了三个字段。第一个是 `_commandStack`，它代表我们的栈数据结构，也是这个类的核心。该字段是私有的，但我们还声明了一个公开可见的获取器
    `GetCommandStack()`。这是必要的，因为只有我们类中的方法应该能够修改这个集合。第二个字段是 `_capacity`。该字段维护我们的调用者定义的集合中的最大命令数。最后，构造函数初始化
    `_commandStack` 并将 `commandCapacity` 赋值给 `_capacity`。
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Again, we need to establish some validation for our collection at the outset.
    The first validation method, `isFull()`, checks if our stack has reached it's
    capacity. Since our business rules state that the robot must backtrack through
    all of it's commands before it can proceed to a new widget, we will track the
    number of commands that are being added into our collection. If for whatever reason
    we find that we have exceeded the pre-defined capacity for `_commandStack`, something
    has gone wrong during the previous backtracking operation and must be addressed.
    Therefore, we check that `_commandStack.size()` is greater than or equal to `_capacity`
    and return the value. `isEmpty()` is the next validation method. This method must
    be called prior to any operations that could attempt to read from our stack by
    *peeking* at the collection. Both of these operations have an **O**(*1*) cost.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们需要在开始时对我们的集合进行一些验证。第一个验证方法是 `isFull()`，它检查我们的栈是否已达到其容量。由于我们的业务规则规定，机器人必须在其命令全部回溯之后才能继续到新的部件，我们将跟踪添加到我们的集合中的命令数量。如果由于任何原因我们发现我们已超过
    `_commandStack` 的预定义容量，那么在之前的回溯操作中肯定出了问题，必须解决。因此，我们检查 `_commandStack.size()` 是否大于或等于
    `_capacity` 并返回该值。`isEmpty()` 是下一个验证方法。此方法必须在尝试通过 *peek* 集合读取我们的栈的任何操作之前调用。这两个操作的成本都是
    **O**(*1*)。
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `performCommand(Command)` method provides the *push* functionality of our
    class. It accepts a single parameter of type `Command`, then checks if `_commandStack`
    is full. If it is full, `performCmmand()` returns `false`. Otherwise, we add `command`
    to our collection by calling the `Stack<t>.push()` method. Then the method returns
    `true` to the caller. This operation has an **O**(*1*) cost.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`performCommand(Command)` 方法提供了我们类中的 *push* 功能。它接受一个类型为 `Command` 的单个参数，然后检查
    `_commandStack` 是否已满。如果已满，`performCommand()` 返回 `false`。否则，我们通过调用 `Stack<t>.push()`
    方法将 `command` 添加到我们的集合中。然后该方法向调用者返回 `true`。此操作的成本为 **O**(*1*)。'
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In case the caller has a script of commands that can be executed successively
    then our class includes the `performCommands(List<Command>)` method as well.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用者有一个可以连续执行的命令脚本，那么我们的类还包括 `performCommands(List<Command>)` 方法。
- en: The `performCommands()` method accepts a list of commands, and inserts them
    sequentially into our collection by calling `performCommand()`. This operation
    has an **O**(*n*) cost, where *n* is the number of elements in `commands`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`performCommands()` 方法接受一个命令列表，并通过调用 `performCommand()` 依次将它们插入到我们的集合中。此操作的成本为
    **O**(*n*)，其中 *n* 是 `commands` 中元素的数量。'
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `undoCommand()` method provides the *pop* functionality of our class. It
    takes no parameters, but pops the last `Command` from our stack by calling `Stack<E>.pop()`.
    The `pop()` method removes the last `Command` from our `_commandStack` collection
    and returns it. If `_commandStack` is empty, `pop()` returns a `null` object.
    As with the C# example, this behavior works to our advantage within the scope
    of this block of code. Since the `undoCommand()` method is designed to return
    an instance of `Command`, we would be forced to return `null` anyway if `_commandStack`
    were empty. Therefore, it would be a waste of time to first check `isEmpty()`
    before calling `pop()`. This operation has an **O**(*1*) cost.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`undoCommand()` 方法提供了我们类中的 *弹出* 功能。它不接受任何参数，通过调用 `Stack<E>.pop()` 弹出我们栈中的最后一个
    `Command`。`pop()` 方法从我们 `_commandStack` 集合中移除最后一个 `Command` 并返回它。如果 `_commandStack`
    为空，`pop()` 返回一个 `null` 对象。与 C# 示例一样，这种行为在这个代码块的作用域内对我们有利。由于 `undoCommand()` 方法被设计为返回
    `Command` 的一个实例，如果 `_commandStack` 为空，我们无论如何都会被迫返回 `null`。因此，在调用 `pop()` 之前先检查
    `isEmpty()` 是一种浪费时间的操作。这个操作的成本是 **O**(*1*)。'
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The final two methods of our `CommandStack` class, `Reset()` and `TotalCommands()`,
    provide the *clear* and *count* functionalities respectively.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `CommandStack` 类的最后两个方法，`Reset()` 和 `TotalCommands()`，分别提供了 *清除* 和 *计数* 功能。
- en: '**Objective-C**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'As we have seen before (and probably will again before this text is through),
    Objective-C does not expose an explicit concrete implementation of the stack data
    structure, but instead provides the `NSMutableArray` class cluster for this purpose.
    Some could argue that this is a weakness in Objective-C, citing that by not providing
    methods for every conceivable operation that a developer could need is inconvenient.
    On the other hand, one could argue that Objective-C is much more powerful in its
    simplicity, providing the developer with a streamlined API and the basic components
    necessary to build whichever data structure he may require. I will leave you to
    come to your own conclusion on the matter. Meanwhile, here''s an example of what
    a simple implementation in Objective-C might look like:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见（并且很可能在文本结束前还会再次见到），Objective-C 并没有暴露出显式的具体实现栈数据结构，而是提供了 `NSMutableArray`
    类簇来达到这个目的。有些人可能会认为这是 Objective-C 的一个弱点，指出由于没有提供开发者可能需要的每一个可想象的操作的方法，这很不方便。另一方面，也有人可能会认为
    Objective-C 在其简洁性方面要强大得多，为开发者提供了一个简化的 API 和构建所需任何数据结构的基本组件。我将把这个问题的结论留给你自己得出。同时，这里有一个
    Objective-C 中简单实现的例子：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our class declares two **ivar** properties. The first is `_commandStack`, which
    represents our stack data structure and the core of this class. The property is
    private, but we also declare a publicly visible accessor called `commandStack`.
    This is necessary because only methods within our class should be able to modify
    the collection. The second property is `_capacity`. This property maintains our
    caller defined maximum number of commands in the collection. Finally, the constructor
    initializes `_commandStack` and assigns `commandCapacity` to `_capacity`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们类声明了两个 **ivar** 属性。第一个是 `_commandStack`，它代表我们的栈数据结构以及这个类的核心。这个属性是私有的，但我们还声明了一个公开可见的访问器
    `commandStack`。这是必要的，因为只有我们类中的方法应该能够修改这个集合。第二个属性是 `_capacity`。这个属性维护了我们调用者定义的集合中命令的最大数量。最后，构造函数初始化
    `_commandStack` 并将 `commandCapacity` 赋值给 `_capacity`。
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Again, we need to establish some validation for our collection at the outset.
    The first validation method, `isFull:`, checks if our stack has reached it's capacity.
    Since our business rules state that the robot must backtrack through all of it's
    commands before it can proceed to a new widget, we will track the number of commands
    that are being added into our collection. If for whatever reason we find that
    we have exceeded the pre-defined capacity for `_commandStack`, something has gone
    wrong during the previous backtracking operation and must be addressed. Therefore,
    we check that `[_commandStack count]` is greater than or equal to `_capacity`
    and return the value. `isEmpty:` is the next validation method. Both of these
    operations have an **O**(*1*) cost.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们需要在开始时对我们的集合进行一些验证。第一个验证方法 `isFull:` 检查我们的栈是否达到了其容量。由于我们的业务规则指出，机器人必须在其所有命令回溯之后才能继续到新的部件，我们将跟踪被添加到我们集合中的命令数量。如果由于任何原因我们发现我们已超过了
    `_commandStack` 的预定义容量，那么在之前的回溯操作中肯定出了问题，必须得到解决。因此，我们检查 `[_commandStack count]`
    是否大于或等于 `_capacity` 并返回该值。`isEmpty:` 是下一个验证方法。这两个操作的成本都是 **O**(*1*)。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since Objective-C is quite forgiving about passing around `nil` objects, you
    may not even consider `isEmpty:` to be a validation method but more of a property
    in its own right. However, consider that, if this method were declared as a property,
    we would need to declare it as `readonly`, in addition to including the method
    in our implementation file. Otherwise, Objective-C would dynamically generate
    the ivar `_isEmpty` on our behalf, and callers could modify the value directly.
    For the sake of simplicity and clarity, in this case it's better to just declare
    the value as a method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Objective-C 对传递 `nil` 对象相当宽容，你可能甚至不会考虑 `isEmpty:` 是一个验证方法，而更像是它自己的属性。然而，考虑一下，如果这个方法被声明为一个属性，我们除了在实现文件中包含这个方法之外，还需要将其声明为
    `readonly`。否则，Objective-C 会为我们动态生成 ivar `_isEmpty`，调用者可以直接修改这个值。为了简单和清晰起见，在这种情况下，仅仅声明这个值为一个方法会更好。
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `performCommand:` method provides the *push* functionality of our class.
    It accepts a single parameter of type `Command`, then checks if `_commandStack`
    is full. If it is full, `performCmmand:` returns `NO`. Otherwise, we add `command`
    to our collection by calling the `addObject:` method. Then the method returns
    `YES` to the caller. This operation has an **O**(*1*) cost.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`performCommand:` 方法提供了我们类中的 *推送* 功能。它接受一个类型为 `Command` 的单个参数，然后检查 `_commandStack`
    是否已满。如果已满，`performCmmand:` 返回 `NO`。否则，我们通过调用 `addObject:` 方法将 `command` 添加到我们的集合中。然后该方法向调用者返回
    `YES`。这个操作的成本是 **O**(*1*)。'
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In case the caller has a script of commands that can be executed successively,
    our class includes the `performCommands:` class. `performCommands:` accepts an
    array of `EDSCommand` objects, and inserts them sequentially into our collection
    by calling `performCommand:`. This operation has an **O**(n) cost, where *n* is
    the number of elements in `commands`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用者有一个可以连续执行的命令脚本，我们的类包括 `performCommands:` 类。`performCommands:` 接受一个 `EDSCommand`
    对象的数组，并通过调用 `performCommand:` 将它们按顺序插入我们的集合中。这个操作的成本是 **O**(n)，其中 *n* 是 `commands`
    中元素的数量。
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `undoCommand:` method provides the *pop* functionality of our class. Since
    Objective-C does not provide a concrete implementation of the stack structure,
    our class needs to be somewhat creative here. This method grabs the top object
    from the stack by calling `lastObject`, then it removes the command from the collection
    by calling `removeLastObject`. Finally, it returns the `Command` object `c` to
    the caller. This series of calls effectively mimics the *pop* functionality found
    in the concrete stack implementations of C# and Java. Although the method has
    to jump through a hoop or two to get the job done, we are always working with
    the last object in the array so this operation still has an **O**(*1*) cost.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`undoCommand:` 方法提供了我们类中的 *弹出* 功能。由于 Objective-C 没有提供堆栈结构的具体实现，我们的类在这里需要有些创新。这个方法通过调用
    `lastObject` 从堆栈中获取顶部对象，然后通过调用 `removeLastObject` 从集合中移除命令。最后，它将 `Command` 对象
    `c` 返回给调用者。这一系列调用有效地模拟了在 C# 和 Java 的具体堆栈实现中找到的 *弹出* 功能。尽管这个方法需要跳过一些障碍来完成工作，但我们始终在处理数组中的最后一个对象，因此这个操作仍然具有
    **O**(*1*) 的成本。'
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once again, the final pair of methods of our `CommandStack` class, `reset()`
    and `totalCommands()`, provide the *clear* functionality and the *count* functionality,
    respectively. Objective-C rules!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们的 `CommandStack` 类的最后两个方法，`reset()` 和 `totalCommands()`，分别提供了 *清除* 功能和
    *计数* 功能。遵循 Objective-C 规则！
- en: '**Swift**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Like Objective-C, Swift does not expose a concrete implementation of the stack
    data structure, but we can use the mutable, generic `Array` class for this purpose.
    Here''s an example of what a simple implementation in Swift might look like:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Objective-C 一样，Swift 并不直接暴露堆栈数据结构的具体实现，但我们可以使用可变的、通用的 `Array` 类来达到这个目的。以下是一个
    Swift 中简单实现的例子：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our class declares two properties. The first is `_commandStack`, which represents
    our stack data structure and is again the core of this class. The property is
    publicly visible but can only be modified by the methods within our class. The
    second property is `_capacity`. This field maintains our caller defined maximum
    number of commands in the collection. Finally, the constructor initializes `_commandStack`
    and assigns `commandCapacity` to `_capacity`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类声明了两个属性。第一个是 `_commandStack`，它代表我们的堆栈数据结构，并且是这个类的核心。这个属性是公开可见的，但只能由我们类中的方法修改。第二个属性是
    `_capacity`。这个字段维护了我们调用者定义的集合中命令的最大数量。最后，构造函数初始化 `_commandStack` 并将 `commandCapacity`
    赋值给 `_capacity`。
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As with the examples in other languages, we include two validation methods called
    `IsFull()` and `IsEmpty()`. The `IsFull()` method checks if our stack has reached
    it's capacity. Since our business rules state that the robot must backtrack through
    all of it's commands before it can proceed to a new widget, we will track the
    number of commands that are being added into our collection. If for whatever reason
    we find that we have exceeded the pre-defined capacity for `_commandStack`, something
    has gone wrong with the previous backtracking operation and must be addressed.
    Therefore, we check that `_commandStack.count` is greater than or equal to `_capacity`
    and return the value. `IsEmpty()` must be called prior to any operations that
    could attempt to read from our stack by *peeking* at the collection. Both of these
    operations have an **O**(*1*) cost.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言的示例一样，我们包含了两个验证方法，分别称为 `IsFull()` 和 `IsEmpty()`。`IsFull()` 方法检查我们的栈是否达到了其容量。由于我们的业务规则规定，机器人必须在其命令全部回溯之后才能继续到新的部件，我们将跟踪添加到我们集合中的命令数量。如果由于任何原因我们发现我们已超过
    `_commandStack` 的预定义容量，那么之前的回溯操作就出了问题，必须解决。因此，我们检查 `_commandStack.count` 是否大于或等于
    `_capacity` 并返回该值。在尝试从我们的栈中读取操作之前，必须调用 `IsEmpty()`。这两个操作的成本都是 **O**(*1*)。
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `PerformCommand(Command)` method provides the *push* functionality of our
    class. It accepts a single parameter of type `Command`, then checks if `_commandStack`
    is full. If it is full, the `PerformCmmand()` method returns `false`. Otherwise,
    we add `command` to our collection by calling the `Array.append()` method. Then
    the method returns `true` to the caller. This operation has an **O**(*1*) cost.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`PerformCommand(Command)` 方法为我们类提供了 *push* 功能。它接受一个类型为 `Command` 的单个参数，然后检查
    `_commandStack` 是否已满。如果已满，`PerformCmmand()` 方法返回 `false`。否则，我们通过调用 `Array.append()`
    方法将 `command` 添加到我们的集合中。然后方法返回 `true` 给调用者。这个操作的成本是 **O**(*1*)。'
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In case the caller has a script of commands that can be executed successively
    our class includes the `PerformCommands(List<Command>)` class. `PerformCommands()`
    accepts a list of commands, and inserts them sequentially into our collection
    by calling the `PerformCommand()` method. This operation has an **O**(*n*) cost,
    where *n* is the number of elements in `commands`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用者有一个可以连续执行的命令脚本，我们的类包括 `PerformCommands(List<Command>)` 类。`PerformCommands()`
    接受一个命令列表，并通过调用 `PerformCommand()` 方法将这些命令按顺序插入到我们的集合中。这个操作的成本是 **O**(*n*)，其中 *n*
    是 `commands` 中元素的数量。
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `UndoCommand()` method provides the *pop* functionality of our class. It
    takes no parameters, but pops the last `Command` from our stack by calling `Array.popLast()!`
    with the forced unwrapping operator to access the value *wrapped* inside the `return`,
    assuming the object is not `nil`. The `popLast()` method removes the top `Command`
    from our `_commandStack` collection and returns it. If `_commandStack` is empty,
    `popLast()` returns `nil`. As seen in Java and Objective-C, this behavior works
    to our advantage within the scope of this block of code. Since the `UndoCommand()` method
    is designed to return an instance of `Command`, we would be forced to return `nil`
    anyway if `_commandStack` were empty. Therefore, it would be a waste of time to
    first check `IsEmpty()` before calling `popLast()`. This operation has an **O**(*1*)
    cost.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`UndoCommand()` 方法为我们类提供了 *pop* 功能。它不接受任何参数，但通过调用 `Array.popLast()!` 并使用强制解包操作符来访问
    `return` 内部的 *wrapped* 值，从而弹出我们栈中的最后一个 `Command`（假设对象不是 `nil`）。`popLast()` 方法从我们的
    `_commandStack` 集合中移除最顶部的 `Command` 并返回它。如果 `_commandStack` 为空，`popLast()` 返回
    `nil`。正如在 Java 和 Objective-C 中所见，这种行为在我们的代码块范围内对我们有利。由于 `UndoCommand()` 方法被设计为返回
    `Command` 的一个实例，如果 `_commandStack` 为空，我们无论如何都会被迫返回 `nil`。因此，在调用 `popLast()` 之前首先检查
    `IsEmpty()` 是一种浪费时间的行为。这个操作的成本是 **O**(*1*)。'
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The final pair of methods of our `CommandStack` class, `Reset()` and `TotalCommands()`,
    provide the *clear* and *count* functionalities, respectively.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `CommandStack` 类的最后一个方法对，`Reset()` 和 `TotalCommands()`，分别提供了 *clear* 和 *count*
    功能。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **nil coalescing operator**, or **null coalescing operator** as it is termed
    in other languages, is shorthand for the more verbose ternary operator and the
    explicit `if...else` statement. Languages such as C# and Swift designate `??`
    for this operator. Swift goes a step further by including the `!`, or unwrapping
    operator, for cases where a return value is optional, or potentially nil. The
    `??` operator in Swift is necessary for defining a default value when unwrapping
    an **optional** type.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**空合并运算符**，或称为其他语言中的**空合并运算符**，是更冗长的三元运算符和显式的`if...else`语句的简写。例如，C#和Swift将`??`指定为这个运算符。Swift更进一步，包括`!`，或解包运算符，用于返回值是可选的或可能为nil的情况。Swift中的`??`运算符在解包**可选**类型时定义默认值是必要的。'
- en: Advanced topics - stack implementations
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级主题 - 栈实现
- en: Now that we have seen how stacks are used in common practice, lets examine the
    different types of stack implementation you may encounter. The two most common
    implementations are the array-based stack and the linked list-based stack. We
    will examine each of these here.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了栈在常见实践中的应用，让我们来考察你可能会遇到的不同类型的栈实现。最常见的两种实现是基于数组的栈和基于链表的栈。我们将在下面考察每一种。
- en: Array-based stack
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于数组的栈
- en: 'An array-based stack utilizes a mutable array to represent the collection.
    In this implementation, the 0 position in the array represents the *bottom* of
    the stack. Therefore, `array[0]` is the first object pushed onto the stack and
    the last one popped off. Array-based structures are not practical for a sorted
    stack as any reorganizing of the structure would require significantly more operational
    cost than that of a list-based stack. The Tower of Hanoi puzzle is the quintessential
    example of sorting am array-based stack, with an operational cost of **O**(*2^n*),
    where *n* is the number of plates on the starting tower. The Tower of Hanoi puzzle
    will be examined in more detail in [Chapter 12](part0069_split_000.html#21PMQ2-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 12. Sorting: Bringing Order Out Of Chaos"), *Sorting: Bringing Order
    Out Of Chaos*.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 基于数组的栈使用可变数组来表示集合。在这个实现中，数组的0位置代表栈的*底部*。因此，`array[0]`是第一个推入栈中的对象，也是最后一个弹出栈的对象。基于数组的结构对于排序栈来说并不实用，因为任何对结构的重新组织都会比基于列表的栈需要显著更多的操作成本。汉诺塔问题是一个典型的基于数组的排序示例，其操作成本为**O**(*2^n*)，其中*n*是起始塔上的盘子数量。汉诺塔问题将在[第12章](part0069_split_000.html#21PMQ2-77f2b5b248f04368a6f723b0e9357ef3
    "第12章. 排序：从混乱中带来秩序")中更详细地考察，*排序：从混乱中带来秩序*。
- en: Linked list-based stack
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于链表的栈
- en: The linked list-based stack utilizes a pointer to the *bottom* object on the
    stack, and subsequent pointers as each new object is linked from the last object
    in the list. Popping an object from the top of the stack simply involves removing
    the last object from the collection. For applications requiring sorted data, a
    linked list stack is far more efficient.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 基于链表的栈使用一个指向栈中*底部*对象的指针，以及随着每个新对象从列表中的最后一个对象链接而来，后续的指针。从栈顶弹出对象只是简单地从集合中移除最后一个对象。对于需要排序数据的应用，链表栈要高效得多。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we learned the basic definition of the Stack data structure,
    including how to initialize concrete implementations of the structure in each
    of the four languages we are discussing. Next, we discussed the most common operations
    associated with the stack data structure and their operational cost. We examined
    a case study using stacks to track commands passed to a robotic manufacturing
    device. These examples demonstrated how C# and Java provide concrete implementations
    of a stack whereas Objective-C and Swift do not. Finally, we examined the two
    most common types of stacks, the array-based and the linked-list-based, and showed
    how the array-based stack is not well suited for a sorted stack.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了栈数据结构的基本定义，包括如何在所讨论的四种语言中初始化结构的具体实现。接下来，我们讨论了与栈数据结构相关联的最常见操作及其操作成本。我们通过一个案例研究来考察使用栈跟踪传递给机器人制造设备的命令。这些例子展示了C#和Java如何提供栈的具体实现，而Objective-C和Swift则没有。最后，我们考察了两种最常见的栈类型，基于数组和基于链表的，并展示了基于数组的栈不适合用于排序栈。
