- en: Getting More Out of Our Objects with Descriptors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过描述符更充分地利用我们的对象
- en: This chapter introduces a new concept that is more advanced in Python development
    since it features descriptors. Moreover, descriptors are not something programmers
    of other languages are familiar with, so there are no easy analogies or parallelisms
    to make.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一个在Python开发中更为高级的新概念，因为它涉及到描述符。此外，描述符并不是其他语言的程序员熟悉的东西，因此没有简单的类比或类似之处。
- en: Descriptors are another distinctive feature of Python that takes object-oriented
    programming to another level, and their potential allows users to build more powerful
    and reusable abstractions. Most of the time, the full potential of descriptors
    is observed in libraries or frameworks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符是Python的另一个独特特性，它将面向对象编程提升到另一个水平，其潜力允许用户构建更强大和可重用的抽象。大多数情况下，描述符的全部潜力都体现在库或框架中。
- en: 'In this chapter, we will achieve the following goals that relate to descriptors:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现与描述符相关的以下目标：
- en: Understand what descriptors are, how they work, and how to implement them effectively
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解描述符是什么，它们是如何工作的，以及如何有效地实现它们
- en: Analyze the two types of descriptors (data and non-data descriptors), in term
    of their conceptual differences and implementation details
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析两种类型的描述符（数据和非数据描述符），从它们的概念差异和实现细节方面进行分析
- en: Reuse code effectively through descriptors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过描述符有效地重用代码
- en: Analyze examples of good uses of descriptors, and how to take advantage of them
    for our own libraries of APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析描述符的良好使用示例，以及如何利用它们来构建我们自己的API库
- en: A first look at descriptors
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述符的初步了解
- en: First, we will explore the main idea behind descriptors to understand their
    mechanics and internal workings. Once this is clear, it will be easier to assimilate
    how the different types of descriptors work, which we will explore in the next
    section.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探索描述符背后的主要思想，以了解它们的机制和内部工作。一旦这一点清楚，就会更容易吸收不同类型的描述符是如何工作的，我们将在下一节中探讨。
- en: Once we have a first understanding of the idea behind descriptors, we will look
    at an example where their use gives us a cleaner and more Pythonic implementation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对描述符背后的思想有了初步了解，我们将看一个示例，其中它们的使用为我们提供了更清晰和更符合Python风格的实现。
- en: The machinery behind descriptors
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述符背后的机制
- en: The way descriptors work is not all that complicated, but the problem with them
    is that there are a lot of caveats to take into consideration, so the implementation
    details are of the utmost importance here.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符的工作方式并不是很复杂，但它们的问题在于有很多需要考虑的注意事项，因此这里的实现细节至关重要。
- en: In order to implement descriptors, we need at least two classes. For the purposes
    of this generic example, we are going to call the `client` class to the one that
    is going to take advantage of the functionality we want to implement in the `descriptor`
    (this class is generally just a domain model one, a regular abstraction we create
    for our solution), and we are going to call the `descriptor` class to the one
    that implements the logic of the descriptor.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现描述符，我们至少需要两个类。对于这个通用示例，我们将称`client`类为将要利用我们想要在`descriptor`中实现的功能的类（这个类通常只是一个领域模型类，是我们解决方案中创建的常规抽象），我们将称`descriptor`类为实现描述符逻辑的类。
- en: 'A descriptor is, therefore, just an object that is an instance of a class that
    implements the descriptor protocol. This means that this class must have its interface
    containing at least one of the following magic methods (part of the descriptor
    protocol as of Python 3.6+):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，描述符只是一个实现描述符协议的类的实例对象。这意味着这个类必须包含至少一个以下魔术方法（作为Python 3.6+的描述符协议的一部分）的接口：
- en: '`__get__`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__get__`'
- en: '**`__set__`**'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`__set__`**'
- en: '`__delete__`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__delete__`'
- en: '**`__set_name__`**'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`__set_name__`**'
- en: 'For the purposes of this initial high-level introduction, the following naming
    convention will be used:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个最初的高层次介绍，将使用以下命名约定：
- en: '| **Name** | **Meaning** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **含义** |'
- en: '| `ClientClass` | The domain-level abstraction that will take advantage of
    the functionality to be implemented by the descriptor. This class is said to be
    a client of the descriptor.This class contains a class attribute (named `descriptor`
    by this convention), which is an instance of `DescriptorClass`. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `ClientClass` | 将利用要由描述符实现的功能的领域级抽象。这个类被称为描述符的客户端。这个类包含一个类属性（按照惯例命名为`descriptor`），它是`DescriptorClass`的一个实例。
    |'
- en: '| `DescriptorClass` | The class that implements the `descriptor` itself. This
    class should implement some of the aforementioned magic methods that entail the
    descriptor protocol. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `DescriptorClass` | 实现`descriptor`本身的类。这个类应该实现一些前面提到的涉及描述符协议的魔术方法。 |'
- en: '| `client` | An instance of `ClientClass`.`client = ClientClass()` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `client` | `ClientClass`的一个实例。`client = ClientClass()` |'
- en: '| `descriptor` | An instance of `DescriptorClass`.`descriptor = DescriptorClass()`.This
    object is a class attribute that is placed in `ClientClass`. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `descriptor` | `DescriptorClass`的一个实例。`descriptor = DescriptorClass()`。这个对象是一个放置在`ClientClass`中的类属性。
    |'
- en: 'This relationship is illustrated in the following diagram:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关系在下图中得到了说明：
- en: '![](assets/583337dd-c514-4f5d-967b-bd0811b56f7f.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/583337dd-c514-4f5d-967b-bd0811b56f7f.png)'
- en: A very important observation to keep in mind is that for this protocol to work,
    the `descriptor` object has to be defined as a class attribute. Creating this
    object as an instance attribute will not work, so it must be in the body of the
    class, and not in the `init` method.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要牢记的一个非常重要的观察是，为了使这个协议工作，`descriptor`对象必须被定义为一个类属性。将这个对象创建为一个实例属性是行不通的，因此它必须在类的主体中，而不是在`init`方法中。
- en: Always place the `descriptor` object as a class attribute!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 始终将`descriptor`对象放置为一个类属性！
- en: On a slightly critical note, readers can also note that it is possible to implement
    the descriptor protocol partially—not all methods must always be defined; instead,
    we can implement only those we need, as we will see shortly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微批评一下，读者还可以注意到，部分实现描述符协议是可能的——并非所有方法总是必须被定义；相反，我们可以只实现我们需要的方法，我们很快将看到。
- en: So, now we have the structure in place—we know what elements are set and how
    they interact. We need a class for the `descriptor`, another class that will consume
    the logic of the `descriptor`, which, in turn, will have a `descriptor` object
    (an instance of the `DescriptorClass`) as a class attribute, and instances of
    `ClientClass` that will follow the descriptor protocol when we call for the attribute
    named `descriptor`. But now what? How does all of this fit into place at runtime?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了结构——我们知道设置了哪些元素以及它们如何交互。我们需要一个用于`descriptor`的类，另一个将使用`descriptor`逻辑的类，这个类将作为类属性具有`descriptor`对象（`DescriptorClass`的实例），以及在调用名为`descriptor`的属性时将遵循描述符协议的`ClientClass`的实例。但现在呢？所有这些在运行时如何组合在一起？
- en: 'Normally, when we have a regular class and we access its attributes, we simply
    obtain the objects as we expect them, and even their properties, as in the following
    example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们有一个常规类并访问其属性时，我们会按预期获得对象，甚至它们的属性，如下例所示：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: But, in the case of descriptors, something different happens. When an object
    is defined as a class attribute (and this one is a `descriptor`), when a `client`
    requests this attribute, instead of getting the object itself (as we would expect
    from the previous example), we get the result of having called the `__get__` magic
    method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在描述符的情况下，情况有所不同。当一个对象被定义为类属性（并且这是一个`descriptor`）时，当一个`client`请求此属性时，我们不是得到对象本身（正如我们从前面的例子中所期望的那样），而是得到了调用`__get__`魔术方法的结果。
- en: 'Let''s start with some simple code that only logs information about the context,
    and returns the same `client` object:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些仅记录有关上下文的信息并返回相同的`client`对象的简单代码开始：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When running this code, and requesting the `descriptor` attribute of an instance
    of `ClientClass`, we will discover that we are, in fact, not getting an instance
    of `DescriptorClass`, but whatever its `__get__()` method returns instead:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码并请求`ClientClass`实例的`descriptor`属性时，我们将发现实际上并没有得到`DescriptorClass`的实例，而是得到了其`__get__()`方法返回的内容：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how the logging line, placed under the `__get__` method, was called instead
    of just returning the object we created. In this case, we made that method return
    the `client` itself, hence making true a comparison of the last statement. The
    parameters of this method are explained in more detail in the following subsections
    when we explore each method in more detail.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，放置在`__get__`方法下面的日志行被调用，而不是只返回我们创建的对象。在这种情况下，我们让该方法返回`client`本身，从而使最后一条语句的比较成立。在我们更详细地探讨每个方法时，将更详细地解释此方法的参数。
- en: Starting from this simple, yet demonstrative example, we can start creating
    more complex abstractions and better decorators, because the important note here
    is that we have a new (powerful) tool to work with. Notice how this changes the
    control flow of the program in a completely different way. With this tool, we
    can abstract all sorts of logic behind the `__get__` method, and make the `descriptor`
    transparently run all sorts of transformations without clients even noticing.
    This takes encapsulation to a new level.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个简单但有示例性的例子开始，我们可以开始创建更复杂的抽象和更好的装饰器，因为这里的重要说明是我们有了一个新的（强大的）工具来使用。请注意，这如何以完全不同的方式改变了程序的控制流。有了这个工具，我们可以在`__get__`方法背后抽象出各种逻辑，并使`descriptor`在客户端甚至察觉不到的情况下运行各种转换。这将封装提升到一个新的水平。
- en: Exploring each method of the descriptor protocol
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索描述符协议的每个方法
- en: Up until now, we have seen quite a few examples of descriptors in action, and
    we got the idea of how they work. These examples gave us a first glimpse of the
    power of descriptors, but you might be wondering about some implementation details
    and idioms whose explanation we failed to address.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了很多描述符在实际中的例子，并且了解了它们的工作原理。这些例子让我们初步了解了描述符的强大之处，但您可能想知道一些我们未能解释的实现细节和习惯用法。
- en: Since descriptors are just objects, these methods take `self` as the first parameter.
    For all of them, this just means the `descriptor` object itself.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于描述符只是对象，这些方法将`self`作为第一个参数。对于所有这些方法，这只是指`descriptor`对象本身。
- en: In this section, we will explore each method of the descriptor protocol, in
    full detail, explaining what each parameter signifies, and how they are intended
    to be used.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细探讨描述符协议的每个方法，解释每个参数的意义，以及它们的预期用法。
- en: __get__(self, instance, owner)
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: __get__(self, instance, owner)
- en: The first parameter, `instance`, refers to the object from which the `descriptor`
    is being called. In our first example, this would mean the `client` object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`instance`指的是调用`descriptor`的对象。在我们的第一个例子中，这意味着`client`对象。
- en: The `owner` parameter is a reference to the class of that object, which following
    our example (from the previous class diagram in *The machinery behind descriptors*
    section) would be `ClientClass`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`owner`参数是指对象的类，根据我们的例子（来自*描述符背后的机制*部分的上一个类图），将是`ClientClass`。'
- en: From the previous paragraph we conclude that the parameter named `instance`
    in the signature of `__get__` is the object over which the descriptor is taking
    action, and `owner` is the class of `instance`. The avid reader might be wondering
    why is the signature define like this, after all the class can be taken from `instance`
    directly (`owner = instance.__class__`). There is an edge case—when the `descriptor`
    is called from the class (`ClientClass`), not from the instance (`client`), then
    the value of `instance` is `None`, but we might still want to do some processing
    in that case.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的段落中我们得出结论，`__get__`签名中名为`instance`的参数是描述符正在操作的对象，而`owner`是`instance`的类。热心的读者可能会想知道为什么签名会这样定义，毕竟类可以直接从`instance`中获取（`owner
    = instance.__class__`）。这里有一个特殊情况——当从类（`ClientClass`）而不是从实例（`client`）中调用`descriptor`时，`instance`的值是`None`，但在这种情况下我们可能仍然想要进行一些处理。
- en: With the following simple code we can demonstrate the difference of when a descriptor
    is being called from the class, or from an instance. In this case, the `__get__` method
    is doing two separate things for each case.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下简单的代码，我们可以演示当描述符从类或实例中被调用时的区别。在这种情况下，`__get__`方法对每种情况都做了两件不同的事情。
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When we call it from `ClientClass` directly it will do one thing, which is
    composing a namespace with the names of the classes:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们直接从`ClientClass`中调用它时，它会做一件事，即用类的名称组成一个命名空间：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And then if we call it from an object we have created, it will return the other
    message instead:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们从创建的对象中调用它，它将返回另一条消息：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In general, unless we really need to do something with the `owner` parameter,
    the most common idiom, is to just return the descriptor itself, when `instance
    is None`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，除非我们真的需要使用`owner`参数做一些事情，最常见的习惯是当`instance`为`None`时，只返回描述符本身。
- en: __set__(self, instance, value)
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: __set__(self, instance, value)
- en: 'This method is called when we try to assign something to a `descriptor`. It
    is activated with statements such as the following, in which a `descriptor` is
    an object that implements `__set__ ()`**.** The `instance` parameter, in this
    case, would be `client`, and the `value `would be the `"value"` string:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试给`descriptor`赋值时，就会调用这个方法。它会被以下语句激活，其中`descriptor`是一个实现了`__set__()`的对象。在这种情况下，`instance`参数将是`client`，而`value`将是字符串`"value"`：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If `client.descriptor` doesn't implement `__set__()`, then `"value"` will override
    the `descriptor` entirely.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`client.descriptor`没有实现`__set__()`，那么`"value"`将完全覆盖`descriptor`。
- en: Be careful when assigning a value to an attribute that is a descriptor. Make
    sure it implements the `__set__` method, and that we are not causing an undesired
    side effect.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在给描述符属性赋值时要小心。确保它实现了`__set__`方法，并且我们没有引起不希望的副作用。
- en: By default, the most common use of this method is just to store data in an object.
    Nevertheless, we have seen how powerful descriptors are so far, and that we can
    take advantage of them, for example, if we were to create generic validation objects
    that can be applied multiple times (again, this is something that if we don't
    abstract, we might end up repeating multiple times in setter methods of properties).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这个方法最常见的用途就是在对象中存储数据。然而，到目前为止我们已经看到了描述符的强大之处，我们可以利用它们，例如，如果我们要创建可以多次应用的通用验证对象（再次强调，如果我们不进行抽象，可能会在属性的setter方法中重复多次）。
- en: 'The following listing illustrates how we can take advantage of this method
    in order to create generic `validation` objects for attributes, which can be created
    dynamically with functions to validate on the values before assigning them to
    the object:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下清单说明了我们如何利用这个方法来为属性创建通用的`validation`对象，可以使用函数动态创建用于在分配给对象之前验证值的对象：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can see this object in action in the following listing:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下清单中看到这个对象的作用：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The idea is that something that we would normally place in a property can be
    abstracted away into a `descriptor`, and reuse it multiple times. In this case,
    the `__set__()`method would be doing what the `@property.setter` would have been
    doing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是，我们通常会将属性放在属性中的东西抽象成一个`descriptor`，并且可以多次重用它。在这种情况下，`__set__()`方法将会做`@property.setter`本来会做的事情。
- en: __delete__(self, instance)
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: __delete__(self, instance)
- en: 'This method is called upon with the following statement, in which `self` would
    be the `descriptor` attribute, and `instance` would be the `client` object in
    this example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下语句中调用这个方法时，`self`将是`descriptor`属性，`instance`将是这个例子中的`client`对象：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the following example, we use this method to create a `descriptor` with
    the goal of preventing you from removing attributes from an object without the
    required administrative privileges. Notice how, in this case, that the `descriptor`
    has logic that is used to predicate with the values of the object that is using
    it, instead of different related objects:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们使用这个方法来创建一个`descriptor`，目的是防止用户在没有必要的管理权限的情况下删除对象的属性。请注意，在这种情况下，`descriptor`具有用于预测使用它的对象的值的逻辑，而不是不同相关对象的逻辑：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Before seeing examples of how this object works, it's important to remark some
    of the criteria of this descriptor. Notice the `User` class requires the `username`
    and `email` as mandatory parameters. According to its `**__init__**` method, it
    cannot be a user if it doesn't have an `email` attribute. If we were to delete
    that attribute, and extract it from the object entirely we would be creating an
    inconsistent object, with some invalid intermediate state that does not correspond
    to the interface defined by the class `User`.  Details like this one are really
    important, in order to avoid issues. Some other object is expecting to work with
    this `User`, and it also expects that it has an `email` attribute.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到这个对象如何工作的例子之前，重要的是要注意这个描述符的一些标准。注意`User`类要求`username`和`email`作为强制参数。根据其`**__init__**`方法，如果没有`email`属性，它就不能成为用户。如果我们要删除该属性，并从对象中完全提取它，我们将创建一个不一致的对象，其中包含一些无效的中间状态，这些状态与`User`类定义的接口不符。像这样的细节非常重要，以避免问题。其他对象期望与这个`User`一起工作，并且也期望它有一个`email`属性。
- en: For this reason, it was decided that the "deletion" of an email will just simply
    set it to `None`, and that is the part of the code listing that is in bold. For
    the same reason, we must forbid someone trying to set a `None` value to it, because
    that would bypass the mechanism we placed in the `**__delete__**` method.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，决定“删除”电子邮件只会将其简单地设置为`None`，这是代码清单中加粗部分的一部分。出于同样的原因，我们必须禁止有人尝试将`None`值设置为它，因为那样会绕过我们放置在`**__delete__**`方法中的机制。
- en: 'Here, we can see it in action, assuming a case where only users with `"admin"`
    privileges can remove their email address:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到它的作用，假设只有具有“admin”权限的用户才能删除他们的电子邮件地址：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, in this simple `descriptor`, we see that we can delete the email from
    users that contain the `"admin"` permission only. As for the rest, when we try
    to call `del` on that attribute, we will get a `ValueError` exception.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的`descriptor`中，我们可以看到只有包含“admin”权限的用户才能删除用户的电子邮件。至于其他情况，当我们尝试在该属性上调用`del`时，我们将得到一个`ValueError`异常。
- en: In general, this method of the descriptor is not as commonly used as the two
    previous ones, but it is worth showing it for completeness.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，描述符的这种方法并不像前两种方法那样常用，但是出于完整性的考虑，还是值得展示一下。
- en: __set_name__(self, owner, name)
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: __set_name__(self, owner, name)
- en: When we create the `descriptor` object in the class that is going to use it,
    we generally need the `descriptor` to know the name of the attribute it is going
    to be handling.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在将要使用它的类中创建`descriptor`对象时，通常需要`descriptor`知道它将要处理的属性的名称。
- en: This attribute name is the one we use to read from and write to `__dict__` in
    the `__get__` and `__set__` methods, respectively.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性名称是我们在`__get__`和`__set__`方法中从`__dict__`中读取和写入的名称。
- en: Before Python 3.6, the descriptor couldn't take this name automatically, so
    the most general approach was to just pass it explicitly when initializing the
    object. This works fine, but it has an issue in that it requires that we duplicate
    the name every time we want to use the descriptor for a new attribute.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.6之前，描述符无法自动获取这个名称，因此最常见的方法是在初始化对象时显式传递它。这样做没问题，但有一个问题，就是每次我们想要为新属性使用描述符时，都需要重复名称。
- en: 'This is what a typical `descriptor` would look like if we didn''t have this
    method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这个方法，典型的`descriptor`将如下所示：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can see how the `descriptor` uses this value:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`descriptor`如何使用这个值：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, if we wanted to avoid writing the name of the attribute twice (once for
    the variable assigned inside the class, and once again as the name of the first
    parameter of the descriptor), we have to resort to a few tricks, like using a
    class decorator, or (even worse) using a metaclass.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要避免两次写入属性名称（一次是在类内部分配的变量，一次是作为描述符的第一个参数的名称），我们必须求助于一些技巧，比如使用类装饰器，或者（更糟糕的是）使用元类。
- en: In Python 3.6, the new method `__set_name__` was added, and it receives the
    class where that descriptor is being created, and the name that is being given
    to that descriptor. The most common idiom is to use this method for the descriptor
    so that it can store the required name in this method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.6中，添加了新的方法`__set_name__`，它接收正在创建该描述符的类和正在赋予该描述符的名称。最常见的习惯用法是使用这种方法来存储所需的名称。
- en: For compatibility, it is generally a good idea to keep a default value in the
    `__init__` method but still take advantage of `__set_name__`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了兼容性，通常最好在`__init__`方法中保留默认值，但仍然利用`__set_name__`。
- en: 'With this method, we can rewrite the previous descriptors as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个方法，我们可以将前面的描述符重写如下：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Types of descriptors
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述符的类型
- en: Based on the methods we have just explored, we can make an important distinction
    among descriptors in terms of how they work. Understanding this distinction plays
    an important role in working effectively with descriptors, and will also help
    to avoid caveats or common errors at runtime.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们刚刚探讨的方法，我们可以在描述符的工作方式方面进行重要的区分。了解这种区别在有效地使用描述符方面起着重要作用，并且还有助于避免运行时的注意事项或常见错误。
- en: If a descriptor implements the `__set__` or `__delete__` methods, it is called
    a** data descriptor**. Otherwise, a descriptor that solely implements `__get__` is
    a** non-data descriptor***.* Notice that `__set_name__` does not affect this classification
    at all.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果描述符实现了`__set__`或`__delete__`方法，则称为**数据描述符**。否则，仅实现`__get__`的描述符是**非数据描述符**。请注意，`__set_name__`对这一分类没有影响。
- en: When trying to resolve an attribute of an object, a data descriptor will always
    take precedence over the dictionary of the object, whereas a non-data descriptor
    will not**.** This means that in a non-data descriptor if the object has a key
    on its dictionary with the same name as the descriptor, this one will always be
    called, and the descriptor itself will never run. Conversely, in a data descriptor,
    even if there is a key in the dictionary with the same name as the descriptor,
    this one will never be used since the descriptor itself will always end up being
    called.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试解析对象的属性时，数据描述符将始终优先于对象的字典，而非数据描述符则不会。这意味着在非数据描述符中，如果对象的字典中有与描述符相同名称的键，将始终调用该键，并且描述符本身永远不会运行。相反，在数据描述符中，即使字典中有与描述符相同名称的键，也永远不会使用该键，因为描述符本身总是会被调用。
- en: The following two sections explain this in more detail, with examples, in order
    to get a deeper idea of what to expect from each type of descriptor.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个部分将通过示例更详细地解释这一点，以便更深入地了解每种类型的描述符可以期望得到什么。
- en: Non-data descriptors
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非数据描述符
- en: 'We will start with a `descriptor` that only implements the `__get__` method,
    and see how it is used:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从仅实现`__get__`方法的`descriptor`开始，看看它是如何使用的：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As usual, if we ask for the `descriptor`, we get the result of its `__get__`
    method:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，如果我们请求`descriptor`，我们将得到其`__get__`方法的结果：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'But if we change the `descriptor` attribute to something else, we lose access
    to this value, and get what was assigned to it instead:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们将`descriptor`属性更改为其他值，我们将失去对该值的访问，并获得分配给它的值：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, if we delete the `descriptor`, and ask for it again, let''s see what we
    get:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们删除`descriptor`，然后再次请求它，让我们看看我们得到什么：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s rewind what just happened. When we first created the `client` object,
    the `descriptor` attribute lay in the class, not the instance, so if we ask for
    the dictionary of the `client` object, it will be empty:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下刚刚发生的事情。当我们首次创建`client`对象时，`descriptor`属性位于类中，而不是实例中，因此如果我们要求`client`对象的字典，它将是空的：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And then, when we request the `.descriptor` attribute, it doesn't find any key
    in `client.__dict__` named `"descriptor"`, so it goes to the class, where it will
    find it ... but only as a descriptor, hence why it returns the result of the `__get__`
    method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们请求`.descriptor`属性时，在`client.__dict__`中找不到任何名为`"descriptor"`的键，因此它转到类中，在那里找到它……但只是作为描述符，因此返回`__get__`方法的结果。
- en: 'But then, we change the value of the `.descriptor` attribute to something else,
    and what this does is set this into the dictionary of the `instance`, meaning
    that this time it won''t be empty:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们将`.descriptor`属性的值更改为其他值，这样做的效果是将其设置到`instance`的字典中，这意味着这次它不会是空的：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So, when we ask for the `.descriptor` attribute here, it will look for it in
    the object (and this time it will find it, because there is a key named `descriptor`
    in the `__dict__` attribute of the object, as the `vars` result is showing us),
    and return it without having to look for it in the class. For this reason, the
    descriptor protocol is never invoked, and the next time we ask for this attribute,
    it will instead return the value we have overridden it with (`99`).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们在这里请求`.descriptor`属性时，它将在对象中查找它（这次会找到，因为`__dict__`属性中有一个名为`descriptor`的键，正如`vars`结果所显示的），并返回它，而无需在类中查找。因此，从未调用描述符协议，下次我们请求此属性时，它将返回我们已经覆盖的值（`99`）。
- en: 'Afterward, we delete this attribute by calling `del`, and what this does is
    remove the key `"descriptor"` from the dictionary of the object, leaving us back
    in the first scenario, where it''s going to default to the class where the descriptor
    protocol will be activated:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们通过调用`del`删除此属性，这样做的效果是从对象的字典中删除键`"descriptor"，使我们回到第一个场景，它将默认到描述符协议将被激活的类中：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This means that if we set the attribute of the `descriptor` to something else,
    we might be accidentally breaking it. Why? Because the `descriptor` doesn't handle
    the delete action (some of them don't need to).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们将`descriptor`的属性设置为其他值，我们可能会意外地破坏它。为什么？因为`descriptor`不处理删除操作（有些不需要）。
- en: This is called a non-data descriptor because it doesn't implement the `__set__`
    magic method, as we will see in the next example.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为非数据描述符，因为它没有实现`__set__`魔术方法，正如我们将在下一个示例中看到的那样。
- en: Data descriptors
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据描述符
- en: 'Now, let''s look at the difference of using a data descriptor. For this, we
    are going to create another simple `descriptor` that implements the `__set__` method:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用数据描述符的区别。为此，我们将创建另一个实现`__set__`方法的简单`descriptor`：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s see what the value of the `descriptor` returns:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`descriptor`的值返回的是什么：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let''s try to change this value to something else, and see what it returns
    instead:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试将此值更改为其他值，看看它返回的是什么：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The value returned by the `descriptor` didn''t change. But when we assign a
    different value to it, it must be set to the dictionary of the object (as it was
    previously):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`descriptor`返回的值没有改变。但是当我们为其分配不同的值时，它必须设置为对象的字典（就像以前一样）：'
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: So, the `__set__()` method was called, and indeed it did set the value to the
    dictionary of the object, only this time, when we request this attribute, instead
    of using the `__dict__` attribute of the dictionary, the `descriptor` takes precedence
    (because it's an overriding `descriptor`).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`__set__()`方法被调用，确实将值设置到了对象的字典中，但是这次，当我们请求此属性时，不再使用字典的`__dict__`属性，而是使用`descriptor`（因为它是覆盖的`descriptor`）。
- en: 'One more thing—deleting the attribute will not work anymore:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事——删除属性将不再起作用：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The reason is as follows—given that now, the `descriptor` always takes place,
    calling `del` on an object doesn't try to delete the attribute from the dictionary
    (`__dict__`) of the object, but instead it tries to call the `__delete__()` method
    of the `descriptor` (which is not implemented in this example, hence the attribute
    error).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 原因如下——现在，`descriptor`总是生效，调用`del`删除对象的属性时，不会尝试从对象的字典（`__dict__`）中删除属性，而是尝试调用`descriptor`的`__delete__()`方法（在这个例子中没有实现，因此会出现属性错误）。
- en: This is the difference between data and non-data descriptors. If the descriptor
    implements `__set__()`, then it will always take precedence, no matter what attributes
    are present in the dictionary of the object. If this method is not implemented,
    then the dictionary will be looked up first, and then the descriptor will run.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据和非数据描述符之间的区别。如果描述符实现了`__set__()`，那么它将始终优先，无论对象的字典中存在什么属性。如果这个方法没有被实现，那么首先会查找字典，然后再运行描述符。
- en: 'An interesting observation you might have noticed is this line on the `set`
    method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到`set`方法中的这行代码是一个有趣的观察：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There are a lot of things to question about that line, but let's break it down
    into parts.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这行代码有很多问题，但让我们分解成几部分。
- en: First, why is it altering just the name of a `"descriptor"` attribute? This
    is just a simplification for this example, but, as it transpires when working
    with descriptors, it doesn't know at this point the name of the parameter it was
    assigned to, so we just used the one from the example, knowing that it was going
    to be `"descriptor"`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为什么只改变`"descriptor"`属性的名称？这只是一个简化的例子，但是，当使用描述符时，它在这一点上并不知道它被分配的参数的名称，所以我们只是使用了例子中的一个，知道它将是`"descriptor"`。
- en: In a real example, you would do one of two things—either receive the name as
    a parameter and store it internally in the `init` method, so that this one will
    just use the internal attribute, or, even better, use the `__set_name__`method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个真实的例子中，你可以做两件事中的一件——要么接收名称作为参数并在`init`方法中内部存储它，这样这个方法将只使用内部属性，或者更好的是使用`__set_name__`方法。
- en: 'Why is it accessing the `__dict__` attribute of the instance directly? Another
    good question, which also has at least two explanations. First, you might be thinking
    why not just do the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么直接访问实例的`__dict__`属性？另一个很好的问题，至少有两种解释。首先，你可能会想为什么不直接这样做：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Remember that this method (`__set__`) is called when we try to assign something
    to the attribute that is a `descriptor`. So, using `setattr()` will call this
    `descriptor` again, which, in turn, will call it again, and so on and so forth.
    This will end up in an infinite recursion.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们尝试给一个`descriptor`属性赋值时，会调用这个方法（`__set__`）。所以，使用`setattr()`会再次调用这个`descriptor`，然后再次调用，依此类推。这将导致无限递归。
- en: Do not use `setattr()` or the assignment expression directly on the descriptor
    inside the `__set__` method because that will trigger an infinite recursion.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在`__set__`方法内部直接使用`setattr()`或赋值表达式来操作描述符，因为这将触发无限递归。
- en: Why, then, is the descriptor not able to book-keep the values of the properties
    for all of its objects?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么描述符不能记录所有对象的属性值？
- en: The `client` class already has a reference to the descriptor. If we add a reference
    from the descriptor to the `client` object, we are creating circular dependencies,
    and these objects will never be garbage-collected. Since they are pointing at
    each other, their reference counts will never drop below the threshold for removal.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`client`类已经引用了描述符。如果我们从描述符到`client`对象创建一个引用，我们就会创建循环依赖关系，这些对象将永远不会被垃圾回收。因为它们相互指向，它们的引用计数永远不会降到移除的阈值以下。'
- en: A possible alternative here is to use weak references, with the `weakref`module,
    and create a weak reference key dictionary if we want to do that. This implementation
    is explained later on in this chapter, but for the implementations within this
    book, we prefer to use this idiom, since it is fairly common and accepted when
    writing descriptors.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个可能的替代方案是使用弱引用，使用`weakref`模块，并且如果我们想要这样做，创建一个弱引用键字典。这个实现在本章后面有解释，但对于本书中的实现，我们更倾向于使用这种习惯用法，因为在编写描述符时它是相当常见和被接受的。
- en: Descriptors in action
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述符的运作
- en: Now that we have seen what descriptors are, how they work, and what the main
    ideas behind them are, we can see them in action. In this section, we will be
    exploring some situations that can be elegantly addressed through descriptors.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了描述符是什么，它们是如何工作的，以及它们背后的主要思想是什么，我们可以看到它们在实际中的运作。在这一部分，我们将探讨一些可以通过描述符优雅地解决的情况。
- en: Here, we will look at some examples of working with descriptors, and we will
    also cover implementation considerations for them (different ways of creating
    them, with their pros and cons), and finally we will discuss what the most suitable
    scenarios for descriptors are.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看一些使用描述符的例子，并且我们也将涵盖它们的实现考虑因素（创建它们的不同方式，以及它们的优缺点），最后我们将讨论描述符最适合的场景是什么。
- en: An application of descriptors
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述符的应用
- en: We will start with a simple example that works, but that will lead to some code
    duplication. It is not very clear how this issue will be addressed. Later on,
    we will devise a way of abstracting the repeated logic into a descriptor, which
    will address the duplication problem, and we will notice that the code on our
    client classes will be reduced drastically.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的可以工作的例子开始，但这将导致一些代码重复。不太清楚这个问题将如何解决。之后，我们将想出一种将重复逻辑抽象成描述符的方法，这将解决重复问题，我们将注意到我们的客户类上的代码将大大减少。
- en: A first attempt without using descriptors
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首次尝试不使用描述符
- en: The problem we want to solve now is that we have a regular class with some attributes,
    but we wish to track all of the different values a particular attribute has over
    time, for example, in a list. The first solution that comes to our mind is to
    use a property, and every time a value is changed for that attribute in the setter
    method of the property, we add it to an internal list that will keep this trace
    as we want it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要解决的问题是，我们有一个普通的类，有一些属性，但我们希望跟踪特定属性随时间变化的所有不同值，例如，以列表的形式。我们脑海中首先想到的解决方案是使用属性，每当在属性的setter方法中更改值时，我们将其添加到一个内部列表中，以便保持所需的痕迹。
- en: 'Imagine that our class represents a traveler in our application that has a
    current city, and we want to keep track of all the cities that user has visited
    throughout the running of the program. The following code is a possible implementation
    that addresses these requirements:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的类代表应用程序中的一个旅行者，他有一个当前城市，我们希望在程序运行期间跟踪用户访问过的所有城市。以下代码是一个可能的实现，满足这些要求：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can easily check that this code works according to our requirements:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地检查这段代码是否符合我们的要求：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: So far, this is all we need and nothing else has to be implemented. For the
    purposes of this problem, the property would be more than enough. What happens
    if we need the exact same logic in multiple places of the application? This would
    mean that this is actually an instance of a more generic problem—tracing all the
    values of an attribute in another one. What would happen if we want to do the
    same with other attributes, such as keeping track of all tickets Alice bought,
    or all the countries she has been in? We would have to repeat the logic in all
    of these places.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这就是我们需要的一切，不需要实现其他内容。对于这个问题来说，属性已经足够了。如果我们需要在应用程序的多个地方使用完全相同的逻辑会发生什么？这意味着这实际上是一个更通用问题的实例——在另一个属性中跟踪所有值。如果我们想对其他属性执行相同的操作，比如跟踪爱丽丝购买的所有票或她去过的所有国家，会发生什么？我们将不得不在所有这些地方重复逻辑。
- en: Moreover, what would happen if we need this same behavior in different classes?
    We would have to repeat the code or come up with a generic solution (maybe a decorator,
    a property builder, or a descriptor). Since property builders are a particular
    (and more convoluted) case of descriptors, they are beyond of the scope of this
    book, and instead, descriptors are suggested as a cleaner way of proceeding.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们需要在不同的类中具有相同的行为，会发生什么？我们将不得不重复代码或提出一个通用解决方案（也许是装饰器、属性构建器或描述符）。由于属性构建器是描述符的一个特殊（更加复杂）的情况，它超出了本书的范围，因此建议使用描述符作为更清晰的处理方式。
- en: The idiomatic implementation
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 惯用的实现
- en: We will now look at how to address the questions of the previous section by
    using a descriptor that is generic enough as to be applied in any class. Again,
    this example is not really needed because the requirements do not specify such
    generic behavior (we haven't even followed the rule of three instances of the
    similar pattern previously creating the abstraction), but it is shown with the
    goal of portraying descriptors in action.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看如何通过使用一个通用的描述符来解决上一节的问题。再次强调，这个例子实际上并不需要，因为要求并没有指定这种通用行为（我们甚至没有遵循之前创建抽象的相似模式的三个实例的规则），但它展示了描述符的作用目标。
- en: Do not implement a descriptor unless there is actual evidence of the repetition
    we are trying to solve, and the complexity is proven to have paid off.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有实际证据表明我们要解决的重复问题，且复杂性已经证明是值得的，否则不要实现描述符。
- en: Now, we will create a generic descriptor that, given a name for the attribute
    to hold the traces of another one, will store the different values of the attribute
    in a list.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个通用的描述符，给定一个属性名称来保存另一个属性的痕迹，将会把属性的不同值存储在一个列表中。
- en: As we mentioned previously, the code is more than what we need for the problem,
    but its intention is just to show how a descriptor would help us in this case.
    Given the generic nature of descriptors, the reader will notice that the logic
    on it (the name of their method, and attributes) does not relate to the domain
    problem at hand (a traveler object). This is because the idea of the descriptor
    is to be able to use it in any type of class, probably on different projects,
    with the same outcomes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，代码超出了问题的需求，但其意图只是展示描述符如何帮助我们解决问题。由于描述符的通用性，读者会注意到它的逻辑（方法的名称和属性）与手头的领域问题（旅行者对象）无关。这是因为描述符的理念是能够在任何类型的类中使用它，可能是在不同的项目中，产生相同的结果。
- en: 'In order to address this gap, some parts of the code are annotated, and the
    respective explanation for each section (what it does, and how it relates to the
    original problem) is described in the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，代码的一些部分被注释，并且对每个部分的相应解释（它的作用以及它如何与原始问题相关）在下面的代码中描述。
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Some annotations and comments on the code are as follows (numbers in the list
    correspond to the number annotations in the previous listing):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对代码的一些注解和评论如下（列表中的数字对应前面清单中的注解编号）：
- en: The name of the attribute is one of the variables assigned to the `descriptor`,
    in this case, `current_city`. We pass to the `descriptor` the name of the variable
    in which it will store the trace for the variable of the `descriptor`. In this
    example, we are telling our object to keep track of all the values that `current_city`
    has had in the attribute named `cities_visited`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性的名称是分配给`descriptor`的变量之一，在这种情况下是`current_city`。我们将变量的名称传递给`descriptor`，它将存储`descriptor`的变量的痕迹。在这个例子中，我们告诉我们的对象跟踪`current_city`在名为`cities_visited`的属性中的所有值。
- en: The first time we call the `descriptor`, in the `init`, the attribute for tracing
    values will not exist, in which case we initialize it to an empty list to later
    append values to it.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一次调用`descriptor`时，在`init`中，用于跟踪值的属性将不存在，这种情况下，我们将其初始化为空列表，以便稍后向其添加值。
- en: In the `init` method, the name of the attribute `current_city` will not exist
    either, so we want to keep track of this change as well. This is the equivalent
    of initializing the list with the first value in the previous example.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`init`方法中，属性`current_city`的名称也不存在，所以我们也想跟踪这个变化。这相当于在前面的例子中用第一个值初始化列表。
- en: Only track changes when the new value is different from the one that is currently
    set.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有在新值与当前设置的值不同时才跟踪更改。
- en: In the `init` method, the `descriptor` already exists, and this assignment instruction
    triggers the actions from step 2 (create the empty list to start tracking values
    for it), and step 3 (append the value to this list, and set it to the key in the
    object for retrieval later).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`init`方法中，`descriptor`已经存在，这个赋值指令会触发第2步(创建空列表以开始跟踪其值)和第3步(将值附加到此列表，并将其设置为对象中的键以便以后检索)的操作。
- en: The `setdefault` method in a dictionary is used to avoid a `KeyError`. In this
    case an empty list will be returned for those attributes that aren't still available
    (see [https://docs.python.org/3.6/library/stdtypes.html#dict.setdefault](https://docs.python.org/3.6/library/stdtypes.html#dict.setdefault)
    for reference).
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字典中的`setdefault`方法用于避免`KeyError`。在这种情况下，对于尚不可用的属性，将返回一个空列表(参见[https://docs.python.org/3.6/library/stdtypes.html#dict.setdefault](https://docs.python.org/3.6/library/stdtypes.html#dict.setdefault)以供参考)。
- en: It is true that the code in the `descriptor` is rather complex. On the other
    hand, the code in the `client` class is considerably simpler. Of course, this
    balance only pays off if we are going to use this `descriptor` multiple times,
    which is a concern we have already covered.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`descriptor`中的代码确实相当复杂。另一方面，`client`类中的代码要简单得多。当然，只有在我们要多次使用这个`descriptor`时才能实现这种平衡，这是我们已经讨论过的问题。'
- en: What might not be so clear at this point is that the descriptor is indeed completely
    independent from the `client` class. Nothing in it suggests anything about the
    business logic. This makes it perfectly suitable to apply it in any other class;
    even if it does something completely different, the descriptor will take the same
    effect.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上可能不太清楚的是，描述符确实完全独立于`client`类。它没有任何关于业务逻辑的暗示。这使得它完全适用于任何其他类；即使它执行完全不同的操作，描述符也会产生相同的效果。
- en: This is the true Pythonic nature of descriptors. They are more appropriate for
    defining libraries, frameworks, or internal APIs, and not that much for business
    logic.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这才是描述符真正的Python特性。它们更适合于定义库、框架或内部API，而不太适合业务逻辑。
- en: Different forms of implementing descriptors
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现描述符的不同形式
- en: We have to first understand a common issue that's specific to the nature of
    descriptors before thinking of ways of implementing them. First, we will discuss
    the problem of a global shared state, and afterward we will move on and look at
    different ways descriptors can be implemented while taking this into consideration.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑实现描述符的方法之前，我们必须首先了解描述符特有的一个常见问题。首先，我们将讨论全局共享状态的问题，然后我们将继续看看在考虑这一点的情况下可以实现描述符的不同方式。
- en: The issue of global shared state
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局共享状态的问题
- en: As we have already mentioned, descriptors need to be set as class attributes
    to work. This should not be a problem most of the time, but it does come with
    some warnings that need to be taken into consideration.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，描述符需要被设置为类属性才能工作。这在大多数情况下不会成为问题，但它确实需要考虑一些警告。
- en: The problem with class attributes is that they are shared across all instances
    of that class. Descriptors are not an exception here, so if we try to keep data
    in a `descriptor` object, keep in mind that all of them will have access to the
    same value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性的问题在于它们在该类的所有实例之间共享。描述符也不例外，因此，如果我们试图在`descriptor`对象中保留数据，请记住所有这些对象都将访问相同的值。
- en: 'Let''s see what happens when we incorrectly define a `descriptor` that keeps
    the data itself, instead of storing it in each object:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们不正确地定义一个将数据本身保存在`descriptor`中而不是在每个对象中存储时会发生什么：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this example, the `descriptor` object stores the data itself. This carries
    with it the inconvenience that when we modify the value for an `instance` all
    other instances of the same classes are also modified with this value as well.
    The following code listing puts that theory in action:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`descriptor`对象存储数据本身。这带来的不便之处在于，当我们修改一个`instance`的值时，同一类的所有其他实例也会被修改为相同的值。下面的代码清单将这个理论付诸实践：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice how we change one object, and suddenly all of them are from the same
    class, and we can see that this value is reflected. This is because `ClientClass.descriptor`
    is unique; it's the same object for all of them.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何改变一个对象，突然之间所有这些对象都来自同一个类，我们可以看到这个值是如何反映的。这是因为`ClientClass.descriptor`是唯一的；它对于所有这些对象都是相同的对象。
- en: In some cases, this might be what we actually want (for instance, if we were
    to create a sort of Borg pattern implementation, on which we want to share state
    across all objects from a class), but in general, that is not the case, and we
    need to differentiate between objects. Such pattern is discussed with more detail
    in [Ch](dee5b4ed-34cd-4077-a5b4-83d4853e6e56.xhtml)[apter](dee5b4ed-34cd-4077-a5b4-83d4853e6e56.xhtml)
    [9](dee5b4ed-34cd-4077-a5b4-83d4853e6e56.xhtml)*, Common Design Patterns*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这可能是我们实际想要的(例如，如果我们要创建一种共享状态的Borg模式实现，我们希望在一个类的所有对象之间共享状态)，但一般情况下并非如此，我们需要区分对象。这种模式在《[常见设计模式](dee5b4ed-34cd-4077-a5b4-83d4853e6e56.xhtml)》中有更详细的讨论。
- en: To achieve this, the descriptor needs to know the value for each `instance`
    and return it accordingly. That is the reason we have been operating with the
    dictionary (`__dict__`) of each `instance` and setting and retrieving the values
    from there.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，描述符需要知道每个`instance`的值并相应地返回它。这就是我们一直在使用每个`instance`的字典(`__dict__`)并从中设置和检索值的原因。
- en: This is the most common approach. We have already covered why we cannot use
    `getattr()` and `setattr()` on those methods, so modifying the `__dict__` attribute
    is the last standing option, and, in this case, is acceptable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最常见的方法。我们已经讨论过为什么不能在这些方法上使用`getattr()`和`setattr()`，因此修改`__dict__`属性是最后的选择，而在这种情况下是可以接受的。
- en: Accessing the dictionary of the object
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问对象的字典
- en: The way we implement descriptors throughout this book is making the `descriptor`
    object store the values in the dictionary of the object, `__dict__`, and retrieve
    the parameters from there as well.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中实现描述符的方式是让`descriptor`对象将值存储在对象的字典`__dict__`中，并从那里检索参数。
- en: Always store and return the data from the `__dict__` attribute of the instance.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 始终从实例的`__dict__`属性中存储和返回数据。
- en: Using weak references
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用弱引用
- en: Another alternative (if we don't want to use `__dict__`) is to make the `descriptor`
    object keep track of the values for each instance itself, in an internal mapping,
    and return values from this mapping as well.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择（如果我们不想使用`__dict__`）是让`descriptor`对象自己跟踪每个实例的值，在内部映射中返回这些值。
- en: There is a caveat, though. This mapping cannot just be any dictionary. Since
    the `client` class has a reference to the descriptor, and now the descriptor will
    keep references to the objects that use it, this will create circular dependencies,
    and, as a result, these objects will never be garbage-collected because they are
    pointing at each other.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，有一个警告。这个映射不能是任何字典。由于`client`类有一个对描述符的引用，现在描述符将保持对使用它的对象的引用，这将创建循环依赖关系，结果这些对象永远不会被垃圾回收，因为它们互相指向。
- en: In order to address this, the dictionary has to be a weak key one, as defined
    in the `weakref` (WEAKREF 01) module.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，字典必须是一个弱键字典，如`weakref`（WEAKREF 01）模块中定义的那样。
- en: 'In this case, the code for the `descriptor` might look like the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`descriptor`的代码可能如下所示：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This addresses the issues, but it does come with some considerations:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了问题，但也带来了一些考虑：
- en: The objects no longer hold their attributes—the descriptor does instead. This
    is somewhat controversial, and it might not be entirely accurate from a conceptual
    point of view. If we forget this detail, we might be asking the object by inspecting
    its dictionary, trying to find things that just aren't there (calling `vars(client)` will
    not return the complete data, for example).
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象不再持有它们的属性，而是由描述符代替。这在概念上可能有争议，并且从概念上来看可能并不完全准确。如果我们忘记了这个细节，我们可能会通过检查它的字典来询问对象，试图找到根本不存在的东西（例如调用`vars(client)`将不会返回完整的数据）。
- en: It poses the requirement over the objects that they need to be hashable. If
    they aren't, they can't be part of the mapping. This might be too demanding a
    requirement for some applications.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对对象提出了需要是可散列的要求。如果它们不是，它们就不能成为映射的一部分。这对一些应用来说可能是一个要求过于苛刻的要求。
- en: For these reasons, we prefer the implementation that has been shown so far in
    this book, which uses the dictionary of each instance. However, for completeness,
    we have shown this alternative as well.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这些原因，我们更喜欢本书中到目前为止所展示的使用每个实例的字典的实现。然而，为了完整起见，我们也展示了这种替代方法。
- en: More considerations about descriptors
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于描述符的更多考虑
- en: Here, we will discuss general considerations about descriptors in terms of what
    we can do with them when it is a good idea to use them, and also how things that
    we might have initially conceived as having been resolved by means of another
    approach can be improved through descriptors. We will then analyze the pros and
    cons of the original implementation versus the one after descriptors have been
    used.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将讨论关于描述符的一般考虑，包括在何时使用它们是一个好主意，以及我们最初可能认为通过另一种方法解决的问题如何通过描述符得到改进。然后我们将分析原始实现与使用描述符后的实现之间的利弊。
- en: Reusing code
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重用代码
- en: Descriptors are a generic tool and a powerful abstraction that we can use to
    avoid code duplication. The best way to decide when to use descriptors is to identify
    cases where we would be using a property (whether for its `get` logic, `set` logic,
    or both), but repeating its structure many times.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符是一种通用工具和强大的抽象，我们可以使用它们来避免代码重复。决定何时使用描述符的最佳方法是识别我们将使用属性的情况（无论是用于`get`逻辑、`set`逻辑还是两者），但重复其结构多次。
- en: Properties are just a particular case of descriptors (the `@property` decorator
    is a descriptor that implements the full descriptor protocol to define their `get`,
    `set`, and `delete` actions), which means that we can use descriptors for far
    more complex tasks.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 属性只是描述符的一个特例（`@property`装饰器是实现完整描述符协议的描述符，用于定义它们的`get`、`set`和`delete`操作），这意味着我们可以将描述符用于更复杂的任务。
- en: Another powerful type we have seen for reusing code was decorators, as explained
    in [Chapter 5](f5d9c7e4-4092-48de-a22c-564df482b021.xhtml), *Using Decorators
    to Improve Our Code*. Descriptors can help us create to better decorators by making
    sure that they will be able to work correctly for class methods as well.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在重用代码方面看到的另一个强大类型是装饰器，如[第5章](f5d9c7e4-4092-48de-a22c-564df482b021.xhtml)中所解释的那样，*使用装饰器改进我们的代码*。描述符可以帮助我们创建更好的装饰器，确保它们能够正确地为类方法工作。
- en: When it comes to decorators, we could say that it is safe to always implement
    the `__get__()` method on them, and also make it a descriptor. When trying to
    decide whether the decorator is worth creating, consider the three problems rule
    we stated in [Chapter 5](f5d9c7e4-4092-48de-a22c-564df482b021.xhtml), *Using Decorators
    to Improve Our Code*, but note that there are no extra considerations toward descriptors.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在装饰器方面，我们可以说始终在它们上实现`__get__()`方法是安全的，并且也将其作为描述符。在尝试决定是否值得创建装饰器时，考虑我们在[第5章](f5d9c7e4-4092-48de-a22c-564df482b021.xhtml)中提到的三个问题规则，*使用装饰器改进我们的代码*，但请注意，对描述符没有额外的考虑。
- en: As for generic descriptors, besides the aforementioned three instances rule
    that applies to decorators (and, in general, any reusable component), it is advisable
    to also keep in mind that you should use descriptors for cases when we want to
    define an internal API, which is some code that will have clients consuming it.
    This is a feature-oriented more toward designing libraries and frameworks, rather
    than one-time solutions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 至于通用描述符，除了适用于装饰器的前述三个实例规则之外（通常适用于任何可重用组件），还应该记住，当我们想要定义一个内部API时，应该使用描述符，这是一些客户端将使用的代码。这更多地是面向设计库和框架的特性，而不是一次性解决方案。
- en: Unless there is a very good reason to, or that the code will look significantly
    better, we should avoid putting business logic in a descriptor. Instead, the code
    of a descriptor will contain more implementational code rather than business code.
    It is more similar to defining a new data structure or object that another part
    of our business logic will use as a tool.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有非常好的理由，或者代码看起来明显更好，否则我们应该避免在描述符中放入业务逻辑。相反，描述符的代码将包含更多的实现代码，而不是业务代码。这更类似于定义另一部分业务逻辑将用作工具的新数据结构或对象。
- en: In general, descriptors will contain implementation logic, and not so much business
    logic.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，描述符将包含实现逻辑，而不是业务逻辑。
- en: Avoiding class decorators
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免类装饰器
- en: 'If we recall the class decorator we used in [Chapter 5,](f5d9c7e4-4092-48de-a22c-564df482b021.xhtml) *Using
    Decorators to Improve Our Code*, to determine how an event object is going to
    be serialized, we ended up with an implementation that (for Python 3.7+) relied
    on two class decorators:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回想一下我们在[第5章](f5d9c7e4-4092-48de-a22c-564df482b021.xhtml)中使用的类装饰器，*使用装饰器改进我们的代码*，来确定如何序列化事件对象，我们最终得到了一个实现（对于Python
    3.7+）依赖于两个类装饰器的实现：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first one takes the attributes from the annotations to declare the variables,
    whereas the second one defines how to treat each file. Let's see whether we can
    change these two decorators for descriptors instead.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个从注释中获取属性来声明变量，而第二个定义了如何处理每个文件。让我们看看是否可以将这两个装饰器改为描述符。
- en: 'The idea is to create a descriptor that will apply the transformation over
    the values of each attribute, returning the modified version according to our
    requirements (for example, hiding sensitive information, and formatting dates
    correctly):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是创建一个描述符，它将对每个属性的值应用转换，根据我们的要求返回修改后的版本（例如，隐藏敏感信息，并正确格式化日期）：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This `descriptor` is interesting. It was created with a function that takes
    one argument and returns one value. This function will be the transformation we
    want to apply to the field. From the base definition that defines generically
    how it is going to work, the rest of the `descriptor` classes are defined, simply
    by changing the particular function each one needs.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个“描述符”很有趣。它是用一个接受一个参数并返回一个值的函数创建的。这个函数将是我们想要应用于字段的转换。从定义了通用工作方式的基本定义开始，其余的“描述符”类被定义，只需更改每个类需要的特定函数即可。
- en: The example uses `functools.partial` ([https://docs.python.org/3.6/library/functools.html#functools.partial](https://docs.python.org/3.6/library/functools.html#functools.partial))
    as a way of simulating sub-classes, by applying a partial application of the transformation
    function for that class, leaving a new callable that can be instantiated directly.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例使用`functools.partial`（[https://docs.python.org/3.6/library/functools.html#functools.partial](https://docs.python.org/3.6/library/functools.html#functools.partial)）来模拟子类的方式，通过对该类的转换函数进行部分应用，留下一个可以直接实例化的新可调用函数。
- en: 'In order to keep the example simple, we will implement the `__init__()` and
    `serialize()` methods, although they could be abstracted away as well. Under these
    considerations, the class for the event will now be defined as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持示例简单，我们将实现`__init__()`和`serialize()`方法，尽管它们也可以被抽象化。在这些考虑下，事件的类现在将被定义如下：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can see how the object behaves at runtime:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到对象在运行时的行为：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There are some differences with respect to the previous implementation that
    used a decorator. This example added the `serialize()` method and hid the fields before
    presenting them to its resulting dictionary, but if we asked for any of these
    attributes to an instance of the event in memory at any point, it would still
    give us the original value, without any transformation applied to it (we could
    have chosen to apply the transformation when setting the value, and return it
    directly on the `__get__()`, as well).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前使用装饰器的实现相比，这里有一些不同之处。这个例子添加了`serialize()`方法，并在呈现其结果的字典之前隐藏了字段，但是如果我们在内存中的任何时候向事件实例询问这些属性，它仍然会给我们原始值，而不会对其进行任何转换（我们可以选择在设置值时应用转换，并直接在`__get__()`中返回它）。
- en: Depending on the sensitivity of the application, this may or may not be acceptable,
    but in this case, when we ask the object for its `public` attributes, the descriptor
    will apply the transformation before presenting the results. It is still possible
    to access the original values by asking for the dictionary of the object (by accessing
    `__dict__`), but when we ask for the value, by default, it will return it converted.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用程序的敏感性，这可能是可以接受的，也可能是不可以接受的，但在这种情况下，当我们要求对象提供其“public”属性时，描述符将在呈现结果之前应用转换。仍然可以通过访问对象的字典（通过访问`__dict__`）来访问原始值，但是当我们请求值时，默认情况下会返回转换后的值。
- en: In this example, all descriptors follow a common logic, which is defined in
    the base class. The descriptor should store the value in the object and then ask
    for it, applying the transformation it defines. We could create a hierarchy of
    classes, each one defining its own conversion function, in a way that the template
    method design pattern works. In this case, since the changes in the derived classes
    are relatively small (just one function), we opted for creating the derived classes
    as partial applications of the base class. Creating any new transformation field
    should be as simple as defining a new class that will be the base class, which
    is partially applied with the function we need. This can even be done ad hoc,
    so there might be no need to set a name for it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，所有描述符都遵循一个共同的逻辑，这个逻辑是在基类中定义的。描述符应该将值存储在对象中，然后请求它，应用它定义的转换。我们可以创建一个类的层次结构，每个类定义自己的转换函数，以使模板方法设计模式起作用。在这种情况下，由于派生类中的更改相对较小（只有一个函数），我们选择将派生类创建为基类的部分应用。创建任何新的转换字段应该像定义一个新的类那样简单，这个类将是基类，部分应用了我们需要的函数。这甚至可以临时完成，因此可能不需要为其设置名称。
- en: Regardless of this implementation, the point is that since descriptors are objects,
    we can create models, and apply all rules of object-oriented programming to them.
    Design patterns also apply to descriptors. We could define our hierarchy, set
    the custom behavior, and so on. This example follows the OCP, which we introduced
    in [Chapter 4](532e5ff0-6f3d-44a5-b2a9-94c686bbd6ba.xhtml), *The SOLID Principles*,
    because adding a new type of conversion method would just be about creating a
    new class, derived from the base one with the function it needs, without having
    to modify the base class itself (to be fair, the previous implementation with
    decorators was also OCP-compliant, but there were no classes involved for each
    transformation mechanism).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 不管这种实现方式，重点是，由于描述符是对象，我们可以创建模型，并将面向对象编程的所有规则应用于它们。设计模式也适用于描述符。我们可以定义我们的层次结构，设置自定义行为等等。这个例子遵循了我们在[第4章](532e5ff0-6f3d-44a5-b2a9-94c686bbd6ba.xhtml)中介绍的OCP，*SOLID原则*，因为添加新的转换方法类型只需要创建一个新的类，从基类派生出它所需的函数，而无需修改基类本身（公平地说，以前使用装饰器的实现也符合OCP，但没有涉及每种转换机制的类）。
- en: 'Let''s take an example where we create a base class that implements the `__init__()`
    and `serialize()` methods so that we can define the `LoginEvent` class simply
    by deriving from it, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子，我们创建一个基类，实现`__init__()`和`serialize()`方法，这样我们就可以通过继承它来简单地定义`LoginEvent`类，如下所示：
- en: '[PRE39]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Once we achieve this code, the class looks cleaner. It only defines the attributes
    it needs, and its logic can be quickly analyzed by looking at the class for each
    attribute. The base class will abstract only the common methods, and the class
    of each event will look simpler and more compact.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们实现了这段代码，类看起来更清晰。它只定义了它需要的属性，通过查看每个属性的类，可以快速分析其逻辑。基类将仅抽象出共同的方法，每个事件的类看起来更简单、更紧凑。
- en: Not only do the classes for each event look simple, but the descriptor itself
    is very compact and a lot simpler than the class decorators. The original implementation
    with class decorators was good, but descriptors made it even better.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事件的类不仅看起来简单，而且描述符本身也非常紧凑，比类装饰器简单得多。原始的类装饰器实现很好，但描述符使其变得更好。
- en: Analysis of descriptors
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述符的分析
- en: We have seen how descriptors work so far and explored some interesting situations
    in which they contribute to clean design by simplifying their logic and leveraging
    more compact classes.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了描述符是如何工作的，并探索了一些有趣的情况，其中它们通过简化逻辑和利用更紧凑的类来促进清晰的设计。
- en: Up to this point, we know that by using descriptors, we can achieve cleaner
    code, abstracting away repeated logic and implementation details. But how do we
    know our implementation of the descriptors is clean and correct? What makes a
    good descriptor? Are we using this tool properly or over-engineering with it?
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道通过使用描述符，我们可以实现更清晰的代码，抽象掉重复的逻辑和实现细节。但是我们如何知道我们的描述符实现是干净和正确的呢？什么是一个好的描述符？我们是否正确地使用了这个工具，还是过度设计了它？
- en: In this section, we will analyze descriptors in order to answer these questions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析描述符以回答这些问题。
- en: How Python uses descriptors internally
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python如何在内部使用描述符
- en: Referring to the question as to what makes a good descriptor?, a simple answer
    would be that a good descriptor is pretty much like any other good Python object.
    It is consistent with Python itself. The idea that follows this premise is that
    analyzing how Python uses descriptors will give us a good idea of good implementations
    so that we know what to expect from the descriptors we write.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 关于什么是好的描述符的问题，一个简单的答案是，一个好的描述符几乎就像任何其他良好的Python对象一样。它与Python本身一致。遵循这个前提的想法是，分析Python如何使用描述符将给我们一个很好的实现想法，这样我们就知道从我们编写的描述符中可以期望什么。
- en: We will see the most common scenarios where Python itself uses descriptors to
    solve parts of its internal logic, and we will also discover elegant descriptors
    and that they have been there in plain sight all along.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到Python本身使用描述符来解决其内部逻辑的最常见情况，并且我们还将发现优雅的描述符，它们一直就在眼前。
- en: Functions and methods
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和方法
- en: The most resonating case of an object that is a descriptor is probably a function.
    Functions implement the `__get__` method, so they can work as methods when defined
    inside a class.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最引人共鸣的描述符对象案例可能是函数。函数实现了`__get__`方法，因此当在类内定义时，它们可以作为方法工作。
- en: Methods are just functions that take an extra argument. By convention, the first
    argument of a method is named "self", and it represents an instance of the class
    that the method is being defined in. Then, whatever the method does with "self",
    would be the same as any other function receiving the object and applying modifications
    to it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 方法只是多了一个额外参数的函数。按照惯例，方法的第一个参数命名为"self"，它代表正在定义方法的类的实例。然后，方法对"self"的任何操作都与任何其他接收对象并对其进行修改的函数相同。
- en: 'In order words, when we define something like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当我们定义类似这样的东西时：
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It is actually the same as if we define this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这与我们定义以下内容是一样的：
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So, it is just another function, modifying the object, only that it's defined
    inside the class, and it is said to be bound to the object.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它只是另一个函数，修改对象，只是它是在类内部定义的，并且被认为是绑定到对象上。
- en: 'When we call something in the form of this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以这种形式调用某些东西时：
- en: '[PRE42]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Python is, in fact, doing something equivalent to this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Python正在做类似于这样的事情：
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Notice that this is just a syntax conversion that is handled internally by Python.
    The way this works is by means of descriptors.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这只是Python在内部处理的一种语法转换。这种工作方式是通过描述符实现的。
- en: 'Since functions implement the descriptor protocol (see the following listing)
    before calling the method, the `__get__()` method is invoked first, and some transformations
    happen before running the code on the internal callable:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数在调用方法之前实现了描述符协议（请参见以下清单），因此首先调用`__get__()`方法，然后在运行内部可调用对象的代码之前进行一些转换：
- en: '[PRE44]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the `instance.method(...)` statement, before processing all the arguments
    of the callable inside the parenthesis, the `"instance.method"` part is evaluated.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在`instance.method(...)`语句中，在处理括号内可调用对象的所有参数之前，会先评估`"instance.method"`部分。
- en: Since `method` is an object defined as a class attribute, and it has a `__get__`
    method, this is called. What this does is convert the `function` to a method,
    which means binding the callable to the instance of the object it is going to
    work with.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`method`是作为类属性定义的对象，并且具有`__get__`方法，因此会被调用。它的作用是将`function`转换为方法，这意味着将可调用对象绑定到它将要使用的对象的实例上。
- en: Let's see this with an example so that we can get an idea of what Python might
    be doing internally.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看这个，以便我们可以对Python内部可能正在做的事情有一个概念。
- en: 'We will define a callable object inside a class that will act as a sort of
    function or method that we want to define to be invoked externally. An instance
    of the `Method` class is supposed to be a function or method to be used inside
    a different class. This function will just print its three parameters—the `instance`
    that it received (which would be the `self` parameter on the class it''s being
    defined in), and two more arguments. Notice that in the `__call__()` method, the
    `self` parameter does not represent the `instance` of `MyClass`, but instead an
    instance of `Method`. The parameter named `instance` is meant to be a `MyClass`
    type of object:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在类内部定义一个可调用对象，它将充当我们想要定义的函数或方法，以便在外部调用。`Method`类的一个实例应该是在不同类内部使用的函数或方法。这个函数将只打印它的三个参数——它接收到的`instance`（它将是在定义它的类中的`self`参数），以及另外两个参数。请注意，在`__call__()`方法中，`self`参数不代表`MyClass`的实例，而是`Method`的一个实例。名为`instance`的参数应该是`MyClass`类型的对象：
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Under these considerations and, after creating the object, the following two
    calls should be equivalent, based on the preceding definition:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑这些因素并创建对象之后，根据前面的定义，以下两个调用应该是等效的：
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'However, only the first one works as expected, as the second one gives an error:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只有第一个按预期工作，因为第二个会出错：
- en: '[PRE47]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We are seeing the same error we faced with a decorator in [Chapter 5](f5d9c7e4-4092-48de-a22c-564df482b021.xhtml),
    *Using Decorators to Improve Our Code*. The arguments are being shifted to the
    left by one, `instance` is taking the place of `self`, `arg1 `is going to be `instance`,
    and there is nothing to provide for `arg2`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了与[第5章](f5d9c7e4-4092-48de-a22c-564df482b021.xhtml)中装饰器面临的相同错误，*使用装饰器改进我们的代码*。参数向左移动了一个位置，`instance`取代了`self`，`arg1`将成为`instance`，而`arg2`没有提供任何内容。
- en: In order to fix this, we need to make `Method` a descriptor.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要将`Method`作为描述符。
- en: 'This way, when we call `instance.method` first, we are going to call its `__get__()`,
    on which we bind this callable to the object accordingly (bypassing the object
    as the first parameter), and then proceed:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当我们首先调用`instance.method`时，我们将调用它的`__get__()`，然后将这个可调用对象绑定到对象上（绕过对象作为第一个参数），然后继续：
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, both calls work as expected:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这两个调用都按预期工作：
- en: '[PRE49]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: What we did is convert the `function` (actually the callable object we defined
    instead) to a method by using `MethodType` from the `types` module. The first
    parameter of this class should be a callable (`self`*,* in this case, is one by
    definition because it implements `__call__`), and the second one is the object
    to bind this function to.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是通过使用`types`模块中的`MethodType`将`function`（实际上是我们定义的可调用对象）转换为方法。这个类的第一个参数应该是一个可调用对象（在这种情况下是`self`，因为它实现了`__call__`），第二个参数是要将这个函数绑定到的对象。
- en: Something similar to this is what function objects use in Python so they can
    work as methods when they are defined inside a class.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的东西是Python中函数对象使用的，这样它们在类内定义时可以作为方法工作。
- en: Since this is a very elegant solution, it's worth exploring it to keep it in
    mind as a Pythonic approach when defining our own objects. For instance, if we
    were to define our own callable, it would be a good idea to also make it a descriptor
    so that we can use it in classes as class attributes as well.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个非常优雅的解决方案，值得探索一下，以便在定义自己的对象时将其作为Pythonic方法。例如，如果我们要定义自己的可调用对象，也将其作为描述符是一个好主意，这样我们也可以在类中将其用作类属性。
- en: Built-in decorators for methods
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法的内置装饰器
- en: As you might have known from looking at the official documentation (PYDESCR-02),
    all `@property`, `@classmethod`, and `@staticmethod` decorators are descriptors.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能从官方文档（PYDESCR-02）中了解到的，所有的`@property`、`@classmethod`和`@staticmethod`装饰器都是描述符。
- en: 'We have mentioned several times that the idiom makes the descriptor return
    itself when it''s being called from a class directly. Since properties are actually
    descriptors, that is the reason why, when we ask it from the class, we don''t
    get the result of computing the property, but the entire `property object` instead:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次提到，当从类直接调用时，惯用法使描述符返回自身。由于属性实际上是描述符，这就是为什么当我们从类中获取它时，我们得到的不是计算属性的结果，而是整个`property
    object`：
- en: '[PRE50]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: For class methods, the `__get__` function in the descriptor will make sure that
    the class is the first parameter to be passed to the function being decorated,
    regardless of whether it's called from the class directly or from an instance.
    For static methods, it will make sure that no parameters are bound other than
    those defined by the function, namely undoing the binding done by `__get__()`
    on functions that make `self `the first parameter of that function.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类方法，在描述符中的`__get__`函数将确保类是传递给被装饰的函数的第一个参数，无论是直接从类调用还是从实例调用。对于静态方法，它将确保除了函数定义的参数之外不绑定任何参数，即撤消`__get__()`在使`self`成为该函数的第一个参数的函数上所做的绑定。
- en: 'Let''s take an example; we create a `@classproperty` decorator that works as
    the regular `@property` decorator, but for classes instead. With a decorator like
    this one, the following code should be able to work:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子；我们创建一个`@classproperty`装饰器，它的工作方式与常规的`@property`装饰器相同，但是用于类。有了这样一个装饰器，以下代码应该能够工作：
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Slots
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Slots
- en: When a class defines the `__slots__` attribute, it can contain all the attributes
    that the class expects and no more.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类定义了`__slots__`属性时，它可以包含类所期望的所有属性，但不能再多了。
- en: Trying to add extra attributes dynamically to a class that defines `__slots __`will
    result in an `AttributeError`. By defining this attribute, the class becomes static,
    so it will not have a `__dict__` attribute where you can add more objects dynamically.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 试图动态地向定义了`__slots__`的类添加额外的属性将导致`AttributeError`。通过定义这个属性，类变得静态，因此它将没有`__dict__`属性，你无法动态地添加更多的对象。
- en: 'How, then, are its attributes retrieved if not from the dictionary of the object?
    By using descriptors. Each name defined in a slot will have its own descriptor
    that will store the value for retrieval later:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果不是从对象的字典中检索它的属性，它的属性是如何检索的呢？通过使用描述符。在slot中定义的每个名称都将有自己的描述符，它将存储值以便以后检索：
- en: '[PRE52]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: While this is an interesting feature, it has to be used with caution because
    it is taking away the dynamic nature of Python. In general, this ought to be reserved
    only for objects that we know are static, and if we are absolutely sure we are
    not adding any attributes to them dynamically in other parts of the code.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个有趣的特性，但必须谨慎使用，因为它会剥夺Python的动态特性。一般来说，这应该只用于我们知道是静态的对象，并且如果我们绝对确定在代码的其他部分动态地添加任何属性到它们。
- en: As an upside of this, objects defined with slots use less memory, since they
    only need a fixed set of fields to hold values and not an entire dictionary.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 作为其优势，使用slots定义的对象使用的内存更少，因为它们只需要一个固定的字段集来保存值，而不是整个字典。
- en: Implementing descriptors in decorators
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在装饰器中实现描述符
- en: We now understand how Python uses descriptors in functions to make them work
    as methods when they are defined inside a class. We have also seen examples of
    cases where we can make decorators work by making them comply with the descriptor
    protocol by using the `__get__()` method of the interface to adapt the decorator
    to the object it is being called with. This solves the problem for our decorators
    in the same way that Python solves the issue of functions as methods in objects.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在了解了Python如何在函数中使用描述符，使它们在类内部定义时作为方法工作。我们还看到了一些例子，其中我们可以通过使用接口的`__get__()`方法使装饰器遵守描述符协议，从而使装饰器适应被调用的对象。这解决了我们的装饰器的问题，就像Python解决了对象中函数作为方法的问题一样。
- en: The general recipe for adapting a decorator in such a way is to implement the
    `__get__()` method on it and use `types.MethodType` to convert the callable (the
    decorator itself) to a method bound to the object it is receiving (the `instance `parameter
    received by `__get__`).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 调整装饰器的一般方法是在其中实现`__get__()`方法，并使用`types.MethodType`将可调用对象（装饰器本身）转换为绑定到接收到的对象（`__get__`接收的`instance`参数）的方法。
- en: For this to work, we will have to implement the decorator as an object, because
    otherwise, if we are using a function, it will already have a `__get__()` method,
    which will be doing something different that will not work unless we adapt it.
    The cleaner way to proceed is to define a class for the decorator.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，我们将不得不将装饰器实现为一个对象，因为如果我们使用一个函数，它已经有一个`__get__()`方法，除非我们对其进行调整，否则它将执行不同的操作，这将无法工作。更干净的方法是为装饰器定义一个类。
- en: Use a decorator class when defining a decorator that we want to apply to class
    methods, and implement the `__get__()` method on it.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义一个我们想要应用于类方法的装饰器时，使用装饰器类，并在其中实现`__get__()`方法。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Descriptors are a more advanced feature in Python that push the boundaries,
    closer to metaprogramming. One of their most interesting aspects is how they make
    crystal-clear that classes in Python are just regular objects, and, as such, they
    have properties and we can interact with them. Descriptors are, in this sense,
    the most interesting type of attribute a class can have because its protocol facilitates
    more advanced, object-oriented possibilities.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符是Python中更高级的功能，它们推动了边界，更接近元编程。它们最有趣的一个方面是它们清晰地表明Python中的类只是普通对象，因此它们具有属性，我们可以与它们交互。描述符在这个意义上是类可以拥有的最有趣的属性类型，因为它的协议提供了更高级的面向对象的可能性。
- en: We have seen the mechanics of descriptors, their methods, and how all of this
    fits together, making a more interesting picture of object-oriented software design.
    By understanding descriptors, we were able to create powerful abstractions that
    yield clean and compact classes. We have seen how to fix decorators that we want
    to apply to functions and methods, we have understood a lot more about how Python
    works internally, and how descriptors play such a core and critical role in the
    implementation of the language.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了描述符的机制，它们的方法，以及所有这些是如何结合在一起的，从而使面向对象的软件设计更加有趣。通过理解描述符，我们能够创建强大的抽象，产生清晰而紧凑的类。我们已经看到了如何修复我们想要应用于函数和方法的装饰器，我们对Python内部的工作原理有了更多的了解，以及描述符在语言实现中起着核心和关键的作用。
- en: This study of how descriptors are used internally in Python should work as a
    reference to identify good uses of descriptors in our own code, with the goal
    of achieving idiomatic solutions.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关于描述符在Python内部如何使用的研究应该作为一个参考，以便在我们自己的代码中识别描述符的良好用法，从而实现成熟的解决方案。
- en: Despite all of the powerful options that descriptors represent to our advantage,
    we have to keep in mind when to properly make use of them without over-engineering.
    In this line, we have suggested that we should reserve the functionality of descriptors
    for truly generic cases, such as the design of internal development APIs, libraries,
    or frameworks. Another important consideration along these lines is that, in general,
    we should not place business logic in descriptors, but rather logic that implements
    technical functionality to be used by other components that do contain business
    logic.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管描述符代表了我们的优势的强大选项，但我们必须记住何时适当地使用它们而不是过度设计。在这方面，我们建议应该将描述符的功能保留给真正通用的情况，比如内部开发API、库或框架的设计。沿着这些线路的另一个重要考虑因素是，一般来说，我们不应该在描述符中放置业务逻辑，而是放置实现技术功能的逻辑，供其他包含业务逻辑的组件使用。
- en: 'Speaking of advanced functionality, the next chapter also covers an interesting
    and in-depth topic: generators. On the face of it generators are rather simple
    (and most readers are probably already familiar with them), but what they have
    in common with descriptors is that they can also be complex, yield a more advanced
    and elegant design, and make Python a unique language to work with.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到高级功能，下一章还涵盖了一个有趣且深入的主题：生成器。乍一看，生成器相当简单（大多数读者可能已经熟悉它们），但它们与描述符的共同之处在于，它们也可以是复杂的，产生更高级和优雅的设计，并使Python成为一种独特的工作语言。
- en: References
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Here is a list of a few things you can reference for more information:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可以供您参考的信息：
- en: Python's official documentation on descriptors ([https://docs.python.org/3/reference/datamodel.html#implementing-descriptors](https://docs.python.org/3/reference/datamodel.html#implementing-descriptors))
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python关于描述符的官方文档 ([https://docs.python.org/3/reference/datamodel.html#implementing-descriptors](https://docs.python.org/3/reference/datamodel.html#implementing-descriptors))
- en: '*WEAKREF 01*: Python `weakref` module ([https://docs.python.org/3/library/weakref.html](https://docs.python.org/3/library/weakref.html))'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WEAKREF 01*: Python `weakref` 模块 ([https://docs.python.org/3/library/weakref.html](https://docs.python.org/3/library/weakref.html))'
- en: '*PYDESCR-02*: Built-in decorators as descriptors ([https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods](https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods))'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PYDESCR-02*: 内置装饰器作为描述符 ([https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods](https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods))'
