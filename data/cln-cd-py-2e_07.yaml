- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Generators, Iterators, and Asynchronous Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器、迭代器和异步编程
- en: Generators are another one of those features that makes Python a peculiar language
    over more traditional ones. In this chapter, we will explore their rationale,
    why they were introduced in the language, and the problems they solve. We will
    also cover how to address problems idiomatically by using generators, and how
    to make our generators (or any iterable, for that matter) Pythonic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是Python区别于更传统语言的特征之一。在本章中，我们将探讨其原理，为什么它们被引入到语言中，以及它们解决的问题。我们还将介绍如何通过使用生成器以惯用的方式解决问题，以及如何使我们的生成器（或任何可迭代对象）具有Python风格。
- en: We will understand why iteration (in the form of the iterator pattern) is automatically
    supported in the language. From there, we will take another journey and explore
    how generators became such a fundamental feature of Python in order to support
    other functionality, such as coroutines and asynchronous programming.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将理解为什么迭代（以迭代器模式的形式）在语言中得到自动支持。从那里，我们将再次踏上旅程，探索生成器如何成为Python的一个基本特性，以支持其他功能，如协程和异步编程。
- en: 'The goals of this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标如下：
- en: To create generators that improve the performance of our programs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建能够提高我们程序性能的生成器
- en: To study how iterators (and the iterator pattern, in particular) are deeply
    embedded in Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究迭代器（特别是迭代器模式）在Python中如何深入嵌入
- en: To solve problems that involve iteration idiomatically
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了以惯用的方式解决涉及迭代的问题
- en: To understand how generators work as the basis for coroutines and asynchronous
    programming
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解生成器作为协程和异步编程基础的工作原理
- en: To explore the syntactic support for coroutines—`yield from`, `await`, and `async`
    `def`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索对协程的语法支持——`yield from`、`await`和`async def`
- en: Mastering generators will take you a long way in writing idiomatic Python, hence
    the importance of them for this book. In this chapter, we not only study how to
    use generators, but we also explore their internals, in order to deeply understand
    how they work.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 精通生成器将大大提高你编写惯用Python代码的能力，因此它们对于本书的重要性不言而喻。在本章中，我们不仅研究如何使用生成器，还探索其内部机制，以便深入理解它们是如何工作的。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The examples in this chapter will work with any version of Python 3.9 on any
    platform.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例将适用于任何平台上的Python 3.9的任何版本。
- en: The code used in this chapter can be found at [https://github.com/PacktPublishing/Clean-Code-in-Python-Second-Edition](https://github.com/PacktPublishing/Clean-Code-in-Python-Second-Edition).
    The instructions are available in the `README` file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在[https://github.com/PacktPublishing/Clean-Code-in-Python-Second-Edition](https://github.com/PacktPublishing/Clean-Code-in-Python-Second-Edition)找到。说明文档在`README`文件中。
- en: Creating generators
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建生成器
- en: Generators were introduced in Python a long time ago (PEP-255), with the idea
    of introducing iteration in Python while improving the performance of the program
    (by using less memory) at the same time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器在Python中引入已久（PEP-255），其想法是在Python中引入迭代的同时，通过使用更少的内存来提高程序的性能。
- en: The idea of a generator is to create an object that is iterable, and, while
    it's being iterated, will produce the elements it contains, one at a time. The
    main use of generators is to save memory—instead of having a very large list of
    elements in memory, holding everything at once, we have an object that knows how
    to produce each particular element, one at a time, as it is required.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器的想法是创建一个可迭代的对象，在迭代过程中，将逐个产生它包含的元素。生成器的主要用途是节省内存——而不是在内存中保留一个非常大的元素列表，一次性持有所有元素，我们有一个知道如何逐个产生每个特定元素的对象，正如它被需要时。
- en: This feature enables lazy computations of heavyweight objects in memory, in
    a similar manner to what other functional programming languages (Haskell, for instance)
    provide. It would even be possible to work with infinite sequences because the
    lazy nature of generators enables such an option.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能使内存中重载对象的延迟计算成为可能，类似于其他函数式编程语言（例如Haskell）提供的方式。甚至可以处理无限序列，因为生成器的延迟特性使得这种选项成为可能。
- en: A first look at generators
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初识生成器
- en: Let's start with an example. The problem at hand now is that we want to process
    a large list of records and get some metrics and indicators over them. Given a
    large dataset with information about purchases, we want to process it in order
    to get the lowest sale, the highest sale, and the average price of a sale.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从例子开始。现在的问题是我们想要处理大量记录并获取一些关于它们的指标和指标。给定一个包含购买信息的庞大数据集，我们想要处理它以获取最低销售额、最高销售额和平均销售价格。
- en: 'For the simplicity of this example, we will assume a CSV with only two fields,
    in the following format:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这个例子，我们将假设一个只有两个字段的CSV文件，其格式如下：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We are going to create an object that receives all the purchases, and this will
    give us the necessary metrics. We could get some of these values out of the box
    by simply using the `min()` and `max()` built-in functions, but that would require
    iterating all of the purchases more than once, so instead, we are using our custom
    object, which will get these values in a single iteration.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个接收所有购买的实例，这将给我们必要的指标。我们可以通过简单地使用内置函数 `min()` 和 `max()` 来获得一些这些值，但这将需要多次迭代所有购买，所以相反，我们使用我们的自定义对象，它将在单次迭代中获取这些值。
- en: 'The code that will get the numbers for us looks rather simple. It''s just an
    object with a method that will process all the prices in one go, and, at each
    step, will update the value of each particular metric we are interested in. First,
    we will show the first implementation in the following listing, and, later on
    in this chapter (once we have seen more about iteration), we will revisit this
    implementation and get a much better (and more compact) version of it. For now,
    we are settling with the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 获取我们所需数字的代码看起来相当简单。它只是一个具有一个方法的对象，该方法一次处理所有价格，并在每个步骤中更新我们感兴趣的每个特定指标的值。首先，我们将展示以下列表中的第一个实现，稍后在本章中（一旦我们了解了更多关于迭代的内容），我们将重新审视这个实现，并得到一个更好（更紧凑）的版本。现在，我们暂时采用以下内容：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This object will receive all the totals for `purchases` and process the required
    values. Now, we need a function that loads these numbers into something that this
    object can process. Here is the first version:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象将接收所有关于“购买”的总数，并处理所需值。现在，我们需要一个函数将这些数字加载到这个对象可以处理的东西中。以下是第一个版本：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code works; it loads all the numbers of the file into a list that, when
    passed to our custom object, will produce the numbers we want. It has a performance
    issue, though. If you run it with a rather large dataset, it will take a while
    to complete, and it might even fail if the dataset is large enough to not fit
    into the main memory.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是有效的；它将文件中的所有数字加载到一个列表中，当传递给我们的自定义对象时，将产生我们想要的数字。尽管如此，它有一个性能问题。如果你用相当大的数据集运行它，它将需要一段时间才能完成，如果数据集足够大以至于无法放入主内存，它甚至可能会失败。
- en: If we take a look at our code that consumes this data, it is processing purchases,
    one at a time, so we might be wondering why our producer fits everything in memory
    at once. It is creating a list where it puts all of the content of the file, but
    we know we can do better.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下消费这些数据的代码，它一次处理一个购买，所以我们可能会想知道为什么我们的生产者一次将所有内容放入内存。它正在创建一个列表，将文件的所有内容都放入其中，但我们知道我们可以做得更好。
- en: 'The solution is to create a generator. Instead of loading the entire content
    of the file in a list, we will produce the results one at a time. The code will
    now look like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是创建一个生成器。而不是将整个文件内容加载到一个列表中，我们将一次产生一个结果。现在的代码将看起来像这样：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you measure the process this time, you will notice that the usage of memory
    has dropped significantly. We can also see how the code looks simpler—there is
    no need to define the list (therefore, there is no need to append to it), and
    the `return` statement has also disappeared.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这次测量过程，你会注意到内存使用量显著下降。我们还可以看到代码看起来更简单——不需要定义列表（因此，不需要向其中添加内容），`return` 语句也消失了。
- en: In this case, the `load_purchases` function is a generator function, or simply
    a generator.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`load_purchases` 函数是一个生成器函数，或者简单地说，是一个生成器。
- en: 'In Python, the mere presence of the keyword `yield` in any function makes it
    a generator, and, as a result, when calling it, nothing other than creating an
    instance of the generator will happen:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，任何函数中关键字 `yield` 的存在都使其成为一个生成器，因此，在调用它时，除了创建生成器实例之外，不会发生任何事情：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A generator object is an iterable (we will revisit iterables in more detail
    later on), which means that it can work with `for` loops. Note how we did not
    have to change anything on the consumer code—our statistics processor remained
    the same, with the `for` loop unmodified, after the new implementation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器对象是一个可迭代对象（我们稍后会更详细地回顾可迭代对象），这意味着它可以与`for`循环一起工作。注意我们并没有在消费者代码上做任何改变——我们的统计处理器保持不变，`for`循环在新的实现后也没有被修改。
- en: Working with iterables allows us to create these kinds of powerful abstractions
    that are polymorphic with respect to `for` loops. As long as we keep the iterable
    interface, we can iterate over that object transparently.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可迭代对象允许我们创建这些类型的强大抽象，它们在`for`循环方面是多态的。只要我们保持迭代器接口，我们就可以透明地遍历该对象。
- en: What we're exploring in this chapter is another case of idiomatic code that
    blends well with Python itself. In previous chapters, we have seen how we can
    implement our own context managers to connect our objects into with statements,
    or how can we create custom container objects to leverage the `in` operator, or
    booleans for the `if` statement, and so on. Now it's the turn of the `for` operator,
    and for that, we'll create iterators.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中探讨的是另一种与Python本身很好地融合的惯用代码案例。在之前的章节中，我们看到了如何实现我们自己的上下文管理器来将我们的对象连接到with语句中，或者如何创建自定义容器对象来利用`in`运算符，或者布尔值用于`if`语句，等等。现在轮到`for`运算符了，为此，我们将创建迭代器。
- en: 'Before going into the details and nuances of generators, we can take a quick
    look at how generators relate to a concept that we have already seen: comprehensions.
    A generator in the form of a comprehension is called a generator expression, and
    we''ll discuss it briefly in the next section.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨生成器的细节和细微差别之前，我们可以快速看一下生成器与我们已经看到的概念之间的关系：理解。以理解形式存在的生成器被称为生成器表达式，我们将在下一节简要讨论。
- en: Generator expressions
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: Generators save a lot of memory, and since they are iterators, they are a convenient
    alternative to other iterables or containers that require more space in memory
    such as lists, tuples, or sets.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器可以节省大量内存，并且由于它们是迭代器，它们是其他需要更多内存的迭代器或容器的方便替代品，例如列表、元组或集合。
- en: Much like these data structures, they can also be defined by comprehension,
    only that they are called a generator expression (there is an ongoing argument
    about whether they should be called generator comprehensions. In this book, we
    will just refer to them by their canonical name, but feel free to use whichever
    you prefer).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与这些数据结构类似，它们也可以通过理解来定义，只是它们被称为生成器表达式（关于它们是否应该被称为生成器理解表达式，目前存在争议。在这本书中，我们将只按其标准名称来称呼它们，但你可以自由选择你喜欢的名称）。
- en: 'In the same way, we would define a list comprehension. If we replace the square
    brackets with parentheses, we get a generator that results from the expression.
    Generator expressions can also be passed directly to functions that work with
    iterables, such as `sum()` and `max()`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以定义列表理解。如果我们用圆括号替换方括号，我们就会得到一个由表达式生成的生成器。生成器表达式也可以直接传递给处理可迭代对象的函数，例如`sum()`和`max()`：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Always pass a generator expression, instead of a list comprehension, to functions
    that expect iterables, such as `min()`, `max()`, and `sum()`. This is more efficient
    and Pythonic.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 总是传递生成器表达式，而不是列表理解，给期望可迭代对象的函数，如`min()`、`max()`和`sum()`。这更高效，也更符合Python风格。
- en: 'What the previous recommendation means is to try to avoid passing lists to
    functions that already work with generators. The example in the next code is something
    you would want to avoid, and favor the approach from the previous listing:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的推荐意味着尽量避免将列表传递给已经可以与生成器一起工作的函数。下面代码中的例子是你想要避免的，而应该优先考虑之前列表中的方法：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And, of course, you can assign a generator expression to a variable and use
    it somewhere else (as with comprehensions). Keep in mind that there is an important
    distinction in this case, because we're talking about generators here. A list
    can be reused and iterated multiple times, but a generator will be exhausted after
    it has been iterated over. For this reason, make sure the result of the expression
    is consumed only once, or you'll get unexpected results.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你还可以将生成器表达式赋值给变量，并在其他地方使用它（就像理解一样）。请注意，在这种情况下有一个重要的区别，因为我们在这里讨论的是生成器。列表可以被重复使用和迭代多次，但生成器在迭代过后就会耗尽。因此，请确保表达式的结果只被消费一次，否则你会得到意外的结果。
- en: Remember that generators are exhausted after they're iterated over, because
    they don't hold all the data in memory.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，生成器在迭代后就会耗尽，因为它们不会在内存中保存所有数据。
- en: A common approach is to create new generator expressions in the code. This way,
    the first one will be exhausted after is iterated, but then a new one is created.
    Chaining generator expressions this way is useful and helps to save memory as
    well as to make the code more expressive because it's resolving different iterations
    in different steps. One scenario where this is useful is when you need to apply
    multiple filters on an iterable; you can achieve this by using multiple generator
    expressions that act as chained filters.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的方法是在代码中创建新的生成器表达式。这样，第一个在迭代后会耗尽，但随后会创建一个新的。以这种方式链式生成器表达式是有用的，并且有助于节省内存，同时使代码更具表现力，因为它在不同的步骤中解决不同的迭代。这种用法的一个场景是当你需要对可迭代对象应用多个过滤器时；你可以通过使用多个作为链式过滤器的生成器表达式来实现这一点。
- en: Now that we have a new tool in our toolbox (iterators), let's see how we can
    use it to write more idiomatic code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们工具箱中有了新的工具（迭代器），让我们看看我们如何使用它来编写更符合习惯的代码。
- en: Iterating idiomatically
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 符合习惯的迭代
- en: In this section, we will first explore some idioms that come in handy when we
    have to deal with iteration in Python. These code recipes will help us get a better
    idea of the types of things we can do with generators (especially after we have
    already seen generator expressions), and how to solve typical problems in relation
    to them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先探索一些在处理Python中的迭代时非常有用的习语。这些代码配方将帮助我们更好地了解我们可以使用生成器（尤其是在我们已经看到生成器表达式之后）做什么，以及如何解决与它们相关的典型问题。
- en: Once we have seen some idioms, we will move on to exploring iteration in Python
    in more depth, analyzing the methods that make iteration possible, and how iterable
    objects work.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们看到了一些习语，我们将进一步探索Python中的迭代，分析使迭代成为可能的方法，以及可迭代对象是如何工作的。
- en: Idioms for iteration
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代习语
- en: 'We are already familiar with the built-in `enumerate()` function that, given
    an iterable, will return another one on which the element is a tuple, whose first
    element is the index of the second one (corresponding to the element in the original
    iterable):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了内置的`enumerate()`函数，给定一个可迭代对象，它将返回另一个对象，其元素是一个元组，第一个元素是第二个元素的索引（对应于原始可迭代对象中的元素）：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We wish to create a similar object, but in a more low-level fashion; one that
    can simply create an infinite sequence. We want an object that can produce a sequence
    of numbers, from a starting one, without any limits.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望创建一个类似的对象，但以更低级的模式；一个可以简单地创建无限序列的对象。我们希望有一个可以产生从起始数字开始的序列的对象，没有任何限制。
- en: 'An object as simple as the following one can do the trick. Every time we call
    this object, we get the next number of the sequence ad infinitum:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如下简单的一个对象就可以做到这一点。每次我们调用这个对象时，我们都会得到序列中的下一个数字，无限循环：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Based on this interface, we would have to use this object by explicitly invoking
    its `next()` method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个接口，我们必须通过显式调用其`next()`方法来使用这个对象：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'But with this code, we cannot reconstruct the `enumerate()` function as we
    would like to, because its interface does not support being iterated over a regular
    Python `for` loop, which also means that we cannot pass it as a parameter to functions
    that expect something to iterate over. Notice how the following code fails:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用这段代码，我们无法像期望的那样重构`enumerate()`函数，因为它的接口不支持在常规Python `for`循环中迭代，这也意味着我们无法将其作为参数传递给期望迭代对象的函数。注意以下代码是如何失败的：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The problem lies in the fact that `NumberSequence` does not support iteration.
    To fix this, we have to make the object an iterable by implementing the magic
    method `__iter__()`. We have also changed the previous `next()` method, by using
    the `__next__ magic method`, which makes the object an iterator:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`NumberSequence`不支持迭代。为了解决这个问题，我们必须通过实现魔法方法`__iter__()`使对象成为一个可迭代对象。我们还改变了之前的`next()`方法，通过使用`__next__`魔法方法，使对象成为一个迭代器：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This has an advantage—not only can we iterate over the element, but we also
    don''t even need the `.next()` method anymore because having `__next__()` allows
    us to use the `next()` built-in function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个优点——我们不仅可以迭代元素，而且我们甚至不再需要`.next()`方法，因为`__next__()`允许我们使用内置的`next()`函数：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This makes use of the iteration protocol. Similar to the context manager protocol
    we have explored in previous chapters, which consists of the `__enter__` and `__exit__`
    methods, this protocol relies on the `__iter__` and `__next__` methods.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这利用了迭代协议。类似于我们在前几章中探索的上下文管理器协议，该协议由`__enter__`和`__exit__`方法组成，这个协议依赖于`__iter__`和`__next__`方法。
- en: 'Having these protocols in Python has an advantage: everyone that knows Python
    will be familiar with this interface already, so there''s a sort of "standard
    contract." This means, instead of having to define your own methods and agree
    with the team (or any potential reader of the code), that this is the expected
    standard or protocol your code works with (as with our custom `next()` method
    in the first example); Python already provides an interface and has a protocol
    already. We only have to implement it properly.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中拥有这些协议有优势：所有了解Python的人都会熟悉这个接口，因此存在一种“标准合同”。这意味着，我们不需要定义自己的方法并与团队（或任何潜在的代码阅读者）达成一致（就像我们在第一个例子中的自定义`next()`方法那样）；Python已经提供了一个接口和协议。我们只需要正确实现它。
- en: The next() function
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`next()`函数'
- en: 'The `next()` built-in function will advance the iterable to its next element
    and return it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`next()`内置函数将迭代器推进到其下一个元素并返回它：'
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the iterator does not have more elements to produce, the `StopIteration`
    exception is raised:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迭代器没有更多元素可以产生，将引发`StopIteration`异常：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This exception signals that the iteration is over and that there are no more
    elements to consume.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个异常表示迭代已经结束，没有更多的元素可以消费。
- en: 'If we wish to handle this case, besides catching the `StopIteration` exception,
    we could provide this function with a default value in its second parameter. Should
    this be provided, it will be the return value in lieu of throwing `StopIteration`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望处理这种情况，除了捕获`StopIteration`异常之外，我们还可以在函数的第二个参数中提供一个默认值。如果提供了这个值，它将作为替代`StopIteration`抛出的返回值：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is advisable to use the default value most of the time, to avoid having exceptions
    at runtime in our programs. If we are absolutely sure that the iterator we're
    dealing with cannot be empty, it's still better to be implicit (and intentional)
    about it, and not rely on side effects of built-in functions (that is, to properly
    assert the case).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，建议使用默认值，以避免在程序运行时出现异常。如果我们绝对确信我们正在处理的迭代器不能为空，仍然最好对此进行隐式（且有意）的说明，而不是依赖于内置函数的副作用（即，正确断言情况）。
- en: The `next()` function can be quite useful in combination with generator expressions,
    in situations where we want to look for the first elements of an iterable that
    meets certain criteria. We'll see examples of this idiom throughout the chapter,
    but the main idea is to use this function instead of creating a list comprehension
    and then taking its first element.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`next()`函数可以与生成器表达式结合使用，在我们要查找满足某些条件的可迭代对象的第一元素的情况下非常有用。我们将在本章中看到这个习惯用法的例子，但主要思想是使用这个函数而不是创建一个列表推导式然后取其第一个元素。'
- en: Using a generator
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用生成器
- en: 'The previous code can be simplified significantly by simply using a generator.
    Generator objects are iterators. This way, instead of creating a class, we can
    define a function that yields the values as needed:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地使用生成器，可以显著简化之前的代码。生成器对象是迭代器。这样，我们不需要创建一个类，而可以定义一个函数，按需产生值：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Remember that from our first definition, the `yield` keyword in the body of
    the function makes it a generator. Because it is a generator, it''s perfectly
    fine to create an infinite loop like this, because, when this generator function
    is called, it will run all the code until the next `yield` statement is reached.
    It will produce its value and suspend there:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，从我们的第一个定义来看，函数体内的`yield`关键字使其成为一个生成器。因为它是生成器，所以创建一个无限循环是完全可行的，因为当这个生成器函数被调用时，它将运行所有代码直到下一个`yield`语句。它将产生其值并暂停在那里：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This difference can be thought of as an analogy of the different ways there
    are to create a decorator, as we explored in the previous chapter (with an object
    of functions). Here as well, we can use a generator function, or an iterable object,
    as in the previous section. Whenever is possible, constructing a generator is
    recommended, because it's syntactically simpler, and therefore easier to understand.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异可以被视为我们在上一章中探讨的不同创建装饰器方式的一个类比（使用函数对象）。在这里，我们也可以使用生成器函数或可迭代对象，就像上一节中那样。只要可能，建议构造生成器，因为它在语法上更简单，因此更容易理解。
- en: Itertools
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: itertools
- en: Working with iterable objects has the advantage that the code blends better
    with Python itself because iteration is a key component of the language. Besides
    that, we can take full advantage of the `itertools` module (ITER-01). Actually,
    the `sequence()` generator we just created is fairly similar to `itertools.count()`.
    However, there is more we can do.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与可迭代对象一起工作的好处是，代码与Python本身更好地融合，因为迭代是语言的关键组成部分。除此之外，我们可以充分利用`itertools`模块（ITER-01）。实际上，我们刚刚创建的`sequence()`生成器与`itertools.count()`相当相似。然而，我们还能做更多。
- en: One of the nicest things about iterators, generators, and itertools is that
    they are composable objects that can be chained together.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器、生成器和itertools最令人愉悦的一点是，它们是可组合的对象，可以串联在一起。
- en: 'For instance, going back to our first example that processed `purchases` in
    order to get some metrics, what if we want to do the same, but only for those
    values over a certain threshold? The naïve approach to solving this problem would
    be to place the condition while iterating:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，回到我们最初处理`purchases`以获取一些度量的例子，如果我们想做同样的事情，但只针对超过某个阈值的值，该怎么办？解决这个问题的天真方法是在迭代时放置条件：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is not only non-Pythonic, but it's also rigid (and rigidity is a trait
    that denotes bad code). It doesn't handle changes very well. What if the number
    changes now? Do we pass it by parameter? What if we need more than one? What if
    the condition is different (less than, for instance)? Do we pass a `lambda`?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅不符合Python风格，而且也很僵化（僵化是表示糟糕代码的特征）。它处理变化的能力很差。如果现在数字变了怎么办？我们通过参数传递吗？如果我们需要不止一个呢？如果条件不同（比如小于）怎么办？我们传递一个`lambda`吗？
- en: These questions should not be answered by this object, whose sole responsibility
    is to compute a set of well-defined metrics over a stream of purchases represented
    as numbers. And, of course, the answer is no. It would be a huge mistake to make
    such a change (once again, clean code is flexible, and we don't want to make it
    rigid by coupling this object to external factors). These requirements will have
    to be addressed elsewhere.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题不应该由这个对象来回答，它的唯一责任是在表示为数字的购买流上计算一系列定义良好的度量。当然，答案是否定的。做出这样的改变将是一个巨大的错误（再次强调，干净的代码是灵活的，我们不希望通过将这个对象与外部因素耦合使其变得僵化）。这些需求将不得不在其他地方解决。
- en: It's better to keep this object independent of its clients. The less responsibility
    this class has, the more useful it will be for more clients, hence enhancing its
    chances of being reused.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最好保持这个对象与其客户独立。这个类承担的责任越少，它对更多客户就越有用，从而增加其被重用的机会。
- en: Instead of changing this code, we're going to keep it as it is and assume that
    the new data is filtered according to whatever requirements each customer of the
    class has.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会改变这段代码，而是保持原样，并假设新数据是根据每个类客户的要求进行过滤的。
- en: 'For instance, if we wanted to process only the first `10` purchases that amount
    to more than `1000`, we would do the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们只想处理前`10`笔超过`1000`的购买，我们会这样做：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There is no memory penalization for filtering this way because since they are
    all generators, the evaluation is always lazy. This gives us the power of thinking
    as if we had filtered the entire set at once and then passed it to the object,
    but without actually fitting everything in memory.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式进行过滤不会产生内存惩罚，因为它们都是生成器，所以评估总是延迟的。这让我们能够像一次性过滤整个集合然后传递给对象一样思考，但实际上并不需要在内存中放入所有内容。
- en: Keep in mind the trade-off mentioned at the beginning of the chapter, between
    memory and CPU usage. While the code might use less memory, it could take up more
    CPU time, but most of the times, this is acceptable, when we have to process lots
    of objects in memory while keeping the code maintainable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住章节开头提到的权衡，即在内存和CPU使用之间的权衡。虽然代码可能使用更少的内存，但它可能需要更多的CPU时间，但大多数时候，这是可以接受的，当我们需要在内存中处理大量对象的同时保持代码的可维护性。
- en: Simplifying code through iterators
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过迭代器简化代码
- en: Now, we will briefly discuss some situations that can be improved with the help
    of iterators, and occasionally the `itertools` module. After discussing each case,
    and its proposed optimization, we will close each point with a corollary.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将简要讨论一些可以用迭代器帮助改进的情况，以及偶尔使用 `itertools` 模块的情况。在讨论每个案例及其提出的优化后，我们将用推论结束每个要点。
- en: Repeated iterations
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重复迭代
- en: 'Now that we have seen more about iterators, and introduced the `itertools`
    module, we can show you how one of the first examples of this chapter (the one
    for computing statistics about some purchases) can be dramatically simplified:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了更多关于迭代器的信息，并介绍了 `itertools` 模块，我们可以向您展示本章的第一个例子（计算一些购买数据的统计信息）可以如何显著简化：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, `itertools.tee` will split the original iterable into three
    new ones. We will use each of these for the different kinds of iterations that
    we require, without needing to repeat three different loops over `purchases`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`itertools.tee` 将原始可迭代对象拆分为三个新的对象。我们将使用这些对象来完成不同类型的迭代，而无需对 `purchases`
    重复三次不同的循环。
- en: The reader can simply verify that if we pass an iterable object as the `purchases`
    parameter, this one is traversed only once (thanks to the `itertools.tee` function
    [TEE]), which was our main requirement. It is also possible to verify how this
    version is equivalent to our original implementation. In this case, there is no
    need to manually raise `ValueError` because passing an empty sequence to the `min()`
    function will do this.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可以简单地验证，如果我们传递一个可迭代对象作为 `purchases` 参数，这个对象只会被遍历一次（多亏了 `itertools.tee` 函数
    [TEE]），这是我们主要的要求。也可以验证这个版本如何与我们的原始实现等效。在这种情况下，没有必要手动引发 `ValueError`，因为将空序列传递给
    `min()` 函数会这样做。
- en: If you are thinking about running a loop over the same object more than once,
    stop and think if `itertools.tee` can be of any help.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在考虑对同一个对象运行多次循环，请停下来思考 `itertools.tee` 是否能有所帮助。
- en: The `itertools` module contains many useful functions and nice abstractions
    that come in handy when dealing with iterations in Python. It also contains good
    recipes about how to solve typical iteration problems in an idiomatic fashion.
    As general advice, if you're thinking about how to solve a particular problem
    that involves iteration, go and take a look at this module. Even if the answer
    isn't literally there, it'll be good inspiration.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools` 模块包含许多有用的函数和方便的抽象，当处理Python中的迭代时非常有用。它还包含关于如何以习惯用法解决典型迭代问题的良好食谱。作为一般建议，如果你在考虑如何解决涉及迭代的具体问题，就去看看这个模块。即使答案不是字面上的，它也会是一个很好的灵感来源。'
- en: Nested loops
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 嵌套循环
- en: In some situations, we need to iterate over more than one dimension, looking
    for a value, and nested loops come as the first idea. When the value is found,
    we need to stop iterating, but the `break` keyword doesn't work entirely because
    we have to escape from two (or more) `for` loops, not just one.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们需要遍历多个维度，寻找一个值，嵌套循环是第一个想法。当找到值时，我们需要停止迭代，但 `break` 关键字并不完全起作用，因为我们必须从两个（或更多）`for`
    循环中退出，而不仅仅是其中一个。
- en: What would be the solution to this? A flag signaling escape? No. Raising an
    exception? No, this would be the same as the flag, but even worse because we know
    that exceptions are not to be used for control flow logic. Moving the code to
    a smaller function and returning it? Close, but not quite.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方案会是什么？一个表示退出的标志？不。引发异常？不，这将与标志相同，但更糟，因为我们知道异常不应该用于控制流逻辑。将代码移动到更小的函数并返回它？接近，但还不够。
- en: The answer is, whenever possible, flatten the iteration to a single `for` loop.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，尽可能地将迭代扁平化为单个 `for` 循环。
- en: 'This is the kind of code we would like to avoid:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们希望避免的代码类型：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And here is a simplified version of it that does not rely on flags to signal
    termination, and has a simpler, more compact structure of iteration:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个简化的版本，它不依赖于标志来指示终止，并且具有更简单、更紧凑的迭代结构：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It's worth mentioning how the auxiliary generator that was created works as
    an abstraction for the iteration that's required. In this case, we just need to
    iterate over two dimensions, but if we needed more, a different object could handle
    this without the client needing to know about it. This is the essence of the iterator
    design pattern, which, in Python, is transparent, since it supports iterator objects
    automatically, which is the topic covered in the next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们创建的辅助生成器是如何作为所需迭代抽象的。在这种情况下，我们只需要迭代两个维度，但如果我们需要更多，一个不同的对象可以处理这些，而客户端无需了解这些。这就是迭代器设计模式的核心，在Python中，它是透明的，因为它自动支持迭代器对象，这是下一节将要讨论的主题。
- en: Try to simplify the iteration as much as possible with as many abstractions
    as are required, flattening the loops wherever possible.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地使用尽可能多的抽象来简化迭代，在可能的地方简化循环。
- en: Hopefully, this example serves as inspiration to you to get the idea that we
    can use generators for something more than just saving memory. We can take advantage
    of the iteration as an abstraction. That is, we can create abstractions not only
    by defining classes or functions but also by taking advantage of the syntax of
    Python. In the same way that we have seen how to abstract away some logic behind
    a context manager (so we don't know the details of what happens under the `with`
    statement), we can do the same with iterators (so we can forget the underlying
    logic of a `for` loop).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个例子能给你带来灵感，让你明白我们可以使用生成器做的不只是节省内存。我们可以利用迭代作为抽象。也就是说，我们不仅可以通过定义类或函数来创建抽象，还可以利用Python的语法。就像我们看到了如何通过上下文管理器抽象掉一些逻辑（这样我们就不需要知道`with`语句下发生的事情的细节），我们也可以用迭代器做到同样的事情（这样我们就可以忘记`for`循环的底层逻辑）。
- en: That's why we will start exploring how the iterator pattern works in Python,
    starting with the next section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将从下一节开始探索Python中迭代器模式的工作原理。
- en: The iterator pattern in Python
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python中的迭代器模式
- en: Here, we will take a small detour from generators to understand iteration in
    Python more deeply. Generators are a particular case of iterable objects, but
    iteration in Python goes beyond generators, and being able to create good iterable
    objects will give us the chance to create more efficient, compact, and readable
    code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将从生成器稍微偏离一下，以更深入地理解Python中的迭代。生成器是可迭代对象的一个特例，但Python中的迭代不仅仅局限于生成器，能够创建良好的可迭代对象将给我们机会编写更高效、紧凑和易于阅读的代码。
- en: In the previous code listings, we have been seeing examples of `iterable` objects
    that are also iterators, because they implement both the `__iter__()` and `__next__()`
    magic methods. While this is fine in general, it's not strictly required that
    they always have to implement both methods, and here we'll show the subtle differences
    between an `iterable` object (one that implements `__iter__`) and an iterator
    (that implements `__next__`).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码示例中，我们已经看到了既是`可迭代对象`又是迭代器的例子，因为它们实现了`__iter__()`和`__next__()`魔法方法。虽然这在一般情况下是可以的，但它们并不严格需要总是实现这两个方法，在这里我们将展示`可迭代对象`（实现了`__iter__`）和迭代器（实现了`__next__`）之间的微妙差异。
- en: We also explore other topics related to iterations, such as sequences and container
    objects.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了与迭代相关的一些其他主题，例如序列和容器对象。
- en: The interface for iteration
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 迭代接口
- en: An `iterable` is an object that supports iteration, which, at a very high level,
    means that we can run a `for` .. `in` ... loop over it, and it will work without
    any issues. However, `iterable` does not mean the same as iterator.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`可迭代对象`是一个支持迭代的对象，在非常高的层面上，这意味着我们可以运行一个`for` .. `in` ... 循环来遍历它，而不会出现任何问题。然而，`可迭代对象`并不等同于迭代器。
- en: Generally speaking, an `iterable` is just something we can iterate, and it uses
    an iterator to do so. This means that in the `__iter__` magic method, we would
    like to return an iterator, namely, an object with a `__next__()` method implemented.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，一个`可迭代对象`就是我们能够迭代的任何东西，它通过迭代器来实现这一点。这意味着在`__iter__`魔法方法中，我们希望返回一个迭代器，即实现了`__next__()`方法的对象。
- en: An iterator is an object that only knows how to produce a series of values,
    one at a time, when it's being called by the already explored built-in `next()`
    function, while the iterator is not called, it's simply frozen, sitting idly by
    until it's called again for the next value to produce. In this sense, generators
    are iterators.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是一个对象，它只知道如何在被已经探索过的内置`next()`函数调用时逐个产生一系列值，当迭代器没有被调用时，它只是简单地冻结，无所事事地坐着，直到再次被调用以产生下一个值。从这个意义上说，生成器是迭代器。
- en: '| Python concept | Magic method | Considerations |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| Python 概念 | 魔法方法 | 考虑事项 |'
- en: '| Iterable | `__iter__` | They work with an iterator to construct the iteration
    logic.These objects can be iterated in a `for` ... `in` ...: loop. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 可迭代对象 | `__iter__` | 它们使用迭代器来构建迭代逻辑。这些对象可以在`for` ... `in` ...循环中进行迭代。 |'
- en: '| Iterator | `__next__` | Define the logic for producing values one at a time.The
    `StopIteration` exception signals that the iteration is over.The values can be
    obtained one by one via the built-in `next()` function. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 迭代器 | `__next__` | 定义逐个产生值的逻辑。`StopIteration`异常表示迭代结束。值可以通过内置的`next()`函数逐个获取。
    |'
- en: 'Table 7.1: Iterables and iterators'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1：可迭代对象和迭代器
- en: 'In the following code, we will see an example of an iterator object that is
    not iterable—it only supports invoking its values, one at a time. Here, the name
    `sequence` refers just to a series of consecutive numbers, not to the sequence
    concept in Python, which we will explore later on:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将看到一个迭代器对象的例子，它不是可迭代的——它只支持逐个调用其值。在这里，名称`sequence`仅仅指一系列连续的数字，并不指Python中的序列概念，我们将在稍后探讨：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Notice that we can get the values of the sequence one at a time, but we can''t
    iterate over this object (this is fortunate because it would otherwise result
    in an endless loop):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以逐个获取序列的值，但我们不能遍历这个对象（这是幸运的，因为否则会导致无限循环）：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The error message is clear, as the object doesn't implement `__iter__()`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息很明确，因为这个对象没有实现`__iter__()`。
- en: Just for explanatory purposes, we can separate the iteration in another object
    (again, it would be enough to make the object implement both `__iter__` and `__next__`,
    but doing so separately will help clarify the distinctive point we're trying to
    make in this explanation).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了解释目的，我们可以将迭代分离到另一个对象中（再次，只要对象实现了`__iter__`和`__next__`，就足够了，但这样分开做将有助于阐明我们在这个解释中试图说明的独特点）。
- en: Sequence objects as iterables
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 序列对象作为可迭代对象
- en: As we have just seen, if an object implements the `__iter__()` magic method,
    it means it can be used in a `for` loop. While this is a great feature, it's not
    the only possible form of iteration we can achieve. When we write a `for` loop,
    Python will try to see if the object we're using implements `__iter__`, and if
    it does, it will use that to construct the iteration, but if it doesn't, there
    are fallback options.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，如果一个对象实现了`__iter__()`魔法方法，这意味着它可以在`for`循环中使用。虽然这是一个很好的特性，但它不是我们能够实现的唯一迭代形式。当我们编写`for`循环时，Python会尝试查看我们使用的对象是否实现了`__iter__`，如果实现了，它将使用这个来构建迭代，如果没有实现，还有回退选项。
- en: If the object happens to be a sequence (meaning that it implements the `__getitem__()`
    and `__len__()` magic methods), it can also be iterated. If that is the case,
    the interpreter will then provide values in sequence, until the `IndexError` exception
    is raised, which, analogous to the aforementioned `StopIteration`, also signals
    the stop for the iteration.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象恰好是一个序列（意味着它实现了`__getitem__()`和`__len__()`魔法方法），它也可以进行迭代。如果是这样，解释器将按顺序提供值，直到抛出`IndexError`异常，这与前面提到的`StopIteration`类似，也标志着迭代的结束。
- en: 'With the sole purpose of illustrating such a behavior, we will run the following
    experiment that shows a sequence object that implements `map()` over a range of
    numbers:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了仅说明这种行为，我们将运行以下实验，展示一个实现了对数字范围应用`map()`的序列对象：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Keep in mind that this example is only designed to illustrate that an object
    such as this one can be iterated with a regular `for` loop. There is a logging
    line placed in the `__getitem__` method to explore what values are passed while
    the object is being iterated, as we can see from the following test:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个例子只是为了说明像这样的对象可以用普通的`for`循环进行迭代。在`__getitem__`方法中放置了一个日志行，以探索在对象被迭代时传递了哪些值，正如我们从下面的测试中可以看到：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As a word of caution, it's important to highlight that while it is useful to
    know this, it's also a fallback mechanism for when the object doesn't implement
    `__iter__`, so most of the time we'll want to resort to these methods by thinking
    about creating proper sequences, and not just objects we want to iterate over.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一句警告，重要的是要强调，虽然了解这一点很有用，但它也是当对象没有实现`__iter__`时的回退机制，所以大多数时候我们都会通过考虑创建合适的序列，而不是仅仅迭代对象来使用这些方法。
- en: When thinking about designing an object for iteration, favor a proper iterable
    object (with `__iter__`), rather than a sequence that can coincidentally also
    be iterated.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑设计用于迭代的对象时，优先考虑一个合适的迭代器对象（具有`__iter__`），而不是一个偶然也可以迭代的序列。
- en: Iterables are an important part of Python, not only because of the capabilities
    they offer to us as software engineers, but also because they play a fundamental
    role in the internals of Python.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是Python的重要组成部分，不仅因为它们为我们软件工程师提供的功能，还因为它们在Python内部起着基本的作用。
- en: We have seen in *A brief introduction to asynchronous code* in *Chapter 2*,
    *Pythonic Code*, how to read asynchronous code. Now that we have also explored
    iterators in Python, we can see how these two concepts are related. In particular,
    the next section explores coroutines, and we'll see how iterators are at the core
    of them.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章“Pythonic Code”中的“*异步代码简介*”中，我们看到了如何阅读异步代码。现在我们已经探索了Python中的迭代器，我们可以看到这两个概念是如何相关的。特别是，下一节将探讨协程，我们将看到迭代器是如何成为其核心的。
- en: Coroutines
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程
- en: The idea of a coroutine is to have a function, whose execution can be suspended
    at a given point in time, to be later resumed. By having this kind of functionality,
    a program might be able to suspend a part of the code, in order to dispatch something
    else for processing, and then come back to this original point to resume.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 协程的想法是有一个函数，其执行可以在某个特定时间点暂停，稍后可以恢复。通过这种功能，程序可能能够暂停代码的一部分，以便处理其他事情，然后返回到这个原始点继续执行。
- en: As we already know, generator objects are iterables. They implement `__iter__()`
    and `__next__()`. This is provided by Python automatically so that when we create
    a generator object function, we get an object that can be iterated or advanced
    through the `next()` function.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，生成器对象是可迭代的。它们实现了`__iter__()`和`__next__()`。这是Python自动提供的，以便当我们创建生成器对象函数时，我们得到一个可以迭代或通过`next()`函数推进的对象。
- en: Besides this basic functionality, they have more methods so that they can work
    as coroutines (PEP-342). Here, we will explore how generators evolved into coroutines
    to support the basis of asynchronous programming before we go into more detail
    in the next section, where we will explore the new features of Python and the
    syntax that covers programming asynchronously.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个基本功能之外，它们还有更多方法，以便它们可以作为协程（PEP-342）工作。在这里，我们将在下一节更详细地探讨生成器如何演变成协程以支持异步编程的基础之前，探索生成器是如何演变成协程的。在下一节中，我们将探讨Python的新特性和用于异步编程的语法。
- en: 'The basic methods added in PEP-342 to support coroutines are as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: PEP-342中添加的基本方法以支持协程如下：
- en: '`.close()`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.close()`'
- en: '`.throw(ex_type[, ex_value[, ex_traceback]])`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.throw(ex_type[, ex_value[, ex_traceback]])`'
- en: '`.send(value)`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.send(value)`'
- en: Python takes advantage of generators in order to create coroutines. Because
    generators can naturally suspend, they're a convenient starting point. But generators
    weren't enough as they were originally thought to be, so these methods were added.
    This is because typically, it's not enough to just be able to suspend some part
    of the code; you'd also want to communicate with it (pass data, and signal about
    changes in the context).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Python利用生成器来创建协程。因为生成器可以自然地暂停，所以它们是一个方便的起点。但是，生成器并不足以满足最初的想法，因此添加了这些方法。这是因为通常，仅仅能够暂停代码的一部分是不够的；你还想与之通信（传递数据，并通知上下文的变化）。
- en: By exploring each method in more detail, we'll be able to learn more about the
    internals of coroutines in Python. After this, I'll present another recapitulation
    of how asynchronous programming works, but unlike the one presented in *Chapter
    2*, *Pythonic Code*, this one will relate to the internal concepts we just learned.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更详细地探索每个方法，我们将能够更多地了解Python协程的内部机制。在此之后，我将再次概述异步编程的工作原理，但与第二章“Pythonic Code”中介绍的不同，这一次它将与我们刚刚学到的内部概念相关。
- en: The methods of the generator interface
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器接口的方法
- en: In this section, we will explore what each of the aforementioned methods does,
    how it works, and how it is expected to be used. By understanding how to use these methods,
    we will be able to make use of simple coroutines.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨上述每种方法的作用、工作原理以及预期如何使用。通过了解如何使用这些方法，我们将能够利用简单的协程。
- en: Later on, we will explore more advanced uses of coroutines, and how to delegate
    to sub-generators (coroutines) in order to refactor code, and how to orchestrate
    different coroutines.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将探讨协程的更高级用法，以及如何委派给子生成器（协程）以重构代码，以及如何编排不同的协程。
- en: close()
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: close()
- en: When calling this method, the generator will receive the `GeneratorExit` exception.
    If it's not handled, then the generator will finish without producing any more
    values, and its iteration will stop.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用此方法时，生成器将接收到`GeneratorExit`异常。如果没有处理，那么生成器将完成而不会产生更多值，并且迭代将停止。
- en: This exception can be used to handle a finishing status. In general, if our
    coroutine does some sort of resource management, we want to catch this exception
    and use that control block to release all resources being held by the coroutine.
    It is similar to using a context manager or placing the code in the `finally`
    block of an exception control, but handling this exception specifically makes
    it more explicit.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此异常可用于处理完成状态。一般来说，如果我们的协程执行某种资源管理，我们希望捕获此异常并使用该控制块释放协程持有的所有资源。这类似于使用上下文管理器或将代码放在异常控制的`finally`块中，但专门处理此异常使其更加明确。
- en: 'In the following example, we have a coroutine that makes use of a database
    handler object that holds a connection to a database, and runs queries over it,
    streaming data by pages of a fixed length (instead of reading everything that
    is available at once):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们有一个协程，它使用一个数据库处理对象，该对象保持对数据库的连接，并对其运行查询，通过固定长度的页面流式传输数据（而不是一次性读取所有可用的数据）：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'At each call to the generator, it will return `10` rows obtained from the database
    handler, but when we decide to explicitly finish the iteration and call `close()`,
    we also want to close the connection to the database:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次调用生成器时，它将返回从数据库处理程序获得的`10`行，但当我们决定显式地完成迭代并调用`close()`时，我们也希望关闭到数据库的连接：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Use the `close()` method on generators to perform finishing-up tasks when needed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要执行收尾任务时，请使用生成器的`close()`方法。
- en: This method is intended to be used for resource cleanup, so you'd typically
    use it for manually freeing resources when you couldn't do this automatically
    (for example, if you didn't use a context manager). Next, we'll see how to pass
    exceptions to the generator.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法旨在用于资源清理，因此你通常会在无法自动执行此操作时（例如，如果你没有使用上下文管理器）手动释放资源。接下来，我们将看到如何将异常传递给生成器。
- en: throw(ex_type[, ex_value[, ex_traceback]])
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: throw(ex_type[, ex_value[, ex_traceback]])
- en: This method will `throw` the exception at the line where the generator is currently
    suspended. If the generator handles the exception that was sent, the code in that
    particular `except` clause will be called; otherwise, the exception will propagate
    to the caller.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将在生成器当前挂起的那一行抛出异常。如果生成器处理了发送的异常，那么将调用特定于该`except`子句的代码；否则，异常将传播到调用者。
- en: 'Here, we are modifying the previous example slightly to show the difference
    when we use this method for an exception that is handled by the coroutine, and
    when it''s not:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们稍微修改了之前的例子，以展示当我们使用此方法处理协程处理的异常和未处理的异常时的差异：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, it is a part of the control flow to receive a `CustomException`, and, in
    such a case, the generator will log an informative message (of course, we can
    adapt this according to our business logic on each case), and move on to the next
    `yield` statement, which is the line where the coroutine reads from the database
    and returns that data.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，接收`CustomException`已成为控制流的一部分，在这种情况下，生成器将记录一条信息性消息（当然，我们可以根据每个案例的业务逻辑进行适配），然后继续到下一个`yield`语句，这是协程从数据库读取并返回数据的行。
- en: 'This particular example handles all exceptions, but if the last block (except
    `Exception`:) wasn''t there, the result would be that the generator is raised
    at the line where the generator is paused (again, `yield`), and it will propagate
    from there to the caller:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，它处理了所有异常，但如果最后的块（除了`Exception`：）不存在，结果将是生成器在生成器暂停的那一行（再次，`yield`）被引发，并且异常将从那里传播到调用者：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When our exception from the domain was received, the generator continued. However,
    when it received another exception that was not expected, the default block caught
    where we closed the connection to the database and finished the iteration, which
    resulted in the generator being stopped. As we can see from the `StopIteration`
    that was raised, this generator can't be iterated further.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到来自域的异常时，生成器继续运行。然而，当它收到一个未预期的异常时，默认的块捕获了我们关闭数据库连接并完成迭代的地方，这导致生成器停止。正如我们从抛出的`StopIteration`中可以看到的，这个生成器不能进一步迭代。
- en: send(value)
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: send(value)
- en: In the previous example, we created a simple generator that reads rows from
    a database, and when we wished to finish its iteration, this generator released
    the resources linked to the database. This is a good example of using one of the
    methods that generators provide (`close()`), but there is more we can do.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们创建了一个简单的生成器，它从数据库中读取行，当我们希望结束其迭代时，这个生成器释放了与数据库关联的资源。这是使用生成器提供的方法（`close()`）的一个很好的例子，但我们还可以做更多。
- en: An obvservation of the generator is that it was reading a fixed number of rows
    from the database.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对生成器的观察是，它从数据库中读取固定数量的行。
- en: 'We would like to parametrize that number (`10`) so that we can change it throughout
    different calls. Unfortunately, the `next()` function does not provide us with
    options for that. But luckily, we have `send()`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将那个数字（`10`）参数化，这样我们就可以在不同的调用中更改它。不幸的是，`next()`函数没有为我们提供这样的选项。但幸运的是，我们有`send()`：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The idea is that we have now made the coroutine able to receive values from
    the caller by means of the `send()` method. This method is the one that actually
    distinguishes a generator from a coroutine because when it's used, it means that
    the `yield` keyword will appear on the right-hand side of the statement, and its
    return value will be assigned to something else.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的想法是，我们已经使协程能够通过`send()`方法从调用者那里接收值。这个方法是真正区分生成器和协程的方法，因为当它被使用时，意味着`yield`关键字将出现在语句的右侧，并且它的返回值将被分配给其他某个东西。
- en: 'In coroutines, we generally find the `yield` keyword to be used in the following
    form:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在协程中，我们通常发现`yield`关键字以以下形式使用：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`yield`, in this case, will do two things. It will send `produced` back to
    the caller, which will pick it up on the next round of iteration (after calling
    `next()`, for example), and it will suspend there. At a later point, the caller
    will want to send a value back to the coroutine by using the `send()` method.
    This value will become the result of the `yield` statement, assigned in this case
    to the variable named `receive`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`yield`将执行两个操作。它将`produced`发送回调用者，调用者将在下一次迭代中（例如，在调用`next()`之后）获取它，并且在那里暂停。在稍后的某个时刻，调用者将通过使用`send()`方法将一个值发送回协程。这个值将成为`yield`语句的结果，在本例中分配给名为`receive`的变量。
- en: 'Sending values to the coroutine only works when this one is suspended at a
    `yield` statement, waiting for something to produce. For this to happen, the coroutine
    will have to be advanced to that status. The only way to do this is by calling
    `next()` on it. This means that before sending anything to the coroutine, this
    has to be advanced at least once via the `next()` method. Failure to do so will
    result in an exception:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当协程在`yield`语句处暂停，等待产生某些内容时，向协程发送值才有效。为了实现这一点，必须将协程推进到该状态。做到这一点的唯一方法是在其上调用`next()`。这意味着在向协程发送任何内容之前，至少要通过`next()`方法推进一次。未能这样做将导致异常：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Always remember to advance a coroutine by calling `next()` before sending any
    values to it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记得在向协程发送任何值之前，通过调用`next()`来推进协程。
- en: Back to our example. We are changing the way elements are produced or streamed
    to make it able to receive the length of the records it expects to read from the
    database.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子。我们正在改变元素的产生或流式传输方式，使其能够接收它从数据库中期望读取的记录长度。
- en: The first time we call `next()`, the generator will advance up to the line containing
    `yield`; it will provide a value to the caller (`None`, as set in the variable),
    and it will suspend there). From there, we have two options. If we choose to advance
    the generator by calling `next()`, the default value of `10` will be used, and
    it will go on with this as usual. This is because calling `next()` is technically
    the same as `send(None)`, but this is covered in the `if` statement that will
    handle the value that we previously set.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用`next()`时，生成器将推进到包含`yield`的行；它将提供一个值给调用者（`None`，如变量中设置的），并且它将在那里暂停）。从那里，我们有两种选择。如果我们选择通过调用`next()`推进生成器，默认值`10`将被使用，并且它将像往常一样继续。这是因为调用`next()`在技术上等同于`send(None)`，但这在处理我们之前设置的值的`if`语句中已经讨论过了。
- en: If, on the other hand, we decide to provide an explicit value via `send(<value>)`,
    this one will become the result of the `yield` statement, which will be assigned
    to the variable containing the length of the page to use, which, in turn, will
    be used to read from the database.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，另一方面，我们决定通过`send(<value>)`提供一个显式的值，这个值将成为`yield`语句的结果，它将被分配给包含要使用页面长度的变量，这个变量反过来将被用来从数据库中读取。
- en: Successive calls will have this logic, but the important point is that now we
    can dynamically change the length of the data to read in the middle of the iteration,
    at any point.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 连续调用将具有这种逻辑，但重要的是现在我们可以在迭代过程中动态地改变要读取的数据长度，在任何时候都可以。
- en: 'Now that we understand how the previous code works, most Pythonistas would
    expect a simplified version of it (after all, Python is also about brevity and
    clean and compact code):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了前面的代码是如何工作的，大多数Python开发者都会期待一个简化版本（毕竟，Python也关于简洁和干净、紧凑的代码）：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This version is not only more compact, but it also illustrates the idea better.
    The parentheses around `yield` makes it clearer that it's a statement (think of
    it as if it were a function call), and that we are using the result of it to compare
    it against the previous value.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本不仅更紧凑，而且更好地说明了这个想法。`yield`周围的括号使它更清楚地表明它是一个语句（把它想象成一个函数调用），并且我们正在使用它的结果来与之前的值进行比较。
- en: This works as we expect it does, but we always have to remember to advance the
    coroutine before sending any data to it. If we forget to call the first `next()`,
    we'll get a `TypeError`. This call could be ignored for our purposes because it
    doesn't return anything we'll use.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像我们预期的那样工作，但我们总是必须记得在向它发送任何数据之前推进协程。如果我们忘记调用第一个`next()`，我们会得到一个`TypeError`。这个调用可以忽略，因为不会返回我们将要使用的内容。
- en: 'It would be good if we could use the coroutine directly, right after it is
    created, without having to remember to call `next()` the first time, every time
    we are going to use it. Some authors (PYCOOK) devised an interesting decorator
    to achieve this. The idea of this decorator is to advance the coroutine, so the
    following definition works automatically:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够在创建协程后立即使用它，而不必每次使用时都记得调用`next()`，那就太好了。一些作者（PYCOOK）设计了一个有趣的装饰器来实现这一点。这个装饰器的想法是推进协程，所以下面的定义可以自动工作：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Keep in mind, these are the fundamentals of how coroutines work in Python. By
    following these examples, you'll get an idea of what's actually going on in Python
    when working with coroutines. However, in modern Python, you wouldn't typically
    write these sorts of coroutines by yourself, because there's new syntax available
    (which we have mentioned, but we'll revisit to see how they relate to the ideas
    we have just seen).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些是Python中协程工作的基础。通过遵循这些示例，你会对Python在处理协程时实际发生的事情有一个概念。然而，在现代Python中，你通常不会自己编写这类协程，因为已经有了新的语法（我们之前提到过，但我们将重新审视，看看它们如何与我们刚刚看到的概念相关）。
- en: Before jumping into the new syntactic capabilities, we need to explore the last
    jump the coroutines took in terms of their added functionality, in order to bridge
    missing gaps. After that, we'll be able to understand the meaning behind each
    keyword and statement used in asynchronous programming.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究新的语法功能之前，我们需要探索协程在功能上所做的最后跳跃，以便填补缺失的空白。之后，我们将能够理解在异步编程中使用的每个关键字和语句背后的含义。
- en: More advanced coroutines
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更高级的协程
- en: So far, we have a better understanding of coroutines, and we can create simple
    ones to handle small tasks. We can say that these coroutines are, in fact, just
    more advanced generators (and that would be right, coroutines are just fancy generators),
    but, if we actually want to start supporting more complex scenarios, we usually
    have to go for a design that handles many coroutines concurrently, and that requires
    more features.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对协程有了更好的理解，我们可以创建简单的协程来处理小任务。我们可以认为这些协程实际上只是更高级的生成器（这将是正确的，协程只是花哨的生成器），但如果我们实际上想要开始支持更复杂的场景，我们通常必须选择一个可以同时处理许多协程的设计，这需要更多的功能。
- en: When handling many coroutines, we find new problems. As the control flow of
    our application becomes more complex, we want to pass values up and down the stack
    (as well as exceptions), be able to capture values from sub-coroutines we might
    call at any level, and finally, schedule multiple coroutines to run toward a common
    goal.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理许多协程时，我们会遇到新的问题。随着我们的应用程序的控制流变得更加复杂，我们希望在上传和下传堆栈（以及异常），能够从任何级别的子协程中捕获值，并最终安排多个协程共同实现一个目标。
- en: To make things simpler, generators had to be extended once again. That is what
    PEP-380 addressed by changing the semantics of generators so that they can return
    values and by introducing the new `yield from` construction.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更简单，生成器不得不再次扩展。这就是PEP-380通过改变生成器的语义，使它们能够返回值，并引入新的`yield from`构造来解决的问题。
- en: Returning values in coroutines
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协程中的返回值
- en: As introduced at the beginning of this chapter, iteration is a mechanism that
    calls `next()` on an iterable object many times until a `StopIteration` exception
    is raised.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，迭代是一种机制，它多次在可迭代对象上调用`next()`，直到抛出`StopIteration`异常。
- en: So far, we have been exploring the iterative nature of generators—we produce
    values one at a time, and, in general, we only care about each value as it's being
    produced at every step of the `for` loop. This is a very logical way of thinking
    about generators, but coroutines have a different idea; even though they are technically
    generators, they weren't conceived with the idea of iteration in mind, but with
    the goal of suspending the execution of code until it's resumed later on.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在探索生成器的迭代特性——我们一次产生一个值，通常我们只关心在`for`循环的每一步产生的每个值。这是关于生成器的一种非常逻辑的思考方式，但协程有不同的想法；尽管它们在技术上也是生成器，但它们并不是以迭代的概念来构思的，而是以在稍后恢复执行时挂起代码执行为目标。
- en: This is an interesting challenge; when we design a coroutine, we usually care
    more about suspending the state rather than iterating (and iterating a coroutine
    would be an odd case). The challenge lies in that it is easy to mix them both.
    This is because of a technical implementation detail; the support for coroutines
    in Python was built upon generators.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的挑战；当我们设计协程时，我们通常更关心挂起状态而不是迭代（迭代协程将是一个奇怪的情况）。挑战在于很容易将它们两者混合。这是因为一个技术实现细节；Python中对协程的支持建立在生成器的基础上。
- en: If we want to use coroutines to process some information and suspend its execution,
    it would make sense to think of them as lightweight threads (or green threads,
    as they are called in other platforms). In such a case, it would make sense if
    they could return values, much like calling any other regular function.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用协程来处理一些信息并挂起其执行，那么将它们视为轻量级线程（在其他平台上被称为绿色线程）是有意义的。在这种情况下，如果它们能够返回值，就像调用任何其他常规函数一样，那就更有意义了。
- en: But let's remember that generators are not regular functions, so in a generator,
    the construction `value = generator()` will do nothing other than create a generator
    object. What would be the semantics for making a generator return a value? It
    will have to be after the iteration is done.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们记住，生成器不是常规函数，所以在生成器中，构造`value = generator()`除了创建一个生成器对象之外，不会做任何事情。生成器返回值的语义应该是什么？它必须在迭代完成后才能进行。
- en: When a generator returns a value, its iteration is immediately stopped (it can't
    be iterated any further). To preserve the semantics, the `StopIteration` exception
    is still raised, and the value to be returned is stored inside the `exception`
    object. It's the responsibility of the caller to catch it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当生成器返回一个值时，其迭代立即停止（它不能再迭代）。为了保持语义，`StopIteration`异常仍然会被抛出，而要返回的值被存储在`exception`对象中。这是调用者的责任去捕获它。
- en: 'In the following example, we are creating a simple generator that produces
    two values and then returns a third. Notice how we have to catch the exception
    in order to get this value, and how it''s stored precisely inside the exception
    under the attribute named `value`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们创建了一个简单的生成器，它产生两个值，然后返回第三个。注意我们如何必须捕获异常才能获取这个值，以及它是如何精确地存储在异常的`value`属性下的：
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As we'll see later, this mechanism is used to make coroutines return values.
    Before PEP-380, this didn't make any sense, and any attempt at having a `return`
    statement inside a generator was considered a syntax error. But now, the idea
    is that, when the iteration is over, we want to return a final value, and the
    way to provide it is to store it in the exception being raised at the end of the
    iteration (`StopIteration`). That might not be the cleanest approach, but it's
    completely backward-compatible, as it doesn't change the interface of the generator.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后将会看到的，这个机制被用来使协程返回值。在PEP-380之前，这并没有什么意义，任何在生成器内部使用`return`语句的尝试都被视为语法错误。但现在，我们的想法是，当迭代结束时，我们想要返回一个最终值，而提供它的方式是将它存储在迭代结束时的异常中（`StopIteration`）。这可能不是最干净的方法，但它完全向后兼容，因为它没有改变生成器的接口。
- en: Delegating into smaller coroutines – the 'yield from' syntax
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 委派到更小的协程 - 'yield from' 语法
- en: The previous feature is interesting in the sense that it opens up a lot of new
    possibilities with coroutines (generators), now that they can return values. But
    this feature, by itself, would not be so useful without proper syntax support,
    because catching the returned value this way is a bit cumbersome.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的特性在意义上很有趣，因为它为协程（生成器）打开了大量新的可能性，现在它们可以返回值。但这个特性本身，如果没有适当的语法支持，将不会那么有用，因为以这种方式捕获返回值有点繁琐。
- en: This is one of the main features of the `yield from` syntax. Among other things
    (that we'll review in detail), it can collect the value returned by a sub-generator.
    Remember that we said that returning data in a generator was nice, but that, unfortunately,
    writing statements as `value = generator()` wouldn't work? Well, writing them
    as `value = yield from generator()` would.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`yield from`语法的最主要特性之一。在其他方面（我们将在详细回顾），它可以收集子生成器返回的值。记住我们说过，在生成器中返回数据是很好的，但不幸的是，将语句写成`value
    = generator()`是不行的？好吧，将它们写成`value = yield from generator()`就可以。
- en: The simplest use of yield from
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`yield from`的最简单用法'
- en: In its most basic form, the new `yield from` syntax can be used to chain generators
    from nested `for` loops into a single one, which will end up with a single string
    of all the values in a continuous stream.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最基本的形式中，新的`yield from`语法可以用来将嵌套的`for`循环中的生成器链式连接成一个单一的循环，最终得到一个连续流中所有值的单个字符串。
- en: A canonical example is about creating a function similar to `itertools.chain()`
    from the `standard` library. This is a very nice function because it allows you
    to pass any number of `iterables` and will return them all together in one stream.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子是创建一个类似于`itertools.chain()`的函数，这个函数来自`standard`库。这是一个非常好的函数，因为它允许你传递任意数量的`iterables`，并将它们全部作为一个流返回。
- en: 'The naïve implementation might look like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 天真的实现可能看起来像这样：
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It receives a variable number of `iterables`, traverses through all of them,
    and since each value is iterable, it supports a `for... in..` construction, so
    we have another `for` loop to get every value inside each particular iterable,
    which is produced by the caller function.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 它接收一个可变数量的`iterables`，遍历它们，由于每个值都是可迭代的，它支持`for... in..`构造，因此我们有一个额外的`for`循环来获取每个特定可迭代对象中的每个值，这些值是由调用函数产生的。
- en: This might be helpful in multiple cases, such as chaining generators together
    or trying to iterate things that it wouldn't normally be possible to compare in
    one go (such as lists with tuples, and so on).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能在多种情况下很有用，比如将生成器链式连接起来，或者尝试迭代那些通常不可能一次性比较的事物（比如列表和元组等）。
- en: 'However, the `yield from` syntax allows us to go further and avoid the nested
    loop because it''s able to produce the values from a sub-generator directly. In
    this case, we could simplify the code like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`yield from`语法允许我们更进一步，避免嵌套循环，因为它能够直接从子生成器产生值。在这种情况下，我们可以将代码简化如下：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Notice that for both implementations, the behavior of the generator is exactly
    the same:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于两种实现，生成器的行为完全相同：
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This means that we can use `yield from` over any other iterable, and it will
    work as if the top-level generator (the one the `yield from` is using) were generating
    those values itself.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以将 `yield from` 应用于任何其他可迭代对象，并且它将像顶级生成器（使用 `yield from` 的那个）自己生成这些值一样工作。
- en: 'This works with any iterable, and even generator expressions aren''t the exception.
    Now that we''re familiar with its syntax, let''s see how we could write a simple
    generator function that will produce all the powers of a number (for instance,
    if provided with `all_powers(2, 3)`, it will have to produce `2^0`, `2^1`,`...
    2^3`):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于任何可迭代对象，甚至生成器表达式也不例外。现在我们熟悉了它的语法，让我们看看我们如何编写一个简单的生成器函数，该函数将产生一个数的所有幂（例如，如果提供
    `all_powers(2, 3)`，它将必须产生 `2^0`，`2^1`，`... 2^3`）：
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: While this simplifies the syntax a bit, saving one line of a `for` statement
    isn't a big advantage, and it wouldn't justify adding such a change to the language.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这简化了语法，节省了一行 `for` 语句，但这并不是一个很大的优势，而且这不足以证明将这种改变添加到语言中的合理性。
- en: Indeed, this is actually just a side effect and the real raison d'être of the
    `yield from` construction is what we are going to explore in the following two
    sections.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这实际上只是一个副作用，`yield from` 构造的真正目的是我们将在接下来的两个部分中探讨的。
- en: Capturing the value returned by a sub-generator
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 捕获子生成器返回的值
- en: 'In the following example, we have a generator that calls another two nested
    generators, producing values in a sequence. Each one of these nested generators
    returns a value, and we will see how the top-level generator is able to effectively
    capture the return value since it''s calling the internal generators through `yield
    from`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们有一个生成器调用了另外两个嵌套生成器，按顺序产生值。这些嵌套生成器中的每一个都返回一个值，我们将看到顶级生成器是如何有效地捕获返回值的，因为它通过
    `yield from` 调用内部生成器：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is a possible execution of the code in `main` while it''s being iterated:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `main` 代码在迭代过程中的一个可能的执行情况：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The first line of `main` delegates into the internal generator, and produces
    the values, extracting them directly from it. This is nothing new, as we have
    already seen. Notice, though, how the `sequence()` generator function returns
    the end value, which is assigned in the first line to the variable named `step1`,
    and how this value is correctly used at the start of the following instance of
    that generator.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 的第一行将任务委托给内部生成器，并产生值，直接从中提取。这并不新鲜，因为我们已经看到了。注意，`sequence()` 生成器函数返回的结束值被分配在第一行给名为
    `step1` 的变量，以及这个值是如何在下一个生成器实例的开始处正确使用的。'
- en: In the end, this other generator also returns the second end value (`10`), and
    the main generator, in turn, returns the sum of them (`5+10=15`), which is the
    value we see once the iteration has stopped.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个其他的生成器也返回第二个结束值（`10`），而主生成器则返回它们的和（`5+10=15`），这就是迭代停止后我们看到的值。
- en: We can use `yield from` to capture the last value of a coroutine after it has
    finished its processing.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `yield from` 来捕获一个协程在完成其处理后的最后一个值。
- en: With this example and the ones presented in the previous section, you can get
    an idea of what the `yield from` construction does in Python. The `yield from`
    construction will take the generator, and forward the iteration of it downstream,
    but once it's done, it'll catch its `StopIteration` exception, get the value of
    it, and return that value to the caller function. The value attribute of the `StopIteration`
    exception becomes the result of the statement.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子和上一节中展示的例子，你可以了解 `yield from` 构造在 Python 中的工作原理。`yield from` 构造将获取生成器，并将其迭代传递到下游，但一旦完成，它将捕获其
    `StopIteration` 异常，获取其值，并将该值返回给调用函数。`StopIteration` 异常的值属性成为该语句的结果。
- en: This is a powerful construction, because in conjunction with the topic of the
    next section (how to send and receive contextual information from a sub-generator),
    this means coroutines can take the shape of something similar to threads.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个强大的构造，因为它与下一节的主题（如何从子生成器发送和接收上下文信息）结合，这意味着协程可以采取类似于线程的形状。
- en: Sending and receiving data to and from a sub-generator
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向子生成器发送和接收数据
- en: Now, we will see the other nice feature of the `yield from` syntax, which is
    probably what gives it its full power. As we already introduced when we explored
    generators acting as coroutines, we know that we can send values and throw exceptions
    at them, and, in such cases, the coroutine will either receive the value for its
    internal processing, or it will have to handle the exception accordingly.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到`yield from`语法的另一个优点，这可能是它全部力量的来源。正如我们在探索作为协程的生成器时已经介绍过的，我们知道我们可以向它们发送值和抛出异常，在这种情况下，协程将接收值以进行内部处理，或者它必须相应地处理异常。
- en: If we now have a coroutine that delegates into other ones (such as in the previous
    example), we would also like to preserve this logic. Having to do so manually
    would be quite complex (you can take a look at the code described in PEP-380 if
    we didn't have this handled by `yield from` automatically).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在有一个将任务委托给其他协程的协程（例如在之前的例子中），我们也希望保留这种逻辑。手动这样做将会非常复杂（如果`yield from`自动处理了这个问题，你可以查看PEP-380中描述的代码）。
- en: In order to illustrate this, let's keep the same top-level generator (main)
    unmodified with respect to the previous example (calling other internal generators),
    but let's modify the internal generators to make them able to receive values and
    handle exceptions.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们保持与之前例子（调用其他内部生成器）相同的顶层生成器（main）不变，但让我们修改内部生成器，使它们能够接收值和处理异常。
- en: 'The code is probably not idiomatic, only for the purposes of showing how this
    mechanism works:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能不是典型的用法，只是为了展示这个机制是如何工作的：
- en: '[PRE44]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we will call the `main` coroutine, not only by iterating it, but also
    by providing values and throwing exceptions at it in order to see how they are
    handled inside sequence:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过迭代它，并给它提供值以及抛出异常来调用`main`协程，以便观察它们在序列中的处理方式：
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This example is telling us a lot of different things. Notice how we never send
    values to `sequence`, but only to `main`, and even so, the code that is receiving
    those values is the nested generators. Even though we never explicitly send anything
    to `sequence`, it's receiving the data as it's being passed along by `yield from`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子告诉我们很多不同的事情。注意我们从未向`sequence`发送值，而只向`main`发送，即便如此，接收这些值的代码是嵌套的生成器。尽管我们从未明确地向`sequence`发送任何东西，但它仍然通过`yield
    from`传递数据时接收数据。
- en: The `main` coroutine calls two other coroutines internally, producing their
    values, and it will be suspended at a particular point in time in any of those.
    When it's stopped at the first one, we can see the logs telling us that it is
    that instance of the coroutine that received the value we sent. The same happens
    when we throw an exception to it. When the first coroutine finishes, it returns
    the value that was assigned in the variable named `step1`, and passed as input
    for the second coroutine, which will do the same (it will handle the `send()`
    and `throw()` calls, accordingly).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`协程内部调用两个其他协程，产生它们的值，并且它将在这些协程中的某个特定时间点挂起。当它停止在第一个协程上时，我们可以看到日志告诉我们是那个协程实例接收了我们发送的值。当我们向它抛出异常时，情况也是如此。当第一个协程完成时，它返回分配在名为`step1`的变量中的值，并将其作为输入传递给第二个协程，该协程将做同样的事情（它将处理`send()`和`throw()`调用，相应地）。'
- en: The same happens for the values that each coroutine produces. When we are at
    any given step, the return from calling `send()` corresponds to the value that
    the sub-coroutine (the one that `main` is currently suspended at) has produced.
    When we throw an exception that is being handled, the `sequence` coroutine produces
    the value `OK`, which is propagated to the called coroutine (`main`), and that
    in turn will end up at `main's` caller.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，每个协程产生的值也会发生这种情况。当我们处于任何给定步骤时，调用`send()`的返回值对应于子协程（`main`当前挂起的那个）产生的值。当我们抛出一个被处理的异常时，`sequence`协程产生值`OK`，这个值被传播到被调用的协程（`main`），然后最终到达`main`的调用者。
- en: As anticipated, these methods, together with `yield from`, provide us with a
    lot of new functionality (something that can resemble threads). This opens up
    the doors for asynchronous programming, which we will explore next.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，这些方法与`yield from`一起为我们提供了很多新的功能（这可以类似于线程）。这为异步编程打开了大门，我们将在下一节中探讨。
- en: Asynchronous programming
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程
- en: With the constructions we have seen so far, we can create asynchronous programs
    in Python. This means that we can create programs that have many coroutines, schedule
    them to work in a particular order, and switch between them when they're suspended
    after a `yield from` has been called on each of them.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们所看到的构造，我们可以在Python中创建异步程序。这意味着我们可以创建具有许多协程的程序，按特定顺序调度它们工作，并在每个协程在调用`yield
    from`后挂起时在它们之间切换。
- en: The main advantage that we can take from this is the possibility of parallelizing
    I/O operations in a non-blocking way. What we would need is a low-level generator
    (usually implemented by a third-party library) that knows how to handle the actual
    I/O while the coroutine is suspended. The idea is for the coroutine to effect
    suspension so that our program can handle another task in the meantime. The way
    the application would retrieve the control back is by means of the `yield from`
    statement, which will suspend and produce a value to the caller (as in the examples
    we saw previously when we used this syntax to alter the control flow of the program).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这里获得的主要优势是能够以非阻塞方式并行化I/O操作。我们需要的是一个低级生成器（通常由第三方库实现），它知道如何在协程挂起时处理实际的I/O。想法是让协程实现挂起，以便我们的程序可以在同时处理另一个任务。应用程序通过`yield
    from`语句恢复控制，这将挂起并产生一个值给调用者（正如我们在之前使用此语法改变程序控制流时的示例中看到的那样）。
- en: This is roughly the way asynchronous programming had been working in Python
    for quite a few years, until it was decided that better syntactic support was
    needed.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这大致是Python中异步编程工作了几年的方式，直到决定需要更好的语法支持。
- en: The fact that coroutines and generators are technically the same causes some
    confusion. Syntactically (and technically), they are the same, but semantically,
    they are different. We create generators when we want to achieve efficient iteration.
    We typically create coroutines with the goal of running non-blocking I/O operations.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 协程和生成器在技术上相同的事实造成了一些混淆。在语法（和技术）上，它们是相同的，但在语义上，它们是不同的。我们创建生成器是为了实现高效的迭代。我们通常创建协程的目的是运行非阻塞的I/O操作。
- en: 'While this difference is clear, the dynamic nature of Python would still allow
    developers to mix these different types of objects, ending up with a runtime error
    at a very late stage of the program. Remember that in the simplest and most basic
    form of the `yield from` syntax, we used this construction over iterable objects
    (we created a sort of `chain` function applied over strings, lists, and so on).
    None of these objects were coroutines, and it still worked. Then, we saw that
    we can have multiple coroutines, use `yield from` to send the value (or exceptions),
    and get some results back. These are clearly two very different use cases; however,
    if we write something along the lines of the following statement:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种区别很清楚，但Python的动态性质仍然允许开发者混合这些不同类型的对象，最终在程序非常晚的阶段出现运行时错误。记住，在最简单和最基本形式的`yield
    from`语法中，我们是在可迭代对象上使用这种构造（我们创建了一种应用于字符串、列表等的`chain`函数）。这些对象都不是协程，但仍然可以工作。然后，我们看到我们可以有多个协程，使用`yield
    from`发送值（或异常），并得到一些结果。这些显然是两种非常不同的用例；然而，如果我们编写类似以下语句的内容：
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It's not clear what `iterable_or_awaitable` returns. It can be a simple iterable
    such as a `string`, and it might still be syntactically correct. Or, it might
    be an actual coroutine. The cost of this mistake will be paid much later, at runtime.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterable_or_awaitable`返回的内容并不明确。它可能是一个简单的可迭代对象，例如一个`string`，并且可能仍然是语法正确的。或者，它可能是一个实际的协程。这个错误的代价将在很久以后，在运行时付出。'
- en: For this reason, the typing system in Python had to be extended. Before Python
    3.5, coroutines were just generators with a `@coroutine` decorator applied, and
    they were to be called with the `yield from` syntax. Now, there is a specific
    type of object the Python interpreter recognizes as such, that is, a coroutine.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Python中的类型系统必须得到扩展。在Python 3.5之前，协程只是应用了`@coroutine`装饰器的生成器，并且它们需要使用`yield
    from`语法来调用。现在，Python解释器识别出一种特定的对象，即协程。
- en: This change heralded syntax changes as well. The `await` and `async def` syntax
    were introduced. The former is intended to be used instead of `yield from`, and
    it only works with `awaitable` objects (which coroutines conveniently happen to
    be). Trying to call `await` with something that doesn't respect the interface
    of an `awaitable` will raise an exception (this is a good example of how interfaces
    can help to achieve a more solid design, preventing runtime errors).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这一变化也预示了语法的改变。引入了`await`和`async def`语法。前者旨在替代`yield from`，并且仅与`awaitable`对象（协程恰好是）一起使用。尝试用不遵守`awaitable`接口的东西调用`await`将引发异常（这是一个很好的例子，说明了接口如何有助于实现更稳固的设计，防止运行时错误）。
- en: '`async def` is the new way of defining coroutines, replacing the aforementioned
    decorator, and this actually creates an object that, when called, will return
    an instance of a coroutine. In the same way as when you invoke a generator function,
    the interpreter will return you a generator object, when you invoke an object
    defined with `async def`, it''ll give you a coroutine object that has an `__await__`
    method, and therefore can be used in await expressions.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`async def`是定义协程的新方法，取代了上述装饰器，并且实际上创建了一个对象，当调用它时，将返回一个协程的实例。与调用生成器函数的方式相同，解释器将返回一个生成器对象，当你调用用`async
    def`定义的对象时，它将给你一个具有`__await__`方法的协程对象，因此可以在`await`表达式中使用。'
- en: Without going into all the details and possibilities of asynchronous programming
    in Python, we can say that despite the new syntax and the new types, this is not
    doing anything fundamentally different from the concepts we have covered in this
    chapter.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入探讨Python异步编程的所有细节和可能性，我们可以这样说，尽管有新的语法和新类型，但这并没有做任何本质上与我们本章所讨论的概念不同的东西。
- en: The idea behind programming asynchronously in Python is that there is an `event`
    loop (typically `asyncio` because it's the one that is included in the `standard`
    library, but there are many others that will work just the same) that manages
    a series of coroutines. These coroutines belong to the event loop, which is going
    to call them according to its scheduling mechanism. When each one of these runs,
    it will call our code (according to the logic we have defined inside the coroutine
    we programmed), and when we want to get control back to the event loop, we call
    `await <coroutine>`, which will process a task asynchronously. The event loop
    will resume and another coroutine will take place while that operation is left
    running.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Python中异步编程的核心理念是存在一个`事件循环`（通常是`asyncio`，因为它包含在`标准`库中，但还有许多其他同样可以工作的循环），它管理一系列的协程。这些协程属于事件循环，它将根据其调度机制调用它们。当这些协程中的任何一个运行时，它将调用我们的代码（根据我们在编写的协程中定义的逻辑），当我们想要将控制权交还给事件循环时，我们调用`await
    <协程>`，这将异步处理一个任务。事件循环将继续运行，并启动另一个协程，同时之前的操作仍在进行中。
- en: This mechanism represents the basics of how asynchronous programming works in
    Python. You can think that the new syntax added for coroutines (`async def` /
    `await`) is just an API for you to write code in a way that's going to be called
    by the event loop. By default, that event loop will typically be `asyncio` because
    it's the one that comes in the `standard` library, but any event loop system that
    matches the API would work. This means you can use libraries like `uvloop` ([https://github.com/MagicStack/uvloop](https://github.com/MagicStack/uvloop))
    and `trio` ([https://github.com/python-trio/trio](https://github.com/python-trio/trio)),
    and the code would work the same. You can even register your own event loop, and
    it should also work the same (provided compliance with the API, that is).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制代表了Python中异步编程工作的基本原理。你可以认为为协程添加的新语法（`async def` / `await`）只是为你编写代码的一个API，以便由事件循环调用。默认情况下，该事件循环通常是`asyncio`，因为它包含在`标准`库中，但任何符合API的事件循环系统都可以工作。这意味着你可以使用像`uvloop`([https://github.com/MagicStack/uvloop](https://github.com/MagicStack/uvloop))和`trio`([https://github.com/python-trio/trio](https://github.com/python-trio/trio))这样的库，代码将按相同的方式工作。你甚至可以注册自己的事件循环，它也应该按相同的方式工作（前提是符合API规范）。
- en: In practice, there are more particularities and edge cases that are beyond the
    scope of this book. It is, however, worth mentioning that these concepts are related
    to the ideas introduced in this chapter and that this arena is another place where
    generators demonstrate being a core concept of the language, as there are many
    things constructed on top of them.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，还有更多特定的特性和边缘情况超出了本书的范围。然而，值得指出的是，这些概念与本章中介绍的思想相关，而且这个领域是另一个展示生成器作为语言核心概念的地方，因为许多东西都是建立在它们之上的。
- en: Magic asynchronous methods
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 魔法异步方法
- en: I've made the case in previous chapters (and hopefully convinced you) that whenever
    possible, we can take advantage of the magic methods in Python in order to make
    the abstractions we created blend naturally with the syntax of the language and
    this way achieve better, more compact, and perhaps cleaner code.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我在前几章中已经提出（并希望说服你）只要有可能，我们就可以利用Python中的魔法方法，使我们所创建的抽象与语言的语法自然融合，从而实现更好、更紧凑、可能更干净的代码。
- en: But what happens if on any of these methods we need to call a coroutine? If
    we have to call `await` in a function, that means the function itself would have
    to be a coroutine (defined with `async def`), or else there will be a syntax error.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果在这些方法中的任何一个我们需要调用协程怎么办？如果我们必须在函数中调用`await`，这意味着该函数本身必须是一个协程（使用`async def`定义），否则将会出现语法错误。
- en: But then, how does this work with the current syntax and magic methods? It doesn't.
    We need new syntax, and new magic methods, in order to work with asynchronous
    programming. The good news is that they're analogous to the previous ones.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这与当前的语法和魔法方法如何工作呢？它不起作用。我们需要新的语法和新的魔法方法才能与异步编程一起工作。好消息是，它们与之前的类似。
- en: Here's a summary of the new magic methods and how they relate to the new syntax.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对新魔法方法和它们如何与新语法相关的一个总结。
- en: '| Concept | Magic methods | Syntax usage |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 概念 | 魔法方法 | 语法用法 |'
- en: '| Context manager | `__aenter__``__aexit__` | `async with async_cm() as x:`...
    |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 上下文管理器 | `__aenter__` `__aexit__` | `async with async_cm() as x:`... |'
- en: '| Iteration | `__aiter__``__anext__` | `async for e in aiter:`... |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 迭代 | `__aiter__` `__anext__` | `async for e in aiter:`... |'
- en: 'Table 7.2: Asynchronous syntax and their magic methods'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.2：异步语法及其魔法方法
- en: This new syntax is mentioned in PEP-492 ([https://www.python.org/dev/peps/pep-0492/](https://www.python.org/dev/peps/pep-0492/)).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新语法在PEP-492中有所提及（[https://www.python.org/dev/peps/pep-0492/](https://www.python.org/dev/peps/pep-0492/))。
- en: Asynchronous context managers
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步上下文管理器
- en: 'The idea is simple: if we were to use a context manager but needed to call
    a coroutine on it, we couldn''t use the normal `__enter__` and `__exit__` methods
    because they''re defined as regular functions, so instead we need to use the new
    `__aenter__` and `__aexit__` coroutine methods. And instead of calling it merely
    using with, we''d have to use `async` with.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，如果我们想使用上下文管理器但需要在其上调用协程，我们不能使用正常的`__enter__`和`__exit__`方法，因为它们被定义为常规函数，所以我们需要使用新的`__aenter__`和`__aexit__`协程方法。而且，我们不仅需要使用`with`来调用它，还需要使用`async`
    with。
- en: There's even an `@asynccontextmanager` decorator available in the `contextlib`
    module, to create an asynchronous context manager in the same way as shown before.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在`contextlib`模块中甚至还有一个`@asynccontextmanager`装饰器，可以创建与之前所示相同的异步上下文管理器。
- en: 'The `async` with syntax for asynchronous context managers works in a similar
    way: when the context is entered, the `__aenter__` coroutine is called automatically,
    and when it''s being exited, `__aexit__` will trigger. It''s even possible to
    group multiple asynchronous context managers in the same `async` with statement,
    but it''s not possible to mix them with regular ones. An attempt of using a regular
    context manager with the `async` with syntax will fail with an `AttributeError`.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 异步上下文管理器的`async` with语法以类似的方式工作：当上下文进入时，`__aenter__`协程会自动调用，当它退出时，`__aexit__`将被触发。甚至可以在同一个`async`
    with语句中组合多个异步上下文管理器，但不能与常规的混合使用。尝试使用常规上下文管理器与`async` with语法将失败并抛出`AttributeError`。
- en: 'Our example from *Chapter 2*, *Pythonic Code*, would look like the following
    code if adapted to asynchronous programming:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将我们的例子从*第2章*，*Pythonic Code*，改编为异步编程，它将看起来像以下代码：
- en: '[PRE47]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Moreover, if we had more than one context manager that we wanted to use, we could
    do, for example:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们想使用多个上下文管理器，我们可以这样做，例如：
- en: '[PRE48]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you'd expect, the `contextlib` module provides the abstract base class `AbstractAsyncContextManager`,
    which requires the implementation of the `__aenter__` and `__aexit__` methods.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，`contextlib`模块提供了一个抽象基类`AbstractAsyncContextManager`，它要求实现`__aenter__`和`__aexit__`方法。
- en: Other magic methods
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他魔法方法
- en: 'What happens with the rest of the magic methods? Do they all get their asynchronous
    counterpart? No, but there''s something I wanted to point out about that: it shouldn''t
    be needed.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 那些其他魔法方法会发生什么？它们都会得到它们的异步对应物吗？不，但我想指出的是：这不应该需要。
- en: Remember that achieving clean code is in part about making sure you distribute
    the responsibilities correctly in the code and place things in their proper places.
    To give an example, if you're thinking about calling a coroutine inside a `__getattr__`
    method, there's something probably amiss in your design, as there should probably
    be a better place for that coroutine.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，编写干净代码的部分是确保你在代码中正确分配责任，并将事物放在适当的位置。举个例子，如果你在考虑在`__getattr__`方法中调用协程，那么你的设计可能存在问题，因为可能有一个更好的地方来放置那个协程。
- en: Coroutines that we await are used in order to have parts of our code running
    concurrently, so they typically relate to external resources being managed, whereas
    the logic we put in the rest of the magic methods `(__getitem__`, `__getattr__`,
    etc.) should be object-oriented code, or code that can be resolved in terms of
    solely the internal representation of that object.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们等待的协程用于使代码的某些部分并发运行，因此它们通常与外部资源的管理相关，而我们在其他魔法方法（`(__getitem__`, `__getattr__`,
    等）中放入的逻辑应该是面向对象的代码，或者可以仅根据该对象的内部表示来解决的代码。
- en: 'By the same token (and also following up on good design practices), it wouldn''t
    be good to make `__init__` a coroutine, because we typically want lightweight
    objects that we can initialize safely without side effects. Even better, we have
    already covered the benefits of using dependency injection, so that''s even more
    reason not to want an asynchronous initialization method: our object should work
    with dependencies already initialized.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地（并且遵循良好的设计实践），将`__init__`设计为协程并不是一个好的选择，因为我们通常希望创建轻量级对象，这样我们可以在没有副作用的情况下安全地初始化它们。更好的是，我们已经讨论了使用依赖注入的好处，因此这更是我们不希望有一个异步初始化方法的原因：我们的对象应该与已经初始化的依赖项一起工作。
- en: The second case of the previous table, asynchronous iteration, is of more interest
    for the purposes of this chapter, so we'll explore it in the next section.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 上一表的第二个案例，异步迭代，对于本章的目的来说更有兴趣，所以我们将在下一节中探讨它。
- en: The syntax for asynchronous iteration (`async` for) works with any asynchronous
    iterator, whether it is created by us (as we'll see how to do in the next section),
    or whether it's an asynchronous generator (which we'll see in the section after
    that).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 异步迭代的语法（`async for`）适用于任何异步迭代器，无论是我们自己创建的（我们将在下一节中看到如何做到这一点），还是异步生成器（我们将在下一节中看到）。
- en: Asynchronous iteration
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步迭代
- en: In the same way that we have the iterator objects we saw at the beginning of
    the chapter (that is, objects that support being iterated over with Python's built-in
    `for` loop), we can do the same, but in an asynchronous fashion.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在本章开头看到的迭代器对象（即支持使用Python内置的`for`循环进行迭代的对象）一样，我们也可以这样做，但以异步的方式进行。
- en: Imagine we want to create an iterator to abstract the way in which we read data
    from an external source (like a database), but the part that extracts the data
    itself is a coroutine, so we couldn't call it during the already familiar `__next__`
    operation as before. That's why we need to make use of the `__anext__` coroutine.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们想要创建一个迭代器来抽象我们从外部源（如数据库）读取数据的方式，但提取数据本身的操作是一个协程，所以我们不能像以前那样在已熟悉的`__next__`操作中调用它。这就是为什么我们需要使用`__anext__`协程的原因。
- en: 'The following example illustrates in a simple way how this can be achieved.
    Disregarding external dependencies, or any other accidental complexity, we''ll
    focus on the methods that make this type of operation possible, in order to study
    them:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例以简单的方式说明了如何实现这一点。不考虑外部依赖或任何其他意外复杂性，我们将专注于使此类操作成为可能的方法，以便研究它们：
- en: '[PRE49]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The first method, `__aiter__`, is used to indicate that the object is an asynchronous
    iterator. Just as in the synchronous version, most of the time it's enough to
    return self, and therefore it doesn't need to be a coroutine.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法，`__aiter__`，用于表示该对象是一个异步迭代器。正如在同步版本中，大多数情况下返回self就足够了，因此它不需要是一个协程。
- en: But `__anext__`, on the other hand, is precisely the part of our code where
    our asynchronous logic lies, so that needs to be a coroutine for starters. In
    this case, we're awaiting another coroutine in order to return part of the data
    to be returned.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 但另一方面，`__anext__`正是我们代码中异步逻辑所在的部分，因此它一开始就需要是一个协程。在这种情况下，我们正在等待另一个协程以返回要返回的部分数据。
- en: It also needs a separate exception in order to signal the end of the iteration,
    in this case, called `StopAsyncIteration`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 它还需要一个单独的异常来表示迭代的结束，在这种情况下，称为`StopAsyncIteration`。
- en: This exception works in an analogous way, only that it's meant for the `async
    for` kind of loops. When encountered, the interpreter will finish the loop.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这个异常以类似的方式工作，只是它是为`async for`类型的循环设计的。当遇到这种情况时，解释器将结束循环。
- en: 'This sort of object can be used in the following form:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对象可以用以下形式使用：
- en: '[PRE50]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can clearly see how this is analogous to the synchronous version we explored
    at the beginning of the chapter. One important distinction though is that, as
    we would expect, the `next()` function wouldn't work on this object (it doesn't
    implement `__next__` after all), so advancing an asynchronous generator by one
    place would require a different idiom.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地看到这与我们在本章开头探索的同步版本是如何类似的。不过，有一个重要的区别是，正如我们所预期的，`next()`函数不会在这个对象上工作（毕竟它没有实现`__next__`），因此要向前推进一个异步生成器，就需要不同的语法。
- en: 'Advancing the asynchronous iterator by one place could be achieved by doing
    something like the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下方式可以向前推进异步迭代器一个位置：
- en: '[PRE51]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: But more interesting constructions, like the ones we saw before about using
    the `next()` function to work over a generator expression to search for the first
    value that meets certain conditions, wouldn't be supported, because they're not
    capable of handling asynchronous iterators.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 但更有趣的结构，比如我们之前看到的，使用`next()`函数在生成器表达式中工作以搜索满足某些条件的第一值，将不会得到支持，因为它们无法处理异步迭代器。
- en: 'Inspired by the previous idiom, we can create a generator expression using
    the asynchronous iteration, and then take the first value from it. Better yet,
    we can create our own version of this function to work with asynchronous generators,
    which might look like this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 受到前面语法的启发，我们可以使用异步迭代创建一个生成器表达式，然后从中获取第一个值。更好的是，我们可以创建我们自己的这个函数版本来与异步生成器一起工作，它可能看起来像这样：
- en: '[PRE52]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Starting from Python 3.8, the `asyncio` module has a nice capability that allows
    us to interact with coroutines directly from the REPL. That way, we can test interactively
    how the previous code would work:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.8开始，`asyncio`模块有一个很好的功能，允许我们从REPL直接与协程交互。这样，我们可以交互式地测试前面的代码将如何工作：
- en: '[PRE53]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You'll note that it resembles the original `next()` function both in terms of
    interface and behavior.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到它在接口和行为上都与原始的`next()`函数相似。
- en: Now we know how to use iteration in asynchronous programming, but we can do
    better than that. Most of the time we just need a generator and not a whole iterator
    object. Generators have the advantage that their syntax makes them easier to write
    and understand, so in the next section, I'll mention how to create generators
    for asynchronous programs.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何在异步编程中使用迭代，但我们可以做得更好。大多数时候我们只需要一个生成器，而不是整个迭代器对象。生成器的优势在于它们的语法使得它们更容易编写和理解，所以在下节中，我将提到如何为异步程序创建生成器。
- en: Asynchronous generators
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步生成器
- en: Before Python 3.6, the functionality explored in the previous section was the
    only way to achieve asynchronous iteration in Python. Because of the intricacies
    of the coroutines and generators we explored in previous sections, trying to use
    the `yield` statement inside a coroutine was not entirely defined, hence not allowed
    (for example, would `yield` try to suspend the coroutine, or generate a value
    for the caller?).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.6之前，上一节中探索的功能是Python中实现异步迭代的唯一方法。由于我们在前几节中探讨了协程和生成器的复杂性，尝试在协程内部使用`yield`语句并没有完全定义，因此不允许（例如，`yield`会尝试挂起协程，还是为调用者生成一个值？）。
- en: Asynchronous generators were introduced in PEP-525 ([https://www.python.org/dev/peps/pep-0525/](https://www.python.org/dev/peps/pep-0525/)).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 异步生成器是在 PEP-525 中引入的 ([https://www.python.org/dev/peps/pep-0525/](https://www.python.org/dev/peps/pep-0525/))。
- en: 'The issue with the use of the `yield` keyword inside a coroutine was solved
    in this PEP, and it''s now allowed, but with a different and clear meaning. Unlike
    the first example of coroutines we have seen, `yield` inside a coroutine properly
    defined (with `async` def) doesn''t mean to suspend or pause the execution of
    that coroutine, but instead to produce a value for the caller. This is an asynchronous
    generator: same as the generators we''ve seen at the very beginning of the chapter,
    but that can be used in an asynchronous way (meaning they probably await other
    coroutines inside their definition).'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 PEP 中解决了在协程中使用 `yield` 关键字的问题，现在允许使用，但具有不同的和明确的意义。与我们所看到的第一个协程示例不同，协程中的
    `yield`（使用 `async def` 正确定义）并不意味着暂停或暂停该协程的执行，而是为调用者生成一个值。这是一个异步生成器：与我们在章节开头看到的生成器相同，但可以以异步方式使用（意味着它们可能在定义内部等待其他协程）。
- en: The main advantage of asynchronous generators over iterators is the same advantage
    regular generators have; they allow us to achieve the same thing but in a more
    compact way.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 异步生成器相对于迭代器的主要优势与常规生成器相同的优势；它们允许我们以更紧凑的方式实现相同的事情。
- en: 'As promised, the previous example looks more compact when written with an asynchronous
    generator:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 正如承诺的那样，使用异步生成器编写的上一个示例看起来更紧凑：
- en: '[PRE54]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This feels closer to a regular generator as the structure is the same except
    for the `async def` / `await` construction. Moreover, you'll have to remember
    fewer details (as to the methods that need implementation and the right exception
    that has to be triggered), so I'd recommend that whenever possible you try to
    favor asynchronous generators over iterators.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 它感觉更接近常规生成器，因为结构是相同的，只是多了 `async def` / `await` 构造。此外，你将不得不记住更少的细节（关于需要实现的方法和必须触发的正确异常），因此我建议，在可能的情况下，你应尽可能优先考虑异步生成器而不是迭代器。
- en: This concludes our journey through iteration in Python and asynchronous programming.
    In particular, this last topic we've just explored is the pinnacle of it, because
    it relates to all the concepts we've learned in this chapter.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们通过 Python 的迭代和异步编程之旅的结束。特别是，我们刚刚探讨的最后一个主题是它的巅峰，因为它与我们在这章中学到的所有概念都有关。
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Generators are everywhere in Python. Since their inception in Python a long
    time ago, they proved to be a great addition that makes programs more efficient
    and iteration much simpler.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器在 Python 中无处不在。自从它们在 Python 中很久以前引入以来，它们证明是一个伟大的补充，使程序更高效，迭代更简单。
- en: As time passed by, and more complex tasks needed to be added to Python, generators
    helped again in supporting coroutines.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，需要添加到 Python 中的更复杂任务越来越多，生成器再次帮助支持协程。
- en: And, while in Python coroutines are generators, we still don't have to forget
    that they're semantically different. Generators are created with the idea of iteration,
    while coroutines have the goal of asynchronous programming (suspending and resuming
    the execution of a part of our program at any given time). This distinction became
    so important that it made Python's syntax (and type system) evolve.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，尽管在 Python 中协程是生成器，我们仍然不能忘记它们在语义上是不同的。生成器是以迭代的概念创建的，而协程的目的是异步编程（在任何给定时间暂停和恢复我们程序的一部分执行）。这种区别变得如此重要，以至于它使
    Python 的语法（以及类型系统）发生了演变。
- en: Iteration and asynchronous programming constitute the last of the main pillars
    of Python programming. Now, it's time to see how everything fits together and
    to put all of these concepts we have been exploring over the past few chapters
    into action. This means that by now, you have a complete understanding of Python's
    capabilities.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代和异步编程构成了 Python 编程的主要支柱的最后一部分。现在，是时候看看所有这些内容是如何结合在一起的，并将我们在过去几章中探索的所有这些概念付诸实践。这意味着，到目前为止，你已经完全理解了
    Python 的功能。
- en: It's now time to use this to your advantage, so in the next chapters, we'll
    see how to put these concepts into action, related to more general ideas of software
    engineering, such as testing, design patterns, and architecture.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候利用这个优势了，所以接下来几章，我们将看到如何将这些概念付诸实践，与更通用的软件工程思想相关，如测试、设计模式和架构。
- en: We'll start this new part of our journey by exploring unit testing and refactoring
    in the next chapter.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章开始探索单元测试和重构这一新部分。
- en: References
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Here is a list of information you can refer to:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一份您可以参考的信息列表：
- en: '*PEP-234*: *Iterators* ([https://www.python.org/dev/peps/pep-0234/](https://www.python.org/dev/peps/pep-0234/))'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-234*: *迭代器* ([https://www.python.org/dev/peps/pep-0234/](https://www.python.org/dev/peps/pep-0234/))'
- en: '*PEP-255*: *Simple Generators* ([https://www.python.org/dev/peps/pep-0255/](https://www.python.org/dev/peps/pep-0255/))'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-255*: *简单生成器* ([https://www.python.org/dev/peps/pep-0255/](https://www.python.org/dev/peps/pep-0255/))'
- en: '*ITER-01*: *Python''s itertools module* ([https://docs.python.org/3/library/itertools.html](https://docs.python.org/3/library/itertools.html))'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ITER-01*: *Python的itertools模块* ([https://docs.python.org/3/library/itertools.html](https://docs.python.org/3/library/itertools.html))'
- en: '*GoF*: The book written by *Erich Gamma*, *Richard Helm*, *Ralph Johnson*,
    and *John Vlissides* named *Design Patterns: Elements of Reusable Object-Oriented
    Software*'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GoF*: 由*Erich Gamma*、*Richard Helm*、*Ralph Johnson*和*John Vlissides*合著的名为*设计模式：可重用面向对象软件元素*的书籍'
- en: '*PEP-342*: *Coroutines via Enhanced Generators* ([https://www.python.org/dev/peps/pep-0342/](https://www.python.org/dev/peps/pep-0342/))'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-342*: *通过增强生成器实现协程* ([https://www.python.org/dev/peps/pep-0342/](https://www.python.org/dev/peps/pep-0342/))'
- en: '*PYCOOK*: The book written by *Brian Jones* and *David Beazley* named *Python
    Cookbook: Recipes for Mastering Python 3, Third Edition*'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PYCOOK*: 由*Brian Jones*和*David Beazley*合著的名为*Python Cookbook: Recipes for
    Mastering Python 3, Third Edition*的书籍'
- en: '*PY99*: *Fake threads (generators, coroutines, and continuations)* ([https://mail.python.org/pipermail/python-dev/1999-July/000467.html](https://mail.python.org/pipermail/python-dev/1999-July/000467.html))'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PY99*: *模拟线程（生成器、协程和延续）* ([https://mail.python.org/pipermail/python-dev/1999-July/000467.html](https://mail.python.org/pipermail/python-dev/1999-July/000467.html))'
- en: '*CORO-01*: *Co Routine* ([http://wiki.c2.com/?CoRoutine](http://wiki.c2.com/?CoRoutine))'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CORO-01*: *协程* ([http://wiki.c2.com/?CoRoutine](http://wiki.c2.com/?CoRoutine))'
- en: '*CORO-02*: *Generators Are Not Coroutines* ([http://wiki.c2.com/?GeneratorsAreNotCoroutines](http://wiki.c2.com/?GeneratorsAreNotCoroutines))'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CORO-02*: *生成器不是协程* ([http://wiki.c2.com/?GeneratorsAreNotCoroutines](http://wiki.c2.com/?GeneratorsAreNotCoroutines))'
- en: '*PEP-492*: *Coroutines with async and await syntax* ([https://www.python.org/dev/peps/pep-0492/](https://www.python.org/dev/peps/pep-0492/))'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-492*: *使用async和await语法的协程* ([https://www.python.org/dev/peps/pep-0492/](https://www.python.org/dev/peps/pep-0492/))'
- en: '*PEP-525*: *Asynchronous Generators* ([https://www.python.org/dev/peps/pep-0525/](https://www.python.org/dev/peps/pep-0525/))'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-525*: *异步生成器* ([https://www.python.org/dev/peps/pep-0525/](https://www.python.org/dev/peps/pep-0525/))'
- en: '*TEE*: *The itertools.tee function* ([https://docs.python.org/3/library/itertools.html#itertools.tee](https://docs.python.org/3/library/itertools.html#itertools.tee))'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TEE*: *itertools.tee函数* ([https://docs.python.org/3/library/itertools.html#itertools.tee](https://docs.python.org/3/library/itertools.html#itertools.tee))'
