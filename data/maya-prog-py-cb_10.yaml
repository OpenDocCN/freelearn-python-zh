- en: Chapter 10. Advanced Topics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 高级主题
- en: 'In this chapter, we''ll look at the following few advanced topics that can
    be used to take your scripts farther:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下几个可以进一步扩展你的脚本的先进主题：
- en: Wrapping Python functionality in MEL
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Python功能封装在MEL中
- en: Creating custom tools using contexts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上下文创建自定义工具
- en: Using script jobs to trigger custom functionality
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脚本作业触发自定义功能
- en: Using script nodes to embed code in scenes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脚本节点在场景中嵌入代码
- en: Combining script jobs and script nodes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合脚本作业和脚本节点
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we'll look at a few advanced topics that can be used to give
    your scripts extra polish and make them easier to use for your teammates. We'll
    see how to make your scripts work like Maya's built-in tools using contexts, trigger
    custom functionality in response to events using script jobs, and embed code into
    a scene using script nodes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些可以用来给你的脚本增加额外光泽并使它们更容易为你的队友使用的先进主题。我们将了解如何使用上下文使你的脚本像Maya的内置工具一样工作，如何使用脚本作业在响应事件时触发自定义功能，以及如何使用脚本节点将代码嵌入场景中。
- en: Finally, we'll look at a tool that can be used to embed custom functionality
    in a scene and trigger it when a specific object is selected (very useful for
    invoking complex UIs for character rigs, for example).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨一个可以用来在场景中嵌入自定义功能并在选择特定对象时触发它的工具（例如，用于调用角色绑定的复杂UI非常有用）。
- en: Wrapping Python functionality in MEL
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Python功能封装在MEL中
- en: Although Python is definitely the preferred way to go about scripting for Maya,
    there are some features that still require you to use MEL. We'll be seeing several
    of those features in this chapter, but first we'll need to look at how to call
    Python code from MEL.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python无疑是Maya脚本编写的首选方式，但仍然有一些功能需要你使用MEL。在本章中，我们将探讨这些功能中的几个，但首先我们需要看看如何从MEL中调用Python代码。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First off, we''ll need a Python script to call. You can either use something
    you''ve already written or make something new. For the sake of this example, I''ll
    use a new script that simply creates a NURBS sphere at the origin, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个Python脚本进行调用。你可以使用你已编写的内容或者创建新的内容。为了这个示例，我将使用一个新脚本，该脚本简单地创建一个位于原点的NURBS球体，如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this example, we''ll create an MEL script that will in turn call our Python
    script. Create a new file and add the following code, being sure to save it with
    a `.mel` extension. In this case, we''ll create a file named `melToPython.mel`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个MEL脚本，该脚本将调用我们的Python脚本。创建一个新文件并添加以下代码，确保将其保存为`.mel`扩展名。在这种情况下，我们将创建一个名为`melToPython.mel`的文件：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that the function defined in the file has the same name as the file itself;
    this is a standard practice when creating MEL scripts, and it is used to indicate
    the entry point for the script. You can certainly have multiple functions within
    the script, but there should generally always be one with the same name as the
    file, and that function should be the starting point for your script.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，文件中定义的函数与文件本身的名称相同；这是创建MEL脚本时的标准做法，并且用于指示脚本的入口点。你当然可以在脚本中拥有多个函数，但通常应该始终有一个与文件名称相同的函数，并且该函数应该是脚本的开始点。
- en: 'Be sure to save the script to one of Maya''s default script locations. On a
    Mac system, that means:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将脚本保存到Maya的默认脚本位置之一。在Mac系统上，这意味着：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And on a PC, it means:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在PC上，这意味着：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once you've done this, you'll need to make sure that Maya is aware of the new
    script, which means calling the rehash MEL command from within Maya. Switch your
    command line to MEL by clicking to the left of the text field, where it says **Python**.
    Alternatively, switch to the **MEL** tab in the script editor and enter your code
    there.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你做了这件事，你需要确保Maya知道新的脚本，这意味着在Maya内部调用rehash MEL命令。通过点击文本字段左侧，显示为**Python**的位置切换你的命令行到MEL。或者，切换到脚本编辑器的**MEL**选项卡并输入你的代码。
- en: The rehash command forces Maya to re-examine its list of known script locations
    and take note of any new MEL scripts that have been added. This happens automatically
    every time Maya starts up, but if you make a new script with Maya open and attempt
    to run it without first calling rehash, Maya will give you an error.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: rehash命令强制Maya重新检查其已知的脚本位置列表，并注意任何新添加的MEL脚本。这会在Maya每次启动时自动发生，但如果你在Maya打开时创建了一个新脚本并尝试在调用rehash之前运行它，Maya会给你一个错误。
- en: Once you've run rehash, you can run our new MEL script by entering the name
    of the script into either the command line or the script editor. Doing so should
    result in a new NURBS sphere appearing at the origin.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行了 rehash，您可以通过在命令行或脚本编辑器中输入脚本名称来运行我们的新 MEL 脚本。这样做应该会在原点处出现一个新的 NURBS 球体。
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The MEL script is pretty straightforward. Note that functions are defined in
    a slightly different manner, with a few minor differences. The `proc` keyword
    (short for *procedure*) serves the same purpose as `def` in Python, indicating
    a named block of code. Also, instead of having a colon after the parentheses,
    curly brackets are used to enclose the actual code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: MEL 脚本相当直观。请注意，函数的定义方式略有不同，只有一些细微的差异。`proc` 关键字（代表 *procedure*）与 Python 中的 `def`
    具有相同的作用，表示一个命名的代码块。此外，与括号后跟冒号不同，实际代码用花括号括起来。
- en: The `global` keyword indicates that this particular function is meant to be
    called from outside the script. It is very common practice when writing MEL to
    have a global procedure with the same name as the file, which serves as the entry
    point for the script.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`global` 关键字表示这个特定的函数旨在从脚本外部调用。在编写 MEL 时，将具有与文件相同名称的全局过程作为脚本的入口点是常见的做法。'
- en: We're mainly interested in getting this script to invoke some Python functionality,
    though. To do that, we rely on the `python` MEL command. The `python` command
    takes a string as an argument and will attempt to run that string as a line of
    Python.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要感兴趣的是让这个脚本调用一些 Python 功能。为此，我们依赖于 `python` MEL 命令。`python` 命令接受一个字符串作为参数，并尝试将那个字符串作为
    Python 语句运行。
- en: 'For example, if we wanted to invoke Python''s `print` command from MEL, we
    could do the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想从 MEL 中调用 Python 的 `print` 命令，我们可以这样做：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that MEL differs from Python in that arguments to built-in functions are
    *not* enclosed in parentheses. So, in the previous example, the `python` command
    receives a string as its single argument. That string is passed to the Python
    interpreter and, in this case, results in some text being printed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，MEL 与 Python 不同，内置函数的参数 *不* 用括号括起来。所以，在上一个例子中，`python` 命令接收一个字符串作为其单个参数。这个字符串被传递给
    Python 解释器，在这种情况下，结果是一些文本被打印出来。
- en: 'To actually run a Python script from MEL, we''ll need to do two things:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 MEL 实际运行 Python 脚本，我们需要做两件事：
- en: Use the import statement to load the script
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `import` 语句加载脚本
- en: Invoke a function from within the script
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在脚本内部调用一个函数
- en: 'That means that we need to call MEL''s `python` command twice. Importing is
    fairly simple:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要调用 MEL 的 `python` 命令两次。导入相当简单：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The second line requires a bit of explanation. When we use the `import` command
    to load a script, the script is loaded as a module. Each of the functions defined
    in the script are attributes of the module. So, to invoke a function defined the
    script, we''ll want to use the following syntax:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行需要一些解释。当我们使用 `import` 命令加载脚本时，脚本被加载为一个模块。脚本中定义的每个函数都是模块的属性。因此，为了调用脚本中定义的函数，我们将想要使用以下语法：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Wrapping that in a string and passing it to MEL gives us the following for
    the `makeSphere()` function defined in the `pythonFromMel` script:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将其包裹在字符串中并传递给 MEL，我们得到 `pythonFromMel` 脚本中定义的 `makeSphere()` 函数如下：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We could optionally combine both the `import` statement and the call to `makeSphere`
    into a single line. To do that, we'll need to separate out the two statements
    with a semicolon. While Python doesn't *require* semicolons at the end of statements,
    it does allow them. In most cases, that's not necessary, but if you need to have
    multiple statements on a single line, it can be useful.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择将 `import` 语句和 `makeSphere` 调用合并到一行。为此，我们需要用分号分隔这两个语句。虽然 Python 不 *要求*
    在语句末尾使用分号，但它允许这样做。在大多数情况下，这并不是必需的，但如果需要在单行上放置多个语句，这可能会很有用。
- en: 'If we did that, we would end up with the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，我们最终会得到以下结果：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will prove useful later, when we need to pass in MEL commands to invoke
    Python functionality as a single line.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们需要将 MEL 命令作为单行传递以调用 Python 功能时很有用。
- en: There's more...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It should be mentioned that Maya provides a built-in utility for creating MEL
    scripts from a given Python script, in the `createMelWrapper` command, defined
    as part of the `maya.mel` library.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 应该提到的是，Maya 提供了一个内置实用程序，可以从给定的 Python 脚本创建 MEL 脚本，该实用程序是 `createMelWrapper`
    命令，它是 `maya.mel` 库的一部分。
- en: 'If we wanted to invoke that on the `makeSphere` function that we used in this
    example, we could do that by running the following code in the **Python** tab
    of the script editor:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在示例中使用的`makeSphere`函数上调用它，我们可以在脚本编辑器的**Python**标签中运行以下代码：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That would prompt you for a place to save the created MEL script. If you open
    the created script, you''ll see something like the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提示你保存创建的MEL脚本的位置。如果你打开创建的脚本，你会看到如下内容：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Differences in formatting aside, the generated script is almost identical to
    what we wrote. The only real difference is that it explicitly imports just the
    `makeSphere` command, rather than the entire `pythonFromMel` module.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了格式上的差异外，生成的脚本几乎与我们写的完全相同。唯一的真正区别是它明确导入了`makeSphere`命令，而不是整个`pythonFromMel`模块。
- en: Creating custom tools using contexts
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文创建自定义工具
- en: Many of Maya's tools are used in an interactive manner, with the user specifying
    inputs as needed, and actions taking place either when the necessary number of
    inputs have been provided, or the user hits the *Enter* key.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Maya的工具都是交互式使用的，用户根据需要指定输入，动作在提供必要数量的输入或用户按下*Enter*键时发生。
- en: So far, none of our scripts have worked this way—it has been necessary to have
    the user explicitly run the script, or press a button. That works fine for many
    things, but providing interactive input can add a lot of polish to a script. In
    this example, we'll be doing exactly that.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的脚本还没有这样工作过——需要用户明确运行脚本或按按钮。这对许多事情来说都很好，但提供交互式输入可以为脚本增添很多润色。在这个例子中，我们将做的是
    exactly that。
- en: We'll create a script that, once invoked, prompts the user to select two or
    more objects. When they press the *Enter* key, we'll create a locator at the average
    position of all of the objects. To do that, we'll need to create a custom context
    to implement our very own tool.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个脚本，一旦调用，就会提示用户选择两个或多个对象。当他们按下*Enter*键时，我们将在所有对象的平均位置创建一个定位器。为此，我们需要创建一个自定义上下文来实现我们自己的工具。
- en: '![Creating custom tools using contexts](img/4657_10_01.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![使用上下文创建自定义工具](img/4657_10_01.jpg)'
- en: Our custom tool in action. Left image is the tool while it's being used (notice
    the custom "AVG" icon on the left), and right image shows the result—a new locator
    at the average position of the selected objects
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义工具正在使用中。左图是使用工具时的样子（注意左侧的自定义"AVG"图标），右图显示了结果——在所选对象平均位置的新定位器。
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The script as presented makes use of a custom icon. While it''s not required,
    it''s a nice bit of polish. If you want to do that as well, create a 32 by 32
    pixel transparent PNG, and save it to the icons folder. On a mac, that would be:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如此呈现的脚本使用了自定义图标。虽然这不是必需的，但这是一项很好的润色。如果你想这么做，创建一个32x32像素的透明PNG文件，并将其保存到图标文件夹中。在mac上，应该是这样的：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '...and on a PC, it means:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '...在PC上，这意味着：'
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a new file and add the following code. Be sure to name it `customCtx.py`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，并添加以下代码。确保将其命名为`customCtx.py`。
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you run the script, you'll see that Maya activates your new icon in the left
    UI, just like is the case with any of the other tools. *Shift*-select at least
    two objects, and press the *Enter* key. You'll see a new locator appear at the
    averaged position of the selected objects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行脚本，你会看到Maya在你的左侧UI中激活了你的新图标，就像其他任何工具一样。*Shift*选择至少两个对象，然后按*Enter*键。你会看到一个新的定位器出现在所选对象平均位置。
- en: As an additional feature, you'll find that the *Y* hotkey, which can be used
    to re-invoke the most recently used tool, will also start your script over again.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 作为附加功能，你会发现*Y*快捷键，它可以用来重新调用最近使用的工具，也会再次启动你的脚本。
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First off, we create a couple of functions that will be used by the new context,
    one that gets called when it starts, and another that gets called when it ends.
    The `start` script is very simple (just prints some text) and is just included
    for demonstration purposes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建几个函数，这些函数将被新上下文使用，一个在它启动时被调用，另一个在它结束时被调用。`start`脚本非常简单（只是打印一些文本），只是为了演示目的而包含在内。
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The function that gets called at the end is a bit more involved, but still nothing
    too complex. We start by grabbing the currently-selected objects, and setting
    up a few variables—one to hold the number of objects, and one each for the x,
    y, and z position that we'll create the locator at.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令结束时调用的函数稍微复杂一些，但仍然不复杂。我们首先获取当前选定的对象，并设置一些变量——一个用于存储对象数量，一个用于我们将创建定位器的x、y和z位置。
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, we run through all of the objects and grab their position using the `xform`
    command in query mode. We add each of the x, y, and z positions to our variables
    to create a running tally of positions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历所有对象，并使用查询模式下的`xform`命令获取它们的位置。我们将每个x、y和z位置添加到我们的变量中，以创建一个位置的总计。
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We then divide each of the position variables by the number of objects to average
    the positions, create a new locator, and move it to the averaged position.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将每个位置变量除以对象数量以平均位置，创建一个新的定位器，并将其移动到平均位置。
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now for the fun part—actually setting up a custom context. We start by creating
    MEL strings that can be used to invoke our two functions. In both cases, they
    simply call one of the functions defined as part of our script.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候进行有趣的部分——实际上设置一个自定义上下文。我们首先创建可以用来调用我们的两个函数的MEL字符串。在两种情况下，它们只是调用我们脚本中定义的一个函数。
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that we're not explicitly importing `customCtx` before invoking the functions
    (as we did in the previous example). That's because we're using functionality
    defined within the same script, so if this code is executing at all, the `customCtx`
    script must have already been imported.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在调用函数之前没有明确导入`customCtx`（如前一个示例中所示）。这是因为我们正在使用同一脚本中定义的功能，所以如果此代码正在执行，则`customCtx`脚本必须已经导入。
- en: Now we're ready for the main event- creating a new context using the `scriptCtx`
    command.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好进行主要事件——使用`scriptCtx`命令创建一个新的上下文。
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, this is a pretty big command, so let's go through the arguments.
    First off, we use the `i1` flag to specify the icon to use for the tool. You can
    leave this out, but if you do, Maya will highlight a blank spot in the UI while
    your tool is active. Be sure to make the icon 32x32 pixels, and to put it in the
    icons folder (see *Getting ready*, above).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个相当大的命令，所以让我们来看看它的参数。首先，我们使用`i1`标志来指定工具要使用的图标。您可以省略这个标志，但如果这样做，Maya将在您的工具激活时在UI中突出显示一个空白区域。务必制作32x32像素的图标，并将其放入图标文件夹中（见上面的*准备就绪*）。
- en: Next, we set the title. This is also optional, but will make the text that appears
    a bit more useful for the user. Similarly, we could leave out the `setNoSelectionPrompt`
    flag, but it's best to leave it in. Setting both the title and `setNoSelectionPrompt`
    flag will cause helpful text to show up in bottom of Maya's interface.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置标题。这也是可选的，但会使显示的文本对用户更有用。同样，我们可以省略`setNoSelectionPrompt`标志，但最好保留它。设置标题和`setNoSelectionPrompt`标志将在Maya界面的底部显示有用的文本。
- en: Now we get to the meat of the command, with the `toolStart` and `finalCommandScript`
    flags. Both have to be passed a single string that corresponds to a MEL command
    that should be run either at the start of the script, or when *Enter* is pressed.
    We pass in the MEL strings that we created for each, which will in turn invoke
    Python functionality.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了命令的核心部分，即`toolStart`和`finalCommandScript`标志。两者都必须传递一个字符串，该字符串对应于应在脚本开始时或按下*Enter*键时运行的MEL命令。我们传递为每个创建的MEL字符串，这将反过来调用Python功能。
- en: The next set of flags all have to do with the specifics of the selection. First
    off, we set the number of selection sets to `1`, meaning that we want a single
    collection of items. After that, we use the `setSelectionCount` flag to specify
    that there should be at least two items selected for the tool to function. In
    this case, we also want to allow for the user to select more than two objects,
    so we set the `setAllowExcessCount` flag to `true`. Since we want to allow the
    user to specify a variable number of objects, and not finish the command until
    they press *Enter*, we need to set `setAutoComplete` to `false`. Setting it to
    `true` would cause the final command script to be run as soon as the user had
    selected objects equal to the `setSelectionCount` number. That's certainly useful
    in some cases, but isn't what we want here.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的一组标志都与选择的特定细节有关。首先，我们将选择集的数量设置为`1`，这意味着我们想要一个单独的项目集合。之后，我们使用`setSelectionCount`标志来指定至少需要选择两个项目以便工具能够运行。在这种情况下，我们还想允许用户选择超过两个对象，因此我们将`setAllowExcessCount`标志设置为`true`。由于我们希望允许用户指定可变数量的对象，并且不完成命令直到他们按下*Enter*，我们需要将`setAutoComplete`设置为`false`。将其设置为`true`会导致最终命令脚本在用户选择了等于`setSelectionCount`数量的对象时立即运行。这在某些情况下当然很有用，但不是我们想要的。
- en: Finally, we set the `toolCursorType` flag to `create`. That will set the cursor
    that gets used during the tool. Maya offers a number of different options, and
    choosing the best one for your purposes can be a great way to add a professional
    touch to your tool (as well as give the user some quality feedback). For the list
    of options, be sure to check the documentation for the `scriptCtx` command.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`toolCursorType`标志设置为`create`。这将设置在工具期间使用的光标。Maya提供了一系列不同的选项，为您的目的选择最佳选项可以是一种很好的方式来为您的工具增添专业感（同时为用户提供一些质量反馈）。有关选项列表，请务必查看`scriptCtx`命令的文档。
- en: Whew—that was a lot of flags, but we're done, and ready to wrap things up. At
    this point in the script, we've created the new context, but it is not yet active.
    To actually invoke the tool, we need to use the `setToolTo` command, and pass
    in the output of the call to `scriptCtx`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 呼——这有很多标志，但我们已经完成了，准备收尾。在这个脚本的这个点上，我们已经创建了新的上下文，但它尚未激活。要实际调用工具，我们需要使用`setToolTo`命令，并传入对`scriptCtx`的调用输出。
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: And with that, we've added a brand-new tool to Maya.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经为Maya添加了一个全新的工具。
- en: There's more...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this example, we created our own, custom tool. You can also invoke Maya's
    built-in tools by using the appropriate command to create a context of that type,
    and then switching to it using `setToolTo`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了自己的自定义工具。您也可以通过使用适当的命令来创建该类型的上下文，然后使用`setToolTo`切换到它，来调用Maya的内置工具。
- en: 'For example, you might be creating a script to allow users to create character
    rigs in a semi-automated way. You might, as a part of that, want to have the user
    create some bones that are then manipulated further by your system. You could
    have that process begin with the user creating some bones using the joint tool.
    To drop them straight into bone creation after invoking your script, you could
    use the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可能正在创建一个脚本，允许用户以半自动化的方式创建角色绑定。作为那部分的一部分，您可能希望用户创建一些骨骼，然后由您的系统进一步操作。您可以通过用户使用关节工具创建一些骨骼来开始这个过程。在调用您的脚本后直接将它们放入骨骼创建中，您可以使用以下方法：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are a large number of contexts that you can create—consult the Maya documentation
    for the full list.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建大量上下文——请参阅Maya文档以获取完整列表。
- en: 'Something else you might find useful is the ability to reset the current context,
    which will discard any input so far and reset the current tool. You can do that
    with either your own custom tools or with those built into Maya. Either way, reset
    the current tool with the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件您可能会发现有用的功能是能够重置当前上下文，这将丢弃迄今为止的所有输入并重置当前工具。您可以使用自己的自定义工具或内置在Maya中的工具来完成此操作。无论如何，以下是如何重置当前工具：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Contexts are a great way to add polish to your scripts, but should only really
    be used when it makes sense to have the user add input in an interactive way,
    or if you expect the user to want to use your tool more than once in rapid succession.
    If you have a script that you only expect the user to use once, with a limited
    (and fixed) number of inputs, it's likely easier to just provide a button. However,
    if your script needs to work with a variable number of inputs and or be called
    again on a new set without re-invoking the script, you may want to consider creating
    a context. Another way to look at it is that you should only use contexts when
    they would offer a net *reduction* in work (as measured in number of clicks) for
    the user.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文是给脚本增添润色的一种好方法，但只有在用户以交互方式添加输入有意义，或者你预计用户会多次快速连续使用你的工具时才真正应该使用。如果你有一个只期望用户使用一次的脚本，并且输入数量有限（且固定），那么直接提供一个按钮可能更容易。然而，如果你的脚本需要处理可变数量的输入，或者需要在新的集合上再次调用而不重新调用脚本，你可能想要考虑创建一个上下文。另一种看待它的方式是，你应该只在上下文能够为用户提供净*减少*工作量（以点击次数衡量）时使用。
- en: Using script jobs to trigger custom functionality
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用脚本作业触发自定义功能
- en: Script jobs offer another alternative to explicitly calling scripts, or pressing
    buttons, to invoke your functionality. By using script jobs, it is possible to
    trigger custom functionality based on either a specific condition or a specific
    event.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本作业提供了另一种替代方法，可以明确调用脚本或按按钮来调用你的功能。通过使用脚本作业，可以根据特定的条件或特定的事件触发自定义功能。
- en: In this example, we'll create a script job that will respond to the selection
    changed event by printing the name and type of the selected object to the console.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个脚本作业，该作业将响应选择更改事件，将所选对象的名称和类型打印到控制台。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'One of the things that makes script jobs so useful is the fact that they persist
    (as opposed to just running once). However, that can make developing scripts that
    use them a bit difficult, since if you change your code and re-run your script,
    you''ll end up with multiple script jobs in your scene. For that reason, it''s
    good to give yourself a way to easily clear out all existing script jobs. The
    following script will do just that:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本作业之所以非常有用，其中一个原因是它们会持续存在（而不是只运行一次）。然而，这可能会使得开发使用它们的脚本变得有些困难，因为如果你更改了代码并重新运行脚本，你会在场景中结束多个脚本作业。因此，给自己一个轻松清除所有现有脚本作业的方法是很好的。以下脚本将做到这一点：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Running the `scriptJob` command with the `killAll` flag will clear out all normal
    script jobs in the scene. However, script jobs can also be created as either `protected`
    or `permanent`. Adding the force flag will also clear out protected script jobs
    as well, but be careful with that, as Maya uses `scriptJobs` to implement some
    of its UI functionality. To be totally safe, leave off the `force=True` flag and
    make sure that the `scriptJobs` you create are not protected.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有`killAll`标志的`scriptJob`命令将清除场景中所有正常的脚本作业。然而，脚本作业也可以创建为`受保护的`或`永久的`。添加强制标志也会清除受保护的脚本作业，但请小心，因为Maya使用`scriptJobs`来实现其一些UI功能。为了完全安全，请省略`force=True`标志，并确保你创建的`scriptJobs`不是受保护的。
- en: Permanent script jobs will persist until you create a new scene, but that shouldn't
    come up in development. Even if you really do want a permanent script job, it's
    best to develop it with default priority and upgrade it to permanent only once
    you're certain that you're getting the functionality you want.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 永久性脚本作业将一直持续到您创建一个新的场景，但在开发过程中不应该出现这种情况。即使你真的想要一个永久性脚本作业，最好是以默认优先级进行开发，一旦你确定你得到了想要的功能，再将其升级为永久性。
- en: Be sure to have the above script (or similar) available before you start working
    with script jobs, as it will definitely make your life a lot easier.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始使用脚本作业之前，确保有上述脚本（或类似）可用，因为它肯定会让你的人生变得更加轻松。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new script and add the following code. Be sure to name the file `selectionOutput.py`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并添加以下代码。请确保将文件命名为`selectionOutput.py`：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Run the above script, and you should see text appear in the bottom of Maya's
    UI every time you select (or deselect) an object.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上面的脚本，每次你选择（或取消选择）一个对象时，你应该在Maya的UI底部看到文本出现。
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First off, note that we're importing the sys (or system) library in addition
    to our standard `maya.cmds`. That's to allow us to print text to the command line,
    so that it will be visible to the user even if they don't have the script editor
    open. More on that in a bit.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，我们除了导入标准的 `maya.cmds` 之外，还导入了 sys（或系统）库。这是为了允许我们将文本打印到命令行，以便即使在用户没有打开脚本编辑器的情况下，用户也能看到。关于这一点，我们稍后再详细说明。
- en: 'Before we create the `scriptJob`, we''ll want to create the code we want it
    to call. In this case, we''ll be triggering code every time the selection changes,
    and we want that code to examine the currently-selected object(s). We start, as
    we have in other examples, by using ls to grab the selection:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `scriptJob` 之前，我们想要创建它需要调用的代码。在这种情况下，我们将触发代码，每当选择发生变化时，我们希望该代码检查当前选定的对象。我们像在其他示例中做的那样开始，使用
    ls 来获取选择：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Then, if we find that there is nothing selected, we output some text to the
    command line.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们发现没有选择任何内容，我们将输出一些文本到命令行。
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And here's where that `sys` library comes in—by using `sys.stdout.write`, we
    are able to output text directly to the command line. That can be a good way to
    provide feedback to the users of your scripts, since you shouldn't expect them
    to have the script editor open. Note that we *could* have used either the error
    or warning commands as well, but since this text is simply output, and neither
    an error nor a warning, it is better to use `stdout.write`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这里，`sys` 库发挥了作用——通过使用 `sys.stdout.write`，我们能够直接将文本输出到命令行。这为向脚本的用户提供反馈提供了一种好方法，因为你不应该期望他们打开脚本编辑器。请注意，我们**也可以**使用错误或警告命令，但由于这段文本仅仅是输出，既不是错误也不是警告，因此使用
    `stdout.write` 更为合适。
- en: The rest of the `selectionChanged` function is pretty straightforward. The only
    slightly tricky thing is that if we look at the node type for the selected nodes
    themselves, we're guaranteed to get nothing but transforms. To avoid that, we
    first check to see if there are any shape nodes connected to the node in question.
    If there are, we append the node type for the shape to the name of the object,
    and output that to the command line.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectionChanged` 函数的其余部分相当直接。唯一稍微棘手的是，如果我们查看选定节点的节点类型，我们保证只会得到变换。为了避免这种情况，我们首先检查是否有任何形状节点连接到相关的节点。如果有，我们将形状的节点类型追加到对象的名称中，并将其输出到命令行。'
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now we're ready for the fun part—actually making `scriptJob`. All `scriptJobs`
    require that we specify either an event or a condition, along with some code to
    execute when the event is triggered, or when the condition assumes a given value
    (true, false, or when it changes).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好进行有趣的部分——实际上创建 `scriptJob`。所有 `scriptJobs` 都需要我们指定一个事件或条件，以及当事件被触发或条件假设给定值（true、false
    或当它改变）时执行的代码。
- en: It's important to note that the events and conditions must correspond to those
    that are built into Maya. In this case, we'll be using the `SelectionChanged`
    event as our trigger. This will fire every time the selection changes for any
    reason, and no matter how many objects are selected (including zero).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，事件和条件必须与 Maya 内置的事件和条件相对应。在这种情况下，我们将使用 `SelectionChanged` 事件作为触发器。每当选择因任何原因发生变化时，它都会触发，无论选择了多少对象（包括零个）。
- en: To actually create the `scriptJob`, we use the `scriptJob` command.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际创建 `scriptJob`，我们使用 `scriptJob` 命令。
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this case, we use the event flag to tell Maya that this `scriptJob` should
    be event-based (as opposed to being based on a condition). The value that we pass
    into the flag needs to be an array, with the first element being a string that
    corresponds to the event we want to watch for, and the second being a function
    to call in response.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用事件标志来告诉 Maya，这个 `scriptJob` 应该基于事件（而不是基于条件）。我们传递给标志的值需要是一个数组，其中第一个元素是我们想要监视的事件对应的字符串，第二个是响应时需要调用的函数。
- en: In this case, we want to call our `selectionChanged` function in response to
    the `SelectionChanged` event. We also include the `killWithScene` flag, which
    will cause `scriptJob` to be destroyed when we leave the current scene, which
    is generally a good idea. There are certainly valid reasons to have `scriptJob`
    persist from scene to scene, but unless you're sure that that's what you want,
    it's usually a good idea to prevent that from happening.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们希望在 `SelectionChanged` 事件发生时调用我们的 `selectionChanged` 函数。我们还包含了 `killWithScene`
    标志，当离开当前场景时，这将导致 `scriptJob` 被销毁，这通常是一个好主意。当然，有合理的理由让 `scriptJob` 在场景之间持续存在，但除非你确定这是你想要的，否则通常最好防止这种情况发生。
- en: And that's it! We will now have our custom function called each time the selection
    changes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在每次选择改变时，我们都会调用自定义函数。
- en: There's more...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the *Getting ready* section, we covered a simple script to delete *all* `scriptJobs`.
    That's fine during testing, but can be a bit heavy-handed sometimes. There are
    many situations where you might want to delete only a specific `scriptJob`—possibly
    because the functionality it is being used to implement is no longer necessary.
    That's easily done, but requires you specify which `scriptJob` you want to delete.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在*准备工作*部分，我们介绍了一个简单的脚本，用于删除*所有*`scriptJobs`。这在测试期间是可以的，但有时可能会有些过于强硬。有许多情况下你可能只想删除特定的`scriptJob`——可能是因为它所实现的功能不再必要。这很容易做到，但需要指定你想要删除的`scriptJob`。
- en: 'When creating a new script job, the `scriptJob` command will return an integer
    that can be used as the ID of the created script job. Later, you can use that
    number to delete that specific script job while leaving any other script jobs
    in the scene intact. If you want to delete a script job later, make sure to save
    the output to a variable as in:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的脚本作业时，`scriptJob`命令将返回一个整数，可以用作创建的脚本作业的ID。稍后，你可以使用这个数字来删除特定的脚本作业，同时保持场景中的其他脚本作业完好无损。如果你想稍后删除脚本作业，请确保将输出保存到变量中，如下所示：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, to delete the script job, call the `scriptJob` command again, but with
    the kill flag, and passing in the ID, as in:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要删除脚本作业，再次调用`scriptJob`命令，但这次带有终止标志，并传入ID，如下所示：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If the script job you''re trying to delete is protected, you''ll need to also
    set the `force` flag to `true`, as in:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图删除的脚本作业受保护，你需要也将`force`标志设置为`true`，如下所示：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also use the `scriptJob` command to get a list of all of the script
    jobs currently active. To do that, run it with the `listJobs` flag set to `True`.
    For example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`scriptJob`命令来获取当前所有活动的脚本作业列表。为此，运行它时将`listJobs`标志设置为`True`。例如：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '...which would result in something like the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '...这会导致以下结果：'
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '...as well as a long list of other script jobs used by Maya, as well as any
    that you have added. The number on the left is the ID of the job, and can be used
    to delete it (as long as it isn''t *permanent*).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '...以及Maya使用的其他长列表脚本作业，以及你添加的任何脚本作业。左侧的数字是作业的ID，可以用来删除它（只要它不是*永久的*）。'
- en: 'As an alternative to deleting all jobs, or deleting individual jobs by ID,
    you can also have Maya delete a script job when a given piece of UI is deleted.
    For example, if we wanted to have a script job that would only exist as long as
    a given window was open, we could do something like the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 作为删除所有作业或通过ID删除单个作业的替代方案，你还可以让Maya在删除给定的UI时删除脚本作业。例如，如果我们想要一个只在给定窗口打开时存在的脚本作业，我们可以做如下操作：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice the addition of the `parent` flag in the call to `cmds.scriptJob`. You
    can include that flag to tie the script job to a specific piece of UI. In this
    case, we tie the script job to the window.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在调用`cmds.scriptJob`时添加了`parent`标志。你可以包含该标志将脚本作业与特定的UI绑定。在这种情况下，我们将脚本作业绑定到窗口上。
- en: Using script nodes to embed code in scenes
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用脚本节点在场景中嵌入代码
- en: All of the examples we've seen so far exist as scripts, separate from the actual
    scene that they are run in. That's fine for tools, but means that if you create
    a script that is tightly tied to a particular scene (such as a custom control
    UI for a character rig), you have to be careful to make sure that the script file
    is always distributed along with the Maya file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的所有示例都作为脚本存在，与它们运行的场景是分开的。这对于工具来说是可以的，但如果你创建了一个与特定场景紧密相关的脚本（例如，用于角色绑定的自定义控制UI），你必须小心确保脚本文件始终与Maya文件一起分发。
- en: For such situations, Maya offers a better way. Script nodes can be used to bake
    scripts directly into a scene, allowing them to be run without any external dependencies.
    Furthermore, script nodes can be created with code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，Maya提供了一种更好的方法。可以使用脚本节点将脚本直接烘焙到场景中，这样它们就可以在没有任何外部依赖的情况下运行。此外，可以使用代码创建脚本节点。
- en: In this example, we'll create a script that will prompt the user for a Python
    file, and will then create a script node with the contents of the file, and set
    it up so that the script will be executed each time the file is opened.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个脚本，它会提示用户输入Python文件，然后创建一个包含文件内容的脚本节点，并设置脚本，以便每次文件打开时执行。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use the script we'll be creating, we'll need to have a script ready to embed.
    For the sake of the example, I'll be using a simple script that shows a window
    containing a single button to create a NURBS sphere.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们创建的脚本，我们需要有一个准备嵌入的脚本。为了举例，我将使用一个简单的脚本，该脚本显示一个包含创建 NURBS 球体按钮的窗口。
- en: 'The full script is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本如下：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new script and add the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并添加以下代码：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Run the script, and point the resulting file browser at the script that you
    want to embed. Save your file, and re-open it. You should see your embedded script
    run automatically.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，并将生成的文件浏览器指向您想要嵌入的脚本。保存您的文件，然后重新打开它。您应该看到您的嵌入脚本自动运行。
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first thing that we do is to invoke the `fileDialog2` command to prompt
    the user to provide a Python file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用 `fileDialog2` 命令来提示用户提供一个 Python 文件。
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the user cancels out of the dialog without specifying a file, `filePath`
    will be empty. We check for that and end the script early if it is.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在未指定文件的情况下取消对话框，`filePath` 将为空。我们检查这一点，并在必要时提前结束脚本。
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If we *do* have a file, we open it for reading, in text mode.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确实有一个文件，我们将以文本模式打开它进行读取。
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: At this point, we're ready to prep the script for embedding. The `scriptNode`
    command will be expecting a single string for the code that makes up the script
    node, so we'll need to create such a string. To do that, we'll start out with
    a blank string, and add each line of the python file specified by the user.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好为嵌入脚本做准备。`scriptNode` 命令将期望一个字符串，该字符串由构成脚本节点的代码组成，因此我们需要创建这样的字符串。为此，我们将从一个空字符串开始，并添加用户指定的
    python 文件的每一行。
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: At this point, the `scriptStr` variable holds the entire contents of the specified
    script. Since we're done with the file, we close it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`scriptStr` 变量包含指定脚本的全部内容。由于我们已经完成了文件，我们将关闭它。
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now we're ready to actually create the script node. Creating a script node requires
    that we specify a few different things. First off, we need to specify whether
    the script is MEL or Python, which we do with the `sourceType` flag.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们实际上可以创建脚本节点了。创建脚本节点需要我们指定一些不同的事情。首先，我们需要指定脚本是否为 MEL 或 Python，我们使用 `sourceType`
    标志来完成。
- en: We also need to specify the conditions under which the code in the script node
    will be run, which requires that we specify both a condition and whether the code
    should be executed either before or after it. In this case, we'll be using what
    is probably the most standard option, in that we'll have the script run once when
    the scene is first loaded.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要指定脚本节点中的代码将运行的条件，这需要我们指定一个条件和代码是否应该在它之前或之后执行。在这种情况下，我们将使用可能是最标准的选项，即脚本将在场景首次加载时运行一次。
- en: 'To do that, we want to use the **Execute on file load** option, and set our
    code using the `beforeScript` flag. Putting it all together gives us the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们想要使用 **文件加载时执行** 选项，并使用 `beforeScript` 标志设置我们的代码。将所有这些放在一起，我们得到以下内容：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `scriptType` flag specifies the condition, and needs to be an integer between
    `0` and `7`. Using a value of `2` will tie the node to the opening of the scene
    when not in batch mode. If you wanted to have the script run on opening even in
    batch mode, use `1` instead. Using a value of `0` will only run the code when
    it is explicitly invoked—more on that in a bit. The other options are less commonly
    used—see the documentation for details.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`scriptType` 标志指定条件，需要是一个介于 `0` 和 `7` 之间的整数。使用 `2` 的值将节点绑定到非批处理模式下的场景打开时。如果您想在批处理模式下打开时也运行脚本，请使用
    `1`。使用 `0` 的值将仅在代码被明确调用时运行代码——稍后我会详细介绍。其他选项使用较少——请参阅文档以获取详细信息。'
- en: Note that there is also an `afterScript` flag which can be used to tie code
    execution to after the given event. If you use that with either of the file load
    options (1 or 2), it will cause the code to be executed when the file is closed.
    You can specify scripts for both the `beforeScript` and `afterScript` flags if
    you want.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，还有一个 `afterScript` 标志，可以用来将代码执行绑定到给定事件之后。如果您与文件加载选项（1 或 2）一起使用它，它将在文件关闭时执行代码。如果您想为
    `beforeScript` 和 `afterScript` 标志指定脚本，您可以这样做。
- en: There's more...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can also use `scriptNodes` to embed functionality that doesn''t execute
    on its own, but is triggered directly. To do that, specify a value of 0 for the
    `scriptType` (corresponding to the **Execute on demand** option). Then, when you
    want to invoke the code, call it in the following way:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`scriptNodes`嵌入不自行执行但直接触发的功能。为此，将`scriptType`的值指定为0（对应于**按需执行**选项）。然后，当你想要调用代码时，可以按以下方式调用：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: … to run the "before" script, or..
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: …运行“之前”脚本，或者..
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '...to run the "after" script.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '...运行“之后”脚本。'
- en: As you work with script nodes, it can be helpful to verify that they have been
    created without directly triggering them. To do that, go to **Windows** | **Animation
    Editors** | **Expression Editor**. From the expression editor, go to **Select
    Filte**r | **By Script Node Name**. You'll see the interface change, and a list
    of the script nodes in your scene appear. Clicking on any of them will allow you
    to alter its properties and view or edit the corresponding code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与脚本节点一起工作时，验证它们是否已创建而不直接触发它们可能会有所帮助。为此，请转到**窗口** | **动画编辑器** | **表达式编辑器**。从表达式编辑器中，转到**选择过滤器**
    | **按脚本节点名称**。你会看到界面发生变化，并出现场景中脚本节点的列表。点击任何一个都会允许你更改其属性并查看或编辑相应的代码。
- en: '![There''s more...](img/4657_10_02.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/4657_10_02.jpg)'
- en: You can also delete script nodes from this window, if you need to.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你也可以从这个窗口中删除脚本节点。
- en: Combining script jobs and script nodes
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并脚本作业和脚本节点
- en: One of the great things about script jobs, and script nodes, is that you can
    use script nodes to ensure that a given script job travels along with your scene.
    For example, you might want to use a script job to trigger a custom character
    rig UI any time the user selects a certain object in the scene.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本作业和脚本节点中的一个优点是，你可以使用脚本节点确保给定的脚本作业随着场景移动。例如，你可能想使用脚本作业在用户选择场景中的某个特定对象时触发自定义角色绑定UI。
- en: 'In this example, we''ll create a script that will make it really easy to set
    such things up. Our script will perform the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个脚本，这将使设置此类事情变得非常容易。我们的脚本将执行以下操作：
- en: It will ask the user to point it at a Python file with one or more functions
    to create UI
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将要求用户将其指向一个包含一个或多个函数以创建UI的Python文件
- en: It will present the user with a list of all functions defined in the file in
    a scroll list
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将以滚动列表的形式向用户展示文件中定义的所有函数
- en: It will allow the user to select an object in the scene and a named function
    from the file
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将允许用户从文件中选择场景中的对象和命名函数
- en: It will embed the contents of the function into the scene as a script node,
    along with a script job that will run the function every time the specified object
    is selected
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将函数的内容嵌入场景作为脚本节点，并附带一个脚本作业，每次选择指定的对象时都会运行该函数
- en: Getting ready
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To use the script we''ll be writing, you''ll need to have a script with at
    least one top-level function definition. Note that the current form of the script
    cannot parse functionality that is part of a class, and will only deal with a
    single function at a time, so make sure that all of your functionality is self-contained
    in a single function. For best results, make sure your input file looks something
    like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们将要编写的脚本，你需要有一个至少包含一个顶级函数定义的脚本。请注意，当前脚本的格式无法解析类中的功能，并且一次只能处理一个函数，所以请确保所有功能都包含在单个函数中。为了获得最佳效果，请确保你的输入文件看起来像这样：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new script and add the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并添加以下内容：
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First off, we create a class for our UI, in order to make it easier to pass
    data around.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为我们的UI创建一个类，以便更容易地传递数据。
- en: 'In the `__init__` function, we add three items:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__init__`函数中，我们添加了三项：
- en: A button to load and parse a source file
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个按钮用于加载和解析源文件
- en: A button to tie a specific function to the selection of a specific object
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个按钮将特定函数与特定对象的选取绑定
- en: A `textScrollList` command to hold the function names and allow the user to
    select them
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`textScrollList`命令来保存函数名并允许用户选择它们
- en: We also give ourselves a `commandList` variable, which is a dictionary that
    we'll be using to hold the commands found in the file. The index of each element
    will be the name of the function, and the value will be the entire source code
    for that function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为自己提供了一个`commandList`变量，这是一个我们将用它来保存文件中找到的命令的字典。每个元素的索引将是函数的名称，值将是该函数的整个源代码。
- en: Note
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Dictionaries are one of Python's built-in data structures, and are equivalent
    to what are sometimes called **associative arrays** in other languages. The big
    difference between dictionaries and lists is that, in lists, you specify entries
    by a numerical index, while with dictionaries you specify entries by name.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是Python内置的数据结构之一，在其他语言中有时被称为**关联数组**。字典和列表之间的大不同在于，在列表中，你通过数字索引指定条目，而在字典中，你通过名称指定条目。
- en: For example, you can create a simple dictionary with `myDict = {'foo':1, 'bar':2}`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用`myDict = {'foo':1, 'bar':2}`创建一个简单的字典。
- en: '…which would create a dictionary with two entries—one for `foo` and another
    for `bar`. Accessing those values looks a lot like indexing into a list, just
    with the name instead of a number, as in `print(myDict[''foo''] # would print
    1`.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: …这将创建一个包含两个条目的字典——一个用于`foo`，另一个用于`bar`。访问这些值的方式与列表索引非常相似，只是用名称代替了数字，例如`print(myDict['foo'])`会打印出1。
- en: 'Putting that all together gives us the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们得到以下内容：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Next up, we implement the `loadScript` function. We start by clearing out our
    `commandList` variable, in case the user is specifying a new file, then ask them
    to point us at a Python source file to load.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现`loadScript`函数。我们首先清除`commandList`变量，以防用户指定了一个新文件，然后要求他们指向一个要加载的Python源文件。
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If we find a file, we open in in read mode.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到一个文件，我们以读取模式打开它。
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now we're ready to actually read the file. We start by creating two variables—one
    to hold the human-friendly function name, which we'll display in the `textScrollList`
    command, and another to hold the actual source code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好实际读取文件了。我们首先创建两个变量——一个用来存储人类友好的函数名，我们将它在`textScrollList`命令中显示，另一个用来存储实际的源代码。
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Once we''ve done that, we start parsing the file. We loop through the file
    in the same way that we''ve done in previous examples, reading each line in turn—the
    only difference is how we parse the contents. Setting aside the handling of the
    file contents for a moment, the outer part of our parsing should look familiar:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们做了这些，我们就开始解析文件。我们以与之前示例相同的方式遍历文件，逐行读取——唯一的区别是我们如何解析内容。暂时不考虑文件内容的处理，我们解析的外部部分应该看起来很熟悉：
- en: '[PRE51]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Onto the parsing—what we want to do is to capture all of the text for each function.
    That means we want everything from the line that defines the function to the function's
    end. Finding the end of the function requires some thought, however. What we're
    looking for is not only a blank line but, more specifically, a blank line that
    does *not* have a tab character.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是解析——我们想要捕获每个函数的所有文本。这意味着我们想要从定义函数的行到函数结束的所有内容。然而，找到函数的结束需要一些思考。我们寻找的不仅是一个空白行，而是一个**不包含制表符**的空白行。
- en: We start by ignoring the import statement. We test to see if the current line
    starts with `import` and if so, we use the pass statement to skip doing anything.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先忽略导入语句。我们检查当前行是否以`import`开头，如果是，我们使用`pass`语句来跳过执行任何操作。
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that we could use the `continue` statement to skip the rest of the loop,
    but that would also skip the line responsible for reading in the next line of
    the file, leaving us with an infinite loop.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以使用`continue`语句跳过循环的其余部分，但这也会跳过负责读取文件下一行的行，导致无限循环。
- en: Next, we check to see if the line starts with `def`, indicating that it represents
    a new function definition.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查该行是否以`def`开头，这表示它代表一个新的函数定义。
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If it does, we want to start collecting the code for the new function, but
    first we want to save the function that we were previously stepping through, if
    one exists. To do that, we check to see if our `functionName` and `functionStr`
    variables are blank. If they both have contents, it is because we were previously
    saving another function, which we insert into our function list as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是，我们想要开始收集新函数的代码，但首先我们想要保存我们之前正在逐步执行的函数，如果有的话。为了做到这一点，我们检查`functionName`和`functionStr`变量是否为空。如果它们都有内容，这意味着我们之前保存了另一个函数，我们将它按以下方式插入到我们的函数列表中：
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This would happen if the file that we're parsing had a new function definition
    on the line directly below a previous function, with no blank lines in between.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在解析的文件在上一行函数的下一行有一个新的函数定义，且中间没有空白行，那么这种情况就会发生。
- en: Now that we've dealt with the previous function (if there was one), we're ready
    to start storing our new function. We'll start by getting a more human-friendly
    form of the function name by discarding the `def` keyword, as well as the parentheses
    and colon.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了之前的函数（如果有的话），我们准备开始存储我们的新函数。我们将从通过丢弃`def`关键字、括号和冒号来获取函数的更人性化的形式开始。
- en: 'To do that, we first use the split function to break the line up into an array
    by spaces, giving us `def` in the first index and something like `myFunction():`
    in the second. We then use replace to remove the `():`. That gives us:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们首先使用split函数通过空格将行拆分成一个数组，第一个索引是`def`，第二个索引是类似`myFunction():`的内容。然后我们使用replace来移除`():`。这给了我们：
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Finally, we set our `functionStr` variable to the entire line. As we continue
    to parse the file, we'll add additional lines to this variable. When we encounter
    either a new `def` statement, or truly empty (no tab character) lines, we'll store
    the entire `functionStr` into our list of commands.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`functionStr`变量设置为整行。在我们继续解析文件的过程中，我们将向这个变量添加额外的行。当我们遇到新的`def`语句或真正空白的（没有制表符）行时，我们将整个`functionStr`存储到我们的命令列表中。
- en: '[PRE56]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Speaking of blank lines, that's the next thing that we check for. If the line
    contains nothing but whitespace characters, running it through the `strip()` function
    will give us an empty string. If we do find an empty string, we might be at the
    end of the current function, but we'll want to make sure by testing to see if
    the current line starts with a tab.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 说到空白行，这是我们接下来要检查的。如果该行只包含空白字符，通过运行`strip()`函数将得到一个空字符串。如果我们确实找到一个空字符串，我们可能处于当前函数的末尾，但我们需要通过测试当前行是否以制表符开头来确保这一点。
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If we do have a truly blank line (no tabs), and we've been building up a function,
    now's the time to store it to our list. Once again, we check to make sure that
    both our `functionName` and `functionStr` variables have contents, and if they
    do, we store the function code into our `commandList`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确实有一个真正的空白行（没有制表符），并且我们一直在构建一个函数，现在就是时候将它存储到我们的列表中。再次检查，确保我们的`functionName`和`functionStr`变量都有内容，如果有，我们将函数代码存储到我们的`commandList`中。
- en: '[PRE58]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In order to prevent the script from storing the same function more than once
    (in the event of multiple blank lines), we also reset both our `functionName`
    and `functionStr` variables to be blank.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止脚本存储同一个函数多次（在出现多个空白行的情况下），我们还将`functionName`和`functionStr`变量重置为空白。
- en: If none of the above code has been triggered, we know that we have a non-blank
    line that starts with neither `import` or `def`. We'll assume that any such line
    is a valid line of code, and is part of the current function. As such, we simply
    add it on to our `functionStr` variable.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述代码没有任何一个被触发，我们知道我们有一个非空白行，它既不以`import`开头也不以`def`开头。我们将假设任何这样的行都是一条有效的代码行，并且是当前函数的一部分。因此，我们只需将其添加到我们的`functionStr`变量中。
- en: '[PRE59]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: And with that, we're done parsing our file, and we close it. At this point,
    our `commandList` dictionary will have an entry for each function in the file.
    We'll want to show those functions to the user by adding them to our scroll list,
    which we do in our `updateList` function.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就完成了文件的解析，并关闭了它。在这个时候，我们的`commandList`字典将为文件中的每个函数都有一个条目。我们想要通过将它们添加到我们的滚动列表中向用户展示这些函数，我们在`updateList`函数中这样做。
- en: '[PRE60]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the `updateList` function, we want to first clear out the contents of `scrollList`,
    and then add an entry for each of the functions we found. Both are easily done
    by calling the `textScrollList` command in edit mode. First, we clear it out:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在`updateList`函数中，我们首先想要清空`scrollList`的内容，然后为找到的每个函数添加一个条目。这两个操作都可以通过在编辑模式下调用`textScrollList`命令轻松完成。首先，我们将其清空：
- en: '[PRE61]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then we run through our list of commands and add the name of each to the list
    with the `append` flag:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们遍历我们的命令列表，并将每个命令的名称添加到带有`append`标志的列表中：
- en: '[PRE62]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now all that's left is to implement the function that will actually create the
    script node. First, we want to make sure that the user has selected both a command
    from the scroll list and an object in the scene. To get the currently selected
    item in the scroll list, we use the `textScrollList` command once again, but this
    time in query mode.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是实现创建脚本节点的函数。首先，我们想要确保用户已经从滚动列表中选择了一个命令，并且在场景中选择了一个对象。为了获取滚动列表中当前选中的项，我们再次使用`textScrollList`命令，但这次是在查询模式下。
- en: '[PRE63]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note that we have a `[0]` at the end of the `textScrollList` command. That's
    necessary, since `textScrollList` widgets can allow for multiple item selection.
    As a result, the output of querying `selectItem` may have multiple values, and
    is returned as an array. Adding the `[0]` gives us the first element (if there
    is one).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`textScrollList`命令的末尾有一个`[0]`。这是必要的，因为`textScrollList`小部件可以允许多项目选择。因此，查询`selectItem`的输出可能有多个值，并以数组形式返回。添加`[0]`给我们第一个元素（如果有的话）。
- en: 'Our code for grabbing the selected object is simple, and should look very familiar
    indeed:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取所选对象的代码很简单，看起来确实很熟悉：
- en: '[PRE64]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If we have *both* an object and a command, we're ready to dive into the script
    node creation. If we don't, we display an error message to the user.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们既有对象又有命令，我们就准备好深入脚本节点创建。如果没有，我们向用户显示错误消息。
- en: 'For our script node, what we want is code that will perform the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的脚本节点，我们想要的代码将执行以下操作：
- en: Run on the start of the scene.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景开始时运行。
- en: Include the definition of the selected function.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含所选函数的定义。
- en: Include the definition of a function that can be run every time the selection
    changes. That function will need to compare the currently selected object to the
    target object and, if there's a match, invoke the trigger function
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个可以在每次选择更改时运行的函数的定义。该函数需要将当前选定的对象与目标对象进行比较，如果匹配，则调用触发函数。
- en: Create a script job tied to the `SelectionChanged` event.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个与`SelectionChanged`事件绑定的脚本作业。
- en: '![How it works...](img/4657_10_03.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/4657_10_03.jpg)'
- en: 'Left: the UI displaying a list of functions in the input file. Right: the result-
    selecting the specified sphere triggers a custom UI.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧：显示输入文件中函数列表的UI。右侧：选择指定的球体将触发一个自定义UI。
- en: That's a number of steps, but ultimately it all amounts to constructing a big
    string that has all of the features listed above. We start off by setting our
    string to the `import maya.cmds as cmds` line that we've been using in all of
    our scripts.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一系列步骤，但最终都归结为构建一个包含上述所有功能的字符串。我们首先将字符串设置为我们在所有脚本中使用的`import maya.cmds as cmds`行。
- en: '[PRE65]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note that there are two newline characters at the end of the line. That will
    make things more readable, and make it easier to check the results in the expression
    editor in case there are problems.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，行尾有两个换行符。这会使内容更易于阅读，并在表达式编辑器中检查结果时，如果出现问题，会更容易。
- en: Next, we add the code for the command we want to trigger. This is really easy,
    since we have all of the code stored in our `commandList` dictionary. All we need
    to do is to index into it using the command name that the user selected.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加我们想要触发的命令的代码。这非常简单，因为我们已经将所有代码存储在我们的`commandList`字典中。我们只需要使用用户选择的命令名称来索引它。
- en: '[PRE66]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now we need to create the code for the function responsible for checking the
    current selection against the target object and running the target script. To
    do that, we'll need to string together some boilerplate code and the specific
    names (of the object and function) that we happen to have.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个函数的代码，该函数负责检查当前选择与目标对象是否匹配，并运行目标脚本。为此，我们需要将一些模板代码和特定的名称（对象和函数的名称）组合在一起。
- en: 'In situations like this, it''s generally helpful to write out what the result
    should look like given a specific input first. Let''s say that we wanted to trigger
    a function named `myFunction` if an object named `triggerObject` was selected.
    To do that, we could use the following function:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，首先写出给定特定输入的结果通常是有帮助的。假设我们想要在选择了名为`triggerObject`的对象时触发一个名为`myFunction`的函数。为此，我们可以使用以下函数：
- en: '[PRE67]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Easy enough, right? All we need to do is to add the above text to our `nodeStr`
    variable, making sure that we replace the object and function name, and that we
    add proper tabs (`\t`) and newline characters (`\n`) so that we follow proper
    Python whitespace rules.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？我们只需要将上述文本添加到我们的`nodeStr`变量中，确保替换对象和函数名称，并添加适当的制表符（`\t`）和换行符（`\n`），以便遵循正确的Python空白规则。
- en: 'That ends up giving us the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这最终给出了以下：
- en: '[PRE68]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'All that''s left is to add the code that will create a script job to properly
    tie our `testSelection` method to the `SelectionChanged` event. We add one final
    line to our `nodeStr` variable to do just that, as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是添加将创建脚本作业以正确地将我们的`testSelection`方法绑定到`SelectionChanged`事件的代码。我们只需在`nodeStr`变量中添加一行来完成此操作，如下所示：
- en: '[PRE69]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We're very close to done, but what we have is still just a big chunk of text.
    To actually make it into a script node, we'll need to pass it into the `scriptNode`
    command as the `beforeScript` value, with `scriptType=2` in order to have it run
    at scene startup.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经非常接近完成，但我们目前拥有的仍然只是一大块文本。为了将其真正变成一个脚本节点，我们需要将其作为`beforeScript`值传递给`scriptNode`命令，并设置`scriptType=2`，以便在场景启动时运行。
- en: '[PRE70]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: And that's it! We now have a way to embed arbitrary UI code into a scene and
    have it trigger when a given object is selected.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在有了一种将任意UI代码嵌入场景并在给定对象被选中时触发它的方法。
- en: There's more...
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As it stands, this example is more of a proof of concept than a proper tool.
    In the interest of brevity, I was forced to leave out several things that one
    would want, but the script could easily be extended to include all of them.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个例子更多的是一个概念验证，而不是一个合适的工具。出于简洁的考虑，我被迫省略了一些人们可能希望包含的内容，但脚本可以很容易地扩展以包括所有这些内容。
- en: First off, the script only deals with single functions. For a proper character
    rig UI, it would be likely that we would want to include a collection of functions,
    possibly bundled together into one or more classes. In order to support that,
    the script would need to be changed to either copy the entire contents of a source
    file to the script node, or to have more sophisticated parsing of the file contents
    to include multiple functions.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个脚本只处理单个函数。对于一个合适的角色绑定UI，我们可能希望包括一个函数集合，可能捆绑在一个或多个类中。为了支持这一点，脚本需要被修改为要么复制源文件的全部内容到脚本节点，要么对文件内容进行更复杂的解析以包括多个函数。
- en: Also, the script as written would not work as desired if it was used more than
    once in the same scene, since every pairing of function and object uses the same
    name (`testSelection`) for the function tied to the script job.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果脚本在同一场景中被多次使用，它将不会按预期工作，因为每个函数和对象的配对都使用相同的名称（`testSelection`）来关联脚本作业。
- en: 'To fix that, we would want to ensure that each script job gets its own uniquely-named
    function to test the selection. One way to do that would be to append the name
    of the function that we ultimately want to trigger to the `testSelection` function
    name, as in:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们希望确保每个脚本作业都有一个唯一命名的函数来测试选择。实现这一目标的一种方法是将我们最终想要触发的函数名称附加到`testSelection`函数名称上，如下所示：
- en: '[PRE71]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
