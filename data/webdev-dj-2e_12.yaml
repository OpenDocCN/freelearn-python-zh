- en: 12\. Building a REST API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12. 构建REST API
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces **REST APIs** and **Django REST Framework** (**DRF**).
    You will start by implementing a simple API for the Bookr project. Next, you will
    learn about the serialization of model instances, which is a key step in delivering
    data to the frontend side of Django applications. You will explore different types
    of API views, including both functional and class-based types. By the end of this
    chapter, you will be able to implement custom API endpoints, including simple
    authentication.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了**REST API**和**Django REST框架**（**DRF**）。你将从为Bookr项目实现一个简单的API开始。接下来，你将学习模型实例的序列化，这是将数据传递到Django应用前端的关键步骤。你将探索不同类型的API视图，包括函数式和基于类的类型。到本章结束时，你将能够实现自定义API端点，包括简单的身份验证。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we learned about templates and class-based views. These
    concepts greatly help expand the range of functionalities we can provide to the
    user on the frontend (that is, in their web browser). However, that is not sufficient
    to build a modern web application. Web apps typically have the frontend built
    with an entirely separate library, such as **ReactJS** or **AngularJS**. These
    libraries provide powerful tools for building dynamic user interfaces; however,
    they do not communicate directly with our backend Django code or database. The
    frontend code simply runs in the web browser and does not have direct access to
    any data on our backend server. Therefore, we need to create a way for these applications
    to "talk" to our backend code. One of the best ways to do this in Django is by
    using REST APIs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了模板和基于类的视图。这些概念极大地帮助我们扩展了提供给用户的前端（即在他们的网络浏览器中）的功能范围。然而，这还不足以构建一个现代Web应用程序。Web应用程序通常使用完全独立的库来构建前端，例如**ReactJS**或**AngularJS**。这些库提供了构建动态用户界面的强大工具；然而，它们不能直接与我们的后端Django代码或数据库通信。前端代码仅在网络浏览器中运行，并且无法直接访问后端服务器上的任何数据。因此，我们需要创建一种方法，让这些应用程序能够“与”我们的后端代码“交流”。在Django中实现这一点的最佳方法之一就是使用REST
    API。
- en: '**API** stands for **Application Programming Interface**. APIs are used to
    facilitate interaction between different pieces of software, and they communicate
    using **HTTP** (**Hypertext Transfer Protocol**). This is the standard protocol
    for communication between servers and clients and is fundamental to information
    transfer on the web. APIs receive requests and send responses in HTTP format.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**API**代表**应用程序编程接口**。API用于促进不同软件组件之间的交互，并且它们使用**HTTP**（**超文本传输协议**）进行通信。这是服务器和客户端之间通信的标准协议，是网络信息传输的基础。API以HTTP格式接收请求并发送响应。'
- en: In our use case in this chapter, an API will help facilitate interaction between
    our Django backend, and our frontend JS code. For example, imagine that we want
    to create a frontend application that allows users to add new books to the Bookr
    database. The user's web browser would send a message (an HTTP request) to our
    API to say that they want to create an entry for a new book, and perhaps include
    some details about the book in that message. Our server would send back a response
    to report on whether the book was successfully added or not. The web browser would
    then be able to display to the user the outcome of their action.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的使用案例中，API将帮助我们促进Django后端和前端JS代码之间的交互。例如，想象一下我们想要创建一个前端应用程序，允许用户向Bookr数据库添加新书。用户的网络浏览器会向我们的API发送一条消息（一个HTTP请求），表示他们想要为新书创建一个条目，并可能在该消息中包含一些关于书籍的细节。我们的服务器会发送一个响应来报告书籍是否成功添加。然后网络浏览器将能够向用户显示他们操作的结果。
- en: REST APIs
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API
- en: '**REST** stands for **Representational State Transfer**. Most modern web APIs
    can be classified as REST APIs. REST APIs are simply a type of API that focuses
    on communicating and synchronizing the *state* of objects between the database
    server and frontend client.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**代表**表示性状态转移**。大多数现代Web API都可以归类为REST API。REST API是一种简单的API类型，它专注于在数据库服务器和前端客户端之间通信和同步对象的**状态**。'
- en: For example, imagine that you are updating your details on a website for which
    you are signed into your account. When you go to the account details page, the
    web server tells your browser about the various details attached to your account.
    When you change the values on that page, the browser sends back the updated details
    to the web server and tells it to update these details on the database. If the
    action is successful, the website will show you a confirmation message.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下你正在更新你登录账户的网站上的详细信息。当你访问账户详情页面时，网络服务器会告诉你的浏览器与你账户相关的各种详细信息。当你更改该页面的值时，浏览器会将更新后的详细信息发送回网络服务器，并告诉它更新数据库中的这些详细信息。如果操作成功，网站将显示确认消息。
- en: This is a very simple example of what is known as **decoupled** architecture
    between frontend and backend systems. Decoupling allows greater flexibility and
    makes it easier to update or change components in your architecture. So, let's
    say you want to create a new frontend website. In such a case, you don't have
    to change the backend code at all, as long as your new frontend is built to make
    the same API requests as the old one.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的例子，说明了前端和后端系统之间所知的 **解耦** 架构。解耦提供了更大的灵活性，并使得更新或更改架构中的组件变得更加容易。所以，假设你想创建一个新的前端网站。在这种情况下，你根本不需要更改后端代码，只要你的新前端能够构建出与旧的一个相同的
    API 请求即可。
- en: REST APIs are *stateless*, which means that neither the client nor the server
    stores any states in-between to do the communication. Every time a request is
    made, the data is processed, and a response is sent back without having to store
    any intermediate data by the protocol itself. What this means is that the API
    is processing each request in isolation. It doesn't need to store information
    regarding the session itself. This is in contrast to a stateful protocol (such
    as **TCP**), which maintains information regarding the session during its life.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 是 *无状态的*，这意味着客户端和服务器在通信过程中都不会存储任何状态。每次请求时，数据都会被处理，并返回响应，而无需协议本身存储任何中间数据。这意味着
    API 正在独立处理每个请求。它不需要存储有关会话本身的信息。这与维护会话信息的 **TCP** 等有状态协议形成对比。
- en: So, a **RESTful web service**, as the name suggests, is a collection of REST
    APIs used to carry out a set of tasks. For example, if we develop a set of REST
    APIs for the Bookr application to carry out a certain set of tasks, then we can
    call it a RESTful web service.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如其名所示，**RESTful 网络服务**是一组用于执行一系列任务的 REST API 的集合。例如，如果我们为 Bookr 应用程序开发一组用于执行特定任务的
    REST API，那么我们可以称它为 RESTful 网络服务。
- en: Django REST Framework
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django REST 框架
- en: '**Django REST Framework**, also called **DRF** for short, is an open-source
    Python library that can be used to develop REST APIs for a Django project. DRF
    has most of the necessary functionality built in to help develop APIs for any
    Django project. Throughout this chapter, we will be using it to develop APIs for
    our Bookr project.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**Django REST 框架**，简称 **DRF**，是一个开源的 Python 库，可用于为 Django 项目开发 REST API。DRF
    内置了大多数必要的功能，以帮助开发任何 Django 项目的 API。在本章中，我们将使用它来为我们的 Bookr 项目开发 API。'
- en: Installation and Configuration
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置
- en: 'Install `djangorestframework` in the `virtual env` setup along with PyCharm.
    Enter the following code in your Terminal app or Command Prompt to do this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PyCharm 的虚拟环境设置中安装 `djangorestframework`。在您的终端应用程序或命令提示符中输入以下代码来完成此操作：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, open the `settings.py` file and add `rest_framework` to `INSTALLED_APPS`
    as shown in the following snippet:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 `settings.py` 文件，并将 `rest_framework` 添加到 `INSTALLED_APPS` 中，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You are now ready to start using DRF to create your first simple API.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好开始使用 DRF 创建你的第一个简单 API。
- en: Functional API Views
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能性 API 视图
- en: 'In *Chapter 3*, *URL Mapping, Views, and Templates*, we learned about simple
    functional views that take a request and return a response. We can write similar
    functional views using DRF. However, note that class-based views are more commonly
    used, and will be covered next. A functional view is created by simply adding
    the following decorator onto a normal view, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 3 章*，*URL 映射、视图和模板* 中，我们学习了简单的功能性视图，它接受一个请求并返回一个响应。我们可以使用 DRF 编写类似的函数视图。然而，请注意，基于类的视图更常用，将在下一章中介绍。一个功能性视图是通过简单地在一个普通视图上添加以下装饰器来创建的，如下所示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This decorator takes the functional view and turns it into a subclass of the
    DRF `APIView`. It's a quick way to include an existing view as part of your API.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器将功能视图转换为 DRF 的 `APIView` 子类。这是一种快速地将现有视图作为 API 部分包含进来的方法。
- en: 'Exercise 12.01: Creating a Simple REST API'
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.01：创建一个简单的 REST API
- en: 'In this exercise, you will create your first REST API using DRF and implement
    an endpoint using a functional view. You will create this endpoint to view the
    total number of books in the database:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用 DRF 创建您的第一个 REST API，并使用功能视图实现一个端点。您将创建这个端点来查看数据库中的书籍总数：
- en: Note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You'll need to have DRF installed on your system to proceed with this exercise.
    If you haven't already installed it, make sure you refer to the section titled
    *Installation and Configuration* earlier in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在本系统上安装 DRF 才能继续此练习。如果您尚未安装，请确保您参考了本章前面标题为 *安装和配置* 的部分。
- en: Create `api_views.py` in the `bookr/reviews` folder.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bookr/reviews` 文件夹中创建 `api_views.py`。
- en: REST API views work like Django's conventional views. We could have added the
    API views, along with the other views, in the `views.py` folder. However, having
    our REST API views in a separate file will help us maintain a cleaner code base.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: REST API 视图的工作方式类似于 Django 的传统视图。我们本可以将 API 视图以及其他视图一起添加到 `views.py` 文件夹中。但是，将我们的
    REST API 视图放在单独的文件中将帮助我们保持代码库的整洁。
- en: 'Add the following code in `api_views.py`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `api_views.py` 中添加以下代码：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: from . import views, api_views
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 . 导入 views, api_views
- en: urlpatterns = [path('api/first_api_view/)',\
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: urlpatterns = [path('api/first_api_view/',)]
- en: path(api_views.first_api_view)
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: path(api_views.first_api_view)
- en: …
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …
- en: ']'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We could also use the Linux `curl` (client URL) command to send an HTTP request
    as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以使用 Linux 的 `curl`（客户端 URL）命令发送 HTTP 请求，如下所示：
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Alternatively, if you are using Windows 10, you can make an equivalent HTTP
    request with `curl.exe` from Command Prompt as follows:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，如果您使用的是 Windows 10，您可以通过命令提示符使用 `curl.exe` 发送等效的 HTTP 请求，如下所示：
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this exercise, we learned how to create an API view using DRF and a simple
    functional view. We will now look at a more elegant way to convert between information
    stored in the database and what gets returned by our API using serializers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何使用 DRF 创建 API 视图和使用简单功能视图。现在我们将探讨一种更优雅的方法，使用序列化器在数据库中存储的信息和 API
    返回的信息之间进行转换。
- en: Serializers
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化器
- en: By now, we are well versed in the way Django works with data in our application.
    Broadly, the columns of a database table are defined in a class in `models.py`,
    and when we access a row of the table, we are working with an instance of that
    class. Ideally, we often just want to pass this object to our frontend application.
    For example, if we wanted to build a website that displayed a list of books in
    our Bookr app, we would want to call the `title` property of each book instance
    to know what string to display to the user. However, our frontend application
    knows nothing about Python and needs to retrieve this data through an HTTP request,
    which just returns a string in a specific format.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们对 Django 在我们的应用程序中处理数据的方式已经非常熟悉。从广义上讲，数据库表中的列是在 `models.py` 中的一个类中定义的，当我们访问表中的一行时，我们正在处理该类的实例。理想情况下，我们通常只想将此对象传递给我们的前端应用程序。例如，如果我们想构建一个显示
    Bookr 应用程序中书籍列表的网站，我们就会调用每个书籍实例的 `title` 属性，以知道向用户显示什么字符串。然而，我们的前端应用程序对 Python
    一无所知，需要通过 HTTP 请求检索这些数据，该请求只返回特定格式的字符串。
- en: 'This means that any information translated between Django and the frontend
    (via our API) must be done by representing the information in **JavaScript Object
    Notation** (**JSON**) format. JSON objects look similar to a Python dictionary,
    except there are some extra rules that constrict the exact syntax. In our previous
    example in *Exercise 12.01*, *Creating a Simple REST API*, the API returned the
    following JSON object containing the number of books in our database:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在 Django 和前端（通过我们的 API）之间转换的任何信息都必须通过以 **JavaScript 对象表示法**（**JSON**）格式表示信息来完成。JSON
    对象看起来与 Python 字典相似，但有一些额外的规则限制了确切的语法。在我们的上一个示例 *练习 12.01*，*创建一个简单的 REST API* 中，API
    返回了以下包含我们数据库中书籍数量的 JSON 对象：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: But what if we wanted to return the full details about an actual book in our
    database with our API? DRF's `serializer` class helps to convert complex Python
    objects into formats such as JSON or XML so that they can be transmitted across
    the web using the HTTP protocol. The part of DRF that does this conversion is
    named `serializer`. Serializers also perform deserialization, which refers to
    converting serialized data back into Python objects, so that the data can be processed
    in the application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想通过我们的API返回数据库中实际书籍的完整详细信息呢？DRF的`serializer`类帮助将复杂的Python对象转换为JSON或XML等格式，以便可以通过HTTP协议在网络上传输。DRF中执行此转换的部分被称为`serializer`。序列化器还执行反序列化，这指的是将序列化数据转换回Python对象，以便在应用程序中处理。
- en: 'Exercise 12.02: Creating an API View to Display a List of Books'
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.02：创建一个API视图以显示书籍列表
- en: 'In this exercise, you will use serializers to create an API that returns a
    list of all books present in the `bookr` application:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用序列化器创建一个API，该API返回`bookr`应用程序中所有书籍的列表：
- en: Create a file named `serializers.py` in the `bookr/reviews` folder. This is
    the file where we will place all the serializer code for the APIs.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bookr/reviews`文件夹中创建一个名为`serializers.py`的文件。这是我们放置所有API序列化代码的文件。
- en: 'Add the following code to `serializers.py`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`serializers.py`中：
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the first line imports the serializers from the `rest_framework` module.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，第一行从`rest_framework`模块导入了序列化器。
- en: Following the imports, we have defined two classes, `PublisherSerializer` and
    `BookSerializer`. As the names suggest, they are serializers for the `Publisher`
    and `Book` models respectively. Both these serializers are subclasses of `serializers.Serializer`
    and we have defined field types for each serializer such as `CharField`, `URLField`,
    and `EmailField`, and so on.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在导入之后，我们定义了两个类，`PublisherSerializer`和`BookSerializer`。正如其名称所暗示的，它们分别是`Publisher`和`Book`模型的序列化器。这两个序列化器都是`serializers.Serializer`的子类，并且我们为每个序列化器定义了字段类型，如`CharField`、`URLField`和`EmailField`等。
- en: Look at the `Publisher` model in the `bookr/reviews/models.py` file. The `Publisher`
    model has `name`, `website`, and `email` attributes. So, to serialize a `Publisher`
    object, we need `name`, `website`, and `email` attributes in the `serializer`
    class, which we have defined accordingly in `PublisherSerializer`. Similarly,
    for the `Book` model, we have defined `title`, `publication_date`, `isbn`, and
    `publisher` as the desired attributes in `BookSerializer`. Since `publisher` is
    a foreign key for the `Book` model, we have used `PublisherSerializer` as the
    serializer for the `publisher` attribute.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查看`bookr/reviews/models.py`文件中的`Publisher`模型。`Publisher`模型有`name`、`website`和`email`属性。因此，为了序列化`Publisher`对象，我们需要在`serializer`类中包含`name`、`website`和`email`属性，我们已经在`PublisherSerializer`中相应地定义了这些属性。同样，对于`Book`模型，我们在`BookSerializer`中定义了`title`、`publication_date`、`isbn`和`publisher`作为所需的属性。由于`publisher`是`Book`模型的外键，我们已将`PublisherSerializer`用作`publisher`属性的序列化器。
- en: 'Open `bookr/reviews/api_views.py`, remove any pre-existing code, and add the
    following code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`bookr/reviews/api_views.py`，删除任何现有的代码，并添加以下代码：
- en: '[PRE9]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the second line, we have imported the newly created `BookSerializer` from
    the `serializers` module.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第二行，我们从`serializers`模块导入了新创建的`BookSerializer`。
- en: 'We then add a functional view, `all_books` (as in the previous exercise). This
    view takes a query set containing all books and then serializes them using `BookSerializer`.
    The `serializer` class is also taking an argument, `many=True`, which indicates
    that the `books` object is a `queryset` or a list of many objects. Remember that
    serialization takes Python objects and returns them in a JSON serializable format,
    as follows:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们添加一个功能视图`all_books`（如前一个练习所示）。此视图接受包含所有书籍的查询集，然后使用`BookSerializer`对它们进行序列化。`serializer`类还接受一个参数`many=True`，这表示`books`对象是一个`queryset`或多个对象的列表。请记住，序列化将Python对象转换为可序列化为JSON的格式，如下所示：
- en: '[PRE10]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Open `bookr/reviews/urls.py`, remove the previous example path for `first_api_view`,
    and add the `all_books` path as shown in the following code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`bookr/reviews/urls.py`，删除之前的`first_api_view`示例路径，并添加如下代码中的`all_books`路径：
- en: '[PRE11]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This newly added path calls the view function `all_books` when it comes across
    the `api/all_books/` path in the URL.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新增的路径在遇到URL中的`api/all_books/`路径时会调用视图函数`all_books`。
- en: 'Once all the code is added, run the Django server with the `python manage.py
    runserver` command and navigate to `http://0.0.0.0:8000/api/all_books/`. You should
    see something similar to *Figure 12.2*:![Figure 12.2: List of books shown in the
    all_books endpoint'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦添加了所有代码，使用`python manage.py runserver`命令运行Django服务器，并导航到`http://0.0.0.0:8000/api/all_books/`。你应该会看到类似于*图12.2*的内容：![图12.2：在all_books端点显示的书籍列表]
- en: '](img/B15509_12_02.jpg)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15509_12_02.jpg]'
- en: 'Figure 12.2: List of books shown in the all_books endpoint'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：在all_books端点显示的书籍列表
- en: The preceding screenshot shows that the list of all books is returned upon calling
    the `/api/all_books` endpoint. And with that, you have successfully used a serializer
    to return data efficiently in your database, with the help of a REST API.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示，在调用`/api/all_books`端点时，返回了所有书籍的列表。就这样，你已经成功使用序列化器在数据库中高效地返回数据，借助REST
    API的帮助。
- en: Till now, we have been focusing on functional views. However, you will now learn
    that class-based views are more commonly used in DRF and will make your life much easier.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于功能视图。然而，你现在将了解到在DRF中更常用的是基于类的视图，这将使你的生活变得更加轻松。
- en: Class-Based API Views and Generic Views
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于类的API视图和通用视图
- en: Similar to what we learned in *Chapter 11*, *Advanced Templating and Class-Based
    Views*, we can write class-based views for REST APIs as well. Class-based views
    are the most preferred way for writing views among developers as a lot can be
    achieved by writing very little code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在*第11章*，*高级模板和基于类的视图*中学到的类似，我们也可以为REST API编写基于类的视图。对于编写视图来说，基于类的视图是开发者中最受欢迎的方式，因为通过编写很少的代码就能实现很多功能。
- en: 'Just as with conventional views, DRF offers a set of generic views that makes
    writing class-based views even simpler. Generic views are designed keeping in
    mind some of the most common operations needed while creating APIs. Some of the
    generic views offered by DRF are `ListAPIView`, `RetrieveAPIView`, and so on.
    In *Exercise 12.02*, *Creating an API View to Display a List of Books*, our functional
    view was responsible for creating a `queryset` of the objects and then calling
    the serializer. Equivalently, we could use `ListAPIView` to do the same thing:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就像传统的视图一样，DRF提供了一套通用视图，使得编写基于类的视图变得更加简单。通用视图是在考虑到创建API时所需的一些最常见操作而设计的。DRF提供的通用视图包括`ListAPIView`、`RetrieveAPIView`等等。在*练习12.02*，*创建一个显示书籍列表的API视图*中，我们的功能视图负责创建对象的`queryset`并调用序列化器。同样，我们也可以使用`ListAPIView`来完成相同的事情：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, the `queryset` of objects is defined as a class attribute. Passing the
    `queryset` through to the `serializer` is handled by methods on `ListAPIView`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对象的`queryset`被定义为类属性。将`queryset`传递给`serializer`由`ListAPIView`上的方法处理。
- en: Model Serializers
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型序列化器
- en: 'In *Exercise 12.02*, *Creating an API View to Display a List of Books*, our
    serializer was defined as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在*练习12.02*，*创建一个显示书籍列表的API视图*中，我们的序列化器定义如下：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, our model for `Book` looks like this (note how similar the definitions
    of the model and serializer appear to be):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的`Book`模型看起来是这样的（注意模型和序列化器的定义看起来多么相似）：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We would prefer not to specify that the title must be `serializers.CharField()`.
    It would be easier if the serializer just looked at how `title` was defined in
    the model and could figure out what serializer field to use.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们宁愿不指定标题必须是`serializers.CharField()`。如果序列化器只需查看模型中`title`是如何定义的，并能够确定要使用什么序列化器字段，那就更容易了。
- en: This is where model serializers come in. They provide shortcuts to create serializers
    by utilizing the definition of the fields on the model. Instead of specifying
    that `title` should be serialized using a `CharField`, we just tell the model
    serializer we want to include the `title`, and it uses the `CharField` serializer
    because the `title` field on the model is also a `CharField`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是模型序列化器发挥作用的地方。它们通过利用模型上字段的定义来提供创建序列化器的快捷方式。我们不需要指定`title`应该使用`CharField`进行序列化，我们只需告诉模型序列化器我们想要包含`title`，它就会使用`CharField`序列化器，因为模型上的`title`字段也是一个`CharField`。
- en: 'For example, suppose we wanted to create a serializer for the `Contributor`
    model in `models.py`. Instead of specifying the types of serializers that should
    be used for each field, we can give it a list of the field names, and let it figure
    out the rest:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想在`models.py`中为`Contributor`模型创建一个序列化器。我们不需要指定每个字段应该使用哪种序列化器的类型，我们可以给它一个字段名称的列表，让它自己决定其他的事情：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the following exercise, we will see how we can use a model serializer to
    avoid the duplication of code in the preceding classes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，我们将看到如何使用模型序列化器来避免在前面类中重复代码。
- en: 'Exercise 12.03: Creating Class-Based API Views and Model Serializers'
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.03：创建基于类的API视图和模型序列化器
- en: 'In this exercise, you will create class-based views to display a list of all
    books while using model serializers:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建基于类的视图来显示所有书籍的列表，同时使用模型序列化器：
- en: 'Open the file `bookr/reviews/serializers.py`, remove any pre-existing code,
    and replace it with the following code:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件`bookr/reviews/serializers.py`，删除任何现有的代码，并用以下代码替换：
- en: '[PRE16]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we have included two model serializer classes, `PublisherSerializer` and
    `BookSerializer`. Both these classes inherit the parent class `serializers.ModelSerializer`.
    We do not need to specify how each field gets serialized, instead, we can simply
    pass a list of field names, and the field types are inferred from the definition
    in `models.py`.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们包含了两个模型序列化类，`PublisherSerializer`和`BookSerializer`。这两个类都继承自父类`serializers.ModelSerializer`。我们不需要指定每个字段如何序列化，相反，我们可以简单地传递一个字段名称列表，字段类型将根据`models.py`中的定义推断。
- en: Although mentioning the field inside `fields` is sufficient for the model serializer,
    under certain special cases, such as this one, we may have to customize the field
    since the `publisher` field is a foreign key. Hence, we must use `PublisherSerializer`
    to serialize the `publisher` field.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然在`fields`中提及字段对于模型序列化器来说是足够的，但在某些特殊情况下，例如这个例子，我们可能需要自定义字段，因为`publisher`字段是一个外键。因此，我们必须使用`PublisherSerializer`来序列化`publisher`字段。
- en: 'Next, open `bookr/reviews/api_views.py`, remove any pre-existing code, and
    add the following code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`bookr/reviews/api_views.py`，删除任何现有的代码，并添加以下代码：
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we use the DRF class-based `ListAPIView` instead of a functional view.
    This means that the list of books is defined as a class attribute, and we do not
    have to write a function that directly handles the request and calls the serializer.
    The book serializer from the previous step is also imported and assigned as an
    attribute of this class.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用DRF的基于类的`ListAPIView`而不是功能视图。这意味着书籍列表被定义为类的属性，我们不需要编写一个直接处理请求并调用序列化器的函数。上一步骤中的书籍序列化器也被导入并分配为这个类的属性。
- en: 'Open the `bookr/reviews/urls.py` file and modify the `/api/all_books` API path
    to include the new class-based view as follows:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开`bookr/reviews/urls.py`文件，修改`/api/all_books` API路径以包含新的基于类的视图，如下所示：
- en: '[PRE18]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since we are using a class-based view, we have to use the class name along with
    the `as_view()` method.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们使用的是基于类的视图，我们必须使用类名以及`as_view()`方法。
- en: 'Once all the preceding modifications are completed, wait till the Django service
    restarts or start the server with the `python manage.py runserver` command, and
    then open the API at `http://0.0.0.0:8000/api/all_books/` in the web browser.
    You should see something like *Figure 12.3*:![Figure 12.3: List of books shown
    in the all_books endpoint'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成所有前面的修改后，等待Django服务重启，或者使用`python manage.py runserver`命令启动服务器，然后在网络浏览器中打开`http://0.0.0.0:8000/api/all_books/`处的API。你应该会看到类似于*图12.3*的内容：![图12.3：在all_books端点显示的书籍列表
- en: '](img/B15509_12_03.jpg)'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_12_03.jpg)'
- en: 'Figure 12.3: List of books shown in the all_books endpoint'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：在all_books端点显示的书籍列表
- en: Like what we saw in *Exercise 12.02*, *Creating an API View to Display a List
    of Books*, this is a list of all books present in the book review application.
    In this exercise, we used model serializers to simplify our code, and the generic
    class-based `ListAPIView` to return a list of the books in our database.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如同我们在*练习12.02*，*创建一个显示书籍列表的API视图*中看到的，这是一个显示在书籍评论应用程序中的所有书籍的列表。在这个练习中，我们使用了模型序列化器来简化我们的代码，并使用通用的基于类的`ListAPIView`来返回数据库中书籍的列表。
- en: 'Activity 12.01: Creating an API Endpoint for a Top Contributors Page'
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动12.01：创建一个顶级贡献者页面API端点
- en: 'Imagine that your team decides to create a web page that displays the top contributors
    (that is, authors, coauthors, and editors) in your database. They decide to enlist
    the services of an external developer to create an app in React JavaScript. To
    integrate with the Django backend, the developer will need an endpoint that provides
    the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的团队决定创建一个显示数据库中顶级贡献者（即作者、合著者和编辑）的网页。他们决定聘请外部开发者使用React JavaScript创建一个应用程序。为了与Django后端集成，开发者需要一个提供以下内容的端点：
- en: A list of all contributors in the database
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库中所有贡献者的列表
- en: For each contributor, a list of all books they contributed to
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个贡献者，列出他们所贡献的所有书籍。
- en: For each contributor, the number of books they contributed to
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个贡献者，列出他们所贡献的书籍数量。
- en: For each book they contributed to, their role in the book
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于他们所贡献的每本书，列出他们在书中的角色。
- en: 'The final API view should look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的API视图应如下所示：
- en: '![Figure 12.4: Top contributors endpoint'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.4：顶级贡献者端点'
- en: '](img/B15509_12_04.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15509_12_04.jpg](img/B15509_12_04.jpg)'
- en: 'Figure 12.4: Top contributors endpoint'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4：顶级贡献者端点
- en: 'To perform this task, execute the following steps:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此任务，请执行以下步骤：
- en: Add a method to the `Contributor` class that returns the number of contributions
    made.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Contributor`类添加一个方法，该方法返回所做的贡献数量。
- en: Add `ContributionSerializer`, which serializes the `BookContribution` model.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`ContributionSerializer`，它序列化`BookContribution`模型。
- en: Add `ContributorSerializer`, which serializes the `Contributor` model.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`ContributorSerializer`，它序列化`Contributor`模型。
- en: Add `ContributorView`, which uses `ContributorSerializer`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`ContributorView`，它使用`ContributorSerializer`。
- en: Add a pattern to `urls.py` to enable access to `ContributorView`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`urls.py`中添加一个模式以启用对`ContributorView`的访问。
- en: Note
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在[http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ)找到。
- en: ViewSets
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图集
- en: We have seen how we can optimize our code and make it more concise using class-based
    generic views. `AllBooks` view to return a list of all books in the application
    and the `BookDetail` view to return the details of a single book. Using viewsets,
    we could combine both these classes into a single class.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们可以如何通过使用基于类的通用视图来优化我们的代码并使其更加简洁。`AllBooks`视图返回应用程序中所有书籍的列表，而`BookDetail`视图返回单本书的详细信息。使用视图集，我们可以将这两个类合并成一个。
- en: 'DRF also provides a class named `ModelViewSet`. This class not only combines
    the two views mentioned in the preceding discussion (that is, list and detail)
    but also allows you to create, update, and delete model instances. The code needed
    to implement all this functionality could be as simple as specifying the serializer
    and `queryset`. For example, a view that allows you to manage all these actions
    for your user model could be defined as tersely as the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: DRF还提供了一个名为`ModelViewSet`的类。这个类不仅结合了前面讨论中提到的两个视图（即列表和详情），还允许您创建、更新和删除模型实例。实现所有这些功能所需的代码可能非常简单，只需指定序列化和`queryset`即可。例如，一个允许您管理用户模型的所有这些操作的视图可以简洁地定义如下：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Lastly, DRF provides a `ReadOnlyModelViewSet` class. This is a simpler version
    of the preceding `ModelViewSet`. It is identical, except that it only allows you
    to list and retrieve specific users. You cannot create, update, or delete records.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，DRF提供了一个名为`ReadOnlyModelViewSet`的类。这是先前`ModelViewSet`的一个更简单的版本。它与前面的版本相同，只是它只允许您列出和检索特定用户。您不能创建、更新或删除记录。
- en: Routers
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由器
- en: 'Routers, when used along with a viewset, take care of automatically creating
    the required URL endpoints for the viewset. This is because a single viewset is
    accessed at different URLs. For example, in the preceding `UserViewSet`, you would
    access a list of users at the URL `/api/users/`, and a specific user record at
    the URL `/api/users/123`, where `123` is the primary key of that user record.
    Here is a simple example of how you might use a router in the context of the previously
    defined `UserViewSet`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当与视图集一起使用时，路由器会自动创建视图集所需的URL端点。这是因为单个视图集在不同的URL上被访问。例如，在先前的`UserViewSet`中，您可以在URL
    `/api/users/` 上访问用户列表，并在URL `/api/users/123` 上访问特定用户记录，其中`123`是该用户记录的主键。以下是一个简单的示例，说明您如何在先前定义的`UserViewSet`的上下文中使用路由器：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, let's try to combine the concepts of routers and viewsets in a simple exercise.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个简单的练习来尝试结合路由器和视图集的概念。
- en: 'Exercise 12.04: Using ViewSets and Routers'
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.04：使用视图集和路由器
- en: 'In this exercise, we will combine the existing views to create a viewset and
    create the required routing for the viewset:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将结合现有的视图来创建视图集，并为视图集创建所需的路由：
- en: 'Open the file `bookr/reviews/serializers.py`, remove the pre-existing code,
    and add the following code snippet:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件`bookr/reviews/serializers.py`，删除现有的代码，并添加以下代码片段：
- en: '[PRE21]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we added two new fields to `BookSerializer`, namely `reviews` and `rating`.
    The interesting thing about these fields is that the logic behind them is defined
    as a method on the serializer itself. This is why we use the `serializers.SerializerMethodField`
    type to set the `serializer` class attributes.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们向 `BookSerializer` 添加了两个新字段，即 `reviews` 和 `rating`。这些字段的有趣之处在于，它们背后的逻辑被定义为序列化器本身上的一个方法。这就是为什么我们使用
    `serializers.SerializerMethodField` 类型来设置 `serializer` 类属性。
- en: 'Open the file `bookr/reviews/api_views.py`, remove the pre-existing code, and
    add the following:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件 `bookr/reviews/api_views.py`，删除现有的代码，并添加以下内容：
- en: '[PRE22]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we have removed the `AllBook` and the `BookDetail` views and replaced
    them with `BookViewSet` and `ReviewViewSet`. In the first line, we import the
    `ViewSets` module from `rest_framework`. The `BookViewSet` class is a subclass
    of `ReadOnlyModelViewSet`, which ensures that the views are used for the `GET`
    operation only.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们删除了 `AllBook` 和 `BookDetail` 视图，并用 `BookViewSet` 和 `ReviewViewSet` 替换它们。在第一行，我们从
    `rest_framework` 模块导入 `ViewSets` 模块。`BookViewSet` 类是 `ReadOnlyModelViewSet` 的子类，这确保了视图仅用于
    `GET` 操作。
- en: 'Next, open the `bookr/reviews/urls.py` file, remove the first two URL patterns
    starting with `api/`, and then add the following (highlighted) code:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，打开 `bookr/reviews/urls.py` 文件，删除以 `api/` 开头的第一个两个 URL 模式，然后添加以下（突出显示）代码：
- en: '[PRE23]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Save all the files, and once the Django service restarts (or you start it manually
    with the `python manage.py runserver` command), go to the URL `http://0.0.0.0:8000/api/books/`
    to get a list of all the books. You should see the following view in the API explorer:![Figure
    12.5: Book list at the path /api/books'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有文件，一旦 Django 服务重启（或者您使用 `python manage.py runserver` 命令手动启动），请访问 URL `http://0.0.0.0:8000/api/books/`
    以获取所有书籍的列表。您应该在 API 探索器中看到以下视图：![图 12.5：/api/books 路径下的书籍列表
- en: '](img/B15509_12_05.jpg)'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_12_05.jpg)'
- en: 'Figure 12.5: Book list at the path /api/books'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.5：/api/books 路径下的书籍列表
- en: 'You can also access the details for a specific book using the URL `http://0.0.0.0:8000/api/books/1/`.
    In this case, it will return details for the book with a primary key of `1` (if
    it exists in your database):![Figure 12.6: Book details for "Advanced Deep Learning
    with Keras"'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您也可以使用 URL `http://0.0.0.0:8000/api/books/1/` 访问特定书籍的详细信息。在这种情况下，它将返回具有主键 `1`
    的书籍的详细信息（如果它在您的数据库中存在）：![图 12.6：“使用 Keras 进行高级深度学习”的书籍详细信息
- en: '](img/B15509_12_06.jpg)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_12_06.jpg)'
- en: 'Figure 12.6: Book details for "Advanced Deep Learning with Keras"'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6：“使用 Keras 进行高级深度学习”的书籍详细信息
- en: In this exercise, we saw how we can use viewsets and routers to combine the
    list and detail views into a single viewset. Using viewsets will make our code
    more consistent and idiomatic, making it easier to collaborate with other developers.
    This becomes particularly important when integrating with a separate frontend
    application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何使用视图集和路由器将列表视图和详细信息视图合并为一个视图集。使用视图集将使我们的代码更加一致和符合惯例，更容易与其他开发者协作。当与单独的前端应用程序集成时，这一点尤为重要。
- en: Authentication
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证
- en: As we learned in *Chapter 9*, *Sessions and Authentication*, it is important
    to authenticate the users of our application. It is good practice to only allow
    those users who have registered in the application to log in and access information
    from the application. Similarly, for REST APIs too, we need to design a way to
    authenticate and authorize users before any information is passed on. For example,
    suppose Facebook's website makes an API request to get a list of all comments
    for a post. If they did not have authentication on this endpoint, you could use
    it to programmatically get comments for any post you want. They obviously don't
    want to allow this, so some sort of authentication needs to be implemented.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *第 9 章* 中学到的，*会话和身份验证*，验证我们应用程序的用户非常重要。只允许在应用程序中注册的用户登录并访问应用程序中的信息是一种良好的做法。同样，对于
    REST API，我们也需要设计一种方式在传递任何信息之前对用户进行验证和授权。例如，假设 Facebook 的网站通过 API 请求获取一个帖子的所有评论列表。如果他们在这个端点上没有进行身份验证，您就可以用它来程序化地获取任何您想要的帖子的评论。显然，他们不希望允许这样做，因此需要实现某种形式的身份验证。
- en: There are different authentication schemes, such as **Basic Authentication**,
    **Session Authentication**, **Token Authentication**, **Remote User Authentication**,
    and various third-party authentication solutions. For the scope of this chapter,
    and for our Bookr application, we will use **Token Authentication**.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种认证方案，例如**基本认证**、**会话认证**、**令牌认证**、**远程用户认证**以及各种第三方认证解决方案。在本章范围内，以及针对我们的Bookr应用程序，我们将使用**令牌认证**。
- en: Note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For further reading on all the authentication schemes, please refer to the official
    documentation at [https://www.django-rest-framework.org/api-guide/authentication](https://www.django-rest-framework.org/api-guide/authentication).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所有认证方案的进一步阅读，请参阅官方文档[https://www.django-rest-framework.org/api-guide/authentication](https://www.django-rest-framework.org/api-guide/authentication)。
- en: Token-Based Authentication
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于令牌的认证
- en: Token-based authentication works by generating a unique token for a user in
    exchange for the user's username and password. Once the token is generated, it
    will be stored in the database for further reference and will be returned to the
    user upon every login.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 基于令牌的认证通过为用户生成一个唯一的令牌来交换用户的用户名和密码。一旦生成令牌，它将被存储在数据库中以供进一步参考，并在每次登录时返回给用户。
- en: This token is unique for a user and the user can then use this token to authorize
    every API request they make. Token-based authentication eliminates the need to
    pass the username and password on every request. It is much safer and is best
    suited to client-server communication, such as a JavaScript-based web client interacting
    with the backend application via REST APIs.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个令牌对每个用户都是唯一的，用户可以使用这个令牌来授权他们发出的每个API请求。基于令牌的认证消除了在每次请求中传递用户名和密码的需要。它更加安全，非常适合客户端-服务器通信，例如，基于JavaScript的Web客户端通过REST
    API与后端应用程序交互。
- en: An example of this would be a ReactJS or AngularJS application interacting with
    a Django backend via REST APIs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个ReactJS或AngularJS应用程序通过REST API与Django后端交互。
- en: The same architecture can be used if you are developing a mobile application
    to interact with the backend server via REST APIs, for instance, an Android or
    iOS application interacting with a Django backend via REST APIs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发一个与后端服务器通过REST API交互的移动应用程序，例如，一个与Django后端通过REST API交互的Android或iOS应用程序，可以使用相同的架构。
- en: 'Exercise 12.05: Implementing Token-Based Authentication for Bookr APIs'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.05：为Bookr API实现基于令牌的认证
- en: 'In this exercise, you will implement token-based authentication for the `bookr`
    application''s APIs:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将为`bookr`应用程序的API实现基于令牌的认证：
- en: 'Open the `bookr/settings.py` file and add `rest_framework.authtoken` to `INSTALLED_APPS`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`bookr/settings.py`文件，并将`rest_framework.authtoken`添加到`INSTALLED_APPS`中：
- en: '[PRE24]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Since the `authtoken` app has associated database changes, run the `migrate`
    command in the command line/terminal as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`authtoken`应用程序关联了数据库更改，请在命令行/终端中运行以下`migrate`命令：
- en: '[PRE25]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Open the `bookr/reviews/api_views.py` file, remove any pre-existing code, and
    replace it with the following:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`bookr/reviews/api_views.py`文件，删除任何现有的代码，并用以下内容替换：
- en: '[PRE26]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we have defined a view called `Login`. The purpose of this view is to
    allow a user to get (or create if it does not already exist) a token that they
    can use to authenticate with the API.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`Login`的视图。这个视图的目的是允许用户获取（或创建如果尚未存在）一个令牌，他们可以使用这个令牌来通过API进行认证。
- en: We override the `post` method of this view because we want to customize the
    behavior when a user sends us data (that is, their login details). First, we use
    the `authenticate` method from Django's `auth` library to check whether the username
    and password are correct. If they are correct, then we will have a `user` object.
    If not, we return an `HTTP 404` error. If we do have a valid `user` object, then
    we simply get or create a token, and return it to the user.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们覆盖了这个视图的`post`方法，因为我们想自定义用户发送数据（即他们的登录详情）时的行为。首先，我们使用Django的`auth`库中的`authenticate`方法来检查用户名和密码是否正确。如果正确，那么我们将有一个`user`对象。如果不正确，我们返回一个`HTTP
    404`错误。如果我们有一个有效的`user`对象，那么我们只需获取或创建一个令牌，并将其返回给用户。
- en: 'Next, let''s add the authentication class to our `BookViewSet`. This means
    that when a user tries to access this viewset, it will require them to authenticate
    using token-based authentication. Note that it''s possible to include a list of
    different accepted authentication methods, not just one. We also add the `permissions_classes`
    attribute, which just uses DRF''s built-in class that checks to see if the given
    user has permission to view the data in this model:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们将认证类添加到我们的`BookViewSet`中。这意味着当用户尝试访问此视图集时，它将要求他们使用基于令牌的认证进行认证。请注意，可以包含一系列不同的接受认证方法，而不仅仅是其中一个。我们还添加了`permissions_classes`属性，它仅使用DRF内置的类来检查给定用户是否有权限查看此模型中的数据：
- en: '[PRE27]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding code (highlighted) won't match the code you see on GitHub as we'll
    be modifying it later in *step 9*
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码（高亮显示）不会与你在GitHub上看到的代码匹配，因为我们将在第9步中对其进行修改
- en: Open `bookr/reviews/urls.py` file and add the following path into url patterns.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`bookr/reviews/urls.py`文件，并将以下路径添加到URL模式中。
- en: '[PRE28]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Save the file and wait for the application to restart, or start the server
    manually with the `python manage.py runserver` command. Then access the application
    using the URL `http://0.0.0.0:8000/api/login`. Your screen should appear as follows:![Figure
    12.7: Login page'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并等待应用程序重新启动，或者使用`python manage.py runserver`命令手动启动服务器。然后使用URL `http://0.0.0.0:8000/api/login`
    访问应用程序。你的屏幕应该如下所示：![图12.7：登录页面
- en: '](img/B15509_12_07.jpg)'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_12_07.jpg)'
- en: 'Figure 12.7: Login page'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.7：登录页面
- en: The API at `/api/login` is a `POST` only message, hence `Method GET not allowed`
    is displayed.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`/api/login` API只接受`POST`请求，因此显示“方法GET不允许”。'
- en: 'Next, enter the following snippet in the content and click on `POST`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在内容中输入以下片段，然后点击`POST`：
- en: '[PRE29]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You will need to replace this with an actual username and password for your
    account in the database. Now you can see the token generated for the user. This is
    the token we need to use to access `BookSerializer`:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你需要将此替换为数据库中你账户的实际用户名和密码。现在你可以看到为用户生成的令牌。这是我们用来访问`BookSerializer`的令牌：
- en: '![Figure 12.8: Token generated for the user'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.8：为用户生成的令牌'
- en: '](img/B15509_12_08.jpg)'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_12_08.jpg)'
- en: 'Figure 12.8: Token generated for the user'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.8：为用户生成的令牌
- en: Try to access the list of books using the API that we previously created at
    `http://0.0.0.0:8000/api/books/`. Note that you are now not allowed to access
    it. This is because this viewset now requires you to use your token to authenticate.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用我们之前创建的API访问书籍列表，API地址为`http://0.0.0.0:8000/api/books/`。请注意，你现在不再被允许访问它。这是因为这个视图集现在要求你使用你的令牌进行认证。
- en: 'The same API can be accessed using `curl` on the command line:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样的API可以使用命令行中的`curl`访问：
- en: '[PRE30]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Since the token was not provided, the message `Authentication credentials were
    not provided` is displayed:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于未提供令牌，显示消息“未提供认证凭据”：
- en: '![Figure 12.9: Message saying that the authentication details weren''t provided'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.9：显示认证详情未提供的消息'
- en: '](img/B15509_12_09.jpg)'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_12_09.jpg)'
- en: '[PRE31]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This operation ensured that only an existing user of the application can access
    and fetch the collection of all books.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此操作确保只有应用程序的现有用户才能访问和检索所有书籍的集合。
- en: Before moving on, set the authentication and permission classes on `BookViewSet`
    to an empty string. Future chapters will not utilize these authentication methods,
    and we will assume for sake of simplicity that our API can be accessed by an unauthenticated
    user.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，将`BookViewSet`上的认证和权限类设置为空字符串。未来的章节将不会使用这些认证方法，我们将为了简单起见假设我们的API可以被未经认证的用户访问。
- en: '[PRE32]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this exercise, we implemented token-based authentication in our Bookr app.
    We created a login view that allows us to retrieve the token for a given authenticated
    user. This then enabled us to make API requests from the command line by passing
    through the token as a header in the request.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们在Bookr应用程序中实现了基于令牌的认证。我们创建了一个登录视图，允许我们检索给定认证用户的令牌。然后，我们通过在请求中将令牌作为头部传递，从命令行进行API请求。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced REST APIs, a fundamental building block in most real-world
    web applications. These APIs facilitate communication between the backend server
    and the web browser, so they are central to your growth as a Django web developer.
    We learned how to serialize data in our database so that it can be transmitted
    via an HTTP request. We also learned the various options DRF gives us to simplify
    the code we write, taking advantage of the existing definitions of the models
    themselves. We also covered viewsets and routers, and saw how they can be used
    to condense code even further by combining the functionality of multiple views.
    We also learned about authentication and authorization and implemented token-based
    authentication for the book review app. In the next chapter, we will extend Bookr's
    functionality for its users by learning how to generate CSVs, PDFs, and other
    binary filetypes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了REST API，这是大多数现实世界Web应用的基本构建块。这些API促进了后端服务器与Web浏览器之间的通信，因此对于你作为Django Web开发者的成长至关重要。我们学习了如何在数据库中序列化数据，以便通过HTTP请求进行传输。我们还学习了DRF为我们提供的各种选项，以简化我们编写的代码，利用模型本身的现有定义。我们还涵盖了视图集和路由器，并看到了如何通过组合多个视图的功能来进一步压缩代码。我们还学习了身份验证和授权，并为书评应用实现了基于令牌的身份验证。在下一章中，我们将通过学习如何生成CSV、PDF和其他二进制文件类型来扩展Bookr为用户的功能。
