- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Creating Menus with Menu and Tkinter Dialogs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用菜单和 Tkinter 对话框创建菜单
- en: As an application grows in functionality, it becomes increasingly counterproductive
    to cram all its functions and inputs into a single form. Instead, we will need
    to organize access to features, information, and controls in a way that keeps
    them available without cluttering up the visual presentation. GUI toolkits like
    Tkinter offer us a couple of tools to help deal with this. First, the **menu system**,
    typically located at the top of the application window (or, on some platforms,
    in a global desktop menu), can be used to organize application functions in a
    condensed hierarchy. Second, **dialog windows**, often referred to as **dialog
    boxes**, provide a quick means of displaying temporary windows containing information,
    errors, or basic forms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序功能的增长，将所有功能和输入都挤入一个单一表单变得越来越低效。相反，我们需要以保持它们可用而不使视觉呈现杂乱的方式组织对功能、信息和控制的访问。像
    Tkinter 这样的 GUI 工具包为我们提供了一些工具来帮助我们处理这个问题。首先，**菜单系统**，通常位于应用程序窗口的顶部（或在某些平台上，在全局桌面菜单中），可以用来以压缩的层次结构组织应用程序功能。其次，**对话框窗口**，通常被称为**对话框**，提供了一种快速显示包含信息、错误或基本表单的临时窗口的方法。
- en: 'In this chapter, we''re going to explore the use and best practices of menus
    and dialog boxes in Tkinter through the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过以下主题来探讨 Tkinter 中菜单和对话框的使用和最佳实践：
- en: In *Solving problems in our application*, we'll analyze some reported problems
    with our application and design a solution involving menus and dialog boxes.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *解决应用程序中的问题* 中，我们将分析一些关于我们应用程序的报告问题，并设计一个涉及菜单和对话框的解决方案。
- en: In *Implementing Tkinter dialogs*, we'll explore Tkinter's dialog classes and
    how to use them to implement common application functionality.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *实现 Tkinter 对话框* 中，我们将探索 Tkinter 的对话框类以及如何使用它们来实现常见应用程序功能。
- en: In *Designing the application menu*, we'll organize our application's features
    into a main menu system using Tkinter's `Menu` widget.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *设计应用程序菜单* 中，我们将使用 Tkinter 的 `Menu` 小部件将我们的应用程序功能组织到一个主菜单系统中。
- en: Let's begin by seeing what improvements our application needs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从看看我们的应用程序需要哪些改进开始。
- en: Solving problems in our application
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决应用程序中的问题
- en: 'Although everyone is happy with your application so far, your boss, after discussion
    with the staff, has brought you this set of problems that need to be addressed:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然到目前为止每个人都对你的应用程序感到满意，但你的老板在与员工讨论后，给你带来了这一系列需要解决的问题：
- en: The hard-coded filename is a problem. Occasionally the data entry staff aren't
    able to get to a form until the following day; in this situation, they need to
    be able to manually enter the filename that they'd like to append the data to.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定代码的文件名是一个问题。有时数据录入人员直到第二天才能到达表单；在这种情况下，他们需要能够手动输入他们想要附加数据的文件名。
- en: Also, the data entry staff have mixed feelings about the auto-filling features
    in the form. Some find it very helpful, but others would like auto-fill to be
    partially or completely disabled.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，数据录入人员对表单中的自动填充功能有矛盾的看法。有些人认为它非常有帮助，但其他人希望自动填充部分或完全禁用。
- en: Some users have a hard time noticing the status bar text at the bottom, and
    would like the application to be more assertive when it fails to save a data record
    due to field errors.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些用户很难注意到底部的状态栏文本，并希望当由于字段错误而无法保存数据记录时，应用程序能够更加果断。
- en: Finally, the lab is bringing in some interns to work in the labs, and the issue
    of data security has been raised. IT has suggested a simple login requirement
    would be advisable. It doesn't have to have high security, just enough to "keep
    the honest person honest."
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，实验室正在引入一些实习生到实验室工作，数据安全问题已经被提出。IT 建议简单的登录要求是可取的。它不需要有很高的安全性，只要足够“让诚实的人保持诚实”即可。
- en: Planning solutions to the issues
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规划解决这些问题的方案
- en: 'It''s clear you need to implement a way to enter login credentials, select
    a save file name, and toggle the auto-populate features of the form. You also
    need to make the status text more noticeable. First, you consider just adding
    controls to the main application for these features and increasing the size of
    the status text. You make a quick mock-up that looks like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，你需要实现一种方法来输入登录凭证，选择保存文件名，并切换表单的自动填充功能。你还需要使状态文本更加引人注目。首先，你考虑只是为主应用程序添加这些功能的控件并增加状态文本的大小。你快速制作了一个看起来像这样的原型：
- en: '![](img/B17578_07_01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17578_07_01.png)'
- en: 'Figure 7.1: Our first attempt at adding the new features: three Entry widgets
    for login data and filename, and two Checkbutton widgets for the settings'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：我们添加新功能的第一次尝试：用于登录数据和文件名的三个Entry小部件，以及两个用于设置的Checkbutton小部件
- en: It's immediately evident that this is not a great design, and certainly not
    one that will accommodate growth. Your users don't want to have to type a file
    path and filename blindly into the box, nor do they need the extra login fields
    and check boxes cluttering up the user interface. Making the status font larger
    seems like a good idea, until you realize that the form is now so long it will
    likely just get pushed off the bottom of the screen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这不是一个好的设计，而且肯定不是一种能够适应增长的设计。用户不想盲目地在框中输入文件路径和文件名，他们也不需要额外的登录字段和复选框来弄乱用户界面。增大状态字体看起来是个好主意，直到你意识到现在表单太长，很可能会被推到屏幕底部。
- en: 'Thinking through other GUI applications, you realize that these features are
    typically handled by dialog windows, usually activated from menu options. Taking
    menus and dialogs into consideration, you plan the following solutions to the
    problems:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在思考其他GUI应用程序时，你会意识到这些功能通常由对话框处理，通常从菜单选项激活。考虑到菜单和对话框，你计划以下解决方案来解决问题：
- en: A **file dialog**, activated from a menu system, can be used to select the file
    that the data will be saved to.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从菜单系统激活的**文件对话框**可以用来选择数据将保存到的文件。
- en: A **settings menu** in our menu system will handle activating or disabling auto-fill.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们菜单系统中的**设置菜单**将处理激活或禁用自动填充。
- en: An **error dialog** will be used to display problematic status messages more
    assertively.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误对话框**将用于更坚定地显示问题状态消息。'
- en: A **login dialog** can be used to enter login information.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**登录对话框**可以用来输入登录信息。'
- en: Before we can code this solution, we'll need to learn more about dialogs in
    Tkinter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够编写这个解决方案之前，我们需要更多地了解Tkinter中的对话框。
- en: Implementing Tkinter dialogs
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Tkinter对话框
- en: 'Tkinter contains a number of submodules that provide ready-made dialog windows
    for different situations. These include:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter包含许多子模块，为不同情况提供现成的对话框。这些包括：
- en: '`messagebox`, for displaying simple messages and warnings'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`messagebox`，用于显示简单的消息和警告'
- en: '`filedialog`, for prompting the user for a file or folder path'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filedialog`，用于提示用户输入文件或文件夹路径'
- en: '`simpledialog`, for requesting string, integer, or float values from a user'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`simpledialog`，用于从用户请求字符串、整数或浮点值'
- en: In this section, we're going to explore these dialogs and use them to solve
    some of the problems with our application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索这些对话框，并使用它们来解决我们应用程序的一些问题。
- en: Error dialogs with the Tkinter messagebox
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Tkinter的messagebox显示错误对话框
- en: The best way to display simple dialog boxes in Tkinter is by using the `tkinter.messagebox`
    module, which provides a variety of information-display dialog types.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tkinter中显示简单对话框的最佳方式是使用`tkinter.messagebox`模块，它提供了各种信息显示对话框类型。
- en: 'Since it is a submodule, we need to explicitly import it before we can use
    it, like so:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个子模块，我们需要在可以使用它之前显式导入它，如下所示：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Rather than having a lot of widget classes that we create instances of, the
    `messagebox` module provides a selection of **convenience functions** for making
    use of its various dialog types. When executed, each function displays a different
    combination of buttons and a preset icon, along with a message and detail text
    that you specify. When the user clicks a button in the dialog or closes it, the
    function will return a Boolean or string value depending on which button was clicked.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建大量小部件实例相比，`messagebox`模块提供了一系列**便利函数**，用于利用其各种对话框类型。当执行时，每个函数都会显示不同的按钮组合和预设图标，以及你指定的消息和详细文本。当用户点击对话框中的按钮或关闭对话框时，该函数将返回一个布尔值或字符串值，具体取决于哪个按钮被点击。
- en: 'The following table shows some of the `messagebox` module''s functions with
    their icons and return values:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了`messagebox`模块的一些函数及其图标和返回值：
- en: '| Function | Icon | Button text/Return value |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 图标 | 按钮文本/返回值 |'
- en: '| `askokcancel()` | Question | OK (`True`), Cancel (`False`) |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `askokcancel()` | 问题 | 确定（`True`），取消（`False`） |'
- en: '| `askretrycancel()` | Warning | Retry (`True`), Cancel (`False`) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `askretrycancel()` | 警告 | 重试（`True`），取消（`False`） |'
- en: '| `askyesno()` | Question | Yes (`True`), No (`False`) |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `askyesno()` | 问题 | 是（`True`），否（`False`） |'
- en: '| `askyesnocancel()` | Question | Yes (`True`), No (`False`), Cancel (`None`)
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `askyesnocancel()` | 问题 | 是（`True`），否（`False`），取消（`None`） |'
- en: '| `showerror()` | Error | OK (`ok`) |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `showerror()` | 错误 | 确定（`ok`） |'
- en: '| `showinfo()` | Information | OK (`ok`) |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `showinfo()` | 信息 | 确定 (`ok`) |'
- en: '| `showwarning()` | Warning | OK (`ok`) |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `showwarning()` | 警告 | 确定 (`ok`) |'
- en: 'Each `message``box` function accepts this same set of arguments:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `message` `box` 函数都接受这个相同的参数集：
- en: '`title` sets the title of the window, which is displayed in the title bar and/or
    task bar in your desktop environment.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title` 设置窗口的标题，该标题在桌面环境中的标题栏和/或任务栏中显示。'
- en: '`message` sets the main message of the dialog. It''s usually in a heading font
    and should be kept fairly short.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message` 设置对话框的主要消息。它通常以标题字体显示，并且应该保持相当简短。'
- en: '`detail` sets the body text of the dialog, which is usually displayed in the
    standard window font.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detail` 设置对话框的主体文本，通常以标准窗口字体显示。'
- en: 'A basic call to `messagebox.showinfo()` would look something like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `messagebox.showinfo()` 的基本调用看起来可能像这样：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In Windows 10, it results in a dialog box that looks like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 10 中，它将导致一个看起来像这样的对话框：
- en: '![A showinfo() message box on Windows 10](img/B17578_07_02.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Windows 10 上的 showinfo() 消息框](img/B17578_07_02.png)'
- en: 'Figure 7.2: A showinfo() message box on Windows 10'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：Windows 10 上的 showinfo() 消息框
- en: 'On macOS, you''d see something like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，你会看到类似这样的东西：
- en: '![](img/B17578_07_03.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17578_07_03.png)'
- en: 'Figure 7.3: A showinfo() message box on macOS'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：macOS 上的 showinfo() 消息框
- en: 'On Ubuntu Linux, the dialog looks like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu Linux 上，对话框看起来像这样：
- en: '![](img/B17578_07_04.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17578_07_04.png)'
- en: 'Figure 7.4: A showinfo() message box on Ubuntu Linux'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：Ubuntu Linux 上的 showinfo() 消息框
- en: Note that Tkinter `messagebox` dialog boxes are **modal**, which means that
    the program execution pauses and the rest of the UI is unresponsive while the
    dialog box is open. There is no way to change this, so only use them in situations
    where it's acceptable for the program to pause execution while the box is open.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Tkinter `messagebox` 对话框是**模态的**，这意味着当对话框打开时，程序执行暂停，其余的 UI 不可响应。没有办法改变这一点，所以只有在程序在对话框打开时暂停执行是可以接受的情况下才使用它们。
- en: 'Let''s create a small example script to show the use of the `messagebox` functions:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个小的示例脚本，以展示 `messagebox` 函数的使用：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This creates a dialog with **Yes** and **No** buttons. If the user clicks **No**,
    the function returns `False` and the application exits. In the case our user wants
    to see more boxes, the program continues and displays an information box.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个带有**是**和**否**按钮的对话框。如果用户点击**否**，函数返回 `False` 并且应用程序退出。在我们的用户想要看到更多对话框的情况下，程序将继续并显示一个信息框。
- en: Showing error dialogs in ABQ Data Entry
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 ABQ 数据输入中显示错误对话框
- en: Now that you understand how to use `messagebox`, error dialogs should be easy
    to implement in our application. The `Application._on_save()` method already displays
    errors in the status bar; we just need to make the same text display in an error
    dialog as well.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何使用 `messagebox`，在应用程序中实现错误对话框应该很容易。`Application._on_save()` 方法已经显示状态栏中的错误；我们只需要确保同样的文本也在错误对话框中显示。
- en: 'First, open `application.py`, and let''s import `messagebox` like so:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开 `application.py`，然后让我们这样导入 `messagebox`：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, locate the line in the `Application._on_save()` method that updates the
    application status with any errors (inside the `if errors:` block). Just after
    that line, let''s add some code to display the error dialog, like so:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，定位到 `Application._on_save()` 方法中更新应用程序状态以显示任何错误的行（在 `if errors:` 块内）。就在那行之后，让我们添加一些代码来显示错误对话框，如下所示：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first thing we've done is build the message and detail strings for the dialog,
    making a bullet list of the fields that have errors by joining them with `\n *`
    (that is, a newline, space, and asterisk). Unfortunately, `messagebox` dialogs
    don't support any sort of markup or rich text, so constructs like bullet lists
    need to be built manually using regular characters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为对话框构建了消息和详细字符串，通过使用 `\n *`（即换行符、空格和星号）将存在错误的字段合并成一个项目符号列表。不幸的是，`messagebox`
    对话框不支持任何类型的标记或富文本，因此像项目符号列表这样的结构需要使用常规字符手动构建。
- en: After building the messages, we call `messagebox.showerror()` to display them.
    Remember that the application will freeze at this point until the user clicks
    **OK** and the `showerror()` function returns.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建消息之后，我们调用 `messagebox.showerror()` 来显示它们。记住，此时应用程序将冻结，直到用户点击**确定**并且 `showerror()`
    函数返回。
- en: 'Open the program and hit **Save**; you''ll see a dialog box alerting you to
    the errors in the application, as shown in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 打开程序并点击**保存**；你会看到一个对话框，提示你应用程序中的错误，如下面的截图所示：
- en: '![The error message when we try to save with no data](img/B17578_07_05.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![尝试保存无数据时的错误信息](img/B17578_07_05.png)'
- en: 'Figure 7.5: The error message on Windows 10 when we try to save with no data'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：当我们在没有数据的情况下尝试保存时，Windows 10上的错误信息
- en: This error should be hard for anyone to miss!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误应该对任何人来说都不难发现！
- en: One shortcoming of the `messagebox` module's dialogs is that they don't scroll;
    a long error message will create a dialog that may fill (or extend beyond) the
    screen. If this is a potential problem, you'll want to create a custom dialog
    containing a scrollable widget. We'll make a custom dialog later in this section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`messagebox`模块的对话框的一个缺点是它们不能滚动；一个长的错误信息将创建一个可能填满（或超出）屏幕的对话框。如果这是一个潜在问题，你将想要创建一个包含可滚动小部件的自定义对话框。我们将在本节的后面创建一个自定义对话框。'
- en: Using filedialog
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`filedialog`
- en: When a user needs to enter a file or directory path, the preferred way to do
    this is to display a dialog containing a miniature file browser, commonly called
    a **file dialog**. Like most toolkits, Tkinter provides us with dialogs for opening
    files, saving files, and selecting a directory. These are all part of the `filedialog`
    module.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户需要输入文件或目录路径时，首选的方式是显示一个包含微型文件浏览器的对话框，通常称为**文件对话框**。像大多数工具包一样，Tkinter为我们提供了打开文件、保存文件和选择目录的对话框。这些都是`filedialog`模块的一部分。
- en: Just like `messagebox`, `filedialog` is a Tkinter submodule that needs to be
    explicitly imported to be used. Also like `messagebox`, it contains a set of convenience
    functions that create file dialogs appropriate to different scenarios.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`messagebox`一样，`filedialog`是Tkinter的一个子模块，需要显式导入才能使用。同样，像`messagebox`一样，它包含一组方便的函数，用于创建适合不同场景的文件对话框。
- en: 'The following table lists the functions, what they return, and what can be
    selected in the dialog shown:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了函数、它们返回的内容以及可以在对话框中选择的选项：
- en: '| Function | Return value | Allows selection of |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 返回值 | 允许选择 |'
- en: '| `askdirectory()` | Directory path as string | Directories only |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `askdirectory()` | 字符串形式的目录路径 | 仅目录 |'
- en: '| `askopenfile()` | File handle object | Existing file only |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `askopenfile()` | 文件句柄对象 | 仅现有文件 |'
- en: '| `askopenfilename()` | File path as string | Existing file only |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `askopenfilename()` | 字符串形式的文件路径 | 仅现有文件 |'
- en: '| `askopenfilenames()` | Multiple file paths as a list of strings | Multiple
    existing files |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `askopenfilenames()` | 字符串列表形式的多个文件路径 | 多个现有文件 |'
- en: '| `asksaveasfile()` | File handle object | New or existing file |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `asksaveasfile()` | 文件句柄对象 | 新或现有文件 |'
- en: '| `asksaveasfilename()` | File path as string | New or existing file |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `asksaveasfilename()` | 字符串形式的文件路径 | 新或现有文件 |'
- en: 'As you can see, each file selection dialog comes in two versions: one that
    returns a path as a string, and one that returns an open file object.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，每个文件选择对话框有两种版本：一种返回一个路径字符串，另一种返回一个打开的文件对象。
- en: 'Each function can take the following arguments:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都可以接受以下参数：
- en: '`title` specifies the dialog window title.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`指定对话框窗口标题。'
- en: '`parent` specifies the (optional) parent widget. The file dialog will appear
    over this widget.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`指定（可选）父小部件。文件对话框将显示在这个小部件之上。'
- en: '`initialdir` sets the directory in which the file browser should start.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialdir`设置文件浏览器应该开始的目录。'
- en: '`filetypes` is a list of tuples, each with a label and matching pattern, which
    will be used to build the "Format" or "files of type" drop-down typically seen
    under the filename entry. This is used to filter the visible files to only those
    supported by the application. For example, a value of `[(''Text'', ''*.txt''),
    (''Python'', ''*.py'')]` would provide the ability to see only `.txt` or `.py`
    files.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filetypes`是一个元组列表，每个元组都有一个标签和匹配的模式，这些模式将用于构建通常在文件名输入下看到的“格式”或“文件类型”下拉列表。这用于过滤可见文件，只显示应用程序支持的文件。例如，`[(''Text'',
    ''*.txt''), (''Python'', ''*.py'')]`的值将提供仅查看`.txt`或`.py`文件的能力。'
- en: 'The `asksaveasfile()` and `asksaveasfilename()` functions take the following
    two additional arguments:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`asksaveasfile()`和`asksaveasfilename()`函数还接受以下两个附加参数：'
- en: '`initialfile`: This argument is a default file path to select'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialfile`：此参数是一个默认文件路径，用于选择。'
- en: '`defaultextension`: This argument is a file extension string that will be automatically
    appended to the filename if the user doesn''t include one'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultextension`：此参数是一个文件扩展名字符串，如果用户没有包含一个，它将被自动附加到文件名上。'
- en: Finally, the methods that return a file object take a `mode` argument that specifies
    the mode to use when opening the file; these are the same one- or two-character
    strings used by Python's built-in `open()` function (for example, `r` for read-only,
    `w` for write, and so on).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，返回文件对象的那些方法接受一个`mode`参数，用于指定打开文件时使用的模式；这些是Python内置`open()`函数使用的相同的一个或两个字符字符串（例如，`r`为只读，`w`为写入，等等）。
- en: Be aware that `asksaveasfile()` automatically opens the selected file in write
    mode by default. This immediately empties the contents of the selected file, *even
    if you do not subsequently write anything to the file or close the file handle!*
    For that reason, this function should be avoided unless you're absolutely certain
    the selected file should be overwritten.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`asksaveasfile()`默认情况下会以写入模式自动打开所选文件。这会立即清空所选文件的内容，*即使您随后没有向文件写入任何内容或关闭文件句柄!*
    因此，除非您绝对确定所选文件应该被覆盖，否则应避免使用此函数。
- en: 'On macOS and Windows, `filedialog` uses the operating system''s built-in file
    dialogs, which you are likely familiar with. On Linux, it will use its own dialog,
    which looks something like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS和Windows上，`filedialog`使用操作系统的内置文件对话框，您可能很熟悉。在Linux上，它将使用自己的对话框，看起来像这样：
- en: '![](img/B17578_07_06.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17578_07_06.png)'
- en: 'Figure 7.6: File dialog on Ubuntu Linux'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：Ubuntu Linux上的文件对话框
- en: 'Which dialog do we need to use in our application? Let''s consider our needs:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序需要使用哪个对话框？让我们考虑我们的需求：
- en: We need a dialog that allows us to select an existing file.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个允许我们选择现有文件的对话框。
- en: We also need to be able to create a new file.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还需要能够创建一个新文件。
- en: Since opening the file is the responsibility of the model, we don't want Tkinter
    to open it for us, so we'll just want to get a filename to pass to the model.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于打开文件是模型的责任，我们不希望Tkinter为我们打开它，所以我们只想获取一个要传递给模型的文件名。
- en: These requirements clearly point to the `asksaveasfilename()` function. Let's
    create a method on our `Application` object that will use this dialog to get a
    filename and build a new model.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求明确指向`asksaveasfilename()`函数。让我们在我们的`Application`对象上创建一个方法，使用此对话框获取文件名并构建一个新的模型。
- en: 'Open `abq_data_entry/application.py` and start a new method on the `Application`
    class called `_on_file_select()`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`abq_data_entry/application.py`，并在`Application`类上启动一个新的方法，名为`_on_file_select()`：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The method first launches an `asksaveasfilename` file dialog; using the `filetypes`
    argument, the selection of existing files will be limited to those ending in `.csv`
    or `.CSV`. When the dialog exits, the function will return the path to the selected
    file as a string to `filename`. Somehow, we have to get this path to our model.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法首先启动`asksaveasfilename`文件对话框；使用`filetypes`参数，现有文件的选取将限制在以`.csv`或`.CSV`结尾的文件。当对话框退出时，该函数将返回所选文件的路径作为字符串传递给`filename`。无论如何，我们必须将此路径传递给我们的模型。
- en: Currently, the filename used by the model is generated in the model's initializer
    method. To create a new model with a user-provided filename, we'll need to update
    the initializer so that it can accept a filename as an argument instead.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，模型使用的文件名是在模型的初始化方法中生成的。为了创建一个带有用户提供的文件名的新的模型，我们需要更新初始化方法，使其能够接受一个文件名作为参数。
- en: 'Open `abq_data_entry/model.py` and let''s edit the `CSVModel.__init__()` method,
    like so:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`abq_data_entry/model.py`，并编辑`CSVModel.__init__()`方法，如下所示：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we've added `filename` as a keyword argument with a default
    value of `None`. If `filename` does happen to be empty, we'll use our generated
    filename as before. This way, we don't have to alter any existing code using `CSVModel`,
    but we have the option to pass in a filename.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已将`filename`作为关键字参数添加，默认值为`None`。如果`filename`确实为空，我们将使用之前生成的文件名。这样，我们就不必修改任何使用`CSVModel`的现有代码，但我们有传递文件名的选项。
- en: 'Now, go back to the `Application` class and let''s finish out the `_on_file_select()`
    method, like so:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到`Application`类，让我们完成`_on_file_select()`方法，如下所示：
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is all that we need to change to use a different file. Currently there's
    no way for us to run this callback; we'll address that in the next section, *Designing
    the application menu*. First, though, let's talk about the last dialog module,
    `simpledialog`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用不同的文件，我们只需要更改这些内容。目前，我们没有运行此回调的方法；我们将在下一节中解决，即*设计应用程序菜单*。不过，首先，让我们谈谈最后一个对话框模块，`simpledialog`。
- en: Using simpledialog and creating a custom dialog
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用simpledialog创建自定义对话框
- en: Quite often in a GUI application, you will need to stop everything and ask the
    user for a value before the program can continue with an operation. For this purpose,
    Tkinter provides the `simpledialog` module. Like `messagebox`, it provides us
    with some convenience functions that display a modal dialog and return a value
    based on the user's interaction. However, with `simpledialog`, the dialog box
    contains an `Entry` widget that allows the user to provide a value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在GUI应用程序中，你经常会需要停止一切，在程序可以继续执行操作之前先询问用户一个值。为此，Tkinter提供了`simpledialog`模块。像`messagebox`一样，它为我们提供了一些便利函数，这些函数显示一个模态对话框，并根据用户的交互返回一个值。然而，与`simpledialog`一样，对话框中包含一个`Entry`小部件，允许用户提供值。
- en: 'As with the other dialog libraries, we have to import `simpledialog` to use
    it, like so:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他对话框库一样，我们必须导入`simpledialog`才能使用它，如下所示：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are three convenience functions available: `askstring()`, `askinteger()`,
    and `askfloat()`. Each one takes a `title` and `prompt` argument, for providing
    the window title and the text prompt for the entry, respectively.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个便利函数可用：`askstring()`、`askinteger()`和`askfloat()`。每个函数都接受一个`title`参数和一个`prompt`参数，分别用于提供窗口标题和输入提示文本。
- en: 'For example, let''s ask the user for a word:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们要求用户输入一个单词：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will display a box like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示一个类似这样的框：
- en: '![The askstring dialog box on macOS](img/B17578_07_07.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![macOS上的askstring对话框](img/B17578_07_07.png)'
- en: 'Figure 7.7: The askstring dialog box on macOS'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：macOS上的askstring对话框
- en: 'When the user clicks **OK**, the function will return whatever was typed into
    the `Entry` widget as a string. `askinteger()` and `askfloat()` work exactly the
    same, except that they will try to convert the entered value into an integer or
    float before returning it. The `Entry` widget itself is not validated using validation
    callbacks, but Tkinter will display an error box when the dialog is submitted
    if there is a problem converting the entered value, as shown here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**确定**时，函数将返回输入到`Entry`小部件中的内容作为字符串。`askinteger()`和`askfloat()`的工作方式完全相同，只是在返回之前，它们会尝试将输入的值转换为整数或浮点数。`Entry`小部件本身不使用验证回调进行验证，但如果在提交对话框时转换输入值出现问题，Tkinter将显示一个错误框，如图所示：
- en: '![Error generated from askinteger() when a non-integer value is submitted.](img/B17578_07_08.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![当提交非整数值时，askinteger()生成的错误](img/B17578_07_08.png)'
- en: 'Figure 7.8: Error generated from askinteger() when a non-integer value is submitted'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：当提交非整数值时，askinteger()生成的错误
- en: Creating a Login dialog using simpledialog
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用simpledialog创建登录对话框
- en: 'One of the tasks we''ve been given for this chapter is adding a `Login` dialog
    to our application. It seems like something `simpledialog` can help us with, but
    none of the built-in convenience functions really work well for this purpose:
    `askstring()` could be used, but it only asks for one string at a time, and it
    would be nice if we could mask the password entry for user security.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中的一项任务是向我们的应用程序添加一个`Login`对话框。这似乎是simpledialog可以帮助我们的事情，但内置的便利函数中没有一个真正适合这个目的：`askstring()`可以用来，但它一次只询问一个字符串，如果我们可以为用户安全起见对密码输入进行掩码那就更好了。
- en: Fortunately we can create our own custom `simpledialog` class with any set of
    fields we wish. To do that, we'll subclass the `simpledialog.Dialog` class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以创建自己的自定义`simpledialog`类，包含我们想要的任何字段集。为此，我们将子类化`simpledialog.Dialog`类。
- en: 'Since this is a GUI form, let''s add it to our `abq_data_entry/views.py` file.
    Open that file and start with importing `Dialog`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个GUI表单，让我们将其添加到我们的`abq_data_entry/views.py`文件中。打开该文件，并从导入`Dialog`开始：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, at the end of the file, let''s start a new class called `LoginDialog`,
    like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在文件末尾，让我们开始一个新的类，称为`LoginDialog`，如下所示：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Dialog` initializer expects a `parent` argument specifying the widget over
    which it will appear, as well as a `title` argument for the window title of the
    box. We've also added a keyword argument, `error`, that will allow us to pass
    an error message to the dialog box when we display it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dialog`初始化器期望一个`parent`参数，指定它将出现的窗口小部件，以及一个`title`参数，用于框的窗口标题。我们还添加了一个关键字参数`error`，它将允许我们在显示对话框时传递一个错误消息。'
- en: Inside the initializer, we're setting up private control variables for the user,
    password, and error strings, then calling the superclass initializer. To actually
    build the GUI for the `Dialog` class, we need to override a method called `body()`.
    This method is expected to build the main body of the GUI and return an instance
    of an input widget, which should receive focus when the dialog is displayed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化器内部，我们正在设置用户、密码和错误字符串的私有控制变量，然后调用超类初始化器。为了实际构建`Dialog`类的GUI，我们需要覆盖一个名为`body()`的方法。此方法预期构建GUI的主体，并返回一个输入小部件的实例，该实例在对话框显示时应获得焦点。
- en: 'Our `body()` method will look like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`body()`方法将如下所示：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `frame` argument to this method is a `tkinter.Frame` object created by the
    super-class initializer on which the body of the dialog can be built. Our method
    needs to build the form on this frame. Here, we've added a `Label` widget for
    the top of the form, then made use of our `LabelInput` class to add User name
    and Password fields. For our password input, we're using the `show` argument to
    mask password entry with asterisks. Also note that we've saved a local reference
    to the user input class; remember that `body()` needs to return a reference to
    a widget that will have focus when the dialog is shown.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法中的`frame`参数是一个由超类初始化器创建的`tkinter.Frame`对象，在它上面可以构建对话框的主体。我们的方法需要在框架上构建表单。在这里，我们为表单的顶部添加了一个`Label`小部件，然后使用我们的`LabelInput`类添加用户名和密码字段。对于我们的密码输入，我们使用`show`参数用星号隐藏密码输入。此外，请注意，我们已经保存了对用户输入类的局部引用；记住`body()`需要返回一个在对话框显示时将获得焦点的部件的引用。
- en: Notice there are no buttons defined by our `body()` method. By default, `Dialog`
    creates an **OK** button and **Cancel** button, which are connected to the `Dialog.ok()`
    and `Dialog.cancel()` callbacks, respectively. This is fine for many situations,
    but we might prefer for our dialog to show **Login** and **Cancel** instead. To
    do that, we need to override the `buttonbox()` method. This method is responsible
    for putting the buttons on the form and connecting them to their callbacks.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们的`body()`方法中没有定义按钮。默认情况下，`Dialog`创建一个**确定**按钮和一个**取消**按钮，分别连接到`Dialog.ok()`和`Dialog.cancel()`回调。这对于许多情况来说是可以的，但我们可能更喜欢我们的对话框显示**登录**和**取消**。为此，我们需要覆盖`buttonbox()`方法。此方法负责将按钮放置在表单上并将它们连接到它们的回调。
- en: 'Let''s override that method like so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们像这样覆盖该方法：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this method, we've created a `Frame` widget, then added Login and Cancel
    buttons. Each button is connected to the appropriate callback and added to the
    frame. Next, we've bound the same callbacks to the `Return` and `Escape` keys,
    respectively. This isn't strictly necessary, but it's a nice touch for keyboard-only
    users, and it's what the superclass version of the method does.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，我们创建了一个`Frame`小部件，然后添加了登录和取消按钮。每个按钮都连接到相应的回调，并添加到框架中。接下来，我们将相同的回调绑定到`Return`和`Escape`键上，分别。这并不是严格必要的，但对于仅使用键盘的用户来说是一个很好的功能，这也是超类方法版本所做的事情。
- en: To make the entered data easily available to the code calling the dialog, we'll
    create a tuple with the entered username and password and make it available as
    a class member when the user clicks **Login**.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使输入的数据容易为调用对话框的代码访问，我们将创建一个包含输入用户名和密码的元组，并在用户点击**登录**时将其作为类成员提供。
- en: We could override the `ok()` method to do this, but that method takes care of
    some other logic (like closing the dialog) that we don't want to have to re-implement.
    Instead, `Dialog` features an `apply()` method that we are meant to override with
    our custom logic.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以覆盖`ok()`方法来实现这一点，但该方法处理一些其他逻辑（如关闭对话框），我们不希望重新实现。相反，`Dialog`具有一个`apply()`方法，我们打算用我们的自定义逻辑覆盖它。
- en: 'Ours will simply look like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 它将简单地如下所示：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function builds a tuple containing the entered data and stores it as a
    public member, `result`. Code using our `LoginDialog` class can access this attribute
    to retrieve the `username` and `password`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数构建一个包含输入数据的元组，并将其存储为公共成员`result`。使用我们的`LoginDialog`类的代码可以访问此属性以检索`username`和`password`。
- en: Incorporating the LoginDialog in our class
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我们的类中整合LoginDialog
- en: The convenience functions, `askstring()`, `askfloat()`, and `askinteger()`,
    essentially create an instance of their associated dialog class and return its
    `result` attribute. To use our custom dialog class, we'll essentially do the same
    thing. When we get the result, however, we'll pass it to an authentication method
    that will decide if the credentials are valid or not. If they're not, we'll re-display
    the dialog with an error until either the credentials are correct, or the user
    cancels the dialog.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 方便函数`askstring()`、`askfloat()`和`askinteger()`基本上创建它们相关联的对话框类的实例，并返回其`result`属性。为了使用我们的自定义对话框类，我们将做同样的事情。当我们得到结果时，我们将将其传递给一个认证方法，该方法将决定凭据是否有效。如果无效，我们将重新显示带有错误的对话框，直到凭据正确或用户取消对话框。
- en: 'To begin, let''s write an authentication method. We''ll be adding this to the
    `Application` class, so open `application.py` and add this `_simple_login()` method
    to the end of the class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写一个认证方法。我们将把这个方法添加到`Application`类中，所以打开`application.py`文件，并将这个`_simple_login()`方法添加到类的末尾：
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice we've implemented this as a static method, since it does not need access
    to the instance or class. It will simply take the `username` and `password` given
    and see if they match hard-coded values. It returns `True` or `False` accordingly.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将其实现为一个静态方法，因为它不需要访问实例或类。它将简单地接受给定的`username`和`password`，并查看它们是否与硬编码的值匹配。它相应地返回`True`或`False`。
- en: This is quite possibly the worst way you can do password security in an application;
    *do not* ever use this approach in a real application. We are using it here for
    the sake of illustration, since the point is to understand dialogs. In *Chapter
    12*, *Improving Data Storage with SQL*, we'll implement an authentication backend
    that's actually production-worthy.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是你在应用程序中做密码安全的最糟糕的方式；**永远不要**在真实的应用程序中使用这种方法。我们在这里使用它是为了说明，因为目的是理解对话框。在**第12章**，**使用SQL改进数据存储**中，我们将实现一个真正值得生产的认证后端。
- en: 'Now, let''s create a second method that will display the login dialog and test
    the entered credentials for validity, like so:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建第二个方法，这个方法将显示登录对话框并测试输入的凭据是否有效，如下所示：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this method, we begin by creating `error` and `title` variables, then entering
    an infinite loop. Inside the loop, we create our `LoginDialog` instance using
    the `title` and `error` strings. This will display the dialog, and execution will
    halt here until the user either cancels or submits the dialog. When that happens,
    `login` is assigned to the instance of the dialog (*not* to the results!). Now
    we can check `login.result` to see what the user entered.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们首先创建`error`和`title`变量，然后进入一个无限循环。在循环内部，我们使用`title`和`error`字符串创建`LoginDialog`实例。这将显示对话框，并且执行将在这里暂停，直到用户取消或提交对话框。当这种情况发生时，`login`被分配给对话框的实例（**不是**结果！）现在我们可以检查`login.result`以查看用户输入了什么。
- en: If `result` is empty, the user canceled, so we can return `False` from the method.
    If the user entered something, we'll extract `result` into its `username` and
    `password` values, then pass those to our `_simple_login()` method. If the credentials
    check out, we will return `True`; if not, we'll update the error string and let
    the loop iterate again, re-displaying the dialog. The net result is that this
    method will return either `False` if the dialog was canceled, or `True` if the
    authentication succeeded.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`result`为空，则用户取消了操作，因此我们可以从方法中返回`False`。如果用户输入了某些内容，我们将`result`提取到其`username`和`password`值中，然后将这些值传递给我们的`_simple_login()`方法。如果凭据检查通过，我们将返回`True`；如果不通过，我们将更新错误字符串并让循环再次迭代，重新显示对话框。最终结果是，这个方法将返回`False`（如果对话框被取消），或者`True`（如果认证成功）。
- en: Now, we need to call this method during the startup of our application. We'll
    do this in the application's initializer. Since dialogs cannot be created until
    a root window has been created, we'll have to do this just after the call to `super().__init__()`
    (remember that `Application` is a subclass of `Tk`, so calling `super().__init__()`
    is what creates our `Tk` instance).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在应用程序启动时调用这个方法。我们将在应用程序的初始化器中这样做。由于对话框必须在创建根窗口之后才能创建，所以我们必须在调用`super().__init__()`之后立即进行（记住，`Application`是`Tk`的子类，所以调用`super().__init__()`就是创建我们的`Tk`实例）。
- en: 'Add the following code to `Application.__init__()`, just under the call to
    `super().__init__()`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Application.__init__()`中，就在调用`super().__init__()`之后：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first line calls the `withdraw()` method, which hides our main window. We
    don't strictly have to do this, but without it we'll have a blank `Application`
    window hanging around while the login dialog is being presented.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行调用了`withdraw()`方法，该方法隐藏了我们的主窗口。我们并不严格必须这样做，但如果没有它，当登录对话框正在显示时，我们将会有一个空白的`Application`窗口悬挂在那里。
- en: After hiding the blank window, we'll call `_show_login()` and test its `return`
    value. Remember it will return `True` if the user successfully authenticates,
    or `False` if the user cancels the dialog. In the latter case, we'll call `self.destroy()`,
    which deletes our `Tk` instance, and return from the method. Effectively, this
    quits the application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在隐藏空白窗口之后，我们将调用`_show_login()`并测试其`return`值。记住，如果用户成功认证，它将返回`True`，如果用户取消对话框，则返回`False`。在后一种情况下，我们将调用`self.destroy()`，这将删除我们的`Tk`实例，并从方法中返回。实际上，这会退出应用程序。
- en: Normally you would call `Application.quit()` to exit a Tkinter program; this
    method of the `Tk` object causes the main loop to exit and thus the program ends.
    However, at this point in the program, we haven't started the main loop yet, so
    `quit()` won't do anything. If we destroy the window and return without adding
    anything else, the main loop will see that the root window is destroyed and exit
    after its first iteration.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通常您会调用`Application.quit()`来退出Tkinter程序；这个`Tk`对象的方法会导致主循环退出，从而程序结束。然而，在程序的这个阶段，我们还没有启动主循环，所以`quit()`不会做任何事情。如果我们销毁窗口并返回而不添加任何其他内容，主循环将看到根窗口已被销毁，并在第一次迭代后退出。
- en: If the user is successful in authenticating, we'll call the application's `deiconify()`
    method, which restores its visibility. Then we continue with the remainder of
    the initializer.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户成功认证，我们将调用应用程序的`deiconify()`方法，这将恢复其可见性。然后我们继续初始化器的其余部分。
- en: 'Go ahead and launch the application to give your `LoginDialog` class a test
    run. It should look something like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 继续启动应用程序，以对您的`LoginDialog`类进行测试运行。它应该看起来像这样：
- en: '![The login dialog](img/B17578_07_09.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![登录对话框](img/B17578_07_09.png)'
- en: 'Figure 7.9: The login dialog'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：登录对话框
- en: Great job!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！
- en: Designing the application menu
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计应用程序菜单
- en: Most applications organize functionality into a hierarchical menu system, typically
    displayed at the top of the application or screen (depending on the operating
    system). While the organization of this menu varies between operating systems,
    certain items are fairly common across platforms.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序将功能组织成层次菜单系统，通常显示在应用程序或屏幕的顶部（取决于操作系统）。虽然不同操作系统之间此菜单的组织方式不同，但某些项目在各个平台之间相当常见。
- en: 'Of these common items, our application will need the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些常见项目之中，我们的应用程序需要以下内容：
- en: A **File menu** containing file operations such as **Open**/**Save**/**Export**,
    and often an option to quit the application. Our users will need this menu to
    select a file to save to, and to quit the program.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含文件操作（如**打开**/**保存**/**导出**）的**文件菜单**，以及通常有一个退出应用程序的选项。我们的用户将需要这个菜单来选择要保存的文件，以及退出程序。
- en: An **Options menu** where users can configure the application. We'll need this
    menu for our toggle settings; sometimes a menu like this is called Preferences
    or Settings, but we'll go with Options for now.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**选项菜单**，用户可以在此配置应用程序。我们需要这个菜单来切换设置；有时这样的菜单被称为首选项或设置，但我们现在先使用选项。
- en: A **Help menu**, which contains links to help documentation, or, at the very
    least, an About message giving the basic information about the application. We'll
    implement this menu for the About dialog.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**帮助菜单**，其中包含指向帮助文档的链接，或者至少是一个提供应用程序基本信息的关于对话框。我们将为此实现菜单。
- en: Apple, Microsoft, and the GNOME Project publish guidelines for macOS, Windows,
    and the GNOME desktop environment (used on Linux and BSD), respectively; each
    set of guidelines addresses the layout of menu items specific to that platform.
    We'll explore this in more detail in *Chapter 10*, *Maintaining Cross-Platform
    Compatibility*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果、微软和GNOME项目分别发布了macOS、Windows和GNOME桌面环境（用于Linux和BSD）的指南；每一套指南都针对特定平台的菜单项布局。我们将在第10章*维护跨平台兼容性*中更详细地探讨这一点。
- en: Before we can implement our menu, we'll need to understand how menus work in
    Tkinter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够实现我们的菜单之前，我们需要了解Tkinter中菜单是如何工作的。
- en: The Tkinter Menu widget
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tkinter菜单小部件
- en: The `tkinter.Menu` widget is the building block used to implement menus in Tkinter
    applications; it's a fairly simple widget that acts as a container for any number
    of menu items.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`tkinter.Menu`小部件是用于在Tkinter应用程序中实现菜单的基本构建块；它是一个相当简单的小部件，充当任意多个菜单项的容器。'
- en: 'The menu items can be one of the following five types:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单项可以是以下五种类型之一：
- en: '| Item type | Description |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 项目类型 | 描述 |'
- en: '| `command` | A labeled item that executes a command when clicked |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `command` | 一个标签化的项，在点击时执行命令 |'
- en: '| `checkbutton` | A labeled checkbutton that can be tied to a Boolean control
    variable |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `checkbutton` | 一个标签化的复选按钮，可以与布尔控制变量相关联 |'
- en: '| `radiobutton` | A labeled radio button that can be tied to a control variable
    |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `radiobutton` | 一个标签化的单选按钮，可以与控制变量相关联 |'
- en: '| `separator` | A system-appropriate visual separator, usually a black line
    |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `separator` | 一个系统适当的视觉分隔符，通常是一条黑色线 |'
- en: '| `cascade` | A submenu, implemented as a second `Menu` instance |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `cascade` | 一个子菜单，作为第二个`Menu`实例实现 |'
- en: 'To explore how the `Menu` class works, let''s start a simple example script,
    like so:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索`Menu`类的工作方式，让我们从一个简单的示例脚本开始，如下所示：
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This application sets up a 200-by-150-pixel main window with a `Label` widget,
    whose text is controlled by a string variable, `main_text`. Now, let''s start
    adding the menu components, like so:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序设置了一个200x150像素的主窗口，其中包含一个`Label`小部件，其文本由一个字符串变量`main_text`控制。现在，让我们开始添加菜单组件，如下所示：
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This creates a `Menu` instance and then sets it as the main menu of our application
    by assigning it to the `root` window's `menu` argument.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个`Menu`实例，然后通过将其分配给`root`窗口的`menu`参数，将其设置为应用程序的主菜单。
- en: 'Currently, the menu is empty, so let''s add an item; add this code to the script:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，菜单是空的，所以让我们添加一个项；将以下代码添加到脚本中：
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we've added a `command` item to quit the application. The `Menu.add()`
    method allows us to specify an item type and any number of keyword arguments to
    create a new menu item. In the case of a `command` item, we need to at least have
    a `label` argument specifying the text that will show in the menu and a `command`
    argument pointing to a Python callback.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个`command`命令项以退出应用程序。`Menu.add()`方法允许我们指定一个项目类型以及任意数量的关键字参数来创建一个新的菜单项。在`command`项的情况下，我们至少需要一个`label`参数来指定将在菜单中显示的文本，以及一个指向Python回调函数的`command`参数。
- en: Some platforms, such as macOS, don't allow a command in the top-level menu.
    We'll cover the differences between menus on different platforms in more detail
    in *Chapter 10*, *Maintaining Cross-Platform Compatibility*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一些平台，如macOS，不允许在顶级菜单中使用命令。我们将在第10章*维护跨平台兼容性*中更详细地介绍不同平台菜单之间的差异。
- en: 'Next, let''s try creating a submenu, like so:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试创建一个子菜单，如下所示：
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating a submenu is just like creating a menu, except that we specify the
    parent menu as the widget's parent. Notice the `tearoff` argument; by default,
    submenus in Tkinter are **tearable**, which means they can be pulled off and moved
    around as independent windows.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个子菜单就像创建一个菜单一样，只不过我们需要指定父菜单作为小部件的父级。注意`tearoff`参数；在Tkinter中，子菜单默认是**可撕离的**，这意味着它们可以被拉出来并作为独立窗口移动。
- en: You don't have to disable this option, but it is a rather archaic UI feature
    that is rarely used on modern platforms. Our users will likely just find it confusing,
    so we're going to disable it whenever we create submenus.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必禁用此选项，但这是一种相当古老的UI功能，在现代平台上很少使用。我们的用户可能会觉得它很困惑，所以每当创建子菜单时，我们都会禁用它。
- en: 'Now that we have a submenu object, let''s add some commands, like so:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了子菜单对象，让我们添加一些命令，如下所示：
- en: '[PRE22]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `add_command()` method used here is simply a shortcut for `add('command')`,
    and it can be used on any `Menu` object. There are analogous methods for adding
    other items as well (`add_cascade()`, `add_separator()`, and so on).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的`add_command()`方法仅仅是`add('command')`的快捷方式，并且可以在任何`Menu`对象上使用。还有类似的方法用于添加其他项（如`add_cascade()`、`add_separator()`等）。
- en: 'Now that we''ve populated the `text_menu`, let''s use the `add_cascade()` method
    to add our menu back to its parent widget as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经填充了`text_menu`，让我们使用`add_cascade()`方法将我们的菜单添加回其父小部件，如下所示：
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When adding a submenu to its parent menu, we simply have to provide the label
    for the menu and the menu object itself.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当将子菜单添加到其父菜单时，我们只需提供菜单的标签和菜单对象本身。
- en: Using Checkbutton and Radiobutton items
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Checkbutton和Radiobutton项
- en: In addition to commands and submenus, we can also add `Checkbutton` and `Radiobutton`
    widgets to the menu. To demonstrate this, let's create another submenu with options
    to alter the label's appearance.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 除了命令和子菜单外，我们还可以在菜单中添加`Checkbutton`和`Radiobutton`小部件。为了演示这一点，让我们创建另一个子菜单，其中包含用于更改标签外观的选项。
- en: 'First, we''ll need to add the following setup code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要添加以下设置代码：
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To use `checkbutton` and `radiobutton` items in a menu, we need to first create
    control variables to bind to them. Here, we're just creating a Boolean variable
    for the bold font toggle, and an integer variable for the font size. Next, we've
    created a callback function that reads the variables and sets the `Label` widget's
    `font` property from them when called. Finally, we've set up a trace on both variables
    to call the callback whenever the values are changed, and called the callback
    to initialize the font settings.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要在菜单中使用`checkbutton`和`radiobutton`项，我们首先需要创建控制变量来绑定它们。在这里，我们只是创建了一个布尔变量用于粗体字体切换，以及一个整数变量用于字体大小。接下来，我们创建了一个回调函数，该函数读取变量并在被调用时从它们设置`Label`小部件的`font`属性。最后，我们为这两个变量设置了跟踪，以便在值更改时调用回调，并调用了回调以初始化字体设置。
- en: 'Now, we just need to create the menu options to change the variables; add this
    code next:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要创建菜单选项来更改变量；添加以下代码：
- en: '[PRE25]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here we've created the submenu for the appearance options and added the checkbutton
    for bold text. Like a regular `Checkbutton` widget, the `add_checkbutton()` method
    uses a `variable` argument to assign its control variable. Unlike a regular `Checkbutton`
    widget, though, it uses the `label` argument, rather than the `text` argument,
    to assign the label text.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了外观选项的子菜单并添加了粗体文本的复选框。就像常规的`Checkbutton`小部件一样，`add_checkbutton()`方法使用`variable`参数来分配其控制变量。然而，与常规的`Checkbutton`小部件不同，它使用`label`参数而不是`text`参数来分配标签文本。
- en: The `checkbutton` item works with a `BooleanVar` by default; however, just like
    a `Checkbutton` widget, you can use it with different control variable types by
    passing in `onvalue` and `offvalue` arguments.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`checkbutton`项与`BooleanVar`一起使用；然而，就像`Checkbutton`小部件一样，你可以通过传递`onvalue`和`offvalue`参数来使用不同的控制变量类型。
- en: 'To demonstrate `radiobutton` items, let''s add a submenu to our Appearance
    submenu, like so:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`radiobutton`项，让我们在我们的外观子菜单中添加一个子菜单，如下所示：
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Just as we added a submenu to our main menu, we can add submenus to submenus.
    In theory, you could nest submenus indefinitely, but most UI guidelines discourage
    more than two levels.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们向主菜单添加了子菜单一样，我们也可以向子菜单添加子菜单。在理论上，你可以无限地嵌套子菜单，但大多数UI指南都建议不超过两个级别。
- en: To create the items for our size menu, we're just iterating a generated list
    of even numbers between 8 and 24; for each one, we call `add_radiobutton()`, adding
    an item with a value equal to that size. Just as with regular `Radiobutton` widgets,
    the control variable passed to the `variable` argument will be updated with the
    value stored in the `value` argument when the button is selected.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的尺寸菜单创建项，我们只是迭代从8到24生成的偶数列表；对于每一个，我们调用`add_radiobutton()`，添加一个具有该尺寸值的项。就像常规的`Radiobutton`小部件一样，传递给`variable`参数的控制变量将在按钮被选中时更新为存储在`value`参数中的值。
- en: 'Finally, let''s add a call to `mainloop()`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加一个对`mainloop()`的调用：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Launch the application and try it out. You should get something like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序并尝试使用它。你应该得到类似以下内容：
- en: '![The Menu demo application](img/B17578_07_10.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![菜单演示应用程序](img/B17578_07_10.png)'
- en: 'Figure 7.10: The Menu demo application'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：菜单演示应用程序
- en: Now that we understand how to work with the `Menu` widget, let's design and
    implement a menu for our application.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用`Menu`小部件，让我们为我们的应用程序设计和实现一个菜单。
- en: Implementing the ABQ application menu
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现ABQ应用程序菜单
- en: 'As a major component of the GUI, our main menu code would be right at home
    in the `views.py` file. However, because it''s going to be expanded considerably
    as our application grows, we''ll put it in its own module file. Create a new file
    the `abq_data_entry` directory called `mainmenu.py`. Then begin the file with
    a docstring and our imports:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 作为GUI的主要组件，我们的主菜单代码将非常适合放在`views.py`文件中。然而，由于随着应用程序的增长它将大大扩展，我们将将其放入自己的模块文件中。在`abq_data_entry`目录中创建一个名为`mainmenu.py`的新文件。然后以一个文档字符串和我们的导入开始文件：
- en: '[PRE28]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, let''s subclass `tkinter.Menu` to create our own main menu class, like
    so:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过以下方式子类化`tkinter.Menu`来创建我们自己的主菜单类：
- en: '[PRE29]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will be building the rest of the menu inside the initializer, though for
    the moment this doesn't do anything extra. Before we start building the menu,
    let's drop back into our `application.py` module and set up this class as the
    application's main menu.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在初始化器内部构建菜单的其余部分，尽管目前这并没有做任何额外的事情。在我们开始构建菜单之前，让我们回到`application.py`模块，并将此类设置为应用程序的主菜单。
- en: 'First, import the class at the top of the file, like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在文件顶部导入类，如下所示：
- en: '[PRE30]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, inside `Application.__init__()`, we need to create an instance of our
    `MainMenu` class and make it the application''s menu. Update the method as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`Application.__init__()`内部，我们需要创建我们的`MainMenu`类的一个实例，并将其作为应用程序的菜单。更新方法如下：
- en: '[PRE31]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now let's head back to `mainmenu.py` and start building the components of our
    menu.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到`mainmenu.py`并开始构建菜单的组件。
- en: Adding a Help menu
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加帮助菜单
- en: Let's begin with something simple. We'll just add an About dialog to display
    some information about our program. This is typically located in a Help menu.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的事情开始。我们只需添加一个关于对话框来显示有关我们程序的一些信息。这通常位于帮助菜单中。
- en: 'Add the following code to `MainMenu.__init__()`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`MainMenu.__init__()`中：
- en: '[PRE32]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we've added a Help menu and a command for About.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个帮助菜单和一个关于的命令。
- en: 'The command specifies an instance method, `show_about()`, as its callback;
    so, we''ll need to add that method to the class, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 命令指定了一个实例方法`show_about()`作为其回调；因此，我们需要将该方法添加到类中，如下所示：
- en: '[PRE33]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This method just specifies some basic information about the application and
    displays it in a `messagebox` dialog. You can, of course, update the `about_detail`
    variable with your own information, or a much longer (and hopefully more helpful)
    message.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法仅指定了一些关于应用程序的基本信息，并在`messagebox`对话框中显示它。当然，您可以更新`about_detail`变量以包含您自己的信息，或者一个更长（并且希望更有帮助）的消息。
- en: Adding a File menu
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加文件菜单
- en: The next menu we'll create is a File menu. This will have two commands, one
    for selecting a file and another for quitting the application. Unlike the About
    dialog, though, we can't really implement the callback logic for either command
    in the menu class itself. File selection will need to call the `Application._on_file_select()`
    method we created earlier in the chapter, and the quit command will need to call
    `Application.quit()`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要创建的菜单是文件菜单。这个菜单将有两个命令，一个用于选择文件，另一个用于退出应用程序。然而，与关于对话框不同的是，我们实际上不能在菜单类本身中实现这两个命令的回调逻辑。文件选择需要调用我们在本章早期创建的`Application._on_file_select()`方法，而退出命令需要调用`Application.quit()`。
- en: Since the menu's parent widget will be the `Application` object, we could just
    bind these commands to `parent._on_file_select` and `parent.quit`, but that would
    create a tight coupling situation as we discussed in *Chapter 6*, *Planning for
    the Expansion of Our Application*. As we did in that chapter, we'll instead use
    generated events to communicate back to the controller class.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 由于菜单的父小部件将是`Application`对象，我们可以将这些命令绑定到`parent._on_file_select`和`parent.quit`，但这样会创建一个紧密耦合的情况，正如我们在第6章中讨论的，*为应用程序的扩展做准备*。正如我们在那一章中所做的那样，我们将使用生成的事件来将信息反馈给控制器类。
- en: 'One possible way to implement our File menu commands is to use a `lambda` function,
    like so:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 实现我们的文件菜单命令的一个可能方法是使用一个`lambda`函数，如下所示：
- en: '[PRE34]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `lambda` keyword creates an anonymous inline function that contains a single
    expression. It is often used in situations where we need a reference to a function
    (such as a widget's `command` argument) but don't need the overhead of defining
    a named function. In this case, we're creating an anonymous function that generates
    a custom `<<FileSelect>>` event on the `MainMenu` object using `event_generate()`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`关键字创建了一个包含单个表达式的匿名内联函数。它通常用于需要函数引用（如小部件的`command`参数）但不需要定义命名函数的开销的情况。在这种情况下，我们创建了一个匿名函数，它使用`event_generate()`在`MainMenu`对象上生成一个自定义的`<<FileSelect>>`事件。'
- en: You can find out more about Lambda expressions in *Section 6.14* of the Python
    official documentation, available at [https://docs.python.org/3/reference/expressions.html](https://docs.python.org/3/reference/expressions.html).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Python官方文档的*第6.14节*中了解更多关于Lambda表达式的信息，该文档可在[https://docs.python.org/3/reference/expressions.html](https://docs.python.org/3/reference/expressions.html)找到。
- en: However, there are two problems with this approach.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法有两个问题。
- en: First, using `lambda` every time is rather verbose and ugly, and since our menu
    is going to be generating a lot of custom events as the application grows, we'd
    like to avoid a lot of repetitive boilerplate code.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，每次都使用 `lambda` 会相当冗长且难看，并且由于我们的菜单在应用程序增长时将生成大量的自定义事件，我们希望避免大量的重复样板代码。
- en: Second, binding events on a `Menu` object doesn't work on all platforms (particularly,
    it doesn't work on Microsoft Windows). This has to do with the fact that the `Menu`
    is built around the native menu system of each platform. To work around this,
    we'll need to get a reference to our `root` window and bind our events to that.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，在 `Menu` 对象上绑定事件在所有平台上都不起作用（特别是，在 Microsoft Windows 上不起作用）。这与 `Menu` 是围绕每个平台的本地菜单系统构建的事实有关。为了解决这个问题，我们需要获取对
    `root` 窗口的引用，并将我们的事件绑定到它。
- en: Since this makes our code even uglier, it makes sense to create a simple wrapper
    function that will keep our menu definitions nice and clean.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这会让我们的代码变得更加丑陋，因此创建一个简单的包装函数来保持我们的菜单定义整洁是有意义的。
- en: 'Add the following `_event()` method to the `MainMenu` class above the initializer:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainMenu` 类的初始化器之上添加以下 `_event()` 方法：
- en: '[PRE35]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This simple method creates a function that causes the `root` window instance
    to generate the provided `sequence` string, then returns a reference to the newly
    defined function. To get a reference to the `root` window, we call `winfo_toplevel()`
    on the menu's parent widget (`self.master`), which returns the top-level window
    of the menu's parent widget. You might wonder why we don't just use `self.master`,
    or just call `winfo_toplevel()` on the `Menu` object itself. In the first case,
    we can't be sure what the menu's parent widget will be until we create an instance
    of it, especially as our program evolves in the future. While we can't be sure
    exactly what the parent widget will be, we can be sure it will be a widget on
    a window; by calling `winfo_toplevel()` we should get the `root` window.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的方法创建了一个函数，该函数会导致 `root` 窗口实例生成提供的 `sequence` 字符串，然后返回对新定义的函数的引用。为了获取 `root`
    窗口的引用，我们在菜单的父小部件（`self.master`）上调用 `winfo_toplevel()`，这将返回菜单父小部件的最高级窗口。你可能想知道为什么我们不直接使用
    `self.master`，或者直接在 `Menu` 对象上调用 `winfo_toplevel()`。在第一种情况下，我们无法确定菜单的父小部件是什么，直到我们创建其实例，尤其是在我们的程序在未来发展时。虽然我们无法确定父小部件的确切类型，但我们确信它将是一个窗口上的小部件；通过调用
    `winfo_toplevel()`，我们应该得到 `root` 窗口。
- en: In the second case, the `winfo_toplevel()` method, when called on a `Menu` object,
    actually returns the top level of the *menu*. In other words, `self.winfo_toplevel()`
    in this context would just return our `MainMenu` object.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，`winfo_toplevel()` 方法，当在 `Menu` 对象上调用时，实际上返回的是 *菜单* 的顶层。换句话说，在这个上下文中，`self.winfo_toplevel()`
    将仅返回我们的 `MainMenu` 对象。
- en: 'Now we can update our menu items to use this wrapper method, like so:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新我们的菜单项以使用这个包装方法，如下所示：
- en: '[PRE36]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note the use of the ellipsis character (`…`) after `"Select file"`. This is
    a convention in menus to indicate when a command will open another window or dialog
    to get information from the user rather than just running a command directly.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 `"Select file"` 后面使用了省略号字符（`…`）。这是菜单中的一个约定，表示当执行命令时，将打开另一个窗口或对话框来获取用户信息，而不是直接运行命令。
- en: Now our code looks much cleaner. To make these commands work, we'll need to
    tell our `Application` class to listen for these events and take appropriate action
    when they're generated.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码看起来整洁多了。为了使这些命令生效，我们需要告诉我们的 `Application` 类监听这些事件，并在它们生成时采取适当的行动。
- en: 'Back in the `application.py` file, let''s add the following lines to `Application.__init__()`,
    just after the menu object setup:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `application.py` 文件中，让我们在菜单对象设置之后，向 `Application.__init__()` 添加以下行：
- en: '[PRE37]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we've created an `event_callbacks` dictionary, matching event sequences
    to callback methods. Then, we're iterating through the dictionary, binding each
    sequence to its event.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个 `event_callbacks` 字典，将事件序列与回调方法相匹配。然后，我们遍历这个字典，将每个序列绑定到其事件。
- en: As we add more items to our menu, we'll just need to update the dictionary with
    the additional bindings. Note that we cannot bind the `<<FileQuit>>` action directly
    to `self.quit()`. That's because callbacks bound using the `bind()` method pass
    arguments when the callback is called, and `self.quit()` takes no arguments. We're
    using a `lambda` call here just to filter out the added argument from the callback.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们向菜单中添加更多项目，我们只需要更新字典以包含额外的绑定。请注意，我们不能直接将`<<FileQuit>>`动作绑定到`self.quit()`。这是因为使用`bind()`方法绑定的回调在调用时传递参数，而`self.quit()`不接受任何参数。我们在这里使用`lambda`调用只是为了从回调中过滤掉添加的参数。
- en: Adding a settings menu
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加设置菜单
- en: The next thing we need to add is our Options menu, which will allow the user
    to specify whether they want the Date and Sheet data auto-filled in the form or
    not. We've already seen that adding checkbutton options to a menu is fairly easy,
    but actually making these options work is going to take some additional plumbing
    work. Somehow, we need to connect these menu options to the `DataRecordForm` instance
    so that it can disable the automation appropriately.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步需要添加的是我们的选项菜单，它将允许用户指定他们是否希望在表单中自动填充日期和表数据。我们已经看到向菜单中添加复选框选项相当简单，但实际上使这些选项工作需要一些额外的管道工作。我们需要以某种方式将这些菜单选项连接到`DataRecordForm`实例，以便它可以适当地禁用自动化。
- en: 'To do this, let''s begin by creating a dictionary in the `Application` class
    that will store some control variables:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，让我们首先在`Application`类中创建一个字典，该字典将存储一些控制变量：
- en: '[PRE38]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Next, we will need to make sure both our `DataRecordForm` and `MainMenu` objects
    have access to these settings; we will do this by passing the `settings` dictionary
    to their initializer methods and storing it as an instance variable on each class.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保我们的`DataRecordForm`和`MainMenu`对象都可以访问这些设置；我们将通过将`settings`字典传递给它们的初始化方法并将它存储在每个类的实例变量上来做到这一点。
- en: 'First, in `views.py`, let''s update the `DataRecordForm.__init__()` method,
    like so:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`views.py`中，让我们更新`DataRecordForm.__init__()`方法，如下所示：
- en: '[PRE39]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, in `mainmenu.py`, let''s update the `MainMenu.__init__()` method, like
    so:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`mainmenu.py`中，让我们更新`MainMenu.__init__()`方法，如下所示：
- en: '[PRE40]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, back in the `Application` class, we have to update the code that creates
    instances of these classes to pass in the `settings` dictionary to each one. Update
    the code in `Application.__init__()` as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到`Application`类，我们必须更新创建这些类实例的代码，以便将`settings`字典传递给每个实例。按照以下方式更新`Application.__init__()`中的代码：
- en: '[PRE41]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Each class now has access to the `settings` dictionary, so let's put it to use.
    To begin with, let's add our Options menu to the main menu.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类现在都可以访问`settings`字典，所以让我们来使用它。首先，让我们将我们的选项菜单添加到主菜单中。
- en: 'In the `MainMenu` file, add this code to the initializer method to build the
    menu:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainMenu`文件中，将以下代码添加到初始化方法中以构建菜单：
- en: '[PRE42]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Very simply, we've created a `Menu` widget called `options_menu` with two `checkbutton`
    items that are bound to our settings variable. That's all the configuration our
    `MainMenu` needs for the settings.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，我们创建了一个名为`options_menu`的`Menu`小部件，其中包含两个绑定到我们的设置变量的`checkbutton`项。这就是`MainMenu`需要的所有设置配置。
- en: The last thing we need to do is make these settings work with the `DataRecordForm`
    class's `reset()` method, which handles the auto-filling of these fields.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是让这些设置与`DataRecordForm`类的`reset()`方法一起工作，该方法处理这些字段的自动填充。
- en: 'In the `views.py` file, locate the `DataRecordForm.reset()` method, and find
    the code that sets the date variable. Update it as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在`views.py`文件中，定位`DataRecordForm.reset()`方法，并找到设置日期变量的代码。更新如下：
- en: '[PRE43]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'All we''ve done here is put this date-setting logic below an `if` statement
    that checks the `settings` value. We need to do the same for our sheet data section,
    as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的只是将这个日期设置逻辑放在一个检查`settings`值的`if`语句下面。我们需要对我们的表数据部分做同样的事情，如下所示：
- en: '[PRE44]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Since this logic was already under an `if` statement, we've just added another
    condition to the check. This should now give us functioning options.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个逻辑已经在`if`语句下面，我们只是向检查中添加了另一个条件。现在这应该会给我们提供功能选项。
- en: Finishing the menu
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成菜单
- en: 'The last thing we need to do in our main menu is add the submenus we''ve created
    to the main menu. At the end of `MainMenu.__init__()`, add the following lines:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主菜单中，我们需要做的最后一件事是将我们创建的子菜单添加到主菜单中。在`MainMenu.__init__()`的末尾，添加以下行：
- en: '[PRE45]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The submenus will be arranged from left to right in the order we add them. Typically
    the File menu is first and the Help menu is last, with the other menus arranged
    in between. We'll learn more about how to arrange menus with respect to platform
    in *Chapter 10*, *Maintaining Cross-Platform Compatibility*.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 子菜单将按照我们添加它们的顺序从左到右排列。通常，文件菜单是第一个，帮助菜单是最后一个，其他菜单在中间排列。我们将在第10章*维护跨平台兼容性*中了解更多关于如何根据平台排列菜单的信息。
- en: 'Run the application, and you should see a nice main menu like this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，你应该看到一个像这样的漂亮主菜单：
- en: '![The ABQ application sporting a fancy main menu](img/B17578_07_11.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![ABQ应用程序拥有一个花哨的主菜单](img/B17578_07_11.png)'
- en: 'Figure 7.11: The ABQ application sporting a fancy main menu'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11：ABQ应用程序拥有一个花哨的主菜单
- en: Give the settings a try by un-checking them and entering some records. They
    should disable the auto-fill functionality when disabled.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通过取消选中设置并输入一些记录来尝试设置。当禁用时，它们应该禁用自动填充功能。
- en: Persisting settings
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久化设置
- en: 'Our settings work, but there''s a major annoyance: they don''t persist between
    sessions. Shut down the application and start it up again, and you''ll see that
    the settings are back to their defaults. It''s not a major problem, but it''s
    a rough edge we shouldn''t leave for our users. Ideally, their personal settings
    should load up each time they launch the application.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设置是有效的，但有一个主要的不便：它们在会话之间不会持久化。关闭应用程序并重新启动，你会看到设置已经恢复到默认值。这不是一个主要问题，但这是我们不应该留给用户的一个粗糙边缘。理想情况下，他们的个人设置应该在每次启动应用程序时加载。
- en: 'Python gives us a variety of ways to persist data in files. We''ve already
    experienced CSV, which is designed for tabular data; there are other formats designed
    with different capabilities in mind. The following table shows just a few of the
    options for storing data available in the Python standard library:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了多种在文件中持久化数据的方法。我们已经体验了CSV，它是为表格数据设计的；还有其他格式，考虑到不同的能力而设计。以下表格显示了Python标准库中可用的存储数据选项的几个示例：
- en: '| Module | File type | Suitable for | Benefits | Drawbacks |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | 文件类型 | 适合 | 优点 | 缺点 |'
- en: '| `pickle` | Binary | Any Python object | Fast, easy, small files | Not safe,
    files not human-readable, whole file must be read |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `pickle` | 二进制 | 任何Python对象 | 快速、简单、文件小 | 不安全，文件不可读，必须读取整个文件 |'
- en: '| `configparser` | Text | Key -> value pairs | Human-readable files | Can''t
    handle sequences or complex objects, limited hierarchy |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `configparser` | 文本 | 键 -> 值对 | 可读性文件 | 无法处理序列或复杂对象，层次结构有限 |'
- en: '| `json` | Text | Simple values and sequences | Widely used, easy, human-readable
    | Can''t handle dates, complex objects without modification |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `json` | 文本 | 简单值和序列 | 广泛使用，简单，可读性高 | 无法处理日期，没有修改无法处理复杂对象 |'
- en: '| `xml` | Text | Any kind of Python object | Powerful, flexible, human-readable
    files | Not safe, complex to use, verbose syntax |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `xml` | 文本 | 任何Python对象 | 强大、灵活、可读性高 | 不安全，使用复杂，语法冗长 |'
- en: '| `sqlite` | Binary | Relational data | Fast, powerful, can represent complex
    relationships | Requires SQL knowledge, objects must be translated to tables |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `sqlite` | 二进制 | 关系数据 | 快速、强大，可以表示复杂关系 | 需要SQL知识，对象必须转换为表 |'
- en: 'Table 7.3:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.3：
- en: 'If this weren''t enough, there are even more options available in the third-party
    libraries. Almost any of them would be suitable for storing a couple of Boolean
    values, so how do we choose? Let''s consider the options:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不够，第三方库中还有更多选项可用。几乎任何一种都适合存储几个布尔值，那么我们如何选择？让我们考虑一下选项：
- en: '`SQL` and `XML` are powerful, but far too complex for our simple needs here.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQL`和`XML`功能强大，但对我们这里的简单需求来说过于复杂。'
- en: We'd like to stick to a text format in case we need to debug a corrupt settings
    file, so `pickle` is out.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们需要调试损坏的设置文件，我们希望坚持使用文本格式，因此`pickle`不可用。
- en: '`configparser` would work for now, but its inability to handle lists, tuples,
    and dictionaries may be limiting in the future.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configparser` 目前可以工作，但它无法处理列表、元组和字典，这可能在将来会成为一个限制。'
- en: That leaves `json`, which is a good option. While it can't handle every kind
    of Python object, it can handle strings, numbers, and Boolean values, as well
    as lists and dictionaries. It can even be extended to handle other kinds of data.
    It should cover our current configuration needs just fine, and most likely our
    future needs as well.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了`json`，这是一个不错的选择。虽然它无法处理每种Python对象，但它可以处理字符串、数字和布尔值，以及列表和字典。它甚至可以扩展以处理其他类型的数据。它应该能够很好地满足我们当前的配置需求，以及我们未来的需求。
- en: What does it mean when we say that a library is "not safe"? Some data formats
    are designed with powerful capabilities, such as extensibility, linking, or aliasing,
    which parser libraries must implement. Unfortunately, those capabilities can be
    exploited for malicious purposes. For example, the "billion laughs" XML vulnerability
    combines three XML capabilities to craft a file that, when parsed, expands to
    a massive size (usually causing the program or, in some cases, the operating system,
    to crash).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说一个库“不安全”时，这意味着什么？一些数据格式被设计成具有强大的功能，如可扩展性、链接或别名，这些功能解析库必须实现。不幸的是，这些功能可能会被用于恶意目的。例如，“十亿笑声”XML漏洞结合了三个XML功能来创建一个文件，当解析时，会膨胀到巨大的大小（通常会导致程序或在某些情况下操作系统崩溃）。
- en: Building a model for settings persistence
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建设置持久化的模型
- en: 'As with any kind of data persistence, we need to start by implementing a model.
    As with our `CSVModel` class, the settings model needs to save and load the data,
    as well as authoritatively defining the layout of the settings data. Since we''re
    using `json`, we need to import it. Add this to the top of `models.py`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何类型的数据持久化一样，我们需要首先实现一个模型。就像我们的`CSVModel`类一样，设置模型需要保存和加载数据，以及权威地定义设置数据的布局。由于我们使用`json`，我们需要导入它。将以下内容添加到`models.py`的顶部：
- en: '[PRE46]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, down at the end of `models.py`, let''s start a new `SettingsModel` class
    as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`models.py`的末尾，让我们开始创建一个新的`SettingsModel`类，如下所示：
- en: '[PRE47]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As we did with the `CSVModel`, we've begun our class with a class variable that
    defines the `fields` included in the settings file. Currently, it only contains
    our two Boolean values. Each field in the dictionary defines a data type and default
    value for the field. Note that we're using strings here rather than Python `type`
    objects; doing this will allow us to persist both the type and the value to a
    text file.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对`CSVModel`所做的那样，我们在类中定义了一个类变量来指定设置文件中包含的`fields`。目前，它只包含我们两个布尔值。字典中的每个字段定义了字段的类型和默认值。请注意，我们在这里使用字符串而不是Python
    `type`对象；这样做将允许我们将类型和值持久化到文本文件中。
- en: 'Next, let''s create the initializer method, as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建初始化器方法，如下所示：
- en: '[PRE48]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The initializer will determine the file path to which our settings will be saved;
    for now, we've hard-coded the name `abq_settings.json` and stored it in the user's
    home directory. `Path.home()` is a class method of the `Path` class that provides
    us with a `Path` object pointed to the user's home directory. In this way, each
    user on the system can have their own settings file.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器将确定我们的设置将被保存到的文件路径；目前，我们已将名称`abq_settings.json`硬编码并存储在用户的家目录中。`Path.home()`是`Path`类的一个类方法，它为我们提供了一个指向用户家目录的`Path`对象。这样，系统上的每个用户都可以有自己的设置文件。
- en: 'As soon as the model is created, we''ll want to load the user''s saved options
    from disk, so let''s add a call to an instance method we''ll call `load()`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模型创建完成，我们希望从磁盘加载用户的保存选项，因此让我们添加一个调用我们称之为`load()`的实例方法：
- en: '[PRE49]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now we need to implement the `load()` method. A simplistic implementation may
    look like this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要实现`load()`方法。一个简单的实现可能如下所示：
- en: '[PRE50]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This simply opens the file stored in our `self.filepath` location and overwrites
    the `fields` variable with whatever contents are extracted by `json.load()`. This
    is the gist of what we need to do, but there are two problems with this approach:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是简单地打开存储在`self.filepath`位置的文件，并用`json.load()`提取的内容覆盖`fields`变量。这是我们需要做的核心，但这种方法有两个问题：
- en: What happens if the file doesn't exist? (For example, if the user has never
    run the program before.)
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件不存在会发生什么？（例如，如果用户之前从未运行过程序。）
- en: What happens if the JSON data in the model doesn't match with the keys expected
    by our application? (For example, if it was tampered with, or created by an older
    version of the application.)
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模型中的JSON数据与我们的应用程序期望的键不匹配会发生什么？（例如，如果它被篡改，或者由应用程序的旧版本创建。）
- en: 'Let''s create a more robust callback that addresses these issues, as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个更健壮的回调来处理这些问题，如下所示：
- en: '[PRE51]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this version, we address the first issue by checking to see if the file exists.
    If the file doesn't exist, the method simply returns and does nothing. It's perfectly
    reasonable for the file not to exist, especially if the user has never run the
    program or edited any of the settings. In this case, the method would leave `self.fields`
    alone and the user would end up with the defaults.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我们通过检查文件是否存在来解决第一个问题。如果文件不存在，该方法将简单地返回并什么都不做。文件不存在是完全合理的，特别是如果用户从未运行过程序或编辑过任何设置。在这种情况下，该方法将保持`self.fields`不变，用户最终将使用默认值。
- en: To address the second problem, we've pulled the JSON data into a local variable
    called `raw_values`; then, we update `fields` by retrieving from `raw_values`
    only those keys that are defined by our class. If the JSON data lacks a particular
    key, we skip it, leaving `fields` with its default value.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决第二个问题，我们将JSON数据拉入一个名为`raw_values`的局部变量中；然后，我们通过从`raw_values`中检索由我们的类定义的键来更新`fields`。如果JSON数据缺少特定的键，我们将跳过它，使`fields`保持其默认值。
- en: 'In addition to loading settings, our model will of course need to save its
    data. Let''s write a `save()` method to write our values to the file:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 除了加载设置外，我们的模型当然还需要保存其数据。让我们编写一个`save()`方法来将我们的值写入文件：
- en: '[PRE52]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `json.dump()` function is the inverse of `json.load()`: it takes a Python
    object and a file handle, converts the object to a JSON string, and writes it
    to the file. Saving our settings data is as simple as converting the `fields`
    dictionary to a JSON string and writing it to the specified text file.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`json.dump()`函数是`json.load()`的逆操作：它接受一个Python对象和一个文件句柄，将对象转换为JSON字符串，并将其写入文件。将我们的设置数据保存下来就像将`fields`字典转换为JSON字符串并写入指定的文本文件一样简单。'
- en: The final method our model needs is a way for external code to set values; we
    could just allow external code to manipulate the `fields` dictionary directly,
    but in the interest of protecting our data integrity, we'll do it through a method
    call.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模型需要的最后一个方法是外部代码设置值的方式；我们本可以直接允许外部代码直接操作`fields`字典，但为了保护我们的数据完整性，我们将通过方法调用来实现。
- en: Keeping with Tkinter convention, we'll call this method `set()`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 按照Tkinter约定，我们将此方法命名为`set()`。
- en: 'A basic implementation of the `set()` method is as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`set()`方法的基本实现如下：'
- en: '[PRE53]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This simple method just takes `key` and `value` arguments and writes them to
    the `fields` dictionary. This opens up some potential problems, though:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的方法只接受`key`和`value`参数，并将它们写入`fields`字典。尽管如此，这也会带来一些潜在的问题：
- en: What if the value provided isn't valid for the data type?
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提供的值对于数据类型无效怎么办？
- en: What if the key isn't in our `fields` dictionary? Should we allow outside code
    to just add new keys?
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果键不在我们的`fields`字典中怎么办？我们应该允许外部代码直接添加新键吗？
- en: These situations could create problems in the application that would be hard
    to debug, so our `set()` method should safeguard against these scenarios.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这些情况可能会在应用程序中造成难以调试的问题，因此我们的`set()`方法应该防范这些场景。
- en: 'Let''s create a more robust version, as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个更健壮的版本，如下所示：
- en: '[PRE54]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this version, we check if the given `key` argument exists in `fields`, and
    if the `type` of the data matches the type defined for that field. To match the
    `value` variable's object type to the `field` dictionary's `type` strings, we
    have extracted the variable's data type as a string using `type(value).__name__`.
    This returns a string like `bool` for Boolean variables, or `str` for strings.
    With these checks protecting our value assignment, an attempt to write an unknown
    key or incorrect variable type will fail.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我们检查给定的`key`参数是否存在于`fields`中，以及数据的`type`是否与该字段定义的类型匹配。为了将`value`变量的对象类型与`field`字典的`type`字符串相匹配，我们使用`type(value).__name__`提取了变量的数据类型作为字符串。这返回一个如`bool`的字符串，对于布尔变量，或者`str`对于字符串。有了这些检查来保护我们的值赋值，尝试写入未知键或错误的变量类型将失败。
- en: However, we don't let it fail silently; if there is bad data, we immediately
    raise a `ValueError` exception. Why raise an exception? If the test fails, it
    can only mean a bug in the calling code. With an exception, we'll know immediately
    if the calling code is sending bad requests to our model. Without it, requests
    would fail silently, leaving a hard-to-find bug.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会让它默默失败；如果有不良数据，我们将立即引发一个`ValueError`异常。为什么要引发异常？如果测试失败，这只意味着调用代码中存在错误。通过异常，我们将立即知道调用代码是否向我们的模型发送了不良请求。如果没有它，请求将默默失败，留下一个难以发现的错误。
- en: Using the settings model in our application
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用设置模型
- en: Our application needs to load in the settings when it starts, then save them
    automatically whenever they are changed. Currently, the application's `settings`
    dictionary is created manually, but our model, as the authority on the settings
    data structure, should really be telling it what kind of variables to create.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序在启动时需要加载设置，然后在它们更改时自动保存。目前，应用程序的 `settings` 字典是手动创建的，但作为设置数据结构的权威，我们的模型应该真正地告诉它要创建什么类型的变量。
- en: 'Back in the `Application.__init__()` method, locate the line that creates our
    `settings` dictionary, and replace it with the following code:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `Application.__init__()` 方法中，找到创建我们的 `settings` 字典的行，并将其替换为以下代码：
- en: '[PRE55]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: First, we've created a `SettingsModel` instance, storing it as an instance variable.
    Then, we're running an instance method called `_load_settings()`. This method
    will be responsible for querying the `settings_model` to create the `Application.settings`
    dictionary.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个 `SettingsModel` 实例，将其存储为实例变量。然后，我们运行一个名为 `_load_settings()` 的实例方法。这个方法将负责查询
    `settings_model` 以创建 `Application.settings` 字典。
- en: 'At the end of the class definition, let''s create the `_load_settings()` method:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义的末尾，让我们创建 `_load_settings()` 方法：
- en: '[PRE56]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Our model stores the type and value for each variable, but our application needs
    Tkinter control variables. We need to translate the model's representation of
    the data into a structure that `Application` can use. So the first thing this
    function does is create a `vartypes` dictionary to translate our `type` strings
    to control variable types.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式存储了每个变量的类型和值，但我们的应用程序需要 Tkinter 控制变量。我们需要将模型的数据表示转换为 `Application` 可以使用的结构。因此，这个函数首先创建一个
    `vartypes` 字典，将我们的 `type` 字符串转换为控制变量类型。
- en: Although we currently only have Boolean variables in our settings, we're going
    to anticipate more settings in the future and create a function capable of handling
    strings, floats, and integers as well.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们目前在我们的设置中只有布尔变量，但我们预计未来会有更多的设置，并创建一个能够处理字符串、浮点数和整数的函数。
- en: After defining the `vartypes` dictionary and creating an empty dictionary for
    `settings`, we just need to iterate through `self.settings_model.fields`, creating
    a matching control variable for each field. Note that `vartypes.get(data['type'],
    tk.StringVar)` ensures that, if we get a variable type not listed in `vartypes`,
    we'll just create a `StringVar` for it.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了 `vartypes` 字典并为 `settings` 创建了一个空字典之后，我们只需要迭代 `self.settings_model.fields`，为每个字段创建一个匹配的控制变量。请注意，`vartypes.get(data['type'],
    tk.StringVar)` 确保如果我们得到一个不在 `vartypes` 中列出的变量类型，我们只需为它创建一个 `StringVar`。
- en: 'The main reason for using Tkinter variables here is so that we can trace any
    changes the user makes to the values via the UI and respond immediately. Specifically,
    we want to save our settings whenever the user makes a change. To implement this,
    add the last two lines to the method:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用 Tkinter 变量的主要原因是为了能够通过 UI 追踪用户对值的任何更改，并立即做出响应。具体来说，我们希望在用户进行更改时保存我们的设置。为了实现这一点，将最后两行添加到方法中：
- en: '[PRE57]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This adds a trace that calls `_save_settings` whenever a settings variable is
    changed. Of course, this means we need to write a method called `Application._save_settings()`,
    which will save the settings to disk.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这添加了一个跟踪，每当设置变量更改时都会调用 `_save_settings`。当然，这意味着我们需要编写一个名为 `Application._save_settings()`
    的方法，该方法将设置保存到磁盘。
- en: 'Add this code to the end of `Application`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加到 `Application` 的末尾：
- en: '[PRE58]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `save_settings()` method just needs to get the data back from `Application.settings`
    to the model and then save it. It's as simple as iterating through `self.settings`
    and calling our model's `set()` method to pull in the values one at a time. Once
    we've updated the values, we call the model's `save()` method.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`save_settings()` 方法只需要从 `Application.settings` 获取数据到模型，然后保存。这就像迭代 `self.settings`
    并调用我们的模型的 `set()` 方法逐个拉入值一样简单。一旦我们更新了值，我们就调用模型的 `save()` 方法。'
- en: This completes our settings persistence; you should be able to run the program
    and observe that the settings are saved, even when you close and re-open the application.
    You'll also find a file in your home directory called `abq_settings.json` (this
    isn't the ideal place to keep a settings file, but we'll address that in *Chapter
    10*, *Maintaining Cross-Platform Compatibility*).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的设置持久化；你应该能够运行程序并观察到设置被保存，即使你在关闭和重新打开应用程序后也是如此。你还会在你的主目录中找到一个名为 `abq_settings.json`
    的文件（这不是保存设置文件的理想位置，但我们在第 10 章 *维护跨平台兼容性* 中将解决这个问题）。
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, our simple form has taken a big step forward toward being a
    full-blown application. We've implemented a main menu, option settings that are
    persisted between executions, and an About dialog. We've added the ability to
    select a file where records are saved, and improved the visibility of form errors
    with an error dialog. Along the way, you learned about Tkinter menus, file dialogs,
    message boxes, and custom dialogs, as well as the various options for persisting
    data in the standard library.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的简单表单已经迈出了很大一步，向成为一个完整的应用程序迈进。我们实现了主菜单、在执行之间保持的选项设置，以及一个关于对话框。我们增加了选择记录保存文件的能力，并通过错误对话框改善了表单错误的可见性。在这个过程中，你学习了
    Tkinter 菜单、文件对话框、消息框和自定义对话框，以及标准库中持久化数据的各种选项。
- en: In the next chapter, we're going to be asked to make the program read data as
    well as write it. We'll learn about Ttk's `Treeview` and `Notebook` widgets, and
    how to make our `CSVModel` and `DataRecordForm` classes capable of reading and
    updating existing data.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将被要求使程序既能读取数据也能写入数据。我们将学习关于 Ttk 的 `Treeview` 和 `Notebook` 小部件，以及如何使我们的
    `CSVModel` 和 `DataRecordForm` 类能够读取和更新现有数据。
