- en: Advanced RESTful API Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级RESTful API模式
- en: Every software designer agrees that design patterns, and solving familiar yet
    recurring design problems by implementing design patterns, are inevitable in the
    modern software design-and-development life cycle. In general, there are various
    API design patterns, and in our earlier chapter, we covered a few fundamental
    RESTful API patterns. We'll delve into few advanced API design patterns in this
    chapter, as those patterns are necessary for real-time RESTful services and what
    the software industry needed at this moment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个软件设计师都认同，在现代软件设计和开发的生命周期中，设计模式和通过实现设计模式来解决熟悉且反复出现的设计问题是不可避免的。一般来说，存在各种API设计模式，在我们前面的章节中，我们介绍了几种基本的RESTful
    API模式。在本章中，我们将深入探讨一些高级API设计模式，因为这些模式对于实时RESTful服务和当前软件行业的需求是必要的。
- en: 'This chapter is part two of API design patterns; the intention is to cover
    a number of advanced design patterns, such as versioning, and backend for frontend.
    Once readers have gone through this chapter, they should know how to implement
    the following patterns:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是API设计模式的第二部分；目的是介绍多个高级设计模式，例如版本控制和后端前端。一旦读者阅读了本章，他们应该知道如何实现以下模式：
- en: Versioning
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制
- en: Authorization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权
- en: Uniform contract
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一契约
- en: Entity endpoint
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体端点
- en: Endpoint redirection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端点重定向
- en: Idempotent
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幂等性
- en: Bulk operations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量操作
- en: Circuit breaker
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器
- en: API facade
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API外观
- en: Backend for frontend
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端前端
- en: Please don't forget to go through the Investor Service code examples and learn
    the advance pattern implementations as well.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要忘记查看投资者服务代码示例，并学习高级模式实现。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As this chapter deals with advanced patterns, we expect that readers have knowledge
    of a few basic software design patterns and practices, Java's programming ability,Spring
    framework, and RESTful services.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章涉及高级模式，我们期望读者具备一些基本软件设计模式和惯例的知识，Java编程能力，Spring框架和RESTful服务。
- en: To run this chapter's sample code, please refer to [Chapter 3,](bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml)
    *Essential RESTful API Patterns, *for the additional technical requirement and
    information on how to run the sample codes provided here.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章的示例代码，请参阅[第3章](bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml)，《必要的RESTful
    API模式》，以获取额外的技术要求和有关如何运行此处提供的示例代码的信息。
- en: RESTful API advanced patterns
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful API高级模式
- en: We covered few critical RESTful patterns in the earlier chapter; now it's time
    to get into more advanced patterns and get our hands dirty to provide our customers
    and app developers with the best-possible RESTful services implementation. Let's
    start learning how to implement versioning for our services.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了一些关键的RESTful模式；现在是时候深入研究更高级的模式，并动手为我们客户提供尽可能好的RESTful服务实现。让我们开始学习如何为我们服务实现版本控制。
- en: Versioning
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制
- en: Many books and articles recommend avoiding versioning APIs if possible. However,
    it's not practical to believe that we'll develop one API that caters to almost
    every requirement within the first release and never changes, so we avoid versioning
    altogether. A few others recommend providing different URIs for different (major)
    version changes. Ideally, we'd manage APIs just like website URLs (most of the
    time the URL address never changes, regardless of any changes/implementations).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 许多书籍和文章建议如果可能的话避免对API进行版本控制。然而，相信我们会在第一次发布时开发出一个几乎满足所有需求的API，并且永远不会改变是不切实际的，所以我们完全避免版本控制。还有一些人建议为不同的（主要）版本变化提供不同的URI。理想情况下，我们会像管理网站URL一样管理API（大多数情况下，URL地址不会改变，无论有任何变化/实现）。
- en: 'The general rules of thumb we''d like to follow when versioning APIs are as
    follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在版本控制API时希望遵循的一般规则如下：
- en: Upgrade the API to a new major version when the new implementation breaks the
    existing customer implementations
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当新的实现破坏现有的客户实现时，将API升级到新的主要版本。
- en: Upgrade the API to a new minor version of the API when the new implementation
    provides enhancements and bug fixes; however, ensure that the implementation takes
    care of backward-compatibility and has no impact on the existing customer implementations
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当新的实现提供了增强功能和错误修复时，将API升级到API的新次要版本；然而，确保实现考虑了向后兼容性，并且不会影响现有的客户实现。
- en: Let's consider that we need to manage the versions in our API; there are four
    different ways that we can implement the versioning, and we will see each type
    in the following sections.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下，我们需要在我们的API中管理版本；我们有四种不同的方式可以实现版本控制，我们将在以下各节中看到每种类型。
- en: Versioning through the URI path
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过URI路径进行版本控制
- en: The major and minor version changes can be a part of the URI, for example, to
    represent `v1` or `v2` of the API the URI can be `http://localhost:9090/v1/investors` or `http://localhost:9090/v2/investors`,
    respectively.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 主版本和次版本变更可以是URI的一部分，例如，为了表示API的`v1`或`v2`版本，URI可以是`http://localhost:9090/v1/investors`或`http://localhost:9090/v2/investors`。
- en: 'The code implementation of the URI path versioning within our investor service
    examples is shown in the following code snippet:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们投资者服务示例中URI路径版本控制的代码实现如下所示：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of this code is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出如下：
- en: '![](img/ef8d6d77-07f1-4b04-89b8-4338b44fed22.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef8d6d77-07f1-4b04-89b8-4338b44fed22.png)'
- en: The preceding screenshot shows the Postman execution of the URI path-versioning
    example.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Postman执行的URI路径版本控制示例。
- en: URI path changes according to the version violates the RESTful principles of
    URI and its resource representation (two different URIs represent the same resources—the
    only difference is `v1`, `v2`, and so on, in our example). However, URI path versioning
    is a popular way of managing API versions due to its simple implementation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据版本更改URI路径违反了RESTful原则的URI及其资源表示（两个不同的URI表示相同的资源——唯一的区别是我们例子中的`v1`、`v2`等）。然而，由于实现简单，URI路径版本控制是管理API版本的一种流行方式。
- en: Versioning through query parameters
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过查询参数进行版本控制
- en: 'The other simple method for implementing the version reference is to make it
    part of the request parameters, as we see in the following examples—`http://localhost:9090/investors?version=1`,` http://localhost:9090/investors?version=2.1.0`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 实现版本引用的另一种简单方法是将它作为请求参数的一部分，如下面的示例所示——`http://localhost:9090/investors?version=1`、`http://localhost:9090/investors?version=2.1.0`：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of this is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如下是输出结果：
- en: '![](img/58f88ef3-5e1c-4134-80b5-ae18620aeab4.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58f88ef3-5e1c-4134-80b5-ae18620aeab4.png)'
- en: The preceding screenshot shows the implementation of versioning through parameters
    within our sample.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在样本中通过参数进行版本控制的实现。
- en: Versioning through custom headers
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过自定义头部进行版本控制
- en: 'Define a new header that contains the version number in the request as part
    of request header itself. A custom header allows the client to maintain the same
    URIs, regardless of any version upgrades. This implementation is the kind of content-negotiation
    that we saw in [Chapter 2](edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml), *Design
    Strategy, Guidelines, and Best Practices* and we''ll see it in the next section
    as well. The following code snippet will help us understand the version implementation
    through a custom header named `x-resource-version`. Please note that the custom
    header name can be any name; in our example, we name it `x-resource-version`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个新的头部，该头部包含请求中的版本号，作为请求头部的一部分。自定义头部允许客户端在版本升级的情况下保持相同的URI。这种实现方式是我们之前在[第2章](edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml)中看到的，*设计策略、指南和最佳实践*，我们将在下一节中再次看到。以下代码片段将帮助我们通过名为`x-resource-version`的自定义头部理解版本实现。请注意，自定义头部的名称可以是任何名称；在我们的例子中，我们将其命名为`x-resource-version`：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/739fc842-0022-4445-b372-e02e5bf7d622.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/739fc842-0022-4445-b372-e02e5bf7d622.png)'
- en: The preceding screenshot is an example of versioning through the `x-resource-version` custom
    header and executing the same code example with postman.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是使用`x-resource-version`自定义头部进行版本控制并使用Postman执行相同代码示例的示例。
- en: Versioning through content-negotiation
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过内容协商进行版本控制
- en: 'Providing the version information through the Accept (request) header along
    with the content-type (media) in response is the preferred way as this helps to
    version APIs without any impact on the URI. As we''ve already learned about content-negotiation,
    in [Chapter 2](edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml), *Design Strategy,
    Guidelines, and Best Practices*, let''s jump to a code implementation of versioning
    through Accept and Content-Type:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过响应中的`Accept`（请求）头部以及内容类型（媒体）提供版本信息是首选方式，因为这有助于在不影响URI的情况下对API进行版本控制。正如我们在[第2章](edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml)中已经学到的，*设计策略、指南和最佳实践*，让我们跳转到通过Accept和Content-Type进行版本控制的代码实现：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshot is the output of the preceding code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图是前面代码的输出：
- en: '![](img/a61c3d39-725e-4418-a1bc-64ee56ea21ef.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a61c3d39-725e-4418-a1bc-64ee56ea21ef.png)'
- en: The preceding screenshot of the postman tool depicts the execution of our investor
    service app versioning through the Accept header. Please observe the response
    header content-type as well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图展示了通过Accept头执行我们的投资者服务应用版本控制的过程。请同时注意响应头中的内容类型。
- en: As we have seen, each type of versioning methodology has advantages and disadvantages,
    so we need to determine the right approach on a case-by-case basis. However, the
    content-negotiation and custom headers are a proponent of RESTful-compliant services.
    We will move on to one of the essential pattern authentication and authorization.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，每种版本控制方法都有其优缺点，因此我们需要根据具体情况确定正确的方法。然而，内容协商和自定义头是RESTful服务的支持者。我们将继续讨论一个重要的模式：认证和授权。
- en: Authorization
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: So far, we've built a sample application investor service with various incorporated
    patterns. Now, how do we ensure our REST API implementation is accessible only
    to genuine users and not to everyone? In our example, the investor's list should
    not be visible to all users, and the stocks URI should not be exposed to anyone
    other than the legitimate investor. Here comes the Authorization header to help
    us out. We'll use a scheme called **basic authentication** as it solves our current
    requirement. Please note that there are different schemes, such as basic authentication,
    **hash-based message authentication** (**HMAC**), **JSON Web Token** (**JWT**),
    and OAuth 2.0 bearer authentication token scheme, that are available to secure
    the REST APIs. However, for this section, we are implementing simple basic authentication
    through the authorization header, and we'll cover OAuth 2.0 in detail in [Chapter
    6](adb6e30f-4e7f-49d7-bf62-7dddebd4afc5.xhtml), *RESTful Services API Testing
    and Security*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了一个包含各种集成模式的示例应用投资者服务。现在，我们如何确保我们的REST API实现仅对真实用户开放，而不是对所有用户开放？在我们的例子中，投资者列表不应对所有用户可见，而股票URI不应向除合法投资者以外的任何人公开。这时，授权头就派上用场了。我们将使用一种称为**基本认证**的方案，因为它解决了我们当前的需求。请注意，有不同方案可供选择，例如基本认证、基于哈希的消息认证（**HMAC**）、**JSON
    Web Token**（**JWT**）和OAuth 2.0携带者认证令牌方案，这些方案都可以用于保护REST API。然而，在本节中，我们将通过授权头实现简单的基本认证，并在[第6章](adb6e30f-4e7f-49d7-bf62-7dddebd4afc5.xhtml)中详细讨论OAuth
    2.0，*RESTful服务API测试和安全*。
- en: Let's start with a simple overview of basic authentication. It's a standard
    HTTP header (RESTful API constraint compliant) with the user's credentials encoded
    in Base64\. The credentials (username and password) are encoded in the format
    of username—password. Please note that the credentials are encoded not encrypted,
    and it's vulnerable to specific security attacks, so it's inevitable that the
    rest API implementing basic authentication will communicate over SSL (https).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本认证的简单概述开始。它是一个标准的HTTP头（符合RESTful API约束），用户的凭据以Base64编码。凭据（用户名和密码）以用户名—密码的格式编码。请注意，凭据是编码而不是加密的，因此它容易受到特定的安全攻击，因此实施基本认证的REST
    API不可避免地需要通过SSL（https）进行通信。
- en: We will also need to understand authentication versus authorization. The authentication
    verifies who (user) is accessing the APIs, and authorization is whether the accessing
    user has privileges or is authorized to access the API resources. Admin users
    of our investor service example are authorized to see all the investors, and individual
    users aren't authorized to see other investors' information.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要了解认证与授权的区别。认证验证谁（用户）正在访问API，而授权则是访问API的用户是否有权限或被授权访问API资源。在我们投资者服务示例中，管理员用户被授权查看所有投资者，而个人用户没有被授权查看其他投资者的信息。
- en: The Spring security framework provides an out-of-the-box security implementation,
    and we'll use Spring-provided functionalities to secure our API. As we are going
    to discuss more security implementations in [Chapter 9](5f63aa25-ec1b-41a2-afef-4c4ab7ab1cfd.xhtml),
    *A More In-depth View of the RESTful Services Paradigm*, we'll stick to a basic
    authentication implementation in this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Spring安全框架提供了一个开箱即用的安全实现，我们将使用Spring提供的功能来保护我们的API。由于我们将在[第9章](5f63aa25-ec1b-41a2-afef-4c4ab7ab1cfd.xhtml)中讨论更多的安全实现，*深入探讨RESTful服务范式*，因此在本章中我们将坚持使用基本认证实现。
- en: Authorization with the default key
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用默认密钥的授权
- en: 'Securing the REST API with basic authentication is exceptionally simplified
    by the Spring security framework. Merely adding the following entries in `pom.xml` provides
    basic authentication to our investor service app:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Spring安全框架，使用基本认证来保护REST API变得异常简单。只需在`pom.xml`中添加以下条目，就可以为我们的投资者服务应用提供基本认证：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now rebuild (`mvn clean package`) the application and restart it. It''s time
    to test our APIs with the postman tool. When we hit the URL, unlike our earlier
    examples, we''ll see an error complaining `Full authorization required to access
    this resource`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新构建（`mvn clean package`）应用程序并重新启动。现在是时候使用Postman工具测试我们的API了。当我们点击URL时，与我们的早期示例不同，我们会看到一个错误，抱怨“访问此资源需要完整授权”：
- en: '![](img/ae6b7bf4-3260-405a-b013-faa999ef1472.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/ae6b7bf4-3260-405a-b013-faa999ef1472.png)'
- en: 'The preceding error is due to the addition of spring-security into our `pom.xml`
    file. How are we going to access our REST API now? Don''t worry, on the console
    where we started our app, we can observe a text using the default security password
    or search for it in our log file. That''s the key for anyone to access our API.
    The following screenshot shows this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的错误是由于将spring-security添加到我们的`pom.xml`文件中。我们现在如何访问我们的REST API呢？别担心，在我们启动应用的控制台中，我们可以观察到使用默认安全密码的文本，或者在日志文件中搜索它。这是任何人访问我们API的密钥。以下截图显示了这一点：
- en: '![](img/eddef983-d7e3-4657-9bf5-4f9ad082fff9.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/eddef983-d7e3-4657-9bf5-4f9ad082fff9.png)'
- en: 'As we see in the preceding screenshot, our console displays the password that
    we can use to access our API, and so let''s use it for the same URL that we have
    got error earlier:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的截图中所看到的，我们的控制台显示了我们可以用来访问我们API的密码，因此让我们使用它来访问我们之前遇到错误的相同URL：
- en: '![](img/24c652c5-e03d-4861-ba6d-33b5c3a2615b.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/24c652c5-e03d-4861-ba6d-33b5c3a2615b.png)'
- en: As we observe in the previous screenshot, we need to provide BasicAuth as the Authorization
    header for the API that we are accessing; we will see the results now without
    any authentication errors. Please note that the Authorization header that carries
    the `XYZKL...` token prefixed with `Basic`, as we use the HTTP Authentication
    header to enforce REST API authentication.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的截图中所观察到的，我们需要为我们要访问的API提供BasicAuth作为Authorization头；我们现在将看到没有认证错误的结果。请注意，携带`XYZKL...`令牌并以前缀`Basic`开头的Authorization头，因为我们使用HTTP认证头来强制REST
    API认证。
- en: Authorization with credentials
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用凭证进行授权
- en: In many real-time situations, we need to use specific credentials to access
    the API and not the default one; in such cases, we can enhance our investor service
    application and secure it with our custom credentials by using few additional
    out-of-the-box spring modules.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多实时场景中，我们需要使用特定的凭证来访问API，而不是默认的凭证；在这种情况下，我们可以通过使用一些额外的现成Spring模块来增强我们的投资者服务应用，并使用我们自定义的凭证来保护它。
- en: 'In our investor service, we will have a new class, called `PatronAuthConfig.java`,
    which helps the app to enforce the credentials to the URLs that we would like
    to secure:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的投资者服务中，我们将有一个新的类，称为`PatronAuthConfig.java`，它帮助应用强制对我们要保护的URL进行凭证验证：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we see in the preceding code block, with a few annotations, we can implement
    the security. The following code snippet shows an override method implementation
    as well as a few lines of code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码块中所看到的，通过几个注解，我们可以实现安全性。以下代码片段显示了覆盖方法实现以及一些代码行：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following code does the magic of forcing authorization headers to validate
    for credentials in each request:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码强制在每个请求中验证凭证的授权头：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Please note that our example uses the following username and password along
    with two roles. We''ve provided the sample execution script and postman scripts
    to execute various scenarios by just clicking the labels:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的示例使用了以下用户名和密码，以及两个角色。我们提供了示例执行脚本和Postman脚本，只需点击标签即可执行各种场景：
- en: '| **User Id** | **Password** | **Role** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **用户ID** | **密码** | **角色** |'
- en: '| `admin` | `admSecret` | `ADMIN` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `admin` | `admSecret` | `ADMIN` |'
- en: '| `user` | `usrSecret` | `USER` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `user` | `usrSecret` | `USER` |'
- en: 'Now, please observe the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请观察以下截图：
- en: '![](img/f28eb49c-7bac-49da-8ab8-4640c0e03b51.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/f28eb49c-7bac-49da-8ab8-4640c0e03b51.png)'
- en: The preceding screenshot depicts a sample run of one rest API call that needs
    admin credentials as the authentication header and shows result for valid credentials.
    On the left-hand side, we can see various test cases; each one has the necessary
    prerequisites. Now we need to run them one by one and observe the results of each
    case. Ensure to see the authentication headers as well for each execution.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图展示了一个REST API调用的示例运行，该调用需要管理员凭据作为认证头，并显示了有效凭据的结果。在左侧，我们可以看到各种测试用例；每个都有一个必要的先决条件。现在我们需要逐个运行它们并观察每个案例的结果。确保查看每个执行的认证头。
- en: The only difference between the investor services example in [Chapter 3](bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml),
    *Essential RESTful API Patterns,* and this authentication example is that we have
    added a new class, `PatronsAuthConfig.java`, that extends the configuration for
    authentication with the Authorization header implementation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章中投资者服务示例与这个认证示例的唯一区别在于我们添加了一个新的类，`PatronsAuthConfig.java`，它扩展了使用授权头实现的认证配置。
- en: Uniform contract
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一合同
- en: As we mentioned earlier in the *API versioning* section, services will always
    evolve with additional capabilities, enhancements, and defects fixes, however,
    now a service consumer can consume the latest version of our services without
    the need to keep changing their implementation or REST API endpoints. Also, the
    service consumer needs to be aware of the latest and evolving details of those
    service contracts.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前在*API版本控制*部分提到的，服务将始终随着额外的功能、增强和缺陷修复而演变，然而，现在服务消费者可以消费我们服务的最新版本，而无需更改他们的实现或REST
    API端点。此外，服务消费者需要了解这些服务合同的最新和演变细节。
- en: 'The uniform contract pattern comes to the rescue to overcome these problems.
    The pattern suggests the following measures:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 统一合同模式可以解决这些问题。该模式建议以下措施：
- en: Standardize the service contract and make it uniform across any service endpoints
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准化服务合同并使其在所有服务端点上一致
- en: Abstract the service endpoints from individual services capabilities
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将服务端点从单个服务功能中抽象出来
- en: Follow the REST principles where the endpoints use only HTTP verbs, and express
    the underlying resources executable actions only with HTTP verbs
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循REST原则，其中端点仅使用HTTP动词，并且仅使用HTTP动词表达底层资源的可执行操作
- en: Please refer to the API versioning examples in the *API versioning* section
    as the implementation is already available and it has the flavor (please refer
    our investor service examples with `GET`, `POST`, `DELETE`, and so on) of the
    uniform contract.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考*API版本控制*部分中的API版本控制示例，因为实现已经可用，并且具有统一合同的味道（请参考我们的投资者服务示例，包括`GET`、`POST`、`DELETE`等操作）。
- en: Entity endpoints
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体端点
- en: 'If service clients want to interact with entities, such as investors, and their
    stocks without needing them to manage a compound identifier for both investor
    and stock, we need a pattern called **entity endpoint**. Entity endpoints suggest
    exposing each entity as individual lightweight endpoints of the service they reside
    in, so the service consumers get the global addressability of service entities:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '如果服务客户端想要与实体（如投资者和他们的股票）交互，而不需要他们管理投资者和股票的复合标识符，我们需要一个名为**实体端点**的模式。实体端点建议将每个实体公开为它们所在服务的独立轻量级端点，以便服务消费者获得服务实体的全局可寻址性： '
- en: '![](img/e14e1db2-4090-4592-800a-7ee0dcef4368.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e14e1db2-4090-4592-800a-7ee0dcef4368.png)'
- en: The preceding screenshot illustrates how a service consumer can access individual
    entity endpoints instead of service endpoints. The entity endpoints expose reusable
    enterprise resources, so service consumers can reuse and share the entity resources.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图说明了服务消费者如何访问单个实体端点而不是服务端点。实体端点公开可重用的企业资源，因此服务消费者可以重用和共享实体资源。
- en: Our rest service, the investor service, exposes a couple of entity endpoints,
    such as `/investors/investorId`, and `investor/stockId` , and they are few examples
    of entity endpoints that our service consumer can reuse and standardize.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务，投资者服务，公开了一些实体端点，例如`/investors/investorId`和`investor/stockId`，它们是我们服务消费者可以重用和标准化的实体端点的几个示例。
- en: Endpoint redirection
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端点重定向
- en: 'Changing service endpoints isn''t always ideal, However, if it needs to, will
    the service client know about it and use the new endpoint? Yes, with standard
    HTTP return codes, `3xx`, and with the **Location** header, then by receiving
    `301 Moved permanently` or `307 Temporary Redirect`, the service client can act
    accordingly. The endpoint redirection pattern suggests returning standard HTTP
    headers and provides an automatic reference of stale endpoints to the current
    endpoints:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 改变服务端点并不总是理想的，然而，如果需要，服务客户端会知道并使用新的端点吗？是的，通过标准的HTTP返回代码，`3xx`，以及通过**位置**头，通过接收`301
    永久移动`或`307 临时重定向`，服务客户端可以相应地行动。端点重定向模式建议返回标准HTTP头，并为过时的端点提供对当前端点的自动引用：
- en: '![](img/f5eeeb69-01ff-4962-9994-e0ab4bd7f7b7.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f5eeeb69-01ff-4962-9994-e0ab4bd7f7b7.png)'
- en: As we can see, the service consumers may call the new endpoints that are found
    in the **Location** header.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，服务消费者可以调用在**位置**头中找到的新端点。
- en: Please refer to our investor service example for header implementations if you
    want to play around with 3xx codes and **Location** headers.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试3xx代码和**位置**头，请参考我们的投资者服务示例中的头实现。
- en: Please note that with the HATEOAS implementation at the services, the client
    could potentially avoid these endpoint redirections.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在服务中实现HATEOAS时，客户端可以避免这些端点重定向。
- en: Idempotent
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 幂等
- en: Imagine a bank's debit API failed immediately after deducting some amount from
    the client account. However, the client doesn't know about it (as it didn't get
    any response from the server) and reissues the call to debit! Alas, the client
    loses money. So how can a service implementation handle messages/data and produce
    the same results, even after multiple calls?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，银行的借记API在从客户账户扣除一定金额后立即失败。然而，客户端并不知道这一点（因为它没有从服务器收到任何响应）并重新发出借记调用！唉，客户端损失了钱。那么服务实现如何处理消息/数据并产生相同的结果，即使经过多次调用？
- en: The dictionary meaning of idempotent is *representing an element of a set that
    is untouched when it involves some operations or is otherwise operated on by itself.*
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 无效的字典意义是*表示一个集合的元素，当它涉及某些操作或被自身操作时不会被改变*。
- en: '**Idempotent** is one of the fundamental resilience and scalable patterns,
    as it decouples the service implementation nodes across distributed systems. Whether
    dealing with data or messages, the services should always have designed for sticking
    to Idempotent in nature.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**幂等**是基本弹性和可扩展模式之一，因为它将分布式系统中的服务实现节点解耦。无论处理数据还是消息，服务都应该始终设计为坚持幂等性。'
- en: 'There is a simple solution: use the idempotent capabilities of the HTTP web
    APIs, whereby services can provide a guarantee that any number of repeated calls
    due to intermittent failures of communication to the service is safe, and process
    those multiple calls from the server without any side effects.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个简单的解决方案：使用HTTP Web API的幂等能力，其中服务可以保证由于与服务通信中断而导致的任何重复调用都是安全的，并且服务器可以无副作用地处理这些多个调用。
- en: Please refer to [Chapter 3](bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml), *Essential
    RESTful API Patterns*, for examples of `DELETE`, `PUT`, and `PATCH`, as those
    are all typical implementation of idempotent services; that is, even after we
    call `DELETE` multiple times for the same stock, it's safe; and the same applies
    to  `PUT` as well.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考第3章，*基本RESTful API模式*，以了解`DELETE`、`PUT`和`PATCH`的示例，因为这些都是幂等服务典型实现的例子；也就是说，即使我们对同一股票多次调用`DELETE`也是安全的；同样也适用于`PUT`。
- en: When it comes to dealing with concurrency, the services can be enhanced with
    E-Tag and send back a `409` conflict response to inform the client that the resource called
    is in an inconsistent state.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到处理并发时，服务可以通过E-Tag增强，并发送回一个`409`冲突响应来通知客户端所调用的资源处于不一致的状态。
- en: Bulk operation
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批量操作
- en: We have seen many REST API patterns and their implementations. However, we have
    yet to discuss an essential pattern, called **bulk operations**, within the REST
    API. It's inevitable that our design should thrive, which will reduce performance
    bottlenecks, such as response time, and the number of round trips between the
    server and clients.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多REST API模式和它们的实现。然而，我们还没有讨论REST API中的一个基本模式，称为**批量操作**。我们的设计应该蓬勃发展，这将减少性能瓶颈，如响应时间，以及服务器和客户端之间的往返次数。
- en: Marking a list of emails as read in our email client could be an example of
    a bulk operation; the customer chooses more than one email to tag as `Read`, and
    one REST API call does the job instead of multiple calls to an underlying API.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的电子邮件客户端中将一封封电子邮件标记为已读可能是一个批量操作的例子；客户选择多封电子邮件标记为`已读`，然后通过一次REST API调用完成工作，而不是多次调用底层API。
- en: 'Let''s take our investor service API: if a client wants to create a set of
    stocks for their portfolio rather than one by one, the client needs to call our
    REST endpoint as many times as the number of stocks that they wanted to create.
    If they need to update 100 stocks, they need to call the endpoint 100 times, and
    indeed, it isn''t an elegant solution. The bulk operations pattern comes to the
    rescue in such scenarios, without compromising the REST principles. Let''s see
    how our investor services can be modified to provide bulk operations.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的投资者服务API：如果客户端想要为他们的投资组合创建一组股票而不是一个接一个地创建，客户端需要根据他们想要创建的股票数量多次调用我们的REST端点。如果他们需要更新100个股票，他们需要调用端点100次，这确实不是一个优雅的解决方案。在这种情况下，批量操作模式可以提供帮助，而不会违背REST原则。让我们看看我们的投资者服务如何修改以提供批量操作。
- en: 'The investor service accepts `PATCH` for a single element, and we need to think
    about enhancing the same resource to also accept multiple insertions, or we can
    have another separate URI to support a bulk operation. Having another URI for
    the same resource isn''t a clean approach as it may deviate from the RESTful principle,
    and so let''s move ahead with the same `PATCH` request to support the update of
    more than one stock through the request. The following two approaches are suggested
    for implementing bulk operations:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 投资者服务接受单个元素的`PATCH`操作，我们需要考虑增强相同的资源以接受多个插入，或者我们可以有另一个独立的URI来支持批量操作。为同一资源使用另一个URI不是一个干净的方法，因为它可能偏离了RESTful原则，因此让我们继续使用相同的`PATCH`请求来支持通过请求更新多个股票。以下两种方法被建议用于实现批量操作：
- en: Content-based bulk operation
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于内容的批量操作
- en: Custom-header action-identifier-based bulk operation
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于自定义头操作标识符的批量操作
- en: 'Our code example follows both approaches; please note that we don''t use any
    specifics of the framework-provided annotations for the bulk operation. However,
    we continue to use the custom header and the enhanced request body to support
    a list of stocks in the client request. The following screenshot depicts the difference
    in the requests for a non-bulk operation and bulk-operation patch request along
    with headers:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码示例遵循两种方法；请注意，我们不会使用框架提供的注解的任何特定细节来执行批量操作。然而，我们继续使用自定义头和增强的请求体来支持客户端请求中的股票列表。以下截图显示了非批量操作和批量操作补丁请求以及头部的差异：
- en: '![](img/4534b4fa-69fc-4f8b-b2be-7ffa7fc10b99.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4534b4fa-69fc-4f8b-b2be-7ffa7fc10b99.png)'
- en: 'The following code snippet from the `InvestorController` class enforces the
    custom header, and the list of the `Stock` object, unlike the `PUT` example in [Chapter
    3](bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml), *Essential RESTful API Patterns*, (accepts
    only one `Stock` object):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`InvestorController`类中的代码片段，它强制执行自定义头，与[第3章](bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml)中的`PUT`示例（仅接受一个`Stock`对象）不同，*Essential
    RESTful API Patterns*（接受一个`Stock`对象）：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By running our `PATCH` example, we can understand the bulk operations of the
    RESTful API by grouping multiple items in one request. Please note that the bulk
    operations may involve many other aspects, such as E-tag, asynchronous executions,
    or parallel-stream implementation to make it effective. However, we aren't covering
    these special topics here, and we encourage readers to refer to the *Sources,
    references, and further reading *section for resources.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行我们的`PATCH`示例，我们可以通过在一个请求中分组多个项目来理解RESTful API的批量操作。请注意，批量操作可能涉及许多其他方面，例如E-tag、异步执行或并行流实现以使其有效。然而，我们在这里不涉及这些特殊主题，并鼓励读者参考*资源、参考文献和进一步阅读*部分以获取资源。
- en: Bulk operations versus batch operations
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 批量操作与批量操作
- en: Bulk operations deal with a single target operation on a varied list of business
    objects within a single REQ, and batch operations (not covered in this chapter)
    deal with a heterogeneous and homogeneous list of business objects, but with multiple
    REQs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 批量操作处理单个请求中的单个目标操作，该操作涉及单个请求中的多个业务对象列表，而批量操作（本章未涉及）处理异构和同构的业务对象列表，但涉及多个请求。
- en: Circuit breaker
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电路断路器
- en: We regularly encounter circuit breakers; the circuit breaker is an automatic
    switch designed to protect entire electrical circuits from damage due to excess
    current load as a result of a short circuit or overload.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常遇到断路器；断路器是一种自动开关，旨在保护整个电路免受短路或过载引起的过电流负载损坏。
- en: 'The same concept applies when services interact with many other services. Failure
    due to any (network) issue can potentially create catastrophic effects across
    the application, and preventing cascading impacts is the sole aim of a circuit-breaker
    pattern. Hence, this pattern helps subsystems to fail gracefully and also prevents
    complete system failure as a result of a subsystem failures:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务与其他许多服务交互时，同样适用此概念。任何（网络）问题导致的故障都可能在整个应用程序中产生灾难性影响，防止级联影响是断路器模式的唯一目标。因此，此模式有助于子系统优雅地失败，并防止子系统故障导致整个系统完全失败：
- en: '![](img/b70fe87f-468c-4e3e-baa7-dc0909f91f82.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b70fe87f-468c-4e3e-baa7-dc0909f91f82.png)'
- en: The preceding screenshot illustrates the circuit-breaker concept in which one
    of the downstream services is non-communicable. However, the circuit breaker implementation
    handles it in such a way that the **API** continues to serve its multiple clients.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图说明了断路器概念，其中一个下游服务无法通信。然而，断路器实现以这种方式处理它，使得**API**继续为多个客户端提供服务。
- en: 'Before we delve into the implementation, let''s understand the three different
    states that constitute the circuit breaker:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入实施之前，让我们了解构成断路器的三个不同状态：
- en: '**Closed**: This is when all the service interconnections are intact (closed),
    and all the calls go through intended services. This state needs to keep track
    of failures to determine threshold limits. If the number of failures exceeds threshold
    limits, the services will move to the open state to avoid cascading impacts.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭**：这是指所有服务连接都完好无损（关闭），所有呼叫都通过预期服务进行。此状态需要跟踪故障以确定阈值限制。如果故障数量超过阈值限制，服务将移动到开启状态以避免级联影响。'
- en: '**Open**: The open state of the services is responsible for returning errors
    without really executing their intended functions.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开启**：服务的开启状态负责返回错误，而实际上并不执行其预期功能。'
- en: '**Half-open**: Once the services land in the open state, it should periodically
    (timeout) check for failures that made the services be in the open state. Moreover,
    if those failures are still occuring, it continues to keep the services in the
    open state until the next check. If the failures are no longer detected, the responsibility
    of this state is to trigger back to the closed state for the continuous function.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半开启**：一旦服务进入开启状态，它应该定期（超时）检查导致服务处于开启状态的故障。此外，如果这些故障仍然发生，它将继续保持服务处于开启状态，直到下一次检查。如果不再检测到故障，此状态的责任是触发回关闭状态以实现连续功能。'
- en: It's time to get our hands dirty with the circuit-breaker implementation. We'll
    use spring annotations, along with an incredibly dominant open source library
    called **hysterix**, and we can implement the entire concept with very little
    effort.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候动手实现断路器了。我们将使用Spring注解，以及一个名为**hysterix**的极其强大的开源库，我们可以用很少的努力实现整个概念。
- en: We need to have a minimum of two services to explain the circuit-breaker implementation,
    so we are creating circuit-breaker-service and circuit-breaker-consumer services,
    which will have the circuit-breaker pattern implemented. The following sections
    elucidate the investor services implementation of circuit-breaker.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要至少有两个服务来解释断路器实现，因此我们正在创建断路器服务和断路器消费者服务，这些服务将实现断路器模式。以下部分阐述断路器的投资者服务实现。
- en: Bring up any service that we've already developed, or, to simplify we have a
    lightweight service called **circuit-breaker-service**, and please note that this
    service doesn't have any specific implementation for circuit-breaker.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 启动我们已开发的任何服务，或者，为了简化，我们有一个名为**断路器服务**的轻量级服务，请注意，此服务没有针对断路器的特定实现。
- en: 'Now for the critical part of our implementation; that is, a new service called
    **circuit-breaker-service-consumer**, which will have all the necessary circuit-breaker
    implementations, along with a call to our first service (circuit-breaker-service).
    Let''s perform the following steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是实施关键部分的时候了；即，一个名为**断路器服务消费者**的新服务，它将包含所有必要的断路器实现，以及对我们第一个服务（断路器服务）的调用。让我们执行以下步骤：
- en: 'Add the hysterix dependency to our `pom.xml` (`circuit-breaker-service-consumer/pom.xml`):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将 hysterix 依赖项添加到我们的 `pom.xml` (`circuit-breaker-service-consumer/pom.xml`)：
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Annotate `InvestorController` to enable circuit-breaker and introduce a new
    method for us to test (`circuit-breaker-service-consumer/com/**/InvestorController.java`):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注释 `InvestorController` 以启用断路器并引入一个新的方法供我们测试 (`circuit-breaker-service-consumer/com/**/InvestorController.java`)：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use the *Hystrix* command and create a method for the circuit-breaker implementation
    as well as a fallback method, as can be seen in the following code block. We will
    have two methods: one for the actual call (`InvestorService.java/circuitBreakerImplWelcome`)
    and another for fallback (`InvestoreService.java/welcomeUrlFailureFallback`),
    so that in case there are failures with the actual call, the app will call the
    fallback method:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *Hystrix* 命令并为断路器实现创建一个方法以及一个回退方法，如下面的代码块所示。我们将有两个方法：一个用于实际调用 (`InvestorService.java/circuitBreakerImplWelcome`)，另一个用于回退
    (`InvestoreService.java/welcomeUrlFailureFallback`)，以便在实际调用出现故障时，应用程序将调用回退方法：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Cool, isn''t it! Implementing the circuit-breaker with *Hysterix* is that simple.
    Now, let''s build and run our services by following these steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 太酷了，不是吗！使用 *Hystrix* 实现断路器就这么简单。现在，让我们按照以下步骤构建和运行我们的服务：
- en: Open a terminal and build circuit-breaker-service (`mvn clean package` of circuit-breaker-service)
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端并构建 circuit-breaker-service (`mvn clean package` of circuit-breaker-service)
- en: Bring up circuit-breaker-service
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 circuit-breaker-service
- en: Open a new terminal and build circuit-breaker-service-consumer
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并构建 circuit-breaker-service-consumer
- en: Bring up circuit-breaker-service-consumer
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 circuit-breaker-service-consumer
- en: Open Postman and run `http://localhost:9090/welcome`
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Postman 并运行 `http://localhost:9090/welcome`
- en: Observe the Japanese welcome text
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察日语欢迎文本
- en: Now, execute the circuit-breaker experimentation
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，执行断路器实验
- en: Stop the circuit-breaker-service that we started in step 2
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止我们在步骤 2 中启动的 circuit-breaker-service
- en: Run step 5 again, and now observe the English message
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行步骤 5，现在观察英文消息
- en: Yes, the circuit-breaker fallback is activated, and so we see the English message,
    not the Japanese message, as the circuit-breaker-service is down. However, the
    `/welcome` URI didn't break.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，断路器回退已被激活，因此我们看到的是英文消息，而不是日语消息，因为 circuit-breaker-service 已经宕机。然而，`/welcome`
    URI 并未中断。
- en: 'The following screenshot captured various phases for verifying the circuit-breaker
    implementation:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图捕捉了验证断路器实现的各个阶段：
- en: '![](img/a6f18627-1693-4a6f-bfe1-e791d4a460b4.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a6f18627-1693-4a6f-bfe1-e791d4a460b4.png)'
- en: 'The following screenshot is another phase of this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是这一过程的另一个阶段：
- en: '![](img/2cd57a68-7473-4762-8fc1-2b273d4f9671.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2cd57a68-7473-4762-8fc1-2b273d4f9671.png)'
- en: As we can observe in the preceding screenshots, in the pre-implementation of
    circuit-breaker, the `/welcome` call is failing and shows console message connection
    errors as well. However, after we implement circuit-breaker, the same call shows
    the content from the fallback method, even though the connections with the circuit-breaker-service
    are still failing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述截图所示，在断路器实现之前，`/welcome` 调用失败并显示控制台连接错误消息。然而，在实现断路器之后，相同的调用显示了回退方法的内容，尽管与
    circuit-breaker-service 的连接仍然失败。
- en: Readers and designers are encouraged to test and enhance circuit-breaker-consumer
    with more fallback methods for other method calls as well.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励读者和设计师测试并增强 circuit-breaker-consumer，为其他方法调用添加更多的回退方法。
- en: The downside of the circuit-breaker pattern is that the applications/services
    involved may experience slight performance hits. However, it's a good trade-off
    for many real-world applications.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器模式的缺点是，涉及的应用程序/服务可能会经历轻微的性能下降。然而，这对于许多实际应用来说是一个很好的权衡。
- en: Combining the circuit pattern and the retry pattern
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合断路器模式和重试模式
- en: As software designers, we understand the importance of gracefully handling application
    failures and failure operations. We may achieve better results by combining the
    retry pattern and the circuit breaker pattern as it provides the application with
    greater flexibility in handling failures.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件设计师，我们理解优雅地处理应用程序失败和故障操作的重要性。通过结合重试模式和断路器模式，我们可以获得更好的结果，因为它为应用程序处理故障提供了更大的灵活性。
- en: The retry patterns enable the application to retry failed operations, expecting
    those operations to become operational and eventually succeed. However, it may
    result in a **denial of service** (**DoS**) attack within our application. The
    circuit-breaker pattern prevents an application from performing an operation that's
    likely to fail. How about an intelligent retry mechanism that's sensitive to any
    failures returned by the circuit breaker that indicates no transient failures,
    and so the application abandons any further retry attempts?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 重试模式使应用程序能够重试失败的操作，预期这些操作将变得可用并最终成功。然而，这可能导致我们的应用程序中出现**拒绝服务**（DoS）攻击。断路器模式防止应用程序执行可能失败的操作。那么，一个对断路器返回的任何失败都敏感的智能重试机制如何？这表明没有瞬态故障，因此应用程序放弃任何进一步的重试尝试。
- en: API facade
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API门面
- en: We knew the pattern called **facade** from GoF, which abstracts the complex
    subsystem from the callers and exposes only necessary details as interfaces to
    the end user. API facade' is also aligned with the same definitions and implementations.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从《设计模式：可复用面向对象软件的基础》（GoF）中了解到名为**门面**的模式，该模式将复杂的子系统从调用者抽象出来，只向最终用户暴露必要的细节作为接口。API门面也符合相同的定义和实现。
- en: 'Let’s have a look at the following diagram, which depicts a simple implementation
    of multiple service calls from a client with and without the API facade pattern
    implementation:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下图表，它描述了客户端在有和没有API门面模式实现的情况下，对多个服务调用的简单实现：
- en: '![](img/cb797c53-fd6f-4a9c-ba89-3ff368e9431d.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图表](img/cb797c53-fd6f-4a9c-ba89-3ff368e9431d.png)'
- en: As we can see in the preceding diagram, the client is calling one API facade
    to make it simpler and more meaningful in cases where the clients need multiple
    service calls. However, that can be implemented with a single API endpoint instead
    of the client calling multiple endpoints. The API facades provide high scalability
    and high performance as well.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的图表中看到的那样，客户端调用一个API门面以使其在客户端需要多个服务调用的情况下更简单、更有意义。然而，这可以通过单个API端点来实现，而不是客户端调用多个端点。API门面提供了高可扩展性和高性能。
- en: Our investor services have implemented a simple API facade implementation for
    its delete operations. As we saw earlier, the delete methods call the design for
    intent methods. However, we have made the *design for the intent* method abstract
    to the caller by introducing a simple interface to our investor services. That
    brings the facade to our API.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的投资服务为其删除操作实现了一个简单的API门面。正如我们之前看到的那样，删除方法调用设计意图方法。然而，我们通过引入一个简单的接口到我们的投资服务中，将*设计意图*方法抽象为调用者。这使门面出现在我们的API中。
- en: 'The interface for the delete service is shown as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 删除服务的接口如下所示：
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The implementation for the delete service interface is shown in the following
    code snippet:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 删除服务接口的实现如下代码片段所示：
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As a simple exercise, we encourage the reader to implement our circuit breaker
    service call as an API facade and to also complete the bulk delete method within
    the delete service.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项简单的练习，我们鼓励读者将我们的断路器服务调用实现为API门面，并在删除服务中完成批量删除方法。
- en: Backend for frontend
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端后端
- en: So far, we have developed various restful service APIs and endpoints so that
    any app developer can start to use it. However, we need to ensure those services
    will cater to various types of devices, since its real purpose is to serve any
    customer using any device, and not only for desktop users or as web-based applications.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经开发了各种RESTful服务API和端点，以便任何应用程序开发者都可以开始使用它们。然而，我们需要确保这些服务将满足各种类型的设备，因为它的真正目的是为使用任何设备的任何客户提供服务，而不仅仅是桌面用户或基于Web的应用程序。
- en: Providing a better user experience across any device is vital, regardless of
    its backend services, and having figured out all possible best practices of developing
    RESTful services become meaningless if we aren't providing a better mechanism
    to use those services by heterogeneous end users and to their devices.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何设备上提供更好的用户体验至关重要，无论其后台服务如何，如果我们不能为异构的最终用户及其设备提供更好的使用这些服务的机制，那么掌握所有可能的最佳实践开发RESTful服务也就变得毫无意义。
- en: '**Backend for frontend** (**BFF**) is a pattern first described by Sam Newman;
    it helps to bridge any API design gaps. BFF suggests introducing a layer between
    the user experience and the resources it calls. It also helps API designers to
    avoid customizing a single backend (services) for multiple interfaces:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**后端为前端**（**BFF**）是一种模式，最初由Sam Newman描述；它有助于弥合任何API设计差距。BFF建议在用户体验与其调用的资源之间引入一个层。它还帮助API设计者避免为多个接口定制单个后端（服务）：'
- en: '![](img/8d474933-241c-44be-9196-14c92592d5c8.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d474933-241c-44be-9196-14c92592d5c8.png)'
- en: The preceding diagram depicts a simple implementation of the BFF pattern in
    the form of exclusive interfaces for both desktop and mobile devices. Each interface
    can define its necessary and unique requirements that cater to frontend requirements
    without worrying about impacting other frontend implementations.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表展示了BFF模式的一个简单实现，即针对桌面和移动设备都提供专属接口。每个接口都可以定义其必要的和独特的需求，以满足前端需求，而无需担心影响其他前端实现。
- en: 'Let''s examine a number of specific requirements of each interface so that
    we understand why we need to have multiple interfaces for the same backend services:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察每个接口的几个具体要求，以便我们了解为什么我们需要为相同的后端服务拥有多个接口：
- en: Response payload formatting and size may differ for each client
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应负载的格式和大小可能因每个客户端而异
- en: Performance bottlenecks and optimization requirements due to the number of calls
    to be made to services
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于需要调用服务的次数较多，可能会出现性能瓶颈和优化需求
- en: When in need of shared or general purpose backend services, but with less development
    and maintenance overhead
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要共享或通用后端服务，但开发和维护开销较少时
- en: BFF may not fit in cases such as multiple interfaces making the same requests
    to the backend, or using only one interface to interact with the backend services.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，如多个接口向后端发送相同的请求，或仅使用一个接口与后端服务交互时，BFF可能不适用。
- en: Please note that there are drawbacks with BFF, and exercise caution when deciding
    on separate, exclusive APIs/interfaces, as it warrants additional and lifelong
    maintenance, security improvement within layers, additional customized designs
    that lead to lapses in security, and defect leaks.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，BFF存在一些缺点，因此在决定使用独立的、专属的API/接口时，请谨慎行事，因为它需要额外的、终身的维护，包括在各个层级上的安全改进、额外的定制设计，这可能导致安全漏洞和缺陷泄露。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Learning the patterns with a few code examples always provides us with great
    insights. In this chapter, we discussed versioning our APIs, securing APIs with
    authorization, and enabling the service clients with uniform contract, entity
    endpoint, and endpoint redirection implementations. We also learned about Idempotent
    and its importance, which powers APIs with bulk operations. The most important
    part of this chapter is the circuit-breaker implementation with *Hysterix*, where
    we envisioned and implemented the resiliency patterns of API designs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几个代码示例学习模式总是能给我们带来深刻的见解。在本章中，我们讨论了API版本控制、使用授权保护API，以及通过统一合同、实体端点和端点重定向实现来使服务客户端具备一致性。我们还学习了幂等及其重要性，它为API提供了批量操作的能力。本章最重要的部分是使用Hysterix实现的断路器，其中我们设想并实现了API设计的弹性模式。
- en: Having covered various advanced patterns, we concluded the chapter with the
    BFF pattern, and we learned how it reduces churns within the cross-implementation
    team by helping them to develop an exclusive interface for target environments.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了各种高级模式后，我们以BFF模式结束了本章，并学习了它是如何通过帮助开发团队为特定环境开发专属接口来减少跨实现团队中的 churns（不稳定）。
- en: In the next chapter, we'll cover RESTful API gateways, which should be an equally
    exciting read for API designers.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍RESTful API网关，这应该对API设计者来说同样是一个令人兴奋的阅读材料。
- en: Further reading
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: RESTful Java Patterns and Best Practices: [https://www.packtpub.com/application-development/restful-java-patterns-and-best-practices](https://www.packtpub.com/application-development/restful-java-patterns-and-best-practices)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful Java 模式和最佳实践：[https://www.packtpub.com/application-development/restful-java-patterns-and-best-practices](https://www.packtpub.com/application-development/restful-java-patterns-and-best-practices)
