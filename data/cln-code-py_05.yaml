- en: Using Decorators to Improve Our Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用装饰器改进我们的代码
- en: In this chapter, we will explore decorators and see how they are useful in many
    situations where we want to improve our design. We will start by first exploring
    what decorators are, how they work, and how they are implemented.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨装饰器，并看到它们在许多情况下如何有用，我们想要改进我们的设计。我们将首先探讨装饰器是什么，它们是如何工作的，以及它们是如何实现的。
- en: With this knowledge, we will then revisit concepts that we learned in previous
    chapters regarding general good practices for software design, and see how decorators
    can help us comply with each principle.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，我们将重新审视我们在以前章节中学到的关于软件设计的一般良好实践，并看看装饰器如何帮助我们遵守每个原则。
- en: 'The goals of this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标如下：
- en: To understand how decorators work in Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Python中装饰器的工作原理
- en: To learn how to implement decorators that apply to functions and classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何实现适用于函数和类的装饰器
- en: To effectively implement decorators, avoiding common implementation mistakes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效实现装饰器，避免常见的实现错误
- en: To analyze how to avoid code duplication (the DRY principle) with decorators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析如何通过装饰器避免代码重复（DRY原则）
- en: To study how decorators contribute to separation of concerns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究装饰器如何有助于关注点分离
- en: To analyze examples of good decorators
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析良好装饰器的示例
- en: To review common situations, idioms, or patterns for when decorators are the
    right choice
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查常见情况、习语或模式，以确定装饰器是正确的选择
- en: What are decorators in Python?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的装饰器是什么？
- en: Decorators were introduced in Python a long time ago, in (PEP-318), as a mechanism
    to simplify the way functions and methods are defined when they have to be modified
    after their original definition.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器在Python中很久以前就被引入了（PEP-318），作为一种简化函数和方法定义的机制，当它们在原始定义之后需要被修改时。
- en: One of the original motivations for this was because functions such as `classmethod`
    and `staticmethod` were used to transform the original definition of the method,
    but they required an extra line, modifying the original definition of the function.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的动机之一是因为诸如“classmethod”和“staticmethod”之类的函数被用来转换方法的原始定义，但它们需要额外的一行，修改函数的原始定义。
- en: More generally speaking, every time we had to apply a transformation to a function,
    we had to call it with the `modifier` function, and then reassign it to the same
    name the function was originally defined with.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地说，每当我们必须对函数应用转换时，我们必须使用“modifier”函数调用它，然后将其重新分配给与函数最初定义的相同名称。
- en: 'For instance, if we have a function called `original`, and then we have a function
    that changes the behavior of `original` on top of it, called `modifier`, we have
    to write something like the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个名为“original”的函数，然后我们有一个在其上更改“original”行为的函数，称为“modifier”，我们必须编写类似以下的内容：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice how we change the function and reassign it to the same name. This is
    confusing, error-prone (imagine that someone forgets to reassign the function,
    or does reassign that but not in the line immediately after the function definition,
    but much farther away), and cumbersome. For this reason, some syntax support was
    added to the language.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何更改函数并将其重新分配给相同的名称。这很令人困惑，容易出错（想象有人忘记重新分配函数，或者确实重新分配了函数，但不是在函数定义后的下一行，而是在更远的地方），而且很麻烦。因此，语言中添加了一些语法支持。
- en: 'The previous example could be rewritten like so:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例可以这样重写：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This means that decorators are just syntax sugar for calling whatever is after
    the decorator as a first parameter of the decorator itself, and the result would
    be whatever the decorator returns.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着装饰器只是调用装饰器后面的内容作为装饰器本身的第一个参数的语法糖，结果将是装饰器返回的内容。
- en: In line with the Python terminology, and our example, `modifier` is what we
    call the decorator, and `original` is the decorated function, often also called
    a **wrapped** object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python术语和我们的示例，“modifier”是我们称之为装饰器，“original”是被装饰的函数，通常也称为“wrapped”对象。
- en: While the functionality was originally thought for methods and functions, the
    actual syntax allows any kind of object to be decorated, so we are going to explore
    decorators applied to functions, methods, generators, and classes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最初的功能是为方法和函数设计的，但实际的语法允许对任何类型的对象进行装饰，因此我们将探讨应用于函数、方法、生成器和类的装饰器。
- en: One final note is that, while the name of a decorator is correct (after all,
    the decorator is in fact, making changes, extending, or working on top of the
    `wrapped` function), it is not to be confused with the decorator design pattern.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点是，虽然装饰器的名称是正确的（毕竟，装饰器实际上是在对“wrapped”函数进行更改、扩展或处理），但它不应与装饰器设计模式混淆。
- en: Decorate functions
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰函数
- en: Functions are probably the simplest representation of a Python object that can
    be decorated. We can use decorators on functions to apply all sorts of logic to
    them—we can validate parameters, check preconditions, change the behavior entirely,
    modify its signature, cache results (create a memorized version of the original
    function), and more.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可能是Python对象的最简单表示形式，可以对函数使用装饰器来应用各种逻辑——我们可以验证参数、检查前提条件、完全改变行为、修改其签名、缓存结果（创建原始函数的记忆版本），等等。
- en: 'As an example, we will create a basic decorator that implements a `retry` mechanism,
    controlling a particular domain-level exception and retrying a certain number
    of times:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将创建一个实现“重试”机制的基本装饰器，控制特定领域级别的异常并重试一定次数：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The use of `@wraps` can be ignored for now, as it will be covered in the section
    named *Effective decorators - avoiding common mistakes*. The use of `_` in the
    for loop, means that the number is assigned to a variable we are not interested
    in at the moment, because it's not used inside the for loop (it's a common idiom
    in Python to name `_` values that are ignored).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以忽略`@wraps`的使用，因为它将在名为*有效装饰器-避免常见错误*的部分中进行介绍。在for循环中使用`_`，意味着这个数字被赋值给一个我们目前不感兴趣的变量，因为它在for循环内没有被使用（在Python中命名`_`的值被忽略是一个常见的习惯）。
- en: 'The `retry` decorator doesn''t take any parameters, so it can be easily applied
    to any function, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`retry`装饰器不接受任何参数，因此可以轻松地应用到任何函数，如下所示：'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As explained at the beginning, the definition of `@retry` on top of `run_operation`
    is just syntactic sugar that Python provides to actually execute `run_operation
    = retry(run_operation)`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在开头解释的那样，在`run_operation`的顶部定义`@retry`只是Python提供的语法糖，实际上执行`run_operation =
    retry(run_operation)`。
- en: In this limited example, we can see how decorators can be used to create a generic
    `retry` operation that, under certain conditions (in this case, represented as
    exceptions that could be related to timeouts, for example), will allow calling
    the decorated code multiple times.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个有限的例子中，我们可以看到装饰器如何被用来创建一个通用的`retry`操作，根据一定的条件（在这种情况下，表示为可能与超时相关的异常），允许调用被装饰的代码多次。
- en: Decorate classes
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰类
- en: Classes can also be decorated (PEP-3129) with the same as can be applied to
    syntax functions. The only difference is that when writing the code for this decorator,
    we have to take into consideration that we are receiving a class, not a function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类也可以使用相同的语法装饰（PEP-3129）作用于函数。唯一的区别是，在编写这个装饰器的代码时，我们必须考虑到我们接收到的是一个类，而不是一个函数。
- en: Some practitioners might argue that decorating a class is something rather convoluted
    and that such a scenario might jeopardize readability because we would be declaring
    some attributes and methods in the class, but behind the scenes, the decorator
    might be applying changes that would render a completely different class.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一些从业者可能会认为装饰一个类是相当复杂的，这种情况可能会危及可读性，因为我们会在类中声明一些属性和方法，但在幕后，装饰器可能会应用会使一个完全不同的类。
- en: 'This assessment is true, but only if this technique is heavily abused. Objectively,
    this is no different from decorating functions; after all, classes are just another
    type of object in the Python ecosystem, as functions are. We will review the pros
    and cons of this issue with decorators in the section titled *Decorators and separation
    of concerns*, but for now, we''ll explore the benefits of decorators that apply
    particularly to classes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个评估是正确的，但只有在这种技术被滥用的情况下。客观地说，这与装饰函数没有什么不同；毕竟，类只是Python生态系统中的另一种对象类型，就像函数一样。我们将在标题为*装饰器和关注点分离*的部分中审查这个问题的利弊，但现在我们将探讨特别适用于类的装饰器的好处：
- en: All the benefits of reusing code and the DRY principle. A valid case of a class
    decorator would be to enforce that multiple classes conform to a certain interface
    or criteria (by making this checks only once in the decorator that is going to
    be applied to those many classes).
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有重用代码和DRY原则的好处。类装饰器的一个有效案例是强制多个类符合某个接口或标准（通过在将应用于这些多个类的装饰器中只进行一次检查）。
- en: We could create smaller or simpler classes that will be enhanced later on by
    decorators
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建更小或更简单的类，稍后可以通过装饰器进行增强。
- en: The transformation logic we need to apply to a certain class will be much easier
    to maintain if we use a decorator, as opposed to more complicated (and often rightfully
    discouraged) approaches such as metaclasses
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要应用到某个类的转换逻辑，如果我们使用装饰器，将会更容易维护，而不是使用更复杂（通常是被不鼓励的）方法，比如元类。
- en: Among all possible applications of decorators, we will explore a simple example
    to give an idea of the sorts of things they can be useful for. Keep in mind that
    this is not the only application type for class decorators, but also that the
    code we show you could have many other multiple solutions as well, all with their
    pros and cons, but we chose decorators with the purpose of illustrating their
    usefulness.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有可能的装饰器应用中，我们将探讨一个简单的例子，以给出它们可以有用的事情的一些想法。请记住，这不是类装饰器的唯一应用类型，但我们展示的代码也可能有许多其他多种解决方案，都有各自的利弊，但我们选择了装饰器，目的是说明它们的用处。
- en: Recalling our event systems for the monitoring platform, we now need to transform
    the data for each event and send it to an external system. However, each type
    of event might have its own particularities when selecting how to send its data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们的监控平台的事件系统，现在我们需要为每个事件转换数据并将其发送到外部系统。然而，每种类型的事件在选择如何发送其数据时可能有其自己的特殊之处。
- en: 'In particular, the `event` for a login might contain sensitive information
    such as credentials that we want to hide. Other fields such as `timestamp` might
    also require some transformations since we want to show them in a particular format.
    A first attempt at complying with these requirements would be as simple as having
    a class that maps to each particular `event` and knows how to serialize it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，登录的`event`可能包含诸如我们想要隐藏的凭据之类的敏感信息。其他字段，比如`timestamp`，也可能需要一些转换，因为我们想以特定格式显示它们。满足这些要求的第一次尝试可能就像有一个映射到每个特定`event`的类，并且知道如何对其进行序列化：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we declare a class that is going to map directly with the login event,
    containing the logic for it—hide the `password` field, and format the `timestamp`
    as required.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个类，它将直接与登录事件进行映射，包含了它的逻辑——隐藏`password`字段，并按要求格式化`timestamp`。
- en: 'While this works and might look like a good option to start with, as time passes
    and we want to extend our system, we will find some issues:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法有效，看起来可能是一个不错的选择，但随着时间的推移，当我们想要扩展我们的系统时，我们会发现一些问题：
- en: '**Too many classes**: As the number of events grows, the number of serialization
    classes will grow in the same order of magnitude, because they are mapped one
    to one.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类太多**：随着事件数量的增加，序列化类的数量也会按同等数量级增长，因为它们是一对一映射的。'
- en: '**The solution is not flexible enough**: If we need to reuse parts of the components
    (for example, we need to hide the `password` in another type of `event` that also
    has it), we will have to extract this into a function, but also call it repeatedly
    from multiple classes, meaning that we are not reusing that much code after all.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案不够灵活**：如果我们需要重用组件的部分（例如，我们需要隐藏另一种类型的`event`中也有的`password`），我们将不得不将其提取到一个函数中，但也要从多个类中重复调用它，这意味着我们实际上并没有重用太多代码。'
- en: '**Boilerplate**: The `serialize()` method will have to be present in all `event`
    classes, calling the same code. Although we can extract this into another class
    (creating a mixin), it does not seem like a good use of inheritance.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**样板代码**：`serialize()`方法必须存在于所有`event`类中，调用相同的代码。尽管我们可以将其提取到另一个类中（创建一个mixin），但这似乎不是继承的好用法。'
- en: An alternative solution is to be able to dynamically construct an object that,
    given a set of filters (transformation functions) and an `event` instance, is
    able to serialize it by applying the filters to its fields. We then only need
    to define the functions to transform each type of field, and the serializer is
    created by composing many of these functions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是能够动态构造一个对象，给定一组过滤器（转换函数）和一个`event`实例，能够通过将这些过滤器应用于其字段来对其进行序列化。然后，我们只需要定义转换每种字段类型的函数，序列化器通过组合许多这些函数来创建。
- en: 'Once we have this object, we can decorate the class in order to add the `serialize()`
    method, which will just call these `Serialization` objects with itself:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个对象后，我们可以装饰类以添加`serialize()`方法，它将只调用这些`Serialization`对象本身：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice how the decorator makes it easier for the user to know how each field
    is going to be treated without having to look into the code of another class.
    Just by reading the arguments passed to the class decorator, we know that the
    `username` and IP address will be left unmodified, the `password` will be hidden,
    and the `timestamp` will be formatted.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，装饰器使用户更容易知道每个字段将如何处理，而无需查看另一个类的代码。只需阅读传递给类装饰器的参数，我们就知道`username`和IP地址将保持不变，`password`将被隐藏，`timestamp`将被格式化。
- en: Now, the code of the class does not need the `serialize()` method defined, nor
    does it need to extend from a mixin that implements it, since the decorator will
    add it. In fact, this is probably the only part that justifies the creation of
    the class decorator, because otherwise, the `Serialization` object could have
    been a class attribute of `LoginEvent`, but the fact that it is altering the class
    by adding a new method to it makes it impossible.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，类的代码不需要定义`serialize()`方法，也不需要扩展实现它的mixin，因为装饰器将添加它。实际上，这可能是唯一证明创建类装饰器的部分，因为否则，`Serialization`对象可以是`LoginEvent`的类属性，但它正在通过向其添加新方法来更改类的事实使其成为不可能。
- en: Moreover, we could have another class decorator that, just by defining the attributes
    of the class, implements the logic of the `init` method, but this is beyond the
    scope of this example. This is what libraries such as `attrs` (ATTRS 01) do, and
    a similar functionality is proposed in (PEP-557) for the Standard library.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以有另一个类装饰器，只需定义类的属性，就可以实现`init`方法的逻辑，但这超出了本示例的范围。这就是诸如`attrs`（ATTRS 01）这样的库所做的事情，标准库中的（PEP-557）也提出了类似的功能。
- en: 'By using this class decorator from (PEP-557), in Python 3.7+, the previous
    example could be rewritten in a more compact way, without the boilerplate code
    of the `init`, as shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Python 3.7+中的（PEP-557）中的这个类装饰器，可以以更紧凑的方式重写先前的示例，而不需要`init`的样板代码，如下所示：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Other types of decorator
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他类型的装饰器
- en: Now that we know what the `@` syntax for decorators actually means, we can conclude
    that it isn't just functions, methods, or classes that can be decorated; actually,
    anything that can be defined, such as generators, coroutines, and even objects
    that have already been decorated, can be decorated, meaning that decorators can
    be stacked.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了装饰器的`@`语法实际上意味着什么，我们可以得出结论，不仅可以装饰函数、方法或类；实际上，任何可以定义的东西，例如生成器、协程，甚至已经被装饰的对象，都可以被装饰，这意味着装饰器可以被堆叠。
- en: The previous example showed how decorators can be chained. We first defined
    the class, and then applied `@dataclass` to it, which converted it into a data
    class, acting as a container for those attributes. After that, the `@Serialization`
    will apply the logic to that class, resulting in a new class with the new `serialize()`
    method added to it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的示例展示了装饰器如何链接。我们首先定义了类，然后对其应用了`@dataclass`，将其转换为数据类，充当这些属性的容器。之后，`@Serialization`将对该类应用逻辑，从而产生一个新的类，其中添加了新的`serialize()`方法。
- en: Another good use of decorators is for generators that are supposed to be used
    as coroutines. We will explore the details of generators and coroutines in [Chapter
    7](32503c77-5ff2-4d35-af0e-8d9300cfa357.xhtml), *Using Generators,* but the main
    idea is that, before sending any data to a newly created generator, the latter
    has to be advanced up to their next `yield` statement by calling `next()` on it.
    This is a manual process that every user will have to remember and hence is error-prone.
    We could easily create a decorator that takes a generator as a parameter, calls
    `next()` to it, and then returns the generator.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器的另一个很好的用途是用于应该用作协程的生成器。我们将在[第7章](32503c77-5ff2-4d35-af0e-8d9300cfa357.xhtml)中探讨生成器和协程的细节，但主要思想是，在向新创建的生成器发送任何数据之前，必须通过调用`next()`将其推进到下一个`yield`语句。这是每个用户都必须记住的手动过程，因此容易出错。我们可以轻松地创建一个装饰器，它以生成器作为参数，调用`next()`，然后返回生成器。
- en: Passing arguments to decorators
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将参数传递给装饰器
- en: At this point, we already regard decorators as a powerful tool in Python. However,
    they could be even more powerful if we could just pass parameters to them so that
    their logic is abstracted even more.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将装饰器视为Python中的强大工具。但是，如果我们可以向它们传递参数，使其逻辑更加抽象，它们可能会更加强大。
- en: There are several ways of implementing decorators that can take arguments, but
    we will go over the most common ones. The first one is to create decorators as
    nested functions with a new level of indirection, making everything in the decorator
    fall one level deeper. The second approach is to use a class for the decorator.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 实现装饰器的几种方法，可以接受参数，但我们将介绍最常见的方法。第一种方法是将装饰器创建为嵌套函数，增加一个新的间接层，使装饰器中的所有内容深入一层。第二种方法是使用类作为装饰器。
- en: In general, the second approach favors readability more, because it is easier
    to think in terms of an object than three or more nested functions working with
    closures. However, for completeness, we will explore both, and the reader can
    decide what is best for the problem at hand.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，第二种方法更有利于可读性，因为以对象的方式思考比使用三个或更多个嵌套函数与闭包更容易。然而，为了完整起见，我们将探讨两种方法，读者可以决定对于手头的问题哪种方法更好。
- en: Decorators with nested functions
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有嵌套函数的装饰器
- en: Roughly speaking, the general idea of a decorator is to create a function that
    returns a function (often called a higher-order function). The internal function
    defined in the body of the decorator is going to be the one actually being called.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 大致来说，装饰器的一般思想是创建一个返回函数的函数（通常称为高阶函数）。在装饰器主体中定义的内部函数将是实际被调用的函数。
- en: Now, if we wish to pass parameters to it, we then need another level of indirection.
    The first one will take the parameters, and inside that function, we will define
    a new function, which will be the decorator, which in turn will define yet another
    new function, namely the one to be returned as a result of the decoration process.
    This means that we will have at least three levels of nested functions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们希望向其传递参数，那么我们需要另一个间接层。第一个将接受参数，并在该函数内部，我们将定义一个新函数，这将是装饰器，然后将定义另一个新函数，即作为装饰过程的结果返回的函数。这意味着我们将至少有三个级别的嵌套函数。
- en: Don't worry if this didn't seem clear so far. After reviewing the examples that
    are about to come, everything will become clear.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果到目前为止这还不清楚，不要担心。在查看即将出现的示例之后，一切都会变得清晰起来。
- en: One of the first examples we saw of decorators implemented the `retry` functionality
    over some functions. This is a good idea, except it has a problem; our implementation
    did not allow us to specify the numbers of retries, and instead, this was a fixed
    number inside the decorator.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的第一个装饰器的示例是在一些函数上实现`retry`功能。这是一个好主意，但是有一个问题；我们的实现不允许我们指定重试次数，而是在装饰器内部是一个固定的数字。
- en: Now, we want to be able to indicate how many retries each instance is going
    to have, and perhaps we could even add a default value to this parameter. In order
    to do this, we need another level of nested functions—first for the parameters,
    and then for the decorator itself.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望能够指示每个实例将具有多少次重试，也许我们甚至可以为此参数添加一个默认值。为了做到这一点，我们需要另一个级别的嵌套函数——首先是参数，然后是装饰器本身。
- en: 'This is because we are now going to have something in the form of the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们现在将有以下形式的东西：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And that has to return a decorator because the `@` syntax will apply the result
    of that computation to the object to be decorated. Semantically, it would translate
    to something like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 并且必须返回一个装饰器，因为`@`语法将该计算的结果应用于要装饰的对象。从语义上讲，它将转换为以下内容：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Besides the number of desired retries, we can also indicate the types of exception
    we wish to control. The new version of the code supporting the new requirements
    might look like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所需的重试次数，我们还可以指示我们希望控制的异常类型。支持新要求的代码的新版本可能如下所示：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here are some examples of how this decorator can be applied to functions, showing
    the different options it accepts:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何将此装饰器应用于函数的一些示例，显示它接受的不同选项：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Decorator objects
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器对象
- en: The previous example requires three levels of nested functions. The first it
    is going to be a function that receives the parameters of the decorator we want
    to use. Inside this function, the rest of the functions are closures that use
    these parameters along with the logic of the decorator.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例需要三个级别的嵌套函数。第一个将是一个接收我们想要使用的装饰器的参数的函数。在这个函数内部，其余的函数都是使用这些参数以及装饰器的逻辑的闭包。
- en: A cleaner implementation of this would be to use a class to define the decorator.
    In this case, we can pass the parameters in the `__init__` method, and then implement
    the logic of the decorator on the magic method named `__call__`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 更干净的实现方法是使用类来定义装饰器。在这种情况下，我们可以在`__init__`方法中传递参数，然后在名为`__call__`的魔术方法上实现装饰器的逻辑。
- en: 'The code for the decorator will look like it does in the following example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器的代码看起来像以下示例中的样子：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And this decorator can be applied pretty much like the previous one, like so:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器可以应用得和之前的一个差不多，像这样：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is important to note how the Python syntax takes effect here. First, we create
    the object, so before the `@` operation is applied, the object is created with
    its parameters passed to it. This will create a new object and initialize it with
    these parameters, as defined in the `init` method. After this, the `@` operation
    is invoked, so this object will wrap the function named `run_with_custom_reries_limit`,
    meaning that it will be passed to the `call` magic method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意Python语法在这里的作用。首先，我们创建对象，因此在应用`@`操作之前，对象已经被创建，并且其参数传递给它。这将创建一个新对象，并使用`init`方法中定义的这些参数进行初始化。之后，调用`@`操作，因此这个对象将包装名为`run_with_custom_reries_limit`的函数，这意味着它将被传递给`call`魔术方法。
- en: Inside this `call` magic method, we defined the logic of the decorator as we
    normally do—we wrap the original function, returning a new one with the logic
    we want instead.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`call`魔术方法中，我们像往常一样定义了装饰器的逻辑-我们包装原始函数，返回一个具有我们想要的逻辑的新函数。
- en: Good uses for decorators
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器的好处
- en: In this section, we will take a look at some common patterns that make good
    use of decorators. These are common situations for when decorators are a good
    choice.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一些常见的模式，这些模式充分利用了装饰器。这些都是装饰器是一个不错选择的常见情况。
- en: 'From all the countless applications decorators can be used for, we will enumerate
    a few, the most common or relevant:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从装饰器可以使用的无数应用中，我们将列举一些最常见或相关的：
- en: '**Transforming parameters**: Changing the signature of a function to expose
    a nicer API, while encapsulating details on how the parameters are treated and
    transformed underneath'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换参数**：更改函数的签名以公开更好的API，同时封装有关如何处理和转换参数的细节'
- en: '**Tracing code**: Logging the execution of a function with its parameters'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪代码**：记录函数的执行及其参数'
- en: '**Validate parameters**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证参数**'
- en: '**Implement retry operations**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现重试操作**'
- en: '**Simplify classes by moving some (repetitive) logic into decorators**'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过将一些（重复的）逻辑移入装饰器来简化类**'
- en: Let's discuss the first two applications in detail in the following section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节详细讨论前两个应用。
- en: Transforming parameters
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换参数
- en: We have mentioned before that decorators can be used to validate parameters
    (and even enforce some preconditions or postconditions under the idea of DbC),
    so from this you probably have got the idea that it is somehow common to use decorators
    when dealing with or manipulating parameters.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，装饰器可以用于验证参数（甚至在DbC的概念下强制执行一些前置条件或后置条件），因此您可能已经得到这样的想法，即在处理或操作参数时，使用装饰器是很常见的。
- en: In particular, there are some cases on which we find ourselves repeatedly creating
    similar objects, or applying similar transformations that we would wish to abstract
    away. Most of the time, we can achieve this by simply using a decorator.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，在某些情况下，我们发现自己反复创建类似的对象，或者应用类似的转换，我们希望将其抽象化。大多数情况下，我们可以通过简单地使用装饰器来实现这一点。
- en: Tracing code
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪代码
- en: 'When talking about **tracing** in this section, we will refer to something
    more general that has to do with dealing with the execution of a function that
    we wish to monitor. This could refer to scenarios in which we want to:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节讨论“跟踪”时，我们将指的是处理我们希望监视的函数的执行的更一般的内容。这可能涉及到我们希望的一些情况：
- en: Actually trace the execution of a function (for example, by logging the lines
    it executes)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上跟踪函数的执行（例如，通过记录它执行的行）
- en: Monitor some metrics over a function (such as CPU usage or memory footprint)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视函数的一些指标（如CPU使用率或内存占用）
- en: Measure the running time of a function
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量函数的运行时间
- en: Log when a function was called, and the parameters that were passed to it
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录函数调用的时间和传递给它的参数
- en: In the next section, we will explore a simple example of a decorator that logs
    the execution of a function, including its name and the time it took to run.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一个简单的例子，即记录函数的执行情况，包括其名称和运行所花费的时间的装饰器。
- en: Effective decorators – avoiding common mistakes
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有效的装饰器-避免常见错误
- en: While decorators are a great feature of Python, they are not exempt from issues
    if used incorrectly. In this section, we will see some common issues to avoid
    in order to create effective decorators.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然装饰器是Python的一个很棒的特性，但如果使用不当，它们也不免有问题。在本节中，我们将看到一些常见的问题，以避免创建有效的装饰器。
- en: Preserving data about the original wrapped object
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留有关原始包装对象的数据
- en: One of the most common problems when applying a decorator to a function is that
    some of the properties or attributes of the original function are not maintained,
    leading to undesired, and hard-to-track, side-effects.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将装饰器应用于函数时最常见的问题之一是，原始函数的某些属性或属性未得到保留，导致不希望的、难以跟踪的副作用。
- en: 'To illustrate this we show a decorator that is in charge of logging when the
    function is about to run:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们展示了一个负责记录函数即将运行时的装饰器：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s imagine we have a function with this decorator applied to it. We
    might initially think that nothing of that function is modified with respect to
    its original definition:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想象一下，我们有一个应用了这个装饰器的函数。我们可能最初会认为该函数的任何部分都没有修改其原始定义：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: But maybe there are changes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但也许有一些变化。
- en: The decorator is not supposed to alter anything from the original function,
    but, as it turns out since it contains a flaw it's actually modifying its name
    and `docstring`, among other properties.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器不应该改变原始函数的任何内容，但事实证明，由于它包含一个缺陷，它实际上修改了其名称和`docstring`等属性。
- en: 'Let''s try to get `help` for this function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试为这个函数获取`help`：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And let''s check how it''s called:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查它是如何被调用的：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can see that, since the decorator is actually changing the original function
    for a new one (called `wrapped`), what we actually see are the properties of this
    function instead of those from the original function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，由于装饰器实际上是将原始函数更改为一个新函数（称为`wrapped`），我们实际上看到的是这个函数的属性，而不是原始函数的属性。
- en: If we apply a decorator like this one to multiple functions, all with different
    names, they will all end up being called `wrapped`, which is a major concern (for
    example, if we want to log or trace the function, this will make debugging even
    harder).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这样一个装饰器应用于多个函数，它们都有不同的名称，它们最终都将被称为`wrapped`，这是一个主要问题（例如，如果我们想要记录或跟踪函数，这将使调试变得更加困难）。
- en: Another problem is that, in case we placed docstrings with tests on these functions,
    they will be overridden by those of the decorator. As a result, the docstrings
    with the test we want will not run when we call our code with the `doctest` module
    (as we have seen in [Chapter 1](bba62a64-dfe9-478f-9b33-6c3240d75f59.xhtml), *Introduction,
    Code Formatting, and Tools*).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是，如果我们在这些函数上放置了带有测试的文档字符串，它们将被装饰器的文档字符串覆盖。结果，我们希望的带有测试的文档字符串在我们使用`doctest`模块调用我们的代码时将不会运行（正如我们在[第1章](bba62a64-dfe9-478f-9b33-6c3240d75f59.xhtml)中所看到的，*介绍、代码格式和工具*）。
- en: 'The fix is simple, though. We just have to apply the `wraps` decorator in the
    internal function (`wrapped`), telling it that it is actually wrapping `function`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 修复很简单。我们只需在内部函数（`wrapped`）中应用`wraps`装饰器，告诉它实际上是在包装`function`：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, if we check the properties, we will obtain what we expected in the first
    place. Check `help` for the function, like so:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们检查属性，我们将得到我们最初期望的结果。像这样检查函数的`help`：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And verify that its qualified name is correct, like so:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 并验证其合格的名称是否正确，如下所示：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Most importantly, we recovered the unit tests we might have had on the docstrings!
    By using the `wraps` decorator, we can also access the original, unmodified function
    under the `__wrapped__` attribute. Although it should not be used in production,
    it might come in handy in some unit tests when we want to check the unmodified
    version of the function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们恢复了可能存在于文档字符串中的单元测试！通过使用`wraps`装饰器，我们还可以在`__wrapped__`属性下访问原始的未修改的函数。虽然不应该在生产中使用，但在一些单元测试中，当我们想要检查函数的未修改版本时，它可能会派上用场。
- en: 'In general, for simple decorators, the way we would use `functools.wraps` would
    typically follow the general formula or structure:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于简单的装饰器，我们使用`functools.wraps`的方式通常遵循以下一般公式或结构：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Always use `functools.wraps` applied over the wrapped function, when creating
    a decorator, as shown in the preceding formula.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建装饰器时，通常对包装的函数应用`functools.wraps`，如前面的公式所示。
- en: Dealing with side-effects in decorators
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理装饰器中的副作用
- en: In this section, we will learn that it is advisable to avoid side-effects in
    the body of the decorator. There are cases where this might be acceptable, but
    the bottom line is that, if in case of doubt, decide against it, for the reasons
    that are explained ahead. Everything that the decorator needs to do aside from
    the function that it's decorating should be placed in the innermost function definition,
    or there will be problems when it comes to importing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解在装饰器的主体中避免副作用是明智的。有些情况下可能是可以接受的，但最重要的是，如果有疑问，最好不要这样做，原因将在后面解释。
- en: Nonetheless, sometimes these side-effects are required (or even desired) to
    run at import time, and the obverse applies.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，有时这些副作用是必需的（甚至是期望的）在导入时运行，反之亦然。
- en: We will see examples of both, and where each one applies. If in doubt, err on
    the side of caution, and delay all side-effects until the very latest, right after
    the `wrapped` function is going to be called.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到两者的示例，以及每种情况的适用情况。如果有疑问，最好谨慎行事，并将所有副作用延迟到最后，就在`wrapped`函数将被调用之后。
- en: Next, we will see when it's not a good idea to place extra logic outside the
    `wrapped` function.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到在`wrapped`函数之外放置额外逻辑不是一个好主意的情况。
- en: Incorrect handling of side-effects in a decorator
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器中副作用的处理不正确
- en: 'Let''s imagine the case of a decorator that was created with the goal of logging
    when a function started running and then logging its running time:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个创建目的是在函数开始运行时记录日志，然后记录其运行时间的装饰器的情况：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we will apply the decorator to a regular function, thinking that it will
    work just fine:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将装饰器应用到一个常规函数上，认为它会正常工作：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This decorator has a subtle, yet critical bug in it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器有一个微妙但关键的错误。
- en: 'First, let''s import the function, call it several times, and see what happens:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们导入函数，多次调用它，看看会发生什么：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Just by importing the function, we will notice that something's amiss. The logging
    line should not be there, because the function was not invoked.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入函数，我们会注意到有些地方不对劲。日志行不应该出现在那里，因为函数没有被调用。
- en: 'Now, what happens if we run the function, and see how long it takes to run?
    Actually, we would expect that calling the same function multiple times will give
    similar results:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行函数，看看运行需要多长时间？实际上，我们期望多次调用相同的函数会得到类似的结果：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Every time we run the same function, it takes longer! At this point, you have
    probably already noticed the (now obvious) error.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行相同的函数，都会花费更长的时间！此时，您可能已经注意到（现在显而易见的）错误。
- en: 'Remember the syntax for decorators. `@traced_function_wrong` actually means
    the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了装饰的函数之外，装饰器需要做的一切都应该放在最内部的函数定义中，否则在导入时会出现问题。
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: And this will run when the module is imported. Therefore, the time that is set
    in the function will be the one at the time the module was imported. Successive
    calls will compute the time difference from the running time until that original
    starting time. It will also log at the wrong moment, and not when the function
    is actually called.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在模块导入时运行。因此，函数中设置的时间将是模块导入时的时间。连续调用将计算从运行时间到原始开始时间的时间差。它还将在错误的时刻记录，而不是在实际调用函数时。
- en: 'Luckily, the fix is also very simple—we just have to move the code inside the
    `wrapped` function in order to delay its execution:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，修复也很简单——我们只需将代码移到`wrapped`函数内部以延迟其执行：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With this new version, the previous problems are resolved.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 记住装饰器的语法。`@traced_function_wrong`实际上意味着以下内容：
- en: If the actions of the decorator had been different, the results could have been
    much more disastrous. For instance, if it requires that you log events and send
    them to an external service, it will certainly fail unless the configuration has
    been run right before this has been imported, which we cannot guarantee. Even
    if we could, it would be bad practice. The same applies if the decorator has any
    other sort of side-effect, such as reading from a file, parsing a configuration,
    and many more.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果装饰器的操作不同，结果可能会更加灾难性。例如，如果它要求您记录事件并将其发送到外部服务，除非在导入此模块之前正确运行了配置，否则肯定会失败，而这是我们无法保证的。即使我们可以，这也是不好的做法。如果装饰器具有其他任何形式的副作用，例如从文件中读取、解析配置等，也是一样。
- en: Requiring decorators with side-effects
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要具有副作用的装饰器
- en: Sometimes, side-effects on decorators are necessary, and we should not delay
    their execution until the very last possible time, because that's part of the
    mechanism which is required for them to work.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，装饰器上的副作用是必要的，我们不应该延迟它们的执行直到最后可能的时间，因为这是它们工作所需的机制的一部分。
- en: One common scenario for when we don't want to delay the side-effect of decorators is
    when we need to register objects to a public registry that will be available in
    the module.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不想延迟装饰器的副作用时，一个常见的情况是，我们需要将对象注册到一个将在模块中可用的公共注册表中。
- en: For instance, going back to our previous `event` system example, we now want
    to only make some events available in the module, but not all of them. In the
    hierarchy of events, we might want to have some intermediate classes that are
    not actual events we want to process on the system, but some of their derivative
    classes instead.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，回到我们之前的`event`系统示例，现在我们只想在模块中使一些事件可用，而不是所有事件。在事件的层次结构中，我们可能希望有一些中间类，它们不是我们想要在系统上处理的实际事件，而是它们的一些派生类。
- en: Instead of flagging each class based on whether it's going to be processed or
    not, we could explicitly register each class through a decorator.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过装饰器显式注册每个类，而不是根据它是否要被处理来标记每个类。
- en: 'In this case, we have a class for all events that relate to the activities
    of a user. However, this is just an intermediate table for the types of event
    we actually want, namely `UserLoginEvent` and `UserLogoutEvent`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一个与用户活动相关的所有事件的类。然而，这只是我们实际想要的事件类型的中间表，即`UserLoginEvent`和`UserLogoutEvent`：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When we look at the preceding code, it seems that `EVENTS_REGISTRY` is empty,
    but after importing something from this module, it will get populated with all
    of the classes that are under the `register_event` decorator:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看前面的代码时，似乎`EVENTS_REGISTRY`是空的，但在从这个模块导入一些内容之后，它将被填充为所有在`register_event`装饰器下的类。
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This might seem like it's hard to read, or even misleading, because `EVENTS_REGISTRY`
    will have its final value at runtime, right after the module was imported, and
    we cannot easily predict its value by just looking at the code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很难阅读，甚至具有误导性，因为`EVENTS_REGISTRY`将在运行时具有其最终值，就在模块导入后，我们无法仅通过查看代码来轻松预测其值。
- en: While that is true, in some cases this pattern is justified. In fact, many web
    frameworks or well-known libraries use this to work and expose objects or make
    them available.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在某些情况下这种模式是合理的。事实上，许多Web框架或知名库使用这种模式来工作和公开对象或使它们可用。
- en: It is also true that in this case, the decorator is not changing the `wrapped`
    object, nor altering the way it works in any way. However, the important note
    here is that, if we were to do some modifications and define an internal function
    that modifies the `wrapped` object, we would still probably want the code that
    registers the resulting object outside it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，装饰器并没有改变`wrapped`对象，也没有以任何方式改变它的工作方式。然而，这里需要注意的是，如果我们进行一些修改并定义一个修改`wrapped`对象的内部函数，我们可能仍然希望在外部注册生成的对象的代码。
- en: Notice the use of the word *outside*. It does not necessarily mean before, it's
    just not part of the same closure; but it's in the outer scope, so it's not delayed
    until runtime.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用*outside*这个词。它不一定意味着之前，它只是不属于同一个闭包；但它在外部范围，因此不会延迟到运行时。
- en: Creating decorators that will always work
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建始终有效的装饰器
- en: There are several different scenarios to which decorators might apply. It can
    also be the case that we need to use the same decorator for objects that fall
    into these different multiple scenarios, for instance, if we want to reuse our
    decorator and apply it to a function, a class, a method, or a static method.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器可能适用于几种不同的情况。也可能出现这样的情况，我们需要对落入这些不同多种情况的对象使用相同的装饰器，例如，如果我们想重用我们的装饰器并将其应用于函数、类、方法或静态方法。
- en: If we create the decorator, just thinking about supporting only the first type
    of object we want to decorate, we might notice that the same decorator does not
    work equally well on a different type of object. The typical example is where
    we create a decorator to be used on a function, and then we want to apply it to
    a method of a class, only to realize that it does not work. A similar scenario
    might occur if we designed our decorator for a method, and then we want it to
    also apply for static methods or class methods.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建装饰器，只考虑支持我们想要装饰的第一种对象类型，我们可能会注意到相同的装饰器在不同类型的对象上效果不同。典型的例子是，我们创建一个用于函数的装饰器，然后想将其应用于类的方法，结果发现它不起作用。如果我们为方法设计了装饰器，然后希望它也适用于静态方法或类方法，可能会发生类似的情况。
- en: When designing decorators, we typically think about reusing code, so we will
    want to use that decorator for functions and methods as well.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计装饰器时，我们通常考虑重用代码，因此我们也希望将该装饰器用于函数和方法。
- en: 'Defining our decorators with the signature `*args`, and `**kwargs`, will make
    them work in all cases, because it''s the most generic kind of signature that
    we can have. However, sometimes we might want not to use this, and instead define
    the decorator wrapping function according to the signature of the original function,
    mainly because of two reasons:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`*args`和`**kwargs`签名定义我们的装饰器将使它们在所有情况下都起作用，因为这是我们可以拥有的最通用的签名。然而，有时我们可能不想使用这个，而是根据原始函数的签名定义装饰器包装函数，主要是因为两个原因：
- en: It will be more readable since it resembles the original function.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将更易读，因为它类似于原始函数。
- en: It actually needs to do something with the arguments, so receiving `*args` and
    `**kwargs` wouldn't be convenient.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它实际上需要对参数进行一些处理，因此接收`*args`和`**kwargs`将不方便。
- en: Consider the case on which we have many functions in our code base that require
    a particular object to be created from a parameter. For instance, we pass a string,
    and initialize a driver object with it, repeatedly. Then we think we can remove
    the duplication by using a decorator that will take care of converting this parameter
    accordingly.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们的代码库中有许多函数需要从参数创建特定对象的情况。例如，我们传递一个字符串，并重复使用它初始化一个驱动程序对象。然后我们认为可以通过使用一个装饰器来消除这种重复。
- en: In the next example, we pretend that `DBDriver` is an object that knows how
    to connect and run operations on a database, but it needs a connection string.
    The methods we have in our code, are designed to receive a string with the information
    of the database and require to create an instance of `DBDriver` always. The idea
    of the decorator is that it's going to take place of this conversion automatically—the
    function will continue to receive a string, but the decorator will create a `DBDriver`
    and pass it to the function, so internally we can assume that we receive the object
    we need directly.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我们假设`DBDriver`是一个知道如何连接和在数据库上运行操作的对象，但它需要一个连接字符串。我们在我们的代码中有的方法，都设计为接收包含数据库信息的字符串，并且总是需要创建一个`DBDriver`实例。装饰器的想法是它将自动进行这种转换——函数将继续接收一个字符串，但装饰器将创建一个`DBDriver`并将其传递给函数，因此在内部我们可以假设我们直接接收到了我们需要的对象。
- en: 'An example of using this in a function is shown in the next listing:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个清单中展示了在函数中使用这个的例子：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It''s easy to verify that if we pass a string to the function, we get the result
    done by an instance of `DBDriver`, so the decorator works as expected:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易验证，如果我们将一个字符串传递给函数，我们会得到一个`DBDriver`实例完成的结果，所以装饰器的工作是符合预期的：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'But now, we want to reuse this same decorator in a class method, where we find
    the same problem:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，我们想在类方法中重用这个相同的装饰器，我们发现了同样的问题：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We try to use this decorator, only to realize that it doesn''t work:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试使用这个装饰器，只是意识到它不起作用：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: What is the problem?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是什么？
- en: The method in the class is defined with an extra argument—`self`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的方法是用额外的参数`self`定义的。
- en: Methods are just a particular kind of function that receives `self` (the object
    they're defined upon) as the first parameter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 方法只是一种特殊类型的函数，它接收`self`（它们所定义的对象）作为第一个参数。
- en: Therefore, in this case, the decorator (designed to work with only one parameter,
    named `dbstring`), will interpret that `self` is said parameter, and call the
    method passing the string in the place of self, and nothing in the place for the
    second parameter, namely the string we are passing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，装饰器（设计为仅适用于名为`dbstring`的参数）将解释`self`是所说的参数，并调用该方法传递字符串作为self的位置，以及在第二个参数的位置上什么都不传，即我们正在传递的字符串。
- en: To fix this issue, we need to create a decorator that will work equally for
    methods and functions, and we do so by defining this as a decorator object, that
    also implements the protocol descriptor.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要创建一个装饰器，它可以同时适用于方法和函数，我们通过将其定义为一个装饰器对象来实现这一点，该对象还实现了协议描述符。
- en: Descriptors are fully explained in [Chapter 7](32503c77-5ff2-4d35-af0e-8d9300cfa357.xhtml), *Using
    Generators*, so, for now, we can just take this as a recipe that will make the
    decorator work.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符在[第7章](32503c77-5ff2-4d35-af0e-8d9300cfa357.xhtml)中有详细解释，*使用生成器*，所以，现在，我们可以将其视为一个可以使装饰器工作的配方。
- en: The solution is to implement the decorator as a class object and make this object
    a description, by implementing the `__get__` method.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将装饰器实现为一个类对象，并使该对象成为一个描述符，通过实现`__get__`方法。
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Details on descriptors will be explained in [Chapter 6](1091614c-9831-4645-aaa6-140ae13f08d8.xhtml), *Getting
    More Out of Our Objects with Descriptors*, but for the purposes of this example,
    we can now say that what it does is actually rebinding the callable it's decorating
    to a method, meaning that it will bind the function to the object, and then recreate
    the decorator with this new callable.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符的详细信息将在[第6章](1091614c-9831-4645-aaa6-140ae13f08d8.xhtml)中解释，*使用描述符更充分地利用我们的对象*，但是对于这个例子的目的，我们现在可以说它实际上是将它装饰的可调用对象重新绑定到一个方法，这意味着它将函数绑定到对象，然后使用这个新的可调用对象重新创建装饰器。
- en: For functions, it still works, because it won't call the `__get__` method at
    all.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数，它仍然有效，因为它根本不会调用`__get__`方法。
- en: The DRY principle with decorators
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器与DRY原则
- en: We have seen how decorators allow us to abstract away certain logic into a separate
    component. The main advantage of this is that we can then apply the decorator
    multiple times into different objects in order to reuse code. This follows the
    **Don't Repeat Yourself** (**DRY**) principle since we define certain knowledge
    once and only once.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到装饰器如何允许我们将某些逻辑抽象成一个单独的组件。这样做的主要优势是我们可以多次应用装饰器到不同的对象中，以便重用代码。这遵循了**不要重复自己**（**DRY**）原则，因为我们只定义了某些知识一次。
- en: The `retry` mechanism implemented in the previous sections is a good example
    of a decorator that can be applied multiple times to reuse code. Instead of making
    each particular function include its `retry` logic, we create a decorator and
    apply it several times. This makes sense once we have made sure that the decorator
    can work with methods and functions equally.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中实现的“重试”机制是一个很好的例子，它是一个可以多次应用以重用代码的装饰器。我们不是让每个特定的函数包含其“重试”逻辑，而是创建一个装饰器并多次应用它。一旦我们确保装饰器可以同样适用于方法和函数，这就是有意义的。
- en: The class decorator that defined how events are to be represented also complies
    with the DRY principle in the sense that it defines one specific place for the
    logic for serializing an event, without needing to duplicate code scattered among
    different classes. Since we expect to reuse this decorator and apply it to many
    classes, its development (and complexity) pay off.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了事件如何表示的类装饰器也符合DRY原则，因为它定义了一个特定的位置来序列化事件的逻辑，而无需在不同的类中重复代码。由于我们希望重用这个装饰器并将其应用于许多类，它的开发（和复杂性）是值得的。
- en: This last remark is important to bear in mind when trying to use decorators
    in order to reuse code—we have to be absolutely sure that we will actually be
    saving code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试使用装饰器来重用代码时，这最后一点很重要——我们必须绝对确定我们实际上将节省代码。
- en: Any decorator (especially if it is not carefully designed) adds another level
    of indirection to the code, and hence more complexity. Readers of the code might
    want to follow the path of the decorator to fully understand the logic of the
    function (although these considerations are addressed in the following section),
    so keep in mind that this complexity has to pay off. If there is not going to
    be too much reuse, then do not go for a decorator and opt for a simpler option
    (maybe just a separate function or another small class is enough).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 任何装饰器（特别是如果设计不慎）都会给代码增加另一层间接性，因此会增加更多的复杂性。代码的读者可能希望跟踪装饰器的路径以充分理解函数的逻辑（尽管这些考虑在下一节中有所解决），因此请记住这种复杂性必须得到回报。如果不会有太多的重用，那么不要选择装饰器，而选择一个更简单的选项（也许只是一个单独的函数或另一个小类就足够了）。
- en: But how do we know what too much reuse is? Is there a rule to determine when
    to refactor existing code into a decorator? There is nothing specific to decorators
    in Python, but we could apply a general rule of thumb in software engineering
    (GLASS 01) that states that a component should be tried out at least three times
    before considering creating a generic abstraction in the sort of a reusable component.
    From the same reference (GLASS 01); (we encourage all readers to read *Facts and
    Fallacies of Software Engineering* because it is a great reference) also comes
    the idea that creating reusable components is three times harder than creating
    simple ones.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何知道太多的重用是什么？有没有规则来确定何时将现有代码重构为装饰器？在Python中，没有特定于装饰器的规则，但我们可以应用软件工程中的一个经验法则（GLASS
    01），该法则规定在考虑创建可重用组件之前，应该至少尝试三次使用组件。从同一参考资料（GLASS 01）中还得出了一个观点，即创建可重用组件比创建简单组件困难三倍。
- en: 'The bottom line is that reusing code through decorators is acceptable, but
    only when you take into account the following considerations:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是，通过装饰器重用代码是可以接受的，但只有在考虑以下几点时才可以：
- en: Do not create the decorator in the first place from scratch. Wait until the
    pattern emerges and the abstraction for the decorator becomes clear, and then
    refactor.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要从头开始创建装饰器。等到模式出现并且装饰器的抽象变得清晰时再进行重构。
- en: Consider that the decorator has to be applied several times (at least three
    times) before implementing it.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到装饰器必须被应用多次（至少三次）才能实施。
- en: Keep the code in the decorators to a minimum.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将装饰器中的代码保持在最小限度。
- en: Decorators and separation of concerns
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器和关注点分离
- en: The last point on the previous list is so important that it deserves a section
    of its own. We have already explored the idea of reusing code and noticed that
    a key element of reusing code is having components that are cohesive. This means
    that they should have the minimum level of responsibility—do one thing, one thing
    only, and do it well. The smaller our components, the more reusable, and the more
    they can be applied in a different context without carrying extra behavior that
    will cause coupling and dependencies, which will make the software rigid.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 前面列表中的最后一点非常重要，值得单独一节来讨论。我们已经探讨了重用代码的想法，并注意到重用代码的一个关键元素是具有内聚性的组件。这意味着它们应该具有最小的责任水平——只做一件事，只做一件事，并且做得很好。我们的组件越小，就越可重用，也越能在不同的上下文中应用，而不会带有额外的行为，这将导致耦合和依赖，使软件变得僵化。
- en: 'To show you what this means, let''s reprise one of the decorators that we used
    in a previous example. We created a decorator that traced the execution of certain
    functions with code similar to the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向您展示这意味着什么，让我们回顾一下我们在先前示例中使用的装饰器之一。我们创建了一个装饰器，用类似以下代码的方式跟踪了某些函数的执行：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, this decorator, while it works, has a problem—it is doing more than one
    thing. It logs that a particular function was just invoked, and also logs how
    much time it took to run. Every time we use this decorator, we are carrying these
    two responsibilities, even if we only wanted one of them.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个装饰器虽然有效，但存在一个问题——它做了不止一件事。它记录了特定函数的调用，并记录了运行所花费的时间。每次使用这个装饰器，我们都要承担这两个责任，即使我们只想要其中一个。
- en: 'This should be broken down into smaller decorators, each one with a more specific
    and limited responsibility:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该被分解成更小的装饰器，每个装饰器都有更具体和有限的责任：
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Notice that the same functionality that we had previously can be achieved by
    simply combining both of them:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们之前所拥有的相同功能可以通过简单地将它们结合起来来实现：
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice how the order in which the decorators are applied is also important.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意装饰器的应用顺序也很重要。
- en: Do not place more than one responsibility in a decorator. The SRP applies to
    decorators as well.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在一个装饰器中放置多个责任。单一责任原则也适用于装饰器。
- en: Analyzing good decorators
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析好的装饰器
- en: As a closing note for this chapter, let's review some examples of good decorators
    and how they are used both in Python itself, as well as in popular libraries.
    The idea is to get guidelines on how good decorators are created.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的结束语，让我们回顾一些好的装饰器的示例以及它们在Python本身以及流行库中的用法。这个想法是获得如何创建好的装饰器的指导方针。
- en: 'Before jumping into examples, let''s first identify traits that good decorators
    should have:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在跳入示例之前，让我们首先确定好的装饰器应该具有的特征：
- en: '**Encapsulation, or separation of concerns**: A good decorator should effectively
    separate different responsibilities between what it does and what it is decorating.
    It cannot be a leaky abstraction, meaning that a client of the decorator should
    only invoke it in black box mode, without knowing how it is actually implementing
    its logic.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装，或关注点分离**：一个好的装饰器应该有效地将它所做的事情和它所装饰的事物之间的不同责任分开。它不能是一个有漏洞的抽象，这意味着装饰器的客户端应该只以黑盒模式调用它，而不知道它实际上是如何实现其逻辑的。'
- en: '**Orthogonality**: What the decorator does should be independent, and as decoupled
    as possible from the object it is decorating.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正交性**：装饰器所做的事情应该是独立的，并且尽可能与它所装饰的对象解耦。'
- en: '**Reusability**: It is desirable that the decorator can be applied to multiple
    types, and not that it just appears on one instance of one function, because that
    means that it could just have been a function instead. It has to be generic enough.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：希望装饰器可以应用于多种类型，而不仅仅出现在一个函数的一个实例上，因为这意味着它本来可以只是一个函数。它必须足够通用。'
- en: 'A nice example of decorators can be found in the Celery project, where a `task`
    is defined by applying the decorator of the `task` from the application to a function:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器的一个很好的例子可以在Celery项目中找到，其中通过将应用程序的`task`装饰器应用到一个函数来定义`task`：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: One of the reasons why this is a good decorator is because it is very good at
    something—encapsulation. The user of the library only needs to define the function
    body and the decorator will convert that into a task automatically. The `"@app.task"`
    decorator surely wraps a lot of logic and code, but none of that is relevant to
    the body of `"mytask()"`. It is complete encapsulation and separation of concerns—nobody
    will have to take a look at what that decorator does, so it is a correct abstraction
    that does not leak any details.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好的装饰器的原因之一是因为它在封装方面非常出色。库的用户只需要定义函数体，装饰器就会自动将其转换为一个任务。`"@app.task"`装饰器肯定包含了大量的逻辑和代码，但这些对`"mytask()"`的主体来说都不相关。这是完全的封装和关注点分离——没有人需要查看装饰器在做什么，因此它是一个不泄漏任何细节的正确抽象。
- en: 'Another common use of decorators is in web frameworks (Pyramid, Flask, and
    Sanic, just to name a few), on which the handlers for views are registered to
    the URLs through decorators:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器的另一个常见用法是在Web框架（例如Pyramid，Flask和Sanic等）中，通过装饰器将视图的处理程序注册到URL：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: These sorts of decorator have the same considerations as before; they also provide
    total encapsulation because a user of the web framework rarely (if ever) needs
    to know what the `"@route"` decorator is doing. In this case, we know that the
    decorator is doing something more, such as registering these functions to a mapper
    to the URL, and also that it is changing the signature of the original function
    to provide us with a nicer interface that receives a request object with all the
    information already set.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的装饰器与之前的考虑相同；它们也提供了完全的封装，因为Web框架的用户很少（如果有的话）需要知道`"@route"`装饰器在做什么。在这种情况下，我们知道装饰器正在做更多的事情，比如将这些函数注册到URL的映射器上，并且它还改变了原始函数的签名，以便为我们提供一个更好的接口，接收一个已经设置好所有信息的请求对象。
- en: The previous two examples are enough to make us notice something else about
    this use of decorators. They conform to an API. These libraries of frameworks
    are exposing their functionality to users through decorators, and it turns out
    that decorators are an excellent way of defining a clean programming interface.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的两个例子足以让我们注意到关于装饰器的这种用法的另一点。它们符合API。这些库或框架通过装饰器向用户公开其功能，结果表明装饰器是定义清晰的编程接口的绝佳方式。
- en: This is probably the best way we should think about to decorators. Much like
    in the example of the class decorator that tells us how the attributes of the
    event are going to be handled, a good decorator should provide a clean interface
    so that users of the code know what to expect from the decorator, without needing
    to know how it works, or any of its details for that matter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是我们应该考虑装饰器的最佳方式。就像在告诉我们事件属性将如何被处理的类装饰器的示例中一样，一个好的装饰器应该提供一个清晰的接口，以便代码的用户知道可以从装饰器中期望什么，而不需要知道它是如何工作的，或者它的任何细节。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Decorators are powerful tools in Python that can be applied to many things such
    as classes, methods, functions, generators, and many more. We have demonstrated
    how to create decorators in different ways, and for different purposes, and drew
    some conclusions along the way.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是Python中强大的工具，可以应用于许多事物，如类、方法、函数、生成器等。我们已经演示了如何以不同的方式创建装饰器，以及不同的目的，并在这个过程中得出了一些结论。
- en: When creating a decorator for functions, try to make its signature match the
    original function being decorated. Instead of using the generic `*args`, and `**kwargs`,
    making the signature match the original one will make it easier to read, and maintain,
    and it will resemble the original function more closely, so it will be more familiar
    to readers of that code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在为函数创建装饰器时，尝试使其签名与被装饰的原始函数匹配。与使用通用的`*args`和`**kwargs`不同，使签名与原始函数匹配将使其更容易阅读和维护，并且它将更接近原始函数，因此对于代码的读者来说更加熟悉。
- en: Decorators are a very useful tool for reusing code and following the DRY principle.
    However, their usefulness comes at a cost, and if they are not used wisely, the
    complexity can do more harm than good. For that reason, we emphasize that decorators
    should be used when they are actually going to be applied multiple times (three
    or more times). In the same way as the DRY principle, we find the ideas of separation
    of concerns, with the goal of keeping the decorators as small as possible.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是重用代码和遵循DRY原则的非常有用的工具。然而，它们的有用性是有代价的，如果不明智地使用，复杂性可能会带来更多的害处。因此，我们强调装饰器应该在实际上会被多次应用（三次或更多次）时使用。与DRY原则一样，我们发现关注点分离的想法，目标是尽可能保持装饰器的小巧。
- en: Another good use of decorators is to create cleaner interfaces, for instance,
    simplifying the definition of a class by extracting part of its logic into a decorator.
    In this sense, decorators also help readability by providing the users with information
    about what that particular component will be doing, without needing to know how
    (encapsulation).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的装饰器用法是创建更清晰的接口，例如，通过将类的一部分逻辑提取到装饰器中来简化类的定义。在这个意义上，装饰器还通过提供关于特定组件将要做什么的信息来帮助可读性，而不需要知道如何做（封装）。
- en: In the next chapter, we will take a look at another advanced feature of Python—descriptors.
    In particular, we will see how with the help of descriptors we can create even
    better decorators, and solve some of the issues we encountered in this chapter.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看Python的另一个高级特性——描述符。特别是，我们将看到如何借助描述符创建更好的装饰器，并解决本章遇到的一些问题。
- en: References
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Here is a list of information you can refer to:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以参考的信息列表：
- en: '*PEP-318*: Decorators for Functions and Methods ([https://www.python.org/dev/peps/pep-0318/](https://www.python.org/dev/peps/pep-0318/))'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-318*：函数和方法的装饰器（[https://www.python.org/dev/peps/pep-0318/](https://www.python.org/dev/peps/pep-0318/)）'
- en: '*PEP-3129*:Class Decorators ([https://www.python.org/dev/peps/pep-3129/](https://www.python.org/dev/peps/pep-3129/))'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-3129*：类装饰器（[https://www.python.org/dev/peps/pep-3129/](https://www.python.org/dev/peps/pep-3129/)）'
- en: '*WRAPT 01*: [https://pypi.org/project/wrapt/](https://pypi.org/project/wrapt/)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WRAPT 01*：[https://pypi.org/project/wrapt/](https://pypi.org/project/wrapt/)'
- en: '*WRAPT 02*: [https://wrapt.readthedocs.io/en/latest/decorators.html#universal-decorators](https://wrapt.readthedocs.io/en/latest/decorators.html#universal-decorators)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WRAPT 02*：[https://wrapt.readthedocs.io/en/latest/decorators.html#universal-decorators](https://wrapt.readthedocs.io/en/latest/decorators.html#universal-decorators)'
- en: '*The Functools module*: The `wraps` function in the `functools` module of Python''s
    standard library ([https://docs.python.org/3/library/functools.html#functools.wrap](https://docs.python.org/3/library/functools.html#functools.wraps))'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Functools模块*：Python标准库中`functools`模块中的`wraps`函数（[https://docs.python.org/3/library/functools.html#functools.wrap](https://docs.python.org/3/library/functools.html#functools.wraps)）'
- en: '*ATTRS 01:* The `attrs` library ([https://pypi.org/project/attrs/](https://pypi.org/project/attrs/))'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ATTRS 01*：`attrs`库（[https://pypi.org/project/attrs/](https://pypi.org/project/attrs/)）'
- en: '*PEP-557*: Data Classes ([https://www.python.org/dev/peps/pep-0557/](https://www.python.org/dev/peps/pep-0557/))'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-557*：数据类（[https://www.python.org/dev/peps/pep-0557/](https://www.python.org/dev/peps/pep-0557/)）'
- en: '*GLASS 01*: The book written by Robert L. Glass named *Facts and Fallacies
    of Software Engineering*'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GLASS 01*：Robert L. Glass撰写的书籍*软件工程的事实和谬误*'
