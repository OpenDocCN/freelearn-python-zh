- en: Debugging and Troubleshooting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和故障排除
- en: '"If debugging is the process of removing software bugs, then programming must
    be the process of putting them in."– Edsger W. Dijkstra'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “如果调试是消除软件错误的过程，那么编程一定是引入错误的过程。”- Edsger W. Dijkstra
- en: In the life of a professional coder, debugging and troubleshooting take up a
    significant amount of time. Even if you work on the most beautiful code base ever
    written by a human, there will still be bugs in it; that is guaranteed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在专业程序员的生活中，调试和故障排除占据了相当大的时间。即使你在人类编写的最美丽的代码库上工作，仍然会有错误；这是肯定的。
- en: We spend an awful lot of time reading other people's code and, in my opinion,
    a good software developer is someone who keeps their attention high, even when
    they're reading code that is not reported to be wrong or buggy.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的观点中，一个优秀的软件开发人员是一个即使在阅读没有报告错误或错误的代码时也能保持高度关注的人。
- en: Being able to debug code efficiently and quickly is a skill that every coder
    needs to keep improving. Some think that because they have read the manual, they're
    fine, but the reality is, the number of variables in the game is so great that
    there is no manual. There are guidelines one can follow, but there is no magic
    book that will teach you everything you need to know in order to become good at
    this.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 能够高效快速地调试代码是每个程序员都需要不断提高的技能。有些人认为因为他们已经阅读了手册，所以没问题，但现实是，游戏中的变量数量如此之大，以至于没有手册。有一些指导方针可以遵循，但没有一本魔法书会教你所有你需要知道的东西，以便成为这方面的专家。
- en: I feel that on this particular subject, I have learned the most from my colleagues.
    It amazes me to observe someone very skilled attacking a problem. I enjoy seeing
    the steps they take, the things they verify to exclude possible causes, and the
    way they consider the suspects that eventually lead them to a solution.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的主题上，我觉得我从同事那里学到了最多。观察一个非常熟练的人攻击问题让我感到惊讶。我喜欢看到他们采取的步骤，验证排除可能的原因，以及他们考虑嫌疑人的方式，最终导致他们找到解决方案。
- en: Every colleague we work with can teach us something, or surprise us with a fantastic
    guess that turns out to be the right one. When that happens, don't just remain
    in wonderment (or worse, in envy), but seize the moment and ask them how they
    got to that guess and why. The answer will allow you to see whether there is something
    you can study in-depth later on so that, maybe next time, you'll be the one who
    will catch the bug.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与之合作的每个同事都可以教给我们一些东西，或者用一个最终证明是正确的奇妙猜测让我们感到惊讶。当这种情况发生时，不要只停留在惊讶中（或者更糟糕的是嫉妒），而是抓住这一刻，问问他们是如何猜到的，以及为什么。答案将让你看到是否有一些东西你可以后来深入研究，也许下一次，你就是那个发现问题的人。
- en: Some bugs are very easy to spot. They come out of coarse mistakes and, once
    you see the effects of those mistakes, it's easy to find a solution that fixes
    the problem.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有些错误很容易发现。它们是由粗心的错误造成的，一旦你看到这些错误的影响，很容易找到解决问题的方法。
- en: But there are other bugs that are much more subtle, much more slippery, and
    require true expertise, and a great deal of creativity and out-of-the-box thinking,
    to be dealt with.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有其他一些错误要微妙得多，更加难以捉摸，需要真正的专业知识，以及大量的创造力和超越常规的思维来处理。
- en: The worst of all, at least for me, are the nondeterministic ones. These sometimes
    happen, and sometimes don't. Some happen only in environment A but not in environment
    B, even though A and B are supposed to be exactly the same. Those bugs are the
    truly evil ones, and they can drive you crazy.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，最糟糕的是那些不确定的错误。有时会发生，有时不会。有些只在环境A中发生，但在环境B中却没有，尽管A和B应该是完全相同的。这些错误是真正邪恶的，它们会让你发疯。
- en: And of course, bugs don't just happen in the sandbox, right? With your boss
    telling you, *"Don't worry! Take your time to fix this. Have lunch first!"* Nope.
    They happen on a Friday at half past five, when your brain is cooked and you just
    want to go home. It's in those moments when everyone is getting upset in a split
    second, when your boss is breathing down your neck, that you have to be able to
    keep calm. And I do mean it. That's the most important skill to have if you want
    to be able to fight bugs effectively. If you allow your mind to get stressed,
    say goodbye to creative thinking, to logical deduction, and to everything you
    need at that moment. So take a deep breath, sit properly, and focus.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，错误不仅仅发生在沙盒中，对吧？当你的老板告诉你，“别担心！花点时间解决这个问题。先吃午饭！”的时候，不。它们发生在星期五下午五点半，当你的大脑已经烧坏，你只想回家的时候。就在那些每个人都在瞬间变得沮丧的时刻，当你的老板在你身边喘着气的时候，你必须能够保持冷静。我是认真的。如果你让自己的大脑感到紧张，那么创造性思维、逻辑推理以及你在那一刻所需要的一切都会消失。所以深呼吸，端正坐姿，集中注意力。
- en: In this chapter, I will try to demonstrate some useful techniques that you can
    employ according to the severity of the bug, and a few suggestions that will hopefully
    boost your weapons against bugs and issues.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我将尝试演示一些有用的技术，根据错误的严重程度，以及一些建议，希望能够增强你对错误和问题的解决能力。
- en: 'Specifically, we''re going to look at the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将看一下以下内容：
- en: Debugging techniques
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试技术
- en: Profiling
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析
- en: Assertions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言
- en: Troubleshooting guidelines
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除指南
- en: Debugging techniques
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试技术
- en: In this part, I'll present you with the most common techniques, the ones I use
    most often; however, please don't consider this list to be exhaustive.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我将向你介绍最常见的技术，我经常使用的技术；但是，请不要认为这个列表是详尽无遗的。
- en: Debugging with print
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用打印进行调试
- en: This is probably the easiest technique of all. It's not very effective, it cannot
    be used everywhere, and it requires access to both the source code and a Terminal
    that will run it (and therefore show the results of the `print` function calls).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是所有技术中最简单的技术。它并不是非常有效，不能在所有地方使用，需要同时访问源代码和一个能运行它的终端（因此显示`print`函数调用结果）。
- en: However, in many situations, this is still a quick and useful way to debug.
    For example, if you are developing a Django website and what happens in a page
    is not what you would expect, you can fill the view with prints and keep an eye
    on the console while you reload the page. When you scatter calls to `print` in
    your code, you normally end up in a situation where you duplicate a lot of debugging
    code, either because you're printing a timestamp (like we did when we were measuring
    how fast list comprehensions and generators were), or because you have somehow
    to build a string of some sort that you want to display.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多情况下，这仍然是一种快速和有用的调试方式。例如，如果你正在开发一个Django网站，页面上发生的情况与你的预期不符，你可以在视图中填充打印，并在重新加载页面时留意控制台。当你在代码中散布调用`print`时，通常会出现这样的情况，你会重复大量的调试代码，要么是因为你正在打印时间戳（就像我们在测量列表推导和生成器的速度时所做的那样），要么是因为你不得不以某种方式构建一个你想要显示的字符串。
- en: Another issue is that it's extremely easy to forget calls to `print` in your
    code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是，在你的代码中很容易忘记调用`print`。
- en: So, for these reasons, rather than using a bare call to `print`, I sometimes
    prefer to code a custom function. Let's see how.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，出于这些原因，我有时候更喜欢编写自定义函数，而不是直接调用`print`。让我们看看如何做。
- en: Debugging with a custom function
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义函数进行调试
- en: Having a custom function in a snippet that you can quickly grab and paste into
    the code, and then use to debug, can be very useful. If you're fast, you can always
    code one on the fly. The important thing is to code it in a way that it won't
    leave stuff around when you eventually remove the calls and its definition. Therefore
    *it's important to code it in a way that is completely self-contained*. Another
    good reason for this requirement is that it will avoid potential name clashes
    with the rest of the code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个片段中有一个自定义函数，你可以快速抓取并粘贴到代码中，然后用于调试，这是非常有用的。如果你很快，你总是可以即兴编写一个。重要的是以一种不会在最终删除调用和定义时留下东西的方式编写它。因此*以一种完全自包含的方式编写它是很重要的*。这个要求的另一个很好的理由是它将避免与代码的其余部分潜在的名称冲突。
- en: 'Let''s see an example of such a function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个这样的函数的例子：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this case, I am using a keyword-only argument to be able to print a separator,
    which is a line of `40` dashes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我使用了一个仅限关键字的参数，以便能够打印一个分隔符，这是一个由`40`个破折号组成的行。
- en: 'The function is very simple. I just redirect whatever is in `msg` to a call
    to `print` and, if `print_separator` is `True`, I print a line separator. Running
    the code will show the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常简单。我只是将`msg`中的任何内容重定向到对`print`的调用，如果`print_separator`为`True`，我会打印一条分隔线。运行代码将显示以下内容：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, there is no separator after the last line.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，最后一行后面没有分隔符。
- en: 'This is just one easy way to somehow augment a simple call to the `print` function.
    Let''s see how we can calculate a time difference between calls, using one of
    Python''s tricky features to our advantage:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一种简单的方法，以某种方式增强对`print`函数的简单调用。让我们看看如何利用Python的一个棘手特性来计算调用之间的时间差：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a bit trickier, but still quite simple. First, notice we import the
    `time` function from the `time` module from inside the `debug` function. This
    allows us to avoid having to add that import outside of the function, and maybe
    forget it there.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点棘手，但仍然相当简单。首先，注意我们从`debug`函数内部的`time`模块中导入`time`函数。这使我们避免了在函数外部添加该导入，也许会忘记在那里添加。
- en: Take a look at how I defined `timestamp`. It's a list, of course, but what's
    important here is that it is a **mutable** object. This means that it will be
    set up when Python parses the function and it will retain its value throughout
    different calls. Therefore, if we put a timestamp in it after each call, we can
    keep track of time without having to use an external global variable. I borrowed
    this trick from my studies on **closures**, a technique that I encourage you to
    read about because it's very interesting.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下我是如何定义`timestamp`的。当然，它是一个列表，但这里重要的是它是一个**可变**对象。这意味着当Python解析函数时，它将被设置，并且在不同的调用中保留其值。因此，如果我们在每次调用后都放一个时间戳，我们就可以跟踪时间，而不必使用外部全局变量。我从我的**闭包**研究中借鉴了这个技巧，我鼓励你去了解一下，因为它非常有趣。
- en: Right, so, after having printed whatever message we had to print and some importing
    time, we then inspect the content of the only item in `timestamp`. If it is `None`,
    we have no previous reference, therefore we set the value to the current time
    (`#1`).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，所以，在打印出我们必须打印的任何消息和一些导入时间之后，我们检查`timestamp`中的唯一项的内容。如果它是`None`，我们没有先前的引用，因此我们将值设置为当前时间（`#1`）。
- en: On the other hand, if we have a previous reference, we can calculate a difference
    (which we nicely format to three decimal digits) and then we finally put the current
    time again in `timestamp` (`#2`). It's a nice trick, isn't it?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们有一个先前的引用，我们可以计算一个差值（我们很好地格式化为三个小数位），然后我们最终再次将当前时间放入`timestamp`（`#2`）。这是一个很好的技巧，不是吗？
- en: 'Running this code shows this result:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码会显示以下结果：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Whatever your situation, having a self-contained function like this can be very
    useful.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的情况如何，拥有一个像这样的自包含函数可能非常有用。
- en: Inspecting the traceback
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查回溯
- en: 'We briefly talked about the traceback in [Chapter 8](part0211.html#6976M0-2ddb708647cc4530a187c2c6c0e9acfe), *Testing,
    Profiling, and Dealing with Exceptions*, when we saw several different kinds of
    exceptions. The traceback gives you information about what went wrong in your
    application. It''s helpful to read it, so let''s see a small example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第8章](part0211.html#6976M0-2ddb708647cc4530a187c2c6c0e9acfe)中简要讨论了回溯，*测试、分析和处理异常*，当我们看到了几种不同类型的异常。回溯提供了关于应用程序出了什么问题的信息。阅读它是有帮助的，所以让我们看一个小例子：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have a dictionary and we try to access a key that isn''t in it. You should
    remember that this will raise a `KeyError` exception. Let''s run the code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个字典，我们尝试访问其中不存在的键。你应该记住这将引发一个`KeyError`异常。让我们运行代码：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can see that we get all the information we need: the module name, the line
    that caused the error (both the number and the instruction), and the error itself.
    With this information, you can go back to the source code and try to understand
    what''s going on.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们获得了所有需要的信息：模块名称，导致错误的行（数字和指令），以及错误本身。有了这些信息，您可以返回到源代码并尝试理解发生了什么。
- en: 'Let''s now create a more interesting example that builds on top of this, and
    exercises a feature that is only available in Python 3\. Imagine that we''re validating
    a dictionary, working on mandatory fields, therefore we expect them to be there.
    If not, we need to raise a custom `ValidationError` that we will trap further
    upstream in the process that runs the validator (which is not shown here, so it
    could be anything, really). It should be something like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个更有趣的例子，基于此构建，并练习Python 3中才有的一个特性。假设我们正在验证一个字典，处理必填字段，因此我们希望它们存在。如果没有，我们需要引发一个自定义的`ValidationError`，我们将在运行验证器的过程中进一步捕获它（这里没有显示，所以它可能是任何东西）。应该是这样的：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We define a custom exception that is raised when the mandatory key isn't there.
    Note that its body consists of its documentation string, so we don't need to add
    any other statements.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个自定义异常，当必需的键不存在时会引发该异常。请注意，它的主体由其文档字符串组成，因此我们不需要添加任何其他语句。
- en: Very simply, we define a dummy dict and try to access it using `mandatory_key`.
    We trap `KeyError` and raise `ValidatorError` when that happens. And we do it
    by using the `raise ... from ...` syntax, which was introduced in Python 3 by
    PEP 3134 ([https://www.python.org/dev/peps/pep-3134/](https://www.python.org/dev/peps/pep-3134/)),
    to chain exceptions. The purpose of doing this is that we may also want to raise
    `ValidatorError` in other circumstances, not necessarily as a consequence of a
    mandatory key being missing. This technique allows us to run the validation in
    a simple `try`/`except` that only cares about `ValidatorError`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单，我们定义了一个虚拟字典，并尝试使用`mandatory_key`访问它。当发生`KeyError`时，我们捕获并引发`ValidatorError`。我们通过使用Python
    3中由PEP 3134（[https://www.python.org/dev/peps/pep-3134/](https://www.python.org/dev/peps/pep-3134/)）引入的`raise
    ... from ...`语法来实现这一点，以链接异常。这样做的目的是，我们可能还想在其他情况下引发`ValidatorError`，不一定是由于缺少必需的键而引起的。这种技术允许我们在一个简单的`try`/`except`中运行验证，只关心`ValidatorError`。
- en: 'Without being able to chain exceptions, we would lose information about `KeyError`. The
    code produces this result:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不能链接异常，我们将丢失关于`KeyError`的信息。代码产生了这个结果：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is brilliant, because we can see the traceback of the exception that led
    us to raise `ValidationError`, as well as the traceback for the `ValidationError`
    itself.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，因为我们可以看到导致我们引发`ValidationError`的异常的回溯，以及`ValidationError`本身的回溯。
- en: I had a nice discussion with one of my reviewers about the traceback you get
    from the `pip` installer. He was having trouble setting everything up in order
    to review the code for [Chapter 13](part0324.html#9KVM80-2ddb708647cc4530a187c2c6c0e9acfe),
    *Data Science*. His fresh Ubuntu installation was missing a few libraries that
    were needed by the `pip` packages in order to run correctly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我和我的一位审阅者就`pip`安装程序产生的回溯进行了很好的讨论。他在设置一切以便审查[第13章](part0324.html#9KVM80-2ddb708647cc4530a187c2c6c0e9acfe)
    *数据科学*的代码时遇到了麻烦。他的新的Ubuntu安装缺少一些`pip`软件包所需的库，以便正确运行。
- en: The reason he was blocked was that he was trying to fix the errors displayed
    in the traceback starting from the top one. I suggested that he started from the
    bottom one instead, and fix that. The reason was that, if the installer had gotten
    to that last line, I guess that before that, whatever error may have occurred,
    it was still possible to recover from it. Only after the last line, `pip` decided
    it wasn't possible to continue any further, and therefore I started fixing that
    one. Once the libraries required to fix that error had been installed, everything
    else went smoothly.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 他被阻止的原因是，他试图修复回溯中显示的错误，从顶部开始。我建议他从底部开始，然后修复。原因是，如果安装程序已经到达最后一行，我猜在那之前，无论发生了什么错误，仍然有可能从中恢复。只有在最后一行之后，`pip`决定无法继续下去，因此我开始修复那个错误。一旦安装了修复该错误所需的库，其他一切都顺利进行。
- en: Reading a traceback can be tricky, and my friend was lacking the necessary experience
    to address this problem correctly. Therefore, if you end up in the same situation.
    Don't be discouraged, and try to shake things up a bit, don't take anything for
    granted.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读回溯可能会很棘手，我的朋友缺乏解决这个问题所需的经验。因此，如果您也遇到了同样的情况。不要灰心，试着摇动一下，不要想当然。
- en: Python has a huge and wonderful community and it's very unlikely that, when
    you encounter a problem, you're the first one to see it, so open a browser and
    search. By doing so, your searching skills will also improve because you will
    have to trim the error down to the minimum but essential set of details that will
    make your search effective.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个庞大而美妙的社区，很少有可能当您遇到问题时，您是第一个遇到它的人，所以打开浏览器并搜索。通过这样做，您的搜索技能也会得到提高，因为您将不得不将错误减少到最小但必要的详细信息集，以使您的搜索有效。
- en: If you want to play and understand the traceback a bit better, in the standard
    library there is a module you can use called, surprise surprise, `traceback`.
    It provides a standard interface to extract, format, and print stack traces of
    Python programs, mimicking the behavior of the Python interpreter when it prints
    a stack trace.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更好地玩耍和理解回溯，标准库中有一个模块可以使用，惊喜惊喜，名为`traceback`。它提供了一个标准接口，用于提取、格式化和打印Python程序的堆栈跟踪，模仿Python解释器在打印堆栈跟踪时的行为。
- en: Using the Python debugger
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python调试器
- en: 'Another very effective way of debugging Python is to use the Python debugger:
    `pdb`. Instead of using it directly though, you should definitely check out the
    `pdbpp` library. `pdbpp` augments the standard `pdb` interface by providing some
    convenient tools, my favorite of which is the **sticky mode**, which allows you
    to see a whole function while you step through its instructions.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 调试Python的另一个非常有效的方法是使用Python调试器：`pdb`。不过，您应该绝对检查`pdbpp`库，而不是直接使用它。`pdbpp`通过提供一些方便的工具来增强标准的`pdb`接口，其中我最喜欢的是**粘性模式**，它允许您在逐步执行其指令时查看整个函数。
- en: There are several different ways to use this debugger (whichever version, it's
    not important), but the most common one consists of simply setting a breakpoint
    and running the code. When Python reaches the breakpoint, execution is suspended
    and you get console access to that point so that you can inspect all the names,
    and so on. You can also alter data on the fly to change the flow of the program.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的使用调试器的方法（无论哪个版本，都不重要），但最常见的一种方法是简单地设置一个断点并运行代码。当Python达到断点时，执行将被暂停，并且您可以访问该点的控制台，以便您可以检查所有名称等。您还可以即时更改数据以改变程序的流程。
- en: 'As a toy example, let''s pretend we have a parser that is raising `KeyError`
    because a key is missing in a dictionary. The dictionary is from a JSON payload
    that we cannot control, and we just want, for the time being, to cheat and pass
    that control, since we''re interested in what comes afterward. Let''s see how
    we could intercept this moment, inspect the data, fix it, and get to the bottom
    of it, with `pdbpp`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个玩具示例，假设我们有一个解析器，因为字典中缺少一个键而引发`KeyError`。字典来自我们无法控制的JSON有效负载，我们只是想暂时欺骗并通过控制，因为我们对之后发生的事情感兴趣。让我们看看我们如何能拦截这一刻，检查数据，修复它，并深入了解，使用`pdbpp`：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, this code will break when `key` gets the `''third''` value,
    which is missing in the dictionary. Remember, we''re pretending that both `d`
    and `keys` come dynamically from a JSON payload we don''t control, so we need
    to inspect them in order to fix `d` and pass the `for` loop. If we run the code
    as it is, we get the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，当`key`获得`'third'`值时，代码将中断，这个值在字典中缺失。请记住，我们假装`d`和`keys`都是动态来自我们无法控制的JSON有效负载，因此我们需要检查它们以修复`d`并通过`for`循环。如果我们按原样运行代码，我们会得到以下结果：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So we see that that `key` is missing from the dictionary, but since every time
    we run this code we may get a different dictionary or `keys` tuple, this information
    doesn''t really help us. Let''s inject a call to `pdb` just before the `for` loop.
    You have two options:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们看到字典中缺少`key`，但由于每次运行此代码时我们可能会得到不同的字典或`keys`元组，这些信息并不能真正帮助我们。让我们在`for`循环之前注入一个`pdb`调用。您有两个选择：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is the most common way of doing it. You import `pdb` and call its `set_trace`
    method. Many developers have macros in their editor to add this line with a keyboard
    shortcut. As of Python 3.7 though, we can simplify things even further, to this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最常见的方法。您导入`pdb`并调用其`set_trace`方法。许多开发人员在其编辑器中有宏，可以通过键盘快捷键添加此行。不过，从Python 3.7开始，我们甚至可以进一步简化事情，变成这样：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The new `breakpoint` built-in function calls `sys.breakpointhook()` under the
    hood, which is programmed by default to call `pdb.set_trace()`. However, you can
    reprogram `sys.breakpointhook()` to call whatever you want, and therefore `breakpoint`
    will point to that too, which is very convenient.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`breakpoint`内置函数在底层调用`sys.breakpointhook()`，默认情况下编程为调用`pdb.set_trace()`。但是，您可以重新编程`sys.breakpointhook()`来调用任何您想要的东西，因此`breakpoint`也将指向那个东西，这非常方便。
- en: 'The code for this example is in the `pdebugger_pdb.py` module. If we now run
    this code, things get interesting (note that your output may vary a little and
    that all the comments in this output were added by me):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的代码位于`pdebugger_pdb.py`模块中。如果我们现在运行此代码，事情变得有趣起来（请注意，您的输出可能会有所不同，本输出中的所有注释都是我添加的）：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, note that when you reach a breakpoint, you're served a console that tells
    you where you are (the Python module) and which line is the next one to be executed.
    You can, at this point, perform a bunch of exploratory actions, such as inspecting
    the code before and after the next line, printing a stack trace, and interacting
    with the objects. Please consult the official Python documentation ([https://docs.python.org/3.7/library/pdb.html](https://docs.python.org/3.7/library/pdb.html))
    on `pdb` to learn more about this. In our case, we first inspect the `keys` tuple.
    After that, we inspect the keys of `d`. We see that `'third'` is missing, so we
    put it in ourselves (could this be dangerous—think about it). Finally, now that
    all the keys are in, we type `c`, which means (*c*)ontinue.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，当您达到断点时，会收到一个控制台，告诉您您所在的位置（Python模块）以及下一行要执行的行。在这一点上，您可以执行一系列的探索性操作，比如检查下一行之前和之后的代码，打印堆栈跟踪，并与对象交互。请参考官方Python文档（[https://docs.python.org/3.7/library/pdb.html](https://docs.python.org/3.7/library/pdb.html)）上的`pdb`，了解更多信息。在我们的例子中，我们首先检查`keys`元组。之后，我们检查`d`的键。我们发现`'third'`缺失了，所以我们自己放进去（这可能危险—想一想）。最后，现在所有的键都在了，我们输入`c`，表示（*c*）继续。
- en: '`pdb` also gives you the ability to proceed with your code one line at a time
    using (*n*)ext, to (*s*)tep into a function for deeper analysis, or to handle
    breaks with (*b*)reak. For a complete list of commands, please refer to the documentation
    or type (*h*)elp in the console.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdb`还可以让您逐行执行代码，使用（*n*）下一步，深入分析函数，或使用（*b*）断点处理。有关命令的完整列表，请参考文档或在控制台中输入（*h*）帮助。'
- en: You can see, from the output of the preceding run, that we could finally get
    to the end of the validation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，从前面的运行输出中，我们最终可以到达验证的结尾。
- en: '`pdb` (or `pdbpp`) is an invaluable tool that I use every day. So, go and have
    fun, set a breakpoint somewhere, and try to inspect it, follow the official documentation
    and try the commands in your code to see their effect and learn them well.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdb`（或`pdbpp`）是我每天都使用的宝贵工具。所以，去玩耍吧，设置一个断点，尝试检查它，按照官方文档尝试在您的代码中使用命令，看看它们的效果并好好学习。'
- en: Notice that in this example I have assumed you installed `pdbpp`. If that is
    not the case, then you might find that some commands don't work the same in `pdb`.
    One example is the letter `d`, which would be interpreted from `pdb` as the *down*
    command. In order to get around that, you would have to add a `!` in front of `d`,
    to tell `pdb` that it is meant to be interpreted literally, and not as a command.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此示例中，我假设您已安装了`pdbpp`。如果不是这样，那么您可能会发现一些命令在`pdb`中不起作用。一个例子是字母`d`，在`pdb`中会被解释为*down*命令。为了解决这个问题，您需要在`d`前面加上`!`，告诉`pdb`它应该被字面解释，而不是作为命令。
- en: Inspecting log files
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查日志文件
- en: Another way of debugging a misbehaving application is to inspect its log files.
    **Log files** are special files in which an application writes down all sorts
    of things, normally related to what's going on inside of it. If an important procedure
    is started, I would typically expect a corresponding line in the logs. It is the
    same when it finishes, and possibly for what happens inside of it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 调试一个行为异常的应用程序的另一种方法是检查其日志文件。**日志文件**是特殊的文件，应用程序会在其中记录各种事情，通常与其内部发生的事情有关。如果重要的过程开始了，我通常期望在日志中有相应的记录。当它结束时也是一样，可能还有它内部发生的事情。
- en: Errors need to be logged so that when a problem happens, we can inspect what
    went wrong by taking a look at the information in the log files.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 错误需要被记录下来，这样当出现问题时，我们可以通过查看日志文件中的信息来检查出错的原因。
- en: 'There are many different ways to set up a logger in Python. Logging is very
    malleable and you can configure it. In a nutshell, there are normally four players
    in the game: loggers, handlers, filters, and formatters:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中有许多不同的设置记录器的方法。日志记录非常灵活，可以进行配置。简而言之，通常有四个角色：记录器、处理程序、过滤器和格式化程序：
- en: '**Loggers**: Expose the interface that the application code uses directly'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录器**：公开应用程序代码直接使用的接口'
- en: '**Handlers**: Send the log records (created by loggers) to the appropriate
    destination'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理程序**：将日志记录（由记录器创建）发送到适当的目的地'
- en: '**Filters**: Provide a finer-grained facility for determining which log records
    to output'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤器**：提供了一个更精细的设施，用于确定要输出哪些日志记录'
- en: '**Formatters**: Specify the layout of the log records in the final output'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**格式化程序**：指定最终输出中日志记录的布局'
- en: 'Logging is performed by calling methods on instances of the `Logger` class.
    Each line you log has a level. The levels normally used are: `DEBUG`, `INFO`,
    `WARNING`, `ERROR`, and `CRITICAL`. You can import them from the `logging` module.
    They are in order of severity and it''s very important to use them properly because
    they will help you filter the contents of a log file based on what you''re searching
    for. Log files usually become extremely big so it''s very important to have the
    information in them written properly so that you can find it quickly when it matters.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 记录是通过调用`Logger`类的实例的方法来执行的。您记录的每一行都有一个级别。通常使用的级别有：`DEBUG`、`INFO`、`WARNING`、`ERROR`和`CRITICAL`。您可以从`logging`模块中导入它们。它们按严重程度排序，正确使用它们非常重要，因为它们将帮助您根据您要搜索的内容过滤日志文件的内容。日志文件通常变得非常庞大，因此将其中的信息正确地写入非常重要，这样在需要时您可以快速找到它。
- en: You can log to a file but you can also log to a network location, to a queue,
    to a console, and so on. In general, if you have an architecture that is deployed
    on one machine, logging to a file is acceptable, but when your architecture spans
    over multiple machines (such as in the case of service-oriented or microservice
    architectures), it's very useful to implement a centralized solution for logging
    so that all log messages coming from each service can be stored and investigated
    in a single place. It helps a lot, otherwise trying to correlate giant files from
    several different sources to figure out what went wrong can become truly challenging.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以记录到文件，也可以记录到网络位置，队列，控制台等。一般来说，如果您的架构部署在一台机器上，记录到文件是可以接受的，但当您的架构跨越多台机器（比如面向服务或微服务架构的情况下），实现一个集中的日志记录解决方案非常有用，这样每个服务产生的所有日志消息都可以存储和调查在一个地方。否则，尝试从几个不同来源的巨大文件中找出问题发生了什么可能会变得非常具有挑战性。
- en: A **service-oriented architecture** (**SOA**) is an architectural pattern in
    software design in which application components provide services to other components
    via a communications protocol, typically over a network. The beauty of this system
    is that, when coded properly, each service can be written in the most appropriate
    language to serve its purpose. The only thing that matters is the communication
    with the other services, which needs to happen via a common format so that data
    exchange can be done.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向服务的架构**（SOA）是软件设计中的一种架构模式，其中应用程序组件通过通信协议向其他组件提供服务，通常通过网络。这个系统的美妙之处在于，当编写正确时，每个服务都可以用最合适的语言来实现其目的。唯一重要的是与其他服务的通信，这需要通过一个共同的格式进行，以便进行数据交换。'
- en: '**Microservice architectures** are an evolution of SOAs, but follow a different
    set of architectural patterns.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务架构**是SOA的演变，但遵循一组不同的架构模式。'
- en: 'Here, I will present you with a very simple logging example. We will log a
    few messages to a file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将向您介绍一个非常简单的日志记录示例。我们将向文件记录一些消息：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let's go through it line by line. First, we import the `logging` module, then
    we set up a basic configuration. In general, a production-logging configuration
    is much more complicated than this, but I wanted to keep things as easy as possible.
    We specify a filename, the minimum logging level we want to capture in the file,
    and the message format. We'll log the date and time information, the level, and
    the message.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行进行。首先，我们导入`logging`模块，然后设置基本配置。一般来说，生产日志配置比这复杂得多，但我想尽可能简单。我们指定一个文件名，我们想要在文件中捕获的最低日志级别，以及消息格式。我们将记录日期和时间信息、级别和消息。
- en: I will start by logging an `info` message that tells me we're about to process
    our list. Then, I will log (this time using the `DEBUG` level, by using the `debug`
    function) which is the value at some position. I'm using `debug` here because
    I want to be able to filter out these logs in the future (by setting the minimum
    level to `logging.INFO` or more), because I might have to handle very big lists
    and I don't want to log all the values.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从记录一个告诉我我们即将处理列表的`info`消息开始。然后，我将记录（这次使用`DEBUG`级别，使用`debug`函数）某个位置的值。我在这里使用`debug`，因为我希望能够在将来过滤这些日志（通过将最低级别设置为`logging.INFO`或更高），因为我可能必须处理非常大的列表，而我不想记录所有的值。
- en: If we get `IndexError` (and we do, since I'm looping over `range(4)`), we call
    `logging.exception()`, which is the same as `logging.error()`, but it also prints
    the traceback.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们得到`IndexError`（我们确实得到了，因为我正在循环遍历`range(4)`），我们调用`logging.exception()`，它与`logging.error()`相同，但还会打印出回溯。
- en: 'At the end of the code, I log another `info` message saying we''re done. The
    result is this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的结尾，我记录了另一个`info`消息，说我们已经完成了。结果是这样的：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is exactly what we need to be able to debug an application that is running
    on a box, and not on our console. We can see what went on, the traceback of any
    exception raised, and so on.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们需要的，可以调试在服务器上运行而不是在我们的控制台上运行的应用程序。我们可以看到发生了什么，引发的任何异常的回溯等等。
- en: 'The example presented here only scratches the surface of logging. For a more
    in-depth explanation, you can find information in the *Python HOWTOs* section of
    the official Python documentation: *Logging HOWTO*, and *Logging Cookbook*.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里介绍的示例只是日志记录的皮毛。要获得更深入的解释，您可以在官方Python文档的*Python HOWTOs*部分找到信息：*日志记录HOWTO*和*日志记录Cookbook*。
- en: Logging is an art. You need to find a good balance between logging everything
    and logging nothing. Ideally, you should log anything that you need to make sure
    your application is working correctly, and possibly all errors or exceptions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是一门艺术。您需要在记录所有内容和不记录任何内容之间找到一个良好的平衡。理想情况下，您应该记录任何需要确保应用程序正常工作的内容，以及可能的所有错误或异常。
- en: Other techniques
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他技术
- en: In this final section, I'd like to demonstrate briefly a couple of techniques
    that you may find useful.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这最后一节中，我想简要演示一些您可能会发现有用的技术。
- en: Profiling
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析
- en: We talked about profiling in [Chapter 8](part0211.html#6976M0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Testing, Profiling, and Dealing with Exceptions*, and I'm only mentioning it
    here because profiling can sometimes explain weird errors that are due to a component
    being too slow. Especially when networking is involved, having an idea of the
    timings and latencies your application has to go through is very important in
    order to understand what may be going on when problems arise, therefore I suggest
    you get acquainted with profiling techniques and also for a troubleshooting perspective.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第8章](part0211.html#6976M0-2ddb708647cc4530a187c2c6c0e9acfe)中讨论了分析，*测试、分析和处理异常*，我在这里提到它只是因为分析有时可以解释由于组件过慢而导致的奇怪错误。特别是涉及网络时，了解应用程序需要经历的时间和延迟非常重要，以便在出现问题时了解可能发生了什么，因此我建议您熟悉分析技术，也从故障排除的角度来看。
- en: Assertions
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言
- en: 'Assertions are a nice way to make your code ensure your assumptions are verified.
    If they are, all proceeds regularly but, if they are not, you get a nice exception
    that you can work with. Sometimes, instead of inspecting, it''s quicker to drop
    a couple of assertions in the code just to exclude possibilities. Let''s see an
    example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是确保代码验证您的假设的一种好方法。如果是，一切都会正常进行，但如果不是，您会得到一个很好的异常，可以处理。有时，与其检查，不如在代码中放置一些断言来排除可能性更快。让我们看一个例子：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This code simulates a situation in which `mylist` isn''t defined by us like
    that, of course, but we''re assuming it has four elements. So we put an assertion
    there, and the result is this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码模拟了一个情况，即`mylist`并非由我们定义，但我们假设它有四个元素。因此我们在那里放置了一个断言，结果是这样的：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This tells us exactly where the problem is.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们问题出在哪里。
- en: Where to find information
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找信息的位置
- en: In the Python official documentation, there is a section dedicated to debugging
    and profiling, where you can read up about the `bdb` debugger framework, and about
    modules such as `faulthandler`, `timeit`, `trace`, `tracemallock`, and of course
    `pdb`. Just head to the standard library section in the documentation and you'll
    find all this information very easily.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python官方文档中，有一个专门介绍调试和分析的部分，您可以在那里了解`bdb`调试器框架，以及诸如`faulthandler`、`timeit`、`trace`、`tracemallock`和当然`pdb`等模块。只需转到文档中的标准库部分，您就可以非常容易地找到所有这些信息。
- en: Troubleshooting guidelines
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除指南
- en: In this short section, I'd like to give you a few tips that come from my troubleshooting
    experience.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的部分中，我想给您一些建议，这些建议来自我的故障排除经验。
- en: Using console editors
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用控制台编辑器
- en: First, get comfortable using **Vim** or **nano** as an editor, and learn the
    basics of the console. When things break, you don't have the luxury of your editor
    with all the bells and whistles there. You have to connect to a box and work from
    there. So it's a very good idea to be comfortable browsing your production environment
    with console commands, and be able to edit files using console-based editors,
    such as vi, Vim, or nano. Don't let your usual development environment spoil you.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要熟练使用**Vim**或**nano**作为编辑器，并学习控制台的基础知识。当事情出错时，您就没有您的编辑器带来的所有便利了。您必须连接到服务器并从那里工作。因此，熟练使用控制台命令浏览生产环境，并能够使用基于控制台的编辑器编辑文件，比如vi、Vim或nano，是一个非常好的主意。不要让您通常的开发环境宠坏了您。
- en: Where to inspect
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查的位置
- en: My second suggestion concerns where to place your debugging breakpoints. It
    doesn't matter if you are using `print`, a custom function, or `pdb`, you still
    have to choose where to place the calls that provide you with the information,
    right?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我的第二个建议涉及在哪里放置调试断点。无论您使用`print`、自定义函数还是`pdb`，您仍然必须选择在哪里放置提供信息的调用，对吧？
- en: Well, some places are better than others, and there are ways to handle the debugging
    progression that are better than others.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有些地方比其他地方更好，有些处理调试进展的方法比其他方法更好。
- en: I normally avoid placing a breakpoint in an `if` clause because, if that clause
    is not exercised, I lose the chance of getting the information I wanted. Sometimes
    it's not easy or quick to get to the breakpoint, so think carefully before placing
    them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常不会在`if`子句中设置断点，因为如果该子句没有执行，我就失去了获取所需信息的机会。有时很难或很快到达断点，所以在设置断点之前请仔细考虑。
- en: Another important thing is where to start. Imagine that you have 100 lines of
    code that handle your data. Data comes in at line 1, and somehow it's wrong at
    line 100\. You don't know where the bug is, so what do you do? You can place a
    breakpoint at line 1 and patiently go through all the lines, checking your data.
    In the worst case scenario, 99 lines (and many cups of coffee) later, you spot
    the bug. So, consider using a different approach.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件重要的事情是从哪里开始。想象一下，您有100行代码来处理您的数据。数据从第1行进入，但在第100行出现错误。您不知道错误在哪里，那么该怎么办呢？您可以在第1行设置断点，耐心地检查所有行，检查您的数据。在最坏的情况下，99行（和许多杯咖啡）后，您找到了错误。因此，请考虑使用不同的方法。
- en: You start at line 50, and inspect. If the data is good, it means the bug happens
    later, in which case you place your next breakpoint at line 75\. If the data at
    line 50 is already bad, you go on by placing a breakpoint at line 25\. Then, you
    repeat. Each time, you move either backward or forward, by half the jump you did
    last time.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您从第50行开始，然后进行检查。如果数据正常，这意味着错误发生在后面，这种情况下，您将在第75行设置下一个断点。如果第50行的数据已经出错，您将在第25行设置断点。然后，您重复这个过程。每次，您要么向后移动，要么向前移动，跳过上次的一半。
- en: In our worst-case scenario, your debugging would go from 1, 2, 3, ..., 99, in
    a linear fashion, to a series of jumps such as 50, 75, 87, 93, 96, ..., 99 which
    is way faster. In fact, it's logarithmic. This searching technique is called **binary
    search**, it's based on a divide-and-conquer approach, and it's very effective,
    so try to master it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，您的调试将从1、2、3、...、99以线性方式进行，变成一系列跳跃，如50、75、87、93、96、...、99，速度要快得多。事实上，这是对数的。这种搜索技术称为**二分搜索**，它基于分而治之的方法，非常有效，因此请尽量掌握它。
- en: Using tests to debug
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试进行调试
- en: Do you remember [Chapter 8](part0211.html#6976M0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Testing, Profiling, and Dealing with Exceptions*, about tests? Well, if we have
    a bug and all tests are passing, it means something is wrong or missing in our
    test code base. So, one approach is to modify the tests in such a way that they
    cater for the new edge case that has been spotted, and then work your way through
    the code. This approach can be very beneficial, because it makes sure that your
    bug will be covered by a test when it's fixed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您还记得[第8章](part0211.html#6976M0-2ddb708647cc4530a187c2c6c0e9acfe)吗，*测试、性能分析和处理异常*，关于测试？如果我们有一个错误，而所有测试都通过了，这意味着我们的测试代码库中有问题或遗漏。因此，一种方法是修改测试，以便它们适应已经发现的新边缘情况，然后逐步检查代码。这种方法非常有益，因为它确保在修复错误时，您的错误将被测试覆盖。
- en: Monitoring
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控
- en: Monitoring is also very important. Software applications can go completely crazy
    and have non-deterministic hiccups when they encounter edge-case situations such
    as the network being down, a queue being full, or an external component being
    unresponsive. In these cases, it's important to have an idea of what the big picture
    was when the problem occurred and be able to correlate it to something related
    to it in a subtle, perhaps mysterious way.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 监控也非常重要。软件应用程序可能会在遇到边缘情况时变得完全疯狂，并且在网络中断、队列已满或外部组件无响应等情况下出现非确定性的故障。在这些情况下，重要的是要了解问题发生时的整体情况，并能够以微妙、甚至神秘的方式将其与相关的内容联系起来。
- en: You can monitor API endpoints, processes, web pages availability and load times,
    and basically almost everything that you can code. In general, when starting an
    application from scratch, it can be very useful to design it keeping in mind how
    you want to monitor it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以监视API端点、进程、网页可用性和加载时间，基本上几乎可以监视您可以编码的所有内容。一般来说，从头开始设计应用程序时，考虑如何监视它可能非常有用。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this short chapter, we looked at different techniques and suggestions for
    debugging and troubleshooting our code. Debugging is an activity that is always
    part of a software developer's work, so it's important to be good at it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的章节中，我们探讨了不同的调试和故障排除技术和建议。调试是软件开发人员工作中始终存在的活动，因此擅长调试非常重要。
- en: If approached with the correct attitude, it can be fun and rewarding.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以正确的态度对待，调试可以是有趣和有益的。
- en: We explored techniques to inspect our code base on functions, logging, debuggers,
    traceback information, profiling, and assertions. We saw simple examples of most
    of them and we also talked about a set of guidelines that will help when it comes
    to facing the fire.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了检查我们的代码库的技术，包括函数、日志记录、调试器、回溯信息、性能分析和断言。我们看到了它们大部分的简单示例，我们还谈到了一套指导方针，将在面对困难时提供帮助。
- en: Just remember always to *stay calm and focused*, and debugging will be much
    easier. This too, is a skill that needs to be learned and it's the most important.
    An agitated and stressed mind cannot work properly, logically, and creatively,
    therefore, if you don't strengthen it, it will be hard for you to put all of your
    knowledge to good use.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 只要记住始终保持*冷静和专注*，调试就会变得更容易。这也是一种需要学习的技能，也是最重要的。激动和紧张的心态无法正常、逻辑和创造性地工作，因此，如果您不加强它，很难将所有知识充分利用。
- en: In the next chapter, we are going to explore GUIs and scripts, taking an interesting
    detour from the more common web-application scenario.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨GUI和脚本，从更常见的Web应用程序场景中进行有趣的偏离。
