- en: 'Chapter 1. Data Types: Foundational Structures'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 数据类型：基础结构
- en: Calling data types *foundational structures* may seem like a bit of a misnomer,
    but not when you consider that developers use data types to build their classes
    and collections. So, before we examine proper data structures, it's a good idea
    to quickly review data types, as these are the foundation of what comes next.
    This chapter is meant to review the most common and most important fundamental
    data types from the 10,000-foot view. If you already have a strong grasp of these
    basic concepts, feel free to skim through this chapter or even skip it entirely
    as you see fit.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据类型称为“基础结构”可能听起来有点名不副实，但当你考虑到开发者使用数据类型来构建他们的类和集合时，情况并非如此。因此，在我们检查适当的数据结构之前，快速回顾数据类型是个好主意，因为这些都是接下来内容的基石。本章旨在从10,000英尺的高度回顾最常见和最重要的基本数据类型。如果你已经对这些基本概念有很强的理解，那么你可以自由地浏览本章，甚至根据需要完全跳过它。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Numeric data types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值数据类型
- en: Casting, Narrowing, and Widening
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换、窄化、和宽化
- en: 32-bit and 64-bit architecture concerns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32位和64位架构关注点
- en: Boolean data types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔数据类型
- en: Logic operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑操作
- en: Order of operations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算顺序
- en: Nesting operations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套操作
- en: Short-circuiting
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短路操作
- en: String data types
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串数据类型
- en: Mutability of strings
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的可变性
- en: Numeric data types
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值数据类型
- en: A detailed description of all the numeric data types in each of the following
    four languages, C#, Java, Objective-C, and Swift, could easily encompass a book
    of its own. Here, we will review only the most common numeric type identifiers
    for each language. The simplest way to evaluate these types is based on the underlying
    size of the data, using examples from each language as a framework for the discussion.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对以下四种语言（C#、Java、Objective-C和Swift）中所有数值数据类型的详细描述，可以很容易地涵盖一本自己的书。在这里，我们将仅回顾每种语言中最常见的数值类型标识符。评估这些类型的最简单方法是基于数据的基本大小，使用每种语言的示例作为讨论的框架。
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Compare apples to apples!**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**比较苹果与苹果！**'
- en: When you are developing applications for multiple mobile platforms, you should
    be aware that the languages you use could share a data type identifier or keyword,
    but under the hood, those identifiers may not be equal in value. Likewise, the
    same data type in one language may have a different identifier in another. For
    example, examine the case of the 16-bit unsigned integer, sometimes referred to
    as an `unsigned short`. Well, it's called an `unsigned short` in Objective-C.
    In C#, we talk about a `ushort`, while Swift calls it a `UInt16`. Java's only
    provision for the 16-bit unsigned integer, on the other hand, is `char` although
    this object would typically not be used for numeric values. Each of these data
    types represents a 16-bit unsigned integer; they just use different names. This
    may seem like a small point, but if you are developing apps for multiple devices
    using each platform's native language, for the sake of consistency, you will need
    to be aware of these differences. Otherwise, you may risk introducing platform-specific
    bugs that are extremely difficult to detect and diagnose.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为多个移动平台开发应用程序时，你应该意识到你使用的语言可能共享一个数据类型标识符或关键字，但在底层，这些标识符可能并不等价。同样，一种语言中的相同数据类型在另一种语言中可能有不同的标识符。例如，考察16位无符号整数的情况，有时被称为`unsigned
    short`。嗯，在Objective-C中它被称为`unsigned short`。在C#中，我们谈论的是`ushort`，而Swift则称之为`UInt16`。另一方面，Java为16位无符号整数提供的唯一选择是`char`，尽管这个对象通常不会用于数值。这些数据类型中的每一个都代表一个16位无符号整数；它们只是使用了不同的名称。这看起来可能是一个小问题，但如果你使用每个平台的本地语言为多个设备开发应用程序，为了保持一致性，你需要了解这些差异。否则，你可能会引入平台特定的错误，这些错误非常难以检测和诊断。
- en: Integer types
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数类型
- en: Integer data types are defined as representing whole numbers and can be either
    **signed** (negative, zero, or positive values) or **unsigned** (zero or positive
    values). Each language uses its own identifiers and keywords for integer types,
    so it is easiest to think in terms of memory length. For our purpose, we will
    only discuss the integer types representing 8-, 16-, 32-, and 64-bit memory objects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '整数数据类型定义为表示整数，可以是**有符号的**（负数、零或正数）或**无符号的**（零或正数）。每种语言都使用自己的标识符和关键字来表示整数类型，因此最容易从内存长度的角度来考虑。就我们的目的而言，我们只将讨论表示8位、16位、32位和64位内存对象的整数类型。 '
- en: 8-bit data types, or **bytes** as they are more commonly referred to, are the
    smallest data types that we will examine. If you have brushed up on your binary
    math, you will know that an 8-bit memory block can represent 2⁸, or 256 values.
    Signed bytes can range in value from -128 to 127, or -(2⁷) to (2⁷) - 1\. Unsigned
    bytes can range in value from 0 to 255, or 0 to (2⁸) -1.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 8 位数据类型，或更常见地称为 **bytes**，是我们将要考察的最小数据类型。如果你已经复习了二进制数学，你会知道一个 8 位的内存块可以表示 2⁸，或
    256 个值。有符号字节可以在 -128 到 127，或 -(2⁷) 到 (2⁷) - 1 的范围内变化。无符号字节可以在 0 到 255，或 0 到 (2⁸)
    -1 的范围内变化。
- en: A 16-bit data type is often referred to as a **short**, although that is not
    always the case. These types can represent 2^(16) values. Signed shorts can range
    in value from -(2^(15)) to (2^(15)) - 1\. Unsigned shorts can range in value from
    0 to (2^(16)) - 1.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 16 位数据类型通常被称为 **short**，尽管这并不总是如此。这些类型可以表示 2^(16) 个值。有符号短整型可以在 -(2^(15)) 到 (2^(15))
    - 1 的范围内变化。无符号短整型可以在 0 到 (2^(16)) - 1 的范围内变化。
- en: A 32-bit data type is most commonly identified as an integer, although it is
    sometimes identified as a **long**. Int types can represent 2^(32) values. Signed
    integers can range in values from -2^(31) to 2^(31) - 1\. Unsigned integers can
    range in values from 0 to (2^(32)) - 1.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 32 位数据类型最常见的是整数，尽管有时也被称为 **long**。整型可以表示 2^(32) 个值。有符号整数可以在 -2^(31) 到 2^(31)
    - 1 的范围内变化。无符号整数可以在 0 到 (2^(32)) - 1 的范围内变化。
- en: Finally, a 64-bit data type is most commonly identified as a long, although
    Objective-C identifies it as a **long** **long**. Long types can represent 2^(64)
    values. Signed long types can range in values from -(2^(63)) to (2^(63)) - 1\.
    Unsigned long types can range in values from 0 to (2^(63)) - 1.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，64 位数据类型最常见的是 long，尽管 Objective-C 将其识别为 **long** **long**。长整型可以表示 2^(64)
    个值。有符号长整型可以在 -(2^(63)) 到 (2^(63)) - 1 的范围内变化。无符号长整型可以在 0 到 (2^(63)) - 1 的范围内变化。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that these values happen to be consistent across the four languages we
    will work with, but some languages will introduce slight variations. It is always
    a good idea to become familiar with the details of a language's numeric identifiers.
    This is especially true if you expect to be working with cases that involve the
    identifier's extreme values.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些值恰好在我们将要使用的四种语言中是一致的，但某些语言可能会引入轻微的变化。熟悉一种语言的数字标识符的细节总是一个好主意。这尤其重要，如果你预期将处理涉及标识符极端值的情况。
- en: '**C#**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'C# refers to integer types as **integral types**. The language provides two
    mechanisms for creating 8-bit types, `byte` and `sbyte`. Both containers hold
    up to 256 values, and the unsigned byte ranges from 0 to 255\. The signed byte
    provides support for negative values and, therefore, ranges from -128 to 127:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: C# 将整数类型称为 **整型**。该语言提供了两种创建 8 位类型的机制，`byte` 和 `sbyte`。这两个容器可以存储多达 256 个值，无符号字节的范围从
    0 到 255。有符号字节支持负值，因此范围从 -128 到 127：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Interestingly, C# reverses its pattern for longer bit identifiers. Instead
    of prefixing signed identifiers with `s`, as in the case of `sbyte`, it prefixes
    unsigned identifiers with `u`. So, for 16-, 32-, and 64-bit identifiers, we have
    `short`, `ushort`; `int`, `uint`; `long`, and `ulong` respectively:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，C# 对于较长的位标识符会反转其模式。它不是像 `sbyte` 一样在有符号标识符前加 `s`，而是将无符号标识符前加 `u`。因此，对于 16
    位、32 位和 64 位标识符，我们有 `short`、`ushort`；`int`、`uint`；`long` 和 `ulong` 分别：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Java**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'Java includes integer types as a part of its primitive data types. The Java
    language only provides one construct for 8-bit storage, also identified as a `byte`.
    It is a signed data type, so it will represent values from -127 to 128\. Java
    also provides a wrapper class called `Byte`, which wraps the primitive value and
    provides additional constructor support for parsable strings, or text, which can
    be converted to a numeric value such as the text 42\. This pattern is repeated
    in the 16-, 32-, and 64-bit data types:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Java 将整数类型作为其原始数据类型的一部分。Java 语言只为 8 位存储提供了一个构造，也称为 `byte`。它是一个有符号数据类型，因此它将表示从
    -127 到 128 的值。Java 还提供了一个名为 `Byte` 的包装类，它包装原始值并提供对可解析字符串或文本的额外构造支持，这些字符串或文本可以转换为数值，例如文本
    42。这种模式在 16 位、32 位和 64 位数据类型中重复：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Java shares identifiers with C# for all of integer data type, which means it
    also provides the `byte`, `short`, `int`, and `long` identifiers for 8-, 16-,
    32-, and 64-bit types. One exception to the pattern in Java is the `char` identifier,
    which is provided for unsigned 16-bit data types. It should be noted, however,
    that the `char` data type is typically only used for ASCII character assignment
    and not for actual integer values:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Java与C#共享所有整数数据类型的标识符，这意味着它也提供了`byte`、`short`、`int`和`long`标识符，用于8位、16位、32位和64位类型。Java中的模式有一个例外是`char`标识符，它用于无符号16位数据类型。然而，需要注意的是，`char`数据类型通常仅用于ASCII字符赋值，而不是实际整数值：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, take note of the `int` type and `Integer` class. Unlike
    the other primitive wrapper classes, `Integer` does not share the same name as
    the identifier it is supporting.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，请注意`int`类型和`Integer`类。与其他原始包装类不同，`Integer`与其支持的标识符名称不同。
- en: 'Also, note the `long` type and its assigned values. In each case, the values
    have the suffix `L`. This is a requirement for `long` literals in Java because
    the compiler interprets all numeral literals as 32-bit integers. If you want to
    explicitly specify that your literal is larger than 32-bit, you must append the
    suffix `L`. Otherwise, the compiler will honk at you. This is not a requirement,
    however, when passing a string value into the `Long` class constructor:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意`long`类型及其指定的值。在每种情况下，值都有后缀`L`。这是Java中`long`字面量的要求，因为编译器将所有数字字面量解释为32位整数。如果你想明确指定你的字面量大于32位，你必须附加后缀`L`。然而，当将字符串值传递给`Long`类构造函数时，这不是一个要求：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Objective-C**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'For 8-bit data, Objective-C provides the `char` data type in both signed and
    unsigned formats. As with other languages, the signed data type ranges from -127
    to 128, while the unsigned data type ranges from 0 to 255\. Developers also have
    the option to use Objective-C''s fixed-width counterparts named `int8_t` and `uint8_t`.
    This pattern is repeated in the 16-, 32-, and 64-bit data types. Finally, Objective-C
    also provides an object-oriented wrapper class for each of the integer types in
    the form of the `NSNumber` class:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于8位数据，Objective-C提供了带符号和无符号格式的`char`数据类型。与其他语言一样，带符号的数据类型范围从-127到128，而无符号数据类型的范围从0到255。开发者还有选择使用Objective-C的固定宽度对应类型`int8_t`和`uint8_t`。这种模式在16位、32位和64位数据类型中重复。最后，Objective-C还提供了`NSNumber`类作为每个整数类型的面向对象包装类：
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The difference between the `char` or the other integer data type identifiers
    and their fixed-width counterparts is an important distinction. With the exception
    of char, which is always precisely 1 byte in length, every other integer data
    type in Objective-C will vary in size, depending on the implementation and underlying
    architecture. This is because Objective-C is based on C, which was designed to
    work at peak efficiency with various types of underlying architectures. Although
    it is possible to determine the exact length of an integer type at runtime, at
    compile, you can only be certain that `short <= int <= long <= long long`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`或其他整数数据类型标识符与其固定宽度对应类型之间的区别是一个重要的区分。除了总是精确为1字节的`char`之外，Objective-C中的其他每个整数数据类型的大小将根据实现和底层架构而变化。这是因为Objective-C基于C，C是为与各种底层架构以最高效率工作而设计的。虽然可以在运行时确定整数类型的确切长度，但在编译时，你只能确定`short
    <= int <= long <= long long`。'
- en: This is where **fixed-width integers** come in handy. If more rigid control
    over the number of bytes is required, the `(u)int<n>_t` data types allow you to
    denote integers that are precisely 8-, 16-, 32-, or 64-bit in length.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**固定宽度整数**派上用场的地方。如果你需要更严格的字节数量控制，`(u)int<n>_t`数据类型允许你表示长度精确为8位、16位、32位或64位的整数。
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding example, you can see that, when using the `char` data types
    in code, you must specify the `unsigned` identifier, such as `unsigned char`.
    However, `signed` is the default and may be omitted, which means the `char` type
    is equivalent to `signed char`. This pattern applies to each of the integer data
    types in Objective-C.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你可以看到，当在代码中使用`char`数据类型时，你必须指定`unsigned`标识符，例如`unsigned char`。然而，`signed`是默认的，并且可以省略，这意味着`char`类型等同于`signed
    char`。这种模式适用于Objective-C中每个整数数据类型。
- en: 'Larger integer types in Objective-C include `short` for 16-bit, `int` for 32-bit,
    and `long long` for 64-bit. Each of these has a fixed-width counterpart following
    the `(u)int<n>_t` pattern. Supporting methods are also available for each type
    within the `NSNumber` class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 中的更大整数类型包括 `short` 用于 16 位，`int` 用于 32 位，以及 `long long` 用于 64 位。每个这些类型都有一个遵循
    `(u)int<n>_t` 模式的固定宽度对应类型。`NSNumber` 类中也为每种类型提供了支持方法：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Swift**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'The Swift language is similar to others, in that, it provides separate identifiers
    for signed and unsigned integers, for example `Int8` and `UInt8`. This pattern
    applies to each of the integer data types in Swift, making it possibly the simplest
    language in terms of remembering which identifier applies to which type:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 语言与其他语言类似，它为有符号和无符号整数提供了单独的标识符，例如 `Int8` 和 `UInt8`。这种模式适用于 Swift 中的每个整数数据类型，使其在记住哪个标识符适用于哪种类型方面可能是最简单的语言：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding example, I have explicitly declared the data type using the
    `:Int8` and `: UInt8` identifiers to demonstrate explicit declaration. In Swift,
    it is also acceptable to leave these identifiers out and allow Swift to infer
    the types dynamically at runtime:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的例子中，我已明确使用 `:Int8` 和 `: UInt8` 标识符来声明数据类型以演示显式声明。在 Swift 中，也可以省略这些标识符，并允许
    Swift 在运行时动态推断类型：'
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Why do I need to know this?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我为什么需要了解这些？
- en: You may ask, Why do I need to know the ins and outs of these data types? Can't
    I just declare an `int` object or some similar identifier and move on to writing
    the interesting code? Modern computers and even mobile devices provide nearly
    unlimited resources, so it's not a big deal, right?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，我为什么需要了解这些数据类型的细节？难道我不能只声明一个 `int` 对象或类似的标识符，然后继续编写有趣的代码吗？现代计算机甚至移动设备提供了几乎无限的资源，所以这并不是什么大问题，对吧？
- en: Well, not exactly. It is true that, in many circumstances in your daily programming
    experience, any integer type will do. For example, looping through a list of license
    plates issued at **Department of Motor Vehicles** (**DMV**) offices across the
    state of West Virginia on any given day may yield anything from a few dozen to
    perhaps a few hundred results. You could control the `for` loop's iterations using
    a `short` or you could use `long long`. Either way, the loop will have very little
    impact on the performance of your system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，并不完全是这样。确实，在你的日常编程经验中的许多情况下，任何整数类型都适用。例如，在某个给定的一天，通过西弗吉尼亚州州立机动车辆管理局（**DMV**）办公室发行的牌照列表进行循环，可能会得到几十到几百个结果。你可以使用
    `short` 或 `long long` 来控制 `for` 循环的迭代次数。无论如何，循环对你的系统性能的影响都非常小。
- en: However, what if you're dealing with a set of data where each discrete result
    in that set can fit in a 16-bit type, but you choose a 32-bit identifier just
    because that's what you're used to? You've just doubled the amount of memory required
    to manage that collection. This decision wouldn't matter with 100 or maybe even
    100,000 results. However, when you start working with very large sets of data,
    with hundreds of thousands or even millions of discrete results, such design decisions
    can have a huge impact on system performance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你处理的数据集中每个离散的结果都可以适应 16 位类型，但你选择了一个 32 位标识符仅仅因为你习惯了这样做？你刚刚将管理该集合所需的内存量翻倍了。对于
    100 或甚至 10 万个结果来说，这个决定可能无关紧要。然而，当你开始处理非常大的数据集时，有数十万甚至数百万个离散结果时，这样的设计决策可能会对系统性能产生巨大影响。
- en: Single precision float
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单精度浮点数
- en: '**Single precision floating point** numbers, or **floats** as they are more
    commonly referred to, are 32-bit floating point containers that allow storing
    values with much greater precision than integer types, typically to six or seven
    significant digits. Many languages use the `float` keyword or identifier for single-precision
    float values, and that is the case for each of the four languages we are discussing.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**单精度浮点数**，或更常见地称为 **floats**，是 32 位浮点容器，可以存储比整数类型具有更高精度的值，通常为六到七位有效数字。许多语言使用
    `float` 关键字或标识符来表示单精度浮点值，我们讨论的四种语言也是如此。'
- en: You should be aware that floating point values are subject to rounding errors
    because they cannot represent base-10 numbers exactly. The arithmetic of floating
    point types is a fairly complex topic, the details of which will not be pertinent
    to the majority of developers on any given day. However, it is still a good practice
    to familiarize yourself with the particulars of the underlying science as well
    as the implementation in each language.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该意识到浮点数会受到舍入误差的影响，因为它们不能精确地表示十进制数。浮点类型的算术是一个相当复杂的话题，其细节对于任何给定日子的大多数开发者来说并不相关。然而，熟悉每种语言中底层科学以及实现的细节仍然是一个好的实践。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As I am by no means an expert on the subject, this discussion will only scratch
    the surface of the science behind these types, and we will not even begin to cover
    the arithmetic. There are others who truly are experts in this area, however,
    and I highly recommend you review some of their work listed in the *Additional
    resources* section at the end of this chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我绝不是该领域的专家，这次讨论只会触及这些类型背后的科学表面，我们甚至不会开始涉及算术。然而，在这个领域确实有真正的专家，我强烈建议你查看本章末尾的
    *附加资源* 部分中列出的他们的一些作品。
- en: '**C#**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'In C#, the `float` keyword identifies 32-bit floating point values. The C#
    `float` data type has an approximate range of -3.4 × 10^(38) to +3.4 × 10^(38)
    and a precision of six significant digits:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，`float` 关键字标识 32 位浮点数。C# 的 `float` 数据类型具有约 -3.4 × 10^(38) 到 +3.4 × 10^(38)
    的范围和 6 位有效数字的精度：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When you examine the preceding code, you will notice that the `float` value
    assignment has the `f` suffix. This is because, like other C-based languages,
    C# treats real numeric literals on the right-hand side of assignments as a **double**
    (discussed later) by default. If you leave the `f` or `F` suffix off the assignment,
    you will receive a compilation error, because you are trying to assign a double
    point precision value to a single point precision type.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查前面的代码时，你会注意到 `float` 值赋值带有 `f` 后缀。这是因为，与其他基于 C 的语言一样，C# 默认将赋值右侧的实数文字视为 **double**（稍后讨论）。如果你在赋值中省略
    `f` 或 `F` 后缀，你将收到编译错误，因为你正在尝试将双精度值赋给单精度类型。
- en: Also, note the rounding error in the last digit. We populated the `piFloat`
    object with pi presented out to 30 significant digits. However, `float` can only
    retain six significant digits, so the software rounded off everything after that.
    When pi is calculated out to six significant digits, we get 3.141592, but our
    `float` value is now 3.141593 due to this limitation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意最后一位的舍入误差。我们用 30 位有效数字表示的 π 填充了 `piFloat` 对象。然而，`float` 只能保留 6 位有效数字，因此软件将之后的数字四舍五入。当
    π 计算到 6 位有效数字时，我们得到 3.141592，但由于这个限制，我们的 `float` 值现在是 3.141593。
- en: '**Java**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'As with C#, Java uses the **float** identifier for floating point values. In
    Java, a `float` has an approximate range of -3.4 × 10^(38) to +3.4 × 10^(38) and
    a precision of six or seven significant digits:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C# 一样，Java 使用 **float** 标识符表示浮点数。在 Java 中，`float` 的近似范围为 -3.4 × 10^(38) 到
    +3.4 × 10^(38)，并且具有 6 或 7 位有效数字的精度：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When you examine the preceding code, you will notice that the float value assignment
    has the `f` suffix. This is because, like other C based languages, Java treats
    real numeric literals on the right side of assignments as a double by default.
    If you leave the `f` or `F` suffix off the assignment, you will receive a compilation
    error because you are trying to assign a double-point precision value to a single-point
    precision type.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查前面的代码时，你会注意到浮点数值赋值带有 `f` 后缀。这是因为，与其他基于 C 的语言一样，Java 默认将赋值右侧的实数文字视为 `double`。如果你在赋值中省略
    `f` 或 `F` 后缀，你将收到编译错误，因为你正在尝试将双精度值赋给单精度类型。
- en: '**Objective-C**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'Objective-C uses the `float` identifier for floating point values. In Objective-C,
    a `float` has an approximate range of -3.4 × 10^(38) to +3.4 × 10^(38) and a precision
    of 6 significant digits:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 使用 `float` 标识符表示浮点数。在 Objective-C 中，`float` 的近似范围为 -3.4 × 10^(38)
    到 +3.4 × 10^(38)，并且具有 6 位有效数字的精度：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When you examine the preceding code, you will notice that the float value assignment
    has the `f` suffix. This is because, like other C-based languages, Objective-C
    treats real numeric literals on the right-hand side of assignments as a double
    by default. If you leave the `f` or `F` suffix off of the assignment, you will
    receive a compilation error because you are trying to assign a double-point precision
    value to a single-point precision type.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查前面的代码时，你会注意到 float 值赋值有 `f` 后缀。这是因为，像其他基于 C 的语言一样，Swift 默认将赋值右侧的实数字面量视为
    double。如果你在赋值时省略 `f` 或 `F` 后缀，你将收到编译错误，因为你正在尝试将双精度值赋给单精度类型。
- en: Also, note the rounding error in the last digit. We populated the `piFloat`
    object with pi presented out to 30 significant digits, but float can only retain
    six significant digits, so the software rounded off everything after that. When
    pi is calculated out to six significant digits, we get 3.141592, but our float
    value is now 3.141593 due to this limitation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意最后一位的舍入误差。我们用 pi 以 30 位有效数字的形式填充了 `piFloat` 对象，但 float 只能保留六位有效数字，因此软件将之后的数字都四舍五入。当
    pi 以六位有效数字计算时，我们得到 3.141592，但我们的 float 值现在变成了 3.141593，这是由于这种限制。
- en: '**Swift**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Swift uses the `float` identifier for floating point values. In Swift, a `float`
    has an approximate range of -3.4 × 10^(38) to +3.4 × 10^(38) and a precision of
    six significant digits:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 使用 `float` 标识符表示浮点数。在 Swift 中，`float` 的近似范围为 -3.4 × 10^(38) 到 +3.4 × 10^(38)，并且具有六位有效数字的精度：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When you examine the preceding code, you will notice that the float value assignment
    has the `f` suffix. This is because, like other C-based languages, Swift treats
    real numeric literals on the right-hand side of assignments as a double by default.
    If you leave the `f` or `F` suffix off of the assignment, you will receive a compilation
    error because you are trying to assign a double-point precision value to a single-point
    precision type.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查前面的代码时，你会注意到 float 值赋值有 `f` 后缀。这是因为，像其他基于 C 的语言一样，Swift 默认将赋值右侧的实数字面量视为
    double。如果你在赋值时省略 `f` 或 `F` 后缀，你将收到编译错误，因为你正在尝试将双精度值赋给单精度类型。
- en: Also, note the rounding error in the last digit. We populated the `floatValue`
    object with pi presented out to 30 significant digits, but float can only retain
    six significant digits, so the software rounded off everything after that. When
    pi is calculated out to six significant digits, we get 3.141592, but our float
    value is now 3.141593 due to this limitation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意最后一位的舍入误差。我们用 pi 以 30 位有效数字的形式填充了 `floatValue` 对象，但 float 只能保留六位有效数字，因此软件将之后的数字都四舍五入。当
    pi 以六位有效数字计算时，我们得到 3.141592，但我们的 float 值现在变成了 3.141593，这是由于这种限制。
- en: Double precision float
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双精度浮点
- en: '**Double precision floating point** numbers, or **doubles** as they are more
    commonly referred to, are 64-bit floating point values that allow storing values
    with much greater precision than the integer types, typically to 15 significant
    digits. Many languages use the double identifier for double precision float values
    and that is also the case for each of the four languages we are discussing.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**双精度浮点数**，或更常见地称为 **doubles**，是 64 位浮点值，允许存储比整数类型具有更高的精度，通常为 15 位有效数字。许多语言使用
    double 标识符表示双精度浮点值，我们讨论的四种语言也是如此。'
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In most circumstances, it will not matter whether you choose `float` over `double` unless
    memory space is a concern, in which case you will want to choose `float` whenever
    possible. Many argue that `float` is more performant than double under most conditions,
    and generally speaking, this is the case. However, there are other conditions
    where `double` will be more performant than `float`. The reality is that the efficiency
    of each type is going to vary from case to case, based on criteria that are too
    numerous to detail in the context of this discussion. Therefore, if your particular
    application requires truly peak efficiency, you should research the requirements
    and environmental factors carefully and decide what is best for your situation.
    Otherwise, just use whichever container will get the job done and move on.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，选择`float`而不是`double`通常不会有什么影响，除非内存空间是一个考虑因素，在这种情况下，你将尽可能选择`float`。许多人认为在大多数情况下`float`比`double`性能更好，一般来说，这是正确的。然而，还有其他情况下`double`会比`float`性能更好。现实是每种类型的效率都会根据具体案例而变化，这些标准太多，无法在本讨论的上下文中详细说明。因此，如果你的特定应用程序确实需要达到顶峰效率，你应该仔细研究需求和环境因素，并决定最适合你情况的选择。否则，只需使用任何能完成工作的容器，然后继续前进。
- en: '**C#**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'In C#, the `double` keyword identifies 64-bit floating point values. The C#
    `double` has an approximate range of ±5.0 × 10^(−324) to ±1.7 × 10^(308) and a
    precision of 14 or 15 significant digits:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，`double`关键字标识64位浮点值。C#的`double`具有大约的范围为±5.0 × 10^(−324)到±1.7 × 10^(308)，并且精度为14或15位有效数字：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When you examine the preceding code, you will notice that the `wholeDouble`
    value assignment has the `d` suffix. This is because, like other C-based languages,
    C# treats real numeric literals on the right-hand side of assignments as integers
    by default. If you were to leave the `d` or `D` suffix off the assignment, you
    will receive a compilation error because you are trying to assign an integer value
    to a double-point precision type.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查前面的代码时，你会注意到`wholeDouble`值赋值有`d`后缀。这是因为，像其他基于C的语言一样，C#默认将赋值右侧的实数字面量视为整数。如果你在赋值时省略`d`或`D`后缀，你将收到编译错误，因为你试图将一个整数值赋给双精度浮点类型。
- en: Also, note the rounding error in the last digit. We populated the `piDouble`
    object using pi out to 30 significant digits, but double can only retain 14 significant
    digits, so the software rounded off everything after that. When pi is calculated
    out to 15 significant digits, we get 3.141592653589793, but our float value is
    now 3.14159265358979 due to this limitation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意最后一位的舍入误差。我们使用π到30位有效数字来填充`piDouble`对象，但`double`只能保留14位有效数字，因此软件将之后的数字四舍五入。当π计算到15位有效数字时，我们得到3.141592653589793，但由于这个限制，我们的`float`值现在是3.14159265358979。
- en: '**Java**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'In Java, the `double` keyword identifies 64-bit floating-point values. The
    Java `double` has an approximate range of ±4.9 × 10^(−324) to ±1.8 × 10^(308)
    and a precision of 15 or 16 significant digits:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，`double`关键字标识64位浮点值。Java的`double`具有大约的范围为±4.9 × 10^(−324)到±1.8 × 10^(308)和15或16位有效数字的精度：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When you examine the preceding code, note the rounding error in the last digit.
    We populated the `piDouble` object using pi out to 30 significant digits, but
    double can only retain 15 significant digits, so the software rounded off everything
    after that. When pi is calculated out to 15 significant digits, we get 3.1415926535897932,
    but our float value is now 3.141592653589793 due to this limitation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查前面的代码时，请注意最后一位的舍入误差。我们使用π到30位有效数字来填充`piDouble`对象，但`double`只能保留15位有效数字，因此软件将之后的数字四舍五入。当π计算到15位有效数字时，我们得到3.1415926535897932，但由于这个限制，我们的`float`值现在是3.141592653589793。
- en: '**Objective-C**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'Objective-C also uses the `double` identifier for 64-bit floating point values.
    The Objective-C double has an approximate range of 2.3E^(-308) to 1.7E^(308) and
    a precision of 15 significant digits. Objective-C takes accuracy a step further
    by providing an even more precise version of double called the **long double**.
    The long double identifier is used for an 80 bit storage container with a range
    of 3.4E^(-4932) to 1.1E^(4932) and a precision of 19 significant digits:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C也使用`double`标识符表示64位浮点值。Objective-C的`double`具有大约的范围为2.3E^(-308)到1.7E^(308)和15位有效数字的精度。Objective-C通过提供称为**long
    double**的更精确的`double`版本，将精度提升了一步。`long double`标识符用于80位存储容器，其范围为3.4E^(-4932)到1.1E^(4932)和19位有效数字的精度：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In our preceding example, note the rounding error in the last digit. We populated
    the `piDouble` object using pi out to 30 significant digits, but double can only
    retain 15 significant digits, so the software rounded off everything after that.
    When pi is calculated out to 15 significant digits, we get 3.1415926535897932,
    but our float value is now 3.141592653589793 due to this limitation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面的示例中，请注意最后一位的舍入误差。我们使用 pi 的 30 位有效数字填充了 `piDouble` 对象，但 double 只能保留 15
    位有效数字，因此软件将之后的数字四舍五入。当 pi 计算到 15 位有效数字时，我们得到 3.1415926535897932，但由于这个限制，我们的 float
    值现在是 3.141592653589793。
- en: '**Swift**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Swift uses the `double` identifier for 64-bit floating-point values. In Swift,
    a double has an approximate range of 2.3E^(-308) to 1.7E^(308) and a precision
    of 15 significant digits. Note that, according to Apple''s documentation for Swift,
    when either `float` or `double` types will suffice, double is recommended:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 使用 `double` 标识符表示 64 位浮点值。在 Swift 中，double 的近似范围是 2.3E^(-308) 到 1.7E^(308)，精度为
    15 位有效数字。请注意，根据 Apple 对 Swift 的文档，当 `float` 或 `double` 类型都适用时，推荐使用 double：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In our preceding example, note the rounding error in the last digit. We populated
    the `doubleValue` object using pi out to 30 significant digits, but double can
    only retain 15 significant digits, so the software rounded off everything after
    that. When pi is calculated out to 15 significant digits, we get 3.141592653589793,
    but our `float` value is now 3.14159265358979 due to this limitation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面的示例中，请注意最后一位的舍入误差。我们使用 pi 的 30 位有效数字填充了 `doubleValue` 对象，但 double 只能保留
    15 位有效数字，因此软件将之后的数字四舍五入。当 pi 计算到 15 位有效数字时，我们得到 3.141592653589793，但由于这个限制，我们的
    `float` 值现在是 3.141592653589793。
- en: Currency
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 货币
- en: Due to the inherent inaccuracy found in floating point arithmetic, grounded
    in the fact that they are based on binary arithmetic, floats, and doubles cannot
    accurately represent the base-10 multiples we use for currency. Representing currency
    as a `float` or `double` may seem like a good idea at first as the software will
    round off the tiny errors in your arithmetic. However, as you begin to perform
    more and complex arithmetic operations on these inexact results, your precision
    errors will begin to add up and result in serious inaccuracies and bugs that can
    be very difficult to track down. This makes float and double data types insufficient
    for working with currency where perfect accuracy for multiples of 10 is essential.
    Luckily, each of the languages we are discussing provides a mechanism to work
    with currency, and other arithmetic problems require high precision in based-10
    values and calculations.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浮点算术固有的不精确性，这是基于它们基于二进制算术的事实，浮点数和 double 无法准确表示我们用于货币的十进制倍数。将货币表示为 `float`
    或 `double` 最初可能看起来是个好主意，因为软件会四舍五入你的算术中的微小误差。然而，当你开始在这些不精确的结果上执行更多和更复杂的算术运算时，你的精度误差将开始累积，并导致严重的不准确性和难以追踪的漏洞。这使得
    float 和 double 数据类型在需要完美精度（10 的倍数）的货币处理中不足。幸运的是，我们讨论的每种语言都提供了一种处理货币以及需要高精度十进制值和计算的其它算术问题的机制。
- en: '**C#**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'C# uses the `decimal` keyword for precise floating-point values. In C#, `decimal`
    has a range of ±1.0 x 10^(-28) to ±7.9 x 10^(28) with a precision of 28 or 29
    significant digits:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: C# 使用 `decimal` 关键字来表示精确的浮点值。在 C# 中，`decimal` 的范围是 ±1.0 x 10^(-28) 到 ±7.9 x
    10^(28)，精度为 28 或 29 位有效数字：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding example, note that we populated the `decimalValue` object with
    pi out to 30 significant digits, but the framework rounded this off to 28 significant
    digits.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，请注意我们使用 pi 的 30 位有效数字填充了 `decimalValue` 对象，但框架将其四舍五入到 28 位有效数字。
- en: '**Java**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'Java provides an object-oriented solution to the currency problem in the form
    of the `BigDecimal` class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Java 以 `BigDecimal` 类的形式提供了一个面向对象的解决方案来解决货币问题：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding example, we are initializing the `BigDecimal` class using a constructor
    that takes a string representation of our decimal value as a parameter. When the
    program runs, the output proves that the `BigDecimal` class did not lose any of
    our intended precision, returning pi to 30 significant digits.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用一个接受字符串表示的十进制值作为参数的构造函数初始化 `BigDecimal` 类。当程序运行时，输出证明 `BigDecimal`
    类没有丢失任何我们预期的精度，返回了 30 位有效数字的 pi。
- en: '**Objective-C**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'Objective-C also provides an object-oriented solution to the currency problem
    in the form of the `NSDecimalNumber` class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 也以 `NSDecimalNumber` 类的形式提供了一个面向对象的解决方案来解决货币问题：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Swift**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Swift also provides an object-oriented solution to the currency problem, and
    it is the same class used in Objective-C, the `NSDecimalNumber` class. The Swift
    version is initialized slightly differently, but it retains the same functionality
    as its Objective-C counterpart:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 还提供了一个面向对象的解决方案来解决货币问题，并且它与 Objective-C 中使用的同一个类相同，即 `NSDecimalNumber`
    类。Swift 版本初始化略有不同，但与 Objective-C 的对应版本具有相同的功能：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that precision, in both the Objective-C and Swift examples, is retained
    out to 30 significant digits, proving that the `NSDecimalNumber` class is superior
    for working with currency and other base-10 values.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 Objective-C 和 Swift 的示例中，精度都保留到 30 位有效数字，这证明了 `NSDecimalNumber` 类在处理货币和其他十进制值方面是优越的。
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'In the spirit of full disclosure, there is a simple and arguably more elegant
    alternative to using these custom types. You could just use `int` or `long` for
    your currency calculations and count in cents rather than dollars:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在充分披露的精神下，使用这些自定义类型有一个简单且可以说是更优雅的替代方案。你可以直接使用 `int` 或 `long` 进行货币计算，并按分而不是按美元计数：
- en: //C# long total = 316;
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: //C# long total = 316;
- en: //$3.16
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: //$3.16
- en: Typecasting
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型转换
- en: In the realm of computer science, **type conversion** or **typecasting** means
    to converting an instance of one object or data type into another. For example,
    let's say you make a call to a method that returns an integer value but you need
    to use that value in another method that requires a long value as the input parameter.
    Since an integer value by definition exists within the realm of allowable `long`
    values, the `int` value can be redefined as a long.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学领域，**类型转换**或**类型转换**意味着将一个对象或数据类型的实例转换为另一个。例如，假设你调用了一个返回整数值的方法，但你需要使用该值在另一个需要将
    `long` 值作为输入参数的方法中。由于整数值根据定义存在于允许的 `long` 值范围内，因此 `int` 值可以被重新定义为 `long`。
- en: Such conversions can be done through either implicit conversion, sometimes called
    **coercion**, or explicit conversion, otherwise known as **casting**. To fully
    appreciate casting, we also need to understand the difference between **static**
    and **dynamic** languages.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换可以通过隐式转换（有时称为**强制转换**）或显式转换（通常称为**类型转换**）来完成。要完全理解类型转换，我们还需要了解**静态**和**动态**语言之间的区别。
- en: Statically versus dynamically typed languages
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态类型语言与动态类型语言
- en: A statically typed language will perform its **type checking** at compile time.
    This means that, when you try to build your solution, the compiler will verify
    and enforce each of the constraints that apply to the types in your application.
    If they are not enforced, you will receive an error and the application will not
    build. C#, Java, and Swift are all statically typed languages.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型语言将在编译时执行其**类型检查**。这意味着，当你尝试构建你的解决方案时，编译器将验证并强制执行应用于应用程序中类型的每个约束。如果它们没有被强制执行，你将收到错误，并且应用程序将无法构建。C#、Java
    和 Swift 都是静态类型语言。
- en: 'Dynamically typed languages, on the other hand, do most or all of their type
    checking at run time. This means that the application might build just fine, but
    could experience a problem while it is actually running if the developer wasn''t
    careful in how he wrote the code. Objective-C is a dynamically typed language
    because it uses a mixture of statically typed objects and dynamically typed objects.
    The plain C objects used for numeric values discussed earlier in this chapter
    are all examples of statically typed objects, while the Objective-C classes `NSNumber`
    and `NSDecimalNumber` are both examples of dynamically typed objects. Consider
    the following code example in Objective-C:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型语言，另一方面，在运行时进行大多数或所有的类型检查。这意味着应用程序可能构建得很好，但如果开发者没有在编写代码时小心谨慎，那么在应用程序实际运行时可能会遇到问题。Objective-C
    是一种动态类型语言，因为它使用静态类型对象和动态类型对象的混合。本章前面讨论的用于数值的普通 C 对象都是静态类型对象的例子，而 Objective-C 类
    `NSNumber` 和 `NSDecimalNumber` 都是动态类型对象的例子。以下是一个 Objective-C 代码示例：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The compiler will throw an error on the first line, stating `Initializing 'double'
    with an expression of incompatible type 'NSString *'`. That's because `double`
    is a plain C object, and it is statically typed. The compiler knows what to do
    with this statically typed object before we even get to the build, so your build
    will fail.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将在第一行抛出错误，指出 `初始化 'double' 时使用了一个不兼容类型的表达式 'NSString *'`。这是因为 `double` 是一个普通的
    C 对象，它是静态类型的。编译器在我们甚至开始构建之前就知道如何处理这个静态类型的对象，所以你的构建将失败。
- en: However, the compiler will only throw a warning on the second line, stating
    `Incompatible pointer types initializing 'NSNumber *' with an expression of type
    'NSString *'`. That's because `NSNumber` is an Objective-C class, and it is dynamically
    typed. The compiler is smart enough to catch your mistake, but it will allow the
    build to succeed (unless you have instructed the compiler to treat warnings as
    errors in your build settings).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编译器只会在第二行抛出警告，指出`初始化 'NSNumber *' 的指针类型不兼容，表达式类型为 'NSString *'`。这是因为`NSNumber`是Objective-C类，它是动态类型的。编译器足够智能，能够捕捉到您的错误，但它将允许构建成功（除非您已在构建设置中指示编译器将警告视为错误）。
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Although the forthcoming crash at runtime is obvious in the previous example,
    there are cases where your app will function perfectly fine despite the warnings.
    However, no matter what type of language you are working with, it is always a
    good idea to consistently clean up your code warnings before moving on to new
    code. This helps keep your code clean and avoids any runtime errors which can
    be difficult to diagnose.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在前面的示例中，运行时即将发生的崩溃是明显的，但有些情况下，即使有警告，您的应用程序也能正常工作。然而，无论您使用的是哪种编程语言，始终在继续编写新代码之前一致地清理代码警告都是一个好主意。这有助于保持代码整洁，并避免任何难以诊断的运行时错误。
- en: On those rare occasions where it is not prudent to address the warning immediately,
    you should clearly document your code and explain the source of the warning so
    that other developers will understand your reasoning. As a last resort, you can
    take advantage of macros or pre-processor (pre-compiler) directives that can suppress
    warnings on a line-by-line basis.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些不适宜立即处理警告的罕见情况下，您应该清楚地记录代码并解释警告的来源，以便其他开发者能够理解您的推理。作为最后的手段，您可以利用宏或预处理器（预编译器）指令，这些指令可以逐行抑制警告。
- en: Implicit and explicit casting
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式和显式转换
- en: '**Implicit casting** does not require any special syntax in your source code.
    This makes implicit casting somewhat convenient. Consider the following code example
    in C#:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐式转换**在您的源代码中不需要任何特殊的语法。这使得隐式转换变得相对方便。以下是一个C#中的代码示例：'
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this scenario, since `a` can be defined as both an `int` and a `double`,
    the cast to type `double` is perfectly acceptable because we have defined both
    types manually. However, since implicit casts do not necessarily define their
    types manually, the compiler cannot always determine which constraints apply to
    the conversion and therefore will not be able to check these constraints until
    runtime. This makes the implicit cast also somewhat dangerous. Consider the following
    code example also in C#:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于`a`可以被定义为`int`和`double`两种类型，因此转换为`double`类型是完全可接受的，因为我们已经手动定义了这两种类型。然而，由于隐式转换不一定手动定义它们的类型，编译器无法始终确定哪些约束适用于转换，因此无法在编译时检查这些约束。这使得隐式转换也具有一定的危险性。以下是一个同样在C#中的代码示例：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is an implicit conversion because you have not told the compiler how to
    treat the string value. In this case, the conversion will fail when you try to
    build the application, and the compiler will throw an error for this line, stating
    `Cannot implicitly convert type ''string'' to ''double''`. Now, consider the explicitly
    cast version of this example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种隐式转换，因为你没有告诉编译器如何处理字符串值。在这种情况下，当尝试构建应用程序时，转换将失败，编译器将抛出错误，指出`无法隐式转换类型 'string'
    到 'double'`。现在，考虑这个示例的显式转换版本：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This conversion is explicit and therefore type-safe, assuming that the string
    value is *parsable*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换是显式的，因此是类型安全的，假设字符串值是*可解析的*。
- en: Widening and narrowing
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展和收缩
- en: When casting between two types, an important consideration is whether the result
    of the change is within the range of the target data type. If your source data
    type supports more bytes than your target data type, the cast is considered to
    be a **narrowing conversion**.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种类型之间进行转换时，一个重要的考虑因素是变化的结果是否在目标数据类型的范围内。如果您的源数据类型支持的字节比目标数据类型多，则这种转换被认为是**收缩转换**。
- en: 'Narrowing conversions are either casts that cannot be proven to always succeed
    or casts that are known to possibly lose information. For example, casting from
    a float to an integer will result in loss of information (precision in this case),
    as the result will be rounded off to the nearest whole number. In most statically
    typed languages, narrowing casts cannot be performed implicitly. Here is an example
    by borrowing from the C# single-precision and double-precision examples earlier
    in this chapter:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 窄化转换要么是无法证明始终成功的转换，要么是已知可能丢失信息的转换。例如，从浮点数到整数的转换将导致信息丢失（在这种情况下是精度），因为结果将被四舍五入到最接近的整数。在大多数静态类型语言中，窄化转换不能隐式执行。以下是一个例子，借鉴了本章前面提到的
    C# 单精度和双精度示例：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this example, the compiler will throw an error, stating `Cannot implicitly
    convert type ''double'' to ''float''. And explicit conversion exists (Are you
    missing a cast?)`. The compiler sees this as a narrowing conversion and treats
    the loss of precision as an error. The error message itself is helpful and suggests
    an explicit cast as a potential solution for our problem:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，编译器将抛出一个错误，指出“无法隐式转换类型 'double' 到 'float'”。并且存在显式转换（你是否遗漏了一个转换？）。编译器将其视为窄化转换，并将精度损失视为错误。错误消息本身很有帮助，并建议显式转换作为我们问题的潜在解决方案：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We have now explicitly cast the double value `piDouble` to a `float`, and the
    compiler no longer concerns itself with loss of precision.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经明确地将双精度值 `piDouble` 转换为 `float` 类型，编译器不再关心精度损失的问题。
- en: 'If your source data type supports fewer bytes than your target data type, the
    cast is considered to be a **widening conversion**. Widening conversions will
    preserve the source object''s value, but may change its representation in some
    way. Most statically typed languages will permit implicit widening casts. Let''s
    borrow again from our previous C# example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的源数据类型支持的字节少于您的目标数据类型，则该转换被认为是**宽化转换**。宽化转换将保留源对象的值，但可能会以某种方式更改其表示。大多数静态类型语言将允许隐式宽化转换。让我们再次借鉴我们之前的
    C# 示例：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this example, the compiler is completely satisfied with the implicit conversion
    and the app will build. Let''s expand the example further:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，编译器对隐式转换完全满意，应用将构建。让我们进一步扩展这个例子：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This explicit cast improves readability, but does not change the nature of the
    statement in any way. The compiler also finds this format to be completely acceptable,
    even if it is somewhat more verbose. Beyond improved readability, explicit casting
    when widening adds nothing to your application. Therefore, it is your preference
    if you want to use explicit casting when widening is a matter of personal preference.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种显式转换提高了可读性，但以任何方式都没有改变语句的本质。编译器也认为这种格式完全可接受，尽管它可能有些冗长。除了提高可读性之外，在宽化转换时显式转换对您的应用程序没有任何增加。因此，如果您想在宽化转换时使用显式转换，这是一个个人偏好的问题。
- en: Boolean data type
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔数据类型
- en: Boolean data types are intended to symbolize binary values, usually denoted
    by `1` and `0`, `true` and `false`, or even `YES` and `NO`. Boolean types are
    used to represent truth logic, which is based on Boolean algebra. This is just
    a way of saying that Boolean values are used in conditional statements, such as
    `if` or `while`, to evaluate logic or repeat an execution conditionally.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数据类型旨在表示二进制值，通常用 `1` 和 `0`、`true` 和 `false` 或甚至 `YES` 和 `NO` 表示。布尔类型用于表示基于布尔代数的真值逻辑。这仅仅是一种说法，即布尔值用于条件语句，如
    `if` 或 `while`，以评估逻辑或有条件地重复执行。
- en: 'Equality operations include any operations that compare the value of any two
    entities. The equality operators are:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 等于操作包括任何比较两个实体值值的操作。等价操作符包括：
- en: '`==` implies equal to'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==` 表示等于'
- en: '`!=` implies not equal to'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!=` 表示不等于'
- en: 'Relational operations include any operations that test a relation between two
    entities. The relational operators are:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 关系操作包括任何测试两个实体之间关系的操作。关系操作符包括：
- en: '`>` implies greater than'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>` 表示大于'
- en: '`>=` implies greater than or equal to'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>=` 表示大于或等于'
- en: '`<` implies less than'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<` 表示小于'
- en: '`<=` implies less than or equal to'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<=` 表示小于或等于'
- en: Logic operations include any operations in your program that evaluate and manipulate
    Boolean values. There are three primary logic operators, namely `AND`, `OR`, and
    `NOT`. Another, slightly less commonly used operator, is the **exclusive or**,
    or XOR operator. All Boolean functions and statements can be built with these
    four basic operators.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算包括程序中评估和操作布尔值的任何操作。主要有三个逻辑运算符，即`AND`、`OR`和`NOT`。另一个稍微不太常用的运算符是**异或**，或称为XOR运算符。所有布尔函数和语句都可以使用这四个基本运算符构建。
- en: 'The AND operator is the most exclusive comparator. Given two Boolean variables
    A and B, AND will return `true` if, and only if, both A and B is `true`. Boolean
    variables are often visualized using tools called **truth tables**. Consider the
    following truth table for the AND operator:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: AND运算符是最为严格的比较运算符。给定两个布尔变量A和B，AND运算符只有在A和B都为`true`时才会返回`true`。布尔变量通常使用称为**真值表**的工具进行可视化。以下为AND运算符的真值表：
- en: '| **A** | **B** | **A ^ B** |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **A ^ B** |'
- en: '| 0 | 0 | 0 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 0 | 1 | 0 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 |'
- en: '| 1 | 0 | 0 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 |'
- en: '| 1 | 1 | 1 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: This table demonstrates the AND operator. When evaluating a conditional statement,
    0 is considered to be `false`, while any other value is considered to be `true`.
    Only when the value of both A and B is `true`, is the resulting comparison of
    A ^ B also `true`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此表展示了AND运算符。在评估条件语句时，0被视为`false`，而任何其他值都视为`true`。只有当A和B的值都为`true`时，A与B的运算结果才为`true`。
- en: 'The OR operator is the inclusive operator. Given two Boolean variables A and
    B, OR will return `true` if either A or B is `true`, including the case when both
    A and B are `true`. Consider the following truth table for the OR operator:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: OR运算符是包含运算符。给定两个布尔变量A和B，OR运算符在A或B为`true`时返回`true`，包括A和B都为`true`的情况。以下为OR运算符的真值表：
- en: '| **A** | **B** | **A v B** |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **A v B** |'
- en: '| 0 | 0 | 0 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 0 | 1 | 1 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 |'
- en: '| 1 | 0 | 1 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 |'
- en: '| 1 | 1 | 1 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: 'Next, the NOT A operator is `true` when A is `false`, and `false` when A is
    `true`. Consider the following truth table for the NOT operator:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，NOT A运算符在A为`false`时为`true`，在A为`true`时为`false`。以下为NOT运算符的真值表：
- en: '| **A** | **!A** |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **!A** |'
- en: '| 0 | 1 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 |'
- en: '| 1 | 0 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 |'
- en: 'Finally, the XOR operator is `true` when either A or B is `true`, but not both.
    Another way to say it is, XOR is `true` when A and B are different. There are
    many occasions where it is useful to evaluate an expression in this manner, so
    most computer architectures include it. Consider the following truth table for
    XOR:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，XOR运算符在A或B为`true`但不同时为`true`时为`true`。另一种说法是，XOR在A和B不同时为`true`。在许多情况下，以这种方式评估表达式非常有用，因此大多数计算机架构都包括它。以下为XOR运算符的真值表：
- en: '| **A** | **B** | **A XOR B** |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **A XOR B** |'
- en: '| 0 | 0 | 0 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 0 | 1 | 1 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 |'
- en: '| 1 | 0 | 1 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 |'
- en: '| 1 | 1 | 0 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 |'
- en: Operator precedence
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符优先级
- en: 'Just as with arithmetic, comparison and Boolean operations have **operator
    precedence**. This means the architecture will give a higher precedence to one
    operator over another. Generally speaking, the Boolean order of operations for
    all languages is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 就像算术一样，比较和布尔运算也有**运算符优先级**。这意味着架构将赋予一个运算符比另一个运算符更高的优先级。一般来说，所有语言的布尔运算顺序如下：
- en: Parentheses
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号
- en: Relational operators
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系运算符
- en: Equality operators
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等式运算符
- en: Bitwise operators (not discussed)
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位运算符（未讨论）
- en: NOT
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NOT
- en: AND
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AND
- en: OR
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OR
- en: XOR
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XOR
- en: Ternary operator
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三元运算符
- en: Assignment operators
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: It is extremely important to understand operator precedence when working with
    Boolean values, because mistaking how the architecture will evaluate complex logical
    operations will introduce bugs in your code that you will not understand how to
    sort out. When in doubt, remember that, as in arithmetic parentheses, take the
    highest precedence and anything defined within them will be evaluated first.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理布尔值时，理解运算符优先级非常重要，因为错误地理解架构将如何评估复杂的逻辑运算会在代码中引入你无法解决的错误。如有疑问，请记住，就像算术中的括号一样，优先级最高，括号内的内容将首先被评估。
- en: Short-circuiting
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 短路
- en: As you recall, AND only returns `true` when both of the operands are `true`,
    and OR returns `true` as soon as one operand is `true`. These characteristics
    sometimes make it possible to determine the outcome of an expression by evaluating
    only one of the operands. When your applications stops evaluation immediately
    upon determining the overall outcome of an expression, it is called **short-circuiting**.
    There are three main reasons why you would want to use short-circuiting in your
    code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，AND运算符仅在两个操作数都为`true`时返回`true`，而OR运算符只要有一个操作数为`true`就会返回`true`。这些特性有时使得仅通过评估其中一个操作数就能确定表达式的结果成为可能。当你的应用程序在确定表达式的整体结果后立即停止评估时，这被称为**短路**。你可能会在代码中使用短路的三种主要原因。
- en: First, short-circuiting can improve your application's performance by limiting
    the number of operations your code must perform. Second, when later operands could
    potentially generate errors based on the value of a previous operand, short-circuiting
    can halt execution before the higher risk operand is reached. Finally, short-circuiting
    can improve the readability and complexity of your code by eliminating the need
    for nested logical statements.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，短路可以通过限制代码必须执行的操作数量来提高应用程序的性能。其次，当后续的操作可能基于先前操作数的值生成错误时，短路可以在达到更高风险的操作数之前停止执行。最后，短路可以通过消除嵌套逻辑语句的需要来提高代码的可读性和复杂性。
- en: '**C#**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'C# uses the `bool` keyword as an alias of `System.Boolean` and stores the values
    `true` and `false`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: C#使用`bool`关键字作为`System.Boolean`的别名，并存储`true`和`false`值：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Java**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'Java uses the `boolean` keyword for the primitive Boolean data type. Java also
    provides a `Boolean` wrapper class for the same primitive type:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Java使用`boolean`关键字表示原始布尔数据类型。Java还提供了一个`Boolean`包装类来表示相同的原始类型：
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Objective-C**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'Objective-C uses the `BOOL` identifier to represent Boolean values:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C使用`BOOL`标识符来表示布尔值：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As it happens, Boolean data types give Objective-C yet another opportunity to
    prove it is more complex than its counterparts. The language does not provide
    one identifier or class to represent logic values. It provides five. For the sake
    of simplicity (and because my editor won't give me the extra pages), we're only
    going to use `BOOL` in this text. If you want to know more, I encourage you to
    check out the *Additional resources* section at the end of this chapter.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，布尔数据类型给了Objective-C另一个证明它比其对手更复杂的机会。该语言没有提供一个标识符或类来表示逻辑值，而是提供了五个。为了简单起见（并且因为我的编辑器不会给我额外的页面），我们在这篇文章中只使用`BOOL`。如果你想了解更多，我鼓励你查看本章末尾的*附加资源*部分。
- en: '**Swift**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Swift uses the `Bool` keyword for the primitive Boolean data type:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Swift使用`Bool`关键字表示原始布尔数据类型：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding example, the Boolean object `c` is not explicitly declared
    as `Bool`, but it is implicitly typed as a `Bool`. In Swift terms, the data type
    has been *inferred* in this case. Also, note that Swift does not provide a specific
    XOR operator, so if you need that comparison, you should use the `(a != b)` pattern.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，布尔对象`c`并未显式声明为`Bool`，但它被隐式地指定为`Bool`。用Swift的话说，在这种情况下数据类型已经被*推断*。此外，请注意Swift不提供特定的XOR运算符，所以如果你需要这种比较，你应该使用`(a
    != b)`模式。
- en: Tip
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Objective-C nil values
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C nil值
- en: In Objective-C, the value `nil` also evaluates to `false`. Although other languages
    must handle NULL objects with care, Objective-C will not crash when it attempts
    to perform an operation on a nil object. Speaking from personal experience, this
    can be somewhat confusing for developers who learned C# or Java before learning
    Objective-C, and thus expect an unhandled NULL object to crash their app. However,
    it is common for Objective-C developers to use this behavior to their advantage.
    Many times, simply checking whether an object is `nil` logically confirms whether
    an operation was successful, saving you from writing tedious logical comparisons.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在Objective-C中，值`nil`也评估为`false`。尽管其他语言必须小心处理NULL对象，但Objective-C在尝试在nil对象上执行操作时不会崩溃。从我个人的经验来看，这可能会让在学习Objective-C之前先学习了C#或Java的开发者感到有些困惑，因为他们期望未处理的NULL对象会导致他们的应用崩溃。然而，Objective-C开发者通常利用这种行为来获得优势。很多时候，仅仅检查一个对象是否为`nil`在逻辑上就能确认操作是否成功，从而节省了你编写繁琐的逻辑比较。
- en: Strings
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: Strings are not precisely data types, although as developers we very often treat
    them as such. In actuality, strings are simply objects whose value is text; under
    the hood, strings contain a sequential collection of read-only `char` objects.
    This read-only nature of a string object makes strings **immutable**, which means
    the objects cannot be changed once they have been created in memory.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串并不是精确的数据类型，尽管作为开发者，我们经常将它们当作这样。实际上，字符串只是值是文本的对象；在底层，字符串包含一个只读的 `char` 对象的顺序集合。字符串对象的这种只读性质使得字符串
    **不可变**，这意味着一旦在内存中创建，对象就不能被更改。
- en: It is important to understand that changing any immutable object, not just a
    string, means your program is actually creating a new object in memory and discarding
    the old one. This is a more intensive operation than simply changing the value
    of an address in memory and requires more processing. Merging two strings together
    is called **concatenation**, and this is an even more costly procedure as you
    are disposing of two objects before creating a new one. If you find that you are
    editing your string values frequently, or frequently concatenating strings together,
    be aware that your program is not as efficient as it could be.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，更改任何不可变对象，不仅仅是字符串，意味着你的程序实际上是在内存中创建一个新的对象并丢弃旧的一个。这比简单地更改内存地址中的值要复杂得多，需要更多的处理。将两个字符串合并在一起称为
    **连接**，这是一个成本更高的过程，因为你是在创建新对象之前先丢弃了两个对象。如果你发现你经常编辑字符串值，或者经常将字符串连接在一起，请注意，你的程序可能没有它本可以做到的那样高效。
- en: Strings are strictly immutable in C#, Java, and Objective-C. It is interesting
    to note that the Swift documentation refers to strings as mutable. However, the
    behavior is similar to Java, in that, when a string is modified, it gets copied
    on assignment to another object. Therefore, although the documentation says otherwise,
    strings are effectively immutable in Swift as well.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C#、Java 和 Objective-C 中，字符串是严格不可变的。有趣的是，Swift 文档将字符串称为可变的。然而，行为与 Java 类似，即当字符串被修改时，它会在赋值给另一个对象时被复制。因此，尽管文档说不同，但在
    Swift 中字符串实际上也是不可变的。
- en: '**C#**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'C# uses the string keyword to declare string types:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: C# 使用字符串关键字来声明字符串类型：
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Java**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'Java uses the system class `String` to declare string types:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Java 使用系统类 `String` 来声明字符串类型：
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Objective-C**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'Objective-C provides the `NSString` class to create string objects:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 提供了 `NSString` 类来创建字符串对象：
- en: '[PRE35]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When you examine the Objective-C example, you might wonder why we have all that
    extra code for creating the purple object. That code is necessary because Objective-C
    does not provide a shortcut mechanism for concatenating strings like the other
    three languages we're using. So, in this scenario, I have chosen to place the
    two strings into an array and then call the `NSArray` method `componentsJoinedByString:`.
    I could have also chosen to use the `NSMutableString` class, which provides a
    method for concatenating strings. However, since we're not discussing mutable
    string classes in any of our selected languages, I have opted not to use that
    approach.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看 Objective-C 的示例时，你可能会想知道为什么我们需要为创建紫色对象编写那么多额外的代码。这段代码是必要的，因为 Objective-C
    并没有提供像我们使用的其他三种语言那样的字符串连接快捷机制。因此，在这种情况下，我选择将两个字符串放入一个数组中，然后调用 `NSArray` 方法 `componentsJoinedByString:`。我也可以选择使用
    `NSMutableString` 类，它提供了一个用于连接字符串的方法。然而，由于我们讨论的语言中并没有涉及可变字符串类，所以我选择了不使用这种方法。
- en: '**Swift**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Swift provides the `String` class to create string objects:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了 `String` 类来创建字符串对象：
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the basic data types available to a programmer
    in each of the four most common mobile development languages. Numeric and floating
    point data type characteristics and operations are as dependent on the underlying
    architecture as on the specifications of the language. You also learned about
    casting objects from one type to another and how the type of cast is defined as
    either a widening cast or a narrowing cast depending on the size of the source
    and target data types in the conversion. Next, we discussed Boolean type and how
    it is used in comparators to affect program flow and execution. In this, we discussed
    operator order of precedence and nested operations. You also learned how to use
    short-circuiting to improve your code's performance. Finally, we examined the
    `String` data type and what it means to work with mutable objects.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了在四种最常见的移动开发语言中，程序员可用的基本数据类型。数值和浮点数据类型的特性和操作既取决于底层架构，也取决于语言的规范。你还学习了如何将对象从一个类型转换为另一个类型，以及转换的类型是如何根据源数据和目标数据类型的大小定义为宽转换或窄转换的。接下来，我们讨论了布尔类型及其在比较器中如何影响程序流程和执行。在这里，我们讨论了运算符的优先级顺序和嵌套操作。你还学习了如何使用短路来提高代码的性能。最后，我们考察了`String`数据类型以及与可变对象一起工作的含义。
