- en: Chapter 7. Basic Function Definitions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 基本函数定义
- en: Mathematically, a function is a mapping of values in a domain to values in a
    range. Functions like sine or cosine map values from a domain of angles to a range
    of real values between -1 and +1\. The details of the mapping are summarized in
    the name, domain, and range. We'll use this function concept as a way to package
    our Python programming into something that allows us to summarize the implementation
    details using a name.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学的角度来看，一个函数是将定义域中的值映射到值域中的映射。像正弦或余弦这样的函数将角度域的值映射到-1和+1之间的实数值域。映射的详细信息总结在函数名、定义域和值域中。我们将使用这个函数概念来将我们的Python编程打包成可以使用名称总结实现细节的东西。
- en: We'll look at how to define and evaluate Python functions. In this chapter,
    we'll focus on Python functions that simply return Python objects as the range
    of values. In [Chapter 8](ch08.html "Chapter 8. More Advanced Functions"), *More
    Advanced Functions*, we'll look at generator functions; these are iterators, which
    are used with a `for` loop to produce sequences of values.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何定义和评估Python函数。在本章中，我们将关注仅返回Python对象作为值域的Python函数。在[第8章](ch08.html "第8章.
    更高级的函数")，*更高级的函数*中，我们将探讨生成器函数；这些是迭代器，它们与`for`循环一起使用以产生值序列。
- en: Python functions offer optional parameters as well as a mixture of positional
    and keyword parameters. This allows us to define a single function which has a
    number of variant signatures, allowing considerable flexibility in how the function
    is used.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python函数还提供可选参数以及位置参数和关键字参数的混合。这使得我们可以定义一个具有多个变体签名的单个函数，从而在函数的使用上提供了相当大的灵活性。
- en: Looking at the five kinds of callables
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看五种可调用类型
- en: 'Python offers five variations on the theme of a function. Each of these is
    a kind of callable object: we can call the object with argument values and it
    returns a result. Here''s how we''ll organize our exploration:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Python在函数主题上提供了五种变体。每一种都是一种可调用对象：我们可以用参数值调用对象，它返回一个结果。以下是我们将如何组织我们的探索：
- en: Basic functions created with the `def` statement are the subject of this chapter.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`def`语句创建的基本函数是本章的主题。
- en: Lambda forms are a function definition reduced to parameters and an expression;
    this is also a topic within this chapter.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda形式是将函数定义简化为参数和表达式；这也是本章的一个主题。
- en: Generator functions and the yield statement are something we'll look at in [Chapter
    8](ch08.html "Chapter 8. More Advanced Functions"), *More Advanced Functions*.
    These functions are iterators which can provide multiple results.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器函数和`yield`语句是我们将在[第8章](ch08.html "第8章. 更高级的函数")，*更高级的函数*中探讨的内容。这些函数是迭代器，可以提供多个结果。
- en: Function wrappers for class methods are something we'll look at in [Chapter
    11](ch11.html "Chapter 11. Class Definitions"), *Class Definitions*. These are
    built-in functions which leverage features of a class. A function like `len()`
    is implemented by the `__len__()` method of a collection.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数包装器用于类方法，我们将在[第11章](ch11.html "第11章. 类定义")，*类定义*中探讨。这些是利用类特性的内置函数。像`len()`这样的函数是由集合的`__len__()`方法实现的。
- en: Callable objects are also part of [Chapter 11](ch11.html "Chapter 11. Class
    Definitions"), *Class Definitions*. These are classes which include the `__call__()`
    method so that an instance of the class behaves like a basic function created
    with the `def` statement.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可调用对象也是[第11章](ch11.html "第11章. 类定义")，*类定义*的一部分。这些类包括`__call__()`方法，使得类的实例表现得像使用`def`语句创建的基本函数。
- en: All of these are variations on a common theme. They are ways to package some
    functionality so that it has a name, input parameters, and a result. This allows
    us to decompose large, complex programs into smaller, easier-to-understand functions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是基于一个共同主题的变体。它们是将某些功能打包成具有名称、输入参数和结果的方式。这使得我们可以将大型、复杂的程序分解成更小、更容易理解的函数。
- en: Defining functions with positional parameters
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用位置参数定义函数
- en: The essential Python function definition is built with the `def` statement.
    We provide a name, the names of the parameters, and an indented suite of statements
    that is the body of the function. The `return` statement provides the range of
    values.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python函数定义的基本结构是用`def`语句构建的。我们提供一个名称、参数的名称，以及函数体的缩进语句序列。`return`语句提供值域。
- en: 'The syntax looks like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 语法看起来像这样：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ve defined a name, `prod`, and provided a list of only one parameter, `sequence`.
    The body of the function includes three statements: assignment, `for`, and `return`.
    The expression in the `return` statement provides the resulting value.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`prod`的名称，并提供了一个只有一个参数`sequence`的列表。函数体包括三个语句：赋值、`for`和`return`。`return`语句中的表达式提供了结果值。
- en: This fits the mathematical idea of a function reasonably well. The domain of
    values is any numeric sequence, the range will be a value of the a type which
    reflects the data types in the sequence.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这合理地符合函数的数学概念。值域是任何数值序列，值域将是反映序列数据类型的类型值。
- en: 'We evaluate a function by simply using the name and a specific value for the
    argument in an expression:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在表达式中使用函数名和特定参数值来评估函数：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the first example, we provided a simple list display, `[1, 2, 3, 4]`, as
    an argument. This was assigned to the parameter of the function, `sequence`. The
    evaluation of the function returned the product of that sequential collection
    of items.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们提供了一个简单的列表显示`[1, 2, 3, 4]`作为参数。这被分配给函数的参数`sequence`。函数的评估返回了这些序列项的乘积。
- en: In the second example, we provided a `range()` object as the argument to the
    `prod()` function. This argument value is assigned to the parameter of the function.
    When used with a `for` loop, the range object behaves like a sequence collection,
    and a product is computed and returned.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们将一个`range()`对象作为`prod()`函数的参数。这个参数值被分配给函数的参数。当与`for`循环一起使用时，范围对象表现得像一个序列集合，计算并返回一个乘积。
- en: Defining multiple parameters
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义多个参数
- en: 'Python offers us a variety of ways to assign values to parameters. In the simplest
    case, the argument values are assigned to the parameters based on position. Here''s
    a function with two positional parameters:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了多种方式来为参数赋值。在最简单的情况下，参数值根据位置分配给参数。这里有一个具有两个位置参数的函数：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We've defined a function that requires the length of the sail's boom, usually
    called the "E" dimension, and the height of the mast along which the sail is rigged,
    usually called the "P" dimension. Given these two numbers, and an assumption about
    the curvature of the sail, we return the approximate sail area.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个函数，该函数需要帆杆的长度，通常称为“E”维度，以及帆索的长度，通常称为“P”维度。给定这两个数字以及关于帆曲率的假设，我们返回帆的大致面积。
- en: We can evaluate this function providing the two positional parameters for boom
    length and mast height.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以评估这个函数，提供两个位置参数，即帆杆长度和桅杆高度。
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can define a function with any number of parameters. A function with a large
    number of parameters will tend to push the edge of the envelope on comprehensibility.
    A good function should have a tidy summary that makes it possible to understand
    the function's purpose without having to struggle with too many details.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义具有任何数量的参数的函数。具有大量参数的函数可能会使可理解性达到极限。一个好的函数应该有一个整洁的摘要，使得在不详细研究太多细节的情况下也能理解函数的目的。
- en: Using the return statement
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`return`语句
- en: 'The `return` statement has two purposes: it ends the function''s execution,
    and it can optionally provide the result value for the function. The `return`
    statement is optional. This leads to three use cases:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`语句有两个目的：它结束函数的执行，并且可以可选地提供函数的结果值。`return`语句是可选的。这导致三种用法：'
- en: 'No `return` statement: The function finishes at the end of the suite of statements.
    The return value is `None`.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有使用`return`语句：函数在语句块结束时结束。返回值是`None`。
- en: 'A `return` statement with no expression: The function finishes when the `return`
    statement is executed, the result is `None`.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有表达式的`return`语句：当执行`return`语句时，函数结束，结果是`None`。
- en: 'A `return` statement with an expression: The function finishes when the `return`
    statement is executed, the value of the expression is the result. A `return` statement
    with a list of expressions creates a `tuple`, suitable for multiple assignment.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有表达式的`return`语句：当执行`return`语句时，函数结束，表达式的值是结果。带有表达式列表的`return`语句创建一个`tuple`，适合多重赋值。
- en: 'Here''s a function with no `return` statement:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个没有`return`语句的函数：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function consists of a single expression statement that uses the `print()`
    function. There's no explicit `return` so the default return value will be `None`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数由一个使用`print()`函数的单个表达式语句组成。没有显式的`return`，所以默认返回值将是`None`。
- en: 'It''s common to use a `return` statement to finish early when an exception
    condition has been met, otherwise you execute the rest of the suite of statements
    in the function definition. It looks like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当满足异常条件时，通常使用 `return` 语句提前结束，否则执行函数定义中的语句序列的其余部分。它看起来像这样：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This function expects a collection of data. It will compute two values from
    that collection: `s0` and `s1`. The `s0` value will be a count of items, the `s1`
    value will be the sum of the items. If the count is too small, the function simply
    returns. If the count is large enough, then additional processing is done: the
    values are printed along with the absolute difference between the value and the
    average.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数期望一个数据集合。它将从该集合中计算两个值：`s0` 和 `s1`。`s0` 值将是项目数量的计数，`s1` 值将是项目的总和。如果计数太小，函数将直接返回。如果计数足够大，则进行额外的处理：打印值及其与平均值的绝对差异。
- en: There's no `return` statement at the end of the suite of statements, since this
    is not required. Using a `return` statement in the middle of a function allows
    us to avoid deeply-nested `if` statements.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在语句序列的末尾没有 `return` 语句，因为这不是必需的。在函数中间使用 `return` 语句允许我们避免深层嵌套的 `if` 语句。
- en: Note that the variables `s0`, `s1`, and `m`, are created in a local namespace
    that only exists while the function is being evaluated. Once the function is finished,
    the local namespace is removed, the reference counts are decremented and the interim
    objects are cleaned up. We'll look at additional details in the *Working with
    namespaces* section later in this chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，变量 `s0`、`s1` 和 `m` 是在局部命名空间中创建的，该命名空间仅在函数被评估时存在。一旦函数完成，局部命名空间将被移除，引用计数将减少，临时对象将被清理。我们将在本章后面的
    *使用命名空间* 部分查看更多细节。
- en: 'The built-in function `divmod()` returns two results. We often use multiple
    assignments like this: `q, r = divmod(n, 16)`; it will assign the two results
    to two variables, `q` and `r`. We can write a function that returns multiple values
    by including multiple expressions on the `return` statement.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数 `divmod()` 返回两个结果。我们经常使用这样的多重赋值：`q, r = divmod(n, 16)`；它将两个结果赋值给两个变量，`q`
    和 `r`。我们可以在 `return` 语句中包含多个表达式来编写返回多个值的函数。
- en: In the *Mutable and immutable argument values* section, we'll show a function
    that has multiple return values.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *可变和不可变参数值* 部分，我们将展示一个具有多个返回值的函数。
- en: Evaluating a function with positional or keyword arguments
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用位置或关键字参数评估函数
- en: Python allows us to provide argument values with explicit parameter names. When
    we provide a name, it's called a keyword argument. For example, the `boat_summary()`
    function in the previous section can be used in a number of different ways.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许我们通过显式参数名称提供参数值。当我们提供名称时，它被称为关键字参数。例如，上一节中的 `boat_summary()` 函数可以用多种方式使用。
- en: 'We can provide the argument values positionally, like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按位置提供参数值，如下所示：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The arguments are assigned to the parameter variables of `name`, `rig`, and
    `sails` based on their position.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 参数根据其位置分配给 `name`、`rig` 和 `sails` 的参数变量。
- en: 'We can, as an alternative, do something like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以，作为替代，这样做：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This example provides all three arguments with keywords. Note that the position
    doesn't matter when providing keyword arguments. The keyword arguments must be
    provided *after* any positional arguments, but the order among the keyword arguments
    doesn't matter, since they are assigned to parameters by name.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例提供了所有三个参数的关键字。请注意，当提供关键字参数时，位置并不重要。关键字参数必须在任何位置参数之后提供，但关键字参数之间的顺序并不重要，因为它们是根据名称分配给参数的。
- en: 'We can use a mixture of positional and keyword arguments. For this to work,
    Python uses two rules to map argument values to a function''s parameters:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用位置和关键字参数的混合。为了使这起作用，Python 使用两条规则将参数值映射到函数的参数：
- en: Match all positional arguments to parameters from left-to-right.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左到右匹配所有位置参数到参数。
- en: Match all keyword parameters by name.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过名称匹配所有关键字参数。
- en: There are several additional rules to handle duplicates and default values—which
    include optional parameters—described later, in the section called *Defining optional
    parameters via default values*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些额外的规则来处理重复项和默认值——包括可选参数——将在稍后的 *通过默认值定义可选参数* 部分描述。
- en: In order for these rules to work properly, we must provide all positional parameters
    first, and then we can provide any keyword parameters after the positional parameters.
    We can't provide two values for the same parameter via position as well as keyword.
    Nor, for that matter, can we provide a keyword twice.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些规则能够正确工作，我们必须首先提供所有位置参数，然后我们可以在位置参数之后提供任何关键字参数。我们不能通过位置和关键字为同一个参数提供两个值。同样，也不能为关键字提供两次。
- en: 'Here''s a good example and a bad example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个好的例子和一个不好的例子：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the first example, the `name` parameter is matched positionally. The `sails`
    and `rig` parameters were matched by keyword.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，`name` 参数是按位置匹配的。`sails` 和 `rig` 参数是通过关键字匹配的。
- en: In the second example, there are both positional and keyword values for the
    `name` variable. This will raise a `TypeError` exception.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，`name` 变量既有位置值也有关键字值。这将引发一个 `TypeError` 异常。
- en: Because of this, it's very important to choose parameter variable names wisely.
    A good choice of parameter name can make keyword argument function evaluation
    very clear.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，选择参数变量名非常重要。一个好的参数名可以使关键字参数函数评估非常清晰。
- en: Writing a function's docstring
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写函数的文档字符串
- en: In order to save space, we haven't provided many examples of functions with
    docstrings. We'll address docstrings in detail in [Chapter 14](ch14.html "Chapter 14. Fit
    and Finish – Unit Testing, Packaging, and Documentation"), *Fit and Finish – Unit
    Testing, Packaging, and Documentation*. For now, we need to be aware that every
    function should, at the very least, have a summary. The summary is included as
    a triple-quoted string that must be the very first expression in the suite of
    statements of the function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，我们没有提供很多带有文档字符串的函数示例。我们将在第 14 章[第 14 章。完善 – 单元测试、打包和文档](ch14.html "Chapter
    14. Fit and Finish – Unit Testing, Packaging, and Documentation")中详细讨论文档字符串。现在，我们需要意识到每个函数至少应该有一个摘要。摘要包含在一个三引号字符串中，它必须是函数语句块中的第一个表达式。
- en: 'A function with a docstring looks like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 带有文档字符串的函数看起来像这样：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This particular triple-quoted string serves two purposes. First, it summarizes
    what the function does. We can read this when we look at the source file. We can
    also see this when we use `help(jib)`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的三引号字符串有两个作用。首先，它总结了函数的功能。当我们查看源文件时可以阅读它。我们也可以在调用 `help(jib)` 时看到它。
- en: The second purpose for this docstring is a way to provide a concrete example
    of how the function is used. The examples always look like they are simply copied
    from a REPL session and pasted into the docstring comment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文档字符串的第二个目的是提供一个具体的例子，说明如何使用该函数。这些例子看起来就像是从一个交互式解释器会话中复制并粘贴到文档字符串注释中一样。
- en: These REPL-formatted examples are located by using the `doctest` tool. After
    locating the examples, this tool can run the code to confirm that it works as
    advertised. All of the examples in this book were tested using `doctest`. While
    the details of testing are part of [Chapter 14](ch14.html "Chapter 14. Fit and
    Finish – Unit Testing, Packaging, and Documentation"), *Fit and Finish – Unit
    Testing, Packaging, and Documentation*, it's important to consider writing docstrings
    in every function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些交互式解释器格式的例子是通过使用 `doctest` 工具定位的。在定位示例后，这个工具可以运行代码以确认它按预期工作。本书中的所有示例都是使用 `doctest`
    测试的。虽然测试的细节是第 14 章[第 14 章。完善 – 单元测试、打包和文档](ch14.html "Chapter 14. Fit and Finish
    – Unit Testing, Packaging, and Documentation")的一部分，但考虑在每个函数中编写文档字符串是很重要的。
- en: Mutable and immutable argument values
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变和不可变参数值
- en: In some programming languages, there are multiple function evaluation strategies,
    including call-by-value and call-by-reference. In call-by-value semantics, copies
    of argument values are assigned to the parameter variables in a function. In call-by-reference
    semantics, a reference to a variable is used in the function. This means that
    an assignment statement inside a function could replace the value of a variable
    outside the function. Neither of these types of semantics apply to Python.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些编程语言中，存在多种函数评估策略，包括按值调用和按引用调用。在按值调用的语义中，将参数值的副本分配给函数中的参数变量。在按引用调用的语义中，在函数中使用变量的引用。这意味着函数内部的赋值语句可以替换函数外部的变量值。这两种语义类型都不适用于
    Python。
- en: Python uses a mechanism named "call-by-sharing" or "call-by-object". A function
    is given a reference to the original object. If that object is mutable, the function
    can mutate the object. The function cannot, however, assign to variables outside
    the function via the parameter variables. The function shares the objects, not
    the variables to which the objects are assigned.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用名为“按共享调用”或“按对象调用”的机制。函数被赋予原始对象的引用。如果该对象是可变的，函数可以修改该对象。然而，函数不能通过参数变量将变量赋值给函数外的变量。函数共享对象，而不是对象所分配的变量。
- en: One of the most important consequences is that the body of a function can assign
    new values to parameter variables without having any impact on the original arguments
    which are passed to a function. The parameter variables are strictly local to
    the function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的影响之一是，函数体可以给参数变量赋新值，而不会对传递给函数的原始参数有任何影响。参数变量严格局限于函数内部。
- en: 'Here''s a function that assigns new values to the parameter variable:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个给参数变量赋新值的函数：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function evaluates the `strip()` method of the `input_string` variable
    and assigns the resulting string to the parameter variable. It applies the `partition()`
    method to the new value of the `input_string` variable and assigns one of the
    three resulting strings to the parameter variable. It then returns this string
    object, assigning it to the parameter variable yet again.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数评估`input_string`变量的`strip()`方法，并将结果字符串赋给参数变量。它将`partition()`方法应用于新的`input_string`变量值，并将三个结果字符串之一赋给参数变量。然后它返回这个字符串对象，再次将其赋给参数变量。
- en: None of the assignment statements to the `input_string` parameter variable have
    any effect on any variables outside the function. When a function is evaluated,
    a separate namespace is used for the parameters and other local variables.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对`input_string`参数变量的任何赋值语句都不会影响函数外的任何变量。当函数被评估时，会使用一个独立的命名空间来处理参数和其他局部变量。
- en: Another consequence of the way Python works is that when we provide mutable
    objects as arguments, these objects can be updated by methods evaluated inside
    a function. The function's parameter variables will be references to the original
    mutable objects, and we can evaluate methods like the `remove()` or `pop()` functions
    that change the referenced object.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Python工作方式的一个后果是，当我们提供可变对象作为参数时，这些对象可以被函数内部评估的方法更新。函数的参数变量将是原始可变对象的引用，我们可以评估像`remove()`或`pop()`这样的方法，这些方法会改变引用的对象。
- en: 'Here''s a function which updates a `list` argument by removing selected values:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通过移除选定值来更新`list`参数的函数：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function expects a mutable object like a list, named `some_list`, and a
    value, named `modulus`. The function makes a temporary copy of the argument value
    using `some_list[:]`. For each value in this copy that is a multiple of the `modulus`
    value, we'll remove that copy from the original `some_list` object. This will
    mutate the original object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数期望一个可变对象，如列表，命名为`some_list`，以及一个值，命名为`modulus`。函数使用`some_list[:]`创建参数值的临时副本。对于这个副本中是`modulus`值的倍数的每个值，我们将从原始的`some_list`对象中移除该副本。这将修改原始对象。
- en: 'When we evaluate this function, it looks like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估这个函数时，它看起来是这样的：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We've created a simple list and assigned it to the `data` variable. This object
    referred to by the `data` variable was mutated by the `remove_mod()` function.
    All multiples of five and seven were discarded from the sequence.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的列表并将其赋值给`data`变量。这个由`data`变量引用的对象被`remove_mod()`函数修改。序列中的所有五和七的倍数都被丢弃。
- en: In this function, we need to create a temporary copy of the input `list` object
    before we can start removing values. If we try to iterate through a `list` while
    simultaneously removing items from that `list`, we'll get results that don't appear
    correct. It helps to have the original values separate from the mutating `list`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，在开始移除值之前，我们需要创建输入`list`对象的临时副本。如果我们试图在同时从该`list`中移除项目的同时迭代该`list`，我们会得到看起来不正确的结果。将原始值与正在修改的`list`分开是有帮助的。
- en: A function can create variables in the global namespace, and other non-local
    namespaces, by making special arrangements. This is done with the `global` and
    `nonlocal` statements shown in the *Working with namespaces* section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以通过`global`和`nonlocal`语句（在*使用命名空间*部分中展示）进行特殊安排，在全局命名空间和其他非局部命名空间中创建变量。
- en: Defining optional parameters via default values
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过默认值定义可选参数
- en: Python lets us provide a default value for a parameter. Parameters with default
    values are optional. The standard library is full of functions with optional parameters.
    One example is the `int()` function. We can use `int("48897")` to convert a string
    to an integer, assuming that the string represents a number in base 10\. We can
    use `int("48897", 16)` to explicitly state that the string should be treated as
    a hexadecimal value. The default value for the `base` parameter is 10.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许我们为参数提供一个默认值。具有默认值的参数是可选的。标准库中充满了具有可选参数的函数。一个例子是`int()`函数。我们可以使用`int("48897")`将字符串转换为整数，假设该字符串表示的是十进制数。我们可以使用`int("48897",
    16)`明确指出字符串应被视为十六进制值。`base`参数的默认值是10。
- en: 'Remember that we can use keyword arguments for a function. This means that
    we might want to write something like this: `int("48897", base=16)`, to make it
    abundantly clear what the second argument to the `int()` function is being used
    for.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们可以为函数使用关键字参数。这意味着我们可能想要写一些像这样的事情：`int("48897", base=16)`，以便清楚地表明`int()`函数的第二个参数是用来做什么的。
- en: Earlier, we listed two rules for matching argument values to parameters. When
    we introduce default values, we add two more rules.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们列出了两个将参数值与参数匹配的规则。当我们引入默认值时，我们增加了两个额外的规则。
- en: Match all positional arguments to parameters from left-to-right.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左到右将所有位置参数与参数匹配。
- en: Match all keyword parameters. In case of already-assigned positional parameters,
    raise a `TypeError` exception.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匹配所有关键字参数。如果已经分配了位置参数，将引发`TypeError`异常。
- en: Set default values for any missing parameters.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为任何缺失的参数设置默认值。
- en: In case there are parameters with no values, raise a `TypeError` exception.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有参数没有值，将引发`TypeError`异常。
- en: Note
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: This is not the final set of rules; there are a few more features to
    cover.'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：这不是最终的规则集；还有一些其他特性需要介绍。
- en: One important consequence of these rules is that the required parameters—those
    without default values—must be defined first. Parameters with default values must
    be defined last. The "required parameters first, optional parameters last" rule
    assures us that the positional matching process works.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则的一个重要后果是，必须首先定义所需的参数——即没有默认值的参数。具有默认值的参数必须最后定义。"先定义必需参数，后定义可选参数"的规则确保我们位置匹配过程能够正常工作。
- en: 'We provide the default value in the function definition. Here''s an example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数定义中提供默认值。以下是一个示例：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We've imported the `random` module so that we can use the `random.randint()`
    function. Our `dice()` function has two parameters, both of which have default
    values. The `n` parameter, if not provided, will have a value of 2\. The `sides`
    parameter, if omitted, will have a value of 6.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了`random`模块，以便可以使用`random.randint()`函数。我们的`dice()`函数有两个参数，它们都有默认值。如果未提供`n`参数，它的值将为2。如果省略了`sides`参数，它的值将为6。
- en: 'The body of this function is a list comprehension: it uses a generator expression
    to build a list of individual values. We''ll look at generator expressions in
    detail in [Chapter 8](ch08.html "Chapter 8. More Advanced Functions"), *More Advanced
    Functions*. For now, we can observe that it uses the `random.randint(1,sides)`
    function to generate numbers between 1 and the value of the `sides` parameter.
    The comprehension includes a `for` clause that iterates through `n` values.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的主体是一个列表推导式：它使用生成器表达式来构建一个包含单个值的列表。我们将在[第8章](ch08.html "第8章。更高级的函数")中详细探讨生成器表达式，*更高级的函数*。现在，我们可以观察到它使用`random.randint(1,sides)`函数来生成介于1和`sides`参数值之间的数字。推导式包括一个`for`子句，它遍历`n`个值。
- en: 'We can use this function in a number of different ways. Here are some examples:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用多种方式使用这个函数。以下是一些示例：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first example relies on default values to emulate the pair of dice commonly
    used in casino games like Craps. The second example uses six dice, typical for
    games like 10,000 (sometimes called Zilch or Crap Out.). The third example uses
    four four-sided dice, typical of games that use a variety of polyhedral dice.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例依赖于默认值来模拟在像Craps这样的赌场游戏中常用的两枚骰子。第二个示例使用六枚骰子，这在像10,000（有时称为Zilch或Crap Out）这样的游戏中很典型。第三个示例使用四枚四面骰子，这在使用各种多面骰子的游戏中很常见。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A note on testing: in order to provide repeatable unit tests for functions
    that involve the `random` module, we''ve set a specific seed value using `random.seed("test")`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 关于测试的说明：为了为涉及`random`模块的函数提供可重复的单元测试，我们已使用`random.seed("test")`设置了一个特定的种子值。
- en: A warning about mutable default values
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于可变默认值的警告
- en: Here's a pathological example. This shows a very bad programming practice; it's
    a mistake that many Python programmers make when they first start working with
    default values.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个病态的例子。这显示了非常糟糕的编程实践；这是许多Python程序员在开始使用默认值时犯的一个错误。
- en: 'This is a very bad idea:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常糟糕的想法：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''ve defined a simple function with only two parameter variables, `n` and
    `collection`. The collection has a default value of an empty list. (Spoiler alert:
    this will turn out to be a mistake.) The function will append a number of simulated
    six-sided dice to the given collection.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个只有一个参数变量`n`和`collection`的简单函数。`collection`的默认值是一个空列表。（剧透：这将会是一个错误。）该函数将模拟六面骰子的数量添加到给定的集合中。
- en: The function returns a value as well as mutating an argument. This means that
    we'll see the `return` value printed when we use this function in the REPL.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回一个值以及修改一个参数。这意味着当我们使用这个函数在REPL中时，我们会看到`return`值被打印出来。
- en: We can use this for games like Yacht, also called Generala or Poker Dice. A
    player has a "hand" of dice from which we'll remove dice and append new dice rolls.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个来玩像Yacht（也称为Generala或Poker Dice）这样的游戏。玩家有一副骰子，我们将从中移除骰子并附加新的骰子滚动。
- en: 'One use case is to create a `list` object and use this as an argument to the
    `more_dice()` function. This `list` object would get updated nicely. Here''s how
    that would work:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用例是创建一个`list`对象，并将其用作`more_dice()`函数的参数。这个`list`对象将得到很好的更新。下面是如何工作的示例：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We've created an empty `list` and assigned it to the `hand` variable. We provided
    this sequence object to the `more_dice()` function to have five values appended
    to the `hand` object. This gave us an initial roll of three sixes, a three, and
    a two. We can remove the two and three from the `hand1` object; we can reuse it
    with `more_dice(2, hand1)` to put two more dice into the hand.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个空的`list`并将其分配给`hand`变量。我们向`more_dice()`函数提供了这个序列对象，以便将五个值附加到`hand`对象上。这给了我们一个初始的三个六、一个三和一个二的骰子。我们可以从`hand1`对象中移除两个和三个；我们可以使用`more_dice(2,
    hand1)`重新使用它，将两个骰子放入手中。
- en: 'We can use another empty sequence as an argument to deal a second hand. Except
    for the results, it''s otherwise identical to the first example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用另一个空序列作为参数来发第二手牌。除了结果外，它与其他示例相同：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Everything seems to work properly. This is because we're providing an explicit
    argument for the collection parameter. Each of the hand objects is a distinct,
    empty `list`. Let's try to use the default value for the `collection` parameter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的东西似乎都工作得很好。这是因为我们为收集参数提供了一个明确的论证。每个手对象都是一个独特的、空的`list`。让我们尝试为`collection`参数使用默认值。
- en: 'In this third example, we won''t provide an argument, but rely on the default
    sequence returned by the `more_dice()` function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第三个示例中，我们不会提供参数，而是依赖于`more_dice()`函数返回的默认序列：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Wait. What just happened? How is this possible?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。刚才发生了什么？这是怎么可能的？
- en: As a hint, we'll need to search through the code for an object with a hidden,
    shared state. Earlier, we noted that a default `list` object would be a problem.
    This hidden `list` object is getting reused.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提示，我们需要在代码中搜索一个具有隐藏的共享状态的对象。之前，我们提到默认的`list`对象会是一个问题。这个隐藏的`list`对象正在被重复使用。
- en: 'What happens is this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情是这样的：
- en: When the `def` statement is executed, the expressions that define the parameter
    defaults are evaluated. This means that a single mutable `list` object is created
    as the default object for the `collection` parameter.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`def`语句执行时，定义参数默认值的表达式将被评估。这意味着创建了一个单个可变`list`对象作为`collection`参数的默认对象。
- en: When the `more_dice()` function is evaluated without an argument for the `collection`
    parameter, the one-and-only mutable `list` object is used as the default object.
    What's important is that a single mutable object is being reused. If, at any point,
    we update this object, that mutation applies to all shared uses of the object.
    Since it's returned by the function, this single `list` could be assigned to several
    variables.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`more_dice()`函数在没有`collection`参数的论证下评估时，唯一可变的`list`对象被用作默认对象。重要的是，单个可变对象正在被重复使用。如果在任何时刻我们更新了这个对象，那么这种变更将应用于该对象的所有共享使用。由于它是由函数返回的，这个单一的`list`可以被分配给几个变量。
- en: When the `more_dice()` function is evaluated a second time without an argument
    for the `collection` parameter, the mutated `list` object is re-used as the default.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`more_dice()`函数在没有`collection`参数的论证下第二次评估时，变更后的`list`对象被重新用作默认对象。
- en: From this, we can see that a mutable object is a terrible choice of a default
    value.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们可以看出可变对象是一个糟糕的默认值选择。
- en: 'Generally, we have to do something like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不得不做类似这样的事情：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This function uses an immutable and easily-recognized default value of `None`.
    If no argument value is provided for the `collection` variable, it will be set
    to `None`. We can replace the `None` value with a brand new `list` object created
    when the function is evaluated. We can then update this new `list` object, confident
    that we're not corrupting any mutable default object which is being reused.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用一个不可变且易于识别的默认值 `None`。如果没有为 `collection` 变量提供参数值，它将被设置为 `None`。我们可以在函数评估时创建一个新的空可变对象来替换
    `None` 值。然后我们可以更新这个新的列表对象，确信我们没有破坏任何正在被重复使用的可变默认对象。
- en: Tip
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't use a mutable object as a default value for a parameter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将可变对象用作参数的默认值。
- en: Avoid `list`, `dict`, `set`, and any other mutable type, as default parameter
    values. Use `None` as a default; replace the `None` with a new, empty mutable
    object.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用 `list`、`dict`、`set` 以及任何其他可变类型作为默认参数值。使用 `None` 作为默认值；将 `None` 替换为一个新的空可变对象。
- en: You've been warned.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经被警告了。
- en: This can lead to mistakes. It's a consequence of the way that function definition
    works and call-by-sharing semantics.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致错误。这是函数定义方式和按共享语义调用的一种后果。
- en: 'It''s possible to exploit this intentionally: we can use a mutable default
    value as a cache to retain values, creating functions which have hysteresis. A
    callable object may be a better way to implement functions with an internal cache
    or buffer. See [Chapter 11](ch11.html "Chapter 11. Class Definitions"), *Class
    Definitions*, for more information.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有意利用这一点是可能的：我们可以使用可变默认值作为缓存来保留值，创建具有滞后效应的函数。可调用对象可能是实现具有内部缓存或缓冲区功能的函数的更好方式。有关更多信息，请参阅[第11章](ch11.html
    "第11章。类定义")，*类定义*。
- en: Using the "everything else" notations of * and **
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 * 和 ** 的 "其余所有内容" 表示法
- en: Python offers even more flexibility in how we can define positional and keyword
    parameters for a function. The examples we've seen are all limited to a fixed
    and finite collection of argument values. Python allows us to write functions
    that have an essentially unlimited number of positional as well as keyword argument
    values.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在如何定义函数的位置参数和关键字参数方面提供了更多的灵活性。我们看到的例子都限于固定和有限的参数值集合。Python 允许我们编写具有无限数量位置参数以及关键字参数值的函数。
- en: 'Python will create a `tuple` of all unmatched positional parameters. It will
    also create a dictionary of all unmatched keyword parameters. This allows us to
    write functions that can be used like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Python 将创建一个包含所有未匹配位置参数的 `tuple`。它还将创建一个包含所有未匹配关键字参数的字典。这允许我们编写如下使用的函数：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This function accepts an arbitrary number of positional arguments. Compare
    this with the `prod()` function shown previously. Our previous example required
    a single sequence object, and we had to use that function as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受任意数量的位置参数。与前面展示的 `prod()` 函数进行比较。我们之前的例子需要一个单一的序列对象，我们必须按照以下方式使用该函数：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `prod2()` function will create a product of all argument values. Since the
    `prod2()` function can work with an unlimited collection of positional arguments,
    this leads to slightly simpler syntax for this function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`prod2()` 函数将创建所有参数值的乘积。由于 `prod2()` 函数可以与无限数量的位置参数一起工作，这导致该函数的语法稍微简单一些。'
- en: 'In order to write a function with an unlimited number of positional arguments,
    we must provide one parameter which has a `*` prefix. It looks like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写一个具有无限数量位置参数的函数，我们必须提供一个带有 `*` 前缀的参数。它看起来是这样的：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The definition of `prod2()` has all positional arguments assigned to the `*`
    prefix parameter, `*args`. The value of the `args` parameter is a tuple of the
    argument values.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`prod2()` 的定义将所有位置参数分配给带有 `*` 前缀的参数 `*args`。`args` 参数的值是一个包含参数值的元组。'
- en: 'Here''s a function which uses a mixture of positional and keyword parameters:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用位置和关键字参数混合的函数：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function will accept two arguments, `name` and `rig`. These can be supplied
    by position or by keyword. Any additional keyword parameters—other than `name`
    and `rig`—are collected into a dictionary and assigned to the `sails` parameter.
    The `sails.values()` expression extracts just the values from the `sails` dictionary;
    these are added together to write the final summary line.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将接受两个参数，`name` 和 `rig`。这些可以通过位置或关键字提供。除了 `name` 和 `rig` 之外的所有额外关键字参数被收集到一个字典中，并分配给
    `sails` 参数。`sails.values()` 表达式仅从 `sails` 字典中提取值；这些值被加在一起以写入最终的总结行。
- en: 'Here''s one of many ways that we can use this function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以使用此函数的许多方法之一：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We've provided the first argument value by position; this will be assigned to
    the first positional parameter, `name`. We've provided one of the defined parameters
    using a keyword argument, `rig`. The remaining keyword arguments are collected
    into a dictionary and assigned to the parameter named `sails`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过位置提供了第一个参数值；这将分配给第一个位置参数，`name`。我们使用关键字参数 `rig` 提供了一个定义好的参数。剩余的关键字参数被收集到一个字典中，并分配给名为
    `sails` 的参数。
- en: 'The `sails` dictionary will be assigned a value similar to this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`sails` 字典将被分配一个类似这样的值：'
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can use any dictionary processing on this mapping since it's a proper `dict`
    object.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个正确的 `dict` 对象，我们可以使用任何字典处理来处理这个映射。
- en: 'Earlier, we provided four rules for matching argument values with parameters.
    Here is a more complete set of rules for matching argument values with function
    parameters:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们提供了匹配参数值与参数的四条规则。以下是匹配参数值与函数参数的更完整的规则集：
- en: Match all positional arguments to parameters from left-to-right.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左到右匹配所有位置参数到参数。
- en: 'If there are more positional arguments than parameter names:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果位置参数多于参数名：
- en: If there's a parameter name with a `*` prefix, assign a `tuple` of remaining
    values to the prefixed parameter.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有一个带有 `*` 前缀的参数名，将剩余值的 `tuple` 分配给带前缀的参数。
- en: If there's no parameter with the `*` prefix, raise a `TypeError` exception.
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有带有 `*` 前缀的参数，则引发 `TypeError` 异常。
- en: Match all keyword parameters. In case of already-assigned positional parameters,
    raise a `TypeError` exception.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匹配所有关键字参数。如果已经分配了位置参数，则引发 `TypeError` 异常。
- en: 'If there are more keyword arguments than parameter names:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果关键字参数多于参数名：
- en: If there's a parameter name with a `**` prefix, assign `dict` of remaining keywords
    and values to the prefixed parameter.
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有一个带有 `**` 前缀的参数名，将剩余的关键字和值 `dict` 分配给带前缀的参数。
- en: If there's no parameter with the `**` prefix, raise a `TypeError` exception.
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有带有 `**` 前缀的参数，则引发 `TypeError` 异常。
- en: Apply default values to missing parameters.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将默认值应用于缺失的参数。
- en: In case of parameters which still have no values, raise a `TypeError` exception.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果参数仍然没有值，则引发 `TypeError` 异常。
- en: A consequence of these rules is that, at most, only one parameter can have a
    `*` prefix; similarly, at most, only one parameter can have a `**` prefix. These
    special cases must be given after all of the other parameters. The `*` prefix
    variable will be assigned an empty tuple if there are no surplus positional parameters.
    The `**` prefix variable will be assigned an empty dictionary if there no surplus
    keyword parameters.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则的一个后果是，最多只有一个参数可以有 `*` 前缀；同样，最多只有一个参数可以有 `**` 前缀。这些特殊情况必须在其他所有参数之后给出。如果没有剩余的位置参数，`*`
    前缀变量将被分配一个空元组。如果没有剩余的关键字参数，`**` 前缀变量将被分配一个空字典。
- en: When invoking a function, we must provide positional argument values first.
    We can provide keyword argument values in any order.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数时，我们必须首先提供位置参数值。我们可以按任何顺序提供关键字参数值。
- en: Using sequences and dictionaries to fill in *args and *kw
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用序列和字典填充 *args 和 *kw
- en: The `prod2()` function, shown earlier, expects individual values which are collected
    into a single `*args` tuple. If we invoke the function with `prod2(1, 2, 3, 4,
    5)`, then a tuple built from the five positional parameters is assigned to the
    `args` parameter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 之前展示的 `prod2()` 函数期望收集到单个 `*args` 元组中的单个值。如果我们用 `prod2(1, 2, 3, 4, 5)` 调用该函数，则从五个位置参数构建的元组被分配给
    `args` 参数。
- en: What if we want to provide a list to the `prod2()` function? How can we, in
    effect, write `prod2(some_list[0], some_list[1], some_list[2], … )`?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想向 `prod2()` 函数提供一个列表，我们如何有效地写出 `prod2(some_list[0], some_list[1], some_list[2],
    … )`？
- en: When we call a function using `prod2(*some_sequence)`, then the values of the
    given argument sequence are matched to positional parameters. Item zero from the
    argument sequence becomes the first positional parameter. Item one from the sequence
    becomes the second parameter, and so on. Each item is assigned until they're all
    used up. If there are extra argument values, and the function was defined with
    a parameter using a `*` prefix, the extra argument values are assigned to the
    `*` prefix parameter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`prod2(*some_sequence)`调用函数时，给定参数序列的值将与位置参数匹配。参数序列中的第一个项成为第一个位置参数。序列中的第二个项成为第二个参数，依此类推。每个项都会被分配，直到它们都被使用完。如果有额外的参数值，并且函数定义中使用了带有`*`前缀的参数，则额外的参数值将被分配给`*`前缀参数。
- en: 'Because of this, we can use `prod2(*range(1, 10))` easily. This is effectively
    `prod2(1, 2, 3, 4, 5, …, 9)`. Since all of the positional argument values are
    assigned to the `*`-prefix `args` variable, we can use this function with individual
    values, like this: `prod2(1, 2, 3, 4)`. We can provide a sequence of values, like
    this: `prod2(*sequence)`.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以轻松地使用`prod2(*range(1, 10))`。这实际上等同于`prod2(1, 2, 3, 4, 5, …, 9)`。由于所有的位置参数值都被分配给`*`前缀的`args`变量，我们可以使用这个函数与单个值一起使用，例如：`prod2(1,
    2, 3, 4)`。我们也可以提供值序列，例如：`prod2(*sequence)`。
- en: 'We have a similar technique for providing a dictionary of keyword arguments
    to a function. We can do this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个类似的技术，可以将关键字参数的字典提供给函数。我们可以这样做：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We've created a dictionary with all of the arguments defined via their keywords.
    This uses a handy feature of the `dict()` function where all of the keyword arguments
    are used to build a dictionary object. We assigned that dictionary to the `rr_args`
    variable. When we invoked the `boat_summary2()` function, we used the `**rr_args`
    parameter to force each key and value in the `rr_args` dictionary to be matched
    against parameters to the function. This means that the values associated with
    the `name` and `rig` keys in the dictionary will be matched with the `name` and
    `rig` parameters. All other keys in the dictionary will be assigned the `sails`
    parameter.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个包含所有通过关键字定义的参数的字典。这是`dict()`函数的一个方便特性，其中所有关键字参数都用于构建字典对象。我们将该字典分配给`rr_args`变量。当我们调用`boat_summary2()`函数时，我们使用`**rr_args`参数来强制将`rr_args`字典中的每个键和值与函数的参数匹配。这意味着与字典中`name`和`rig`键关联的值将与`name`和`rig`参数匹配。字典中的所有其他键都将分配给`sails`参数。
- en: These techniques allow us to build function arguments dynamically. This gives
    us tremendous flexibility in how we define and use Python functions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术使我们能够动态地构建函数参数。这为我们定义和使用Python函数提供了极大的灵活性。
- en: Nested function definitions
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套函数定义
- en: We can include anything inside a function definition, even another function
    definition. When we look at decorators in [Chapter 13](ch13.html "Chapter 13. Metaprogramming
    and Decorators"), *Metaprogramming and Decorators*, we'll see cases of a function
    which includes a nested function definition.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在函数定义中包含任何内容，甚至另一个函数定义。当我们查看第13章中的装饰器时，*元编程与装饰器*，我们会看到包含嵌套函数定义的函数的例子。
- en: We can include `import` statements within a function definition. An `import`
    statement is only really executed once. There's a global collection of imported
    modules. The name, however, would be localized to the function doing the import.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在函数定义中包含`import`语句。一个`import`语句实际上只执行一次。但是，导入的模块有一个全局集合。然而，名称会被本地化到执行导入的函数。
- en: 'The general advice is given in the *Zen of Python* poem by Tim Peters:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一般建议在Tim Peters的《Python之禅》诗中给出：
- en: '*Flat is better than nested.*'
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*扁平优于嵌套*。'
- en: We'll generally strive to have functions defined in a relatively simple, flat
    sequence. We'll avoid nesting unless it's truly required, as it is when creating
    decorators.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会努力使函数定义在一个相对简单、扁平的序列中。除非真正需要，否则我们会避免嵌套，例如在创建装饰器时。
- en: Working with namespaces
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与命名空间一起工作
- en: When a function is evaluated, Python creates a local namespace. The parameter
    variables are created in this local namespace when the argument values (or default
    values) are assigned. Any variables that are created in the suite of statements
    in the function's body are also created in this local namespace.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数被评估时，Python会创建一个局部命名空间。当参数值（或默认值）被分配时，参数变量在这个局部命名空间中创建。函数体中的语句块中创建的任何变量也会在这个局部命名空间中创建。
- en: As we noted in [Chapter 4](ch04.html "Chapter 4. Variables, Assignment and Scoping
    Rules"), *Variables, Assignment and Scoping Rules*, each object has a reference
    counter. An object provided as an argument to a function will have the reference
    count incremented during the execution of the function's suite of statements.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第4章](ch04.html "第4章。变量、赋值和作用域规则")中提到的，*变量、赋值和作用域规则*，每个对象都有一个引用计数器。作为函数参数提供的对象，在函数的语句套件执行期间，其引用计数会增加。
- en: When the function finishes—either because of an explicit `return` statement
    or the implicit return at the end of the suite—the namespace is removed. This
    will decrement the number of references to the argument objects.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数完成时——无论是由于显式的`return`语句还是套件末尾的隐式返回——命名空间被移除。这将减少对参数对象的引用数。
- en: When we evaluate an expression like `more_dice_good(2, hand)`, the literal integer
    `2` will be assigned to the `n` parameter variable. Its reference count will be
    one during the execution of the function. The object assigned to the `hand` variable
    will be assigned to the `collection` parameter. This object will have a reference
    count of two during the execution of the function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估像`more_dice_good(2, hand)`这样的表达式时，字面整数`2`将被分配给`n`参数变量。在函数执行期间，它的引用计数为`1`。分配给`hand`变量的对象将被分配给`collection`参数。在函数执行期间，这个对象将有一个引用计数为`2`。
- en: When the function exits, the namespace is removed, which removes the two parameter
    variables. The literal `2` object, assigned to the `n` variable, will wind up
    with a reference count of zero, and that `int` object can be removed from memory.
    The object assigned to the `collection` variable will have its reference count
    decreased from two to one; it will not be removed from memory. This object will
    still be assigned to the `hand` variable, and can continue to be used elsewhere.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数退出时，命名空间被移除，这将移除两个参数变量。分配给`n`变量的`2`对象将结束时的引用计数为零，这个`int`对象可以从内存中移除。分配给`collection`变量的对象将它的引用计数从两个减少到一；它不会被从内存中移除。这个对象仍然被分配给`hand`变量，并且可以在其他地方继续使用。
- en: This use of a local namespace allows us to freely assign objects to parameters
    without having the objects overwritten or removed from memory. It also allows
    us to freely create intermediate variables within the body of a function, secure
    in the knowledge that the variable will not overwrite some other variable used
    elsewhere in the script.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用局部命名空间的好处是，我们可以自由地将对象分配给参数，而不用担心对象会被覆盖或从内存中移除。这还允许我们在函数体内自由创建中间变量，因为我们知道变量不会覆盖脚本中其他地方使用的某个变量。
- en: When we reference a variable, Python looks in two places for the variable. It
    looks first in the local namespace. If the variable isn't found, Python then searches
    the global namespace.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们引用一个变量时，Python会在两个地方查找该变量。它首先在局部命名空间中查找。如果找不到变量，Python然后搜索全局命名空间。
- en: When we import a module, like `random`, we generally write `import` at the beginning
    of our script so that the module is imported into the global namespace. This means
    that a function which uses `random.randint()` will first check the local namespace
    for `random`; failing to find that, it will check the global namespace and find
    the imported module.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们导入一个模块，比如`random`，我们通常在脚本的开头写`import`，这样模块就被导入到全局命名空间。这意味着使用`random.randint()`的函数首先会在局部命名空间中查找`random`；如果没有找到，它将检查全局命名空间并找到导入的模块。
- en: This fallback to the global namespace allows us to reuse imported modules, function
    definitions, and class definitions freely within a script file. We can also—to
    an extent—share global variables. The default behavior is that we can read the
    values of global variables, but we can't easily update them.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这种回退到全局命名空间的做法允许我们在脚本文件中自由地重用导入的模块、函数定义和类定义。我们还可以在一定程度上共享全局变量。默认行为是我们可以读取全局变量的值，但不容易更新它们。
- en: If we write `global_variable = global_variable + 1` in a function, we can fetch
    the value of a global variable named `global_variable`. The assignment, however,
    will create a new variable in the local namespace with the name `global_variable`.
    The actual global variable will remain untouched.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在函数中写入`global_variable = global_variable + 1`，我们可以获取名为`global_variable`的全局变量的值。然而，这个赋值操作将在局部命名空间中创建一个新的名为`global_variable`的变量。实际的全球变量将保持不变。
- en: Assigning a global variable
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值全局变量
- en: What if we want to assign values to a variable which has not been provided as
    an argument? We can write a function which will update global variables. This
    can lead to confusing programs because several functions may share common states
    via the global variable.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为一个没有作为参数提供的变量赋值怎么办？我们可以编写一个函数来更新全局变量。这可能导致程序令人困惑，因为几个函数可能通过全局变量共享公共状态。
- en: 'To create names in the global namespace instead of a local namespace, we use
    the `global` statement. This identifies the variables which must be found in the
    global namespace instead of the local namespace. Here''s a function which updates
    a global variable:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要在全局命名空间而不是局部命名空间中创建名称，我们使用 `global` 语句。这标识了必须在全局命名空间而不是局部命名空间中找到的变量。以下是一个更新全局变量的函数示例：
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We've defined a function and used the `global` statement to state that the variable
    named `sevens` will be found in the global namespace. We've created two random
    numbers, and assigned the pair to a local variable, `d`. This variable will be
    created in the local namespace, and won't conflict with any other variables defined
    in other namespaces.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个函数，并使用 `global` 语句来声明名为 `sevens` 的变量将在全局命名空间中找到。我们创建了两个随机数，并将这对数赋给一个局部变量
    `d`。这个变量将在局部命名空间中创建，并且不会与其他命名空间中定义的其他变量冲突。
- en: Each time the pair of dice total seven, the global variable is updated. This
    is a side effect that can be confusing. It must be documented explicitly, and
    it requires some careful unit testing.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 每当两个骰子的总和为七时，全局变量就会被更新。这是一个可能令人困惑的副作用。它必须明确记录，并且需要一些仔细的单元测试。
- en: 'The two built-in functions, `globals()` and `locals()`, can help clarify the
    variables available when this function is being evaluated. If we add a `print()`
    function right before the `return` statement, we''ll see results (with some details
    elided) like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 两个内置函数 `globals()` 和 `locals()` 可以帮助澄清在函数被评估时可以使用的变量。如果我们直接在 `return` 语句之前添加一个
    `print()` 函数，我们会看到如下结果（一些细节被省略）：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `globals` function includes variables like `sevens`, it includes the random
    module, and the `roll_dice_count_7` function. It includes some system variables:
    `like __cached__`, `__loader__`, `__name__`, and `__file__`.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`globals` 函数包括像 `sevens` 这样的变量，它包括随机模块和 `roll_dice_count_7` 函数。它还包括一些系统变量：`like
    __cached__`、`__loader__`、`__name__` 和 `__file__`。'
- en: The `locals` function includes the local variable `d` and nothing more.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`locals` 函数包括局部变量 `d` 以及没有其他内容。'
- en: Assigning a non-local variable
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值非局部变量
- en: When one function is defined inside another function, the outer function can
    contain variables which are neither local to the inner function nor global. We
    call these non-local variables. There are situations where we might want to set
    a variable which is part of an enclosing function.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数在另一个函数内部定义时，外部函数可以包含既不是内部函数的局部变量也不是全局的变量。我们称这些为非局部变量。在某些情况下，我们可能想要设置一个属于封装函数的变量。
- en: Nested function definitions are most commonly used when defining decorators.
    We'll look at this in [Chapter 13](ch13.html "Chapter 13. Metaprogramming and
    Decorators"), *Metaprogramming and Decorators*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套函数定义最常用于定义装饰器。我们将在第 13 章[《元编程和装饰器》](ch13.html "Chapter 13. Metaprogramming
    and Decorators")中探讨这一点。
- en: 'Here''s a contrived example of nested functions and a non-local shared variable:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个关于嵌套函数和非局部共享变量的虚构示例：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We've defined a function, `roll_nl()`, which will simulate rolls of dice. The
    function's body includes a nested function definition, `dice()`. The rest of the
    body creates the variable `total`, evaluates the internal `dice()` function, and
    returns the value of the `total` variable.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `roll_nl()` 的函数，该函数将模拟掷骰子。函数的主体包括一个嵌套函数定义 `dice()`。其余的主体创建了变量 `total`，评估内部
    `dice()` 函数，并返回 `total` 变量的值。
- en: How did the `total` variable get set to anything other than zero? It isn't updated
    in the body of the `roll_nl()` function.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`total` 变量是如何被设置为非零值的？在 `roll_nl()` 函数的主体中并没有更新它。'
- en: Within the nested `dice()` function, there's a nonlocal reference to a variable
    named `total`. This variable must exist in an outer namespace, but not necessarily
    the global namespace. The `dice()` function creates a `tuple` object with the
    values of `n` dice. This expression builds a tuple from the result of a generator
    function. It updates the nonlocal `total` variable the sum of the `points` tuple.
    The `nonlocal` statement assures us that the `total` variable is part of the container
    for the `dice()` function. The return value of the `dice()` function is the tuple
    of dice, a value this isn't really used.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套的`dice()`函数中，有一个对名为`total`的变量的非局部引用。这个变量必须存在于外部命名空间中，但不一定是全局命名空间。`dice()`函数创建一个包含`n`个骰子值的`tuple`对象。这个表达式从一个生成器函数的结果构建一个`tuple`。它更新非局部的`total`变量，即`points`元组的总和。`nonlocal`语句确保`total`变量是`dice()`函数容器的一部分。`dice()`函数的返回值是骰子元组，这个值实际上并没有被真正使用。
- en: Defining lambdas
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义lambda表达式
- en: 'A lambda form is a degenerate kind of function. A lambda doesn''t even have
    a name: it has only parameters and a single expression. We create a lambda by
    providing the parameter names and the expression. It looks like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: lambda形式是一种退化的函数。lambda甚至没有名字：它只有参数和一个单一的表达式。我们通过提供参数名称和表达式来创建lambda。它看起来像这样：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This kind of thing is helpful in the context of Python''s higher-order functions.
    We often use lambdas with `max()`, `min()`, `sorted()`, `map()`, `filter()`, or
    `list.sort()`. Here''s a simple example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在Python的高阶函数上下文中很有帮助。我们经常与`max()`、`min()`、`sorted()`、`map()`、`filter()`或`list.sort()`一起使用lambda。这里有一个简单的例子：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We've created a simple list object which has four RGB color values. If we use
    the `sorted()` function on this list, the colors are sorted into order by the
    red component value. If the red components are equal, then the green component
    is used. In the rare case that the red and green components are equal the blue
    component is used.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的列表对象，其中包含四个RGB颜色值。如果我们对这个列表使用`sorted()`函数，颜色将按照红色分量值排序。如果红色分量相等，则使用绿色分量。在红色和绿色分量都相等的情况下，则使用蓝色分量。
- en: If we want colors sorted by brightness, we can't simply sort by red, green,
    and blue. The perception of brightness is subtle and a number of formulae approximate
    the phenomena. We've picked just one, which is to average the RGB values. This
    formula doesn't take into account the fact that our eyes are more sensitive to
    green.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要按亮度排序颜色，我们不能简单地按红色、绿色和蓝色排序。对亮度的感知是微妙的，有多个公式可以近似这种现象。我们只选择了一个，那就是平均RGB值。这个公式没有考虑到我们的眼睛对绿色更敏感的事实。
- en: The `sorted()` function accepts a second parameter, `key`, which we've provided
    as a keyword argument in the second example. Rather than write a complete function
    definition that would only really embody a single expression, we've packaged the
    expression, `(rgb[0]+rgb[1]+rgb[2])/3`, as a lambda.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted()`函数接受第二个参数`key`，我们在第二个示例中提供了关键字参数。我们不是写一个完整的函数定义，这个定义只会包含一个表达式，而是将表达式`(rgb[0]+rgb[1]+rgb[2])/3`打包成一个lambda。'
- en: 'The syntax `lambda rgb: (rgb[0]+rgb[1]+rgb[2])/3` is equivalent to the following
    function definition.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '语法 `lambda rgb: (rgb[0]+rgb[1]+rgb[2])/3` 等同于以下函数定义。'
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The lambda is more compact. If we only need this expression in one place, a
    reusable function may not be appropriate. A lambda is an easy way to provide a
    simple expression with minimal overhead. If we think we need to write complex
    lambdas—more than a simple expression—or we need to reuse a lambda, then we should
    consider using a proper function.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式更紧凑。如果我们只需要在某个地方使用这个表达式，那么一个可重用的函数可能就不合适了。lambda是一个提供简单表达式且开销最小的简单方法。如果我们认为我们需要编写复杂的lambda表达式——不仅仅是简单表达式，或者我们需要重用lambda，那么我们应该考虑使用合适的函数。
- en: Writing additional function annotations
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写附加函数注释
- en: The **Python Enhancement Proposal** (**PEP**) number 3107 specifies additional
    annotations which can be applied to a function definition. Additionally, PEPs
    482, 483, and 484 cover some related ideas.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python增强提案**（**PEP**）编号3107指定了可以应用于函数定义的附加注释。此外，PEP 482、483和484涵盖了相关的一些想法。'
- en: 'This is important only because Python has some optional syntax that we may
    see. In Python 3.5, there may be additional tools for the type of information
    provided in this optional syntax. The annotated code can look like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以重要，仅仅是因为Python有一些可选的语法，我们可能会看到。在Python 3.5中，可能会有提供此类信息类型的一些额外工具。注释的代码可以看起来像这样：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This function includes additional `: expression` annotations after each parameter.
    It also includes a `-> expression` annotation to show the return type of the function.
    All of the annotation expressions in this example are the names of built-in types.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '此函数在每个参数之后包含额外的`: 表达式`注解。它还包括一个`-> 表达式`注解来显示函数的返回类型。本例中的所有注解表达式都是内置类型的名称。'
- en: In order to describe more complex structures, an additional typing module can
    offer the tools for defining a more exact `Tuple[int, …]` as the return type for
    this function. This is an exciting development that may avoid certain kinds of
    bugs.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了描述更复杂的结构，一个额外的类型模块可以提供定义更精确的`Tuple[int, …]`作为此函数返回类型的工具。这是一个令人兴奋的发展，可能会避免某些类型的错误。
- en: These annotations are legal Python3 syntax. They have no formally-defined semantics,
    which means that they are optional. There are some enhancement projects that are
    working on leveraging these optional annotations and creating tools that can use
    the information provided there. It's rarely used, but perfectly legal.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这些注解是合法的Python3语法。它们没有正式定义的语义，这意味着它们是可选的。有一些增强项目正在努力利用这些可选注解，并创建可以使用那里提供的信息的工具。虽然很少使用，但完全合法。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We''ve looked at a number of Python features for function definition. We''ve
    looked at how we define the name, and the parameters to a function, providing
    default values to make parameters optional. We''ve also looked at how we can provide
    arguments to a function: we can provide arguments by position, or by using the
    parameter variable name as a keyword. We can evaluate `function(*args)` to map
    a sequence of values to parameters by position. We can also evaluate `function(**kw)`
    to map a dictionary of values to parameters by name. And, of course, we can combine
    these two techniques.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了Python中用于函数定义的许多功能。我们探讨了如何定义函数的名称和参数，提供默认值以使参数可选。我们还探讨了如何向函数提供参数：我们可以按位置提供参数，或者使用参数变量名作为关键字。我们可以通过位置将值映射到参数上，通过评估`function(*args)`。我们也可以通过评估`function(**kw)`将字典中的值按名称映射到参数上。当然，我们也可以结合这两种技术。
- en: We've looked at how functions return values via the `return` statement. We've
    also looked at functions which don't return a value. Technically, they return
    a value of `None`, which the rest of the Python programming ignores.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了函数如何通过`return`语句返回值。我们还探讨了不返回值的函数。技术上，它们返回一个`None`值，Python编程的其他部分会忽略这个值。
- en: We've looked at the all-important issue of attempting to use a mutable object
    as a default value in a function definition. Most of the time, a mutable object
    as a default is going to create problems.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了尝试在函数定义中将可变对象作为默认值使用的重要问题。大多数情况下，将可变对象作为默认值将会引起问题。
- en: In addition to the basics of function definition, we looked at how local variables
    are assigned to temporary namespaces. We also looked at how we can use the `global`
    statement to create variables in the global namespace. We also looked at how a
    nested function definition can manipulate variables that are nonlocal to the nested
    function, but not properly global to the container function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 除了函数定义的基本知识之外，我们还探讨了如何将局部变量分配给临时命名空间。我们还探讨了如何使用`global`语句在全局命名空间中创建变量。我们还探讨了如何使用嵌套函数定义来操作嵌套函数非局部但不是容器函数全局的变量。
- en: In [Chapter 8](ch08.html "Chapter 8. More Advanced Functions"), *More Advanced
    Functions*, we'll look at generator expressions and functions. These are functions
    which are iterable, and work cooperatively with the `for` loop to handle collections
    and sequences of data.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html "第8章。更高级的函数")中，我们将探讨生成器表达式和函数。这些是可迭代的函数，与`for`循环协同工作，以处理集合和数据序列。
