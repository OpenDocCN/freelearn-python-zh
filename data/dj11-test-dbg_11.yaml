- en: 'Chapter 11. When it''s Time to Go Live: Moving to Production'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。当是时候上线：转入生产环境
- en: 'The final topic we will cover on the subject of testing and debugging Django
    applications is the move to production. When the application code is all written,
    fully tested and debugged, it is time to set up a production web server and make
    the application accessible to real users. Since the application has been fully
    tested and debugged during development, this should be straightforward, right?
    Unfortunately, not always. There are a number of differences between a production
    web server environment and the Django development server environment. These differences
    can cause problems during the move to production. In this chapter, we will see
    what some of these differences are, what types of problems they can cause, and
    how to overcome them. Specifically, we will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在测试和调试Django应用程序的主题上涵盖的最后一个主题是转入生产环境。当应用程序代码全部编写、完全测试和调试完成时，就是设置生产Web服务器并使应用程序对真实用户可访问的时候了。由于应用程序在开发过程中已经经过了全面的测试和调试，这应该是直截了当的，对吗？不幸的是，情况并非总是如此。生产Web服务器环境与Django开发服务器环境之间存在许多差异。这些差异可能在转入生产过程中引发问题。在本章中，我们将看到其中一些差异是什么，它们可能引起什么类型的问题，以及如何克服它们。具体来说，我们将：
- en: Configure an Apache web server with `mod_wsgi` to run the sample `marketr` project.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置一个带有`mod_wsgi`的Apache Web服务器来运行示例`marketr`项目。
- en: Encounter a number of issues during development of the Apache configuration.
    For each, we will see how to diagnose and address the problem.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发Apache配置过程中遇到了一些问题。针对每个问题，我们将看看如何诊断和解决这些问题。
- en: Perform functional stress testing of the application running under Apache to
    ensure that it operates correctly under load.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对在Apache下运行的应用程序进行功能性压力测试，以确保它在负载下能够正确运行。
- en: Fix any code errors revealed by the functional stress testing.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复功能性压力测试中暴露的任何代码错误。
- en: Discuss the possibility of using Apache with `mod_wsgi` during development.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论在开发过程中使用Apache和`mod_wsgi`的可能性。
- en: Developing an Apache/mod_wsgi configuration
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发Apache/mod_wsgi配置
- en: Ordinarily, the move to production will involve running the code on a machine
    other than the ones it has been developed on. The production server might be dedicated
    hardware or resources obtained from a hosting provider. In either case, it is
    typically entirely separate from the machines used by developers when writing
    the code. The production server needs to have any of the pre-requisite packages
    installed (Django and matplotlib, for example, for our sample project). In addition
    a copy of the application project code, generally extracted from a version control
    system, needs to be placed on the production server.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，转入生产环境将涉及在与开发时使用的不同机器上运行代码。生产服务器可能是专用硬件，也可能是从托管提供商那里获得的资源。无论哪种情况，它通常与开发人员编写代码时使用的机器完全分开。生产服务器需要安装任何先决条件包（例如，对于我们的示例项目，需要安装Django和matplotlib）。此外，应用项目代码的副本通常需要从版本控制系统中提取，并放置在生产服务器上。
- en: For the sake of simplicity in this chapter, though, we are going to configure
    a production web server on the same machine where we have been developing the
    code. This will allow us to skip over some of the complexity involved in a real
    move to production while still experiencing many of the issues that may arise
    during production deployment. For the most part the issues we will skip over in
    doing this are not Django-specific, but rather are common issues that need to
    be dealt with whenever moving any kind of application from development into production.
    The issues we will encounter will tend to be more Django-specific.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化本章，我们将在与开发代码相同的机器上配置生产Web服务器。这将使我们能够跳过一些在实际转入生产过程中涉及的复杂性，同时仍然体验到在生产部署过程中可能出现的许多问题。在很大程度上，我们将跳过这样做时遇到的问题并不是特定于Django的，而是在将任何类型的应用程序从开发转入生产时需要处理的常见问题。我们将遇到的问题往往更具体于Django。
- en: The example deployment environment that will be developed is Apache with `mod_wsgi`,
    which is the current recommended environment for deploying Django applications.
    **WSGI** stands for **Web Server Gateway Interface**. WSGI is a Python standard
    specification that defines an interface between web servers (Apache, for example)
    and web applications or frameworks written in Python (Django, for example).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将要开发的示例部署环境是使用`mod_wsgi`的Apache，这是目前推荐的部署Django应用程序的环境。**WSGI**代表**Web Server
    Gateway Interface**。WSGI是Python的标准规范，定义了Web服务器（例如Apache）和用Python编写的Web应用程序或框架（例如Django）之间的接口。
- en: The base Apache web server does not support WSGI. However, Apache's modular
    structure allows such support to be provided by a plug-in module. Thus, the web
    server side support for WSGI is provided by `mod_wsgi`, an Apache module written
    and actively maintained by Graham Dumpleton. Django itself does implement the
    application side of the WSGI specification. Thus, there is no need for any additional
    adapter module between `mod_wsgi` and Django.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的Apache Web服务器不支持WSGI。然而，Apache的模块化结构允许通过插件模块提供此支持。因此，WSGI的Web服务器端支持由Graham
    Dumpleton编写并积极维护的`mod_wsgi`提供。Django本身确实实现了WSGI规范的应用程序端。因此，在`mod_wsgi`和Django之间不需要任何额外的适配器模块。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Prior to the development of `mod_wsgi`, the `mod_python` module for Apache was
    the recommended deployment environment for Django. Though `mod_python` is still
    available and even still in wide use, its most recent release was over three years
    ago. The current source code needs a patch in order to compile with the latest
    Apache 2.2.X release. Going forward, more extensive changes will be needed due
    to changes in Apache APIs, but there are no active `mod_python` developers to
    make such changes. Given the current moribund state of `mod_python` development,
    I believe it is now a poor choice for Django application deployment. Therefore,
    specifics of configuring it are not covered here. If for some reason you must
    use `mod_python`, many of the issues encountered in this chapter with `mod_wsgi`
    apply to `mod_python` as well, and the specifics of configuring `mod_python` are
    still included in the Django documentation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发`mod_wsgi`之前，Apache的`mod_python`模块是Django推荐的部署环境。尽管`mod_python`仍然可用且仍然被广泛使用，但其最近的发布已经超过三年。当前的源代码需要一个补丁才能与最新的Apache
    2.2.X版本编译。未来，由于Apache API的更改，将需要更广泛的更改，但没有活跃的`mod_python`开发人员来进行这些更改。鉴于`mod_python`开发目前的停滞状态，我认为它现在不适合用于Django应用程序的部署。因此，这里不涵盖配置它的具体内容。如果出于某种原因您必须使用`mod_python`，那么在本章中遇到的许多问题也适用于`mod_python`，并且配置`mod_python`的具体内容仍包含在Django文档中。
- en: Both Apache and `mod_wsgi` are readily obtained and easily installed on a variety
    of different platforms. Details of installation for these will not be covered.
    As a general guide, using your machine's regular package management service to
    install these packages is likely the easiest path. If that isn't possible, details
    of downloading and installing Apache can be found on the Web at [http://httpd.apache.org/](http://httpd.apache.org/)
    and the same information for `mod_wsgi` can be found at [http://code.google.com/p/modwsgi/](http://code.google.com/p/modwsgi/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Apache和`mod_wsgi`都可以在各种不同的平台上轻松获取和安装。这里不会涵盖这些安装的细节。一般来说，使用机器的常规软件包管理服务来安装这些软件包可能是最简单的方法。如果这不可能，可以在网上找到有关下载和安装Apache的详细信息，网址为[http://httpd.apache.org/](http://httpd.apache.org/)，同样的信息也可以在[http://code.google.com/p/modwsgi/](http://code.google.com/p/modwsgi/)找到`mod_wsgi`的信息。
- en: The machine used to develop the sample configuration shown in this chapter is
    running Ubuntu, a Debian-based version of Linux. This flavor of Linux has developed
    a particular structure for Apache configuration that may not match the structure
    used on your own machine. The configuration structure, however, is not significant.
    Rather it is the Apache directives contained in the configuration that are important.
    If your machine does not follow the Debian structure, you may simply place the
    directives shown here in the main Apache configuration file, usually named `httpd.conf`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示的示例配置的开发机器运行Ubuntu，这是Linux的基于Debian的版本。这种Linux的配置结构可能与您自己机器上使用的结构不匹配。然而，配置结构并不重要，重要的是配置中包含的Apache指令。如果您的机器不遵循Debian结构，您可以简单地将这里显示的指令放在主Apache配置文件中，通常命名为`httpd.conf`。
- en: There are two pieces to the configuration for a WSGI client application running
    under Apache with `mod_wsgi`. First, there is a Python WSGI script that sets up
    the environment for and identifies the WSGI client application that will handle
    requests. Second, there are the Apache configuration directives that control the
    operation of `mod_wsgi` and direct requests for particular URL paths to `mod_wsgi`.
    Creating each of these for the Django `marketr` project will be discussed next.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Apache下运行WSGI客户端应用程序的配置有两个部分，首先是一个Python WSGI脚本，它设置环境并标识将处理请求的WSGI客户端应用程序。其次是控制`mod_wsgi`操作并将特定URL路径的请求指向`mod_wsgi`的Apache配置指令。接下来将讨论为Django
    `marketr`项目创建这两部分。
- en: Creating the WSGI script for the marketr project
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建`marketr`项目的WSGI脚本。
- en: The WSGI script for a Django project has three responsibilities. First, it must
    set the Python path to include any paths that are needed by the Django project
    but are not on the regular system path. In our case, the path to the `martketr`
    project itself will need to be added to the Python path. All of the other pre-requisite
    code used by the project has been installed so that it is automatically found
    under the Python site-packages directory.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Django项目的WSGI脚本有三个责任。首先，它必须设置Python路径，包括Django项目所需但不在常规系统路径上的任何路径。在我们的情况下，`martketr`项目本身的路径将需要添加到Python路径中。项目使用的所有其他先决条件代码都已安装，因此它会自动在Python
    site-packages目录下找到。
- en: Second, the WSGI script must set the `DJANGO_SETTINGS_MODULE` variable in the
    environment to point to the appropriate settings module. In our case, it will
    need to be set to point to the `settings.py` file in `/dj_projects/marketr`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，WSGI脚本必须在环境中设置`DJANGO_SETTINGS_MODULE`变量，指向适当的设置模块。在我们的情况下，它需要设置为指向`/dj_projects/marketr`中的`settings.py`文件。
- en: Third, the WSGI script must set the variable `application` to an instance of
    a callable that implements the WSGI interface. For Django, this interface is provided
    by `django.core.handlers.wsgi.WSGIHandler`, so the script for the `marketr` project
    may simply set `application` to an instance of that class. There is nothing specific
    to the `marketr` project here—this piece of the WSGI script will be the same for
    all Django projects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，WSGI脚本必须将变量`application`设置为实现WSGI接口的可调用实例。对于Django，这个接口由`django.core.handlers.wsgi.WSGIHandler`提供，因此`marketr`项目的脚本可以简单地将`application`设置为该类的实例。这里没有特定于`marketr`项目的内容——这部分WSGI脚本对所有Django项目都是相同的。
- en: Where should this script go? It might seem natural to place it directly in `/dj_projects/marketr`,
    along with the `settings.py` and `urls.py` files, since they are all project-level
    files. However, as mentioned in the `mod_wsgi` documentation, this would be a
    poor choice. Apache will need to be configured to allow access to files in the
    directory containing the WSGI script. Thus, it is best to keep the WSGI script
    in a directory separate from any code files that should not be accessible to website
    users. (The directory containing `settings.py`, in particular, should never be
    configured to be accessible to website clients, since it may contain sensitive
    information such as the database password.)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本应该放在哪里？将其直接放在`/dj_projects/marketr`中似乎是很自然的，与`settings.py`和`urls.py`文件一起，因为它们都是项目级文件。然而，正如`mod_wsgi`文档中所提到的，这将是一个不好的选择。Apache需要配置以允许访问包含WSGI脚本的目录中的文件。因此，最好将WSGI脚本保存在与不应对网站用户可访问的任何代码文件分开的目录中。（特别是包含`settings.py`的目录，绝对不应该配置为对网站客户端可访问，因为它可能包含诸如数据库密码之类的敏感信息。）
- en: 'Therefore, we will create a new directory inside `/dj_projects/marketr` named
    `apache`, to hold all of the files related to running the project under Apache.
    Under the `apache` directory, we''ll create a `wsgi` directory to hold the WSGI
    script for the `marketr` project, which we will name `marketr.wsgi`. Based on
    the three responsibilities previously noted for this script, a first pass at implementing
    this `/dj_projects/marketr/apache/wsgi/marketr.wsgi` script might be:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将在`/dj_projects/marketr`内创建一个名为`apache`的新目录，用于保存在Apache下运行项目相关的所有文件。在`apache`目录下，我们将创建一个`wsgi`目录，用于保存`marketr`项目的WSGI脚本，我们将其命名为`marketr.wsgi`。根据此脚本的前面提到的三个职责，实现`/dj_projects/marketr/apache/wsgi/marketr.wsgi`脚本的第一步可能是：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code adds the `marketr` project directory at the front of the Python system
    path, sets the `DJANGO_SETTINGS_MODULE` environment variable to `marketr.settings`,
    and sets `application` to be an instance of the Django-provided callable that
    implements the WSGI application interface. When `mod_wsgi` is called to respond
    for a URL path that has been mapped to this script, it will call the appropriate
    Django code with an environment correctly set so that Django will be able to handle
    the request. The next step, then, is to develop the Apache configuration that
    will route requests appropriately to `mod_wsgi` and this script.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将`marketr`项目目录添加到Python系统路径的最前面，将`DJANGO_SETTINGS_MODULE`环境变量设置为`marketr.settings`，并将`application`设置为实现WSGI应用程序接口的Django提供的可调用实例。当`mod_wsgi`被调用以响应已映射到此脚本的URL路径时，它将使用正确设置的环境调用适当的Django代码，以便Django能够处理请求。因此，下一步是开发Apache配置，将请求适当地路由到`mod_wsgi`和此脚本。
- en: Creating an Apache VirtualHost for the marketr project
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为marketr项目创建Apache虚拟主机
- en: 'In order to isolate the Django project from anything else that you might already
    be using Apache for, we will use an Apache `VirtualHost` tied to port 8080 for
    the Django configuration. The following directives instruct Apache to listen for
    requests on port 8080 and define a virtual host to handle those requests:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将Django项目与您可能已经使用Apache的其他任何内容隔离开来，我们将使用绑定到端口8080的Apache `VirtualHost`来进行Django配置。以下指令指示Apache监听端口8080的请求，并定义一个虚拟主机来处理这些请求：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that this is in no way a complete Apache configuration, but is rather what
    needs to be added to an existing (or the shipped sample) configuration to support
    handling requests for the `marketr` project directed at port 8080\. Inside the
    `VirtualHost` container are three directives that control the behavior of `mod_wsgi`,
    and three that will affect how logging is handled for this virtual host.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这绝不是一个完整的Apache配置，而是需要添加到现有（或已发货的示例）配置中以支持处理定向到端口8080的`marketr`项目请求的内容。在`VirtualHost`容器内有三个指令控制`mod_wsgi`的行为，另外三个指令将影响此虚拟主机的日志处理方式。
- en: The first directive, `WSGIScriptAlias`, is straightforward. It maps all requests
    matching its first argument, `/`, to the WSGI script specified in its second argument,
    `/dj_projects/marketr/apache/wsgi/marketr.wsgi`. The effect of this directive
    will be to have all requests for this virtual host routed to the `marketr` WSGI
    script defined in the previous section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个指令`WSGIScriptAlias`很简单。它将与其第一个参数匹配的所有请求映射到其第二个参数中指定的WSGI脚本，即`/dj_projects/marketr/apache/wsgi/marketr.wsgi`。此指令的效果将是将此虚拟主机的所有请求路由到前面部分定义的`marketr`WSGI脚本。
- en: The next two directives, `WSGIDaemonProcess` and `WSGIProcessGroup`, instruct
    `mod_wsgi` to route requests for this virtual host to an independent group of
    processes, distinct from the normal Apache child processes used to service requests.
    This is referred to as running `mod_wsgi` in daemon mode. By contrast, having
    `mod_wsgi` use the normal Apache child processes is referred to as running in
    embedded mode.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个指令，`WSGIDaemonProcess`和`WSGIProcessGroup`，指示`mod_wsgi`将此虚拟主机的请求路由到一个独立的进程组，与用于处理请求的正常Apache子进程不同。这被称为以守护程序模式运行`mod_wsgi`。相比之下，让`mod_wsgi`使用正常的Apache子进程被称为以嵌入模式运行。
- en: Generally running in daemon mode is preferable (see the `mod_wsgi` documentation
    for full details as to why), but this mode is not supported when running Apache
    on Windows. Thus, if you are using a Windows machine for your Apache server, you
    will need to omit these two directives from your configuration.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，以守护程序模式运行更可取（有关详细信息，请参阅`mod_wsgi`文档），但在Windows上运行Apache时不支持此模式。因此，如果您在Windows机器上使用Apache服务器，则需要从配置中省略这两个指令。
- en: In the directives shown, the `WSGIDaemonProcess` directive defines a process
    group named `marketr`. This directive supports several additional arguments that
    can be used to control, for example, the number of processes in the group, the
    number of threads in each process, and the user and group for the processes. None
    of those arguments have been specified here so `mod_wsgi` will use its default
    values. The `WSGIProcessGroup` directive names the previously-defined `marketr`
    group as the one to use for handling requests for this virtual host.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在所示的指令中，`WSGIDaemonProcess`指令定义了一个名为`marketr`的进程组。这个指令支持几个额外的参数，可以用来控制，例如，组中的进程数量，每个进程中的线程数量，以及进程的用户和组。这里没有指定这些参数，所以`mod_wsgi`将使用其默认值。`WSGIProcessGroup`指令将先前定义的`marketr`组命名为处理这个虚拟主机请求的组。
- en: The next directive, `LogLevel debug`, sets logging to its most verbose setting.
    A more typical setting for production would be `warn`, but when just getting started
    setting something up, it is frequently useful to have the code log as much information
    as possible, so we will use `debug` here.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个指令，`LogLevel debug`，将日志设置为最详细的设置。在生产环境中，更典型的设置可能是`warn`，但是当刚开始设置某些东西时，通常有必要让代码记录尽可能多的信息，所以我们将在这里使用`debug`。
- en: The final two directives, `ErrorLog` and `CustomLog`, define error and access
    logs for this virtual host, distinct from the main Apache error and access logs.
    This can be convenient to isolate log information related to the new project from
    any other traffic Apache may be handling. In this case, we have directed Apache
    to place the logs in a `logs` directory under the `/dj_projects/marketr/apache`
    directory.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个指令，`ErrorLog`和`CustomLog`，为这个虚拟主机定义了错误和访问日志，与主要的Apache错误和访问日志不同。这可以方便地将与新项目相关的日志信息与Apache可能处理的其他流量隔离开来。在这种情况下，我们已经指示Apache将日志放置在`/dj_projects/marketr/apache`目录下的`logs`目录中。
- en: Activating the new Apache configuration
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 激活新的Apache配置
- en: Where should the configuration directives from the previous section be placed?
    As noted earlier, the answer depends on the specifics of how Apache is configured
    on your machine. For an Apache configuration that consists of a single `httpd.conf`
    file, you may simply place the directives at the end of that file. Although that
    may also work for more structured configurations, it is better to avoid confusion
    and use the provided structure. Thus, this section will describe how to integrate
    the definitions previously listed into a Debian-based configuration, since that
    is the type of machine being used for the example project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节的配置指令应该放在哪里？正如前面所述，答案取决于Apache在您的机器上的配置细节。对于由单个`httpd.conf`文件组成的Apache配置，您可以简单地将指令放在该文件的末尾。尽管这对于更结构化的配置也可能有效，但最好避免混淆并使用提供的结构。因此，本节将描述如何将先前列出的定义集成到基于Debian的配置中，因为这是示例项目所使用的机器类型。
- en: 'For a Debian-based Apache configuration, the `Listen` directive should be placed
    in `/etc/apache2/ports.conf`. The `VirtualHost` directive, and all it contains,
    should be placed in a file under `/etc/apache2/sites-available`. For this example,
    though, the virtual host configuration has been placed in a file `/dj_projects/marketr/apache/conf/marketr`
    so that the `/dj_projects` directory can contain complete configuration information
    for the project. We can make this file also appear in the `sites-available` directory
    by creating a symbolic link for it:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于Debian的Apache配置，`Listen`指令应放置在`/etc/apache2/ports.conf`中。`VirtualHost`指令及其所有内容应放置在`/etc/apache2/sites-available`下的一个文件中。但是，在这个例子中，虚拟主机配置已放置在一个名为`/dj_projects/marketr/apache/conf/marketr`的文件中，以便`/dj_projects`目录可以包含项目的完整配置信息。我们可以通过为其创建一个符号链接，使这个文件也出现在`sites-available`目录中：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that general users cannot create or modify files under `/etc/apache2/sites-available`,
    so the `sudo` command is needed to perform the requested command as a superuser.
    This is necessary for all commands that modify the Apache configuration or control
    its operation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一般用户无法在`/etc/apache2/sites-available`下创建或修改文件，因此需要使用`sudo`命令以超级用户的身份执行所请求的命令。这对于所有修改Apache配置或控制其操作的命令都是必要的。
- en: 'Once the file containing the virtual host configuration is in place in `sites-available`,
    the `a2ensite` command can be used to enable the new site:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦包含虚拟主机配置的文件放置在`sites-available`中，就可以使用`a2ensite`命令启用新站点：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `a2ensite` command creates a symbolic link in the `/etc/apache2/sites-enabled`
    directory to the specified file in the `sites-available` directory. There is a
    companion command, `a2dissite`, that disables a site by removing the symbolic
    link for it in `sites-enabled`. (Note that you can also manage the symbolic links
    manually and not use these commands, if you prefer.)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`a2ensite`命令在`/etc/apache2/sites-enabled`目录中为`sites-available`目录中指定的文件创建一个符号链接。还有一个伴随命令`a2dissite`，它通过在`sites-enabled`中删除指定文件的符号链接来禁用站点。（请注意，如果愿意，您也可以手动管理符号链接，而不使用这些命令。）'
- en: 'As noted by the output of `a2ensite`, it is necessary to reload Apache in order
    for the new site configuration to take effect. In this case, since a `Listen`
    directive was added, a full restart of Apache is required. That is done by running
    the `/etc/init.d/apache2` command and specifying `restart` as an argument. When
    we try that, the response is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如`a2ensite`的输出所示，需要重新加载Apache才能使新的站点配置生效。在这种情况下，由于添加了`Listen`指令，需要完全重新启动Apache。这可以通过运行`/etc/init.d/apache2`命令并指定`restart`作为参数来完成。当我们尝试这样做时，响应如下：
- en: '![Activating the new Apache configuration](img/7566_11_01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![激活新的Apache配置](img/7566_11_01.jpg)'
- en: 'The **[fail]** on the right-hand side of the screen does not look good. Something
    apparently went wrong during restart, but what? The answer is not found in the
    output of the command used to restart Apache, which only reports success or failure.
    Rather, the Apache error log contains details of the reason for the failure. Further,
    for a failure related to server start-up, it will likely be the main Apache error
    log that contains the detailed information, not a site-specific error log. On
    this machine, the main Apache error logfile is `/var/log/apache2/error.log`. Looking
    at the end of that file, we find the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕右侧的 **[fail]** 看起来不太好。显然在重新启动期间出了一些问题，但是是什么呢？答案在于重新启动Apache时使用的命令的输出中找不到，它只报告成功或失败。相反，Apache错误日志包含了失败原因的详细信息。此外，对于与服务器启动相关的失败，主要的Apache错误日志可能包含详细信息，而不是特定于站点的错误日志。在这台机器上，主要的Apache错误日志文件是`/var/log/apache2/error.log`。查看该文件的末尾，我们找到了以下内容：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The problem is that the new virtual host configuration specified a directory
    for the error logfile that does not exist. Apache will not automatically create
    the specified directory, thus we need to create it manually. Doing that and again
    attempting to restart Apache produces a better result:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于新的虚拟主机配置指定了一个不存在的错误日志文件目录。Apache不会自动创建指定的目录，因此我们需要手动创建它。这样做并再次尝试重新启动Apache会产生更好的结果：
- en: '![Activating the new Apache configuration](img/7566_11_02.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![激活新的Apache配置](img/7566_11_02.jpg)'
- en: '**[ OK ]** certainly looks better than **[fail]**; apparently this time Apache
    was able to start successfully. We''ve now gotten to the point where we have a
    valid Apache configuration, but there may still be some work to do to get a working
    configuration, as we will see next.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**[ OK ]** 确实看起来比 **[fail]** 好得多；显然这一次Apache能够成功启动。我们现在已经到了拥有有效Apache配置的地步，但可能还有一些工作要做才能获得一个可用的配置，接下来我们将看到。'
- en: Debugging the new Apache configuration
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试新的Apache配置
- en: 'The next test is to see whether Apache will successfully process a request
    directed to the new virtual host''s port. To do that, let''s try to retrieve the
    project root (home) page from a web browser. The result does not look good:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试是看Apache是否能成功处理发送到新虚拟主机端口的请求。为了做到这一点，让我们尝试从Web浏览器中检索项目根（主页）。结果看起来不太好：
- en: '![Debugging the new Apache configuration](img/7566_11_03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![调试新的Apache配置](img/7566_11_03.jpg)'
- en: 'What might be wrong now? In this case, the main Apache error log is silent
    on the reason for the error. Rather, it is the error log configured for the `marketr`
    virtual site that provides an indication of the problem. Checking that file, we
    see that the full content of `/dj_projects/marketr/apache/logs/error.log` is now:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能出了什么问题？在这种情况下，主要的Apache错误日志对于错误的原因是沉默的。相反，是为`marketr`虚拟站点配置的错误日志提供了问题的指示。检查该文件，我们看到`/dj_projects/marketr/apache/logs/error.log`的完整内容现在是：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Except for the last one, none of these messages indicate a problem. Rather they
    are informational and debug level messages logged by `mod_wsgi`, as requested
    by the setting of `LogLevel debug` in the virtual host configuration. These messages
    show `mod_wsgi` reporting on various values (deadlock timeout, inactivity timeout)
    it is using, and show that `mod_wsgi` started 15 threads in the daemon process
    `marketr`. All looks good until the last line, which is an error level message.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最后一个之外，这些消息都没有指示问题。相反，它们是由`mod_wsgi`记录的信息和调试级别消息，根据虚拟主机配置中`LogLevel debug`的设置。这些消息显示`mod_wsgi`报告了它正在使用的各种值（死锁超时，不活动超时），并显示`mod_wsgi`在守护进程`marketr`中启动了15个线程。一切看起来都很好，直到最后一行，这是一个错误级别的消息。
- en: The specifics of this last message are not much more helpful than the bare **Forbidden**
    displayed by the web browser. The message does indicate that the `marketr.wsgi`
    script is involved, and that the request is **denied by server configuration**.
    In this case, the problem is not that the file does not exist, but rather that
    the server has been configured to not allow access to it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条消息的具体内容并没有比Web浏览器显示的光秃秃的 **Forbidden** 更有帮助。消息确实表明`marketr.wsgi`脚本涉及其中，并且请求被
    **服务器配置拒绝**。在这种情况下，问题不在于文件不存在，而是服务器已经配置为不允许访问它。
- en: 'The cause of this specific problem lies elsewhere in the Apache configuration
    on this machine, and this is a problem you may or may not encounter depending
    on your overall Apache configuration. The problem is that this machine''s Apache
    configuration has been set up to deny access to files in all directories except
    those that are explicitly enabled for access. This type of configuration is good
    from a security standpoint, but it does make configuration a bit more tedious.
    In this case, what is needed is a `Directory` block that allows access to files
    in the directory containing the `marketr.wsgi` script:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定问题的原因在这台机器上的Apache配置的其他地方，这是一个问题，根据您的整体Apache配置，您可能会遇到或者不会遇到。问题在于这台机器的Apache配置已经设置为拒绝访问除了明确启用访问的所有目录中的文件。从安全的角度来看，这种类型的配置是好的，但它确实使配置变得有点更加费力。在这种情况下，需要的是一个`Directory`块，允许访问包含`marketr.wsgi`脚本的目录中的文件：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The details of Apache's three-pass access control system is beyond the scope
    of this book; if you are interested, the Apache documentation describes the process
    in detail. For our purposes, it is sufficient to note that this `Directory` block
    allows all clients to access files in `/dj_projets/marketr/apache/wsgi`, which
    should be acceptable and enough to get past the **Forbidden** initially returned
    by the browser for the `marketr` project's home page.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Apache三遍访问控制系统的细节超出了本书的范围；如果您感兴趣，Apache文档详细描述了这个过程。对于我们的目的，值得注意的是这个`Directory`块允许所有客户端访问`/dj_projets/marketr/apache/wsgi`中的文件，这应该是可以接受的，并足以解决浏览器对`marketr`项目主页最初返回的
    **Forbidden**。
- en: 'The `Directory` block should be placed inside the `VirtualHost` block for the
    `marketr` project. Changing the configuration requires an Apache restart, after
    which we can try again to access the project home page. This time we see the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Directory`块应放在`marketr`项目的`VirtualHost`块内。更改配置需要重新启动Apache，之后我们可以再次尝试访问项目主页。这次我们看到以下内容：'
- en: '![Debugging the new Apache configuration](img/7566_11_04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![调试新的Apache配置](img/7566_11_04.jpg)'
- en: 'The good news is we got past the **Forbidden** error. The bad news is we did
    not get much farther. Again the page returned to the browser is of little use
    in debugging the problem, rather the site''s error log is where details of the
    problem are recorded. This time at the end of the file we find:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是我们已经解决了**Forbidden**错误。坏消息是我们并没有走得更远。再次返回到浏览器的页面对于调试问题没有什么用，而网站的错误日志记录了问题的详细信息。这次在文件的末尾我们发现：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Clearly, the `marketr.wsgi` script did get used this time, since the traceback
    shows that Django code has been called. But the environment was not set up entirely
    correctly, since Django is unable to import the specified `marketr.settings` settings
    module. This is a commonly-encountered error that is almost always due to one
    of two things: either the Python path has not been set properly, or the user that
    the Apache process runs as does not have read access to the settings file (and
    the directory that contains it).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`marketr.wsgi`脚本这次确实被使用了，因为回溯显示Django代码已被调用。但是环境设置并不完全正确，因为Django无法导入指定的`marketr.settings`设置模块。这是一个常见的错误，几乎总是由两种情况之一引起的：要么Python路径没有正确设置，要么Apache进程运行的用户没有读取设置文件（以及包含它的目录）的权限。
- en: 'In this case, a quick check of the permissions on the `/dj_projects/marketr`
    directory and its files show that they are readable by all:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，快速检查`/dj_projects/marketr`目录及其文件的权限显示它们是可读的：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Thus, it does not seem likely the problem is related to the ability of the web
    server process to access the `settings.py` file. Note, however, if you are running
    a version of Linux that uses the security-enhanced kernel (SELinux kernel), the
    permissions information displayed by `ls -l` may be misleading. This kernel has
    a complex file access control structure that requires additional configuration
    (beyond the scope of this book) in order to allow the web server process to access
    files outside of its own designated area.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，问题似乎不太可能与Web服务器进程访问`settings.py`文件的能力有关。但是，请注意，如果您运行的是使用安全增强内核（SELinux内核）的Linux版本，则`ls
    -l`显示的权限信息可能会误导。这个内核有一个复杂的文件访问控制结构，需要额外的配置（超出本书的范围）才能允许Web服务器进程访问其自己指定区域之外的文件。
- en: 'In this case, though, the machine is not running the SELinux kernel and the
    permissions information shows that any process can read the `settings.py` file.
    The problem, then, is likely in the path setting. Recall that the path and settings
    specification in the `marketr.wsgi` script is:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在这种情况下，机器并没有运行SELinux内核，并且权限信息显示任何进程都可以读取`settings.py`文件。因此，问题很可能在路径设置中。请回忆一下`marketr.wsgi`脚本中的路径和设置规范：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That path does not work to import a settings file specified as `marketr.settings`
    because the `marketr` part has been duplicated in both the path and the module
    specification. Python, in trying to find the module and using the first element
    on the path, will attempt to find a file named `/dj_projects/marketr/marketr/settings.py`.
    This will fail since the actual file is `/dj_projects/marketr/settings.py`. Unless
    `/dj_projects` alone is on `sys.path`, Python will not be able to load `marketr.settings`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个路径无法导入指定为`marketr.settings`的设置文件，因为路径和模块规范中的`marketr`部分都被重复了。Python在尝试找到模块并使用路径上的第一个元素时，将尝试找到一个名为`/dj_projects/marketr/marketr/settings.py`的文件。这将失败，因为实际文件是`/dj_projects/marketr/settings.py`。除非`/dj_projects`单独在`sys.path`上，否则Python将无法加载`marketr.settings`。
- en: 'One fix, then, is to include `/dj_projects` in the path setting:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个解决方法是在路径设置中包含`/dj_projects`。
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It seems a bit odd, though, to need to add two different items to the path
    for a single project. Are both really necessary? The first is necessary because
    throughout the survey application code, for example, we used imports of the form:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，需要为一个项目添加两个不同的项目路径似乎有点奇怪。这两个都真的必要吗？第一个是必要的，因为在调查应用程序代码中，例如，我们使用了以下形式的导入：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since `marketr` is not included in those imports, it must be included in an
    element of the Python path. When running the development server, the `/dj_projects/marketr`
    directory is the current path, which is automatically included in the Python path,
    so these imports work. When running under Apache, `/dj_projects/marketr` must
    be included on the path for these imports to work.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些导入中没有包含`marketr`，因此必须在Python路径的一个元素中包含它。在运行开发服务器时，`/dj_projects/marketr`目录是当前路径，自动包含在Python路径中，因此这些导入有效。在Apache下运行时，必须在路径中包含`/dj_projects/marketr`才能使这些导入工作。
- en: 'Alternatively, we could change all the imports in both the `survey` and `gen_utils`
    applications to use the form:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以更改`survey`和`gen_utils`应用程序中的所有导入，使用以下形式：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This approach, however, ties these applications tightly to the `marketr` project,
    making it harder to re-use them outside of that one project. I feel it is better
    practice to make applications independent and not include in their imports the
    name of the containing project.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法将这些应用程序紧密地绑定到`marketr`项目，使得在该项目之外重新使用它们变得更加困难。我认为最好的做法是使应用程序独立，不在它们的导入中包含包含项目的名称。
- en: 'What about `/dj_projects`—does that really need to be included in the path?
    Could we eliminate needing to have it in the path by specifying the settings module
    as simply `settings` instead of `marketr.settings`? Yes, that would get us past
    this particular error, but we would quickly hit another similar error when the
    `ROOT_URLCONF` value in the settings file was processed. `ROOT_URLCONF` also includes
    `marketr` in its specification:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`/dj_projects`呢？是否真的需要在路径中包含它？我们是否可以通过将设置模块指定为简单的`settings`而不是`marketr.settings`来消除需要在路径中包含它的需要？是的，这将使我们摆脱特定的错误，但当处理设置文件中的`ROOT_URLCONF`值时，我们很快会遇到另一个类似的错误。`ROOT_URLCONF`也在其规范中包括`marketr`：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We could change that as well, and hope it is the last one, but it is probably
    easier to just include `/dj_projects` in the path when running under the web server.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以更改它，并希望这是最后一个问题，但最好的方法可能是在Web服务器下运行时简单地包括`/dj_projects`在路径中。
- en: You might wonder how `/dj_projects` was included in the path when running under
    the development server, since the parent of the current directory is not generally
    included in the Python path the way the current directory is. The answer is that
    the setup code for the development server places the parent of the project directory
    in the Python path. This can be helpful to people new to Python when starting
    out, but often causes confusion in the long run, since it is somewhat surprising
    behavior to anyone who is not new to Python.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道在开发服务器下运行时如何将`/dj_projects`包含在路径中，因为当前目录的父目录通常不包含在Python路径中，就像当前目录一样。答案是，开发服务器的设置代码将项目目录的父目录放在Python路径中。对于刚开始学习Python的人来说，这可能有所帮助，但长远来看，这往往会引起混乱，因为对于不是刚开始学习Python的人来说，这是令人惊讶的行为。
- en: 'To proceed from this point, however, we will just include `/dj_projects` as
    well as `/dj_projects/marketr` in the Python path, as previously shown. Note that
    when running `mod_wsgi` in daemon mode, it is not necessary to reload or restart
    Apache to get it to pick up changes to the WSGI script. Changing the WSGI script
    itself is sufficient to cause `mod_wsgi` to automatically restart its daemon processes.
    Thus, all we need to do is save the modified file and again try to access the
    project home page. This time we see the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要从这一点继续，我们只需在Python路径中包括`/dj_projects`以及`/dj_projects/marketr`，如前所示。请注意，在守护程序模式下运行`mod_wsgi`时，不需要重新加载或重新启动Apache即可使其获取WSGI脚本的更改。更改WSGI脚本本身足以导致`mod_wsgi`自动重新启动其守护进程。因此，我们只需要保存修改后的文件，然后再次尝试访问项目主页。这次我们看到以下内容：
- en: '![Debugging the new Apache configuration](img/7566_11_05.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![调试新的Apache配置](img/7566_11_05.jpg)'
- en: Again, we have good news and bad news. We certainly got further, and the Django
    code is working well enough to return a debug page, which is encouraging and easier
    to deal with than having to go search in the Apache error logs for the problem.
    Unfortunately, the fact that we got a debug page and not the project home page
    means there is still more that is not quite right in the environment when running
    under the web server.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次有好消息和坏消息。我们确实取得了进展，Django代码运行良好，足以返回调试页面，这是令人鼓舞的，比起不得不在Apache错误日志中搜索问题，这更容易处理。不幸的是，我们得到调试页面而不是项目主页意味着在Web服务器下运行时环境仍然存在一些问题。
- en: 'This time the exception information indicates that the `matplotlib` code needs
    write access to a directory for its configuration data. It apparently tried to
    create a directory named `/var/www/.matplotlib`, and that failed. The message
    suggests that if an environment variable named `MPLCONFIGDIR` is set to point
    to a writable directory, we may get past this problem. We can certainly set this
    environment variable in the `marketr.wsgi` script, just as the `DJANGO_SETTINGS_MODULE`
    environment variable is set:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这次异常信息表明`matplotlib`代码需要对其配置数据的目录具有写访问权限。它显然尝试创建一个名为`/var/www/.matplotlib`的目录，但失败了。消息表明，如果设置一个名为`MPLCONFIGDIR`的环境变量指向一个可写目录，我们可能会解决这个问题。我们当然可以在`marketr.wsgi`脚本中设置这个环境变量，就像设置`DJANGO_SETTINGS_MODULE`环境变量一样：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We also need to create the directory specified there and make it writeable
    by the web server process. The easiest way to do this is to simply change the
    owner of the directory to the user the web server process runs as, which on this
    machine is `www-data`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建指定的目录，并使Web服务器进程可以对其进行写操作。最简单的方法是将目录的所有者更改为Web服务器进程运行的用户，这台机器上的用户是`www-data`：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Alternatively, the `WSGIDaemonProcess` directive in the virtual host configuration
    could be changed to specify a different user. But the only user that would have
    write access, by default, to directories under `/dj_projects` would be my own
    user, `kmt`, and I would prefer not to have a web server process running with
    write access to all of my own files. Thus, it is easier to simply let the web
    server continue to run as `www-data` and explicitly give it permission to access
    directories as necessary. Note that if you are using SQLite as your database,
    you will also need to set permissions on the database file so that the Apache
    process can read and write it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，虚拟主机配置中的`WSGIDaemonProcess`指令可以更改为指定不同的用户。但是，默认情况下，唯一具有对`/dj_projects`目录下目录的写访问权限的用户是我的用户`kmt`，我宁愿不让Web服务器进程以写访问权限运行我的所有文件。因此，更容易的方法是让Web服务器继续以`www-data`运行，并明确允许它根据需要访问目录。请注意，如果您使用SQLite作为数据库，还需要设置数据库文件的权限，以便Apache进程可以读取和写入它。
- en: 'Have we got past the last problem yet? Saving the changed `marketr.wsgi` file
    and retrying the project home page brings up the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解决了最后一个问题吗？保存更改后的`marketr.wsgi`文件并重试项目主页，会出现以下内容：
- en: '![Debugging the new Apache configuration](img/7566_11_06.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![调试新的Apache配置](img/7566_11_06.jpg)'
- en: Success at last, of a sort. There are no surveys displayed on the home page
    because enough time has passed that the one closed `survey` we had been working
    with has now been closed for too long to be listed. Thus, there is not much of
    interest to see on the home page. The next natural step in testing is to go to
    the admin application and change the `closes` date on the survey so that it will
    appear on the home page. Attempting to do this reveals some configuration we have
    not yet set up, which will be discussed next.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后成功，但是有点。主页上没有显示调查，因为已经过了足够长的时间，我们一直在处理的那个已关闭的`survey`现在已经关闭了太长时间，无法列出。因此，在主页上没有太多有趣的东西可看。测试的下一个自然步骤是转到管理员应用程序，并更改调查的`closes`日期，以便它出现在主页上。尝试这样做会显示一些我们尚未设置的配置，接下来将讨论。
- en: Configuring Apache to serve static files
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Apache以提供静态文件
- en: 'Attempting to access the admin application running under Apache, we get:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在Apache下访问管理员应用程序，我们得到：
- en: '![CoApache/mod_wsgi configurationnew configuration, debuggingnfiguring Apache
    to serve static files](img/7566_11_07.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![CoApache/mod_wsgi配置新配置，调试配置Apache以提供静态文件](img/7566_11_07.jpg)'
- en: That looks a lot like our sample project pages, bare of any custom styling.
    But the admin application, unlike our sample project, does have stylesheets it
    uses, which were correctly loaded when running under the development server. That
    was done by special-purpose code in the development server. When running under
    Apache, we need to configure it (or some other web server) to serve the admin
    application's static files.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很像我们的示例项目页面，没有任何自定义样式。但是，与我们的示例项目不同，管理员应用程序确实有它使用的样式表，在运行开发服务器时正确加载。这是由开发服务器中的专用代码完成的。在Apache下运行时，我们需要配置它（或其他Web服务器）来提供管理员应用程序的静态文件。
- en: How do we do that? All of the admin's static files will be referenced using
    the same prefix, specified by `ADMIN_MEDIA_PREFIX` in `settings.py`. The default
    value for this setting is `/media/`. Thus, we need to instruct Apache to serve
    files with this prefix directly from the admin's media directory tree, instead
    of routing the request to `mod_wsgi` and our Django project code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该如何做呢？所有管理员的静态文件都将使用相同的前缀引用，由`settings.py`中的`ADMIN_MEDIA_PREFIX`指定。此设置的默认值为`/media/`。因此，我们需要指示Apache直接从管理员的媒体目录树中提供带有此前缀的文件，而不是将请求路由到`mod_wsgi`和我们的Django项目代码。
- en: 'The Apache directives to accomplish this are (note that though the `Alias`
    and `Directory` lines below are split due to page width constraints, these need
    to be placed on single lines in the Apache configuration file):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一目标的Apache指令是（请注意，下面的`Alias`和`Directory`行由于页面宽度限制而被拆分，这些指令需要放在Apache配置文件中的单行上）：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first directive, `Alias`, sets up a mapping from URL paths that start with
    `/media` to the actual files which are located (on this machine) under `/usr/lib/python2.5/site-packages/django/contrib/admin/media/`.
    The following `Directory` block instructs Apache to allow all clients to access
    files in the directory where the admin media is located. Like the `Directory`
    block for the `marketr.wsgi` script, this is only needed if your Apache configuration
    has been set up to deny access to all directories by default.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个指令`Alias`设置了从以`/media`开头的URL路径到实际文件的映射，这些文件位于（在此计算机上）`/usr/lib/python2.5/site-packages/django/contrib/admin/media/`下。接下来的`Directory`块指示Apache允许所有客户端访问管理员媒体所在的目录中的文件。与`marketr.wsgi`脚本的`Directory`块一样，只有在您的Apache配置已经设置为默认拒绝访问所有目录时才需要这样做。
- en: 'These directives should be placed in the `VirtualHost` block for the `marketr`
    project virtual host. Apache then needs to be reloaded to recognize the configuration
    changes. Reloading the admin page in the browser then brings up a page with the
    correct custom styling:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令应该放在`marketr`项目虚拟主机的`VirtualHost`块中。然后需要重新加载Apache以识别配置更改。在浏览器中重新加载管理员页面，然后会出现带有正确自定义样式的页面：
- en: '![CoApache/mod_wsgi configurationnew configuration, debuggingnfiguring Apache
    to serve static files](img/7566_11_08.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![CoApache/mod_wsgi配置新配置，调试配置Apache以提供静态文件](img/7566_11_08.jpg)'
- en: 'Note, though, it is not only admin that has static files. In [Chapter 9](ch09.html
    "Chapter 9. When You Don''t Even Know What to Log: Using Debuggers"), *When You
    Don''t Even Know What to Log: Using Debuggers*, we added some use of static files
    into the `marketr` project. Specifically, the image files generated by matplotlib
    to show survey results are served as static files. These files, unlike the admin
    media files, were not automatically served by the development server, so we had
    to add an entry for them in the `marketr` project `urls.py` file, specifying that
    they be served by the Django static server view:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不仅管理员有静态文件。在[第9章](ch09.html "第9章。当你甚至不知道要记录什么时：使用调试器")中，*当你甚至不知道要记录什么时：使用调试器*，我们将一些静态文件的使用添加到了`marketr`项目中。具体来说，由matplotlib生成的图像文件以显示调查结果被作为静态文件提供。与管理员媒体文件不同，这些文件不会被开发服务器自动提供，因此我们不得不在`marketr`项目的`urls.py`文件中为它们添加一个条目，指定它们由Django静态服务器视图提供：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This configuration would still work to serve the files under Apache, but the
    static server is not recommended for use in production. Besides being a very inefficient
    way to serve static files, the static server code has not been audited for security.
    Thus, for production, this URL pattern should be removed from the `urls.py` file
    and Apache (or another server) should be configured to serve these files directly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置仍然可以在Apache下提供文件，但是不建议在生产中使用静态服务器。除了是一种非常低效的提供静态文件的方式之外，静态服务器代码还没有经过安全审计。因此，在生产中，这个URL模式应该从`urls.py`文件中删除，并且应该配置Apache（或其他服务器）直接提供这些文件。
- en: 'The directives to get Apache to serve these files are:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让Apache提供这些文件的指令是：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These are nearly identical to the directives needed for the admin media files,
    only modified to specify the URL path prefix used for the site media files, and
    the actual location of those files.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些与为管理员媒体文件所需的指令几乎完全相同，只是修改为指定用于站点媒体文件的URL路径前缀和这些文件的实际位置。
- en: 'Is that all? Not quite. Unlike the admin media files, the image files used
    by the `marketr` project are actually generated on-demand by the `marketr` project
    code. If we delete the existing image files and attempt to access the detail page
    for the completed survey, we will get an error when the web server process attempts
    to create one of the image files, as the following shows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部吗？还不是。与管理媒体文件不同，`marketr`项目使用的图像文件实际上是由`marketr`项目代码按需生成的。如果我们删除现有的图像文件并尝试访问已完成调查的详细页面，当Web服务器进程尝试创建其中一个图像文件时，我们将会收到错误，如下所示：
- en: '![CoApache/mod_wsgi configurationnew configuration, debuggingnfiguring Apache
    to serve static files](img/7566_11_09.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![CoApache/mod_wsgi configurationnew configuration, debuggingnfiguring Apache
    to serve static files](img/7566_11_09.jpg)'
- en: 'To fix this, the web server code will need write access to the directory containing
    the files. This can be done by changing the owner of the directory `/dj_projects/marketr/site_media
    /piecharts` to `www-data`, as was done for the matplotlib configuration directory.
    After we make that change, attempting to reload the survey detail page shows that
    the web server is now able to create the image files, as the following shows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Web服务器代码需要对包含文件的目录具有写访问权限。这可以通过将目录`/dj_projects/marketr/site_media/piecharts`的所有者更改为`www-data`来实现，就像为matplotlib配置目录所做的那样。在我们进行了这个更改之后，尝试重新加载调查详细页面会显示Web服务器现在能够创建图像文件，如下所示：
- en: '![CoApache/mod_wsgi configurationnew configuration, debuggingnfiguring Apache
    to serve static files](img/7566_11_10.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![CoApache/mod_wsgi configurationnew configuration, debuggingnfiguring Apache
    to serve static files](img/7566_11_10.jpg)'
- en: We have now got the project up and running under Apache. Next, we will consider
    whether there are any additional potential problems we might run into as a result
    of differences between the development and production web server environments.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在Apache下成功运行了项目。接下来，我们将考虑是否存在任何额外的潜在问题，这些问题可能是由于开发和生产Web服务器环境之间的差异而导致的。
- en: Testing multithreaded behavior
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试多线程行为
- en: In the previous section, we encountered a few environmental differences between
    running under the development server and running under Apache. Some of these (for
    example, file permissions and Python path differences) caused problems that had
    to be overcome before we could get the project functioning properly under Apache.
    One difference we observed, but have not yet encountered a problem with, is multithreading.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们遇到了在开发服务器和Apache下运行时的一些环境差异。其中一些（例如，文件权限和Python路径差异）导致了在我们能够使项目在Apache下正常运行之前必须克服的问题。我们观察到的一个差异是多线程，但我们还没有遇到与之相关的问题。
- en: When we checked the error log in the previous section we could see that `mod_wsgi`
    had started one process with 15 threads, each ready to handle an incoming request.
    Multiple requests that arrive at the server nearly simultaneously, then, will
    be dispatched to different threads for handling, and the steps of their execution
    may be arbitrarily interleaved in real time. This can never happen with the development
    server, which is strictly single threaded, ensuring each request is fully processed
    before processing of the next one is started. It also never happens with any of
    the test tools covered in the first five chapters, since they too all test in
    a single-threaded manner.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在上一节中检查错误日志时，我们可以看到`mod_wsgi`已经启动了一个包含15个线程的进程，每个线程都准备处理一个传入的请求。因此，几乎同时到达服务器的多个请求将被分派到不同的线程进行处理，并且它们的执行步骤可能在实时中任意交错。这在开发服务器中永远不会发生，因为开发服务器是严格单线程的，确保每个请求在处理完之前不会启动下一个请求的处理。这也不会发生在前五章中介绍的任何测试工具中，因为它们也都以单线程方式进行测试。
- en: In Chapter 9 we already noted the need to keep in mind potential multithreading
    issues. In that chapter, we wrote the code to generate the image files for the
    display of survey results. The images are generated on-demand when the first request
    to display the survey is received after the survey has closed. Generating the
    image and writing it to disk took a perceptible amount of time, and it was fairly
    obvious that the code needed to properly handle the case where a second request
    was received for the survey results, but the processing of the first request had
    not yet completed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9章中，我们已经注意到需要牢记潜在的多线程问题。在那一章中，我们编写了用于显示调查结果的图像文件生成代码。这些图像是在调查关闭后首次收到显示调查请求时按需生成的。生成图像并将其写入磁盘需要一定的时间，很明显，代码需要正确处理这样一种情况：当收到对调查结果的第二个请求时，第一个请求的处理尚未完成。
- en: In that chapter, we learned how we could use breakpoints in the debugger to
    force multiple threads to execute in a particular sequence. In this way, we saw
    how we could test to ensure that the code behaved properly in whatever worst-case
    interleaved execution scenarios might arise in a multithreaded environment.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在那一章中，我们学习了如何在调试器中使用断点来强制多个线程按特定顺序执行。通过这种方式，我们看到了如何测试以确保代码在多线程环境中可能出现的最坏情况下的交错执行场景中的行为是否正常。
- en: 'But it is not only operations that take a significant amount of time, such
    as generating images or writing files, that we need to be concerned with. Under
    a heavy request load in a multithreaded environment, even the processing of requests
    that are generally quite quick may get interrupted and interleaved with processing
    from other requests being handled at the same time. On a multiprocessor machine,
    it''s not even necessary for one request to be interrupted: a second request could
    be running on a second processor truly simultaneously.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不仅需要关注那些需要大量时间的操作，比如生成图像或写文件，还需要关注在多线程环境下的高请求负载下，即使通常很快的请求处理也可能被中断并与同时处理的其他请求的处理交错。在多处理器机器上，甚至不需要中断一个请求：第二个请求可能会在第二个处理器上真正同时运行。
- en: 'Is there any code in the `marketr` project that might not function properly
    in a multithreaded environment? Possibly. Generally, the first code to consider
    for potential multithreading problems is any code that updates data. For the `survey`
    application, there is one view that updates data on the server: the one that receives
    and records posted survey results.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在“marketr”项目中是否有任何代码可能在多线程环境下无法正常工作？可能有。通常，首先要考虑潜在的多线程问题的代码是更新数据的任何代码。对于“survey”应用程序，有一个视图在服务器上更新数据：接收和记录发布的调查结果的视图。
- en: Are we sure the survey results recording code will function properly when it
    is run in a multithreaded environment where many copies of it may be running simultaneously?
    Since we have not tested it, no, we can't be sure. But now that we have the code
    running in a multithreaded environment, we can try testing it and see the outcome.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在多线程环境中运行时，我们是否确定调查结果记录代码在运行时能够正常工作，其中可能会同时运行许多副本？由于我们还没有测试过，所以不能确定。但是现在我们已经在多线程环境中运行代码，我们可以尝试测试它并查看结果。
- en: Generating load with siege
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用siege生成负载
- en: Having the code available for testing in a multithreaded environment is only
    half of what is needed to effectively test multithreaded behavior. The other half
    is some way of generating many simultaneous requests for the server to process.
    There are a number of different tools that can be used for this. The one we will
    use here is called `siege`, a freely available command line tool written by Jeffrey
    Fulmer. Information on downloading and installing `siege` can be found at [http://www.joedog.org/index/siege-home](http://www.joedog.org/index/siege-home).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程环境中测试代码的可用性只是有效测试多线程行为所需的一半。另一半是一些方式来生成服务器处理的许多同时请求。有许多不同的工具可以用于此。我们将在这里使用的是称为`siege`的工具，这是由Jeffrey
    Fulmer编写的一个免费的命令行工具。有关下载和安装`siege`的信息可以在[http://www.joedog.org/index/siege-home](http://www.joedog.org/index/siege-home)找到。
- en: 'Once installed, `siege` is very easy to use. The simplest way to call it is
    to pass a URL on the command line. It will start up several threads and continuously
    request the passed URL. As it runs, it displays what it is doing and key information
    about the responses it is receiving. For example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，`siege`非常容易使用。调用它的最简单方法是在命令行上传递一个URL。它将启动几个线程，并不断请求传递的URL。在运行时，它会显示它正在做什么以及有关它正在接收的响应的关键信息。例如：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here we see `siege` called to continuously request the project home page. During
    startup, it reports its version and prints out how many threads it will be using
    to make simultaneous requests. The default, as seen here, is 15; the `-c` (for
    concurrent) command line switch could be used to change that. `Siege` then prints
    out information about each request it sends. For each, it prints the protocol
    used (here all `HTTP/1.1`), the response code received (`200`), how long it took
    for the response to arrive (between `.02` and `.06` seconds), how many bytes in
    the response (`986`), and finally the URL path for the request.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到调用`siege`来不断请求项目主页。在启动时，它报告了它的版本，并打印出它将使用多少线程来进行同时请求。默认值如此，为15；`-c`（用于并发）命令行开关可以用来更改。然后，`siege`打印出有关它发送的每个请求的信息。对于每个请求，它打印出所使用的协议（这里都是`HTTP/1.1`），收到的响应代码（`200`），响应到达所花费的时间（在`.02`和`.06`秒之间），响应中的字节数（`986`），最后是请求的URL路径。
- en: 'By default `siege` will keep running until interrupted by *Ctrl-C*. When interrupted,
    it will stop generating load and report statistics on the results. For example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`siege`将一直运行，直到通过*Ctrl-C*中断。中断时，它将停止生成负载，并报告结果的统计信息。例如：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The tool made slightly over 700 requests and all received responses, as indicated
    by the report of 100 percent availability and 0 failed transactions. The performance
    numbers reported are interesting, but since we are presently running on a development
    machine with debug still turned on, it is a little early to be reading much into
    performance numbers. What we really want to check is whether the code that processes
    survey responses behaves correctly when called in a multithreaded environment
    under heavy load. We will consider how to do that next.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具发出了略多于700个请求，所有请求都收到了响应，正如报告所示，可用性达到了100%，没有失败的交易。报告的性能数字很有趣，但由于我们目前是在一个开发机器上运行，调试仍然打开，现在读取性能数字还为时过早。我们真正想要检查的是，在高负载的多线程环境下调用处理调查响应的代码是否正确。我们将考虑下一步该如何做。
- en: Load testing the results recording code
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试结果记录代码的负载
- en: How can we use `siege` to test the code that records survey answers? First,
    we need a survey in the database that is still open and thus will accept posted
    responses. The easiest way to do this is to use the admin application and change
    the `closes` date on the existing **Television Trends** survey to be some time
    in the future. At the same time, we can change the answer counts for all of the
    answers in the survey to be 0, which will make it easy to tell if all of the responses
    we generate with `siege` are processed correctly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用`siege`来测试记录调查答案的代码？首先，我们需要在数据库中有一个仍然开放的调查，因此将接受发布的答复。最简单的方法是使用管理应用程序，并将现有的**电视趋势**调查的“关闭”日期更改为将来的某个时间。同时，我们可以将调查中所有答案的答复计数更改为0，这将使我们能够轻松地判断我们使用`siege`生成的所有答复是否被正确处理。
- en: 'Next we need to determine what URL to specify to `siege` to get it to POST
    valid data for the survey''s form. The easiest way to do this is to bring up the
    page that displays the survey form in a browser and check the HTML source to see
    what the form fields are named and what the valid values for each are. In this
    case, the source HTML for the form displayed when we retrieve `http://localhost:8080/1/`
    is:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确定要指定给`siege`的URL，以便它可以为调查表单发布有效数据。最简单的方法是在浏览器中打开显示调查表单的页面，并检查HTML源代码，看看表单字段的名称和每个字段的有效值是什么。在这种情况下，当我们检索`http://localhost:8080/1/`时，显示表单的源HTML如下：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The form has two radio group inputs, one named `answer` and one named `1-answer`.
    Valid choices for `answer` are `1`, `2`, and `3`. Valid choices for `1-answer`
    are `4`, `5`, and `6`. Thus, we want to instruct `siege` to POST to `http://localhost:8080/1/`
    a value between `1` and `3` for `answer` and between `4` and `6` for `1-answer`.
    The way to do this, arbitrarily choosing the first choice for both questions,
    is to specify the URL as `"http://localhost:8080/1/ POST answer=1&1-answer=4"`.
    Note that the quotes around this URL are needed when passing it as a parameter
    on the command line due to the spaces and `&` in it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 表单有两个单选组输入，一个名为`answer`，一个名为`1-answer`。`answer`的有效选择是`1`、`2`和`3`。`1-answer`的有效选择是`4`、`5`和`6`。因此，我们希望指示`siege`向`http://localhost:8080/1/`发送`answer`为`1`到`3`之间的值，并且`1-answer`为`4`到`6`之间的值。任意选择两个问题的第一个选项的方法是将URL指定为`"http://localhost:8080/1/
    POST answer=1&1-answer=4"`。请注意，由于其中包含空格和`&`，在命令行上传递此URL时需要使用引号。
- en: 'In order to get a predictable number of requests generated, we can specify
    the `-r` command line switch, specifying the number of test repetitions. If we
    leave the default number of concurrent threads at 15 and specify 5 repetitions,
    at the end of the test we should see that the two chosen answers each have 5*15,
    or 75 votes. Let''s try it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得可预测的生成请求数，我们可以指定`-r`命令行开关，指定测试重复的次数。如果我们保留默认的并发线程数为15，并指定5次重复，在测试结束时，我们应该看到两个选择的答案每个都有5*15，或75票。让我们试一试：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here the output is a bit different from the first example. The `survey` application
    response to a successful POST of a survey response is an HTTP redirect (status
    302). The `siege` tool, like a browser, responds to the received redirect by requesting
    the location specified in the redirect response. The previous output, then, is
    showing that the POST requests are succeeding, and then the subsequent redirects
    to the thanks page for the survey are also succeeding.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的输出与第一个示例有些不同。`survey`应用程序对调查响应的成功POST是一个HTTP重定向（状态302）。`siege`工具，就像浏览器一样，响应接收到的重定向，请求重定向响应中指定的位置。因此，先前的输出显示了POST请求成功，然后对调查感谢页面的后续重定向也成功。
- en: 'The tail end of the output for this test run is:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试运行的输出末尾是：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That looks good. The total number of transactions is twice the number of posts
    requested, indicating that all of the POST requests returned a redirect, so they
    were all successfully processed. From the client side, then, it appears that the
    test ran successfully.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错。事务总数是请求的帖子数量的两倍，表明所有POST请求都返回了重定向，因此它们都被成功处理。因此，从客户端的角度来看，测试似乎运行成功。
- en: 'But do the vote counts on the server match up to what we expect? Answers 1
    (**Comedy**) and 4 (**Hardly any: I already watch too much TV!**) were each posted
    75 times, so we expect that they each have 75 votes while all of the other answers
    have none. Checking the vote count for the first question in the admin application,
    we see the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 但是服务器上的投票计数是否符合我们的预期？答案1（**喜剧**）和4（**几乎没有：我已经看了太多电视了！**）每个都被发布了75次，因此我们期望它们每个都有75票，而所有其他答案都没有。在管理应用程序中检查第一个问题的投票计数，我们看到以下内容：
- en: '![Load testing the results recording code](img/7566_11_11.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![加载测试结果记录代码](img/7566_11_11.jpg)'
- en: 'Similarly, checking the second question we see the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，检查第二个问题，我们看到以下内容：
- en: '![Load testing the results recording code](img/7566_11_12.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![加载测试结果记录代码](img/7566_11_12.jpg)'
- en: That's not good. While the `votes` values that were supposed to be 0 are all
    indeed **0**, the two `votes` values that were supposed to be 75 are instead **40**
    and **34**. Based on the results sent to the client, the server appeared to process
    all of the requests successfully. Yet clearly many of the votes were not actually
    recorded. How did that happen? The answer lies in the code that attempts to record
    posted survey responses, which we will check next.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这不好。虽然应该为0的`votes`值确实都是**0**，但是应该为75的两个`votes`值分别是**40**和**34**。根据发送给客户端的结果，服务器似乎成功处理了所有请求。然而，显然许多投票实际上并没有被记录。这是怎么发生的？答案在试图记录发布的调查响应的代码中，我们将在下面检查。
- en: Fixing the results recording code
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复结果记录代码
- en: 'Recall that the code which records posted survey answers is in the `display_active_survey`
    function in `survey/views.py`. This code processes both GET and POST requests.
    In the case of a POST, the code to validate and record the submitted values is:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请回想一下，记录发布的调查答案的代码位于`survey/views.py`中的`display_active_survey`函数中。此代码处理GET和POST请求。在POST的情况下，用于验证和记录提交值的代码是：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code runs fine and behaves properly when a single thread runs through it
    at a time. However, if multiple threads (from the same or different processes)
    are running through it simultaneously, all trying to increment `votes` value for
    the same answers, this code is likely to lose votes. The problem is that retrieving
    the current `votes` value, incrementing it, and saving the new value is not atomic.
    Rather it is done in three distinct steps that may be interleaved with the same
    steps done by another thread simultaneously.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当单个线程依次运行时，此代码运行良好并且行为正常。但是，如果多个线程（来自相同或不同的进程）同时运行，都尝试增加相同答案的`votes`值，那么这段代码很可能会丢失投票。问题在于检索当前的`votes`值，增加它并保存新值不是原子操作。而是在可能与另一个线程同时交错进行的三个不同步的步骤中完成。
- en: Consider two threads running concurrently, both attempting to record a vote
    for the `Answer` with primary key value 1\. (For simplicity, we will assume there
    is only one question in the survey.) The first thread enters this code and runs
    through the `for qf in qforms` loop validating the forms. It is during this loop
    that the current `votes` value for the chosen answer will be read from the database.
    Let's say the value that the first thread reads for the `votes` value for answer
    with primary key 1 is 5.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两个并发运行的线程，都试图记录对主键值为1的`Answer`进行投票。（为简单起见，我们假设调查中只有一个问题。）第一个线程进入这段代码，并通过`for
    qf in qforms`循环验证表单。在这个循环中，将从数据库中读取所选答案的当前`votes`值。假设第一个线程读取的主键为1的答案的`votes`值为5。
- en: 'Now, before this first thread is able to finish its work and save an incremented
    value of 6 for the `votes` field to the database, a second thread (either through
    pre-emptive scheduling or multiprocessor execution) enters the `for qf in qforms`
    loop. The posted form data this second thread is working with also specifies a
    vote for the answer with primary key 1\. This second thread also reads a current
    value of 5 for the `votes` value for this answer. Now we have a problem: two threads,
    both intending to increment the `votes` value for the same answer, both read the
    same existing value, and both will increment that value and save the result. Together
    the two threads will only cause the `votes` count to be incremented by one: one
    of the votes will effectively be lost.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在第一个线程能够完成其工作并将`votes`字段的递增值保存到数据库中之前，第二个线程（通过抢占式调度或多处理器执行）进入`for qf in qforms`循环。这第二个线程正在处理的发布的表单数据也指定了对主键为1的答案的投票。这第二个线程还读取了该答案的`votes`值的当前值为5。现在我们有一个问题：两个线程都意图递增相同答案的`votes`值，都读取了相同的现有值，并且都将递增该值并保存结果。两个线程一起只会导致`votes`计数增加一次：一个投票实际上将会丢失。
- en: 'How do we fix this problem? For this simple case of incrementing (or performing
    some other arithmetic operation on) an existing field''s value in the database,
    it is reasonably easy to avoid the problem. We can slightly change the code in
    the `for answer in chosen_answers` loop to use a Django `F` expression to describe
    the desired result for `votes` instead of giving it an explicit numerical value.
    The changed code looks like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？对于在数据库中对现有字段的值进行递增（或执行其他算术操作）的简单情况，可以相对容易地避免这个问题。我们可以稍微改变`for answer
    in chosen_answers`循环中的代码，使用Django的`F`表达式来描述`votes`的期望结果，而不是给它一个明确的数值。更改后的代码如下：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use of an `F` expression in the value for `votes` will cause Django to construct
    an `UPDATE` SQL statement of the form:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`votes`的值中使用`F`表达式将导致Django构造一个`UPDATE` SQL语句的形式：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This type of `UPDATE` statement pushes the responsibility of ensuring that the
    increment operation is atomic onto the database server. That is generally where
    you want to place such responsibility, since that is exactly what database servers
    are supposed to do both correctly and efficiently.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`UPDATE`语句将确保递增操作是原子的责任推到数据库服务器上。通常情况下，这就是您希望放置这种责任的地方，因为这正是数据库服务器应该正确和高效地执行的操作。
- en: 'If we now save this change to the code, reset all the vote counts to 0, and
    re-run the `siege` test, the problem will hopefully be gone. Only it is not! Checking
    the `votes` values again after running the test shows the same behavior: for the
    two answers that should have values of 75, one value is 43 and the other 39\.
    Why didn''t the code change fix the problem?'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在保存这个代码更改，将所有的投票计数重置为0，并重新运行`siege`测试，问题应该就解决了。但事实并非如此！在运行测试后再次检查`votes`值显示相同的行为：对于应该具有75值的两个答案中，一个值为43，另一个值为39。为什么代码更改没有解决问题呢？
- en: The problem in this case is that the code change was not seen by the running
    web server process. When running under Apache with `mod_wsgi`, changes to the
    Django application code will not automatically cause a reload of the processes
    that handle requests. Thus, the existing running processes will continue to use
    the old code. When running in daemon mode, touching the WSGI script will trigger
    a reload on receipt of the next request. Alternatively, restarting Apache will
    ensure the new code is loaded. As we will see later in the chapter, it is also
    possible to code the WSGI script to automatically restart the daemon process when
    a code change is detected.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下的问题是，代码更改没有被正在运行的Web服务器进程看到。在Apache下运行时，对Django应用程序代码的更改不会自动导致处理请求的进程重新加载。因此，现有的运行进程将继续使用旧代码。在守护程序模式下，触摸WSGI脚本将在接收到下一个请求时触发重新加载。或者，重新启动Apache将确保加载新代码。正如我们将在本章后面看到的，还可以编写WSGI脚本，以便在检测到代码更改时自动重新启动守护进程。
- en: For now, since the existing WSGI script does not monitor for source code changes,
    and since we are running in daemon mode, touching the WSGI script is the easiest
    way to get the application code change loaded. If we do that, again use the admin
    application to reset the vote counts to 0, and again try the `siege` test, we
    see that when the test finishes the votes for the two chosen answers are indeed
    the correct value, 75.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，由于现有的WSGI脚本不监视源代码更改，并且我们正在守护程序模式下运行，触摸WSGI脚本是加载应用程序代码更改的最简单方法。如果我们这样做，再次使用管理应用程序将投票计数重置为0，并再次尝试`siege`测试，我们会发现当测试完成时，两个选择的答案的投票确实是正确的值，即75。
- en: Additional load testing notes
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外的负载测试说明
- en: While we have successfully found and fixed a multithreading problem with the
    code that receives and records survey results, we have not done enough testing
    to ensure that the remainder of the application will behave properly in a typical
    production environment. A full test would involve load testing all views, both
    in isolation and in combination with each other, and ensures that the server responds
    correctly. Constructing such a test is beyond the scope of this book, but some
    notes about the process are included here.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经成功地发现并修复了接收和记录调查结果的代码中的多线程问题，但我们还没有进行足够的测试，以确保应用程序的其余部分在典型的生产环境中能够正常运行。完整的测试将涉及对所有视图进行负载测试，无论是单独还是与其他视图组合，并确保服务器正确响应。构建这样的测试超出了本书的范围，但这里包括了一些关于这个过程的注释。
- en: First, for the problem we did find we were fortunate that a very simple code
    change, namely use of an `F` expression, was available to easily make the database
    update atomic. For other situations, Django may or may not provide a simple API
    to help ensure atomicity of updates. For creating objects, for example, Django
    does have an atomic `get_or_create` function. For more complicated situations,
    such as ones involving updating several values in different objects, there may
    not be a simple Django API to use to ensure atomicity.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，对于我们发现的问题，我们很幸运地发现一个非常简单的代码更改，即使用`F`表达式，可以轻松地使数据库更新具有原子性。对于其他情况，Django可能会或可能不会提供一个简单的API来帮助确保更新的原子性。例如，对于创建对象，Django确实有一个原子的`get_or_create`函数。对于更复杂的情况，比如涉及更新不同对象中的多个值的情况，可能没有一个简单的Django
    API可用于确保原子性。
- en: In these cases, it will be necessary to use database support for maintaining
    data consistency. Some databases provide transactions to help with this, and Django
    in turn provides an API that allows an application to control transactional behavior.
    Other databases don't support transactions but do provide lower-level support,
    such as the ability to lock tables. Django does not provide an API for table locking,
    but it does allow applications to construct and execute arbitrary (raw) SQL, so
    an application can still use such functions. The disadvantage of using the raw
    SQL API is that the application will generally not be portable to a different
    database.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，有必要使用数据库支持来维护数据一致性。一些数据库提供事务来帮助处理这个问题，Django反过来提供了一个API，允许应用程序控制事务行为。其他数据库不支持事务，但提供更低级别的支持，比如锁定表的能力。Django不提供表锁定的API，但它允许应用程序构建和执行任意（原始）SQL，因此应用程序仍然可以使用这样的功能。使用原始SQL
    API的缺点是，应用程序通常无法在不同的数据库上移植。
- en: When setting out to create a new application, then, careful consideration should
    be given to the kinds of database updates the application will need to perform.
    If possible, it is best to structure the data so that simple atomic APIs can be
    used for all updates. If that is not possible, then use of database transactions
    or lower-level locking support may be required. The range of options available
    may be restricted by the database in use (if it is predetermined), and likewise
    the choice of specific technique used for ensuring data consistency may limit
    the databases on which the application will ultimately be able to run correctly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新应用程序时，应仔细考虑应用程序需要执行的数据库更新类型。如果可能的话，最好构造数据，以便所有更新都可以使用简单的原子API。如果不可能，那么可能需要使用数据库事务或更低级别的锁定支持。可用的选项范围可能会受到使用的数据库的限制（如果它是预定的），同样，用于确保数据一致性的特定技术的选择可能会限制应用程序最终能够正确运行的数据库。
- en: Second, while careful consideration and coding will help to ensure no multithreading
    surprises like the one bug we uncovered, explicit testing for problems like this
    is a good idea. Unfortunately, it is not something supported by the testing tools
    covered in the first five chapters, which all focus on verifying correct single-threaded
    behavior. Thus, some additional work will generally be required to augment the
    unit testing suite with additional tests that ensure correct behavior (and possibly
    some minimum level of performance) in a production environment under load. It
    may not be practical to expect individual developers to routinely run these additional
    tests, but having them available, and running them before placing any code updates
    into production, will save headaches in the long run.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，虽然仔细考虑和编码将有助于确保不会出现多线程意外，就像我们发现的一个bug，但显式测试这类问题是一个好主意。不幸的是，这并不是第一至第五章涵盖的测试工具所支持的，这些工具都专注于验证正确的单线程行为。因此，通常需要一些额外的工作来增加单元测试套件，以确保在生产环境中的正确行为（可能还有一定的性能水平）。个别开发人员通常不太可能经常运行这些额外的测试，但是有这些测试可用，并在将任何代码更新放入生产环境之前运行它们，将会在长远节省麻烦。
- en: Using Apache/mod_wsgi during development
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在开发过程中使用Apache/mod_wsgi
- en: As described throughout this chapter, the switch from using the Django development
    server to a production server such as Apache with `mod_wsgi` may run into various
    snags along the way. Some are easily overcome, others may require more effort.
    It is often inconvenient to encounter such difficulties late in the development
    cycle, when there is typically very little time available for making code changes.
    One way to make the transition smoother is to use a production server configuration
    during development. This is an idea worth some serious consideration.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章中所描述的，从使用Django开发服务器切换到像Apache与`mod_wsgi`这样的生产服务器可能会遇到各种各样的问题。有些问题很容易克服，其他可能需要更多的努力。通常在开发周期的后期遇到这些困难是不方便的，因为通常很少有时间进行代码更改。使过渡更加顺利的一种方法是在开发过程中使用生产服务器配置。这是一个值得认真考虑的想法。
- en: One possible objection to using a production server (namely Apache with `mod_wsgi`)
    during development is that installing and properly configuring Apache is difficult.
    Asking individual developers to do this is asking too much of them. Installation,
    however, is not generally difficult—and most development machines today are easily
    capable of running Apache without causing any performance impact for other activities.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生产服务器（即带有`mod_wsgi`的Apache）在开发过程中可能会遇到的一个可能的反对意见是，安装和正确配置Apache很困难。要求个别开发人员这样做对他们来说要求过多。然而，安装通常并不困难，而且今天大多数开发机器都可以轻松运行Apache而不会对其他活动造成任何性能影响。
- en: Configuring Apache can indeed be daunting, since there are many configuration
    directives and optional modules to consider. However, it is not necessary to become
    an expert in Apache configuration in order to successfully take a shipped default
    configuration and modify it to support running a Django application. The result
    may not be finely tuned for great performance under heavy load, but such tuning
    is not required for use of the configuration during development testing.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 配置Apache确实可能令人生畏，因为有许多配置指令和可选模块需要考虑。然而，并不需要成为Apache配置专家才能成功地使用默认配置并修改它以支持运行Django应用程序。结果可能不会经过精细调整以在重载情况下获得良好的性能，但在开发测试期间并不需要对配置进行调整。
- en: A second objection to using Apache during development may be that it is relatively
    inconvenient, compared to the development server. The console of the development
    server provides an easy way to check on what is going on; needing to consult the
    Apache log files is a bit of a nuisance in comparison. This is true but a very
    minor inconvenience.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Apache在开发过程中的第二个反对意见可能是相对不便，与开发服务器相比。开发服务器的控制台提供了一种轻松查看正在进行的操作的方式；需要查看Apache日志文件有点麻烦。这是真的，但只是一个非常小的不便。
- en: A more serious inconvenience is the need to be sure the running web server processes
    are restarted in order to pick up code changes during development. It is very
    easy to get used to the development server's automatic restart, and forget the
    need to do something (even if it is as simple as touching the WSGI script file)
    to ensure that the web server is using the latest code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 更严重的不便之处是需要确保运行的Web服务器进程在开发过程中重新启动以获取代码更改。很容易习惯于开发服务器的自动重启，并忘记需要做一些事情（即使只是简单地触摸WSGI脚本文件）来确保Web服务器使用最新的代码。
- en: However, it is in fact possible to set up the WSGI script for a Django project
    to behave in the same way as the development server. That is, the WSGI script
    can start up a code monitoring thread that checks for changed Python source files
    and triggers an automatic reload when necessary. Details of this can be found
    at [http://code.google.com/p/modwsgi/wiki/ReloadingSourceCode](http://code.google.com/p/modwsgi/wiki/ReloadingSourceCode).
    Using the code included on that page, an Apache with `mod_wsgi` configuration
    can be almost as convenient for development as the Django development server.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实际上可以设置Django项目的WSGI脚本以与开发服务器相同的方式运行。也就是说，WSGI脚本可以启动一个代码监视线程，检查更改的Python源文件，并在必要时触发自动重新加载。有关此内容的详细信息可以在[http://code.google.com/p/modwsgi/wiki/ReloadingSourceCode](http://code.google.com/p/modwsgi/wiki/ReloadingSourceCode)找到。使用该页面上包含的代码，带有`mod_wsgi`配置的Apache几乎可以像Django开发服务器一样方便。
- en: One remaining convenience of the development server that has not yet been covered
    is the ability to easily put breakpoints in code and drop into the Python debugger.
    Even this is possible when running under Apache, but for this Apache does need
    to be started in a special mode from a console session, so that it has a console
    to allow the debugger to interact with the user. Details of doing this can be
    found at [http://code.google.com/p/modwsgi/wiki/DebuggingTechniques](http://code.google.com/p/modwsgi/wiki/DebuggingTechniques).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 开发服务器的一个便利之处尚未涵盖的是能够轻松在代码中设置断点并进入Python调试器。即使在Apache下运行时也是可能的，但是为此Apache需要在控制台会话中以特殊模式启动，以便它有一个控制台允许调试器与用户交互。如何做到这一点的详细信息可以在[http://code.google.com/p/modwsgi/wiki/DebuggingTechniques](http://code.google.com/p/modwsgi/wiki/DebuggingTechniques)找到。
- en: In summary, it is quite possible to get nearly all the convenience of the Django
    development server from an Apache/`mod_wsgi` setup. Using such a configuration
    during development can help to ease the eventual transition to production, and
    can be well worth the additional early effort of installing and configuring Apache
    with `mod_wsgi` on a development machine.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，几乎可以从Apache/`mod_wsgi`设置中获得Django开发服务器的所有便利。在开发过程中使用这样的配置可以帮助轻松过渡到生产环境，并且值得在开发机器上安装和配置Apache与`mod_wsgi`的早期额外努力。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We have now reached the end of discussing the move to production for a Django
    application. In this chapter, we:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经讨论完将Django应用程序转移到生产环境的过程。在本章中，我们：
- en: Developed a configuration to support running the `marketr` project under Apache
    with `mod_wsgi`.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发了一个配置来支持在Apache下使用`mod_wsgi`运行`marketr`项目。
- en: Encountered a number of problems getting the project running under Apache. For
    each, we saw how to diagnose and fix the issue.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将项目运行在Apache下遇到了一些问题。针对每个问题，我们都看到了如何诊断和解决。
- en: Considered what additional testing could be done in the new environment, given
    its ability to run multiple threads concurrently.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑在新环境中可以进行哪些额外的测试，考虑到其能够同时运行多个线程。
- en: Developed a test for the code that records posted survey responses, and observed
    that the code did not operate correctly under heavy load in the production environment.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为记录发布的调查响应的代码开发了一个测试，并观察到在生产环境下在重载情况下代码无法正确运行。
- en: Fixed the problem found in the results recording code, and discussed other techniques
    that may be needed to fix more complex multithreading problems.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复了在结果记录代码中发现的问题，并讨论了可能需要修复更复杂的多线程问题的其他技术。
- en: Discussed the possibility of using Apache and `mod_wsgi` during development.
    This configuration can be made nearly as convenient for development as the Django
    development server, and use of the production setup during development can help
    reduce the number of problems encountered during the eventual move to production.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论了在开发过程中使用Apache和`mod_wsgi`的可能性。这种配置几乎可以和Django开发服务器一样方便，而在开发过程中使用生产环境设置可以帮助减少最终转移到生产环境时遇到的问题数量。
