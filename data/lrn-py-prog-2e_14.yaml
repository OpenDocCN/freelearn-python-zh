- en: Web Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web开发
- en: '"Don''t believe everything you read on the web."– Confucius'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “不要相信你在网上看到的一切。”– 孔子
- en: In this chapter, we're going to work on a website together. By working on a
    small project, my aim is to open a window for you to take a peek into what web
    development is, along with the main concepts and tools you should know if you
    want to be successful with it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将一起开发一个网站。通过参与一个小项目，我的目标是为你打开一扇窗，让你窥探一下Web开发是什么，以及你应该了解的主要概念和工具，如果你想在这方面取得成功的话。
- en: 'In particular, we are going to explore the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们将探索以下内容：
- en: The basic concepts around web programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web编程的基本概念
- en: The Django web framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django Web框架
- en: Regular expressions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式
- en: A brief overview of the Flask and Falcon web frameworks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask和Falcon Web框架的简要概述
- en: Let's start with the fundamentals.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础知识开始。
- en: What is the web?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是网络？
- en: The **World Wide Web** (**WWW**), or simply the **web**, is a way of accessing
    information through the use of a medium called the **internet**. The internet
    is a huge network of networks, a networking infrastructure. Its purpose is to
    connect billions of devices together, all around the globe, so that they can communicate
    with one another. Information travels through the internet in a rich variety of
    languages, called **protocols**, that allow different devices to speak the same
    tongue in order to share content.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**万维网**（**WWW**），或者简称为**web**，是通过使用称为**互联网**的媒介来访问信息的一种方式。互联网是一个庞大的网络，一个网络基础设施。它的目的是连接全球各地的数十亿设备，以便它们可以相互通信。信息通过互联网以丰富多样的语言（称为**协议**）传输，这些语言允许不同的设备说同一种语言以共享内容。'
- en: The web is an information-sharing model, built on top of the internet, which
    employs the **Hypertext Transfer Protocol** (**HTTP**) as a basis for data communication.
    The web, therefore, is just one of several different ways information can be exchanged
    over the internet; email, instant messaging, news groups, and so on, all rely
    on different protocols.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是一种建立在互联网之上的信息共享模型，它以**超文本传输协议**（**HTTP**）作为数据通信的基础。因此，网络只是互联网上可以交换信息的几种不同方式之一；电子邮件、即时通讯、新闻组等都依赖于不同的协议。
- en: How does the web work?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络是如何工作的？
- en: 'In a nutshell, HTTP is an asymmetric **request-response** **client-server**
    protocol. An HTTP client sends a request message to an HTTP server. The server,
    in turn, returns a response message. In other words, HTTP is a **pull protocol**
    in which the client pulls information from the server (as opposed to a **push
    protocol**, in which the server pushes information down to the client). Take a
    look at the following diagram:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，HTTP是一种不对称的**请求-响应** **客户端-服务器**协议。HTTP客户端向HTTP服务器发送请求消息。服务器反过来返回一个响应消息。换句话说，HTTP是一个**拉取协议**，客户端从服务器拉取信息（与**推送协议**相对，服务器向客户端推送信息）。看一下下面的图表：
- en: '![](../images/00026.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00026.jpeg)'
- en: HTTP is based on **TCP**/**IP** (or the **Transmission Control Protocol**/**Internet
    Protocol**), which provides the tools for a reliable communication exchange.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP基于**TCP**/**IP**（或者**传输控制协议**/**互联网协议**），它提供了可靠的通信交换工具。
- en: An important feature of the HTTP protocol is that it's *stateless*. This means
    that the current request has no knowledge about what happened in previous requests.
    This is a limitation, but you can browse a website with the illusion of being
    logged in. Under the covers though, what happens is that, on login, a token of
    user information is saved (most often on the client side, in special files called
    **cookies**) so that each request the user makes carries the means for the server
    to recognize the user and provide a custom interface by showing their name, keeping
    their basket populated, and so on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议的一个重要特点是它是*无状态*的。这意味着当前请求对之前的请求发生的事情一无所知。这是一个限制，但你可以以被登录的幻觉浏览网站。然而，在幕后，发生的是，在登录时，用户信息的令牌被保存（通常在客户端，称为**cookies**的特殊文件中），以便用户发出的每个请求都携带服务器识别用户并提供自定义界面的手段，比如显示他们的名字，保持他们的购物篮中的物品等等。
- en: Even though it's very interesting, we're not going to delve into the rich details
    of HTTP and how it works. However, we're going to write a small website, which
    means we'll have to write the code to handle HTTP requests and return HTTP responses.
    I won't keep prepending HTTP to the terms request and response from now on, as
    I trust there won't be any confusion.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它非常有趣，我们不打算深入研究HTTP的丰富细节以及它的工作原理。然而，我们将要编写一个小型网站，这意味着我们将不得不编写处理HTTP请求并返回HTTP响应的代码。从现在开始，我不会再在术语请求和响应前面加上HTTP，因为我相信不会有任何混淆。
- en: The Django web framework
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django Web框架
- en: 'For our project, we''re going to use one of the most popular web frameworks
    you can find in the Python ecosystem: Django.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们将使用Python生态系统中最流行的Web框架之一：Django。
- en: A **web framework** is a set of tools (libraries, functions, classes, and so
    on) that we can use to code a website. We need to decide what kind of requests
    we want to allow to be issued against our web server and how we respond to them.
    A web framework is the perfect tool for doing that because it takes care of many
    things for us so that we can concentrate only on the important bits without having
    to reinvent the wheel.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web框架**是一组工具（库、函数、类等），我们可以用它们来编写网站。我们需要决定允许针对我们的Web服务器发出什么样的请求以及我们如何对它们做出响应。Web框架是做到这一点的完美工具，因为它为我们处理了许多事情，这样我们就可以专注于重要的部分，而不必重新发明轮子。'
- en: There are different types of frameworks. Not all of them are designed for writing
    code for the web. In general, a **framework** is a tool that provides functionalities
    to facilitate the development of software applications, products, and solutions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的框架。并非所有框架都是为编写网络代码而设计的。一般来说，**框架**是一种提供功能以便于开发软件应用程序、产品和解决方案的工具。
- en: Django design philosophy
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django设计哲学
- en: 'Django is designed according to the following principles:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Django根据以下原则设计：
- en: '**Don''t repeat yourself** (**DRY**): Don''t repeat code, and code in a way
    that makes the framework deduce as much as possible from as little as possible.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要重复自己**（**DRY**）：不要重复编写代码，并以尽可能从尽可能少的代码中推断出尽可能多的框架。'
- en: '**Loose coupling**: The various layers of the framework shouldn''t know about
    each other (unless absolutely necessary for whatever reason). Loose coupling works
    best when paralleled with high cohesion. Putting together things which change
    for the same reason, and spreading apart those which change for different reasons.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松耦合**：框架的各个层次不应该彼此了解（除非出于绝对必要的原因）。松耦合最适合与高内聚并行。将因同一原因而改变的事物放在一起，将因不同原因而改变的事物分开。'
- en: '**Less code**: Applications should use the least possible amount of code, and
    be written in a way that favors reuse as much as possible.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**少量代码**：应用程序应尽可能使用最少的代码，并以尽可能有利于重用的方式编写。'
- en: '**Consistency**: When using the Django framework, regardless of which layer
    you''re coding against, your experience will be very consistent with the design
    patterns and paradigms that were chosen to lay out the project.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：使用Django框架时，无论您正在编写哪个层，您的体验都将与选择布置项目的设计模式和范例非常一致。'
- en: The framework itself is designed around the **model-template-view** (**MTV**)
    pattern, which is a variant of **model-view-controller** (**MVC**), which is widely
    employed by other frameworks. The purpose of such patterns is to separate concerns
    and promote code reuse and quality.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 框架本身是围绕**模型-模板-视图**（**MTV**）模式设计的，这是**模型-视图-控制器**（**MVC**）的一个变体，其他框架广泛采用。这些模式的目的是分离关注点，促进代码重用和质量。
- en: The model layer
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型层
- en: Of the three layers, this is the one that defines the structure of the data
    that is handled by the application, and deals with data sources. A **model** is
    a class that represents a data structure. Through some Django magic, models are
    mapped to database tables so that you can store your data in a relational database.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三个层次中，这一层定义了应用程序处理的数据结构，并处理数据源。**模型**是表示数据结构的类。通过一些Django魔术，模型被映射到数据库表，以便您可以将数据存储在关系数据库中。
- en: A **relational database** stores data in tables in which each column is a property
    of the data and each row represents a single item or entry in the collection represented
    by that table. Through the **primary key** of each table, which is that part of
    the data that allows it to uniquely identify each item, it is possible to establish
    relationships between items belonging to different tables, that is, to put them
    into *relation*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库以表格形式存储数据，其中每一列都是数据的属性，每一行代表该表格所代表的集合中的单个项目或条目。通过每个表格的主键，即允许其唯一标识每个项目的数据部分，可以建立不同表格中项目之间的关系，即将它们放入*关系*中。
- en: 'The beauty of this system is that you don''t have to write database-specific
    code in order to handle your data. You just have to configure your models correctly
    and use them. The work on the database is done for you by the Django **object-relational
    mapping** (**ORM**), which takes care of translating operations done on Python
    objects into a language that a relational database can understand: **SQL** (or **Structured
    Query Language**). We saw an example of ORM in [Chapter 7](part0187.html#5IAP60-2ddb708647cc4530a187c2c6c0e9acfe), *Files
    and Data Persistence*, where we explored SQLAlchemy.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统的美妙之处在于，您不必编写特定于数据库的代码来处理数据。您只需正确配置模型并使用它们。Django的**对象关系映射**（**ORM**）为您处理数据库的工作，它负责将在Python对象上执行的操作转换为关系数据库可以理解的语言：**SQL**（或**结构化查询语言**）。我们在[第7章](part0187.html#5IAP60-2ddb708647cc4530a187c2c6c0e9acfe)中看到了ORM的一个例子，即*文件和数据持久性*，在那里我们探讨了SQLAlchemy。
- en: One benefit of this approach is that you will be able to change databases without
    rewriting your code, since all the database-specific code is produced by Django
    on the fly, according to which database it's connected to. Relational databases
    speak SQL, but each of them has its own unique flavor of it; therefore, not having
    to hardcode any SQL in our application is a tremendous advantage.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个好处是，您可以在不重写代码的情况下更改数据库，因为Django会根据连接的数据库动态生成所有特定于数据库的代码。关系数据库使用SQL，但每个数据库都有其自己独特的风格；因此，在我们的应用程序中不需要硬编码任何SQL是一个巨大的优势。
- en: Django allows you to modify your models at any time. When you do, you can run
    a command that creates a migration, which is the set of instructions needed to
    port the database in a state that represents the current definition of your models.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Django允许您随时修改模型。当您这样做时，您可以运行一个命令来创建一个迁移，这是将数据库移植到表示模型当前定义的状态的一组指令。
- en: To summarize, this layer deals with defining the data structures you need to
    handle in your website and gives you the means to save and load them from and
    to the database by simply accessing the models, which are Python objects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，这一层处理定义您的网站中需要处理的数据结构，并为您提供通过简单访问模型来保存和加载数据到数据库的手段，这些模型是Python对象。
- en: The view layer
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图层
- en: The function of a view is handling a request, performing whatever action needs
    to be carried out, and eventually returning a response. For example, if you open
    your browser and request a page corresponding to a category of products in an
    e-commerce shop, the view will likely talk to the database, asking for all the
    categories that are children of the selected category (for example, to display
    them in a navigation sidebar) and for all the products that belong to the selected
    category, in order to display them on the page.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的功能是处理请求，执行需要执行的任何操作，并最终返回响应。例如，如果您打开浏览器并请求电子商务商店中产品类别对应的页面，视图可能会与数据库交互，请求所有作为所选类别子类的类别（例如，在导航侧栏中显示它们）以及属于所选类别的所有产品，以便在页面上显示它们。
- en: 'Therefore, the view is the mechanism through which we can fulfill a request.
    Its result, the response object, can assume several different forms: a JSON payload,
    text, an HTML page, and so on. When you code a website, your responses usually
    consist of HTML or JSON.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，视图是我们可以满足请求的机制。其结果，响应对象，可以呈现为多种不同形式：JSON有效载荷、文本、HTML页面等。当您编写网站时，您的响应通常由HTML或JSON组成。
- en: The **Hypertext Markup Language**, or **HTML**, is the standard markup language
    used to create web pages. Web browsers run engines that are capable of interpreting
    HTML code and render it into what we see when we open a page of a website.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**超文本标记语言**，或**HTML**，是用于创建网页的标准标记语言。Web浏览器运行引擎，能够解释HTML代码并将其呈现为我们在打开网站页面时看到的内容。'
- en: The template layer
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板层
- en: This is the layer that provides the bridge between backend and frontend development.
    When a view has to return HTML, it usually does it by preparing a **context object**
    (a dictionary) with some data, and then it feeds this context to a template, which
    is rendered (that is to say, transformed into HTML), and returned to the caller
    in the form of a response (more precisely, the body of the response). This mechanism
    allows for maximum code reuse. If you go back to the category example, it's easy
    to see that, if you browse a website that sells products, it doesn't really matter
    which category you click on or what type of search you perform, the layout of
    the products page doesn't change. What does change is the data with which that
    page is populated.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是提供后端和前端开发之间桥梁的层。当视图必须返回HTML时，通常会通过准备一个**上下文对象**（字典）与一些数据，然后将此上下文提供给模板，模板会被呈现（即转换为HTML），并以响应的形式返回给调用者（更准确地说，是响应的主体）。这种机制允许最大程度地重用代码。如果回到类别的例子，很容易看出，如果您浏览销售产品的网站，您点击哪个类别或执行何种类型的搜索并不重要，产品页面的布局不会改变。改变的是用于填充该页面的数据。
- en: Therefore, the layout of the page is defined by a template, which is written
    in a mixture of HTML and Django template languages. The view that serves that
    page collects all the products to be displayed in the context dictionary, and
    feeds it to the template, which will be rendered into an HTML page by the Django
    template engine.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，页面的布局是由模板定义的，该模板是用HTML和Django模板语言编写的混合体。提供页面的视图会在上下文字典中收集所有要显示的产品，并将其提供给模板，然后由Django模板引擎将其呈现为HTML页面。
- en: The Django URL dispatcher
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django URL分发器
- en: The way Django associates a **Uniform Resource Locator** (**URL**) with a view
    is by matching the requested URL with the patterns that are registered in a special
    file. A URL represents a page in a website so `http://mysite.com/categories?id=123`
    would probably point to the page for the category with ID `123` on my website,
    while `https://mysite.com/login` would probably be the user login page.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Django将**统一资源定位符**（**URL**）与视图关联的方式是通过将请求的URL与注册在特殊文件中的模式进行匹配。URL代表网站中的一个页面，因此`http://mysite.com/categories?id=123`可能指向我的网站上ID为`123`的类别页面，而`https://mysite.com/login`可能是用户登录页面。
- en: The difference between HTTP and HTTPS is that the latter adds encryption to
    the protocol so that the data that you exchange with the website is secured. When
    you put your credit card details on a website, or log in anywhere, or do anything
    around sensitive data, you want to make sure that you're using HTTPS.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP和HTTPS之间的区别在于后者为协议添加了加密，以确保您与网站交换的数据是安全的。当您在网站上输入信用卡详细信息，或者在任何地方登录，或者处理敏感数据时，您希望确保您正在使用HTTPS。
- en: Regular expressions
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: The way Django matches URLs to patterns is through a regular expression. A **regular
    expression** is a sequence of characters that defines a search pattern with which
    we can carry out operations, such as pattern and string matching, and find/replace.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Django将URL与模式匹配的方式是通过正则表达式。**正则表达式**是一系列字符，用于定义搜索模式，我们可以执行操作，如模式和字符串匹配，查找/替换等。
- en: Regular expressions have a special syntax to indicate things such as digits,
    letters, and spaces, as well as how many times we expect a character to appear,
    and much more. A complete explanation of this topic is outside the scope of this
    book. However, it is a very important subject, so the project we're going to work
    on together will revolve around it, in the hope that you will be stimulated to
    find the time to explore it a bit more on your own.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式具有特殊的语法，用于指示诸如数字、字母和空格等内容，以及我们期望字符出现的次数等内容。本书不涵盖此主题的完整解释。然而，这是一个非常重要的主题，因此我们将一起开展的项目将围绕它展开，希望您能有时间自行探索一下。
- en: 'To give you a quick example, imagine that you wanted to specify a pattern to
    match a date, such as `"26-12-1947"`. This string consists of two digits, one
    dash, two digits, one dash, and finally four digits. Therefore, we could write
    it like this: `r''[0-9]{2}-[0-9]{2}-[0-9]{4}''`. We created a class by using square
    brackets, and we defined a range of digits inside, from `0` to `9`, hence all
    the possible digits. Then, between curly brackets, we say that we expect two of
    them. Then a dash, then we repeat this pattern once as it is, and once more, by
    changing how many digits we expect, and without the final dash. Having a class
    such as `[0-9]` is such a common pattern that a special notation has been created
    as a shortcut: `''\d''`. Therefore, we can rewrite the pattern like this: `r''\d{2}-\d{2}-\d{4}''`
    and it will work exactly the same. That **r** in front of the string stands for
    **raw**, and its purpose is to prevents python from trying to interpret backslash
    escape sequences, so that they can be passed as-is to the regular expression engine.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 举个快速的例子，假设您想指定一个匹配日期的模式，比如 `"26-12-1947"`。这个字符串由两个数字、一个破折号、两个数字、一个破折号，最后是四个数字。因此，我们可以这样写：`r'[0-9]{2}-[0-9]{2}-[0-9]{4}'`。我们使用方括号创建了一个类，并在其中定义了一个数字范围，从
    `0` 到 `9`，因此包括了所有可能的数字。然后，在花括号中，我们说我们期望其中有两个。然后是一个破折号，然后我们重复这个模式一次，然后再一次，通过改变我们期望的数字数量，而最后没有破折号。拥有一个类，比如
    `[0-9]` 是一个如此常见的模式，以至于已经创建了一个特殊的符号作为快捷方式：`'\d'`。因此，我们可以这样重写这个模式：`r'\d{2}-\d{2}-\d{4}'`，它将完全相同地工作。字符串前面的那个
    **r** 代表 **原始**，它的目的是防止 Python 尝试解释反斜杠转义序列，以便它们可以原样传递给正则表达式引擎。
- en: A regex website
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个正则表达式网站
- en: So, here we are. We'll code a website that stores regular expressions so that
    we'll be able to play with them a little bit.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们要编写一个网站，用于存储正则表达式，以便我们可以稍微玩一下。
- en: Before we proceed with creating the project, I'd like to talk about **Cascading
    Style Sheets** (**CSS**). CSS are files in which we specify how the various elements
    on an HTML page look. You can set all sorts of properties, such as shape, size,
    color, margins, borders, and fonts. In this project, I have tried my best to achieve
    a decent result on the pages, but I'm neither a frontend developer nor a designer,
    so please don't pay too much attention to how things look. Try to focus on how
    they work.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续创建项目之前，我想谈谈 **层叠样式表**（**CSS**）。CSS 是我们在其中指定 HTML 页面上各种元素的外观的文件。您可以设置各种属性，比如形状、大小、颜色、边距、边框和字体。在这个项目中，我已经尽力在页面上取得了一个体面的结果，但我既不是前端开发人员也不是设计师，所以请不要太在意事物的外观。请尽量关注它们的工作原理。
- en: Setting up Django
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Django
- en: 'On the Django website ([https://www.djangoproject.com/](https://www.djangoproject.com/)),
    you can follow the tutorial, which gives you a pretty good idea of Django''s capabilities.
    If you want, you can follow that tutorial first and then come back to this example.
    So, first things first; let''s install Django in your virtual environment (you
    will find it is already installed, as it is part of the requirements file):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Django 网站 ([https://www.djangoproject.com/](https://www.djangoproject.com/))
    上，您可以按照教程，这会让您对 Django 的功能有一个很好的了解。如果您愿意，您可以先按照该教程操作，然后再回到这个例子。所以，首先要做的事情是；让我们在您的虚拟环境中安装
    Django（您会发现它已经安装好了，因为它是要求文件的一部分）：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When this command is done, you can test it within a console (try doing it with
    `bpython`, it gives you a shell similar to IPython but with nice introspection
    capabilities):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个命令完成后，您可以在控制台中测试它（尝试使用 `bpython`，它会给您一个类似于 IPython 但具有良好内省能力的 shell）：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that Django is installed, we're good to go. We'll have to do some scaffolding,
    so I'll quickly guide you through that.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Django 已经安装好了，我们可以开始了。我们需要做一些搭建工作，所以我会快速指导您完成。
- en: Starting the project
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动项目
- en: 'Choose a folder in the book''s environment and change into that. I''ll use
    `ch14`. From there, we can start a Django project with the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 选择书中环境中的一个文件夹并切换到其中。我会使用 `ch14`。从那里，我们可以使用以下命令启动一个 Django 项目：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will prepare the skeleton for a Django project called `regex`. Change
    into the `regex` folder and run the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为一个名为 `regex` 的 Django 项目准备好骨架。切换到 `regex` 文件夹并运行以下命令：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should be able to go to `http://127.0.0.1:8000/` with your browser and
    see the It worked! default Django page. This means that the project is correctly
    set up. When you''ve seen the page, kill the server with *Ctrl* + *C* (or whatever
    it says in the console). I''ll paste the final structure for the project now so
    that you can use it as a reference:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够在浏览器中输入 `http://127.0.0.1:8000/` 并看到 It worked! 默认的 Django 页面。这意味着项目已经正确设置。当您看到页面后，使用
    *Ctrl* + *C* 杀死服务器（或者控制台上显示的其他指令）。我现在将粘贴项目的最终结构，以便您可以用作参考：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Don''t worry if you''re missing files, we''ll get there. A Django project is
    typically a collection of several different applications. Each application is
    meant to provide a functionality in a self-contained, reusable fashion. We''ll
    create just one, called `entries`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您缺少文件，不要担心，我们会解决的。一个 Django 项目通常是由几个不同的应用程序集合组成的。每个应用程序都旨在以一种独立的、可重用的方式提供功能。我们将创建一个名为
    `entries` 的应用程序：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Within the `entries` folder that has been created, you can get rid of the `tests.py`
    module.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建的 `entries` 文件夹中，您可以删除 `tests.py` 模块。
- en: 'Now, let''s fix the `regex/settings.py` file in the `regex` folder. We need
    to add our application to the `INSTALLED_APPS` list so that we can use it (add
    it at the bottom of the list):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修复 `regex/settings.py` 文件在 `regex` 文件夹中。我们需要将我们的应用程序添加到 `INSTALLED_APPS`
    列表中，以便我们可以使用它（将其添加到列表的底部）：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, you may want to fix the language and time zone according to your personal
    preference. I live in London, so I set them like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可能想根据个人喜好设置语言和时区。我住在伦敦，所以我设置它们如下：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There is nothing else to do in this file, so you can save and close it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中没有其他事情要做，所以您可以保存并关闭它。
- en: 'Now it''s time to apply the **migrations** to the database. Django needs database
    support to handle users, sessions, and things like that, so we need to create
    a database and populate it with the necessary data. Luckily, this is very easily
    done with the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将**迁移**应用到数据库了。Django需要数据库支持来处理用户、会话等内容，所以我们需要创建一个数据库并用必要的数据填充它。幸运的是，这可以很容易地通过以下命令完成：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For this project, we use an SQLite database, which is basically just a file.
    On a real project, you would use a different database engine, such as MySQL or
    PostgreSQL.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们使用SQLite数据库，它基本上只是一个文件。在一个真正的项目中，你会使用不同的数据库引擎，比如MySQL或PostgreSQL。
- en: Creating users
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户
- en: 'Now that we have a database, we can create a superuser using the console:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个数据库，我们可以使用控制台创建一个超级用户：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After entering the username and other details, we have a user with admin privileges.
    This is enough to access the Django admin section, so try to start the server:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输入用户名和其他细节后，我们有了一个具有管理员特权的用户。这足以访问Django管理部分，所以尝试启动服务器：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will start the Django development server, which is a very useful built-in
    web server that you can use while working with Django. Now that the server is
    running, we can access the admin page at `http://localhost:8000/admin/`. I will
    show you a screenshot of this section later. If you log in with the credentials
    of the user you just created and head to the Authentication and Authorization
    section, you''ll find Users. Open that and you will be able to see the list of
    users. You can edit the details of any user you want as an admin. In our case,
    make sure you create a different one so that there are at least two users in the
    system (we''ll need them later). I''ll call the first user Fabrizio (username:
    `fab`) and the second one Adriano (username: `adri`), in honor of my father.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动Django开发服务器，这是一个非常有用的内置Web服务器，你可以在使用Django时使用它。现在服务器正在运行，我们可以在`http://localhost:8000/admin/`访问管理页面。稍后我会向你展示这部分的截图。如果你用刚刚创建的用户的凭据登录并转到身份验证和授权部分，你会找到用户。打开它，你就能看到用户列表。你可以作为管理员编辑任何用户的细节。在我们的情况下，请确保你创建一个不同的用户，这样系统中至少有两个用户（我们以后会需要）。我会称第一个用户为Fabrizio（用户名：`fab`），第二个用户为Adriano（用户名：`adri`），以纪念我的父亲。
- en: By the way, you should see that the Django admin panel comes for free automatically.
    You define your models, hook them up, and that's it. This is an incredible tool
    that shows how advanced Django's introspection capabilities are. Moreover, it
    is completely customizable and extendable. It's truly an excellent piece of work.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，你应该看到Django管理面板是自动免费提供的。你定义你的模型，连接它们，就这样。这是一个令人难以置信的工具，显示了Django的内省能力有多么先进。而且，它是完全可定制和可扩展的。这真是一项出色的工作。
- en: Adding the Entry model
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Entry模型
- en: 'Now that the boilerplate is out of the way, and we have a couple of users,
    we''re ready to code. We start by adding the `Entry` model to our application
    so that we can store objects in the database. Here''s the code you''ll need to
    add (remember to use the project tree for reference):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 既然样板代码已经完成，我们有了一些用户，我们准备好编码了。我们首先要将`Entry`模型添加到我们的应用程序中，以便我们可以将对象存储在数据库中。以下是你需要添加的代码（记得使用项目树作为参考）：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is the model we'll use to store regular expressions in our system. We'll
    store a pattern, a test string, a reference to the user who created the entry,
    and the moment of creation. You can see that creating a model is actually quite
    easy, but nonetheless, let's go through it line by line.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将用来在系统中存储正则表达式的模型。我们将存储一个模式、一个测试字符串、对创建条目的用户的引用以及创建的时刻。你可以看到创建一个模型实际上是相当容易的，但尽管如此，让我们逐行过一遍。
- en: First we need to import the `models` module from `django.db`. This will give
    us the base class for our `Entry` model. Django models are special classes and
    much is done for us behind the scenes when we inherit from `models.Model`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从`django.db`中导入`models`模块。这将为我们提供`Entry`模型的基类。Django模型是特殊的类，当我们从`models.Model`继承时，很多工作都是在幕后为我们完成的。
- en: We want a reference to the user who created the entry, so we need to import
    the `User` model from Django's authorization application and we also need to import
    the `timezone` model to get access to the `timezone.now()` function, which provides
    us with a `timezone`-aware version of `datetime.now()`. The beauty of this is
    that it's hooked up with the `TIME_ZONE` settings I showed you before.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个对创建条目的用户的引用，所以我们需要从Django的授权应用程序中导入`User`模型，我们还需要导入`timezone`模型以访问`timezone.now()`函数，该函数为我们提供了`datetime.now()`的`timezone`-aware版本。这样做的美妙之处在于它与我之前向你展示的`TIME_ZONE`设置相连。
- en: As for the primary key for this class, if we don't set one explicitly, Django
    will add one for us. A **primary key** is a key that allows us to uniquely identify
    an `Entry` object in the database (in this case, Django will add an auto-incrementing
    integer ID).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 至于这个类的主键，如果我们不明确设置一个，Django会为我们添加一个。**主键**是一个允许我们在数据库中唯一标识`Entry`对象的键（在这种情况下，Django将添加一个自增的整数ID）。
- en: So, we define our class, and we set up four class attributes. We have a `ForeignKey`
    attribute that is our reference to the `User` model. We also have two `CharField`
    attributes that hold the pattern and test strings for our regular expressions.
    We also have `DateTimeField`, whose default value is set to `timezone.now`. Note
    that we don't call `timezone.now` right there, it's `now`, not `now()`. So, we're
    not passing a `DateTime` instance (set at the moment in time when that line is
    parsed) rather, we're passing a callable, a function that is called when we save
    an entry in the database. This is similar to the callback mechanism we used in
    [Chapter 12](part0305.html#92RRI0-2ddb708647cc4530a187c2c6c0e9acfe), *GUIs and
    Scripts*, when we were assigning commands to button clicks.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了我们的类，并设置了四个类属性。我们有一个`ForeignKey`属性，它是我们对`User`模型的引用。我们还有两个`CharField`属性，用于保存我们的正则表达式的模式和测试字符串。我们还有一个`DateTimeField`，其默认值设置为`timezone.now`。请注意，我们不在那里调用`timezone.now`，它是`now`，而不是`now()`。因此，我们不是传递一个`DateTime`实例（在解析该行时设置的时间点），而是传递一个可调用的函数，在保存数据库中的条目时调用该函数。这类似于我们在[第12章](part0305.html#92RRI0-2ddb708647cc4530a187c2c6c0e9acfe)中使用的回调机制，*GUIs
    and Scripts*，当我们将命令分配给按钮点击时。
- en: The last two lines are very interesting. We define a `Meta` class within the
    `Entry` class itself. The `Meta` class is used by Django to provide all sorts
    of extra information for a model. Django has a great deal of logic under the hood
    to adapt its behavior according to the information we put into the `Meta` class.
    In this case, in the admin panel, the pluralized version of `Entry` would be *Entrys*,
    which is wrong, therefore we need to set it manually. We specify the plural in
    all lowercase, as Django takes care of capitalizing it for us when needed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行非常有趣。我们在`Entry`类本身内部定义了一个`Meta`类。`Meta`类被Django用来为模型提供各种额外信息。Django在幕后有很多逻辑，根据我们放入`Meta`类的信息来调整其行为。在这种情况下，在管理面板中，`Entry`的复数形式将是*Entrys*，这是错误的，因此我们需要手动设置它。我们将复数形式指定为全部小写，因为Django在需要时会为我们大写它。
- en: 'Now that we have a new model, we need to update the database to reflect the
    new state of the code. In order to do this, we need to instruct Django that it
    needs to create the code to update the database. This code is called **migration**.
    Let''s create it and execute it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个新模型，我们需要更新数据库以反映代码的新状态。为了做到这一点，我们需要告诉Django它需要创建更新数据库的代码。这段代码被称为**迁移**。让我们创建并执行它：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After these two instructions, the database will be ready to store `Entry` objects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个指令之后，数据库将准备好存储`Entry`对象。
- en: 'There are two different kinds of migrations: data and schema migrations. **Data
    migrations** port data from one state to another without altering its structure.
    For example, a data migration could set all products for a category as out of
    stock by switching a flag to `False` or `0`. A **schema migration** is a set of
    instructions that alter the structure of the database schema. For example, that
    could be adding an `age` column to a `Person` table, or increasing the maximum
    length of a field to account for very long addresses. When developing with Django,
    it''s quite common to have to perform both kinds of migrations over the course
    of development. Data evolves continuously, especially if you code in an agile
    environment.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同类型的迁移：数据迁移和模式迁移。**数据迁移**将数据从一种状态转移到另一种状态，而不改变其结构。例如，数据迁移可以通过将标志切换为`False`或`0`来将某个类别的所有产品设置为缺货。**模式迁移**是一组指令，用于改变数据库模式的结构。例如，可以向`Person`表添加一个`age`列，或者增加字段的最大长度以适应非常长的地址。在使用Django进行开发时，通常需要在开发过程中执行这两种类型的迁移。数据不断发展，特别是在敏捷环境中编码时。
- en: Customizing the admin panel
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义管理面板
- en: The next step is to hook the `Entry` model up with the admin panel. You can
    do it with one line of code, but in this case, I want to add some options to customize
    the way the admin panel shows the entries, both in the list view of all entry
    items in the database and in the form view that allows us to create and modify
    them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将`Entry`模型与管理面板连接起来。您可以用一行代码做到这一点，但在这种情况下，我想添加一些选项来自定义管理面板显示条目的方式，无论是在数据库中的所有条目的列表视图中，还是在允许我们创建和修改它们的表单视图中。
- en: 'All we need to do is to add the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要添加以下代码：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is simply beautiful. My guess is that you probably already understand most
    of it, even if you're new to Django.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是太美了。我猜你可能已经理解了大部分内容，即使你是Django的新手。
- en: So, we start by importing the `admin` module and the `Entry` model. Because
    we want to foster code reuse, we import the `Entry` model using a relative import
    (there's a dot before `models`). This will allow us to move or rename the application
    without too much trouble. Then, we define the `EntryAdmin` class, which inherits
    from `admin.ModelAdmin`. The decoration on the class tells Django to display the
    `Entry` model in the admin panel, and what we put in the `EntryAdmin` class tells
    Django how to customize the way it handles this model.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先导入`admin`模块和`Entry`模型。因为我们想要促进代码重用，我们使用相对导入导入`Entry`模型（在`models`之前有一个点）。这将使我们能够在不太麻烦的情况下移动或重命名应用程序。然后，我们定义`EntryAdmin`类，它继承自`admin.ModelAdmin`。类上的装饰告诉Django在管理面板中显示`Entry`模型，我们在`EntryAdmin`类中放入的内容告诉Django如何自定义处理这个模型。
- en: First, we specify the `fieldsets` for the create/edit page. This will divide
    the page into two sections so that we get a better visualization of the content
    (pattern and test string) and the other details (user and timestamp) separately.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为创建/编辑页面指定`fieldsets`。这将把页面分成两个部分，以便我们更好地可视化内容（模式和测试字符串）和其他细节（用户和时间戳）分开。
- en: Then, we customize the way the list page displays the results. We want to see
    all the fields, but not the date. We also want to be able to filter on the user
    so that we can have a list of all the entries by just one user, and we want to
    be able to search on `test_string`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们自定义列表页面显示结果的方式。我们想要看到所有字段，但不包括日期。我们还希望能够按用户进行筛选，以便我们可以列出一个用户的所有条目，并且我们希望能够在`test_string`上进行搜索。
- en: 'I will go ahead and add three entries, one for myself and two on behalf of
    my father. The result is shown in the next two screenshots. After inserting them,
    the list page looks like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续添加三个条目，一个是我自己的，另外两个是我父亲的。结果显示在接下来的两个屏幕截图中。插入它们后，列表页面如下所示：
- en: '![](../images/00027.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00027.jpeg)'
- en: I have highlighted the three parts of this view that we customized in the `EntryAdmin`
    class. We can filter by user, we can search, and we have all the fields displayed.
    If you click on a pattern, the edit view opens up.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经突出显示了我们在`EntryAdmin`类中自定义的此视图的三个部分。我们可以按用户筛选，可以搜索，并且所有字段都显示出来。如果单击模式，则会打开编辑视图。
- en: 'After our customization, it looks like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的自定义之后，它看起来像这样：
- en: '![](../images/00028.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00028.jpeg)'
- en: 'Notice how we have two sections: Regular Expression and Other Information,
    thanks to our custom `EntryAdmin` class. Have a go with it, add some entries to
    a couple of different users, get familiar with the interface. Isn''t it nice to
    have all this for free?'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们有两个部分：正则表达式和其他信息，这要归功于我们自定义的`EntryAdmin`类。试一试，为几个不同的用户添加一些条目，熟悉界面。免费获得所有这些东西是不是很好？
- en: Creating the form
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表单
- en: Every time you fill in your details on a web page, you're inserting data in
    form fields. A **form** is a part of the HTML **Document Object Model** (**DOM**)
    tree. In HTML, you create a form by using the `form` tag. When you click on the
    submit button, your browser normally packs the `form` data together and puts it
    in the body of a `POST` request. As opposed to `GET` requests, which are used
    to ask the web server for a resource, a `POST` request normally sends data to
    the web server with the aim of creating or updating a resource. For this reason,
    handling `POST` requests usually requires more care than `GET` requests.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您在网页上填写详细信息时，您都在表单字段中插入数据。**表单**是HTML **文档对象模型**（**DOM**）树的一部分。在HTML中，您可以使用`form`标签创建一个表单。当您单击提交按钮时，您的浏览器通常会将`form`数据打包在一起，并将其放入`POST`请求的正文中。与用于向Web服务器请求资源的`GET`请求相反，`POST`请求通常会将数据发送到Web服务器，目的是创建或更新资源。因此，处理`POST`请求通常需要比处理`GET`请求更多的注意。
- en: When the server receives data from a `POST` request, that data needs to be validated.
    Moreover, the server needs to employ security mechanisms to protect against various
    types of attacks. One attack that is very dangerous is the **cross-site request
    forgery** (**CSRF**) attack, which happens when data is sent from a domain that
    is not the one the user is authenticated on. Django allows you to handle this
    issue in a very elegant way.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器接收到来自`POST`请求的数据时，需要对这些数据进行验证。此外，服务器需要采用安全机制来防范各种类型的攻击。一种非常危险的攻击是**跨站点请求伪造**（**CSRF**）攻击，当数据从未经用户认证的域发送时就会发生。Django允许您以非常优雅的方式处理这个问题。
- en: So, instead of being lazy and using the Django admin to create the entries,
    I'm going to show you how to do it using a Django form. By using the tools the
    framework gives you, you get a very good degree of validation work already done
    (in fact, we won't need to add any custom validation ourselves).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与其懒惰地使用Django管理员来创建条目，我将向您展示如何使用Django表单来完成。通过使用框架提供的工具，您已经完成了非常好的验证工作（实际上，我们不需要添加任何自定义验证）。
- en: 'There are two kinds of form classes in Django: `Form` and `ModelForm`. You
    use the former to create a form whose shape and behavior depends on how you code
    the class, what fields you add, and so on. On the other hand, the latter is a
    type of form that, albeit still customizable, infers fields and behavior from
    a model. Since we need a form for the `Entry` model, we''ll use that one:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中有两种形式类：`Form`和`ModelForm`。您可以使用前者创建一个表单，其形状和行为取决于您如何编写类，添加哪些字段等。另一方面，后者是一种类型的表单，尽管仍然可定制，但是从模型中推断字段和行为。由于我们需要一个`Entry`模型的表单，我们将使用这个：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Amazingly enough, this is all we have to do to have a form that we can put on
    a page. The only notable thing here is that we restrict the fields to only `pattern`
    and `test_string`. Only logged-in users will be allowed access to the insert page,
    and therefore we don't need to ask who the user is, we already know that. As for
    the date, when we save an `Entry`, the `date_added` field will be set according
    to its default, therefore we don't need to specify that as well. We'll see in
    the view how to feed the user information to the form before saving. So, now that
    the background work is done, all we need is the views and the templates. Let's
    start with the views.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，这就是我们需要做的一切，就可以在页面上放置一个表单。这里唯一值得注意的是，我们将字段限制为`pattern`和`test_string`。只有已登录的用户才能访问插入页面，因此我们不需要询问用户是谁，我们已经知道了。至于日期，当我们保存一个`Entry`时，`date_added`字段将根据其默认设置，因此我们也不需要指定。我们将在视图中看到如何在保存之前向表单提供用户信息。因此，现在背景工作已经完成，我们所需要的只是视图和模板。让我们从视图开始。
- en: Writing the views
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写视图
- en: 'We need to write three views. We need one for the home page, one to display
    the list of all entries for a user, and one to create a new entry. We also need
    views to log in and log out. But thanks to Django, we don''t need to write them.
    I''ll paste the code in steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写三个视图。我们需要一个用于主页的视图，一个用于显示用户的所有条目的列表，以及一个用于创建新条目的视图。我们还需要登录和注销视图。但幸运的是，由于Django，我们不需要编写它们。我将逐步粘贴代码：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's start with the imports. We need the `re` module to handle regular expressions,
    then we need a few classes and functions from Django, and finally, we need the
    `Entry` model and the `EntryForm` form.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导入开始。我们需要`re`模块来处理正则表达式，然后我们需要从Django中导入一些类和函数，最后，我们需要`Entry`模型和`EntryForm`表单。
- en: The home view
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主页视图
- en: 'The first view is `HomeView`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个视图是`HomeView`：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It inherits from `TemplateView`, which means that the response will be created
    by rendering a template with the context we'll create in the view. All we have
    to do is specify the `template_name` class attribute to point to the correct template.
    Django promotes code reuse to a point that if we didn't need to make this view
    accessible only to logged-in users, the first two lines would have been all we
    needed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 它继承自`TemplateView`，这意味着响应将通过渲染视图中创建的上下文来创建。我们所要做的就是指定`template_name`类属性，指向正确的模板。Django在代码重用方面的推广程度达到了一个程度，以至于如果我们不需要使此视图仅对已登录用户可访问，前两行就足够了。
- en: 'However, we want this view to be accessible only to logged-in users; therefore,
    we need to decorate it with `login_required`. Now, historically views in Django
    were functions; therefore, this decorator was designed to accept a function, and
    not a method like we have in this class. We''re using Django class-based views
    in this project so, in order to make things work, we need to transform `login_required`
    so that it accepts a method (the difference being in the first argument: `self`).
    We do this by passing `login_required` to `method_decorator`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们希望此视图仅对已登录用户可访问；因此，我们需要用`login_required`进行装饰。现在，历史上Django中的视图是函数；因此，这个装饰器是设计为接受一个函数的，而不是我们在这个类中拥有的方法。在这个项目中，我们使用Django基于类的视图，因此为了使事情正常工作，我们需要转换`login_required`，以便它接受一个方法（不同之处在于第一个参数：`self`）。我们通过将`login_required`传递给`method_decorator`来实现这一点。
- en: 'We also need to feed the `login_required` decorator with `login_url` information,
    and here comes another wonderful feature of Django. As you''ll see after we''re
    done with the views, in Django, you tie a view to a URL through a pattern, consisting
    of a string which may or may not be a regular expression, and possibly other information.
    You can give a name to each entry in the `urls.py` file so that when you want
    to refer to a URL, you don''t have to hardcode its value into your code. All you
    have to do is get Django to reverse-engineer that URL from the name we gave to
    the entry in `urls.py`, defining the URL and the view that is tied to it. This
    mechanism will become clearer later. For now, just think of `reverse(''...'')`
    as a way of getting a URL from an identifier. In this way, you only write the
    actual URL once, in the `urls.py` file, which is brilliant. In the `views.py`
    code, we need to use `reverse_lazy`, which works exactly like `reverse` with one
    major difference: it only finds the URL when we actually need it (in a lazy fashion).
    The reason why `reverse_lazy` can be so useful is that sometimes it might happen
    that we need to reverse an URL from an identifier, but at the moment we call `reverse`,
    the `urls.py` module hasn''t been loaded yet, which causes a failure. The lazy
    behavior of `reverse_lazy` solves the issue because even if the call is made before
    the `urls.py` module has been loaded, the actual reversing of the identifier,
    to get to the related URL, happens in a lazy fashion, later on, when `urls.py`
    has surely been loaded.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要向`login_required`装饰器提供`login_url`信息，这里又出现了Django的另一个精彩特性。正如在我们完成视图后所看到的那样，在Django中，您通过模式将视图绑定到URL，该模式由一个字符串组成，该字符串可能是正则表达式，也可能是其他信息。您可以在`urls.py`文件中为每个条目指定一个名称，以便在引用URL时，您不必将其值硬编码到代码中。您只需让Django从我们在`urls.py`中为条目指定的名称中反向工程出该URL，定义URL和绑定到它的视图。这种机制稍后将变得更加清晰。现在，只需将`reverse('...')`视为从标识符获取URL的一种方式。通过这种方式，您只需在`urls.py`文件中写入实际的URL一次，这是非常出色的。在`views.py`代码中，我们需要使用`reverse_lazy`，它的工作原理与`reverse`完全相同，只有一个主要区别：它只在我们实际需要时才找到URL（以懒惰的方式）。`reverse_lazy`之所以如此有用的原因是，有时可能需要从标识符反转URL，但在调用`reverse`时，`urls.py`模块尚未加载，这会导致失败。`reverse_lazy`的懒惰行为解决了这个问题，因为即使在`urls.py`模块加载之前进行调用，从标识符反转到相关URL的实际过程也是以懒惰的方式进行的，稍后，当`urls.py`肯定已经加载时。
- en: The `get` method, which we just decorated, simply calls the `get` method of
    the parent class. Of course, the `get` method is the method that Django calls
    when a `GET` request is performed against the URL tied to this view.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚装饰的`get`方法只是简单地调用了父类的`get`方法。当然，`get`方法是Django在针对与此视图绑定的URL执行`GET`请求时调用的方法。
- en: The entry list view
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条目列表视图
- en: 'This view is much more interesting than the previous one:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图比之前的要有趣得多：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'First of all, we decorate the `get` method as we did before. Inside of it,
    we need to prepare a list of `Entry` objects and feed it to the template, which
    shows it to the user. In order to do so, we start by getting the `context` dictionary
    like we''re supposed to do, by calling the `get_context_data` method of the `TemplateView`
    class. Then, we use the ORM to get a list of the entries. We do this by accessing
    the objects manager, and calling a filter on it. We filter the entries according
    to which user is logged in, and we ask for them to be sorted in descending order
    (that `''-''` in front of the name specifies the descending order). The `objects`
    manager is the default **manager** every Django model is augmented with on creation:
    it allows us to interact with the database through its methods.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们像之前一样装饰`get`方法。在其中，我们需要准备一个`Entry`对象列表并将其提供给模板，然后将其显示给用户。为了做到这一点，我们首先获取`context`字典，调用`TemplateView`类的`get_context_data`方法。然后，我们使用ORM获取条目列表。我们通过访问对象管理器并对其进行过滤来执行此操作。我们根据登录的用户对条目进行过滤，并要求它们按降序排序（名称前面的'-'指定了降序排序）。`objects`管理器是每个Django模型在创建时都会增强的默认**管理器**：它允许我们通过其方法与数据库进行交互。
- en: We parse each entry to get a list of matches (actually, I coded it so that `matches`
    is a generator expression). Finally, we add to the context an `'entries'` key
    whose value is the coupling of `entries` and `matches`, so that each `Entry` instance
    is paired with the resulting match of its pattern and test string.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解析每个条目以获得匹配项列表（实际上，我编码使`matches`成为一个生成器表达式）。最后，我们向上下文添加了一个`'entries'`键，其值是`entries`和`matches`的耦合，以便每个`Entry`实例与其模式和测试字符串的结果匹配配对。
- en: On the last line, we simply ask Django to render the template using the context
    we created.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，我们简单地要求Django使用我们创建的上下文来呈现模板。
- en: 'Take a look at the `_parse_entry` method. All it does is perform a search on
    the `entry.test_string` with the `entry.pattern`. If the resulting `match` object
    is not `None`, it means that we found something. If so, we return a tuple with
    three elements: the overall group, the subgroups, and the group dictionary.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`_parse_entry`方法。它所做的就是对`entry.test_string`和`entry.pattern`进行搜索。如果结果的`match`对象不是`None`，那么意味着我们找到了一些东西。如果是这样，我们返回一个包含三个元素的元组：总体组、子组和组字典。
- en: Notice that `match.groups()` and `match.groupdict()` might return respectively
    an empty tuple and an empty dict. In order to normalize empty results to a simpler `None`,
    I use a common pattern in Python by exploiting the `or` operator. `A or B`, in
    fact, will return `A` if `A` evaluates to a truthy value, or `B` otherwise. Can
    you think how this might differ from the behavior of the `and` operator?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`match.groups()`和`match.groupdict()`可能分别返回一个空元组和一个空字典。为了将空结果规范化为更简单的`None`，我使用了Python中的一个常见模式，即利用`or`运算符。实际上，`A
    or B`将返回`A`，如果`A`评估为真值，否则返回`B`。你能想到这与`and`运算符的行为有何不同吗？
- en: If you're not familiar with those terms, don't worry, you'll see a screenshot
    soon with an example. We return `None` if there is no match (which technically
    is not needed, as Python would do that anyway, but I have included it here for
    the sake of being explicit).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些术语不熟悉，不用担心，你很快就会看到一个例子的截图。如果没有匹配，我们返回`None`（从技术上讲，这并不需要，因为Python会自动执行，但我在这里包含它是为了明确起见）。
- en: The form view
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单视图
- en: 'Finally, let''s examine `EntryFormView`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看一下`EntryFormView`：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is particularly interesting for a few reasons. First, it shows us a nice
    example of Python's multiple inheritance. We want to display a message on the
    page, after having inserted an `Entry`, so we inherit from `SuccessMessageMixin`.
    But we want to handle a form as well, so we also inherit from `FormView`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这对几个原因来说特别有趣。首先，它向我们展示了Python的多重继承的一个很好的例子。我们想在插入`Entry`后在页面上显示一条消息，所以我们继承自`SuccessMessageMixin`。但是我们也想处理一个表单，所以我们还继承自`FormView`。
- en: Note that, when you deal with mixins and inheritance, you may have to consider
    the order in which you specify the base classes in the class declaration, as it
    will affect how methods are found when going up the inheritance chain to serve
    a call.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当处理混合和继承时，您可能需要考虑在类声明中指定基类的顺序，因为这将影响在继承链上传递调用时方法的查找方式。
- en: 'In order to set up this view correctly, we need to specify a few attributes
    at the beginning: the template to be rendered, the form class to be used to handle
    the data from the `POST` request, the URL we need to redirect the user to in the
    case of success, and the success message.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确设置这个视图，我们需要在开始时指定一些属性：要呈现的模板、用于处理来自`POST`请求的数据的表单类、在成功时需要将用户重定向到的URL以及成功消息。
- en: Another interesting feature is that this view needs to handle both `GET` and
    `POST` requests. When we land on the form page for the first time, the form is
    empty, and that is the `GET` request. On the other hand, when we fill in the form
    and want to submit the `Entry`, we make a `POST` request. You can see that the
    body of `get` is conceptually identical to `HomeView`. Django does everything
    for us.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的特点是，这个视图需要处理`GET`和`POST`请求。当我们第一次进入表单页面时，表单是空的，这是`GET`请求。另一方面，当我们填写表单并想要提交`Entry`时，我们会发出`POST`请求。你可以看到`get`的主体在概念上与`HomeView`是相同的。Django为我们做了一切。
- en: The `post` method is just like `get`. The only reason we need to code these
    two methods is so that we can decorate them to require login.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`post`方法就像`get`一样。我们需要编写这两种方法的唯一原因是为了能够装饰它们以要求登录。'
- en: Within the Django form-handling process (in the `FormView` class), there are
    a few methods that we can override in order to customize the overall behavior.
    We need to do it with the `form_valid` method. This method will be called when
    the form validation is successful. Its purpose is to save the form so that an
    `Entry` object is created out of it, and then stored in the database.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django的表单处理过程中（在`FormView`类中），有一些方法可以重写以自定义整体行为。我们需要使用`form_valid`方法。当表单验证成功时，将调用此方法。它的目的是保存表单，以便从中创建一个`Entry`对象，然后将其存储在数据库中。
- en: The only problem is that our form is missing the user. We need to intercept
    that moment in the chain of calls and put the user information in ourselves. This
    is done by calling the `_save_with_user` method, which is very simple.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是我们的表单缺少用户。我们需要在调用链的某个时刻拦截并自己放入用户信息。这是通过调用`_save_with_user`方法来完成的，非常简单。
- en: First, we ask Django to save the form with the `commit` argument set to `False`.
    This creates an `Entry` instance without attempting to save it to the database.
    Saving it immediately would fail because the `user` information is not there.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要求Django使用`commit`参数设置为`False`保存表单。这将创建一个`Entry`实例，而不会尝试将其保存到数据库中。立即保存它会失败，因为`user`信息不在那里。
- en: The next line updates the `Entry` instance (`self.object`), adding the `user`
    information and, on the last line, we can safely save it. The reason I called `object`
    and set it on the instance like that was to follow what the original `FormView`
    class does.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行更新了`Entry`实例（`self.object`），添加了`user`信息，并且在最后一行，我们可以安全地保存它。我之所以这样调用`object`并将其设置在实例上，是为了遵循原始的`FormView`类的做法。
- en: We're fiddling with the Django mechanism here, so if we want the whole thing
    to work, we need to pay attention to when and how we modify its behavior, and
    make sure we don't alter it incorrectly. For this reason, it's very important
    to remember to call the `form_valid` method of the base class (we use `super`
    for that) at the end of our own customized version, to make sure that every other
    action that method usually performs is carried out correctly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里玩弄Django的机制，因此如果我们希望整个事情能够正常工作，我们需要注意何时以及如何修改它的行为，并确保我们不会错误地改变它。因此，非常重要的是要记住在我们自定义的版本的最后调用基类的`form_valid`方法（我们使用`super`来实现），以确保该方法通常执行的所有其他操作都能正确执行。
- en: Note how the request is tied to each view instance (`self.request`) so that
    we don't need to pass it through when we refactor our logic into methods. Note
    also that the user information has been added to the request automatically by
    Django. Finally, the reason why all the process is split into very small methods
    like these is so that we can only override those that we need to customize. All
    this removes the need to write a lot of code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，请求与每个视图实例（`self.request`）相关联，因此当我们将我们的逻辑重构为方法时，我们不需要通过它传递。还要注意，用户信息已经被Django自动添加到请求中。最后，将整个过程分成非常小的方法的原因是，这样我们只需要覆盖我们需要自定义的方法。所有这些都消除了编写大量代码的需要。
- en: Now that we have the views covered, let's see how we couple them to the URLs.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了视图，让我们看看如何将它们与URL配对。
- en: Tying up URLs and views
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定URL和视图
- en: 'In the `urls.py` module, we tie each view to a URL. There are many ways of
    doing this. I chose the simplest one, which works perfectly for the extent of
    this exercise, but you may want to explore this subject more deeply if you intend
    to work with Django. This is the core around which the whole website logic will
    revolve; therefore, you should try to get it down correctly. Note that the `urls.py`
    module belongs to the project folder:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`urls.py`模块中，我们将每个视图与一个URL绑定。有许多方法可以做到这一点。我选择了最简单的方法，这对于这个练习的范围来说完全有效，但如果你打算使用Django，你可能需要更深入地探索这个主题。这是整个网站逻辑的核心，因此你应该努力正确地理解它。请注意，`urls.py`模块属于项目文件夹：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you are familiar with version 1 of Django, you will notice some differences
    here, as this project is coded in version 2.As you can see, the magic comes from
    the `path` function, which has recently replaced the `url` function. First, we
    pass it a path string (also known as a *route*), then the view, and finally a
    name, which is what we will use in the `reverse` and `reverse_lazy` functions
    to recover the URL.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉Django的1.x版本，你会注意到一些区别，因为这个项目是在2.x版本中编写的。正如你所看到的，这种魔法来自`path`函数，它最近取代了`url`函数。首先，我们传递一个路径字符串（也称为*路由*），然后是视图，最后是一个名称，这是我们将在`reverse`和`reverse_lazy`函数中使用的，以恢复URL。
- en: Note that, when using class-based views, we have to transform them into functions,
    which is what `path` is expecting. To do that, we call the `as_view()` method
    on them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当使用基于类的视图时，我们必须将它们转换为函数，这是`path`所期望的。为此，我们在它们上调用`as_view()`方法。
- en: Note also that the first `path` entry, for the admin, is special. Instead of
    specifying a URL and a view, it specifies a URL prefix and another `urls.py` module
    (from the `admin.site` package). In this way, Django will complete all the URLs
    for the admin section by prepending `'admin/'` to all the URLs specified in `admin.site.urls`.
    We could have done the same for our entries application (and we should have),
    but I feel it would have been a bit of overkill for this simple project.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，对于管理员的第一个`path`条目是特殊的。它不是指定一个URL和一个视图，而是指定一个URL前缀和另一个`urls.py`模块（来自`admin.site`包）。这样，Django将通过在所有在`admin.site.urls`中指定的URL前面添加`'admin/'`来完成管理员部分的所有URL。我们本可以对我们的entries应用程序做同样的事情（而且我们应该这样做），但我觉得对于这个简单的项目来说有点过度了。
- en: The URL paths defined in this module are so simple that they don't require any
    regular expression to be defined. Should you need to use a regular expression,
    you can check out the `re_path` function, which is designed for that purpose.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模块中定义的URL路径是如此简单，以至于不需要定义任何正则表达式。如果你需要使用正则表达式，你可以查看`re_path`函数，它就是为此目的而设计的。
- en: We also include login and logout functionalities, by employing views that come
    straight out of the `django.contrib.auth` package. We enrich the declaration with
    the necessary information (such as the next page, for the logout view, for example)
    and we don't need to write a single line of code to handle authentication. This
    is brilliant and saves us a lot of time.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过使用直接来自`django.contrib.auth`包的视图，包括登录和注销功能。我们用必要的信息（例如注销视图的下一页）丰富了声明，而且我们不需要编写任何处理身份验证的代码。这很棒，节省了我们很多时间。
- en: Each `path` declaration must be done within the `urlpatterns` list and on this
    matter, it's important to consider that, when Django is trying to find a view
    for a URL that has been requested, the patterns are exercised in order, from top
    to bottom. The first one that matches is the one that will provide the view for
    it so, in general, you have to put specific patterns before generic ones, otherwise
    they will never get a chance to be caught. To show you an example that uses regular
    expressions in the route declaration, `'^shop/categories/$'` needs to come before
    `'^shop'` (notice that the `'$'` signals the end of the pattern, and it is not
    specified in the latter), otherwise it would never be called.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`path`声明必须在`urlpatterns`列表中完成，在这个问题上，重要的是要考虑到，当Django试图为已请求的URL找到一个视图时，模式是按顺序从上到下进行的。第一个匹配的模式将为其提供视图，因此一般来说，你必须在通用模式之前放置特定模式，否则它们永远不会有机会被捕获。举个例子，使用正则表达式在路由声明中，`'^shop/categories/$'`需要放在`'^shop'`之前（注意`'$'`表示模式的结尾，在后者中没有指定），否则它永远不会被调用。
- en: So, models, forms, admin, views, and URLs are all done. All that's left is to
    take care of the templates. I'll have to be very brief on this part because HTML
    can be very verbose.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模型、表单、管理员、视图和URL都已完成。剩下的就是处理模板。我必须在这部分非常简要，因为HTML可能非常冗长。
- en: Writing the templates
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写模板
- en: 'All templates inherit from a base one, which provides the HTML structure for
    all others, in a very **object-oriented programming** (**OOP**) fashion. It also
    specifies a few blocks, which are areas that can be overridden by children so
    that they can provide custom content for those areas. Let''s start with the base
    template:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模板都继承自一个基本模板，它为所有其他模板提供HTML结构，以一种非常面向对象的编程（OOP）方式。它还指定了一些块，这些块是可以被子模板覆盖的区域，以便它们可以为这些区域提供自定义内容。让我们从基本模板开始：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There is a good reason to repeat the `entries` folder from the `templates` one.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从`templates`中的`entries`文件夹重复`entries`文件夹有一个很好的理由。
- en: When you deploy a Django website, you collect all the template files under one
    folder. If you don't specify the paths like I did, you may get a `base.html` template
    in the entries application, and a `base.html` template in another app. The last
    one to be collected will override any other file with the same name. For this
    reason, by putting them in a `templates/entries` folder and using this technique
    for each Django application you write, you avoid the risk of name collisions (the
    same goes for any other static file).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当您部署Django网站时，您需要将所有模板文件收集到一个文件夹下。如果您不像我一样指定路径，您可能会在entries应用程序中得到一个`base.html`模板，在另一个应用程序中得到一个`base.html`模板。最后收集的文件将覆盖同名的任何其他文件。因此，通过将它们放在`templates/entries`文件夹中，并对每个您编写的Django应用程序使用这种技术，您可以避免名称冲突的风险（对于任何其他静态文件也是如此）。
- en: There is not much to say about this template, really, apart from the fact that
    it loads the `static` tag so that we can get easy access to the `static` path
    without hardcoding it in the template using `{% static ... %}`. The code in the
    special `{% ... %}` sections is code that defines logic. The code in the special
    `{{ ... }}` represents variables that will be rendered on the page.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个模板，实际上没有什么可说的，除了它加载了`static`标签，以便我们可以轻松访问`static`路径，而不需要在模板中硬编码使用`{% static
    ... %}`。特殊的`{% ... %}`部分中的代码定义了逻辑。特殊的`{{ ... }}`中的代码表示将在页面上呈现的变量。
- en: We define five blocks: `styles`, `meta`, `title`, `page-content`, and `footer`,
    whose purpose is to hold the metadata, style information, title, the content of
    the page, and the footer, respectively. Blocks can be optionally overridden by
    child templates in order to provide different content within them.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了五个块：`styles`，`meta`，`title`，`page-content`和`footer`，它们的目的是保存元数据，样式信息，标题，页面内容和页脚。块可以选择性地被子模板覆盖，以便在其中提供不同的内容。
- en: 'Here''s the footer:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是页脚：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It gives us a nice link to the home page, which comes from the following template:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 它为我们提供了一个指向主页的链接，这个链接来自以下模板：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It extends the `base.html` template, and overrides `title` and `page-content`.
    You can see that basically all it does is provide four links to the user. These
    are the list of entries, the insert page, the logout page, and the admin page.
    All of this is done without hardcoding a single URL, through the use of the `{%
    url ... %}` tag, which is the template equivalent of the `reverse` function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它扩展了`base.html`模板，并覆盖了`title`和`page-content`。您可以看到它基本上只是为用户提供了四个链接。这些是条目列表，插入页面，注销页面和管理页面。所有这些都是在不硬编码任何URL的情况下完成的，通过使用`{%
    url ... %}`标签，这是`reverse`函数的模板等效。
- en: 'The template for inserting `Entry` is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 插入`Entry`的模板如下：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There is some conditional logic at the beginning to display messages, if any,
    and then we define the form. Django gives us the ability to render a form by simply
    calling `{{ form.as_p }}` (alternatively, `form.as_ul` or `form.as_table`). This
    creates all the necessary fields and labels for us. The difference between the
    three commands is in the way the form is laid out: as a paragraph, as an unordered
    list, or as a table. We only need to wrap it in form tags and add a submit button.
    This behavior was designed for our convenience: we need the freedom to shape that
    `<form>` tag as we want, so Django isn''t intrusive on that. Also, note that `{%
    csrf_token %}`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时有一些条件逻辑来显示消息（如果有的话），然后我们定义表单。Django让我们能够通过简单调用`{{ form.as_p }}`（或者`form.as_ul`或`form.as_table`）来呈现一个表单。这为我们创建了所有必要的字段和标签。这三个命令之间的区别在于表单的布局方式：作为段落，作为无序列表或作为表格。我们只需要将其包装在表单标签中并添加一个提交按钮。这种行为是为了我们的方便而设计的：我们需要自由地塑造`<form>`标签，所以Django在这方面并不具有侵入性。另外，请注意`{%
    csrf_token %}`。
- en: It will be rendered into a token by Django and will become part of the data
    sent to the server on submission. This way, Django will be able to verify that
    the request was from an allowed source, thus avoiding the aforementioned CSRF
    issue. Did you see how we handled the token when we wrote the view for the `Entry`
    insertion? Exactly. We didn't write a single line of code for it. Django takes
    care of it automatically thanks to a **middleware** class (`CsrfViewMiddleware`).
    Please refer to the official Django documentation ([https://docs.djangoproject.com/en/2.0/](https://docs.djangoproject.com/en/2.0/))
    to explore this subject further.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 它将被Django渲染为一个令牌，并成为提交时发送到服务器的数据的一部分。这样，Django将能够验证请求是否来自允许的来源，从而避免前面提到的CSRF问题。当我们为`Entry`插入编写视图时，您是否看到了我们如何处理令牌？没错。我们没有为此编写一行代码。Django会自动处理它，这要归功于一个**中间件**类（`CsrfViewMiddleware`）。请参阅官方Django文档（[https://docs.djangoproject.com/en/2.0/](https://docs.djangoproject.com/en/2.0/)）以进一步探讨这个主题。
- en: 'For this page, we also use the footer block to display a link to the home page.
    Finally, we have the list template, which is the most interesting one:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个页面，我们还使用页脚块来显示指向主页的链接。最后，我们有列表模板，这是最有趣的一个：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It may take you a while to get used to the template language, but really, all
    there is to it is the creation of a table using a `for` loop. We start by checking
    whether there are any entries and, if so, we create a table. There are two columns,
    one for `Entry`, and the other for the match.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要一段时间来适应模板语言，但实际上，它只是使用`for`循环创建表格。我们首先检查是否有任何条目，如果有，我们创建一个表格。有两列，一列是`Entry`，另一列是匹配。
- en: In the `Entry` column, we display the `Entry` object (apart from the user),
    and in the `Matches` column, we display that three-tuple we created in the `EntryListView`.
    Note that to access the attributes of an object, we use the same dot syntax we
    use in Python, for example `{{ entry.pattern }}` or `{{ entry.test_string }}`,
    and so on.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Entry`列中，我们显示`Entry`对象（除了用户），在`Matches`列中，我们显示在`EntryListView`中创建的三元组。请注意，要访问对象的属性，我们使用与Python中相同的点语法，例如`{{
    entry.pattern }}`或`{{ entry.test_string }}`等。
- en: When dealing with lists and tuples, we cannot access items using the square
    brackets syntax, so we use the dot one as well (`{{ match.0 }}` is equivalent
    to `match[0]`, and so on). We also use a filter, through the pipe (`|`) operator
    to display a custom value if a match is `None`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理列表和元组时，我们不能使用方括号语法访问项目，因此我们也使用点语法（`{{ match.0 }}`相当于`match[0]`，依此类推）。我们还使用过滤器，通过管道（`|`）运算符来显示一个自定义值，如果匹配为`None`。
- en: The Django template language (which is not properly Python) is kept simple for
    a precise reason. If you find yourself limited by the language, it means you're
    probably trying to do something in the template that should actually be done in
    the view, where that logic is more pertinent.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Django模板语言（它并不是真正的Python）之所以保持简单，是有一个明确的原因的。如果你发现自己受到语言的限制，那意味着你可能正在尝试在模板中做一些实际上应该在视图中完成的事情，那里的逻辑更相关。
- en: 'Allow me to show you a couple of screenshots of the *list* and *insert* templates.
    This is what the list of entries looks like for my father:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我向你展示一些*列表*和*插入*模板的屏幕截图。这是我父亲的条目列表的样子：
- en: '![](../images/00029.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00029.jpeg)'
- en: Note how the use of the cycle tag alternates the background color of the rows
    from white to light gray. Those classes are defined in the `main.css` file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用循环标签交替将行的背景颜色从白色变为浅灰色。这些类在`main.css`文件中定义。
- en: The `Entry` insertion page is smart enough to provide a few different scenarios.
    When you land on it at first, it presents you with just an empty form. If you
    fill it in correctly, it will display a nice message for you (see the following
    picture). However, if you fail to fill in both fields, it will display an error
    message before them, alerting you that those fields are required.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entry`插入页面足够智能，可以提供几种不同的场景。当你第一次登陆时，它会向你展示一个空表单。如果你正确填写了它，它会为你显示一个漂亮的消息（见下图）。然而，如果你未能填写两个字段，它将在它们之前显示一个错误消息，提醒你这些字段是必填的。'
- en: 'Note also the custom footer, which includes both a link to the entries list
    and a link to the home page:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意自定义页脚，其中包括指向条目列表和主页的链接：
- en: '![](../images/00030.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00030.jpeg)'
- en: And that's it! You can play around with the CSS styles if you want. Download
    the code for the book and have fun exploring and extending this project. Add something
    else to the model, create and apply a migration, play with the templates, there's
    lots to do!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！如果你愿意，你可以玩弄CSS样式。下载这本书的代码，尽情探索和扩展这个项目。向模型添加其他内容，创建并应用迁移，玩弄模板，有很多事情要做！
- en: Django is a very powerful framework, and offers so much more than what I've
    been able to show you in this chapter, so you should definitely check it out.
    The beauty of it is that Django is Python, so reading its source code is a very
    useful exercise.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Django是一个非常强大的框架，提供的功能远远超出了我在本章中能够向你展示的内容，所以你绝对应该去了解一下。它的美妙之处在于Django是Python，因此阅读其源代码是非常有用的练习。
- en: The future of web development
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web开发的未来
- en: Computer science is a very young subject, compared to other branches of science
    that have existed alongside humankind for centuries. One of its main characteristics
    is that it moves extremely fast. It leaps forward with such speed that, in just
    a few years, you can see changes that are comparable to real-world changes that
    took a century to happen. Therefore, as a coder, you must pay attention to what
    happens in this world, all the time.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与人类共存数个世纪的其他科学分支相比，计算机科学是一个非常年轻的学科。它的主要特点之一是发展极快。它以如此之快的速度前进，以至于在短短几年内，你可以看到与需要一个世纪才会发生的现实世界变化相媲美的变化。因此，作为一个编码者，你必须时刻关注这个世界发生的事情。
- en: Currently, because powerful computers are quite cheap and almost everyone has
    access to them, the trend is to try to avoid putting too much workload on the
    backend, and let the frontend handle part of it. Therefore, in the last few years,
    JavaScript frameworks and libraries, such as jQuery, Backbone and, more recently,
    React, have become very popular. Web development has shifted from a paradigm where
    the backend takes care of handling data, preparing it, and serving it to the frontend
    to display it, to a paradigm where the backend is sometimes just used as an API,
    a sheer data provider. The frontend fetches the data from the backend with an
    API call, and then it takes care of the rest. This shift facilitates the existence
    of paradigms such as **Single-Page Application** (**SPA**), where, ideally, the
    whole page is loaded once and then evolves, based on the content that usually
    comes from the backend. E-commerce websites that load the results of a search
    in a page that doesn't refresh the surrounding structure are made with similar
    techniques. Browsers can perform asynchronous calls such as **Asynchronous JavaScript
    and XML** (**AJAX**) that can return data that can be read, manipulated, and injected
    back into the page with JavaScript code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，由于强大的计算机相当便宜，几乎每个人都可以接触到，趋势是尽量避免在后端投入过多的工作量，让前端处理部分工作。因此，在过去几年中，JavaScript框架和库，如jQuery，Backbone，以及最近变得非常流行的React，已经变得非常流行。Web开发已经从后端负责处理数据、准备数据并提供给前端显示的范式转变为后端有时仅用作API，纯粹的数据提供者。前端通过API调用从后端获取数据，然后处理其余部分。这种转变促进了**单页应用程序**（**SPA**）等范式的存在，理想情况下，整个页面只加载一次，然后根据通常来自后端的内容进行演变。使用类似技术的电子商务网站在不刷新周围结构的页面中加载搜索结果。浏览器可以执行异步调用，如**异步JavaScript和XML**（**AJAX**），可以返回数据，该数据可以通过JavaScript代码读取、操作并注入回页面。
- en: 'So, if you''re planning to work on web development, I strongly suggest you
    to get acquainted with JavaScript (if you''re not already), and also with APIs.
    In the last few pages of this chapter, I''ll give you an example of how to make
    a simple API using two different Python microframeworks: Flask and Falcon.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您计划从事Web开发，我强烈建议您熟悉JavaScript（如果您还没有），以及API。在本章的最后几页，我将为您演示如何使用两种不同的Python微框架（Flask和Falcon）制作一个简单的API的示例。
- en: Writing a Flask view
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个Flask视图
- en: 'Flask ([http://flask.pocoo.org/](http://flask.pocoo.org/)) is a Python microframework.
    It provides far fewer features than Django, but if your project is meant to be
    very small, then it might be a better choice. In my experience though, when developers
    choose Flask at the beginning of a project, they eventually end up adding plugin
    after plugin, until they have what I call a Django Frankenstein project. Being
    agile means having periodically to spend time reducing the technical debt accumulated
    over time. However, switching from Flask to Django can be a daunting operation,
    so when starting a new project, make sure you consider its evolution. My cheeky
    opinion on this matter is very simple: I always go with Django, as I personally
    prefer it to Flask, but you might disagree with me, so I want to offer you an
    example.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Flask（[http://flask.pocoo.org/](http://flask.pocoo.org/)）是一个Python微框架。它提供的功能远不及Django，但如果您的项目非常小，那么它可能是一个更好的选择。不过，根据我的经验，当开发人员在项目开始时选择Flask时，他们最终会不断添加插件，直到拥有我所说的Django
    Frankenstein项目。灵活意味着不时地花时间减少随时间积累的技术债务。但是，从Flask切换到Django可能是一个令人生畏的操作，因此在启动新项目时，请确保考虑其发展。我对这个问题的俏皮看法非常简单：我总是选择Django，因为我个人更喜欢它而不是Flask，但您可能不同意我的看法，因此我想为您提供一个例子。
- en: 'In your `ch14` folder, create a `flask` folder with the following structure:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`ch14`文件夹中，创建一个`flask`文件夹，其结构如下：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Basically, we''re going to code two simple files: a Flask application and an
    HTML template. Flask uses Jinja2 as a template engine. It''s extremely popular
    and very fast, to the point that even Django started offering native support for
    it:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们将编写两个简单的文件：一个Flask应用程序和一个HTML模板。Flask使用Jinja2作为模板引擎。它非常受欢迎且非常快速，以至于即使Django也开始为其提供原生支持：
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The template is almost offensively simple. All it does is change the greeting
    according to the presence of the `name` variable. A bit more interesting is the
    Flask application that renders it:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 模板几乎是令人反感地简单。它只是根据`name`变量的存在改变问候语。更有趣的是渲染它的Flask应用程序：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We create an `app` object, which is a Flask application. We only feed the fully
    qualified name of the module, which is stored in `__name__`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`app`对象，它是一个Flask应用程序。我们只需提供模块的完全限定名称，该名称存储在`__name__`中。
- en: Then, we write a simple `hello` view, which takes an optional `name` argument.
    In the body of the view, we simply render the `main.html` template, passing to
    it the `name` argument, regardless of its value.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们编写一个简单的`hello`视图，它接受一个可选的`name`参数。在视图的主体中，我们只是渲染`main.html`模板，并将`name`参数传递给它，而不管其值如何。
- en: 'What''s interesting is the routing. Differently from Django''s way of tying
    up views and URLs (the `urls.py` module), in `Flask` you decorate your views with
    one or more `@app.route` decorators. In this case, we decorate twice: the first
    line ties the view to the root URL (`/`), while the second line ties the view
    to the root URL with a name information (`/<name>`).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是路由。与Django将视图和URL绑定在一起的方式不同（`urls.py`模块），在`Flask`中，您可以使用一个或多个`@app.route`装饰器来装饰您的视图。在这种情况下，我们装饰两次：第一行将视图绑定到根URL（`/`），而第二行将视图绑定到具有名称信息的根URL（`/<name>`）。
- en: 'Change into the `flask` folder and type (make sure you have either installed
    Flask with `$ pip install flask` or by installing the requirements in the source
    code for the book):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到`flask`文件夹并输入（确保您已经使用`$ pip install flask`安装了Flask，或者通过安装书籍源代码中的要求）：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can open a browser and go to `http://127.0.0.1:5000/`. This URL has no name
    information; therefore, you will see Hello shy person! It is written all nice
    and big. Try to add something to that URL, such as `http://127.0.0.1:5000/Milena`.
    Hit *Enter* and the page will change to Hello Milena! (so you will have said hello
    to my sister).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以打开浏览器并转到`http://127.0.0.1:5000/`。此URL没有名称信息；因此，您将看到“Hello shy person！”它写得很好很大。尝试在该URL中添加一些内容，例如`http://127.0.0.1:5000/Milena`。按*Enter*，页面将更改为Hello
    Milena！（这样您就向我的妹妹打招呼了）。
- en: Of course, Flask offers you much more than this, but we don't have the room
    to go through a more complex example. It's definitely worth exploring, though.
    Several projects use it successfully and it's fun and nice to create websites
    or APIs with it. Flask's author, Armin Ronacher, is a successful and very prolific
    coder. He also created or collaborated on several other interesting projects,
    such as Werkzeug, Jinja2, Click, and Sphinx. He also contributed functionalities
    to the Python AST module.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Flask为您提供的远不止这些，但我们没有足够的空间来介绍更复杂的示例。不过，它绝对值得探索。许多项目都成功使用它，使用它创建网站或API非常有趣和愉快。Flask的作者Armin
    Ronacher是一位成功且非常多产的程序员。他还创建或参与了其他几个有趣的项目，如Werkzeug、Jinja2、Click和Sphinx。他还为Python
    AST模块贡献了功能。
- en: Building a JSON quote server in Falcon
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Falcon中构建JSON引用服务器
- en: Falcon ([http://falconframework.org/](http://falconframework.org/)) is another
    microframework written in Python, which was designed to be light, fast, and flexible.
    I have seen this relatively young project evolve to become something really popular
    due to its speed, which is impressive, so I'm happy to show you a tiny example
    using it. We're going to build an API that returns a random quote from the Buddha.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Falcon（[http://falconframework.org/](http://falconframework.org/)）是另一个用Python编写的微框架，旨在轻巧、快速和灵活。我看到这个相对年轻的项目发展成为真正受欢迎的东西，因为它的速度令人印象深刻，所以我很高兴向您展示一个使用它的小例子。我们将构建一个API，从佛陀那里返回一个随机引用。
- en: 'In your `ch14` folder, create a new one called `falcon`. We''ll have two files:
    `quotes.py` and `main.py`. To run this example, install Falcon and Gunicorn (`$
    pip install falcon gunicorn` or the full requirements for the book). Falcon is
    the framework, and **Gunicorn** (**Green Unicorn**) is a Python WSGI HTTP Server
    for Unix (which, in layman''s terms, means the technology that is used to run
    the server).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`ch14`文件夹中，创建一个名为`falcon`的新文件夹。我们将有两个文件：`quotes.py`和`main.py`。要运行此示例，请安装Falcon和Gunicorn（`$
    pip install falcon gunicorn`或书中的完整要求）。Falcon是框架，**Gunicorn**（**Green Unicorn**）是用于Unix的Python
    WSGI HTTP服务器（通俗地说，这是用于运行服务器的技术）。
- en: The Web Server Gateway Interface (WSGI) is a simple calling convention for web
    servers to forward requests to web applications or frameworks written in Python.
    If you wish to learn more, please checkout [PEP333](https://www.python.org/dev/peps/pep-0333/),
    which defines the interface.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器网关接口（WSGI）是一个简单的调用约定，用于将请求转发给用Python编写的Web应用程序或框架。如果您想了解更多，请查看[PEP333](https://www.python.org/dev/peps/pep-0333/)，该页面定义了接口。
- en: 'When you''re all set up, start by creating the `quotes.py` file:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备好后，首先创建`quotes.py`文件：
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You will find the complete list of quotes in the source code for this book.
    If you don't have it, you can instead fill in your favorite quotes. Note that
    not every line has a comma at the end. In Python, it's possible to concatenate
    strings like that, as long as they are in brackets (or braces). It's called **implicit
    concatenation**.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在本书的源代码中找到完整的引用列表。如果您没有，您可以填写您喜欢的引用。请注意，并非每一行都在末尾有逗号。在Python中，可以这样连接字符串，只要它们在括号（或大括号）中。这被称为**隐式连接**。
- en: 'The code for the main application is not long, but it is interesting:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 主应用程序的代码并不长，但很有趣：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let's start with the class. In Django we had a `get` method, in Flask we defined
    a function, and here we write an `on_get` method, a naming style that reminds
    me of Java/C# event handlers. It takes a request and a response argument, both
    automatically fed by the framework. In its body, we define a dictionary with a
    randomly chosen quote, and the author information. Then we dump that dictionary
    to a JSON string and set the response body to its value. We don't need to return
    anything, Falcon will take care of it for us.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从类开始。在Django中，我们有一个`get`方法，在Flask中我们定义了一个函数，在这里我们编写了一个`on_get`方法，这种命名风格让我想起了Java/C#事件处理程序。它接受一个请求和一个响应参数，两者都由框架自动提供。在其主体中，我们定义了一个包含随机选择的引用和作者信息的字典。然后我们将该字典转储为JSON字符串，并将响应主体设置为其值。我们不需要返回任何东西，Falcon会为我们处理。
- en: At the end of the file, we create the Falcon application, and we call `add_route`
    on it to tie the handler we have just written to the URL we want.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件末尾，我们创建了Falcon应用程序，并在其上调用`add_route`，将我们刚刚编写的处理程序绑定到我们想要的URL。
- en: 'When you''re all set up, change to the `falcon` folder and type:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备好后，切换到`falcon`文件夹并输入：
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, make a request (or simply open the page with your browser) to `http://127.0.0.1:8000/quote`.
    When I did it, I got this JSON in response:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，发出请求（或者简单地用浏览器打开页面）到`http://127.0.0.1:8000/quote`。当我这样做时，我得到了这个JSON作为响应：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Within the `falcon` folder, I have left a `stress.py` module for you, which
    tests how fast our Falcon code is. See if you can make it work by yourself, it
    should be very easy for you at this point.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在`falcon`文件夹中，我留下了一个名为`stress.py`的模块，用于测试我们的Falcon代码的速度。看看您是否可以自己使其工作，对您来说应该很容易。
- en: Whatever framework you end up using for your web development, try to keep yourself
    informed about other choices too. Sometimes you may be in situations where a different
    framework is the right way to go, and having a working knowledge of different
    tools will give you an advantage.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您最终选择哪个框架进行Web开发，都要尽量了解其他选择。有时候您可能会处于需要选择不同框架的情况，了解不同工具的工作原理将给您带来优势。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a look at web development. We talked about important
    concepts, such as the DRY philosophy and the concept of a framework as a tool
    that provides us with many things we need in order to write code to serve requests.
    We also talked about the MTV pattern, and how nicely these three layers play together
    to realize a request-response path.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一下Web开发。我们谈到了重要的概念，比如DRY哲学和框架的概念，框架作为一个工具，为我们提供了许多编写代码以响应请求所需的东西。我们还谈到了MTV模式，以及这三个层如何很好地协同工作来实现请求-响应路径。
- en: Then, we briefly introduced regular expressions, which is a subject of paramount
    importance, and it's the layer that provides the tools for URL routing.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们简要介绍了正则表达式，这是一个非常重要的主题，它是提供URL路由工具的层。
- en: There are many different frameworks out there, and Django is definitely one
    of the best and most widely used, so it's worth exploring, especially its source
    code, which is well written.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的框架，Django绝对是最好和最广泛使用的之一，因此值得探索，特别是其源代码，写得很好。
- en: There are other very interesting and important frameworks too, such as Flask.
    They provide fewer features but might be faster, both in execution time and to
    set up. One that is extremely fast is the Falcon project, whose benchmarks are
    outstanding.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他非常有趣和重要的框架，比如Flask。它们提供的功能较少，但可能更快，无论是执行时间还是设置时间。一个非常快速的框架是Falcon项目，其基准测试非常出色。
- en: It's important to get a solid understanding of how the request-response mechanism
    works, and how the web in general works, so that eventually it won't matter too
    much which framework you have to use. You will be able to pick it up quickly because
    it will only be a matter of getting familiar with a way of doing something you
    already know a lot about.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要对请求-响应机制以及Web的工作原理有扎实的理解，这样最终您将不会太在意必须使用哪个框架。您将能够快速掌握它，因为这只是熟悉已经了解很多的某种做事方式的问题。
- en: Explore at least three frameworks and try to come up with different use cases
    to decide which one of them could be the ideal choice. When you are able to make
    that choice, you will know you have a good enough understanding of them.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 至少探索三种框架，并尝试提出不同的用例来决定它们中哪一个可能是理想的选择。当你能够做出选择时，你就会知道你对它们有足够的了解。
- en: A farewell
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 告别
- en: I hope that you are still thirsty and that this book will be just the first
    of many steps you take towards Python. It's a truly wonderful language, well worth
    learning deeply.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你仍然渴望，并且这本书只是你迈向Python的第一步。这是一门非常美妙的语言，值得深入学习。
- en: I hope that you enjoyed this journey with me, I did my best to make it interesting
    for you. It sure was for me, I had such a great time writing these pages.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你喜欢和我一起的这段旅程，我尽力让它对你有趣。对我来说肯定是有趣的，我在写这些页面时度过了美好的时光。
- en: Python is open source, so please keep sharing it and consider supporting the
    wonderful community around it.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Python是开源的，所以请继续分享它，并考虑支持周围的美妙社区。
- en: Until next time, my friend, farewell!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下次再见，朋友，再见！
