- en: Creating Testable Documentation with doctest
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用doctest创建可测试的文档
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Documenting the basics
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录基础知识
- en: Catching stack traces
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获堆栈跟踪
- en: Running a doctest from the command line
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行运行doctest
- en: Coding a test harness for doctest
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为doctest编写测试工具
- en: Filtering out test noise
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤测试噪音
- en: Printing out all your documentation including a status report
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印出所有文档，包括状态报告。
- en: Testing the edges
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试边缘情况
- en: Testing corner cases by iteration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过迭代测试边缘情况
- en: Getting nosy with doctest
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用doctest进行调试
- en: Updating the project-level script to run this chapter's doctests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新项目级脚本以运行本章的doctest
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Python provides a useful ability to embed comments inside functions that are
    accessible from a Python shell. These are known as **docstrings**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一种在函数内部嵌入注释的有用能力，可以从Python shell中访问。这些被称为**文档字符串**。
- en: A docstring provides the ability to embed not only information, but also code
    samples that are runnable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串不仅提供了嵌入信息的能力，还提供了可运行的代码示例。
- en: There is an old adage that says *comments **aren't **code*. This is because
    comments don't undergo syntax checks and are often not maintained. Thus, the information
    they carry can lose its value over time. `doctest` counters this by turning comments
    into code, which can serve many useful purposes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有一句古谚说“*注释不是代码*”。这是因为注释不经过语法检查，通常不会被维护。因此，它们携带的信息随着时间的推移可能会失去其价值。`doctest`通过将注释转换为代码来解决这个问题，这可以有很多有用的用途。
- en: In this chapter, we will explore different ways to use `doctest` to develop
    testing, documentation, and project support. No special setup is required, as
    `doctest` is part of Python's standard libraries.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨使用`doctest`开发测试、文档和项目支持的不同方法。不需要特殊设置，因为`doctest`是Python标准库的一部分。
- en: Documenting the basics
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录基础知识
- en: Python provides an out-of-the-box capability to put comments in code, known
    as docstrings. Docstrings can be read when looking at the source and also when
    inspecting the code interactively from a Python shell. In this recipe, we will
    demonstrate how these interactive docstrings can be used as runnable tests.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一种在代码中放置注释的开箱即用的能力，称为文档字符串。查看源代码和从Python shell交互检查代码时，可以阅读文档字符串。在本配方中，我们将演示如何使用这些交互式文档字符串作为可运行的测试。
- en: What does this provide? It offers easy-to-read code samples for the users. Not
    only are the code samples readable, they are also runnable, meaning we can ensure
    the documentation stays up-to-date.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了什么？它为用户提供了易于阅读的代码示例。这些代码示例不仅易于阅读，而且可以运行，这意味着我们可以确保文档保持最新。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With the following steps, we will create an application combined with runnable
    docstring comments, and see how to execute these tests:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，我们将创建一个应用程序，其中包含可运行的文档字符串注释，并看看如何执行这些测试：
- en: Create a new file named `recipe16.py` to put all the code we write for this
    recipe.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe16.py`的新文件，以放置我们为此配方编写的所有代码。
- en: 'Create a function that converts base-10 numbers to any other base using recursion:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，使用递归将十进制数转换为任何其他进制：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add a docstring just below the external function, as shown in the highlighted
    section of the following code. This docstring declaration includes several examples
    of using the function:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在外部函数的下面添加一个文档字符串，如下面代码的突出部分所示。这个文档字符串声明包括使用该函数的几个示例：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add a test runner block that invokes Python''s `doctest` module:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个测试运行器块，调用Python的`doctest`模块：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'From an interactive Python shell, import the recipe and view its documentation.
    Take a look at this screenshot:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从交互式Python shell导入配方并查看其文档。看看这个截图：
- en: '![](../images/00036.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00036.jpeg)'
- en: 'Run the code from the command line. In the following screenshot, notice how
    nothing is printed. This is what happens when all the tests pass. Look at this
    screenshot:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行运行代码。在下面的截图中，请注意没有任何内容被打印出来。这就是当所有测试都通过时会发生的情况。看看这个截图：
- en: '![](../images/00037.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00037.jpeg)'
- en: 'Run the code from the command line with `-v` to increase verbosity. In the
    following screenshot, we see a piece of the output, showing what was run and what
    was expected. This can be useful when debugging `doctest`:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行运行代码，使用`-v`增加详细程度。在下面的截图中，我们看到了一部分输出，显示了运行的内容和预期的内容。在调试`doctest`时，这可能很有用：
- en: '![](../images/00038.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00038.jpeg)'
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `doctest` module looks for blocks of Python inside docstrings and runs it
    like real code. `>>>` is the same prompt we see when we use the interactive Python
    shell. The line following `>>>` shows the expected output. `doctest` runs the
    statements it sees and then compares the actual output with the expected output.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`模块查找文档字符串中的Python代码块，并像真正的代码一样运行它。`>>>`是我们在使用交互式Python shell时看到的相同提示。`>>>`后面的行显示了预期的输出。`doctest`运行它看到的语句，然后将实际输出与预期输出进行比较。'
- en: Later in this chapter, we will see how to catch things such as stack traces,
    errors, and also add extra code that equates to a test fixture.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将看到如何捕获堆栈跟踪、错误，并添加额外的代码，相当于测试装置。
- en: There's more...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`doctest` is very picky when matching expected output with actual results:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`在匹配预期输出和实际结果时非常挑剔：'
- en: An extraneous space or tab can cause things to break.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多余的空格或制表符可能会导致出现问题。
- en: Structures such as dictionaries are tricky to test, because Python doesn't guarantee
    the order of items. On each test run, the items could be stored in a different
    order. Simply printing out a dictionary is bound to break.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如字典之类的结构很难测试，因为Python不能保证项目的顺序。在每次测试运行时，项目可能以不同的顺序存储。简单地打印出一个字典肯定会出错。
- en: It is strongly advised not to include object references in expected outputs.
    These values also vary every time the test is run.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强烈建议不要在预期输出中包含对象引用。这些值每次运行测试时也会变化。
- en: Catching stack traces
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获堆栈跟踪
- en: It's a common fallacy that we should write tests only for successful code paths.
    We also need to code against error conditions including the ones that generate
    stack traces. With this recipe, we will explore how stack traces are pattern-matched
    in doc testing, which allows us to confirm expected errors.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的谬论是我们只应该为成功的代码路径编写测试。我们还需要针对包括生成堆栈跟踪的错误条件编写代码。通过这个示例，我们将探讨如何在文档测试中模式匹配堆栈跟踪，从而允许我们确认预期的错误。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With the following steps, we will see how to use `doctest` to verify error
    conditions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，我们将看到如何使用`doctest`来验证错误条件：
- en: Create a new file called `recipe17.py` for all our code in this recipe.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此示例中的所有代码创建一个名为`recipe17.py`的新文件。
- en: 'Create a function that converts base-10 numbers to any other base using recursion:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，使用递归将十进制数转换为任何其他进制：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add a docstring just below the external function declaration that includes
    two examples that are expected to generate stack traces:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在外部函数声明的下方添加一个文档字符串，其中包含两个预期生成堆栈跟踪的示例：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add a test runner block that invokes Python''s `doctest` module:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个测试运行器块，调用Python的`doctest`模块：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the code from the command line. In the following screenshot, notice how
    nothing is printed. This is what happens when all the tests pass:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行运行代码。在下面的截图中，请注意没有打印任何内容。这是当所有测试都通过时发生的情况：
- en: '![](../images/00039.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00039.jpeg)'
- en: 'Run the code from the command line with `-v` to increase verbosity. In the
    following screenshot, we can see that `0` and `-1` generate math domain errors.
    This is due to using `math.log` to find the starting exponent:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-v`从命令行运行代码以增加详细信息。在下面的截图中，我们可以看到`0`和`-1`生成了数学域错误。这是由于使用`math.log`来找到起始指数：
- en: '![](../images/00040.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00040.jpeg)'
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `doctest` module looks for blocks of Python inside docstrings and runs it
    like real code. `>>>` is the same prompt we see when we use the interactive Python
    shell. The line following `>>>` shows the expected output. `doctest` runs the
    statements it sees and then compares the actual output with the expected output.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`模块查找文档字符串中的Python代码块，并像真正的代码一样运行它。`>>>`是我们在交互式Python shell中使用时看到的相同提示。`>>>`后面的行显示了预期的输出。`doctest`运行它看到的语句，然后将实际输出与预期输出进行比较。'
- en: 'With regard to stack traces, there is a lot of detailed information provided
    in the stack trace. Pattern matching the entire trace is ineffective. By using
    the ellipsis, we are able to skip the intermediate parts of the stack trace and
    just match on the distinguishing part: `ValueError: math domain error`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '关于堆栈跟踪，堆栈跟踪提供了大量详细信息。模式匹配整个跟踪是无效的。通过使用省略号，我们能够跳过堆栈跟踪的中间部分，只匹配区分部分：`ValueError:
    math domain error`。'
- en: This is valuable, because our users will not only see the way it handles good
    values, but will also observe what errors to expect when bad values are provided.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有价值的，因为我们的用户不仅会看到它如何处理良好的值，还会观察到在提供坏值时可以期望什么错误。
- en: Running a doctest from the command line
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从命令行运行`doctest`
- en: We have seen how to develop tests by embedding runnable fragments of code in
    docstrings. But for each of these tests, we had to make the module runnable. What
    if we wanted to run something else other than our `doctest` from the command line?
    We would have to get rid of the `doctest.testmod()` statements!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何通过在文档字符串中嵌入可运行的代码片段来开发测试。但是对于这些测试中的每一个，我们都必须使模块可运行。如果我们想要从命令行运行除了我们的`doctest`之外的其他内容怎么办？我们将不得不摆脱`doctest.testmod()`语句！
- en: The good news is that, starting with Python 2.6, there is a command-line option
    to run a specific module using `doctest` without coding a runner.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，从Python 2.6开始，有一个命令行选项可以在不编写运行器的情况下运行特定模块的`doctest`。
- en: The `python -m doctest -v example.py` command will import `example.py` and run
    it through `doctest.testmod()`. According to the documentation, this may fail
    if the module is part of a package and imports other sub modules.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`python -m doctest -v example.py`命令将导入`example.py`并通过`doctest.testmod()`运行它。根据文档，如果模块是包的一部分并导入其他子模块，则可能会失败。'
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the following steps, we will create a simple application. We will add some
    doctests and then run them from the command line without writing a special test
    runner:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将创建一个简单的应用程序。我们将添加一些doctests，然后从命令行运行它们，而无需编写特殊的测试运行器：
- en: Create a new file called `recipe18.py` to store the code written for this recipe.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe18.py`的新文件，用于存储为此示例编写的代码。
- en: 'Create a function that converts base-10 numbers to any other base using recursion:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，使用递归将十进制数转换为任何其他进制：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add a docstring just below the external function declaration that includes
    some of the tests:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在外部函数声明的下方添加一个文档字符串，其中包含一些测试：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the code from the command line using `-m doctest`. As shown in the following
    screenshot, no output indicates that all the tests have passed:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-m doctest`从命令行运行代码。如下面的截图所示，没有输出表示所有测试都已通过：
- en: '![](../images/00041.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00041.jpeg)'
- en: 'Run the code from the command line with `-v` to increase verbosity. What happens
    if we forget to include `-m doctest`? Using the `-v` option helps us to avoid
    this by giving us a warm fuzzy feeling that our tests are working. Take a look
    at this screenshot:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-v`从命令行运行代码以增加详细信息。如果我们忘记包含`-m doctest`会发生什么？使用`-v`选项可以帮助我们避免这种情况，因为它给我们一种温暖的感觉，让我们知道我们的测试正在工作。看一下这个截图：
- en: '![](../images/00042.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00042.jpeg)'
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the previous chapter, we were using the `__main__` block of a module to run
    other test suites. What if we wanted to do the same here? We would have to pick
    whether `__main__` would be for unittest tests, doctests, or both! What if we
    didn't even want to run testing through `__main__`, but instead run our application?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们正在使用模块的`__main__`块来运行其他测试套件。如果我们想在这里做同样的事情怎么办？我们必须选择`__main__`是用于单元测试、doctests还是两者兼而有之！如果我们甚至不想通过`__main__`运行测试，而是运行我们的应用程序怎么办？
- en: That is why Python added the option of invoking testing right from the command
    line using `-m doctest`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么 Python 添加了使用 `-m doctest` 从命令行直接调用测试的选项。
- en: Don't you want to *know* whether your tests are running or working? Is the test
    suite really doing what it promised? With other tools, we usually have to embed
    print statements, or deliberate failures just to know things are being trapped
    properly. Doesn't it appear that the `-v` option in `doctest` provides a convenient
    quick glance at what's happening?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你难道不想*知道*你的测试是否正在运行或工作吗？测试套件是否真的在做它承诺的事情？使用其他工具，通常我们必须嵌入打印语句，或者故意失败，只是为了知道事情被正确地捕获了。看起来`doctest`中的`-v`选项提供了一个方便的快速浏览正在发生的事情的方式，不是吗？
- en: Coding a test harness for doctest
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为`doctest`编写一个测试工具
- en: The tests we have written so far are very simple, because the function we are
    testing is simple. There are two inputs and one output with no side effects. No
    objects have to be created. This isn't the most common use case for us. Often,
    we have objects that interact with other objects.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写的测试非常简单，因为我们正在测试的函数很简单。有两个输入和一个输出，没有副作用。不需要创建对象。这对我们来说并不是最常见的用例。通常，我们有与其他对象交互的对象。
- en: The `doctest` module supports creating objects, invoking methods, and checking
    results. With this recipe, we will explore this in more detail.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest` 模块支持创建对象、调用方法和检查结果。通过这个示例，我们将更详细地探讨这个问题。'
- en: An important aspect of `doctest` is that it finds individual instances of docstrings,
    and runs them in a local context. Variables declared in one docstring cannot be
    used in another docstring.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`的一个重要方面是它找到文档字符串的各个实例，并在本地上下文中运行它们。在一个文档字符串中声明的变量不能在另一个文档字符串中使用。'
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new file called `recipe19.py` to contain the code from this recipe.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe19.py`的新文件，包含这个示例的代码。
- en: 'Write a simple shopping cart application:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个简单的购物车应用程序：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Insert a docstring at the top of the module, before the `ShoppingCart` class
    declaration:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ShoppingCart`类声明之前，在模块顶部插入一个文档字符串：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the recipe using `-m doctest` and `-v` for verbosity:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-m doctest`和`-v`进行运行：
- en: '![](../images/00043.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00043.jpeg)'
- en: Copy all the code we just wrote from `recipe19.py` into a new file called `recipe19b.py`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们刚刚从`recipe19.py`中编写的所有代码复制到一个名为`recipe19b.py`的新文件中。
- en: 'Inside `recipe19b.py`, add another docstring to `item`, which attempts to reuse
    the `cart` variable defined at the top of the module:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`recipe19b.py`中，在模块顶部定义`cart`变量后添加另一个文档字符串：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run this variant of the recipe. Why does it fail? Wasn''t `cart` declared in
    the earlier docstring? Look at this screenshot:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行这个示例的变体。为什么它失败了？`cart`不是在之前的文档字符串中声明的吗？看一下这个截图：
- en: '![](../images/00044.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00044.jpeg)'
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `doctest` module looks for every docstring. For each docstring it finds,
    it creates a shallow copy of the module's global variables and then runs the code
    and checks results. Apart from that, every variable created is locally scoped
    and then cleaned up when the test is complete. This means that our second docstring
    that was added later cannot see the `cart` that was created in our first docstring.
    That is why the second run failed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`模块查找每个文档字符串。对于它找到的每个文档字符串，它都会创建模块全局变量的浅拷贝，然后运行代码并检查结果。除此之外，每个创建的变量都是局部作用域的，当测试完成时会被清除。这意味着我们稍后添加的第二个文档字符串无法看到我们在第一个文档字符串中创建的`cart`。这就是为什么第二次运行失败的原因。'
- en: There is no equivalent to a `setUp` method as we used with some of the unittest
    recipes. If there is no `setUp` option with `doctest`, then what value is this
    recipe? It highlights a key limitation of `doctest` that all developers must understand
    before using it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些unittest示例中使用的`setUp`方法相比，`doctest`没有等价的方法。如果`doctest`没有`setUp`选项，那么这个示例有什么价值呢？它突显了所有开发人员在使用之前必须了解的`doctest`的一个关键限制。
- en: There's more...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `doctest` module provides an incredibly convenient way to add testability
    to our documentation. But this is not a substitute for a full-fledged testing
    framework, such as unittest. As noted earlier, there is no equivalent to a `setUp`.
    There is also no syntax checking of the Python code embedded in the docstrings.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest` 模块提供了一种非常方便的方式来为我们的文档添加可测试性。但这并不能替代完整的测试框架，比如 unittest。正如前面所述，没有`setUp`的等价物。在文档字符串中嵌入的
    Python 代码也没有语法检查。'
- en: Mixing the right level of a `doctest` with unittest (or any other testing framework
    we may pick) is a matter of judgment.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `doctest` 的正确级别与 unittest（或者我们可能选择的任何其他测试框架）混合在一起是一个判断的问题。
- en: Filtering out test noise
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤测试噪音
- en: Various options help `doctest` ignore noise, such as whitespace, in test cases.
    This can be useful, because it allows us to structure the expected outcome in
    a better way, to ease reading for the users.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 各种选项帮助`doctest`忽略噪音，比如在测试用例中的空白。这是有用的，因为它允许我们更好地结构化预期的结果，以便用户更容易阅读。
- en: We can also flag some tests that can be skipped. This can be used where we want
    to document known issues, but haven't yet patched the system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以标记一些可以跳过的测试。这可以用在我们想要记录已知问题，但尚未修补系统的地方。
- en: Both of these situations can easily be construed as noise when we are trying
    to run comprehensive testing but are focused on other parts of the system. In
    this recipe, we will dig in to ease the strict checking done by `doctest`. We
    will also look at how to ignore entire tests, whether it's for temporary or permanent
    needs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们试图进行全面测试但专注于系统的其他部分时，这两种情况都很容易被解释为噪音。在这个示例中，我们将深入研究如何放宽`doctest`的严格检查。我们还将看看如何忽略整个测试，无论是临时的还是永久的。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With the following steps, we will experiment with filtering out test results
    and easing certain restrictions of `doctest`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，我们将尝试过滤测试结果并放宽`doctest`的某些限制：
- en: Create a new file called `recipe20.py` for the code from this recipe.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个示例的代码创建一个名为`recipe20.py`的新文件。
- en: 'Create a recursive function that converts base-10 numbers into other bases:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个递归函数，将十进制数转换为其他进制：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add a docstring that includes a test to exercise a range of values as well
    as document a future feature that is not yet implemented:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个包含一系列值的测试来练习的文档字符串，以及记录一个尚未实现的未来功能：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add a test runner:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个测试运行程序：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the test case in verbose mode, as shown in this screenshot:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以详细模式运行测试用例，如此截图所示：
- en: '![](../images/00045.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00045.jpeg)'
- en: Copy the code from `recipe20.py` into a new file called `recipe20b.py`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`recipe20.py`中的代码复制到一个名为`recipe20b.py`的新文件中。
- en: 'Edit `recipe20b.py` by updating the docstring to include another test exposing
    that our function doesn''t convert `0`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过更新文档字符串来编辑`recipe20b.py`，包括另一个测试，显示我们的函数不会转换`0`：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the test case. Notice what is different about this version of the recipe
    and why it fails? Take a look at this screenshot:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试用例。注意这个版本的配方有什么不同之处，以及为什么它失败了？看一下这个截图：
- en: '![](../images/00046.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00046.jpeg)'
- en: Copy the code from `recipe20b.py` into a new file called `recipe20c.py`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`recipe20b.py`中的代码复制到一个名为`recipe20c.py`的新文件中。
- en: 'Edit `recipe20c.py` and update the docstring, indicating that we will skip
    the test for now:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`recipe20c.py`并更新文档字符串，指示我们现在将跳过测试：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the test case. Take a look at this screenshot:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试用例。看一下这个截图：
- en: '![](../images/00047.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00047.jpeg)'
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we revisit the function for converting from base-10 to any base
    numbers. The first test shows it being run over a range. Normally, Python would
    fit this array of results on one line. To make it more readable, we spread the
    output across two lines. We also put some arbitrary spaces between the values
    to make the columns line up better.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们重新审视了从十进制转换为任意进制数字的函数。第一个测试显示它在一个范围内运行。通常，Python会将这个结果数组放在一行上。为了使其更易读，我们将输出分布在两行上。我们还在值之间放了一些任意的空格，以使列更好地对齐。
- en: 'This is something that `doctest` definitely would *not* support, due to its
    strict pattern matching nature. By using `#doctest: +NORMALIZE_WHITESPACE`, we
    are able to ask `doctest` to ease this restriction. There are still constraints.
    For example, the first value in the expected array cannot have any whitespace
    in front of it (*believe me, I tried for maximum readability!*) But wrapping the
    array to the next line no longer breaks the test.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '这是`doctest`绝对不会支持的事情，因为它严格的模式匹配性质。通过使用`#doctest: +NORMALIZE_WHITESPACE`，我们能够要求`doctest`放宽这个限制。仍然有约束。例如，预期数组中的第一个值不能有任何空格在它前面（*相信我，我试过了，为了最大的可读性！*）但是将数组包装到下一行不再破坏测试。'
- en: 'We also have a test case that is really meant as documentation only. It indicates
    a future requirement that shows how our function would handle negative binary
    values. By adding `#doctest: +SKIP`, we are able to command `doctest` to skip
    this particular instance.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还有一个测试用例，实际上只是作为文档。它指示了一个未来的要求，显示了我们的函数如何处理负二进制值。通过添加`#doctest: +SKIP`，我们能够命令`doctest`跳过这个特定的实例。'
- en: 'Finally, we see a scenario where we discover that our code doesn''t handle
    `0`. As the algorithm gets the highest exponent by taking a logarithm, there is
    a math problem. We capture this edge case with a test. We then confirm that the
    code fails in classic **test-****driven ****design** (**TDD**) fashion. The final
    step would be to fix the code to handle this edge case. But we decide, in a somewhat
    contrived fashion, that we don''t have enough time in the current sprint to fix
    the code. To avoid breaking our **continuous ****integration** (**CI**) server,
    we mark the test with a `TO-DO` statement and add `#doctest: +SKIP`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我们看到了一个情景，我们发现我们的代码不能处理`0`。由于算法通过取对数得到最高指数，存在一个数学问题。我们通过一个测试来捕获这个边缘情况。然后我们确认代码以经典的**测试驱动设计**（**TDD**）方式失败。最后一步将是修复代码以处理这个边缘情况。但我们决定，以一种有点牵强的方式，我们没有足够的时间在当前的迭代中修复代码。为了避免破坏我们的**持续集成**（**CI**）服务器，我们用一个`TO-DO`语句标记测试，并添加`#doctest:
    +SKIP`。'
- en: There's more...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Both situations that we have marked up with `#doctest: +SKIP` are cases where
    eventually we will want to remove the `SKIP` tag and have them run. There may
    be other situations where we will never remove `SKIP`. Demonstrations of code
    that have big fluctuations may not be readily testable without making them unreadable.
    For example, functions that return dictionaries are harder to test because the
    order of results vary. We can bend it to pass a test, but we may lose the value
    of the documentation in order to present it to the reader.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '我们用`#doctest: +SKIP`标记的两种情况都是最终我们希望移除`SKIP`标记并让它们运行的情况。可能还有其他情况我们永远不会移除`SKIP`。代码演示可能有很大的波动，可能无法轻易测试而不使其难以阅读。例如，返回字典的函数更难测试，因为结果的顺序会变化。我们可以弯曲它以通过测试，但我们可能会失去文档的价值，以便呈现给读者。'
- en: Printing out all your documentation including a status report
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印出所有的文档，包括状态报告
- en: Since this chapter has been about both documentation and testing, let's build
    a script that takes a set of modules and prints out a complete report, showing
    all documentation as well as running any given tests.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章涉及文档和测试，让我们构建一个脚本，它接受一组模块并打印出一个完整的报告，显示所有文档以及运行任何给定的测试。
- en: This is a valuable recipe, because it shows us how to use Python's APIs to harvest
    a code-driven runnable report. This means the documentation is accurate and up
    to date, reflecting the current state of our code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有价值的配方，因为它向我们展示了如何使用Python的API来收集一个基于代码的可运行报告。这意味着文档是准确的，也是最新的，反映了我们代码的当前状态。
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the following steps, we will write an application and some `doctests`. Then
    we will build a script to harvest a useful report:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将编写一个应用程序和一些`doctests`。然后我们将构建一个脚本来收集一个有用的报告：
- en: Create a new file called `recipe21_report.py` to contain the script that harvests
    our report.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe21_report.py`的新文件，用于包含收集报告的脚本。
- en: 'Start creating a script by importing Python''s `inspect` library as the basis
    for drilling down into a module: `from inspect import*`.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导入Python的`inspect`库来创建一个脚本，作为深入模块的基础：`from inspect import*`。
- en: 'Add a function that focuses on either printing out an item''s `__doc__` string
    or prints out that no documentation was found:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个函数，专注于打印出一个项目的`__doc__`字符串或打印出未找到文档的消息：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add a function that prints out the documentation based on a given module. Make
    sure this function looks for classes, methods, and functions, and prints out their
    docs:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个函数，根据给定模块打印出文档。确保这个函数查找类、方法和函数，并打印出它们的文档：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add a runner that parses the command-line string, and iterates over each provided
    module:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个解析命令行字符串并迭代每个提供的模块的运行器：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Create a new file, `recipe21.py`, to contain an application with tests that
    we will run the earlier script against.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件`recipe21.py`，其中包含一个我们将对之前的脚本运行的应用程序和测试。
- en: 'In `recipe21.py`, create a shopping cart app and fill it with docstrings and
    `doctests`. This is documentation for the entire recipe. With it, we can demonstrate
    usage of the code:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`recipe21.py`中，创建一个购物车应用程序，并填充它的文档字符串和`doctests`。这是整个食谱的文档。有了它，我们可以演示代码的用法：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the report script against this module using `-v`, and look at the screen''s
    output:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-v`对这个模块运行报告脚本，并查看屏幕输出：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This script is tiny, yet it harvests a lot of useful information.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本很小，但它收集了很多有用的信息。
- en: By using Python's standard `inspect` module, we are able to drill down starting
    at the module level. The reflective way to look up a docstring is by accessing
    the `__doc__` property of an object. This is contained in modules, classes, methods,
    and functions. They exist in other places, but we limited our focus for this recipe.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Python的标准`inspect`模块，我们能够从模块级别开始深入研究。查找文档字符串的反射方式是通过访问对象的`__doc__`属性。它包含在模块、类、方法和函数中。它们存在于其他地方，但我们在这个食谱中限制了我们的重点。
- en: 'We ran it in verbose mode to show that the tests were actually executed. We
    hand parsed the command-line options, but `doctest` automatically looks for `-v`
    to decide whether or not to turn on verbose output. To prevent our module processor
    from catching this and trying to process it as another module, we added a line
    to skip any `-xyz` style flags:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以详细模式运行它，以显示测试实际上被执行。我们手动解析了命令行选项，但`doctest`自动查找`-v`来决定是否打开详细输出。为了防止我们的模块处理器捕捉到这一点并尝试将其处理为另一个模块，我们添加了一行来跳过任何`-xyz`风格的标志：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There's more...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We could spend more time enhancing this script. For example, we could dump this
    out with an HTML markup, making it viewable in a web browser. We could also find
    third-party libraries to export it in other ways.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以花更多时间来增强这个脚本。例如，我们可以使用HTML标记将其导出，使其可以在Web浏览器中查看。我们还可以找到第三方库以其他方式导出它。
- en: We could also work on refining where it looks for docstrings and how it handles
    them. In our case, we just printed them to the screen. A more reusable approach
    would be to return some type of structure containing all the information. Then,
    the caller can decide whether to print to screen, encode it in HTML, or generate
    a PDF document.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在哪里寻找文档字符串以及如何处理它们上进行改进。在我们的情况下，我们只是将它们打印到屏幕上。一个更可重用的方法是返回包含所有信息的某种结构。然后，调用者可以决定是打印到屏幕上，将其编码为HTML，还是生成PDF文档。
- en: This isn't necessary, because this recipe's focus is on seeing how to mix these
    powerful out-of-the-box options Python provides into a quick and useful tool.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是必要的，因为这个食谱的重点是看如何将Python提供的这些强大的开箱即用选项混合到一个快速和有用的工具中。
- en: Testing the edges
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试边缘
- en: Tests need to exercise the boundaries of our code up to and beyond the range
    limits. In this recipe, we will dig into defining and testing edges with `doctest`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 测试需要在我们的代码边界上进行练习，直到超出范围限制。在这个食谱中，我们将深入定义和测试使用`doctest`的边缘。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With the following steps, we will see how to write code that tests the edges
    of our software:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，我们将看到如何编写测试软件边缘的代码：
- en: Create a new file named `recipe22.py` and use it to place all of our code for
    this recipe.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe22.py`的新文件，并使用它来放置这个食谱的所有代码。
- en: 'Create a function that converts base-10 numbers to anything between base-2
    and base-36:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将十进制数转换为2进制到36进制之间任何进制的函数：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add a docstring just below our function declaration that includes tests showing
    base-2 edges, base-36 edges, and the invalid base-37:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的函数声明下面添加一个文档字符串，其中包括显示2进制边缘、36进制边缘和无效的37进制的测试：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add a test runner:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个测试运行器：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the recipe, as shown in this screenshot:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照这个屏幕截图展示的方式运行这个食谱：
- en: '![](../images/00048.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00048.jpeg)'
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This version has a limit of handling base-2 through base-36.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本有一个处理2进制到36进制的限制。
- en: For base-36, it uses `a` to `*z*`. This is compared to base-16 that uses `a`
    to `f`. `35` in base-10 is represented as `z` in base-36.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于36进制，它使用`a`到`z`。这与使用`a`到`f`的16进制进行比较。在10进制中，`35`表示为36进制中的`z`。
- en: We include several tests, including `1` for base-2 and base-36\. We also test
    the maximum value before rolling over, and the next value, to show the rollover.
    For base-2, this is `1` and `2`. For base-36, this is `35` and `36`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括了几个测试，包括2进制和36进制的`1`。我们还测试了在回卷之前的最大值和下一个值，以显示回卷。对于2进制，这是`1`和`2`。对于36进制，这是`35`和`36`。
- en: As we have also included tests for 0 to show that our function doesn't handle
    this for any base, we also test base-37, which is invalid as well.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们还包括了测试0来显示我们的函数不处理任何基数，我们还测试了无效的36进制。
- en: There's more...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It's important that our software works for valid inputs. It's just as important
    that our software works as expected for invalid inputs. We have documentation
    that can be viewed by our users when using our software that documents these edges.
    And, thanks to Python's `doctest` module, we can test it and make sure that our
    software performs correctly.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有效的输入，我们的软件能够正常工作是很重要的。同样重要的是，我们的软件对于无效的输入能够按预期工作。我们有文档可以在用户使用我们的软件时查看，记录了这些边缘情况。而且，由于Python的`doctest`模块，我们可以测试它，确保我们的软件表现正确。
- en: See also
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Testing **the **edges* section mentioned in [Chapter 1](part0025.html#NQU20-dd965cfd3480473da68e719fadb0727c),
    *Using Unittest to Develop Basic Tests*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0025.html#NQU20-dd965cfd3480473da68e719fadb0727c)中提到的*测试边缘*部分，*使用Unittest开发基本测试*。
- en: Testing corner cases by iteration
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过迭代测试边缘情况
- en: Corner cases will appear as we continue to develop our code. By capturing corner
    cases in an iterable list, there is less code to write for capturing another test
    scenario. This can increase our efficiency at testing new scenarios.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续开发我们的代码，边缘情况将会出现。通过在可迭代列表中捕获边缘情况，我们需要编写的代码更少，以捕获另一个测试场景。这可以提高我们测试新场景的效率。
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new file called `recipe23.py`, and use it to store all our code for
    this recipe.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe23.py`的新文件，并用它来存储这个配方的所有代码。
- en: 'Create a function that converts base-10 to any other base:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将十进制转换为任何其他进制的函数：
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add some instances of `doctest` that include an array of input values to generate
    an array of expected outputs. Include one failure:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些包含一系列输入值以生成一系列预期输出的`doctest`实例。包括一个失败的实例：
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a test runner:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个测试运行器：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the recipe:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行这个配方：
- en: '![](../images/00049.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00049.jpeg)'
- en: 'In the previous screenshot, the key information is on this line: `AssertionError:
    expected: 11/2 actual: 10/2`. Is this test failure a bit contrived? Sure it is.
    But seeing a test case that shows useful output is not. It''s important to verify
    that our tests give us enough information to fix either the tests or the code.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的截图中，关键信息在这一行上：`AssertionError: expected: 11/2 actual: 10/2`。这个测试失败有点牵强吗？当然是。但是看到一个显示有用输出的测试用例并不是。重要的是要验证我们的测试是否给了我们足够的信息来修复测试或代码。'
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We created an array with each entry containing both the input data as well as
    the expected output. This provides us an easy way to glance at a set of test cases.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个数组，每个条目都包含输入数据和预期输出。这为我们提供了一种简单的方式来查看一组测试用例。
- en: 'Then, we iterated over each test case, calculated the actual value, and ran
    it through a Python `assert`. An important part that is needed is the custom message
    `''expected: %s actual: %s''`. Without it, we would never get the information
    that tells us which test case failed.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，我们遍历了每个测试用例，计算了实际值，并通过Python的`assert`运行了它。一个需要的重要部分是自定义消息`''expected: %s
    actual: %s''`。没有它，我们将永远得不到告诉我们哪个测试用例失败的信息。'
- en: '**What if one test case fails?**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个测试用例失败会怎么样？
- en: If one of the tests in the array fails, then that code block exits and skips
    over the rest of the tests. This is the trade-off for having a more succinct set
    of tests.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组中的一个测试失败了，那么该代码块将退出并跳过其余的测试。这是为了拥有更简洁的一组测试而进行的权衡。
- en: Does this type of test fit better into doctest or unittest?
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这种类型的测试更适合于doctest还是unittest？
- en: 'Here are some criteria to help you decide whether it''s worth putting these
    tests in `doctest`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些标准，可以帮助您决定是否值得将这些测试放入`doctest`中：
- en: Is the code easy to comprehend at a glance?
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码一目了然吗？
- en: Is there clear, succinct, useful information when users view the docstrings?
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户查看文档字符串时，是否有清晰、简洁、有用的信息？
- en: If there is little value of having this in the documentation, and it clutters
    the code, then that is a strong hint that this test block belongs to a separate
    test module.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在文档中没有这个的价值，而且它会使代码混乱，那么这是一个明显的提示，表明这个测试块属于一个单独的测试模块。
- en: See also
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Testing **corner **cases **by **iteration* section of [Chapter 1](part0025.html#NQU20-dd965cfd3480473da68e719fadb0727c),
    *Using Unittest to Develop Basic Tests*
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0025.html#NQU20-dd965cfd3480473da68e719fadb0727c)的*通过迭代测试边缘情况*部分，*使用Unittest开发基本测试*
- en: Getting nosy with doctest
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用doctest变得爱管闲事
- en: Up to this point, we have been either appending modules with a test runner,
    or we have typed `python -m doctest <module>` on the command line to exercise
    our tests.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们要么是用测试运行器附加模块，要么是在命令行上输入`python -m doctest <module>`来执行我们的测试。
- en: In the previous chapter, we introduced the powerful `nose` library (refer to [http://somethingaboutorange.com/mrl/projects/nose](http://somethingaboutorange.com/mrl/projects/nose)
    for more details).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了强大的`nose`库（有关详细信息，请参阅[http://somethingaboutorange.com/mrl/projects/nose](http://somethingaboutorange.com/mrl/projects/nose)）。
- en: 'For a quick recap, nose has the following features:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 简要回顾一下，nose具有以下功能：
- en: Provides us with the convenient test discovering tool `nosetests`
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们提供了方便的测试发现工具`nosetests`
- en: Is pluggable, with a huge ecosystem of plugins available
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可插拔，有大量的插件可用
- en: Includes a built-in plugin targeted at finding doctests and running them
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括一个针对查找doctests并运行它们的内置插件
- en: Getting ready
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We need to activate our virtual environment (`virtualenv`) and then install
    nose for this recipe:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要激活我们的虚拟环境（`virtualenv`），然后为这个配方安装nose：
- en: 'Create a virtual environment, activate it, and verify the tools are working.
    Take a look at this screenshot:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个虚拟环境，激活它，并验证工具是否正常工作。看一下这个截图：
- en: '![](../images/00050.jpeg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00050.jpeg)'
- en: 'Using `pip`, install `nose`, as shown in the screenshot:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pip`，按照截图中显示的方式安装`nose`：
- en: '![](../images/00051.jpeg)This recipe assumes you have built all of the previous
    recipes in this chapter. If you have built only some of them, your results may
    appear different.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00051.jpeg)这个配方假设您已经构建了本章中的所有先前的配方。如果您只构建了其中一些，您的结果可能会有所不同。'
- en: How to do it...
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Run `nosetests -with-doctest` against all the modules in this folder. You may
    notice that it prints a very short `.....F.F...F`, indicating that three tests
    have failed.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对这个文件夹中的所有模块运行`nosetests -with-doctest`。您可能会注意到它打印了一个非常简短的`.....F.F...F`，表示有三个测试失败了。
- en: 'Run `nosetests -with-doctest -v` to get a more verbose output. In the following
    screenshot, notice how the tests that failed are the same ones that failed for
    the previous recipes in this chapter. It is also valuable to see the `<module>.<method>`
    format with either `ok` or `FAIL`:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`nosetests -with-doctest -v`以获得更详细的输出。在下面的截图中，注意到失败的测试与本章前面的示例中失败的测试是相同的。还有一个有价值的地方是看到了`<module>.<method>`格式，要么是`ok`要么是`FAIL`：
- en: '![](../images/00052.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00052.jpeg)'
- en: 'Run `nosetests -with-doctest` against both the `recipe19.py` file as well as
    the `recipe19` module, in different combinations, as shown in the screenshot:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照屏幕截图中显示的方式，对`recipe19.py`文件以及`recipe19`模块运行`nosetests -with-doctest`，以不同的组合方式进行测试：
- en: '![](../images/00053.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00053.jpeg)'
- en: How it works...
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`nosetests` is targeted at discovering test cases and then running them. With
    this plugin, when it finds a docstring, it uses the `doctest` library to programmatically
    test it.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`nosetests`旨在发现测试用例，然后运行它们。使用这个插件时，当它发现一个文档字符串时，它会使用`doctest`库来进行程序化测试。'
- en: The `doctest` plugin is built around the assumption that doctests are not in
    the same package as other tests, such as unittest. This means it will only run
    doctests found from non-test packages.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`插件是基于这样的假设构建的，即doctests不在与其他测试（如unittest）相同的包中。这意味着它只会运行从非测试包中找到的doctests。'
- en: There isn't a whole lot of complexity to `nosetests` nor in using them, `nosetests`
    is meant to be an easy-to-use tool that puts testing at your fingertips. In this
    recipe, we have seen how to use `nosetests` to get a hold of all the doctest we
    have built so far in this chapter.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`nosetests`并不复杂，也不难使用，`nosetests`旨在成为一个方便使用的工具，让测试触手可及。在这个示例中，我们已经看到了如何使用`nosetests`来获取到目前为止在本章中构建的所有doctest。'
- en: Updating the project-level script to run this chapter's doctests
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新项目级别的脚本以运行本章的doctests
- en: This recipe will help us explore building a project-level script that allows
    us to run different test suites. We will also focus on how to run it in our `doctest`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将帮助我们探索构建一个项目级别的脚本，允许我们运行不同的测试套件。我们还将专注于如何在我们的`doctest`中运行它。
- en: How to do it...
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With the following steps, we will craft a command-line script to allow us to
    manage a project that includes running `doctest`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，我们将创建一个命令行脚本，以允许我们管理一个包括运行`doctest`的项目：
- en: Create a new file called `recipe25.py` to put all the code for this recipe.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe25.py`的新文件，以放置本示例的所有代码。
- en: 'Add code that parses a set of options using Python''s `getopt` library:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加代码，使用Python的`getopt`库解析一组选项：
- en: '[PRE28]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a function that maps to `-test`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个映射到“-test”的函数：
- en: '[PRE29]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a function that maps to `-doctest`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个映射到“-doctest”的函数：
- en: '[PRE30]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create stub functions that support `package`, `publish`, and `register`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建支持`package`、`publish`和`register`的存根函数：
- en: '[PRE31]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add some code that detects if the option list is empty. If so, have it print
    out the help menu and exit the script:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些代码来检测选项列表是否为空。如果是，让它打印出帮助菜单并退出脚本：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add some code that defines debug levels and then parses options to allow the
    user to override:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些代码来定义调试级别，然后解析选项以允许用户进行覆盖：
- en: '[PRE33]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add some code that scans the command-line options for `-help`, and, if found,
    exits the script:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些代码，扫描命令行选项以查找“-help”，如果找到，则退出脚本：
- en: '[PRE34]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add code that checks if `--doctest` has been picked. If so, have it specifically
    scan `--suite` and run it through the `doctest()` method. Otherwise, run `-suite`
    through the  `test()` method:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加代码来检查是否选择了`--doctest`。如果是，让它专门扫描`--suite`并通过`doctest()`方法运行它。否则，通过`-suite`运行`test()`方法：
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finish it by iterating through each of the command-line options, and invoking
    the other functions based on the options that are picked:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过迭代每个命令行选项来完成，并根据所选的选项调用其他函数：
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run the script with `--help`, as shown in the screenshot:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照屏幕截图中显示的方式使用“--help”运行脚本：
- en: '![](../images/00054.jpeg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00054.jpeg)'
- en: 'Run the script with `--doctest`. Notice the first few lines of output in the
    following screenshot. It shows how the tests have passed and failed along with
    detailed output. Take a look at this screenshot:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`--doctest`运行脚本。注意以下屏幕截图中的前几行输出。它显示了测试的通过和失败以及详细的输出。看一下这个屏幕截图：
- en: '![](../images/00055.jpeg)The output is much longer. It has been trimmed for
    the sake of brevity.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00055.jpeg)输出要长得多。为了简洁起见，已经对其进行了修剪。'
- en: 'Run the script with `-doctest -suite=recipe16,recipe17.py`, as shown in the
    screenshot:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照屏幕截图中显示的方式，使用`-doctest -suite=recipe16,recipe17.py`运行脚本：
- en: '![](../images/00056.jpeg)We deliberately used `recipe16.py` and `recipe17.py`
    to demonstrate that it works with both module names and filenames.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00056.jpeg)我们故意使用`recipe16.py`和`recipe17.py`来演示它是如何与模块名和文件名一起工作的。'
- en: How it works...
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This script uses Python's `getopt` library, which is modeled after the `getopt()`
    function (refer to [http://docs.python.org/library/getopt.html](http://docs.python.org/library/getopt.html)
    for more details).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本使用了Python的`getopt`库，它是模仿`getopt()`函数的（有关更多详细信息，请参阅[http://docs.python.org/library/getopt.html](http://docs.python.org/library/getopt.html)）。
- en: 'We have wired the following functions:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经连接了以下函数：
- en: '`Usage`: A function to provide help to the user.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Usage`：提供帮助给用户的函数。'
- en: '`Key`: The key option definitions are included in the following block:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Key`：关键选项定义包括在以下块中：'
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We parse everything in the arguments except the first, it being the executable
    itself.
  id: totrans-268
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解析除第一个外的所有参数，第一个是可执行文件。
- en: '`"h"` defined the short option: `-h`.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"h"`定义了短选项：`-h`。'
- en: The list defines long options. Those with `"="` accept an argument. Those without
    are flags.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表定义了长选项。带有“=”的选项接受一个参数。没有参数的是标志。
- en: If an option is received that isn't in the list, an exception is thrown, we
    print out `usage()`, and then exit.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果收到的选项不在列表中，就会抛出异常，我们打印出`usage()`，然后退出。
- en: '`doctest`: It runs modules through nose using `-with-doctest`.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doctest`：它使用“-with-doctest”通过nose运行模块。'
- en: '`package`, `pubilsh`, and `register`: These are just like the functions described
    in the previous chapter.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package`、`pubilsh`和`register`：这些与上一章中描述的函数类似。'
- en: 'With each of these functions defined, we can now iterate over the options that
    were parsed. For this script, there is a sequence:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这些函数后，我们现在可以迭代解析的选项。对于这个脚本，有一个顺序：
- en: Check whether there is a debugging override. We default to `logging.INFO`, but
    we provide the ability to switch to `logging.DEBUG`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否有调试覆盖。我们默认为`logging.INFO`，但我们提供切换到`logging.DEBUG`的能力。
- en: Check whether `-h` or `-help` was called. If so, print out the `usage()` information
    and then exit with no more parsing.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否调用了`-h`或`-help`。如果是，打印出`usage()`信息，然后退出，不再解析。
- en: Because `-suite` can be used either by itself to run unittest tests, or as a
    suboption for `-doctest`, we have to parse through things and figure out whether `-doctest`
    was used.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为`-suite`可以单独用于运行unittest测试，或作为`-doctest`的子选项，我们必须解析一下，并弄清楚是否使用了`-doctest`。
- en: Finally, iterate over the options, and call their corresponding functions.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，迭代选项，并调用它们对应的函数。
- en: To exercise things, we first called this script with the `-help` option that
    printed out the command choices we had.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习，我们首先用`-help`选项调用这个脚本，打印出我们的命令选择。
- en: Then we called it with `-doctest` to see how it handled finding all the doctests
    in this folder. In our case, we found all the recipes for this chapter including
    three test failures.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们用`-doctest`调用它，看它如何找到这个文件夹中的所有doctests。在我们的例子中，我们找到了本章的所有配方，包括三个测试失败。
- en: Finally, we called the script with `-doctest -suite=recipe16,recipe17.py`. This
    shows how we can pick a subset of tests delineated by the comma. With this example,
    we see that nose can process either by the module name (`recipe16.py`) or by the
    filename (`recipe17.py`).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们用`-doctest -suite=recipe16,recipe17.py`调用脚本。这显示了我们如何选择由逗号分隔的测试子集。通过这个例子，我们看到nose可以通过模块名（`recipe16.py`）或文件名（`recipe17.py`）来处理。
- en: There's more...
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The features this script provides could easily be handled by commands that are
    already built. We looked at `nosetests` with `doctest` earlier in this chapter
    and saw how it can take arguments to pick tests flexibly.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本提供的功能可以很容易地通过已经构建的命令来处理。我们在本章前面看过`nosetests`和`doctest`，并看到它如何接受参数来灵活地选择测试。
- en: Using `setup.py` to generate tarballs and register releases is also a commonly
    used feature in the Python community.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python社区中，使用`setup.py`生成tarballs和注册发布也是一个常用的功能。
- en: So why write this script? Because, we can exploit all these features with a
    single command.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么要编写这个脚本呢？因为我们可以利用一个命令来利用所有这些功能。
