- en: '*Chapter 3*: Models, Relations, and Inheritance'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：模型、关系和继承'
- en: '**Models** represent tables, also known as objects, within a database. Django
    provides a simple way to map objects to a project''s underlying database(s). We
    will use this mapping system to work with other components of Django in later
    chapters of this book, such as a template, view, or form, to name a few. Anything
    that relies on accessing data from within a database will rely on the models that
    we create. If a project connects to an external database system or the project
    uses an API to interact with data, then there is no need to create any models
    in that situation.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型**代表数据库中的表，也称为对象。Django提供了一种简单的方法将对象映射到项目的底层数据库（或数据库）。我们将使用这种映射系统在本书的后续章节中与其他Django组件一起工作，例如模板、视图或表单，仅举几例。任何依赖于从数据库内部访问数据的东西都将依赖于我们创建的模型。如果一个项目连接到外部数据库系统或项目使用API与数据交互，那么在这种情况下就不需要创建任何模型。'
- en: 'In this chapter, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Writing model classes to create database tables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写模型类以创建数据库表
- en: Using standard field types and third-party field types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准字段类型和第三方字段类型
- en: Configuring field validators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置字段验证器
- en: Linking tables through field relationships
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过字段关系链接表
- en: Working with model meta classes and options
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与模型元类和选项一起工作
- en: Using model methods and method decorators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型方法和方法装饰器
- en: Practicing extending models
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习扩展模型
- en: Introducing using the Django shell as a tool to perform queries and add data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍使用Django shell作为执行查询和添加数据的工具
- en: Creating a model manager to format and control data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模型管理器以格式化和控制数据
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To work with the code in this chapter, the following tools will need to be
    installed on your local machine:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用本章中的代码，以下工具需要在你的本地机器上安装：
- en: Python version 3.9 – used as the underlying programming language for the project
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python版本3.9 – 作为项目的底层编程语言
- en: Django version 4.0 – used as the backend framework of the project
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django版本4.0 – 作为项目的后端框架
- en: pip package manager – used to manage third-party Python/Django packages
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pip包管理器 – 用于管理第三方Python/Django包
- en: We will continue to work with the solution created in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037),
    *Project Configuration*. However, it is not necessary to use the Visual Studio
    IDE. The main project itself can be run using another IDE or independently using
    a terminal or command-line window from within the project root folder. This is
    where the `manage.py` file resides. Whatever editor or IDE you are using, a virtual
    environment will also be needed to work with the Django project. Instructions
    for how to create a project and virtual environment can be found in [*Chapter
    2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*. You will
    need a database to store the data contained in your project. PostgreSQL was chosen
    for the examples in the previous chapter; however, any database type that you
    choose for your project can be used to work with the examples in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用在[*第2章*](B17243_02_ePub.xhtml#_idTextAnchor037)“项目配置”中创建的解决方案进行工作。然而，并不需要使用Visual
    Studio IDE。主要项目本身可以使用其他IDE或从项目根目录独立运行，使用终端或命令行窗口。这就是`manage.py`文件所在的位置。无论你使用什么编辑器或IDE，都需要一个虚拟环境来与Django项目一起工作。有关如何创建项目和虚拟环境的说明可以在[*第2章*](B17243_02_ePub.xhtml#_idTextAnchor037)“项目配置”中找到。你需要一个数据库来存储项目中的数据。在上一章的示例中选择了PostgreSQL；然而，你可以为你的项目选择任何数据库类型来与本章中的示例一起工作。
- en: 'All of the code created in this chapter can be found in the GitHub repository
    for this book: [https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer](https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer).
    The bulk of the code depicted in this chapter can be found in the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_3/`
    directory.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中创建的所有代码都可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer](https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer)。本章中展示的大部分代码可以在`/becoming_a_django_entdev/becoming_a_django_entdev/chapter_3/`目录中找到。
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3zZ68RS](https://bit.ly/3zZ68RS)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看*代码在行动*：[https://bit.ly/3zZ68RS](https://bit.ly/3zZ68RS)
- en: Preparing for this chapter
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为本章做准备
- en: Start by creating a new app in your project called `chapter_3` by following
    the steps discussed in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project
    Configuration*, under the subsection titled *Creating a Django app*. As discussed
    in that section, don't forget to change the value of the `name =` variable for
    your app class found in the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_3/apps.py`
    file to now point to the path where you installed your app. Be sure to also include
    this app in your `INSTALLED_APPS` variable found in the `settings.py` file as
    well.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照在[*第2章*](B17243_02_ePub.xhtml#_idTextAnchor037)中讨论的步骤，在你的项目中创建一个名为`chapter_3`的新应用。正如该部分所讨论的，不要忘记将`/becoming_a_django_entdev/becoming_a_django_entdev/chapter_3/apps.py`文件中找到的你的应用类中的`name
    =`变量的值更改为指向你安装应用的位置。确保还将此应用包含在`settings.py`文件中的`INSTALLED_APPS`变量中。
- en: Writing model classes
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写模型类
- en: Each model in your project represents a table within your database. The fields
    that are created in those models all relate to columns within that table. Django
    provides a technique called `settings.py` file of a project. The ORM technique
    is a process used to convert data between two systems of incompatible data types.
    This means that Django takes the headache out of working directly with **Structured
    Query Language** (**SQL**) to perform queries. The Django ORM irons out odd differences
    between the various database types when interpreting SQL, making it a universal
    tool for working with all data structures. Now, you and your developers can focus
    more on developing and less on the headaches involved. Django does not require
    the use of SQL as a standard writing practice. However, if you want or need to,
    Django does provide a way to use basic SQL when performing query operations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你项目中的每个模型都代表数据库中的一个表。在这些模型中创建的字段都与该表中的列相关。Django提供了一种称为`settings.py`文件的项目技术。ORM技术是一种用于在两种不兼容的数据类型系统之间转换数据的过程。这意味着Django消除了直接使用**结构化查询语言**（**SQL**）进行查询的烦恼。Django
    ORM在解释SQL时消除了各种数据库类型之间的差异，使其成为处理所有数据结构的通用工具。现在，你和你的开发者可以更多地专注于开发，而不是处理这些烦恼。Django不要求使用SQL作为标准写作实践。然而，如果你想或需要这样做，Django确实提供了一种在执行查询操作时使用基本SQL的方法。
- en: 'Next, imagine we are building a site that allows a user to view a page providing
    details about a specific car, commonly referred to as a detail page/view. Let''s
    say we are building a basic site just to store and look up details about cars
    that are listed for sale. A user could do this for a number of reasons; perhaps
    they are renting, buying, leasing, or selling a car. In any scenario, we would
    need a table that represents a vehicle object, another table for the model of
    the vehicle (not to be confused with a Django model), and another table for the
    engine type. In a real-world scenario, your project may consist of many other
    tables and the structure of these tables may also differ in many ways. In this
    particular exercise, we won''t create a model for the manufacturer, also known
    as the make of a vehicle. The manufacturer will be created as a set in order to
    demonstrate certain concepts for educational purposes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设我们正在构建一个允许用户查看提供特定汽车详细信息的页面的网站，通常称为详情页面/视图。让我们假设我们正在构建一个基本的网站，仅用于存储和查找待售汽车的详细信息。用户可能出于多种原因这样做；可能是租车、购买、租赁或出售汽车。在任何情况下，我们都需要一个表示车辆对象的表，另一个表示车辆型号的表（不要与Django模型混淆），以及另一个表示发动机类型的表。在现实世界的场景中，你的项目可能包含许多其他表，这些表的结构也可能在许多方面有所不同。在这个特定的练习中，我们不会为制造商创建模型，也称为车辆的型号。制造商将作为一个集合来创建，以展示某些教育目的的概念：
- en: 'Inside the `models.py` file of the `chapter_3` directory that was just created,
    write three empty classes, one for each of the tables related to our vehicle exercise,
    following this example:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在刚刚创建的`chapter_3`目录下的`models.py`文件中，编写三个空类，每个类对应于与我们的车辆练习相关的表格，按照以下示例进行：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Create one class each for `Vehicle`, `VehicleModel`, and `Engine`. We will name
    the class pertaining to a model of a vehicle as `VehicleModel` instead of `Model`
    in order to prevent confusion as we work through each exercise.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Vehicle`、`VehicleModel`和`Engine`创建一个类。我们将把与车辆模型相关的类命名为`VehicleModel`而不是`Model`，以防止我们在完成每个练习时产生混淆。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: In the preceding example, three classes were created that do absolutely nothing
    at this time by writing the `pass` statement directly in them. This is a tool
    to add to your toolbox for writing skeleton code and allowing other components
    to continue to function while you write. Python will give you errors if nothing
    is placed in a class and when you are ready to write code for that class, remove
    the `pass` statement and replace it with your actual code.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的示例中，创建了三个类，通过直接在它们中写入 `pass` 语句，目前它们什么也不做。这是一个工具，可以添加到您的工具箱中，用于编写骨架代码，并允许其他组件在您编写代码时继续运行。如果类中没有放置任何内容，Python
    会给出错误；当您准备好为该类编写代码时，请删除 `pass` 语句，并用您的实际代码替换它。
- en: 'The names given to model classes can be almost anything you would like, but
    they cannot be any of the reserved Python keywords, such as `True`, `False`, `class`,
    `pass`, and `import`. Name your classes anything that makes sense when you are
    using them elsewhere in your code. You can use uppercase or lowercase letters,
    but when Django creates your tables, the names will always be lowercase. This
    is why it is unacceptable to name two different classes the same name with different
    letter casings. For example, if we named two classes `class Vehicle` and `class
    vehicle`, Django would then tell us we have the following `RuntimeError` when
    attempting to make migrations:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给模型类的名称几乎可以是您想要的任何名称，但不能是 Python 的保留关键字，例如 `True`、`False`、`class`、`pass` 和
    `import`。在您的代码中其他地方使用时，请为您的类命名任何有意义的名称。您可以使用大写或小写字母，但 Django 创建您的表时，名称将始终是小写的。这就是为什么不允许用不同的字母大小写来命名两个不同的类。例如，如果我们命名两个类
    `class Vehicle` 和 `class vehicle`，当 Django 尝试进行迁移时，会告诉我们以下 `RuntimeError`：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is why it is better to adopt a writing style that uses one or the other
    letter casing and stick with that pattern throughout your project.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好采用一种使用一个或另一个字母大小写的写作风格，并在整个项目中坚持这种模式。
- en: Let's discuss the various field types that exist and see which ones we can use
    for our vehicle exercises.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论现有的各种字段类型，并看看哪些我们可以用于我们的车辆练习。
- en: Standard field types
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准字段类型
- en: 'Right out of the box, Django offers numerous **Standard Field Types** to choose
    from. The following tables can be used as cheat sheets when writing your models:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 开箱即用，Django 提供了众多可供选择的**标准字段类型**。以下表格可以在编写模型时作为速查表使用：
- en: '![](img/B17243_03_Table1.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17243_03_Table1.jpg)'
- en: '![](img/B17243_03_Table2.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17243_03_Table2.png)'
- en: 'For a complete breakdown of all of the field types to choose from, you can
    visit the official Django documentation on field types here: [https://docs.djangoproject.com/en/4.0/ref/models/fields/](https://docs.djangoproject.com/en/4.0/ref/models/fields/).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 若要详细了解所有可选择的字段类型，您可以访问官方 Django 文档中的字段类型部分，链接如下：[https://docs.djangoproject.com/en/4.0/ref/models/fields/](https://docs.djangoproject.com/en/4.0/ref/models/fields/).
- en: Field arguments
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字段参数
- en: Every field class will accept `verbose_name`, `blank`, and `null` arguments
    on our fields quite often. `verbose_name` will specify the human-readable name
    for a field. We should specify a `max_length` argument for any `CharField` instances
    that we use, to limit the character length of that field. Without setting a `max_length`
    argument, the character length limit is theoretically unlimited. However, you
    are limited by the physical restrictions of the database that you are using; the
    limit would then be several thousand or hundreds of thousands of characters instead
    of the literal infinite limit. The `null` and `blank` arguments are almost considered
    the same thing, except that the `null` argument says that the database can store
    a null value for any empty records. The `blank` argument is related to validation
    performed on that field, at the database level, to check whether a user attempted
    to enter a null value when saving or creating that record in the database.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字段类都会在我们的字段上经常接受 `verbose_name`、`blank` 和 `null` 参数。`verbose_name` 将指定字段的可读名称。对于任何我们使用的
    `CharField` 实例，我们应该指定一个 `max_length` 参数，以限制该字段的字符长度。如果没有设置 `max_length` 参数，理论上字符长度限制是无限的。然而，您受到所使用数据库的物理限制；限制将是几千或几十万个字符，而不是字面上的无限限制。`null`
    和 `blank` 参数几乎被认为是同一件事，除了 `null` 参数表示数据库可以为任何空记录存储一个空值。`blank` 参数与在数据库级别对该字段进行的验证相关，以检查用户在保存或创建数据库中的该记录时是否尝试输入空值。
- en: A `default` argument will be used to assign a value to a field by default, should
    a value not be provided at the time an object is created or updated. Default values
    are used in circumstances where, say, data is being migrated into your database
    from an outside source, with data that isn't in synchronization with the constraints
    set on your tables. For example, if you had a field argument set to `null=False`
    and you imported data that contained a null value, errors would likely result.
    Say you had a `BooleanField` with the `default=True`/`False` argument, and then
    performed the same data import; then, all those null values would be converted
    to `True`/`False` automatically during your import. A `default` argument can be
    applied to virtually every field type.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`default`参数将用于在创建或更新对象时未提供值的情况下，默认分配一个值给字段。默认值用于数据从外部源迁移到您的数据库的情况，其中数据与您在表上设置的约束不一致。例如，如果您有一个字段参数设置为`null=False`，并且导入了包含空值的数据，则可能会出现错误。假设您有一个带有`default=True`/`False`参数的`BooleanField`，然后执行相同的数据导入；那么，所有这些空值将在导入过程中自动转换为`True`/`False`。`default`参数几乎可以应用于任何字段类型。'
- en: The `choices` argument allows us to pass in a predefined set of choices that
    contain a value and a human-readable interpretation of that value. Choices can
    be used on `CharField` and `BooleanField` instances, as well as a handful of other
    field types. They can be made into a drop-down select box or be used in a collection
    of checkboxes or radio buttons. The `choices` argument accepts a list of tuples,
    where each tuple consists of the first element being the value of the field and
    the second element being the human-readable string representation of that value.
    For this exercise, we will be converting the human-interpreted *yes/no* choices
    into a computer-interpreted *true/false* value on a `BooleanField`. We will also
    apply this technique to the manufacturer/make field later in this chapter, in
    order to store an integer value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`choices`参数允许我们传递一个包含值和该值的人类可读解释的预定义选择集。选择可以在`CharField`和`BooleanField`实例上使用，以及一些其他字段类型。它们可以被制作成下拉选择框，或者用于一组复选框或单选按钮。`choices`参数接受一个元组的列表，其中每个元组的第一个元素是字段的值，第二个元素是该值的人类可读字符串表示。在这个练习中，我们将把人类可解释的*是/否*选择转换为计算机可解释的*真/假*值，在`BooleanField`上。我们还将在此章的后面部分应用这种技术，以便在制造商/制造字段上存储整数值。'
- en: Another argument that can be useful is the `editable=False` attribute. This
    attribute would render a field hidden in any form object within a template. This
    field would not be visible or editable by the user in any way. The `unique=True`
    argument can also be useful. This argument states that two rows/records in your
    table cannot have the same value for that particular field. This would be useful
    if, say, an email field is used as a unique identifier for a model, preventing
    duplicates from existing. We would get conflicting results with errors telling
    us that the email address already exists when saving or creating a new record.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能很有用的论点是`editable=False`属性。这个属性会在模板中的任何表单对象中隐藏字段。用户将无法以任何方式查看或编辑该字段。`unique=True`参数也可能很有用。这个参数表示表中两行/记录在该特定字段上不能有相同的值。例如，如果将电子邮件字段用作模型的唯一标识符，可以防止重复的存在。在保存或创建新记录时，我们可能会得到冲突的结果，错误信息会告诉我们电子邮件地址已存在。
- en: Model field arguments differ from form field arguments in that the model arguments
    will apply rules to your columns on the database level. Your form field arguments,
    which we will cover in [*Chapter 5*](B17243_05_ePub.xhtml#_idTextAnchor152), *Django
    Forms*, are rules that only apply to a field as it is used within a particular
    form. This means you can set `blank=True` on a model field, making it not required
    on the database level but in a `required=True` form field set, making it required
    for that particular form. Alternatively, we could make that field required in
    all forms by setting the constraint at the database level using `blank=False`.
    Keep that in mind when writing your model classes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 模型字段参数与表单字段参数不同，因为模型参数将在数据库级别应用规则到您的列上。我们将在[*第五章*](B17243_05_ePub.xhtml#_idTextAnchor152)“Django表单”中介绍您的表单字段参数，这些参数是仅适用于特定表单中字段的规则。这意味着您可以在模型字段上设置`blank=True`，使其在数据库级别不是必需的，但在`required=True`的表单字段集中是必需的，使其对该特定表单是必需的。或者，我们可以通过在数据库级别使用`blank=False`设置约束，使该字段在所有表单中都是必需的。在编写模型类时请记住这一点。
- en: Next, let's begin writing the different fields that are needed for our vehicle
    scenario.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们开始编写我们车辆场景所需的各个字段。
- en: Adding a standard field type
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加标准字段类型
- en: From the Django fields list provided earlier, we will use `CharField` for each
    of the models. `CharField` will be used to provide a name for each item as we
    add them to the database, except for the `Vehicle` model class. For the `Vehicle`
    model, we will use `CharField` as the `BooleanField` on the `Vehicle` model, to
    store a value indicating whether or not this vehicle has been sold. This is the
    field where we will create a list of *yes/no* choices to use instead of the *true/false*
    values.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面提供的 Django 字段列表中，我们将为每个模型使用 `CharField`。`CharField` 将用于在将每个项目添加到数据库时提供名称，除了
    `Vehicle` 模型类。对于 `Vehicle` 模型，我们将使用 `CharField` 作为 `BooleanField` 在 `Vehicle`
    模型上，以存储一个值，表示该车辆是否已售出。这就是我们将创建一个 *是/否* 选项列表来代替 *true/false* 值的字段。
- en: 'Follow these steps to create the fields for each of your model classes. Remember
    to remove the `pass` statement:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤为每个模型类创建字段。记住要删除 `pass` 语句：
- en: 'In your `/chapter_3/models.py` file, create the set of *yes/no* choices above
    your model classes and below your `import` statements, as depicted:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_3/models.py` 文件中，在你的模型类上方和 `import` 语句下方创建上述 *是/否* 选项集，如图所示：
- en: '[PRE2]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the following field to your `VehicleModel` class:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下字段添加到你的 `VehicleModel` 类中：
- en: '[PRE3]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following field to your `Engine` class:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下字段添加到你的 `Engine` 类中：
- en: '[PRE4]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following fields to your `Vehicle` class:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下字段添加到你的 `Vehicle` 类中：
- en: '[PRE5]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `name` field on the `VehicleModel` class shown previously will use the `unique`
    argument, allowing only names that do not already exist in that table. The `name`
    field on the `Engine` class will not use the `unique` argument, so we can allow
    engines of the same name but assign them to different vehicle models. The `YESNO_CHOICES`
    variable is used as a global variable placed outside of any model class so that
    it can be used in many fields if needed. If a variable or set of choices is extremely
    unique, then it is best practice to place it above your field declarations, within
    the model class that is it being used in. You could also store these variables
    in an entirely separate file as well, as long as the code remains clean and simple.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的 `VehicleModel` 类上的 `name` 字段将使用 `unique` 参数，只允许在该表中不存在的名称。`Engine` 类上的
    `name` 字段将不会使用 `unique` 参数，因此我们可以允许具有相同名称的引擎，但将它们分配给不同的车辆模型。`YESNO_CHOICES` 变量用作全局变量，放置在任何模型类之外，以便在需要时可以在多个字段中使用。如果变量或选项集非常独特，那么将它们放置在字段声明上方，在使用的模型类中是最佳实践。你也可以将这些变量存储在一个完全独立的文件中，只要代码保持整洁简单。
- en: Note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding code is a relaxed style of the PEP-8 style guide where we are
    placing each argument on its own line, separated by a comma while also following
    basic Python indentation rules. Most of the code throughout this book will be
    written in this way.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是 PEP-8 风格指南的宽松风格，我们将每个参数放在单独的一行上，用逗号分隔，同时遵循基本的 Python 缩进规则。本书中的大部分代码将以这种方式编写。
- en: 'Run the Django `makemigration` and `migrate` commands, as shown:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Django 的 `makemigration` 和 `migrate` 命令，如下所示：
- en: '[PRE6]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Every time a model is changed, created, or deleted, these Django migration commands
    will need to be executed in order to prevent runtime errors. They can be executed
    from either your IDE or within a command line or terminal window, executed from
    within your project's root directory, where your `manage.py` file lives. Refer
    to [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*,
    in the subsection titled *Building initial table structures* to learn more about
    the different ways to execute these commands.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每当模型被更改、创建或删除时，都需要执行这些 Django 迁移命令以防止运行时错误。这些命令可以从你的 IDE 或命令行或终端窗口中执行，在项目根目录下执行，其中包含你的
    `manage.py` 文件。参考[*第 2 章*](B17243_02_ePub.xhtml#_idTextAnchor037)，*项目配置*部分，标题为*构建初始表结构*的子部分，了解更多关于执行这些命令的不同方法。
- en: 'If those two Django migration commands were successful, three more tables will
    have been created in your database. When viewed from within your PgAdmin tool
    or any other database management tool that you decided to use, those tables will
    look similar to as in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个 Django 迁移命令执行成功，你的数据库中将会创建三个额外的表。从 PgAdmin 工具或任何其他你决定使用的数据库管理工具中查看，这些表将类似于以下截图所示：
- en: '![Figure 3.1 – PgAdmin – created vehicle, model, and engine tables'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – PgAdmin – 创建车辆、模型和引擎表'
- en: '](img/Figure_3.1_B17243.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – PgAdmin – 创建车辆、模型和引擎表](img/Figure_3.1_B17243.jpg)'
- en: Figure 3.1 – PgAdmin – created vehicle, model, and engine tables
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – PgAdmin – 创建车辆、模型和引擎表
- en: If we needed to use fields that don't come standard in Django, such as `AddressField`,
    `MoneyField`, or `PhoneField`, we would have to install packages and also configure
    settings before we can use them. Let's prepare our project next to let us do just
    that, by integrating `MoneyField` into these examples.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要使用Django标准中不包含的字段，例如`AddressField`、`MoneyField`或`PhoneField`，我们必须安装包并配置设置，然后才能使用它们。让我们准备我们的项目，以便通过将这些示例中的`MoneyField`集成进来，做到这一点。
- en: Third-party field types
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方字段类型
- en: 'A `django-address` package uses the Google Maps API to suggest addresses related
    to what the user has typed as the user is typing into a single text field. This
    means that the package provides the model class as well as the form field class
    it creates and any other related tools. Related tools such as, all of the JavaScript
    and CSS libraries that help a form work. The `django-image-cropping` tool is also
    very powerful: it allows a user to upload an image and let the user crop the image
    however they desire.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`django-address`包使用Google Maps API在用户输入单个文本字段时建议与用户输入相关的地址。这意味着该包提供了模型类以及它创建的表单字段类和其他相关工具。相关工具包括所有帮助表单工作的JavaScript和CSS库。`django-image-cropping`工具也非常强大：它允许用户上传图片，并让用户按照自己的意愿裁剪图片。'
- en: There is a package specifically made to handle currency called `django-money`.
    This package takes `DecimalField` from the list of standard field types and provides
    many different actions that involve working with money in a financial industry-accepted
    way. The `django-money` package provides definitions for all currencies that exist
    today and includes their corresponding currency sign. In addition to performing
    arithmetic operations, such as addition and subtraction, currencies can also be
    converted from one sign to another using current exchange rates. This means that
    this package will communicate with an API to retrieve that information.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个专门用于处理货币的包叫做`django-money`。这个包从标准字段类型列表中取出了`DecimalField`，并提供了许多涉及金融行业接受方式的金钱操作。`django-money`包为今天存在的所有货币提供了定义，并包括它们对应的货币符号。除了执行加法、减法等算术运算外，货币还可以使用当前汇率从一种符号转换为另一种符号。这意味着这个包将与API通信以检索该信息。
- en: The `django-phone-field` package will accept a phone number that is rather versatile.
    The phone field allows for country codes and accepts special characters so that
    it can be masked to any format you need. The `django-ckeditor` package is a tool
    used for adding rich text editors to your pages, allowing users to enter HTML
    into one of your form fields. If you're using django CMS, they also make a version
    of the django-ckeditor package specifically for use with the django CMS package.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`django-phone-field`包可以接受相当灵活的电话号码。电话字段允许使用国家代码，并接受特殊字符，以便可以将其掩码为所需的任何格式。`django-ckeditor`包是一个用于向您的页面添加富文本编辑器的工具，允许用户将HTML输入到您的表单字段之一。如果您使用的是django
    CMS，他们还提供了一个专门用于与django CMS包一起使用的django-ckeditor包版本。'
- en: 'Here is a short list of third-party field types to add to your field type cheat
    sheet from before:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简短的第三方字段类型列表，您可以将其添加到之前的字段类型速查表中：
- en: '`AddressField` – [https://pypi.org/project/django-address/](https://pypi.org/project/django-address/)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddressField` – [https://pypi.org/project/django-address/](https://pypi.org/project/django-address/)'
- en: '`ImageCropField` – [https://pypi.org/project/django-image-cropping/](https://pypi.org/project/django-image-cropping/)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageCropField` – [https://pypi.org/project/django-image-cropping/](https://pypi.org/project/django-image-cropping/)'
- en: '`MoneyField` – [https://pypi.org/project/django-money/](https://pypi.org/project/django-money/)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MoneyField` – [https://pypi.org/project/django-money/](https://pypi.org/project/django-money/)'
- en: '`PhoneField` – [https://pypi.org/project/django-phone-field/](https://pypi.org/project/django-phone-field/)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PhoneField` – [https://pypi.org/project/django-phone-field/](https://pypi.org/project/django-phone-field/)'
- en: '`RichTextField` – [https://pypi.org/project/django-ckeditor/](https://pypi.org/project/django-ckeditor/)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RichTextField` – [https://pypi.org/project/django-ckeditor/](https://pypi.org/project/django-ckeditor/)'
- en: (*django CMS*) `RichTextField` – [https://pypi.org/project/djangocms-text-ckeditor/](https://pypi.org/project/djangocms-text-ckeditor/)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (*django CMS*) `RichTextField` – [https://pypi.org/project/djangocms-text-ckeditor/](https://pypi.org/project/djangocms-text-ckeditor/)
- en: Next, we will add `MoneyField` to our `Vehicle` model class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向我们的`Vehicle`模型类中添加`MoneyField`。
- en: Adding a third-party field type
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加第三方字段类型
- en: Since some of the fields, such as `AddressField`, require obtaining a personal
    Google API key directly from Google, we will not be using that field type. We
    will only demonstrate using one of these third-party field types and then move
    on to the next topic.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一些字段，如 `AddressField`，需要直接从 Google 获取个人 Google API 密钥，因此我们不会使用该字段类型。我们只会演示使用这些第三方字段类型之一，然后继续下一个主题。
- en: 'To include `MoneyField` in a project, follow these steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中包含 `MoneyField`，请按照以下步骤操作：
- en: 'Add `django-money` to your `requirements.txt` file and install it in your virtual
    environment or run the following command to manually install this package. Make
    sure your virtual environment is already activated:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `django-money` 添加到你的 `requirements.txt` 文件中，并在你的虚拟环境中安装它，或者运行以下命令手动安装此包。确保你的虚拟环境已经激活：
- en: '[PRE7]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In your `settings.py` file, add the following app to your `INSTALLED_APPS`
    list:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `settings.py` 文件中，将以下应用添加到你的 `INSTALLED_APPS` 列表中：
- en: '[PRE8]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Make sure it is located above your local apps and below all of your `django.contrib`
    apps, as shown previously, where it is placed before the `chapter_3` app.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 确保它位于你的本地应用之上，并在所有 `django.contrib` 应用之下，如前所述，它放置在 `chapter_3` 应用之前。
- en: 'Using `MoneyField`, you can specify the different currencies available in your
    project within the `settings.py` file. In the following example, we specify the
    US dollar and European euro as the two currencies available in this project:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `MoneyField`，你可以在 `settings.py` 文件中指定项目中可用的不同货币。在以下示例中，我们指定美元和欧元为该项目中可用的两种货币：
- en: '[PRE9]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following highlighted `import` statement to the top of your `/chapter_3/models.py`
    file:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下高亮的 `import` 语句添加到你的 `/chapter_3/models.py` 文件顶部：
- en: '[PRE10]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In your `Vehicle` class, add the price field shown here:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `Vehicle` 类中，添加以下价格字段：
- en: '[PRE11]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You will also need to use the field arguments depicted in the preceding example
    (adjust the values as needed).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要使用前面示例中描述的字段参数（根据需要调整值）。
- en: Let's explore what validation we can apply to the field types that we are using.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索我们可以应用于我们正在使用的字段类型的验证。
- en: Model field validators
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型字段验证器
- en: 'Field validators are database-level rules that can be set on model fields.
    They are useful in situations where instead of `DecimalField`, using a `max_length`
    argument to control the character length, we are defining a minimum or maximum
    numeric value. A Django `ValidationError` if that criterion is not met. Since
    this is a callable, you can write your own function to suit your needs or use
    one of the many different callable functions that come included with Django. For
    instance, we could use the `MinValueValidator` and `MaxValueValidator` functions
    when specifying a constraint for a minimum or maximum numeric value. You can view
    a complete list of validator functions provided by Django here: [https://docs.djangoproject.com/en/4.0/ref/validators/](https://docs.djangoproject.com/en/4.0/ref/validators/).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 字段验证器是数据库级别的规则，可以在模型字段上设置。在需要使用 `DecimalField` 而不是使用 `max_length` 参数来控制字符长度的情况下，它们非常有用。我们定义一个最小或最大数值。如果不符合该标准，Django
    将抛出 `ValidationError`。由于这是一个可调用的对象，你可以编写自己的函数来满足你的需求，或者使用 Django 内置的许多不同的可调用函数之一。例如，当指定最小或最大数值约束时，我们可以使用
    `MinValueValidator` 和 `MaxValueValidator` 函数。你可以在以下位置查看 Django 提供的完整验证器函数列表：[https://docs.djangoproject.com/en/4.0/ref/validators/](https://docs.djangoproject.com/en/4.0/ref/validators/)。
- en: Setting a field validator
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置字段验证器
- en: '`MoneyField` offers a few of its own field validators that add constraints
    on currency values of whatever type is defined in your project. The money validators
    take the leg work out of using a Django `DecimalValidator` or writing your own
    callable method.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoneyField` 提供了一些自己的字段验证器，这些验证器对项目中定义的任何类型的货币值添加了约束。货币验证器简化了使用 Django `DecimalValidator`
    或编写自己的可调用方法的过程。'
- en: 'Follow these steps to set your validator on the existing `Vehicle` model:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在现有的 `Vehicle` 模型上设置验证器：
- en: 'At the top of your `/chapter_3/models.py` file, and just below your existing
    `import` statements, add the following `import` statement:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_3/models.py` 文件顶部，并在现有的 `import` 语句下方，添加以下 `import` 语句：
- en: '[PRE12]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Whether it is a standard Django field validator or another one provided by
    a third-party package, it will go in the validator argument of a field, as shown
    on the `price` field of the `Vehicle` model here:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不论是标准的 Django 字段验证器还是由第三方包提供的验证器，它都将作为字段参数传入，如下所示，这是在 `Vehicle` 模型的 `price`
    字段中：
- en: '[PRE13]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These functions usually take in one or more arguments themselves. In this example,
    we are specifying the parameters for the minimum and maximum currency values.
    The preceding example states that all Euro (`EUR`) values should be between 500
    and 500,000 Euros and the American dollar values (`USD)` should be between 400
    and 400,000 dollars. These are rough estimates used for demonstration only and
    are not exact conversion rates.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数通常自己接受一个或多个参数。在这个例子中，我们指定了最小和最大货币值的参数。前面的例子指出，所有欧元（`EUR`）值应在500到500,000欧元之间，美元值（`USD`）应在400到400,000美元之间。这些只是用于演示的粗略估计，并不代表确切的转换率。
- en: Currently, our three model classes exist independently from one another. This
    means they are not linked to each other in any way just yet. We will need them
    to be related to one another before we are done. Next, we will be linking those
    tables by working with model field relationships.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的三个模型类彼此独立存在。这意味着它们目前还没有以任何方式相互链接。在我们完成之前，我们需要使它们相互关联。接下来，我们将通过处理模型字段关系来链接这些表。
- en: Working with model field relationships
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理模型字段关系
- en: 'Django provides three relationship types for linking tables:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了三种关系类型用于链接表：
- en: '**Many****–****to****–****one**'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对一**关系'
- en: '**Many****–****to****–****many**'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对多**关系'
- en: '**One****–****to****–****one**'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对一**关系'
- en: A *many-to-one* relationship is defined by using a `ForeignKey` field, and the
    other two relationship types are defined using the self-explanatory `ManyToManyField`
    and `OneToOneField`. These fields are named appropriately after the relationship
    type that they represent.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ForeignKey`字段定义一个**多对一**关系，其他两种关系类型则使用自解释的`ManyToManyField`和`OneToOneField`定义。这些字段根据它们所代表的关系类型适当地命名。
- en: Next, we will discuss the key components of working with model field relationships.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论处理模型字段关系的关键组件。
- en: Field arguments
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段参数
- en: The three field types, `ForeignKey`, `ManyToManyField`, and `OneToOneField`,
    all accept the standard `default`, `blank`, and `verbose_name` field arguments
    that other field types accept. The `null` argument will have no effect on a `ManyToManyField`
    and will only apply to the `ForeignKey` and `OneToOneField` types. Two of these
    field types—`ForeignKey` and `OneToOneField`—require at least two positional arguments,
    the first being the model class that the field relates to and the second being
    the `on_delete` argument. Positional means they need to be in that order and required
    means they must be specified. The `on_delete` argument specifies what the database
    will do with records from related tables if a parent or child object is deleted.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 三种字段类型，`ForeignKey`、`ManyToManyField`和`OneToOneField`，都接受其他字段类型接受的标准的`default`、`blank`和`verbose_name`字段参数。`null`参数对`ManyToManyField`没有影响，只会应用于`ForeignKey`和`OneToOneField`类型。这两种字段类型中的两种——`ForeignKey`和`OneToOneField`——至少需要两个位置参数，第一个是字段相关的模型类，第二个是`on_delete`参数。位置参数意味着它们需要按顺序排列，必要参数意味着它们必须指定。`on_delete`参数指定了当删除父或子对象时，数据库将如何处理相关表中的记录。
- en: 'The `on_delete` choices include the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_delete`选项包括以下内容：'
- en: '`models.CASCADE` – used to automatically delete any related objects when an
    object is deleted from that table.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.CASCADE` – 当从该表中删除对象时，用于自动删除任何相关对象。'
- en: '`models.PROTECT` – used to prevent deletion of any of the objects.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.PROTECT` – 用于防止删除任何对象。'
- en: '`models.RESTRICT` – used to prevent deletion in certain scenarios.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.RESTRICT` – 用于在特定场景中防止删除。'
- en: '`models.SET_DEFAULT` – used to set the field of related objects to a default
    value.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.SET_DEFAULT` – 用于将相关对象的字段设置为默认值。'
- en: '`models.SET_NULL` – used to set the field of related objects to a null value.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.SET_NULL` – 用于将相关对象的字段设置为空值。'
- en: '`models.SET()` – accepts a callable to write your own function for setting
    a value.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.SET()` – 接受一个可调用的函数，用于设置值。'
- en: '`models.DO_NOTHING` – will take no action; using this option could cause **IntegrityError**
    and should be used with caution.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.DO_NOTHING` – 不会采取任何行动；使用此选项可能会导致**IntegrityError**，应谨慎使用。'
- en: We will set the value for the `on_delete` argument to `models.CASCADE`, ensuring
    that if a `Vehicle` is deleted from the database, nothing will happen to the related
    `VehicleModel` and `Engine` objects. But if we deleted a `VehicleModel` or `Engine`
    object from the database, the related `Vehicle` that depends on that soon-to-be-deleted
    object will also be deleted. If we want to preserve `Vehicle` in the scenario
    of when either of those two is deleted, we should use the `models.SET_DEFAULT`
    value instead.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `on_delete` 参数的值设置为 `models.CASCADE`，确保如果从数据库中删除一个 `Vehicle`，相关的 `VehicleModel`
    和 `Engine` 对象将不会受到影响。但如果从数据库中删除一个 `VehicleModel` 或 `Engine` 对象，依赖于即将删除的对象的相关 `Vehicle`
    也会被删除。如果我们想在删除其中任何一个的情况下保留 `Vehicle`，我们应该使用 `models.SET_DEFAULT` 值。
- en: The three field types—`ForeignKey`, `ManyToManyField`, and `OneToOneField`—all
    allow for us to follow relationships forward and backward when performing queries,
    which means if you query a parent object, you can follow that lookup forward to
    get all of its child objects. A reverse lookup would mean you query a child object
    and follow its lookup backward to get its parent object. These forward and reverse
    relationships are defined on fields by using the `related_name` and `related_query_name`
    arguments, which will soon be demonstrated.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 三个字段类型—`ForeignKey`、`ManyToManyField` 和 `OneToOneField`—都允许我们在执行查询时向前和向后跟踪关系，这意味着如果你查询一个父对象，你可以跟随这个查找向前以获取所有子对象。反向查找意味着你查询一个子对象，并跟随其查找向后以获取其父对象。这些向前和反向关系是通过使用
    `related_name` 和 `related_query_name` 参数在字段上定义的，这将在下面演示。
- en: A `ForeignKey` field and `ManyToManyField` can accept a `limit_choices_to` argument,
    which applies a filter to the related queries. The `limit_choices_to` argument
    will accept a dictionary or Q object. It will also accept a callable function
    that returns either a dictionary or Q object.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForeignKey` 字段和 `ManyToManyField` 可以接受一个 `limit_choices_to` 参数，该参数对相关查询应用一个过滤器。`limit_choices_to`
    参数将接受一个字典或 Q 对象。它还可以接受一个可调用的函数，该函数返回一个字典或 Q 对象。'
- en: Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'A `filter()`, `all()`, or `order_by()` statement cannot provide. To learn more
    about complex lookups with Q objects, visit the official Django documentation
    here: [https://docs.djangoproject.com/en/4.0/topics/db/queries/#complex-lookups-with-q-objects](https://docs.djangoproject.com/en/4.0/topics/db/queries/#complex-lookups-with-q-objects).
    To learn more about performing queries in general, jump ahead to the section titled
    *Performing queries* later in this chapter.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`、`all()` 或 `order_by()` 语句无法提供。要了解更多关于使用 Q 对象进行复杂查找的信息，请访问官方 Django
    文档：[https://docs.djangoproject.com/en/4.0/topics/db/queries/#complex-lookups-with-q-objects](https://docs.djangoproject.com/en/4.0/topics/db/queries/#complex-lookups-with-q-objects)。要了解更多关于执行查询的一般信息，请跳转到本章后面的标题为
    *执行查询* 的部分。'
- en: Continuing on with our vehicle classes, we can apply some of these model relations
    and arguments to the classes we already wrote. They will help us link a hypothetical
    `Seller` to a `Vehicle`, a `Vehicle` to a `VehicleModel`, and that `VehicleModel`
    to an `Engine`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用我们的车辆类，我们可以将这些模型关系和参数应用到我们已编写的类中。它们将帮助我们将一个假设的 `Seller` 与 `Vehicle`、`Vehicle`
    与 `VehicleModel` 以及 `VehicleModel` 与 `Engine` 相关联。
- en: Field type – ForeignKey
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段类型 – ForeignKey
- en: We will be using a `ForeignKey` field to represent a *many-to-one* relationship
    between the `Vehicle` class and the `VehicleModel` and `Engine` classes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `ForeignKey` 字段来表示 `Vehicle` 类与 `VehicleModel` 和 `Engine` 类之间的 *多对一* 关系。
- en: 'Follow these steps to create your `ForeignKey` field:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建你的 `ForeignKey` 字段：
- en: 'In your `/chapter_3/models.py` file, add the following two fields to your existing
    `Vehicle` model class, as shown:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_3/models.py` 文件中，将以下两个字段添加到现有的 `Vehicle` 模型类中，如下所示：
- en: '[PRE14]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In your `/chapter_3/models.py` file, add the following field to your existing
    `Engine` model class, as shown:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_3/models.py` 文件中，将以下字段添加到现有的 `Engine` 模型类中，如下所示：
- en: '[PRE15]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, run your Django migration commands one more time, as discussed in the
    subsection titled *Building initial table structures* in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037),
    *Project Configuration*. You can see the two fields that we created, `vehicle_model`
    and `engine`, are now in the list of columns shown in our database management
    tool:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次运行你的 Django 迁移命令，如在第 2 章的子节标题为 *构建初始表结构* 中所述，*项目配置*。你可以看到我们创建的两个字段，`vehicle_model`
    和 `engine`，现在显示在我们的数据库管理工具的列列表中：
- en: '![Figure 3.2 – PgAdmin – ForeignKey field'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.2 – PgAdmin – ForeignKey field'
- en: '](img/Figure_3.2_B17243.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.2 – PgAdmin – ForeignKey field'
- en: Figure 3.2 – PgAdmin – ForeignKey field
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – PgAdmin – ForeignKey字段
- en: In the preceding screenshot, these fields are shown as `vehicle_model_id` and
    `engine_id`. The `_id` suffix automatically gets added to the column name in your
    database.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的屏幕截图中，这些字段被显示为 `vehicle_model_id` 和 `engine_id`。`_id` 后缀会自动添加到你的数据库中的列名。
- en: Field type – ManyToManyField
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段类型 – ManyToManyField
- en: Here, we will represent a *many-to-many* field relationship between a seller
    and the vehicles they are selling with a `ManyToManyField` type. `ManyToManyField`
    will not accept the `on_delete` argument. Instead, when a child or parent is deleted,
    the other will always remain in your database since many other objects could relate
    to it as well.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用 `ManyToManyField` 类型来表示卖家和他们所销售的车辆之间的 *多对多* 字段关系。`ManyToManyField`
    不会接受 `on_delete` 参数。相反，当子项或父项被删除时，另一项将始终保留在你的数据库中，因为许多其他对象也可能与之相关。
- en: 'Follow these steps to create `ManyToManyField`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '按照以下步骤创建 `ManyToManyField`:'
- en: 'In your `/chapter_3/models.py` file, create a new `Seller` model class with
    a `name` field and a `vehicle` field to use as your *many-to-many* relationship.
    Your code should now resemble the following example:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_3/models.py` 文件中，创建一个新的 `Seller` 模型类，包含一个 `name` 字段和一个 `vehicle`
    字段，用于作为你的 *多对多* 关系。你的代码现在应该类似于以下示例：
- en: '[PRE16]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We will link `ManyToManyField` to the `Vehicle` model class in the first positional
    argument. It's given a `related_name` argument with a value of `vehicle_sellers`
    and a `related_query_name` argument with a value of `vehicle_seller`. These two
    arguments are used for linking and mapping to this field later on in [*Chapter
    10*](B17243_10_ePub.xhtml#_idTextAnchor293), *Database Management*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `ManyToManyField` 链接到 `Vehicle` 模型类在第一个位置参数。它被赋予一个 `related_name` 参数，其值为
    `vehicle_sellers`，以及一个 `related_query_name` 参数，其值为 `vehicle_seller`。这两个参数用于稍后在
    [*第10章*](B17243_10_ePub.xhtml#_idTextAnchor293)，*数据库管理* 中链接和映射到该字段。
- en: 'Go ahead and run your Django migration commands one more time. You should see
    the columns that were created for this table in your database management tool,
    similar to the following screenshot:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行你的 Django 迁移命令。你应该在你的数据库管理工具中看到为该表创建的列，类似于以下屏幕截图：
- en: '![Figure 3.3 – pgAdmin – ManyToManyField'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – pgAdmin – ManyToManyField'
- en: '](img/Figure_3.3_B17243.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – pgAdmin – ManyToManyField](img/Figure_3.3_B17243.jpg)'
- en: Figure 3.3 – pgAdmin – ManyToManyField
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – pgAdmin – ManyToManyField
- en: We should also see any additional tables that automatically get created, which
    are used to manage the relationships between `Seller` and `Vehicle`. That table
    is shown in the preceding screenshot as **chapter_3_seller_vehicle**.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该看到任何自动创建的附加表，这些表用于管理 `Seller` 和 `Vehicle` 之间的关系。该表在先前的屏幕截图中被显示为 **chapter_3_seller_vehicle**。
- en: Mutable versus immutable objects
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变对象与不可变对象
- en: '**Mutability** is a fundamental concept of the Python language and is broken
    down into mutable and immutable objects. An object is said to be **mutable** if
    its values can change over time. If an object''s value will not change, then that
    object is said to be **immutable**. In Python, an object''s mutability is also
    defined by the data type that it is. For example, mutable objects are represented
    using a *list*, *dictionary*, *set*, or *QuerySet*. Immutable objects are defined
    by using the *bool*, *decimal*, *float*, *int*, *range*, *string*, and *tuple*
    data types. Queries will perform better if the object being searched is immutable
    rather than mutable. Most of the time, the difference is miniscule, literally
    in nano-or milliseconds. When your project goes live and your database starts
    to collect thousands, if not millions, of records, the time it takes to query
    something will then be noticed when it takes seconds, if not minutes or tens of
    minutes, to complete a single query.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**可变性** 是 Python 语言的一个基本概念，分为可变对象和不可变对象。如果一个对象的价值可以随时间改变，那么这个对象就被说成是 **可变的**。如果一个对象的价值不会改变，那么这个对象就被说成是
    **不可变的**。在 Python 中，一个对象的可变性也由其数据类型定义。例如，可变对象使用 *list*、*dictionary*、*set* 或 *QuerySet*
    来表示。不可变对象使用 *bool*、*decimal*、*float*、*int*、*range*、*string* 和 *tuple* 数据类型来定义。如果被搜索的对象是不可变的而不是可变的，查询将表现得更好。大多数时候，这种差异微乎其微，实际上在纳秒或毫秒级别。当你的项目上线并且数据库开始收集成千上万，甚至数百万条记录时，查询所需的时间将会在它需要几秒钟，甚至几分钟或十几分钟来完成单个查询时被注意到。'
- en: For example, we could represent a set of choices as a `PositiveIntegerField`
    using a tuple object to associate a human-readable string representation to a
    numeric integer value. Take the make/manufacturer of a vehicle that was mentioned
    earlier in this chapter. We don't really need a table to store this information
    unless we have other related information that needs to be stored or have a project
    requirement stating that the user should have the ability to add/edit these choices.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用元组对象将一组选择表示为 `PositiveIntegerField`，将可读的字符串表示与数值整数关联。以本章前面提到的车辆制造商为例。除非我们需要存储其他相关联的信息，或者有项目需求表明用户应该能够添加/编辑这些选择，否则我们实际上不需要一个表来存储这些信息。
- en: 'Hardcoding these values as an immutable data type can be done by following
    these steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤可以将这些值作为不可变数据类型硬编码：
- en: 'In the `/chapter_3/models.py` file, add the following set above your model
    classes and below your `import` statements:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/chapter_3/models.py` 文件中，在你的模型类上方和 `import` 语句下方添加以下设置：
- en: '[PRE17]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Use that set as the value of the `choices` argument of your `make` field within
    your `Vehicle` class, as shown:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该集合用作你的 `Vehicle` 类中 `make` 字段的 `choices` 参数的值，如下所示：
- en: '[PRE18]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, let's discuss what the `Meta` subclass is and how it is used to control
    the behavior of models even more than what we have already done.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论一下 `Meta` 子类是什么以及它是如何被用来控制模型行为，甚至比我们之前所做的一切都要多的。
- en: Using the Meta subclass
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Meta 子类
- en: '`Meta`. It is not required and completely optional but it does make using Django
    much more useful when it is included in your models. Metadata provides all of
    the "other" information that is not defined in model field arguments. The settings
    that are defined inside this class are called **meta options,** and there are
    quite a lot to choose from. We will go over only some of the most commonly used
    options in the following sections and how they can be helpful. A complete breakdown
    of all of the options is available here: [https://docs.djangoproject.com/en/4.0/ref/models/options/](https://docs.djangoproject.com/en/4.0/ref/models/options/).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Meta`。这不是必需的，完全可选，但它确实使得在模型中包含它时使用 Django 更加有用。元数据提供了所有在模型字段参数中未定义的“其他”信息。在这个类内部定义的设置被称为
    **元选项**，有很多可供选择。在接下来的几节中，我们将介绍一些最常用的选项以及它们如何有所帮助。所有选项的完整分解可在以下链接中找到：[https://docs.djangoproject.com/en/4.0/ref/models/options/](https://docs.djangoproject.com/en/4.0/ref/models/options/)。'
- en: Meta options – verbose_name and verbose_name_plural
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Meta 选项 – verbose_name 和 verbose_name_plural
- en: We can use the `verbose_name` and `verbose_name_plural` options to specify what
    human-readable text is used in areas of the Django admin site or if we look it
    up later in the code that we write. We will introduce the Django admin site in
    [*Chapter 6*](B17243_06_ePub.xhtml#_idTextAnchor190), *Exploring the Django Admin
    Site*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `verbose_name` 和 `verbose_name_plural` 选项来指定在 Django 管理站点区域中使用的可读文本，或者在我们稍后编写的代码中查找时使用的文本。我们将在
    [*第 6 章*](B17243_06_ePub.xhtml#_idTextAnchor190) 中介绍 Django 管理站点，*探索 Django 管理站点*。
- en: 'To add these options to your model classes, using the class named `VehicleModel`,
    set these two verbose options to read as `Vehicle Model` and `Vehicle Models`,
    as depicted:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这些选项添加到你的模型类中，使用名为 `VehicleModel` 的类，将这些详细选项设置为 `Vehicle Model` 和 `Vehicle
    Models`，如图所示：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, throughout your code and the Django admin site, these values will be used
    as the singular and plural representations of your object(s).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的代码和 Django 管理站点中，这些值将被用作你的对象（复数）的单数和复数表示。
- en: Meta option – ordering
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Meta 选项 – 排序
- en: The `ordering` option is used when obtaining a list of objects. This setting
    will accept one or many fields as a parameter to order by default if no other
    ordering rules have been specified when the query is performed. It will order
    in ascending order unless a dash (`–`) character has been placed before the value;
    if a dash is used, then the results will appear in descending order instead.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当获取对象列表时，使用 `ordering` 选项。如果没有指定其他排序规则，则默认情况下，此设置将接受一个或多个字段作为参数进行排序。如果没有放置破折号（`–`）字符，则将按升序排序；如果使用了破折号，则结果将按降序显示。
- en: 'To add this option to your model classes, we can order the `VehicleModel` class
    by `name` in ascending order, and then again in descending order, as shown in
    the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此选项添加到你的模型类中，我们可以按 `name` 字段对 `VehicleModel` 类进行升序排序，然后再按降序排序，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first example, commented out in the previous code block, shows us that we
    can order by additional fields, separated by a comma as well as in ascending order.
    The last example in the preceding code block depicts ordering the results in descending
    order alphabetically, from Z to A.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块中注释掉的第一个示例显示我们可以按额外的字段排序，字段之间用逗号分隔，也可以按升序排序。上述代码块中的最后一个示例描述了按字母顺序降序排序结果，从Z到A。
- en: Meta option – indexes
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元选项 – 索引
- en: The `indexes` option relates to a standard data architecture concept called
    `indexes` meta option.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexes`选项与一个称为`indexes`元选项的标准数据架构概念相关。'
- en: 'Follow these steps to add this option to your model classes:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将此选项添加到你的模型类中：
- en: 'To index the name field on the `VehicleModel` class, it would be written as
    shown here:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在`VehicleModel`类的名称字段上创建索引，可以写成如下所示：
- en: '[PRE34]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding example creates three separate indexes, one for the name in ascending
    order, one in descending order, and another for lowercase-only names in ascending
    order.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例创建了三个独立的索引，一个用于升序排列的名称，一个用于降序排列，另一个用于仅小写字母的名称的升序排列。
- en: 'Next, run your Django migration commands one more time. In your command-line
    or terminal window, the following messages should appear:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，再次运行你的Django迁移命令。在你的命令行或终端窗口中，应该出现以下消息：
- en: '[PRE35]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we don''t specify a `name=` attribute, as was not done in the first index
    of the preceding example, Django will name it using its default naming convention
    instead. This is what resulted in the name `chapter_3_v_name_055414_idx` for the
    first index message in the preceding example. The preceding example imports a
    class from the `django.db.models.functions` library, called `Lower`. The `Lower`
    class allows us to create an index on all of the lowercase character representations
    for the `name` field in the last index in the previous code block. There are numerous
    database functions that Django provides, and a complete breakdown of these functions
    can be found in the official Django documentation here: [https://docs.djangoproject.com/en/4.0/ref/models/database-functions/](https://docs.djangoproject.com/en/4.0/ref/models/database-functions/).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不指定`name=`属性，如前一个示例中的第一个索引未做的那样，Django将使用其默认命名约定来命名它。这就是前一个示例中第一个索引消息的结果，即名称为`chapter_3_v_name_055414_idx`。前一个示例从`django.db.models.functions`库中导入了一个名为`Lower`的类。`Lower`类允许我们在前一个代码块中的最后一个索引上创建所有小写字符表示的`name`字段的索引。Django提供了许多数据库函数，这些函数的完整说明可以在官方Django文档中找到：[https://docs.djangoproject.com/en/4.0/ref/models/database-functions/](https://docs.djangoproject.com/en/4.0/ref/models/database-functions/)。
- en: 'The indexes for each table are usually shown within a database management tool.
    For example, in PgAdmin, navigate the data tree from within the **Browser** tab
    to find the **chapter_3_vehiclemodel** indexes. It is a very deep navigation:
    go to **PostgreSQL 13** | **Databases** | **local_postgresql** | **Schemas** |
    **public** | **Tables** | **chapter_3_vehiclemodel** | **Indexes** and you should
    see your indexes, as shown in the following screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表的索引通常在数据库管理工具中显示。例如，在PgAdmin中，从**浏览器**选项卡中导航数据树以找到**chapter_3_vehiclemodel**索引。这是一个非常深的导航：转到**PostgreSQL
    13** | **数据库** | **local_postgresql** | **模式** | **public** | **表** | **chapter_3_vehiclemodel**
    | **索引**，你应该能看到你的索引，如下面的截图所示：
- en: '![Figure 3.4 – PgAdmin – model indexes'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 – PgAdmin – 模型索引'
- en: '](img/Figure_3.4_B17243.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_3.4_B17243.jpg)'
- en: Figure 3.4 – PgAdmin – model indexes
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – PgAdmin – 模型索引
- en: Meta option – db_table
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元选项 – db_table
- en: Sometimes, a project might have so many models that they start to conflict with
    each other or it just becomes too confusing to manage. The `db_table` option is
    used to specify the name of the table in a database. If this option is not set,
    by default Django will name your tables using the `{{ app_name }}_{{ model_name
    }}` naming convention. We can use this option to specify a unique table name on
    a case-by-case basis that differs from the default naming convention.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个项目可能有如此多的模型，它们开始相互冲突，或者管理起来变得过于混乱。`db_table`选项用于指定数据库中的表名。如果此选项未设置，则Django默认将使用`{{
    app_name }}_{{ model_name }}`命名约定来命名你的表。我们可以使用此选项在特定情况下指定一个独特的表名，该表名与默认命名约定不同。
- en: For example, let's create a new class named `engine2`, in lowercase this time.
    This way, we know that the lowercase classes are meant for side practice, separate
    from the main classes, which will be named with the first letter capitalized.
    Here, we will add the number `RuntimeError`, which was mentioned earlier in this
    chapter, in the *Writing model classes* section.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个名为`engine2`的新类，这次使用小写。这样，我们知道小写类是为了辅助练习，与主要类分开，主要类将以首字母大写命名。在这里，我们将添加之前在本章*编写模型类*部分中提到的`RuntimeError`。
- en: 'Follow these steps to add this option to your model classes:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将此选项添加到你的模型类中：
- en: 'In the `/chapter_3/models.py` file, create the `engine2` class and copy the
    name field from the `Engine` class into it, as shown:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/chapter_3/models.py`文件中，创建`engine2`类并将`Engine`类中的名称字段复制到其中，如下所示：
- en: '[PRE36]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create the `Meta` subclass and set the `db_table` option as depicted here.
    Do not use this option on the `Engine` class:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Meta`子类并设置`db_table`选项，如图所示。不要在`Engine`类上使用此选项：
- en: '[PRE37]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Set the value of `db_table` to `'chapter_3_practice_engine'`, as shown.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将`db_table`的值设置为`'chapter_3_practice_engine'`，如图所示。
- en: 'Next, run your Django migration commands one more time. In your database management
    tool, such as PgAdmin, the `chapter_3` tables should look similar to the following:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，再次运行你的Django迁移命令。在你的数据库管理工具，如PgAdmin中，`chapter_3`表应该看起来类似于以下内容：
- en: '![Figure 3.5 – PgAdmin – db_table option'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 – PgAdmin – db_table选项'
- en: '](img/Figure_3.5_B17243.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.5_B17243.jpg)'
- en: Figure 3.5 – PgAdmin – db_table option
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – PgAdmin – db_table选项
- en: We can see the `engine2` model class. Another valuable meta option that you
    may find yourself using a lot is the abstract option. This is primarily used for
    extending model classes and is best explained later in the section titled *Extending
    models* of this chapter.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看`engine2`模型类。另一个你可能经常使用的有用元选项是抽象选项。这个选项主要用于扩展模型类，最好在本章标题为*扩展模型*的部分中稍后解释。
- en: Before we extend model classes, let's explore using model methods and method
    decorators.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展模型类之前，让我们先探索使用模型方法和方法装饰器。
- en: Customizing models
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制模型
- en: Model methods are custom functions written within a model class that provide
    added functionality related to a single record within a table. They let us create
    our own business logic and format field data as we need to. Django provides us
    with several default methods and we can also write our own custom methods. Custom
    methods can combine fields and return data derived from those two or more fields.
    Decorators are sometimes used in combination with model methods to provide even
    more functionality.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 模型方法是写在模型类内部的定制函数，为表中的单个记录提供附加功能。它们让我们能够创建自己的业务逻辑，并按需格式化字段数据。Django为我们提供了几个默认方法，我们也可以编写自己的定制方法。定制方法可以将字段组合起来，并从这些两个或更多字段中返回派生数据。装饰器有时与模型方法结合使用，以提供更多的功能。
- en: 'Some methods can let us perform special operations when an object is saved
    and/or deleted at the database level. Other methods are used when queries are
    performed or when rendering an object within a template. We will discuss some
    of the methods that Django provides and then demonstrate their uses. For a complete
    breakdown of the full capabilities of using Django''s model methods, visit their
    documentation, found here: [https://docs.djangoproject.com/en/4.0/topics/db/models/#model-methods](https://docs.djangoproject.com/en/4.0/topics/db/models/#model-methods).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方法可以在对象在数据库级别保存和/或删除时执行特殊操作。其他方法用于查询执行或模板内渲染对象时使用。我们将讨论Django提供的一些方法，并演示它们的用法。要了解使用Django模型方法的全部功能，请访问他们的文档，网址为[https://docs.djangoproject.com/en/4.0/topics/db/models/#model-methods](https://docs.djangoproject.com/en/4.0/topics/db/models/#model-methods)。
- en: Writing methods
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写方法
- en: Writing a model method is similar to writing a `Meta` subclass, except instead
    of writing a class, we are now writing a function inside that class using the
    `def` keyword.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 编写模型方法类似于编写`Meta`子类，除了我们现在是在该类内部使用`def`关键字编写一个函数，而不是编写一个类。
- en: 'The four most helpful and most used methods are defined here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里定义了四个最有帮助且最常用的方法：
- en: '`def save(self, *args, **kwargs)` – used to override the save action of this
    model at the database level. You can inject your own logic either before or after
    the save has occurred by tapping into this method.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def save(self, *args, **kwargs)` – 用于覆盖此模型在数据库级别的保存操作。你可以通过调用此方法在保存之前或之后注入自己的逻辑。'
- en: '`def delete(self, *args, **kwargs)` – this is similar to the `save` method,
    except that you can add your own logic before or after an object has been deleted
    at the database level.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def delete(self, *args, **kwargs)` – 这与`save`方法类似，不同之处在于你可以在对象在数据库级别被删除之前或之后添加自己的逻辑。'
- en: '`def get_absolute_url(self)` – used by Django to formulate a canonical URL
    for that object. This is used to redefine the default behavior of how Django creates
    a URL structure for these objects. This is also the URL used within the Django
    admin site to access this object.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def get_absolute_url(self)` – Django用来制定该对象的规范URL。这用于重新定义Django创建这些对象URL结构的默认行为。这也是在Django管理站点中访问此对象所使用的URL。'
- en: '`def __str__(self)` – used to redefine the default manner that Django will
    use to create a string representation of a single record within that table.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def __str__(self)` – 用来重新定义Django将用于创建表中单个记录的字符串表示的默认方式。'
- en: We will use the `__str__()` method to demonstrate how to override a Django-provided
    method and access methods throughout the code of your project.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`__str__()`方法来演示如何覆盖Django提供的方法并访问项目代码中的方法。
- en: Model method – __str__
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型方法 – __str__
- en: Using the same `MAKE_CHOICES` tuple that was created earlier, we will override
    the `__str__()` method to formulate a custom name for all `Vehicle` objects. The
    default string representation of a `Vehicle` object that we will define will use
    the following naming convention, `{{ vehicle make }} {{ vehicle model }}`, with
    a space in between.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前创建的相同的`MAKE_CHOICES`元组，我们将覆盖`__str__()`方法，为所有`Vehicle`对象制定一个自定义名称。我们将定义的`Vehicle`对象的默认字符串表示将使用以下命名约定，`{{
    vehicle make }} {{ vehicle model }}`，中间有一个空格。
- en: 'To configure this method in your `Vehicle` class, in your `/chapter_3/models.py`
    file, write the `__str__()` method, as depicted in the following code block, in
    your existing `Vehicle` model class:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`Vehicle`类中配置此方法，在你的`/chapter_3/models.py`文件中，在你的现有`Vehicle`模型类中编写`__str__()`方法，如下面的代码块所示：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It's easy to see that model methods are just functions that take in an instance
    of itself, perform an operation of some kind on itself, and then return the transformed
    value. The value in the preceding example is a string, and for the `__str__()`
    method, it should always return a string, whereas other methods, including custom
    methods that you create, can return any other data type, such as an *integer*,
    *dictionary*, *QuerySet*, or *date/time* object, to name a few.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，模型方法只是接受自身实例作为参数，对自己执行某种操作，然后返回转换后的值。前一个例子中的值是一个字符串，对于`__str__()`方法，它应该始终返回一个字符串，而其他方法，包括你创建的自定义方法，可以返回任何其他数据类型，例如*整数*、*字典*、*QuerySet*或*日期/时间*对象，仅举几例。
- en: Next, let's discuss writing our own custom model methods, one that Django does
    not provide for us.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论编写我们自己的自定义模型方法，这是Django没有为我们提供的。
- en: Custom model method
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义模型方法
- en: A custom method would come in handy if say we want to display a more in-depth
    name than what the `__str__()` method already does for a model class. For example,
    let's include the engine type in addition to the information returned from the
    `__str__()` method. The naming convention will be `{{ vehicle make }} {{ vehicle
    model }} – {{ vehicle engine }}`, with the space and dash in between.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要显示比`__str__()`方法为模型类提供的更深入的名字，自定义方法将很有用。例如，让我们包括发动机类型，除了`__str__()`方法返回的信息。命名约定将是`{{
    vehicle make }} {{ vehicle model }} – {{ vehicle engine }}`，中间有空格和破折号。
- en: 'To create your own model method on the `Vehicle` class, in your `/chapter_3/models.py`
    file, create a new method within your `Vehicle` model and call it `full_vehicle_name()`,
    as shown:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`Vehicle`类上创建自己的模型方法，在你的`/chapter_3/models.py`文件中，在你的`Vehicle`模型内部创建一个新的方法，并将其命名为`full_vehicle_name()`，如下所示：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The preceding example uses the same logic found in the `__str__()` method. We
    are just calling that method from within the custom method using the `self.__str__()`
    expression, instead of writing the same code in two different places.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个例子使用了`__str__()`方法中找到的相同逻辑。我们只是在自定义方法中使用`self.__str__()`表达式调用该方法，而不是在两个不同的地方编写相同的代码。
- en: Next, we will apply a decorator around the newly created custom method, changing
    how we interact with this data.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在新创建的自定义方法周围应用装饰器，改变我们与这些数据交互的方式。
- en: Decorators
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器
- en: A decorator is a standard Python design pattern that allows developers to extend
    the functionality of an object without permanently changing the behavior of that
    object. The concept of decorators can be applied to virtually any class or method
    that exists in a project. We will be applying this concept to the `full_vehicle_name()`
    method that we just created, to change it from a callable to now a meta property
    of that model.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是一种标准的 Python 设计模式，允许开发者在不永久更改对象行为的情况下扩展对象的功能。装饰器的概念可以应用于项目中几乎任何存在的类或方法。我们将应用这个概念到我们刚刚创建的
    `full_vehicle_name()` 方法上，将其从可调用对象变为该模型的元属性。
- en: Decorator – @property
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 装饰器 – @property
- en: A `@property` decorator allows us to write a method to act as a regular property
    of a model instance, rather than act as a function. Using this decorator, we can
    access `full_vehicle_name` just like we would any other field found in that table.
    The only thing we cannot do is save data as we would for any other field, because
    that property is not technically its own column in that table to store data in.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`@property` 装饰器允许我们编写一个方法，使其作为模型实例的常规属性，而不是作为函数。使用此装饰器，我们可以像访问表中任何其他字段一样访问
    `full_vehicle_name`。唯一不能做的事情是像其他任何字段一样保存数据，因为该属性在技术上不是表中存储数据的独立列。'
- en: 'With no `@property` decorator present, data would be accessed similar to the
    following demonstration:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 `@property` 装饰器，数据访问方式将类似于以下演示：
- en: '[PRE51]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'With the `@property` decorator present, the `print` statement would be written
    similar to the following demonstration:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在 `@property` 装饰器，`print` 语句的编写方式将类似于以下演示：
- en: '[PRE52]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To wrap your method in a `@property` decorator, in your `/chapter_3/models.py`
    file, within the `Vehicle` model class, create a new method called `fullname()`,
    as depicted here:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要将你的方法包裹在 `@property` 装饰器中，在你的 `/chapter_3/models.py` 文件中，在 `Vehicle` 模型类内部，创建一个新的方法名为
    `fullname()`，如下所示：
- en: '[PRE53]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The preceding example will perform the same task as the `full_vehicle_name()`
    method except with the `@property` decorator applied. When we perform query operations
    later, in the section titled *Performing queries*, we will compare the difference
    between the two methods to see how that data is returned and used.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例将执行与 `full_vehicle_name()` 方法相同的功能，只是应用了 `@property` 装饰器。当我们稍后在该节标题为 *执行查询*
    的部分进行查询操作时，我们将比较两种方法的差异，以查看数据是如何返回和使用的。
- en: Now that we have discussed most of the core concepts of what makes up a Django
    model, let's practice extending these models in an effort to keep to a **Don't
    Repeat Yourself** (**DRY**) style of writing.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了构成 Django 模型的大部分核心概念，让我们练习扩展这些模型，以保持一种**不要重复自己**（**DRY**）的编写风格。
- en: Extending models
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展模型
- en: '`User` model, which is a very common model to extend.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 模型，这是一个非常常见的扩展模型。'
- en: Next, we will practice extending our practice model called `engine2` and then
    extend the Django `User` model, turning it into the `Seller` model. This would
    make the `Seller` object related to a `Vehicle` and also act as a `User`, provided
    with permission-based roles and permission group capabilities.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将练习扩展我们的实践模型 `engine2`，然后扩展 Django 的 `User` 模型，将其变为 `Seller` 模型。这将使 `Seller`
    对象与 `Vehicle` 相关，并充当 `User`，提供基于权限的角色和权限组功能。
- en: Extending basic model classes
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展基本模型类
- en: 'Extending regular model classes is pretty easy to do. Follow these steps to
    extend the `engine2` practice class:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展常规模型类相当简单。按照以下步骤扩展 `engine2` 实践类：
- en: 'In your `/chapter_3/models.py` file, in the class named `engine2`, keep the
    name field as is and then add a new field called `vehicle_model`, with the `related_name`
    attribute value that is depicted in the following code block:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_3/models.py` 文件中，在名为 `engine2` 的类中，保持名称字段不变，然后添加一个新的字段名为 `vehicle_model`，其
    `related_name` 属性值如以下代码块所示：
- en: '[PRE60]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Make sure your `engine2` class has the following `Meta` class options:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的 `engine2` 类具有以下 `Meta` 类选项：
- en: '[PRE61]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We basically want `engine2` to resemble the `Engine` class exactly, except that
    we want to keep the original class untouched and write a new class called `engine3`
    constructed from `engine2`. We also have to give the `vehicle_model` field in
    the `engine2` class a new and unique value for the `related_name` argument. Otherwise,
    when we run the Django migration commands, we will experience conflicting errors
    with the `Engine` class. In the `engine2` class, specify the `abstract = True`
    option as we did in the preceding example. That option allows us to use that class
    as a parent class.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上想让 `engine2` 类与 `Engine` 类完全一致，除了我们想要保持原始类不变，并编写一个名为 `engine3` 的新类，该类由
    `engine2` 构造。我们还需要给 `engine2` 类中的 `vehicle_model` 字段提供一个新的唯一值作为 `related_name`
    参数。否则，当我们运行 Django 迁移命令时，我们将遇到与 `Engine` 类的冲突错误。在 `engine2` 类中，指定与前面示例中相同的 `abstract
    = True` 选项。该选项允许我们将其用作父类。
- en: 'Now, create a new class called `engine3` below your `engine2` class, as depicted
    in the following code block:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在你的 `engine2` 类下面创建一个名为 `engine3` 的新类，如下面的代码块所示：
- en: '[PRE62]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the `engine3` class shown here, we are not creating a `Meta` subclass and
    we will only give it one field. We also replaced `models.Model` with `engine2`.
    That is where we pass in the name of the class that we want to construct the new
    class from, otherwise known as extending or inheriting from that parent class.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里展示的 `engine3` 类中，我们并没有创建一个 `Meta` 子类，我们只给它提供一个字段。我们还用 `engine2` 替换了 `models.Model`。这就是我们传入我们想要从该类构造新类（也称为扩展或从该父类继承）的类名的地方。
- en: Running your Django migration commands now will result in an error, telling
    us that the `chapter_3_practice_engine` table already exists. To prevent this,
    we can do one of two things. We could rename the `Meta` class option `db_table`
    of the `engine2` class or we can drop all of the tables in the database and start
    fresh.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行你的 Django 迁移命令将导致错误，告诉我们 `chapter_3_practice_engine` 表已经存在。为了防止这种情况，我们可以做两件事之一。我们可以重命名
    `engine2` 类的 `Meta` 类选项 `db_table`，或者我们可以删除数据库中的所有表并从头开始。
- en: Dropping database tables
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除数据库表
- en: Since, currently, we do not have any real data to worry about and because we
    are so early in the development life cycle, it's okay to drop our tables. It is
    acceptable because we are still getting started with building the skeleton code
    of our project. We are also working with a local database, meaning we won't disrupt
    other developers' workflows by performing this task. Dropping your tables can
    be done using any database management tool.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目前我们没有任何实际数据需要担心，并且因为我们处于开发生命周期的早期阶段，删除我们的表是可以的。这是可以接受的，因为我们还在构建我们项目骨架代码的起点。我们还在使用本地数据库，这意味着我们不会通过执行此任务来干扰其他开发者的工作流程。你可以使用任何数据库管理工具来删除你的表。
- en: 'Follow these steps to drop your tables using PgAdmin:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用 PgAdmin 删除你的表：
- en: In PgAdmin, navigate to **Tools** | **Query Tool**.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PgAdmin 中，导航到 **工具** | **查询工具**。
- en: 'In the tab that opens, enter the following two commands:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的选项卡中，输入以下两个命令：
- en: '[PRE63]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Execute these commands by hitting the **Execute/Refresh** button or pressing
    *F5* on your keyboard.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **执行/刷新** 按钮或按键盘上的 *F5* 来执行这些命令。
- en: You will also need to delete all migration files found in any migrations folder,
    such as the `/chapter_3/migrations/` and `/chapter_3/migrations/__pycache__/`
    folders.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要删除任何迁移文件夹中找到的所有迁移文件，例如 `/chapter_3/migrations/` 和 `/chapter_3/migrations/__pycache__/`
    文件夹。
- en: Note
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Every time tables are dropped, data is lost. The next time the Django migration
    commands are executed, the `createsuperuser` command should be executed and/or
    data fixtures loaded.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次删除表时，数据都会丢失。下次执行 Django 迁移命令时，应该执行 `createsuperuser` 命令或加载数据固定。
- en: 'Execute your Django migration commands one more time. The following screenshot
    shows that all of the fields and `Meta` class options that existed before in the
    `engine2` class now exist in the `engine3` class even though we did not write
    them for the `engine3` class:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次执行你的 Django 迁移命令。以下截图显示，之前在 `engine2` 类中存在的所有字段和 `Meta` 类选项现在都存在于 `engine3`
    类中，尽管我们没有为 `engine3` 类编写它们：
- en: '![Figure 3.6 – PgAdmin – extended engine'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – PgAdmin – 扩展引擎'
- en: '](img/Figure_3.6_B17243.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.6_B17243.jpg)'
- en: Figure 3.6 – PgAdmin – extended engine
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – PgAdmin – 扩展引擎
- en: We can see this because the `Meta` class `db_table = 'chapter_3_practice_engine'`
    option is placed in the `engine2` class and is what the `engine3` table is named.
    No table was created for the `engine2` class because it is configured as an abstract
    class. We also see that the two fields, `name` and `vehicle_model`, from the `engine2`
    class also get applied to the `engine3` class.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这是因为 `Meta` 类的 `db_table = 'chapter_3_practice_engine'` 选项放置在 `engine2`
    类中，这就是 `engine3` 表的名称。没有为 `engine2` 类创建表，因为它被配置为抽象类。我们还看到来自 `engine2` 类的两个字段，`name`
    和 `vehicle_model`，也应用于 `engine3` 类。
- en: Let's extend the built-in Django `User` class next.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们扩展内置的 Django `User` 类。
- en: Extending the Django User model
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展 Django 用户模型
- en: Extending the Django `User` model will transform the `Seller` model, making
    it act as a `User` in the system. This means you can create a user profile that
    will have fields that do not come standard with Django; it will have fields that
    we create. This is done by constructing the `Seller` class using the `AbstractUser`
    or `AbstractBaseUser` class as the parent class.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 Django 的 `User` 模型将转换 `Seller` 模型，使其在系统中充当 `User` 角色。这意味着你可以创建一个用户资料，它将包含
    Django 标准中不存在的字段；它将包含我们创建的字段。这是通过使用 `AbstractUser` 或 `AbstractBaseUser` 类作为父类来构造
    `Seller` 类实现的。
- en: 'Follow these steps to extend your `User` class:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤扩展你的 `User` 类：
- en: 'In your `/chapter_3/models.py` file, in the `Seller` class, replace `models.Model`
    with the `AbstractUser` parent class and include the `import` statement shown
    here:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_3/models.py` 文件中，在 `Seller` 类中，将 `models.Model` 替换为 `AbstractUser`
    父类，并包含此处所示的 `import` 语句：
- en: '[PRE64]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: An `AbstractUser` class will allow us to keep all of the original fields that
    exist in the `User` model. If we want to create a brand-new `User` model from
    scratch, use the `AbstractBaseUser` parent class instead.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractUser` 类将允许我们保留 `User` 模型中存在的所有原始字段。如果我们想从头开始创建一个全新的 `User` 模型，请使用
    `AbstractBaseUser` 父类。'
- en: 'We also need to adjust the value of the `AUTH_USER_MODEL` variable in the `settings.py`
    file, as shown:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要调整 `settings.py` 文件中 `AUTH_USER_MODEL` 变量的值，如下所示：
- en: '[PRE65]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Use the `app_name.model_name` naming convention, paying attention to model class
    letter casing. Without adjusting this value, we will get a `User` model for this
    project; instead, the `Seller` model will be used.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `app_name.model_name` 命名约定，注意模型类字母的大小写。如果不调整此值，我们将为该项目获得一个 `User` 模型；相反，将使用
    `Seller` 模型。
- en: 'If we try to run the Django migration commands now, Django will ask us to assign
    a default value to the username and password fields. Since a username field needs
    to be unique, we can''t just set a default value for this object easily because
    that will result in duplicate usernames. The reason this will happen is that we
    destroyed the previous `auth_user` tables in the database and created an entirely
    new set of relations for a `User`. Go ahead and drop your tables just like you
    did in the previous subsection, titled *Dropping database tables*. Now run the
    Django migrations commands. The following screenshot shows the `chapter_3_seller`
    table now has many other fields that we did not write:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在尝试运行 Django 迁移命令，Django 将会要求我们为用户名和密码字段分配一个默认值。由于用户名字段需要唯一，我们无法轻易地为这个对象设置默认值，因为这会导致重复的用户名。这种情况发生的原因是我们破坏了数据库中之前的
    `auth_user` 表，并为 `User` 创建了一个全新的关系集。按照之前小节中标题为 *删除数据库表* 的步骤，继续删除你的表。现在运行 Django
    迁移命令。以下截图显示 `chapter_3_seller` 表现在有许多我们没有编写的其他字段：
- en: '![Figure 3.7 – PgAdmin – user model extension'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.7 – PgAdmin – 用户模型扩展]'
- en: '](img/Figure_3.7_B17243.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.7 – PgAdmin – user model extension](img/Figure_3.7_B17243.jpg)'
- en: Figure 3.7 – PgAdmin – user model extension
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – PgAdmin – 用户模型扩展
- en: Now that we have covered the basics of writing and extending models, let's use
    the Django shell to perform queries. We can use the Django shell to see the results
    of queries without having to learn about rendering templates first, which is what
    all of [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116), *URLs, Views, and
    Templates*, will cover.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了编写和扩展模型的基础知识，让我们使用 Django shell 来执行查询。我们可以使用 Django shell 来查看查询结果，而无需先学习渲染模板，这正是所有
    [*第 4 章*](B17243_04_ePub.xhtml#_idTextAnchor116)，*URLs、视图和模板* 将要涵盖的内容。
- en: Using the Django shell
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Django shell
- en: The **Django shell** is a powerful tool to add to any toolbox. It will activate
    the Python interactive interpreter and uses the Django database abstraction API
    to let us connect directly to the database(s) configured in a project. With this,
    we can write Python and perform queries directly from a terminal or command-line
    window.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**Django shell** 是任何工具箱中一个强大的工具。它将激活Python交互式解释器，并使用Django数据库抽象API让我们能够直接连接到项目中配置的数据库（们）。有了这个，我们就可以从终端或命令行窗口直接编写Python代码和执行查询。'
- en: 'To activate the Django shell, follow these steps:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活Django shell，请按照以下步骤操作：
- en: 'Open your terminal or command-line window and navigate to the root of your
    project. Make sure your virtual environment has been activated and then execute
    the following command:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的终端或命令行窗口，导航到项目的根目录。确保您的虚拟环境已经激活，然后执行以下命令：
- en: '[PRE66]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'You should see it print out the following information about the `InteractiveConsole`
    that was launched:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该会看到它打印出有关启动的`InteractiveConsole`的以下信息：
- en: '[PRE67]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Your console will now display three right-angle brackets, where you can begin
    writing and executing Python code one line at a time. Theoretically, you could
    input an entire script this way, but it will not be saved anywhere, and your code
    will be lost when the window is closed or the `InteractiveConsole` is terminated.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的终端现在将显示三个右尖括号，您可以在其中逐行编写和执行Python代码。从理论上讲，您可以通过这种方式输入整个脚本，但它不会被保存到任何地方，并且当窗口关闭或`InteractiveConsole`终止时，您的代码将丢失。
- en: Now that this shell is activated, let's add sample data and perform a few queries
    to observe how it behaves.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个shell已经激活，让我们添加一些示例数据并执行几个查询来观察它的行为。
- en: Running basic Python scripts
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行基本的Python脚本
- en: 'Earlier in this chapter, in the subsection titled *Mutable versus immutable
    objects*, it was mentioned that a Python string is one of the immutable data types
    that exist. An immutable string is one that cannot be reassigned a character at
    a particular index of that string after it has been created. This means that what
    is allowed is reassigning the value to that string altogether, and what is not
    allowed is changing the value of a character at a particular index. This is a
    basic fundamental of Python, and those who are new to Python can find this to
    be confusing. In this next example, we will demonstrate how to use the Django
    shell and at the same time demonstrate what makes a string immutable:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的部分，在标题为*可变对象与不可变对象*的小节中提到，Python字符串是存在的不可变数据类型之一。不可变字符串是指在创建后不能重新分配该字符串特定索引处的字符。这意味着允许的是将整个值重新分配给该字符串，而不允许的是更改特定索引处的字符值。这是Python的基本原则，对于Python新手来说可能会感到困惑。在下一个例子中，我们将演示如何使用Django
    shell，同时演示是什么使得字符串不可变：
- en: 'Launch the Python interactive interpreter by running the following Django shell
    command:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下Django shell命令来启动Python交互式解释器：
- en: '[PRE68]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Assign a new variable called `myvar` and give it an initial value of `my_string`,
    as shown:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个新的变量`myvar`，并给它一个初始值`my_string`，如下所示：
- en: '[PRE69]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'By executing the second statement shown in the previous code block, where we
    try to remove the underscore from the string at index `2`, we are receiving an
    error stating `TypeError: ''str'' object does not support item assignment`.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '通过执行前面代码块中显示的第二个语句，我们尝试从字符串索引`2`处删除下划线，我们收到了一个错误，指出`TypeError: ''str'' object
    does not support item assignment`。'
- en: 'If we just reassign the value of the `myvar` variable, as is done in the following
    code block, we will be able to remove the underscore this way:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们只是重新分配`myvar`变量的值，如下面的代码块所示，我们将能够以这种方式删除下划线：
- en: '[PRE70]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the preceding example, the first `print` statement returns `my_string` and
    then, after we change the value of `myvar`, the next `print` statement returns
    `mystring`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，第一个`print`语句返回`my_string`，然后，在我们更改`myvar`的值之后，下一个`print`语句返回`mystring`。
- en: 'We could use string indexes to look up characters and combine them but we cannot
    reassign a character at an index. The following example would remove the underscore
    by looking up characters at specified index ranges:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用字符串索引来查找字符并将它们组合，但我们不能重新分配索引处的字符。以下示例将通过查找指定索引范围内的字符来删除下划线：
- en: '[PRE71]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Type `exit()` to quit using the interactive interpreter and return to using
    your `manage.py` commands:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`exit()`退出交互式解释器，并返回使用`manage.py`命令：
- en: '[PRE72]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now that we know how to execute basic Python scripts in the interactive interpreter,
    let's use this tool to generate a custom `SECRET_KEY` and set a project's `.env`
    file.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何在交互式解释器中执行基本的Python脚本，让我们使用这个工具生成一个自定义的`SECRET_KEY`并设置项目的`.env`文件。
- en: Generating a SECRET_KEY variable
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成一个SECRET_KEY变量
- en: A `SECRET_KEY` variable in Django is used as a hash to secure things, such as
    your sessions, cookie storage, password tokenization, and all other methods of
    cryptographic signing that act to secure your site. Instead of using an online
    tool to generate this key, where the transmission either to or from that source
    could be compromised, you could generate your own using the Django shell. All
    we are doing is generating a random string. There is nothing special about this
    operation; you could technically use any combination of letters and numbers that
    you enter on a keyboard too. While this is not necessary since Django already
    generates a unique key for us when we create a new Django project, it is a useful
    step to allow us to create different keys to use on each of our Heroku environments.
    This way, we don't share the same `SECRET_KEY`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Django中的`SECRET_KEY`变量用作哈希来保护一些内容，例如您的会话、cookie存储、密码令牌化以及所有其他用于保护您网站的加密签名方法。您不必使用在线工具生成此密钥，因为从该源传输或接收可能会被破坏，您可以使用Django
    shell生成自己的密钥。我们正在生成一个随机字符串。这个操作没有特别之处；技术上您也可以使用键盘上输入的任何字母和数字组合。虽然Django在创建新的Django项目时已经为我们生成了一个唯一的密钥，但这是一个有用的步骤，允许我们在每个Heroku环境中使用不同的密钥。这样，我们就不会共享相同的`SECRET_KEY`。
- en: 'To generate your own `SECRET_KEY`, follow these steps:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成自己的`SECRET_KEY`，请按照以下步骤操作：
- en: 'Activate the Django shell in your terminal or command-line window and then
    import the method shown in the following code block:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端或命令行窗口中激活Django shell，然后导入以下代码块中所示的方法：
- en: '[PRE73]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The method shown here comes from the package called `secret_key_generator`,
    which we installed in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project
    Configuration*.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这里所示的方法来自名为`secret_key_generator`的包，我们在[*第2章*](B17243_02_ePub.xhtml#_idTextAnchor037)，*项目配置*中安装了它。
- en: 'Next, execute the following `print` statement:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，执行以下`print`语句：
- en: '[PRE74]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Take the key that gets printed onscreen and use it to set or reset your environment
    variables. To reset your variables, just follow the same steps as were discussed
    in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*,
    under the subsection titled *Remote variables* and it will update your value with
    the new value.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取出屏幕上打印的密钥，并使用它来设置或重置您的环境变量。要重置变量，只需遵循[*第2章*](B17243_02_ePub.xhtml#_idTextAnchor037)，*项目配置*中标题为*远程变量*的子节中讨论的相同步骤，它将使用新值更新您的值。
- en: The preceding shell command also created for us a text file called `.secret.txt`,
    found in the root of your project, where your `manage.py` file is located. You
    can delete the `.sectret.txt` file as it is not needed.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 上述shell命令还为我们创建了一个名为`.secret.txt`的文本文件，位于项目的根目录中，您的`manage.py`文件也位于此处。您可以删除`.sectret.txt`文件，因为它不是必需的。
- en: Now, let's use the Django shell to add data to our tables next, allowing us
    to use the Django shell to perform queries after that.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Django shell向我们的表中添加数据，这样我们就可以在之后使用Django shell进行查询。
- en: Saving data
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存数据
- en: Creating and saving objects to your database using the Django shell is easy.
    After we have activated the Django shell, we need to import the models that we
    want to work with into memory just like when we import something at the top of
    any `.py` file.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Django shell将对象保存到数据库中很容易。在我们激活Django shell之后，我们需要将我们想要与之一起工作的模型导入内存中，就像在`.py`文件的顶部导入某个东西一样。
- en: 'Follow these steps to create and save data using the Django shell:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用Django shell创建和保存数据：
- en: 'Import your vehicle class objects using the `InteractiveConsole` window by
    executing the following commands:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`InteractiveConsole`窗口通过执行以下命令导入您的车辆类对象：
- en: '[PRE75]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: These objects will be available for you to use until that window is closed or
    the `exit()` command is executed.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象将可供您使用，直到该窗口关闭或执行`exit()`命令。
- en: 'While these objects are loaded, it only takes the two lines of code shown in
    the following code block to create a new object and then save it:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当这些对象被加载时，只需以下代码块中的两行代码就可以创建一个新的对象并将其保存：
- en: '[PRE76]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The preceding lines will create and then save a `VehicleModel` object with the
    name of `Enclave Avenir` into the `chapter_3_vehiclemodel` table. In the creation
    of the `vehicle_model` object previously, we provided values to all of the fields
    that exist for that class. The value of the `make` field uses the numeric value
    of the tuple that we created earlier, called `MAKE_CHOICES`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行将创建并保存一个名为`Enclave Avenir`的`VehicleModel`对象到`chapter_3_vehiclemodel`表中。在之前创建`vehicle_model`对象时，我们为该类存在的所有字段提供了值。`make`字段的值使用我们之前创建的元组的数值，称为`MAKE_CHOICES`。
- en: 'However, if we try to create an `Engine` object using a numeric value for the
    `vehicle_model` field, then we will be given a `ValueError`, as shown:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试使用`vehicle_model`字段的数值来创建一个`Engine`对象，那么我们会收到一个`ValueError`，如下所示：
- en: '[PRE77]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In order to successfully create an `Engine` object, we first have to create
    a `VehicleModel` object as we did for the `vehicle_model` temporary object in
    *step 2*. Then, use that variable to set as the value of the `model` field instead
    of using a numeric integer, as shown:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了成功创建一个`Engine`对象，我们首先必须创建一个`VehicleModel`对象，就像我们在*第2步*中为`vehicle_model`临时对象所做的那样。然后，使用该变量将`model`字段的值设置为，而不是使用数值整数，如下所示：
- en: '[PRE78]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '*Step 4* of the preceding example will likely result in an error due to us
    adding the `unique = True` argument to the `name` field of the `VehicleModel`
    class. This is also because we just created an object using the same name in *step
    2*. You can get around that by providing a unique name or disregarding it and
    moving forward. This error was made intentionally for learning purposes. The error
    you receive should look like the one shown in the following code block, indicating
    that you have duplicate entries:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个示例的*第4步*可能会因为我们在`VehicleModel`类的`name`字段上添加了`unique = True`参数而导致错误。这也是因为我们刚刚在*第2步*中使用相同的名称创建了一个对象。你可以通过提供一个唯一的名称或忽略它并继续前进来解决这个问题。这个错误是为了学习目的而故意制造的。你收到的错误应该看起来像以下代码块中显示的错误，表明你有重复条目：
- en: '[PRE79]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: To get around this, we need to use the `update_or_create()` method instead of
    the `save()` method.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要使用`update_or_create()`方法而不是`save()`方法。
- en: 'If we try to create and then save an engine with a `vehicle_model` field that
    has not been already saved to the database, we will get a `ValueError` informing
    us that there is an unsaved related object present. If you wish to see this, create
    the `vehicle_model` object using the following values. Then, use that object to
    assign as the value of the `vehicle_model` field on the `engine` object and try
    to save:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试创建并保存一个`vehicle_model`字段尚未保存到数据库中的`Engine`对象，我们将收到一个`ValueError`，告知我们存在未保存的相关对象。如果你希望看到这个，请使用以下值创建`vehicle_model`对象。然后，使用该对象将`engine`对象上的`vehicle_model`字段的值设置为该对象，并尝试保存：
- en: '[PRE80]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Once you try to save that `engine`, the error shown in the preceding code block
    would print to your screen, which is the reason why we need to save each related
    object before creating an object that they rely on.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦尝试保存该`engine`，前一个代码块中显示的错误就会打印到你的屏幕上，这就是为什么我们需要在创建依赖于它们的对象之前保存每个相关对象的原因。
- en: Let's discuss using the `update_or_create()` method next.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论使用`update_or_create()`方法。
- en: Model method – update_or_create()
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型方法 – update_or_create()
- en: We use the `update_or_create()` method instead of the `save()` method to create
    or modify an existing object.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`update_or_create()`方法而不是`save()`方法来创建或修改现有对象。
- en: 'Follow these steps to use this method:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用此方法：
- en: 'Make sure the Django shell is activated and then execute the following command:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Django shell已激活，然后执行以下命令：
- en: '[PRE81]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The preceding example should have been successful. If it was, then you received
    no errors, and you'll see the three right-angle brackets waiting for your next
    input command.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例应该已经成功。如果成功了，那么你没有收到任何错误，你会看到三个右尖括号等待你的下一个输入命令。
- en: Using a database management tool such as PgAdmin, check to see that you have
    a `VehicleModel` record in your table with the name `Enclave Avenir`. The `defaults`
    argument in the preceding example is an optional argument that defines the values
    that you want to set if this operation creates a new record. Without it, the system
    will default to values set on your model fields instead.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数据库管理工具，如PgAdmin，检查你的表中是否有一个名为`Enclave Avenir`的`VehicleModel`记录。前一个示例中的`defaults`参数是一个可选参数，它定义了在创建新记录时你想设置的值。如果没有它，系统将默认使用你的模型字段上设置的值。
- en: 'In this step, we will add a `Vehicle` to the database. It requires the use
    of a `Money` class to create a `Money` object. To use the `Money` class, execute
    the following `import` statement:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步中，我们将向数据库中添加一个`Vehicle`对象。这需要使用`Money`类来创建一个`Money`对象。要使用`Money`类，请执行以下`import`语句：
- en: '[PRE82]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, execute the following three `update_or_create()` commands:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，执行以下三个`update_or_create()`命令：
- en: '[PRE83]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The commands in this subsection should have all resulted in success without
    errors.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节中的命令应该都成功执行，没有错误。
- en: Note
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If a vehicle with the same VIN as the one shown previously is already created
    for you by importing the data found in the `chapter_3` data fixture, then you
    can just change the `vin` value in the preceding example to a new and unique `vin`
    value. This allows you to witness a new record being added to your table when
    viewed in a database management tool such as PgAdmin.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前已经通过导入`chapter_3`数据固定文件中找到的数据创建了一个具有相同VIN号的车辆，那么你只需将前一个示例中的`vin`值更改为一个新的唯一`vin`值即可。这样，当你使用像PgAdmin这样的数据库管理工具查看时，你可以看到一条新记录被添加到你的表中。
- en: Let's discuss loading the `chapter_3` data fixture next.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来讨论加载`chapter_3`数据固定文件。
- en: Loading the chapter_3 data fixture
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载`chapter_3`数据固定文件
- en: Instead of providing steps on how to create all of the data that will be needed
    to demonstrate the exercises throughout the rest of this chapter and this book,
    we will be adding data from a data fixture. Adding data can be done in a much
    simpler way than how it was done from within the Django shell. We will discuss
    this concept in more depth and create our own fixtures later in [*Chapter 10*](B17243_10_ePub.xhtml#_idTextAnchor293),
    *Database Management*. For now, make sure the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_3/fixtures/`
    folder and all of the files found in this folder from the code of this book are
    copied into your `/chapter_3/` app folder. The `chapter_3` fixture will provide
    enough data for us to work with the remaining examples of this chapter.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会提供如何创建本章和本书其余部分所需的所有数据的步骤，而是将从数据固定文件中添加数据。添加数据可以比在Django shell中执行的方式简单得多。我们将在[*第10章*](B17243_10_ePub.xhtml#_idTextAnchor293)
    *数据库管理*中更深入地讨论这个概念，并稍后创建我们自己的固定文件。现在，请确保将`/becoming_a_django_entdev/becoming_a_django_entdev/chapter_3/fixtures/`文件夹以及该文件夹中本书代码中找到的所有文件复制到你的`/chapter_3/`应用文件夹中。`chapter_3`固定文件将为我们提供足够的数据，以便我们处理本章剩余的示例。
- en: 'To load your data fixture make sure you have exited your Django shell and that
    your virtual environment is active and then execute the following command:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载数据固定文件，请确保你已经退出了Django shell，并且你的虚拟环境是激活的，然后执行以下命令：
- en: '[PRE84]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: If you have issues with importing this fixture, double-check that your table
    structures match the structures of the models provided with the code of this book
    in the `chapter_3` app.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导入此固定文件存在问题，请确保你的表结构与本书`chapter_3`应用中提供的模型结构相匹配。
- en: The alternative would be to follow the steps in the *Saving data* subsection
    of this chapter to add your own sample data one painstaking item at a time. Create
    and save as many objects as you would like using those examples. If you were to
    create a `Vehicle` object, it would be done in the same way as creating an `Engine`
    object, except now you are defining the values of two related objects instead
    of one in order to save successfully. We just need to have a few objects to play
    around with in the next exercises of this chapter.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是遵循本章*保存数据*小节中的步骤，逐个添加你的样本数据。使用这些示例创建并保存你想要的任何数量的对象。如果你要创建一个`Vehicle`对象，它将以创建`Engine`对象相同的方式进行，但现在你需要定义两个相关对象的值，而不是一个，以便成功保存。我们只需要在下一章的练习中玩转几个对象。
- en: Performing queries
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行查询
- en: Performing queries using the Django shell will give us some insight into how
    queries work. In the following subsections, we will discuss some common methods
    that are used.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Django shell执行查询将让我们了解查询是如何工作的。在以下小节中，我们将讨论一些常用的方法。
- en: Model method – all()
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型方法 – all()
- en: 'The `all()` method returns all records found in the table for that model object.
    This method will return a QuerySet in the following format, representing all entries
    that it finds:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`all()`方法返回该模型对象表中找到的所有记录。此方法将返回以下格式的QuerySet，表示它找到的所有条目：'
- en: '[PRE85]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `chapter_3` data fixture only provides three VehicleModel and that is why
    a collection of only three objects is returned to us. Your results may vary. One
    of the reasons why we created a `__str__()` method, as was done earlier in this
    chapter, in the subsection titled *Model method – __str__*, is so that it could
    be represented in a logical way in code usage such as this, where the object name
    that gets printed out is a name that makes sense to us and not something that
    won''t make sense. Without the `__str__()` method defined in the `VehicleModel`
    class, the QuerySet would have been returned to us in a manner that looks like
    the following example:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`chapter_3` 数据固定只提供了三个 VehicleModel，这就是为什么只返回了三个对象的集合。您的结果可能会有所不同。我们创建 `__str__()`
    方法的原因之一，就像在本章的 *模型方法 – __str__* 小节中做的那样，是为了使它能够在代码使用中以一种逻辑方式表示，其中打印出来的对象名称是我们能理解的名称，而不是一些没有意义的名称。如果没有在
    `VehicleModel` 类中定义 `__str__()` 方法，查询集将按以下示例所示返回给我们：'
- en: '[PRE86]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We would have no way to distinguish which object is which and what order they
    are in just by looking at the collection printed in this code block.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过查看此代码块中打印的集合，我们无法区分哪些对象是哪些，以及它们的顺序。
- en: Model method – get()
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型方法 – get()
- en: The `get()` method is used to target a specific database record.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()` 方法用于定位特定的数据库记录。'
- en: 'Follow these steps to see this method in action:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤查看此方法的效果：
- en: 'Use `get()` to target the `vin` value of a vehicle when performing a query,
    as is done here:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行查询时使用 `get()` 来定位车辆的 `vin` 值，就像这里所做的那样：
- en: '[PRE87]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Using the single object that was returned to us, run the `print` statement
    again using the `full_vehicle_name()` method that we created earlier, to see the
    difference in the results that are generated:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用返回给我们的单个对象，再次使用我们之前创建的 `full_vehicle_name()` 方法运行 `print` 语句，以查看生成的结果差异：
- en: '[PRE88]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Next, use the other `fullname` method with the `@property` decorator to return
    the exact same results:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用其他 `fullname` 方法与 `@property` 装饰器返回完全相同的结果：
- en: '[PRE89]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Django is using the format that we defined earlier in the `__str__` method to
    generate a string that gets printed to the screen in *step 1*. We already know
    that the `vin` field is set to `unique = True`, meaning there will never be two
    objects with the same `vin` value in the database, so we know that it is safe
    to use the `get()` method in all the preceding steps. If there are numerous items
    with the same value and a `get()` method is used, then you will need to use a
    `filter()` method instead.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: Django 正在使用我们在 `__str__` 方法中定义的格式来生成字符串，该字符串在 *步骤 1* 中被打印到屏幕上。我们已经知道 `vin` 字段被设置为
    `unique = True`，这意味着数据库中永远不会有两个具有相同 `vin` 值的对象，因此我们知道在所有前面的步骤中使用 `get()` 方法是安全的。如果有多个具有相同值的项并且使用了
    `get()` 方法，那么您将需要使用 `filter()` 方法。
- en: Model method – filter()
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型方法 – filter()
- en: The `filter()` method is used to look up records in a database that may have
    the same field values. This method will return a collection of results instead
    of a single result. The collection will be returned to us as a `QuerySet`. For
    example, we can filter the `VehicleModel` table, which we already know contains
    three rows.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()` 方法用于在可能具有相同字段值的数据库中查找记录。此方法将返回一个结果集合而不是单个结果。集合将以 `QuerySet` 的形式返回给我们。例如，我们可以过滤
    `VehicleModel` 表，我们知道它包含三行。'
- en: 'The following example will filter the `make` field by the value of `Buick`,
    to return a collection of only two objects instead of three:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将根据 `Buick` 的值过滤 `make` 字段，以返回仅包含两个对象的集合而不是三个：
- en: '[PRE90]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Queries can get much more complex than using a simple `all()`, `get()`, or
    `filter()` method. Q objects provide more complicated queries as well. For a complete
    breakdown of how to use Q objects in Django, visit the documentation here: https://docs.djangoproject.com/en/4.0/ref/models/querysets/#q-objects.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 查询可以比使用简单的 `all()`、`get()` 或 `filter()` 方法复杂得多。Q 对象也提供了更复杂的查询。有关如何在 Django 中使用
    Q 对象的完整说明，请访问以下文档：https://docs.djangoproject.com/en/4.0/ref/models/querysets/#q-objects。
- en: We can even obtain a summary of objects using arithmetic functions, which brings
    us to our next subsection, discussing aggregates.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用算术函数来获取对象的摘要，这把我们带到了下一个子节，讨论聚合。
- en: Aggregates
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合
- en: 'Django provides an easy way to generate a summary of a collection of objects,
    known as **aggregates**. What this means is that we can perform a query and use
    any one of the many **aggregation functions** that Django provides. This can be
    used to generate an average price for all the vehicles, generate an average price
    of just the sold vehicles, or generate a total count of vehicles for a particular
    seller. While there is a lot of information regarding the topic of aggregates
    and annotates, we will discuss some basic usages. A complete guide to generating
    aggregates in Django can be found here: [https://docs.djangoproject.com/en/4.0/ref/models/querysets/#aggregation-functions](https://docs.djangoproject.com/en/4.0/ref/models/querysets/#aggregation-functions).'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了一个简单的方式来生成对象集合的摘要，这被称为**聚合**。这意味着我们可以执行查询并使用Django提供的许多**聚合函数**中的任何一个。这可以用来生成所有车辆的平均价格，生成仅售出车辆的平均价格，或者为特定卖家生成车辆的总数。虽然关于聚合和注解的信息有很多，但我们将讨论一些基本用法。有关在Django中生成聚合的完整指南，请参阅此处：[https://docs.djangoproject.com/en/4.0/ref/models/querysets/#aggregation-functions](https://docs.djangoproject.com/en/4.0/ref/models/querysets/#aggregation-functions)。
- en: Model method – aggregate()
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型方法 – aggregate()
- en: Aggregates are used to generate a summary of every object in a QuerySet. To
    get an average price of every vehicle that exists in that table, we can use the
    `Avg` aggregate function. The argument that we pass into the `Avg` function is
    the field that we want to perform this operation on.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合用于生成查询集中每个对象的摘要。为了获取表中每个存在的车辆的平均价格，我们可以使用`Avg`聚合函数。我们传递给`Avg`函数的参数是我们想要执行此操作的字段。
- en: 'Follow these steps to practice using aggregates:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤练习使用聚合：
- en: 'Import your `Vehicle` model and the `Avg` class objects, as shown:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤导入您的`Vehicle`模型和`Avg`类对象，如下所示：
- en: '[PRE91]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Perform a query lookup using the `all()` method combined with the `aggregate()`
    method, as shown:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`all()`方法和`aggregate()`方法执行查询查找，如下所示：
- en: '[PRE92]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Print your `vehicles` object:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印您的`vehicles`对象：
- en: '[PRE93]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The summary is returned as a dictionary object.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要作为字典对象返回。
- en: 'You can get the value of the `price__avg` key by executing the following `print`
    statement:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过执行以下`print`语句来获取`price__avg`键的值：
- en: '[PRE94]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The result of the average is, of course, not actually formatted in any particular
    currency type yet.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值的结果当然还没有实际格式化为任何特定的货币类型。
- en: 'We can format it in US dollars by applying the same `Money()` conversion that
    we did before when we created and then saved our first vehicle in the database,
    by executing the following commands:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过应用之前在数据库中创建并保存我们的第一个车辆时使用的相同的`Money()`转换来将其格式化为美元，执行以下命令：
- en: '[PRE95]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Where we wrote `Vehicle.objects.all().aggregate()` in *step 2* previously,
    the `all()` method is redundant. The `aggregate()` method basically does the same
    thing as the `all()` method, meaning we could write our statement as follows and
    produce the same results:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前*步骤 2*中我们写了`Vehicle.objects.all().aggregate()`，这里的`all()`方法是多余的。`aggregate()`方法基本上与`all()`方法做同样的事情，这意味着我们可以将我们的语句写成如下，并产生相同的结果：
- en: '[PRE96]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We can also replace the `all()` method with any of the standard query methods,
    such as `get()` or `filter()`, as depicted in the following example:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用任何标准查询方法替换`all()`方法，如以下示例所示：
- en: '[PRE97]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Let's discuss annotations next.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论注解。
- en: Model method – annotate()
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型方法 – annotate()
- en: Annotations are used when we have objects that relate to other objects in a
    QuerySet and we want to generate a summary of every related object in that QuerySet.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在查询集中有与其它对象相关联的对象，并且我们想要生成该查询集中每个相关对象的摘要时，我们会使用注解。
- en: 'Follow these steps to practice using annotations:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤练习使用注解：
- en: 'Execute the following commands to provide a query of all sellers that exist
    in a table and then generate a count of only the sold vehicles that it finds:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令以提供查询所有存在于表中的卖家，然后生成仅找到的已售车辆的数量：
- en: '[PRE98]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Alter the preceding `filter` statement to count only the unsold vehicles, as
    shown:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的`filter`语句修改为仅计算未售出的车辆，如下所示：
- en: '[PRE99]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: We need to specify the index at `sellers[0]` because a `filter()` method will
    always return a collection of objects, even if the query only results in one object.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`sellers[0]`处指定索引，因为`filter()`方法总是会返回一个对象集合，即使查询只产生一个对象。
- en: 'Print the `sellers` collection to the screen, as shown:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`sellers`集合打印到屏幕上，如下所示：
- en: '[PRE100]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: We can see that there is only one `Seller` in the database at this time. We
    got the numbers `2` and then `5` as the results, for a total of seven vehicles
    that relate to that seller.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，目前数据库中只有一个 `Seller`。我们得到了数字 `2` 和 `5` 作为结果，总共是七个与该卖家相关的车辆。
- en: Next, we will discuss model managers and how they can be used to perform advanced
    queries.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论模型管理器以及它们如何用于执行高级查询。
- en: Writing model managers
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写模型管理器
- en: 'We now know that when we want to apply logic that pertains to a single object
    within a table, we will look into writing a model method. An advanced Django concept
    can allow us to add logic that would relate to the entire table of objects instead.
    That would be written using a `objects` manager, as in when we write a query statement
    such as `MyModel.objects.all()`. Since the `objects` manager is already created
    for us, there is technically no need for us to create a model manager at all.
    However, custom model managers can be used in a project to provide additional
    methods that the entire table uses. We will discuss a simple use of this concept
    that adds filters to a table. To learn more about how model managers can be used
    in more depth, visit the official Django documentation, found here: [https://docs.djangoproject.com/en/4.0/topics/db/managers/](https://docs.djangoproject.com/en/4.0/topics/db/managers/).'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，当我们想要应用与表中单个对象相关的逻辑时，我们将考虑编写模型方法。一个高级 Django 概念可以让我们添加与整个对象表相关的逻辑。这可以通过使用
    `objects` 管理器来实现，就像我们编写查询语句 `MyModel.objects.all()` 一样。由于 `objects` 管理器已经为我们创建，实际上我们根本不需要创建模型管理器。然而，自定义模型管理器可以在项目中使用，以提供整个表使用的额外方法。我们将讨论这个概念的简单用法，即向表中添加过滤器。要了解更多关于模型管理器如何深入使用的知识，请访问官方
    Django 文档，网址为：[https://docs.djangoproject.com/en/4.0/topics/db/managers/](https://docs.djangoproject.com/en/4.0/topics/db/managers/)。
- en: 'Take the following steps to apply a filter, separating the vehicle objects
    by make/manufacturer. Here, we will write a manager for the `Buick` vehicles and
    another manager for the `Chevy` vehicles. In a large project, it would also be
    wise to place your managers in a separate `managers.py` file and import them into
    `models.py` before using them. Let''s just add them all to the `models.py` file
    for now:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤应用过滤器，根据制造商/品牌区分车辆对象。在这里，我们将编写一个用于 `Buick` 车辆的管理器，另一个用于 `Chevy` 车辆的管理器。在一个大型项目中，将你的管理器放在一个单独的
    `managers.py` 文件中并在使用之前将其导入到 `models.py` 中也是一个明智的选择。现在，让我们先将它们全部添加到 `models.py`
    文件中：
- en: 'In the `/chapter_3/models.py` file, add the following two model manager classes
    above your model classes and below any existing `import` statements, as shown:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/chapter_3/models.py` 文件中，在你的模型类上方和任何现有的 `import` 语句下方添加以下两个模型管理器类，如下所示：
- en: '[PRE101]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'In the `/chapter_3/models.py` file, add the following three model manager statements
    to your existing `Vehicle` class, below the model fields found in that class and
    above the `Meta` subclass, as shown:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/chapter_3/models.py` 文件中，在你的 `Vehicle` 类中模型字段下方和 `Meta` 子类上方添加以下三个模型管理器语句，如下所示：
- en: '[PRE102]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Next, open your terminal or command-line window and activate your virtual environment
    and the Django shell. Then, import the `Vehicle` model into `InteractiveConsole`,
    as is done here:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开你的终端或命令行窗口，激活你的虚拟环境和 Django shell。然后，将 `Vehicle` 模型导入到 `InteractiveConsole`
    中，如下所示：
- en: '[PRE103]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Execute the following `objects` manager `count()` method:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下 `objects` 管理器 `count()` 方法：
- en: '[PRE104]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Execute the following `buick_objects` manager `count()` method:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下 `buick_objects` 管理器 `count()` 方法：
- en: '[PRE105]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Execute the following `chevy_objects` manager `count()` method:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下 `chevy_objects` 管理器 `count()` 方法：
- en: '[PRE106]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: What we get in return are the vehicles that relate to each manager that we created,
    starting with the `objects` manager, then `buick_objects` and `chevy_objects`.
    This counts the filtered objects instead of providing us with a total count of
    all objects in that table. Even though we are still using the `all()` method,
    we only get all of the objects related to that filter. We also apply the `count()`
    method to print a numeric count of what gets returned in a QuerySet versus printing
    the names of each object, as was depicted in previous query examples.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的是与每个我们创建的管理器相关的车辆，首先是 `objects` 管理器，然后是 `buick_objects` 和 `chevy_objects`。这计算了过滤后的对象数量，而不是提供该表中所有对象的总量。尽管我们仍在使用
    `all()` 方法，但我们只得到与该过滤器相关的所有对象。我们还应用了 `count()` 方法来打印返回的查询集的数字计数，而不是像之前查询示例中那样打印每个对象的名称。
- en: Summary
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned that models are building blocks of everything else
    we build that accesses data in a database. They provide the containers where all
    of a project's data will exist as a data storage device for this application.
    We now have a toolbox with tools related to the structure of the tables, such
    as the columns that exist or rules/constraints that we apply to them. Other tools
    help us to link these tables together that build the relationships between those
    tables. We also know how to transform the data that we have to provide other data
    not kept in those tables, but rather derived from it. Some of the concepts add
    performance power by doing work in the background, indexing data, and reducing
    the time that it takes to look up information. Querying objects is also a complex
    subject and there is a lot of material regarding it; use the concepts in this
    chapter to help guide you through researching more advanced ways of querying data,
    to help with complex real-world scenarios. Later, in [*Chapter 10*](B17243_10_ePub.xhtml#_idTextAnchor293),
    *Database Management*, we will discuss other tricks that help to enhance database
    performance when performing database queries.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到模型是我们构建的其他所有访问数据库数据的构建块。它们提供了容器，其中所有项目的数据都将作为此应用程序的数据存储设备存在。我们现在有一个工具箱，其中包含与表格结构相关的工具，例如存在的列或我们应用到的规则/约束。其他工具帮助我们将这些表格链接在一起，建立这些表格之间的关系。我们还知道如何将我们拥有的数据进行转换，以提供那些表格中未保存的其他数据，而是从中派生出来的。一些概念通过在后台执行工作、索引数据和减少查找信息所需的时间来增加性能。查询对象也是一个复杂的话题，有很多关于它的材料；使用本章中的概念来帮助您研究更高级的数据查询方式，以帮助处理复杂的现实世界场景。稍后，在[*第10章*](B17243_10_ePub.xhtml#_idTextAnchor293)
    *数据库管理*中，我们将讨论其他有助于在执行数据库查询时提高数据库性能的技巧。
- en: Next, let's take the models that we created in this chapter and render that
    data onto an actual web page, finally viewing something within a browser. These
    will be the URLs, views, and templates that we create in the next chapter.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将本章创建的模型渲染到实际的网页上，最终在浏览器中查看。这些将是我们在下一章中创建的URL、视图和模板。
