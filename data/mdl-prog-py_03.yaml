- en: Chapter 3. Using Modules and Packages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用模块和包
- en: 'To be able to use modules and packages within your Python programs, you need
    to understand how they work. In this chapter, we will examine the nuts and bolts
    of how modules and packages are defined and used in Python. In particular, we
    will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够在Python程序中使用模块和包，您需要了解它们的工作原理。在本章中，我们将研究模块和包在Python中是如何定义和使用的。特别是，我们将：
- en: Review how Python modules and packages are defined
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾Python模块和包的定义
- en: See how packages can be created inside other packages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看如何在其他包中创建包
- en: Discover how modules and packages can be initialized
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现模块和包如何初始化
- en: Learn more about the import process
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解更多关于导入过程
- en: Explore the notion of relative imports
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索相对导入的概念
- en: Learn how to control what gets imported
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何控制导入的内容
- en: Find out how to deal with circular dependencies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何处理循环依赖
- en: See how a module can be run directly from the command line, and why this can
    be useful
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看模块如何可以直接从命令行运行，以及为什么这很有用
- en: Modules and packages
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和包
- en: By now, you should be fairly comfortable with organizing your Python code into
    modules and then importing and using these modules in other modules and programs.
    This is only a taste of what can be done, however. Let's briefly review what Python
    modules and packages are before looking closer at how they work.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经相当熟悉如何将您的Python代码组织成模块，然后在其他模块和程序中导入和使用这些模块。然而，这只是一个小小的尝试。在深入了解它们如何工作之前，让我们简要回顾一下Python模块和包是什么。
- en: 'As we have seen, a **module** is simply a Python source file. You can import
    the module using the `import` statement:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，**模块**只是一个Python源文件。您可以使用`import`语句导入模块：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once this is done, you can refer to any functions, classes, variables, and
    other definitions within the module by prepending the module name to the item,
    for example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，您可以通过在项目名称前面添加模块名称来引用模块中的任何函数、类、变量和其他定义，例如：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In [Chapter 1](ch01.html "Chapter 1. Introducing Modular Programming"), *Introducing
    Modular Programming*, we learned that a Python **package** is a directory containing
    a special file named `__init__.py`. This is called the **package initialization
    file** and identifies the directory as a Python package. The package also typically
    contains one or more Python modules, for example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。介绍模块化编程")中，*介绍模块化编程*，我们了解到Python的**包**是一个包含名为`__init__.py`的特殊文件的目录。这被称为**包初始化文件**，并将目录标识为Python包。该包通常还包含一个或多个Python模块，例如：
- en: '![Modules and packages](graphics/B05012_3_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![模块和包](graphics/B05012_3_01.jpg)'
- en: 'To import the modules within this package, you add the package name to the
    start of the module name. For example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入此包中的模块，您需要在模块名称的开头添加包名称。例如：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also use an alternative version of the `import` statement to make your
    code easier to read:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`import`语句的另一种版本来使您的代码更易于阅读：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will look at the various ways in which you can use the `import` statement
    in the section *How to Import Anything* later in this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面的*如何导入任何内容*部分中查看您可以使用`import`语句的各种方式。
- en: Packages within packages
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含包的包
- en: 'Just like you can have directories within directories, you can have packages
    within other packages. For example, imagine that our `my_package` directory contained
    another directory called `my_sub_package`, which itself had an `__init__.py` file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您可以在目录中有子目录一样，您也可以在其他包中有包。例如，想象一下，我们的`my_package`目录包含另一个名为`my_sub_package`的目录，它本身有一个`__init__.py`文件：
- en: '![Packages within packages](graphics/B05012_3_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![包含包的包](graphics/B05012_3_02.jpg)'
- en: 'As you might expect, you import the modules within a sub-package by prepending
    the names of the packages that contain it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的那样，您可以通过在包含它的包的名称前面添加来导入子包中的模块：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There is no limit to how deeply you can nest packages, though in practice it
    becomes a bit unwieldy if you have too many levels of packages-within-packages.
    More interestingly, the various packages and sub-packages form a **tree-like structure**
    which allows you to organize even the most complex program. For example, a sophisticated
    business system might be arranged like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以无限嵌套包，但实际上，如果包含太多级别的包中包，它会变得有些难以管理。更有趣的是，各种包和子包形成了一个**树状结构**，这使您可以组织甚至最复杂的程序。例如，一个复杂的商业系统可能会被安排成这样：
- en: '![Packages within packages](graphics/B05012_3_03.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![包含包的包](graphics/B05012_3_03.jpg)'
- en: As you can see, this is called a tree-like structure because the packages-within-packages
    look like the spreading branches of a tree. A tree-like structure like this allows
    you to group logically-related parts of your program together, while ensuring
    that everything can be found when you need it. For example, using the structure
    described by the preceding illustration, you would access your customer data using
    the `program.logic.data.customers` package, and the various menus in your program
    would be defined by the `program.gui.widgets.menus` package.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这被称为树状结构，因为包中的包看起来像树的扩展分支。这样的树状结构使您可以将程序的逻辑相关部分组合在一起，同时确保在需要时可以找到所有内容。例如，使用前面插图描述的结构，您将使用`program.logic.data.customers`包访问客户数据，并且程序中的各种菜单将由`program.gui.widgets.menus`包定义。
- en: Obviously, this is an extreme example. Most programs—even very complex ones—won't
    be this complicated. But you can see how Python packages allow you to keep your
    program well organized, no matter how big and elaborate it becomes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是一个极端的例子。大多数程序——甚至非常复杂的程序——都不会这么复杂。但是您可以看到Python包如何使您能够保持程序的良好组织，无论它变得多么庞大和复杂。
- en: Initializing a module
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化模块
- en: 'When a module is imported, any top-level code within that module is executed.
    This has the effect of making the various functions, variables, and classes you
    defined in your module available for the caller to use. To see how this works,
    create a new Python source file named `test_module.py`, and enter the following
    code into this module:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个模块被导入时，该模块中的任何顶层代码都会被执行。这会使你在模块中定义的各种函数、变量和类对调用者可用。为了看看这是如何工作的，创建一个名为`test_module.py`的新Python源文件，并输入以下代码到这个模块中：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, open up a terminal window, `cd` into the directory where your `test_module.py`
    file is stored, and type `python` to start up the Python interpreter. Then try
    typing the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开一个终端窗口，`cd`到存储`test_module.py`文件的目录，并输入`python`启动Python解释器。然后尝试输入以下内容：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you do this, the Python interpreter prints the following message:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做时，Python解释器会打印以下消息：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It does this because all the top-level Python statements in the module—including
    the `def` statements and our `print` statement—are executed when the module is
    imported. You can then call the `foo` and `bar` functions, and access the `my_var`
    global, by prefixing the names with `my_module`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为模块中的所有顶层Python语句——包括`def`语句和我们的`print`语句——在模块被导入时都会被执行。然后你可以通过在名称前加上`my_module`来调用`foo`和`bar`函数，并访问`my_var`全局变量：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because all the top-level Python statements are executed when a module is imported,
    you can initialize a module by directly including the initialization statements
    in the module itself, just like the statement in our test module which sets `my_var`
    to zero. This means that the module will be automatically initialized when the
    module is imported.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因为模块被导入时会执行所有顶层的Python语句，所以你可以通过直接在模块中包含初始化语句来初始化一个模块，就像我们测试模块中设置`my_var`为零的语句一样。这意味着当模块被导入时，模块将自动初始化。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that a module is only imported once. If two modules import the same module,
    the second `import` statement will simply return a reference to the already-imported
    module, so you won't get the same module imported (and initialized) twice.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一个模块只会被导入一次。如果两个模块导入了同一个模块，第二个`import`语句将简单地返回对已经导入的模块的引用，因此你不会导入（和初始化）两次相同的模块。
- en: Initialization functions
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化函数
- en: This implicit initialization works, but it isn't necessarily a good practice.
    One of the guidelines promoted by the designers of the Python language is that
    *explicit is better than implicit*. In other words, having a module automatically
    initialize itself isn't always good coding practice, as it isn't always clear
    from reading the code exactly what gets initialized and what doesn't.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种隐式初始化是有效的，但不一定是一个好的实践。Python语言设计者提倡的指导方针之一是*显式优于隐式*。换句话说，让一个模块自动初始化并不总是一个好的编码实践，因为从代码中并不总是清楚哪些内容被初始化了，哪些没有。
- en: 'To avoid this confusion, and in order to follow the Python guidelines, it is
    often a good idea to explicitly initialize your modules. By convention, this is
    done by defining a top-level function called `init()` which performs all of the
    initialization for your module. For example, in our `test_module`, we could replace
    the `my_var = 0` statement with the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种混乱，并且为了遵循Python的指导方针，明确地初始化你的模块通常是一个好主意。按照惯例，这是通过定义一个名为`init()`的顶层函数来完成模块的所有初始化。例如，在我们的`test_module`中，我们可以用以下代码替换`my_var
    = 0`语句：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is a bit more verbose, but it makes the initialization explicit. Of course,
    you also have to remember to call `test_module.init()` before you use the module,
    usually from within your main program.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这会显得有点啰嗦，但它使初始化变得明确。当然，你还必须记得在使用模块之前调用`test_module.init()`，通常是在主程序中调用。
- en: One of the main advantages of explicit module initialization is that you can
    control the order in which your various modules get initialized. For example,
    if the initialization for module A includes calling a function in module B, and
    this function requires module B to have been initialized, the program will crash
    if the two modules are imported in the wrong order. This can get particularly
    difficult when modules import other modules, as the order in which modules are
    imported can be quite confusing. To avoid this, it's better to use explicit module
    initialization and have your main program call `B.init()` before it calls `A.init()`.
    This is a perfect example of why it's generally better to use explicit initialization
    functions for your modules.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 显式模块初始化的主要优势之一是你可以控制各个模块初始化的顺序。例如，如果模块A的初始化包括调用模块B中的函数，并且这个函数需要模块B已经被初始化，如果两个模块的导入顺序错误，程序将崩溃。当模块导入其他模块时，情况会变得特别困难，因为模块导入的顺序可能会非常令人困惑。为了避免这种情况，最好使用显式模块初始化，并让你的主程序在调用`A.init()`之前调用`B.init()`。这是一个很好的例子，说明为什么通常最好为你的模块使用显式初始化函数。
- en: Initializing a package
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化一个包
- en: 'To initialize a package, you place the Python code inside the package''s `__init__.py`
    file. This code is then executed when the package is imported. For example, imagine
    that you have a package named `test_package`, which contains an `__init__.py`
    file and one module named `test_module.py`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化一个包，你需要将Python代码放在包的`__init__.py`文件中。这段代码将在包被导入时执行。例如，假设你有一个名为`test_package`的包，其中包含一个`__init__.py`文件和一个名为`test_module.py`的模块：
- en: '![Initializing a package](graphics/B05012_3_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![初始化一个包](graphics/B05012_3_04.jpg)'
- en: You can place whatever code you like inside the `__init__.py` file, and when
    the package (or a module within the package) is imported for the first time, that
    code will be executed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`__init__.py`文件中放置任何你喜欢的代码，当包（或包内的模块）第一次被导入时，该代码将被执行。
- en: You might be wondering why you might want to do this. Initializing a module
    makes sense as a module contains various functions that might need to be initialized
    before they are used (for example, by setting global variables to an initial value).
    But why initialize a package, rather than just a module within that package?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么要这样做。初始化一个模块是有道理的，因为一个模块包含了可能需要在使用之前初始化的各种函数（例如，通过将全局变量设置为初始值）。但为什么要初始化一个包，而不仅仅是包内的一个模块？
- en: 'The answer lies in what happens when you import a package. When you do this,
    anything you define in the package''s `__init__.py` file becomes available at
    the package level. For example, imagine that your `__init__.py` file contained
    the following Python code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在于当你导入一个包时发生了什么。当你这样做时，你在包的`__init__.py`文件中定义的任何东西都可以在包级别使用。例如，想象一下，你的`__init__.py`文件包含了以下Python代码：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then you could access this function from your main program in the following
    way:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以通过以下方式从主程序中访问这个函数：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You don't need to define the `say_hello()` function inside a module within the
    package for it to be easily accessed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要在包内的模块中定义`say_hello()`函数，它就可以很容易地被访问。
- en: As a general principle, however, adding code to the `__init__.py` file isn't
    a great idea. It works, but people looking through your package's source code
    will expect the package's code to be defined inside modules rather than in the
    package initialization file. Also, there is only one `__init__.py` file for the
    whole package, which makes organizing your code within the package more difficult.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个一般原则，向`__init__.py`文件添加代码并不是一个好主意。它可以工作，但是查看包源代码的人会期望包的代码被定义在模块内，而不是在包初始化文件中。另外，整个包只有一个`__init__.py`文件，这使得在包内组织代码变得更加困难。
- en: 'A better way of using package initialization files is to write your code in
    modules within the package, and then use the `__init__.py` file to import this
    code so that it is available at the package level. For example, you might implement
    the `say_hello()` function within the `test_module` module, and then include the
    following in the package''s `__init__.py` file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的使用包初始化文件的方法是在包内的模块中编写代码，然后使用`__init__.py`文件导入这些代码，以便在包级别使用。例如，你可以在`test_module`模块中实现`say_hello()`函数，然后在包的`__init__.py`文件中包含以下内容：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Programs using your package would still call the `say_hello()` function in exactly
    the same way. The only difference is that this function is now implemented as
    part of the `test_module` module, rather than being lumped inside the `__init__.py`
    file for the entire package.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的包的程序仍然可以以完全相同的方式调用`say_hello()`函数。唯一的区别是，这个函数现在作为`test_module`模块的一部分实现，而不是被整个包的`__init__.py`文件包含在一起。
- en: This is a very useful technique, especially as your packages get more complicated
    and you have lots of functions, classes, and other definitions which you want
    to make available. By adding `import` statements to your package initialization
    file, you can write the parts of your package in whatever modules make the most
    sense to you, and then choose which functions, classes, and so on to make available
    at the package level.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用的技术，特别是当你的包变得更加复杂，你有很多函数、类和其他定义想要提供。通过向包初始化文件添加`import`语句，你可以在任何模块中编写包的部分，然后选择哪些函数、类等在包级别可用。
- en: One of the nice things about using `__init__.py` files in this way is that the
    various `import` statements tell the users of your package which functions and
    classes they should be using; if you haven't included a module or function in
    your package initialization file, then it's probably excluded for a reason.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`__init__.py`文件的一个好处是，各种`import`语句告诉包的用户他们应该使用哪些函数和类；如果你没有在包初始化文件中包含一个模块或函数，那么它可能被排除是有原因的。
- en: Using `import` statements in a package initialization file also tells the users
    of your package where the various parts of a complex package are located—the `__init__.py`
    file acts as a kind of index into the package's source code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在包初始化文件中使用`import`语句还告诉包的用户复杂包的各个部分的位置——`__init__.py`文件充当了包源代码的一种索引。
- en: To summarize, while you can include any Python code you like within a package's
    `__init__.py` file, it's probably best if you limit yourself to `import` statements,
    and keep your real package code elsewhere.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，虽然你可以在包的`__init__.py`文件中包含任何你喜欢的Python代码，但最好限制自己只使用`import`语句，并将真正的包代码放在其他地方。
- en: How to import anything
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何导入任何东西
- en: 'So far, we have used two different versions of the `import` statement:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了`import`语句的两种不同版本：
- en: 'Importing a module and then using the module name to access something defined
    within that module. For example:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入一个模块，然后使用模块名来访问在该模块中定义的东西。例如：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Importing something from a module and then using that thing directly. For example:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模块中导入某些东西，然后直接使用那个东西。例如：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `import` statement is very powerful, however, and we can do all sorts of
    interesting things with it. In this section, we will look at the different ways
    in which you can use the `import` statement to import modules and packages, and
    their contents, into your program.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`import`语句非常强大，我们可以用它做各种有趣的事情。在本节中，我们将看看你可以使用`import`语句以及它们的内容将模块和包导入到你的程序中的不同方式。
- en: What does the import statement actually do?
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入语句实际上是做什么？
- en: 'Whenever you create a global variable or function, the Python interpreter adds
    the name of that variable or function to what is called the **global namespace**.
    The global namespace holds all the names that you have defined at the global level.
    To see how this works, enter the following command into the Python interpreter:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你创建一个全局变量或函数时，Python解释器都会将该变量或函数的名称添加到所谓的**全局命名空间**中。全局命名空间包含了你在全局级别定义的所有名称。要查看这是如何工作的，输入以下命令到Python解释器中：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `globals()` built-in function returns a dictionary with the current contents
    of the global namespace:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`globals()`内置函数返回一个带有全局命名空间当前内容的字典：'
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't worry about the various oddly named globals such as `__package__`; these
    are used internally by the Python interpreter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心各种奇怪命名的全局变量，例如`__package__`；这些是Python解释器内部使用的。
- en: 'Now, let''s define a new top-level function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个新的顶级函数：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we now print out the dictionary of global names, our `test()` function will
    be included:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在打印全局名称的字典，我们的`test()`函数将被包括在内：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are several other entries in the `globals()` dictionary, but from now
    on we'll only show the items that interest us so that these examples aren't too
    confusing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`globals()`字典中还有其他几个条目，但从现在开始，我们只会显示我们感兴趣的项目，以便这些示例不会太令人困惑。'
- en: As you can see, the name `test` has been added to our global namespace.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，名称`test`已添加到我们的全局命名空间中。
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Once again, don't worry about the value associated with the `test` name; this
    is Python's internal way of storing the functions that you define.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，不要担心与`test`名称关联的值；这是Python存储您定义的函数的内部方式。
- en: 'When something is in the global namespace, you can access it by name from anywhere
    in your program:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当某物在全局命名空间中时，您可以通过程序中的任何位置的名称访问它：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that there's a second namespace, called the **local namespace**, that holds
    variables and other things defined within the current function. While the local
    namespace is important when it comes to variable scope, we're going to ignore
    it as it isn't generally involved in importing modules.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，还有第二个命名空间，称为**局部命名空间**，其中保存了当前函数中定义的变量和其他内容。虽然局部命名空间在变量范围方面很重要，但我们将忽略它，因为它通常不涉及导入模块。
- en: 'Now, when you use the `import` statement, you are adding entries to the global
    namespace:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您使用`import`语句时，您正在向全局命名空间添加条目：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see, the module that you imported has been added to the global namespace,
    allowing you to access that module by name, for example like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，您导入的模块已添加到全局命名空间中，允许您通过名称访问该模块，例如像这样：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the same way, if you used the `from...import` version of the `import` statement,
    the item you''ve imported will be added directly to the global namespace:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果您使用`import`语句的`from...import`版本，您导入的项目将直接添加到全局命名空间中：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So now you know what the `import` statement does: it adds what you''re importing
    to the global namespace so that you can access it.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道`import`语句的作用：它将您要导入的内容添加到全局命名空间，以便您可以访问它。
- en: Using the import statement
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用导入语句
- en: Now that we've seen what the `import` statement does, let's take a look at the
    different versions of the `import` statement that Python provides.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了`import`语句的作用，让我们来看看Python提供的`import`语句的不同版本。
- en: 'We''ve already seen the two most common forms of the `import` statement:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`import`语句的两种最常见形式：
- en: '`import <something>`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import <something>`'
- en: '`from <somewhere> import <something>`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from <somewhere> import <something>`'
- en: 'With the first form, you aren''t limited to importing modules one at a time.
    If you want, you can import multiple modules at once, like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第一种形式时，您不限于一次导入一个模块。如果愿意，您可以一次导入多个模块，就像这样：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Similarly, you can import multiple things at once from a module or package:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以一次从模块或包中导入多个项目：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you have more items to import than will fit on one line, you can either
    use line continuation characters (`\`) to spread the import across multiple lines,
    or surround the list of items that you want to import with parentheses. For example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要导入的项目比一行所能容纳的要多，您可以使用行继续字符（`\`）将导入扩展到多行，或者用括号括起要导入的项目列表。例如：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When you import something, you can also change the name of the imported item:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当您导入某物时，您还可以更改所导入项目的名称：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this case, you are importing the `math` module under the name `math_ops`.
    The `math` module will be added to your global namespace using the name `math_ops`,
    and you can access the `math` module''s contents using the `math_ops` name:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您正在将`math`模块导入为名称`math_ops`。`math`模块将使用名称`math_ops`添加到全局命名空间中，您可以使用`math_ops`名称访问`math`模块的内容：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There are two reasons why you might want to use the `import...as` statement
    to change the name of something when you import it:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个原因可能要使用`import...as`语句来更改导入时的名称：
- en: To make a long or unwieldy name easier to type.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使长名称或难以处理的名称更容易输入。
- en: 'To avoid naming conflicts. For example, if you are using two packages that
    both define a module named `utils`, you might want to use the `import...as` statement
    so that the names are different. For example:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免命名冲突。例如，如果您使用了两个都定义了名为`utils`的模块的包，您可能希望使用`import...as`语句，以便名称不同。例如：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that you should probably use the `import...as` statement sparingly. Every
    time you change the name of something, you (and anyone reading your code) will
    have to remember that `X` is another name for `Y`, which adds complexity and means
    that you have more things to remember as you write your program. There are certainly
    legitimate uses for the `import...as` statement, but don't overuse it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可能应该谨慎使用`import...as`语句。每次更改某物的名称时，您（以及任何阅读您代码的人）都必须记住`X`是`Y`的另一个名称，这增加了复杂性，并意味着您在编写程序时需要记住更多的事情。`import...as`语句当然有合法的用途，但不要过度使用它。
- en: 'You can, of course, combine the `from...import` statement with `import...as`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以将`from...import`语句与`import...as`结合使用：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, you can use a **wildcard import** to import everything from a module
    or package in one fell swoop:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用**通配符导入**一次性从模块或包中导入所有内容：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This adds all the items defined in the `math` module into the current global
    namespace. If you are importing from a package, then all the items defined in
    the package's `__init__.py` file will be imported.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将所有在`math`模块中定义的项目添加到当前全局命名空间。如果您从包中导入，则将导入包的`__init__.py`文件中定义的所有项目。
- en: By default, everything in the module (or package) that doesn't start with an
    underscore character will be imported by a wildcard import. This ensures that
    private variables and functions won't be imported. If you want, however, you can
    change what gets included in a wildcard import by using the `__all__` variable;
    this will be discussed in the *Controlling what gets imported* section later in
    this chapter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，模块（或包）中以下划线字符开头的所有内容都将被通配符导入。这确保了私有变量和函数不会被导入。然而，如果你愿意，你可以通过使用`__all__`变量来改变通配符导入中包含的内容；这将在本章后面的*控制导入内容*部分中讨论。
- en: Relative imports
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相对导入
- en: So far, whenever we've imported something, we've used the full name of the module
    or package that we want to import from. For simple imports such as `from math
    import pi`, this is sufficient. There are times, however, when this type of importing
    can be quite cumbersome.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，每当我们导入东西时，我们都使用了要从中导入的模块或包的完整名称。对于简单的导入，比如`from math import pi`，这是足够的。然而，有时这种类型的导入可能会相当繁琐。
- en: 'Consider, for example, the complex tree of packages that we looked at in the
    *Packages within packages* section earlier in this chapter. Imagine that we want
    to import a module named `slider.py` from within the `program.gui.widgets.editor`
    package:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑我们在本章前面的*包内包*部分中看到的复杂包树。假设我们想要从`program.gui.widgets.editor`包内导入名为`slider.py`的模块：
- en: '![Relative imports](graphics/B05012_3_06.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![相对导入](graphics/B05012_3_06.jpg)'
- en: 'You could import this module using the following Python statement:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下Python语句导入这个模块：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `program.gui.widgets.editor` part of the `import` statement identifies the
    package where the `slider` module can be found.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句中的`program.gui.widgets.editor`部分标识了`slider`模块所在的包。'
- en: While this works, it can be quite unwieldy, especially if you have a lot of
    modules to import or if one part of a package needs to import several other modules
    from within the same package.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样可以工作，但它可能会相当笨拙，特别是如果你需要导入许多模块，或者如果包的某个部分需要从同一个包内导入多个其他模块。
- en: 'To handle this type of situation, Python supports the concept of **relative
    imports**. Using relative imports, you identify what you want to import relative
    to the current module''s position within the tree of packages. For example, imagine
    that the `slider` module wanted to import another module within the `program.gui.widgets.editor`
    package:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种情况，Python支持**相对导入**的概念。使用相对导入，你可以确定相对于包树中当前模块位置的位置导入你想要的内容。例如，假设`slider`模块想要从`program.gui.widgets.editor`包内导入另一个模块：
- en: '![Relative imports](graphics/B05012_3_07.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![相对导入](graphics/B05012_3_07.jpg)'
- en: 'To do this, you replace the package name with a `.` character:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，你用`.`字符替换包名：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `.` character is a shorthand for *the current package*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`.`字符是*当前包*的简写。'
- en: 'In a similar way, imagine that you have a module within the `program.gui.widgets`
    package that wants to import the `slider` module from the `editor` sub-package:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，假设你有一个在`program.gui.widgets`包内的模块想要从`editor`子包内导入`slider`模块：
- en: '![Relative imports](graphics/B05012_3_08.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![相对导入](graphics/B05012_3_08.jpg)'
- en: 'In this case, your `import` statement would look like the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你的`import`语句将如下所示：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `.` character still refers to the current location, and `editor` is the
    name of the package relative to this current location. In other words, you are
    telling Python to look for a package named `editor` in the current location, and
    then import the module named `slider` within this package.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`.`字符仍然指的是当前位置，`editor`是相对于当前位置的包的名称。换句话说，你告诉Python在当前位置查找名为`editor`的包，然后导入该包内的名为`slider`的模块。'
- en: 'Let''s consider the opposite situation. Imagine that the `slider` module wants
    to import a module from the `widgets` directory:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑相反的情况。假设`slider`模块想要从`widgets`目录中导入一个模块：
- en: '![Relative imports](graphics/B05012_3_09.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![相对导入](graphics/B05012_3_09.jpg)'
- en: 'In this case, you can use two `.` characters to mean *go up one level*:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以使用两个`.`字符来表示*向上移动一个级别*：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you might imagine, you can use three `.` characters to mean *go up two levels*
    and so on. You can also combine these techniques to move through the package hierarchy
    in any way you like. For example, imagine that the `slider` module wants to import
    a module named `errDialog` from the `gui.dialogs.errors` package:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想象的那样，你可以使用三个`.`字符来表示*向上移动两个级别*，依此类推。你也可以结合这些技术以任何你喜欢的方式在包层次结构中移动。例如，假设`slider`模块想要从`gui.dialogs.errors`包内导入名为`errDialog`的模块：
- en: '![Relative imports](graphics/B05012_3_10.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![相对导入](graphics/B05012_3_10.jpg)'
- en: 'Using relative imports, the `slider` module could import the `errDialog` module
    in the following way:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相对导入，`slider`模块可以以以下方式导入`errDialog`模块：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, you can use these techniques to select any module or package
    anywhere in the tree of packages, relative to your current position in the tree.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以使用这些技术来选择树状包结构中任何位置的模块或包。
- en: 'There are two main reasons for using relative imports:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相对导入有两个主要原因：
- en: They're a great way of making your `import` statements shorter and easier to
    read. Instead of having to type `from` `program.gui.widgets.editor import utils`
    in the `slider` module, you can simply type `from . import utils`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们是使你的`import`语句更短、更易读的好方法。在`slider`模块中，你不必再输入`from` `program.gui.widgets.editor
    import utils`，而是可以简单地输入`from . import utils`。
- en: When you write a package for others to use, you can have different modules within
    your package refer to each other without having to worry about where the user
    installed the package. For example, I might take a package you've written and
    place it inside another package; using relative imports, your package will continue
    to work without having to change all the `import` statements to reflect the new
    package structure.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你为他人编写一个包时，你可以让包内的不同模块相互引用，而不必担心用户安装包的位置。例如，我可能会拿到你写的一个包并将其放入另一个包中；使用相对导入，你的包将继续工作，而无需更改所有`import`语句以反映新的包结构。
- en: Like anything, relative imports can be overused. Because the meaning of the
    `import` statement depends on the position of the current module, relative imports
    tend to violate the *explicit is better than implicit* principle. You can also
    get into trouble if you attempt to run a module from the command line, as described
    in the *Running modules from the command line* section later in this chapter.
    For these reasons, you should use relative imports sparingly, and stick to fully
    listing out the entire package hierarchy in your `import` statements unless you
    have a good reason not to.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何东西一样，相对导入可能会被滥用。因为`import`语句的含义取决于当前模块的位置，相对导入往往违反了“显式优于隐式”的原则。如果你尝试从命令行运行一个模块，也会遇到麻烦，这在本章后面的“从命令行运行模块”部分有描述。因此，除非有充分的理由，你应该谨慎使用相对导入，并坚持在`import`语句中完整列出整个包层次结构。
- en: Controlling what gets imported
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制导入的内容
- en: When you import a module or package, or when you use a wildcard import such
    as `from my_module import *`, the Python interpreter loads the contents of the
    given module or package into your global namespace. If you are importing from
    a module, all of the top-level functions, constants, classes, and other definitions
    will be imported. When importing from a package, all of the top-level functions,
    constants, and so on defined in the package's `__init__.py` file will be imported.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入一个模块或包，或者使用通配符导入，比如`from my_module import *`，Python解释器会将给定模块或包的内容加载到你的全局命名空间中。如果你从一个模块导入，所有顶层函数、常量、类和其他定义都会被导入。当从一个包导入时，包的`__init__.py`文件中定义的所有顶层函数、常量等都会被导入。
- en: By default, these imports load *everything* from the given module or package.
    The only exception is that a wildcard import will automatically skip any function,
    constant, class, or other definition starting with an underscore—this has the
    effect of excluding private definitions from the wildcard import.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这些导入会从给定的模块或包中加载*所有*内容。唯一的例外是通配符导入会自动跳过任何以下划线开头的函数、常量、类或其他定义——这会导致通配符导入排除私有定义。
- en: While this default behavior generally works well, there are times when you may
    want more control over what gets imported. To do this, you can use a special variable
    named `__all__`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种默认行为通常运行良好，但有时你可能希望更多地控制导入的内容。为此，你可以使用一个名为`__all__`的特殊变量。
- en: 'To see how the `__all__` variable works, take a look at the following module:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看`__all__`变量是如何工作的，让我们看一下以下模块：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you imported this module, only `A` and `B` would be imported. While the module
    defines the variable `C`, this definition would be skipped because it isn't included
    in the `__all__` list.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导入这个模块，只有`A`和`B`会被导入。虽然模块定义了变量`C`，但这个定义会被跳过，因为它没有包含在`__all__`列表中。
- en: 'Within a package, the `__all__` variable behaves in the same way, with one
    important difference: you can also include the name of modules and sub-packages
    that you want to include when the package is imported. For example, a package''s
    `__init__.py` file might contain only the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个包内，`__all__`变量的行为方式相同，但有一个重要的区别：你还可以包括你希望在导入包时包含的模块和子包的名称。例如，一个包的`__init__.py`文件可能只包含以下内容：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this case, the `__all__` variable controls which modules and packages to
    include; when you import this package, the two modules and the sub-package will
    be imported automatically.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`__all__`变量控制要包含的模块和包；当你导入这个包时，这两个模块和子包将被自动导入。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that the preceding `__init.py__` file is equivalent to the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的`__init.py__`文件等同于以下内容：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Both versions of the `__init__.py` file would have the effect of including the
    two modules and the sub-package within the package.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__.py`文件的两个版本都会导致包中包含这两个模块和子包。'
- en: 'While you don''t need to use it, the `__all__` variable gives you complete
    control over your imports. The `__all__` variable can also be a useful way of
    indicating to users of your modules and packages which parts of your code they
    should be using: if something isn''t included in the `__all__` list, then it''s
    not intended to be used by external code.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你不一定需要使用它，`__all__`变量可以完全控制你的导入。`__all__`变量也可以是向模块和包的用户指示他们应该使用你代码的哪些部分的有用方式：如果某些东西没有包含在`__all__`列表中，那么它就不打算被外部代码使用。
- en: Circular dependencies
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环依赖
- en: 'One of the annoying problems that you are likely to face while working with
    modules is what is known as circular dependencies. To understand what these are,
    consider the following two modules:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模块时，你可能会遇到的一个令人讨厌的问题是所谓的循环依赖。要理解这些是什么，考虑以下两个模块：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'While this is a contrived example, you can see that `module_1` imports something
    from `module_2`, and `module_2` imports something from `module_1`. If you tried
    to run a program containing these two modules, you would see the following error
    when `module_1` is imported:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个假设的例子，你可以看到`module_1`从`module_2`导入了一些东西，而`module_2`又从`module_1`导入了一些东西。如果你尝试运行包含这两个模块的程序，当导入`module_1`时，你会看到以下错误：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you tried to import `module_2` instead, you would get a similar error. With
    the code organized in this way, you''re stuck: you can''t import either module
    as both depend on the other.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试导入`module_2`，你会得到类似的错误。以这种方式组织代码，你就陷入了困境：你无法导入任何一个模块，因为它们都相互依赖。
- en: To get around this, you would have to restructure your modules so that they
    don't depend on each other. In this example, you could create a third module,
    named `module_3`, and move the `calc_markup()` function to that module. This would
    make `module_1` dependent on `module_3`, rather than `module_2`, which breaks
    the circular dependency.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你需要重新构建你的模块，使它们不再相互依赖。在这个例子中，你可以创建一个名为`module_3`的第三个模块，并将`calc_markup()`函数移动到该模块中。这将使`module_1`依赖于`module_3`，而不是`module_2`，从而打破了循环依赖。
- en: Tip
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There are other tricks you can perform to avoid circular dependency errors,
    for example by moving the `import` statement inside a function. In general, however,
    a circular dependency means that your code is badly designed, and you should refactor
    your code to remove the circular dependency entirely.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些技巧可以避免循环依赖错误，例如将`import`语句放在一个函数内部。然而，一般来说，循环依赖意味着你的代码设计有问题，你应该重构你的代码以完全消除循环依赖。
- en: Running modules from the command line
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从命令行运行模块
- en: 'In [Chapter 2](ch02.html "Chapter 2. Writing Your First Modular Program"),
    *Writing Your First Modular Program*, we saw your system''s main program is often
    named `main.py` and typically has the following structure:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。编写你的第一个模块化程序")*编写你的第一个模块化程序*中，我们看到你系统的主程序通常被命名为`main.py`，并且通常具有以下结构：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `__name__` global variable will be set to the value `"__main__"` by the
    Python interpreter when the user runs your program. This has the effect of calling
    your `main()` function when the program is run.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户运行你的程序时，Python解释器会将`__name__`全局变量设置为值`"__main__"`。这会在程序运行时调用你的`main()`函数。
- en: There is nothing special about the `main.py` program, however; it's just another
    Python source file. You can take advantage of this to make your Python modules
    executable from the command line.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.py`程序并没有什么特别之处；它只是另一个Python源文件。你可以利用这一点，使你的Python模块能够从命令行运行。'
- en: 'Consider, for example, the following module, which we will call `double.py`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下模块，我们将其称为`double.py`：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This module defines some functionality, in this case a function named `double()`,
    and then uses the `if __name__ == "__main__"` trick to demonstrate and test the
    module''s functionality when it is run from the command line. Let''s try running
    this module to see how it works:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块定义了一些功能，比如一个名为`double()`的函数，然后使用`if __name__ == "__main__"`的技巧来演示和测试模块在从命令行运行时的功能。让我们尝试运行这个模块，看看它是如何工作的：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Another common use for a runnable module is to allow the end user to directly
    access the module''s functionality from the command line. To see how this works,
    create a new module named `funkycase.py`, and enter the following into this file:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 可运行模块的另一个常见用途是允许最终用户直接从命令行访问模块的功能。要了解这是如何工作的，创建一个名为`funkycase.py`的新模块，并输入以下内容到这个文件中：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `funky_case()` function takes a string and capitalizes every second letter.
    If you wanted to, you could import this module and then access this function from
    within your program:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`funky_case()` 函数接受一个字符串，并将每第二个字母大写。如果你愿意，你可以导入这个模块，然后在你的程序中访问这个函数：'
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'While this is useful, we also want to let the user run the `funkycase.py` module
    as a standalone program, directly converting the supplied string to funky-case
    and printing it out to the user can see it. To do this, we can use the `if __name__
    == "__main__"` trick along with `sys.argv` to extract the string supplied by the
    user. We can then call the `funky_case()` function to convert this string to funky-case
    and print it out. To do this, add the following code to the end of your `funkycase.py`
    module:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很有用，但我们也希望让用户直接运行`funkycase.py`模块作为一个独立的程序，直接将提供的字符串转换为funky-case并打印出来给用户看。为了做到这一点，我们可以使用`if
    __name__ == "__main__"`的技巧以及`sys.argv`来提取用户提供的字符串。然后我们可以调用`funky_case()`函数来将这个字符串转换为funky-case并打印出来。为此，将以下代码添加到你的`funkycase.py`模块的末尾：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Also, add the following to the top of your module:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，将以下内容添加到你的模块顶部：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can now run this module directly as if it was a standalone program:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以直接运行这个模块，就像它是一个独立的程序一样：
- en: '[PRE48]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this way, `funkycase.py` acts as a kind of *chameleon module*. To other Python
    source files, it appears as just another module that can be imported and used,
    while to the end user it looks like a standalone program that can be run from
    the command line.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，`funkycase.py` 充当了一种*变色龙模块*。对于其他的Python源文件，它看起来就像是可以导入和使用的另一个模块，而对于最终用户来说，它看起来像是一个可以从命令行运行的独立程序。
- en: Tip
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that if you want to make a module executable from the command line, you
    aren't limited to just using `sys.argv` to accept and process the arguments supplied
    by the user. The excellent `argparse` module in the Python Standard Library allows
    you to write Python programs (and modules) that accept a wide range of inputs
    and options from the user. If you haven't used this module before, do check it
    out.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你想让一个模块能够从命令行运行，你不仅仅可以使用`sys.argv`来接受和处理用户提供的参数。Python标准库中的优秀`argparse`模块允许你编写接受用户各种输入和选项的Python程序（和模块）。如果你以前没有使用过这个模块，一定要试试。
- en: 'There is one issue to be aware of when you create a module that can be run
    from the command line: if your module uses relative imports, your imports will
    fail with an *attempted relative import of non-package* error when you run it
    directly using the Python interpreter. This error occurs because a module forgets
    about its position within the package hierarchy when it is run from the command
    line. As long as your module doesn''t use any command-line arguments, you can
    get around this problem by using Python''s `-m` command-line option, like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个可以从命令行运行的模块时，有一个需要注意的问题：如果你的模块使用相对导入，当你直接使用Python解释器运行时，你的导入将会失败，并出现*尝试相对导入非包*的错误。这个错误是因为当模块从命令行运行时，它会忘记它在包层次结构中的位置。只要你的模块不使用任何命令行参数，你可以通过使用Python的`-m`命令行选项来解决这个问题，就像这样：
- en: '[PRE49]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: However, if your module does accept command-line arguments, then you will need
    to replace your relative imports so that this problem doesn't occur. There are
    workarounds, but they are kludgy and not recommended for general use.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您的模块确实接受命令行参数，那么您将需要替换相对导入，以避免出现这个问题。虽然有解决方法，但它们很笨拙，不建议一般使用。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at the details of how Python modules and packages
    work. We saw that modules are simply Python source files that get imported using
    an `import` statement, and that packages are directories of Python source files
    identified by a package initialization file named `__init__.py`. We learned that
    packages can be defined inside other packages to form a tree-like structure of
    nested packages. We looked at how modules and packages can be initialized, and
    how the `import` statement can be used in various ways to import modules and packages,
    and their contents, into your programs.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入了解了Python模块和包的工作原理。我们看到模块只是使用`import`语句导入的Python源文件，而包是由名为`__init__.py`的包初始化文件标识的Python源文件目录。我们了解到包可以定义在其他包内，形成嵌套包的树状结构。我们看了模块和包如何初始化，以及`import`语句如何以各种方式导入模块和包及其内容到您的程序中。
- en: We then saw how relative imports can be used to import modules relative to your
    current position in the package hierarchy and how the `__all__` variable can be
    used to control what gets included in an import.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看到了相对导入如何用于相对于包层次结构中的当前位置导入模块，以及`__all__`变量如何用于控制导入的内容。
- en: We then learned about circular dependencies and how to avoid them, and we finished
    by learning about chameleon modules, which can act as both importable modules
    and as standalone programs that can be run from the command line.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们了解了循环依赖以及如何避免它们，最后学习了变色龙模块，它可以作为可导入的模块，也可以作为可以从命令行运行的独立程序。
- en: In the next chapter, we will apply what we have learned to the design and implementation
    of a more complicated program, and we will see how a good understanding of these
    techniques will let us build a system that is robust and can be updated to meet
    changing requirements.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将应用所学知识来设计和实现一个更复杂的程序，我们将看到对这些技术的深入理解将使我们能够构建一个健壮的系统，并能够根据不断变化的需求进行更新。
