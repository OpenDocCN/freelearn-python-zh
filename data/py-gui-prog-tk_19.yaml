- en: B
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: B
- en: A Quick SQL Tutorial
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速 SQL 教程
- en: For over three decades, relational database systems have remained a de facto
    standard for storing business data. They are more commonly known as SQL databases,
    after the **Structured Query Language** (**SQL**) used to interact with them.
    Although a full treatment of SQL warrants a book of its own, this appendix will
    provide a brief coverage of its basic concepts and syntax that will be adequate
    for following its usage in this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 超过三十年，关系型数据库系统一直是存储商业数据的实际标准。它们更常见地被称为 SQL 数据库，这是由于与它们交互所使用的 **结构化查询语言**（**SQL**）。尽管对
    SQL 的全面处理需要一本自己的书，但本附录将简要介绍其基本概念和语法，这将足以跟随本书中对其的使用。
- en: SQL concepts
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 概念
- en: 'SQL databases are made up of **tables**. A table is something like a CSV or
    spreadsheet file, in that it has rows representing individual items and columns
    representing data values associated with each item. A SQL table has some important
    differences from a spreadsheet, though:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 数据库由 **表** 组成。表就像 CSV 或电子表格文件，因为它有行表示单个项目，列表示与每个项目关联的数据值。尽管 SQL 表与电子表格有一些重要区别：
- en: First, each column in the table is assigned a **data type**, which is strictly
    enforced. Just as Python will produce an error when you try to convert `"abcd"`
    to an `int` or `0.03` into a `date`, a SQL database will return an error if you
    try to insert letters into a numeric column or decimal values into a date column.
    SQL databases typically support basic data types like text, numbers, dates and
    times, Boolean values, and binary data; in addition, some implementations have
    specialized data types for things like IP addresses, JSON data, currency, or images.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，表中的每一列都被分配了一个 **数据类型**，这是严格强制执行的。就像 Python 会在你尝试将 `"abcd"` 转换为 `int` 或 `0.03`
    转换为 `date` 时产生错误一样，如果尝试将字母插入到数字列或十进制值插入到日期列中，SQL 数据库也会返回错误。SQL 数据库通常支持基本数据类型，如文本、数字、日期和时间、布尔值和二进制数据；此外，一些实现还有一些专门的数据类型，用于诸如
    IP 地址、JSON 数据、货币或图像等事物。
- en: SQL tables can also have **constraints**, which further enforce the validity
    of data inserted into the table. For example, a column can be given a **unique
    constraint**, which prevents two rows from having the same value in that column,
    or a **not null** constraint, which means that every row must have a value.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 表也可以有 **约束**，这进一步确保了插入到表中的数据的有效性。例如，一列可以指定一个 **唯一约束**，这防止两行在该列中有相同的值，或者一个
    **非空约束**，这意味着每一行都必须有一个值。
- en: SQL databases commonly contain many tables, and these can be joined together
    to represent much more complicated data structures. By breaking data into multiple
    linked tables, we can store it in a way that is much more efficient and resilient
    than a two-dimensional plaintext CSV file.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 数据库通常包含许多表，这些表可以连接起来以表示更复杂的数据结构。通过将数据分解成多个链接的表，我们可以以比二维纯文本 CSV 文件更高效和更具弹性的方式存储它。
- en: Syntax differences from Python
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Python 的语法差异
- en: 'If you''ve only ever programmed in Python, SQL may feel odd at first, as the
    rules and syntax are very different. We''ll be going over the individual commands
    and keywords, but here are some general differences from Python:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前只使用过 Python 编程，SQL 可能一开始会感觉有些奇怪，因为规则和语法非常不同。我们将介绍单个命令和关键字，但这里有一些与 Python
    的一般差异：
- en: 'SQL is (mostly) **case-insensitive**: Although it''s conventional for readability
    purposes to type the SQL keywords in all caps, most SQL implementations are not
    case-sensitive. There are a few small exceptions here and there, but, for the
    most part, you can type SQL in whatever case is easiest for you.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 是（大部分）**不区分大小写**的：虽然为了可读性目的，通常会将 SQL 关键字全部大写，但大多数 SQL 实现并不区分大小写。这里和那里有一些小的例外，但总的来说，你可以用对你最容易的任何大小写来输入
    SQL。
- en: '**Whitespace** is not significant: In Python, new lines and indentation can
    change the meaning of a piece of code. In SQL, whitespace is not significant and
    statements are terminated with a semicolon. Indents and new lines in a query are
    only there for readability.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空白**没有意义：在 Python 中，换行和缩进可以改变代码的含义。在 SQL 中，空白没有意义，语句以分号结束。查询中的缩进和新行只是为了可读性。'
- en: 'SQL is **declarative**: Python could be described as an **imperative programming
    language**: we tell Python what we want it to do by telling it how to do it. SQL
    is more of a declarative language: we *describe* what we want done, and the SQL
    engine figures out how to do it.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 是**声明式**的：Python 可以被描述为一种**命令式编程语言**：我们通过告诉 Python 如何做来告诉它我们想要做什么。SQL 更像是一种声明式语言：我们*描述*我们想要完成的事情，而
    SQL 引擎会找出如何完成它。
- en: We'll encounter additional syntax differences as we look at specific SQL code
    examples.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在查看具体的 SQL 代码示例时，会遇到额外的语法差异。
- en: SQL operations and syntax
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL操作和语法
- en: SQL is a powerful and expressive language for doing mass manipulations of tabular
    data, but the basics can be grasped quickly. SQL code is executed as individual
    queries that either define, manipulate, or select data in the database. SQL dialects
    vary somewhat between different relational database products, but most of them
    support **ANSI/ISO-standard SQL** for core operations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 是一种强大且表达丰富的语言，用于对表格数据进行大量操作，但基本概念可以快速掌握。SQL 代码作为单独的查询执行，这些查询要么定义、操作，要么选择数据库中的数据。不同的关系数据库产品之间的
    SQL 方言略有不同，但它们大多数都支持**ANSI/ISO 标准SQL**的核心操作。
- en: While most of the basic concepts and keywords covered here will work across
    SQL implementations, we'll be using PostgreSQL's dialect for the examples in this
    section. If you wish to try these examples on a different SQL implementation,
    be prepared to make some adjustments to the syntax.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这里涵盖的大多数基本概念和关键字在 SQL 实现中都是通用的，但我们将在本节的示例中使用 PostgreSQL 的方言。如果您想在不同的 SQL 实现上尝试这些示例，请准备好对语法进行一些调整。
- en: To follow along with this section, connect to an empty database on your PostgreSQL
    database server, either using the `psql` command-line tool, the `pgAdmin` graphical
    tool, or another database client software of your choosing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本节内容，请连接到您 PostgreSQL 数据库服务器上的一个空数据库，无论是使用`psql`命令行工具、`pgAdmin`图形工具，还是您选择的任何其他数据库客户端软件。
- en: Defining tables and inserting data
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义表和插入数据
- en: 'SQL tables are created using the `CREATE TABLE` command, as shown in the following
    SQL query:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 表是通过使用`CREATE TABLE`命令创建的，如下面的 SQL 查询所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we're creating a table called `musicians`. After the name,
    we specify a list of column definitions. Each column definition follows the format
    `column_name data_type constraints`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在创建一个名为`musicians`的表。在名称之后，我们指定一个列定义列表。每个列定义遵循以下格式：`column_name data_type
    constraints`。
- en: 'Let''s break down the details of these columns we''ve defined:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下我们定义的这些字段的细节：
- en: The `id` column will be an arbitrary ID value for the row. Its type is `SERIAL`,
    which means it will be an auto-incrementing integer field, and its constraint
    is `PRIMARY KEY`, which means it will be used as the unique identifier for the
    row.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`列将为行提供一个任意的ID值。它的类型是`SERIAL`，这意味着它将是一个自动增长的整数字段，并且它的约束是`PRIMARY KEY`，这意味着它将被用作行的唯一标识符。'
- en: The `name` field is of type `TEXT`, so it can hold a string of any length. Its
    constraint of `NOT NULL` means that a `NULL` value is not allowed in this field.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`字段是`TEXT`类型，因此它可以存储任意长度的字符串。它的`NOT NULL`约束意味着这个字段不允许有`NULL`值。'
- en: The `born` and `died` fields are of type `DATE`, so they can only hold a date
    value.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`born`和`died`字段是`DATE`类型，因此它们只能存储日期值。'
- en: The `born` field has no constraints but `died` has a `CHECK` constraint enforcing
    that its value must be greater than the value of `born` for any given row.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`born`字段没有约束，但`died`字段有一个`CHECK`约束，强制其值必须大于任何给定行的`born`值。'
- en: Although it's not required, it's a good practice to specify a **primary key**
    for each table. Primary keys can be one field, or a combination of fields, but
    the value must be unique for any given row. For example, if we made `name` the
    primary key field, we couldn't have two musicians with the same name in our table.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是必需的，但为每个表指定一个**主键**是一个好的实践。主键可以是一个字段，也可以是字段的组合，但任何给定行的值必须是唯一的。例如，如果我们把`name`设为主键字段，我们表中就不能有两个同名音乐家。
- en: 'To add rows of data to this table, we use the `INSERT INTO` command as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要向这个表中添加数据行，我们使用以下格式的`INSERT INTO`命令：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `INSERT INTO` command takes a table name and an optional list specifying
    the fields to receive data; other fields will receive their default value (`NULL`
    if not otherwise specified in the `CREATE` statement). The `VALUES` keyword indicates
    that a list of data values will follow, formatted as a comma-separated list of
    tuples. Each tuple corresponds to one table row and must match the order of the
    field list specified after the table name.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT INTO` 命令接受一个表名和一个可选的字段列表，指定接收数据字段；其他字段将接收它们的默认值（如果未在 `CREATE` 语句中指定，则为
    `NULL`）。`VALUES` 关键字表示将跟随一系列数据值，格式为逗号分隔的元组列表。每个元组对应一行表，必须与表名之后指定的字段列表的顺序相匹配。'
- en: 'Note that strings are delimited by the single quote character. Unlike Python,
    single quotes and double quotes have different meanings in SQL: a single quote
    indicates a string literal, while double quotes are used for object names that
    include spaces or need to preserve case. For example, if we had called our table
    `Musicians of the ''70s`, we would need to enclose that name in double-quotes
    due to the spaces, apostrophe, and capitalization.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，字符串由单引号字符分隔。与 Python 不同，单引号和双引号在 SQL 中的含义不同：单引号表示字符串字面量，而双引号用于包含空格或需要保留大小写的对象名称。例如，如果我们把我们的表命名为
    `Musicians of the '70s`，由于空格、撇号和大小写，我们需要用双引号括住那个名称。
- en: 'Using double-quotes to enclose a string literal results in an error, for example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用双引号括起来的字符串字面量会导致错误，例如：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To make our database more interesting, let''s create and populate another table;
    this time, an `instruments` table:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的数据库更有趣，让我们创建并填充另一个表；这次是一个 `instruments` 表：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the `VALUES` lists must always use parentheses around each row, even
    if there's only one value per row.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`VALUES` 列表必须始终在每个行周围使用括号，即使每行只有一个值。
- en: 'To relate the `musicians` table to the `instruments` table, we''ll need to
    add a column to it. Tables can be changed after they are created using the `ALTER
    TABLE` command. For example, we can add our new column like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `musicians` 表与 `instruments` 表相关联，我们需要向其中添加一个列。可以使用 `ALTER TABLE` 命令在创建表之后更改表。例如，我们可以添加我们的新列如下：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `ALTER TABLE` command takes a table name, then a command altering some aspect
    of the table. In this case, we're adding a new column called `main_instrument`,
    which will be an integer.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`ALTER TABLE` 命令接受一个表名，然后是一个改变表某些方面的命令。在这种情况下，我们正在添加一个名为 `main_instrument`
    的新列，它将是一个整数。'
- en: The `REFERENCES` constraint we've specified is known as a **foreign key constraint**;
    it limits the possible values of `main_instrument` to existing ID numbers in the
    `instruments` table.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定的 `REFERENCES` 约束称为**外键约束**；它限制 `main_instrument` 的可能值只能为 `instruments`
    表中存在的 ID 号。
- en: Retrieving data from tables
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从表中检索数据
- en: 'To retrieve data from tables, we can use a `SELECT` statement, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要从表中检索数据，我们可以使用 `SELECT` 语句，如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `SELECT` command takes a column or comma-separated list of columns followed
    by a `FROM` clause, which specifies the table or tables containing the specified
    columns. This query asks for the `name` column from the `musicians` table.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT` 命令接受一个列或逗号分隔的列列表，后跟一个 `FROM` 子句，该子句指定包含指定列的表或表。此查询请求 `musicians` 表中的
    `name` 列。'
- en: 'Its output is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 其输出如下：
- en: '| name |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| name |'
- en: '| Bill Bruford |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| Bill Bruford |'
- en: '| Keith Emerson |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| Keith Emerson |'
- en: '| Greg Lake |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| Greg Lake |'
- en: '| Robert Fripp |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| Robert Fripp |'
- en: '| David Gilmour |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| David Gilmour |'
- en: 'Instead of a list of columns, we can also specify an asterisk, which means
    "all columns." For example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了列列表之外，我们还可以指定一个星号，表示“所有列”。例如：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding SQL query returns the following table of data:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 SQL 查询返回以下数据表：
- en: '| ID | name | born | died | main_instrument |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| ID | name | born | died | main_instrument |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 4 | Bill Bruford | 1949-05-17 |  |  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 4 | Bill Bruford | 1949-05-17 |  |  |'
- en: '| 2 | Keith Emerson | 1944-11-02 | 2016-03-11 |  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Keith Emerson | 1944-11-02 | 2016-03-11 |  |'
- en: '| 3 | Greg Lake | 1947-11-10 | 2016-12-07 |  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Greg Lake | 1947-11-10 | 2016-12-07 |  |'
- en: '| 1 | Robert Fripp | 1946-05-16 |  |  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Robert Fripp | 1946-05-16 |  |  |'
- en: '| 5 | David Gilmour | 1946-03-06 |  |  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 5 | David Gilmour | 1946-03-06 |  |  |'
- en: 'To filter out rows we don''t want, we can specify a `WHERE` clause, like so:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要过滤掉我们不需要的行，我们可以指定一个 `WHERE` 子句，如下所示：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `WHERE` command must be followed by a conditional expression that evaluates
    to `True` or `False`; rows for which the expression evaluates `True` are shown,
    while rows for which it evaluates `False` are left out.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE`命令必须后跟一个条件表达式，该表达式评估为`True`或`False`；评估为`True`的表达式的行被显示，而评估为`False`的行被省略。'
- en: 'In this case, we have asked for the names of musicians for which the `died`
    date is `NULL`. We can specify more complex conditions by combining expressions
    with the `AND` and `OR` operators, like so:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们要求的是那些`died`日期为`NULL`的音乐家的名字。我们可以通过使用`AND`和`OR`运算符组合表达式来指定更复杂的条件，如下所示：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, we would only get musicians born before 1945 who don't have a
    died date in the database.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只会得到在1945年之前出生且数据库中没有死亡日期的音乐家。
- en: 'The `SELECT` command can also do operations on fields, or re-order the results
    by certain columns:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT`命令也可以对字段进行操作，或根据某些列重新排序结果：'
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we're using the `age()` function to determine the age of the
    musicians from their birth dates. We're also doing math on the `died` and `born`
    dates to determine the age at death for those who have passed. Notice that we're
    using the `AS` keyword to **alias**, or rename, the generated column.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`age()`函数根据出生日期确定音乐家的年龄。我们还对`died`和`born`日期进行数学运算，以确定已故者的死亡年龄。请注意，我们使用`AS`关键字来**别名**或重命名生成的列。
- en: 'When you run this query, you should get output like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个查询时，你应该得到如下输出：
- en: '| name | age | age at death |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 姓名 | 年龄 | 死亡年龄 |'
- en: '| Bill Bruford | 72 years 4 mons 18 days |  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 比尔·布鲁福德 | 72岁4个月18天 |  |'
- en: '| Greg Lake | 73 years 10 mons 24 days | 69 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 格雷格·莱克 | 73岁10个月24天 | 69 |'
- en: '| Robert Fripp | 75 years 4 mons 19 days |  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 罗伯特·弗里普 | 75岁4个月19天 |  |'
- en: '| David Gilmour | 75 years 6 mons 29 days |  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 大卫·吉尔莫尔 | 75岁6个月29天 |  |'
- en: '| Keith Emerson | 76 years 11 mons 2 days | 71 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 吉思·艾默森 | 76岁11个月2天 | 71 |'
- en: Notice that `age at death` is `NULL` for those without a date of death. Mathematical
    or logical operations on a `NULL` value always return an answer of `NULL`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于没有死亡日期的人，“死亡年龄”是`NULL`。对`NULL`值进行数学或逻辑运算始终返回`NULL`答案。
- en: The `ORDER BY` clause specifies a column or list of columns by which the results
    should be ordered. It also takes an argument of `DESC` or `ASC` to specify descending
    or ascending order, respectively.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`ORDER BY`子句指定了按哪个列或列列表排序结果。它还接受`DESC`或`ASC`参数来指定降序或升序，分别。'
- en: We have ordered the output here by date of birth in descending order. Note that
    each data type has its own rules for sorting data, just like in Python. Dates
    are ordered by their calendar position, strings by alphabetical order, and numbers
    by their numeric value.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里按出生日期降序排列了输出。请注意，每种数据类型都有自己的排序规则，就像在Python中一样。日期按日历位置排序，字符串按字母顺序排序，数字按其数值排序。
- en: Updating rows, deleting rows, and more WHERE clauses
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新行、删除行和更多的WHERE子句
- en: To update or delete existing rows, we use the `UPDATE` and `DELETE FROM` keywords
    in conjunction with a `WHERE` clause to select the affected rows.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新或删除现有行，我们使用`UPDATE`和`DELETE FROM`关键字与`WHERE`子句结合来选择受影响的行。
- en: 'Deleting is fairly simple; for example, if we wanted to delete the `instrument`
    record with an `id` value of `5`, it would look like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 删除相对简单；例如，如果我们想删除`id`值为`5`的`instrument`记录，它看起来会是这样：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `DELETE FROM` command will delete any rows that match the `WHERE` conditions.
    In this case, we match the primary key to ensure only one row is deleted. If no
    rows match the `WHERE` conditions, no rows will be deleted. Note, however, that
    the `WHERE` clause is technically optional: `DELETE FROM instruments` will simply
    delete all rows in the table.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE FROM`命令将删除任何匹配`WHERE`条件的行。在这种情况下，我们匹配主键以确保只删除一行。如果没有行匹配`WHERE`条件，则不会删除任何行。请注意，然而，`WHERE`子句在技术上不是必需的：`DELETE
    FROM instruments`将简单地删除表中的所有行。'
- en: 'Updating is similar, except it includes a `SET` clause to specify new column
    values, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 更新类似，但它包括一个`SET`子句来指定新列值，如下所示：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we are setting `main_instrument` in the `musicians` table to the primary
    key value from the `instruments` table that identifies the instrument we want
    to associate with each musician.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`musicians`表中的`main_instrument`设置为`instruments`表中标识我们想要与每位音乐家关联的乐器的主键值。
- en: We can select the `musician` records we want to update using the primary key,
    name, or any combination of conditions. Like `DELETE`, omitting the `WHERE` clause
    would cause the query to affect all rows.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用主键、名称或任何条件的组合来选择我们想要更新的`musician`记录。就像`DELETE`一样，省略`WHERE`子句会导致查询影响所有行。
- en: 'Any number of columns can be updated in the `SET` clause; for example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`SET`子句中可以更新任意数量的列；例如：'
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Additional columns to be updated are just separated by commas. Note that we''ve
    also matched the record using the `LIKE` operator in tandem with the `%` wildcard
    character. `LIKE` can be used with text and string data types to match partial
    values. Standard SQL supports two wildcard characters: `%`, which matches zero
    or more characters, and `_`, which matches a single character.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新的附加列只需用逗号分隔。请注意，我们还在使用`LIKE`运算符和`%`通配符的同时匹配记录。`LIKE`可以与文本和字符串数据类型一起使用来匹配部分值。标准
    SQL 支持两个通配符：%匹配零个或多个字符，_匹配单个字符。
- en: 'We can also match against transformed column values:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以匹配转换后的列值：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we've used the `LOWER` function to match our string against the lowercase
    version of the column value. This doesn't permanently change the data in the table;
    it just temporarily changes the value for the purpose of the comparison.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`LOWER`函数来将我们的字符串与列值的 lowercase 版本进行匹配。这不会永久更改表中的数据；它只是暂时更改值以用于比较目的。
- en: Standard SQL specifies that `LIKE` is a case-sensitive match. PostgreSQL offers
    an `ILIKE` operator that does case-insensitive matching, as well as a `SIMILAR
    TO` operator that matches using more advanced regular expression syntax.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 标准 SQL 指定`LIKE`是区分大小写的匹配。PostgreSQL 提供了一个`ILIKE`运算符，它执行不区分大小写的匹配，以及一个`SIMILAR
    TO`运算符，它使用更高级的正则表达式语法进行匹配。
- en: Subqueries
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子查询
- en: 'Inserting data using meaningless primary key values is not very user-friendly.
    To make inserting these values a little more intuitive, we can use a **subquery**,
    as shown in the following SQL query:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无意义的键值插入数据并不非常用户友好。为了使插入这些值更加直观，我们可以使用**子查询**，如下面的 SQL 查询所示：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A subquery is a SQL query within a SQL query. If your subquery can be guaranteed
    to return a single value, it can be used anywhere you would use a literal value.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询是 SQL 查询中的 SQL 查询。如果你的子查询可以保证返回单个值，它可以在任何使用文字值的地方使用。
- en: In this case, we're letting our database do the work of figuring out what the
    primary key of `'guitar'` is, and inserting the returned integer for our `main_instrument`
    value.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们让数据库来做找出`'guitar'`的主键是什么的工作，并将返回的整数插入到我们的`main_instrument`值中。
- en: 'In the `WHERE` clause, we''ve also used the `IN` operator to match the musician''s
    name. Just like the Python `in` keyword, this SQL keyword allows us to match against
    a list of values. `IN` can be used with a subquery as well; for example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WHERE`子句中，我们也使用了`IN`运算符来匹配音乐家的姓名。就像 Python 的`in`关键字一样，这个 SQL 关键字允许我们匹配值列表。`IN`也可以与子查询一起使用；例如：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, we've asked the database to give us every musician whose main
    instrument contains the letter "r". Since `IN` is meant to be used with a list
    of values, any query that returns a single column with any number of rows is valid.
    In this case, our subquery returns several rows with only the `id` column, so
    it works with `IN` just fine.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们要求数据库给我们每个主要乐器包含字母“r”的音乐家。由于`IN`是用来与值列表一起使用的，任何返回单个列和任意行数的查询都是有效的。在这种情况下，我们的子查询返回了几个只有`id`列的行，所以它与`IN`配合得很好。
- en: 'Subqueries that return multiple rows and multiple columns can be used anywhere
    that a table can be used; for example, we can use a subquery in a `FROM` clause,
    like so:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 返回多行和多列的子查询可以在任何可以使用表的地方使用；例如，我们可以在`FROM`子句中使用子查询，如下所示：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, SQL treats our subquery as though it were a table in the database.
    Note that subqueries used in a `FROM` clause require an alias; we've aliased this
    subquery as `living_musicians`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，SQL 将我们的子查询视为数据库中的一个表。请注意，在`FROM`子句中使用的子查询需要别名；我们将此子查询别名为`living_musicians`。
- en: Joining tables
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表连接
- en: 'Subqueries are one way of using multiple tables together, but a more flexible
    and powerful way is to use `JOIN`. `JOIN` is used in the `FROM` clause of a SQL
    statement, for example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询是使用多个表的一种方法，但更灵活和强大的方法是使用`JOIN`。`JOIN`用于 SQL 语句的`FROM`子句中，例如：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A `JOIN` statement requires an `ON` clause that specifies the conditions used
    to match rows in each table. The `ON` clause acts like a filter, much like the
    `WHERE` clause does; you can imagine that the `JOIN` creates a new table containing
    every possible combination of rows from both tables, then filters out the ones
    that don't match the `ON` conditions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`JOIN`语句需要一个`ON`子句，该子句指定用于匹配每个表中行的条件。`ON`子句的作用就像一个过滤器，就像`WHERE`子句一样；你可以想象`JOIN`创建了一个包含来自两个表的所有可能行组合的新表，然后过滤掉不符合`ON`条件的行。'
- en: Tables are typically joined by matching the values in common fields, such as
    those specified in a foreign key constraint. In this case, our `musicians.main_instrument`
    column contains the `id` values from the `instrument` table, so we can join the
    two tables based on this.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 表通常通过匹配公共字段中的值来连接，例如在外键约束中指定的那些。在这种情况下，我们的`musicians.main_instrument`列包含来自`instrument`表的`id`值，因此我们可以根据这个值将两个表连接起来。
- en: 'Joins are used to implement four types of table relationships:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 连接用于实现四种类型的表关系：
- en: '**One-to-one joins** match exactly one row in the first table to exactly one
    row in the second.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对一连接**将第一表中的单行与第二表中的单行精确匹配。'
- en: '**Many-to-one joins** match multiple rows in the first table to exactly one
    row in the second.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对一连接**将第一表中的多行与第二表中的单行精确匹配。'
- en: '**One-to-many joins** match one row in the first table to multiple rows in
    the second.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对多连接**将第一表中的一行与第二表中的多行匹配。'
- en: '**Many-to-many joins** match multiple rows in both tables. This kind of join
    requires the use of an intermediary table.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对多连接**匹配两个表中的多行。这种连接需要使用一个中间表。'
- en: The previous query shows a many-to-one join, since many `musicians` can have
    the same main instrument. Many-to-one joins are often used when a column's value
    should be limited to a set of options, such as fields that our GUI might represent
    with a `Combobox` widget. The table joined is often called a **lookup table**.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的查询显示了一个多对一连接，因为许多音乐家可能有相同的主体乐器。当一列的值应该限制为一组选项时，通常使用多对一连接，例如我们的GUI可能用`Combobox`小部件表示的字段。连接的表通常被称为**查找表**。
- en: 'If we were to reverse our last query, it would be one-to-many:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们反转最后的查询，它将是一对多：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'One-to-many joins are commonly used when a record has a list of sub-records
    associated with it; in this case, each instrument has a list of musicians who
    consider it their main instrument. The joined table is often called a **detail
    table**. The preceding SQL query will give you the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一对多连接通常用于一个记录有一个与其关联的子记录列表的情况；在这种情况下，每种乐器都有一个将其视为主要乐器的音乐家列表。连接的表通常被称为**详细表**。前面的SQL查询将给出以下输出：
- en: '| instrument | musician |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 乐器 | 音乐家 |'
- en: '| --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| drums | Bill Bruford |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 鼓 | 比尔·布鲁福德 |'
- en: '| keyboards | Keith Emerson |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 键盘 | 凯斯·埃默森 |'
- en: '| bass | Greg Lake |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 贝斯 | 格雷格·莱克 |'
- en: '| guitar | Robert Fripp |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 吉他 | 罗伯特·弗里普 |'
- en: '| guitar | David Gilmour |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 吉他 | 大卫·吉尔莫 |'
- en: Notice that `guitar` is duplicated in the `instrument` list. When two tables
    are joined, the rows of the result no longer refer to the same entity. One row
    in the `instrument` table represents an instrument.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`guitar`在`instrument`列表中重复了。当两个表连接时，结果表的行不再指代相同的实体。`instrument`表中的一行代表一种乐器。
- en: One row in the `musician` table represents one musician. One row in *this* table
    represents an instrument-musician relationship.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`musician`表中的一行代表一位音乐家。*这张*表中的一行代表一种乐器与音乐家的关系。'
- en: 'Suppose we wanted to keep the output such that one row represented one instrument,
    but still include information about associated musicians in each row. To do this,
    we''ll need to combine the matched musician rows using an **aggregate function**
    and a `GROUP BY` clause, as shown in the following SQL query:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要保持输出，使得一行代表一种乐器，但仍然在每一行中包含有关关联音乐家的信息。为此，我们需要使用**聚合函数**和`GROUP BY`子句将匹配的音乐家行组合起来，如下面的SQL查询所示：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `GROUP BY` clause specifies which column or columns describe what each row
    in the output table represents. Output columns not in the `GROUP BY` clause must
    then be reduced to single values using an aggregate function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`GROUP BY`子句指定哪些列或列描述了输出表中的每一行代表的内容。不在`GROUP BY`子句中的输出列必须使用聚合函数将其减少到单个值。'
- en: 'In this case, we''re using the `count()` aggregate function to count the total
    number of musician records associated with each instrument. Its output looks like
    this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`count()`聚合函数来计算与每种乐器关联的音乐家记录总数。其输出如下所示：
- en: '| instrument | musicians |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| instrument | musicians |'
- en: '| --- | --- |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| drums | 1 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| drums | 1 |'
- en: '| keyboards | 1 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| keyboards | 1 |'
- en: '| bass | 1 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| bass | 1 |'
- en: '| guitar | 2 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| guitar | 2 |'
- en: Standard SQL contains several more aggregate functions, such as `min()`, `max()`,
    and `sum()`, and most SQL implementations extend this with their own functions
    as well.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 标准SQL包含更多聚合函数，如 `min()`、`max()` 和 `sum()`，并且大多数 SQL 实现也扩展了它们自己的函数。
- en: Many-to-one and one-to-many joins don't quite cover every possible situation
    that databases need to model; quite often, a many-to-many relationship is required.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 多对一和一对多连接并不能涵盖数据库需要建模的每一种可能情况；很多时候，需要多对多关系。
- en: 'To demonstrate a many-to-many join, let''s create a new table called `bands`,
    like so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示多对多连接，让我们创建一个新的表 `bands`，如下所示：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A band has multiple musicians, and musicians can be part of multiple bands.
    How can we create a relationship between musicians and bands? If we added a `band`
    field to the `musicians` table, this would limit each musician to one band. If
    we added a `musician` field to the `band` table, this would limit each band to
    one musician. To make the connection, we need to create a **junction table**,
    in which each row represents a musician's membership in a band.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个乐队有多位音乐家，而音乐家也可以属于多个乐队。我们如何创建音乐家和乐队之间的关系？如果我们向 `musicians` 表中添加一个 `band` 字段，这将限制每位音乐家只能属于一个乐队。如果我们向
    `band` 表中添加一个 `musician` 字段，这将限制每个乐队只能有一位音乐家。为了建立这种联系，我们需要创建一个 **连接表**，其中每一行代表一位音乐家在乐队中的成员资格。
- en: 'Create the `musicians_bands` table like so:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `musicians_bands` 表如下所示：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `musicians_bands` table simply contains two foreign key fields, one to point
    to a musician's ID and one to point to the band's ID.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`musicians_bands` 表仅包含两个外键字段，一个指向音乐家的 ID，另一个指向乐队的 ID。'
- en: Notice that instead of creating or specifying one field as the primary key,
    we use the combination of both fields as the primary key. It wouldn't make sense
    to have multiple rows with the same two values in them, so the combination makes
    an acceptable primary key.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不是创建或指定一个字段作为主键，而是使用这两个字段的组合作为主键。如果有多个行具有相同的两个值，那就没有意义，所以这种组合可以作为一个可接受的主键。
- en: 'To write a query that uses this relationship, our `FROM` clause needs to specify
    two `JOIN` statements: one from `musicians` to `musicians_bands` and one from
    `bands` to `musicians_bands`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写使用这种关系的查询，我们的 `FROM` 子句需要指定两个 `JOIN` 语句：一个是从 `musicians` 到 `musicians_bands`，另一个是从
    `bands` 到 `musicians_bands`。
- en: 'For example, let''s get the names of the bands each musician has been in:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们获取每位音乐家所属乐队的名称：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This query ties musicians to bands using the junction table, then displays
    musician names next to an aggregated list of the bands they''ve been in, and orders
    it by the musician''s name. It gives you the following output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询通过连接表将音乐家和乐队关联起来，然后显示音乐家的名字以及他们所属乐队的聚合列表，并按音乐家的名字排序。它给出了以下输出：
- en: '| name | bands |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| name | bands |'
- en: '| --- | --- |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Bill Bruford | {ABWH,"King Crimson",Yes} |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 比尔·布鲁福德 | {ABWH,"King Crimson",Yes} |'
- en: '| David Gilmour | {"Pink Floyd"} |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 大卫·吉尔莫 | {"Pink Floyd"} |'
- en: '| Greg Lake | {ELP,"King Crimson"} |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 格雷格·莱克 | {ELP,"King Crimson"} |'
- en: '| Keith Emerson | {ELP} |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 吉思·艾默森 | {ELP} |'
- en: '| Robert Fripp | {"King Crimson"} |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 罗伯特·弗里普 | {"King Crimson"} |'
- en: The `array_agg()` function used here aggregates string values into an array
    structure. This method, and the `ARRAY` data type, are specific to PostgreSQL.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的 `array_agg()` 函数将字符串值聚合到一个数组结构中。这种方法以及 `ARRAY` 数据类型是 PostgreSQL 特有的。
- en: There is no SQL standard function for aggregating string values, though most
    SQL implementations have a solution for it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数 SQL 实现都有针对聚合字符串值的解决方案，但并没有 SQL 标准函数用于聚合字符串值。
- en: Managing transactions
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理事务
- en: While we can accomplish a lot of data manipulation in a single SQL query, there
    are times when a change requires multiple queries. Often in these cases, if one
    query fails, the whole set of queries must be reversed or else the data would
    be corrupted.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在单个 SQL 查询中完成很多数据操作，但有时一个更改需要多个查询。在这些情况下，如果其中一个查询失败，整个查询集必须被撤销，否则数据会被破坏。
- en: 'For example, suppose we want to insert `''Vocals''` as a value in the `instruments`
    table, but we want it to be ID #1\. To do that, we''d need to first move the other
    ID values in the `instruments` table up by one, adjust the foreign key values
    in the `musicians` table, then add the new row. The queries would look like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，假设我们想在 `instruments` 表中插入 `''Vocals''` 作为值，但希望它是 ID #1。为此，我们首先需要将 `instruments`
    表中的其他 ID 值向上移动一位，调整 `musicians` 表中的外键值，然后添加新行。查询将如下所示：'
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, all three queries must run successfully in order to effect
    the change we want, and at the very least the first two must run to avoid data
    corruption. If only the first query ran, our data would be corrupt.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，所有三个查询都必须成功运行才能产生我们想要的变化，而且至少前两个必须运行以避免数据损坏。如果只有第一个查询运行了，我们的数据就会损坏。
- en: To do this safely, we need to use a **transaction**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全地完成这项操作，我们需要使用一个**事务**。
- en: 'Using transactions in PostgreSQL involves three keywords, as shown here:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PostgreSQL 中使用事务涉及三个关键字，如下所示：
- en: '| Keyword | Function |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 关键字 | 功能 |'
- en: '| `BEGIN` | Start a transaction |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `BEGIN` | 开始一个事务 |'
- en: '| `ROLLBACK` | Undo the transaction and start fresh |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `ROLLBACK` | 取消事务并重新开始 |'
- en: '| `COMMIT` | Permanently save the transaction |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `COMMIT` | 永久保存事务 |'
- en: 'To put our queries in a transaction, we simply add `BEGIN` before the queries
    and `COMMIT` afterward, like so:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的查询放入事务中，我们只需在查询之前添加 `BEGIN`，之后添加 `COMMIT`，如下所示：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, if anything goes wrong with one of our queries, we can execute a `ROLLBACK`
    statement to revert the database to the state it was in when we called `BEGIN`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们的查询中任何一个出现问题，我们可以执行一个 `ROLLBACK` 语句将数据库回滚到我们调用 `BEGIN` 时的状态。
- en: In DBAPI2-compatible modules like the `psycopg2` module that we use in *Chapter
    12*, *Improving Data Storage with SQL*, transaction management is often handled
    implicitly through connection settings, or explicitly through connection object
    methods, rather than using SQL statements.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 *第 12 章* 中使用的 `psycopg2` 模块等 DBAPI2 兼容模块中，事务管理通常是通过连接设置隐式处理的，或者通过连接对象方法显式处理，而不是使用
    SQL 语句。
- en: Learning more
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习更多
- en: This has been a quick overview of SQL concepts and syntax; we've covered most
    of what you need to know to write a simple database application, but there's much
    more to learn. The PostgreSQL manual, available at [https://www.postgresql.org/docs/manuals](https://www.postgresql.org/docs/manuals),
    is a great resource and reference for SQL syntax and the specific features of
    PostgreSQL.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个 SQL 概念和语法的快速概述；我们涵盖了您编写简单数据库应用程序所需了解的大部分内容，但还有更多需要学习。PostgreSQL 手册，可在
    [https://www.postgresql.org/docs/manuals](https://www.postgresql.org/docs/manuals)
    找到，是 SQL 语法和 PostgreSQL 特定功能的优秀资源。
