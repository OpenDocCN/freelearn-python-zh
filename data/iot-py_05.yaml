- en: Chapter 5. Working with Digital Inputs, Polling and Interrupts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：处理数字输入、轮询和中断
- en: 'In this chapter, we will use digital inputs to make it possible for users to
    interact with the board while we process the HTTP requests. We will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用数字输入，以便在处理HTTP请求的同时让用户与板交互。我们将：
- en: Understand the difference between pull-up and pull-down resistors to connect
    pushbuttons
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解上拉电阻和下拉电阻之间的区别，以便连接按钮
- en: Wire digital input pins with pushbuttons
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将按钮与数字输入引脚连接
- en: Use polling to check the pushbutton status with the `mraa` and `wiring-x86`
    libraries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用轮询检查`mraa`和`wiring-x86`库中的按钮状态
- en: Combine polling to read digital inputs while running a RESTful API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行RESTful API的同时结合轮询读取数字输入
- en: Write code that maintains consistency when we provide shared features with electronic
    components and APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写代码，确保在提供电子组件和API的共享功能时保持一致性
- en: Use interrupts and the `mraa` library to detect pressed pushbuttons
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用中断和`mraa`库检测按下的按钮
- en: Understand the differences, advantages, and trade-offs between polling and interrupts
    to detect changes in digital inputs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解轮询和中断在检测数字输入变化之间的差异、优势和权衡
- en: Understanding pushbuttons and pullup resistors
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解按钮和上拉电阻
- en: 'We controlled the brightness levels for red, green, and blue LEDs with a RESTful
    API. Then, we replaced the three LEDs with a single RGB LED and generated lights
    of different colors with the same RESTful API. Now, we want to make it possible
    for the users to change the brightness level for the three components with two
    pushbuttons added to the breadboard:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用RESTful API控制红、绿、蓝LED的亮度级别。然后，我们将三个LED替换为单个RGB LED，并使用相同的RESTful API生成不同颜色的灯光。现在，我们希望用户能够通过面包板上添加的两个按钮来改变三个组件的亮度级别：
- en: A pushbutton to turn off all the colors, that is, to set all the colors to a
    brightness level equal to 0
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个按钮用于关闭所有颜色，即设置所有颜色亮度级别为0
- en: A pushbutton to set all the colors to their maximum brightness levels, that
    is, to set all the colors to a brightness level equal to 255
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个按钮用于将所有颜色设置为最大亮度级别，即设置所有颜色亮度级别为255
- en: When the user presses the pushbutton, also known as a microswitch, it acts like
    a wire, and therefore, it lets the current flow through the circuit in which it
    is incorporated. When the pushbutton isn't pressed, the circuit in which it is
    incorporated is interrupted. Thus, whenever the user releases the pushbutton,
    the circuit is interrupted. Obviously, we don't want to short circuit the connection
    whenever the user presses a pushbutton, and therefore, we will analyze the different
    possible ways to safely connect a pushbutton to an Intel Galileo Gen 2 board.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下按钮，也称为微动开关时，它就像一根电线，因此，它允许电流通过其融入的电路。当按钮未按下时，其融入的电路被中断。因此，每当用户释放按钮时，电路都会被中断。显然，我们不希望在用户按下按钮时短路连接，因此，我们将分析不同的可能方法来安全地将按钮连接到英特尔Galileo
    Gen 2板上。
- en: 'The following picture shows one of the ways in which we can connect a pushbutton
    to an Intel Galileo Gen 2 board and uses the GPIO pin number **0** as an input
    to determine whether the pushbutton is pressed or not. The Fritzing file for the
    sample is `iot_fritzing_chapter_05_01.fzz` and the following picture is the breadboard
    view:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了我们可以将按钮连接到英特尔Galileo Gen 2板的一种方法，并使用GPIO引脚号**0**作为输入以确定按钮是否被按下。该示例的Fritzing文件为`iot_fritzing_chapter_05_01.fzz`，以下图片是面包板视图：
- en: '![Understanding pushbuttons and pullup resistors](img/B05042_05_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![理解按钮和上拉电阻](img/B05042_05_01.jpg)'
- en: 'The following picture shows the schematic with the electronic components represented
    as symbols:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了用符号表示的电子组件的电路图：
- en: '![Understanding pushbuttons and pullup resistors](img/B05042_05_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![理解按钮和上拉电阻](img/B05042_05_02.jpg)'
- en: As seen in the previous schematic, the GPIO pin labeled **D0/RX**, in the board's
    symbol, is connected to a 120Ω resistor with 5% tolerance (brown red brown gold),
    and wired to the **IOREF** pin. We already know that the pin labeled **IOREF**
    provides us the IOREF voltage, that is, 5V in our actual configuration. As we
    might want to work with other voltage configuration in the future, we can always
    work with the IOREF pin instead of specifically using the **5V** or the **3V3**
    pins. The GPIO pin labeled **D0/RX** in the board's symbol is also connected to
    the **S1** pushbutton, wired to the 120Ω resistor and **GND** (ground).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，板子符号上标记为**D0/RX**的GPIO引脚连接到一个120Ω电阻，公差为5%（棕色红棕色金色），并连接到**IOREF**引脚。我们已经知道，标记为**IOREF**的引脚为我们提供IOREF电压，即在我们的实际配置中为5V。由于我们可能希望在将来使用其他电压配置，我们始终可以使用IOREF引脚而不是专门使用**5V**或**3V3**引脚。板子符号上标记为**D0/RX**的GPIO引脚也连接到**S1**按钮，通过120Ω电阻和**GND**（地）连接。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The configuration is known as a voltage divider and the 120Ω resistor is called
    a pull-up resistor.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该配置被称为分压器，120Ω电阻被称为上拉电阻。
- en: The pull-up resistor limits the electric current when we press the **S1** pushbutton.
    As an effect of the pull-up resistor, if we press the **S1** pushbutton, we will
    read a low value (0V) in the GPIO pin labeled **D0/RX**. When we release the S1
    pushbutton, we will read a high value, that is, the IOREF voltage (5V in our actual
    configuration).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 拉高电阻在按下**S1**按钮时限制电流。由于拉高电阻的作用，如果我们按下**S1**按钮，我们将在标记为**D0/RX**的GPIO引脚上读取低值（0V）。当我们释放S1按钮时，我们将读取高值，即IOREF电压（在我们的实际配置中为5V）。
- en: The situation might be confusing because we read a low value when the button
    in pressed. However, we can write object-oriented code to encapsulate the behavior
    for a pushbutton and work with easier to understand states that isolate the way
    in which the pull-up resistor works.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在按钮按下时读取到低值，所以情况可能有些令人困惑。然而，我们可以编写面向对象的代码来封装按钮的行为，并使用更容易理解的状态来隔离上拉电阻的工作方式。
- en: 'It is also possible to work with a pull-down resistor. We can connect the 120Ω
    resistor to ground and transform it from a pull-up resistor into a pull-down resistor.
    The following picture shows how we can connect a pushbutton to an Intel Galileo
    Gen 2 board with a pull-down resistor and use the GPIO pin number **0** as an
    input to determine whether the pushbutton is pressed or not. The Fritzing file
    for the sample is `iot_fritzing_chapter_05_02.fzz` and the following picture is
    the breadboard view:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用下拉电阻。我们可以将120Ω电阻连接到地，将其从上拉电阻转换为下拉电阻。以下图片显示了如何使用下拉电阻将按钮连接到英特尔Galileo Gen
    2板，并使用GPIO引脚号**0**作为输入来确定按钮是否被按下。该示例的Fritzing文件为`iot_fritzing_chapter_05_02.fzz`，以下图片是面包板视图：
- en: '![Understanding pushbuttons and pullup resistors](img/B05042_05_03.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![理解按钮和上拉电阻](img/B05042_05_03.jpg)'
- en: 'The following picture shows the schematic with the electronic components represented
    as symbols:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了用符号表示的电子元件的原理图：
- en: '![Understanding pushbuttons and pullup resistors](img/B05042_05_04.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![理解按钮和上拉电阻](img/B05042_05_04.jpg)'
- en: As seen in the previous schematic, in this case, the GPIO pin labeled **D0/RX**
    in the board's symbol is connected to the **S1** pushbutton and the **IOREF**
    pin. The other connector of the S1 pushbutton is wired to the 120Ω resistor and
    this resistor is wired to **GND** (ground).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，在本例中，板子符号上标记为**D0/RX**的GPIO引脚连接到**S1**按钮和**IOREF**引脚。S1按钮的另一个引脚连接到120Ω电阻，该电阻连接到**GND**（地）。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In this configuration, the 120Ω resistor is called a pull-down resistor.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中，120Ω电阻被称为下拉电阻。
- en: The pull-down resistor limits the electric current when we press the **S1**
    pushbutton. As an effect of the pull-down resistor, if we press the **S1** pushbutton,
    we will read a high value, that is, the IOREF voltage (5V in our actual configuration)
    in the GPIO pin labeled **D0/RX**. When we release the **S1** pushbutton, we will
    read a low value (0V). Thus, the pull-down resistor works with the inverse values
    we read when we use a pull-up resistor.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 拉低电阻在按下**S1**按钮时限制电流。由于拉低电阻的作用，如果我们按下**S1**按钮，我们将在标记为**D0/RX**的GPIO引脚上读取高值，即IOREF电压（在我们的实际配置中为5V）。当我们释放**S1**按钮时，我们将读取低值（0V）。因此，拉低电阻与我们在使用上拉电阻时读取的相反值一起工作。
- en: Wiring digital input pins with pushbuttons
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用按钮连接数字输入引脚
- en: 'Now, we will use the following pins to connect the two pushbuttons and we will
    work with pull-up resistors:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用以下引脚连接两个按钮，并将使用上拉电阻：
- en: Pin **1** (labeled **D1/TX**) to connect the pushbutton that turns off the three
    colors
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引脚 **1**（标记为 **D1/TX**）用于连接关闭三种颜色的按钮
- en: Pin **0** (labeled **D0/RX**) to connect the pushbutton that sets the three
    colors to their maximum brightness levels
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引脚 **0**（标记为 **D0/RX**）用于连接设置三种颜色到最大亮度级别的按钮
- en: 'After we finish the necessary wirings, we will write the Python code to check
    whether each pushbutton was pressed while keeping our RESTful API working as expected.
    This way, we will make it possible for the user to interact with the RGB LED with
    the pushbuttons and also with the RESTful API. We need the following additional
    parts to work with this example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成必要的布线后，我们将编写 Python 代码来检查每个按钮是否被按下，同时保持我们的 RESTful API 正常工作。这样，我们将使用户能够通过按钮和
    RESTful API 与 RGB LED 交互。为了使用此示例，我们需要以下额外的组件：
- en: Two pushbuttons with two pins
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个带两个引脚的按钮
- en: Two 120Ω resistors with 5% tolerance (brown red brown gold)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 120Ω 电阻，公差为 5%（棕色 红色 棕色 金色）
- en: 'The following diagram shows the components connected to the breadboard, the
    necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard.
    The Fritzing file for the sample is `iot_fritzing_chapter_05_03.fzz` and the following
    picture is the breadboard view:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了连接到面包板上的组件、必要的布线和从英特尔 Galileo Gen 2 板到面包板的布线。示例的 Fritzing 文件是 `iot_fritzing_chapter_05_03.fzz`，以下图片是面包板视图：
- en: '![Wiring digital input pins with pushbuttons](img/B05042_05_05.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![使用按钮连接数字输入引脚](img/B05042_05_05.jpg)'
- en: The following picture shows the schematic with the electronic components represented
    as symbols.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了用符号表示的电子组件的原理图。
- en: '![Wiring digital input pins with pushbuttons](img/B05042_05_06.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![使用按钮连接数字输入引脚](img/B05042_05_06.jpg)'
- en: As seen in the previous schematic, we added two pushbuttons (**S1** and **S2**)
    and two 120Ω pull-up resistors (**R4** and **R5**). The GPIO pin labeled **D0/RX**
    in the board's symbol is connected to the **S2** pushbutton and the **R4** resistor
    is its pull-up resistor. The GPIO pin labeled **D1/TX** in the board's symbol
    is connected to the **S1** pushbutton and the R5 resistor is its pull-up resistor.
    This way, GPIO pin number 0 will be low when the **S2** pushbutton is pressed
    and GPIO pin number 1 will be low when the **S1** pushbutton is pressed. The **S1**
    pushbutton is located at the left-hand side in the breadboard while the **S2**
    pushbutton is located at the right-hand side.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们添加了两个按钮（**S1** 和 **S2**）和两个 120Ω 上拉电阻（**R4** 和 **R5**）。板符号中标记为 **D0/RX**
    的 GPIO 引脚连接到 **S2** 按钮，**R4** 电阻是其上拉电阻。板符号中标记为 **D1/TX** 的 GPIO 引脚连接到 **S1** 按钮，**R5**
    电阻是其上拉电阻。这样，当 **S2** 按钮被按下时，GPIO 引脚编号 0 将为低电平，当 **S1** 按钮被按下时，GPIO 引脚编号 1 将为低电平。**S1**
    按钮位于面包板的左侧，而 **S2** 按钮位于右侧。
- en: Now, it is time to insert the components in the breadboard and make all the
    necessary wirings. Don't forget to shutdown the Yocto Linux, wait for all the
    onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen
    2 board before adding or removing any wire from the board's pins.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将组件插入面包板并完成所有必要的布线了。在添加或从板上的引脚移除任何电线之前，不要忘记关闭 Yocto Linux，等待所有板载 LED 熄灭，并从英特尔
    Galileo Gen 2 板上拔掉电源。
- en: Reading pushbutton statuses with digital inputs and the mraa library
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数字输入和 mraa 库读取按钮状态
- en: We will create a new `PushButton` class to represent a pushbutton connected
    to our board that can use either a pull-up or a pull-down resistor. The following
    lines show the code for the new `PushButton` class that works with the `mraa`
    library. The code file for the sample is `iot_python_chapter_05_01.py`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的 `PushButton` 类来表示连接到我们的板上的按钮，该按钮可以使用上拉或下拉电阻。以下行显示了与 `mraa` 库一起工作的新
    `PushButton` 类的代码。示例的代码文件是 `iot_python_chapter_05_01.py`。
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have to specify the pin number to which the pushbutton is connected when
    we create an instance of the `PushButton` class in the `pin` required argument.
    In case we don't specify additional values, the optional `pull_up` argument will
    be `True` and the instance will work as if the pushbutton were connected with
    a pull-up resistor. If we work with a pull-down resistor, we must pass `False`
    in the `pull_up` argument. The constructor, that is, the `__init__` method, creates
    a new `mraa.Gpio` instance with the received `pin` as its `pin` argument, saves
    its reference in the `gpio` attribute and calls its `dir` method to configure
    the pin to be an input pin (`mraa.DIR_IN`).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`PushButton`类的实例时，我们必须指定按钮连接的引脚号，作为`pin`必需参数。如果我们没有指定其他值，可选的`pull_up`参数将为`True`，实例将像按钮连接了上拉电阻一样工作。如果我们使用下拉电阻，我们必须在`pull_up`参数中传递`False`。构造函数，即`__init__`方法，使用接收到的`pin`作为其`pin`参数创建一个新的`mraa.Gpio`实例，将其引用保存到`gpio`属性中，并调用其`dir`方法将引脚配置为输入引脚（`mraa.DIR_IN`）。
- en: 'The class defines the following two properties:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该类定义了以下两个属性：
- en: '`is_pressed`: Calls the `read` method for the related `mraa.Gpio` instance
    to retrieve the value from the pin and saved it in the `push_button_status` variable.
    If the pushbutton is connected with a pull-up resistor (`self.pull_up` is `True`),
    the code will return `True`, indicating that the pushbutton is pressed if the
    value in `push_button_status` is `0` (low value). If the pushbutton is connected
    with a pull-down resistor (`self.pull_up` is `False`), the code will return `True`,
    indicating that the pushbutton is pressed if the value in `push_button_status`
    is `1` (high value).'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_pressed`：调用相关`mraa.Gpio`实例的`read`方法从引脚获取值并将其保存到`push_button_status`变量中。如果按钮连接了上拉电阻（`self.pull_up`为`True`），则代码将返回`True`，表示如果`push_button_status`中的值为`0`（低值），则按钮被按下。如果按钮连接了下拉电阻（`self.pull_up`为`False`），则代码将返回`True`，表示如果`push_button_status`中的值为`1`（高值），则按钮被按下。'
- en: '`is_released`: Returns the inverted result of the `is_pressed` property.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_released`：返回`is_pressed`属性的相反结果。'
- en: Now, we can write code that uses the new `PushButton` class to create one instance
    for each of the two pushbuttons and easily check whether they are pressed or not.
    The new class handles whether the pushbuttons are connected with pull-up or pull-down
    resistors, and therefore, we just need to check the value of the `is_pressed`
    or `is_released` properties without worrying about the specific details about
    their connection.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写使用新的`PushButton`类创建每个按钮实例的代码，并轻松检查它们是否被按下。新类处理按钮是否连接了上拉或下拉电阻，因此我们只需检查`is_pressed`或`is_released`属性值，无需担心它们连接的具体细节。
- en: We will integrate the code that considers the statuses of the two pushbuttons
    in our RESTful API later. First, we will isolate the two pushbuttons in a simple
    example to understand how we can read their statuses. In this case, we will use
    polling, that is, a loop that will check whether the pushbuttons are pressed or
    not. If a pushbutton is pressed, we want the code to print a message in the console
    output indicating the specific pushbutton that is being pressed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后集成考虑两个按钮状态的代码到我们的RESTful API中。首先，我们将通过一个简单的示例将两个按钮隔离出来，以了解我们如何读取它们的状态。在这种情况下，我们将使用轮询，即一个循环，将检查按钮是否被按下。如果按钮被按下，我们希望代码在控制台输出中打印一条消息，指示正在按下的特定按钮。
- en: The following lines show the Python code that performs the previously explained
    actions. The code file for the sample is `iot_python_chapter_05_01.py`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了执行先前解释操作的Python代码。示例的代码文件为`iot_python_chapter_05_01.py`。
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first two lines create two instances of the previously coded `PushButton`
    class. The **S1** pushbutton is connected to GPIO pin number 1 and the **S2**
    pushbutton is connected to GPIO pin number 0\. In both cases, the code doesn''t
    specify a value for the `pull_up` argument. Thus, the constructor, that is, the
    `__init__` method, will use the default value for this argument, `True`, and the
    instance will be configured for a pushbutton connected with a pull-up resistor.
    We need to worry about this when we create the two instances, and then, we work
    with the names of the variables that hold the instances: `s1_push_button` and
    `s2_push_button`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行创建了之前编写的`PushButton`类的两个实例。**S1**按钮连接到GPIO引脚1，**S2**按钮连接到GPIO引脚0。在这两种情况下，代码没有为`pull_up`参数指定值。因此，构造函数，即`__init__`方法，将使用此参数的默认值`True`，并将实例配置为与上拉电阻连接的按钮。我们需要在创建两个实例时注意这一点，然后，我们使用包含实例的变量的名称：`s1_push_button`和`s2_push_button`。
- en: Then, the code runs in a loop forever, that is, until you interrupt the execution
    by pressing *Ctrl* + *C* or the button to stop the process, in case you are using
    a Python IDE with remote development features to run the code in your board.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将无限循环运行，即直到你通过按下*Ctrl* + *C*或停止进程的按钮来中断执行，如果你使用具有远程开发功能的Python IDE来运行代码在你的板上。
- en: The first line within the `while` loop checks the value of the `is_pressed`
    property for the `PushButton` instance named `s1_push_button` is `True`. A `True`
    value means that the pushbutton is pressed at this time, and therefore, the code
    prints a message to the console output indicating that the S1 pushbutton is being
    pressed. The next lines within the while loop follow the same procedure for the
    `PushButton` instance named `s2_push_button`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环内的第一行检查名为`s1_push_button`的`PushButton`实例的`is_pressed`属性的值是否为`True`。`True`值表示此时按钮被按下，因此代码会在控制台输出中打印一条消息，表明S1按钮正在被按下。`while`循环内的后续行对名为`s2_push_button`的`PushButton`实例执行相同的程序。'
- en: After we check the statuses for both the pushbuttons, a call to `time.sleep`
    with `0.5` as the value for the second argument delays the execution for 500 milliseconds,
    that is, 0.5 seconds.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们检查了两个按钮的状态之后，调用`time.sleep`函数，并将`0.5`作为第二个参数的值，将执行延迟500毫秒，即0.5秒。
- en: 'The following line will start the example; don''t forget that you need to transfer
    the Python source code file to the Yocto Linux with an SFTP client:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将启动示例；不要忘记你需要使用SFTP客户端将Python源代码文件传输到Yocto Linux。
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After you run the example, perform the following actions:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行示例之后，执行以下操作：
- en: Press the S1 pushbutton for 1 second
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下S1按钮1秒钟
- en: Press the S2 pushbutton for 1 second
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下S2按钮1秒钟
- en: Press both the S1 and S2 pushbuttons for one second
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时按下S1和S2按钮1秒钟
- en: 'As a result of the previous actions, you will see the following output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于之前的操作，你将看到以下输出：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, we are reading digital inputs with polling. The `mraa` library
    also allows us to work with interrupts and declare interrupt handlers with Python.
    This way, whenever a user presses a button, the event generates an interrupt and
    the `mraa` library calls the specified interrupt handler. If you have ever worked
    with event-based programming, you can think about events and event handlers instead
    of interrupts and interrupt handlers and you will easily understand how things
    work.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在使用轮询读取数字输入。`mraa`库还允许我们使用中断，并用Python声明中断处理程序。这样，每当用户按下按钮时，事件会生成中断，`mraa`库会调用指定的中断处理程序。如果你曾经从事基于事件的编程，你可以考虑事件和事件处理程序而不是中断和中断处理程序，这样你将很容易理解事情是如何工作的。
- en: The interrupt handlers run in a different thread, and the code you can write
    for them has many limitations. For example, you cannot use the basic types within
    interrupt handlers. Thus, in this case, it doesn't make sense to work with interrupts
    and polling makes things easier for us due to the tasks that we have to execute
    when the user presses any of the two buttons.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 中断处理程序在不同的线程中运行，你可以为它们编写的代码有很多限制。例如，你无法在中断处理程序中使用基本类型。因此，在这种情况下，使用中断并不合适，而轮询由于我们必须在用户按下任意一个按钮时执行的任务，使得事情变得更容易。
- en: 'Reading digital inputs with polling as in the previous example has the following
    advantages compared with the usage of interrupts for the same task:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前示例中的轮询读取数字输入相比，用于相同任务的轮询具有以下优点：
- en: The code is easy to understand and read
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码易于理解和阅读
- en: The flow is easy to understand and we don't have to worry about code running
    in callbacks
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程易于理解，我们不必担心回调中运行的代码。
- en: We can write all the necessary code to perform actions when the button is pressed
    without worrying about specific limitations related to interrupt callbacks
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以编写所有必要的代码来执行按钮按下时的动作，而不必担心与中断回调相关的特定限制。
- en: We don't have to worry about code running in multiple threads
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不必担心多线程中运行的代码。
- en: 'However, reading digital inputs with polling has the following disadvantages
    compared with the usage of interrupts for the same task:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与使用中断进行相同任务相比，使用轮询读取数字输入有以下缺点：
- en: If we don't keep the pushbutton pressed for a specific amount of time, the code
    might not detect that the pushbutton has been pressed.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们没有按住按钮特定的时间，代码可能无法检测到按钮被按下。
- en: If we keep the pushbutton pressed for a long time, the code will behave as if
    the pushbutton was pressed many times. Sometimes, we don't want this situation
    to happen.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们长时间按住按钮，代码将表现得好像按钮被多次按下。有时，我们不希望这种情况发生。
- en: The loop consumes more resources that we can require for other tasks compared
    with an interrupt triggered event.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与中断触发的事件相比，循环消耗的资源更多，我们可能无法为其他任务提供这些资源。
- en: In this case, we want users to keep any of the two buttons pressed for at least
    half a second, and therefore, we don't need the advantages of interrupts. However,
    we will use interrupts later in this chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们希望用户至少按住任意一个按钮半秒钟，因此我们不需要中断的优势。然而，我们将在本章后面使用中断。
- en: Reading pushbutton statuses and running a RESTful API
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取按钮状态和运行RESTful API。
- en: Now, we will integrate the code that checks the statuses of the two pushbuttons
    in our RESTful API. We want to be able to make HTTP requests to the RESTful API
    and we also want to be able to use the two buttons we have added to the breadboard.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将集成检查两个按钮状态的代码到我们的RESTful API中。我们希望能够向RESTful API发出HTTP请求，并且我们也希望能够使用我们添加到面包板上的两个按钮。
- en: We have to make Tornado run a periodic callback and write the code that checks
    the statuses of the two pushbuttons in this callback. We will take the code we
    wrote in the previous chapter when we created the last version of our RESTful
    API with the `mraa` library and we will use this code as a baseline to add the
    new features. The code file for the sample was `iot_python_chapter_04_03.py`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须让Tornado运行一个周期性回调，并在该回调中编写检查两个按钮状态的代码。我们将使用我们在上一章中创建最后一个版本的RESTful API时编写的代码，使用`mraa`库，并将此代码作为基准来添加新功能。示例代码文件为`iot_python_chapter_04_03.py`。
- en: We will add two class attributes and three class methods to the existing `BoardInteraction`
    class. The code file for the sample is `iot_python_chapter_05_02.py`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向现有的`BoardInteraction`类添加两个类属性和三个类方法。示例代码文件为`iot_python_chapter_05_02.py`。
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The previous code adds two class attributes to the `BoardInteraction` class:
    `reset_push_button` and `max_brightness_push_button`. The `reset_push_button`
    class attribute is an instance of `PushButton` with its `pin` attribute set to
    `1`. This way, the instance can check the status of the pushbutton connected to
    GPIO pin number 1\. The `max_brightness_push_button` class attribute is an instance
    of `PushButton` with its `pin` attribute set to `0`, and therefore, this instance
    can check the status of the pushbutton connected to GPIO pin number 0\. In addition,
    the previous code adds the following class methods to the `BoardInteraction` class:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码向`BoardInteraction`类添加了两个类属性：`reset_push_button`和`max_brightness_push_button`。`reset_push_button`类属性是一个`PushButton`实例，其`pin`属性设置为`1`。这样，该实例可以检查连接到GPIO引脚1的按钮的状态。`max_brightness_push_button`类属性是一个`PushButton`实例，其`pin`属性设置为`0`，因此，该实例可以检查连接到GPIO引脚0的按钮的状态。此外，之前的代码还向`BoardInteraction`类添加了以下类方法：
- en: '`set_min_brightness`: Calls the `set_brightness` method with `0` as an argument
    for the three `AnalogLed` instances saved in the `red_led`, `green_led` and `blue_led`
    class attributes. This way, the three components of the RGB LED will be turned
    off.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_min_brightness`: 使用`0`作为参数调用`set_brightness`方法，针对保存在`red_led`、`green_led`和`blue_led`类属性中的三个`AnalogLed`实例。这样，RGB
    LED的三个组件将被关闭。'
- en: '`set_max_brightness`: Calls the `set_brightness` method with `255` as an argument
    for the three `AnalogLed` instances saved in the `red_led`, `green_led` and `blue_led`
    class attributes. This way, the three components of the RGB LED will be turned
    on with their maximum brightness levels.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_max_brightness`：调用`set_brightness`方法，将`255`作为参数传递给保存在`red_led`、`green_led`和`blue_led`类属性中的三个`AnalogLed`实例。这样，RGB
    LED的三个组件将以最大亮度级别打开。'
- en: '`check_push_buttons_callback`: First, checks whether the reset pushbutton is
    pressed by evaluating the value of the `is_pressed` property for the `PushButton`
    instance that represents the reset pushbutton, that is, `cls.reset_push_button`.
    In case the value for the property is `True`, the code prints a message indicating
    that you are pressing the reset pushbutton and calls the previously described
    `cls.set_min_brightness` class method to turn off the three components of the
    RGB LED. Then, the code checks whether the maximum brightness pushbutton is pressed
    by evaluating the value of the `is_pressed` property for the `PushButton` instance
    that represents the maximum brightness pushbutton, that is, `cls.max_brightness_push_button`.
    In case the value for the property is `True`, the code prints a message indicating
    that you are pressing the maximum brightness pushbutton and calls the previously
    described `cls.set_max_brightness` class method to turn on the three components
    of the RGB LED with their maximum brightness levels.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check_push_buttons_callback`：首先，通过评估代表复位按钮的`PushButton`实例的`is_pressed`属性值来检查复位按钮是否被按下。即，`cls.reset_push_button`。如果属性的值为`True`，代码将打印一条消息表明您正在按下复位按钮，并调用之前描述的`cls.set_min_brightness`类方法来关闭RGB
    LED的三个组件。然后，代码检查最大亮度按钮是否被按下，通过评估代表最大亮度按钮的`PushButton`实例的`is_pressed`属性值，即`cls.max_brightness_push_button`。如果属性的值为`True`，代码将打印一条消息表明您正在按下最大亮度按钮，并调用之前描述的`cls.set_max_brightness`类方法，以最大亮度级别打开RGB
    LED的三个组件。'
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is necessary to add the `@classmethod` decorator before the class method
    header to declare class methods in Python. Instance methods receive `self` as
    the first argument, but class methods receive the current class as the first argument
    and the parameter name is usually called `cls`. In the previous code, we have
    been using `cls` to access the class attributes and class methods for the `BoardInteraction`
    class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，在类方法标题之前添加`@classmethod`装饰器是必要的，以声明类方法。实例方法接收`self`作为第一个参数，但类方法接收当前类作为第一个参数，参数名称通常称为`cls`。在前面的代码中，我们使用`cls`来访问`BoardInteraction`类的类属性和类方法。
- en: 'The following lines show the new classes that we must add to our existing code
    to make it possible to set the minimum and maximum brightness with HTTP requests.
    We want to be able to have the same features we can command with pushbuttons available
    in our RESTful API. The code adds the following two classes: `PutMinBrightnessHandler`
    and `PutMaxBrightnessHandler`. The code file for the sample is `iot_python_chapter_05_02.py`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行展示了我们必须添加到现有代码中的新类，以便通过HTTP请求设置最小和最大亮度。我们希望能够在我们的RESTful API中拥有与通过按钮可以控制的相同功能。代码添加了以下两个类：`PutMinBrightnessHandler`和`PutMaxBrightnessHandler`。示例代码文件为`iot_python_chapter_05_02.py`。
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The code declares the following two subclasses of `tornado.web.RequestHandler`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了以下两个`tornado.web.RequestHandler`的子类：
- en: '`PutMinBrightnessHandler`: Defines the `put` method that calls the `set_min_brightness`
    class method for the `BoardInteraction` class. Then, the code returns a response
    with the minimum brightness levels that have been translated to output duty cycle
    percentages in the PWM pins to which the red, green and blue anodes of the RGB
    LED are connected to.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PutMinBrightnessHandler`：定义了调用`BoardInteraction`类的`set_min_brightness`类方法的`put`方法。然后，代码返回一个响应，其中包含已转换为连接到RGB
    LED红、绿、蓝阳极的PWM引脚输出占空比百分比的最低亮度级别。'
- en: '`PutMaxBrightnessHandler`: Defines the `put` method that calls the `set_max_brightness`
    class method for the `BoardInteraction` class. Then, the code returns a response
    with the maximum brightness levels that have been translated to output duty cycle
    percentages in the PWM pins to which the red, green and blue anodes of the RGB
    LED are connected to.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PutMaxBrightnessHandler`：定义了调用`BoardInteraction`类的`set_max_brightness`类方法的`put`方法。然后，代码返回一个响应，其中包含已转换为连接到RGB
    LED红、绿、蓝阳极的PWM引脚输出占空比百分比的最高亮度级别。'
- en: Now, it is necessary to add the highlighted lines to the code that creates an
    instance of the `tornado.web.Application` class named `application` with the list
    of request handlers that make up the Web application, that is, the tuples of regular
    expressions and subclasses of `tornado.web.RequestHandler`. The code file for
    the sample is `iot_python_chapter_05_02.py`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有必要将高亮行添加到创建名为`application`的`tornado.web.Application`类实例的代码中，该实例包含构成Web应用程序的请求处理器列表，即正则表达式和`tornado.web.RequestHandler`子类的元组。示例代码文件为`iot_python_chapter_05_02.py`。
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As shown in our previous example, the code creates an instance of the `tornado.web.Application`
    class named `application` with the list of request handlers that make up the Web
    application, that is, the tuples of regular expressions and subclasses of `tornado.web.RequestHandler`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前的示例所示，代码创建了一个名为`application`的`tornado.web.Application`类实例，其中包含构成Web应用程序的请求处理器列表，即正则表达式和`tornado.web.RequestHandler`子类的元组。
- en: Finally, it is necessary to replace the `__main__` method with a new one because
    we want to run a periodic callback to check whether any of the two pushbuttons
    was pressed. The code file for the sample is `iot_python_chapter_05_02.py`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有必要将`__main__`方法替换为一个新的方法，因为我们想要运行一个周期性回调来检查两个按钮中的任何一个是否被按下。示例代码文件为`iot_python_chapter_05_02.py`。
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As happened in the previous examples, the `__main__` method calls the `application.listen`
    method to build an HTTP server for the application with the defined rules on the
    port number `8888`. Then, the code retrieves the global `IOLoop` instance and
    saves it in the `ioloop` local variable. We have to use the instance as one of
    the arguments to create a `tornado.ioloop.PeriodicCallback` instance named `periodic_callback`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，`__main__`方法调用`application.listen`方法来为应用程序构建一个HTTP服务器，该服务器在端口号`8888`上定义了规则。然后，代码检索全局`IOLoop`实例并将其保存到`ioloop`局部变量中。我们必须使用该实例作为创建名为`periodic_callback`的`tornado.ioloop.PeriodicCallback`实例的一个参数。
- en: The `PeriodicCallback` instance allows us to schedule a specified callback to
    be called periodically. In this case, we specify the `BoardInteraction.check_push_buttons_callback`
    class method as the callback that will be called every 500 milliseconds. This
    way, we instruct Tornado to run the `BoardInteraction.check_push_buttons_callback`
    class method every 500 milliseconds. In case the method takes more than 500 milliseconds
    to complete its execution, Tornado will skip subsequent invocations to get back
    on schedule. After the code creates the `PeriodicCallback` instance, the next
    line calls its `start` method.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`PeriodicCallback`实例允许我们安排一个指定的回调定期被调用。在这种情况下，我们指定`BoardInteraction.check_push_buttons_callback`类方法作为每500毫秒将被调用的回调。这样，我们指示Tornado每500毫秒运行一次`BoardInteraction.check_push_buttons_callback`类方法。如果该方法执行时间超过500毫秒，Tornado将跳过后续调用以回到预定时间表。在代码创建`PeriodicCallback`实例后，下一行调用其`start`方法。'
- en: Finally, the call to `ioloop.start()` starts the server created with `application.listen`.
    This way, the Web application will process the received requests and will also
    run a callback to check whether the buttons are pressed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用`ioloop.start()`启动了使用`application.listen`创建的服务器。这样，Web应用程序将处理接收到的请求，并且还会运行一个回调来检查按钮是否被按下。
- en: The following line will start the HTTP server and our new version of the RESTful
    API. Don't forget that you need to transfer the Python source code file to the
    Yocto Linux with an SFTP client.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将启动HTTP服务器和我们的新版本RESTful API。别忘了你需要使用SFTP客户端将Python源代码文件传输到Yocto Linux。
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After you run the example, press the pushbutton that sets the colors to their
    maximum brightness for one second. The RGB LED will display a white light and
    you will see the following output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例后，按下设置颜色为最大亮度的按钮一秒钟。RGB LED将显示白光，你将看到以下输出：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, press the pushbutton that sets the colors to their minimum brightness
    for one second. The RGB LED will turn off and you will see the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按下设置颜色为最小亮度的按钮一秒钟。RGB LED将关闭，你将看到以下输出：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With the new RESTful API we can compose the following HTTP verb and request
    URL:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的RESTful API，我们可以组合以下HTTP动词和请求URL：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The previous request path will match the previously added tuple (`regexp`,
    `request_class`) `(r"/putmaxbrightness", PutMaxBrightnessHandler)` and Tornado
    will call the `PutMaxBrightnessHandler.put` method. The RGB LED will display a
    white light, as happened when you pressed the maximum brightness button. The following
    lines show the response from the HTTP server with the brightness levels that have
    been set for the three LEDs:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的请求路径将与之前添加的元组 (`regexp`, `request_class`) 匹配 (`r"/putmaxbrightness", PutMaxBrightnessHandler`)，Tornado
    将调用 `PutMaxBrightnessHandler.put` 方法。RGB LED 将显示白色光，就像你按下最大亮度按钮时发生的那样。以下行显示了 HTTP
    服务器对三个 LED 设置的亮度级别的响应：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following HTTP verb and request URL will turn off the RGB LED, as happened
    when we pressed the pushbutton that sets the colors to their minimum brightness:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 HTTP 动词和请求 URL 将关闭 RGB LED，就像我们按下设置颜色为最小亮度按钮时发生的那样：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following lines show the response from the HTTP server with the brightness
    levels that have been set for the three LEDs:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了 HTTP 服务器对三个 LED 设置的亮度级别的响应：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, press the pushbutton that sets the colors to their maximum brightness for
    one second. The RGB LED will display a white light. Then, the following three
    HTTP verbs and request URLs will retrieve the brightness level for each of the
    colors. All the requests will return `255` as the current value. We set the brightness
    level with the pushbutton, but the code has the same effect as if we were making
    API calls to change the colors. We kept the consistency for our application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按下设置颜色为最大亮度按钮一秒钟。RGB LED 将显示白色光。然后，以下三个 HTTP 动词和请求 URL 将检索每种颜色的亮度级别。所有请求都将返回
    `255` 作为当前值。我们使用按钮设置亮度级别，但代码的效果与调用 API 来更改颜色相同。我们保持了应用程序的一致性。
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we work with HTTPie, the following commands will do the job:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 HTTPie，以下命令将完成工作：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following lines show the responses from the three requests:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了三个请求的响应：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We created methods that we could use in both an API call and when the user presses
    the pushbuttons. We can process HTTP requests and run actions when the user presses
    pushbuttons. As we build our RESTful API with Tornado, we had to create and configure
    a `PeriodicCallback` instance to make it possible to check whether the pushbuttons
    are pressed every 500 milliseconds.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了可以在 API 调用和用户按下按钮时使用的方法。我们可以处理 HTTP 请求并在用户按下按钮时运行操作。当我们使用 Tornado 构建我们的
    RESTful API 时，我们必须创建和配置一个 `PeriodicCallback` 实例，以便每 500 毫秒检查按钮是否被按下。
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is very important to take into account consistency when we add features that
    we can control with pushbuttons or other electronic components that interact with
    the board. In this case, we made sure that when the user pressed the pushbuttons
    and changed the brightness values for the three colors, the brightness values
    read with API calls were exactly the values set. We worked with object-oriented
    code and with the same methods, and therefore, it was easy to keep consistency.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加可以通过按钮或其他与板交互的电子组件控制的特性时，考虑一致性非常重要。在这种情况下，我们确保当用户按下按钮并更改三种颜色的亮度值时，通过 API
    调用读取的亮度值与设置的值完全一致。我们使用面向对象的代码和相同的方法，因此保持一致性很容易。
- en: Reading digital inputs with the wiring-x86 library
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 wiring-x86 库读取数字输入
- en: So far, we have been using the `mraa` library to read digital inputs. However,
    in the first chapter, we also installed the `wiring-x86` library. We can change
    just a few lines of our object-oriented code to replace the `mraa` library with
    the `wiring-x86` one to check whether the pushbuttons were pressed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用 `mraa` 库读取数字输入。然而，在第一章中，我们也安装了 `wiring-x86` 库。我们可以修改几行面向对象的代码，用
    `wiring-x86` 库替换 `mraa` 库来检查按钮是否被按下。
- en: We will take the code we wrote in the previous chapter when we created the last
    version of our RESTful API with the `wiring-x86` library and we will use this
    code as a baseline to add the new features. The code file for the sample was `iot_python_chapter_04_04.py`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `wiring-x86` 库创建我们 RESTful API 的最后一个版本时，我们将使用上一章编写的代码，并将此代码作为基准来添加新功能。示例代码文件为
    `iot_python_chapter_04_04.py`。
- en: First, we will create a new version of the `PushButton` class to represent a
    pushbutton connected to our board that can use either a pull-up or a pull-down
    resistor. The following lines show the code for the new `PushButton` class that
    works with the `wiring-x86` library. The code file for the sample is `iot_python_chapter_05_03.py`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个`PushButton`类的新版本来表示连接到我们的板上的按钮，该按钮可以使用上拉或下拉电阻。以下行显示了与`wiring-x86`库一起工作的新`PushButton`类的代码。示例代码文件为`iot_python_chapter_05_03.py`。
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We just needed to change a few lines from the previous code of the `PushButton`
    class, that is, the version that worked with the `mraa` library. The new lines
    that interact with the `wiring-x86` library are highlighted in the previous code.
    The constructor, that is, the `__init__` method receives the same argument as
    the `PushButton` class that worked with the `mraa` library. In this case, this
    method saves a reference to the `Board.gpio` class attribute in `self.gpio`. Then,
    the code determines the value of the `pin_mode` local variable based on the value
    of the `pull_up` parameter. If `pull_up` is `true`, the value will be `self.gpio.INPUT_PULLUP`
    and `self.gpio.INPUT_PULLDOWN` otherwise. Finally, the constructor calls the `self.gpio.pinMode`
    method with the received `pin` as its `pin` argument and `pin_mode` as its mode
    argument. This way, we configure the pin to be a digital input pin with the appropriate
    pull-up or pull-down resistor. All the `PushButton` instances will save a reference
    to the same `Board.gpio` class attribute that created an instance of the `GPIO`
    class, specifically, the `wiringx86.GPIOGalileoGen2` class with its `debug` argument
    set to `False` to avoid unnecessary debug information for the low-level communications.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要从`PushButton`类的先前代码中更改几行，即与`mraa`库一起工作的版本。与`wiring-x86`库交互的新行在之前的代码中突出显示。构造函数，即`__init__`方法接收与`mraa`库一起工作的`PushButton`类的相同参数。在这种情况下，此方法将`Board.gpio`类属性的一个引用保存到`self.gpio`中。然后，代码根据`pull_up`参数的值确定`pin_mode`局部变量的值。如果`pull_up`是`true`，则值将是`self.gpio.INPUT_PULLUP`，否则是`self.gpio.INPUT_PULLDOWN`。最后，构造函数使用接收到的`pin`作为其`pin`参数和`pin_mode`作为其模式参数调用`self.gpio.pinMode`方法。这样，我们配置引脚为具有适当的上拉或下拉电阻的数字输入引脚。所有的`PushButton`实例都将保存对创建`GPIO`类实例的同一`Board.gpio`类属性的引用，特别是`wiringx86.GPIOGalileoGen2`类，其`debug`参数设置为`False`以避免不必要的低级通信调试信息。
- en: The `is_pressed` property calls the `digitalRead` method for the GPIO instance
    (`self.gpio`) to set retrieve the digital value for the pin configured as a digital
    input. The `self.pin` attribute specifies the `pin` value for the `analogRead`
    method call. The rest of the code for the `is_pressed` property and the `PushButton`
    class remains the same as the version that works with the `mraa` library.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_pressed`属性调用GPIO实例（`self.gpio`）的`digitalRead`方法来检索配置为数字输入的引脚的数字值。`self.pin`属性指定`analogRead`方法调用的`pin`值。`is_pressed`属性和`PushButton`类的其余代码与使用`mraa`库的版本保持相同。'
- en: Then, it is necessary to make the same edits we made in the previous example
    to create the new version of the `BoardInteraction` class, add the `PutMinBrightnessHandler`
    and `PutMaxBrightnessHandler` classes, create the `tornado.web.Application` instance
    and the new version of the `__main__` method that created and configured the `PeriodicCallback`
    instance. Thus, the rest of the code for our RESTful API remains the same one
    that we have used for the previous example. There is no need to make changes to
    the rest of the code because it will automatically work with the new `PushButton`
    class and there were no changes in the arguments for its constructor or its properties.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要对之前的例子中进行的相同编辑进行修改，以创建`BoardInteraction`类的新版本，添加`PutMinBrightnessHandler`和`PutMaxBrightnessHandler`类，创建`tornado.web.Application`实例以及创建和配置`PeriodicCallback`实例的新版本`__main__`方法。因此，我们RESTful
    API的其余代码与之前示例中使用的代码保持相同。没有必要对代码的其余部分进行修改，因为它将自动与新`PushButton`类一起工作，并且其构造函数或其属性的参数没有发生变化。
- en: The following line will start the HTTP server and our new version of the RESTful
    API that works with the `wiring-x86` library. Don't forget that you need to transfer
    the Python source code file to the Yocto Linux with an SFTP client, as explained
    in the previous chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将启动HTTP服务器和与`wiring-x86`库一起工作的我们新的RESTful API版本。不要忘记，你需要使用SFTP客户端将Python源代码文件传输到Yocto
    Linux，正如前一章所述。
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We can press the pushbuttons and then make the same HTTP requests we made in
    our previous example to check that we can achieve exactly the same results with
    the `wiring-x86` library.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按下按钮，然后发出我们在上一个示例中发出的相同HTTP请求，以检查我们是否可以使用`wiring-x86`库实现完全相同的结果。
- en: Using interrupts to detect pressed pushbuttons
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用中断检测按下按钮
- en: Previously, we analyzed the advantages of disadvantages of reading digital inputs
    with polling as in the previous examples compared with the usage of interrupts
    for the same task. If we keep any of the pushbuttons pressed for a long time,
    the code behaves as if the pushbutton was pressed many times. Now, we don't want
    this situation to happen, and therefore, we will use interrupts instead of polling
    to detect when the pushbuttons are pressed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们分析了与之前示例中轮询读取数字输入相比，使用中断执行相同任务的优缺点。如果我们长时间按下任何一个按钮，代码的行为就像按钮被多次按下一样。现在，我们不希望这种情况发生，因此我们将使用中断而不是轮询来检测按钮是否被按下。
- en: Before we start editing our code, it is necessary to make changes to our existing
    wirings. The problem is that not all the GPIO pins support interrupts. In fact,
    pins number 0 and 1 don't support interrupts and we have our pushbuttons connected
    to them. In [Chapter 1](ch01.html "Chapter 1. Understanding and Setting up the
    Base IoT Hardware"), *Understanding and Setting up the Base IoT Hardware* when
    we learned about the I/O pins included in the Intel Galileo Gen 2 board, we understood
    that the pins labeled with a tilde symbol (**~**) as a prefix for the number can
    be used as PWM output pins. The fact is that the pins labeled with a tilde symbol
    (**~**) as a prefix for the number also supports interrupts.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编辑代码之前，有必要修改我们现有的接线。问题是并非所有的GPIO引脚都支持中断。实际上，编号为0和1的引脚不支持中断，而我们的按钮连接到了这些引脚上。在[第1章](ch01.html
    "第1章. 理解和设置基础物联网硬件")中，*理解和设置基础物联网硬件*，当我们学习到英特尔Galileo Gen 2板上的I/O引脚时，我们了解到带有波浪线符号（**~**）作为编号前缀的引脚可以用作PWM输出引脚。事实上，带有波浪线符号（**~**）作为编号前缀的引脚也支持中断。
- en: Thus, we can move the wire that connects the reset pushbutton that turns off
    the three colors from pin **1** to pin **~11**, and move the wire that connects
    the pushbutton that sets the three colors to their maximum brightness from pin
    **0** to pin **~10**.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将连接到关闭三个颜色的复位按钮的线从引脚**1**移到引脚**~11**，并将连接到将三个颜色设置为最大亮度的按钮的线从引脚**0**移到引脚**~10**。
- en: 'The following diagram shows the components connected to the breadboard, the
    necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard.
    The Fritzing file for the sample is `iot_fritzing_chapter_05_04.fzz` and the following
    picture is the breadboard view:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了连接到面包板的组件、必要的接线以及从英特尔Galileo Gen 2板到面包板的接线。该示例的Fritzing文件为`iot_fritzing_chapter_05_04.fzz`，以下图片是面包板视图：
- en: '![Using interrupts to detect pressed pushbuttons](img/B05042_05_07.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![使用中断检测按下按钮](img/B05042_05_07.jpg)'
- en: 'The following picture shows the schematic with the electronic components represented
    as symbols:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了用符号表示的电子元件的电路图：
- en: '![Using interrupts to detect pressed pushbuttons](img/B05042_05_08.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![使用中断检测按下按钮](img/B05042_05_08.jpg)'
- en: The GPIO pin labeled **D10 PWM/SS** in the board's symbol is connected to the
    **S2** pushbutton and the **R4** resistor is its pull-up resistor. The GPIO pin
    labeled **D11 PWM/MOSI** in the board's symbol is connected to the **S1** pushbutton
    and the **R5** resistor is its pull-up resistor. This way, GPIO pin number 10
    will be low when the **S2** pushbutton is pressed and GPIO pin number 11 will
    be low when the **S1** pushbutton is pressed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 板上符号中标记为**D10 PWM/SS**的GPIO引脚连接到**S2**按钮，**R4**电阻是其上拉电阻。板上符号中标记为**D11 PWM/MOSI**的GPIO引脚连接到**S1**按钮，**R5**电阻是其上拉电阻。这样，当**S2**按钮被按下时，GPIO引脚编号10将是低电平，当**S1**按钮被按下时，GPIO引脚编号11将是低电平。
- en: Tip
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The signal will fall from high to low when the pushbutton is pressed, and therefore,
    we are interested in the interrupt that is generated when the signal falls because
    it indicates that the pushbutton has been pressed. If the user keeps the pushbutton
    pressed, the signal won't fall many times, and the GPIO pin will stay in the low
    level. Thus, only one interrupt will be fired when we are observing the fall from
    high to low and we won't have multiple calls to the interrupt handler code even
    if the user keeps the button pressed for a long time.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被按下时，信号将从高电平降至低电平，因此，我们对当信号降至低电平时产生的中断感兴趣，因为这表明按钮已被按下。如果用户持续按下按钮，信号不会多次下降，GPIO引脚将保持在低电平。因此，当我们观察从高电平降至低电平的过程中，即使用户长时间按下按钮，也只会触发一次中断，我们不会对中断处理代码进行多次调用。
- en: Remember that the **S1** pushbutton is located at the left-hand side in the
    breadboard while the **S2** pushbutton is located at the right-hand side. Now,
    it is time to make the changes to the wirings. Don't forget to shutdown the Yocto
    Linux, wait for all the onboard LEDs to turn off, and unplug the power supply
    from the Intel Galileo Gen 2 board before removing any wire from the board's pins.
    After we finish the changes in the wirings, we will write the Python code to detect
    when the user presses the pushbuttons with interrupts instead of working with
    polling.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，**S1**按钮位于面包板的左侧，而**S2**按钮位于右侧。现在，是时候对连线进行更改了。在从板上的引脚上拔掉任何电线之前，不要忘记关闭Yocto
    Linux，等待所有板载LED灯熄灭，并从Intel Galileo Gen 2板上拔掉电源。完成连线更改后，我们将编写Python代码来检测用户按下按钮时使用中断而不是轮询。
- en: We will take the code we wrote in the previous example when we created the last
    version of our RESTful API with the `mraa` library and we will use this code as
    a baseline to add the new features. The code file for the sample was `iot_python_chapter_05_02.py`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`mraa`库创建我们RESTful API的最后一个版本时，我们将使用之前示例中编写的代码，并将此代码作为基准来添加新功能。示例代码文件为`iot_python_chapter_05_02.py`。
- en: We will create a new `PushButtonWithInterrupt` class to represent a pushbutton
    connected to our board that can use either a pull-up or a pull-down resistor and
    will specify the callback that needs to be called when the button is pressed,
    that is, the interrupt handler. When the button is pressed, an interrupt will
    occur and the specified callback will be executed as the interrupt handler. The
    following lines show the code for the new `PushButtonWithInterrupt` class that
    works with the `mraa` library. The code file for the sample is `iot_python_chapter_05_04.py`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的`PushButtonWithInterrupt`类来表示连接到我们板上的按钮，该按钮可以使用上拉或下拉电阻，并将指定当按钮被按下时需要调用的回调，即中断处理程序。当按钮被按下时，将发生中断，指定的回调将作为中断处理程序执行。以下行显示了与`mraa`库一起工作的新`PushButtonWithInterrupt`类的代码。示例代码文件为`iot_python_chapter_05_04.py`。
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have to specify the following arguments when we create an instance of the
    `PushButtonWithInterrupt` class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`PushButtonWithInterrupt`类的实例时，我们必须指定以下参数：
- en: The pin number to which the pushbutton is connected in the `pin` argument
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`pin`参数中，按钮连接到的引脚号
- en: The function that will be called when the interrupt is triggered, that is, the
    interrupt handler function, in the `pyfunc` argument
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当中断被触发时将被调用的函数，即中断处理函数，在`pyfunc`参数中
- en: The arguments that will be passed to the interrupt handler function, in the
    `args` argument
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将传递给中断处理函数的参数，在`args`参数中
- en: In case we don't specify additional values, the optional `pull_up` argument
    will be `True` and the instance will work as if the pushbutton were connected
    with a pull-up resistor. If we work with a pull-down resistor, we must pass `False`
    in the `pull_up` argument.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有指定额外的值，可选的`pull_up`参数将为`True`，实例将像按钮连接上拉电阻一样工作。如果我们使用下拉电阻，我们必须在`pull_up`参数中传递`False`。
- en: The constructor, that is, the `__init__` method, creates a new `mraa.Gpio` instance
    with the received `pin` as its `pin` argument, saves its reference in the `gpio`
    attribute and calls its `dir` method to configure the pin to be an input pin (`mraa.DIR_IN`).
    Then, the code determines the value of the `mode` local variable based on the
    value of the `pull_up` parameter. If `pull_up` is `true`, the value will be `mraa.EDGE_FALLING`
    and `mraa.EDGE_RISING` otherwise. The `mode` local variable holds the edge mode
    that will trigger the interrupt. When we work with pull-up resistors and the user
    presses a pushbutton, the signal will fall from high to low, and therefore, we
    want an edge falling scenario to trigger the interrupt that indicates the button
    has been pressed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数，即 `__init__` 方法，创建一个新的 `mraa.Gpio` 实例，将接收到的 `pin` 作为其 `pin` 参数，将其引用保存到
    `gpio` 属性中，并调用其 `dir` 方法来配置引脚为输入引脚（`mraa.DIR_IN`）。然后，代码根据 `pull_up` 参数的值确定 `mode`
    局部变量的值。如果 `pull_up` 为 `true`，则值将为 `mraa.EDGE_FALLING` 和 `mraa.EDGE_RISING`；否则。`mode`
    局部变量持有将触发中断的边缘模式。当我们使用上拉电阻并且用户按下按钮时，信号将从高电平下降到低电平，因此我们希望边缘下降场景触发中断，以指示按钮已被按下。
- en: Then, the code calls the `self.gpio.isr` method with the received `pin` as its
    `pin` argument, the local `mode` variable as its `mode` argument, and the received
    `pyfunc` and `args` as its `pyfunc` and `args` arguments. This way, we set the
    callback to be called when the pin value changes because a pushbutton was pressed.
    As we determined the appropriate value for the `mode` local variable before, we
    will configure the appropriate edge mode that will trigger an interrupt when the
    button is pressed based on the usage of pull-up or pull-down resistors. As previously
    explained, not all the GPIO pins support interrupts, and therefore, it is necessary
    to check the results of calling the `self.gpio.isr` method. In case an interrupt
    handler has already been set to the pin with a previous call to the `self.gpio.isr`
    method wouldn't return an `mraa.SUCCESS` value.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码使用接收到的 `pin` 作为其 `pin` 参数，局部变量 `mode` 作为其 `mode` 参数，以及接收到的 `pyfunc` 和 `args`
    作为其 `pyfunc` 和 `args` 参数来调用 `self.gpio.isr` 方法。这样，我们设置了一个回调，当引脚值改变（即按钮被按下）时将被调用。因为我们之前已经确定了
    `mode` 局部变量的适当值，所以我们将根据上拉或下拉电阻的使用配置适当的边缘模式，以便在按钮被按下时触发中断。如前所述，并非所有 GPIO 引脚都支持中断，因此有必要检查调用
    `self.gpio.isr` 方法的返回结果。如果之前通过调用 `self.gpio.isr` 方法已经将中断处理程序设置到引脚上，则不会返回 `mraa.SUCCESS`
    值。
- en: The `PushButtonWithInterrupt` class also declares a `__del__` method that will
    be called before Python removes an instance of this class from memory, that is,
    when the object becomes inaccessible and gets deleted by the garbage-collection
    mechanism. The method just calls the `self.gpio.isrExit` method to remove the
    interrupt handler associated to the pin.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`PushButtonWithInterrupt` 类还声明了一个 `__del__` 方法，该方法将在 Python 从内存中删除此类的实例之前被调用，即当对象变得不可访问并被垃圾回收机制删除时。该方法只是调用
    `self.gpio.isrExit` 方法来移除与引脚关联的中断处理程序。'
- en: We will replace the two class attributes in the existing `BoardInteraction`
    class. Instead of working with `PushButton` instances, we will work with `PushButtonWithInterrupt`
    instances. The class methods declared in the class remain the same as in the code
    we are using as a baseline but they aren't included in the next lines. The code
    file for the sample is `iot_python_chapter_05_04.py`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将替换现有 `BoardInteraction` 类中的两个类属性。我们将不再使用 `PushButton` 实例，而是使用 `PushButtonWithInterrupt`
    实例。类中声明的类方法与作为基准使用的代码中保持相同，但它们不包括在下述行中。示例代码的文件名为 `iot_python_chapter_05_04.py`。
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The highlighted lines of code declare two class attributes for the `BoardInteraction`
    class: `reset_push_button` and `max_brightness_push_button`. The `reset_push_button`
    class attribute is an instance of `PushButtonWithInterrupt` with its `pin` attribute
    set to `11` and its interrupt handler set to the `set_min_brightness_callback`
    function that we will declare later. This way, the instance will make all the
    necessary configurations to call the `set_min_brightness_callback` function when
    the user presses the pushbutton connected to GPIO pin number 11\. The `max_brightness_push_button`
    class attribute is an instance of `PushButtonWithInterrupt` with its `pin` attribute
    set to `10`, and therefore, will make all the necessary configurations to call
    the `set_max_brightness_callback` function when the user presses the pushbutton
    connected to GPIO pin number 10.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码行声明了`BoardInteraction`类的两个类属性：`reset_push_button`和`max_brightness_push_button`。`reset_push_button`类属性是一个`PushButtonWithInterrupt`的实例，其`pin`属性设置为`11`，中断处理程序设置为稍后我们将声明的`set_min_brightness_callback`函数。这样，该实例将在用户按下连接到GPIO引脚编号11的按钮时调用`set_min_brightness_callback`函数进行所有必要的配置。`max_brightness_push_button`类属性是一个`PushButtonWithInterrupt`的实例，其`pin`属性设置为`10`，因此，将在用户按下连接到GPIO引脚编号10的按钮时调用`set_max_brightness_callback`函数进行所有必要的配置。
- en: 'Now, it is necessary to declare the functions that will be called when the
    interrupts are triggered: `set_min_brightness_callback` and `set_max_brightness_callback`.
    Notice that the functions are declared as functions and they aren''t methods of
    any class.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有必要声明当中断被触发时将被调用的函数：`set_min_brightness_callback`和`set_max_brightness_callback`。请注意，这些函数被声明为函数，而不是任何类的成员方法。
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Both functions declared in the previous code print a message indicating that
    a specific button has been pressed and call either the `BoardInteraction.set_max_brightness`
    or the `BoardInteraction.set_min_brightness` class method. We already know these
    class methods from our previous examples and we didn't have to make any changes
    to them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中声明的两个函数会打印一条消息，指示已按下特定按钮，并调用`BoardInteraction.set_max_brightness`或`BoardInteraction.set_min_brightness`类方法。我们已经从之前的示例中知道了这些类方法，并且我们没有对它们进行任何更改。
- en: Finally, it is necessary to replace the `__main__` method with a new one because
    we don't need to run a periodic callback anymore. Now, our `PushButtonWithInterrupt`
    instances configure the interrupt handlers that will be called whenever a pushbutton
    is pressed. The code file for the sample is `iot_python_chapter_05_04.py`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有必要用一个新的方法替换`__main__`方法，因为我们不再需要运行周期性回调了。现在，我们的`PushButtonWithInterrupt`实例配置了当按下按钮时将被调用的中断处理程序。示例的代码文件是`iot_python_chapter_05_04.py`。
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When the `__main__` method starts running, the `BoardInteraction` class already
    executed the code that creates the two `PushButtonWithInterrupt` instances, and
    therefore, the interrupt handlers will run whenever we press a pushbutton. The
    `__main__` method just builds and starts the HTTP server.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当`__main__`方法开始运行时，`BoardInteraction`类已经执行了创建两个`PushButtonWithInterrupt`实例的代码，因此，每当按下按钮时，中断处理程序都会运行。`__main__`方法只是构建并启动HTTP服务器。
- en: The following line will start the HTTP server and our new version of the RESTful
    API. Don't forget that you need to transfer the Python source code file to the
    Yocto Linux with an SFTP client.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将启动HTTP服务器和我们的新版本RESTful API。别忘了你需要使用SFTP客户端将Python源代码文件传输到Yocto Linux。
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After you run the example, press the pushbutton that sets the colors to their
    maximum brightness for 5 seconds. The RGB LED will display a white light and you
    will see the following output:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例后，按下设置颜色为最大亮度的按钮5秒钟。RGB LED将显示白色光，你将看到以下输出：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You were pressing the pushbutton for 5 seconds but the output displayed the
    messages indicating that you were pressing the button just once. The GPIO pin
    number 10 signal went from high to low once when you pressed the button, and therefore,
    the `mraa.EDGE_FALLING` interrupt was fired and the configured interrupt handler
    (`set_max_brightness_callback`) was executed. You kept the pushbutton pressed,
    but the signal stayed in the low value, and therefore, the interrupt wasn't triggered
    again.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你按下了按钮5秒钟，但输出显示的消息表明你只按了一次按钮。当你按下按钮时，GPIO引脚编号10的信号从高变低一次，因此触发了`mraa.EDGE_FALLING`中断，并执行了配置的中断处理程序(`set_max_brightness_callback`)。你继续按住按钮，但信号保持在低值，因此没有再次触发中断。
- en: Tip
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Obviously, when you want to run code just once when a pushbutton is pressed
    even for a long time, the usage of interrupt handlers provides the necessary precision
    that polling makes more complex to achieve.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当你只想在按下按钮一次（即使按得很久）时运行代码，中断处理程序的用法提供了轮询所难以实现的必要精度。
- en: 'Now, press the pushbutton that sets the colors to their minimum brightness
    for 10 seconds. The RGB LED will turn off and you will see the following output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按下设置颜色为最低亮度的按钮10秒钟。RGB LED将关闭，你将看到以下输出：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As happened with the other pushbutton, you were pressing the pushbutton for
    many seconds but the output displayed the messages indicating that you were pressing
    the button just once. The GPIO pin number 11 signal went from high to low once
    when you pressed the button, and therefore, the `mraa.EDGE_FALLING` interrupt
    was fired and the configured interrupt handler (`set_min_brightness_callback`)
    was executed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他按钮一样，你按下了按钮很多秒，但显示的消息表明你只按了一次按钮。当你按下按钮时，GPIO引脚11的信号从高电平变为低电平一次，因此，`mraa.EDGE_FALLING`中断被触发，配置的中断处理程序（`set_min_brightness_callback`）被执行。
- en: Tip
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We can make the same HTTP requests we made in our previous examples to check
    that we can achieve exactly the same results with the new code that works with
    interrupt handlers while running the HTTP server.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以发出与之前示例中相同的HTTP请求，以检查我们是否可以使用与使用中断处理程序运行HTTP服务器的新代码实现完全相同的结果。
- en: We can process HTTP requests and run interrupt handlers when the user presses
    pushbuttons. We improved accuracy compared with the previous version in which
    the code acted as if the pushbuttons were pressed many times when the user kept
    the pushbuttons for a long time. In addition, we removed the periodic callback.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以处理HTTP请求，并在用户按下按钮时运行中断处理程序。与之前版本相比，我们提高了准确性，因为代码表现得好像用户长时间按住按钮时按钮被按了很多次。此外，我们还移除了周期性回调。
- en: Tip
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Whenever we have to read digital inputs, we can decide between working with
    polling or interrupt handlers based on the specific requirements we have for our
    projects. Sometimes, interrupt handlers are the best solution but in other cases
    polling is more suitable. It is very important to know that the `wiring-x86` library
    doesn't allow us to work with interrupt handlers for digital inputs, and therefore,
    in case we decide to use them, we have to work with the `mraa` library.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们需要读取数字输入时，我们可以根据我们项目中的具体需求在轮询或中断处理程序之间进行选择。有时，中断处理程序是最佳解决方案，但在其他情况下轮询更为合适。非常重要的一点是，`wiring-x86`库不允许我们使用中断处理程序来处理数字输入，因此，如果我们决定使用它们，我们必须使用`mraa`库。
- en: Test your knowledge
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'As an effect of using a pull-up resistor with a pushbutton, we will read the
    following value when the pushbutton is pressed in the GPIO pin to which it is
    connected:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于在按钮上使用了上拉电阻，当按钮按下连接到GPIO引脚时，我们将读取以下值：
- en: A low value (0V).
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 低值（0V）。
- en: A high value, that is, the IOREF voltage.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高值，即IOREF电压。
- en: A value between 1V and 3.3V.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电压值在1V到3.3V之间。
- en: 'As an effect of using a pull-up resistor with a pushbutton, we will read the
    following value when the pushbutton is released in the GPIO pin to which it is
    connected:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于在按钮上使用了上拉电阻，当按钮释放连接到GPIO引脚时，我们将读取以下值：
- en: A low value (0V).
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 低值（0V）。
- en: A high value, that is, the IOREF voltage.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高值，即IOREF电压。
- en: A value between 1V and 3.3V.
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电压值在1V到3.3V之间。
- en: 'If we check a pushbutton status by reading the GPIO pin value to which it is
    connected with polling, the loop runs every 0.5 seconds and the user keeps the
    pushbutton pressed for 3 seconds:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们通过轮询读取连接到GPIO引脚的按钮状态，循环每0.5秒运行一次，并且用户持续按下按钮3秒钟：
- en: The code will behave as if the pushbutton was pressed more than once.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码将表现得好像按钮被按了多次。
- en: The code will behave as if the pushbutton was pressed just once.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码将表现得好像按钮被按了一次。
- en: The code will behave as if the pushbutton was never pressed.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码将表现得好像按钮从未被按下。
- en: 'We have an interrupt handler for a pushbutton with the interrupt edge mode
    set to `mraa.EDGE_FALLING`, and the pushbutton is connected with a pull-up resistor.
    If the user keeps the pushbutton pressed for 3 seconds:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个中断处理程序，用于按钮，中断边缘模式设置为`mraa.EDGE_FALLING`，按钮通过上拉电阻连接。如果用户持续按下按钮3秒钟：
- en: The code will behave as if the pushbutton was pressed more than once.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码将表现得好像按钮被按了多次。
- en: The code will behave as if the pushbutton was pressed just once.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码将表现得好像按钮只被按下了一次。
- en: The code will behave as if the pushbutton was never pressed.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码将表现得好像按钮从未被按下。
- en: 'In the Intel Galileo Gen 2 board, the pins labeled with the following symbol
    as a prefix for the number can be configured with interrupt handlers for digital
    inputs in the `mraa` library:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在英特尔Galileo Gen 2板上，带有以下符号作为前缀的引脚可以在`mraa`库中配置为数字输入的中断处理程序：
- en: Hash sign (**#**).
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哈希符号（**#**）。
- en: Dollar sign (**$**).
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 美元符号（**$**）。
- en: Tilde symbol (**~**).
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 波浪符号（**~**）。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we understood the difference between pull-up and pull-down
    resistors to wire pushbuttons and read their status with the `mraa` and `wiring-x86`
    libraries. We understood the difference between reading the pushbutton statuses
    with polling and working with interrupts and interrupt handlers.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了上拉和下拉电阻的区别，以及如何使用`mraa`和`wiring-x86`库读取按钮的状态。我们了解了使用轮询读取按钮状态与使用中断和中断处理程序工作的区别。
- en: We created consistent code that allowed the user to perform the same actions
    with either pushbuttons in the breadboard or HTTP request. We combined code that
    reacts to changes in the statuses of the pushbuttons with a RESTful API built
    with Tornado Web server. As in the previous chapters, we took advantage of Python's
    object-oriented features and we created classes to encapsulate pushbuttons and
    the necessary configurations with the `mraa` and `wiring-x86` libraries. Our code
    is easy to read and understand and we can easily switch the underlying low-level
    library.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了统一的代码，允许用户使用面包板上的按钮或HTTP请求执行相同的操作。我们将响应按钮状态变化的代码与使用Tornado Web服务器构建的RESTful
    API相结合。与前面的章节一样，我们利用了Python的面向对象特性，并创建了类来封装按钮和必要的配置，使用`mraa`和`wiring-x86`库。我们的代码易于阅读和理解，并且我们可以轻松切换底层低级库。
- en: Now that we were able to read digital inputs in different ways and configurations
    that made is possible for users to interact with our IoT device while it processed
    HTTP requests, we can work with more complex communications capabilities included
    in the board and take advantage of its storage, which are the topics of the next
    chapter.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够以不同的方式和配置读取数字输入，这使得用户在设备处理HTTP请求的同时能够与之交互，我们可以利用板上的更复杂的通信功能，并利用其存储功能，这些是下一章的主题。
