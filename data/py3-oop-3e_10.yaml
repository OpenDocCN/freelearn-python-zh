- en: Python Design Patterns I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python设计模式I
- en: In the previous chapter, we were briefly introduced to design patterns, and
    covered the iterator pattern, a pattern so useful and common that it has been
    abstracted into the core of the programming language itself. In this chapter,
    we'll be reviewing other common patterns, and how they are implemented in Python.
    As with iteration, Python often provides an alternative syntax to make working
    with such problems simpler. We will cover both the *traditional* design, and the
    Python version for these patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了设计模式，并涵盖了迭代器模式，这是一个非常有用且常见的模式，以至于它被抽象成了编程语言的核心。在本章中，我们将回顾其他常见模式，以及它们在Python中的实现方式。与迭代类似，Python经常提供替代语法来简化此类问题的处理。我们将涵盖这些模式的*传统*设计和Python版本。
- en: 'In summary, we''ll see:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们将看到：
- en: Numerous specific patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多具体的模式
- en: A canonical implementation of each pattern in Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中每个模式的规范实现
- en: Python syntax to replace certain patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python语法来替换某些模式
- en: The decorator pattern
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: The decorator pattern allows us to *wrap* an object that provides core functionality
    with other objects that alter this functionality. Any object that uses the decorated
    object will interact with it in exactly the same way as if it were undecorated
    (that is, the interface of the decorated object is identical to that of the core
    object).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式允许我们用其他改变此功能的对象来*包装*提供核心功能的对象。任何使用装饰对象的对象都将以与未装饰对象完全相同的方式与之交互（即，装饰对象的接口与核心对象的接口相同）。
- en: 'There are two primary uses of the decorator pattern:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式有两个主要用途：
- en: Enhancing the response of a component as it sends data to a second component
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强组件在向第二个组件发送数据时的响应
- en: Supporting multiple optional behaviors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多个可选行为
- en: 'The second option is often a suitable alternative to multiple inheritance.
    We can construct a core object, and then create a decorator wrapping that core.
    Since the decorator object has the same interface as the core object, we can even
    wrap the new object in other decorators. Here''s how it looks in a UML diagram:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择通常是多重继承的一个合适替代方案。我们可以构建一个核心对象，然后创建一个装饰器来包装这个核心。由于装饰器对象与核心对象具有相同的接口，我们甚至可以在其他装饰器中包装新对象。以下是一个UML图中的示例：
- en: '![](img/03350c12-8e05-436c-b1a4-523d3c95399e.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/03350c12-8e05-436c-b1a4-523d3c95399e.png)'
- en: Here, **Core** and all the decorators implement a specific **Interface**. The
    decorators maintain a reference to another instance of that **Interface** via
    composition. When called, the decorator does some added processing before or after
    calling its wrapped interface. The wrapped object may be another decorator, or
    the core functionality. While multiple decorators may wrap each other, the object
    in the *center* of all those decorators provides the core functionality.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**核心**和所有装饰器实现了一个特定的**接口**。装饰器通过组合维护对该接口另一个实例的引用。当被调用时，装饰器在其包装的接口之前或之后执行一些附加处理。包装的对象可能是另一个装饰器，或者是核心功能。虽然多个装饰器可以相互包装，但所有这些装饰器的*中心*对象提供了核心功能。
- en: A decorator example
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器示例
- en: 'Let''s look at an example from network programming. We''ll be using a TCP socket.
    The `socket.send()` method takes a string of input bytes and outputs them to the
    receiving socket at the other end. There are plenty of libraries that accept sockets
    and access this function to send data on the stream. Let''s create such an object;
    it will be an interactive shell that waits for a connection from a client and
    then prompts the user for a string response:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看网络编程中的一个示例。我们将使用TCP套接字。`socket.send()`方法接收一个输入字节的字符串，并将其输出到另一端的接收套接字。有许多库接受套接字并使用此功能在流中发送数据。让我们创建这样一个对象；它将是一个交互式外壳，等待客户端的连接，然后提示用户输入字符串响应：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `respond` function accepts a `socket` parameter and prompts for data to
    be sent as a reply, then sends it. To use it, we construct a server socket and
    tell it to listen on port `2401` (I picked the port randomly) on the local computer.
    When a client connects, it calls the `respond` function, which requests data interactively
    and responds appropriately. The important thing to notice is that the `respond`
    function only cares about two methods of the socket interface: `send` and `close`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`respond`函数接受一个`socket`参数，提示输入要发送作为回复的数据，然后发送它。要使用它，我们构建一个服务器套接字，并告诉它在本地的计算机上监听端口`2401`（我随机选择的端口）。当客户端连接时，它调用`respond`函数，该函数交互式地请求数据并相应地响应。需要注意的是，`respond`函数只关心套接字接口的两个方法：`send`和`close`。'
- en: 'To test this, we can write a very simple client that connects to the same port
    and outputs the response before exiting:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个，我们可以编写一个非常简单的客户端，它连接到相同的端口，在退出前输出响应：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To use these programs, follow these steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些程序，请按照以下步骤操作：
- en: Start the server in one Terminal.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个终端中启动服务器。
- en: Open a second Terminal window and run the client.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开第二个终端窗口并运行客户端。
- en: 'At the Enter a value: prompt in the server window, type a value and press *Enter*.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器窗口的“输入一个值：”提示符下，输入一个值并按*Enter*键。
- en: The client will receive what you typed, print it to the console, and exit. Run
    the client a second time; the server will prompt for a second value.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端将接收你输入的内容，将其打印到控制台，然后退出。再次运行客户端；服务器将提示输入第二个值。
- en: 'The result will look something like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来可能像这样：
- en: '![](img/4a7dbf2a-12ac-488a-87f4-f8b7fc895c4e.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a7dbf2a-12ac-488a-87f4-f8b7fc895c4e.png)'
- en: Now, looking back at our server code, we see two sections. The `respond` function
    sends data into a `socket` object. The remaining script is responsible for creating
    that `socket` object. We'll create a pair of decorators that customize the socket
    behavior without having to extend or modify the socket itself.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回顾我们的服务器代码，我们看到有两个部分。`respond`函数将数据发送到`socket`对象。剩余的脚本负责创建这个`socket`对象。我们将创建一对装饰器，以定制`socket`行为，而无需扩展或修改`socket`本身。
- en: 'Let''s start with a *logging* decorator. This object outputs any data being
    sent to the server''s console before it sends it to the client:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`*logging*`装饰器开始。该对象在将数据发送到客户端之前，将其输出到服务器的控制台：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This class decorates a `socket` object and presents the `send` and `close` interface
    to client sockets. A better decorator would also implement (and possibly customize)
    all of the remaining `socket` methods. It should properly implement all of the
    arguments to `send`, (which actually accepts an optional flags argument) as well,
    but let's keep our example simple. Whenever `send` is called on this object, it
    logs the output to the screen before sending data to the client using the original
    socket.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类装饰了一个`socket`对象，并向客户端套接字提供了`send`和`close`接口。更好的装饰器还会实现（并可能定制）所有剩余的`socket`方法。它应该正确实现所有`send`的参数（实际上接受一个可选的标志参数），但让我们保持示例简单。每当在这个对象上调用`send`时，它都会在将数据发送到客户端之前将输出记录到屏幕上。
- en: 'We only have to change one line in our original code to use this decorator.
    Instead of calling `respond` with the socket, we call it with a decorated socket:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在我们的原始代码中更改一行来使用这个装饰器。我们不是用套接字调用`respond`，而是用装饰过的套接字调用它：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While that's quite simple, we have to ask ourselves why we didn't just extend
    the `socket` class and override the `send` method. We could call `super().send`
    to do the actual sending, after we logged it. There is nothing wrong with this
    design either.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很简单，但我们不得不问自己，为什么我们没有只是扩展`socket`类并重写`send`方法。我们可以在记录之后调用`super().send`来执行实际的发送。这种设计也没有什么问题。
- en: 'When faced with a choice between decorators and inheritance, we should only
    use decorators if we need to modify the object dynamically, according to some
    condition. For example, we may only want to enable the logging decorator if the
    server is currently in debugging mode. Decorators also beat multiple inheritance
    when we have more than one optional behavior. As an example, we can write a second
    decorator that compresses data using `gzip` compression whenever `send` is called:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 面对装饰器和继承之间的选择时，我们只有在需要根据某些条件动态修改对象时才应使用装饰器。例如，我们可能只想在服务器当前处于调试模式时启用日志装饰器。当我们有多个可选行为时，装饰器也比多重继承更胜一筹。例如，我们可以编写第二个装饰器，在调用`send`时使用`gzip`压缩来压缩数据：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `send` method in this version compresses the incoming data before sending
    it on to the client.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的`send`方法中，在将数据发送到客户端之前，会对传入的数据进行压缩。
- en: 'Now that we have these two decorators, we can write code that dynamically switches
    between them when responding. This example is not complete, but it illustrates
    the logic we might follow to mix and match decorators:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这两个装饰器，我们可以编写代码在响应时动态地在它们之间切换。这个例子并不完整，但它说明了我们可能遵循的逻辑来混合和匹配装饰器：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code checks a hypothetical configuration variable named `log_send`. If
    it's enabled, it wraps the socket in a `LogSocket` decorator. Similarly, it checks
    whether the client that has connected is in a list of addresses known to accept
    compressed content. If so, it wraps the client in a `GzipSocket` decorator. Notice
    that none, either, or both of the decorators may be enabled, depending on the
    configuration and connecting client. Try writing this using multiple inheritance
    and see how confused you get!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查一个假设的配置变量`log_send`。如果它被启用，它将套接字包裹在`LogSocket`装饰器中。同样，它检查连接的客户端是否在已知接受压缩内容的地址列表中。如果是这样，它将客户端包裹在`GzipSocket`装饰器中。注意，根据配置和连接的客户端，可能没有，一个，或者两个装饰器被启用。尝试使用多重继承来编写这个，看看你会多么困惑！
- en: Decorators in Python
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的装饰器
- en: The decorator pattern is useful in Python, but there are other options. For
    example, we may be able to use monkey-patching (for example, `socket.socket.send
    = log_send`) to get a similar effect. Single inheritance, where the *optional* calculations
    are done in one large method, could be an option, and multiple inheritance should
    not be written off just because it's not suitable for the specific example seen
    previously.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式在Python中很有用，但还有其他选择。例如，我们可能能够使用猴子补丁（例如，`socket.socket.send = log_send`）来达到类似的效果。单继承，其中*可选*的计算在一个大方法中完成，可能是一个选择，而且多重继承不应该因为之前看到的特定示例不适合而被放弃。
- en: In Python, it is very common to use this pattern on functions. As we saw in
    a previous chapter, functions are objects too. In fact, function decoration is
    so common that Python provides a special syntax to make it easy to apply such
    decorators to functions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，在函数上使用这种模式非常常见。正如我们在前面的章节中看到的，函数也是对象。事实上，函数装饰如此常见，以至于Python提供了一种特殊的语法，使其能够轻松地将这样的装饰器应用于函数。
- en: 'For example, we can look at the logging example in a more general way. Instead
    of logging, only send calls on sockets; we may find it helpful to log all calls
    to certain functions or methods. The following example implements a decorator
    that does just this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以更一般地看待日志记录的例子。除了在套接字上发送日志调用之外；我们可能会发现记录对某些函数或方法的全部调用是有帮助的。以下示例实现了一个执行此操作的装饰器：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This decorator function is very similar to the example we explored earlier;
    in those cases, the decorator took a socket-like object and created a socket-like
    object. This time, our decorator takes a function object and returns a new function
    object. This code comprises three separate tasks:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器函数与我们之前探索的例子非常相似；在那些情况下，装饰器接受一个类似套接字的对象并创建了一个类似套接字的对象。这次，我们的装饰器接受一个函数对象并返回一个新的函数对象。这段代码包括三个独立任务：
- en: A function, `log_calls`, that accepts another function
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`log_calls`的函数，它接受另一个函数
- en: This function defines (internally) a new function, named `wrapper`, that does
    some extra work before calling the original function
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数定义（内部）了一个名为`wrapper`的新函数，它在调用原始函数之前做一些额外的工作
- en: The inner function is returned from the outer function
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部函数是从外部函数返回的
- en: Three sample functions demonstrate the decorator in use. The third one includes
    a `sleep` call to demonstrate the timing test. We pass each function into the
    decorator, which returns a new function. We assign this new function to the original
    variable name, effectively replacing the original function with a decorated one.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 三个示例函数展示了装饰器的使用。第三个包括一个`sleep`调用，以展示时间测试。我们将每个函数传递给装饰器，装饰器返回一个新的函数。我们将这个新函数分配给原始变量名，实际上是用装饰过的函数替换了原始函数。
- en: This syntax allows us to build up decorated function objects dynamically, just
    as we did with the socket example. If we don't replace the name, we can even keep
    decorated and non-decorated versions for different situations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法允许我们动态地构建装饰过的函数对象，就像我们在套接字示例中所做的那样。如果我们不替换名称，我们甚至可以保留装饰和非装饰版本以适应不同的情况。
- en: Typically, these decorators are general modifications that are applied permanently
    to different functions. In this situation, Python supports a special syntax to
    apply the decorator at the time the function is defined. We've already seen this
    syntax in a few places; now, let's understand how it works.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些装饰器是对不同函数进行永久性修改的一般修改。在这种情况下，Python 支持一种特殊语法，在定义函数时应用装饰器。我们已经在几个地方看到了这种语法；现在，让我们了解它是如何工作的。
- en: 'Instead of applying the decorator function after the method definition, we
    can use the `@decorator` syntax to do it all at once:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在方法定义之后应用装饰器函数，而不是使用`@decorator`语法一次性完成：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The primary benefit of this syntax is that we can easily see that the function
    has been decorated whenever we read the function definition. If the decorator
    is applied later, someone reading the code may miss that the function has been
    altered at all. Answering a question like, *Why is my program logging function
    calls to the console?* can become much more difficult! However, the syntax can
    only be applied to functions we define, since we don't have access to the source
    code of other modules. If we need to decorate functions that are part of somebody
    else's third-party library, we have to use the earlier syntax.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法的首要好处是，当我们阅读函数定义时，可以很容易地看到函数已被装饰。如果装饰器是在之后应用的，那么阅读代码的人可能会错过函数已被修改的事实。回答像“为什么我的程序将函数调用记录到控制台？”这样的问题会变得更加困难！然而，这种语法只能应用于我们定义的函数，因为我们没有访问其他模块的源代码。如果我们需要装饰属于其他人第三方库的函数，我们必须使用早期的语法。
- en: There is more to the decorator syntax than we've seen here. We don't have room
    to cover the advanced topics here, so check the Python reference manual or other
    tutorials for more information. Decorators can be created as callable objects,
    not just functions that return functions. Classes can also be decorated; in that
    case, the decorator returns a new class instead of a new function. Finally, decorators
    can take arguments to customize them on a per-function basis.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器语法的内容比我们这里看到的要多。我们没有足够的空间来介绍高级主题，所以请查阅 Python 参考手册或其他教程以获取更多信息。装饰器可以作为可调用对象创建，而不仅仅是返回函数的函数。类也可以被装饰；在这种情况下，装饰器返回一个新的类而不是一个新的函数。最后，装饰器可以接受参数，以便根据每个函数进行自定义。
- en: The observer pattern
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The observer pattern is useful for state monitoring and event handling situations.
    This pattern allows a given object to be monitored by an unknown and dynamic group
    of *observer* objects.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式对于状态监控和事件处理情况很有用。这种模式允许一个给定的对象被一个未知且动态的观察者对象组监控。
- en: Whenever a value on the core object changes, it lets all the observer objects
    know that a change has occurred, by calling an `update()` method. Each observer
    may be responsible for different tasks whenever the core object changes; the core
    object doesn't know or care what those tasks are, and the observers don't typically
    know or care what other observers are doing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当核心对象上的任何值发生变化时，它会通过调用一个`update()`方法来通知所有观察者对象，表明已发生更改。每当核心对象发生变化时，每个观察者可能负责不同的任务；核心对象不知道或关心那些任务是什么，观察者通常也不知道或关心其他观察者在做什么。
- en: 'Here it is in UML:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 UML 中的表示：
- en: '![](img/ba0eb0db-e28f-48b0-900a-a501cb8938e0.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ba0eb0db-e28f-48b0-900a-a501cb8938e0.png)'
- en: An observer example
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者示例
- en: 'The observer pattern might be useful in a redundant backup system. We can write
    a core object that maintains certain values, and then have one or more observers
    create serialized copies of that object. These copies might be stored in a database,
    on a remote host, or in a local file, for example. Let''s implement the core object
    using properties:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式可能在冗余备份系统中很有用。我们可以编写一个维护某些值的核心对象，然后让一个或多个观察者创建该对象的序列化副本。例如，这些副本可能存储在数据库中、远程主机上或本地文件中。让我们使用属性来实现核心对象：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This object has two properties that, when set, call the `_update_observers`
    method on itself. All this method does is loop over any registered observers and
    let each know that something has changed. In this case, we call the observer object
    directly; the object will have to implement `__call__` to process the update.
    This would not be possible in many object-oriented programming languages, but
    it's a useful shortcut in Python that can help make our code more readable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象有两个属性，当设置时，会调用其自身上的`_update_observers`方法。这个方法所做的只是遍历任何已注册的观察者，并让每个观察者知道有变化发生。在这种情况下，我们直接调用观察者对象；该对象必须实现`__call__`来处理更新。这在许多面向对象编程语言中是不可能的，但在Python中这是一个有用的快捷方式，可以帮助使我们的代码更易读。
- en: 'Now let''s implement a simple observer object; this one will just print out
    some state to the console:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现一个简单的观察者对象；这个对象将只打印一些状态到控制台：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There''s nothing terribly exciting here; the observed object is set up in the
    initializer, and when the observer is called, we do *something*. We can test the
    observer in an interactive console:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别激动人心的；被观察对象是在初始化器中设置的，当观察者被调用时，我们执行*某个操作*。我们可以在交互式控制台中测试观察者：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After attaching the observer to the `Inventory` object, whenever we change
    one of the two observed properties, the observer is called and its action is invoked.
    We can even add two different observer instances:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在将观察者附加到`Inventory`对象之后，每次我们更改两个被观察属性中的任何一个时，都会调用观察者并执行其操作。我们甚至可以添加两个不同的观察者实例：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This time when we change the product, there are two sets of output, one for
    each observer. The key idea here is that we can easily add totally different types
    of observers that back up the data in a file, database, or internet application
    at the same time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这次当我们更改产品时，有两个输出集，每个观察者一个。这里的关键思想是我们可以轻松地添加完全不同类型的观察者，同时备份文件、数据库或互联网应用程序中的数据。
- en: The observer pattern detaches the code being observed from the code doing the
    observing. If we were not using this pattern, we would have had to put code in
    each of the properties to handle the different cases that might come up; logging
    to the console, updating a database or file, and so on. The code for each of these
    tasks would all be mixed in with the observed object. Maintaining it would be
    a nightmare, and adding new monitoring functionality at a later date would be
    painful.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式将正在被观察的代码与执行观察的代码分离。如果我们不使用这种模式，我们就必须在每个属性中放置代码来处理可能出现的不同情况；例如，记录到控制台、更新数据库或文件等。每个这些任务的代码都会与被观察对象混合在一起。维护它将是一场噩梦，而且在未来添加新的监控功能将会很痛苦。
- en: The strategy pattern
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式
- en: The strategy pattern is a common demonstration of abstraction in object-oriented
    programming. The pattern implements different solutions to a single problem, each
    in a different object. The client code can then choose the most appropriate implementation
    dynamically at runtime.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式是面向对象编程中抽象的常见演示。该模式实现了对单个问题的不同解决方案，每个解决方案都在不同的对象中实现。客户端代码可以在运行时动态地选择最合适的实现。
- en: 'Typically, different algorithms have different trade-offs; one might be faster
    than another, but uses a lot more memory, while a third algorithm may be most
    suitable when multiple CPUs are present or a distributed system is provided. Here
    is the strategy pattern in UML:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，不同的算法有不同的权衡；一个可能比另一个更快，但使用更多的内存，而第三个算法可能在存在多个CPU或提供了分布式系统时最为合适。以下是UML中的策略模式：
- en: '![](img/280d5e74-70d4-49a2-91f2-d083a054a7d2.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/280d5e74-70d4-49a2-91f2-d083a054a7d2.png)'
- en: The **User** code connecting to the strategy pattern simply needs to know that
    it is dealing with the **Abstraction** interface. The actual implementation chosen
    performs the same task, but in different ways; either way, the interface is identical.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到策略模式的**用户**代码只需要知道它正在处理**抽象**接口。实际选择的实现执行相同的任务，但以不同的方式；无论哪种方式，接口都是相同的。
- en: A strategy example
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式的示例
- en: The canonical example of the strategy pattern is sort routines; over the years,
    numerous algorithms have been invented for sorting a collection of objects; quick
    sort, merge sort, and heap sort are all fast sort algorithms with different features,
    each useful in its own right, depending on the size and type of inputs, how out
    of order they are, and the requirements of the system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式的典型示例是排序例程；多年来，已经发明了多种用于排序对象集合的算法；快速排序、归并排序和堆排序都是快速排序算法，具有不同的特性，每个都有其自身的用途，这取决于输入的大小和类型、它们的顺序以及系统的要求。
- en: 'If we have client code that needs to sort a collection, we could pass it to
    an object with a `sort()` method. This object may be a `QuickSorter` or `MergeSorter`
    object, but the result will be the same in either case: a sorted list. The strategy
    used to do the sorting is abstracted from the calling code, making it modular
    and replaceable.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端代码需要排序一个集合，我们可以将其传递给一个具有`sort()`方法的对象。这个对象可能是一个`QuickSorter`或`MergeSorter`对象，但无论哪种情况，结果都是相同的：一个排序后的列表。用于排序的策略从调用代码中抽象出来，使其模块化和可替换。
- en: Of course, in Python, we typically just call the `sorted` function or `list.sort`
    method and trust that it will do the sorting in a near-optimal fashion. So, we
    really need to look at a better example.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在Python中，我们通常只是调用`sorted`函数或`list.sort`方法，并相信它将以接近最优的方式完成排序。因此，我们实际上需要查看一个更好的例子。
- en: Let's consider a desktop wallpaper manager. When an image is displayed on a
    desktop background, it can be adjusted to the screen size in different ways. For
    example, assuming the image is smaller than the screen, it can be tiled across
    the screen, centered on it, or scaled to fit. There are other, more complicated,
    strategies that can be used as well, such as scaling to the maximum height or
    width, combining it with a solid, semi-transparent, or gradient background color,
    or other manipulations. While we may want to add these strategies later, let's
    start with the basic ones.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个桌面壁纸管理器。当一张图片显示在桌面背景上时，它可以以不同的方式调整到屏幕大小。例如，假设图片比屏幕小，它可以平铺在整个屏幕上，居中显示，或者缩放到适合。还可以使用其他更复杂的策略，例如缩放到最大高度或宽度，与纯色、半透明或渐变背景颜色结合，或其他操作。虽然我们可能希望在以后添加这些策略，但让我们从基本的策略开始。
- en: 'Our strategy objects take two inputs; the image to be displayed, and a tuple
    of the width and height of the screen. They each return a new image the size of
    the screen, with the image manipulated to fit according to the given strategy.
    You''ll need to install the `pillow` module with `pip3 install pillow` for this
    example to work:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的战略对象接受两个输入；要显示的图片和屏幕宽度和高度的元组。它们各自返回一个新图像，其大小为屏幕大小，图片根据给定的策略进行调整。您需要使用`pip3
    install pillow`安装`pillow`模块才能使此示例正常工作：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we have three strategies, each using `PIL` to perform their task. Individual
    strategies have a `make_background` method that accepts the same set of parameters.
    Once selected, the appropriate strategy can be called to create a correctly sized
    version of the desktop image. `TiledStrategy` loops over the number of input images
    that would fit in the width and height of the image and copies it into each location,
    repeatedly. `CenteredStrategy` figures out how much space needs to be left on
    the four edges of the image to center it. `ScaledStrategy` forces the image to
    the output size (ignoring aspect ratio).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有三种策略，每种策略都使用`PIL`来执行其任务。每个策略都有一个`make_background`方法，它接受相同的参数集。一旦选择，适当的策略就可以被调用以创建桌面图像的正确尺寸版本。`TiledStrategy`遍历可以放入图片宽度和高度中的输入图片数量，并将其复制到每个位置，重复进行。`CenteredStrategy`计算出需要在图片的四边留下多少空间以使其居中。`ScaledStrategy`强制将图片调整到输出大小（忽略宽高比）。
- en: Consider how switching between these options would be implemented without the
    strategy pattern. We'd need to put all the code inside one great big method and
    use an awkward `if` statement to select the expected one. Every time we wanted
    to add a new strategy, we'd have to make the method even more ungainly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在没有策略模式的情况下如何实现这些选项之间的切换。我们需要将所有代码放入一个巨大的方法中，并使用一个尴尬的`if`语句来选择预期的选项。每次我们想要添加一个新的策略时，我们都需要使该方法变得更加笨拙。
- en: Strategy in Python
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的策略
- en: The preceding canonical implementation of the strategy pattern, while very common
    in most object-oriented libraries, is rarely seen in Python programming.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 之前策略模式的规范实现，虽然在大多数面向对象的库中非常常见，但在Python编程中却很少见到。
- en: These classes each represent objects that do nothing but provide a single function.
    We could just as easily call that function `__call__` and make the object callable
    directly. Since there is no other data associated with the object, we need do
    no more than create a set of top-level functions and pass them around as our strategies
    instead.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类各自代表只提供单个函数的对象。我们同样可以将其函数命名为`__call__`并直接使对象可调用。由于与对象没有其他数据关联，我们只需要创建一组顶级函数并将它们作为我们的策略传递。
- en: Opponents of design pattern philosophy will therefore say, *because Python has
    first-class functions, the strategy pattern is unnecessary*. In truth, Python's
    first-class functions allow us to implement the strategy pattern in a more straightforward
    way. Knowing the pattern exists can still help us choose a correct design for
    our program, but implement it using a more readable syntax. The strategy pattern,
    or a top-level function implementation of it, should be used when we need to allow
    client code or the end user to select from multiple implementations of the same
    interface.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，设计模式哲学的反对者会说，*由于Python有第一类函数，策略模式是不必要的*。实际上，Python的第一类函数允许我们以更直接的方式实现策略模式。了解该模式的存在仍然可以帮助我们为我们的程序选择正确的设计，但使用更易读的语法来实现。当我们需要允许客户端代码或最终用户从同一接口的多个实现中选择时，应使用策略模式或其顶级函数实现。
- en: The state pattern
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态模式
- en: 'The state pattern is structurally similar to the strategy pattern, but its
    intent and purpose are very different. The goal of the state pattern is to represent
    state-transition systems: systems where it is obvious that an object can be in
    a specific state, and that certain activities may drive it to a different state.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式在结构上与策略模式相似，但其意图和目的却大相径庭。状态模式的目标是表示状态转换系统：在这些系统中，一个对象可以处于特定的状态，并且某些活动可能会将其驱动到不同的状态。
- en: To make this work, we need a manager, or context class that provides an interface
    for switching states. Internally, this class contains a pointer to the current
    state. Each state knows what other states it is allowed to be in and will transition
    to those states depending on actions invoked upon it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这成为可能，我们需要一个管理者，或者上下文类，它提供了一个切换状态的接口。内部，这个类包含了一个指向当前状态的指针。每个状态都知道它可以处于哪些其他状态，并且将根据对其调用的动作转换到那些状态。
- en: 'So, we have two types of classes: the context class and multiple state classes.
    The context class maintains the current state, and forwards actions to the state
    classes. The state classes are typically hidden from any other objects that are
    calling the context; it acts like a black box that happens to perform state management
    internally. Here''s how it looks in UML:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有两种类型的类：上下文类和多个状态类。上下文类维护当前状态，并将动作转发到状态类。状态类通常对调用上下文的其他对象是隐藏的；它像一个内部执行状态管理的黑盒。以下是它在UML中的样子：
- en: '![](img/381f487e-aad8-4b2b-95a1-4c13ddf6f461.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/381f487e-aad8-4b2b-95a1-4c13ddf6f461.png)'
- en: A state example
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态示例
- en: 'To illustrate the state pattern, let''s build an XML parsing tool. The context
    class will be the parser itself. It will take a string as input and place the
    tool in an initial parsing state. The various parsing states will eat characters,
    looking for a specific value, and when that value is found, change to a different
    state. The goal is to create a tree of node objects for each tag and its contents.
    To keep things manageable, we''ll parse only a subset of XML – tags and tag names.
    We won''t be able to handle attributes on tags. It will parse text content of
    tags, but won''t attempt to parse *mixed* content, which has tags inside of text.
    Here is an example *simplified XML* file that we''ll be able to parse:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明状态模式，让我们构建一个XML解析工具。上下文类将是解析器本身。它将接受一个字符串作为输入，并将工具置于初始解析状态。各种解析状态将消费字符，寻找特定的值，当找到该值时，将转换到不同的状态。目标是为每个标签及其内容创建一个节点对象的树。为了保持可管理性，我们将只解析XML的子集——标签和标签名。我们无法处理标签上的属性。它将解析标签的文本内容，但不会尝试解析*混合*内容，其中文本内有标签。以下是我们将能够解析的简化XML文件示例：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Before we look at the states and the parser, let''s consider the output of
    this program. We know we want a tree of `Node` objects, but what does a `Node`
    look like? It will clearly need to know the name of the tag it is parsing, and
    since it''s a tree, it should probably maintain a pointer to the parent node and
    a list of the node''s children in order. Some nodes have a text value, but not
    all of them. Let''s look at this `Node` class first:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看状态和解析器之前，让我们考虑这个程序的输出。我们知道我们想要一个`Node`对象的树，但`Node`看起来是什么样子？它显然需要知道它正在解析的标签的名称，并且由于它是一个树，它可能需要维护一个指向父节点的指针以及节点子列表。一些节点有文本值，但并非所有节点都有。让我们首先看看这个`Node`类：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This class sets default attribute values upon initialization. The `__str__`
    method is supplied to help visualize the tree structure when we're finished.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类在初始化时设置默认属性值。`__str__`方法提供帮助，以便我们在完成时可视化树结构。
- en: Now, looking at the example document, we need to consider what states our parser
    can be in. Clearly, it's going to start in a state where no nodes have yet been
    processed. We'll need a state for processing opening tags and closing tags. And
    when we're inside a tag with text contents, we'll have to process that as a separate
    state, too.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，查看示例文档，我们需要考虑我们的解析器可能处于哪些状态。显然，它将从一个还没有处理任何节点的状态开始。我们需要一个状态来处理开标签和闭标签。当我们处于包含文本内容的标签内时，我们还需要将其作为一个单独的状态来处理。
- en: 'Switching states can be tricky; how do we know if the next node is an opening
    tag, a closing tag, or a text node? We could put a little logic in each state
    to work this out, but it actually makes more sense to create a new state whose
    sole purpose is figuring out which state we''ll be switching to next. If we call
    this transition state **ChildNode**, we end up with the following states:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 切换状态可能很棘手；我们如何知道下一个节点是开标签、闭标签还是文本节点？我们可以在每个状态中放入一点逻辑来解决这个问题，但实际上创建一个新的状态，其唯一目的是确定我们将切换到哪个状态，更有意义。如果我们称这个转换状态为
    **ChildNode**，我们最终会得到以下状态：
- en: '`FirstTag`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FirstTag`'
- en: '`ChildNode`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChildNode`'
- en: '`OpenTag`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenTag`'
- en: '`CloseTag`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CloseTag`'
- en: '`Text`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Text`'
- en: 'The **FirstTag** state will switch to **ChildNode**, which is responsible for
    deciding which of the other three states to switch to; when those states are finished,
    they''ll switch back to **ChildNode**. The following state-transition diagram
    shows the available state changes:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**FirstTag** 状态将切换到 **ChildNode**，它负责决定切换到其他三个状态中的哪一个；当这些状态完成后，它们将切换回 **ChildNode**。以下状态转换图显示了可用的状态变化：'
- en: '![](img/98701341-1821-4aaa-b23a-457371c26270.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/98701341-1821-4aaa-b23a-457371c26270.png)'
- en: 'The states are responsible for taking *what''s left of the string*, processing
    as much of it as they know what to do with, and then telling the parser to take
    care of the rest of it. Let''s construct the `Parser` class first:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 状态负责处理 *字符串的剩余部分*，处理它们知道如何处理的部分，然后告诉解析器处理其余部分。让我们首先构建 `Parser` 类：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The initializer sets up a few variables on the class that the individual states
    will access. The `parse_string` instance variable is the text that we are trying
    to parse. The `root` node is the *top* node in the XML structure. The `current_node`
    instance variable is the one that we are currently adding children to.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器在类上设置了一些变量，这些变量将被各个状态访问。`parse_string` 实例变量是我们试图解析的文本。`root` 节点是 XML 结构中的
    *顶层* 节点。`current_node` 实例变量是我们目前正在添加子节点的那个。
- en: The important feature of this parser is the `process` method, which accepts
    the remaining string, and passes it off to the current state. The parser (the
    `self` argument) is also passed into the state's process method so that the state
    can manipulate it. The state is expected to return the remainder of the unparsed
    string when it is finished processing. The parser then recursively calls the `process`
    method on this remaining string to construct the rest of the tree.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此解析器的重要特性是 `process` 方法，它接受剩余的字符串，并将其传递给当前状态。解析器（`self` 参数）也被传递到状态的方法中，以便状态可以对其进行操作。状态在完成处理后应返回未解析字符串的剩余部分。然后解析器递归地调用此剩余字符串的
    `process` 方法来构建树的其余部分。
- en: 'Now let''s have a look at the `FirstTag` state:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `FirstTag` 状态：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This state finds the index (the `i_` stands for index) of the opening and closing
    angle brackets on the first tag. You may think this state is unnecessary, since
    XML requires that there be no text before an opening tag. However, there may be
    whitespace that needs to be consumed; this is why we search for the opening angle
    bracket instead of assuming it is the first character in the document.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此状态找到第一个标签上开和闭尖括号的位置（`i_` 代表索引）。你可能认为这个状态是不必要的，因为 XML 要求在开标签之前不能有文本。然而，可能需要消耗空白字符；这就是为什么我们搜索开尖括号而不是假设它是文档中的第一个字符。
- en: Note that this code is assuming a valid input file. A proper implementation
    would be rigorously testing for invalid input, and would attempt to recover or
    display an extremely descriptive error message.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此代码假设了一个有效的输入文件。一个合适的实现将严格测试无效输入，并尝试恢复或显示一个极其详细的错误消息。
- en: The method extracts the name of the tag and assigns it to the root node of the
    parser. It also assigns it to `current_node`, since that's the one we'll be adding
    children to next.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法提取标签的名称并将其分配给解析器的根节点。它还将其分配给 `current_node`，因为我们将在下一个要添加子节点的地方使用它。
- en: 'Then comes the important part: the method changes the current state on the
    parser object to a `ChildNode` state. It then returns the remainder of the string
    (after the opening tag) to allow it to be processed.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是重要部分：该方法将解析器对象上的当前状态更改为`ChildNode`状态。然后它返回字符串的其余部分（开标签之后），以便它可以被处理。
- en: 'The `ChildNode` state, which seems quite complicated, turns out to require
    nothing but a simple conditional:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChildNode`状态看起来相当复杂，但实际上只需要一个简单的条件：'
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `strip()` call removes whitespace from the string. Then the parser determines
    if the next item is an opening or closing tag, or a string of text. Depending
    on which possibility occurs, it sets the parser to a particular state, and then
    tells it to parse the remainder of the string.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`strip()`调用从字符串中删除空白。然后解析器确定下一个项目是一个开标签、闭标签还是一串文本。根据发生的情况，它将解析器设置为特定的状态，然后告诉它解析字符串的其余部分。'
- en: 'The `OpenTag` state is similar to the `FirstTag` state, except that it adds
    the newly created node to the previous `current_node` object''s `children` and
    sets it as the new `current_node`. It places the processor back in the `ChildNode`
    state before continuing:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenTag`状态类似于`FirstTag`状态，除了它将新创建的节点添加到先前的`current_node`对象的`children`中，并将其设置为新的`current_node`。在继续之前，它将处理器放回`ChildNode`状态：'
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `CloseTag` state basically does the opposite; it sets the parser''s `current_node`
    back to the parent node so any further children in the outside tag can be added
    to it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`CloseTag`状态基本上是相反的；它将解析器的`current_node`设置回父节点，以便任何进一步的外部标签中的子节点都可以添加到它：'
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The two `assert` statements help ensure that the parse strings are consistent.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`assert`语句有助于确保解析字符串的一致性。
- en: 'Finally, the `TextNode` state very simply extracts the text before the next
    close tag and sets it as a value on the current node:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`TextNode`状态非常简单地提取下一个闭合标签之前的文本，并将其设置为当前节点的值：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we just have to set up the initial state on the parser object we created.
    The initial state is a `FirstTag` object, so just add the following to the `__init__`
    method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需设置我们创建的解析器对象的初始状态。初始状态是一个`FirstTag`对象，所以只需将以下内容添加到`__init__`方法中：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To test the class, let''s add a main script that opens an file from the command
    line, parses it, and prints the nodes:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个类，让我们添加一个主脚本，它从命令行打开一个文件，解析它，并打印出节点：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code opens the file, loads the contents, and parses the result. Then it
    prints each node and its children in order. The `__str__` method we originally
    added on the `node` class takes care of formatting the nodes for printing. If
    we run the script on the earlier example, it outputs the tree as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码打开文件，加载内容，并解析结果。然后它按顺序打印每个节点及其子节点。我们最初在`node`类中添加的`__str__`方法负责格式化节点以供打印。如果我们运行此脚本在先前的示例上，它将按以下方式输出树：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Comparing this to the original simplified XML document tells us the parser is
    working.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与原始简化的XML文档进行比较，告诉我们解析器正在工作。
- en: State versus strategy
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态与策略
- en: The state pattern looks very similar to the strategy pattern; indeed, the UML
    diagrams for the two are identical. The implementation, too, is identical. We
    could even have written our states as first-class functions instead of wrapping
    them in objects, as was suggested for strategy.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式看起来与策略模式非常相似；实际上，这两个的UML图是相同的。实现也是相同的。我们甚至可以将我们的状态作为一等函数编写，而不是像策略那样将它们包装在对象中。
- en: While the two patterns have identical structures, they solve completely different
    problems. The strategy pattern is used to choose an algorithm at runtime; generally,
    only one of those algorithms is going to be chosen for a particular use case.
    The state pattern, on the other hand, is designed to allow switching between different
    states dynamically, as some process evolves. In code, the primary difference is
    that the strategy pattern is not typically aware of other strategy objects. In
    the state pattern, either the state or the context needs to know which other states
    that it can switch to.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个模式具有相同的结构，但它们解决的问题完全不同。策略模式用于在运行时选择一个算法；通常，对于特定的用例，只会选择这些算法中的一个。另一方面，状态模式旨在允许在某个过程演变时动态地在不同状态之间切换。在代码中，主要区别在于策略模式通常不会意识到其他策略对象。在状态模式中，状态或上下文需要知道它可以切换到哪些其他状态。
- en: State transition as coroutines
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态转换作为协程
- en: The state pattern is the canonical object-oriented solution to state-transition
    problems. However, you can get a similar effect by constructing your objects as
    coroutines. Remember the regular expression log file parser we built in [Chapter
    9](0abbcae0-eb3f-4237-adda-32765e1cce32.xhtml), *The Iterator Pattern*? That was
    a state-transition problem in disguise. The main difference between that implementation
    and one that defines all the objects (or functions) used in the state pattern
    is that the coroutine solution allows us to encode more of the boilerplate in
    language constructs. There are two implementations, but neither one is inherently
    better than the other. The state pattern is actually the only place I would consider
    using coroutines outside of `asyncio`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式是面向对象解决状态转换问题的典范。然而，通过将对象构建为协程，你也可以得到类似的效果。还记得我们在[第9章](0abbcae0-eb3f-4237-adda-32765e1cce32.xhtml)，《迭代器模式》中构建的正则表达式日志文件解析器吗？那其实是一个隐藏的状态转换问题。与定义状态模式中所有对象（或函数）的实现相比，协程解决方案允许我们在语言构造中编码更多的样板代码。有两种实现方式，但它们并没有本质上的优劣之分。实际上，状态模式是除了`asyncio`之外，我会考虑使用协程的唯一地方。
- en: The singleton pattern
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式
- en: The singleton pattern is one of the most controversial patterns; many have accused
    it of being an *anti-pattern*, a pattern that should be avoided, not promoted.
    In Python, if someone is using the singleton pattern, they're almost certainly
    doing something wrong, probably because they're coming from a more restrictive
    programming language.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式是最具争议的模式之一；许多人指责它是一种*反模式*，一种应该避免而不是推广的模式。在Python中，如果有人使用单例模式，他们几乎肯定是在做错事，可能是因为他们来自更受限制的编程语言。
- en: So, why discuss it at all? Singleton is one of the most famous of all design
    patterns. It is useful in overly object-oriented languages, and is a vital part
    of traditional object-oriented programming. More relevantly, the idea behind singleton
    is useful, even if we implement the concept in a totally different way in Python.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么要讨论它呢？单例是所有设计模式中最著名的之一。在过度面向对象的语言中很有用，并且是传统面向对象编程的重要组成部分。更有相关性的是，单例背后的思想是有用的，即使我们在Python中以完全不同的方式实现这个概念。
- en: The basic idea behind the singleton pattern is to allow exactly one instance
    of a certain object to exist. Typically, this object is a sort of manager class
    like those we discussed in [Chapter 5](42cd7e16-073b-485c-8073-554ac64d992f.xhtml),
    *When to Use Object-Oriented Programming*. Such objects often need to be referenced
    by a wide variety of other objects, and passing references to the manager object
    around to the methods and constructors that need them can make code hard to read.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式背后的基本思想是允许恰好存在一个特定对象的实例。通常，这个对象是我们讨论过的某种管理类，如我们在[第5章](42cd7e16-073b-485c-8073-554ac64d992f.xhtml)，《何时使用面向对象编程》中讨论过的。这样的对象通常需要被各种其他对象引用，将管理对象的引用传递给需要它们的函数和构造函数可能会使代码难以阅读。
- en: 'Instead, when a singleton is used, the separate objects request the single
    instance of the manager object from the class, so a reference to it need not to
    be passed around. The UML diagram doesn''t fully describe it, but here it is for
    completeness:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当使用单例时，单独的对象会从类中请求管理对象的单个实例，因此不需要传递对该实例的引用。UML图并没有完全描述它，但为了完整性，这里提供了：
- en: '![](img/ce1b7c4a-1f9e-4c9f-8290-86b645a94096.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ce1b7c4a-1f9e-4c9f-8290-86b645a94096.png)'
- en: In most programming environments, singletons are enforced by making the constructor
    private (so no one can create additional instances of it), and then providing
    a static method to retrieve the single instance. This method creates a new instance
    the first time it is called, and then returns that same instance for all subsequent
    calls.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程环境中，单例是通过使构造函数私有（因此没有人可以创建它的额外实例）来强制执行的，然后提供一个静态方法来检索单个实例。该方法在第一次被调用时创建一个新的实例，然后对所有后续调用返回相同的实例。
- en: Singleton implementation
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例实现
- en: 'Python doesn''t have private constructors, but for this purpose, we can use
    the `__new__` class method to ensure that only one instance is ever created:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有私有构造函数，但为了这个目的，我们可以使用`__new__`类方法来确保始终只创建一个实例：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When `__new__` is called, it normally constructs a new instance of that class.
    When we override it, we first check whether our singleton instance has been created;
    if not, we create it using a `super` call. Thus, whenever we call the constructor
    on `OneOnly`, we always get the exact same instance:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `__new__` 时，它通常构造该类的新实例。当我们覆盖它时，我们首先检查我们的单例实例是否已经创建；如果没有，我们使用 `super` 调用来创建它。因此，每次我们在
    `OneOnly` 上调用构造函数时，我们总是得到完全相同的实例：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The two objects are equal and located at the same address; thus, they are the
    same object. This particular implementation isn't very transparent, since it's
    not obvious that a singleton object has been created. Whenever we call a constructor,
    we expect a new instance of that object; in this case, that contract is violated.
    Perhaps, good docstrings on the class could alleviate this problem if we really
    think we need a singleton.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个对象相等且位于相同的地址；因此，它们是同一个对象。这种特定的实现并不非常透明，因为它并不明显表明已经创建了一个单例对象。每次我们调用构造函数时，我们都期望得到该对象的新实例；在这种情况下，这个合同被违反了。也许，如果我们真的认为我们需要单例，良好的类文档字符串可以缓解这个问题。
- en: But we don't need it. Python coders frown on forcing the users of their code
    into a specific mindset. We may think only one instance of a class will ever be
    required, but other programmers may have different ideas. Singletons can interfere
    with distributed computing, parallel programming, and automated testing, for example.
    In all those cases, it can be very useful to have multiple or alternative instances
    of a specific object, even though a *normal* operation may never require one.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们并不需要它。Python 程序员不喜欢强迫他们的代码用户形成特定的思维模式。我们可能认为一个类的实例将永远只需要一个，但其他程序员可能有不同的想法。单例可能会干扰分布式计算、并行编程和自动化测试，例如。在这些所有情况下，拥有多个或替代的特定对象实例可能非常有用，即使正常操作可能永远不需要一个。
- en: Module variables can mimic singletons
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块变量可以模拟单例
- en: Normally, in Python, the singleton pattern can be sufficiently mimicked using
    module-level variables. It's not as *safe* as a singleton in that people could
    reassign those variables at any time, but as with the private variables we discussed
    in [Chapter 2](0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml), *Objects in Python*,
    this is acceptable in Python. If someone has a valid reason to change those variables,
    why should we stop them? It also doesn't stop people from instantiating multiple
    instances of the object, but again, if they have a valid reason to do so, why
    interfere?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在 Python 中，单例模式可以通过模块级变量足够地模拟。它并不像单例那样安全，因为人们可以在任何时候重新分配这些变量，但就像我们在[第2章](0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml)“Python
    中的对象”中讨论的私有变量一样，这在 Python 中是可以接受的。如果有人有合理的理由改变这些变量，我们为什么要阻止他们？它也不会阻止人们实例化该对象的多实例，但同样，如果他们有合理的理由这样做，我们为什么要干涉？
- en: Ideally, we should give them a mechanism to get access to the *default singleton* value,
    while also allowing them to create other instances if they need them. While technically
    not a singleton at all, it provides the most Pythonic mechanism for singleton-like
    behavior.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们应该提供一个机制让他们能够访问默认的单例值，同时允许他们在需要时创建其他实例。虽然技术上根本不是单例，但它提供了最符合 Python 风格的单例类似行为的机制。
- en: 'To use module-level variables instead of a singleton, we instantiate an instance
    of the class after we''ve defined it. We can improve our state pattern to use
    singletons. Instead of creating a new object every time we change states, we can
    create a module-level variable that is always accessible:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用模块级变量而不是单例，我们在定义类之后实例化类的实例。我们可以改进我们的状态模式以使用单例。不是每次改变状态时都创建一个新的对象，我们可以创建一个始终可访问的模块级变量：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: All we've done is create instances of the various state classes that can be
    reused. Notice how we can access these module variables inside the classes, even
    before the variables have been defined? This is because the code inside the classes
    is not executed until the method is called, and by this point, the entire module
    will have been defined.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的一切只是创建了各种状态类的实例，这些实例可以重复使用。注意我们如何在类内部访问这些模块变量，甚至在变量定义之前？这是因为类内部的代码只有在方法被调用时才会执行，而到那时，整个模块已经定义完毕。
- en: The difference in this example is that instead of wasting memory creating a
    bunch of new instances that must be garbage collected, we are reusing a single
    state object for each state. Even if multiple parsers are running at once, only
    these state classes need to be used.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，与创建大量新实例以浪费内存并必须进行垃圾回收不同，我们正在为每个状态重用单个状态对象。即使同时运行多个解析器，也只需要使用这些状态类。
- en: When we originally created the state-based parser, you may have wondered why
    we didn't pass the parser object to `__init__` on each individual state, instead
    of passing it into the `process` method as we did. The state could then have been
    referenced as `self.parser`. This is a perfectly valid implementation of the state
    pattern, but it would not have allowed leveraging the singleton pattern. If the
    state objects maintain a reference to the parser, then they cannot be used simultaneously
    to reference other parsers.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最初创建基于状态的分析器时，你可能想知道为什么我们没有将分析器对象传递给每个单独状态的`__init__`方法，而是像我们做的那样将其传递到`process`方法中。状态可以引用为`self.parser`。这是一个完全有效的状态模式实现，但它不会允许利用单例模式。如果状态对象维护对分析器的引用，那么它们不能同时用来引用其他分析器。
- en: Remember, these are two different patterns with different purposes; the fact
    that singleton's purpose may be useful for implementing the state pattern does
    not mean the two patterns are related.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这些是两种不同的模式，具有不同的目的；单例模式的目的可能对实现状态模式有用，并不意味着这两个模式是相关的。
- en: The template pattern
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板模式
- en: 'The template pattern is useful for removing duplicate code; it''s intended
    to support the **Don''t Repeat Yourself** principle we discussed in [Chapter 5](42cd7e16-073b-485c-8073-554ac64d992f.xhtml),
    *When to Use Object-Oriented Programming*. It is designed for situations where
    we have several different tasks to accomplish that have some, but not all, steps
    in common. The common steps are implemented in a base class, and the distinct
    steps are overridden in subclasses to provide custom behavior. In some ways, it''s
    like a generalized strategy pattern, except similar sections of the algorithms
    are shared using a base class. Here it is in the UML format:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 模板模式对于删除重复代码很有用；它的目的是支持我们在第5章中讨论的**不要重复自己**原则，即*何时使用面向对象编程*。它设计用于我们有几个不同的任务要完成，这些任务有一些但不是所有步骤是共同的。共同的步骤在基类中实现，而不同的步骤在子类中重写以提供自定义行为。在某种程度上，它就像一个通用策略模式，除了使用基类共享算法的相似部分。以下是UML格式的示例：
- en: '![](img/ec4347a5-997f-43a6-a91a-ca31741a38c6.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ec4347a5-997f-43a6-a91a-ca31741a38c6.png)'
- en: A template example
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个模板示例
- en: Let's create a car sales reporter as an example. We can store records of sales
    in an SQLite database table. SQLite is a simple file-based database engine that
    allows us to store records using SQL syntax. Python includes SQLite in its standard
    library, so there are no extra modules required.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以汽车销售报告员为例。我们可以在SQLite数据库表中存储销售记录。SQLite是一个简单的基于文件的数据库引擎，它允许我们使用SQL语法存储记录。Python将其包含在其标准库中，因此不需要额外的模块。
- en: 'We have two common tasks we need to perform:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个常见的任务需要执行：
- en: Select all sales of new vehicles and output them to the screen in a comma-delimited
    format
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择所有新车的销售并按逗号分隔的格式输出到屏幕
- en: Output a comma-delimited list of all salespeople with their gross sales and
    save it to a file that can be imported to a spreadsheet
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出所有销售人员的逗号分隔列表，包括他们的毛销售额，并将其保存到可以导入电子表格的文件中
- en: 'These seem like quite different tasks, but they have some common features.
    In both cases, we need to perform the following steps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务看起来相当不同，但它们有一些共同特征。在两种情况下，我们需要执行以下步骤：
- en: Connect to the database.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到数据库。
- en: Construct a query for new vehicles or gross sales.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建针对新车或毛销售额的查询。
- en: Issue the query.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行查询。
- en: Format the results into a comma-delimited string.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果格式化为逗号分隔的字符串。
- en: Output the data to a file or email.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据输出到文件或电子邮件。
- en: The query construction and output steps are different for the two tasks, but
    the remaining steps are identical. We can use the template pattern to put the
    common steps in a base class, and the varying steps in two subclasses.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个任务，查询构建和输出步骤不同，但剩余步骤是相同的。我们可以使用模板模式将共同步骤放在基类中，将不同的步骤放在两个子类中。
- en: 'Before we start, let''s create a database and put some sample data in it, using
    a few lines of SQL:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们创建一个数据库，并使用几行SQL语句在其中放入一些样本数据：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Hopefully, you can see what's going on here even if you don't know SQL; we've
    created a table to hold the data, and used six `insert` statements to add sales
    records. The data is stored in a file named `sales.db`. Now we have a sample we
    can work with in developing our template pattern.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 希望即使你不了解 SQL，你也能看懂这里的情况；我们已经创建了一个表来存储数据，并使用了六个 `insert` 语句来添加销售记录。数据存储在一个名为
    `sales.db` 的文件中。现在我们有一个样本，可以用来开发我们的模板模式。
- en: 'Since we''ve already outlined the steps that the template has to perform, we
    can start by defining the base class that contains the steps. Each step gets its
    own method (to make it easy to selectively override any one step), and we have
    one more managerial method that calls the steps in turn. Without any method content,
    here''s how it might look:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经概述了模板必须执行的步骤，我们可以从定义包含这些步骤的基类开始。每个步骤都有自己的方法（以便可以单独覆盖任何步骤），我们还有一个管理方法，它会依次调用这些步骤。在没有方法内容的情况下，它可能看起来是这样的：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `process_format` method is the primary method to be called by an outside
    client. It ensures each step is executed in order, but it does not care whether
    that step is implemented in this class or in a subclass. For our examples, we
    know that three methods are going to be identical between our two classes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_format` 方法是外部客户端需要调用的主要方法。它确保每个步骤按顺序执行，但并不关心该步骤是在这个类中实现还是在子类中实现。在我们的示例中，我们知道两个类之间有三个方法将是相同的：'
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To help with implementing subclasses, the two methods that are not specified
    raise `NotImplementedError`. This is a common way to specify abstract interfaces
    in Python when abstract base classes seem too heavyweight. The methods could have
    empty implementations (with `pass`), or could be fully unspecified. Raising `NotImplementedError`,
    however, helps the programmer understand that the class is meant to be subclassed
    and these methods overridden. Empty methods or methods that do not exist are harder
    to identify as needing to be implemented and to debug if we forget to implement
    them.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助实现子类，未指定的两个方法会引发 `NotImplementedError`。在 Python 中，当抽象基类显得过于笨重时，这是一种常见的指定抽象接口的方式。这些方法可以有空的实现（使用
    `pass`），或者可以完全未指定。然而，引发 `NotImplementedError` 帮助程序员理解这个类是打算被子类化并且这些方法需要被覆盖。空方法或不存在的方法更难以识别为需要实现，并且如果忘记实现它们，调试起来也更困难。
- en: Now we have a template class that takes care of the boring details, but is flexible
    enough to allow the execution and formatting of a wide variety of queries. The
    best part is, if we ever want to change our database engine from SQLite to another
    database engine (such as `py-postgresql`), we only have to do it here, in this
    template class, and we don't have to touch the two (or two hundred) subclasses
    we might have written.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个模板类，它处理了无聊的细节，但足够灵活，可以允许执行和格式化各种查询。最好的部分是，如果我们想将数据库引擎从 SQLite 更改为另一个数据库引擎（例如
    `py-postgresql`），我们只需要在这里，在这个模板类中做，而不必触及我们可能编写的两个（或两百个）子类。
- en: 'Let''s have a look at the concrete classes now:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看具体的类：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'These two classes are actually pretty short, considering what they''re doing:
    connecting to a database, executing a query, formatting the results, and outputting
    them. The superclass takes care of the repetitive work, but lets us easily specify
    those steps that vary between tasks. Further, we can also easily change steps
    that are provided in the base class. For example, if we wanted to output something
    other than a comma-delimited string (for example: an HTML report to be uploaded
    to a website), we can still override `format_results`.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到它们所做的事情，这两个类实际上相当短：连接到数据库、执行查询、格式化结果并输出它们。超类负责重复性工作，但让我们可以轻松地指定任务之间不同的步骤。此外，我们还可以轻松地更改基类中提供的步骤。例如，如果我们想输出除了逗号分隔的字符串之外的内容（例如：上传到网站的
    HTML 报告），我们仍然可以覆盖 `format_results`。
- en: Exercises
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: While writing the examples for this chapter, I discovered that it can be very
    difficult, and extremely educational, to come up with good examples where specific
    design patterns should be used. Instead of going over current or old projects
    to see where you can apply these patterns, as I've suggested in previous chapters,
    think about the patterns and different situations where they might come up. Try
    to think outside your own experiences. If your current projects are in the banking
    business, consider how you'd apply these design patterns in a retail or point-of-sale
    application. If you normally write web applications, think about using design
    patterns while writing a compiler.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本章的示例时，我发现提出应该使用特定设计模式的好例子可能非常困难，但同时也极具教育意义。与其像前几章建议的那样，查看当前或旧项目以了解可以应用这些模式的地方，不如考虑这些模式和可能出现的不同情况。尝试跳出自己的经验。如果你的当前项目在银行业务，考虑如何将这些设计模式应用于零售或销售点应用。如果你通常编写Web应用，考虑在编写编译器时使用设计模式。
- en: Look at the decorator pattern and come up with some good examples of when to
    apply it. Focus on the pattern itself, not the Python syntax we discussed. It's
    a bit more general than the actual pattern. The special syntax for decorators
    is, however, something you may want to look for places to apply in existing projects
    too.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 看看装饰器模式，并想出一些应用它的好例子。专注于模式本身，而不是我们讨论的Python语法。它比实际的模式更通用。然而，装饰器的特殊语法是你在现有项目中可能想要寻找应用的地方。
- en: What are some good areas to use the observer pattern? Why? Think about not only
    how you'd apply the pattern, but how you would implement the same task without
    using observer? What do you gain, or lose, by choosing to use it?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有哪些好的领域可以使用观察者模式？为什么？不仅要考虑如何应用这个模式，还要考虑在不使用观察者的情况下如何实现同样的任务。通过选择使用它，你得到了什么，失去了什么？
- en: Consider the difference between the strategy and state patterns. Implementation-wise,
    they look very similar, yet they have different purposes. Can you think of cases
    where the patterns could be interchanged? Would it be reasonable to redesign a
    state-based system to use strategy instead, or vice versa? How different would
    the design actually be?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑策略模式和状态模式之间的区别。在实现上，它们看起来非常相似，但它们有不同的目的。你能想到可以互换使用这些模式的情况吗？将基于状态的系统重新设计为使用策略，或者相反，是否合理？实际的设计会有多大的不同？
- en: The template pattern is such an obvious application of inheritance to reduce
    duplicate code that you may have used it before, without knowing its name. Try
    to think of at least half a dozen different scenarios where it would be useful.
    If you can do this, you'll be finding places for it in your daily coding all the
    time.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 模板模式是将继承应用于减少重复代码的一个如此明显的例子，你可能已经使用过它，却不知道它的名字。试着想出至少六种不同的场景，在这些场景中它会有所帮助。如果你能这样做，你将在日常编码中不断找到它的应用。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter discussed several common design patterns in detail, with examples,
    UML diagrams, and a discussion of the differences between Python and statically
    typed object-oriented languages. The decorator pattern is often implemented using
    Python's more generic decorator syntax. The observer pattern is a useful way to
    decouple events from actions taken on those events. The strategy pattern allows
    different algorithms to be chosen to accomplish the same task. The state pattern
    looks similar, but is used instead to represent systems can move between different
    states using well-defined actions. The singleton pattern, popular in some statically
    typed languages, is almost always an anti-pattern in Python.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细讨论了几个常见的设计模式，包括示例、UML图以及Python与静态类型面向对象语言之间差异的讨论。装饰器模式通常使用Python更通用的装饰器语法来实现。观察者模式是一种将事件与其在事件上采取的操作解耦的有用方式。策略模式允许选择不同的算法来完成同一任务。状态模式看起来相似，但用于表示系统可以通过定义良好的操作在状态之间移动。在静态类型语言中流行的单例模式，在Python中几乎总是反模式。
- en: In the next chapter, we'll wrap up our discussion of design patterns.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将结束对设计模式的讨论。
