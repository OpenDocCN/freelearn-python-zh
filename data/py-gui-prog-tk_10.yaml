- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Maintaining Cross-Platform Compatibility
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护跨平台兼容性
- en: Word has spread throughout ABQ AgriLabs about your application, and it is being
    requested as a way to visualize and work on experimental data files. As a result,
    it now needs to run on Windows, macOS, and Linux systems equally well. Fortunately
    for you, Python and Tkinter are supported on these three operating systems, and
    you'll be pleasantly surprised to find that your application already runs unaltered
    on all three. However, there are some small issues that you need to address and
    remain aware of in order for your application to be a good citizen on each platform.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于你的应用程序的消息已经在ABQ AgriLabs传开，它被用作可视化和处理实验数据文件的方式。因此，它现在需要在Windows、macOS和Linux系统上同等良好地运行。幸运的是，对于你来说，Python和Tkinter在这三个操作系统上都有支持，你可能会惊喜地发现你的应用程序在所有三个系统上都能无修改地运行。然而，还有一些小问题需要你解决，并保持警觉，以便你的应用程序能够在每个平台上成为良好的公民。
- en: 'In this chapter, we''ll learn more about cross-platform compatibility as we
    cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过介绍以下主题来了解更多关于跨平台兼容性的内容：
- en: In *Writing cross-platform Python*, you'll learn how to keep basic Python code
    functional across multiple platforms.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在《跨平台Python编写》中，你将学习如何保持基本的Python代码在多个平台上保持功能。
- en: In *Writing cross-platform Tkinter*, you'll learn about cross-platform issues
    that affect Tkinter code specifically.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在《跨平台Tkinter编写》中，你将了解影响Tkinter代码的特定跨平台问题。
- en: In *Improving our application's cross-platform compatibility*, we'll update
    our ABQ Data Entry application for better cross-platform support.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在《改进我们应用程序的跨平台兼容性》中，我们将更新我们的ABQ数据录入应用程序以获得更好的跨平台支持。
- en: Writing cross-platform Python
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台Python编写
- en: At the time of writing, Python is supported on nearly a dozen operating system
    platforms, covering everything from common desktop systems like Windows to high-end
    commercial Unixes like AIX and obscure OS projects such as Haiku OS.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Python在近十种操作系统平台上都有支持，涵盖了从常见的桌面系统如Windows到高端商业Unix如AIX，以及像Haiku OS这样的神秘OS项目。
- en: Across all these platforms, most Python code works without any significant alteration,
    as Python has been designed to translate high-level functionality into appropriate
    low-level operations on each system. Even so, there are situations where OS differences
    cannot be (or simply have not been) abstracted away, and careful handling is required
    to avoid platform-specific failures.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些平台上，大多数Python代码无需任何重大修改即可工作，因为Python已被设计为将高级功能转换为每个系统上适当的低级操作。即便如此，仍然存在一些情况，其中操作系统差异无法（或尚未）抽象化，需要谨慎处理以避免特定平台的失败。
- en: In this section, we'll look at some of the larger issues that impact cross-platform
    Python.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些影响跨平台Python的较大问题。
- en: Filenames and file paths across platforms
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨平台文件名和文件路径
- en: Filesystems are probably the biggest source of pitfalls for cross-platform development.
    Although most platforms share the concept of files and directories arranged in
    a hierarchy, there are some crucial differences that can trip up developers who
    are unfamiliar with a variety of operating systems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统可能是跨平台开发中最大的陷阱来源。尽管大多数平台共享文件和目录按层次结构排列的概念，但有一些关键差异可能会让不熟悉各种操作系统的开发者陷入困境。
- en: Path separators and drives
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路径分隔符和驱动器
- en: 'When it comes to identifying locations on a filesystem, operating systems generally
    use one of the following two models:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在文件系统中标识位置时，操作系统通常使用以下两种模型之一：
- en: 'Windows/DOS: In this model, each partition or storage device is assigned a
    volume label (usually a single letter), and each volume has its own filesystem
    tree. Paths are separated by a backslash (`\`) character. This system is used
    by Windows, DOS, and VMS.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows/DOS：在这个模型中，每个分区或存储设备都被分配一个卷标（通常是一个字母），每个卷都有自己的文件系统树。路径由反斜杠（`\`）字符分隔。这个系统被Windows、DOS和VMS使用。
- en: 'Unix: In this model, there is one filesystem tree, into which devices and partitions
    are mounted at arbitrary points. Paths are separated by a forward slash (`/`).
    This model is used by macOS, Linux, BSD, iOS, Android, and other Unix-like operating
    systems.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix：在这个模型中，有一个文件系统树，设备和分区在任意点挂载。路径由正斜杠（`/`）分隔。这个模型被macOS、Linux、BSD、iOS、Android和其他类Unix操作系统使用。
- en: Thus, a path like `E:\Server\Files\python` is meaningless on Linux or macOS,
    while a path like `/mnt/disk1/files/python` is equally meaningless on Windows.
    This could make it quite difficult to write code that accesses files in a cross-platform
    way, but Python gives us a few tools to deal with the differences.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，像`E:\Server\Files\python`这样的路径在Linux或macOS上是没有意义的，而像`/mnt/disk1/files/python`这样的路径在Windows上同样没有意义。这可能会使得编写跨平台访问文件的代码变得相当困难，但Python为我们提供了一些工具来处理这些差异。
- en: Path separator translation
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 路径分隔符转换
- en: If you use the Unix-style forward slash path separators on a Windows system,
    Python will automatically translate them into backslashes. This is quite useful
    for cross-platform purposes because using backslashes in strings can be problematic.
    For example, if you try to create the string `C:\Users` in Python, you'll get
    an exception, because `\u` is an escape sequence for specifying Unicode sequences,
    and `sers` (the rest of the string after `\U`) is not a valid Unicode sequence.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个Windows系统上使用Unix风格的正斜杠路径分隔符，Python会自动将它们转换为反斜杠。这对于跨平台用途非常有用，因为在使用字符串中的反斜杠时可能会遇到问题。例如，如果你尝试在Python中创建字符串`C:\Users`，你会得到一个异常，因为`\u`是用于指定Unicode序列的转义序列，而`sers`（`\U`之后的字符串）不是一个有效的Unicode序列。
- en: To use backslashes in a string, you must either escape them by entering a double-backslash
    (`\\`) or you must use a raw string (by prefixing the string literal with an `r`).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要在字符串中使用反斜杠，你必须通过输入双反斜杠（`\\`）来转义它们，或者你必须使用原始字符串（通过在字符串字面量前加上`r`）。
- en: 'Note that there is no Windows-to-Unix path separator translation: Python will
    not translate backslashes into Unix-style forward slashes. Thus, a path like `r''\usr\bin\python''`
    will simply not work on macOS or Linux.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有Windows到Unix路径分隔符的转换：Python不会将反斜杠转换为Unix风格的正斜杠。因此，像`r'\usr\bin\python'`这样的路径在macOS或Linux上将无法正常工作。
- en: The os.path module
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: os.path模块
- en: Even with automatic path-separator interpolation, building or hardcoding paths
    as strings is a messy business. Python's powerful string manipulation methods
    make it tempting to try to work with paths as strings, and many programmers attempt
    to do so.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有自动路径分隔符插值，构建或硬编码路径作为字符串也是一项繁琐的工作。Python强大的字符串操作方法使得尝试以字符串的形式处理路径变得诱人，许多程序员都尝试这样做。
- en: 'The result is often ugly, non-portable code like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 结果通常是丑陋的、不可移植的代码，如下所示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While this approach might work most of the time (even on Windows), it's prone
    to breaking on some edge cases (for example, if `some_path` is `/script.sh`).
    For this reason, the Python standard library includes the `os.path` module for
    working with filesystem paths.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法在大多数情况下可能有效（甚至在Windows上），但它容易在一些边缘情况下出错（例如，如果`some_path`是`/script.sh`）。因此，Python标准库包括了`os.path`模块来处理文件系统路径。
- en: The `path` module appears to be a collection of functions and constants that
    help abstract common filenames and directory operations, though it's actually
    a wrapper around the low-level modules `posixpath` for Unix-like systems and `ntpath`
    for Windows. When you import `path`, Python simply detects your operating system
    and loads the appropriate low-level library.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`path`模块似乎是一组函数和常量，有助于抽象常见的文件名和目录操作，尽管它实际上是对Unix-like系统的`posixpath`模块和Windows的`ntpath`模块的低级封装。当你导入`path`时，Python会简单地检测你的操作系统并加载适当的低级库。'
- en: 'The following table shows some common `os.path` functions that are useful for
    cross-platform developers:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了对于跨平台开发者有用的某些常见的`os.path`函数：
- en: '| Function | Purpose |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 目的 |'
- en: '| `join()` | Joins two or more path segments in a platform-appropriate way
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `join()` | 以平台适当的方式连接两个或多个路径段 |'
- en: '| `expanduser()` | Expands the `~` or `username` shortcuts to the user''s home
    directory or user name, respectively |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `expanduser()` | 将`~`或`username`快捷方式分别扩展到用户的家目录或用户名 |'
- en: '| `expandvars()` | Expands any shell variables present in a path string |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `expandvars()` | 扩展路径字符串中存在的任何shell变量 |'
- en: '| `dirname()` | Extracts the parent directory of the path |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `dirname()` | 提取路径的父目录 |'
- en: '| `isfile()` | Determines whether the path points to a file |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `isfile()` | 确定路径是否指向一个文件 |'
- en: '| `isdir()` | Determines whether the path points to a directory |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `isdir()` | 确定路径是否指向一个目录 |'
- en: '| `exists()` | Determines whether the given path exists |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `exists()` | 确定给定的路径是否存在 |'
- en: Using these functions rather than directly manipulating path strings guarantees
    that your code will work across platforms consistently.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些函数而不是直接操作路径字符串可以保证你的代码在各个平台上的一致性。
- en: The pathlib module
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: pathlib模块
- en: A more recent addition to the Python standard library is the `pathlib` module.
    The `pathlib` module is a more object-oriented and somewhat higher-level take
    on filesystem paths, which we have been using throughout this book. Unlike `os.path`,
    which is just a collection of functions and constants, `pathlib` offers the `Path`
    object, which represents a filesystem location and provides a variety of methods
    for modifying the path and obtaining information about it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库中较新的补充是`pathlib`模块。`pathlib`模块是对文件系统路径的一种更面向对象且稍微高级的抽象，我们在整本书中一直在使用它。与仅是一系列函数和常量的`os.path`不同，`pathlib`提供了`Path`对象，它代表一个文件系统位置，并提供了一系列修改路径和获取其信息的方法。
- en: 'We typically use `pathlib` by importing the `Path` class from it. For example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常通过从其中导入`Path`类来使用`pathlib`。例如：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`Path` defaults to the current working directory, but you can also provide
    it with an absolute or relative path string. Relative paths will be calculated
    against the current working directory.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`默认为当前工作目录，但你也可以提供绝对或相对路径字符串。相对路径将相对于当前工作目录进行计算。'
- en: '`Path` objects have a variety of useful properties and methods:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`对象具有各种有用的属性和方法：'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Refer to the `pathlib` module's documentation at [https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html)
    for more information on this powerful library.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这个强大库的更多信息，请参阅`pathlib`模块的文档：[https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html)。
- en: Should you use `os.path` or `pathlib.Path`? Generally speaking, `pathlib` is
    the better choice and results in much cleaner code overall. However, there are
    a few edge cases where you might need `os.path`. For example, `pathlib` has no
    equivalent to `expandvars()`; also, the `os.path` module's function-oriented approach
    may be more useful in functional programming situations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用`os.path`还是`pathlib.Path`？一般来说，`pathlib`是更好的选择，并且总体上代码更干净。然而，在某些边缘情况下，你可能需要`os.path`。例如，`pathlib`没有与`expandvars()`等效的功能；此外，`os.path`模块以函数为导向的方法在函数式编程场景中可能更有用。
- en: Case sensitivity
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大小写敏感性
- en: Platforms also differ in terms of filesystem case sensitivity. On Linux, BSD,
    and Unix, for example, the files `log.txt`, `LOG.txt`, and `LoG.TxT` are all different
    files that can coexist in the same directory. On Windows or macOS (depending on
    your settings), all three names would refer to the same file, and three files
    with these names could not exist in the same directory.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 平台在文件系统大小写敏感性方面也存在差异。例如，在Linux、BSD和Unix上，文件`log.txt`、`LOG.txt`和`LoG.TxT`都是不同的文件，可以在同一目录中共存。在Windows或macOS（取决于你的设置），这三个名称都会指向同一个文件，并且不能在同一目录中存在三个具有这些名称的文件。
- en: 'The following table breaks down the case sensitivity of major operating systems:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格详细说明了主要操作系统的大小写敏感性：
- en: '| System | Case-sensitive |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 系统 | 大小写敏感 |'
- en: '| Windows | No |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| Windows | 否 |'
- en: '| macOS | Not by default (configurable) |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| macOS | 默认不区分（可配置） |'
- en: '| Linux | Yes |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| Linux | 是 |'
- en: '| BSD, most other Unix systems | Yes |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| BSD，大多数其他Unix系统 | 是 |'
- en: 'Problems with case (in)sensitivity usually depend on which system you''re accustomed
    to:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 大小写（不）敏感性问题通常取决于你习惯的系统：
- en: Programmers used to a case-insensitive system tend to run into problems with
    inconsistent use of cases when referencing files and paths. For instance, you
    might save a file as `UserSettings.json` but try to retrieve it as `usersettings.JSON`.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 习惯于不区分大小写的系统的程序员在引用文件和路径时可能会遇到大小写使用不一致的问题。例如，你可能会将文件保存为`UserSettings.json`，但尝试以`usersettings.JSON`的形式检索它。
- en: Programmers used to a case-sensitive system can have problems when depending
    on a case to differentiate between file or directory names. For example, you might
    have the files `ImportIngest.txt` and `ImportingEst.txt` in the same directory.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 习惯于大小写敏感系统的程序员在依赖于大小写来区分文件或目录名时可能会遇到问题。例如，你可能在同一目录下有`ImportIngest.txt`和`ImportingEst.txt`这两个文件。
- en: 'Avoiding these issues is fairly simple with the following few basic rules:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下几条基本规则可以避免这些问题：
- en: Use all-lowercase names for file and path names unless there is a good reason
    not to.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非有充分的理由，否则请使用全小写名称作为文件和路径名称。
- en: If you do mix cases, follow consistent rules, so that you don't need to remember
    arbitrary case usage.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你确实混合了大小写，请遵循一致的规则，这样你就不需要记住任意的使用大小写。
- en: Avoid CamelCase or similar naming schemes that rely on case to denote word breaks.
    Use underscores, hyphens, or spaces (they're valid in all modern filesystems!).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用CamelCase或类似依赖于大小写来表示单词分隔的命名方案。使用下划线、连字符或空格（它们在所有现代文件系统中都是有效的！）。
- en: 'To put it another way: treat all paths and filenames as if you had a case-sensitive
    system, but don''t rely on the system being case-sensitive.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：将所有路径和文件名视为如果系统是大小写敏感的，但不要依赖于系统是大小写敏感的。
- en: Symbolic links
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 符号链接
- en: A symbolic link is a special filesystem-level construct that appears to be a
    file or directory but is actually just a pointer to another file or directory
    on the system. They're often used to provide aliases to files or directories,
    or to make it appear as though the same file exists in multiple places without
    using additional disk space. Although they exist on Windows, they're far more
    commonly used on Linux, macOS, and other Unix-like systems; thus, they can be
    a point of confusion for programmers coming from a Windows environment.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接是一种特殊的文件系统级构造，看起来像文件或目录，但实际上只是指向系统上另一个文件或目录的指针。它们通常用于提供文件或目录的别名，或者在不使用额外磁盘空间的情况下，使同一个文件看起来存在于多个位置。尽管它们存在于Windows上，但在Linux、macOS和其他类Unix系统上使用得更为普遍；因此，对于来自Windows环境的程序员来说，它们可能是一个混淆点。
- en: Symbolic links are not to be confused with desktop shortcuts, which also exist
    on all three major platforms. Shortcuts are just metadata files implemented at
    the desktop environment level, whereas symbolic links are implemented at the filesystem
    level.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接不应与桌面快捷方式混淆，后者也存在于所有三个主要平台上。快捷方式只是桌面环境级别的元数据文件，而符号链接是在文件系统级别实现的。
- en: File and path operations sometimes need to clarify if they're working with the
    symbolic link itself or the file that the link points to.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 文件和路径操作有时需要明确它们是在处理符号链接本身还是链接指向的文件。
- en: 'For example, suppose we had a symbolic link in our current directory, `secret_stuff.txt`,
    that points to the nonexistent file `/tmp/secret_stuff.txt`. Look at how `os.path()`
    responds to such a file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们当前目录中有一个符号链接 `secret_stuff.txt`，它指向一个不存在的文件 `/tmp/secret_stuff.txt`。看看
    `os.path()` 如何响应这样的文件：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The regular `path.exists()` function will follow the link and discover that
    the actual file in question does not exist. `os.path` also includes a `lexists()`
    function that will tell us if the *link* exists, even if the *file* does not.
    This situation could be a problem; for example, your program might be attempting
    to create a directory with the same name as a broken symbolic link. In this case,
    `os.path.exists()` or `Path.exists()` would both return `False`, but the name
    conflict would still exist, and directory creation would fail. Checking `os.path.lexists()`
    or `Path.is_symlink()` as well would be a good idea in this case.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的 `path.exists()` 函数会跟随链接并发现实际文件不存在。`os.path` 还包括一个 `lexists()` 函数，它会告诉我们链接是否存在，即使文件不存在。这种情况可能是一个问题；例如，你的程序可能正在尝试创建一个与损坏的符号链接同名目录。在这种情况下，`os.path.exists()`
    或 `Path.exists()` 都会返回 `False`，但名称冲突仍然存在，目录创建会失败。在这种情况下，检查 `os.path.lexists()`
    或 `Path.is_symlink()` 也是一个好主意。
- en: 'The following table shows some of the `os.path` functions that help deal with
    symbolic links:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了 `os.path` 中一些帮助处理符号链接的函数：
- en: '| Method | Description |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| `islink()` | Returns `True` if a path is a symbolic link |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `islink()` | 如果路径是符号链接，则返回 `True` |'
- en: '| `lexists()` | Returns `True` if a path exists, even if it''s a broken symbolic
    link |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `lexists()` | 如果路径存在，即使它是损坏的符号链接，也返回 `True` |'
- en: '| `realpath()` | Returns the actual path, resolving any symbolic links to real
    files and directories |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `realpath()` | 返回实际路径，解析任何符号链接到真实文件和目录 |'
- en: '`pathlib.Path` objects also feature these link-related methods:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`pathlib.Path` 对象也具有这些与链接相关的方法：'
- en: '| Method | Description |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| `is_symlink()` | Returns `True` if the path is a symbolic link |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `is_symlink()` | 如果路径是符号链接，则返回 `True` |'
- en: '| `resolve()` | Returns a path with all symbolic links resolved to real files
    and directories |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `resolve()` | 返回一个路径，其中所有符号链接都已解析为真实文件和目录 |'
- en: '| `lchmod()` | Changes permissions on a symbolic link, rather than the file
    it is pointed to |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `lchmod()` | 改变符号链接的权限，而不是它指向的文件 |'
- en: '| `lstat()` | Returns filesystem information on a symbolic link, rather than
    the file it is pointed to |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `lstat()` | 返回符号链接的文件系统信息，而不是它指向的文件 |'
- en: In summary, our code should be mindful of symbolic links in situations where
    they might cause it to behave unexpectedly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们的代码应该注意在可能引起其行为异常的情况下处理符号链接。
- en: Path variables
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路径变量
- en: Most platforms, including Windows, macOS, and Linux, support some kind of shell
    variables, which are often automatically set up by the system to point to common
    filesystem locations. The `os.path` module provides the `expandvars()` function
    to expand these variables into their actual values (`pathlib` has no equivalent
    method). While these variables can be useful in locating common path locations,
    the cross-platform developer should understand that they are not consistent across
    platforms.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数平台，包括 Windows、macOS 和 Linux，支持某种类型的 shell 变量，这些变量通常由系统自动设置，以指向常见的文件系统位置。`os.path`
    模块提供了 `expandvars()` 函数来将这些变量展开为其实际值（`pathlib` 没有等效方法）。虽然这些变量在定位常见路径位置时可能很有用，但跨平台开发者应该了解它们在平台间并不一致。
- en: 'Some commonly used variables across different systems include the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同系统间，一些常用的变量包括以下内容：
- en: '| Description | Windows | macOS | Linux |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 描述 | Windows | macOS | Linux |'
- en: '| Current user home directory | `%HOME%`, `%USERPROFILE%` | `$HOME` | `$HOME`
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 当前用户主目录 | `%HOME%`, `%USERPROFILE%` | `$HOME` | `$HOME` |'
- en: '| Temporary directory | `%TMP%`, `%TEMP%` | `$TMPDIR` | None |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 临时目录 | `%TMP%`, `%TEMP%` | `$TMPDIR` | 无 |'
- en: '| Path to default shell | N/A | `$SHELL` | `$SHELL` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 默认 shell 路径 | 无 | `$SHELL` | `$SHELL` |'
- en: '| Current working directory | None | `$PWD` | `$PWD` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 当前工作目录 | 无 | `$PWD` | `$PWD` |'
- en: '| Configuration directory | `%APPDATA%`, `%LOCALAPPDATA%` | None | `$XDG_CONFIG_HOME`
    (often not set) |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 配置目录 | `%APPDATA%`, `%LOCALAPPDATA%` | 无 | `$XDG_CONFIG_HOME`（通常未设置）|'
- en: '| OS directory | `%WINDIR%`, `%SYSTEMROOT%` | N/A | N/A |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| OS 目录 | `%WINDIR%`, `%SYSTEMROOT%` | 无 | 无 |'
- en: '| Program files directory | `%PROGRAMFILES%`, `%PROGRAMW6432%` | N/A | N/A
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 程序文件目录 | `%PROGRAMFILES%`, `%PROGRAMW6432%` | 无 | 无 |'
- en: Note that Windows variables can be spelled using the native `%VARIABLENAME%`
    format or the Unix-style `$VARIABLENAME` format; macOS and Linux only accept the
    Unix-style format.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Windows 变量可以使用本地的 `%VARIABLENAME%` 格式或 Unix 风格的 `$VARIABLENAME` 格式；macOS
    和 Linux 只接受 Unix 风格格式。
- en: Using these variables is not necessarily a bad idea (they can help abstract
    differences between versions or configurations of an OS), but be aware that they
    are not consistently available, or even meaningful, across platforms.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些变量不一定是个坏主意（它们可以帮助抽象操作系统的版本或配置之间的差异），但请注意，它们在平台间并不一致可用，甚至可能没有意义。
- en: Inconsistent library and feature support
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库和功能支持不一致
- en: While it's understandable that many third-party Python libraries only support
    a limited number of platforms, you might be surprised to learn that the standard
    library contains a slightly different set of modules depending on the platform.
    Even those that do exist across platforms might behave slightly differently, or
    have inconsistent contents, depending on the platform.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以理解许多第三方 Python 库只支持有限数量的平台，但你可能会惊讶地发现，标准库包含的模块集合根据平台略有不同。即使那些在平台上都存在的模块，其行为也可能略有不同，或者内容不一致，这取决于平台。
- en: Naturally, these have to be handled carefully in cross-platform applications.
    Let's look at a few examples of these libraries and features.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这些变量在跨平台应用程序中必须谨慎处理。让我们看看这些库和功能的几个例子。
- en: Python's platform-limited libraries
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 的平台限制库
- en: In sections 34 and 35 of Python's standard library documentation ([https://docs.python.org/3/library/index.html](https://docs.python.org/3/library/index.html)),
    you'll find a list of libraries available only on Windows or Unix-like systems,
    respectively. Careful reading of the documentation shows that there are a couple
    more platform-limited libraries listed in other sections as well.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 标准库文档的第 34 和 35 部分 ([https://docs.python.org/3/library/index.html](https://docs.python.org/3/library/index.html))
    中，你可以找到仅在 Windows 或类 Unix 系统上可用的库列表。仔细阅读文档可显示，在其他部分还列出了更多平台限制库。
- en: 'This is a list of the more common platform-limited libraries you may encounter:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个你可能遇到的常见平台限制库列表：
- en: '| Library | Description | Availability |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 库 | 描述 | 可用性 |'
- en: '| `ossaudiodev` | Open Sound System (OSS) audio server interface | Linux, FreeBSD
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `ossaudiodev` | 开放声音系统 (OSS) 音频服务器接口 | Linux, FreeBSD |'
- en: '| `winsound` | Windows audio interface | Windows |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `winsound` | Windows 音频接口 | Windows |'
- en: '| `msilib` | Windows software packaging tools | Windows |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `msilib` | Windows 软件打包工具 | Windows |'
- en: '| `winreg` | Windows registry tools | Windows |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `winreg` | Windows 注册表工具 | Windows |'
- en: '| `syslog` | Unix system log interface | Linux, macOS, BSD |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `syslog` | Unix 系统日志接口 | Linux, macOS, BSD |'
- en: '| `pwd`, `spwd` | Unix password database interface | Linux, macOS, BSD |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `pwd`, `spwd` | Unix 密码数据库接口 | Linux, macOS, BSD |'
- en: '| `resource` | System resource limits | Linux, macOS, BSD |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `resource` | 系统资源限制 | Linux、macOS、BSD |'
- en: '| `curses` | Terminal-based UI library | Linux, macOS, BSD |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `curses` | 基于终端的UI库 | Linux、macOS、BSD |'
- en: In some cases, there are higher-level, cross-platform libraries that you can
    use to replace these (for example, use `logging` instead of `syslog`), but in
    other cases the functionality is so platform-specific that you may have no choice
    (`winreg`, for example). In this case, you'll need to do a platform check before
    importing these libraries, as you'll get an `ImportError` exception on unsupported
    platforms.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可以使用更高层次的跨平台库来替换这些库（例如，使用`logging`代替`syslog`），但在其他情况下，功能过于特定于平台，可能别无选择（例如`winreg`）。在这种情况下，在导入这些库之前，您需要进行平台检查，因为在不支持的平台上您将收到`ImportError`异常。
- en: Checking low-level function compatibility
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查低级函数兼容性
- en: Even in universally available libraries, there are sometimes functions or methods
    that are unavailable or exhibit different behaviors depending on the platform.
    The `os` module is perhaps the most notable case.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在普遍可用的库中，有时也存在某些函数或方法，它们根据平台的不同而不可用或表现出不同的行为。`os`模块可能是最显著的例子。
- en: The `os` module is a relatively thin wrapper around system calls or commands,
    and while it attempts to abstract some roughly analogous calls across platforms,
    many of its functions are too platform-specific to make available universally.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`模块是对系统调用或命令的相对较薄的包装，尽管它试图抽象跨平台的一些大致类似调用，但许多函数过于特定于平台，无法普遍提供。'
- en: 'The `os` module documentation at [https://docs.python.org/3/library/os.html](https://docs.python.org/3/library/os.html)
    contains complete details on platform support, but some examples are listed here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`模块的文档在[https://docs.python.org/3/library/os.html](https://docs.python.org/3/library/os.html)中包含有关平台支持的完整详细信息，但这里列出了其中的一些示例：'
- en: '| Library | Description | Availability |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 库 | 描述 | 可用性 |'
- en: '| `getuid`, `getgid`, `getgroups`, `geteuid` | Get user or group information
    for the current process | Unix-like |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `getuid`、`getgid`、`getgroups`、`geteuid` | 获取当前进程的用户或组信息 | 类Unix |'
- en: '| `setuid`, `setgid`, `setgroups`, `seteuid` | Set user or group information
    for the current process | Unix-like |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `setuid`、`setgid`、`setgroups`、`seteuid` | 设置当前进程的用户或组信息 | 类Unix |'
- en: '| `getpriority`, `setpriority` | Get or set the priority of the current process
    | Unix-like |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `getpriority`、`setpriority` | 获取或设置当前进程的优先级 | 类Unix |'
- en: '| `chown`, `lchown` | Change the owner of a file or its symbolic link | Unix-like
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `chown`、`lchown` | 更改文件或其符号链接的所有者 | 类Unix |'
- en: '| `startfile` | Open a file as if it were double-clicked | Windows |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `startfile` | 以双击文件的方式打开文件 | Windows |'
- en: Attempting to use an unavailable function will cause an exception, so none of
    these functions should be in a cross-platform application without appropriate
    checks or exception handling. By far, most of the platform-limited functions in
    `os` are limited to Unix-like systems (Linux, macOS, BSD, and so on), and most
    of the analogous functions for Windows will be found in the third-party `pywin32`
    package (which is only available for Windows, of course).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用不可用的函数将导致异常，因此这些函数中没有一个应该在跨平台应用程序中使用，除非进行适当的检查或异常处理。到目前为止，`os`模块中大多数受平台限制的函数仅限于类Unix系统（Linux、macOS、BSD等），而大多数Windows的类似函数可以在第三方`pywin32`包中找到（当然，该包仅适用于Windows）。
- en: In general, you need to check the documentation of the libraries you use to
    make sure they're available on all the platforms you intend to support. Caution
    is especially warranted when using libraries that interact with operating system
    functions (such as window management, filesystems, user authentication, and so
    on) or with services that are only available on certain platforms (Microsoft SQL
    Server, for example).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您需要检查您使用的库的文档，以确保它们在您打算支持的平台上都可用。当使用与操作系统功能（如窗口管理、文件系统、用户身份验证等）或仅在某些平台上可用的服务（例如Microsoft
    SQL Server）交互的库时，应特别注意。
- en: The dangers of the subprocess module
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子进程模块的危险
- en: The `subprocess` module provides tools to launch and manage other programs and
    commands from within your Python application. For programmers already familiar
    with their operating system's command-line interface, it often provides a fast
    and convenient way to accomplish filesystem operations or other administrative
    tasks. It's also highly effective at sabotaging cross-platform compatibility!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`subprocess` 模块提供了在您的 Python 应用程序中启动和管理其他程序和命令的工具。对于已经熟悉其操作系统命令行界面的程序员来说，它通常提供了一种快速便捷的方式来完成文件系统操作或其他管理任务。但它也极有可能破坏跨平台兼容性！'
- en: 'For example, a programmer on Linux or macOS might be tempted to copy files
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Linux 或 macOS 上的程序员可能会尝试以下方式复制文件：
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This would work on Unix-like operating systems but fail on Windows, as `cp`
    is not a valid Windows shell command. The better option in this case is to use
    the `shutil` library, which contains high-level functions for copying files.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这在类 Unix 操作系统上会起作用，但在 Windows 上会失败，因为 `cp` 不是一个有效的 Windows 命令行命令。在这种情况下，更好的选择是使用
    `shutil` 库，它包含用于复制文件的高级函数。
- en: 'To avoid problems here, follow these guidelines:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这里的问题，请遵循以下指南：
- en: Look for high-level libraries before resorting to `subprocess` to solve a problem.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在求助于 `subprocess` 解决问题之前，先寻找高级库。
- en: If you must use `subprocess`, carefully study the called command on each supported
    platform, making sure the syntax, output, and behavior are identical.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您必须使用 `subprocess`，请仔细研究每个受支持平台上的调用命令，确保语法、输出和行为完全相同。
- en: If they're not, make sure to create different cases for each platform (see the
    section *Writing code that changes according to the platform*, below).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它们不是，请确保为每个平台创建不同的案例（参见下文“根据平台编写代码”部分）。
- en: Naturally, all this advice applies equally to any third-party modules that allow
    you to execute operating system commands from within Python.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，所有这些建议同样适用于任何允许您在 Python 中执行操作系统命令的第三方模块。
- en: Text file encodings and formats
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本文件编码和格式
- en: Plaintext files on different platforms use different character encodings and
    end-of-line characters by default. Although most operating systems can handle
    a wide variety of encodings, each system has a default (often determined by language
    or localization settings) that will be used if none is specified. Text files on
    different platforms also use different character codes for end-of-line characters.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 不同平台上的纯文本文件默认使用不同的字符编码和换行符。尽管大多数操作系统可以处理多种编码，但每个系统都有一个默认编码（通常由语言或本地化设置确定），如果没有指定，将使用该编码。不同平台上的文本文件也使用不同的字符代码作为换行符。
- en: Modern versions of Linux and macOS use UTF-8 as a default encoding and the line
    feed character (`\n`) as a line terminator. Windows 10, however, uses `cp1252`
    as its default encoding and the combination of the carriage return and line feed
    (`\r\n`) characters as a line terminator. Most of the time, these differences
    do not represent a problem, especially if you are only reading and writing files
    in Python and working with standard English characters.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 和 macOS 的现代版本使用 UTF-8 作为默认编码，并使用换行符（`\n`）作为行终止符。然而，Windows 10 使用 `cp1252`
    作为其默认编码，并使用回车符和换行符的组合（`\r\n`）作为行终止符。大多数时候，这些差异不会造成问题，尤其是如果您只使用 Python 读取和写入文件，并且处理标准英语字符。
- en: 'Consider, however, a scenario where you attempt to append a Unicode character
    to a text file, like so:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，考虑以下场景，您尝试将一个 Unicode 字符追加到文本文件中，如下所示：
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On Windows, or other systems with a non-Unicode default encoding, the preceding
    code will raise an exception, like so:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 或其他使用非 Unicode 默认编码的系统上，前面的代码将引发异常，如下所示：
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To avoid this problem, you can manually specify a character encoding when opening
    a file, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，您可以在打开文件时手动指定字符编码，如下所示：
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The line-terminator character can also be specified when opening a file using
    the `newline` argument, like so:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `newline` 参数打开文件时，也可以指定行终止符字符，如下所示：
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We've already been doing this in ABQ Data Entry to work around a bug in Windows
    with the `csv` module. In a cross-platform situation, it's a good idea to specify
    both the `encoding` and `newline` arguments whenever saving data you don't control
    (such as user-entered data).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 ABQ 数据录入中这样做，以解决 Windows 上 `csv` 模块的错误。在跨平台的情况下，指定 `encoding` 和 `newline`
    参数以保存您不控制的数据（例如用户输入的数据）是一个好主意。
- en: Graphical and console modes
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图形和控制台模式
- en: 'On Windows, programs are launched in either GUI mode or console mode, as determined
    by metadata in the executable. The Python distribution for Windows includes a
    utility called Python launcher, which is associated with Python files during installation.
    Python launcher will launch your application in either GUI or console mode depending
    on its file extension, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，程序将以 GUI 模式或控制台模式启动，这由可执行文件中的元数据决定。Windows 的 Python 发行版包括一个名为 Python
    launcher 的实用程序，它在安装期间与 Python 文件关联。Python launcher 将根据其文件扩展名在 GUI 或控制台模式下启动您的应用程序，如下所示：
- en: Files ending in the `.py` extension will be launched in console mode using `python.exe`.
    This will cause a command-line window to open in the background, which must stay
    open while the program runs.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `.py` 扩展名结尾的文件将使用 `python.exe` 在控制台模式下启动。这将导致在后台打开一个命令行窗口，程序运行期间必须保持该窗口打开。
- en: Files ending in `.pyw` will be launched in GUI mode using `pythonw.exe`. No
    command-line window will be launched, and if run from a command line the program
    will not block the console (that is, the prompt will return immediately, while
    the program is still running); however, `print()` will have no effect and `sys.stderr`
    and `sys.stdout` will not exist. Trying to access them will raise an exception.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `.pyw` 结尾的文件将使用 `pythonw.exe` 在 GUI 模式下启动。不会启动命令行窗口，如果从命令行运行程序，程序将不会阻塞控制台（即，提示符将立即返回，而程序仍在运行）；然而，`print()`
    将没有效果，`sys.stderr` 和 `sys.stdout` 也不会存在。尝试访问它们将引发异常。
- en: This distinction often causes confusion for developers coming from Linux or
    macOS, where it is common to have graphical applications that output errors and
    debugging information to the terminal. Even for Windows programmers who are new
    to GUI applications, the lack of command-line output for GUI applications can
    be problematic.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别常常会让来自 Linux 或 macOS 的开发者感到困惑，在这些系统中，图形应用程序通常会将错误和调试信息输出到终端。即使是对于刚开始接触 GUI
    应用程序的 Windows 程序员来说，GUI 应用程序没有命令行输出也可能是个问题。
- en: 'To avoid issues, simply remember the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免问题，只需记住以下内容：
- en: Remove any `sys.stdout()` or `sys.stderr()` calls from the code if deploying
    to Windows.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果将代码部署到 Windows，请从代码中移除任何 `sys.stdout()` 或 `sys.stderr()` 调用。
- en: Rely on logging rather than `print()` or `sys.stderr()` calls to record debugging
    information.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依靠日志记录而不是 `print()` 或 `sys.stderr()` 调用来记录调试信息。
- en: Create a copy of the main executable script with a `.pyw` extension so that
    Windows users can launch it without a command-line window.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建主可执行脚本的 `.pyw` 扩展名副本，以便 Windows 用户可以无需命令行窗口即可启动它。
- en: While macOS does not distinguish between GUI and console applications (apart
    from the obvious presence of a GUI), its desktop launches regular `.py` files
    by launching a Terminal window, just like Windows. While macOS Python includes
    a `pythonw.exe` file that launches without the Terminal, there are two problems
    with it. First, it is not associated with the `.pyw` extension by default; you'd
    need to do that manually if you wanted that behavior. Second, depending on how
    you installed Python 3 (for instance, if you installed it using `homebrew`), your
    installation may not have `pythonw`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 macOS 不区分 GUI 和控制台应用程序（除了明显的 GUI 存在之外），但其桌面通过启动一个终端窗口来启动常规的 `.py` 文件，就像 Windows
    一样。虽然 macOS Python 包含一个无需终端即可启动的 `pythonw.exe` 文件，但存在两个问题。首先，它默认不与 `.pyw` 扩展名关联；如果您想实现这种行为，则需要手动进行。其次，根据您如何安装
    Python 3（例如，如果您使用 `homebrew` 安装），您的安装可能没有 `pythonw`。
- en: There is a way to set up Python programs on macOS so that they behave like proper
    GUI applications, which we'll cover in *Chapter 16*, *Packaging with setuptools
    and cxFreeze*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上设置 Python 程序以使其表现得像真正的 GUI 应用程序是有方法的，我们将在 *第 16 章*，*使用 setuptools 和
    cxFreeze 打包* 中介绍。
- en: Writing code that changes according to the platform
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写根据平台变化的代码
- en: As you've seen so far, there are certain situations where you simply can't avoid
    writing platform-specific code, either because a high-level library is unavailable
    or because the actions that need to be performed are fundamentally different on
    a particular platform.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在某些情况下，您根本无法避免编写特定平台的代码，要么是因为高级库不可用，要么是因为需要在特定平台上执行的操作本质上不同。
- en: 'In this case, it becomes necessary to detect the platform. There are a few
    ways of doing this in Python, including the `os.system()` function and the `sys.platform`
    attribute, but the standard library `platform` module contains the best set of
    functionality for determining the OS details most useful in making decisions.
    When called, the `platform.system()` function returns a string identifying the
    operating system: `Windows`, `Linux`, `freebsd7`, or `Darwin` (for macOS).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，检测平台变得必要。在Python中，有几种方法可以做到这一点，包括`os.system()`函数和`sys.platform`属性，但标准库中的`platform`模块包含了确定OS详细信息的最有用的功能集。当调用时，`platform.system()`函数返回一个标识操作系统的字符串：`Windows`、`Linux`、`freebsd7`或`Darwin`（用于macOS）。
- en: Some other useful functions in the `platform` module include `release()`, which
    returns the version string of the OS (for example, "10" on Windows 10, "17.3.0"
    on macOS High Sierra, or the running kernel version on Linux); and `architecture()`,
    which tells us if the system is 64 bit or 32 bit.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`platform`模块中一些其他有用的函数包括`release()`，它返回OS的版本字符串（例如，Windows 10上的"10"，macOS High
    Sierra上的"17.3.0"，或Linux上的运行内核版本）；以及`architecture()`，它告诉我们系统是64位还是32位。'
- en: 'For simple differences in code, using this information in a nested `if` / `else`
    chain usually suffices:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代码中的简单差异，通常使用嵌套的`if` / `else`链中的此信息就足够了：
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This example defines a platform-appropriate list of command tokens based on
    the value returned by `platform.system()`. The correct list is saved as `cmd`,
    which is then passed to `subprocess.check_output()` to run the command and obtain
    its output.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例定义了一个基于`platform.system()`返回值的平台适当的命令标记列表。正确的列表被保存为`cmd`，然后传递给`subprocess.check_output()`以运行命令并获取其输出。
- en: 'This works acceptably for the occasional call, but for more complex situations,
    it makes sense to bundle platform-specific code into backend classes that we can
    then select on the basis of our platform string. For example, we could re-implement
    the above code as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于偶尔的调用来说是可接受的，但对于更复杂的情况，将特定于平台的代码打包到后端类中是有意义的，然后我们可以根据我们的平台字符串选择这些类。例如，我们可以将上述代码重新实现如下：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this approach, we have created a generic class to handle the common logic
    for getting processes, then subclassed it to override the `cmd` attribute specifically
    for each platform.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们创建了一个通用类来处理获取进程的常见逻辑，然后将其子类化以专门针对每个平台覆盖`cmd`属性。
- en: 'Now, we can create a selector function to return an appropriate backend class
    when given an OS name:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个选择函数，当给定OS名称时返回适当的后端类：
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, code that needs to use this class can utilize this function to retrieve
    a platform-appropriate version. For example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，需要使用此类的代码可以利用此函数检索平台适当的版本。例如：
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This script can now be run on Linux, Windows, macOS, or BSD to print a process
    list. Other platforms can be easily added by creating more `GenericProcessGetter`
    subclasses and updating `get_process_getter_class()`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，此脚本可以在Linux、Windows、macOS或BSD上运行以打印进程列表。可以通过创建更多的`GenericProcessGetter`子类并更新`get_process_getter_class()`轻松添加其他平台。
- en: 'For even more complex situations, where multiple classes or functions need
    to be implemented differently between platforms, we can take an approach similar
    to the standard library''s `os.path` module: implement completely separate modules
    for each platform, then import them with a common alias depending on the platform.
    For example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的情况，其中多个类或函数需要在平台之间以不同的方式实现，我们可以采取类似于标准库的`os.path`模块的方法：为每个平台实现完全独立的模块，然后根据平台导入它们，使用一个共同的别名。例如：
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Bear in mind that each backend module should ideally contain identical class
    and function names and produce similar output. That way `backend` can be used
    by the code without concern for the platform in question.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每个后端模块理想情况下应包含相同的类和函数名称，并产生类似的输出。这样，`backend`就可以在代码中使用，而无需关心特定的平台。
- en: Writing cross-platform Tkinter
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写跨平台Tkinter
- en: As you've seen so far, Tkinter mostly works identically across platforms, and
    even has the capability to do the right thing on each platform with minimal effort.
    However, there are some minor issues to be aware of as you support a Tkinter application
    across multiple operating systems. In this section, we'll explore the more significant
    differences.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如您迄今为止所见，Tkinter在各个平台上大多工作方式相同，甚至可以以最小的努力在每个平台上做正确的事情。然而，当您在多个操作系统上支持Tkinter应用程序时，有一些小问题需要注意。在本节中，我们将探讨更显著的不同之处。
- en: Tkinter version differences across platforms
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨平台Tkinter版本差异
- en: As of 2021, the official Python 3 distributions for major platforms ship at
    least Tcl/Tk 8.6; this is the latest major release of Tcl/Tk and includes all
    the functionality discussed in this book. However, not every platform includes
    the latest minor version, which may impact bug fixes and minor features. At the
    time of writing, the latest version of Tcl/Tk is 8.6.11.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2021年，主流平台官方Python 3发行版至少包含Tcl/Tk 8.6；这是Tcl/Tk的最新主要版本，包含了本书中讨论的所有功能。然而，并非每个平台都包含最新的次要版本，这可能会影响错误修复和次要功能。在撰写本文时，Tcl/Tk的最新版本是8.6.11。
- en: Historically, some platforms (notably macOS) have lagged behind in shipping
    the latest version of Tcl/Tk. While platform support at the time of writing is
    fairly consistent, it's possible that differences may arise again in the future.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，一些平台（尤其是macOS）在发布Tcl/Tk最新版本方面落后。尽管在撰写本文时平台支持相当一致，但未来可能会有所差异。
- en: 'To discover the exact version of Tcl/Tk installed on your system, you can execute
    the following commands at a Python prompt:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要发现您系统上安装的Tcl/Tk的确切版本，您可以在Python提示符下执行以下命令：
- en: '[PRE14]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code uses the `Tcl()` function to create a new Tcl interpreter, then calls
    the `info patchlevel` command. Here''s what this command returns on several platforms
    using the most commonly used Python 3 distribution for each platform:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用 `Tcl()` 函数创建一个新的Tcl解释器，然后调用 `info patchlevel` 命令。以下是使用每个平台最常用的Python 3发行版在几个平台上运行此命令的返回结果：
- en: '| Platform | Python version | Tcl/Tk version |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 平台 | Python版本 | Tcl/Tk版本 |'
- en: '| Windows 10 | 3.9 (from python.org) | 8.6.9 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| Windows 10 | 3.9（来自python.org）| 8.6.9 |'
- en: '| macOS High Sierra | 3.9 (from python.org) | 8.6.8 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| macOS High Sierra | 3.9（来自python.org）| 8.6.8 |'
- en: '| Ubuntu 20.04 | 3.8 (from the repositories) | 8.6.10 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| Ubuntu 20.04 | 3.8（来自仓库）| 8.6.10 |'
- en: '| Debian 10 | 3.7 (from the repositories) | 8.6.9 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| Debian 10 | 3.7（来自仓库）| 8.6.9 |'
- en: As you can see, none of these platforms offer the latest version of Tcl/Tk,
    and even those with newer versions of Python may have older versions of Tcl/Tk.
    Ultimately, if you intend to write cross-platform Tkinter code, make sure you
    are not relying on features from the very latest version of Tcl/Tk.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些平台中没有一个提供Tcl/Tk的最新版本，即使那些拥有Python较新版本的系统，也可能拥有较旧的Tcl/Tk版本。最终，如果您打算编写跨平台Tkinter代码，请确保您没有依赖于Tcl/Tk最新版本的特性。
- en: Application menus across platforms
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台间的应用程序菜单
- en: The application menu is probably one of the most visible areas where both capabilities
    and conventions vary between platforms. As mentioned in *Chapter 7*, *Creating
    Menus with Menu and Tkinter Dialogs*, we should be aware of both the limitations
    and the expectations on major operating systems when designing our menus.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序菜单可能是能力与平台间差异最明显的区域之一。如 *第7章* 中所述，*使用Menu和Tkinter对话框创建菜单*，在设计我们的菜单时，我们应该了解主要操作系统对限制和期望。
- en: Menu widget capabilities
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 菜单小部件功能
- en: The `Menu` widget, which we learned about in *Chapter 7*, is different from
    most other Tkinter widgets in that it relies on the menu facilities of the underlying
    platform. This allows your application to have a menu that behaves natively; for
    example, on macOS, the menu appears in the global menu area at the top of the
    screen, while on Windows it appears in the application window under the taskbar.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第7章中了解到的 `Menu` 小部件与其他大多数Tkinter小部件不同，因为它依赖于底层平台的菜单功能。这允许您的应用程序拥有一个表现本地的菜单；例如，在macOS上，菜单出现在屏幕顶部的全局菜单区域，而在Windows上，它出现在任务栏下的应用程序窗口中。
- en: Because of this design, there are some limitations when working with cross-platform
    `Menu` widgets. To demonstrate this, let's build an extremely non-cross-platform
    menu.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种设计，当与跨平台的 `Menu` 小部件一起工作时，存在一些限制。为了演示这一点，让我们构建一个极端的非跨平台菜单。
- en: 'We''ll begin by creating a simple `Tk` window with a menu, like so:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个带有菜单的简单 `Tk` 窗口，如下所示：
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we''ll create a cascade menu:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个级联菜单：
- en: '[PRE16]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `smile_menu` contains two commands, one with a text label and the other
    with only an image. We've also used the image when adding the cascade to the menu,
    so that it shouldn't have a text label, just an image.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`smile_menu` 包含两个命令，一个带有文本标签，另一个只包含图像。我们在添加菜单的级联时也使用了图像，因此它不应该有文本标签，只需一个图像即可。'
- en: 'While we''re at it, let''s add some colors; in *Chapter 9*, *Improving the
    Look with Styles and Themes*, we customized the color of the application menu,
    mentioning that it only worked in Linux. Let''s see what it does on other platforms;
    add in the following code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在此期间，让我们添加一些颜色；在*第9章*，*通过样式和主题改进外观*中，我们自定义了应用程序菜单的颜色，提到它只在Linux上工作。让我们看看它在其他平台上会做什么；添加以下代码：
- en: '[PRE17]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That should make our main menu white text on a black background, and the cascade
    yellow on red.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这样应该会使我们的主菜单显示为黑色背景上的白色文字，而级联菜单为红色背景上的黄色。
- en: 'Next, let''s add a separator and a command directly to the main menu, after
    the `smile_menu`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`smile_menu`之后的主菜单中添加一个分隔符和一条命令：
- en: '[PRE18]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Last of all, we''ll create a `Checkbutton` widget directly on the main menu,
    and finish with the usual boilerplate to configure `root` and run the `mainloop()`
    method:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在主菜单上直接创建一个`Checkbutton`小部件，并使用通常的样板代码来配置`root`并运行`mainloop()`方法：
- en: '[PRE19]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Save this file and execute the code. Depending on your operating system, you'll
    see some different things.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此文件并执行代码。根据你的操作系统，你可能会看到一些不同的结果。
- en: 'If you are on Linux (in this case, Ubuntu 20.04), it seems to work mostly as
    expected:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Linux（在这个例子中是Ubuntu 20.04），它似乎大致按预期工作：
- en: '![Figure 10.1: The menu experiment on Ubuntu 20.04](img/B17578_10_01.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1：Ubuntu 20.04上的菜单实验](img/B17578_10_01.png)'
- en: 'Figure 10.1: The menu experiment on Ubuntu 20.04'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：Ubuntu 20.04上的菜单实验
- en: We have our first cascade labeled with the smiley face GIF, our top-level menu
    command, and our top-level `Checkbutton` (which we've checked, because it is true
    that our menu works!). The colors also seem to be correct, although the background
    of the GIF is the default grey rather than the red we would expect (the GIF itself
    has a transparent background).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了第一个带有笑脸GIF标签的级联菜单，我们的顶级菜单命令，以及我们的顶级`Checkbutton`（因为我们已经检查过，确实我们的菜单是工作的！）。颜色似乎也是正确的，尽管GIF的背景是默认的灰色，而不是我们预期的红色（GIF本身有透明背景）。
- en: 'If you''re using Windows 10, you should see something more like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Windows 10，你应该会看到类似这样的效果：
- en: '![Figure 10.2: The menu experiment on Windows 10](img/B17578_10_02.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2：Windows 10上的菜单实验](img/B17578_10_02.png)'
- en: 'Figure 10.2: The menu experiment on Windows 10'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：Windows 10上的菜单实验
- en: Instead of our smiling icon in the top menu, we only have the text **(Image)**.
    Even if we specify a label, this text shows up where the image should be. Fortunately,
    the image does appear when we use it in the cascade menu. As for the colors, they
    work as expected in the cascade menu, but the top-level menu ignores them completely.
    The command in the main menu appears and works just fine, but the `Checkbutton`
    widget does not. Its label appears and can be clicked on, but the check mark itself
    does not appear.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部菜单中，我们没有微笑图标，而是只有文本**（图像）**。即使我们指定了一个标签，这个文本也会出现在图像应该出现的位置。幸运的是，当我们在级联菜单中使用它时，图像确实出现了。至于颜色，它们在级联菜单中按预期工作，但顶级菜单完全忽略了它们。主菜单中的命令出现并正常工作，但`Checkbutton`小部件没有。它的标签出现并可以点击，但复选标记本身没有出现。
- en: 'Finally, let''s try this menu on macOS. It should look something like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在macOS上尝试这个菜单。它应该看起来像这样：
- en: '![Figure 10.3: The menu experiment on macOS](img/B17578_10_03.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3：macOS上的菜单实验](img/B17578_10_03.png)'
- en: 'Figure 10.3: The menu experiment on macOS'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：macOS上的菜单实验
- en: On macOS, our menu shows up not in the program window, but in the global menu
    at the top of the screen, as macOS users would expect it to. However, there are
    some obvious problems.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，我们的菜单不是显示在程序窗口中，而是显示在屏幕顶部的全局菜单中，正如macOS用户所期望的那样。然而，有一些明显的问题。
- en: 'First, while our smiling icon appears, it''s cut off. Since the top bar is
    a fixed height and Tkinter will not resize our icon for us, images larger than
    the top bar height get truncated. There are bigger problems too: neither the top-level
    command nor the `Checkbutton` widget are anywhere to be seen. Only our cascade
    menu shows up. Color-wise, the top-level menu ignored our colors, while the cascades
    only honored the foreground color (resulting in a fairly unreadable yellow-on-gray
    combination). Also note that we have a "Python" cascade menu that we did not create.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当我们的微笑图标出现时，它似乎被截断了。由于顶部栏的高度是固定的，Tkinter不会为我们调整图标大小，所以大于顶部栏高度的图片会被截断。还有更大的问题：顶级命令和`Checkbutton`小部件都无处可寻。只有我们的级联菜单出现了。在颜色方面，顶级菜单忽略了我们的颜色，而级联菜单只尊重前景色（导致了一种相当难以阅读的灰色背景上的黄色组合）。此外，请注意，我们有一个我们没有创建的“Python”级联菜单。
- en: On each platform, we're limited by the capabilities of the menu system, and
    while it appears that anything goes for menus on Linux, the other two operating
    systems require more care when constructing menus.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个平台上，我们受限于菜单系统的功能，虽然看起来Linux上的菜单似乎可以随意设置，但其他两个操作系统在构建菜单时需要更加小心。
- en: 'To avoid any issues with menus, follow these guidelines:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免菜单出现任何问题，请遵循以下指南：
- en: Avoid command, `Checkbutton`, and `Radiobutton` items in the main menu; stick
    to cascade menus only.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主菜单中避免使用命令、`Checkbutton`和`Radiobutton`项；仅使用级联菜单。
- en: Don't use images in the top-level main menu.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在顶级主菜单中使用图像。
- en: Don't use colors to style the menu, at least not on Windows or macOS.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用颜色来设置菜单样式，至少不要在Windows或macOS上使用。
- en: If you must do any of the preceding points, create separate menus for each platform.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你必须执行上述任何一点，为每个平台创建单独的菜单。
- en: If you take the approach of building separate menus for each platform, of course,
    you can implement whatever features are supported on the platform in question.
    However, just because you *can* use a feature on a platform doesn't necessarily
    mean you *should*. In the next section, we'll look at the guidelines and standards
    that can help you decide how to implement a menu on each platform.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为每个平台分别构建菜单，当然可以实施该平台支持的所有功能。然而，仅仅因为你在某个平台上可以使用某个功能，并不意味着你“应该”使用它。在下一节中，我们将探讨可以帮助你决定如何在每个平台上实现菜单的指南和标准。
- en: Menu guidelines and standards
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 菜单指南和标准
- en: Each of our major platforms offers standards to direct developers in making
    user interfaces that meet the expectations of that system's users. While these
    standards should be taken into consideration for the whole application, one of
    the most visible areas affected by them is the layout of the application menu
    (or menu bar, to use the standard terminology).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要平台都提供了标准，以指导开发者创建满足该系统用户期望的用户界面。虽然这些标准应考虑整个应用程序，但受其影响最明显的区域之一是应用程序菜单（或菜单栏，使用标准术语）的布局。
- en: Let's look at the standards available for each platform, which we'll refer to
    later in the chapter when we create a cross-platform main menu.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个平台可用的标准，我们将在本章创建跨平台主菜单时参考这些标准。
- en: Windows user experience interaction guidelines
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Windows用户体验交互指南
- en: Microsoft's *Windows user experience interaction guidelines*, available at [https://docs.microsoft.com/en-us/windows/win32/uxguide/guidelines](https://docs.microsoft.com/en-us/windows/win32/uxguide/guidelines),
    offer developers a wealth of information for designing applications that fit right
    in to the Windows desktop. Among many guidelines offered for menu bar design is
    a description of the standard menu items and how they should be arranged.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的*Windows用户体验交互指南*，可在[https://docs.microsoft.com/en-us/windows/win32/uxguide/guidelines](https://docs.microsoft.com/en-us/windows/win32/uxguide/guidelines)找到，为开发者提供了大量关于设计适合Windows桌面的应用程序的信息。在提供的许多关于菜单栏设计的指南中，包括对标准菜单项及其排列方式的描述。
- en: At the time of writing, Microsoft has just released newer guidelines aimed at
    Windows 11 and the Universal Windows Platform, available at [https://docs.microsoft.com/en-us/windows/apps/design/basics/](https://docs.microsoft.com/en-us/windows/apps/design/basics/).
    However, these newer guidelines do not offer specific guidance on menu structure,
    so we have used the older guidelines instead.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，微软刚刚发布了针对Windows 11和通用Windows平台的新指南，可在[https://docs.microsoft.com/en-us/windows/apps/design/basics/](https://docs.microsoft.com/en-us/windows/apps/design/basics/)找到。然而，这些新指南并没有提供关于菜单结构的具体指导，因此我们使用了较旧的指南。
- en: Apple's human interface guidelines
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 苹果公司的人机界面指南
- en: Apple's human interface guidelines are available at [https://developer.apple.com/macos/human-interface-guidelines/](https://developer.apple.com/macos/human-interface-guidelines/)
    and offer a detailed set of rules for creating macOS-friendly interfaces.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果公司的人机界面指南可在[https://developer.apple.com/macos/human-interface-guidelines/](https://developer.apple.com/macos/human-interface-guidelines/)找到，并提供了一套详细的规则，用于创建符合macOS的界面。
- en: While much of the basic advice for menu bar design is similar to that offered
    by Microsoft, the layout recommendations are quite different and much more specific.
    For example, the first cascade on a macOS application should be the App menu,
    a menu named after the application, which contains items like **About** and **Preferences**.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然菜单栏设计的基本建议与微软提供的类似，但布局建议却截然不同，并且更加具体。例如，macOS应用程序的第一个级联菜单应该是应用程序菜单，即以应用程序命名的菜单，其中包含**关于**和**首选项**等项。
- en: Linux and BSD human interface guidelines
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Linux和BSD人机界面指南
- en: In sharp contrast to Windows and macOS, Linux, BSD, and other X11 systems have
    no blessed default desktop environments or controlling entities to dictate UI
    standards. There are well over a dozen full desktop environments available for
    these platforms, each with its own goals and ideas about user interaction. While
    there are multiple projects working to create **human interface guidelines** (**HIG**)
    for these platforms, we'll be following the Gnome HIG from the Gnome project.
    This set of guidelines is used by the Gnome, MATE, and XFCE desktops and is available
    at [https://developer.gnome.org/hig/](https://developer.gnome.org/hig/). The Gnome
    desktop is the default desktop environment on many Linux distributions, including
    Red Hat, Ubuntu, and notably Debian, which is our target Linux environment at
    ABQ.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 与Windows和macOS形成鲜明对比的是，Linux、BSD和其他X11系统没有受到祝福的默认桌面环境或控制实体来规定UI标准。这些平台有十多个完整的桌面环境可供选择，每个都有其自己的目标和关于用户交互的想法。虽然有许多项目正在为这些平台创建**人机界面指南**（**HIG**），但我们将遵循Gnome项目制定的Gnome
    HIG。这组指南被Gnome、MATE和XFCE桌面使用，可在[https://developer.gnome.org/hig/](https://developer.gnome.org/hig/)找到。Gnome桌面是许多Linux发行版的默认桌面环境，包括Red
    Hat、Ubuntu，以及特别值得注意的是Debian，这是我们在ABQ的目标Linux环境。
- en: Menus and accelerator keys
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 菜单和加速键
- en: Accelerator keys are keyboard shortcuts assigned to common application actions,
    particularly menu items. Thus far, we've added no accelerator keys, which is bad
    for keyboard-only users.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 加速键是分配给常见应用程序操作的键盘快捷键，尤其是菜单项。到目前为止，我们还没有添加任何加速键，这对仅使用键盘的用户来说是不利的。
- en: In Tkinter, accelerator keys can be assigned to a widget using the `bind()`
    method. We can also use the `bind_all()` method, which can be called on any widget
    and effectively binds an event globally (that is, even if the widget that called
    `bind_all()` is not focused). Our menu items also take an `accelerator` argument,
    which can be used to specify a string that will be shown in the menu as an accelerator
    key hint.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tkinter中，可以使用`bind()`方法将加速键分配给小部件。我们还可以使用`bind_all()`方法，该方法可以在任何小部件上调用，并有效地全局绑定事件（即，即使调用`bind_all()`的小部件没有获得焦点）。我们的菜单项也接受一个`accelerator`参数，该参数可以用来指定将在菜单中显示的加速键提示字符串。
- en: The UI guidelines on each platform define standard accelerator keys for common
    actions, most of which are the same across platforms since they descend from the
    IBM **Common User Access** (**CUA**) standard established in the 1980s. The most
    notable difference is the use of the command (![](img/B17578_10_001.jpg)) key
    on macOS in place of the control (Ctrl) key used by Windows and Linux.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 每个平台的UI指南定义了常见操作的标准化加速键，其中大多数在平台上是相同的，因为它们源自20世纪80年代建立的IBM **通用用户访问**（**CUA**）标准。最显著的区别是macOS使用命令（![](img/B17578_10_001.jpg)）键代替Windows和Linux使用的控制（Ctrl）键。
- en: As we rewrite our application menus for cross-platform compatibility, we'll
    also add platform-appropriate accelerator keys.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在为跨平台兼容性重写我们的应用程序菜单时，我们还将添加适合平台的加速键。
- en: Cross-platform fonts
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨平台字体
- en: In *Chapter 9*, *Improving the Look with Styles and Themes*, we learned how
    easy it is to customize Tkinter's fonts to change the look and feel of your application.
    Doing so, however, can cause inconsistencies across platforms.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第9章*，*使用样式和主题改进外观*中，我们了解到如何轻松地自定义Tkinter的字体以改变应用程序的外观和感觉。然而，这样做可能会导致跨平台的不一致性。
- en: There are around 18 fonts that are shared between macOS and Windows, but not
    all of them look identical on both platforms. As for Linux, most distributions
    ship with none of those 18 fonts due to license issues.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 大约有18种字体在macOS和Windows之间共享，但它们在两个平台上并不完全相同。至于Linux，由于许可问题，大多数发行版都不包含这18种字体中的任何一种。
- en: Unless you can guarantee that a particular font is available on all supported
    platforms, it's best to avoid naming specific font families in your styles. Fortunately,
    if you do happen to specify a nonexistent font, Tkinter will just use the default,
    but even that could cause layout or readability issues in certain cases.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你能保证特定字体在所有支持的平台上都可用，否则最好避免在样式中使用特定的字体家族名称。幸运的是，如果你恰好指定了一个不存在的字体，Tkinter将只使用默认字体，但即使在某些情况下这也可能引起布局或可读性问题。
- en: To be safe, stick with Tkinter's named fonts, which are automatically set to
    the same defaults on each platform.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，请坚持使用Tkinter的命名字体，这些字体在每个平台上都自动设置为相同的默认值。
- en: Cross-platform theme support
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨平台主题支持
- en: As we saw in *Chapter 9*, *Improving the Look with Styles and Themes*, Ttk provides
    a number of themes that differ from platform to platform. Each platform contains
    an alias called "default", which points to the most sensible theme for that platform.
    Attempting to set a theme that doesn't exist results in an exception, so avoid
    hardcoding a theme setting in your application, and make sure theme choices are
    checked against the output of `Style.theme_names()`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第9章*中看到的，*使用样式和主题改进外观*，Ttk提供了一系列在不同平台上不同的主题。每个平台都包含一个名为“default”的别名，它指向该平台最合理的主题。尝试设置一个不存在的主题会导致异常，因此请避免在应用程序中硬编码主题设置，并确保主题选择与`Style.theme_names()`的输出进行核对。
- en: Window zoomed state
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 窗口缩放状态
- en: 'In addition to maximized and minimized windows, many windowing environments
    have the concept of a "zoomed" window, which takes over the screen completely.
    On Windows or macOS, it can be activated for a Tkinter application using the root
    window''s `state()` method, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最大化窗口和最小化窗口外，许多窗口环境还有一个“缩放”窗口的概念，它完全占据屏幕。在Windows或macOS上，可以通过使用根窗口的`state()`方法来激活Tkinter应用程序的缩放功能，如下所示：
- en: '[PRE20]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: On Windows or macOS, this creates a window that takes over the screen; on Linux
    or BSD, however, it raises an exception because X11 does not provide anything
    for setting a zoomed state.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows或macOS上，这会创建一个占据整个屏幕的窗口；然而，在Linux或BSD上，它会引发异常，因为X11没有提供设置缩放状态的功能。
- en: 'On X11, this is accomplished by turning on the root window''s `-zoomed` attribute
    as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在X11上，可以通过以下方式打开根窗口的`-zoomed`属性来实现：
- en: '[PRE21]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Unfortunately, the preceding code raises an exception on Windows and macOS.
    If you need to be able to set this state in a program, you'll need to use some
    platform-specific code.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，前面的代码在Windows和macOS上会引发异常。如果您需要在程序中设置此状态，您需要使用一些特定于平台的代码。
- en: Now that we've walked through a variety of cross-platform issues, let's take
    a look at ABQ Data Entry and see what we can do to improve its behavior across
    different operating systems.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经走过了一系列跨平台问题，让我们来看看ABQ数据输入，看看我们能为不同操作系统改进其行为做些什么。
- en: Improving our application's cross-platform compatibility
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高我们应用程序的跨平台兼容性
- en: 'Our application does pretty well across platforms, but there are some things
    we can do to improve it:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序在各个平台上表现相当不错，但我们还可以做一些事情来改进它：
- en: First, our application stores its preferences in the user's home folder, which
    is not ideal on any platform. Most desktop platforms define specific locations
    where configuration files should be placed, so we will fix our application to
    use those for the `abq_settings.json` file.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们的应用程序将首选项存储在用户的家目录中，这在任何平台上都不是最佳选择。大多数桌面平台定义了配置文件应放置的具体位置，因此我们将修复我们的应用程序以使用这些位置来存储`abq_settings.json`文件。
- en: Second, we're creating our CSV files without specifying any encoding; if a user
    inserted a Unicode character (say, in the `Notes` field), file saving would raise
    an exception and fail on non-Unicode platforms.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，我们在创建CSV文件时没有指定任何编码；如果用户插入了一个Unicode字符（比如在`Notes`字段中），文件保存将引发异常并在非Unicode平台上失败。
- en: Finally, the current menu structure does not really come close to following
    any of the human interface guidelines we've discussed. We'll implement separate
    menus for each platform to ensure users have a UI that is consistent with their
    platform.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，当前的菜单结构实际上并没有真正接近遵循我们所讨论的任何人类界面指南。我们将为每个平台实现独立的菜单，以确保用户有一个与其平台一致的UI。
- en: Let's get started!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Storing preferences correctly
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确存储首选项
- en: 'Each platform defines a proper location for storing user configuration files:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 每个平台定义了存储用户配置文件的适当位置：
- en: Linux and other X11 systems store configuration files in a location defined
    in the `$XDG_CONFIG_HOME` environment variable, which defaults to `$HOME/.config`
    if it's not defined.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux和其他X11系统将配置文件存储在由`$XDG_CONFIG_HOME`环境变量定义的位置，如果没有定义，则默认为`$HOME/.config`。
- en: macOS user configuration files are stored in `$HOME/Library/Application Support/`.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS用户配置文件存储在`$HOME/Library/Application Support/`。
- en: Windows user configuration files are stored in `%USERPROFILE%\AppData\Local`.
    Though if your environment uses **Active Directory** (**AD**) with roaming profiles,
    you might prefer to use `%HOME%\AppData\Roaming` instead.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows用户配置文件存储在`%USERPROFILE%\AppData\Local`。尽管如果你的环境使用带有漫游配置文件的**Active Directory**（**AD**），你可能更喜欢使用`%HOME%\AppData\Roaming`。
- en: To realize this in our application, we'll need to update the `SettingsModel`
    class. Remember that our `SettingsModel` class's initializer method currently
    places the configuration file in `Path.home()`, which returns the user's home
    directory on each platform. Let's update this with some platform-specific code.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的应用程序中实现这一点，我们需要更新`SettingsModel`类。记住，我们`SettingsModel`类的初始化方法目前将配置文件放置在`Path.home()`，它返回每个平台上的用户家目录。让我们用一些特定平台的代码来更新它。
- en: 'To begin, open `models.py` and import the `platform` module, like so:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开`models.py`并导入`platform`模块，如下所示：
- en: '[PRE22]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To figure out the directories required, we're going to need to get the name
    of the platform, as well as some environment variables. The `os.environ` variable
    is a dictionary containing the environment variables set on the system. Since
    we've already imported `os` into the `models.py` file, we can use `os.environ`
    to retrieve the variables we need.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定所需的目录，我们需要获取平台名称以及一些环境变量。`os.environ`变量是一个包含系统上设置的环境变量的字典。由于我们已经在`models.py`文件中导入了`os`，我们可以使用`os.environ`来检索我们需要的变量。
- en: 'In the `SettingsModel` class, we''ll create a dictionary for looking up the
    correct configuration directories, like so:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SettingsModel`类中，我们将创建一个字典来查找正确的配置目录，如下所示：
- en: '[PRE23]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In each case, we've matched a platform name with a `pathlib.Path` object pointing
    to the default configuration directory for each platform. Now, inside the `SettingsModel`
    initializer, we just need to look up the correct directory using the value of
    `platform.system()`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，我们都将一个平台名称与一个指向每个平台默认配置目录的`pathlib.Path`对象匹配。现在，在`SettingsModel`初始化器内部，我们只需要使用`platform.system()`的值来查找正确的目录。
- en: 'Update the `__init__()` method as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式更新`__init__()`方法：
- en: '[PRE24]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If the platform is not in our list, we simply default to `Path.home()` to place
    the configuration file in the user's home directory. Otherwise, the file should
    be placed correctly for the platform.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果平台不在我们的列表中，我们只需默认使用`Path.home()`将配置文件放置在用户的家目录中。否则，文件应该正确放置在平台上。
- en: Now when you run the application, you should find that any previous preferences
    are reset to the default (since we're now looking for the configuration file in
    a different location), and that if you save new preferences, the file `abq_settings.json`
    shows up in your platform's configuration directory.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你运行应用程序时，你应该会发现任何之前的偏好设置都被重置为默认设置（因为我们现在正在不同的位置查找配置文件），并且如果你保存新的偏好设置，文件`abq_settings.json`将出现在你的平台配置目录中。
- en: Specifying an encoding for our CSV file
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的CSV文件指定编码
- en: Our application is currently saving CSV files using the system's default encoding.
    This could be a problem for Windows users if they try to use Unicode characters.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序目前正在使用系统的默认编码保存CSV文件。如果Windows用户尝试使用Unicode字符，这可能会成为一个问题。
- en: 'In `models.py`, we need to locate the three instances of `open()` in our `CSVModel`
    class and specify an encoding, as in this example:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在`models.py`中，我们需要找到`CSVModel`类中的三个`open()`实例，并指定一个编码，如下例所示：
- en: '[PRE25]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Make sure to update all the `open()` calls in `models.py`, including those in
    `SettingsModel`. With this change, the Unicode characters should no longer be
    a problem.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 确保更新`models.py`中的所有`open()`调用，包括`SettingsModel`中的调用。有了这个更改，Unicode字符应该不再有问题。
- en: Making platform-appropriate menus
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建适合平台的菜单
- en: Creating platform-specific menus is going to be a bit more involved than the
    previous fixes. Our basic approach will be to create multiple menu classes and
    use a selector function to return an appropriate class as explained in the previous
    section.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 创建特定平台的菜单将比之前的修复更复杂。我们的基本方法将是创建多个菜单类，并使用选择函数返回适当的类，如前一小节所述。
- en: Before we can do this, we'll need to prepare our `MainMenu` class so that it's
    easier to subclass.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够这样做之前，我们需要准备我们的`MainMenu`类，使其更容易被继承。
- en: Preparing our MainMenu class
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备我们的`MainMenu`类
- en: Currently, the bulk of the configuration of our `MainMenu` class takes place
    in `__init__()`. For each platform, though, we're going to need to build the menu
    with a different structure, and with some different details for certain commands.
    To make this simpler, we're going to take a compositional approach, in which we'll
    break the menu creation into many discrete methods that we can then compose in
    each subclass as needed.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的`MainMenu`类的配置的大部分工作发生在`__init__()`中。然而，对于每个平台，我们都需要以不同的结构构建菜单，并且对于某些命令有一些不同的细节。为了使这更简单，我们将采取组合方法，其中我们将菜单创建分解为许多离散的方法，然后我们可以在每个子类中按需组合这些方法。
- en: 'The first thing we''ll do is change its name to explain its role more clearly:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是将其名称更改，以便更清楚地说明其作用：
- en: '[PRE26]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We've also created an empty `styles` dictionary as a class attribute. Since
    menu styles are not supported across all platforms well, this empty dictionary
    can act as a placeholder so that we can apply styles when desired by simply overriding
    this attribute.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个空的`styles`字典作为类属性。由于菜单样式并不是在所有平台上都得到很好的支持，这个空字典可以作为一个占位符，这样我们就可以通过简单地覆盖这个属性来在需要时应用样式。
- en: Next, we're going to create individual methods for creating each menu item.
    Because these items may be added to different menus depending on the platform,
    each method will take a `menu` argument that will be used to specify which `Menu`
    object it will be added to.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为创建每个菜单项创建单独的方法。因为这些项可能会根据平台的不同添加到不同的菜单中，所以每个方法都将接受一个`menu`参数，该参数将用于指定它将添加到哪个`Menu`对象。
- en: 'Let''s begin with methods for creating our **Select file** and **Quit** command
    entries:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建用于创建我们的**选择文件**和**退出**命令条目的方法开始：
- en: '[PRE27]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, create the methods to add the auto-fill settings options:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建添加自动填充设置选项的方法：
- en: '[PRE28]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For our font options that have their own sub-menus, we''ll create methods that
    create the whole sub-menu, like so:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们具有自己子菜单的字体选项，我们将创建创建整个子菜单的方法，如下所示：
- en: '[PRE29]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that we've used the `self.styles` dict in defining our cascade menus; although
    it's empty in this class, we want the styles to apply to all menus if we define
    them.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在定义级联菜单时使用了`self.styles`字典；尽管在这个类中它是空的，但我们希望如果定义了样式，它们将应用到所有菜单。
- en: 'For the themes menu, we''ll do the same, and also set up the trace that displays
    the warning message, as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主题菜单，我们将做同样的事情，并设置显示警告消息的跟踪，如下所示：
- en: '[PRE30]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, let''s add the last three methods for our navigation and About commands:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加用于导航和“关于”命令的最后三个方法：
- en: '[PRE31]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, to compose these methods into a menu, we'll create a new method called
    `_build_menu()`. This method can be overridden by our subclasses, leaving `__init__()`
    to take care of the common setup tasks.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了将这些方法组合成一个菜单，我们将创建一个新的方法，称为`_build_menu()`。此方法可以被我们的子类覆盖，而`__init__()`则负责处理常见的设置任务。
- en: 'To see how this will work, let''s create a version of this method that will
    recreate our generic menu:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这将如何工作，让我们创建一个将重新创建我们的通用菜单的方法版本：
- en: '[PRE32]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we're creating our File, Options, Go, and Help cascade menus, and passing
    each one to the appropriate item-adding methods to set up its items. We're storing
    these in a dictionary, `self._menus`, rather than as local variables. At the end
    of the method, we iterate through the dictionary to add each cascade to the main
    menu.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建我们的文件、选项、导航和帮助级联菜单，并将每个菜单传递给适当的项添加方法以设置其项。我们将这些存储在字典`self._menus`中，而不是作为局部变量。在方法末尾，我们遍历字典以将每个级联添加到主菜单。
- en: 'Now, we can reduce the initializer of this class to a bare skeleton of method
    calls, like so:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将这个类的初始化器简化为仅包含方法调用的骨架，如下所示：
- en: '[PRE33]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After calling the superclass initializer, this method just saves the settings,
    creates the icons and the `_menus` dictionary, then calls `_build_menu()`. If
    any styles are set, those are applied to the main menu by `self.configure()`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用超类初始化器后，此方法仅保存设置，创建图标和`_menus`字典，然后调用`_build_menu()`。如果设置了任何样式，则通过`self.configure()`将这些样式应用到主菜单。
- en: Adding accelerators
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加加速键
- en: Before we start building subclasses of `GenericMainMenu`, let's make it possible
    to add platform-specific accelerator keys to each menu. These are simply keyboard
    shortcuts that can activate our menu items. We don't need these for every menu
    item, just a few commands that will be commonly used.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建`GenericMainMenu`的子类之前，让我们使每个菜单能够添加特定于平台的加速键。这些只是可以激活我们的菜单项的键盘快捷键。我们不需要为每个菜单项都这样做，只需为一些常用命令添加即可。
- en: 'To create a key binding to menu items, there are two steps:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建菜单项的关键绑定，有两个步骤：
- en: Bind the keyboard event to the callback using the `bind_all()` method.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`bind_all()`方法将键盘事件绑定到回调函数。
- en: Label the menu item with the keyboard sequence using the menu entry's accelerator
    argument.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用菜单项的加速器参数用键盘序列标记菜单项。
- en: It's important to understand that we need to do both; the `accelerator` argument
    does not automatically set up the key binding, it just determines how the menu
    item will be labeled. Likewise, the `bind_all()` method will not cause menu items
    to be labeled, it will just create the event binding.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解我们需要做这两件事；`accelerator`参数不会自动设置键绑定，它只是决定了菜单项的标签。同样，`bind_all()`方法不会导致菜单项被标签化，它只会创建事件绑定。
- en: 'To accomplish both, we''ll create two class attribute dictionaries, one for
    the accelerators and one for the key bindings, like so:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这两项任务，我们将创建两个类属性字典，一个用于加速器，一个用于键绑定，如下所示：
- en: '[PRE34]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The first dictionary simply matches accelerator strings with keys that we can
    use in our menu definition methods. To use this dictionary, we just need to update
    those methods to include the accelerator; for example, update the `_add_file_open()`
    method like so:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字典只是将加速器字符串与我们可以用于我们的菜单定义方法中的键匹配。要使用此字典，我们只需要更新这些方法以包括加速器；例如，像这样更新`_add_file_open()`方法：
- en: '[PRE35]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Go ahead and add the `accelerator` argument to the `add_command()` calls in
    `_add_quit()`, `_add_go_record_list()`, and `_add_go_new_record()` as well.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 请继续在`_add_quit()`、`_add_go_record_list()`和`_add_go_new_record()`中的`add_command()`调用中添加`accelerator`参数。
- en: 'To handle the key bindings, we just need to create a method that will make
    the key bindings. Add this `_bind_accelerators()` method to the class:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理键绑定，我们只需要创建一个将创建键绑定的方法。将此`_bind_accelerators()`方法添加到类中：
- en: '[PRE36]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `_bind_accelerators()` method iterates the `keybinds` dictionary and binds
    each key sequence to a function created by the `_event()` method that will generate
    the given event. Note that we've used `bind_all()` here; unlike the `bind()` method,
    which only responds to events on the widget, the `bind_all()` method will cause
    the callback to be executed when the event is generated on *any* widget. Thus,
    regardless of what widget is selected or in focus, a Control + Q keystroke will
    quit the program, for example.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`_bind_accelerators()`方法遍历`keybinds`字典，并将每个键序列绑定到由`_event()`方法创建的函数，该函数将生成给定的事件。请注意，我们在这里使用了`bind_all()`；与只对小部件上的事件做出响应的`bind()`方法不同，`bind_all()`方法将在任何小部件上生成事件时执行回调。因此，无论选择或聚焦的是哪个小部件，Control
    + Q快捷键都会退出程序，例如。'
- en: 'The final piece is to call this new method from our initializer. Add this to
    the end of `GenericMainMenu.__init__()`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分是从我们的初始化器中调用这个新方法。将以下内容添加到`GenericMainMenu.__init__()`的末尾：
- en: '[PRE37]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now the `GenericMainMenu` class is ready for subclassing. Let's go through one
    platform at a time and figure out what needs to be updated.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`GenericMainMenu`类已准备好进行子类化。让我们一次处理一个平台，找出需要更新的内容。
- en: Building the Windows menu
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建Windows菜单
- en: 'After studying the *Windows user experience interaction guidelines*, you deem
    the following changes are necessary to make our menu Windows-friendly:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习完*Windows用户体验交互指南*后，你认为以下更改是使我们的菜单Windows友好的必要步骤：
- en: '**File** | **Quit** should be changed to **File** | **Exit**, and there should
    be no accelerator for it. Windows uses Alt + F4 to close programs, and this is
    handled by Windows automatically.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件** | **退出**应改为**文件** | **退出**，并且不应为其设置加速器。Windows使用Alt + F4来关闭程序，这由Windows自动处理。'
- en: Windows can handle commands in the menu bar just fine, and the guidelines encourage
    this for frequently used functionality. We'll move our Record List and New Record
    commands directly to the main menu. We'll have to remove the icons, though, since
    it can't handle icons in the main menu.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows可以很好地处理菜单栏中的命令，并且指南鼓励这样做以用于常用功能。我们将直接将我们的记录列表和新记录命令移动到主菜单。不过，我们必须移除图标，因为主菜单无法处理图标。
- en: Configuration option items are supposed to go under a Tools menu, separated
    from the rest of the items in tools (if there are any). We'll need to create a
    Tools menu and move our options there.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置选项项应放在工具菜单下，与工具中的其他项（如果有）分开。我们需要创建一个工具菜单并将我们的选项移到那里。
- en: 'Let''s implement these changes and create our Windows menu class. Start by
    subclassing the `GenericMainMenu` class like so:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实施这些更改并创建我们的Windows菜单类。首先，像这样对`GenericMainMenu`类进行子类化：
- en: '[PRE38]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The first thing we''ll do is override the initializer so we can remove the
    keybinding for **File** | **Exit**:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将重写初始化器，以便我们可以删除 **文件** | **退出** 的快捷键绑定：
- en: '[PRE39]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we''ll need to override the `_add_quit()` method to relabel it and remove
    the accelerator:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要重写 `_add_quit()` 方法以重新标记它并删除加速键：
- en: '[PRE40]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We need to remove the icons for the two navigation commands, so that we don''t
    have the **(Image)** string showing up in our menu. To do that, we''ll next override
    the `_create_icons()` method, as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要删除两个导航命令的图标，这样我们菜单中就不会出现 **(Image)** 字符串。为此，我们将接下来重写 `_create_icons()` 方法，如下所示：
- en: '[PRE41]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The superclass version of the method creates `self.icons`, so we just need to
    run it and delete the icons we don't want.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的超类版本创建了 `self.icons`，所以我们只需运行它并删除我们不需要的图标。
- en: 'Now that those are fixed, we can create the `_build_menu()` method to compose
    our menu, starting with the three cascades like so:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些问题都解决了，我们可以创建 `_build_menu()` 方法来组合我们的菜单，从以下三个级联开始：
- en: '[PRE42]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Since we''d like to add our navigation command entries for Record List and
    NewRecord directly to the main menu rather than to a cascade menu, we can''t just
    iterate over the `_menus` dictionary to add the cascades. Instead, we''ll have
    to manually add the entries to the top-level menu, like so:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望将导航命令条目（记录列表和新记录）直接添加到主菜单而不是级联菜单中，我们无法简单地遍历 `_menus` 字典来添加级联。相反，我们必须手动将条目添加到顶级菜单中，如下所示：
- en: '[PRE43]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The Windows menu is now complete and ready to use. Let's move on to the next
    platform!
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 菜单现在已完整并准备好使用。让我们继续到下一个平台！
- en: Building the Linux menu
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建 Linux 菜单
- en: 'Our `GenericMainMenu` class is pretty close to the Gnome HIG, but there is
    one change to be made: our Options menu doesn''t really belong; rather, we need
    to split its items into two categories:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `GenericMainMenu` 类与 Gnome HIG 非常接近，但需要做出一个修改：我们的选项菜单实际上并不合适；相反，我们需要将其项目分为两个类别：
- en: The autofill options, since they change the way data is entered in the form,
    belong in an Edit menu.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动填充选项，因为它们改变了表单中数据输入的方式，应属于编辑菜单。
- en: The font and theme options, since they only change the appearance of the application
    and not the actual data, belong in a View menu.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体和主题选项，因为它们只改变应用程序的外观而不改变实际数据，应属于视图菜单。
- en: Since Linux also fully supports menu colors, we'll add our color styles back
    to this version of the menu.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Linux 也完全支持菜单颜色，我们将把颜色样式添加回这个版本的菜单。
- en: 'Let''s start by subclassing `GenericMainMenu` and defining some styles:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从子类化 `GenericMainMenu` 并定义一些样式开始：
- en: '[PRE44]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: These menu styles aren't strictly necessary, but if we're going to make a separate
    menu for Linux, we may as well take advantage of some of its features!
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这些菜单样式并非绝对必要，但如果我们要为 Linux 创建一个单独的菜单，那么充分利用其一些特性也是可以的！
- en: 'Now let''s begin the `_build_menu()` method with the File and Edit menus:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从文件和编辑菜单开始 `_build_menu()` 方法：
- en: '[PRE45]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note that we''ve added back `**self.styles` to each `Menu()` call to apply
    the styles. We''ll do the same building the next three cascades, as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经将 `**self.styles` 添加回每个 `Menu()` 调用以应用样式。我们将在构建下一个三个级联时做同样的事情，如下所示：
- en: '[PRE46]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we''ll iterate over the `_menus` dictionary and add all the cascades:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将遍历 `_menus` 字典并添加所有级联：
- en: '[PRE47]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We don't need to change anything else; our accelerators and the rest of the
    menu line up pretty well with the Gnome HIG.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要做其他任何更改；我们的加速键和菜单的其他部分与 Gnome HIG 非常匹配。
- en: Building the macOS menu
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建 macOS 菜单
- en: Of the three platform-specific menus, the macOS menu will need the most extensive
    changes. Unlike the Windows and Gnome guidelines, which mostly suggest categories,
    the Apple guidelines are very specific about which menus should be created and
    which items belong in them. Furthermore, macOS also creates and pre-populates
    some of these menus with default commands, so we'll need to use special arguments
    to hook into those menus and add our own items.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三个特定平台的菜单中，macOS 菜单需要最多的更改。与 Windows 和 Gnome 指南主要建议类别不同，Apple 指南非常具体地说明了哪些菜单应该创建以及哪些项目属于它们。此外，macOS
    还创建并预先填充了一些这些菜单的默认命令，因此我们需要使用特殊参数来钩入这些菜单并添加我们自己的项目。
- en: 'The changes we need to make to comply with Apple''s HIG are as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做出的更改以符合 Apple 的 HIG 如下：
- en: We need to create an **App menu**. This is the first menu macOS creates, just
    to the right of the Apple icon on the menu bar. It's created by default, but we'll
    need to hook into it to add some custom items.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要创建一个**应用程序菜单**。这是 macOS 创建的第一个菜单，位于菜单栏中苹果图标右侧。它默认创建，但我们需要将其钩入以添加一些自定义项。
- en: The About command belongs in the App menu; we'll move it there and remove the
    unused Help menu.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于命令属于应用程序菜单；我们将将其移动到那里并删除未使用的帮助菜单。
- en: Since macOS will provide a Quit command for us, we'll remove ours.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于macOS将为我们提供一个退出命令，我们将移除我们的。
- en: As we did with the Linux menu, our options will be split between the Edit and
    View menus.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们在Linux菜单中所做的那样，我们的选项将在编辑和查看菜单之间分配。
- en: We need to add a Window menu; this is another autogenerated menu that macOS
    fills with window management and navigation functions. Our navigation items will
    be moved from the Go menu to this menu.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要添加一个窗口菜单；这是macOS填充窗口管理和导航功能的另一个自动生成的菜单。我们的导航项将从“转到”菜单移动到这个菜单。
- en: Finally, macOS uses the command key rather than the Control key to activate
    accelerators. We need to update both our key bindings and accelerator dictionaries
    accordingly.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，macOS使用命令键而不是控制键来激活加速器。我们需要相应地更新我们的键绑定和加速器字典。
- en: 'As before, we''ll start by creating a subclass of `GenericMainMenu`:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将从创建`GenericMainMenu`的子类开始：
- en: '[PRE48]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first thing we've done is redefine the `keybinds` and `accelerators` dictionaries
    to remove the `Quit` entries and change "`Control`" `to` "`Command`". Note that,
    when the menu displays, Tkinter will automatically replace the strings `Command`
    or `Cmd` with the symbol for the command key (![](img/B17578_10_0011.jpg)), so
    make sure to use one or the other when specifying accelerators.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情是重新定义`keybinds`和`accelerators`字典，移除`Quit`条目并将"`Control`"改为"`Command`"。请注意，当菜单显示时，Tkinter会自动将字符串`Command`或`Cmd`替换为命令键的符号（![img/B17578_10_0011.jpg]），所以当你指定加速器时，确保使用其中一个。
- en: 'Now, let''s start working on the `_build_menu()` method, as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始工作于`_build_menu()`方法，如下所示：
- en: '[PRE49]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The first order of business is the App menu. To access this built-in menu, all
    we need to do is pass in a `name` argument set to `apple` when we create the `Menu`
    object. The App menu should contain both our About option and our Quit option,
    but we only need to add the former since macOS automatically adds a Quit action.
    Note that we've also added a separator, which should always be added after the
    About command.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项任务是应用程序菜单。要访问这个内置菜单，我们只需要在创建`Menu`对象时传递一个设置为`apple`的`name`参数。应用程序菜单应包含我们的关于选项和退出选项，但我们只需要添加前者，因为macOS会自动添加退出操作。请注意，我们还在关于命令后添加了一个分隔符，这应该总是添加在关于命令之后。
- en: The App menu should *always* be the first menu you add to the main menu on macOS.
    If you add anything else first, your customized app menu items will be added in
    their own menu rather than in the generated App menu.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序菜单应该*始终*是你在macOS主菜单中添加的第一个菜单。如果你先添加其他任何内容，你的自定义应用程序菜单项将添加到它们自己的菜单中，而不是生成的应用程序菜单中。
- en: 'Before moving on, we need to make one correction to our About command. Apple''s
    HIG specifies that this command should read *About <program name>* rather than
    just *About*. So, we''ll need to override `_add_about()` to correct this, like
    so:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要对我们的关于命令进行一个修正。苹果的HIG指定这个命令应该读作*关于<程序名称>*而不是仅仅*关于*。因此，我们需要覆盖`_add_about()`来纠正这一点，如下所示：
- en: '[PRE50]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Your App menu will currently read "Python" rather than "ABQ Data Entry". We'll
    address this when we package our application in *Chapter 16*, *Packaging with
    setuptools and cxFreeze*.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序菜单目前会显示为"Python"而不是"ABQ数据输入"。我们将在第16章*使用setuptools和cxFreeze打包*中解决这个问题。
- en: 'After the App menu is created, let''s create our File, Edit, and View menus,
    like so:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建应用程序菜单之后，让我们创建我们的文件、编辑和查看菜单，如下所示：
- en: '[PRE51]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We don''t really need to do anything different there; however, the `Window`
    menu is another automatically generated menu created by macOS, so we will once
    again need to use the `name` argument when creating it:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上不需要在那里做任何不同的事情；然而，`Window`菜单是macOS创建的另一个自动生成的菜单，因此我们再次需要在创建它时使用`name`参数：
- en: '[PRE52]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, let''s iterate over the `_menus` dictionary and add all the cascades:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们遍历`_menus`字典并添加所有级联菜单：
- en: '[PRE53]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Even though macOS automatically creates the App and Window menus, you still
    need to explicitly add the `Menu` objects to the main menu using `add_cascade()`,
    or your added items will not appear on the automatically created menu.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管macOS会自动创建应用程序和窗口菜单，但你仍然需要显式地使用`add_cascade()`方法将`Menu`对象添加到主菜单中，否则你添加的项目将不会出现在自动创建的菜单中。
- en: That completes our macOS menu class.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的macOS菜单类。
- en: Creating and using our selector function
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和使用我们的选择函数
- en: 'With our classes created, let''s add a simple selector function to return the
    appropriate class for each platform; add this code to `mainmenu.py`:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了我们的类之后，让我们添加一个简单的选择器函数来为每个平台返回适当的类；将以下代码添加到 `mainmenu.py` 中：
- en: '[PRE54]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The keys in this dictionary are the output strings from `platform.system()`,
    which we have pointed to a platform-appropriate menu class. In the event we're
    running on some new, unknown system, we default to the `GenericMainMenu` class.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字典中的键是 `platform.system()` 的输出字符串，我们将它们指向适当的平台菜单类。如果我们运行在一些新的、未知系统上，我们将默认使用
    `GenericMainMenu` 类。
- en: 'Now, back in `application.py`, we''ll change our import statement from `mainmenu`
    to only import this function, like so:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到 `application.py`，我们将更改我们的导入语句，从 `mainmenu` 只导入这个函数，如下所示：
- en: '[PRE55]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note that we've also imported `platform`, which we'll use to determine the running
    operating system.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还导入了 `platform`，我们将使用它来确定正在运行的操作系统。
- en: 'Now, instead of calling `v.MainMenu()` (which no longer exists), we use the
    following function:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再调用 `v.MainMenu()`（它已不存在），而是使用以下函数：
- en: '[PRE56]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now when you run the application, your menu appearance will change according
    to the platform. On Windows, you should see something like this:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您运行应用程序时，您的菜单外观将根据平台而改变。在 Windows 上，您应该看到类似如下内容：
- en: '![Figure 10.4: The menu system on a Windows computer](img/B17578_10_04.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4：Windows 电脑上的菜单系统](img/B17578_10_04.png)'
- en: 'Figure 10.4: The menu system on a Windows computer'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4：Windows 电脑上的菜单系统
- en: 'On macOS, you''ll see something like this:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，您将看到类似如下内容：
- en: '![Figure 10.5: The menu system on macOS](img/B17578_10_05.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5：macOS 上的菜单系统](img/B17578_10_05.png)'
- en: 'Figure 10.5: The menu system on macOS'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5：macOS 上的菜单系统
- en: 'On Linux or BSD, you''ll see a menu as shown in the following screenshot:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 或 BSD 上，您将看到如下截图所示的菜单：
- en: '![Figure 10.5: The menu system on Ubuntu Linux](img/B17578_10_06.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5：Ubuntu Linux 上的菜单系统](img/B17578_10_06.png)'
- en: 'Figure 10.6: The menu system on Ubuntu Linux'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6：Ubuntu Linux 上的菜单系统
- en: Summary
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to write Python software that works well across
    multiple platforms. You learned how to avoid common platform pitfalls in Python
    code such as filesystem differences and library support, and how to write software
    that intelligently adapts to the needs of different operating systems. You also
    learned about published guidelines that help developers write software that meets
    platform users' expectations, and you used these guidelines to create platform-specific
    menus for ABQ Data Entry.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何编写跨多个平台工作的 Python 软件。您学习了如何在 Python 代码中避免常见的平台陷阱，例如文件系统差异和库支持，以及如何编写能够智能适应不同操作系统需求的软件。您还了解了有助于开发者编写满足平台用户期望的软件的已发布指南，并使用这些指南为
    ABQ 数据录入创建了特定平台的菜单。
- en: In the next chapter, we're going to learn about automated testing. You'll learn
    to write tests that ensure your code works correctly, both for regular Python
    code and specifically for Tkinter code, and to take advantage of the testing framework
    included in the Python standard library.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于自动化测试的内容。您将学习编写确保代码正确工作的测试，无论是常规 Python 代码还是特定于 Tkinter 的代码，并利用
    Python 标准库中包含的测试框架。
