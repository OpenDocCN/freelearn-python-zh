- en: Interacting with Buttons
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与按钮交互
- en: This chapter will introduce you to methods of interacting with the buttons and
    touchpads that come with the Adafruit Circuit Playground Express. You will learn
    how to detect whether a button is being pressed and you will also explore more
    advanced topics, such as fine tuning the sensitivity of capacitive touchpads.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍与Adafruit Circuit Playground Express配备的按钮和触摸板进行交互的方法。您将学习如何检测按钮是否被按下，并且还将探索更高级的主题，例如微调电容触摸板的灵敏度。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Detecting push button presses
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测按下按钮
- en: Controlling LEDs with push buttons
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用按下按钮控制LED
- en: Reading a slide switch
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取滑动开关
- en: Calling functions on the button state change
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在按钮状态更改时调用函数
- en: Moving active LEDs with push buttons
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用按下按钮移动活动LED
- en: Playing a beep on the button press
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下按钮时播放蜂鸣声
- en: Detecting touch on a touchpad
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测触摸板上的触摸
- en: Monitoring the touchpad raw measurements
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视触摸板的原始测量值
- en: Adjusting the touch threshold
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整触摸阈值
- en: The Adafruit Circuit Playground Express layout
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Adafruit Circuit Playground Express布局
- en: 'The following photograph displays the locations of the two push buttons, labeled
    A and B, that come with the board:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下照片显示了标有A和B的两个按下按钮的位置：
- en: '![](assets/218effcf-eb72-4d4b-9d79-22da608a3f65.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/218effcf-eb72-4d4b-9d79-22da608a3f65.png)'
- en: Courtesy of adafruit.com
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由adafruit.com提供
- en: 'The following photograph shows the location of the slide switch on the device:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下照片显示了设备上滑动开关的位置：
- en: '![](assets/654587b7-181c-48c5-be45-6e3d7f9b9d2b.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/654587b7-181c-48c5-be45-6e3d7f9b9d2b.png)'
- en: Courtesy of adafruit.com
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由adafruit.com提供
- en: 'The following photograph shows the location of the seven capacitive touchpads
    on the board:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下照片显示了板上七个电容触摸板的位置：
- en: '![](assets/1d427f3e-82fd-4e6f-b431-d853f833347e.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1d427f3e-82fd-4e6f-b431-d853f833347e.png)'
- en: Courtesy of adafruit.com
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由adafruit.com提供
- en: Each touchpad contains a different material that can conduct electricity. Alligator
    clips can be used to connect these materials to the pads. Additionally, metals,
    water, and fruits can conduct electricity well enough to be used as connectors
    to the pads.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个触摸板都包含可以导电的不同材料。鳄鱼夹可以用来连接这些材料到触摸板。此外，金属、水和水果都可以导电，足以用作连接器连接到触摸板。
- en: Now, let's take a look at how to detect the press of a button.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何检测按钮的按下。
- en: Detecting push button presses
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测按下按钮
- en: In this recipe, we will learn how to create a program that will print a message
    when the push button is pressed. Push buttons are a great way to create user interaction
    on your devices. This board comes with two push buttons, A and B, so you can create
    all sorts of different interactions with your users by reading and responding
    to push button events.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将学习如何创建一个程序，当按下按钮时将打印一条消息。按下按钮是在设备上创建用户交互的好方法。该板配有两个按下按钮A和B，因此您可以通过读取和响应按下按钮事件来创建各种不同的用户交互。
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL才能运行本配方中提供的代码。
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s perform the following steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'First, run the following lines of code in the REPL. The value of `cpx.button_a` is
    `False` here because the button is not pressed:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在REPL中运行以下代码行。这里`cpx.button_a`的值是`False`，因为按钮没有被按下：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Keep push button A pressed while you run the following code block. This will
    change the value to `True`:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行以下代码块时，保持按下按钮A。这将把值更改为`True`：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, add the following code to the `main.py` file and this will repeatedly
    print the state of push button A on execution:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下代码添加到`main.py`文件中，这将在执行时重复打印按下按钮A的状态：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first line of code imports the Circuit Playground Express library. The `cpx`
    object exposes a property called `button_a`. This property will return `True`
    when the button is pressed, and it will return `False` when the button is not
    pressed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码导入了Circuit Playground Express库。`cpx`对象公开了一个名为`button_a`的属性。当按钮被按下时，此属性将返回`True`，当按钮未被按下时，它将返回`False`。
- en: The script loops forever with a 50 millisecond delay between each loop. The
    state of the button press is continually printed. When running this program, hold
    and release the push button to see the printed output change.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本循环运行，每个循环之间延迟50毫秒。按钮按下的状态不断打印。运行此程序时，按住并释放按钮，以查看打印输出的变化。
- en: Note that there is another property called `button_b`, which serves the same
    function but for push button B instead.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，还有另一个名为`button_b`的属性，它具有相同的功能，但用于按下按钮B。
- en: There's more...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The interface for interacting with the push button in Python is very straightforward.
    Essentially, it translates to a Boolean value, which you can inspect at any time
    during your script execution in order to check the current state of the button.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中与按下按钮交互的界面非常简单。基本上，它转换为一个布尔值，您可以在脚本执行期间的任何时间检查以检查按钮的当前状态。
- en: This polling model of repeatedly checking the button state works well in simple
    scenarios. However, it proves to be problematic when you want to perform a single
    action for each button press, as opposed to continually pressing the button. This
    is similar to how you would expect to interact with a keyboard on a desktop. In
    this scenario, you expect that one physical key press will translate into an action
    being applied once. On the other hand, a physical key press that is held down
    for an extended period of time usually produces repeated key actions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的情况下，反复检查按钮状态的轮询模型效果很好。然而，当您想要对每次按下按钮执行单个操作时，而不是持续按下按钮时，它会出现问题。这类似于您期望在桌面上与键盘交互的方式。在这种情况下，您期望一个物理按键按下将转换为一次应用的动作。另一方面，长时间按下的物理按键通常会产生重复的按键动作。
- en: On most operating systems, a delay of 500 milliseconds or so is applied before
    the key is released, where it is considered as a **repeat key action**. It is
    important to bear these details in mind when you are trying to implement code
    that interacts with the push buttons in a natural and intuitive way.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数操作系统上，在释放按键之前会应用大约500毫秒的延迟，这被视为**重复按键操作**。当您尝试实现与按键自然和直观交互的代码时，牢记这些细节是很重要的。
- en: See also
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'You can find out more information here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到更多信息：
- en: Further documentation on the `button_a` property can be found at [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.button_a](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.button_a).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`button_a`属性的更多文档可以在[https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.button_a](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.button_a)找到。
- en: An example of interacting with push buttons can be found at [https://learn.adafruit.com/circuitpython-made-easy-on-circuit-playground-express/buttons](https://learn.adafruit.com/circuitpython-made-easy-on-circuit-playground-express/buttons).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://learn.adafruit.com/circuitpython-made-easy-on-circuit-playground-express/buttons](https://learn.adafruit.com/circuitpython-made-easy-on-circuit-playground-express/buttons)找到与按键交互的示例。
- en: Controlling LEDs with push buttons
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用按钮控制LED
- en: In this recipe, we will learn how to control two separate NeoPixels with two
    independent push buttons. This is a fun and simple way of creating interactivity
    with your device. Here, you will get immediate feedback from the board the moment
    you press each push button, as the pixels will light up in response.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用两个独立的按钮控制两个单独的NeoPixels。这是一种有趣而简单的方式，可以使您的设备具有交互性。在这里，您将在按下每个按钮时立即从板上获得反馈，因为像素会做出响应而亮起。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL才能运行本示例中提供的代码。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s perform the following steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'First, run the following lines of code in the REPL:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在REPL中运行以下代码行：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Keep push button A pressed while you run the following code block. You should
    see pixel 2, which is located right next to the push button, light up green:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行以下代码块时，保持按下按钮A。您应该会看到紧挨着按钮的像素2变成绿色：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Release push button A and run the following code block; you should now see
    pixel 2 turn off:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放按钮A并运行以下代码块；现在应该看到像素2关闭：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following code to the `main.py` file and it will turn pixel 2 and pixel
    7 *on*, depending on whether push button A or push button B is being pressed:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`main.py`文件中，它将根据按下按钮A或按钮B来打开像素2和像素7：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The first line of code imports the Circuit Playground Express library. The constants
    for the green and black color are defined and the pixel brightness is then set
    to a comfortable level.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一行导入了Circuit Playground Express库。定义了绿色和黑色的常量，并将像素亮度设置为舒适的水平。
- en: Then, an infinite loop is started, which executes two lines of code on each
    iteration. The first line will set the color of pixel 2 to green if push button
    A is pressed, otherwise, it will set the pixel to off. The second line will set
    the color of pixel 7 to green if push button B is pressed, otherwise, it will
    set the pixel to off.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，启动一个无限循环，每次迭代执行两行代码。如果按下按钮A，则第一行将把像素2的颜色设置为绿色，否则将关闭像素。第二行将把像素7的颜色设置为绿色，如果按下按钮B，则将关闭像素。
- en: There's more...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In contrast to the first recipe in this chapter, there is no call to the `sleep`
    function to cause a delay between each loop. In this specific recipe, there is
    a reason why no delay is needed between each time the button state is polled.
    If one of the buttons is held down, then one of the lights will turn on and stay
    on without an issue.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章第一个示例相比，在每次循环之间没有调用`sleep`函数来引起延迟。在这个特定的示例中，之所以不需要在轮询按钮状态之间设置延迟，是有原因的。如果其中一个按钮被按住，那么其中一个灯将打开并保持打开，而不会出现问题。
- en: In the case of the first recipe, a flood of print statements will occur while
    the button is being pressed. It is important to look at each scenario carefully
    to decide whether a delay is required between each poll.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，当按下按钮时将会出现大量的打印语句。仔细观察每种情况，以决定是否需要在每次轮询之间设置延迟。
- en: See also
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'You can find out more information here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到更多信息：
- en: More documentation on conditional expressions can be found at [https://docs.python.org/3/reference/expressions.html#conditional-expressions](https://docs.python.org/3/reference/expressions.html#conditional-expressions).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关条件表达式的更多文档可以在[https://docs.python.org/3/reference/expressions.html#conditional-expressions](https://docs.python.org/3/reference/expressions.html#conditional-expressions)找到。
- en: Further details on how push buttons work can be found at [https://sciencing.com/push-switches-work-electrical-circuit-5030234.html](https://sciencing.com/push-switches-work-electrical-circuit-5030234.html).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关按钮如何工作的更多详细信息，请访问[https://sciencing.com/push-switches-work-electrical-circuit-5030234.html](https://sciencing.com/push-switches-work-electrical-circuit-5030234.html)。
- en: Reading a slide switch
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取滑动开关
- en: In this recipe, we will learn how to create a program that will repeatedly print
    whether a slide switch is on or off. Slide switches have their own strengths,
    and this recipe will demonstrate how you can incorporate one into your project.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何创建一个程序，该程序将重复打印滑动开关是打开还是关闭。滑动开关有其自身的优势，这个示例将演示如何将其纳入您的项目中。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL才能运行本示例中提供的代码。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s perform the following steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'Ensure that the slide switch is flipped to the left-hand side. Run the following
    lines of code in the REPL:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将滑动开关翻转到左侧。在REPL中运行以下代码行：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Change the slide switch to be flipped to the right-hand side. Run the following
    code block:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将滑动开关翻转到右侧。运行以下代码块：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the following code to the `main.py` file and it will repeatedly print the
    state of the slide switch on execution. Turn the slide switch to the left and
    right to observe the change in output:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`main.py`文件中，它将在执行时重复打印滑动开关的状态。将滑动开关向左和向右转动，观察输出的变化：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The first line of code imports the Circuit Playground Express library. The `cpx`
    object exposes a property called `switch`. This property will return `True` when
    the switch is in the left position, and `False` when it is in the right position.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码导入了Circuit Playground Express库。`cpx`对象公开了一个名为`switch`的属性。当开关处于左侧位置时，此属性将返回`True`，当开关处于右侧位置时，将返回`False`。
- en: The script loops forever with a 50 millisecond delay between each loop. The
    state of the slide switch is continually printed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本将无限循环，每个循环之间有50毫秒的延迟。滑动开关的状态将不断打印。
- en: There's more...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Push buttons are great for applying an action repeatedly, or when you want to
    register a single button press. Slide switches, however, are more suitable when
    you want people to be able to specify between two operating modes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 按下按钮非常适合重复应用动作，或者当您希望注册单次按钮按下时。然而，滑动开关更适合当您希望人们能够在两种操作模式之间进行选择时。
- en: For instance, you might have a project that has two animation modes that can
    be selected with a slide switch. You could use the slide switch to enable or disable
    an alarm sound in your project. Depending on the user action, a slide switch or
    push button might be more appropriate.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可能有一个项目，其中有两种动画模式可以使用滑动开关进行选择。您可以使用滑动开关来启用或禁用项目中的警报声音。根据用户的操作，滑动开关或按钮可能更合适。
- en: The good thing about the Circuit Playground Express is that both options are
    available, so you can pick and choose which one works best for you.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Circuit Playground Express的好处在于两种选项都可用，因此您可以选择最适合您的选项。
- en: See also
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'You can find out more information here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到更多信息：
- en: Further documentation on the switch property can be found at [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.switch](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.switch).
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关开关属性的更多文档可以在[https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.switch](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.switch)找到。
- en: An explanation of how common types of switches work can be found at [https://learn.sparkfun.com/tutorials/switch-basics/all](https://learn.sparkfun.com/tutorials/switch-basics/all).
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://learn.sparkfun.com/tutorials/switch-basics/all](https://learn.sparkfun.com/tutorials/switch-basics/all)找到关于常见类型开关工作原理的解释。
- en: Calling functions on the button state change
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在按钮状态改变时调用函数
- en: In this recipe, we will learn how to call a function when the state of a button
    has changed. It is a common requirement that you only want an action to be performed
    when a button has a state change, as opposed to while the button is pushed down.
    This recipe demonstrates one technique that you can use to implement this requirement
    in your project.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将学习如何在按钮状态发生变化时调用函数。通常要求仅在按钮状态发生变化时执行操作，而不是在按钮被按下时执行操作。本文演示了一种您可以在项目中实现此要求的技术。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL来运行本文中提供的代码。
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s perform the following steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'First, run the following lines of code in the REPL:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在REPL中运行以下代码行：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will define the `button_change` function, which will be called each time
    a change has occurred in the button state. Run the following code and then repeatedly
    press and release push button A:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将定义`button_change`函数，每次按钮状态发生变化时都会调用该函数。运行以下代码，然后重复按下和释放按钮A：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The code that follows combines all the code shown in this recipe to make one
    complete program. Add this to the `main.py` file; it will print a message each
    time push button A is pressed or released:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的代码将结合本文中展示的所有代码，制作一个完整的程序。将其添加到`main.py`文件中；每次按下或释放按钮A时，它都会打印一条消息：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `button_change` function is defined, which will be called each time the
    state of the button changes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了`button_change`函数，每次按钮状态改变时都会调用该函数。
- en: The `last` global variable will be used to keep track of the last state of the
    button. Then, an infinite loop is started, which will check whether the current
    state of the button differs from its last state. If it has detected a change,
    then it will call the `button_change` function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`last`全局变量将用于跟踪按钮的上一个状态。然后，启动一个无限循环，它将检查按钮的当前状态是否与其上一个状态不同。如果检测到变化，它将调用`button_change`函数。'
- en: Finally, the latest button state is saved in the `last` variable whenever it
    changes. This script essentially implements an event loop that detects button
    press events and calls the `button_change` event handler to handle these events
    whenever they are detected.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每当按钮状态发生变化时，最新的按钮状态都将保存在`last`变量中。该脚本实际上实现了一个事件循环，用于检测按钮按下事件，并在检测到这些事件时调用`button_change`事件处理程序来处理这些事件。
- en: There's more...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Occasionally, you might want to register a button press as a single event regardless
    of whether the user holds the button down for a long or short period of time.
    This recipe achieves that goal by keeping track of the previous state of the button
    and only calling the event handler once, as the result of a button press.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，您可能希望将按钮按下注册为单个事件，而不管用户按下按钮的时间长短。这个方法通过跟踪按钮的先前状态并仅在按钮按下的结果时调用事件处理程序来实现这一目标。
- en: Even though you have the extra step of tracking the last state of a button,
    the benefit of this approach is that you don't have to fiddle with the timing
    of delays between polling for key presses, or the timing of repeated keyboard
    delays. This recipe is just another viable approach to solve the problem of when
    and how to respond to physical button interactions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您需要跟踪按钮的最后状态这一额外步骤，但这种方法的好处在于您不必在轮询按键的延迟时间或重复键盘延迟的时间上纠缠。这个方法只是解决如何响应物理按钮交互的另一种可行方法。
- en: See also
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'You can find out more information here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到更多信息：
- en: A good example of an event loop and event handlers can be found at [https://docs.python.org/3/library/cmd.html](https://docs.python.org/3/library/cmd.html).
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://docs.python.org/3/library/cmd.html](https://docs.python.org/3/library/cmd.html)找到事件循环和事件处理程序的很好的示例。
- en: An example of responding to button presses can be found at [https://learn.adafruit.com/sensor-plotting-with-mu-and-circuitpython/buttons-and-switch](https://learn.adafruit.com/sensor-plotting-with-mu-and-circuitpython/buttons-and-switch).
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://learn.adafruit.com/sensor-plotting-with-mu-and-circuitpython/buttons-and-switch](https://learn.adafruit.com/sensor-plotting-with-mu-and-circuitpython/buttons-and-switch)找到响应按钮按下的示例。
- en: Moving active LEDs with push buttons
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用按钮移动活动LED
- en: In this recipe, we will learn how to move the active NeoPixel clockwise and
    counterclockwise depending on whether the left or right push button is pressed.
    This recipe goes beyond the simpler button and LED interactions shown in previous
    recipes. This is a more involved recipe, which will create the impression that
    button presses are moving the light in a circular motion around the board.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们将学习如何根据按下左侧或右侧按钮来顺时针或逆时针移动活动的NeoPixel。这个方法超越了以前方法中显示的更简单的按钮和LED交互。这是一个更复杂的方法，它将产生按钮按下正在使光在面板上以圆周运动的印象。
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL才能运行本方法中提供的代码。
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s perform the following steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'Run the following lines of code in the REPL:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the following code and press the push buttons to see the effect this has
    on the pixels:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下代码并按下按钮以查看其对像素的影响：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The code that follows combines all the code shown in this recipe to make one
    complete program. Add this block of code to the `main.py` file and it will change
    the direction of the lighted pixels from clockwise to counterclockwise each time
    push button A and push button B are pressed:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的代码将结合本方法中显示的所有代码，以制作一个完整的程序。将此代码块添加到`main.py`文件中，它将在按下按钮A和按钮B时将点亮的像素的方向从顺时针改为逆时针：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first line of code imports the Circuit Playground Express library and the
    `time` library. Then, the color constants and brightness level are set. The `i` variable
    will keep track of which pixel is currently lit. The `direction` variable will
    either have the value of `1` or `-1` and will control whether the pixel moves
    in a clockwise or counterclockwise direction.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一行导入了Circuit Playground Express库和`time`库。然后设置了颜色常量和亮度级别。`i`变量将跟踪当前点亮的像素。`direction`变量将具有值`1`或`-1`，并将控制像素是顺时针移动还是逆时针移动。
- en: In the infinite loop, the direction will be changed if either push button A
    or push button B is pressed. The direction is applied to the position and a modulus
    10 operation is applied so that the position value rotates between the values
    of 0 and 10.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在无限循环中，如果按下按钮A或按下按钮B，则会更改方向。方向应用于位置，并应用模10运算，以便位置值在0和10之间旋转。
- en: In each iteration, all the pixels are turned off and then the selected pixel
    is turned on. The speed of the light animation is controlled with a call to make
    the board sleep for 50 milliseconds between each loop iteration.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，所有像素都会关闭，然后打开所选像素。通过调用使面板在每次循环迭代之间休眠50毫秒来控制灯光动画的速度。
- en: There's more...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe combines a number of different techniques in order to produce the
    final result. It uses an animation effect where someone looking at the board thinks
    the light is moving around the board in a circle.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法结合了许多不同的技术，以产生最终的结果。它使用了一个动画效果，让看着面板的人认为光在面板上以圆圈的方式移动。
- en: The animation effect has been implemented to support directional motion so that
    it will look as if the light is moving in either a clockwise or counterclockwise
    direction. Then, the push buttons are combined with this animation to change the
    direction of the animation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 已实施动画效果以支持方向运动，使其看起来就像光在顺时针或逆时针方向移动。然后，按键与此动画结合在一起，以改变动画的方向。
- en: You can take this base recipe and adapt it to different scenarios. For instance,
    you could replace the light show with a sound effect that goes from either quiet
    to loud, or loud to quiet, depending on which button is pressed. Additionally,
    you could use the two push buttons to increase or decrease the level of brightness.
    Having two push buttons opens many options to either increase or decrease a particular
    value depending on which button is being pressed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以采用这个基本方法并将其适应不同的场景。例如，您可以用声音效果替换灯光秀，声音效果可以从安静到响亮，或者从响亮到安静，具体取决于按下哪个按钮。此外，您可以使用两个按键来增加或减少亮度级别。有两个按键可以打开许多选项，以便根据按下的按钮来增加或减少特定值。
- en: See also
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'You can find out more information here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到更多信息：
- en: Details on a Circuit Playground project that uses the push buttons and pixels
    can be found at [https://learn.adafruit.com/circuit-playground-simple-simon](https://learn.adafruit.com/circuit-playground-simple-simon).
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://learn.adafruit.com/circuit-playground-simple-simon](https://learn.adafruit.com/circuit-playground-simple-simon)找到使用按钮和像素的Circuit
    Playground项目的详细信息。
- en: Documentation on the modulo operator can be found at [https://docs.python.org/3.3/reference/expressions.html#binary-arithmetic-operations](https://docs.python.org/3.3/reference/expressions.html#binary-arithmetic-operations).
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关取模运算符的文档可以在[https://docs.python.org/3.3/reference/expressions.html#binary-arithmetic-operations](https://docs.python.org/3.3/reference/expressions.html#binary-arithmetic-operations)找到。
- en: Playing a beep on the button press
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在按钮按下时播放蜂鸣声
- en: In this recipe, we will learn how to play a beeping tone when the button is
    pressed. The previous recipes allowed us to interact with light using the buttons.
    This recipe will show you how to introduce button and sound interactions in your
    projects.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习在按下按钮时播放蜂鸣声。之前的教程允许我们使用按钮与灯进行交互。本教程将向您展示如何在项目中引入按钮和声音交互。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL，以运行本教程中提供的代码。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s perform the following steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'Run the following lines of code in the REPL while keeping push button A pressed:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按住按钮A的同时在REPL中运行以下代码行：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The speaker should have given a low-pitch beep. Run the following code while
    keeping push button B pressed, and you should hear a high-pitch beep:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扬声器应该发出低音蜂鸣声。在按住按钮B的同时运行以下代码，您应该听到高音蜂鸣声：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The code that follows combines all the code shown in this recipe and adds a
    `while` loop to it to make one complete program. Add this to the `main.py` file,
    and, when executed, it will produce either a high-or low-pitch beep each time
    either push button A or push button B is pressed:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的代码将结合本教程中显示的所有代码，并向其中添加一个`while`循环，以使其成为一个完整的程序。将此添加到`main.py`文件中，当执行时，每次按下按钮A或按钮B时，它将产生高音或低音蜂鸣声：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first line of code imports the Circuit Playground Express library. An infinite
    loop is then entered that will check whether push button A or push button B is
    being pressed in each loop iteration, and play a different pitched beep in each
    case for a duration of 0.2 seconds.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码导入了Circuit Playground Express库。然后进入一个无限循环，每次循环迭代都会检查按钮A或按钮B是否被按下，并在每种情况下播放不同音调的蜂鸣声，持续时间为0.2秒。
- en: There's more...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This simple recipe demonstrates how you can make the board react to different
    button presses by playing different tones. Another way that you can make the script
    behave is by playing different audio `.wav` files depending on which push button
    is being pressed. The slide switch could also be incorporated into the recipe
    to set two different modes; one mode could play notes of a low pitch, and the
    other could play notes of a high pitch.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的教程演示了如何通过播放不同的音调使板对不同的按钮按下做出反应。另一种使脚本行为的方法是根据按下的按钮不同播放不同的音频`.wav`文件。滑动开关也可以并入到教程中，以设置两种不同的模式；一种模式可以播放低音调的音符，另一种可以播放高音调的音符。
- en: See also
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'You can find out more information here:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到更多信息：
- en: Examples of how CircuitPython can read the input from push buttons can be found
    at [https://learn.adafruit.com/circuitpython-essentials/circuitpython-digital-in-out](https://learn.adafruit.com/circuitpython-essentials/circuitpython-digital-in-out).
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关CircuitPython如何读取按钮输入的示例可以在[https://learn.adafruit.com/circuitpython-essentials/circuitpython-digital-in-out](https://learn.adafruit.com/circuitpython-essentials/circuitpython-digital-in-out)找到。
- en: An example of a Circuit Playground project that reacts to inputs to play different
    tones can be found at [https://learn.adafruit.com/dear-diary-alarm](https://learn.adafruit.com/dear-diary-alarm).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://learn.adafruit.com/dear-diary-alarm](https://learn.adafruit.com/dear-diary-alarm)找到对输入做出反应以播放不同音调的Circuit
    Playground项目的示例。
- en: Detecting touch on a touchpad
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在触摸板上检测触摸
- en: In this recipe, we will learn how to detect when a touchpad is touched and to
    print a message each time this event occurs. The Circuit Playground Express comes
    with a number of touchpad connectors that can be attached to all sorts of objects.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何检测触摸板何时被触摸，并在每次发生此事件时打印一条消息。Circuit Playground Express配备了许多可以连接到各种对象的触摸板连接器。
- en: Essentially, anything that can conduct electricity can be used as a way to interact
    with your device. You can use wires, conductive thread, fruit, water, or copper
    tape to interact with your device.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，任何可以导电的东西都可以用作与设备交互的方式。您可以使用导线、导电线、水果、水或铜箔与设备交互。
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL，以运行本教程中提供的代码。
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s perform the following steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'Run the following lines of code in the REPL. The value of `cpx.touch_A1` is
    `False` because touchpad A1 is not being touched:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行。`cpx.touch_A1`的值为`False`，因为未触摸触摸板A1：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Keep your finger touching touchpad A1 while you run the following code block:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行以下代码块时，保持手指触摸触摸板A1：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following code should be added to the `main.py` file. This will print a
    message every time you press touchpad A1:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应添加到`main.py`文件中。每次按下触摸板A1时，这将打印一条消息：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first few lines of code import the Circuit Playground Express library and
    the `time` library. The script then enters into an infinite loop where it checks
    the state of touchpad A1 in each loop iteration. If it has detected a touch occurring,
    then it will print a message.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行代码导入了Circuit Playground Express库和`time`库。然后脚本进入一个无限循环，在每次循环迭代中检查触摸板A1的状态。如果检测到触摸事件，则会打印一条消息。
- en: There's more...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe demonstrates a simple way to interact with touchpads. However, when
    it comes to capacitive touch sensors, the devil is in the detail. Depending on
    how conductive the material you attach to the touchpad is, you might find yourself
    in one of two extremes; that is, the sensors might not detect some touch events
    at all, or if there is a lot of ambient noise, which is being falsely detected
    as multiple touch events.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程演示了与触摸板交互的简单方法。但是，当涉及到电容触摸传感器时，细节至关重要。取决于您连接到触摸板的材料的导电性，您可能会发现自己处于两个极端之一；也就是说，传感器可能根本不会检测到某些触摸事件，或者如果有很多环境噪音被错误地检测为多次触摸事件。
- en: These devices aren't as simple as a mechanical push button. On the flip side,
    however, they will let you create projects where you can interact with your embedded
    device using bananas and oranges (as they are electrically conductive).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备并不像机械按钮那样简单。然而，它们将让您创建可以使用香蕉和橙子与嵌入式设备进行交互的项目（因为它们具有电导性）。
- en: See also
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'You can find out more information here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到更多信息：
- en: Further documentation on the `touch_A1` property can be found at [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.touch_A1](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.touch_A1).
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`touch_A1`属性的更多文档可以在[https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.touch_A1](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.touch_A1)找到。
- en: An example of interacting with capacitive touch sensors can be found at [https://learn.adafruit.com/adafruit-circuit-playground-express/adafruit2-circuitpython-cap-touch](https://learn.adafruit.com/adafruit-circuit-playground-express/adafruit2-circuitpython-cap-touch).
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://learn.adafruit.com/adafruit-circuit-playground-express/adafruit2-circuitpython-cap-touch](https://learn.adafruit.com/adafruit-circuit-playground-express/adafruit2-circuitpython-cap-touch)找到与电容触摸传感器交互的示例。
- en: Monitoring the touchpad raw measurements
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控触摸板的原始测量值
- en: In this recipe, we will learn how to monitor the touchpad raw measurements,
    which is a very useful way to verify how much the touch threshold should be adjusted.
    It is very important to be able to directly read the raw sensor values that are
    coming from the touch sensors.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何监控触摸板的原始测量值，这是验证触摸阈值应该如何调整的非常有用的方法。能够直接读取来自触摸传感器的原始传感器值非常重要。
- en: This level of detail is necessary when you want to correctly set touch thresholds
    or when you want to find out why the touchpads aren't responding the way you expect
    them to.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要正确设置触摸阈值或想要找出为什么触摸板的响应方式与您的预期不符时，这种详细级别是必要的。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL才能运行本教程中提供的代码。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s perform the following steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'Run the following lines of code in the REPL. The output shows the value taken
    from a raw touch measurement and the initial threshold value that was automatically
    set when the object was created:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行。输出显示了从原始触摸测量中获取的值以及在创建对象时自动设置的初始阈值值：
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Keep your finger touching touchpad A1 while you run the next block of code:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行下一段代码时，保持手指触摸触摸板A1：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Release your finger from touchpad A1 while you run the next block of code:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行下一段代码时，从触摸板A1上松开手指：
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following code should be added to the `main.py` file and then run. While
    this code is executing, it will continually print the raw touch measurements and
    the current threshold, and determine whether the current reading is considered
    a touch event. This script can be used to get live sensor readings:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应添加到`main.py`文件中，然后运行。在执行此代码时，它将不断打印原始触摸测量值和当前阈值，并确定当前读数是否被视为触摸事件。此脚本可用于获取实时传感器读数：
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The first few lines of code import the different low-level libraries that are
    required to interact with the touchpad. A `TouchIn` object is created and connected
    to pad A1\. Then, an infinite loop is run, which continually prints out a number
    of values relating to the sensor. It prints the current raw touch measurement
    of the threshold and whether the current measurement should be registered as a
    touch event.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行代码导入了与触摸板交互所需的不同低级库。创建了一个`TouchIn`对象并连接到A1接口。然后，运行一个无限循环，不断打印与传感器相关的多个值。它打印当前原始触摸测量值的阈值以及当前测量是否应被注册为触摸事件。
- en: The last value is simply `True`, but if the raw value exceeds the threshold,
    then it is `False`. The threshold is set when the `TouchIn` object is first instantiated
    by taking the initial raw value and adding 100 to this value.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个值只是`True`，但如果原始值超过阈值，那么它就是`False`。当`TouchIn`对象首次实例化时，阈值是通过取初始原始值并将其加100来设置的。
- en: There's more...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This script is very useful for verifying the actual values that are being read
    from the touch sensor and for deciding how low or high the touch threshold should
    be set. It's also a great way to connect different materials to your board and
    see how well they perform in conducting electricity and detecting touch events.
    Without these raw values, you can only guess at what is actually going on.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本非常有用，可以验证从触摸传感器读取的实际值，并决定触摸阈值应设置多低或多高。这也是将不同材料连接到您的板上并查看它们在导电和检测触摸事件方面表现如何的好方法。如果没有这些原始值，您只能猜测实际发生了什么。
- en: The higher-level properties used elsewhere in this chapter actually used a lot
    of the libraries introduced in this recipe under the hood. It is helpful to look
    at the source code of this higher-level code, as much of it is implemented in
    Python. Additionally, it gives you an insight into how the code is actually interacting
    with the hardware.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中其他地方使用的高级属性实际上在底层使用了许多在本配方中介绍的库。查看这些高级代码的源代码很有帮助，因为其中的大部分是用Python实现的。此外，它可以让您了解代码实际上是如何与硬件交互的。
- en: See also
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'You can find out more information here:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到更多信息：
- en: Further documentation on the `touchio` module can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/touchio/__init__.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/touchio/__init__.html).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`touchio`模块的更多文档可以在[https://circuitpython.readthedocs.io/en/3.x/shared-bindings/touchio/__init__.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/touchio/__init__.html)找到。
- en: Further documentation on the `board` module can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/board/__init__.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/board/__init__.html).
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`board`模块的更多文档可以在[https://circuitpython.readthedocs.io/en/3.x/shared-bindings/board/__init__.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/board/__init__.html)找到。
- en: A discussion on the capabilities of capacitive touch sensors on the Circuit
    Playground can be found at [https://learn.adafruit.com/circuit-playground-fruit-drums/hello-capacitive-touch](https://learn.adafruit.com/circuit-playground-fruit-drums/hello-capacitive-touch).
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Circuit Playground上电容触摸传感器的功能的讨论可以在[https://learn.adafruit.com/circuit-playground-fruit-drums/hello-capacitive-touch](https://learn.adafruit.com/circuit-playground-fruit-drums/hello-capacitive-touch)找到。
- en: An explanation of how capacitive touch sensors work can be found at [https://scienceline.org/2012/01/okay-but-how-do-touch-screens-actually-work/](https://scienceline.org/2012/01/okay-but-how-do-touch-screens-actually-work/).
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关电容触摸传感器工作原理的解释可以在[https://scienceline.org/2012/01/okay-but-how-do-touch-screens-actually-work/](https://scienceline.org/2012/01/okay-but-how-do-touch-screens-actually-work/)找到。
- en: Adjusting the touch threshold
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整触摸阈值
- en: In this recipe, we will learn how to adjust the sensitivity of the touchpad
    by changing the threshold value. This is used to decide whether a signal will
    be treated as a touch event not. This is an important setting to tweak and set
    to the correct value. If you don't, then a lot of your touch projects won't behave
    correctly.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将学习如何通过更改阈值来调整触摸板的灵敏度。这用于决定信号是否将被视为触摸事件。这是一个重要的设置，需要进行微调并设置为正确的值。如果不这样做，那么您的触摸项目将无法正确运行。
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL才能运行本配方中提供的代码。
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s perform the following steps:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'Run the following lines of code in the REPL. The touch threshold will have
    been increased by `200` at this point:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行。此时，触摸阈值将增加`200`：
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Keep your finger touching touchpad A1 while you run the next block of code:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行下一块代码时，保持手指触摸触摸板A1：
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following code should be added to the `main.py` file and run. The script
    will increase the touch threshold by `200` and print a message each time the sensor
    detects a touch event:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应将以下代码添加到`main.py`文件并运行。该脚本将通过`200`增加触摸阈值，并在传感器检测到触摸事件时打印消息：
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The first line of code imports the Circuit Playground Express library. The `cpx`
    object exposes a method called `adjust_touch_threshold`. This method can be used
    to change the configured threshold on the touchpads. When called, the threshold
    for all touchpads will be increased by the specified amount.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码导入了Circuit Playground Express库。`cpx`对象公开了一个名为`adjust_touch_threshold`的方法。可以使用此方法来更改触摸板上的配置阈值。调用时，所有触摸板的阈值都将增加指定的量。
- en: Increasing the threshold value makes the touchpad less sensitive, while decreasing
    this value will make the sensor more sensitive. If the threshold setting is set
    too low, then many sensor readings will be incorrectly detected as touch events.
    On the other hand, if the threshold is too high, then genuine touch events will
    not be detected. A sleep function of 500 milliseconds is applied between each
    loop iteration so that a flood of touch events isn't detected during each iteration.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 增加阈值会使触摸板变得不那么敏感，而减小此值将使传感器更敏感。如果阈值设置得太低，则许多传感器读数将被错误地检测为触摸事件。另一方面，如果阈值太高，则无法检测到真正的触摸事件。在每次循环迭代之间应用500毫秒的休眠函数，以便在每次迭代期间不会检测到大量的触摸事件。
- en: There's more...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The best way to decide on what to set as the value for the threshold is through
    experimentation. Connect all the actual conductive materials to the touchpads
    before starting your threshold tuning. Then, use the *Monitoring the touchpad
    raw measurements* recipe in this chapter to get a live view of the sensor readings
    you are receiving.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实验来决定阈值的最佳值是最好的方法。在开始调整阈值之前，将所有实际导电材料连接到触摸板。然后，在本章中的*监视触摸板原始测量*配方中，获取传感器读数的实时视图。
- en: You can also repeatedly touch the material in question to see how the readings
    vary when you touch and let go. Based on these readings, you can set the ideal
    threshold that will reliably read touch events. It is important to restart your
    script each time you change the materials as the initial threshold autoconfiguration
    occurs each time you run the code the first time.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以重复触摸所讨论的材料，以查看触摸和释放时读数的变化。根据这些读数，您可以设置可靠读取触摸事件的理想阈值。每次更改材料时重启脚本很重要，因为每次首次运行代码时都会发生初始阈值自动配置。
- en: See also
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'You can find out more information here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到更多信息：
- en: Further documentation on the `adjust_touch_threshold` method can be found at
    [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.adjust_touch_threshold](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.adjust_touch_threshold).
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`adjust_touch_threshold`方法的进一步文档可以在[https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.adjust_touch_threshold](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.adjust_touch_threshold)找到。
- en: An example of calling the `adjust_touch_threshold` method can be found at [https://learn.adafruit.com/make-it-sense/circuitpython-6](https://learn.adafruit.com/make-it-sense/circuitpython-6).
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`adjust_touch_threshold`方法的示例可以在[https://learn.adafruit.com/make-it-sense/circuitpython-6](https://learn.adafruit.com/make-it-sense/circuitpython-6)找到。
