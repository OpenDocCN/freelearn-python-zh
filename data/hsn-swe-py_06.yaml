- en: Development Tools and Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发工具和最佳实践
- en: Before starting on the actual development of `hms_sys`, there are several decisions
    that need to be made. In a real-world scenario, some (maybe all) of these decisions
    might be made at a policy level, either by the development team or maybe by management
    above the team. Some, such as the IDE/code editor program, might be an individual
    decision by each individual team member; so long as there are no conflicts between
    different developers' choices, or any issues raised as a result, there's nothing
    wrong with that. On the other hand, having some consistency isn't a bad thing
    either; that way, every team member knows what to expect when they're working
    on code that someone else on the team has touched.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际开发`hms_sys`之前，需要做出几项决定。在现实世界的情况下，一些（也许全部）这些决定可能是由开发团队或者团队上面的管理层在政策层面上做出的。有些决定，比如IDE/代码编辑器程序，可能是每个团队成员个人的决定；只要不同开发人员的选择之间没有冲突，或者由此引起的任何问题，那就没有问题。另一方面，保持一些一致性也不是坏事；这样，每个团队成员在处理其他团队成员触及的代码时都知道可以期待什么。
- en: 'These choices fall into two main categories selection of development tools
    and what best practices (and standards) will be in play, specifically the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选择可以分为两大类：开发工具的选择和最佳实践（和标准）的运用，具体包括以下内容：
- en: Integrated Development Environment options
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成开发环境选项
- en: Source Control Management options
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码控制管理选项
- en: Code and development process standards, including organization of Python code
    into packages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码和开发流程标准，包括将Python代码组织成包
- en: Setting up and using of Python virtual environments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和使用Python虚拟环境
- en: Development tools
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发工具
- en: The two most important tool-oriented decisions that need to be considered are,
    not surprisingly, centered around creating, editing, and managing the code through
    the development life cycle.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的两个最重要的工具导向决策，毫不奇怪地围绕着通过开发生命周期创建、编辑和管理代码。
- en: Integrated Development Environment (IDE) options
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成开发环境（IDE）选项
- en: It's certainly possible to write and edit code without using a full-blown **Integrated
    Development Environment** (**IDE**). Ultimately, anything that can read and write
    text files of arbitrary types or with arbitrary file extensions is technically
    usable. Many IDEs, though, provide additional, development-centric capabilities
    that can save time and effort—sometimes a lot of time and effort. The trade-off
    is, generally, that the more features and functionality that any given IDE provides,
    the less lightweight it is, and the more complicated it can become. Finding one
    that every member of a development team can agree on can be difficult, or even
    painful there are downsides to most of them, and there may not be a single, obvious
    right choice. It's very subjective.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用完整的**集成开发环境**（**IDE**）的情况下编写和编辑代码是完全可能的。最终，任何能够读取和写入任意类型或带有任意文件扩展名的文本文件的东西在技术上都是可用的。然而，许多IDE提供额外的、面向开发的功能，可以节省时间和精力——有时甚至可以节省大量的时间和精力。一般来说，权衡是，任何给定的IDE提供的功能和功能越多，它就越不轻量级，也就越复杂。找到一个所有开发团队成员都能同意的IDE可能是困难的，甚至痛苦，大多数IDE都有缺点，可能没有一个单一、明显的正确选择。这是非常主观的。
- en: 'In looking at code editing and management tools, only real IDEs will be examined.
    As noted, text editors can be used to write code, and there are a fair few of
    them out there that recognize various language formats, including Python. However
    good they are (and there are some that are very good), if they don''t provide
    at least one of the following functional capabilities, they won''t be considered.
    It''s just a matter of time until something in this list is needed and not available,
    and at a minimum, that eventuality will be distracting, and at worst, it could
    be a critical issue (though that seems unlikely). The feature set criteria are
    as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看代码编辑和管理工具时，只有真正的IDE将被考虑。正如前面所述，文本编辑器可以用来编写代码，市面上有很多识别各种语言格式的文本编辑器，包括Python。然而，无论它们有多好（有些确实非常好），如果它们没有提供以下至少一项功能能力，它们将不被考虑。这只是一个时间问题，直到列表中的某个功能是必需的，但却不可用，至少这种可能性会分散注意力，最坏的情况下，可能会成为一个关键问题（尽管这似乎不太可能）。功能集的标准如下：
- en: '**Large-project support**: A large project, for the purposes of discussion,
    involves the development of two or more distinct, installable Python packages
    that have different environmental requirements. An example might include a `business_objects`
    class library that''s used by two separate packages such as an `online_store`
    and `back_office` that provide different functionality for different users. The
    best-case scenario for this would include the following :'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大型项目支持**：在讨论的目的上，大型项目涉及开发两个或更多个不同的可安装的Python包，这些包具有不同的环境要求。一个例子可能包括一个`business_objects`类库，它被两个独立的包如`online_store`和`back_office`所使用，为不同的用户提供不同的功能。这种情况的最佳情况将包括以下内容：'
- en: Support for different Python interpreters (possibly as individual virtual environments)
    in different package projects
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持不同的Python解释器（可能作为单独的虚拟环境）在不同的包项目中
- en: The ability to have and manage interproject references (in this example, the
    `online_store` and `back_office` packages would be able to have useful references
    to the `business_objects` library)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有和管理项目间引用的能力（在这个例子中，`online_store` 和 `back_office` 包将能够对 `business_objects`
    库有有用的引用）
- en: Less important, but still highly useful, would be the ability to have multiple
    projects open and editable at the same time, so that as changes in one package
    project require corresponding changes in another, there's little or no context
    change needed by the developer making those changes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不太重要，但仍然非常有用的是，能够同时打开和编辑多个项目，这样当一个包项目的更改需要在另一个包项目中进行相应的更改时，开发人员几乎不需要进行上下文的变化
- en: '**Refactoring support**: Given a long enough period of time, it''s inevitable
    that changes to a system''s code without changing how it behaves from an external
    perspective is going to be necessary. That''s a textbook definition of refactoring.
    Refactoring efforts tend to require, at a minimum, the ability to find and replace
    entity names in the code across multiple files, possibly across multiple libraries.
    At the more complex end of the range, refactoring can include the creation of
    new classes or members of classes to move functionality into a different location
    in the code, while maintaining the interface of the code.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构支持**：在足够长的时间内，不改变系统行为的情况下对系统代码进行更改是不可避免的。这是重构的教科书定义。重构工作通常需要至少能够在多个文件中查找和替换实体名称，可能还涉及多个库。在更复杂的范围内，重构可能包括创建新的类或类的成员，将功能移动到代码的不同位置，同时保持代码的接口。'
- en: '**L****anguage exploration**: The ability to examine code that''s used by,
    but not a part of, a project is helpful, at least occasionally. This is more useful
    than it might sound, unless you are lucky enough to possess an eidetic memory,
    and thus never have to look up function signatures, module members and so on.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言探索**：检查项目使用但不是项目一部分的代码是有帮助的，至少偶尔是。这比听起来更有用，除非你很幸运拥有完美的记忆，因此从不必查找函数签名，模块成员等。'
- en: '**C****ode execution**: The ability to actually run the code being worked on
    is immensely helpful during development. Having to drop out of an editor into
    a terminal in order to run code, to test changes to it, is a context change, and
    those are tedious at the least, and can actually be disruptive to the process
    under the right circumstances.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码执行**：在开发过程中实际运行正在处理的代码是非常有帮助的。不得不从编辑器退出到终端以运行代码，测试对其进行更改，这是一种上下文的改变，至少是乏味的，而在适当的情况下，实际上可能会对过程产生破坏性影响。'
- en: 'These items will be rated on the following scale, from best to worst:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项目将按照以下标准进行评分，从好到坏：
- en: Superb
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 极好
- en: Great
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很棒
- en: Good
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 好
- en: Fair
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公平
- en: Mediocre
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般
- en: Poor
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 差
- en: Terrible
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 糟糕
- en: These are the author's opinion, obviously, so take these with an appropriately
    sized grain of salt. Your personal views on any or all of these, or your needs
    for any or all of them, may be substantially different.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是作者的观点，显然，所以要以适当的心态对待。你对这些任何或所有的个人观点，或者你对它们的需求，可能会有很大不同。
- en: 'Many IDEs have various bells and whistles functionality that helps, perhaps
    substantially, with the processes of writing or managing code, but isn''t something
    that''s really critical. Examples of these include the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 许多IDE具有各种花里胡哨的功能，可以在编写或管理代码的过程中帮助，但并非真正关键。这些功能的例子包括以下内容：
- en: The ability to navigate to where a code entity is defined from someplace where
    it's being used
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从某个地方导航到代码实体的定义位置
- en: Code completion and autosuggestion, which allows the developer to quickly and
    easily select from a list of entities based on the first few characters of an
    entity name that they've started typing
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码完成和自动建议，允许开发人员根据他们开始输入的实体名称的前几个字符，快速轻松地从列表中选择实体
- en: Code coloration and presentation, which provides an easy-to-understand visual
    indication of what a given block of code is – comments, class, function and variable
    names, that sort of thing
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码颜色和呈现，提供了一个易于理解的视觉指示，给出了代码块的内容 - 注释，类，函数和变量名称等
- en: These will also be rated on the same scale, but since they aren't critical functionality,
    they are presented merely as additional information items.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些也将按照相同的标准进行评分，但由于它们不是关键功能，因此仅作为额外信息项呈现。
- en: All of the following IDEs are available across all the major operating systems
    – Windows, Macintosh, and Linux (and probably most UNIX systems, for that matter) – so
    that, an important criteria for evaluating the IDE part of a development toolkit
    is moot across the three discussed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有以下IDE都适用于所有主要操作系统 - Windows，Macintosh和Linux（可能还包括大多数UNIX系统），因此，评估开发工具包的IDE部分的重要标准在这三个中都是无效的。
- en: IDLE
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDLE
- en: IDLE is a simple IDE, written in Python and using the `Tkinter` GUI, which means
    that it should run on pretty much anything that Python can run on. It is often,
    but not always, part of a default Python installation but even when it's not included
    by default, it's easily installed and doesn't require much of anything in the
    way of external dependencies or other languages runtime environments.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE是一个简单的IDE，用Python编写，使用`Tkinter` GUI，这意味着它应该可以在Python可以运行的任何地方运行。它通常是默认Python安装的一部分，但即使默认情况下没有包含，也很容易安装，不需要外部依赖或其他语言运行环境。
- en: '**Large-project support**: Poor'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大型项目支持**：差'
- en: '**Refactoring support**: Poor'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构支持**：差'
- en: '**Language exploration**: Good'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言探索**：好'
- en: '**Code execution**: Good'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码执行**：好'
- en: '**Bells and whistles**: Fair'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**花里胡哨**：公平'
- en: Out of the box, IDLE doesn't provide any project management tools, though there
    may be plugins that provide some of this capability. Even so, unless there are
    also plugins available that allow for more than one file to be open at a time
    without requiring each to be in a separate window, working with code across multiple
    files will eventually be tedious, at best, and perhaps impractical to the point
    of being effectively impossible.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE默认情况下不提供任何项目管理工具，尽管可能有提供部分功能的插件。即使有插件可用，也可能需要每个文件都在单独的窗口中打开，这样在多个文件之间工作最终会变得乏味，甚至可能变得不切实际，甚至可能根本不可能。
- en: Although IDLE's search-and-replace functionality includes one nice feature –
    regular expression-based searches – that's about it as far as functionality that
    is meaningful or useful for refactoring purposes. Any significant refactoring
    effort, or even widespread but smaller scoped changes, will require a relatively
    high degree of manual effort.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管IDLE的搜索和替换功能包括一个不错的功能 - 基于正则表达式的搜索 - 但就重构目的而言，这就是有意义或有用的功能。任何重大的重构工作，甚至是广泛但范围较小的更改，都需要相对高程度的手动工作。
- en: Where IDLE really shines is in its ability to dig into the packages and modules
    available on the system. It provides both a class browser that allows direct exploration
    of any importable namespace in the Python path, and a path browser that allows
    exploration of all available namespaces. The only downsides to these are a lack
    of search capability and that each class browser has to reside in a separate window.
    Were these not concerns, a Great rating would not seem out of line.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE真正闪亮的地方在于它能够深入挖掘系统中可用的包和模块。它提供了一个类浏览器，允许直接探索Python路径中的任何可导入命名空间，以及一个路径浏览器，允许探索所有可用的命名空间。这些唯一的缺点是缺乏搜索功能，以及每个类浏览器都必须驻留在单独的窗口中。如果这些不是问题，那么给予一个很高的评价似乎也不过分。
- en: IDLE allows any open file to be executed with a single keystroke, with the results/output
    of that run displayed in a single, common Python shell window. There is no facility
    for passing arguments to those executions, but that's probably only a concern
    if a project involves some sort of command-line program that accepts arguments.
    IDLE also provides a syntax check that identifies the first syntax problem detected
    in the code, which could be of some use.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE允许通过按下一个键来执行任何打开的文件，执行的结果/输出显示在一个单独的Python shell窗口中。没有提供传递参数给这些执行的功能，但这可能只有在项目涉及接受参数的命令行程序时才是一个问题。IDLE还提供了一个语法检查，识别代码中检测到的第一个语法问题，这可能有些用处。
- en: The only reliably functional bells and whistles item that IDLE offers is coloration
    of code. There are extensions that are supposed to provide things such as auto-completion
    and some code authoring assistance (automatic generation of closing parenthesis,
    for example), but none of them appear to be functional.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE可靠的功能之一是代码的着色。有一些扩展可以提供诸如自动完成和一些代码编写辅助功能（例如自动生成闭合括号），但似乎没有一个是功能性的。
- en: 'The following is a screenshot of IDLE showing the console, a code editing window,
    class and path browser windows, and a search and replace window:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是IDLE的屏幕截图，显示了控制台，代码编辑窗口，类和路径浏览器窗口，以及搜索和替换窗口：
- en: '![](assets/cb6a9cc5-4e01-4b10-bd7c-fae5882d7abb.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cb6a9cc5-4e01-4b10-bd7c-fae5882d7abb.png)'
- en: IDLE is probably a reasonable choice for small code efforts – anything that
    doesn't require having more files open than the user's comfortable with having
    displayed in their individual windows. It's lightweight, with a reasonably stable
    (if occasionally quirky) GUI. It's not something that feels like it would work
    well for projects that involve more than one distributable package, though.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE可能是小型代码项目的合理选择 - 任何不需要打开的文件比用户在其各自窗口中显示的更多的东西。它很轻量级，具有相当稳定（偶尔古怪）的GUI。但对于涉及多个可分发包的项目来说，它并不适合。
- en: Geany
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Geany
- en: '**G****eany** is a lightweight code editor and IDE with support for a number
    of languages, including Python. It''s available as an installable application
    across all the major operating systems, though it has some features that aren''t
    available on Windows. Geany is available as a free download from [www.geany.org](http://www.geany.org/):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**Geany**是一个轻量级的代码编辑器和集成开发环境，支持多种语言，包括Python。它作为一个可安装的应用程序在所有主要操作系统上都可用，尽管在Windows上有一些功能是不可用的。Geany可以从[www.geany.org](http://www.geany.org/)免费下载：'
- en: '**Large-project support**: Fair'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大型项目支持**：一般'
- en: '**Refactoring support**: Mediocre'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构支持**：一般'
- en: '**Language exploration**: Mediocre'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言探索**：一般'
- en: '**Code execution**: Good'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码执行**：好'
- en: '**Bells and whistles**: Good'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**花里胡哨**：好'
- en: 'This is a screenshot of Geany showing one of several project plugins'' sidebars,
    an open code file, project settings, and search and replace windows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Geany的屏幕截图，显示了几个项目插件的侧边栏，一个打开的代码文件，项目设置以及搜索和替换窗口：
- en: '![](assets/04bcf30d-2150-4dfb-a864-6ac87529cc7b.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/04bcf30d-2150-4dfb-a864-6ac87529cc7b.png)'
- en: Geany's interface makes working with multiple concurrently open files a great
    deal easier than the same task would be in IDLE; each open file resides in a single
    tab in the UI, making multi-file editing quite a bit easier to deal with. It also
    supports a basic project structure even in its most basic installed configuration,
    and there are a few different project-oriented plugins that allow for easier/better
    management and visibility into the files of a project. What it lacks, generally,
    for large-project support is the ability to actually have multiple projects open
    at once, though multiple open files across different project source trees is supported.
    With some careful planning, and judicious configuration of individual projects'
    settings, it's possible to manage different execution requirements and even specific
    **Python virtual environments** across a set of related projects, though it requires
    some discipline to keep those well-isolated and efficient. As can be seen in the
    screen capture, Geany also provides settings for compilation and build/make commands
    at a project level, which can be very handy.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Geany的界面使得同时打开多个文件变得更加容易，而在IDLE中进行相同的任务将会更加困难；每个打开的文件都位于UI中的一个标签中，使得多文件编辑变得更加容易处理。即使在其最基本的安装配置中，它也支持基本的项目结构，并且有一些不同的面向项目的插件，可以更轻松/更好地管理和查看项目的文件。通常，对于大型项目的支持，它缺少实际上可以同时打开多个项目的能力，尽管支持跨不同项目源树打开多个文件。通过一些仔细的规划，并且审慎配置各个项目的设置，可以管理不同的执行要求，甚至是一组相关项目中特定的**Python虚拟环境**，尽管需要一些纪律来保持这些环境的隔离和高效。正如屏幕截图所示，Geany还提供了项目级别的编译和构建/制作命令设置，这可能非常方便。
- en: Geany's refactoring support is just slightly better than IDLE's, mostly because
    of its multi-file search and replace capabilities. There is no out-of-the box
    support for refactoring operations such as renaming a Python module file across
    an entire project or project set, leaving it as a wholly manual process, but with
    some care (and, again, discipline) even those aren't difficult to manage correctly,
    though they may be tedious and/or time consuming.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Geany的重构支持略优于IDLE，主要是因为它具有多文件搜索和替换功能。没有针对重构操作的开箱即用支持，例如在整个项目或项目集中重命名Python模块文件，因此这是一个完全手动的过程，但是通过一些小心（再次，纪律）甚至这些操作也不难正确管理，尽管可能会很乏味和/或耗时。
- en: Geany's language exploration capabilities don't look like they should warrant
    as high a rating as the *Mediocre* that was given. Short of actually opening every
    Python namespace that's tied to a given project, which would at least allow exploration
    of those packages in the Symbols panel, there really isn't much obviously available
    in the way of support for digging into the underlying language. Geany's redemption
    here is a very robust auto completion capability. Once the first four characters
    of an identifiable language element are entered – whether that element is part
    of an open file in the project or part of an imported module – all of the element
    names that match the currently entered text are shown and selectable, and if the
    selected item is a function or method, the code hint that comes up for the item
    includes that item's argument signature.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Geany的语言探索能力看起来似乎不应该获得如此高的评分，就像给出的*平庸*一样。除了实际打开与给定项目相关联的每个Python命名空间之外，这至少可以允许在符号面板中探索这些包之外，实际上并没有太多显而易见的支持来深入了解底层语言。Geany在这里的救赎是非常强大的自动完成功能。一旦输入了可识别语言元素的前四个字符
    - 无论该元素是项目中打开文件的一部分还是导入模块的一部分 - 所有与当前输入文本匹配的元素名称都会显示并可选择，如果所选项目是函数或方法，则为该项目提供的代码提示包括该项目的参数签名。
- en: Geany's code execution capabilities are pretty solid – slightly better than
    IDLE's in a few respects, if not enough so, or across enough areas, to warrant
    a higher rating. With some attention to needs and details early on in the project
    setup, it's possible to configure a given project's Execute settings to use a
    specific Python interpreter, such as one that's part of a specific virtual environment,
    and allow imports from other projects' virtual environment installations and code
    bases. The downside is that doing so does require a degree of planning, and it
    introduces additional complexity in managing the related virtual environments.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Geany的代码执行能力相当不错 - 在某些方面略优于IDLE，尽管在足够的程度或足够的领域内，这并不足以获得更高的评分。通过在项目设置的早期关注需求和细节，可以配置特定项目的执行设置以使用特定的Python解释器，例如作为特定虚拟环境的一部分，并允许从其他项目的虚拟环境安装和代码库中导入。不利的一面是这样做需要一定程度的规划，并且在管理相关虚拟环境时引入了额外的复杂性。
- en: Geany's out-of-the box bells and whistles are comparable to those provided by
    IDLE, with a single significant improvement;  a good number of readily-available
    plugins for a lot of common and useful tasks and needs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Geany的开箱即用功能与IDLE提供的功能相当，但有一个重大改进；有许多常见和有用任务和需求的即用插件。
- en: Eclipse variations + PyDev
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eclipse变体+ PyDev
- en: The Eclipse Platform, managed by the Eclipse Foundation ([www.eclipse.org](http://www.eclipse.org/)),
    is intended to provide a robust, customizable and fully featured IDE for any number
    of languages and development focuses. It's an open source project, and has spun
    off at least two distinct child variants (Aptana Studio, focused on web development), 
    and LiClipse , (focusing on Python development).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由Eclipse基金会（[www.eclipse.org](http://www.eclipse.org/)）管理的Eclipse平台旨在为任何语言和开发重点提供强大，可定制和功能齐全的IDE。这是一个开源项目，并且至少产生了两个不同的子变体（专注于Web开发的Aptana
    Studio和专注于Python开发的LiClipse）。
- en: 'The LiClipse installation will be used as the basis of comparison here, since
    it requires no language-specific setup to begin writing Python code, but it''s
    perhaps worth noting that any Eclipse-derived installation that has access to
    the same plugins and extensions (PyDev for Python language support, and EGit for
    Git support) would provide the same functionality. All that said, Eclipse is not,
    perhaps, for everyone. It can be a very heavy IDE, especially if it''s providing
    support for more than a couple of languages, and can have a significant operational
    footprint memory and CPU usage – even if its supported languages and functionality
    set is fairly tightly controlled:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里将使用LiClipse安装作为比较的基础，因为它不需要特定于语言的设置即可开始编写Python代码，但也值得注意的是，任何具有相同插件和扩展（PyDev用于Python语言支持，EGit用于Git支持）的Eclipse衍生安装都将提供相同的功能。总之，Eclipse可能并不适合所有人。它可能是一个非常沉重的IDE，特别是如果它为多种语言提供支持，并且可能具有显着的操作占用内存和CPU使用率
    - 即使其支持的语言和功能集是相当受控制的：
- en: '**Large project support**: Great'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大型项目支持**：很好'
- en: '**Refactoring support**: Good'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构支持**：好'
- en: '**Language exploration**: Fair'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言探索**：一般'
- en: '**Code execution**: Good'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码执行**：好'
- en: '**Bells and whistles**: Good'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**铃铛和口哨**：好'
- en: 'Here is a screenshot of LiClipse, showing a code outline view of the open code
    file, project properties, and a task list automatically generated from TODO comments
    in the open code files:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是LiClipse的屏幕截图，显示了打开的代码文件的代码大纲视图，项目属性以及从打开的代码文件中的TODO注释自动生成的任务列表：
- en: '![](assets/296fff72-b10c-4674-af22-f78b46f8d40e.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/296fff72-b10c-4674-af22-f78b46f8d40e.png)'
- en: 'Eclipse''s support for large Python projects is very good:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse对大型Python项目的支持非常好：
- en: Multiple projects can be defined and open for modification at the same time
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以定义多个项目并同时进行修改
- en: Each project can have its own distinct Python interpreter, which can be a project-specific
    virtual environment, allowing distinct package requirements on a per-project basis,
    while still also allowing execution
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个项目都可以有自己独特的Python解释器，这可以是项目特定的虚拟环境，允许每个项目基础上具有不同的包要求，同时还允许执行
- en: Projects can be set up to use other projects through the Project References
    settings as dependencies, and code execution will take those dependencies into
    account; that is, if code is run in a project that has a different project set
    up as a reference/dependency, the first project will still have access to the
    second's code and installed packages
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以设置项目以使用其他项目作为依赖项的项目引用设置，并且代码执行将考虑这些依赖项；也就是说，如果在设置了不同项目作为引用/依赖项的项目中运行代码，第一个项目仍将可以访问第二个项目的代码和已安装的包。
- en: Refactoring support across all the Eclipse-derived IDEs is also quite good,
    providing processes for the renaming of code elements including modules, the extraction
    of variables and methods, and facilities for the generation of properties and
    other code constructs. There may be other refactoring capabilities that are context
    dependent, and thus aren't obviously available at first glance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所有基于Eclipse的IDE的重构支持也相当不错，提供了对代码元素重命名，包括模块，提取变量和方法以及生成属性和其他代码结构的过程。可能还有其他重构功能是上下文相关的，因此乍一看并不明显。
- en: Once a Python environment has been associated with a project, the structure
    of that environment is completely available in the project's UI. By itself, that
    allows for drill-down exploration of what packages and functionality are available
    through the associated environment. Less obviously, control-clicking on a member
    of an installed package (for example, on `urllib.request` in the example code
    from [Chapter 5](https://cdp.packtpub.com/hands_on_software_engineering_with_python/wp-admin/post.php?post=29&action=edit), *The
    hms_sys System-Project,* or the `urlopen` function that module provides) will
    take the developer to the actual member (method or property) of the actual module
    that the project has in its installation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将Python环境与项目关联起来，该环境的结构就完全可以在项目的UI中使用。单独这样做可以通过相关环境进行包和功能的深入探索。不那么明显的是，单击已安装包的成员（例如，在[第5章](https://cdp.packtpub.com/hands_on_software_engineering_with_python/wp-admin/post.php?post=29&action=edit)的示例代码中的`urllib.request`，*hms_sys系统项目*，或该模块提供的`urlopen`函数）将带开发人员转到项目安装中实际模块的实际成员（方法或属性）。
- en: The Eclipse family of IDEs provides reasonably good execution capabilities for
    Python code, though it takes some getting used to. Any module or package file
    can be executed if or as needed, and any results, be they output or errors, will
    be displayed. The execution of a specific file also generates an internal run
    configuration that can be modified or removed as needed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse系列的IDE为Python代码提供了相当不错的执行能力，尽管需要一些时间来适应。任何模块或包文件都可以根据需要执行，并且将显示任何结果，无论是输出还是错误。对特定文件的执行还会生成一个内部运行配置，可以根据需要进行修改或删除。
- en: 'The Eclipse/PyDev bells and whistles are, for the most part, comparable with
    those of Geany and IDLE  code and structure coloration is available and configurable,
    autosuggestion and autocompletion is available. The one potentially significant
    item that LiClipse in particular provides from the get-go is an integrated Git
    client. LiClipse''s Git integration, before any repositories have been cloned,
    is shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse/PyDev的铃铛和口哨在很大程度上与Geany和IDLE相当，提供了可用和可配置的代码和结构颜色，提供了自动建议和自动完成。LiClipse特别提供的一个潜在重要项目是集成的Git客户端。LiClipse的Git集成在克隆任何存储库之前就显示在这里：
- en: '![](assets/c038b753-9ac2-4b49-9747-7c2eb1262aab.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c038b753-9ac2-4b49-9747-7c2eb1262aab.png)'
- en: Others
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他
- en: 'These are not the only IDEs available for Python development, nor are they
    necessarily the best. Other popular options, based on various professional and
    semi-professional group polling, include:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些并不是Python开发的唯一可用的IDE，也不一定是最好的。根据各种专业和半专业团体的投票，其他流行的选择包括：
- en: '**PyCharm** (Community or Professional version): PyCharm shows up pretty consistently
    as a popular IDE for Python development. Its feature list includes most of the
    same bells and whistles that have been noted for Geany and Eclipse/PyDev tools,
    and it also features out-of-the box integration with Git, Subversion, and Mercurial
    version control systems, as well as UI and tools for working with various popular
    RDBMS, such as  MySQL and SQL Server in the Professional version. It''s probably
    a good first choice for the development of web applications in Python, provided
    that its project management functionality isn''t going to be overwhelmed by the
    code base. PyCharm can be downloaded at[ ](http://www.jetbrains.com/pycharm)[www.jetbrains.com/pycharm](http://www.jetbrains.com/pycharm)[.](http://www.jetbrains.com/pycharm)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PyCharm**（社区版或专业版）：PyCharm一直是Python开发中受欢迎的IDE。其功能列表包括Geany和Eclipse/PyDev工具中已经注意到的大部分功能，还具有与Git、Subversion和Mercurial版本控制系统的开箱即用集成，以及专业版中用于与各种流行的RDBMS（如MySQL和SQL
    Server）一起使用的UI和工具。对于Python Web应用程序的开发来说，这可能是一个很好的首选，前提是其项目管理功能不会被代码库压倒。PyCharm可以在[www.jetbrains.com/pycharm](http://www.jetbrains.com/pycharm)下载。'
- en: '**Visual Studio Code**: VS Code is touted as being a lightning fast code editor,
    and has a lot of functionality available through a large collection of extensions
    for various languages and purposes. Although it''s one of the newer IDEs in the
    wild with Python support, it''s fast becoming a popular choice for scripting tasks,
    and has a lot of potential for larger, application-centric efforts as well. Visual
    Studio can be downloaded at[code.visualstudio.com](https://code.visualstudio.com/).'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：VS Code被誉为是一个闪电般快速的代码编辑器，并且通过大量的扩展提供了许多功能，适用于各种语言和目的。虽然它是支持Python的较新的IDE之一，但它正在迅速成为脚本任务的热门选择，并且在更大的面向应用程序的努力方面具有很大的潜力。Visual
    Studio可以在[code.visualstudio.com](https://code.visualstudio.com/)下载。'
- en: '**Ninja IDE**: Judging by its feature list, Ninja has most of the same base
    features available through Geany, with the addition of a single, built-in project
    management subsystem that sounds useful and attractive. Ninja IDE can be downloaded
    at[ninja-ide.org](http://ninja-ide.org/)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ninja IDE**：根据其功能列表，Ninja具有Geany提供的大部分基本功能，还增加了一个单一的内置项目管理子系统，听起来很有用和吸引人。Ninja
    IDE可以在[ninja-ide.org](http://ninja-ide.org/)下载。'
- en: Source Code Management
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码管理
- en: 'Whether described as a version or revision control system, **Source Code Management**
    (**SCM**), or some other name, the more common and more popular SCMs provide a
    host of features and capabilities to make certain aspects of the development process
    easier, faster, or at a minimum, more stable. These include the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 无论被描述为版本控制系统还是修订控制系统，**源代码管理**（**SCM**）或其他名称，更常见和更受欢迎的SCM提供了一系列功能和能力，使开发过程的某些方面更容易、更快或至少更稳定。这些包括以下内容：
- en: Allowing multiple developers to collaborate on the same parts of the same code
    base without having to worry (as much) about overwriting each other's work
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许多个开发人员在相同代码库的相同部分上合作，而无需过多担心彼此的工作被覆盖
- en: Keeping track of all versions of a code base, and who made what changes to it
    at each point that a new version was committed
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪代码库的所有版本，以及在每次提交新版本时谁做了什么更改
- en: Providing visibility into what changes were made as each new version was committed
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供对每个新版本提交时所做更改的可见性
- en: 'Maintaining different versions of the same code base for specific purposes,
    probably the most common variation of which is having versions for different environments
    that code changes are worked on and promoted through, which might include:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为特定目的维护相同代码库的不同版本，其中最常见的变化可能是为不同环境创建版本，代码更改在其中进行并通过推广，这可能包括：
- en: Local development environments
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地开发环境
- en: A shared development environment, where all developers' local code changes first
    mix together
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享开发环境，所有开发人员的本地代码更改首先混合在一起
- en: A shared test server for QA and broader integration testing
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于QA和更广泛的集成测试的共享测试服务器
- en: A **User Acceptance Testing** server, using realistic, production-like data,
    which can be used to demonstrate functionality to whoever needs to give final
    approval for changes to be promoted to a live environment or build
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户验收测试**服务器，使用真实的、类似生产的数据，可以用来向需要最终批准变更推广到现场环境或构建的人演示功能'
- en: A staging environment that has full access to a complete copy of production
    data, with an eye towards being able to perform load and other tests that require
    access to that dataset
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有完整生产数据副本访问权限的暂存环境，以便能够执行需要访问该数据集的负载和其他测试
- en: The live environment/build code base
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现场环境/构建代码库
- en: 'While there are at least a few major variations in how such systems function
    under the hood, from a developer''s perspective, those functional differences
    may not really matter, so long as they function as expected and function well.
    Taken together, those basic capabilities, and the permutations of them with various
    manual efforts, allow the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些系统在内部功能上至少有几种主要变化，但从开发人员的角度来看，只要它们按预期运行并且运行良好，这些功能上的差异可能并不重要。这些基本功能以及它们与各种手动努力的变体一起，允许以下操作：
- en: 'Developers to roll back to an earlier version of a complete code base, make
    changes to it, and re-commit those as a new version, which can be useful for:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员可以回滚到先前版本的完整代码库，对其进行更改，并将其重新提交为新版本，这对于以下情况可能很有用：
- en: Finding and removing or fixing changes that unexpectedly raised significant
    issues after being committed or even promoted
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找并删除或修复提交后甚至推广后意外引起重大问题的更改
- en: Creating new branches of the code to experiment with other approaches to committed
    functionality
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建代码的新分支，以尝试其他方法来实现已提交的功能
- en: Multiple developers with different areas of expertise to work on parts of the
    same problem and/or code, allowing them to get that problem solved, or that code
    written much faster
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个具有不同专业领域专长的开发人员可以共同解决同一个问题和/或代码的部分，从而使他们能够更快地解决问题或编写代码。
- en: Developers with stronger architectural backgrounds or skill sets to define bare-bones
    code structures (classes and their members, perhaps), then commit them to be fully
    implemented by someone else
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有较强架构背景或技能集的开发人员可以定义基本的代码结构（例如类及其成员），然后将其提交给其他人完全实现。
- en: System domain experts to easily review changes to the code base, identifying
    risks to functionality or performance before those get promoted to an unforgiving
    environment
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统领域专家可以轻松审查代码库的更改，识别功能或性能风险，然后再将其推广到一个严苛的环境之前。
- en: Configuration managers to access and deploy different versions of the code base
    to their various target environments
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置管理器可以访问和部署代码库的不同版本到它们的各种目标环境
- en: There are probably a lot of other, more specific applications that a good SCM
    system, especially if it's got good ties to the development and code promotion
    processes, can help manage.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有许多其他更具体的应用程序，一个良好的SCM系统，特别是如果它与开发和代码推广流程有良好的联系，可以帮助管理。
- en: Typical SCM activities
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 典型的SCM活动
- en: 'Probably the most common use pattern for any SCM, no matter which one is in
    play, and regardless of the specific command variations, is the following sequence
    of operations:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪种SCM系统，也不管具体的命令变化，可能最常见的使用模式是以下操作序列：
- en: 'Fetching a version of a given code base:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取给定代码库的版本：
- en: Usually, this will be the most recent version, perhaps from a specific branch
    for development, but any branch or version that needs to be retrieved could be
    fetched. In any event, the process will make a complete copy of the requested
    code base in some location on the local file-system, ready to be edited.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，这将是最近的版本，可能来自特定的开发分支，但可以获取任何需要检索的分支或版本。无论如何，该过程将在本地文件系统的某个位置创建所请求的代码库的完整副本，准备进行编辑。
- en: Making changes to the local copy of the code.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对本地代码副本进行更改。
- en: 'Reconciling any differences prior to committing changes:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在提交更改之前对任何差异进行对比：
- en: The goal with this step is to pull down any changes that have been made to the
    same code base, and find and resolve any conflicts between local changes and any
    that may have been made by others in the same code. Several current SCMs allow
    a local commit before committing to a shared repository. In these SCMs, this reconciliation
    is, perhaps, not as critical until code is being committed to the shared repository,
    but doing so with every local commit will often break the resolution of conflicts
    down into smaller, more manageable chunks.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这一步的目标是拉取对同一代码库所做的任何更改，并找到并解决本地更改与其他人可能在同一代码中所做的更改之间的任何冲突。一些当前的SCM允许在提交到共享存储库之前进行本地提交。在这些SCM中，这种对比可能在提交到共享存储库之前并不那么关键，但是在每次本地提交时这样做通常会将冲突的解决分解成更小、更易管理的部分。
- en: 'Committing to the shared repository:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交到共享存储库：
- en: Once this has been completed, the changes made are now available for other developers
    to retrieve (and reconcile conflicts against, if necessary).
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦完成了这一步，所做的更改现在可以供其他开发人员检索（如果需要，还可以与之对比冲突）。
- en: This use pattern will probably encompass most development efforts—anything that
    involves working on an established branch, and that doesn't require a new branch.
    Creation of new branches is also not unusual, especially if there are major changes
    expected to substantial portions of an existing code base. It's also not an unusual
    strategy to have nested branches for different environments, where the deeper
    branches are still pending some review or acceptance before being promoted up
    to the more stable branches.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用模式可能涵盖了大多数开发工作，即任何涉及在已建立的分支上工作，并且不需要新分支的工作。创建新分支也并不少见，特别是如果预计对现有代码库的大部分进行重大更改。对于不同环境可能会有嵌套分支的策略也并不少见，其中更深层的分支在被推广到更稳定的分支之前仍在等待某些审查或接受。
- en: 'The branch structure is shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 分支结构如下所示：
- en: '![](assets/a290b555-e718-42f7-971f-702003d4d233.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a290b555-e718-42f7-971f-702003d4d233.png)'
- en: The process for promoting code, for example from the `[dev]` branch up to `[test]`,
    is reduced to an upwards merge, copying code from the lower branch to the higher,
    followed if necessary by branching from the higher branch back down to the lower
    again.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从`[dev]`分支上升到`[test]`的代码推广过程被简化为向上合并，从较低的分支复制代码到较高的分支，然后如有必要，再从较高的分支分支回到较低的分支。
- en: 'It''s also not unusual to have separate branches created for specific projects—especially
    if there are two or more efforts underway that are likely to make widespread and/or
    significant changes, and most especially if those efforts are expected to conflict
    with each other. Project-specific branches will usually be taken from a shared
    development branch, as shown here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会为特定项目创建单独的分支，特别是如果有两个或更多正在进行的工作，可能会进行广泛和/或重大的更改，尤其是如果这些工作预计会相互冲突。项目特定的分支通常会从共享开发分支中获取，如下所示：
- en: '![](assets/07fcf23a-46e8-446d-b0b7-f4f25bad4f64.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/07fcf23a-46e8-446d-b0b7-f4f25bad4f64.png)'
- en: As code is completed for either `[project1]` or `[project2]` branches, it would
    be committed to its own branch, then merged up into the existing `[dev]` branch,
    checking for and resolving any conflicts in the process.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当`[project1]`或`[project2]`分支的代码完成时，它将被提交到自己的分支，然后合并到现有的`[dev]`分支中，在此过程中检查并解决任何冲突。
- en: 'There are dozens of SCMs available, about a dozen of which are open source
    systems and free of cost. The most popular systems are:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有数十种SCM可用，其中约有十几种是开源系统，免费使用。最流行的系统有：
- en: Git (by a wide margin)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git（远远领先）
- en: Subversion
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Subversion
- en: Mercurial
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mercurial
- en: Git
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git
- en: Git is, by a significant margin, the most popular SCM in use at present. It
    is a distributed SCM system that keeps local branches of code bases and other
    content very inexpensively, while still providing the ability to push locally
    committed code into a shared central repository that multiple users can then access
    and work from. Above all else, it's capable of handling a lot of concurrent commit
    (or patch) activity—not surprising since it was written to accommodate the Linux
    kernel development team's efforts, where there might be hundreds of such patches/commits
    at a time. It's fast and efficient, and the commands for basic functionality that
    covers most day-to-day needs are fairly easily committed to memory, if using the
    command line is the preferred approach.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Git是目前使用最广泛的SCM系统。它是一个分布式SCM系统，可以以非常低的成本保留代码库和其他内容的本地分支，同时仍然能够将本地提交的代码推送到共享的中央存储库，多个用户可以从中访问和工作。最重要的是，它能够处理大量并发的提交（或补丁）活动，这并不奇怪，因为它是为了适应Linux内核开发团队的工作而编写的，那里可能会有数百个这样的补丁/提交。它快速高效，基本功能的命令相对容易记忆，如果使用命令行是首选的话。
- en: 'Git has more functionality outside the normal commands and processes than in
    those processes themselves, that is, there are eight or nine commands that probably
    encompass the fetch/edit/reconcile/commit steps noted earlier, but Git has 21
    commands in total, with the other 12-13 providing functionality that is less commonly
    needed or used. Anecdotal evidence suggests that most developers, unless they
    are working on projects over a certain size or complexity, are probably closer
    to the end of the spectrum that these folks are at:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Git在正常命令和流程之外有更多的功能，也就是说，可能包括之前提到的获取/编辑/调和/提交步骤的八九个命令，但Git总共有21个命令，其他12-13个提供的功能通常不太需要或使用。有传闻称，除非他们在处理一定规模或复杂性的项目，否则大多数开发人员可能更接近这些人所在的那一端。
- en: '![](assets/aebd4069-95c3-407d-9394-5a6052b28ead.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aebd4069-95c3-407d-9394-5a6052b28ead.png)'
- en: There's no shortage of GUI tools for Git either, though many IDEs, whether in
    an effort to minimize context switches, or for some other reason, provide some
    sort of interface to Git, even if it's through an optional plugin. The best of
    those will also detect when problems with some process (a commit or push, for
    example) crop up, and provide some instruction on how to resolve those problems.
    There are also free standing Git-GUI applications, and even integrations with
    built-in system tools such as TortoiseGit ([https://tortoisegit.org/](https://tortoisegit.org/))
    , which adds Git functionality to the Windows File Explorer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Git也有不少GUI工具，尽管许多IDE，无论是为了最小化上下文切换，还是出于其他原因，都提供了一些与Git交互的界面，即使是通过可选插件。其中最好的工具还会在出现问题时（例如提交或推送）检测到，并提供一些解决问题的指导。还有独立的Git-GUI应用程序，甚至与内置系统工具集成，比如TortoiseGit（[https://tortoisegit.org/](https://tortoisegit.org/)），它将Git功能添加到Windows文件资源管理器中。
- en: Subversion
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Subversion
- en: Subversion (or SVN) is an older SCM that's been in play since early in 2004\.
    It's one of the most popular non-distributed SCMs still in use today. Like most
    SCMs before it, SVN stores a complete local copy of the code and content for each
    checked-out branch that it's tracking, and uploads those (perhaps in their entirety)
    during the commit process. It's also a centralized rather than a distributed system,
    which means that all branching and merging has to happen with respect to the master
    copy of the code base, wherever it might live.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Subversion（或SVN）是一种自2004年初以来就在使用的较老的SCM。它是今天仍在使用的最受欢迎的非分布式SCM之一。与它之前的大多数SCM一样，SVN存储了每个检出的分支的代码和内容的完整本地副本，并在提交过程中上传这些内容（可能是完整的）。它也是一个集中式而不是分布式系统，这意味着所有的分支和合并都必须相对于代码基础的主要副本进行，无论它可能存在于何处。
- en: The various under-the-hood differences and popularity of Git notwithstanding,
    SVN is a perfectly viable option for managing source code across a team, even
    if it's less efficient or less popular than Git. It fully supports the typical
    get-edit-commit work cycle, just not with the same degree of flexibility as Git
    provides.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Git的各种底层差异和流行程度，SVN仍然是管理团队源代码的一个完全可行的选择，即使它不如Git高效或受欢迎。它完全支持典型的获取-编辑-提交工作循环，只是没有Git提供的灵活性。
- en: Basic workflows for Git and SVN compared
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git和SVN的基本工作流程比较
- en: Although the basic checkout, work, merge, and commit workflow is supported by
    all mainstream SCMs, it's worth looking at some of the additional process steps
    that Git requires. Each additional step is, obviously, an additional task that
    a developer will have to perform before code is fully committed, though none of
    them are necessarily long-running tasks, so the impact is rarely going to be substantial.
    On the other hand, each additional step involved provides an additional point
    where additional code modification can be made before it's attached to the master
    version of the code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有主流SCM都支持基本的检出、工作、合并和提交工作流程，但值得看看Git需要的一些额外的流程步骤。显然，每个额外的步骤都是开发人员在代码完全提交之前必须执行的额外任务，尽管它们都不一定是长时间运行的任务，因此影响很少会是实质性的。另一方面，每个涉及的额外步骤都提供了一个额外的点，在这个点之前可以对代码进行额外的修改，然后再将其附加到代码的主要版本上。
- en: 'Compare the **Git Workflow** (left) and **SVN Workflow** (right):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 比较**Git工作流**（左）和**SVN工作流**（右）：
- en: '![](assets/4c3c0c41-6776-47a9-9746-f6b285d72ba8.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4c3c0c41-6776-47a9-9746-f6b285d72ba8.png)'
- en: The processes of getting the current version of the code and editing it are
    fundamentally the same.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取当前版本的代码并对其进行编辑的过程在根本上是相同的。
- en: Git allows the developer to **Stage Changes**. However, perhaps the modifications
    to the code in three out of five files are complete, and ready to be committed,
    at least locally, while there are significant efforts still needed on the other
    two. Since changes must be staged in Git prior to committing, the files that are
    done can be staged and then committed separately, leaving the others still in
    progress. Uncommitted staged files can still be edited and re-staged (or not)
    as needed as well; until a change-set is actually committed, everything is still
    in an in-progress state.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git允许开发人员**暂存更改**。然而，也许五个文件中有三个文件的代码修改已经完成，并且准备好至少在本地提交，而其他两个文件仍然需要大量工作。由于在提交之前必须在Git中暂存更改，因此可以将已完成的文件暂存，然后分别提交，而其他文件仍在进行中。未提交的暂存文件仍然可以根据需要进行编辑和重新暂存（或不进行暂存）；直到实际提交更改集，一切仍处于进行中状态。
- en: Git's **Commit Changes** is to a local repository, which again means that continued
    editing can happen, as well as manipulation of local commits, until everything
    is as it needs to be for the final master repository commit.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git的**提交更改**是针对本地存储库的，这意味着可以继续进行编辑，以及对本地提交进行操作，直到一切都符合最终主存储库提交的要求。
- en: Both provide the ability to perform a **Merge from Master** before the final
    **Push** or **Commit to Master** operations. Realistically, this can happen at
    any point prior to the final commit, but the granularity of Git's stage-then-commit
    approach lends itself well to doing so in smaller, more manageable chunks, which
    will often mean that any merges down from the master source code will also be
    smaller and easier to manage. There's no reason, on the SVN side, why similar
    periodic merges down can't be performed, it's just easier to remember to do so
    during a local commit routine during development.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最终**推送**或**提交到主存储库**操作之前，两者都提供了在**从主分支合并**的能力。实际上，这可以在最终提交之前的任何时候发生，但是Git的暂存然后提交的粒度方法很适合以更小、更易管理的块来执行此操作，这通常意味着从主源代码合并下来的任何合并也会更小，更容易管理。在SVN方面，没有理由不能执行类似的定期合并，只是在开发过程中进行本地提交例程时更容易记住这样做。
- en: Other SCM options
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他SCM选项
- en: 'Git and SVN are not the only available options, by any means. The next most
    popular options are the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Git和SVN并不是唯一的选择，绝对不是。下一个最受欢迎的选择是以下几种：
- en: '**Mercurial**:A free, open source SCM, written in Python, that uses a distributed
    structure like Git, but doesn''t require the change staging operation that Git
    does. Mercurial has been adopted for internal use by Google and Facebook.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mercurial**：一种免费的、开源的SCM，用Python编写，使用类似Git的分布式结构，但不需要Git所需的更改暂存操作。Mercurial已被Google和Facebook内部采用。'
- en: '**Perforce** **Helix Core**:A proprietary, distributed SCM that is at least
    somewhat compatible with Git commands, targeted for Enterprise clients and use.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Perforce** **Helix Core**：一种专有的、分布式的SCM，至少在一定程度上与Git命令兼容，面向企业客户和使用。'
- en: Best practices
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: There are any number of standards and best practices that surround development,
    at least once the code base(s) involved gets above a certain level of complexity.
    They are considered as such because they solve (or prevent) various difficulties
    that will likely arise if they aren't followed. A fair number of them also focus,
    if indirectly, on some aspect of future-proofing code, at least from the perspective
    of trying to make it easier for a new developer (or the same developer, maybe
    years later) to understand what the code does, how to find specific chunks of
    code, or, perhaps, to extend or refactor it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多标准和最佳实践围绕着开发，至少在涉及的代码基数达到一定复杂程度之后。它们被认为是这样，因为它们解决（或预防）了各种困难，如果不遵循这些困难很可能会出现。其中相当多的标准也间接地关注着代码的未来性，至少从尝试使新开发人员（或可能是同一开发人员，也许是几年后）更容易理解代码的功能，如何找到特定的代码块，或者扩展或重构它的角度来看。
- en: 'Those guidelines fall, roughly, into two categories, no matter the programming
    language:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指导方针大致分为两类，无论编程语言如何：
- en: '**Standards for code:** Guidelines and concepts that focus on the structure
    and organization of code, though not necessarily on how that code functions – more
    on keeping it easily understood and navigable'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码标准：**关于代码结构和组织的指导方针和概念，虽然不一定关注代码的功能方式，而更多地关注使其易于理解和导航'
- en: '**Process standards:** Guidelines and concepts that center around making sure
    that code is well behaved and that changes to it can be made with the minimum
    amount of hassle and disruption'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流程标准：**围绕着确保代码行为良好以及对其进行更改时可以尽量减少麻烦和干扰的指导方针和概念'
- en: 'Python adds two more items into that mix that don''t quite fit into either
    of those language-agnostic categories; they are the results of capabilities and
    functional requirements in the context of Python specifically:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Python在这方面增加了另外两个项目，它们不太适合于那些与编程语言无关的类别；它们是Python特定上下文中的能力和功能要求的结果：
- en: '**Package organization:** How best to structure code at a file-system level;
    where and when to generate new module files and package directories'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包组织：如何在文件系统级别最好地组织代码；何时何地生成新的模块文件和包目录
- en: '**When and how to use Python virtual environments:** What purposes they serve,
    and how best to leverage them for a given collection of code'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**何时以及如何使用Python虚拟环境：**它们的作用是什么，以及如何最好地利用它们来处理一组给定的代码'
- en: Standards for code
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码标准
- en: 'Code level standards, at the end of the day, are as much about trying to ensure
    that the code itself is written and structured in a predictable and easily understood
    manner as anything else. When those standards are followed, and when they are
    reasonably well understood by the developers who are working with the code base,
    it''s not unreasonable to expect that any developer, even one who may never have
    seen a given chunk of code, will nevertheless be able to do the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后，代码级别的标准实际上更多地是为了确保代码本身以可预测和易理解的方式编写和结构化。当这些标准被遵循，并且被与代码库一起工作的开发人员合理理解时，可以合理地期望任何开发人员，甚至是从未见过特定代码块的开发人员，仍然能够做到以下几点：
- en: Read and more easily understand the code and what it's doing
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读并更容易理解代码及其功能
- en: Find a code element (a class, function, constant, or some other item) that may
    only be identified by name, or in terms of a namespace, quickly and easily
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找一个代码元素（类、函数、常量或其他项），只能通过名称或命名空间来快速、轻松地识别
- en: Create new code elements in an existing structure that also conform to those
    standards
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现有结构中创建符合这些标准的新代码元素
- en: Modify existing code elements and know what standards-related items need to
    be modified in concert with those changes (if any)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改现有的代码元素，并了解需要与这些更改一起修改的与标准相关的项目（如果有）
- en: The Python community has one set of guidelines (PEP-8), but there may well be
    additional internal standards that are in place as well.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Python社区有一套指南（PEP-8），但也可能存在其他内部标准。
- en: PEP-8
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PEP-8
- en: At least some of Python's DNA is bound to the observation that code is generally
    read more often that it is written. That is the basis for significant functional
    aspects of its syntax, particularly those that relate to the structure of Python
    code, such as the use of indentation to indicate blocks of functionality. It should,
    perhaps, then come as no great surprise that one of the earliest **Python Enhancement
    Proposals** (**PEPs**) is a focused look at how to maintain readability of code
    where variations in style have no functional significance. PEP-8 is a long specification,
    some 29 pages if printed directly from the current Python page ([www.python.org/dev/peps/pep-0008](http://www.python.org/dev/peps/pep-0008)),
    but the significant aspects are worth summarizing here.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有一部分Python的基因是基于这样的观察：代码通常被阅读的次数比被编写的次数多。这是其语法的重要功能方面的基础，特别是与Python代码结构相关的方面，比如使用缩进来表示功能块。也许不足为奇的是，最早的Python增强提案之一（PEP）是专注于如何在样式变化没有功能意义的情况下保持代码的可读性。PEP-8是一个很长的规范，如果直接从当前Python页面打印，有29页（[www.python.org/dev/peps/pep-0008](http://www.python.org/dev/peps/pep-0008)），但其中重要的方面值得在这里总结。
- en: 'The first, and perhaps most significant, item therein is the recognition that
    while it''d be ideal if all Python code followed the same standards, there are
    a number of defensible reasons not to (see *A Foolish Consistency is the Hobgoblin
    of Little Minds* in PEP-8). Those include, but are not limited to, the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 其中第一个，也许是最重要的一点是认识到，虽然如果所有Python代码都遵循相同的标准会是理想的，但有许多可辩护的理由不这样做（参见PEP-8中的“愚蠢的一致性是小心思想的小恶魔”）。这些包括但不限于以下情况：
- en: When applying PEP-8 style guidelines would make the code less readable, even
    for someone who is used to reading code that follows the standards
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用PEP-8样式指南会使代码变得不易阅读，即使对于习惯于遵循标准的人也是如此
- en: To be consistent with surrounding code that also does not adhere to them (maybe
    for historic reasons)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了与周围的代码保持一致，而周围的代码也没有遵循它们（也许是出于历史原因）
- en: Because there is no reason other than the style guidelines to make changes to
    the code
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为除了样式指南之外没有理由对代码进行更改
- en: If adherence to the guidelines would break backwards compatibility (let alone
    functionality, though that seems unlikely)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果遵守这些指南会破坏向后兼容性（更不用说功能了，尽管这似乎不太可能）
- en: 'PEP-8 notes specifically that it is a style guide, and as mentioned in the
    Style Guide Introduction of Solidity v0.3.0:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: PEP-8特别指出它是一个样式指南，正如Solidity v0.3.0的样式指南介绍中所提到的：
- en: '"A style guide is about consistency. Consistency with this style guide is important.
    Consistency within a project is *more* important. Consistency within one module
    or function is the most important".'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: “样式指南是关于一致性的。遵循本样式指南是重要的。项目内的一致性*更*重要。一个模块或函数内的一致性是最重要的”。
- en: 'That implies that there may be good (or at least defensible) reasons to not
    adhere to some or all of the guidelines, even for new code. Examples might include
    the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着可能有很好（或至少是可辩护的）理由不遵守一些或所有的指南，即使是对于新代码。例如可能包括以下情况：
- en: Using naming conventions from another language because the functionality is
    equivalent, such as using JavaScript naming conventions in a Python class library
    that provides the same **Document Object Model** (**DOM**) manipulation functionality
    across a server-side class library for creating and working with DOM objects
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用另一种语言的命名约定，因为功能是等效的，比如在提供相同DOM操作功能的Python类库中使用JavaScript命名约定
- en: Using very specific documentation string structures or formats to conform to
    a documentation management system's requirements that applies to all code (Python
    or otherwise) across the business
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非常具体的文档字符串结构或格式，以符合文档管理系统对所有代码（Python或其他）的要求
- en: Conforming to other internal standards that contradict the ones advised by PEP-8
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循与PEP-8建议的标准相矛盾的其他内部标准
- en: Ultimately though, since PEP-8 is a set of style guidelines, not functional
    ones, the worst that can happen is that someone will complain that the code doesn't
    stick to the publicly accepted standards. If your code is never going to be shared
    outside your organization, that may well never be a concern.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，由于PEP-8是一套样式指南，而不是功能性指南，最糟糕的情况就是有人会抱怨代码不符合公认的标准。如果您的代码永远不会在组织外共享，那可能永远不会成为一个问题。
- en: 'There are three loose groupings in PEP-8''s guidelines whose members can be
    summarized briefly:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: PEP-8指南中有三个宽松的分组，其成员可以简要总结如下：
- en: '**Code layout**:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码布局**：'
- en: 'Indentation should be four spaces per level:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩进应为每级四个空格：
- en: Don't use tabs
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用制表符
- en: Hanging indentation should use the same set of rules wherever possible, see
    the PEP-8 page for specifics and recommendations
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 悬挂缩进应尽可能使用相同的规则，具体规则和建议请参阅PEP-8页面
- en: Functional lines should not exceed 79 characters in length and long text strings
    should be limited to 72 characters per line, including indentation spaces
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能行不应超过79个字符的长度，长文本字符串应限制在每行72个字符的长度，包括缩进空格
- en: If a line has to break around an operator (+, -, *, and, or, and so on), break
    it before the operator
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一行必须在运算符（+，-，*，and，or等）周围中断，那么在运算符之前中断
- en: Surround top-level functions and class definitions with two blank lines
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用两个空行包围顶级函数和类定义
- en: '**Comments**:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**注释**：'
- en: Comments that contradict the code are worse than no comments—always make a priority
    of keeping the comments up-to-date when the code changes!
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与代码相矛盾的注释比没有注释更糟糕——当代码发生变化时，始终优先保持注释的最新状态！
- en: Comments should be complete sentences. The first word should be capitalized,
    unless it is an identifier that begins with a lowercase letter (never alter the
    case of identifiers!).
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释应该是完整的句子。第一个单词应该大写，除非它是以小写字母开头的标识符（永远不要改变标识符的大小写！）。
- en: Block comments generally consist of one or more paragraphs built out of complete
    sentences, with each sentence ending in a period.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块注释通常由一个或多个段落组成，由完整句子构成，每个句子以句号结束。
- en: '**Naming conventions**:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名约定**：'
- en: Packages and modules should have short names, and use the `lowercase` or (if
    necessary) `lowercase_words` naming convention
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包和模块应该有短名称，并使用“lowercase”或（如果必要）“lowercase_words”命名约定
- en: Class names should use the `CapWords` naming convention
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名应使用“CapWords”命名约定
- en: Functions and methods should use the `lowercase_words` naming convention
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和方法应使用“lowercase_words”命名约定
- en: Constants should use the `CAP_WORDS` naming convention
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量应使用“CAP_WORDS”命名约定
- en: 'Other items that are noted in PEP-8 but are too long to summarize usefully
    here include the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: PEP-8中还有其他一些太长而无法在此进行有用总结的项目，包括以下内容：
- en: Source file encoding (which feels like it may soon stop being a concern)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源文件编码（感觉可能很快就不再是一个关注点）
- en: Imports
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入
- en: Whitespace in expressions and statements
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式和语句中的空格
- en: Documentation strings (which have their own PEP:  [www.python.org/dev/peps/pep-0257](http://www.python.org/dev/peps/pep-0257))
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档字符串（它们有自己的PEP：[www.python.org/dev/peps/pep-0257](http://www.python.org/dev/peps/pep-0257)）
- en: Designing for inheritance
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计继承
- en: These, along with PEP-8's substantial *Programming Recommendations* section,
    will be followed in code during the development of the `hms_sys` project where
    they don't conflict with other standards.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些，以及PEP-8的实质性“编程建议”部分，在“hms_sys”项目的开发过程中将被遵循，除非它们与其他标准冲突。
- en: Internal standards
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部标准
- en: Any given development effort, team, or even company may have specific standards
    and expectations around how code is written or structured. There may also be functional
    standards as well, things such as policies that define what types of external
    systems will be used to provide various functionality that systems consume, which
    RDBMS engines are supported, what web servers will be used, and so on. For the
    purposes of this book, the functional standards will be determined during development,
    but some code structure and format standards will be defined here and now. As
    a starting point, the PEP-8 code layout, comments, and naming convention standards
    will apply. Over and above that, there are some code organization and class structure
    standards that will also be in play.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 任何给定的开发工作、团队，甚至公司，可能都有特定的标准和期望，关于代码的编写或结构。也可能有功能标准，例如定义系统消耗的各种功能的外部系统类型的政策，支持哪些RDBMS引擎，将使用哪些Web服务器等。对于本书的目的，功能标准将在开发过程中确定，但是一些代码结构和格式标准将在此处定义。作为起点，将应用PEP-8的代码布局、注释和命名约定标准。除此之外，还有一些代码组织和类结构标准也将发挥作用。
- en: Code organization in modules
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块中的代码组织
- en: The PEP-8 structure and sequence guidelines will be followed, with a module
    level doc string, imports from `__future__`, various dunder-names (an `__all__`
    list to support `from [module] import [member]` use of the module's members, and
    some standard `__author__`, `__copyright__` and `__status__` metadata about the
    module), then imports from standard libraries, then third-party libraries, and
    finally internal libraries.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将遵循PEP-8的结构和顺序指南，包括模块级别的文档字符串，来自“__future__”的导入，各种dunder名称（一个“__all__”列表，支持对模块成员的“from
    [module] import [member]”使用，以及一些有关模块的标准“__author__”，“__copyright__”和“__status__”元数据），然后是来自标准库的导入，然后是第三方库，最后是内部库。
- en: 'After that, code will be organized and grouped by member types, in this order,
    with each element in alphabetical order (unless there are functional reasons why
    that order isn''t viable, such as classes depending on or inheriting from other
    classes that haven''t been defined yet if they are in strict order):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，代码将按成员类型组织和分组，按照以下顺序，每个元素按字母顺序排列（除非有功能上的原因，使得该顺序不可行，比如类依赖于或继承自尚未定义的其他类，如果它们是严格顺序的）：
- en: Module-level constants
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块级常量
- en: Custom exceptions defined in the module
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块中定义自定义异常
- en: Functions
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Abstract base classes that are intended to serve as formal interfaces
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旨在作为正式接口的抽象基类
- en: Abstract base classes that are intended to serve as standard abstract classes,
    or as mixins
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旨在作为标准抽象类或混合类的抽象基类
- en: Concrete classes
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体类
- en: The goal of all of these structure constraints is to provide some predictability
    across the entire code base, to make it easy to locate a given module member without
    having to search for it every single time. Modern IDEs, with the ability to control-click
    on a member name in code and jump straight to that member's definition, arguably
    make that unnecessary, but if code is going to be viewed or read by someone without
    access to such an IDE, organizing it this way still has some value.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些结构约束的目标是为整个代码库提供一些可预测性，使得能够轻松定位给定模块成员，而不必每次都去搜索它。现代集成开发环境（IDE）可以通过在代码中控制点击成员名称并直接跳转到该成员的定义，这可能使这种方式变得不必要，但如果代码将被查看或阅读者无法访问这样的IDE，以这种方式组织代码仍然具有一定价值。
- en: 'Accordingly, module and package header files follow a very specific structure,
    and that structure is set up in a set of template files, one for general purpose
    modules, and one for package header (`__init__.py`) modules. Structurally, they
    are identical, with only some slight variation between the two in the starting
    text/content. The `module.py` template then is the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模块和包头文件遵循非常特定的结构，并且该结构设置在一组模板文件中，一个用于通用模块，一个用于包头（`__init__.py`）模块。在结构上，它们是相同的，只是在起始文本/内容之间有一些轻微的变化。然后`module.py`模板如下：
- en: '[PRE0]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The only real differences between a module''s template and one for a package
    header is the initial documentation and that there is a specific callout for including
    child package and module namespace members in the `__all__` list:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 模块模板和包头文件模板之间唯一的真正区别是初始文档和在`__all__`列表中包含子包和模块命名空间成员的特定调用：
- en: '[PRE1]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Having these available as template files for developer use also makes starting
    a new module or package a bit quicker and easier. Copying the file, or its contents,
    to a new file takes a few seconds longer than just creating a new, blank file,
    but having the structure ready to start coding in makes it a lot easier to maintain
    the relevant standards.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '将这些作为开发人员可用的模板文件也使得开始一个新模块或包变得更快更容易。复制文件或其内容到一个新文件比只创建一个新的空文件多花几秒钟，但准备好开始编码的结构使得维护相关标准变得更容易。 '
- en: Structure and standards for classes
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类的结构和标准
- en: 'Class definitions, whether for concrete/instantiable classes or any of the
    ABC variants, have a similar structure defined, and will be arranged in sorted
    groups as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义，无论是用于具体/可实例化的类还是任何ABC变体，都有一个类似的结构定义，并将按照以下方式排列成分组：
- en: Class attributes and constants
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类属性和常量
- en: Property getter methods
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性获取方法
- en: Property setter methods
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性设置方法
- en: Property deleter methods
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性删除方法
- en: Instance property definitions
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例属性定义
- en: Object initialization (`__init__`)
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象初始化（`__init__`）
- en: Object deletion (`__del__`)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象删除（`__del__`）
- en: Instance methods (concrete or abstract)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例方法（具体或抽象）
- en: Overrides of standard built-in methods (`__str__`)
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写标准内置方法（`__str__`）
- en: Class methods
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类方法
- en: Static methods
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法
- en: The property getter, setter, and deleter methods approach was selected, rather
    than using method decoration, in order to make it easier to keep property documentation
    in a single location in the class definition. The use of properties (technically,
    they are managed attributes, but properties is a shorter name, and has the same
    meaning across several languages) as opposed to general attributes is a concession
    to unit testing requirements, and to a policy of raising errors as close to their
    cause as possible. Both will be discussed shortly, in the unit testing part of
    the *Process standards* section.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 选择了属性的getter、setter和deleter方法的方法，而不是使用方法装饰，是为了更容易地将属性文档保存在类定义的单个位置。使用属性（严格来说，它们是受控属性，但属性是一个更短的名称，并且在几种语言中具有相同的含义）而不是一般属性是对单元测试要求的让步，并且是尽可能接近其原因引发错误的策略。这两者将很快在*流程标准*部分的单元测试部分讨论。
- en: 'The concrete class template then contains the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 具体类的模板然后包含以下内容：
- en: '[PRE2]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Apart from the `__init__` method, which will almost always be implemented, the
    actual functional elements, the properties and methods, are commented out. This
    allows the standards expected to be present in the template, and developers can,
    if they so choose, simply copy and paste whichever code stub(s) they need, uncomment
    the whole pasted block, rename what needs to be renamed, and start writing code.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`__init__`方法，几乎总是会被实现，实际的功能元素，即属性和方法，都被注释掉。这允许模板中预期存在的标准，并且开发人员可以选择，只需复制并粘贴他们需要的任何代码存根，取消注释整个粘贴的块，重命名需要重命名的内容，并开始编写代码。
- en: 'The template file for abstract classes is very similar to the concrete class
    template, with the addition of a few items to accommodate code elements that are
    not present in a concrete class:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类的模板文件与具体类的模板文件非常相似，只是增加了一些项目来适应在具体类中不存在的代码元素：
- en: '[PRE3]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A similar template is also available for class definitions that are intended
    to serve as formal interfaces; classes that define functional requirements for
    an instance of a class, but that don''t provide any implementation of those requirements.
    It looks very much like the abstract class template, barring some name changes
    and the removal of anything that is or implies a concrete implementation:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个类似的模板可用于旨在作为正式接口的类定义；定义了类的实例的功能要求，但不提供这些要求的任何实现。它看起来非常像抽象类模板，除了一些名称更改和删除任何具体实现的内容：
- en: '[PRE4]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Taken together, these five templates should provide solid starting points for
    writing code for any of the more commonly expected element types expected in most
    projects.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个模板一起应该为编写大多数项目中预期的常见元素类型的代码提供了坚实的起点。
- en: Function and method annotation (hinting)
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和方法注释（提示）
- en: 'If you''ve worked with Python functions and methods before, you may have noticed
    and wondered about some unexpected syntax in some of the methods in the template
    files earlier, specifically the items in bold here:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前曾经使用过Python函数和方法，你可能已经注意到并对之前模板文件中一些方法中的一些意外语法感到困惑，特别是这里加粗的部分：
- en: '[PRE5]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These are examples of type hints that are supported in Python 3\. One of the
    standards that `hms_sys` code will also adhere to is that all methods and functions
    should be type hinted. The resulting annotations may eventually be used to enforce
    type checking of arguments using a decorator, and even later on may be useful
    in streamlining unit testing. On a shorter-term basis, there is some expectation
    that an automatic documentation generation system will pay attention to those,
    so they're part of the internal standards now.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是Python 3支持的类型提示的示例。`hms_sys`代码将遵循的标准之一是所有方法和函数都应该有类型提示。最终的注释可能会被用来使用装饰器来强制对参数进行类型检查，甚至以后可能会在简化单元测试方面发挥作用。在短期内，有一些预期，自动生成文档系统将关注这些内容，因此它们现在是内部标准的一部分。
- en: 'Type hinting is probably new enough that it''s not in common use just yet,
    so a walk-through of what it does and how it works is probably worth examination.
    Consider the following unannotated function and its results when executed:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示可能还不够常见，因此了解它的作用和工作原理可能值得一看。考虑以下未注释的函数及其执行结果：
- en: '[PRE6]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The results from executing that code look good:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 执行该代码的结果看起来不错：
- en: '![](assets/da5bef60-87f3-45c8-9f50-29ebc2ef05ca.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/da5bef60-87f3-45c8-9f50-29ebc2ef05ca.png)'
- en: This is pretty straightforward, as Python functions go. The `my_function` function
    expects a `name` and `price`, and also allows for a `description` argument, but
    that is optional and defaults to `None`. The function itself just collects all
    those into a formatted string-value and returns it. The `price` argument should
    be a number value of some sort, and the others should be strings, if they exist.
    In this case, the expected types of those argument values are probably obvious
    based on the argument names.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 就Python函数而言，这相当简单。`my_function`函数期望一个`name`和`price`，还允许一个`description`参数，但是这是可选的，默认为`None`。函数本身只是将所有这些收集到一个格式化的字符串值中并返回它。`price`参数应该是某种数字值，其他参数应该是字符串，如果它们存在的话。在这种情况下，根据参数名称，这些参数值的预期类型可能是显而易见的。
- en: The price argument, though, could be any of several different numerical types,
    and still function—`int` and `float` values obviously work, since the code runs
    without error. So too would a `decimal.Decimal` value, or even a `complex` type,
    as nonsensical as that would be. The type hinting annotation syntax exists, then,
    to provide a way to indicate without requiring what type or types of values are
    expected or returned.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，价格参数可以是几种不同的数值类型中的任何一种，并且仍然可以运行——显然`int`和`float`值可以工作，因为代码可以无错误运行。`decimal.Decimal`值也可以，甚至`complex`类型也可以，尽管那将是毫无意义的。类型提示注释语法存在的目的是为了提供一种指示预期值的类型或类型的方式，而不需要强制要求。
- en: 'Here''s the same function, hinted:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相同的函数，带有类型提示：
- en: '[PRE7]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The only differences here are the type hinting annotations after each argument
    and the return type hint at the end of the function''s first line, which indicate
    the expected types of each argument, and of the results of calling the function:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的区别是每个参数后面的类型提示注释和函数第一行末尾的返回类型提示，它们指示了每个参数的预期类型以及调用函数的结果的类型：
- en: '[PRE8]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output from the function call is identical, but the `__annotations__` attribute
    of the function is shown at the end of the output:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用的输出是相同的，但函数的`__annotations__`属性显示在输出的末尾：
- en: '![](assets/5eace41e-d234-4549-85e7-277465066658.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5eace41e-d234-4549-85e7-277465066658.png)'
- en: All the type-hinting annotations really do is to populate the `__annotations__`
    property of `my_function`, as shown at the end of the preceding execution. Essentially,
    they are providing metadata about and attached to the function itself that can
    be used later.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型提示注释实际上只是填充了`my_function`的`__annotations__`属性，如前面执行的结果所示。本质上，它们提供了关于函数本身的元数据，可以以后使用。
- en: 'Taken together then, all of these standards are intended to do the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有这些标准的目的是：
- en: Help keep code as readable as possible (baseline PEP-8 conventions)
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助保持代码尽可能可读（基本PEP-8约定）
- en: Keep the structure and organization of code within files predictable (module
    and class element organization standards)
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持文件中代码的结构和组织可预测（模块和类元素组织标准）
- en: Make it easy to create new elements (modules, classes, and so on) that conform
    to those standards (the various templates)
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使得创建符合这些标准的新元素（模块、类等）变得更容易（各种模板）
- en: Provide some degree of future-proofing against efforts to allow automated documentation
    generation, type checking of methods and functions, and possibly some unit testing
    efficiencies to be explored later (type-hinting annotations)
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在未来，提供一定程度的未来保障，以允许自动生成文档、方法和函数的类型检查，以及可能探索一些单元测试的效率（类型提示注释）
- en: Process standards
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过程标准
- en: 'Process standards are concerned with what processes are executed against a
    code base towards any of several purposes. The two that are most common as separate
    entities are the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 过程标准关注的是针对代码库执行的各种过程的目的。最常见的两种分开的实体是以下两种：
- en: '**Unit testing:** Ensuring that code is tested and can be re-tested on demand,
    in an effort to ensure in turn that it works as expected'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试：** 确保代码经过测试，并且可以根据需要重新测试，以确保其按预期工作'
- en: '**Repeatable build processes:** Designed so that whatever build process you
    use and probably the installation process as a result, is automated, error free,
    and repeatable on demand while requiring as little developer time to execute as
    possible'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重复的构建过程：** 设计成无论你使用什么构建过程，可能作为结果的安装过程都是自动化的、无错误的，并且可以根据需要重复执行，同时尽可能少地需要开发人员的时间来执行'
- en: Taken together, these two also lead to the idea of **integrating unit tests
    and build processes**, so that, if needful or desired, a build process can ensure
    that its resulting output has been tested.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 综合起来，这两个也导致了**集成单元测试和构建过程**的想法，这样，如果需要或者希望的话，构建过程可以确保其生成的输出已经经过测试。
- en: Unit testing
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'It''s not unusual for people, even developers, to think of unit testing as
    a process of making sure that bugs aren''t present in a code base. While there
    is a fair amount of truth to that, at least in smaller code bases, that''s actually
    more a result of the real purpose behind unit testing: unit testing is about ensuring
    that code behaves in a predictable fashion across all reasonably possible execution
    cases. The difference can be subtle, but it''s still a significant one.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 人们，甚至开发人员，认为单元测试是确保代码库中不存在错误的过程并不罕见。虽然在较小的代码库中这是有一定道理的，但这实际上更多是单元测试背后真正目的的结果：单元测试是确保代码在所有合理可能的执行情况下表现出可预测行为。这种差异可能微妙，但仍然是一个重要的差异。
- en: 'Let''s take another look at the preceding `my_function`,  this time from a
    unit testing perspective. It''s got three arguments, one that is a required string
    value, one that is a required number value, and one that is an optional string
    value. It makes no decisions based on any of those values or their types, it just
    dumps them into a string and returns that string. Let''s assume that the arguments
    supplied are properties of a product (which is what the output implies, even if
    that''s not really the case). Even without any decision making involved, there
    are aspects to the functionality that will raise errors, or that probably should
    in that context:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从单元测试的角度再次看一下前面的`my_function`。它有三个参数，一个是必需的字符串值，一个是必需的数字值，一个是可选的字符串值。它不会根据这些值或它们的类型做出任何决定，只是将它们转储到一个字符串中并返回该字符串。让我们假设提供的参数是产品的属性（即使实际情况并非如此）。即使没有涉及任何决策，该功能的某些方面也会引发错误，或者在这种情况下可能会引发错误：
- en: Passing a non-numeric `price `value will raise a `TypeError` because the string
    formatting won't format a non-numeric value with the `%0.2f` format specified
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递一个非数值的`price`值将引发`TypeError`，因为字符串格式化不会使用指定的`%0.2f`格式格式化非数值
- en: Passing a negative `price` value probably should raise an error—unless it's
    actually possible for a product to have a negative price, it just doesn't make
    sense
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递一个负的`price`值可能会引发错误——除非产品实际上可能具有负价格，否则这是没有意义的
- en: Passing a `price` value that is numeric, but isn't a real number (like a `complex`
    number) probably should raise an error
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递一个数值的`price`，但不是一个实数（比如一个`complex`数）可能会引发错误
- en: Passing an empty `name` value probably should raise an error—it makes no sense
    to have what we presume to be a product name accept an empty value
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递一个空的`name`值可能会引发错误——我们假设产品名称不接受空值是没有意义的
- en: Passing a multi-line `name` value might be a case that should raise an error
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递一个多行的`name`值可能是应该引发错误的情况
- en: Passing a non-string `name` value probably ought to raise an error as well,
    for similar reasons, as would a non-string `description` value
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递一个非字符串的`name`值也可能会因类似的原因而引发错误，非字符串的`description`值也是如此
- en: Apart from the first item in the list, these are all potential flaws in the
    function itself, none of which will raise any errors at present, but all of which
    could very well lead to undesirable behavior.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 除了列表中的第一项之外，这些都是函数本身的潜在缺陷，目前都不会引发任何错误，但所有这些都很可能导致不良行为。
- en: Bugs.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 错误。
- en: The following basic test code is collected in the `test-my_function.py` module.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下基本测试代码收集在`test-my_function.py`模块中。
- en: 'Even without bringing a formal unit testing structure into play, it''s not
    difficult to write code that will test a representative set of all good argument
    values. First, those values have to be defined:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有引入正式的单元测试结构，编写代码来测试所有良好参数值的代表性集合也并不难。首先，必须定义这些值：
- en: '[PRE9]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, it''s a simple matter of iterating over all the good combinations and
    keeping track of any errors that surface as a result:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，只需简单地迭代所有良好组合并跟踪任何因此而出现的错误：
- en: '[PRE10]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The results from executing that code look good:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 执行该代码的结果看起来不错：
- en: '![](assets/c119726e-0acd-4486-ae24-6c187cf44232.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c119726e-0acd-4486-ae24-6c187cf44232.png)'
- en: 'Next, a similar approach is taken for defining bad values for each argument,
    and checking each possible bad value with known good values:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对每个参数定义坏值采取类似的方法，并检查每个可能的坏值与已知的好值：
- en: '[PRE11]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Even with just the name argument tests in place, we already start seeing issues:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 即使只是放置了name参数测试，我们已经开始看到问题：
- en: '![](assets/0870e550-8c3c-4b42-bbea-31e3170ac59c.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0870e550-8c3c-4b42-bbea-31e3170ac59c.png)'
- en: 'And after adding in similar tests for price and description values:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 并在价格和描述值上添加类似的测试后：
- en: '[PRE12]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The resulting list of issues is larger still, with a total of 15 items, any
    of which could lead to a production code bug if they aren''t addressed:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 问题列表还更长，共有15项，如果不加以解决，任何一项都可能导致生产代码错误：
- en: '![](assets/3fad35b8-d5db-4a7a-ae38-1a9bb763e598.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3fad35b8-d5db-4a7a-ae38-1a9bb763e598.png)'
- en: 'It''s not enough, then, just to say that unit testing is a requirement in the
    development process; some thought has to be given to what those tests actually
    do, to what the relevant test policies look like, and what they are required to
    take into account. A good bare-bones starting point test policy would probably
    include, at a minimum the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，仅仅说单元测试是开发过程中的一个要求是不够的；必须考虑这些测试实际上做了什么，相关的测试策略是什么样的，以及它们需要考虑什么。一个良好的基本起点测试策略可能至少包括以下内容：
- en: 'What values are used when testing arguments or properties of specific types:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试参数或特定类型的属性时使用了哪些值：
- en: Numeric values should probably include even and odd variations, positive and
    negative values, and zero at a minimum
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值应该至少包括偶数和奇数变化、正数和负数值，以及零
- en: String values should include expected values, an empty string value, and strings 
    that are nothing more than whitespace (" ")
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串值应包括预期值、空字符串值和仅仅是空格的字符串(" ")
- en: Some understanding of when each of those values is valid and when they are not,
    for each element being tested
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个被测试元素，了解每个值何时有效何时无效的一些理解。
- en: Tests must be written for both passing and failing cases
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须为通过和失败的情况编写测试
- en: Tests must be written such that they execute every branch in the element being
    tested
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须编写测试，以便执行被测试元素中的每个分支
- en: That last item bears some explanation. Thus far, the code being tested made
    no decisions—it executes in exactly the same way, no matter what the values of
    the arguments are. A full unit test executed against code that does make decisions
    based on the values of arguments must be sure to pass test values for those arguments
    that invoke all of the decisions that the code can make. It is rare that this
    need will not be sufficiently accounted for by simply making sure that the good
    and bad test values are sufficiently varied, but it can become more difficult
    to ensure when complex class instances enter the picture, and those circumstances
    warrant closer, deeper attention.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一项需要一些解释。到目前为止，被测试的代码没有做出任何决定——无论参数的值如何，它都会以完全相同的方式执行。对于基于参数值做出决定的代码执行完整的单元测试必须确保为这些参数传递测试值，以调用代码可以做出的所有决定。通常情况下，通过确保良好和不良的测试值足够多样化，就可以充分满足这种需求，但当复杂的类实例进入图景时，确保这一点可能会变得更加困难，这些情况需要更密切、更深入的关注。
- en: 'It was noted earlier, in the discussion around class templates, that formal
    properties (managed attributes) would be used, and that the reason behind that
    tied in to unit testing policies. We''ve seen that it''s relatively easy to generate
    tests that can check for specific error types during the execution of a function
    or method. Since properties are collections of methods, one each for get, set,
    and delete operation, packaged up by the `property` keyword, it follows that performing
    checks against a value passed to a setter method and raising errors if the value
    or type passed in is invalid (and thus probably going to raise errors elsewhere)
    is going to make unit testing implementation following the structure/pattern shown
    earlier at least somewhat faster and easier. A basic structure, using the `property_name`
    property from the `class-concrete.py` template, shows that it''s quite straightforward
    to implement such a property:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在围绕类模板的讨论中早些时候就指出，将使用正式属性（受管理属性），而这背后的原因与单元测试政策有关。我们已经看到，相对容易生成可以在函数或方法执行期间检查特定错误类型的测试。由于属性是方法的集合，每个方法都用于获取、设置和删除操作，由`property`关键字打包，因此执行对传递给设置方法的值的检查，并在传递的值或类型无效（因此可能在其他地方引发错误）时引发错误，将使得单元测试实施遵循之前显示的结构/模式至少在某种程度上更快、更容易。使用`class-concrete.py`模板中的`property_name`属性的基本结构表明，实现这样的属性是相当简单的：
- en: '[PRE13]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are 18 lines of code involved, which is at least 17 lines more than would
    be required if `property_name` was a simple, unmanaged attribute, and there are
    probably going to be at least two more lines of code in the `__init__` method
    of the class that uses this property if `property_name` is set during the creation
    of an instance. The trade-off, though, is that the managed attribute property
    is going to be self regulating, so there won't have to be much in the way of checking
    its type or value wherever else it might be used. The fact that it is accessible
    at all, that the instance it's a member of hasn't thrown an error before the property
    is being accessed, means that it's in a known (and valid) state.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及18行代码，这至少比`property_name`是一个简单的、未管理的属性所需的17行代码多，如果`property_name`在创建实例的过程中被设置，那么使用这个属性的类的`__init__`方法中可能还会有至少两行代码。然而，权衡之处在于受管理的属性属性将是自我调节的，因此在其他地方使用它时，不需要太多检查其类型或值。它可以被访问的事实，即在访问属性之前，它所属的实例没有抛出错误，意味着它处于已知（和有效）状态。
- en: Repeatable build processes
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重复构建过程
- en: The idea of having a build process may have originated with languages that require
    compilation before their code can be executed, but there are advantages to establishing
    such a process even for languages such as Python that don't. In Python's case,
    specifically, such a process can collect code from multiple project code bases,
    define requirements without actually attaching them to the final package, and
    package code up in a consistent fashion, ready for installation. Since a build
    process is, itself, another program (or at least a script-like process), it also
    allows for the possibility of executing other code to whatever end is needed,
    which means that a build process can also execute automated tests, or even potentially
    deploy code to a designated destination, locally or remotely.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有构建过程的想法可能起源于需要在其代码执行之前进行编译的语言，但即使对于像Python这样不需要编译的语言，建立这样一个过程也有优势。在Python的情况下，这样的过程可以从多个项目代码库中收集代码，定义要求，而不实际将它们附加到最终包中，并以一致的方式打包代码，准备进行安装。由于构建过程本身是另一个程序（或至少是一个类似脚本的过程），它还允许执行其他代码以满足需要，这意味着构建过程还可以执行自动化测试，甚至可能部署代码到指定的目的地，本地或远程。
- en: 'Python''s default installation includes two packaging tools, `distutils` ,
    which is a collection of bare-bones functionality, and `setuptools`, which builds
    on top of that to provide a more powerful packaging solution. The output of a
    `setuptools` run, if packaging arguments are supplied, is a ready-to-install package
    (an egg). The conventional practice for the creation of a package is through a
    `setup.py` file that makes a call to the setup function that `setuptools` provides,
    which might look something like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Python的默认安装包括两个打包工具，`distutils`是一组基本功能，`setuptools`在此基础上提供了更强大的打包解决方案。如果提供了打包参数，`setuptools`运行的输出是一个准备安装的包（一个egg）。创建包的常规做法是通过一个`setup.py`文件，该文件调用`setuptools`提供的setup函数，可能看起来像这样：
- en: '[PRE14]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The arguments shown all relate to specific aspects of the final package:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 所示的参数都与最终包的特定方面有关：
- en: '`name`: Defines the base name for the final package file (for example, `MyPackageName`)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`名称`：定义最终包文件的基本名称（例如，`MyPackageName`）'
- en: '`version`: Defines the version of the package, a string that will also be part
    of the final package file''s name'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`版本`：定义包的版本，这个字符串也将成为最终包文件名称的一部分'
- en: '`author`: The name of the primary author of the package'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`作者`：包的主要作者的姓名'
- en: '`description`: A short description of the package'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`描述`：包的简要描述'
- en: '`long_description`: A long description of the package; this is often implemented
    by opening and reading a file containing the long description data, typically
    in Markdown format if the package is intended to be uploaded to the Python website''s 
    package repository'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`长描述`：包的长描述；通常通过打开和读取包含长描述数据的文件来实现，如果包打算上传到Python网站的包存储库，则通常以Markdown格式呈现'
- en: '`author_email`: The email address of the primary author of the package'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`作者电子邮件`：包的主要作者的电子邮件地址'
- en: '`url`: The home URL for the package'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`网址`：包的主页网址'
- en: '`install_requires`: A list of package name and version requirements that need
    to be installed in order to use the code in the package – a collection of dependencies'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install_requires`：需要安装的包名称和版本要求的列表，以便使用包中的代码 - 依赖项的集合'
- en: '`package_dir`: A dictionary that maps package names to source directories;
    the `''package_name'':''project_root_directory''` value shown is typical for projects
    that have their source code organized under a `src` or `lib` directory, often
    at the same level in the filesystem as the `setup.py` file itself'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package_dir`：将包名称映射到源目录的字典；所示的`''package_name'':''project_root_directory''`值对于将源代码组织在`src`或`lib`目录下的项目来说是典型的，通常与`setup.py`文件本身在文件系统中的同一级别'
- en: '`packages`: A list of packages that will be added to the final output package;
    the `setuptools` module also provides a function, `find_packages`, that will search
    out and return that list, with provisions for explicit exclusion of package directories
    and files using a list of patterns to define what should be left out'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`packages`：将添加到最终输出包中的包的列表；`setuptools`模块还提供了一个`find_packages`函数，它将搜索并返回该列表，并提供了使用模式列表来定义应该排除什么的明确排除包目录和文件的规定'
- en: '`package_data`: A collection of non-Python files that need to be included in
    the package directory that they are mapped to; that is, in the example shown,
    the `setup.py` run will look for a `package_name` package (from the packages list),
    and include the `file_name.ext` file in that package because it''s been listed
    for inclusion'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package_data`：需要包含在其映射到的包目录中的非Python文件的集合；也就是说，在所示的示例中，`setup.py`运行将寻找`package_name`包（来自包列表），并将`file_name.ext`文件包含在该包中，因为它已被列为要包含的文件'
- en: '`entry_points`: Allows the installer to create command-line-executable aliases
    for specific functions in the code base; what it will actually do is create a
    small, standard Python script that knows how to find and load the specified function
    from the package, then execute it'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry_points`：允许安装程序为代码库中特定函数创建命令行可执行别名；它实际上会创建一个小型的标准Python脚本，该脚本知道如何找到并加载包中指定的函数，然后执行它'
- en: A far more detailed look at the creation, execution, and results from an actual
    `setup.py` will be undertaken with the first package created for `hms_sys`. There
    are also options for specifying, requiring, and executing automated unit tests
    that will be explored. If they provide the test execution and stop-on-failure
    functionality needed, then `setuptools.setup` will probably suffice for all the
    needs of `hms_sys`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 对于为`hms_sys`创建的第一个包，将对实际`setup.py`的创建、执行和结果进行更详细的查看。还有一些选项用于指定、要求和执行自动化单元测试，这些将被探讨。如果它们提供了所需的测试执行和失败停止功能，那么`setuptools.setup`可能足以满足`hms_sys`的所有需求。
- en: If there are additional needs discovered that a standard Python setup process
    cannot manage for whatever reason, then a fallback build process will be needed,
    though it will almost certainly still use the results of a `setup.py` run as part
    of its process. In order to keep that fallback as (relatively) simple as possible,
    and to ensure that the solution is available across as many different platforms
    as possible, the fallback will use GNU Make.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现有额外的需求，标准的Python设置过程无法管理，无论出于什么原因，都需要一个备用的构建过程，尽管它几乎肯定仍然会使用`setup.py`运行的结果作为其过程的一部分。为了尽可能地保持备用方案（相对）简单，并确保解决方案在尽可能多的不同平台上可用，备用方案将使用GNU
    Make。
- en: 'Make operates by executing command-line scripts for each target that is specified
    in a `Makefile`. A simple `Makefile`, with targets for testing and executing a
    `setup.py` file, is very simple:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Make通过执行在`Makefile`中指定的每个目标的命令行脚本来运行。一个简单的`Makefile`，包含用于测试和执行`setup.py`文件的目标，非常简单：
- en: '[PRE15]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Running a Make process from the command line is as simple as executing `make`,
    perhaps with a target specification:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行运行Make过程就像执行`make`一样简单，也许还可以指定目标：
- en: '![](assets/c6164b64-9f8f-47cf-8a44-41abbb02a21f.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c6164b64-9f8f-47cf-8a44-41abbb02a21f.png)'
- en: 'The first run (`make` without any target specified) executes the first target
    in the `Makefile`: `main`. The `main` target, in turn, has the `test` and `setup`
    targets specified as prerequisite targets to execute before moving ahead with
    its own processes. The same results would be returned if `make main` were executed.
    The second and third runs, `make test` and `make setup`, respectively, execute
    those specific targets.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行（未指定任何目标的`make`）执行`Makefile`中的第一个目标：`main`。`main`目标又有`test`和`setup`目标作为先决条件目标指定，在继续执行自己的流程之前执行。如果执行`make
    main`，将返回相同的结果。第二次和第三次运行，分别执行特定的目标`make test`和`make setup`。
- en: Make, then, is a very flexible and powerful tool to have available. So long
    as a given build process step can be executed in the command line, it can be incorporated
    into a Make-based build. If different processes are needed for different environments
    (`dev`, `test`, `stage` , and `live`, for example), it's possible to set up Make
    targets that correspond to those environments, allowing one build process to handle
    those variations with nothing more complex than executing `make dev`, `…`, `make
    live`, though some care in target naming will be needed to avoid name collisions
    between two different but logically sound `test` targets in this case.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Make是一个非常灵活和强大的工具。只要给定的构建过程步骤可以在命令行中执行，就可以将其纳入基于Make的构建中。如果不同的环境需要不同的流程（例如`dev`，`test`，`stage`和`live`），则可以设置与这些环境对应的Make目标，允许一个构建过程处理这些变化，只需执行`make
    dev`，`…`，`make live`，尽管在目标命名上需要一些小心，以避免在这种情况下两个不同但逻辑上合理的`test`目标之间的名称冲突。
- en: Integrating unit tests and build processes
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成单元测试和构建过程
- en: The build process, as hinted earlier, should allow the incorporation and execution
    of all available automated tests (unit tests at a minimum) that are created for
    a project. The goal of that integration is to prevent code that's failed its suite
    of tests from being buildable, and thus deployable, and thus to ensure that only
    demonstrably good code is available for installation, at least at a live or production
    code level.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，构建过程应允许纳入并执行为项目创建的所有可用自动化测试（至少是单元测试）。该集成的目标是防止未通过测试套件的代码可构建，因此可部署，并确保只有经证明良好的代码可用于安装，至少在生产代码级别。
- en: 'It may be necessary to allow broken code, code that fails its tests, to be
    buildable at a local or shared development build level, though, if only because
    developers may well want or need to install a broken build in order to troubleshoot
    issues. That will be very circumstantial, dependent on whatever policies and procedures
    are in place to handle circumstances like that. A possible policy set, based on
    five environments, might boil down to the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要允许损坏的代码，在本地或共享开发构建级别构建，尽管只是因为开发人员可能需要安装损坏的构建来解决问题。这将是非常具体的，取决于处理这种情况的政策和程序。基于五个环境的可能政策集可能归结为以下内容：
- en: '**Local development:** No testing required at all'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地开发：**根本不需要测试'
- en: '**Shared development:** Test required, but failed tests do not kill the build
    process, so broken builds can be promoted to the common dev server(s); broken
    builds are logged, however, and those logs are easily available in case there''s
    a need to promote code in a hurry'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享开发：**测试是必需的，但是失败的测试不会中断构建过程，因此损坏的构建可以被推广到共同的开发服务器；但是损坏的构建会被记录，这些日志在需要紧急推广代码时很容易获得。'
- en: '**QA/test:** As the shared development environment'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QA/测试：**与共享开发环境相同'
- en: '**Staging** (and **User Acceptance Testing**) **environments:** Tests must
    execute and pass for code to be installed or promoted'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暂存**（和**用户验收测试**）**环境：**必须执行并通过测试才能安装或推广代码'
- en: '**Live/production:** As staging'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产环境：**与暂存相同'
- en: If the standard `setuptools`-based packaging process will allow tests to run,
    cause failed tests to abort the packaging effort, and won't require tests to execute
    during installation, then that provides adequate functional coverage of this sort
    of policy set, though use of a wrapper (such as Make) to provide environment-specific
    targets and build processes may be needed to deal with policy conformance/coverage.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标准的`setuptools`-based打包过程允许运行测试，导致失败的测试中止打包工作，并且在安装期间不需要执行测试，那么这提供了这种政策集的足够功能覆盖，尽管可能需要使用包装器（如Make）提供特定于环境的目标和构建过程，以处理政策的一致性/覆盖。
- en: If unit testing and build process standards are in place and followed, the end
    result will tend to be code that is both easily built and deployed, no matter
    what state it might be in, and that behaves in a known (and provable) fashion
    under all known circumstances. That doesn't mean that it will be free of bugs,
    though; it's much less likely to have any significant bugs, so long as the test
    suite(s) are thorough and complete, but that's not a guarantee.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果制定并遵循了单元测试和构建过程标准，最终结果往往是代码很容易构建和部署，无论其状态如何，并且在所有已知情况下都以已知（且可证明）的方式运行。这并不意味着它将没有错误，尽管，只要测试套件很全面和完整，它就不太可能有任何重大错误，但这并不是一个保证。
- en: There is some overhead involved in establishing the associated processes, and,
    particularly on the unit testing side, still more overhead in maintaining them,
    but the effects and impact on a system's stability can be amazing.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 建立相关流程需要一些额外开销，特别是在单元测试方面，维护这些流程的开销更大，但对系统稳定性的影响和影响可能是惊人的。
- en: The author once wrote an asset catalog system for an advertising firm that was
    in daily use by as many as 300 people every business day following these process
    guidelines. Over the course of four years, runtime, including an update to a new
    and significantly changed version of the system, the total number of errors reported
    that weren't user error, data entry errors, or enterprise-level access permissions
    was four. These process standards make a difference.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 作者曾为一家广告公司编写过一个资产目录系统，该系统每个工作日都有多达300人在使用，遵循这些流程指南。在四年的时间里，包括对系统进行了更新和显著改变版本，报告的错误总数（不包括用户错误、数据输入错误或企业级访问权限）只有四个。这些流程标准产生了影响。
- en: Defining package structures for Python code
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Python代码定义包结构
- en: 'The package structure rules in Python are important, since they will determine
    what code is accessible when an attempt is made to import members from that package.
    Package structure is also a subset of the overall project structure that can have
    a significant impact on an automated build process, and it might also have an
    impact on unit testing setup and execution. Let''s start then by examining a possible
    top-level project structure first, as shown here, and then review what a Python
    package''s requirements are, and see how it fits into the project overall:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的包结构规则很重要，因为它们将决定在尝试从该包中导入成员时可以访问到哪些代码。包结构也是整体项目结构的一个子集，可能对自动化构建过程产生重大影响，也可能对单元测试的设置和执行产生影响。让我们首先从检查可能的顶层项目结构开始，如下所示，然后审查Python包的要求，并看看它如何适应整体项目：
- en: '![](assets/f45a3c24-c8ce-41a4-8da5-36ea2ff5459d.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f45a3c24-c8ce-41a4-8da5-36ea2ff5459d.png)'
- en: 'This project structure assumes that the final build will be installed on a
    POSIX system – most Linux installations, macOS, UNIX, and so  on. There may be
    different needs for, say, a Windows installation, and that will be explored during
    the `hms_sys` development cycle, when we start working out the remote desktop
    applications for it. Even so, the structure may still hold up:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目结构假设最终构建将安装在POSIX系统上 - 大多数Linux安装、macOS、UNIX等。对于Windows安装可能有不同的需求，在`hms_sys`开发周期中将进行探讨，当我们开始为其制定远程桌面应用程序时。即便如此，这个结构可能仍然保持不变：
- en: The `bin` directory is intended to collect code and programs that the end user
    can execute, whether from a command line, or through the GUI of the OS. Those
    items may or may not use the main package's code, though the odds are good that
    it will if they are Python executables.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bin`目录旨在收集最终用户可以执行的代码和程序，无论是从命令行还是通过操作系统的GUI。这些项目可能会或可能不会使用主包的代码，尽管如果它们是Python可执行文件，那么它们很可能会使用。'
- en: The `etc` directory is where configuration files are stored, and the `example_project`
    directory beneath that would then be for a configuration that is very specific
    to the final installed instance of the project. It may be feasible, or even a
    better approach, to drop project-specific configurations in the top-level, and
    so on, directory—that decision will need to be evaluated on a project-by-project
    basis, and may depend on whether the end user installing the project has permissions
    to install to global directories.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etc`目录是存储配置文件的地方，然后`etc`目录下的`example_project`目录将用于存储与项目最终安装实例非常特定的配置。将项目特定的配置放在顶层目录中可能是可行的，甚至可能是更好的方法，这将需要根据项目的具体情况进行评估，并可能取决于安装项目的最终用户是否有权限安装到全局目录。'
- en: The `scratch-space` directory is just a place to collect whatever random files
    might be useful during development – proof-of-concept code, note files, whatever.
    It's not intended to be part of a build and won't be deployable.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scratch-space`目录只是一个收集在开发过程中可能有用的任何随机文件的地方 - 概念验证代码，笔记文件等。它不打算成为构建的一部分，也不会被部署。'
- en: The `src` directory is where the project code lives. We'll dig deeper into that
    shortly.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`目录是项目代码所在的地方。我们很快就会深入探讨。'
- en: The `var` directory is where POSIX systems store program data that needs to
    be persisted as files. The `cache` directory within it is a standard POSIX location
    for caching files, and the `example_project` directory within that would therefore
    be the location specifically for the project's code to cache files. It may be
    useful to have a dedicated, project-specific directory in `var` that's not in
    `cache`, and that's also provided.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var`目录是POSIX系统存储需要以文件形式持久保存的程序数据的地方。其中的`cache`目录是缓存文件的标准POSIX位置，因此其中的`example_project`目录将是项目代码专门用于缓存文件的位置。在`var`中有一个专门的、项目特定的目录，不在`cache`中，这也是提供的。'
- en: Packages in a project's context
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目上下文中的包
- en: 'Within the `src` directory is the package tree for the project. Each directory
    level at or under the `example_project` directory that has an `__init__.py` file
    is a formal Python package, and will be accessible through an import statement
    in Python code. Once this project is built and installed, then, and assuming that
    the code within it is written to accommodate the relevant import structure, all
    of the following would be legitimate imports from the project''s code:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`src`目录中是项目的包树。在`example_project`目录下的每个具有`__init__.py`文件的目录级别都是一个正式的Python包，并且可以通过Python代码中的导入语句访问。一旦这个项目被构建和安装，假设其中的代码是按照相关的导入结构编写的，那么以下所有内容都将是项目代码的合法导入：'
- en: '| `import example_project` | Imports the entire `example_project` namespace
    |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `import example_project` | 导入整个`example_project`命名空间 |'
- en: '| `import example_project.package` | Imports `example_project.package` and
    all its members |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `import example_project.package` | 导入`example_project.package`和它的所有成员 |'
- en: '| `from example_project import package` |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `from example_project import package` |'
- en: '| `from example_project.package import member` | Assuming that `member` exists,
    imports it from `example_project.package` |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `from example_project.package import member` | 假设`member`存在，从`example_project.package`导入它
    |'
- en: '| `import example_project.package.subpackage` | Imports `example_project.package.subpackage`
    and all its members |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `import example_project.package.subpackage` | 导入`example_project.package.subpackage`和它的所有成员
    |'
- en: '| `from example_project.package import subpackage` |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `from example_project.package import subpackage` |'
- en: '| `from example_project.package.subpackage import member` | Assuming that `member`
    exists, imports it from `example_project.package.subpackage` |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `from example_project.package.subpackage import member` | 假设`member`存在，从`example_project.package.subpackage`导入它
    |'
- en: 'A typical pattern for packages in Python is to group code elements around common
    realms of functionality. For example, a package that, at a very high level, is
    focused on DOM manipulation (HTML page structure), and supports XML, XHTML, and
    HTML5 might group things like so:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: Python包的典型模式是围绕功能的共同领域将代码元素分组。例如，一个在非常高的层次上专注于DOM操作（HTML页面结构）并支持XML、XHTML和HTML5的包可能会这样分组：
- en: '`dom (__init__.py)`'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dom (__init__.py)`'
- en: '`generic (__init__.py)`'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generic (__init__.py)`'
- en: '[General-purpose classes for working with elements]'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[用于处理元素的通用类]'
- en: '`html (__init__.py)`'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`html (__init__.py)`'
- en: '`generic (generic.py)`'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generic (generic.py)`'
- en: '[General-purpose classes for working with HTML elements]'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[用于处理HTML元素的通用类]'
- en: '``forms (forms.py)``'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '``forms (forms.py)``'
- en: '`html5 (__init__.py)`'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`html5 (__init__.py)`'
- en: '[Classes for working with HTML-5-specific elements]'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[用于处理HTML-5特定元素的类]'
- en: '`forms (forms.py)`'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forms (forms.py)`'
- en: '`xhtml (__init__.py)`'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xhtml (__init__.py)`'
- en: '[Classes for working with XHTML-specific elements]'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[用于处理XHTML特定元素的类]'
- en: '`forms (forms.py)`'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forms (forms.py)`'
- en: '`xml (__init__.py)`'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xml (__init__.py)`'
- en: A full implementation, then, of that structure might allow a developer to access
    an HTML5 Email field object by creating an instance of a class that lived at the
    `dom.html5.forms.EmailField` namespace, and whose code lived in `.../dom/html5/forms.py`
    as a class named `EmailField`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该结构的完整实现可能允许开发人员通过创建一个生活在`dom.html5.forms.EmailField`命名空间中的类的实例来访问HTML5的Email字段对象，并且其代码位于`.../dom/html5/forms.py`中，作为一个名为`EmailField`的类。
- en: Deciding where specific classes, functions, constants, and so on should exist
    in the structure of a code base is a complex topic, and will be explored in greater
    depth as part of the early architecture and design of `hms_sys`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 决定代码库结构中特定类、函数、常量等应该存在的位置是一个复杂的话题，将在`hms_sys`的早期架构和设计的一部分中进行更深入的探讨。
- en: Using Python virtual environments
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python虚拟环境
- en: Python allows a developer to create virtual environments that collect up all
    the baseline language facilities and functionality into a single location. Once
    set up, those virtual environments have packages installed in to or removed from
    them, which allows a project that's executing in the context of the environment
    to have access to packages and functionality that may not be needed in the base
    system. A virtual environment also provides a mechanism for keeping track of those
    installations, which in turn allows a developer to keep track of only those dependencies
    and requirements that are relevant to the project itself.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许开发人员创建虚拟环境，将所有基线语言设施和功能收集到一个单一位置。一旦设置好，这些虚拟环境就可以安装或移除其中的包，这允许在环境上下文中执行的项目访问可能不需要在基本系统中的包和功能。虚拟环境还提供了一种跟踪这些安装的机制，这反过来允许开发人员只跟踪与项目本身相关的那些依赖和要求。
- en: Virtual environments can also be used, with some care and thought, to allow
    a project to be developed against a specific version of the Python language –
    one that's no longer supported, for example, or that's still too new to be available
    as a standard installation in the development machine's OS. This last aspect can
    be very useful in developing Python applications to run in various public clouds
    such as Amazon's AWS, where the Python version may be newer than what's generally
    available, and may also have significant syntax differences from earlier versions
    of the language.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境也可以被使用，只要小心谨慎地考虑，就可以允许项目针对特定版本的Python语言进行开发 - 例如，一个不再受支持的版本，或者一个在开发机器的操作系统中还太新而无法作为标准安装。这最后一个方面在开发Python应用程序以在各种公共云中运行时非常有用，比如亚马逊的AWS，在那里Python版本可能比通常可用的要新，也可能与语言早期版本有显著的语法差异。
- en: Breaking changes at the language level aren't very common, but they have happened
    in the past. Virtual environments won't solve those, but they will, at least,
    allow different versions of code to be maintained with more ease.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 语言级别的重大变化并不常见，但过去确实发生过。虚拟环境不能解决这些问题，但至少可以更轻松地维护不同版本的代码。
- en: 'Provided that the appropriate Python module (`venv` in Python 3) is already
    installed, creating a virtual environment, activating, and deactivating it at
    a command-line level is pretty straightforward:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 假设适当的Python模块（Python 3中的`venv`）已经安装，创建虚拟环境，激活和停用它在命令行级别是非常简单的：
- en: '![](assets/38b5c2fb-3d5a-421d-be9a-1e53fd809b99.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/38b5c2fb-3d5a-421d-be9a-1e53fd809b99.png)'
- en: '[PRE16]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Creates a new, minimal virtual environment at the specified location (in this
    case, in a directory named `example_ve`, in a directory named `py_envs` in the
    user''s home directory):'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定位置（在这种情况下，在名为`example_ve`的目录中，在用户主目录中名为`py_envs`的目录中）创建一个新的、最小的虚拟环境：
- en: '[PRE17]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This activates the newly created virtual environment. At this point, launching
    `python` shows that it''s using version 3.5.2, and the command line interface
    prefaces each line with `(example_ve)` to show that the virtual environment is
    active:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这激活了新创建的虚拟环境。此时，启动`python`会显示它正在使用版本3.5.2，并且命令行界面在每一行前面都加上`(example_ve)`，以显示虚拟环境是激活的：
- en: '[PRE18]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This deactivates the active virtual environment. Launching `python` from the
    command-line now shows the default Python version, 2.7.12, for the system.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这停用了活动的虚拟环境。现在从命令行启动`python`会显示系统的默认Python版本2.7.12。
- en: 'Installing, updating, and removing packages, and showing what packages are
    installed, are equally straightforward:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 安装、更新和删除包，并显示已安装的包，同样也很简单：
- en: '![](assets/338a4a04-54ba-4f30-9a7e-84635fca9214.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/338a4a04-54ba-4f30-9a7e-84635fca9214.png)'
- en: 'This activates the virtual environment again:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这将再次激活虚拟环境：
- en: '[PRE19]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This shows the list of currently installed packages. It does not show any of
    the packages that are part of the core Python distribution, only those that have
    been added.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了当前安装的软件包列表。它不显示任何属于核心Python分发的软件包，只显示已添加的软件包。
- en: '[PRE20]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The first run, in this case, also notes that the current version of `pip` in
    the environment is old and can be updated, which is done with this command:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，第一次运行还指出环境中的当前版本的“pip”已经过时，可以使用以下命令进行更新：
- en: '[PRE21]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `pip` package itself is part of the base Python installation, and even though
    it's just been updated, that has no effect on the list of packages returned by
    calling `pip freeze` again.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: “pip”软件包本身是基本Python安装的一部分，即使它刚刚更新，这也不会影响通过再次调用“pip freeze”返回的软件包列表。
- en: 'To illustrate how `pip` deals with installation of new packages, the `pillow`
    library, a Python API for working with graphics files, was installed with this:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明“pip”如何处理新软件包的安装，使用了“pillow”库，这是一个用于处理图形文件的Python API：
- en: '[PRE22]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Since `pillow` is not a standard library, it does appear in the results of
    another `pip freeze` call. The results of `pip freeze` can be dumped to a requirements
    file (`requirements.txt`, for the purposes of illustration) as part of a project
    structure, and stored with the project, so that package dependencies don''t actually
    have to live in the source tree of the project, or be stored with it in an SCM.
    That would allow a new developer on a project to simply create their own virtual
    environment, then install the dependencies with another `pip` call:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“pillow”不是标准库，它出现在另一个“pip freeze”调用的结果中。 “pip freeze”的结果可以作为项目结构的一部分转储到要求文件（例如“requirements.txt”），并与项目一起存储，以便软件包依赖关系实际上不必存储在项目的源树中，或者与之一起存储在SCM中。这将允许项目中的新开发人员简单地创建自己的虚拟环境，然后使用另一个“pip”调用安装依赖项：
- en: '[PRE23]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `pillow` library was then uninstalled to show what that looks like, with
    this:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 然后卸载了“pillow”库，以展示其外观，使用了以下命令：
- en: '[PRE24]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `pip` program does a good job of keeping track of dependencies, but it may
    not be foolproof. Even if uninstalling a package removes something that it lists
    as a dependency, but that's still in use, it's easy enough to re-install it with
    another `pip` call.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: “pip”程序在跟踪依赖关系方面做得很好，但可能并非百分之百可靠。即使卸载软件包会删除它列为依赖项的内容，但仍在使用，也很容易使用另一个“pip”调用重新安装它。
- en: 'Virtual environments, then, allow for a lot of control over what third-party
    packages can be associated with a project. They come with a small price, though:
    they have to be maintained, if rarely, and as changes to those external packages
    are made by one developer, some discipline needs to be exerted to make sure that
    those changes are available for other developers working on the same code base.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，虚拟环境允许对与项目关联的第三方软件包进行很好的控制。然而，它们也有一些小小的代价：它们必须被维护，尽管很少，当一个开发人员对这些外部软件包进行更改时，需要一些纪律来确保这些更改对其他在同一代码库上工作的开发人员是可用的。
- en: Summary
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: There are a fair few factors that can affect how code is written and managed,
    even before the first line of code is written. Each of them can have some impact
    on how smoothly a development effort progresses, or on how successful that effort
    is. Fortunately, there are a lot of options, and a fair amount of flexibility
    in making the decisions that determine which of them are in play, and how, even
    assuming that some team or managerial-level policies don't dictate them.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多因素可能会影响代码的编写和管理，甚至在编写第一行代码之前。它们中的每一个都可能对开发工作的顺利进行或该工作的成功产生一定影响。幸运的是，有很多选择，并且在决定哪些选择起作用以及如何起作用时有相当大的灵活性，即使假设一些团队或管理层的政策没有规定它们。
- en: 'Several of the decisions concerning these items for the `hms_sys` project have
    been noted, but since the next chapter starts on that development for real, they
    might be worth calling out once more:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 关于“hms_sys”项目中这些项目的决定已经注意到，但由于下一章将真正开始开发，可能值得再次提出：
- en: Code will be written using either Geany or LiClipse as the IDE. They both provide
    code project management facilities that should handle the multiple-project structure
    that's expected, and will provide enough of the bells and whistles needed to make
    navigating across projects relatively painless. Initially, the effort will use
    Geany, and LiClipse will be held in reserve if Geany becomes too troublesome to
    work with, or can't handle some aspect of the project after development has progressed.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码将使用Geany或LiClipse作为IDE进行编写。它们都提供了代码项目管理设施，应该能够处理预期的多项目结构，并提供足够的功能，以使跨项目导航相对轻松。最初，该工作将使用Geany，如果Geany变得过于麻烦或无法处理项目的某些方面，则将保留LiClipse，或者在开发进展后无法处理项目的某些方面。
- en: Source Code Management will be handled with Git, pointing at an external repository
    service such as GitHub or Bitbucket.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码管理将使用Git进行，指向GitHub或Bitbucket等外部存储库服务。
- en: Code will follow PEP-8 recommendations until or unless there's a compelling
    reason not to, or they conflict with any of the internal standards noted.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码将遵循PEP-8的建议，直到除非有令人信服的理由不这样做，或者它们与任何已知的内部标准冲突。
- en: Code will be written following the structure laid out in the various template
    files shown.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码将按照各种模板文件中的结构进行编写。
- en: Callables – functions and class methods – will use type-hinting annotations
    until or unless there is a compelling reason not to.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可调用对象-函数和类方法-将使用类型提示注释，直到除非有令人信服的理由不这样做。
- en: All code will be unit tested, though test policy details have yet to be defined
    other than assuring that all public members are tested.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有代码都将进行单元测试，尽管测试策略的细节尚未被定义，除了确保测试所有公共成员之外。
- en: Each code project in the system will have its own build process, using standard
    `setup.py` mechanisms, with `Makefile`-based processes wrapped around them if
    needed.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中的每个代码项目都将有自己的构建过程，使用标准的“setup.py”机制，并在需要时使用基于“Makefile”的流程进行包装。
- en: Each build process will integrate unit test results in order to prevent a build
    from completing if any of the unit tests fail.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个构建过程都将集成单元测试结果，以防止构建在任何单元测试失败时完成。
- en: Package structure within the projects has not yet been defined, but will unfold
    as development gets underway.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目内的包结构尚未定义，但将随着开发的进行而逐渐展开。
- en: Each project will have and use its own distinct virtual environment, in order
    to keep the requirements and dependencies associated with each project separate.
    This may require some build process tweaking, but that remains to be seen.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个项目都将拥有并使用自己独特的虚拟环境，以保持与每个项目相关的要求和依赖项分开。这可能需要一些构建过程的调整，但还有待观察。
