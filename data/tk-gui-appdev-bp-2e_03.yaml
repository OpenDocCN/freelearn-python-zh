- en: Programmable Drum Machine
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可编程鼓机
- en: We looked at several common Tkinter widgets, such as Menu, Buttons, Label, and
    Text, in [Chapter 2](41f1fda5-b3b1-4dfa-8971-2a016274d39a.xhtml), *Making a Text
    Editor*. Let's now expand our experience with Tkinter to make some music. Let's
    build a cross-platform drum machine using Tkinter and some other Python modules.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](41f1fda5-b3b1-4dfa-8971-2a016274d39a.xhtml)“制作文本编辑器”中探讨了几个常见的Tkinter小部件，例如菜单、按钮、标签和文本。现在，让我们扩展我们对Tkinter的经验，来制作一些音乐。让我们使用Tkinter和一些其他Python模块构建一个跨平台的鼓机。
- en: 'Some of the key objectives for this chapter are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一些关键目标包括：
- en: Learning to structure Tkinter programs in the **object-oriented style** of programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习以**面向对象**的风格结构 Tkinter 程序
- en: Delving deeper into a few more Tkinter widgets, such as Spinbox, Button, Entry,
    and Checkbutton
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解几个更多的 Tkinter 小部件，例如 Spinbox、Button、Entry 和 Checkbutton
- en: Applying the grid geometry manager in a practical project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实际项目中应用网格几何管理器
- en: Understanding the importance of choosing the right **data structure** for our
    programs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解选择合适的**数据结构**对我们程序的重要性
- en: Learning to bind **higher-order callback** **functions** to widgets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习将**高阶回调函数**绑定到小部件
- en: Learning to use Tkinter in conjunction with some standard and third-party modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何结合一些标准和第三方模块使用Tkinter
- en: Understanding the need for **multithreading** and how to write multithreaded applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解**多线程**的必要性以及如何编写多线程应用程序
- en: Learning about **object** **serialization** or **pickling**
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习关于**对象序列化**或**pickle**
- en: Learning about **ttk widgets**
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 **ttk 小部件**
- en: Getting started
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Our goal here is to build a programmable drum machine. Let's call it the `Explosion
    Drum Machine`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是构建一个可编程的鼓机。让我们称它为`爆炸鼓机`。
- en: 'The drum machine will let the user create an unlimited number of beat patterns using
    an unlimited number of drum samples. You can then store multiple riffs in a project
    and playback or edit the project later on. In its final form, the drum machine
    would look like the following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓机允许用户使用无限数量的鼓样本创建无限数量的节奏模式。然后您可以在项目中存储多个riff，并在稍后回放或编辑该项目。在最终形态下，鼓机将看起来像以下截图：
- en: '![](img/9ac7e30d-1364-4af6-9643-b78b52f5338e.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9ac7e30d-1364-4af6-9643-b78b52f5338e.png)'
- en: To create your own drum beat patterns, simply load some drum samples (which
    can be any audio file with a `.wav` or `.ogg` extension) using the buttons on
    the left. You can design your beat patterns by clicking on the buttons on the
    right.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自己的鼓点节奏模式，只需使用左侧的按钮加载一些鼓样本（可以是任何具有`.wav`或`.ogg`扩展名的音频文件）。您可以通过点击右侧的按钮来设计您的鼓点节奏。
- en: You can decide the number of **beats per unit** (**BPU**). Most western beats
    have 4 BPU, a Waltz would have 3 BPU, and some Indian and Arabic rhythms that
    I composed on this machine had 3-16 BPU! You can also change the **beats per minute
    (BPM)**, which in turn decides the tempo of the rhythm.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以决定每个单位**节拍数**（**BPU**）。大多数西方节拍有4 BPU，华尔兹有3 BPU，而我在这台机器上创作的某些印度和阿拉伯节奏则有3-16
    BPU！您还可以更改**每分钟节拍数（BPM**），这反过来又决定了节奏的速度。
- en: A single pattern, as shown in the previous screenshot, constitutes a single
    beat pattern. You can design multiple beat patterns by changing the Pattern Number
    Spinbox widget in the top-left section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一张截图所示，单个模式构成一个单独的节拍模式。您可以通过更改顶部左侧的“模式编号”微调部件来设计多个节拍模式。
- en: Once you have made some beat patterns, you can even save the pattern and later replay
    or modify it. The saving and reloading of files are done from the File menu at
    the top.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你制作了一些节奏模式，你甚至可以保存这个模式，稍后重新播放或修改它。保存和重新加载文件的操作都通过顶部的文件菜单完成。
- en: A few drum samples are provided in the `Loops` subdirectory; however, you can
    load any other drum sample. You can download a large number of samples for free
    from the internet.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Loops`子目录中提供了一些鼓样本；然而，您可以加载任何其他鼓样本。您可以从互联网上免费下载大量样本。
- en: Technical requirements
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will use some more built-in libraries from the standard Python distribution
    for this chapter. This includes `tkinter`, `os`, `math`, `threading`, and `pickle`
    modules.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用一些来自标准Python分发的更多内置库。这包括`tkinter`、`os`、`math`、`threading`和`pickle`模块。
- en: 'To verify that these modules exist, simply run the following statement in your Python3
    IDLE interactive prompt:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这些模块是否存在，只需在您的Python3 IDLE交互式提示符中运行以下语句：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This should not cause an error, as Python3 comes with these modules built into the
    distribution.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这不应该导致错误，因为Python3将这些模块内置到了发行版中。
- en: Other than this, you need to add an extra Python module called `pygame`. We
    will be using the version named 1.9.3 Package, which can be downloaded at [http://www.pygame.org/download.shtml](http://www.pygame.org/download.shtml).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个，你还需要添加一个名为 `pygame` 的额外 Python 模块。我们将使用名为 1.9.3 的软件包版本，可以在 [http://www.pygame.org/download.shtml](http://www.pygame.org/download.shtml)
    下载。
- en: Linux users may additionally want to take a look at the following page for instructions
    on getting `pygame` to work with Python 3.x: [http://www.pygame.org/wiki/CompileUbuntu?parent=Compilation](http://www.pygame.org/wiki/CompileUbuntu?parent=Compilation).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Linux用户可能还需要查看以下页面以获取将`pygame`与Python 3.x一起工作的说明：[http://www.pygame.org/wiki/CompileUbuntu?parent=Compilation](http://www.pygame.org/wiki/CompileUbuntu?parent=Compilation).
- en: '`pygame` is a cross-platform package normally used for making games with Python.
    However, we will just be using a small module from the package named `pygame.mixer`,
    which is used for loading and playing sounds. The API documentation for this module
    can be found at [http://www.pygame.org/docs/ref/mixer.html](http://www.pygame.org/docs/ref/mixer.html).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame` 是一个跨平台包，通常用于使用 Python 制作游戏。然而，我们只会使用该包中的一个名为 `pygame.mixer` 的小模块，该模块用于加载和播放声音。该模块的
    API 文档可以在 [http://www.pygame.org/docs/ref/mixer.html](http://www.pygame.org/docs/ref/mixer.html)
    找到。'
- en: 'After you have installed the module, you can verify it by importing it:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在您安装了该模块之后，您可以通过导入它来验证它：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If no errors are reported and the version output is 1.9.3, you are ready to
    program the drum machine. Let's start!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误报告，并且版本输出为1.9.3，你就可以开始编程鼓机了。让我们开始吧！
- en: Setting up the GUI in OOP
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在面向对象编程（OOP）中设置GUI
- en: 'The text editor we developed in the previous chapter was implemented in procedural
    code. Although it offered some benefits for quick coding, it had some typical
    limitations:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中我们开发的文本编辑器是使用过程式代码实现的。尽管它为快速编码提供了一些好处，但它也有一些典型的局限性：
- en: We started encountering global variables
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们开始遇到全局变量
- en: The function definitions needed to be defined above the code that called them
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要在调用它们的代码上方定义所需的功能定义
- en: Most importantly, the code was not reusable
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的是，代码不可重用
- en: Therefore, we need some way to ensure that our code is reusable. This is why programmers
    prefer to use **object-oriented programming** (**OOP**) to organize their code
    into classes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要某种方法来确保我们的代码是可重用的。这就是为什么程序员更倾向于使用**面向对象编程**（**OOP**）来组织他们的代码成类。
- en: OOP is a programming paradigm that shifts the focus onto the objects we want to
    manipulate rather than the logic required to manipulate them. This is in contrast
    to procedural programming, which views a program as a logical procedure that takes
    input, processes it, and produces some output.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）是一种编程范式，它将焦点转移到我们想要操作的对象上，而不是操作它们的逻辑。这与过程式编程形成对比，后者将程序视为一个逻辑过程，它接受输入，处理它，并产生一些输出。
- en: OOP provides several benefits, such as **data abstraction**, **encapsulation**,
    **inheritance**, and **polymorphism**. In addition, OOP provides a clear **modular
    structure** for programs. Code modification and maintenance are easy, as new objects
    can be created without modifying the existing ones.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程提供了多个好处，例如**数据抽象**、**封装**、**继承**和**多态**。此外，面向对象编程为程序提供了一个清晰的**模块结构**。代码修改和维护变得容易，因为可以创建新的对象而不需要修改现有的对象。
- en: 'Let''s build our drum program using OOP to illustrate some of these features. An
    indicative OOP structure for our drum program could be as follows (code `3.01.py`):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用面向对象编程（OOP）来构建我们的鼓程序，以此展示一些这些特性。我们的鼓程序的一个指示性OOP结构可能如下所示（代码`3.01.py`）：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The description of the code is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We create a class structure called `DrumMachine` and initialize the Toplevel window
    passed as an argument to it
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `DrumMachine` 的类结构，并将其作为参数传递给 Toplevel 窗口进行初始化
- en: If the script is run as a standalone program, that is, `if __name__ == '__main__'`,
    a new `Tk()` root object is created and the root window is passed as an argument
    to the `DrumMachine` object
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果脚本作为独立程序运行，即`if __name__ == '__main__'`，则会创建一个新的`Tk()`根对象，并将根窗口作为参数传递给`DrumMachine`对象
- en: We then initiate an object from the `DrumMachine` class to get a Toplevel window
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们随后从`DrumMachine`类中初始化一个对象以获取一个顶层窗口
- en: Now that we have our Toplevel window ready, let's stop adding any more visual elements
    and think about something that is critical to how well our program will eventually
    turn out to be. Let's spend some time finalizing the data structure for our program.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了顶层窗口，让我们停止添加任何更多的视觉元素，并思考一些对我们程序最终效果至关重要的因素。让我们花些时间确定我们程序的数据结构。
- en: Finalizing the data structure
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定数据结构
- en: 'As Linus Torvalds, the developer of Linux, once said:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如Linux的开发者林纳斯·托瓦兹（Linus Torvalds）曾说过：
- en: '"Bad programmers worry about the code. Good programmers worry about data structures
    and their relationships."'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '"糟糕的程序员担心代码。优秀的程序员担心数据结构和它们之间的关系。"'
- en: What he means is that well-designed data structures make the code very easy
    to design, maintain, and scale up. In contrast, if you start with a poor data
    structure, you can't make up for that, even with the best of code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 他所说的意思是，设计良好的数据结构使得代码非常容易设计、维护和扩展。相比之下，如果你从一个糟糕的数据结构开始，即使代码再好也无法弥补这一点。
- en: Start with a good data structure and your code will naturally be more simple, elegant,
    and easy to maintain.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个良好的数据结构开始，你的代码自然会变得更加简单、优雅且易于维护。
- en: With that in mind, let's try to decide on a suitable data structure for our
    program. Go back and take a look at the previous screenshot (under the *G**etting
    started* section). What kind of data structure, do you think, would be needed
    to capture all the necessary fields of information?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，让我们尝试决定为我们程序选择一个合适的数据结构。回顾一下之前的截图（在*入门*部分）。你认为需要哪种数据结构来捕捉所有必要的信息字段？
- en: Well, first of all our drum machine needs to keep information about beat patterns.
    So let's start by creating a list named `all_patterns = []`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，首先我们的鼓机需要保存有关节拍模式的资料。所以，让我们先创建一个名为 `all_patterns = []` 的列表。
- en: 'Now, each of the patterns within the list needs to capture information about
    the drum files related to the pattern: the number of units in the pattern, the
    BPU for the pattern, the BPM, and the buttons clicked to form the pattern.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，列表中的每个模式都需要捕获与该模式相关的鼓文件信息：模式中的单元数量、模式的BPU、BPM以及形成模式的按钮点击。
- en: 'Accordingly, we need to come up with a data structure where `all_patterns`
    is a list where each item represents a single pattern. Each pattern is then denoted
    by a dictionary, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要设计一种数据结构，其中`all_patterns`是一个列表，其中每个项目代表一个单独的模式。每个模式随后由一个字典表示，如下所示：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is very important that you get familiar with the preceding data structure
    definition for our drum machine. Notice that, with just this data in hand, we
    can define the logic to display everything that you see in the finalized drum
    machine.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的鼓机，熟悉前面的数据结构定义非常重要。请注意，仅凭这些数据，我们就可以定义逻辑来显示最终鼓机中显示的所有内容。
- en: Also notice that this data structure does not contain information about any
    GUI elements, such as widget information or widget states. As far as possible,
    we should always strive to cleanly separate the data of the backend (program logic)
    from the data related to the frontend (user interfaces). Our data structure here
    merely represents the backend but is sufficient enough to allow us to lay out
    the logic to determine our frontend.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，这个数据结构不包含任何GUI元素的信息，例如小部件信息或小部件状态。在尽可能的情况下，我们应该始终努力将后端（程序逻辑）的数据与前端（用户界面）相关的数据干净地分开。我们这里的数据结构仅仅代表后端，但足够让我们安排出确定我们前端逻辑的布局。
- en: The preceding data structure was what I found to be a good representation of
    the data at hand. There could have been an equally valid but altogether different
    representation of the data. There is no one *correct answer* to the question of
    data representation. However, building the representation around built-in collections
    of a language allows us to work with highly optimized code and is generally a good
    idea. The choice of data structure directly affects the performance of an application—sometimes
    trivially but at other times very severely.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的数据结构是我认为对现有数据的一个良好表示。可能存在一个同样有效但完全不同的数据表示。关于数据表示的问题没有唯一的*正确答案*。然而，围绕语言内置集合构建表示使我们能够使用高度优化的代码，这通常是一个好主意。数据结构的选择直接影响到应用程序的性能——有时是微不足道的，但在其他时候则非常严重。
- en: 'We modify our code accordingly (see code `3.02.py`) to initialize this data
    structure:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相应地修改了我们的代码（见代码`3.02.py`）以初始化此数据结构：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We also initialize `is_button_clicked_list` with all values set to `False`,
    as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将 `is_button_clicked_list` 初始化为所有值都设置为 `False`，如下所示：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To support this structure, we define a few constants (see code `3.02.py`):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这个结构，我们定义了一些常量（参见代码`3.02.py`）：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, if you run this program, you simply see a root window—nothing different from
    the previous code. But internally our code is reserving memory for all the data
    we will need to construct our logic. We have laid a strong foundation for our program
    to run. Believe it or not, we have done half the job.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行这个程序，你将只看到一个根窗口——与之前的代码没有任何不同。但我们的代码在内部正在为构建逻辑所需的所有数据保留内存。我们已经为程序的运行打下了坚实的基础。信不信由你，我们已经完成了一半的工作。
- en: Creating broader visual elements
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建更广泛的视觉元素
- en: 'Next, let''s lay out the broader visual elements of our program. For the sake
    of modularity, we divide the program into four broad visual sections, as shown
    in the following diagram:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们梳理我们程序更广泛的视觉元素。为了模块化，我们将程序划分为四个广泛的视觉部分，如下所示图解：
- en: '![](img/898ba06f-ef69-41f1-8ad0-a1d9034ae921.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/898ba06f-ef69-41f1-8ad0-a1d9034ae921.png)'
- en: 'Let''s define a method called `init_gui()`, which is called from within the
    `__init__` method as follows (see code `3.03.py`):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个名为 `init_gui()` 的方法，该方法在 `__init__` 方法内部被调用，如下所示（参见代码 `3.03.py`）：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We then proceed to define all four of these methods (`3.03.py`). The code is
    not discussed here, as we have done similar coding in previous chapters.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来定义这四种方法（`3.03.py`）。由于我们在前面的章节中已经进行过类似的编码，所以这里不讨论代码。
- en: 'We begin with the **Top Bar** section. The Top Bar is simple. It has a few
    labels, three Spinboxes, and an Entry widget. We will not reproduce the entire
    code here (see code `3.03.py`) as we have already seen examples of creating Labels
    and Entry widgets several times in the previous chapters. For `Spinbox`, the options are
    specified as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从**顶部栏**部分开始。顶部栏很简单。它包含几个标签，三个旋转框（Spinboxes），以及一个输入框（Entry widget）。我们在这里不会展示完整的代码（见代码`3.03.py`），因为我们已经在之前的章节中多次看到了创建标签和输入框的示例。对于`Spinbox`，选项的指定如下：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We set the class-level properties accordingly:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相应地设置了类级别属性：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since we will allow multiple patterns to be designed, we need to keep track
    of the currently showing or active pattern. The `self.current_pattern_index` property
    keeps track of the currently active pattern.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将允许设计多个模式，我们需要跟踪当前显示或激活的模式。`self.current_pattern_index` 属性用于跟踪当前激活的模式。
- en: 'Next, let''s code the `create_left_drum_loader()` method. This again is pretty self-explanatory.
    We create a loop (see `code 3.03.py`):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写`create_left_drum_loader()`方法。这同样非常直观。我们创建一个循环（参见`code 3.03.py`）：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Before we proceed to code the `create_right_button_matrix()` method, let's finish coding
    the `create_play_bar()` method, as it is the simpler of the two. All it contains
    is two Buttons, a Checkbutton, a Spinbox, and an image. We have coded similar
    widgets earlier in the book, and so I will leave it for you to explore on your
    own (see code `3.03.py`).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续编写 `create_right_button_matrix()` 方法之前，让我们先完成 `create_play_bar()` 方法的编码，因为它比另一个简单。它只包含两个按钮、一个复选框、一个微调框和一个图像。我们在书中之前已经编码过类似的控件，所以我会留给你自己探索（参见代码
    `3.03.py`）。
- en: Next, let's code the `create_right_button_matrix()` method. This is the most complex
    of all.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写`create_right_button_matrix()`方法。这是所有方法中最复杂的。
- en: The **right button matrix** comprises a two-dimensional array of rows and columns.
    The number of rows in the matrix equals the constant, `MAX_NUMBER_OF_DRUM_SAMPLES`,
    and the number of columns represents the number of beat units per cycle and is
    calculated by multiplying the number of units and the number of beats per unit.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**正确按钮矩阵**由行和列组成的二维数组。矩阵中的行数等于常数`MAX_NUMBER_OF_DRUM_SAMPLES`，列数代表每个周期内的节拍单位数量，通过将单位数量和每个单位节拍数相乘得到。'
- en: 'The code that creates the button matrix looks like this (see code `3.03.py`):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建按钮矩阵的代码看起来是这样的（参见代码`3.03.py`）：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The associated code for the `find_number_of_columns()` method is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_number_of_columns()` 方法的相关代码如下：'
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have already created the button matrix, but we want the buttons to be colored in
    two alternating shades. Therefore, we define two constants:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了按钮矩阵，但希望按钮以两种交替的色调着色。因此，我们定义了两个常量：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This can be any hexadecimal color code or any color from Tkinter's predefined
    list of colors. We also require a third color to represent the button in a pressed
    state.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是任何十六进制颜色代码，也可以是Tkinter预定义颜色列表中的任何颜色。我们还需要一个第三种颜色来表示按钮的按下状态。
- en: The constant `BUTTON_CLICKED_COLOR = 'green'` takes care of that.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 常量 `BUTTON_CLICKED_COLOR = 'green'` 负责处理这一点。
- en: 'We then define two methods:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后定义两种方法：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The idea is simple. A button is to be colored green if the value of the button
    is found to be `True` in our data structure, or else the button is to be shaded
    in patterns of `COLOR_1` and `COLOR_2` for each alternating unit of beats.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法很简单。如果一个按钮在我们数据结构中被发现其值为`True`，那么这个按钮应该被涂成绿色；否则，每个交替的节拍单位应该用`COLOR_1`和`COLOR_2`的图案来着色。
- en: 'This alternating color is obtained by using this mathematical formula:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种交替颜色是通过使用这个数学公式获得的：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Remember that we had created a two-dimensional Boolean list called `is_button_clicked_list`
    as a dictionary item in our original data structure to hold this value.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们在原始数据结构中创建了一个名为 `is_button_clicked_list` 的二维布尔列表，作为字典项来存储这个值。
- en: 'We change the color of the button to `BUTTON_CLICKED_COLOR` if that value is
    found to be `True`. Accordingly, we define a `getter` method to get the value
    of the button:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现该值是`True`，我们将按钮的颜色更改为`BUTTON_CLICKED_COLOR`。相应地，我们定义一个`getter`方法来获取按钮的值：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now each button is attached to the command callback named `on_button_clicked`, which
    is coded as follows (see code `3.03.py`):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每一个按钮都连接到名为 `on_button_clicked` 的命令回调，其代码如下（参见代码 `3.03.py`）：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice something fancy with this piece of code? This method defines a function within
    the function. It does not return a value as is typical of functions. Instead,
    it returns a function that can be executed at a later stage. These are called
    **higher-order functions** or, more precisely, **function closures**.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到这段代码的巧妙之处了吗？这种方法在函数内部定义了一个函数。它并不像典型的函数那样返回一个值。相反，它返回一个可以在稍后阶段执行的函数。这些被称为**高阶函数**，或者更精确地说，**函数闭包**。
- en: Why did we need to do this? We had to do this because each button is identified
    by its unique row and column-based indexes. The row values and column values are only
    available when the loop runs at the time of creating the buttons. The `row` and
    `col` variables are lost after that. We, therefore, need some way to keep these
    variables alive if we have to identify which button was clicked later on.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么需要这样做呢？我们必须这样做是因为每个按钮都通过其独特的行和列索引来识别。行值和列值只有在创建按钮时循环运行时才可用。在那之后，`row`和`col`变量就会丢失。因此，如果我们需要稍后识别哪个按钮被点击，我们就需要某种方法来保持这些变量活跃。
- en: These callback functions come to our rescue as they encapsulate the row and
    column values in the function that they return at the time of creation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些回调函数在需要时伸出援手，因为它们在创建时将行和列的值封装在它们返回的函数中。
- en: Functions are first-class objects in Python. This means that you can pass a
    function to another function as a parameter and you can return a function from
    another function. In short, you can treat a function as any other object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在Python中是一等对象。这意味着你可以将一个函数作为参数传递给另一个函数，你也可以从一个函数中返回一个函数。简而言之，你可以将函数当作任何其他对象来对待。
- en: You can bind a method object to a particular context, as we did in the previous
    code, by nested scoping of a method within a method. Higher-order functions like
    these are a common way of associating functions with widgets in GUI programming.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在方法内部嵌套方法的方式将一个方法对象绑定到特定的上下文中，就像我们在之前的代码中所做的那样。这类高阶函数是GUI编程中将函数与控件关联的常见方式。
- en: You can find more information about function closures at [https://en.wikipedia.org/wiki/Closure_(computer_programming)](https://en.wikipedia.org/wiki/Closure_(computer_programming)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://en.wikipedia.org/wiki/Closure_(computer_programming)](https://en.wikipedia.org/wiki/Closure_(computer_programming))找到更多关于函数闭包的信息。
- en: 'We then define a method called `process_button_clicked`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后定义了一个名为 `process_button_clicked` 的方法：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The key section in the preceding code is the line that sets the button value
    opposite to its current value using the `not` operator. Once the value is toggled,
    the method calls the `display_button_color` method to recolor the buttons.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的关键部分是使用`not`运算符将按钮值设置为与其当前值相反的行。一旦值被切换，该方法将调用`display_button_color`方法来重新着色按钮。
- en: 'Finally, let''s complete this iteration by defining some dummy methods for
    now and attach them as command callbacks to the respective widgets:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过定义一些临时方法来完成这个迭代，并将它们作为命令回调附加到相应的部件上：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'That completes the iteration. Now if you run the program (see code `3.03.py`),
    it should display all the broad visual elements:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了迭代。现在如果你运行程序（见代码`3.03.py`），它应该会显示所有主要的视觉元素：
- en: '![](img/b2060aae-7d86-4f34-beb2-31140f244c73.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b2060aae-7d86-4f34-beb2-31140f244c73.png)'
- en: The buttons matrix should be colored in two alternating shades, and pressing
    the buttons should toggle its color between green and its previous color.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮矩阵应涂成两种交替的色调，并且按下按钮应在其绿色和之前颜色之间切换。
- en: All other widgets remain non-functional at this stage as we have attached them
    to non-functional command callbacks. We will soon make them functional but, before
    we do that, let's do something to make all our future coding simple, clean, and
    elegant.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他小部件在此阶段仍然无法使用，因为我们已经将它们附加到了非功能性的命令回调。我们很快将使它们变得可用，但在我们这样做之前，让我们做一些事情来使我们的未来编码变得简单、整洁和优雅。
- en: Defining getter and setter methods
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义获取器和设置器方法
- en: In our previous section, we needed to know the value of a button in a given
    row and column of the button matrix for a given pattern. If the value was `True`,
    we colored the button green. If the value was `False`, we colored it in an alternative
    color.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的章节中，我们需要知道在按钮矩阵中给定行和列的按钮值对于给定模式。如果该值为`True`，我们就将按钮涂成绿色。如果该值为`False`，我们就用另一种颜色涂色。
- en: 'We can get the value of the button by calling this line of code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用这一行代码来获取按钮的值：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice how this line has four sets of square brackets, `[]`. Since this nested
    super-scripting business can soon get ugly, we encapsulated this logic in a method
    named `get_button_value(row, col)`. Now, whenever we need to get a button's value,
    we can simply call this method with the right parameters.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到这一行有四组方括号`[]`。由于这种嵌套上标功能很快就会变得难看，我们将这个逻辑封装在一个名为`get_button_value(row, col)`的方法中。现在，每当我们需要获取一个按钮的值时，我们只需用正确的参数调用这个方法即可。
- en: Now our code will not be littered with those ugly nested superscripts. Whenever
    we want to get the value of a button, we can call the `get_button_value(row, col)` method,
    which has a nice indicative name for the work it does. Isn't this much more readable
    and comprehensible than its rather ugly counterpart?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代码将不会充斥着那些难看的嵌套上标。每当我们需要获取按钮的值时，我们可以调用`get_button_value(row, col)`方法，这个方法有一个很好的指示性名称来描述其功能。这难道不是比其相对丑陋的对应物更易于阅读和理解吗？
- en: 'One thing is for sure: all logic that we build from now onward will heavily
    rely on data we get from, or set to, our data structure. Given that we will need
    all this data all the time in our program, let''s write its `getter` and `setter`
    methods in advance. This will certainly make our lives a lot easier.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一件事是肯定的：从现在开始，我们构建的所有逻辑都将严重依赖于我们从数据结构中获取或设置的数据。鉴于我们将在程序中一直需要所有这些数据，让我们提前编写它的`getter`和`setter`方法。这无疑会让我们的生活变得更加容易。
- en: The goal for this part of the iteration is simple—to define `getter` and `setter`
    methods for all the data that we have decided to store in our data structure.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本迭代部分的目标很简单——为所有我们决定存储在我们数据结构中的数据定义`getter`和`setter`方法。
- en: 'The code is as follows (see `code 3.04.py`):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下（见`code 3.04.py`）：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That is all there is to coding the `getter` and `setter` methods. The code should
    be self-explanatory if you have understood the underlying data structure, as all
    that we do here is either get a value or set a value for various items in the
    data structure.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是编写`getter`和`setter`方法的全部内容。如果你已经理解了底层的数据结构，代码应该是自解释的，因为我们在这里所做的只是获取或为数据结构中的各种项目设置值。
- en: With these methods now handy, let's complete coding the functionality of widgets
    we had earlier left uncoded.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这些方法，让我们来完成之前未编码的小部件功能。
- en: The number of units and beats per unit features
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单位数量和每单位节拍数
- en: 'We earlier coded the matrix called `create_right_button_matrix`, which creates
    a two-dimensional matrix with the number of rows equal to `MAX_NUMBER_OF_DRUM_SAMPLES`.
    The number of columns would be decided by multiplying the number of units by the
    beats per unit values selected by the end user. Its formula can be given as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前编写了名为 `create_right_button_matrix` 的矩阵代码，该代码创建一个二维矩阵，其行数等于 `MAX_NUMBER_OF_DRUM_SAMPLES`。列数将由用户选择的每个单元的节拍数乘以单元数来决定。其公式可以表示如下：
- en: '*Number of columns of buttons = Number of units x BPU*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*按钮列数 = 单元数 x BPU*'
- en: '![](img/62fb1dbc-f9ee-45d9-a72d-24fef899dc02.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/62fb1dbc-f9ee-45d9-a72d-24fef899dc02.png)'
- en: This means that every time the user changes the number of units or the beats
    per unit, the button matrix should be redrawn to change the number of columns.
    This change should also be reflected in our underlying data structure. Let's add
    this feature to our drum machine.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每次用户更改单位数量或每单位节拍数时，按钮矩阵应该重新绘制以更改列数。这种变化也应该反映在我们的底层数据结构中。让我们将这个功能添加到我们的鼓机中。
- en: 'We had earlier defined two dummy methods—`on_number_of_units_changed()` and `on_bpu_changed()`.
    We modify them now as follows (see `code 3.04.py`):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前定义了两个虚拟方法——`on_number_of_units_changed()` 和 `on_bpu_changed()`。我们现在对它们进行如下修改（见
    `code 3.04.py`）：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding methods do two things:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方法做两件事：
- en: Modify the data structure to reflect the changes in BPU or number of units
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改数据结构以反映BPU或单元数量的变化
- en: Call the `create_right_button_matrix()` method to recreate the button matrix
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `create_right_button_matrix()` 方法来重新创建按钮矩阵
- en: Now if you go and run the code (see code `3.04.py`) and change either the values
    of number of units or BPU, the button matrix should redraw itself to reflect the
    change.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你去运行代码（见代码`3.04.py`）并更改单元数量或BPU的值，按钮矩阵应该会重新绘制自己以反映这些更改。
- en: Loading drum samples
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载鼓样本
- en: Our main objective is to play sound files in the order of a beat pattern decided
    by the user. To do this, we need to add sound files to the drum machine.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要目标是按照用户决定的节奏模式顺序播放声音文件。为了实现这一点，我们需要将声音文件添加到鼓机中。
- en: Our program does not have any preloaded drum files. Instead, we want to let
    the user select from a wide variety of drum files.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目中没有预加载的鼓点文件。相反，我们希望让用户从众多鼓点文件中选择。
- en: Thus, besides the normal drum, you can play a Japanese tsuzumi, an Indian tabla, Latin
    American bongo drums, or just about any other sound that you want to add to your
    rhythm. All you need is a small `.wav` or `.ogg` file containing that sound's
    sample.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了普通的鼓，你还可以演奏日本太鼓、印度塔布拉鼓、拉丁美洲邦戈鼓，或者几乎任何你想添加到你的节奏中的其他声音。你只需要一个包含该声音样本的小型 `.wav`
    或 `.ogg` 文件即可。
- en: 'The drum sample is to be loaded on the left bar, as shown in the following
    screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓样本需要加载到左侧栏中，如下截图所示：
- en: '![](img/6b80c556-2219-4b10-a3a7-7b5cdc2c0de3.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6b80c556-2219-4b10-a3a7-7b5cdc2c0de3.png)'
- en: Let's code the ability to add drum samples to our program.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们的程序具备添加鼓样本的能力。
- en: We have already created buttons with folder icons on the left-hand side of our
    drum pad. Now we need to make it functional. The desired functionality is simple. When
    a user clicks on any of the left buttons, they should open a file dialog letting the
    user choose a `.wav` or `.ogg` file. When the user selects the file and clicks
    on Open, the Entry widget next to that button should be populated with the name
    of the file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在鼓垫的左侧创建了带有文件夹图标的按钮。现在我们需要使其具有功能。所需的功能很简单。当用户点击任何左侧按钮时，应该打开一个文件对话框，让用户选择`.wav`或`.ogg`文件。当用户选择文件并点击“打开”时，该按钮旁边的Entry小部件应该填充文件的名称。
- en: Further, the location of the drum sample file should be added to our data structure at
    the appropriate place.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，应该将鼓样本文件的位置添加到我们的数据结构中适当的位置。
- en: First, we will import the required modules.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将导入所需的模块。
- en: 'We will use the `filedialog` module to ask the user to select drum files. We have
    already used the file dialog module in [Chapter 2](41f1fda5-b3b1-4dfa-8971-2a016274d39a.xhtml),
    *Making a Text Editor*. The functionality here is very similar. We will also need
    to extract the filename of the given sound sample using the `os` module. Let''s
    begin by importing the two modules (see `code 3.05.py`):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`filedialog`模块来让用户选择鼓点文件。我们已经在[第2章](41f1fda5-b3b1-4dfa-8971-2a016274d39a.xhtml)，*制作文本编辑器*中使用了文件对话框模块。这里的功能非常相似。我们还将需要使用`os`模块来提取给定声音样本的文件名。让我们先导入这两个模块（见`code
    3.05.py`）：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The buttons we created for uploading drum files are attached to the `on_open_file_button_clicked`
    method through a command callback. We created a dummy method earlier by that name.
    We now modify that method to add the required functionality (see `code 3.05.py`):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为上传鼓文件创建的按钮通过命令回调连接到`on_open_file_button_clicked`方法。我们之前已经通过那个名字创建了一个虚拟方法。现在我们修改那个方法以添加所需的功能（见`code
    3.05.py`）：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding method again returns a function, as we need to track which of
    the drum files was actually selected from all the rows of drum files.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方法再次返回一个函数，因为我们需要追踪从所有鼓文件行中实际选择了哪个鼓文件。
- en: 'The preceding code does three things:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码做了三件事：
- en: Asks the user for the file path using Tkinter's `filedialog`
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Tkinter的`filedialog`请求用户输入文件路径
- en: Modifies the underlying data structure to save the provided file path
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改底层数据结构以保存提供的文件路径
- en: Calls another method to display the filename in the adjacent Entry widget
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用另一个方法以在相邻的Entry小部件中显示文件名
- en: 'The next two methods are then responsible for displaying all drum names in
    the frontend (see code `3.05.py`):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两种方法负责在前端显示所有鼓的名称（参见代码 `3.05.py`）：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding method uses `os.path.basename` from the `os` module to obtain the
    filename from the file path.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法使用`os.path.basename`函数，该函数位于`os`模块中，从文件路径中获取文件名。
- en: This completes the section. Our code is now capable of loading drum samples
    and storing records of all file paths in the data structure. Go ahead and try
    loading some drum samples (see code `3.05.py`) and the program should display
    the name of the drum file in the adjacent Entry widget.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容已经完成。我们的代码现在能够加载鼓样本，并将所有文件路径的记录存储在数据结构中。请继续尝试加载一些鼓样本（参见代码`3.05.py`），程序应该会在相邻的Entry小部件中显示鼓文件名。
- en: Playing the drum machine
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演奏鼓机
- en: Now that we have a mechanism to load drum samples and a mechanism to define beat
    patterns in place, let's add the ability to play these beat patterns. In many ways,
    this is the core of our program.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了加载鼓样本的机制和定义节拍模式的机制，接下来让我们添加播放这些节拍模式的能力。在许多方面，这构成了我们程序的核心。
- en: Let's first understand the functionality that we want to achieve here.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解我们在这里想要实现的功能。
- en: Once the user has loaded one or more drum samples and has defined a beat pattern using
    the toggle buttons, we need to scan each column of the pattern to see if it finds a
    green button (a `True` value in our data structure).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户加载了一个或多个鼓样本，并使用切换按钮定义了一个节奏模式，我们需要扫描模式的每一列，以查看是否找到了绿色按钮（在我们数据结构中的`True`值）。
- en: If the value is `True` for a given location in the matrix, our code should play
    the corresponding drum sample before moving ahead. If two or more drum samples
    are selected in the same column, all the samples should play almost simultaneously.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果矩阵中某个位置的值为 `True`，我们的代码应该在继续前进之前播放相应的鼓样本。如果同一列中选择了两个或更多鼓样本，所有样本应该几乎同时播放。
- en: Moreover, there should be a fixed time gap between the playing of each successive column,
    which will define the tempo of the music.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在播放每一连续列之间应该有一个固定的时间间隔，这将定义音乐的节奏。
- en: To achieve this functionality, we need to import the `pygame` module to play
    the sounds, and the `time` module to define the temporal gap between them.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一功能，我们需要导入`pygame`模块来播放声音，以及导入`time`模块来定义它们之间的时间间隔。
- en: Initializing pygame
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化pygame
- en: The `pygame` module is a set of highly portable modules that runs on most operating
    systems. We will use the mixer module from `pygame` to play the sound files.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame` 模块是一组高度可移植的模块，可以在大多数操作系统上运行。我们将使用 `pygame` 中的混音器模块来播放声音文件。'
- en: 'Assuming that you have installed the package, let''s begin by importing `pygame` (see
    code `3.06.py`):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已安装该包，让我们首先导入 `pygame`（参见代码 `3.06.py`）：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: According to the official API documentation of the mixer module at [http://www.pygame.org/docs/ref/mixer.html](http://www.pygame.org/docs/ref/mixer.html),
    we need to initialize `pygame` before we can play back the audio files.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 根据混合器模块的官方API文档[http://www.pygame.org/docs/ref/mixer.html](http://www.pygame.org/docs/ref/mixer.html)，在播放音频文件之前，我们需要初始化`pygame`。
- en: 'We initialize `pygame` in a new method called `init_pygame` (see code `3.06.py`):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在名为 `init_pygame` 的新方法中初始化 `pygame`（参见代码 `3.06.py`）：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `mixer.pre_init` method is a special requirement for our drum machine because
    the lack of it causes a lot of sound lagging. We will not get into the details of
    audio programming here, but suffice to say that the arguments to the `pre_init` method
    are as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`mixer.pre_init` 方法是我们鼓机的特殊要求，因为缺少它会导致很多声音滞后。我们在这里不会深入讨论音频编程的细节，但可以简单地说，`pre_init`
    方法的参数如下：'
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After `pygame` is initialized like this, the documentation suggests the following
    code to play the sound. Let''s add this to our code as well (see code `3.06.py`):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 `pygame` 初始化为如下所示后，文档建议使用以下代码来播放声音。让我们也将这段代码添加到我们的代码中（参见代码 `3.06.py`）：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Playing complete patterns
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演奏完整的模式
- en: 'Now our program has the ability to play any sound. But we don''t just need
    to play a single sound. We need to play a pattern. Let''s define a method called
    `play_pattern`, which reads our internal data structure and plays files accordingly
    (see code `3.06.py`):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的程序具有播放任何声音的能力。但我们需要的不只是播放单个声音。我们需要播放一个模式。让我们定义一个名为 `play_pattern` 的方法，它读取我们的内部数据结构并相应地播放文件（参见代码
    `3.06.py`）：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We also add an associated method that returns the *i*^(th) column from a matrix:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个相关方法，该方法可以从矩阵中返回第 *i* 列：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The description of the preceding code is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的描述如下：
- en: We create a class attribute called `self.keep_playing` to decide whether the
    pattern is to be played just once or continuously in a loop.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `self.keep_playing` 的类属性，用来决定模式是只播放一次还是连续循环播放。
- en: We create another class attribute called `self.now_playing` to track whether
    a beat is currently playing. This will help us to make some decisions on how to handle
    a sudden close of program or change of pattern by the user.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `self.now_playing` 的另一个类属性，用于跟踪是否有节拍正在播放。这将帮助我们做出一些决策，比如如何处理程序突然关闭或用户更改模式的情况。
- en: We then fetch the two-dimensional Boolean list from our data structure and scan
    each column of the list to look for `True` values. We get the column data from
    the matrix by defining a separate method called `get_column_from_matrix(self,
    matrix, i)`.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们随后从我们的数据结构中获取二维布尔列表，并对列表的每一列进行扫描以查找`True`值。我们通过定义一个名为`get_column_from_matrix(self,
    matrix, i)`的独立方法来从矩阵中获取列数据。
- en: For every column, if a `True` value is encountered, we fetch the corresponding drum
    file path and call the `self.play_sound()` method to play the file.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每一列，如果遇到`True`值，我们就获取相应的鼓文件路径并调用`self.play_sound()`方法来播放文件。
- en: The code sleeps for a fixed duration of time before reading the second column. This
    sleep duration defines the tempo of the drum beat. If the code does not sleep
    for some time between each column, all the patterns would play almost immediately
    and would not even sound like a rhythm. We need to import the `time` module to
    use the `time.sleep()` method.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码在读取第二列之前会暂停固定的时间。这个暂停时间定义了鼓点的节奏。如果代码在每列之间不暂停一段时间，所有模式几乎会立即播放，甚至听起来都不像节奏。我们需要导入`time`模块来使用`time.sleep()`方法。
- en: The amount of time the code sleeps between scanning each column is decided by
    another method called `self.time_to_play_each_column()`, which we define next.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码在扫描每一列之间的睡眠时间是由另一种名为 `self.time_to_play_each_column()` 的方法决定的，我们将在下文中定义该方法。
- en: Determining the tempo of a rhythm
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定节奏的节奏速度
- en: The mathematics of defining the tempo of a rhythm is simple. We get the value associated
    with the `beats_per_minute` attribute and divide it by `60` to get the beats per
    second. Then, the time to play each beat (or group of beats simultaneously for
    a given column) is the reciprocal of `beats_per_second`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 定义节奏速度的数学计算很简单。我们获取与`beats_per_minute`属性相关的值，并将其除以`60`以得到每秒的节拍数。然后，播放每个节拍（或给定列中同时播放的一组节拍）的时间是`beats_per_second`的倒数。
- en: 'The code is as follows (see code `3.06.py`):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下（见代码 `3.06.py`）：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'While we are handling the tempo for the pattern, let''s also complete coding
    of the command callback attached to our beats per minute Spinbox widget (see code
    `3.06.py`):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理模式的节奏时，也让我们完成与每分钟节拍 Spinbox 小部件相关联的命令回调的编码（参见代码 `3.06.py`）：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now let''s code the functionality related to the loop Checkbox. We have already factored
    in the looping issue in our `play_pattern` method using the `self.loop` variable.
    We simply need to set the value of the `self.loop` attribute by reading the value
    of the Spinbox widget (see code `3.06.py`):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写与循环复选框相关的功能代码。我们已经在`play_pattern`方法中通过使用`self.loop`变量解决了循环问题。我们只需通过读取Spinbox小部件的值来设置`self.loop`属性的值（参见代码`3.06.py`）：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With that out of the way, let''s code the command callback attached to our
    Play button and the Stop button (see code `3.06.py`):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了这些问题之后，让我们编写与我们的播放按钮和停止按钮关联的命令回调函数（参见代码 `3.06.py`）：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Our drum machine is now operational (see code `3.06.py`). You can load drum samples
    and define beat patterns, and when you click on the Play button, the drum machine
    plays that beat pattern!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的音乐鼓机现在已投入使用（见代码 `3.06.py`）。您可以加载鼓样本并定义节拍模式，当您点击播放按钮时，鼓机就会播放该节拍模式！
- en: However, there is a small problem. The `play_sound` method blocks the main loop of
    our Tkinter program. It does not relinquish control back to the main loop until it
    is done playing the sound sample.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在一个小问题。`play_sound`方法阻塞了我们Tkinter程序的主循环。它不会将控制权交还给主循环，直到完成声音样本的播放。
- en: 'Since our `self.loop` variable is set to `True`, this means that `pygame` never
    returns back control to Tkinter''s main loop and our play button and program is
    stuck! This can be seen in the following screenshot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`self.loop`变量被设置为`True`，这意味着`pygame`永远不会将控制权交还给Tkinter的主循环，我们的播放按钮和程序就卡住了！这可以在以下屏幕截图中看到：
- en: '![](img/3f8fd9e9-473b-4d5f-94ae-892dc30c887b.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f8fd9e9-473b-4d5f-94ae-892dc30c887b.png)'
- en: This means that if you now want to click on the Stop button or change some other
    widget, or even close the window, you will have to wait for the play loop to complete,
    which never happens in our case.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你现在想要点击停止按钮或更改其他小部件，或者甚至关闭窗口，你将不得不等待播放循环完成，在我们这个情况下这种情况永远不会发生。
- en: This is clearly a glitch. We need some method to confer back the control to
    the Tkinter main loop while the play is still in progress.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一个错误。在播放仍在进行时，我们需要某种方法将控制权交还给Tkinter主循环。
- en: That brings us to the next iteration, where we discuss and implement **multithreading** in
    our application.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们来到了下一个迭代阶段，我们将在这个阶段讨论并实现我们应用中的**多线程**。
- en: Tkinter and threading
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tkinter 和线程
- en: One of the simplest ways that we can make our root window responsive is to use
    the `root.update()` method within our `play_pattern` loop. This updates the `root.mainloop()`
    method after each sound sample is played.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使根窗口响应的最简单方法之一是，在`play_pattern`循环中使用`root.update()`方法。这将在每个声音样本播放后更新`root.mainloop()`方法。
- en: However, this is an inelegant method because the control is passed to the main
    loop with some staggering experienced in the GUI. Thus, you may experience a slight delay
    in the responses of other widgets in the Toplevel window.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是一个不够优雅的方法，因为控制权在GUI中传递时伴随着一些令人震惊的延迟。因此，你可能会在其他Toplevel窗口的小部件响应中体验到轻微的延迟。
- en: Further, if some other event causes the method to be called, it could result
    in a nested event loop.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果其他事件导致调用该方法，可能会导致嵌套事件循环。
- en: A better solution would be to run the `play_pattern` method from a separate
    **thread**.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是从一个单独的**线程**运行`play_pattern`方法。
- en: Let's use the threading module of Python to play the pattern in a separate thread. This
    way, `pygame` will not interfere with Tkinter's main loop.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Python 的线程模块在单独的线程中播放模式。这样，`pygame` 就不会干扰 Tkinter 的主循环。
- en: A thread is a coding construct that can advance two or more separate sets of logical
    workflow together within an instance of a running program (process), **context-switching**
    between the workflows. Each thread in a running program gets its own stack and
    its own program counter, but all threads in a process share the same memory.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是一种编码结构，可以在运行程序（进程）的实例中同时推进两个或更多独立的逻辑工作流，**在各个工作流之间进行上下文切换**。运行程序中的每个线程都有自己的堆栈和自己的程序计数器，但进程中的所有线程共享相同的内存。
- en: In contrast to threads, processes are independent execution instances of programs, each
    maintaining its own state information and address space. Processes can only interact
    with other processes using interprocess communication mechanisms.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 与线程不同，进程是程序的独立执行实例，每个进程都维护着自己的状态信息和地址空间。进程只能通过进程间通信机制与其他进程进行交互。
- en: 'Threading is a topic for a book in itself. However, we will not get into the
    details and instead will use the threading module from the Python standard library.
    The threading module provides a higher-level threading interface to hide away
    the inner complexities of implementing a multithreaded program. To use the module, let''s
    first import the threading module into our namespace (see code `3.07.py`):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 线程本身就是一个值得一本书来探讨的主题。然而，我们不会深入细节，而是将使用 Python 标准库中的线程模块。线程模块提供了一个高级的线程接口，以隐藏实现多线程程序的内层复杂性。要使用此模块，我们首先需要将线程模块导入到我们的命名空间中（参见代码
    `3.07.py`）：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let''s create a method, `play_in_thread()`, as follows (`3.07.py`):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们创建一个方法，`play_in_thread()`，如下所示 (`3.07.py`):'
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, change the `start_play` method to call the `play_in_thread` rather
    than calling the `play_pattern` directly:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，将`start_play`方法改为调用`play_in_thread`而不是直接调用`play_pattern`:'
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now if you load some drum samples, define the beat patterns, and hit the Play button,
    the sound will play in a separate thread without causing other widgets to become
    unresponsive (see code `3.07.py`).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您加载一些鼓样本，定义节拍模式，然后点击播放按钮，声音将在单独的线程中播放，而不会导致其他小部件变得无响应（参见代码`3.07.py`）。
- en: However, this poses a new problem. What happens if the user clicks the Play
    button multiple times? That would spawn multiple threads of beat patterns all
    playing simultaneously.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这又带来了一个新的问题。如果用户多次点击播放按钮会发生什么？那将会产生多个同时播放的节奏模式线程。
- en: 'We can overcome this problem by disabling the Play button when the audio is
    playing. This can be achieved by defining `toggle_play_button_state()` (see code
    `3.07.py`):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在音频播放时禁用播放按钮来克服这个问题。这可以通过定义`toggle_play_button_state()`函数来实现（参见代码`3.07.py`）：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We then attach this state toggling method onto the Play, Stop, and Loop widget command
    callbacks, as follows (`3.07.py`):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '我们然后将这种状态切换方法附加到播放、停止和循环小部件的命令回调中，如下所示 (`3.07.py`):'
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We also modify our `play_pattern()` method to include a call to `toggle_play_button_state()`
    at the end (see code `3.07.py`). This will ensure that when the pattern has ended
    playing, the Play button returns to its normal state.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还修改了`play_pattern()`方法，在末尾添加了对`toggle_play_button_state()`的调用（参见代码`3.07.py`）。这将确保当模式播放结束后，播放按钮返回到其正常状态。
- en: The Play button now remains in a disabled state as long as some audio is playing. It
    returns to a normal state when audio isn't playing.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 播放按钮现在在有音频播放时保持禁用状态。当没有音频播放时，它将恢复到正常状态。
- en: Tkinter and thread safety
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tkinter 和线程安全性
- en: Tkinter is not thread safe. The Tkinter interpreter is valid only in the thread
    that runs the main loop. Any calls to widgets must ideally be done from the thread
    that created the main loop. Invoking widget-specific commands from other threads
    is possible but is not reliable.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 不是线程安全的。Tkinter 解释器仅在运行主循环的线程中有效。任何对小部件的调用理想情况下都应该从创建主循环的线程中进行。从其他线程调用特定于小部件的命令是可能的，但不可靠。
- en: When you call a widget from another thread, the events get queued for the interpreter
    thread, which executes the command and passes the result back to the calling thread.
    If the main loop is running but not processing events, it sometimes results in
    unpredictable exceptions.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从另一个线程调用小部件时，事件会被排队到解释器线程，该线程执行命令并将结果传回调用线程。如果主循环正在运行但未处理事件，有时会导致不可预测的异常。
- en: In fact, if you find yourself calling a widget from a thread other than the
    main loop, chances are that you have not separated the visual elements from the
    underlying data structure. You are possibly doing it wrong.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果你发现自己从主循环以外的线程调用小部件，那么很可能你没有将视觉元素与底层数据结构分离。你可能是做错了。
- en: Before we complete this iteration, let's take care of a small detail. What happens
    if a beat is currently playing and the user hits the Close button on the window?
    The main loop will die and our audio-playing thread will be left in an orphaned
    state. This can lead to ugly error messages thrown at the user.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成这个迭代之前，让我们处理一个小细节。如果当前有节拍正在播放，用户点击窗口的关闭按钮会发生什么？主循环将会终止，而我们的音频播放线程将会处于孤儿状态。这可能会导致向用户抛出难看的错误信息。
- en: 'Let''s, therefore, override the Close button and stop the audio play before
    we quit the window. To override the Close button, we add a small line to our class
    `__init__` method, as follows (see code `3.07.py`):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们退出窗口之前，让我们覆盖关闭按钮并停止音频播放。要覆盖关闭按钮，我们在类的 `__init__` 方法中添加一行代码，如下所示（参见代码 `3.07.py`）：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, we define a method called `exit_app()`, as follows (see code `3.07.py`):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了一个名为 `exit_app()` 的方法，具体如下（参见代码 `3.07.py`）：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This completes the project iteration.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了项目迭代。
- en: To summarize, we refined our `start_play()` method to play the audio files on
    a separate thread. We also made sure to disable the Play button as long as the
    audio plays. Finally, we overrode the Close button to handle exiting when some
    audio is currently playing.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们改进了`start_play()`方法，使其在单独的线程上播放音频文件。我们还确保在音频播放时禁用播放按钮。最后，我们重写了关闭按钮，以便在播放某些音频时处理退出操作。
- en: We used Python's built-in threading module to play the loops in a separate thread. We
    also looked at some of the threading-related limitations of Tkinter. However, threading
    is a vast topic in itself and we have just scratched the surface here.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了Python内置的线程模块来在单独的线程中播放循环。我们还探讨了Tkinter中一些与线程相关的限制。然而，线程本身是一个庞大的主题，我们在这里只是略作触及。
- en: You can find more details about the threading module at [https://docs.python.org/3/library/threading.html](https://docs.python.org/3/library/threading.html).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.python.org/3/library/threading.html](https://docs.python.org/3/library/threading.html)找到有关线程模块的更多详细信息。
- en: Support for multiple beat patterns
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持多种节拍模式
- en: Our drum program is now functional. You can load drum samples and define a beat pattern
    and our drum machine will play it.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小鼓程序现在已可用。您可以加载鼓样本并定义一个节奏模式，我们的鼓机将会播放它。
- en: 'Let''s now extend our drum machine to create more than one pattern in the same program.
    This will provide us with the ability to play different patterns simply by changing
    the pattern number. This gives the user the ability to make different beats for
    the intro, verse, chorus, bridge, and other parts of a song. The pattern-changing
    user interface is highlighted in red in the following screenshot:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将扩展我们的鼓机，使其能够在同一个程序中创建多个模式。这将使我们能够通过更改模式编号来简单地播放不同的模式。这使用户能够为歌曲的引子、副歌、桥段以及其他部分制作不同的节奏。以下截图中的模式更改用户界面以红色突出显示：
- en: '![](img/7606143a-fe26-4e33-8d6e-6ff623910f51.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7606143a-fe26-4e33-8d6e-6ff623910f51.png)'
- en: 'At the very outset, we have an Entry widget adjacent to the Pattern Number
    Spinbox widget. We want to display the current pattern number in that Entry widget. We
    accordingly create a method, `display_pattern_name()`, which does this task (see
    code `3.08.py`):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在一开始，我们就有一个Entry小部件紧邻Pattern Number Spinbox小部件。我们希望在Entry小部件中显示当前的图案编号。因此，我们创建了一个方法`display_pattern_name()`，用于完成这项任务（参见代码`3.08.py`）：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We want the pattern name to display in the text widget when the program initially launches.
    Therefore, we modify our `create_top_bar()` method to include a call to this newly
    defined method (see code `3.08.py`).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望模式名称在程序首次启动时显示在文本小部件中。因此，我们修改了`create_top_bar()`方法，以包含对这个新定义方法的调用（参见代码`3.08.py`）。
- en: 'A change of pattern requires several changes. First of all, let''s modify the `on_pattern_changed()`
    command callback to call a new method, `change_pattern()`, as follows (see code
    `3.08.py`):'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 改变模式需要几个变更。首先，让我们修改`on_pattern_changed()`命令回调函数，以调用一个新的方法`change_pattern()`，如下所示（参见代码`3.08.py`）：
- en: '[PRE44]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, let''s define the `change_pattern()` method:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义`change_pattern()`方法：
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding code should almost read like plain English and the steps involved
    in a change of pattern should be self-explanatory.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码几乎应该像普通英语一样易读，并且模式变化中涉及的步骤应该是自解释的。
- en: This completes coding our drum machine to support multiple beat patterns. Go ahead
    and run code `3.08.py`. Load some drum files, define the first beat pattern, and
    play it. Change the beat pattern using the Spinbox widget at the top left,
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的鼓机编码，以支持多种节拍模式。现在运行代码`3.08.py`。加载一些鼓文件，定义第一个节拍模式，并播放它。使用左上角的Spinbox小部件更改节拍模式，
- en: load new drums, and define a new pattern. Then, play that pattern. While it
    is playing, try switching to your first beat pattern. The change should happen seamlessly.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 加载新的鼓点，并定义一个新的节奏模式。然后，演奏这个节奏模式。当它在播放时，尝试切换到你的第一个鼓点模式。变化应该无缝进行。
- en: Saving beat patterns
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存节拍模式
- en: In the preceding iteration, we added the capability to define multiple beat
    patterns.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个迭代中，我们增加了定义多个节拍模式的功能。
- en: However, the beat patterns can be played only on a single script run. When the program
    is closed and restarted, all previous pattern data is lost.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，节拍模式只能在单个脚本运行时播放。当程序关闭并重新启动时，所有之前的模式数据都会丢失。
- en: We need a way to persist or store the beat patterns beyond a single program
    run. We need the ability to store values in some form of file storage and reload,
    play, and even edit the patterns. We need some form of **object persistence**.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个方法来持久化或存储超过单个程序运行的节拍模式。我们需要在某种形式的文件存储中存储值，并能够重新加载、播放，甚至编辑这些模式。我们需要某种形式的**对象持久化**。
- en: Python provides several modules for object persistence. The module that we will
    use for persistence is called the `pickle` module. Pickle is a standard library
    of Python.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了多个用于对象持久化的模块。我们将用于持久化的模块称为`pickle`模块。Pickle是Python的标准库。
- en: An object represented as a string of bytes is called a **pickle** in Python.
    **Pickling**, also known as object **serialization**, let's us convert our object
    into a string of bytes. The process of reconstructing the object from the string
    of bytes is called **unpickling** or **deserialization**.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，将表示为字节串的对象称为 **pickle**。**Pickling**，也称为对象 **序列化**，允许我们将我们的对象转换成字节串。从字节串中重建对象的过程称为
    **unpickling** 或 **反序列化**。
- en: More information about the `pickle` module is available at [http://docs.python.org/3/library/pickle.html](http://docs.python.org/3/library/pickle.html).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`pickle`模块的信息可在[http://docs.python.org/3/library/pickle.html](http://docs.python.org/3/library/pickle.html)找到。
- en: 'Let''s illustrate it with a simple example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来说明：
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: First, we serialize or pickle our list, `party_menu`, using `pickle.dump`, and
    save it in an external file, `my_menu`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `pickle.dump` 将列表 `party_menu` 序列化或冻结，并将其保存在外部文件 `my_menu` 中。
- en: 'We later retrieve the object using `pickle.load`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后使用 `pickle.load` 来检索对象：
- en: '[PRE47]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Coming back to our drum machine—if we need to store and reuse the beat patterns, we
    only need to pickle our data structure list, named `self.all_patterns`. Having saved
    the object, we can later easily unpickle the file to reconstruct our beat patterns.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的鼓机——如果我们需要存储和重用节拍模式，我们只需要将名为 `self.all_patterns` 的数据结构列表进行序列化。保存了对象之后，我们稍后可以轻松地反序列化文件来重建我们的节拍模式。
- en: 'We first need to add three top-menu items to our program, as shown in the following
    screenshot:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要向我们的程序中添加三个顶部菜单项，如图所示：
- en: '![](img/87a44fda-a35d-45de-beb5-5c82f1e10240.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/87a44fda-a35d-45de-beb5-5c82f1e10240.png)'
- en: 'The three top-menu items are:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 三个顶级菜单项包括：
- en: '**File** | **Load Project**'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件** | **加载项目**'
- en: File | Save Project
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件 | 保存项目
- en: File | Exit
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件 | 退出
- en: While we are creating our menu items, let's also add an About menu item.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建菜单项时，也让我们添加一个“关于”菜单项。
- en: 'Here, we are particularly interested in saving the project (pickling), and
    loading the project back (unpickling). The code for menu items is defined in a
    separate method called `create_top_menu`, as shown in the following code (see
    code `3.09.py`):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们特别关注保存项目（序列化），以及将项目重新加载（反序列化）。菜单项的代码定义在一个单独的方法中，称为 `create_top_menu`，如下所示（参见代码
    `3.09.py`）：
- en: '[PRE48]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The code is self-explanatory. We have created similar menu items in our last
    two projects. Finally, to display this menu, we call this method from our `init_gui()` method.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是自我解释的。我们在前两个项目中创建了类似的菜单项。最后，为了显示这个菜单，我们从`init_gui()`方法中调用此方法。
- en: 'To pickle our object, we first import the pickle module into the current namespace,
    as follows (`3.09.py`):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '要对我们的对象进行腌制，我们首先将pickle模块导入到当前命名空间中，如下所示 (`3.09.py`):'
- en: '[PRE49]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The Save Project menu has a command callback attached to `self.save_project`, which
    is where we define the pickling process:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: “保存项目”菜单中有一个命令回调附加到`self.save_project`，这是我们定义序列化过程的地点：
- en: '[PRE50]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The description of the code is as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The `save_project` method is called when the user clicks on the Save Project menu;
    hence, we need to give the user an option to save the project in a file.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户点击“保存项目”菜单时，会调用`save_project`方法；因此，我们需要为用户提供一个选项，以便将项目保存到文件中。
- en: We have chosen to define a new file extension (`.ebt`) to keep track of our beat
    patterns. This is a completely arbitrary choice of extension name.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们选择定义一个新的文件扩展名（`.ebt`）来跟踪我们的节奏模式。这是一个完全随意的扩展名命名选择。
- en: When the user specifies the filename, it is saved with a `.ebt` extension. The file
    contains the serialized list `self.all_patterns`, which is dumped into the file
    using `pickle.dump`.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户指定文件名时，文件将以 `.ebt` 扩展名保存。该文件包含序列化的列表 `self.all_patterns`，使用 `pickle.dump`
    将其写入文件。
- en: Lastly, the title of the Toplevel window is changed to reflect the filename.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，Toplevel窗口的标题被更改以反映文件名。
- en: 'We are done pickling the object. Let''s now code the unpickling process. The unpickling
    process is handled by a method, `load_project`, which is called from the Load
    Project menu, as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了对象的腌制。现在让我们编写反腌制过程。反腌制过程由一个名为`load_project`的方法处理，该方法从“加载项目”菜单中调用，如下所示：
- en: '[PRE51]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The description of the code is as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: When a user clicks on the Load Project menu, it triggers a command callback connected
    to this `load_project` method.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户点击“加载项目”菜单时，它会触发与该`load_project`方法连接的命令回调。
- en: The first line of the method prompts the user with an Open File window. When
    the user specifies a previously pickled file with a `.ebt` extension, the filename
    is stored in a variable called `pickled_file_object`.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法的第一行会弹出一个打开文件窗口。当用户指定一个具有`.ebt`扩展名的已保存文件时，文件名将被存储在一个名为`pickled_file_object`的变量中。
- en: If the filename returned is `None` because the user cancels the Open File dialog,
    nothing is done. The file is then opened in read mode, and the contents of the
    file are read into `self.all_patterns` using `pickle.load`.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果返回的文件名为 `None` 因为用户取消了打开文件对话框，则不执行任何操作。此时文件将以读取模式打开，并使用 `pickle.load` 将文件内容读取到
    `self.all_patterns` 中。
- en: '`self.all_patterns` now contains the list of beat patterns defined in the previous
    pickle.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.all_patterns` 现在包含在之前的 pickle 中定义的节拍模式列表。'
- en: The file is closed and the first pattern of `self.all_patterns` is reconstructed by
    calling our previously defined `change_pattern()` method.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件已关闭，通过调用我们之前定义的`change_pattern()`方法，重新构建了`self.all_patterns`的第一个模式。
- en: This should load the first pattern on our drum machine. Try playing any of the patterns,
    and you should be able to replay the pattern exactly as it was defined at the
    time of pickling.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在我们的鼓机中加载第一个模式。尝试播放任何模式，你应该能够精确地回放模式，就像在保存时定义的那样。
- en: Note, however, that the pickled `.ebt` files are not portable from one computer
    to another. This is because we have just pickled the file path for our drum files.
    We have not pickled the actual audio files. So if you try to run the `.ebt` file
    on another machine or if the file path to the audio files has changed since the
    pickling, our code will not be able to load the audio files and will report an
    error.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，然而，经过腌制的 `.ebt` 文件无法从一个计算机转移到另一个计算机。这是因为我们只是腌了我们的鼓文件路径。我们没有腌制实际的音频文件。所以如果你尝试在另一台机器上运行
    `.ebt` 文件，或者如果音频文件的路径自从腌制后已经改变，我们的代码将无法加载音频文件，并会报告错误。
- en: The process of pickling uncompressed audio files like those in `.wav` files,
    `.ogg` files, or PCM data is the same as the preceding process. After all, these
    uncompressed audio files are nothing but lists of numbers.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 将未压缩的音频文件（如`.wav`文件、`.ogg`文件或PCM数据）进行腌制的流程与前面的流程相同。毕竟，这些未压缩的音频文件不过是数字列表。
- en: However, trying to pickle audio files here would require us to deviate a lot
    from our current topic. Therefore, we have not implemented it here.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这里尝试腌制音频文件会使我们偏离当前的主题很远。因此，我们在这里没有实现它。
- en: Pickling, though great for serialization, is vulnerable to malicious or erroneous
    data. You may want to pickle only if the data is from a trusted source, or if
    proper validation mechanisms are in place.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Pickling，虽然非常适合序列化，但容易受到恶意或错误数据的攻击。你可能只想在数据来自受信任的来源，或者有适当的验证机制的情况下进行Pickling。
- en: You may also find the `json` module useful for serializing objects in JSON.
    Also, the `ElementTree` and `xml.minidom` libraries are relevant for parsing XML
    data.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能发现`json`模块对于将对象序列化为JSON格式很有用。此外，`ElementTree`和`xml.minidom`库对于解析XML数据也是相关的。
- en: 'To end this section, let''s complete coding the response to clicking on the
    About menu item:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本节，让我们完成对点击“关于”菜单项的响应代码：
- en: '[PRE52]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is self-explanatory. We have done similar coding in our previous project.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点不言而喻。我们在之前的项目中已经做过类似的编码工作。
- en: To summarize this iteration, we used Python's built-in pickle module to pickle
    and unpickle the beat patterns defined by the user.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 总结这次迭代，我们使用了Python内置的pickle模块来序列化和反序列化用户定义的节奏模式。
- en: This now lets us save our beat patterns. We can later load, replay, and edit
    these saved patterns in our drum machine (see code `3.09.py`).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以保存我们的节奏模式了。我们可以在以后加载、回放和编辑在鼓机中保存的这些模式（参见代码`3.09.py`）。
- en: Working with ttk-themed widgets
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ttk 主题小部件
- en: We are almost done programming our drum machine. However, we would like to end
    this chapter by introducing you to ttk-themed widgets.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了鼓机的编程。然而，我们希望通过介绍 ttk 主题小部件来结束这一章。
- en: Tkinter does not bind to the native platform widgets on many platforms, such
    as Microsoft Windows and X11.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 在许多平台上不绑定到本地平台小部件，例如 Microsoft Windows 和 X11。
- en: The Tk toolkit (and Tkinter) originally appeared on **X-Window systems;** hence, it
    adopted the motif style that was the *de facto* standard for GUI development on
    X-Window systems.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Tk工具包（以及Tkinter）最初出现在**X-Window系统**上；因此，它采用了当时X-Window系统上GUI开发的**事实标准**——motif风格。
- en: When Tk was ported to other platforms, such as Windows and Mac OS, this motif style
    started appearing out of place with the look of these platforms.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当Tk被移植到其他平台，例如Windows和Mac OS时，这种主题风格开始与这些平台的视觉风格显得格格不入。
- en: Due to this, some even argue that Tkinter widgets are rather ugly and do not integrate
    well with such desktop environments.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，有些人甚至认为 Tkinter 小部件相当丑陋，并且与这样的桌面环境不太兼容。
- en: Another criticism of Tkinter is based on the fact that Tkinter mixes logic and
    styling by allowing both to be changed as widget options.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter的另一个批评基于这样一个事实：Tkinter允许通过小部件选项来同时更改逻辑和样式，从而将它们混合在一起。
- en: Tkinter was also criticized for lacking any kind of theming support. Although
    we saw an example of centralized styling via the option database, the method required styling
    to be done at the widget level. It does not allow for selective styling of two Button
    widgets differently, for example. This made it difficult for developers to implement
    visual consistency for similar groups of widgets while differentiating them from
    other groups of widgets.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 也受到了缺乏任何主题支持批评。尽管我们看到了通过选项数据库实现的集中式样式的例子，但这种方法要求在部件级别进行样式设置。例如，它不允许对两个按钮部件进行不同的选择性样式设置。这使得开发者难以在保持相似组部件视觉一致性同时，将它们与其他组部件区分开来。
- en: As a result of this, many GUI developers moved to Tkinter alternatives, such
    as **wxPython**, **PySide**, and **PyQT**.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，许多图形用户界面（GUI）开发者转向了Tkinter的替代品，例如 **wxPython**、**PySide** 和 **PyQT**。
- en: With Tkinter 8.5, the makers of Tkinter have tried to address all these concerns
    by introducing the **ttk module**, which may be considered as an advance to the
    original Tkinter module.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tkinter 8.5版本中，Tkinter的开发者通过引入**ttk模块**来尝试解决所有这些担忧，该模块可以被视为对原始Tkinter模块的改进。
- en: Let's take a look at some of the features offered by the ttk-themed widgets
    module.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 ttk 主题小部件模块提供的一些功能。
- en: One of the first things that ttk does is provide a set of built-in themes that
    allows Tk widgets to look like the native desktop environment in which the application
    is running.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ttk 首先要做的事情是提供一组内置主题，这使得 Tk 小部件看起来像应用程序正在运行的本地桌面环境。
- en: Additionally, it introduces 6 new widgets—**Combobox**, **Notebook**, **Progressbar**, **Separator**,
    **Sizegrip**, and **Treeview** to the list of widgets, in addition to supporting 11
    core Tkinter widgets, which are Button, Checkbutton, Entry, Frame, Label, LabelFrame,
    Menubutton, PanedWindow, Radiobutton, Scale, and Scrollbar.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还向小部件列表中引入了6个新的小部件——**Combobox**、**Notebook**、**Progressbar**、**Separator**、**Sizegrip**和**Treeview**，同时支持11个核心Tkinter小部件，包括Button、Checkbutton、Entry、Frame、Label、LabelFrame、Menubutton、PanedWindow、Radiobutton、Scale和Scrollbar。
- en: 'To use the ttk module, we first import it into the current namespace:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 ttk 模块，我们首先将其导入到当前命名空间中：
- en: '[PRE53]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You can display the ttk widgets as follows (see code `3.10.py`):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下方式显示 ttk 小部件（参见代码 `3.10.py`）：
- en: '[PRE54]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Code `3.10.py` provides a comparison of displays between the normal Tkinter widgets
    and the counterpart ttk widgets, as shown in the following screenshot:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 代码 `3.10.py` 提供了正常 Tkinter 小部件与其对应 ttk 小部件之间的显示比较，如下所示截图：
- en: '![](img/c5bf786b-584c-448e-9fc0-9704f879de32.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c5bf786b-584c-448e-9fc0-9704f879de32.png)'
- en: Notice that the preceding screenshot is taken on a Microsoft Windows platform
    as the differences are more marked on systems that do not explicitly use the X-Window system.
    Notice how Tkinter widgets (on the left) look out of place on Microsoft Windows
    as compared to ttk widgets (on the right), which is the native Microsoft Windows
    look and feel (see code `3.10.py`).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的截图是在 Microsoft Windows 平台上拍摄的，因为在没有明确使用 X-Window 系统的系统中，差异更为明显。注意 Tkinter
    小部件（在左侧）与 ttk 小部件（在右侧）相比，在 Microsoft Windows 上的外观显得格格不入，后者是 Microsoft Windows
    的原生外观和感觉（参见代码 `3.10.py`）。
- en: 'You can even override the basic Tkinter widgets by importing ttk after Tkinter
    as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以通过在Tkinter之后导入ttk来覆盖基本的Tkinter小部件，如下所示：
- en: '`from tkinter import *`'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`从 tkinter 导入所有内容`'
- en: '`from tkinter.ttk import *`'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`从 tkinter.ttk 导入所有内容`'
- en: This causes all widgets common to Tk and ttk to be replaced by ttk widgets.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致所有Tk和ttk共有的小部件都被ttk小部件所替换。
- en: This has the direct benefit of using the new widgets, which gives a better look
    and feel across platforms.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这直接的好处是使用新的小部件，这使得跨平台看起来和感觉都更好。
- en: 'However, the disadvantage of this kind of import is that you cannot distinguish
    the module from which the widget classes are imported. This is important because
    the Tkinter and ttk widget classes are not completely interchangeable. In this
    case, an unambiguous solution is to import them, as shown in the following code:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种导入方式的缺点是您无法区分导入小部件类的模块。这一点很重要，因为 Tkinter 和 ttk 小部件类并不是完全可互换的。在这种情况下，一个明确的解决方案是按照以下代码导入它们：
- en: '`import tkinter as tk`'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`import tkinter as tk`'
- en: '`from tkinter import ttk`'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`from tkinter import ttk`'
- en: Although most of the configuration options for Tkinter and ttk widgets are common, ttk-themed
    widgets do not support styling options such as fg, bg, relief, and border. This
    is purposefully removed from ttk in an attempt to keep logic and styling in different
    controls.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Tkinter和ttk小部件的大多数配置选项都是通用的，但ttk主题小部件不支持fg、bg、relief和border等样式选项。这是有意从ttk中移除的，目的是为了保持逻辑和样式的不同控制。
- en: Instead, all styling-related options are handled by the respective style names.
    In a standard ttk module, each widget has an associated style name. You can retrieve the
    default style name of a widget using the `widget.winfo_class()` method.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，所有与样式相关的选项都由相应的样式名称处理。在一个标准的 ttk 模块中，每个小部件都有一个关联的样式名称。您可以使用 `widget.winfo_class()`
    方法检索小部件的默认样式名称。
- en: 'For instance, consider a ttk Button:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个 ttk 按钮：
- en: '[PRE55]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This prints `Tbutton`, which is the default style name for `ttk.Button`. For
    a list of default ttk style names for different widgets, refer to [http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/ttk-style-layer.html](http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/ttk-style-layer.html).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印 `Tbutton`，它是 `ttk.Button` 的默认样式名称。有关不同小部件的默认 ttk 样式名称列表，请参阅[http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/ttk-style-layer.html](http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/ttk-style-layer.html)。
- en: 'In addition to the default style, you can assign a custom style class to a
    widget or group of widgets. To set up a new style, you use the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认样式外，您还可以为小部件或小部件组分配一个自定义样式类。要设置新样式，您可以使用以下方法：
- en: '[PRE56]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To configure the style options for a default style, you use the command:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置默认样式的样式选项，您可以使用以下命令：
- en: '[PRE57]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: To create a new style from the built-in styles, define a style name of the form `newName.oldName`.
    For instance, to create an Entry widget to hold a date, you can call it `Date.Tentry`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 要从内置样式创建一个新的样式，请定义一个形式为`newName.oldName`的样式名称。例如，要创建一个用于存储日期的Entry小部件，你可以将其命名为`Date.Tentry`。
- en: 'To use the new style on a widget, you use the command:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要在部件上使用新样式，您需要使用以下命令：
- en: '[PRE58]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Next, we will discuss **ttk theming**.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论**ttk主题**。
- en: The `Style` is used to control the appearance for individual widgets. Themes,
    on the other hand, control the appearance of the entire GUI. More simply put,
    a theme is a collection of styles. Grouping styles into themes lets the user switch
    designs for the entire GUI all at once. Like styles, all themes are uniquely identified
    by their name.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`样式`用于控制单个小部件的外观。另一方面，主题控制整个GUI的外观。更简单地说，主题是一组样式的集合。将样式分组为主题允许用户一次性切换整个GUI的设计。与样式一样，所有主题都通过它们的名称唯一标识。'
- en: 'The list of available themes can be obtained as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 可用主题列表的获取方法如下：
- en: '[PRE59]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can change to another theme from the `style.theme_names()` list; use the
    following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`style.theme_names()`列表中切换到另一个主题；使用以下方法：
- en: '[PRE60]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To explore various styling and theming-related options of ttk, refer to the
    dummy example (see `code 3.11.py`):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索 ttk 的各种样式和主题相关选项，请参考示例（见 `code 3.11.py`）：
- en: '[PRE61]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The description of the code is as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The first three lines of code import Tkinter and ttk, and set up a new root
    window.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前三行代码导入Tkinter和ttk，并设置一个新的root窗口。
- en: The next line, `style = ttk.Style()`, defines a new style.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个代码行，`style = ttk.Style()`，定义了一个新的样式。
- en: The next line configures a program-wide style configuration using `style.configure`.
    The dot character (`.`), which is the first argument of `configure`, means that
    this style would apply to the `Toplevel` window and to all its child elements.
    This is the reason why all of our widgets get to have a yellow background.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行配置了一个程序范围内的样式配置，使用`style.configure`。点号字符（`.`），作为`configure`的第一个参数，表示此样式将应用于`Toplevel`窗口及其所有子元素。这就是为什么我们所有的小部件都得到了黄色的背景。
- en: The next line creates an extension (`danger`) to the default style (`TButton`). This
    is how you create custom styles, which are variations on a base default style.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行创建了一个扩展（`danger`）到默认样式（`TButton`）。这就是创建自定义样式的方法，这些样式是基于基础默认样式的变体。
- en: The next line creates a `ttk.Label` widget. Since we have not specified any style
    for this widget, it inherits the global style specified for the Toplevel window.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行创建了一个 `ttk.Label` 小部件。由于我们没有为这个小部件指定任何样式，它继承了为 Toplevel 窗口指定的全局样式。
- en: The next line creates a `ttk.button` widget and specifies it to be styled using our
    custom style definition of `danger.TButton`. This is why the foreground color
    of this button turns red. Notice how it still inherits the background color, yellow,
    from the global Toplevel style that we defined earlier.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行创建了一个 `ttk.button` 小部件，并指定使用我们自定义的 `danger.TButton` 风格定义进行样式化。这就是为什么这个按钮的前景色变成了红色。注意它仍然继承了我们在之前定义的全局
    Toplevel 风格中的背景色，黄色。
- en: The next two lines of code demonstrate how ttk allows for styling different widget
    states. In this example, we styled different states for a `ttk.Button` widget
    to display in different colors. Go ahead and click on this second button to see
    how different styles apply to different states of a button. Here, we use `map(style,
    query_options, **kw)` to specify dynamic values of style for changes in the state
    of the widget.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下面的两行代码展示了 ttk 如何允许对不同的小部件状态进行样式设置。在这个例子中，我们为 `ttk.Button` 小部件的不同状态设置了不同的样式，以显示不同的颜色。请点击这个第二个按钮，看看不同的样式是如何应用到按钮的不同状态上的。在这里，我们使用
    `map(style, query_options, **kw)` 来指定小部件状态变化时的动态样式值。
- en: The next line fetches the current applicable theme. It then overrides some of
    the options for the theme's Entry widget using `style.theme_settings('themename',
    ***options)`.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行获取当前适用的主题。然后使用`style.theme_settings('themename', ***options)`覆盖主题的Entry小部件的一些选项。
- en: The next line defines an Entry widget but does not specify any style to it.
    It, therefore, inherits its properties from the theme we configured earlier. If
    you now type anything in this Entry widget, you will notice that it gets a padding of
    10 px and the foreground text color is red inside the Entry widget.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行定义了一个条目小部件（Entry widget），但没有指定任何样式给它。因此，它继承了我们之前配置的主题属性。如果你现在在这个条目小部件中输入任何内容，你会注意到它获得了10像素的内边距，并且条目小部件内的前景文本颜色为红色。
- en: Now that we know how to make our widgets look more like native platform widgets,
    let's change the **Play** and Stop buttons for our drum machine to `ttk.button`.
    Let's also change the `Loop` Checkbutton from `Tkinter` Checkbutton to `ttk` Checkbutton
    and add a few separators in the Play Bar section.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何让我们的小部件看起来更像原生平台的小部件，让我们将鼓机的**播放**和**停止**按钮改为`ttk.button`。同时，也将`Loop`复选按钮从`Tkinter`复选按钮改为`ttk`复选按钮，并在播放栏部分添加几个分隔符。
- en: 'The following screenshots show the Play Bar before and after making the changes:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了更改前后的播放栏：
- en: '![](img/a965371a-280a-4c3f-818c-aefea9b16a94.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a965371a-280a-4c3f-818c-aefea9b16a94.png)'
- en: 'We first import `ttk` into our namespace and append `ttk` to the Play and Stop buttons
    as follows (code `3.12.py`):'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`ttk`导入到我们的命名空间中，并将`ttk`附加到播放和停止按钮上，如下所示（代码`3.12.py`）：
- en: '[PRE62]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We then simply modify the buttons and Checkbutton in the `create_play_bar`, replacing
    `button` with `ttk.Button`, and `loopbutton` with `ttk.Checkbutton`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后简单地修改了`create_play_bar`中的按钮和Checkbutton，将`button`替换为`ttk.Button`，将`loopbutton`替换为`ttk.Checkbutton`：
- en: '[PRE63]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note that these changes make the Buttons and the Checkbutton look more like
    the native widgets of your working platform.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些更改使得按钮和复选框看起来更像是您工作平台的原生小部件。
- en: 'Finally, let''s add `ttk.separators` to our Play Bar (see code `3.12.py`).
    The format for adding separators is as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将 `ttk.separators` 添加到我们的播放条（参见代码 `3.12.py`）。添加分隔符的格式如下：
- en: '[PRE64]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note that we cannot change the buttons in the right-button matrix from button to
    `ttk.Button`. This is because ttk buttons do not support specifying options like background
    color.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们无法将右键矩阵中的按钮从`button`更改为`ttk.Button`。这是因为 ttk 按钮不支持指定选项，如背景颜色。
- en: This concludes the last iteration of this project. In this iteration, we first
    saw how and why to use **ttk-themed** widgets to improve the look and feel of
    our programs.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着本项目的最后一个迭代结束。在这个迭代中，我们首先了解了如何以及为什么使用**ttk主题**小部件来改善我们程序的外观和感觉。
- en: We then used ttk Buttons and ttk Checkbuttons in our drum program to improve
    its look. We also saw the reasons why certain Tkinter Buttons in our program could
    not be replaced by ttk Buttons.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在鼓程序中使用了 ttk 按钮（Buttons）和 ttk 复选按钮（Checkbuttons）来改善其外观。我们还了解了为什么我们程序中的某些 Tkinter
    按钮不能被 ttk 按钮所替代的原因。
- en: That brings us to the end of this chapter.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们结束了这一章。
- en: Summary
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Here's a quick summary of things we covered in this chapter.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章涵盖内容的简要总结。
- en: We started by learning how to structure the Tkinter program as classes and objects.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先学习了如何将 Tkinter 程序结构化为类和对象。
- en: We then decided the data structure for our program. This enabled us to set the ground
    for writing the rest of the program logic, maintaining a clean separation between
    data, logic, and its visual representation. We saw the vital benefits of deciding
    the data structure in advance.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后决定了我们程序的数据结构。这使得我们能够为编写程序逻辑的其余部分奠定基础，保持了数据、逻辑及其视觉表示之间的清晰分离。我们看到了提前决定数据结构的重要益处。
- en: We also worked with more Tkinter widgets such as Spinbox, Button, Entry, and
    Checkbutton. We also saw the grid geometry manager in action in the chapter.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了更多Tkinter小部件，例如Spinbox、Button、Entry和Checkbutton。我们还在本章中看到了网格布局管理器的实际应用。
- en: We then saw how to bind widgets to higher-order functions using command callbacks.
    This is a very common technique used in GUI programming.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着学习了如何使用命令回调将小部件绑定到高阶函数。这是一种在图形用户界面编程中非常常见的技巧。
- en: We then understood multithreaded programming in the context of Tkinter. We moved
    the audio playback onto a separate thread. This enabled us to keep the audio playing
    without hampering Tkinter's main loop in any way.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后在Tkinter的上下文中理解了多线程编程。我们将音频播放移到了一个单独的线程上。这使得我们能够在不任何方式妨碍Tkinter主循环的情况下保持音频播放。
- en: We then understood how to persist an object's state with the pickle module and
    then how to unpickle it later to retrieve the state of the object.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后了解了如何使用pickle模块持久化对象的状态，以及之后如何反序列化它以检索对象的状态。
- en: Finally, we saw how to use ttk-themed widgets to ensure that our GUI feels native
    on the platform where it is run.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了如何使用 ttk 主题小部件来确保我们的 GUI 在运行平台上感觉是本地的。
- en: Congratulations! You have now completed coding your drum machine.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在已经完成了鼓机的编码。
- en: QA section
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QA部分
- en: 'Before you proceed to the next chapter, make sure you can answer these questions
    to your satisfaction:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续阅读下一章之前，请确保你能满意地回答这些问题：
- en: How do you organize a Tkinter program in an object-oriented fashion? What are
    the advantages of using an object-oriented structure as apposed to writing pure
    procedural code? What are the disadvantages?
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何以面向对象的方式组织 Tkinter 程序？使用面向对象结构而不是编写纯过程性代码有哪些优点？又有哪些缺点？
- en: At what stage of programming should you consider drafting a data structure for
    your GUI program? What are the benefits of having a data structure or model in
    place?
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编程的哪个阶段你应该考虑为你的GUI程序设计数据结构？拥有一个数据结构或模型有什么好处？
- en: What are higher-order functions?
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是高阶函数？
- en: Why is threading required? What are its advantages and disadvantages?
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么需要线程？它的优点和缺点是什么？
- en: What is the difference between a process and a thread?
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程和线程之间的区别是什么？
- en: What is object persistence?
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是对象持久化？
- en: How do you pickle and unpickle objects in Python?
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何在 Python 中进行对象的序列化和反序列化？
- en: Besides pickling, what are the other common modes of persisting objects?
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了腌制，还有哪些常见的对象持久化方式？
- en: What are ttk widgets? Why are they used?
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ttk小部件是什么？为什么它们会被使用？
- en: Further reading
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Read about object-oriented programming terminologies like class, objects, constructor,
    inheritance, encapsulation, class methods, static methods, getters, setters, and
    their specific implementation in Python. A good place to start would be the official
    documentation of classes at [https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 了解面向对象编程术语，如类（class）、对象（objects）、构造函数（constructor）、继承（inheritance）、封装（encapsulation）、类方法（class
    methods）、静态方法（static methods）、获取器（getters）、设置器（setters）及其在Python中的具体实现。一个好的起点是查看类官方文档，链接为[https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html)。
- en: Read the official documentation of Python object serialization at [https://docs.python.org/3/library/pickle.html](https://docs.python.org/3/library/pickle.html).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读Python对象序列化的官方文档，请访问[https://docs.python.org/3/library/pickle.html](https://docs.python.org/3/library/pickle.html)。
- en: Read more about threading, context switching, and thread-based parallelism in
    general, along with its specific implementation in Python. The official documentation
    for threading is located at [https://docs.python.org/3/library/threading.html](https://docs.python.org/3/library/threading.html).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于线程、上下文切换以及一般基于线程的并行性的内容，以及Python中的具体实现。线程的官方文档位于[https://docs.python.org/3/library/threading.html](https://docs.python.org/3/library/threading.html)。
