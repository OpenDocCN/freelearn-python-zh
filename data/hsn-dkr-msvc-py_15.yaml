- en: Handling Change, Dependencies, and Secrets in the System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理系统中的变更、依赖和秘密
- en: In this chapter, we will describe different elements that interact with multiple
    microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将描述与多个微服务交互的不同元素。
- en: We will look at strategies on how to make services describe their version so
    that dependent microservices can discover them and be sure that they have the
    proper dependencies already deployed. This will allow us to define a deploying
    order in dependent services and will stop deployment of a service if not all dependencies
    are ready.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究如何制定服务描述其版本的策略，以便依赖的微服务可以发现它们，并确保它们已经部署了正确的依赖关系。这将允许我们在依赖服务中定义部署顺序，并且如果不是所有依赖关系都准备好，将停止服务的部署。
- en: This chapter describes how to define configuration parameters that are cluster-wide,
    so they can be shared across multiple microservices and managed in a single place,
    using Kubernetes ConfigMap. We will also learn how to deal with configuration
    parameters that are secrets—like encryption keys—that should not be accessible
    to most people on the team.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了如何定义集群范围的配置参数，以便它们可以在多个微服务之间共享，并在单个位置进行管理，使用Kubernetes ConfigMap。我们还将学习如何处理那些属于秘密的配置参数，比如加密密钥，这些密钥不应该对团队中的大多数人可见。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding shared configuration across microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解微服务之间的共享配置
- en: Handling Kubernetes secrets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理Kubernetes秘密
- en: Defining a new feature affecting multiple services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义影响多个服务的新功能
- en: Dealing with service dependencies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理服务依赖关系
- en: By the end of this chapter, you'll know how to prepare dependent services for
    safe deployment and how to include secrets in your microservices that won't be
    accessible outside the deployment they're intended for.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解如何为安全部署准备依赖服务，以及如何在微服务中包含不会在其预期部署之外可访问的秘密。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code is available on GitHub at the following URL: [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11).
    Note that the code is an extension of the code in `Chapter10`, with extra elements
    as described in this chapter. The structure is the same a subdirectory called
    `microservices` with the code, and another one called `kubernetes` with the Kubernetes
    configuration files.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可在GitHub上的以下URL找到：[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11)。请注意，该代码是`Chapter10`代码的扩展，其中包含本章描述的额外元素。结构相同，有一个名为`microservices`的子目录，其中包含代码，另一个名为`kubernetes`的子目录，其中包含Kubernetes配置文件。
- en: 'To install the cluster, you need to build each individual microservice with
    the following commands:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装集群，您需要使用以下命令构建每个单独的微服务：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will build the required services.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建所需的服务。
- en: Note that we use the `build-test.sh `script. We will explain how it works in
    this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`build-test.sh`脚本。我们将在本章中解释它的工作原理。
- en: 'And then, create the `namespace` example and start the Kubernetes cluster with
    the configuration found in the `Chapter11/kubernetes` subdirectory:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建`namespace`示例，并使用`Chapter11/kubernetes`子目录中的配置启动Kubernetes集群：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This deploys the microservices to the cluster.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在集群中部署微服务。
- en: 'The code included in `Chapter11` has some issues and **won''t** deploy correctly
    until it is fixed. This is the expected behavior. During the chapter, we will
    explain the two problems: the secrets not getting configured, and the dependency
    for Frontend not getting fulfilled, stopping it from starting.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chapter11`中包含的代码存在一些问题，**在修复之前**将无法正确部署。这是预期的行为。在本章中，我们将解释两个问题：无法配置秘密，以及无法满足前端的依赖关系，导致无法启动。'
- en: Keep reading the chapter to find the problems described. The solution is proposed
    as an assessment.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读本章以找到所描述的问题。解决方案将作为评估提出。
- en: 'To be able to access the different services, you need to update your `/etc/hosts` file
    to include the following lines:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够访问不同的服务，您需要更新您的`/etc/hosts`文件，包括以下行：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With that, you will be able to access services for this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，您就可以访问本章的服务了。
- en: Understanding shared configurations across microservices
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解微服务之间的共享配置
- en: Some configurations may be common to several microservices. In our example,
    we are duplicating the same values for the database connection. Instead of repeating
    the values on each of the deployment files, we can use ConfigMap and share it
    across the different deployments.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 某些配置可能适用于多个微服务。在我们的示例中，我们正在为数据库连接重复相同的值。我们可以使用ConfigMap并在不同的部署中共享它，而不是在每个部署文件中重复这些值。
- en: We've seen how to add ConfigMap to include files in [Chapter 10](ca9b0606-730a-4006-a575-de8e897a19ba.xhtml),
    *Monitoring Logs and Metrics*, under the *Setting up metrics *section. It was
    used for a single service, though.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何在[第10章](ca9b0606-730a-4006-a575-de8e897a19ba.xhtml) *监控日志和指标* 的*设置指标*部分中添加ConfigMap以包含文件。尽管它只用于单个服务。
- en: A ConfigMap is a group of key/value elements. They can be added as environment
    variables or as files. In the next section, we will add a general configuration file
    that includes all the shared variables in the cluster.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap是一组键/值元素。它们可以作为环境变量或文件添加。在下一节中，我们将添加一个包含集群中所有共享变量的通用配置文件。
- en: Adding the ConfigMap file
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加ConfigMap文件
- en: 'The `configuration.yaml` file contains the common configuration of the system.
    It is available in the `Chapter11/kubernetes` subdirectory:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`configuration.yaml`文件包含系统的公共配置。它位于`Chapter11/kubernetes`子目录中：'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The variables related to the database, `DATABASE_ENGINE`, `POSTGRES_USER`, `POSTGRES_HOST`,
    and `POSTGRES_PORT`, are shared across the Thoughts Backend and Users Backend.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库相关的变量，如`DATABASE_ENGINE`、`POSTGRES_USER`、`POSTGRES_HOST`和`POSTGRES_PORT`，在Thoughts
    Backend和Users Backend之间共享。
- en: The `POSTGRES_PASSWORD` variable is a secret. We will describe this later in
    this chapter in the *Handling Kubernetes secrets *section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`POSTGRES_PASSWORD`变量是一个密钥。我们将在本章的*处理Kubernetes密钥*部分中描述这一点。'
- en: The `THOUGHTS_BACKEND_URL` and `USER_BACKEND_URL` variables are used in the
    Frontend service. They are common across the cluster, though. Any service that
    wants to connect to the Thoughts Backend should use the same URL as described
    in `THOUGHTS_BACKEND_URL`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`THOUGHTS_BACKEND_URL`和`USER_BACKEND_URL`变量在前端服务中使用。尽管它们在集群中是通用的。任何想要连接到Thoughts
    Backend的服务都应该使用与`THOUGHTS_BACKEND_URL`中描述的相同URL。'
- en: Even though it's only used in a single service, Frontend, so far, it fits the
    description of a variable that's system-wide and should be included in the general
    configuration.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它目前只在单个服务Frontend中使用，但它符合系统范围的变量的描述，并应包含在通用配置中。
- en: One of the advantages of having a shared repository for variables is to consolidate
    them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有共享变量存储库的一个优点是将它们合并。
- en: While creating multiple services and developing them independently, it is quite
    common to end up using the same information, but in two slightly different ways.
    Teams developing independently won't be able to share information perfectly, and
    this kind of mismatch will happen.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建多个服务并独立开发它们的同时，很常见的情况是最终以两种略有不同的方式使用相同的信息。独立开发的团队无法完美共享信息，这种不匹配会发生。
- en: For example, one service can describe an endpoint as `URL=http://service/api`,
    and another service using the same endpoint will describe it as `HOST=service
    PATH=/api`. The code of each service handles the configuration differently, though
    they connect to the same endpoint. This makes it more difficult to change the
    endpoint in a unified way, as it needs to be changed in two or more places, in
    two ways.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个服务可以将一个端点描述为`URL=http://service/api`，另一个使用相同端点的服务将其描述为`HOST=service PATH=/api`。每个服务的代码处理配置方式不同，尽管它们连接到相同的端点。这使得以统一方式更改端点更加困难，因为需要在两个或更多位置以两种方式进行更改。
- en: A shared place is a good way to first detect these problems, as they normally
    go undetected if each service keeps its own independent configuration, and then
    to adapt the services to use the same variable, reducing the complexity of the
    configuration.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 共享位置是首先检测这些问题的好方法，因为如果每个服务保留自己独立的配置，这些问题通常会被忽略，然后调整服务以使用相同的变量，减少配置的复杂性。
- en: The name of ConfigMap in our example is `shared-config` as defined in the metadata
    and, like any other Kubernetes object, it can be managed through `kubectl` commands.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，ConfigMap的名称是`shared-config`，如元数据中所定义的，像任何其他Kubernetes对象一样，可以通过`kubectl`命令进行管理。
- en: Using kubectl commands
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用kubectl命令
- en: 'The ConfigMap information can be checked with the usual set of `kubectl` commands.
    This allows us to discover the defined ConfigMap instances in the cluster:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用通常的一组`kubectl`命令来检查ConfigMap信息。这使我们能够发现集群中定义的ConfigMap实例：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note how the number of keys, or variables, that ConfigMap contains is displayed;
    here, it is `6`. To see the content of ConfigMap, use `describe`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，ConfigMap包含的键或变量的数量是显示的；在这里，它是`6`。要查看ConfigMap的内容，请使用`describe`：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you need to change ConfigMap, you can use the `kubectl edit` command, or,
    even better, change the `configuration.yaml` file and reapply it using the following
    command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更改ConfigMap，可以使用`kubectl edit`命令，或者更好的是更改`configuration.yaml`文件，并使用以下命令重新应用它：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will overwrite all the values.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将覆盖所有的值。
- en: The configuration won't be applied automatically to the Kubernetes cluster.
    You'll need to redeploy the pods affected by the changes. The easiest way is to
    delete the affected pods and allow the deployment to recreate them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 配置不会自动应用到Kubernetes集群。您需要重新部署受更改影响的pod。最简单的方法是删除受影响的pod，并允许部署重新创建它们。
- en: On the other hand, if Flux is configured, it will redeploy the dependent pods
    automatically. Keep in mind that a change in ConfigMap (referenced in all pods)
    will trigger a redeploy on all pods in that situation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果配置了Flux，它将自动重新部署依赖的pod。请记住，更改ConfigMap（在所有pod中引用）将触发在该情况下所有pod的重新部署。
- en: We will now see how to add ConfigMap to the deployments.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看到如何将ConfigMap添加到部署中。
- en: Adding ConfigMap to the deployment
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将ConfigMap添加到部署
- en: Once ConfigMap is in place, it can be used to share its variables with different
    deployments, maintaining a central location where to change the variables and
    avoid duplication.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦ConfigMap就位，它可以用于与不同部署共享其变量，保持一个中央位置来更改变量并避免重复。
- en: Let's see how each of the deployments for the microservices (Thoughts Backend,
    Users Backend, and Frontend) makes use of the `shared-config` ConfigMap.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看微服务（Thoughts Backend、Users Backend和Frontend）的每个部署如何使用`shared-config` ConfigMap。
- en: Thoughts Backend ConfigMap configuration
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Thoughts Backend ConfigMap配置
- en: 'The Thoughts Backend deployment is defined as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Thoughts Backend部署定义如下：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The full `shared-config` ConfigMap will be injected into the pod. Note that
    this includes the `THOUGHTS_BACKEND_URL` and `USER_BACKEND_URL` environment variables that
    previously were not available in the pod. More environment variables can be added.
    Here, we left `POSTGRES_DB` instead of adding it to the ConfigMap.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的`shared-config` ConfigMap将被注入到pod中。请注意，这包括以前在pod中不可用的`THOUGHTS_BACKEND_URL`和`USER_BACKEND_URL`环境变量。可以添加更多环境变量。在这里，我们保留了`POSTGRES_DB`，而没有将其添加到ConfigMap中。
- en: We can use `exec` in the pod to confirm it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在pod中使用`exec`来确认它。
- en: Note that to be able to connect the secret, it should be properly configured.
    Refer to the *Handling Kubernetes secrets* section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了能够连接到密钥，它应该被正确配置。请参阅*处理Kubernetes密钥*部分。
- en: 'To check inside the container, retrieve the pod name and use `exec` in it,
    as shown in the following commands:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要在容器内部检查，请检索pod名称并在其中使用`exec`，如下面的命令所示：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `env` command returns all the environment variables, but there are a lot
    of them added automatically by Kubernetes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`env`命令返回所有环境变量，但Kubernetes会自动添加很多环境变量。'
- en: Users Backend ConfigMap configuration
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户后端ConfigMap配置
- en: 'The Users Backend configuration is similar to the previous type of configuration
    we just saw:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 用户后端配置与我们刚刚看到的前一种类型的配置类似：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The value of `POSTGRES_DB` is the same as in the Thoughts Backend, but we left
    it here to show how you can add more environment variables.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`POSTGRES_DB`的值与Thoughts后端中的相同，但我们将其留在这里以展示如何添加更多环境变量。'
- en: Frontend ConfigMap configuration
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端ConfigMap配置
- en: 'The Frontend configuration only uses ConfigMap, as no extra environment variables
    are required:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前端配置仅使用ConfigMap，因为不需要额外的环境变量：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The Frontend pods will also now include the information about the connection
    to the database, something that it doesn't require. This is fine for most of the
    configuration parameters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前端pod现在还将包括连接到数据库的信息，尽管它不需要。对于大多数配置参数来说，这是可以的。
- en: You can also use multiple ConfigMaps to describe different groups of configurations,
    if necessary. It is simpler to handle them in a big bucket with all the configuration
    parameters, though. This will help to catch duplicated parameters and ensure that
    you have all the required parameters in all microservices.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您还可以使用多个ConfigMaps来描述不同的配置组。不过，将它们放在一个大桶中处理会更简单。这将有助于捕获重复的参数，并确保所有微服务中都有所需的参数。
- en: However, some configuration parameters have to be handled with more care as
    they'll be sensitive. For example, we left out from the `shared-config` ConfigMap
    the `POSTGRES_PASSWORD` variable. This allows us to log into the database, and
    it should not be stored on any file with other parameters, so as to avoid accidental
    exposure.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些配置参数必须更加小心处理，因为它们将是敏感的。例如，我们从`shared-config` ConfigMap中省略了`POSTGRES_PASSWORD`变量。这允许我们登录到数据库，并且不应该存储在任何带有其他参数的文件中，以避免意外暴露。
- en: To deal with this kind of information, we can use Kubernetes secrets.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种信息，我们可以使用Kubernetes秘密。
- en: Handling Kubernetes secrets
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理Kubernetes秘密
- en: Secrets are a special kind of configuration. They need to be protected from
    being read by the other microservices that are using them. They are typically
    sensitive data, such as private keys, encryption keys, and passwords.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密是一种特殊的配置。它们需要受到保护，以免被其他使用它们的微服务读取。它们通常是敏感数据，如私钥、加密密钥和密码。
- en: Remember that reading a secret is a valid operation. After all, they need to
    be used. What differentiates a secret from other configuration parameters is that
    they need to be protected so only the authorized sources are able to read them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，读取秘密是有效的操作。毕竟，它们需要被使用。秘密与其他配置参数的区别在于它们需要受到保护，因此只有授权的来源才能读取它们。
- en: The secrets should be injected by the environment. This requires the code to
    be able to retrieve the configuration secrets and use the proper one for the current
    environment. It also avoids storing the secret inside the code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密应该由环境注入。这要求代码能够检索配置秘密并在当前环境中使用适当的秘密。它还避免了在代码中存储秘密。
- en: Remember *never* to commit production secrets in your Git repositories. The
    Git tree means that, even if it's deleted, the secret is retrievable. This includes
    the GitOps environment.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 记住*永远*不要在Git存储库中提交生产秘密。即使删除了Git树，秘密也是可检索的。这包括GitOps环境。
- en: Also, use different secrets for different environments. The production secrets
    require more care than the ones in test environments.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 还要为不同的环境使用不同的秘密。生产秘密需要比测试环境中的秘密更加小心。
- en: In our Kubernetes configuration, the authorized sources are the microservices
    using them, as well as administrators of the system, accessing through `kubectl`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Kubernetes配置中，授权的来源是使用它们的微服务以及通过`kubectl`访问的系统管理员。
- en: Let's see how to manage these secrets.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何管理这些秘密。
- en: Storing secrets in Kubernetes
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes中存储秘密
- en: Kubernetes deals with secrets as a particular kind of ConfigMap values. They
    can be defined in the system and then applied in the same say a ConfigMap will
    be. The difference with the general ConfigMaps is that the information is protected
    internally. While they can be accessed through `kubectl`, they are protected against
    accidental exposure.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes将秘密视为一种特殊类型的ConfigMap值。它们可以在系统中定义，然后以与ConfigMap相同的方式应用。与一般的ConfigMap的区别在于信息在内部受到保护。虽然它们可以通过`kubectl`访问，但它们受到意外暴露的保护。
- en: A secret can be created in the cluster through `kubectl` commands. They should
    *not* be created through files and GitOps or Flux, but manually instead. This
    avoids storing the secrets under the GitOps repo.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`kubectl`命令在集群中创建秘密。它们不应该通过文件和GitOps或Flux创建，而应该手动创建。这样可以避免将秘密存储在GitOps存储库下。
- en: The pods that require the secret to operate will indicate so in their deployment
    file. This is safe to store under GitOps source control, as it doesn't store the
    secret but only the reference to the secret. When the pod gets deployed, it will
    use the proper reference and decode secret.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 需要秘密来操作的pod将在其部署文件中指示。这是安全的存储在GitOps源代码控制下，因为它不存储秘密，而只存储对秘密的引用。当pod被部署时，它将使用适当的引用并解码秘密。
- en: Logging into the pod will grant you access to the secret. This is normal, since,
    inside the pod, the application needs to read its value. Granting access to execute
    commands in the pod will grant them access to the secrets inside, so keep it in
    mind. You can read Kubernetes documentation about the best practices of the secrets
    to understand and adjust depending on your requirements ([https://kubernetes.io/docs/concepts/configuration/secret/#best-practices](https://kubernetes.io/docs/concepts/configuration/secret/#best-practices)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到pod将授予您对秘密的访问权限。这是正常的，因为在pod内部，应用程序需要读取其值。授予对pod中执行命令的访问权限将授予他们对内部秘密的访问权限，因此请记住这一点。您可以阅读Kubernetes文档了解秘密的最佳实践，并根据您的要求进行调整（[https://kubernetes.io/docs/concepts/configuration/secret/#best-practices](https://kubernetes.io/docs/concepts/configuration/secret/#best-practices)）。
- en: Now that we know how to handle them, let's see how to create these secrets.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道如何处理它们，让我们看看如何创建这些秘密。
- en: Creating the secrets
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建秘密
- en: 'Let''s create the secrets in Kubernetes. We will store the following secrets:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Kubernetes中创建这些秘密。我们将存储以下秘密：
- en: The PostgreSQL password
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL密码
- en: The public and private keys to sign and validate requests
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于签署和验证请求的公钥和私钥
- en: 'We will store them inside the same Kubernetes secret that can have multiple
    keys. The following commands show how to generate a pair of keys:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将它们存储在同一个Kubernetes秘密中，该秘密可以有多个密钥。以下命令显示了如何生成一对密钥：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These keys are unique to you. We will use them to replace the stored example
    keys in the previous chapters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些密钥是唯一的。我们将使用它们来替换前几章中存储的示例密钥。
- en: Storing the secrets in the cluster
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在集群中存储秘密
- en: 'Store the secrets in the cluster, under the `thoughts-secrets` secret. Remember
    to store it in the `example` namespace:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将秘密存储在集群中，在`thoughts-secrets`秘密下。请记住将其存储在`example`命名空间中：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can list the secrets in the namespace:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以列出命名空间中的秘密：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And you can describe the secrets for more info:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以描述更多信息的秘密：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can get the content of a secret, but the data gets retrieved encoded in
    Base64.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以获取秘密的内容，但数据以Base64编码检索。
- en: Base64 is an encoding scheme that allows you to transform binary data into text
    and vice versa. It is widely used. This allows you to store any binary secret,
    not only text. It also means that the secrets are not displayed in plain text
    when retrieved, adding a small layer of protection in cases such as unintentional
    display in screens.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Base64是一种编码方案，允许您将二进制数据转换为文本，反之亦然。它被广泛使用。这使您可以存储任何二进制秘密，而不仅仅是文本。这也意味着在检索时秘密不会以明文显示，从而在意外显示在屏幕上等情况下增加了一层保护。
- en: 'To obtain the secret, use the usual `kubectl get` command as shown here. We
    use the `base64` command to decode it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取秘密，请使用如下所示的常规`kubectl get`命令。我们使用`base64`命令对其进行解码：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the same way, if you edit a secret to update it, the input should be encoded
    in Base64.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果要编辑秘密以更新它，输入应该以Base64编码。
- en: Secret deployment configuration
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 秘密部署配置
- en: 'We need to configure the secret usage in the deployment configuration, so the
    secret is available in the required pod. For example, in the User Backend `deployment.yaml`
    config file, we have the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在部署配置中配置秘密的使用，以便在所需的pod中可用。例如，在用户后端的`deployment.yaml`配置文件中，我们有以下代码：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We create the `POSTGRES_PASSWORD` environment variable that comes directly from
    the secret. We also create a volume called `sign-keys` that contains two keys
    as files, `public_key.pub` and `private_key.pem`. It mounts in the `/opt/keys/` path.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了来自秘密的`POSTGRES_PASSWORD`环境变量。我们还创建了一个名为`sign-keys`的卷，其中包含两个密钥文件，`public_key.pub`和`private_key.pem`。它挂载在`/opt/keys/`路径中。
- en: In a similar way, the `deployment.yaml` file for the Thoughts Backend includes
    secrets, but only the PostgreSQL password and `public_key.pub`. Note that the
    private key is not added, as the Thoughts Backend doesn't require it, and it's
    not available.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，Thoughts后端的`deployment.yaml`文件包括秘密，但只包括PostgreSQL密码和`public_key.pub`。请注意，私钥没有添加，因为Thoughts后端不需要它，也不可用。
- en: For the Frontend, only the public key is required. Now, let's establish how
    to retrieve the secrets.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前端，只需要公钥。现在，让我们来建立如何检索这些秘密。
- en: Retrieving the secrets by the applications
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序检索秘密
- en: For the `POSTGRES_PASSWORD` environment variable, we don't need to change anything.
    It was already an environment variable and the code was extracting it from there.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`POSTGRES_PASSWORD`环境变量，我们不需要更改任何内容。它已经是一个环境变量，代码已经从中提取它。
- en: But for the secrets stored as files, we need to retrieve them from the proper
    location. The secrets stored as files are the key to signing the authentication
    headers. The public file is required in all the microservices, and the private
    key only in the Users Backend.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但是对于存储为文件的秘密，我们需要从适当的位置检索它们。存储为文件的秘密是签署身份验证标头的关键。公共文件在所有微服务中都是必需的，而私钥仅在用户后端中使用。
- en: 'Now, let''s take a look at the `config.py` file for the Users Backend:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下用户后端的`config.py`文件：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The current keys are still there as default values. They will be used for unit
    tests when the secret files are not mounted.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当前密钥仍然作为默认值存在。当秘密文件没有挂载时，它们将用于单元测试。
- en: It is worth saying it again, but please *do not* use any of these keys. These
    are for running tests only and available to anyone that has access to this book.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，请*不要*使用这些密钥。这些仅用于运行测试，并且对于任何可以访问本书的人都是可用的。
- en: If the files in the `/opt/keys/` path are present, they'll be read, and the
    content will be stored in the proper constant. The Users Backend requires both
    the public and private keys.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`/opt/keys/`路径中存在文件，它们将被读取，并且内容将被存储在适当的常量中。用户后端需要公钥和私钥。
- en: 'In the Thoughts Backend `config.py `file, we only retrieve the public key,
    as seen in the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在Thoughts后端的`config.py`文件中，我们只检索公钥，如下所示：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The Frontend service adds the public key in the `settings.py` file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前端服务将公钥添加到`settings.py`文件中：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This configuration makes the secret available for the applications and closes
    the loop for the secret values. Now, the microservices cluster uses the signing
    key from a secret value, which is a safe way of storing sensible data.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置使秘密对应用程序可用，并为秘密值关闭了循环。现在，微服务集群使用来自秘密值的签名密钥，这是一种安全存储敏感数据的方式。
- en: Defining a new feature affecting multiple services
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义影响多个服务的新功能
- en: We talked about change requests within the realm of a single microservice. But
    what if we need to deploy a feature that works within two or more microservices?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈到了单个微服务领域内的更改请求。但是，如果我们需要部署在两个或多个微服务中运行的功能，该怎么办呢？
- en: These kinds of features should be relatively rare and are one of the main causes
    of overhead in microservices compared with the monolith approach. In a monolith,
    this case is simply not possible as everything is contained within the walls of
    the monolith.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的功能应该相对罕见，并且是与单体应用程序相比微服务中的开销的主要原因之一。在单体应用程序中，这种情况根本不可能发生，因为一切都包含在单体应用程序的墙内。
- en: In a microservice architecture, meanwhile, this is a complex change. This involves
    at least two independent features on each involved microservice that resides in
    two different repos. It is likely that the repos will be developed by two different
    teams, or at least different people will be responsible for each of the features.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，在微服务架构中，这是一个复杂的更改。这至少涉及到每个相关微服务中的两个独立功能，这些功能位于两个不同的存储库中。很可能这些存储库将由两个不同的团队开发，或者至少负责每个功能的人将不同。
- en: Deploying one change at a time
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐个更改
- en: To ensure that the features can be deployed smoothly, one at a time, they need
    to keep backward compatibility. This means that you need to be able to live in
    an intermediate stage when service A has been deployed, but not service B. Each
    change in the microservices needs to be as small as possible to minimize risks,
    and they should be introduced one change at a time.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保功能可以顺利部署，一次一个，它们需要保持向后兼容。这意味着您需要能够在服务A已部署但服务B尚未部署的中间阶段生存。微服务中的每个更改都需要尽可能小，以最小化风险，并且应逐个引入更改。
- en: Why don't we deploy them all simultaneously? Because releasing two microservices
    at the same time is dangerous. To start with, deployments are not instantaneous,
    so there will be moments where out-of-date services will either send or receive calls
    that the system is not prepared to handle. That will create errors that may affect
    your customers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不同时部署它们？因为同时发布两个微服务是危险的。首先，部署不是瞬时的，因此会有时刻，过时的服务将发送或接收系统尚未准备处理的调用。这将导致可能影响您的客户的错误。
- en: But there's a chance of a situation occurring where one of the microservices
    is incorrect and needs to be rolled back. Then, the system is left in an inconsistent
    state. The dependent microservice needs to be rolled back as well. This, in itself,
    is problematic, but it can make things worse when, during the debugging of this
    problem, both microservices are stuck and cannot be updated until the problem
    gets fixed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 但是存在一种情况，其中一个微服务不正确并且需要回滚。然后，系统将处于不一致状态。依赖的微服务也需要回滚。这本身就是有问题的，但是当在调试此问题期间，两个微服务都卡住并且在问题得到解决之前无法更新时，情况会变得更糟。
- en: In a healthy microservice environment, there will be deployments happening quite
    often. Having to stop the pipeline for a microservice because another service
    requires work is a bad position to be in, and it will just add stress and urgency.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在健康的微服务环境中，部署会经常发生。因为另一个服务需要工作而不得不停止微服务的流水线是一个糟糕的处境，它只会增加压力和紧迫感。
- en: Remember that we talked about the speed of deployment and change. Deploying
    small increments often is the best way to ensure that each deployment will be
    of high quality. The constant flow of incremental work is very important.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们谈到了部署和变更的速度。经常部署小的增量通常是确保每次部署都具有高质量的最佳方式。增量工作的持续流非常重要。
- en: Interrupting this flow due to an error is bad, but the effect multiplies quickly
    if the inability to deploy affects the pace of multiple microservices.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于错误而中断此流程是不好的，但是如果无法部署影响了多个微服务的速度，影响会迅速扩大。
- en: Multiple services being deployed simultaneously may also create a deadlock,
    where both services require work to fix the situation. This complicates the development
    and time to fix the issue.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 同时部署多个服务也可能导致死锁，其中两个服务都需要进行修复工作。这会使开发和解决问题的时间变得更加复杂。
- en: Instead of simultaneous deployments, analysis needs to be done to determine
    which microservice is dependent on the other. Most of the time, it is obvious.
    In our example, the Frontend is dependent on the Thoughts Backend, so any change
    that involves them both will need to start with the Thoughts Backend and then
    move to the Frontend.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进行分析以确定哪个微服务依赖于另一个而不是同时部署。大多数情况下，这是显而易见的。在我们的例子中，前端依赖于Thoughts后端，因此任何涉及它们两者的更改都需要从Thoughts后端开始，然后转移到前端。
- en: Actually, the Users Backend is a dependency of both, so assuming there's a change
    that affects the three of them, you'll need to first change the Users Backend,
    then the Thoughts Backend, and finally the Frontend.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，用户后端是两者的依赖项，因此假设有一个影响它们三者的更改，您需要首先更改用户后端，然后是Thoughts后端，最后是前端。
- en: 'Keep in mind that sometimes, it is possible that deployments need to move across
    services more than once. For example, let''s imagine that we have a change in
    the signing mechanism for the authentication headers. The process then should
    be as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，有时部署可能需要跨多个服务进行多次移动。例如，让我们想象一下，我们对身份验证标头的签名机制进行了更改。然后，流程应该如下：
- en: Implement the new authentication system in the Users Backend, but keep producing
    tokens with the old system through a config change. The old authentication process
    is still used in the cluster so far.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户后端实施新的身份验证系统，但通过配置更改继续使用旧系统生成令牌。到目前为止，集群仍在使用旧的身份验证流程。
- en: Change the Thoughts Backend to allow working with both the old and the new system
    of authenticating. Note that it is not activated yet.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改Thoughts后端以允许与旧系统和新的身份验证系统一起工作。请注意，它尚未激活。
- en: Change the Frontend to work with both authentication systems. Still, at this
    point, the new system is not yet used.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改前端以使其与两种身份验证系统一起工作。但是，此时新系统尚未被使用。
- en: Change configuration in the Users Backend to produce new authentication tokens. Now
    is when the new system starts to be used. While the deployment is underway, some
    old system tokens may be generated.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户后端更改配置以生成新的身份验证令牌。现在是新系统开始使用的时候。在部署过程中，可能会生成一些旧系统令牌。
- en: The Users Backend and Frontend will work with any token in the system, either
    new or old. Old tokens will disappear over time, as they expire. New tokens are
    the only ones being created.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户后端和前端将使用系统中的任何令牌，无论是新的还是旧的。旧令牌将随着时间的推移而消失，因为它们会过期。只有新令牌才会被创建。
- en: As an optional stage, the old authentication system can be deleted from the
    systems. The three systems can delete them without any dependency as the system
    is not used at this point.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为可选阶段，可以从系统中删除旧的身份验证系统。三个系统可以在没有任何依赖关系的情况下删除它们，因为此时系统不再使用。
- en: At any step of the process, the service is not interrupted. Each individual
    change is safe. The process is slowly making the whole system evolve, but each
    of the individual steps is reversible if there's a problem, and the service is
    not interrupted.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程的任何步骤中，服务都不会中断。每个单独的更改都是安全的。该过程正在慢慢使整个系统发展，但如果出现问题，每个单独的步骤都是可逆的，并且服务不会中断。
- en: Systems tend to develop by adding new features, and it is uncommon to have a
    clean-up stage. Normally, systems live with deprecated features for a long time,
    even after the feature is not used anywhere.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 系统往往通过添加新功能来发展，清理阶段并不常见。通常，即使功能在任何地方都没有使用，系统也会长时间保留已弃用的功能。
- en: We will talk a bit more about clean-up in [Chapter 12](d1a54332-1f4f-4ec7-a5a4-7ea81121bbea.xhtml),
    *Collaborating and Communicating across Teams*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在《第12章》*跨团队协作和沟通*中更详细地讨论清理工作。
- en: 'This process may also be required for configuration changes. In the example,
    changing the private key required to sign the authentication headers will require
    the following steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程也可能需要进行配置更改。例如，更改用于签署身份验证标头的私钥将需要以下步骤：
- en: Make the Thoughts Backend and Frontend able to handle more than one public key.
    This is a prerequisite and a new feature.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使Thoughts后端和前端能够处理多个公钥。这是一个先决条件和一个新功能。
- en: Change the handled keys in the Thoughts Backend to have both the old and the
    new public keys. So far, no headers signed with the new key are flowing in the
    system.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改Thoughts后端中处理的密钥，使其同时具有旧公钥和新公钥。到目前为止，系统中没有使用新密钥签名的标头。
- en: Change the handled keys in the Frontend to have both the old and the new. Still,
    no headers signed with the new key are flowing in the system.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改前端中处理的密钥，使其同时具有旧密钥和新密钥。但是，系统中仍没有使用新密钥签名的标头。
- en: Change the configuration of the Users Backend to use the new private key. From
    now on, there are headers signed with the new private key in the system. Other
    microservices are able to handle them.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改用户后端的配置以使用新的私钥。从现在开始，系统中有用新私钥签名的标头。其他微服务能够处理它们。
- en: The system still accepts headers signed with the old key. Wait for a safe period
    to ensure all old headers are expired.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统仍然接受用旧密钥签名的标头。等待一个安全期以确保所有旧标头都已过期。
- en: Remove the configuration for the old key in the Users Backend.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除用户后端的旧密钥配置。
- en: Steps 2 to 6 can be repeated every few months to use new keys.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤2至6可以每隔几个月重复使用新密钥。
- en: This process is called **key rotation**, and it is considered a good security
    practice as it reduces the life when a key is valid, reducing the window of time
    the system is vulnerable to a leaked key. For simplicity, we have not implemented
    it in our example system, but doing so is left as a recommended exercise. Try
    to change the example code to implement this key rotation example!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程被称为**密钥轮换**，被认为是一种良好的安全实践，因为它减少了密钥有效的时间，缩短了系统暴露于泄露密钥的时间窗口。为简单起见，我们没有在示例系统中实施它，但建议您这样做。尝试更改示例代码以实现此密钥轮换示例！
- en: The full system feature may involve multiple services and teams. To help with
    coordinating the dependencies of the system, we need to know when a certain dependency
    of service is deployed and ready to go. We will talk about the inter-team communication
    in [Chapter 12](d1a54332-1f4f-4ec7-a5a4-7ea81121bbea.xhtml), *Collaborating and
    Communicating across Teams*, but we can help programmatically by making the service
    API to explicitly describe which version of the service is deployed, as we will
    discuss in the *Dealing with service dependencies* section.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的系统功能可能涉及多个服务和团队。为了帮助协调系统的依赖关系，我们需要知道某个服务的特定依赖项何时部署并准备就绪。我们将在《第12章》*跨团队协作和沟通*中讨论团队间的沟通，但我们可以通过使服务API明确描述已部署的服务版本来通过编程方式进行帮助，正如我们将在*处理服务依赖关系*部分中讨论的那样。
- en: In case there's a problem in the new version that has just been deployed, the
    deployment can be reverted quickly through a rollback.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新版本出现问题，刚刚部署的版本可以通过回滚快速恢复。
- en: Rolling back the microservices
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回滚微服务
- en: Rollback is the process to step back quickly one of the microservices to the
    previous version.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 回滚是将微服务之一迅速退回到先前版本的过程。
- en: This process can be triggered when there's a catastrophic error in a new version
    just released, so it can be solved quickly. Given that the version was already
    currently compatible, this can be done with confidence in a very short reaction
    time. Through GitOps principles, a `revert` commit can be done to bring back the
    old version.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当新版本出现灾难性错误时，可以触发此过程，以便快速解决问题。鉴于该版本已经兼容，可以在非常短的反应时间内放心地进行此操作。通过GitOps原则，可以执行“revert”提交以恢复旧版本。
- en: The `git revert` command allows you to create a commit that undoes another,
    applying the same changes in reverse.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`git revert`命令允许您创建一个撤消另一个提交的提交，以相反的方式应用相同的更改。'
- en: This is a quick way to undo a particular change, and to allow later to *revert
    the revert* and reintroduce the changes. You can check the Git documentation for
    more details ([https://git-scm.com/docs/git-revert](https://git-scm.com/docs/git-revert)[).](https://git-scm.com/docs/git-revert)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是撤消特定更改的快速方法，并允许稍后*撤消撤消*并重新引入更改。您可以查看Git文档以获取更多详细信息（[https://git-scm.com/docs/git-revert](https://git-scm.com/docs/git-revert)）。
- en: Given the strategic approach to keep moving forward, a rollback is a temporary
    measure that, while in place, will stop new deployments in the microservice. A
    new version addressing the bug that caused the catastrophic deployment should
    be created as soon as possible, so as to keep the normal flow of releases.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于保持前进的战略性方法，回滚是一种临时措施，一旦实施，将停止微服务中的新部署。应尽快创建一个解决导致灾难性部署的错误的新版本，以保持正常的发布流程。
- en: As you deploy more and more often, and get better checks in place, rollbacks
    will be less and less common.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 随着部署次数的增加，并且在适当的位置进行更好的检查，回滚将变得越来越少。
- en: Dealing with service dependencies
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理服务依赖关系
- en: To allow services to check whether their dependencies have the correct version,
    we will make services to expose their version through a RESTful endpoint.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让服务检查它们的依赖项是否具有正确的版本，我们将使服务通过RESTful端点公开它们的版本。
- en: We will follow the example in the Thoughts Backend available in GitHub at this
    URL: [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11/microservices/thoughts_backend](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11/microservices/thoughts_backend).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循GitHub上的Thoughts Backend示例，网址为：[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11/microservices/thoughts_backend](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11/microservices/thoughts_backend)。
- en: Check the version is available in the Frontend ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11/microservices/frontend](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11/microservices/frontend)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端检查版本是否可用（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11/microservices/frontend](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11/microservices/frontend)）。
- en: The first step in the process is to properly define the version for each service.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程的第一步是为每个服务正确定义版本。
- en: Versioning the services
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务版本控制
- en: To allow a clear understanding of progress in our software, we need to name
    the different versions to be deployed. As we use `git` to keep track of changes,
    every commit in the system has an individual commit ID, but it doesn't follow
    any specific pattern.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰地了解软件的进展，我们需要命名要部署的不同版本。由于我们使用`git`来跟踪更改，系统中的每个提交都有一个独立的提交ID，但它没有遵循任何特定的模式。
- en: To give a meaning to it and order them, we need to develop a version schema.
    There are multiple ways of making a version schema, including by release date
    (Ubuntu uses this one) or by `major.minor.patch`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了赋予其意义并对其进行排序，我们需要开发一个版本模式。有多种制定版本模式的方法，包括按发布日期（Ubuntu使用此方法）或按`major.minor.patch`。
- en: Having the same versioning scheme everywhere helps to develop a common language
    and understanding across teams. It also helps management to understand the changes—both
    in terms of when things are released, as well as how quickly they are changing. Agree
    with your teams a versioning scheme that makes sense in your organization, and
    follow it in all services.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有地方使用相同的版本控制方案有助于在团队之间发展共同的语言和理解。它还有助于管理了解变化，无论是在发布时的变化还是变化的速度。与您的团队商定一个在您的组织中有意义的版本控制方案，并在所有服务中遵循它。
- en: For this example, we will use a `vMajor.Minor` schema and the version for the
    Users Backend as `v2.3`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将使用`vMajor.Minor`模式，并将用户后端的版本设置为`v2.3`。
- en: The most common pattern in software versioning is semantic versioning. This
    versioning pattern is useful for packages and customer-facing APIs, but less useful
    for internal microservice APIs. Let's see what its characteristics are.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 软件版本控制中最常见的模式是语义版本控制。这种版本控制模式对于软件包和面向客户的API非常有用，但对于内部微服务API则不太有用。让我们看看它的特点是什么。
- en: Semantic versioning
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语义版本控制
- en: Semantic versioning imposes meaning to the change on each of the different version
    numbers. This makes it easy to understand the scope of changes between versions
    and whether the update is risky to do on a dependent system.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本控制对不同版本号的每个更改赋予了含义。这使得很容易理解各个版本之间的变化范围，以及更新是否对依赖系统有风险。
- en: 'Semantic versioning defines each version with three numbers: major, minor,
    and patch, normally described as `major.minor.patch`*.*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本控制使用三个数字定义每个版本：主要版本、次要版本和补丁版本，通常描述为`major.minor.patch`。
- en: 'Increasing any of these numbers carries a particular meaning, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 增加这些数字中的任何一个都具有特定的含义，如下所示：
- en: Increasing the major number produces backward-incompatible changes.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加主要版本号会产生不兼容的变化。
- en: Increasing the minor number adds new features, but keeps backward-compatibility.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加次要版本号会添加新功能，但保持向后兼容。
- en: Increasing the patch number fixes bugs, but doesn't add any new features.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加补丁号修复错误，但不添加任何新功能。
- en: 'As an example, Python works under this schema as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Python按照以下模式工作：
- en: Python 3 included compatibility changes with Python 2.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3与Python 2包含了兼容性变化。
- en: Python version 3.7 introduced new features compared with Python 3.6.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.7版本与Python 3.6相比引入了新功能。
- en: And Python 3.7.4 added security and bug fixes compared with Python 3.7.3.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.7.4版本相对于Python 3.7.3增加了安全性和错误修复。
- en: This versioning scheme is useful in communicating with external partners and
    is great for big releases and standard packages. But for small incremental changes
    in microservices, it is not very useful.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这种版本控制方案在与外部合作伙伴的沟通中非常有用，并且非常适用于大型发布和标准软件包。但对于微服务中的小型增量变化，它并不是非常有用。
- en: As we discussed in previous chapters, the key to continuous integration to be
    delivered is to make very small changes. They should not break backward compatibility,
    but, over time, old features will be dropped. Each microservice works in unison
    with other services, in a controlled manner. There's no need to have such a strong
    feature labeling, compared with an external package. The consumers of the service
    are the other microservices, under tight control in the cluster.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中讨论的那样，持续集成的关键是进行非常小的更改。它们不应该破坏向后兼容性，但随着时间的推移，旧功能将被删除。每个微服务都以受控的方式与其他服务协同工作。与外部包相比，没有必要具有如此强烈的功能标签。服务的消费者是集群中受严格控制的其他微服务。
- en: Some projects are abandoning semantic versioning due to this change in operation.
    For example, the Linux kernel stopped using semantic versioning to produce new
    versions without any particular meaning ([http://lkml.iu.edu/hypermail/linux/kernel/1804.1/06654.html](http://lkml.iu.edu/hypermail/linux/kernel/1804.1/06654.html)),
    as changes from one version to the next are relatively small.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一些项目由于操作方式的改变而放弃了语义版本。例如，Linux内核停止使用语义版本来生成没有特定含义的新版本（[http://lkml.iu.edu/hypermail/linux/kernel/1804.1/06654.html](http://lkml.iu.edu/hypermail/linux/kernel/1804.1/06654.html)），因为从一个版本到下一个版本的更改相对较小。
- en: Python will also treat version 4.0 as *the version that goes after 3.9*, without
    major changes like Python 3 had ([http://www.curiousefficiency.org/posts/2014/08/python-4000.html](http://www.curiousefficiency.org/posts/2014/08/python-4000.html)).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Python也将版本4.0视为*在3.9之后的版本*，并且不像Python 3那样有重大变化（[http://www.curiousefficiency.org/posts/2014/08/python-4000.html](http://www.curiousefficiency.org/posts/2014/08/python-4000.html)）。
- en: That's why, internally, semantic versioning is *not* recommended. It may be
    useful to keep a similar versioning scheme, but without forcing it to make compatibility
    changes, just ever-increasing numbers, without specific requirements on when to
    change minor or major versions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在内部*不*建议使用语义版本。保持类似的版本方案可能是有用的，但不要强制它进行兼容性更改，只需增加数字，而不对何时更改次要或主要版本做出具体要求。
- en: Externally, though, version numbers may still have a marketing meaning. For externally
    accessible endpoints, it may be interesting to use semantic versioning.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从外部来看，版本号可能仍然具有营销意义。对于外部可访问的端点，使用语义版本可能是有趣的。
- en: Once decided which version the service is, we can work on an endpoint that exposes
    this information.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了服务的版本，我们就可以着手创建一个公开此信息的端点。
- en: Adding a version endpoint
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加版本端点
- en: The version to be deployed can be read from either the Kubernetes deployment
    or from the GitOps configuration. But there is a problem. Some of the configurations
    could be misleading or not uniquely pointing to a single image. For example, the `latest` tag may
    represent different containers at different times, as it gets overwritten.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署的版本可以从Kubernetes部署或GitOps配置中读取。但是存在一个问题。一些配置可能会误导或不唯一地指向单个镜像。例如，`latest`标签可能在不同时间代表不同的容器，因为它会被覆盖。
- en: Also, there's a problem of having access to the Kubernetes configuration or
    GitOps repo. For a developer, maybe this configuration is available, but they
    won't be for the microservices (nor should they be).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还存在访问Kubernetes配置或GitOps存储库的问题。对于开发人员来说，也许这些配置是可用的，但对于微服务来说不会（也不应该）。
- en: To allow the remainder of the microservices in the cluster to discover the version
    of the service, the best way is to explicitly create a version endpoint in the
    RESTful API. The discovery of the service version is granted, as it uses the same
    interface it will use in any other request. Let's see how to implement it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让集群中的其他微服务发现服务的版本，最好的方法是在RESTful API中明确创建一个版本端点。服务版本的发现是被授予的，因为它使用与任何其他请求中将使用的相同接口。让我们看看如何实现它。
- en: Obtaining the version
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取版本
- en: To serve the version, we first need to record it into the service.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供版本，我们首先需要将其记录到服务中。
- en: As we discussed previously, the version is stored as a Git tag. This will be
    our canon in the version. We will add the Git SHA-1 of the commit as well to avoid
    any discrepancies.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论过的，版本是存储为Git标签的。这将是我们版本的标准。我们还将添加提交的Git SHA-1，以避免任何差异。
- en: The SHA-1 is a unique ID that identifies each commit. It's produced by hashing
    the Git tree, so that it's able to capture any change—either the content or the
    tree history. We will use the full SHA-1 of 40 characters, even though sometimes
    it is abbreviated to eight or less.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-1是一个唯一的标识符，用于标识每个提交。它是通过对Git树进行哈希处理而生成的，因此能够捕获任何更改——无论是内容还是树历史。我们将使用40个字符的完整SHA-1，尽管有时它会被缩写为八个或更少。
- en: 'The commit SHA-1 can be obtained with the following command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 提交的SHA-1可以通过以下命令获得：
- en: '[PRE20]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This prints the last commit information, and only the SHA with the `%H` descriptor.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出最后一次提交的信息，以及带有`%H`描述符的SHA。
- en: 'To get the tag this commit refers to, we will use the `git-describe` command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取此提交所指的标签，我们将使用`git-describe`命令：
- en: '[PRE21]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Basically, `git-describe` finds the closest tags to the current commit. If
    this commit is marked by a tag, as it should be for our deployments, it returns
    the tag itself. If it''s not, it suffixes the tag with extra information about
    the commits until it reaches the current one. The following code shows how to
    use `git describe`, depending on the committed version of the code. Note how the
    code not associated with a tag returns the closest tag and extra digits:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`git-describe`会找到最接近当前提交的标签。如果此提交由标签标记，正如我们的部署应该做的那样，它将返回标签本身。如果没有，它将在标签后缀中添加有关提交的额外信息，直到达到当前提交。以下代码显示了如何使用`git
    describe`，具体取决于代码的提交版本。请注意，与标签不相关的代码将返回最接近的标签和额外的数字：
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This always returns a version and allows us to check at a glance whether the
    code in the current commit is tagged in `git` or not.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这将始终返回一个版本，并允许我们一目了然地检查当前提交的代码是否在`git`中标记。
- en: Anything that gets deployed to an environment should be tagged. Local development
    is a different matter, as it consists of code that is not ready yet.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将部署到环境中的任何内容都应该被标记。本地开发是另一回事，因为它包括尚未准备好的代码。
- en: We can store these two values programmatically, allowing us to do it automatically
    and including them in the Docker image.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以编程方式存储这两个值，从而使我们能够自动地进行操作，并将它们包含在Docker镜像中。
- en: Storing the version in the image
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将版本存储在镜像中
- en: We want to have the version available inside the image. Because the image is
    immutable, doing so during the build process is the objective. The limitation
    we need to overcome here is that the Dockerfile process does not allow us to execute
    commands on the host, only inside the container. We need to inject those values
    in the Docker image while building.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在镜像内部有版本可用。由于镜像是不可变的，所以在构建过程中实现这一目标是我们的目标。我们需要克服的限制是Dockerfile过程不允许我们在主机上执行命令，只能在容器内部执行。我们需要在构建时向Docker镜像中注入这些值。
- en: A possible alternative is to install Git inside the container, copy the whole
    Git tree, and obtain the values. This is usually discouraged because installing
    Git and the full source tree adds a lot of space to the container, something that
    is worse. During the build process, we already have Git available, so we just
    need to be sure to inject it externally, which is easy to do with a build script.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的替代方案是在容器内安装Git，复制整个Git树，并获取值。通常不鼓励这样做，因为安装Git和完整的源代码树会给容器增加很多空间，这是不好的。在构建过程中，我们已经有了Git可用，所以我们只需要确保外部注入它，这在构建脚本中很容易做到。
- en: 'The easiest way of passing the value is through the `ARG` parameters. As a
    part of the build process, we will transform them into environment variables,
    so they''ll be as easily available as any other part of the configuration. Let''s
    take a look at the Dockerfile in the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ARG`参数传递值的最简单方法。作为构建过程的一部分，我们将把它们转换为环境变量，这样它们将像配置的任何其他部分一样容易获取。让我们来看看以下代码中的Dockerfile：
- en: '[PRE23]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We accept an `ARG` parameter and then transform it into an environment variable
    through the `ENV` parameter. Both have the same name for simplicity. The `ARG`
    parameter has a default value for corner cases.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接受一个`ARG`参数，然后通过`ENV`参数将其转换为环境变量。为了简单起见，两者都具有相同的名称。`ARG`参数对于特殊情况有一个默认值。
- en: 'This makes the version available (inside the container) after we build it with
    the `build.sh` script, which obtains the values and calls `docker-compose` to
    build with the version as arguments, using the following steps:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`build.sh`脚本构建后，这使得版本在构建后（在容器内部）可用，该脚本获取值并调用`docker-compose`进行构建，使用版本作为参数，具体步骤如下：
- en: '[PRE24]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After the build process, the version is available as standard environment variables
    inside the container.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程之后，版本作为标准环境变量在容器内部可用。
- en: We included a script (`build-test.sh `) in each of the microservices in this
    chapter  (for example, [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter11/microservices/thoughts_backend/build-test.sh](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter11/microservices/thoughts_backend/build-test.sh)).
    This mocks the SHA-1 and version name to create a synthetic version for tests.
    It sets up the `v2.3` version for the Users Backend and `v1.5` for the Thoughts
    Backend. These will be used for examples in our code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的每个微服务中都包含了一个脚本（例如，[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter11/microservices/thoughts_backend/build-test.sh](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter11/microservices/thoughts_backend/build-test.sh)）。这个脚本模拟SHA-1和版本名称，以创建一个用于测试的合成版本。它为用户后端设置了`v2.3`版本，为思想后端设置了`v1.5`版本。这些将被用作我们代码中的示例。
- en: Check that the Kubernetes deployments include those versions (for example, the [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter11/microservices/thoughts_backend/docker-compose.yaml#L21](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter11/microservices/thoughts_backend/docker-compose.yaml#L21)
    image is the `v1.5` version).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Kubernetes部署是否包含这些版本（例如，[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter11/microservices/thoughts_backend/docker-compose.yaml#L21](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter11/microservices/thoughts_backend/docker-compose.yaml#L21)镜像是`v1.5`版本）。
- en: 'Furthermore, `VERSION_NAME` can also come from the CI pipeline as a parameter
    to the script. To do so, you''ll need to replace the script to accept it externally,
    as seen in the `build-ci.sh` script:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`VERSION_NAME`也可以作为CI管道的参数传递给脚本。为此，您需要替换脚本以接受外部参数，就像在`build-ci.sh`脚本中看到的那样：
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: All the versions of these scripts include the tagging of the image with `VERSION_NAME` as
    a tag.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些脚本的版本都包括使用`VERSION_NAME`作为标签对镜像进行标记。
- en: We can retrieve the environment variables with the version inside the container
    in the Python code, returning them in an endpoint, making the version easily accessible
    through the external API.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Python代码中在容器内检索包含版本的环境变量，并在端点中返回它们，使版本通过外部API轻松访问。
- en: Implementing the version endpoint
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现版本端点
- en: 'In the `admin_namespace.py` file, we will create a new `Version` endpoint using
    the following code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在`admin_namespace.py`文件中，我们将使用以下代码创建一个新的`Version`端点：
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Okay, now this code is very simple. It uses `os.environ` to retrieve the environment
    variables injected during the build as configuration parameters and return a dictionary
    with the commit SHA-1 and tag (described as a version).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这段代码非常简单。它使用`os.environ`来检索在构建过程中注入的环境变量作为配置参数，并返回一个包含提交SHA-1和标签（描述为版本）的字典。
- en: 'The service can be built and run locally, using `docker-compose`. To test access
    to the endpoint in `/admin/version` and to check it, follow these steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`docker-compose`在本地构建和运行服务。要测试对`/admin/version`端点的访问并进行检查，请按照以下步骤进行：
- en: '[PRE27]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As the version is available, we can update the autogenerated documentation
    to display the correct value, as shown in `app.py`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于版本可用，我们可以更新自动生成的文档以显示正确的值，如`app.py`中所示：
- en: '[PRE28]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So the version gets properly displayed in the automatic Swagger documentation.
    Once the version for a microservice is accessible through an endpoint in the API,
    other external services can access it to discover the version and make use of
    it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，版本将在自动生成的Swagger文档中正确显示。一旦微服务的版本通过API中的端点可访问，其他外部服务就可以访问它以发现版本并加以利用。
- en: Checking the version
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查版本
- en: Being able to check the version through the API allows us to access the version
    easily in a programmatic way. This can be used for multiple purposes, like generating
    a dashboard displaying the different versions deployed in different environments.
    But we will explore the possibility to introduce service dependencies.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通过API能够检查版本使我们能够以编程方式轻松访问版本。这可以用于多种目的，比如生成一个仪表板，显示不同环境中部署的不同版本。但我们将探讨引入服务依赖的可能性。
- en: A microservice, when it starts, can check the services it depends on, and also
    checks whether they are higher than an expected version. If they're not, it will
    not start. This avoids configuration problems when one dependent service gets
    deployed before the dependency is updated. This can happen in complex systems
    where there's no great coordination in deployments.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当微服务启动时，可以检查其所依赖的服务，并检查它们是否高于预期版本。如果不是，它将不会启动。这可以避免在依赖服务更新之前部署依赖服务时出现配置问题。这可能发生在部署协调不佳的复杂系统中。
- en: To check the version, when starting the server in `start_server.sh`, we will first call
    a small script that checks the dependency. If it is not available, it will produce
    an error and stop. We will check that the Frontend has an available version of
    the Thought Backend or even higher.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在`start_server.sh`中启动服务器时，要检查版本，我们将首先调用一个检查依赖项的小脚本。如果不可用，它将产生错误并停止。我们将检查前端是否具有Thought后端的可用版本，甚至更高版本。
- en: The script, which we will call in our example, is called `check_dependencies_services.py`,
    and it gets called in `start_server.sh` for the Frontend.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的示例中调用的脚本称为`check_dependencies_services.py`，并且在前端的`start_server.sh`中调用它。
- en: 'The `check_dependencies_services` script can be divided into three parts: a
    list of the dependencies required; a check for one dependency; and a main section
    where each of the dependencies is checked. Let''s take a look at the three parts.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`check_dependencies_services`脚本可以分为三个部分：所需依赖项列表；一个依赖项的检查；以及一个主要部分，其中检查每个依赖项。让我们来看看这三个部分。'
- en: Required version
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所需版本
- en: 'The first section describes each of the dependencies and the minimum version
    required. In our example, we stipulate that `thoughts_backend` needs to be version `v1.6` or
    up:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分描述了每个依赖项和所需的最低版本。在我们的示例中，我们规定`thoughts_backend`需要是版本`v1.6`或更高：
- en: '[PRE29]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This reuses the environment variable, `THOUGHTS_BACKEND_URL`, and completes
    the URL with the specific version path.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重用环境变量`THOUGHTS_BACKEND_URL`，并使用特定版本路径完成URL。
- en: The main section goes through all the dependencies described to check them.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 主要部分遍历了所有描述的依赖项以进行检查。
- en: The main function
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要函数
- en: 'The main function iterates through the `VERSIONS` dictionary and, for each
    one, does the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 主要函数遍历`VERSIONS`字典，并对每个版本执行以下操作：
- en: Calls the endpoint
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用端点
- en: Parses the result and gets the version
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析结果并获取版本
- en: Calls `check_version` to see whether it's correct
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`check_version`来查看是否正确
- en: 'If it fails, it ends with a `-1` status, so the script reports as failed. These
    steps are executed through the following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果失败，它以`-1`状态结束，因此脚本报告为失败。这些步骤通过以下代码执行：
- en: '[PRE30]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The main function also prints some messages to help to understand the different
    stages. To call the version endpoint, it uses the `requests` package and expects
    both a `200` status code and a parsable JSON result.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 主要函数还打印一些消息，以帮助理解不同的阶段。为了调用版本端点，它使用`requests`包，并期望`200`状态代码和可解析的JSON结果。
- en: Note that this code iterates through the `VERSION` dictionary. So far, we only
    added one dependency, but the User Backend is another dependency and can be added.
    It's left as an exercise to do.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此代码会遍历`VERSION`字典。到目前为止，我们只添加了一个依赖项，但用户后端是另一个依赖项，可以添加。这留作练习。
- en: The version field will be checked in the `check_version` function, which we
    will see in the next section.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 版本字段将在`check_version`函数中进行检查，我们将在下一节中看到。
- en: Checking the version
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查版本
- en: The `check_version` function checks whether the current version returned is
    higher or equal to the minimum version. To simplify it, we will use the `natsort` package to
    sort the versions and then check the lowest.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`check_version`函数检查当前返回的版本是否高于或等于最低版本。为了简化，我们将使用`natsort`包对版本进行排序，然后检查最低版本。'
- en: You can check out the `natsort` full documentation ([https://github.com/SethMMorton/natsort](https://github.com/SethMMorton/natsort)).
    It can sort a lot of natural strings and can be used in a lot of situations.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看`natsort`的完整文档（[https://github.com/SethMMorton/natsort](https://github.com/SethMMorton/natsort)）。它可以对许多自然字符串进行排序，并且可以在许多情况下使用。
- en: 'Basically, `natsort `supports ordering common patterns of versioning, which
    includes our standard versioning schema described previously (`v1.6` is higher
    than `v1.5`). The following code uses the library to sort both versions and verify
    that the minimum version is the lower one:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`natsort`支持常见的版本排序模式，其中包括我们之前描述的标准版本模式（`v1.6`高于`v1.5`）。以下代码使用该库对版本进行排序，并验证最低版本是否为较低版本：
- en: '[PRE31]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With this script, we can now start the service and it will check whether the
    Thoughts Backend has the proper version. If you started the service as described
    in the *Technical requirements* section, you''ll see that the Frontend is not
    starting properly, and produces a `CrashLoopBackOff` status, as shown here:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个脚本，我们现在可以启动服务，并检查Thoughts后端是否具有正确的版本。如果您按照*技术要求*部分中描述的方式启动了服务，您会发现前端无法正确启动，并产生`CrashLoopBackOff`状态，如下所示：
- en: '[PRE32]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Check the logs of one of the Frontend pods to see the reason, using the `kubectl
    logs` command, as seen here:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一个前端pod的日志，以查看原因，使用`kubectl logs`命令，如下所示：
- en: '[PRE33]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To fix the problem, you need to either build a version of the Thoughts Backend
    with a higher version or reduce the dependency requirement. This is left as an
    assessment at the end of the chapter.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决问题，您需要构建一个具有更高版本的Thoughts后端版本，或者减少依赖要求。这将作为本章结束时的评估留下。
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to deal with elements that work with several
    microservices at the same time.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何处理同时与多个微服务一起工作的元素。
- en: First, we talked about strategies to follow when new features need to change
    multiple microservices, including how to deploy small increments in an ordered
    fashion and to be able to roll back if there's a catastrophic problem.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们讨论了在新功能需要更改多个微服务时要遵循的策略，包括如何以有序的方式部署小的增量，并且能够在出现灾难性问题时回滚。
- en: We then talked about defining a clear versioning schema, and adding a version
    endpoint to the RESTful interfaces that allow self-discovery of the version for
    microservices. This self-discovery can be used to ensure that a microservice that
    depends on another is not deployed if the dependency is not there, which helps
    in coordinating releases.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了定义清晰的版本模式，并向RESTful接口添加了一个版本端点，以允许微服务自我发现版本。这种自我发现可以用来确保依赖于另一个微服务的微服务在没有依赖项的情况下不会被部署，这有助于协调发布。
- en: The code in GitHub for the Frontend in this chapter ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11/microservices/frontend](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11/microservices/frontend))
    includes a dependency to the Thoughts Backend that will stop deploying it. Note
    that the code, as is, won't work. Fixing it is left as an exercise.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的前端GitHub代码（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11/microservices/frontend](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11/microservices/frontend)）包含对Thoughts后端的依赖，这将阻止部署。请注意，原样的代码无法工作。修复留作练习。
- en: We also learned how to use ConfigMap to describe configuration information that's
    shared across different services in the Kubernetes cluster. We later described
    how to use Kubernetes secrets to handle a configuration that's sensitive and requires
    extra care.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何使用ConfigMap来描述在Kubernetes集群中共享的配置信息。我们随后描述了如何使用Kubernetes secrets来处理敏感且需要额外注意的配置。
- en: In the next chapter, we will see the various techniques for coordinating, in
    a highly effective manner, different teams working with different microservices.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到协调不同团队与不同微服务高效工作的各种技术。
- en: Questions
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the differences between releasing changes in a microservice architecture
    system and a monolith?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在微服务架构系统和单体架构中发布更改的区别是什么？
- en: Why should the released changes be small in a microservice architecture?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在微服务架构中，为什么发布的更改应该很小？
- en: How does semantic versioning work?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语义版本化是如何工作的？
- en: What are the problems associated with semantic versioning for internal interfaces
    in a microservice architecture system?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务架构系统中内部接口的语义版本化存在哪些问题？
- en: What are the advantages of adding a version endpoint?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加版本端点的优势是什么？
- en: How can we fix the dependency problem in this chapter's code?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何修复本章代码中的依赖问题？
- en: Which configuration variables should we store in a shared ConfigMap?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该在共享的ConfigMap中存储哪些配置变量？
- en: Can you describe the advantages and disadvantages of getting all the configuration
    variables in a single shared ConfigMap?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能描述将所有配置变量放在单个共享的ConfigMap中的优缺点吗？
- en: What's the difference between a Kubernetes ConfigMap and a Kubernetes secret?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes ConfigMap和Kubernetes secret之间有什么区别？
- en: How can we change a Kubernetes secret?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何更改Kubernetes secret？
- en: Imagine that, based on the configuration, we decided to change the `public_key.pub` file
    from a secret to a ConfigMap. What changes do we have to implement?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设根据配置，我们决定将`public_key.pub`文件从秘密更改为ConfigMap。我们需要实施哪些更改？
- en: Further reading
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For handling your secrets on AWS, you can interact with a tool called CredStash
    ([https://github.com/fugue/credstash](https://github.com/fugue/credstash)). You
    can learn more about how to use it in the book *AWS SysOps Cookbook – Second Edition* ([https://www.packtpub.com/cloud-networking/aws-administration-cookbook-second-edition](https://www.packtpub.com/cloud-networking/aws-administration-cookbook-second-edition)).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理AWS上的秘密，您可以与一个名为CredStash的工具交互（[https://github.com/fugue/credstash](https://github.com/fugue/credstash)）。您可以在书籍*AWS
    SysOps Cookbook – Second Edition* ([https://www.packtpub.com/cloud-networking/aws-administration-cookbook-second-edition](https://www.packtpub.com/cloud-networking/aws-administration-cookbook-second-edition))中了解更多信息。
