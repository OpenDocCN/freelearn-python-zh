- en: Building Microservices in Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 构建微服务
- en: Now, since you understand what microservices are and, hopefully, have a sense
    of their key benefits, I'm sure you are eager to begin building them. In this
    chapter, we will immediately start writing REST APIs, which collectively work
    as microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然您了解了微服务是什么，并且希望您对它们的关键优势有所了解，我相信您迫不及待地想要开始构建它们。在本章中，我们将立即开始编写 REST API，这些
    API 共同作为微服务工作。
- en: 'The topics we will cover in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Building a REST API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 REST API
- en: Testing an API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 API
- en: Python concepts
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 概念
- en: Let's first understand a few concepts of Python, which we will use in this book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解一些 Python 的概念，这些概念将在本书中使用。
- en: Modules
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: A module basically allows you to logically organize your programming code. It
    is similar to any other Python program. They are needed in scenarios where we
    need only a bit of code to be imported instead of the entire program. A **module**
    can be a combination of one or multiple functions classes, and many more. We will
    use a couple of inbuilt functions, which are a part of the Python library. Also,
    wherever needed, we will create our own modules.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 模块基本上允许您逻辑地组织您的编程代码。它类似于任何其他 Python 程序。在需要仅导入少量代码而不是整个程序的情况下，我们需要它们。**模块**可以是一个或多个函数类的组合，以及其他许多内容。我们将使用一些内置函数，它们是
    Python 库的一部分。此外，我们将根据需要创建自己的模块。
- en: 'The following example code showcases the structure of modules:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码展示了模块的结构：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can import the preceding module using the following command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令导入前面的模块：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Functions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'A function is a block of organized, self-contained programs that perform a
    specific task, which you can incorporate into your own larger programs. They are
    defined as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一块组织良好的、自包含的程序块，执行特定任务，您可以将其合并到自己的更大的程序中。它们的定义如下：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'These are a few points to remember:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要记住的几点：
- en: Indentation is very important in Python programs
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩进在 Python 程序中非常重要
- en: By default, parameters have a positional behavior, and you need to inform them
    in the same order that they were defined in
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，参数具有位置行为，您需要按照它们在定义时的顺序进行通知
- en: 'Please see the following code snippet example, which showcases functions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下代码片段示例，其中展示了函数：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can call the preceding function as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按以下方式调用前面的函数：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following screenshot shows the execution of the preceding `display` function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面的 `display` 函数的执行情况：
- en: '![](img/00025.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00025.jpeg)'
- en: Note that if you have more than one Python version installed on your system,
    you need to use Python 3 instead of Python, which uses the default version of
    Python (generally, 2.7.x).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您的系统上安装了多个 Python 版本，您需要使用 Python 3 而不是 Python，后者使用 Python 的默认版本（通常是 2.7.x）。
- en: Modeling microservices
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建模微服务
- en: In this book, we will develop a full-fledged working web app that works independently.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将开发一个完整的独立工作的 Web 应用程序。
- en: Now, since we have a basic understanding of Python, let's get started with modeling
    our microservices and understanding the application workflow.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我们对 Python 有了基本的了解，让我们开始对我们的微服务进行建模，并了解应用程序的工作流程。
- en: 'The following diagram shows the microservices architecture and application
    workflow:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了微服务架构和应用程序工作流程：
- en: '![](img/00026.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00026.jpeg)'
- en: Building microservices
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建微服务
- en: In this book, we will use Flask as a web framework to build our microservices.
    **Flask** is a powerful web framework, which is easy to learn and simple to use.
    Additionally, in Flask, we need a little boilerplate code to get a simple app
    up and running.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用 Flask 作为构建微服务的 Web 框架。**Flask** 是一个强大的 Web 框架，易于学习和简单易用。此外，在 Flask
    中，我们需要一些样板代码来启动一个简单的应用程序。
- en: Since we will create our application using the twelve-factor app concept, we
    will begin by ensuring that we have a centralized code base. By now, you should
    know how to create a GitHub repository. If not, make sure you create it as per
    the blogpost link provided in [Chapter 1](part0023.html#LTSU0-4022ecb0f8ea4b719ffb742bf2a6a072),
    *Introducing Cloud Native Architecture and Microservices*. We will be pushing
    the code regularly to the repository.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用十二要素应用程序概念创建我们的应用程序，因此我们将首先确保我们有一个集中的代码库。到目前为止，您应该知道如何创建 GitHub 存储库。如果不知道，请确保按照[第
    1 章](part0023.html#LTSU0-4022ecb0f8ea4b719ffb742bf2a6a072)中提供的博客文章链接创建它，*介绍云原生架构和微服务*。我们将定期将代码推送到存储库。
- en: Assuming you have created the repository during the course of this book, we
    will use the GitHub repository ([https://github.com/PacktPublishing/Cloud-Native-Python.git](https://github.com/PacktPublishing/Cloud-Native-Python.git)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您在本书的过程中已创建了存储库，我们将使用 GitHub 存储库 ([https://github.com/PacktPublishing/Cloud-Native-Python.git](https://github.com/PacktPublishing/Cloud-Native-Python.git))。
- en: 'So, let''s set up our local directory in sync with the remote repository. To
    ensure that we are in the app directory, use the following commands:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将本地目录与远程存储库同步。确保我们在 app 目录中，使用以下命令：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You will see the following output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '![](img/00027.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00027.jpeg)'
- en: We have successfully pushed our first commit to the remote repository; we will
    keep doing so in a similar fashion till we reach a certain milestone in building
    microservices, as well as the application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功将第一个提交推送到远程存储库；我们将以类似的方式继续这样做，直到我们在构建微服务和应用程序方面达到一定的里程碑。
- en: Now, we need to install a file-based database, such as SQLite version 3, which
    will work as the datastore for our microservices.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要安装一个基于文件的数据库，例如 SQLite 版本 3，它将作为我们微服务的数据存储。
- en: 'To install SQLite 3, use the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 SQLite 3，请使用以下命令：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can now create and use (source) a `virtualenv` environment, which will isolate
    the local app''s environment from the global `site-packages` installations. If
    `virtualenv` is not installed, you can install it using the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建并使用（源）`virtualenv` 环境，它将使本地应用程序的环境与全局 `site-packages` 安装隔离开来。如果未安装
    `virtualenv`，可以使用以下命令进行安装：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now create `virtualenv` as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按如下方式创建`virtualenv`：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We should see the output of the preceding command as shown in the following
    screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到上述命令的输出，如下面的截图所示：
- en: '![](img/00028.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00028.jpeg)'
- en: 'After the `virtualenv` setup, currently, we need one dependency in our virtualenv
    environment that needs to be installed. Use the following command to add one package
    dependency into `requirements.txt`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`virtualenv`设置之后，当前，我们的`virtualenv`环境中需要安装一个依赖项。使用以下命令将一个包依赖项添加到`requirements.txt`中：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the future, if any more dependencies are needed as part of the application,
    they will go inside the `requirements.txt` file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将来，如果应用程序需要更多依赖项，它们将放在`requirements.txt`文件中。
- en: 'Let''s use the requirements file to install the dependencies into the `virtualenv`
    environment as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用要求文件将依赖项安装到`virtualenv`环境中，如下所示：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we have the dependencies installed, let''s create a file, `app.py`,
    with the following contents:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了依赖项，让我们创建一个名为`app.py`的文件，其中包含以下内容：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code is the basic structure to run an application using Flask.
    It basically initializes the `Flask` variable and runs on port `5000`, which is
    accessible from anywhere (`0.0.0.0`).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是使用Flask运行应用程序的基本结构。它基本上初始化了`Flask`变量，并在端口`5000`上运行，可以从任何地方（`0.0.0.0`）访问。
- en: Now, let's test the preceding code and see if everything is working fine.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试上述代码，并查看一切是否正常工作。
- en: 'Execute the following command to run the application:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令来运行应用程序：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We should see the output of the preceding command as shown in the following
    screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到上述命令的输出，如下面的截图所示：
- en: '![](img/00029.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00029.jpeg)'
- en: 'At this point in time, before we start building RESTful APIs, we need to decide
    what will be our root URL to access the service, which will further decide the
    sub URI for the different methods. Consider the following example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，在我们开始构建RESTful API之前，我们需要决定我们的根URL是什么，以访问服务，这将进一步决定不同方法的子URI。考虑以下示例：
- en: '`http://[hostname]/api/v1/`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://[hostname]/api/v1/`。'
- en: 'Since, in our case, we will be using a local machine, `hostname` can be `localhost`
    with port, which is, by default, `5000` for a Flask application. So, our root
    URL will be as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在我们的情况下，我们将使用本地机器，`hostname`可以是带有端口的`localhost`，默认情况下，对于Flask应用程序，端口为`5000`。因此，我们的根URL将如下所示：
- en: '`http://localhost:5000/api/v1/`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:5000/api/v1/`。'
- en: 'Now, let''s decide the resources on which different actions will be performed,
    and which will be exposed by this service. In this case, we will create two resources:
    users and tweets.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们决定对哪些资源执行不同的操作，并且这些资源将由此服务公开。在这种情况下，我们将创建两个资源：用户和推文。
- en: 'Our users and info resource will use the HTTP methods as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户和信息资源将使用以下HTTP方法：
- en: '| **HTTP Method** | **URI** | **Actions** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP方法** | **URI** | **操作** |'
- en: '| `GET` | `http://localhost:5000/api/v1/info` | This responds back with the
    version |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `http://localhost:5000/api/v1/info` | 这将返回版本信息 |'
- en: '| `GET` | `http://localhost:5000/api/v1/users` | This responds with the user
    list |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `http://localhost:5000/api/v1/users` | 这将返回用户列表 |'
- en: '| `GET` | `http://localhost:5000/api/v1/users/[user_id]` | The response will
    be the user details of the specified `user_id` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `http://localhost:5000/api/v1/users/[user_id]` | 响应将是指定`user_id`的用户详细信息
    |'
- en: '| `POST` | `http://localhost:5000/api/v1/users` | This resource will create
    new users in the backend server with values from the object passed |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `http://localhost:5000/api/v1/users` | 此资源将在后端服务器中创建新用户，并使用传递的对象的值
    |'
- en: '| `DELETE` | `http://localhost:5000/api/v1/users` | This resource will delete
    the user with the specified username passed in JSON format |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `http://localhost:5000/api/v1/users` | 此资源将删除以JSON格式传递的指定用户名的用户
    |'
- en: '| `PUT` | `http://localhost:5000/api/v1/users/[user_id]` | This resource updates
    the user information of the specific `user_id` based on the JSON object passed
    as part of the API call. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `http://localhost:5000/api/v1/users/[user_id]` | 此资源将根据API调用的一部分传递的JSON对象更新特定`user_id`的用户信息。|'
- en: Using the client, we will perform actions against resources such as `add`, `remove`,
    `modify`, and many more.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用客户端，我们将对资源执行操作，如`add`，`remove`，`modify`等等。
- en: For the scope of this chapter, we will take a file-based database, such as SQLite
    3, which we already installed earlier.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的范围内，我们将采用基于文件的数据库，如SQLite 3，我们之前已经安装过。
- en: Let's go and create our first resource, which is `/api/v1/info`, and show the
    available versions and their release details.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去创建我们的第一个资源，即`/api/v1/info`，并显示可用版本及其发布详细信息。
- en: 'Before that, we need to create an `apirelease` table schema, as defined in
    SQLite 3, which will contain information about the API version release. This can
    be done as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，我们需要创建一个`apirelease`表模式，如SQLite 3中定义的，其中将包含有关API版本发布的信息。可以按如下方式完成：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once it is created, you can add records into SQLite 3 for our first version
    (`v1`) using the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，您可以使用以下命令将记录添加到SQLite 3中的第一个版本（`v1`）：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s define the route `/api/v1/info` and function in `app.py`, which will
    basically handle the RESTful call on the `/api/v1/info` route. This is done as
    follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`app.py`中定义路由`/api/v1/info`和函数，它将基本上处理`/api/v1/info`路由上的RESTful调用。这样做如下：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we have added a route and the handle for it, let''s make a RESTful
    call on `http://localhost:5000/api/v1/info`, as shown in this screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了一个路由和其处理程序，让我们在`http://localhost:5000/api/v1/info`上进行RESTful调用，如此截图所示：
- en: '![](img/00030.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00030.jpeg)'
- en: Awesome! It works!!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！它有效了！
- en: Let's move on to the `/api/v1/users` resource, which will help us perform various
    actions on the user's records.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论`/api/v1/users`资源，它将帮助我们对用户记录执行各种操作。
- en: 'We can define a user as having the following fields:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将用户定义为具有以下字段：
- en: '`id`: This is a unique identifier for users (Numeric type)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这是用户的唯一标识符（数字类型）'
- en: '`username`: This is a unique identifier or `handler` for users for authentication
    (String type)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username`：这是用户的唯一标识符或`handler`，用于身份验证（字符串类型）'
- en: '`emailid`: This is the user''s email (String type)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emailid`：这是用户的电子邮件（字符串类型）'
- en: '`password`: This is the user''s password (String type)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password`：这是用户的密码（字符串类型）'
- en: '`full_name`: This is the full name of the user (String type)'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`full_name`：这是用户的全名（字符串类型）'
- en: 'In order to create the user''s table schema in SQLite, use the following command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在SQLite中创建用户表模式，请使用以下命令：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Building resource user methods
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建资源用户方法
- en: Let's define our `GET` methods for user resources.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为用户资源定义我们的`GET`方法。
- en: GET /api/v1/users
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GET /api/v1/users
- en: The `GET/api/v1/users` method shows the list of all users.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET/api/v1/users`方法显示所有用户的列表。'
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have added the route, we need to define the `list_users()` function,
    which will connect with the database to get you the complete list of users. Add
    the following code to `app.py`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了路由，我们需要定义`list_users()`函数，它将连接数据库以获取完整的用户列表。将以下代码添加到`app.py`中：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that we have added the route and the handle for it, let''s test check the
    `http://localhost:5000/api/v1/users` URL as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了路由和处理程序，让我们测试`http://localhost:5000/api/v1/users` URL，如下所示：
- en: '![](img/00031.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00031.jpeg)'
- en: GET /api/v1/users/[user_id]
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GET /api/v1/users/[user_id]
- en: The `GET/api/v1/users/[user_id]` method shows the user details defined by `user_id`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET/api/v1/users/[user_id]`方法显示由`user_id`定义的用户详细信息。'
- en: 'Let''s create the route for preceding a `GET` request into the `app.py` file
    as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个将`GET`请求前置到`app.py`文件中的路由，如下所示：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see in the preceding code, we call the `list_user(user_id)` route
    into the `list_user(user)` function, which is not yet defined in `app.py`. Let''s
    define it to get the details of the specified user, as follows, in the `app.py`
    file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在上面的代码中所看到的，我们将`list_user(user_id)`路由调用到`list_user(user)`函数中，但`app.py`中尚未定义。让我们定义它以获取指定用户的详细信息，如下所示，在`app.py`文件中：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that we''ve added the `list_user(user_id)` function, let''s test it out
    and see if everything is working fine:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了`list_user(user_id)`函数，让我们测试一下，看看是否一切正常：
- en: '![](img/00032.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00032.jpeg)'
- en: 'Oops! It seems the ID is not present; usually, Flask applications respond with
    an HTML message with a `404` error if the ID is not present. Since this is a web
    service application, and we are getting a response in JSON for other APIs, we
    need to write `handler` for the `404` error so that, instead of the HTML response,
    it should respond back in JSON, even for errors. For example, see the following
    code for `404` error handling. Now, the server will respond with proper messages
    which are part of the code, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕！看来ID不存在；通常，如果ID不存在，Flask应用程序会以`404`错误的HTML消息作出响应。由于这是一个Web服务应用程序，并且我们正在为其他API获取JSON响应，因此我们需要为`404`错误编写`handler`，以便即使对于错误，它也应该以JSON形式而不是HTML响应进行响应。例如，查看以下代码以处理`404`错误。现在，服务器将以代码的一部分作出适当的响应消息，如下所示：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![](img/00033.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00033.jpeg)'
- en: Additionally, you can add the `abort` library from Flask, which is basically
    for calling exceptions. Similarly, you can create multiple error handlers for
    different HTTP error codes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以从Flask中添加`abort`库，这基本上是用于调用异常。同样，您可以为不同的HTTP错误代码创建多个错误处理程序。
- en: Now that our `GET` methods are working fine, we will go forward and write the
    `POST` method, which is similar to adding new users to the users list.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`GET`方法运行良好，我们将继续编写`POST`方法，这类似于将新用户添加到用户列表中。
- en: 'There are two methods to pass the data into the `POST` method, which are as
    follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以将数据传递到`POST`方法中，如下所示：
- en: '**JSON**: In this approach, we pass the JSON record in the form of an object
    as part of the request. The RESTful API call would look like this:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON**：在这种方法中，我们将JSON记录作为请求的一部分以对象的形式传递。RESTful API调用将如下所示：'
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Parameterized**: In this approach, we pass the values of the record as parameters,
    as follows:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数化**：在这种方法中，我们将记录的值作为参数传递，如下所示：'
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the JSON method, we provide the input data in the form of `json`, and we
    read it in the same way. On the other hand, in the parameterized method, we provide
    the input data (that is, `username`, and so on) in the form of URL parameters,
    and read data in the same way.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSON方法中，我们以`json`的形式提供输入数据，并以相同的方式读取它。另一方面，在参数化方法中，我们以URL参数的形式提供输入数据（即`username`等），并以相同的方式读取数据。
- en: Also note that the API creation at the backend will vary with the type of API
    call being made.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，后端的API创建将根据所进行的API调用类型而有所不同。
- en: POST /api/v1/users
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POST /api/v1/users
- en: 'In this book, we go with the first approach to the `POST` method. So, let''s
    define our route for the `post` method in `app.py`, and call the function to update
    the user record to the database file, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们采用了`POST`方法的第一种方法。因此，让我们在`app.py`中定义`post`方法的路由，并调用函数将用户记录更新到数据库文件，如下所示：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, in the preceding method, we called the exception with error
    code `400`; let''s write its handler now:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的方法中，我们使用错误代码`400`调用了异常；现在让我们编写它的处理程序：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We still need to define the `add_user(user)` function, which will update the
    new user record. Let''s define it in `app.py`, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要定义`add_user(user)`函数，它将更新新的用户记录。让我们在`app.py`中定义它，如下所示：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that we have added `handler`, as well as the route for the `POST` method
    of the user, let''s test it by adding a new user using the following API call:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了`handler`，以及用户的`POST`方法的路由，让我们通过以下API调用来测试添加新用户：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, validate the user''s list curl, `http://localhost:5000/api/v1/users`,
    as shown in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，验证用户列表的curl，`http://localhost:5000/api/v1/users`，如下截图所示：
- en: '![](img/00034.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00034.jpeg)'
- en: DELETE /api/v1/users
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DELETE /api/v1/users
- en: The `delete` method helps remove a specific record, which is defined by a username.
    We will pass `username` as the JSON object that needs to be deleted from the database.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`方法帮助删除特定记录，该记录由用户名定义。我们将以JSON对象形式传递需要从数据库中删除的`username`。'
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Great! We have added the route `/handler` for the `DELETE` method for the user
    resource; let''s test it using the following `test` API call:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经为用户资源的`DELETE`方法添加了路由`/handler`；让我们使用以下`test`API调用来测试它：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, hit the user list API (`curl http://localhost:5000/api/v1/users`) to
    see if the changes have been made:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，访问用户列表API（`curl http://localhost:5000/api/v1/users`）以查看是否已进行更改：
- en: '![](img/00035.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00035.jpeg)'
- en: Awesome! User deletion is successful.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！用户删除成功。
- en: PUT /api/v1/users
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PUT /api/v1/users
- en: The PUT API basically helps us update a user's record specified by `user_id`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: PUT API基本上帮助我们更新由`user_id`指定的用户记录。
- en: 'Go ahead and create a route with the `PUT` method to update the `user` records
    defined in the `app.py` file, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 继续并创建一个使用`PUT`方法更新`app.py`文件中定义的`user`记录的路由，如下所示：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s specify the definition of the `upd_user(user)` function, which basically
    updates the information in the database with the check that the user `id` exists:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们指定`upd_user(user)`函数的定义，它基本上会更新数据库中的信息，并检查用户`id`是否存在：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now that we have added the API handle for the `PUT` method for the user resource,
    let''s test it out as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为用户资源添加了`PUT`方法的API句柄，让我们按照以下方式进行测试：
- en: '![](img/00036.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00036.jpeg)'
- en: 'We have defined our resources that are a part of version `v1`. Now, let''s
    define our next version release, `v2`, which will add a tweet resource to our
    microservices. Users who are defined in users resources are allowed to perform
    actions on their tweets. Now, `/api/info` will be shown, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了我们的资源，这是版本`v1`的一部分。 现在，让我们定义我们的下一个版本发布，`v2`，它将向我们的微服务添加一个推文资源。 在用户资源中定义的用户被允许对其推文执行操作。
    现在，`/api/info`将显示如下：
- en: '![](img/00037.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00037.jpeg)'
- en: 'Our tweets resource will use the `HTTP` methods as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的推文资源将使用以下`HTTP`方法：
- en: '| **HTTP Method** | **URI** | **Actions** |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP方法** | **URI** | **操作** |'
- en: '| `GET` | `http://localhost:5000/api/v2/tweets` | This retrieves the tweets
    list |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `http://localhost:5000/api/v2/tweets` | 这将检索推文列表'
- en: '| `GET` | `http://localhost:5000/api/v2/users/[user_id]` | This retrieves a
    tweet that is given a specific ID |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `http://localhost:5000/api/v2/users/[user_id]` | 这将检索给定特定ID的推文'
- en: '| `POST` | `http://localhost:5000/api/v2/tweets` | This resource will register
    new tweets with the JSON data passed as part of the API call into the backend
    database |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `http://localhost:5000/api/v2/tweets` | 此资源将使用作为API调用的一部分传递的JSON数据在后端数据库中注册新推文'
- en: 'We can define a tweet as having the following fields:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将推文定义为具有以下字段：
- en: '`id`: This is the unique identifier for each tweet (Numeric type)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这是每条推文的唯一标识符（数字类型）'
- en: '`username`: This should exist as a user in the users resources (String type)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username`：这应该作为用户存在于用户资源中（字符串类型）'
- en: '`body`: This is the content of the tweet (String type)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body`：这是推文的内容（字符串类型）'
- en: '`Tweet_time`: (Specify type)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tweet_time`：（指定类型）'
- en: 'You can define the preceding tweets resource schema in SQLite 3 as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在SQLite 3中定义前面的推文资源模式如下：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Great! The tweets resource schema is ready; let's create our `GET` methods for
    the tweets resource.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！推文资源模式已准备就绪； 让我们为推文资源创建我们的`GET`方法。
- en: Building resource tweets methods
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建资源推文方法
- en: In this section, we will be creating APIs for the tweet resource with a different
    method which will help us perform different operations on the backend database
    for tweets.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用不同的方法为推文资源创建API，这将帮助我们在后端数据库上执行不同的操作。
- en: GET /api/v2/tweets
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GET /api/v2/tweets
- en: This method lists all the tweets from all the users.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法列出所有用户的所有推文。
- en: 'Add the following code to `app.py` to add the route for the `GET` method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`app.py`中以添加`GET`方法的路由：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So, now that we''ve added a function to get the complete tweets list, let''s
    test out the preceding code by making a RESTful API call as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经添加了获取完整推文列表的功能，让我们通过以下RESTful API调用测试前面的代码：
- en: '![](img/00038.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.jpeg)'
- en: Currently, we haven't added any tweet, that's why it returned the empty set.
    Let's add a few tweets.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们还没有添加任何推文，这就是为什么它返回了空集。 让我们添加一些推文。
- en: POST /api/v2/tweets
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POST /api/v2/tweets
- en: The POST method adds new tweets by a specified user.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: POST方法通过指定的用户添加新推文。
- en: 'Add the following code to `app.py` to add the route for the `POST` method for
    the tweets resource:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`app.py`中，以添加`POST`方法的路由到推文资源：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s add the definition of `add_tweet(user_tweet)` to add tweets by a specified
    user, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加`add_tweet(user_tweet)`的定义，以通过指定的用户添加推文，如下所示：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So, now that we''ve added the function to add the tweets list to the database,
    let''s test out the preceding code by making a RESTful API call as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经添加了将推文列表添加到数据库的功能，让我们通过以下RESTful API调用测试前面的代码：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We should see the output of the preceding API call similar to the following
    screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到前面的API调用的输出与以下截图类似：
- en: '![](img/00039.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00039.jpeg)'
- en: 'Let''s check whether the tweet was added successfully or not by checking the
    tweets status using:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过检查推文的状态来检查推文是否成功添加：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![](img/00040.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00040.jpeg)'
- en: Now that we have added our first tweet, what if we need to see only a tweet
    with a certain ID? In that case, we go for the `GET` method with `user_id`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了我们的第一条推文，如果我们需要只看到特定ID的推文怎么办？在这种情况下，我们使用`GET`方法和`user_id`。
- en: GET /api/v2/tweets/[id]
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GET /api/v2/tweets/[id]
- en: The `GET` method lists the tweets made by the specified ID.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`方法列出由指定ID制作的推文。'
- en: 'Add the following code to `app.py` to add a route for the `GET` method with
    a specified ID:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`app.py`中，以添加具有指定ID的`GET`方法的路由：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s define the `list_tweet()` function, which connects to the database,
    gets us the tweets with the specified ID, and responds with the JSON data. This
    is done as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义`list_tweet()`函数，它连接到数据库，获取具有指定ID的推文，并以JSON数据响应。 这样做如下：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now that we''ve added the function to get a tweet with the specified ID, let''s
    test out the preceding code by making a RESTful API call at:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了获取具有指定ID的推文的功能，让我们通过在以下位置进行RESTful API调用来测试前面的代码：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![](img/00041.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00041.jpeg)'
- en: With this addition of tweets, we have successfully built the RESTful API that
    collectively works as the microservices needed to access data and perform various
    actions around it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些推文的添加，我们成功地构建了RESTful API，它作为访问数据和执行各种操作所需的微服务共同工作。
- en: Testing the RESTful API
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试RESTful API
- en: So far, we have been building the RESTful API and hitting the URL for the root
    URL to see the response and to understand whether the different methods are working
    properly in the backend or not. Since it's new code, everything should be tested
    100% to make sure it works fine in the production environment. In this section,
    we will write the test cases, which should work individually, and also as a system,
    to make sure that the complete backend service is good to go for production.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在构建RESTful API并访问根URL以查看响应，并了解不同的方法是否在后端正常工作。由于这是新代码，应该对所有内容进行100%的测试，以确保它在生产环境中正常工作。在本节中，我们将编写测试用例，这些测试用例应该单独工作，也应该作为一个系统工作，以确保完整的后端服务可以投入生产。
- en: 'There are different types of testing, which are defined as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的测试，定义如下：
- en: '**Functional testing**: This is basically used to test the functionality of
    a component or a system. We do this test against the functional specification
    of a component.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试**：基本上用于测试组件或系统的功能。我们根据组件的功能规范进行此测试。'
- en: '**Non-function testing**: This kind of testing is done against the quality
    characteristics of a component, which includes efficiency testing, reliability
    testing, and so on.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非功能测试**：这种测试针对组件的质量特征进行，包括效率测试、可靠性测试等。'
- en: '**Structural testing**: This type of testing is used to test the structure
    of the system. To write test cases, testers are required to have a knowledge of
    the internal implementations of the code.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构测试**：这种类型的测试用于测试系统的结构。为了编写测试用例，测试人员需要了解代码的内部实现。'
- en: In this section, we will write the test cases, specifically, unit test cases,
    against our application. We will write Python code which will run automatically,
    test out all the API calls, and respond back with the test results.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写测试用例，特别是单元测试用例，针对我们的应用程序。我们将编写Python代码，它将自动运行，测试所有API调用，并以测试结果做出响应。
- en: Unit testing
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'A unit test is a piece of code that tests a unit of work or the logical unit
    in the tested system. The following are the characteristics of unit test cases:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是测试工作单元或被测试系统中的逻辑单元的代码片段。以下是单元测试用例的特点：
- en: '**Automated**: They should be executed automatically'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化**：它们应该自动执行'
- en: '**Independent**: They shouldn''t have any dependencies'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立**：它们不应该有任何依赖关系'
- en: '**Consistent and repeatable**: They should maintain idempotency'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致和可重复：它们应该保持幂等性
- en: '**Maintainable**: They should be easy enough to understand and update'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护**：它们应该足够容易理解和更新'
- en: We will use a unit testing framework called **nose**. As an alternative, we
    can use docstest (`https://docs.python.org/2/library/doctest.html`) for testing.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为**nose**的单元测试框架。作为替代，我们可以使用docstest（`https://docs.python.org/2/library/doctest.html`）进行测试。
- en: 'So, let''s install nose using `pip` with the following command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们使用以下命令使用`pip`安装nose：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Or, you can put it in `requirement.txt`, and use the following command to install
    it:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以将其放在`requirement.txt`中，并使用以下命令进行安装：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now that we have installed the nose test framework, let''s begin writing the
    initial test cases on a separate file, say, `flask_test.py`, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了nose测试框架，让我们开始在一个单独的文件上编写初始测试用例，比如`flask_test.py`，如下所示：
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding code will test the app and initialize `self.app` with our app.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将测试应用程序并使用我们的应用程序初始化`self.app`。
- en: 'Let''s write our test case to get the response code for `GET` `/api/v1/users`
    and add it to our FlaskappTest class as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写我们的测试用例，以获取`GET` `/api/v1/users`的响应代码，并将其添加到我们的FlaskappTest类中，如下所示：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The preceding code will test whether we get the response on `/api/v1/users`
    as `200`; if not, it will throw an error and our test will fail. As you can see,
    as this code doesn't have any dependency from any other code, we will call it
    as a unit test case.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将测试我们是否在`/api/v1/users`上获得`200`的响应；如果没有，它将抛出错误，我们的测试将失败。正如你所看到的，由于这段代码没有任何来自其他代码的依赖，我们将其称为单元测试用例。
- en: 'Now, how to run this code? Since we have installed the nose testing framework,
    simply execute the following command from the current working directory of the
    test case file (in this case, `flask_test.py`):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如何运行这段代码？由于我们已经安装了nose测试框架，只需从测试用例文件的当前工作目录（在本例中为`flask_test.py`）中执行以下命令：
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Great! Similarly, let's write more test cases for the RESTful API for the different
    methods of the resources that we created earlier in this chapter.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！同样，让我们为本章前面创建的资源的不同方法的RESTful API编写更多的测试用例。
- en: 'The GET `/api/v2/tweets` test case is given as follows:'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET `/api/v2/tweets`测试用例如下：
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The GET `/api/v1/info` test case is as follows:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET `/api/v1/info`测试用例如下：
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The POST `/api/v1/users` test case is written like this:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POST `/api/v1/users`测试用例写成这样：
- en: '[PRE51]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The PUT `/api/v1/users` test case is as follows:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PUT `/api/v1/users`测试用例如下：
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The POST `/api/v1/tweets` test case is as follows:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POST `/api/v1/tweets`测试用例如下：
- en: '[PRE53]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The DELETE `/api/v1/users` test case is given as follows:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DELETE `/api/v1/users`测试用例如下：
- en: '[PRE54]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Similarly, you can write more test cases based on your thinking to make these
    RESTful APIs more reliable and bug-free.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以根据自己的想法编写更多的测试用例，使这些RESTful API更加可靠和无错。
- en: 'Let''s execute all of them together and check whether all the tests have passed.
    The following screenshot shows the test result to the `flask_test.py` script:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起执行所有这些测试，并检查是否所有测试都已通过。以下屏幕截图显示了对`flask_test.py`脚本的测试结果：
- en: '![](img/00042.jpeg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00042.jpeg)'
- en: Awesome! Now that all our tests have passed, we are good to go for the next
    level of creating web pages around these RESTful API's.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们所有的测试都已通过，我们可以继续创建围绕这些RESTful API的网页的下一个级别。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we focused on writing lots of code to build our microservices.
    We basically got an understanding of how the RESTful APIs work. We also saw how
    we can extend these APIs and make sure that we understand the `HTTP` response
    by the response given by these APIs. Moreover, you learned how to write test cases,
    which are most important to ensure that our code works well and is good to go
    for the production environment.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们专注于编写大量的代码来构建我们的微服务。我们基本上了解了RESTful API的工作原理。我们还看到了如何扩展这些API，并确保我们理解这些API给出的`HTTP`响应。此外，您还学会了如何编写测试用例，这对于确保我们的代码能够正常运行并且适用于生产环境非常重要。
