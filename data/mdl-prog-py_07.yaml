- en: Chapter 7. Advanced Module Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。高级模块技术
- en: 'In this chapter, we will look at a number of more advanced techniques for working
    with modules and packages. In particular, we will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究一些更高级的模块和包的工作技术。特别是，我们将：
- en: Examine the more unusual ways in which the `import` statement can be used, including
    optional imports, local imports, and how to tweak the way importing works by changing
    `sys.path`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查`import`语句可以使用的更不寻常的方式，包括可选导入、本地导入，以及通过更改`sys.path`来调整导入工作方式的方法
- en: Briefly examine a number of "gotchas" relating to importing modules and packages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要检查与导入模块和包相关的一些“陷阱”
- en: Take a look at how you can use the Python interactive interpreter to help develop
    your modules and packages more quickly
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看如何使用Python交互解释器来帮助更快地开发你的模块和包
- en: Learn how to work with global variables within a module or package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在模块或包内使用全局变量
- en: See how to configure a package
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看如何配置一个包
- en: Discover how to include data files as part of your Python package.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何将数据文件包含为Python包的一部分。
- en: Optional imports
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选导入
- en: 'Try opening the Python interactive interpreter and entering the following command:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试打开Python交互解释器并输入以下命令：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The interpreter will return the following error message:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器将返回以下错误消息：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This shouldn't be a surprise to you; you may have even seen this error in your
    own programs if you made a typo within an `import` statement.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你来说不应该是个惊喜；如果在`import`语句中打错字，甚至可能在你自己的程序中看到这个错误。
- en: 'The interesting thing about this error is that it doesn''t just apply where
    you''ve made a typo. You can also use this to test if a module or package is available
    on this particular computer, for example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误的有趣之处在于它不仅适用于你打错字的情况。你也可以用它来测试这台计算机上是否有某个模块或包，例如：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can then use this to have your program take advantage of the module if
    it is present, or do something else if the module or package isn''t available,
    like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用这个来让你的程序利用模块（如果存在），或者如果模块或包不可用，则执行其他操作，就像这样：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we check to see if the `numpy` library was installed, and if
    so, use `numpy.zeros()` to create a two-dimensional array. Otherwise, we use a
    list of lists instead. This allows your program to take advantage of the speed
    of the NumPy library if it was installed, while still working (albeit more slowly)
    if this library isn't available.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们检查`numpy`库是否已安装，如果是，则使用`numpy.zeros()`创建一个二维数组。否则，我们使用一个列表的列表。这样，你的程序可以利用NumPy库的速度（如果已安装），同时如果这个库不可用，仍然可以工作（尽管速度较慢）。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this example is just made up; you probably wouldn't be able to use
    a list of lists directly instead of a NumPy array and have the rest of your program
    work without any change. But the concept of doing one thing if a module is present,
    and something else if it is not, remains the same.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个例子只是虚构的；你可能无法直接使用一个列表的列表而不是NumPy数组，并且在不做任何更改的情况下使你的程序的其余部分工作。但是，如果模块存在，则执行一项操作，如果不存在，则执行另一项操作的概念是相同的。
- en: Using optional imports like this is a great way of having your module or package
    take advantage of other libraries, while still working if they aren't installed.
    Of course, you should always mention these optional imports in the documentation
    for your package so that your users will know what will happen if these optional
    modules or packages are installed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样使用可选导入是一个很好的方法，让你的模块或包利用其他库，同时如果它们没有安装也可以工作。当然，你应该在包的文档中始终提到这些可选导入，这样你的用户就会知道如果这些可选模块或包被安装会发生什么。
- en: Local imports
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地导入
- en: In [Chapter 3](ch03.html "Chapter 3. Using Modules and Packages"), *Using Modules
    and Packages*, we introduced the concept of a **global namespace**, and showed
    how the `import` statement adds the name of the imported module or package into
    the global namespace. This description was actually a slight oversimplification.
    In fact, the `import` statement adds the imported module or package to the *current*
    namespace, which may or may not be the global namespace.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。使用模块和包")中，*使用模块和包*，我们介绍了**全局命名空间**的概念，并展示了`import`语句如何将导入的模块或包的名称添加到全局命名空间。这个描述实际上是一个轻微的过度简化。事实上，`import`语句将导入的模块或包添加到*当前*命名空间，这可能是全局命名空间，也可能不是。
- en: 'In Python, there are two namespaces: the global namespace and the local namespace.
    The global namespace is where all the top-level definitions in your source file
    are stored. For example, consider the following Python module:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，有两个命名空间：全局命名空间和本地命名空间。全局命名空间是存储源文件中所有顶层定义的地方。例如，考虑以下Python模块：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you import this Python module, you will have added four entries to the
    global namespace: `random`, `string`, `set_length`, and `make_name`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入这个Python模块时，你将向全局命名空间添加四个条目：`random`、`string`、`set_length`和`make_name`。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are several other entries in the global namespace, automatically added
    by the Python interpreter. We'll ignore these for now.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Python解释器还会自动向全局命名空间添加几个其他条目。我们现在先忽略这些。
- en: If you then call the `set_length()` function, the `global` statement at the
    top of this function will add another entry to the module's global namespace,
    called `_length`. The `make_name()` function also includes a `global` statement,
    allowing it to refer to the global `_length` value while generating a random name.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你然后调用`set_length()`函数，这个函数顶部的`global`语句将向模块的全局命名空间添加另一个条目，名为`_length`。`make_name()`函数也包括一个`global`语句，允许它在生成随机名称时引用全局`_length`值。
- en: So far so good. The thing that may not be so obvious is that, within each function,
    there is a second namespace called the **local namespace**, that holds all variables
    and other definitions that aren't global. In the `make_name()` function, the `letters`
    list, as well as the variable `i` used by the `for` statement, are *local* variables—they
    only exist within the local namespace, and their values are lost when the function
    exits.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切都很好。可能不那么明显的是，在每个函数内部，还有一个称为**本地命名空间**的第二个命名空间，其中包含所有不是全局的变量和其他定义。在`make_name()`函数中，`letters`列表以及`for`语句使用的变量`i`都是*本地*变量——它们只存在于本地命名空间中，当函数退出时它们的值就会丢失。
- en: 'The local namespace isn''t just for local variables: you can use it for local
    imports, too. For example, consider the following function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本地命名空间不仅用于本地变量：你也可以用它来进行本地导入。例如，考虑以下函数：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice how the `os` and `os.path` modules are imported *within* the function,
    rather than at the top of a module or other source file. Because these modules
    are imported within the function, the `os` and `os.path` names are added to the
    local namespace rather than the global namespace.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`os`和`os.path`模块是在函数内部导入的，而不是在模块或其他源文件的顶部。因为这些模块是在函数内部导入的，所以`os`和`os.path`名称被添加到本地命名空间而不是全局命名空间。
- en: 'In most cases, you should avoid using local imports: having all your `import`
    statements near the top of the source file (and so making all your import statements
    global) makes it easier to see at a glance which modules your source file depends
    upon. There are, however, two situations where local imports can be useful:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你应该避免使用本地导入：将所有的`import`语句放在源文件的顶部（使所有的导入语句都是全局的）可以更容易地一眼看出你的源文件依赖于哪些模块。然而，有两种情况下本地导入可能会有用：
- en: If the module or package you are importing is particularly large or is slow
    to initialize itself, your module will be quicker to import if you use a local
    import rather than a global one. The delay when importing the module will only
    show up when your function is called. This can be particularly useful if the function
    is only called in certain circumstances.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你要导入的模块或包特别大或初始化速度慢，使用本地导入而不是全局导入将使你的模块更快地导入。导入模块时的延迟只会在调用函数时显示出来。如果函数只在某些情况下被调用，这将特别有用。
- en: Local imports are a great way of avoiding circular dependencies. If module A
    depends on module B and module B depends on module A, then your program will crash
    if both sets of imports are global. However, changing one set of imports to be
    a local import will break the co-dependency since the import won't take place
    until your function is called.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地导入是避免循环依赖的好方法。如果模块A依赖于模块B，模块B又依赖于模块A，那么如果两组导入都是全局的，你的程序将崩溃。然而，将一组导入更改为本地导入将打破相互依赖，因为导入直到调用函数时才会发生。
- en: As a general rule you should stick to global imports, though local imports can
    be very useful in these special situations.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，你应该坚持使用全局导入，尽管在特殊情况下，本地导入也可以非常有用。
- en: Tweaking imports using sys.path
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sys.path调整导入
- en: When you use the `import` command, the Python interpreter has to search for
    the module or package you want to import. It does this by looking through the
    **module search path**, which is a list of the various directories where modules
    or packages can be found. The module search path is stored in `sys.path`, and
    the Python interpreter will check the directories in this list one after another
    until the desired module or package is found.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`import`命令时，Python解释器必须搜索你想要导入的模块或包。它通过查找**模块搜索路径**来实现，这是一个包含各种目录的列表，模块或包可以在其中找到。模块搜索路径存储在`sys.path`中，Python解释器将依次检查此列表中的目录，直到找到所需的模块或包。
- en: 'When the Python interpreter starts, it initializes the module search path with
    the following directories:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python解释器启动时，它会使用以下目录初始化模块搜索路径：
- en: The directory containing the currently-executing script, or the current directory
    if you are running the Python interactive interpreter in a terminal window
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含当前执行脚本的目录，或者如果你在终端窗口中运行Python交互解释器，则为当前目录
- en: Any directories listed in the `PYTHONPATH` environment variable
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PYTHONPATH`环境变量中列出的任何目录'
- en: The contents of the interpreter's `site-packages` directory, including any modules
    referred to by path configuration files within the `site-packages` directory
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器的`site-packages`目录中的内容，包括`site-packages`目录中路径配置文件引用的任何模块
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `site-packages` directory is used to hold the various third-party modules
    and packages that you install. For example, if you use the Python Package Manager,
    `pip`, to install a Python module or package, that module or package would normally
    be placed within the `site-packages` directory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`site-packages`目录用于保存各种第三方模块和包。例如，如果你使用Python包管理器`pip`来安装Python模块或包，那么该模块或包通常会放在`site-packages`目录中。'
- en: A number of directories containing the various modules and packages that make
    up the Python Standard Library
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含组成Python标准库的各种模块和包的多个目录
- en: The order in which these directories appear in `sys.path` is important because
    the search stops as soon as a module or package with the desired name is found.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些目录在`sys.path`中出现的顺序很重要，因为一旦找到所需名称的模块或包，搜索就会停止。
- en: 'You can print out the contents of your module search path if you wish, though
    the list is likely to be long and rather hard to understand as there are often
    many directories containing the various parts of the Python Standard Library as
    well as other directories used by any third-party packages you may have installed:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以打印出你的模块搜索路径的内容，尽管列表可能会很长，而且很难理解，因为通常有许多包含Python标准库各个部分的目录，以及任何你可能安装的第三方包使用的其他目录：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The important thing to remember is that this list is searched *in sequence*
    until a match is found. As soon as a module or package is found with the desired
    name, the search stops.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，这个列表是按顺序搜索的，直到找到匹配项为止。一旦找到具有所需名称的模块或包，搜索就会停止。
- en: Now, `sys.path` is not just a read-only list. If you alter this list, for example
    by adding a new directory, you will change the places where the Python interpreter
    searches for modules.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`sys.path`不仅仅是一个只读列表。如果您更改此列表，例如通过添加新目录，您将更改Python解释器搜索模块的位置。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are actually a few modules that are built in to the Python interpreter;
    these are always imported directly, ignoring the module search path. To see which
    modules have been built in to your Python interpreter, you can execute the following
    commands:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有一些模块是内置到Python解释器中的；这些模块总是直接导入，忽略模块搜索路径。要查看已内置到您的Python解释器中的模块，可以执行以下命令：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you try to import one of these modules, the built-in version will always
    be used, regardless of what you do to the module search path.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试导入这些模块之一，无论您对模块搜索路径做了什么，始终会使用内置版本。
- en: 'While you can make any changes you like to `sys.path`, for instance by removing
    or rearranging the contents of this list, the most common use is to add entries
    to the list. For example, you might want to store the various modules and packages
    that you create in a special directory, which you can then access from any Python
    program that needs it. For example, imagine that you have a directory at `/usr/local/shared-python-libs`
    which contains several modules and packages you''ve written that you want to use
    within a number of different Python programs. Within that directory, imagine that
    you have a module named `utils.py` and a package named `approxnums` that you wish
    to use in your program. While a simple `import utils` would fail with an `ImportError`,
    you can make the contents of your `shared-python-libs` directory available to
    your program in the following manner:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以对`sys.path`进行任何更改，例如删除或重新排列此列表的内容，但最常见的用法是向列表添加条目。例如，您可能希望将您创建的各种模块和包存储在一个特殊的目录中，然后可以从任何需要它的Python程序中访问。例如，假设您在`/usr/local/shared-python-libs`目录中有一个包含您编写的几个模块和包的目录，您希望在多个不同的Python程序中使用。在该目录中，假设您有一个名为`utils.py`的模块和一个名为`approxnums`的包，您希望在程序中使用。虽然简单的`import
    utils`会导致`ImportError`，但您可以通过以下方式使`shared-python-libs`目录的内容可用于程序：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You might be wondering why you can''t just store your shared modules and packages
    within the `site-packages` directory. There are two reasons for this: first, because
    the `site-packages` directory is often protected and can only be written to by
    an administrator, which makes it hard to create and modify files stored in this
    directory. The second reason is that you might want to keep your own shared modules
    separate from other third-party modules that you''ve installed.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么不能只将共享模块和包存储在`site-packages`目录中。这有两个原因：首先，因为`site-packages`目录通常受保护，只有管理员才能写入，这使得在该目录中创建和修改文件变得困难。第二个原因是，您可能希望将自己的共享模块与您安装的其他第三方模块分开。
- en: 'In the previous example, we modified `sys.path` by appending our `shared-python-libs`
    directory to the end of this list. While this works, remember that the module
    search path is searched *in sequence*. If there was any other module in any directory
    on the module search path named `utils.py`, that module would be imported rather
    than the one in your `shared-python-libs` directory. For this reason, rather than
    appending, you would normally modify `sys.path` in the following way:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们通过将我们的`shared-python-libs`目录附加到此列表的末尾来修改了`sys.path`。虽然这样做有效，但要记住，模块搜索路径是按顺序搜索的。如果在模块搜索路径上的任何目录中有任何其他模块命名为`utils.py`，那么该模块将被导入，而不是您的`shared-python-libs`目录中的模块。因此，与其附加，您通常会以以下方式修改`sys.path`：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that we use `insert(1, ...)` rather than `insert(0, ...)`. This has the
    effect of adding the new directory as the *second* entry in `sys.path`. Since
    the first entry in the module search path is normally the directory containing
    the currently executing script, adding the new directory as the second entry means
    that the program's directory will be searched first. This helps to avoid confusing
    errors where you define a module within your program's directory and find that
    a different module with the same name is being imported instead. For this reason,
    it is good practice to use `insert(1, ...)` when adding a directory to `sys.path`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用的是`insert(1, ...)`而不是`insert(0, ...)`。这会将新目录添加为`sys.path`中的*第二*个条目。由于模块搜索路径中的第一个条目通常是包含当前执行脚本的目录，将新目录添加为第二个条目意味着程序的目录将首先被搜索。这有助于避免混淆的错误，其中您在程序目录中定义了一个模块，却发现导入了一个同名的不同模块。因此，当向`sys.path`添加目录时，使用`insert(1,
    ...)`是一个良好的做法。
- en: Note that, like any other technique, modifying `sys.path` can be abused. If
    your reusable module or package modifies `sys.path`, users of your code may be
    confused by subtle bugs that show up because you've changed the module search
    path. As a general rule, you should only ever change the module search path in
    a main program rather than a reusable module and always clearly document what
    you've done so that there are no surprises.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与任何其他技术一样，修改`sys.path`可能会被滥用。如果您的可重用模块或包修改了`sys.path`，您的代码用户可能会因为您更改了模块搜索路径而困惑，从而出现微妙的错误。一般规则是，您应该只在主程序中而不是在可重用模块中更改模块搜索路径，并始终清楚地记录您所做的工作，以免出现意外。
- en: Import gotchas
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入陷阱
- en: While modules and packages are extremely useful, there are times when Python's
    `import` machinery can leave you with subtle problems that can take a long time
    to figure out. In this section, we will discuss some of the more common problems
    that you are likely to encounter while working with modules and packages.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然模块和包非常有用，但在使用模块和包时可能会遇到一些微妙的问题，这些问题可能需要很长时间才能解决。在本节中，我们将讨论一些您在使用模块和包时可能遇到的更常见的问题。
- en: Using an existing name for your module or package
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用现有名称作为您的模块或包
- en: 'Imagine that you''re writing a program that makes use of the Python Standard
    Library. For example, you might make use of the `random` module to do the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在编写一个使用Python标准库的程序。例如，您可能会使用`random`模块来执行以下操作：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Your program is working correctly until you decide that it has too many mathematical
    functions in the main script, and you refactor it to move these functions into
    a separate module. You decide to call this module `math.py`, and store it in your
    main program''s directory. As soon as you do this, the previous code will crash
    with the following error:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您的程序一直正常工作，直到您决定主脚本中有太多数学函数，因此对其进行重构，将这些函数移动到一个单独的模块中。您决定将此模块命名为`math.py`，并将其存储在主程序的目录中。一旦这样做，之前的代码将会崩溃，并显示以下错误：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What on earth is going on here? Code that was working perfectly now crashes,
    even though you haven't changed it. To make matters worse, the traceback shows
    that it's crashing at the point where your program imports a module from the Python
    Standard Library!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这到底是怎么回事？原本正常运行的代码现在崩溃了，尽管您没有对其进行更改。更糟糕的是，回溯显示它在程序导入Python标准库的模块时崩溃！
- en: To understand what is going on here, you need to remember that the module search
    path by default includes the current program's directory as the first entry—ahead
    of other entries which point to the various parts of the Python Standard Library.
    By creating a new module named `math.py` as part of your program, you've made
    it impossible for the Python interpreter to load the `math.py` module from the
    Python Standard Library. This applies not just to the code you write but to *any*
    module or package on the module search path that may try to load this module from
    the Python Standard Library. In this example, it was the `random` module that
    failed, but it could have been any module that depended on the `math` library.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这里发生了什么，您需要记住，默认情况下，模块搜索路径包括当前程序目录作为第一个条目——在指向Python标准库各个部分的其他条目之前。通过在程序中创建一个名为`math.py`的新模块，您已经使得Python解释器无法从Python标准库加载`math.py`模块。这不仅适用于您编写的代码，还适用于模块搜索路径上的*任何*模块或包，它们可能尝试从Python标准库加载此模块。在这个例子中，失败的是`random`模块，但它可能是任何依赖于`math`库的模块。
- en: This is known as **name masking**, and is a particularly insidious problem.
    To avoid it, you should always be careful when choosing the names for the top-level
    modules and packages in your program to make sure they don't mask a module in
    the Python Standard Library, regardless of whether you use that module or not.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**名称屏蔽**，是一个特别阴险的问题。为了避免这种情况，您在选择程序中顶层模块和包的名称时，应该始终小心，以确保它们不会屏蔽Python标准库中的模块，无论您是否使用该模块。
- en: An easy way to avoid name masking is to make use of a package to organize the
    modules and packages you write within your program. For example, you might create
    a top-level package named `lib`, and create your various modules and packages
    within the `lib` package. Since there's no module or package named `lib` in the
    Python Standard Library, there's no risk of you masking a Standard Library module,
    no matter what name you choose for the modules and packages you place inside the
    `lib` package.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 避免名称屏蔽的一种简单方法是利用包来组织您在程序中编写的模块和包。例如，您可以创建一个名为`lib`的顶层包，并在`lib`包内创建各种模块和包。由于Python标准库中没有名为`lib`的模块或包，因此无论您为`lib`包内的模块和包选择什么名称，都不会有屏蔽标准库模块的风险。
- en: Naming a Python script after a module or package
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Python脚本命名为模块或包
- en: 'A more subtle example of name masking can occur when you have a Python script
    that has the same name as a module in the Python Standard Library. For example,
    imagine that you''re trying to figure out how the `re` module ([https://docs.python.org/3.3/library/re.html](https://docs.python.org/3.3/library/re.html))
    works. This module can be a bit confusing if you haven''t worked with regular
    expressions before, so you might decide to write a simple test script to discover
    how it works. This test script might include the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 名称屏蔽的一个更微妙的例子可能发生在您有一个Python脚本，其名称与Python标准库中的一个模块相同。例如，假设您想弄清楚`re`模块（[https://docs.python.org/3.3/library/re.html](https://docs.python.org/3.3/library/re.html)）的工作原理。如果您之前没有使用过正则表达式，这个模块可能会有点令人困惑，因此您可能决定编写一个简单的测试脚本来了解它的工作原理。这个测试脚本可能包括以下代码：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This program might help you to figure out what the `re` module does, but if
    you save this script under the name `re.py`, you''ll get a mysterious error when
    you run your program:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序可能会帮助您弄清楚`re`模块的作用，但如果您将此脚本保存为`re.py`，当运行程序时会出现一个神秘的错误：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Can you figure out what's going on here? The answer lies, once again, in the
    module search path. The name of your script, `re.py`, is masking the `re` module
    in the Python Standard Library, so when your program attempts to import the `re`
    module, it actually loads itself instead. You're seeing an `AttributeError` here
    because the script successfully loaded itself as a module but that module doesn't
    have the `search()` function you were expecting.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到这里发生了什么吗？答案再次在于模块搜索路径。您的脚本名称`re.py`屏蔽了Python标准库中的`re`模块，因此当您的程序尝试导入`re`模块时，实际上加载的是脚本本身。您在这里看到`AttributeError`，是因为脚本成功地将自身作为模块加载，但该模块并没有您期望的`search()`函数。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Having a script import itself as a module can also cause unexpected problems;
    we'll look at this shortly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让脚本导入自身作为模块也可能导致意外问题；我们马上就会看到这一点。
- en: 'The solution to this problem is simple: never use the name of a Python Standard
    Library module for a script. Instead, call your test script something like `re_test.py`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方法很简单：永远不要使用Python标准库模块的名称作为脚本的名称。而是将你的测试脚本命名为类似`re_test.py`的东西。
- en: Adding package directories to sys.path
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将包目录添加到sys.path
- en: A common trap to fall into is adding a package directory to `sys.path`. Let's
    take a look at what happens when you do this.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的陷阱是将包目录添加到`sys.path`。让我们看看当你这样做时会发生什么。
- en: 'Create a directory to hold a test program, and create a sub-directory named
    `package` within this main directory. Then, create an empty package initialization
    (`__init__.py`) file within the `package` directory. Also, create a module, named
    `module.py`, within the same directory. Then, add the following to the `module.py`
    file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个目录来保存一个测试程序，并在这个主目录中创建一个名为`package`的子目录。然后，在`package`目录中创建一个空的包初始化（`__init__.py`）文件。同时，在同一个目录中创建一个名为`module.py`的模块。然后，将以下内容添加到`module.py`文件中：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This prints out a message when the module is imported. Next, create a Python
    source file named `good_imports.py` in your top-most directory, and enter the
    following Python code into this file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当导入模块时，这会打印出一条消息。接下来，在你的最顶层目录中创建一个名为`good_imports.py`的Python源文件，并输入以下Python代码到这个文件中：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After saving this file, open a terminal or command-line window and use the
    `cd` command to set the current directory to your outermost directory (the one
    containing your `good_imports.py` script), and type `python good_imports.py` to
    run this program. You should see the following output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这个文件后，打开一个终端或命令行窗口，并使用`cd`命令将当前目录设置为你最外层的目录（包含你的`good_imports.py`脚本的目录），然后输入`python
    good_imports.py`来运行这个程序。你应该会看到以下输出：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, the first `import` statement loaded the module, which caused
    the `### Initializing module.py ###` message to be printed out. For the subsequent
    `import` statements, no initialization took place—instead, the already-imported
    copy of the module was used. This is the behavior we want as it ensures that we
    only ever have one copy of each module. This is important for those modules that
    keep information in global variables as having different copies of a module with
    different values in their global variables can lead to all sorts of strange and
    confusing behavior.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '正如你所看到的，第一个`import`语句加载了模块，导致打印出`### Initializing module.py ###`的消息。对于后续的`import`语句，不会发生初始化——相反，已经导入的模块副本会被使用。这是我们想要的行为，因为它确保我们只有一个模块的副本。这对于那些在全局变量中保存信息的模块非常重要，因为拥有不同副本的模块，其全局变量中的值不同，可能会导致各种奇怪和令人困惑的行为。'
- en: 'Unfortunately, that''s exactly what we can end up with if we add a package,
    or a sub-directory of a package, to `sys.path`. To see this problem in action,
    create a new top-level script named `bad_imports.py`, and enter the following
    into this file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果我们将一个包或包的子目录添加到`sys.path`中，我们可能会得到这样的结果。要看到这个问题的实际情况，创建一个名为`bad_imports.py`的新顶级脚本，并输入以下内容到这个文件中：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This program sets `package_dir` to the full directory path to the `package`
    directory and then adds this directory to `sys.path`. It then makes two separate
    `import` statements, one to import `module` from the package named `package` and
    the other to import `module` directly. Both `import` statements will work as the
    module can be accessed in both ways. However, the results are not what you might
    expect:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将`package_dir`设置为`package`目录的完整目录路径，然后将这个目录添加到`sys.path`中。然后，它进行了两个单独的`import`语句，一个是从名为`package`的包中导入`module`，另一个是直接导入`module`。这两个`import`语句都可以工作，因为模块可以以这两种方式访问。然而，结果并不是你可能期望的：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, the module is imported *twice*, once as `package.module` and
    again as `module`. You end up with two separate copies of the module, both of
    which are initialized and appear as two distinct modules to the Python system.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，模块被导入了*两次*，一次是作为`package.module`，另一次是作为`module`。你最终会得到两个独立的模块副本，它们都被初始化，并作为两个不同的模块出现在Python系统中。
- en: Having two copies of a module can lead to all sorts of subtle bugs and problems.
    This is why you should never add a Python package, or a sub-directory of a Python
    package, directly to `sys.path`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有两个模块副本可能会导致各种微妙的错误和问题。这就是为什么你永远不应该直接将Python包或Python包的子目录添加到`sys.path`中。
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Of course, it's fine to add a directory *containing* a package to `sys.path`;
    just don't add the package directory itself.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，将包含包的目录添加到`sys.path`是可以的；只是不要添加包目录本身。
- en: Executing and importing the same module
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行和导入相同的模块
- en: 'Another more subtle example of the double-import problem can occur if you execute
    a Python source file and then import that same file as if it were a module. To
    see how this works, create a directory to hold a new example program, and create
    a new Python source file in this directory named `test.py`. Then, enter the following
    into this file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个更微妙的双重导入问题的例子是，如果您执行一个Python源文件，然后导入同一个文件，就好像它是一个模块一样。要了解这是如何工作的，请创建一个目录来保存一个新的示例程序，并在该目录中创建一个名为`test.py`的新的Python源文件。然后，输入以下内容到这个文件中：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When this file is run as a script, it calls the `helpers.run_test()` function
    to start running a test. This file also defines a function, `do_something()`,
    that performs some useful functionality. Now, create a second Python source file
    in the same directory named `helpers.py`, and enter the following into this file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个文件作为脚本运行时，它调用`helpers.run_test()`函数来开始运行一个测试。这个文件还定义了一个函数`do_something()`，执行一些有用的功能。现在，在同一个目录中创建第二个名为`helpers.py`的Python源文件，并输入以下内容到这个文件中：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, the `helpers.py` module is importing `test.py` as a module and
    then calling the `do_something()` function as part of running the test. In other
    words, even though `test.py` is executed as a script, it is also being imported
    (indirectly) as a module as part of the execution of that script.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`helpers.py`模块正在将`test.py`作为模块导入，然后调用`do_something()`函数作为运行测试的一部分。换句话说，即使`test.py`作为脚本执行，它也会作为模块被导入（间接地）作为该脚本的执行的一部分。
- en: 'Let''s see what happens when you run this program:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当你运行这个程序时会发生什么：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So far so good. The program is running and, despite the convoluted module imports,
    it seems to be working. But let''s take a closer look; add the following statement
    to the top of your `test.py` script:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。程序正在运行，尽管模块导入复杂，但似乎工作正常。但让我们更仔细地看一下；在你的`test.py`脚本顶部添加以下语句：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As in our previous example, we are using a `print()` statement to show when
    the module is being loaded. This gives the module the opportunity to initialize
    itself, and we would expect to only see the initialization happen once as there
    should only ever be one copy of each module in memory.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前的例子一样，我们使用`print()`语句来显示模块何时被加载。这给了模块初始化的机会，我们期望只看到初始化发生一次，因为内存中应该只有每个模块的一个副本。
- en: 'In this case, however, that''s not what happens. Try running the program again:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，情况并非如此。尝试再次运行程序：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, the module is being initialized *twice*—once when it's run as
    a script and again when the module is imported by `helpers.py`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，模块被初始化了*两次*——一次是当它作为脚本运行时，另一次是当`helpers.py`导入该模块时。
- en: To avoid this problem, make sure that any scripts you write are only used as
    scripts. Keep any other code (such as the `do_something()` function from our previous
    example) out of your scripts so that you'll never need to import them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，请确保你编写的任何脚本只用作脚本。将任何其他代码（例如我们之前示例中的`do_something()`函数）从你的脚本中移除，这样你就永远不需要导入它们。
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that this doesn't mean that you can't have chameleon modules that act as
    both a module and as a script, as described in [Chapter 3](ch03.html "Chapter 3. Using
    Modules and Packages"), *Using Modules and Packages*. Just be careful that the
    script you execute only uses functions defined within the module itself. If you
    start importing other modules from the same package, you should probably move
    all the functionality into a different module, which you then import into your
    script, rather than having them both together in the same file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这并不意味着你不能有变色龙模块，既可以作为模块又可以作为脚本，正如[第3章](ch03.html "第3章。使用模块和包")中所描述的那样，*使用模块和包*。只是要小心，你执行的脚本只使用模块本身定义的函数。如果你开始从同一个包中导入其他模块，你可能应该将所有功能移动到一个不同的模块中，然后将其导入到你的脚本中，而不是让它们都在同一个文件中。
- en: Using modules and packages with the Python interactive interpreter
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python交互解释器的模块和包
- en: 'As well as calling modules and packages from a Python script, it is often useful
    to call them directly from the Python interactive interpreter. This is a great
    way of employing the **rapid application development** (**RAD**) technique for
    Python programming: you make a change of some sort to a Python module or package
    and immediately see the results of your change by calling that module or package
    from the Python interactive interpreter.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从Python脚本中调用模块和包，直接从Python交互解释器中调用它们通常也很有用。这是使用Python编程的**快速应用开发**（**RAD**）技术的一个很好的方法：你对Python模块或包进行某种更改，然后立即通过从Python交互解释器调用该模块或包来看到你的更改的结果。
- en: There are, however, a few limitations and issues to be aware of. Let's take
    a closer look at how you can use the interactive interpreter to speed up your
    development of modules and packages; we'll also see where a different approach
    might suit you better.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一些限制和问题需要注意。让我们更仔细地看看你如何使用交互解释器来加快模块和包的开发；我们也会看到不同的方法可能更适合你。
- en: 'Start by creating a new Python module named `stringutils.py`, and enter the
    following code into this file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个名为`stringutils.py`的新Python模块，并将以下代码输入到这个文件中：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This module represents our first attempt at writing a function to extract all
    the numbers from a string. Note that it is not working yet—the `extract_numbers()`
    function will crash if you try to use it. It's also not particularly efficient
    (a much easier approach would be to use the `re.findall()` function). But we're
    using this code deliberately to show how you can apply rapid application development
    techniques to your Python modules, so bear with us.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块代表我们第一次尝试编写一个从字符串中提取所有数字的函数。请注意，它还没有工作——如果你尝试使用它，`extract_numbers()`函数将崩溃。它也不是特别高效（一个更简单的方法是使用`re.findall()`函数）。但我们故意使用这段代码来展示你如何将快速应用开发技术应用到你的Python模块中，所以请耐心等待。
- en: This function uses the `re` (regular expression) module to find the parts of
    the string that match the given expression pattern. The complicated `pattern`
    string is used to match a number, including an optional `+` or `-` at the front,
    any number of digits, and an optional fractional part at the end.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用`re`（正则表达式）模块来找到与给定表达式模式匹配的字符串部分。复杂的`pattern`字符串用于匹配数字，包括可选的`+`或`-`在前面，任意数量的数字，以及可选的小数部分在末尾。
- en: Using the `re.finditer()` function, we find the parts of the string that match
    our regular expression pattern. We then extract each matching part of the string
    and append the results to the `numbers` list, which we then return back to the
    caller.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`re.finditer()`函数，我们找到与我们的正则表达式模式匹配的字符串部分。然后提取字符串的每个匹配部分，并将结果附加到`numbers`列表中，然后将其返回给调用者。
- en: So much for what our function is supposed to do. Let's test it out.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的函数应该做的事情。让我们来测试一下。
- en: 'Open a terminal or command-line window, and use the `cd` command to switch
    to the directory holding the `stringutils.py` module. Then, type `python` to start
    up the Python interactive interpreter. When the Python command prompt appears,
    try entering the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端或命令行窗口，并使用`cd`命令切换到包含`stringutils.py`模块的目录。然后，输入`python`启动Python交互解释器。当Python命令提示符出现时，尝试输入以下内容：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, our module doesn''t work yet—we have a bug in it. Looking closer,
    we can see that the problem is on line 7 of our `stringutils.py` module:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的模块还没有工作——我们在其中有一个bug。更仔细地看，我们可以看到问题在我们的`stringutils.py`模块的第7行：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The error message suggests that you are trying to add a built-in function (in
    this case, `match.end`) to a number (`1`), which of course doesn''t work. The
    `match.start` and `match.end` values were supposed to be the indices into the
    string for the start and end of the number, but a quick look at the documentation
    for the `re` module shows that `match.start` and `match.end` are functions, not
    simple numbers, and so we need to call these functions to get the values we want.
    Doing this is easy; simply edit line 7 of your file to look like the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息表明您正在尝试将内置函数（在本例中为`match.end`）添加到一个数字（`1`），这当然是行不通的。`match.start`和`match.end`值应该是字符串的开始和结束的索引，但是快速查看`re`模块的文档显示`match.start`和`match.end`是函数，而不是简单的数字，因此我们需要调用这些函数来获取我们想要的值。这样做很容易；只需编辑您的文件的第7行，使其看起来像下面这样：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that we''ve changed our module, let''s take a look at what happens. We''ll
    start by re-executing the `print()` statement to see if that works:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更改了我们的模块，让我们看看会发生什么。我们将从重新执行`print()`语句开始，看看是否有效：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Did you know that you can press the up arrow and down arrow keys on your keyboard
    to move through the history of commands that you've typed previously into the
    Python interactive interpreter? This saves you from having to retype a command;
    simply use the arrow keys to select the command you want, and press *Return* to
    execute it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道您可以按键盘上的上箭头和下箭头键来浏览您之前在Python交互解释器中键入的命令历史记录吗？这样可以避免您不得不重新键入命令；只需使用箭头键选择您想要的命令，然后按*Return*执行它。
- en: You'll immediately see the same error message you saw previously—nothing has
    changed. This is because you imported the module into the Python interpreter;
    once a module or package has been imported, it is held in memory and the source
    file(s) on disk are ignored.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您将立即看到与之前看到的相同的错误消息-没有任何变化。这是因为您将模块导入Python解释器；一旦导入了模块或包，它就会保存在内存中，磁盘上的源文件将被忽略。
- en: 'To have your changes take effect, you need to **reload** the module. To do
    this, type the following into your Python interpreter:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使您的更改生效，您需要**重新加载**模块。要做到这一点，请在Python解释器中键入以下内容：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Tip
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are using Python 2.x, you can't use the `importlib` module. Instead,
    simply type `reload(stringutils)`. If you are using Python version 3.3, use `imp`
    rather than `importlib`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Python 2.x，则无法使用`importlib`模块。相反，只需键入`reload(stringutils)`。如果您使用的是Python
    3.3版本，则使用`imp`而不是`importlib`。
- en: 'Now try re-executing that `print()` statement:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试重新执行`print()`语句：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'That''s much better—our program now runs without crashing. There is, however,
    one more problem we need to fix: when we extract the characters that make up a
    number, we''re extracting one character too many, so the number `1` is being returned
    as `1o` and so on. To fix this, remove the `+1` from line 7 of your source file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这好多了-我们的程序现在可以正常运行了。然而，我们还需要解决一个问题：当我们提取组成数字的字符时，我们提取了一个多余的字符，所以数字`1`被返回为`1o`等等。要解决这个问题，请从源文件的第7行中删除`+1`：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, reload the module again and re-execute your `print()` statement. You
    should see the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次重新加载模块并重新执行您的`print()`语句。您应该会看到以下内容：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Perfect! If you wanted to, you could use the `float()` function to convert these
    strings into floating-point numbers, but for our purposes this module is now finished.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！如果您愿意，您可以使用`float()`函数将这些字符串转换为浮点数，但对于我们的目的，这个模块现在已经完成了。
- en: Let's take a step back and review what we've done. We had a module with mistakes
    in it, and used the Python interactive interpreter to help identify and fix these
    problems. We repeatedly tested our program, noticed a mistake, and fixed it, using
    a RAD approach to quickly find and correct the bugs in our module.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，回顾一下我们所做的事情。我们有一个有错误的模块，并使用Python交互解释器来帮助识别和修复这些问题。我们反复测试我们的程序，注意到一个错误，并修复它，使用RAD方法快速找到和纠正我们模块中的错误。
- en: When developing your modules and packages, it's often helpful to test them in
    the interactive interpreter to find and fix problems as you go along. You just
    have to remember that every time you make a change to a Python source file, you'll
    need to call `importlib.reload()` to reload the affected module or package.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发模块和包时，通常有助于在交互解释器中进行测试，以便在进行过程中找到并解决问题。您只需记住，每次对Python源文件进行更改时，您都需要调用`importlib.reload()`来重新加载受影响的模块或包。
- en: Using the Python interactive interpreter in this way also means that you have
    the complete Python system available for your testing. For example, you could
    use the `pprint` module in the Python Standard Library to pretty-print a complex
    dictionary or list so that you can easily view the information being returned
    by one of your functions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用Python交互解释器也意味着您可以使用完整的Python系统进行测试。例如，您可以使用Python标准库中的`pprint`模块来漂亮地打印复杂的字典或列表，以便您可以轻松地查看一个函数返回的信息。
- en: 'There are some limitations, however, in the `importlib.reload()` process:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`importlib.reload()`过程中存在一些限制：
- en: Imagine that you have two modules, A and B. Module A uses the `from B import...`
    statement to load functionality from module B. If you then change module B, the
    changed functionality won't be used by module A unless you reload that module
    too.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想象一下，您有两个模块A和B。模块A使用`from B import...`语句从模块B加载功能。如果您更改了模块B，那么模块A将不会使用更改后的功能，除非您也重新加载该模块。
- en: 'If your module crashes while initializing itself, it can end up in a strange
    state. For example, imagine that your module includes the following top-level
    code, which is supposed to initialize a list of customers:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的模块在初始化时崩溃，它可能会处于奇怪的状态。例如，想象一下，您的模块包括以下顶层代码，它应该初始化一个客户列表：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This module will be imported, but because of the misspelled variable name it
    will raise an exception during initialization. If this happens, you will need
    to firstly use the `import` command in the Python interactive interpreter to make
    the module available, and then use `imp.reload()` to load the updated source code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块将被导入，但由于变量名拼写错误，它将在初始化期间引发异常。如果发生这种情况，您首先需要在Python交互解释器中使用`import`命令使模块可用，然后使用`imp.reload()`来加载更新后的源代码。
- en: Because you have to either type the commands yourself or select a command from
    the Python command history, it can get tedious to run the same code over and over,
    especially if your test involves more than a couple of steps. It's also very easy
    to miss a step when using the interactive interpreter.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为您必须手动输入命令或从Python命令历史记录中选择命令，所以反复运行相同的代码可能会变得乏味，特别是如果您的测试涉及多个步骤。在使用交互式解释器时，很容易错过某个步骤。
- en: For these reasons, it is best to use the interactive interpreter to fix specific
    problems or to help you rapidly develop a particular small piece of code. Custom
    written scripts work better when the tests get complicated or if you have to work
    with multiple modules.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好使用交互式解释器来修复特定问题或帮助您快速开发特定的小代码片段。当测试变得复杂或者需要与多个模块一起工作时，自定义编写的脚本效果更好。
- en: Dealing with global variables
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理全局变量
- en: We have already seen how to use global variables to share information between
    different functions within a module. We've seen how to define globals as top-level
    variables within a module, causing them to be initialized the first time the module
    is imported, and we have also seen how to use the `global` statement within a
    function to allow that function to access and change the value of a global variable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用全局变量在模块内的不同函数之间共享信息。我们已经看到如何在模块内将全局变量定义为顶级变量，导致它们在导入模块时首次初始化，并且我们还看到如何在函数内使用`global`语句允许该函数访问和更改全局变量的值。
- en: In this section, we will build on this knowledge to learn how to share global
    variables *between* modules. When creating a package, you often need to define
    variables that can be accessed or changed by any module within that package. Sometimes,
    you also need to make a variable available to Python code outside your package.
    Let's take a look at how this can be done.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将进一步学习如何在*模块之间*共享全局变量。在创建包时，通常需要定义可以被该包内任何模块访问或更改的变量。有时，还需要将变量提供给包外的Python代码。让我们看看如何实现这一点。
- en: 'Create a new directory named `globtest`, and create an empty package initialization
    file inside this directory to make it a Python package. Then, create a file inside
    this directory named `globals.py`, and enter the following into this file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`globtest`的新目录，并在此目录中创建一个空的包初始化文件，使其成为Python包。然后，在此目录中创建一个名为`globals.py`的文件，并输入以下内容到此文件中：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this module, we have defined two global variables that we want to use in
    our package, and given each variable a default value of `None`. Let's now use
    these globals in another module.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模块中，我们已经定义了两个全局变量，我们希望在我们的包中使用，并为每个变量设置了默认值`None`。现在让我们在另一个模块中使用这些全局变量。
- en: 'Create another file in the `globtest` directory named `test.py`, and enter
    the following into this file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`globtest`目录中创建另一个名为`test.py`的文件，并输入以下内容到此文件中：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To test your program, open a terminal or command-line window, use the `cd`
    command to move to the directory that contains your `globtest` package, and type
    `python` to start up the Python interactive interpreter. Then, try entering the
    following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试您的程序，请打开终端或命令行窗口，使用`cd`命令移动到包含您的`globtest`包的目录，并输入`python`启动Python交互解释器。然后，尝试输入以下内容：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, we have successfully set the value of the `language` and `currency`
    globals, which are stored in our `globals` module, and then retrieved these values
    again to print them out. Because we are storing these globals in a separate module,
    you can retrieve or change these globals anywhere within the current package or
    even in other code that imports your package. Using a separate module to hold
    your package's global variables is an excellent way of managing globals within
    a package.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已成功设置了存储在我们的`globals`模块中的`language`和`currency`全局变量的值，然后再次检索这些值以打印它们。因为我们将这些全局变量存储在一个单独的模块中，所以您可以在当前包内的任何地方或者甚至在导入您的包的其他代码中检索或更改这些全局变量。使用单独的模块来保存包的全局变量是管理包内全局变量的一种绝佳方式。
- en: 'There is, however, one thing to be aware of: for a global variable to be shared
    between modules, you must import the *module* that contains that global variable,
    not the variable itself. For example, the following won''t work:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意一点：要使全局变量在模块之间共享，必须导入包含该全局变量的*模块*，而不是变量本身。例如，以下内容不起作用：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: What this statement does is import a copy of the `language` variable into your
    current module's global namespace, not the original global. This means that the
    global variable won't be shared with other modules. For a variable to be shared
    between modules, you need to import the `globals` module, not the variables within
    it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明的作用是将`language`变量的副本导入到当前模块的全局命名空间中，而不是原始全局命名空间。这意味着全局变量不会与其他模块共享。要使变量在模块之间共享，需要导入`globals`模块，而不是其中的变量。
- en: Package configuration
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包配置
- en: As you develop more sophisticated modules and packages, you will often find
    that your code needs to be *configured* in some way before it can be used. For
    example, imagine that you're writing a package that uses a database. To do this,
    your package needs to know which database engine to use, the name of the database,
    and the username and password to use to access that database.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您开发更复杂的模块和包，通常会发现您的代码在使用之前需要以某种方式*配置*。例如，想象一下，您正在编写一个使用数据库的包。为了做到这一点，您的包需要知道要使用的数据库引擎，数据库的名称，以及用于访问该数据库的用户名和密码。
- en: 'You could hardwire this information into your program''s source code, but doing
    this is a very bad idea, for two reasons:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些信息硬编码到程序的源代码中，但这样做是一个非常糟糕的主意，有两个原因：
- en: Different computers and different operating systems will use different database
    setups. Since the information used to access the database will vary from one computer
    to another, anyone wanting to use your package would have to edit the source code
    directly to enter the correct database details before the package can be run.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的计算机和不同的操作系统将使用不同的数据库设置。由于用于访问数据库的信息会因计算机而异，任何想要使用你的包的人都必须直接编辑源代码以输入正确的数据库详细信息，然后才能运行包。
- en: The username and password used to access a database is highly sensitive information.
    If you share your package with other people, or even just store a copy of your
    package's source code on a public repository such as GitHub, then other people
    can discover your database access credentials. This is a huge security risk.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于访问数据库的用户名和密码是非常敏感的信息。如果你与其他人分享你的包，甚至只是将你的包源代码存储在GitHub等公共仓库上，那么其他人就可以发现你的数据库访问凭据。这是一个巨大的安全风险。
- en: These database access credentials are an example of *package configuration*—information
    that your package needs before it can run but which you don't want to build into
    your package's source code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据库访问凭据是*包配置*的一个例子——在你的包运行之前需要的信息，但你不希望将其构建到包的源代码中。
- en: If you are building an application rather than a standalone module or package,
    your configuration task is much simpler. There are modules in the Python Standard
    Library that can help with configuration, for example, `configparser`, `shlex`,
    and `json`. Using these modules, you can store configuration settings in a file
    on disk, which the end user can edit. When your program starts, you load those
    settings into memory and access them as needed. Because the configuration settings
    are stored externally to your application, users won't have to edit your source
    code to configure the program, and you won't be exposing sensitive information
    if your source code is published or shared.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建一个应用程序而不是一个独立的模块或包，那么你的配置任务就简单得多了。Python标准库中有一些模块可以帮助配置，例如`configparser`、`shlex`和`json`。使用这些模块，你可以将配置设置存储在磁盘上的文件中，用户可以编辑。当你的程序启动时，你将这些设置加载到内存中，并根据需要访问它们。因为配置设置是存储在应用程序外部的，用户不需要编辑你的源代码来配置程序，如果你的源代码被发布或共享，你也不会暴露敏感信息。
- en: When writing modules and packages, however, the file-based approach to configuration
    is much less convenient. There's no obvious place to store a package's configuration
    file, and requiring configuration files at a particular location is going to make
    your module or package harder to reuse as part of a different program.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当编写模块和包时，基于文件的配置方法就不那么方便了。没有明显的地方来存储包的配置文件，要求配置文件位于特定位置会使你的模块或包更难以作为不同程序的一部分进行重用。
- en: 'Instead, configuration for a module or package is usually done by supplying
    parameters to your module or package''s initialization function. We saw an example
    of this in the previous chapter, where the `quantities` package required you to
    supply a `locale` value when initializing the package:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，模块或包的配置通常是通过向模块或包的初始化函数提供参数来完成的。我们在上一章中看到了一个例子，在那里`quantities`包在初始化时需要你提供一个`locale`值：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This passes the job of configuration back to the surrounding application; the
    application can make use of a configuration file, or any other configuration scheme
    it likes, and it is the application that supplies the package''s configuration
    settings when the package is initialized:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将配置的工作交给了周围的应用程序；应用程序可以利用配置文件或任何其他喜欢的配置方案，并且是应用程序在包初始化时提供包的配置设置：
- en: '![Package configuration](graphics/B05102_7_01.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![包配置](graphics/B05102_7_01.jpg)'
- en: This makes things easier for the package developer as all the package needs
    to do is remember the settings it has been given.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这对包开发者来说更加方便，因为包所需要做的就是记住它所得到的设置。
- en: 'While the `quantities` package only used a single configuration setting (the
    name of the locale), it is common for packages to use many settings. A very convenient
    way of supplying the configuration settings for a package is to use a Python dictionary.
    For example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`quantities`包只使用了一个配置设置（区域的名称），但是包通常会使用许多设置。为包提供配置设置的一个非常方便的方式是使用Python字典。例如：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Using a dictionary in this way makes it easy to support *default values* for
    your package''s configuration settings. The following Python snippet shows how
    a package''s `init()` function can accept configuration settings, supply default
    values, and store the settings in a global variable so that it can be accessed
    when needed:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典这种方式可以很容易地支持包的配置设置的*默认值*。以下Python代码片段展示了一个包的`init()`函数如何接受配置设置，提供默认值，并将设置存储在全局变量中，以便在需要时可以访问：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using `dict.get()` in this way, you retrieve the setting if one has been supplied,
    while providing a default value to use if the setting isn't specified. This is
    an ideal way of handling configuration within a Python module or package, making
    it simple for users of your module or package to configure it as required, while
    still leaving the details of how and where the configuration settings are stored
    up to the application.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dict.get()`这种方式，如果已经提供了设置，你就可以检索到该设置，同时提供一个默认值以供在未指定设置时使用。这是处理Python模块或包中配置的理想方式，使得模块或包的用户可以根据需要配置它，同时仍然将配置设置的存储方式和位置的细节留给应用程序。
- en: Package data
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包数据
- en: A package might contain more than just Python source files. Sometimes, you might
    need to include other types of files as well. For example, a package may include
    one or more image files, a large text file containing a list of all the ZIP codes
    in the USA, or any other type of data you may need. If you can store something
    in a file, you can include this file as part of your Python package.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包可能包含的不仅仅是Python源文件。有时，您可能还需要包含其他类型的文件。例如，一个软件包可能包括一个或多个图像文件，一个包含美国所有邮政编码列表的大型文本文件，或者您可能需要的任何其他类型的数据。如果您可以将某些东西存储在文件中，那么您可以将此文件包含为Python软件包的一部分。
- en: 'Normally, you would place your package data in a separate sub-directory within
    the package directory. To access these files, your package needs to know where
    to find this sub-directory. While you could hardwire the location of this directory
    into your package, this won''t work if your package is to be reused or moved.
    It''s also not necessary as you can easily find the directory in which a module
    resides by using the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会将软件包数据放在软件包目录中的一个单独的子目录中。要访问这些文件，您的软件包需要知道在哪里找到这个子目录。虽然您可以将该目录的位置硬编码到您的软件包中，但如果您的软件包要被重用或移动，这种方法将行不通。这也是不必要的，因为您可以使用以下代码轻松找到模块所在的目录：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This gives you the complete path to the directory containing the current module.
    Using the `os.path.join()` function, you can then get access to the sub-directory
    that holds your data files and open them in the usual way:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您提供包含当前模块的完整路径。使用`os.path.join()`函数，然后可以访问包含数据文件的子目录，并以通常的方式打开它们：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The great thing about including data files inside your package is that the data
    files are effectively part of your package's source code. When you share your
    package or upload it to a source code repository such as GitHub, the data files
    are automatically included along with the rest of your package. This makes it
    much easier to keep track of the data files used by your package.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据文件包含在软件包中的好处是，数据文件实际上是软件包源代码的一部分。当您分享软件包或将其上传到GitHub等源代码存储库时，数据文件将自动包含在软件包的其余部分中。这使得更容易跟踪软件包使用的数据文件。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at a number of the more advanced aspects of working
    with modules and packages in Python. We saw how a `try..except` statement can
    be used to implement optional imports, and how an `import` statement can be placed
    inside a function so that the module only gets imported when that function is
    executed. We then learned about the module search path and how you can modify
    `sys.path` to change the way the Python interpreter looks for modules and packages.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一些与在Python中使用模块和软件包相关的更高级方面。我们看到`try..except`语句如何用于实现可选导入，以及如何将`import`语句放在函数内，以便在执行该函数时仅导入模块。然后我们了解了模块搜索路径以及如何修改`sys.path`以改变Python解释器查找模块和软件包的方式。
- en: We then looked at some of the gotchas related to the use of modules and packages.
    We learned about name masking, where you define a module or package with the same
    name as a module or package in the Python Standard Library, which can lead to
    unexpected failures. We looked at how giving a Python script the same name as
    a Standard Library module can also cause name masking problems, and how adding
    a package directory or sub-directory to `sys.path` can cause a module to be loaded
    twice, leading to subtle problems with global variables within that module. We
    saw how executing a module and then importing it also leads to that module being
    loaded twice, which can again lead to problems.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看了一些与使用模块和软件包相关的陷阱。我们了解了名称屏蔽，其中您定义了与Python标准库中的模块或软件包相同名称的模块或软件包，这可能导致意外的失败。我们看了一下，给Python脚本与标准库模块相同的名称也可能导致名称屏蔽问题，以及如何将软件包目录或子目录添加到`sys.path`可能导致模块被加载两次，从而导致该模块中的全局变量出现微妙的问题。我们看到执行一个模块然后导入它也会导致该模块被加载两次，这可能再次导致问题。
- en: We next looked at how you can use the Python interactive interpreter as a type
    of rapid application development (RAD) tool to quickly find and fix problems within
    your modules and packages, and how the `importib.reload()` command allows you
    to reload a module after you have changed the underlying source code
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何使用Python交互式解释器作为一种快速应用程序开发（RAD）工具，快速查找和修复模块和软件包中的问题，以及`importlib.reload()`命令允许您在更改底层源代码后重新加载模块
- en: We finished our survey of advanced module techniques by learning how to define
    global variables that are used throughout a package, how to handle package configuration,
    and how to store and access data files within a package.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过学习如何定义在整个软件包中使用的全局变量，如何处理软件包配置以及如何在软件包中存储和访问数据文件来完成了对高级模块技术的调查。
- en: In the next chapter, we will look at some of the ways in which you can test,
    deploy, and share your Python modules and packages.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一些您可以测试、部署和分享Python模块和软件包的方式。
