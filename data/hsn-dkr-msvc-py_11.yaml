- en: Using GitOps Principles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GitOps原则
- en: After seeing how to configure a Kubernetes cluster, we will learn how to do
    it using GitOps practices instead of applying manual commands and files. GitOps
    means managing the cluster configuration using a Git repo to store and track the
    YAML files that contain the configuration. We will see how to link a GitHub repo
    with a cluster, so that it gets updated regularly, using Flux.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解如何配置Kubernetes集群之后，我们将学习如何使用GitOps实践来进行配置，而不是应用手动命令和文件。GitOps意味着使用Git存储库来管理集群配置，以存储和跟踪包含配置的YAML文件。我们将看到如何将GitHub存储库与集群链接，以便使用Flux定期更新。
- en: This method allows us to store the configuration in a deterministic way, describing
    the changes to infrastructure in code. The changes can be reviewed and the cluster
    can be recovered from scratch or duplicated, as we will see in [Chapter 9](6cd790eb-a881-418b-ba9f-b506ff82f924.xhtml),
    *Managing Workflows*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许我们以确定性的方式存储配置，以代码描述基础设施的更改。更改可以进行审查，并且集群可以从头开始恢复或复制，正如我们将在[第9章](6cd790eb-a881-418b-ba9f-b506ff82f924.xhtml)
    *管理工作流*中看到的那样。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the description of GitOps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解GitOps的描述
- en: Setting up Flux to control the Kubernetes cluster
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Flux以控制Kubernetes集群
- en: Configuring GitHub
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置GitHub
- en: Making a Kubernetes cluster change through GitHub
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过GitHub进行Kubernetes集群更改
- en: Working in production
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生产环境中工作
- en: By the end of the chapter, you will know how to store the Kubernetes configuration
    in a Git repository and apply automatically any changes that are merged into the
    main branch.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解如何将Kubernetes配置存储在Git存储库中，并自动应用合并到主分支的任何更改。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for the examples in the chapter is available on GitHub: [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter08).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章示例的代码可在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter08)。
- en: You will need to install the `fluxctl` tool. We will then use this tool to sync
    manually and to obtain an SSH key to allow Flux to interact with the Git repo.
    See how to install it in its documentation: [https://docs.fluxcd.io/en/stable/tutorials/get-started.html](https://docs.fluxcd.io/en/stable/tutorials/get-started.html).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装`fluxctl`工具。然后，我们将使用此工具手动同步并获取SSH密钥，以允许Flux与Git存储库进行交互。请参阅其文档中的安装方法：[https://docs.fluxcd.io/en/stable/tutorials/get-started.html](https://docs.fluxcd.io/en/stable/tutorials/get-started.html)。
- en: Understanding the description of GitOps
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解GitOps的描述
- en: A big traditional problem in operations has been ensuring that the different
    servers maintain a proper configuration. When you have a fleet of servers, deploying
    a service and keeping them properly configured is not a straightforward task.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 运维中的一个传统大问题是确保不同服务器保持适当的配置。当您拥有一大批服务器时，部署服务并保持它们正确配置并不是一项简单的任务。
- en: For this chapter, we will use *configuration* as a way of describing a service
    and all the required configuration to run it in production. This includes the
    particular version of the service, but also things such as the underlying infrastructure
    (OS version, number of servers, and so on) or packages and configuration of the dependent services
    (load balancers, third-party libraries, and so on).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用*配置*来描述服务以及在生产环境中运行所需的所有配置。这包括服务的特定版本，以及基础设施（操作系统版本，服务器数量等）或依赖服务的软件包和配置（负载均衡器，第三方库等）。
- en: '*Configuration management* will, therefore, be the way to make changes to that.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*配置管理*将是进行更改的方式。
- en: Keeping configuration on track in all servers is challenging as the infrastructure
    grows. The most common change is to deploy a new version of a service, but there
    are other possibilities. For example, there's a new server being added that needs
    to be added to the load balancer, new configuration tweaks for NGINX to fix a
    security bug, or a new environment variable for the service to enable a feature.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着基础设施的增长，保持所有服务器上的配置跟踪是具有挑战性的。最常见的更改是部署服务的新版本，但还有其他可能性。例如，需要添加到负载均衡器的新服务器，用于修复安全漏洞的NGINX的新配置调整，或者用于启用功能的服务的新环境变量。
- en: The initial stage is manual configuration, but that gets difficult to do after
    a while.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 初始阶段是手动配置，但随着时间的推移，这变得难以做到。
- en: Managing configuration
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理配置
- en: The manual configuration means that someone on the team keeps track of a small
    number of servers, and when a change is required, logs individually on each server
    and makes the required changes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 手动配置意味着团队中的某人跟踪少量服务器，并且在需要进行更改时，单独登录到每台服务器并进行所需的更改。
- en: This way of operating is work-intensive and error prone with multiple servers,
    as they could easily diverge.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作方式在多个服务器上需要大量工作，并且容易出错，因为它们可能很容易发散。
- en: So, after some time, it can be improved through some scripts using Fabric ([http://www.fabfile.org/](http://www.fabfile.org/))
    or Capistrano ([https://capistranorb.com/](https://capistranorb.com/)). The basic
    model is to push the configuration and the new code to the servers and perform
    a number of automated tasks, restarting the service at the end. Typically, this
    is done directly from the computers of the team, as a manual step.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一段时间后，可以通过使用Fabric ([http://www.fabfile.org/](http://www.fabfile.org/))或Capistrano
    ([https://capistranorb.com/](https://capistranorb.com/))的一些脚本来改进。基本模型是将配置和新代码推送到服务器，并执行一些自动化任务，在最后重新启动服务。通常，这是直接从团队的计算机上作为手动步骤完成的。
- en: The code and configuration are normally present on Git, but the manual process
    makes it possible to change this, as it is detached. If you work this way, ensure
    that only files stored under source control are being deployed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 代码和配置通常存在于Git上，但手动过程使得可以更改这一点，因为它是分离的。如果以这种方式工作，请确保只部署存储在源代码控制下的文件。
- en: Some elements for server maintenance, like operating system upgrades or updating
    libraries, may still require to be done manually.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一些服务器维护的元素，如操作系统升级或更新库，可能仍然需要手动完成。
- en: 'The following diagram shows how the code is pushed from the computer of the
    team member that makes the configuration change:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了代码是如何从进行配置更改的团队成员的计算机上推送的：
- en: '![](img/eb0cae60-9e53-4481-867b-a36d9c12c30b.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb0cae60-9e53-4481-867b-a36d9c12c30b.png)'
- en: In this stage, new infrastructure can be added manually or by using a tool such
    as Terraform ([https://www.terraform.io/](https://www.terraform.io/)) to interact
    with cloud services.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，可以通过手动添加新的基础设施，也可以使用诸如Terraform（[https://www.terraform.io/](https://www.terraform.io/)）这样的工具与云服务进行交互。
- en: A more sophisticated alternative is to use tools such as Puppet ([https://puppet.com/](https://puppet.com/))
    or Chef ([https://www.chef.io/](https://www.chef.io/)). They work with a client-server
    architecture. They allow us to describe the state of the servers using their own
    declarative language, and when that's changed in the server, all clients will
    update to follow the definition. The server will report any problems or deviations
    and will centralize the configuration definition.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的选择是使用Puppet（[https://puppet.com/](https://puppet.com/)）或Chef（[https://www.chef.io/](https://www.chef.io/)）等工具。它们采用客户端-服务器架构。它们允许我们使用自己的声明性语言描述服务器的状态，当服务器中的状态发生变化时，所有客户端都会更新以遵循定义。服务器将报告任何问题或偏差，并将集中配置定义。
- en: 'This process is summarized in the following diagram:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程总结在下面的图表中：
- en: '![](img/0efcc43d-9cf4-4a97-ba2f-bf652c5e7998.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0efcc43d-9cf4-4a97-ba2f-bf652c5e7998.png)'
- en: In some cases, these tools may be able to allocate resources in cloud services;
    for example, adding a new EC2 instance in AWS.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这些工具可以在云服务中分配资源；例如，在AWS中添加一个新的EC2实例。
- en: A configuration management tool also helps in monitoring and performs a number
    of remediation tasks. For example, it can restart services that should be running,
    or retry if there has been a problem changing the configuration.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理工具还有助于监控并执行一些纠正任务。例如，它可以重新启动应该运行的服务，或者在更改配置时出现问题时重试。
- en: It also scales better for a higher number of servers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 它也更适合于更多服务器的情况。
- en: All these strategies require specialized tools and are normally handled by a
    specific operations team. This makes the configuration out of reach for developers
    requiring coordination between them in  order to make a configuration update.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些策略都需要专门的工具，通常由特定的运维团队处理。这使得开发人员无法配置，需要他们之间的协调才能进行配置更新。
- en: This division of work creates some friction and, over time, the DevOps movement
    has proposed other ways of structuring this work.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工作分工的划分会产生一些摩擦，随着时间的推移，DevOps运动提出了其他组织这项工作的方式。
- en: Understanding DevOps
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解DevOps
- en: The traditional way of dividing the work was to create an operations team that
    will control the infrastructure and deployments, and a development team that creates
    the service.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的工作划分方式是创建一个控制基础设施和部署的运维团队，以及一个创建服务的开发团队。
- en: The problem with this approach is that developers normally won't understand
    truly how their code works in production, and, simultaneously, operations won't
    exactly know what a deployment contains. This can lead to situations of *I don't
    know what it is*/*I don't know where it is*, where there is a chasm between the
    two teams. DevOps was eventually created as an approach to fill that gap.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题在于开发人员通常不会真正了解他们的代码在生产环境中是如何工作的，同时，运维人员也不会确切地知道部署包含什么。这可能导致“我不知道它是什么”/“我不知道它在哪里”的情况，两个团队之间存在鸿沟。DevOps最终被创建为填补这一差距的方法。
- en: A typical problem is one where a service frequently fails in production and
    is detected by operations, which performs remediation tactics (for example, restarting
    the service).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的问题是一个服务在生产环境中经常失败，并被运维发现，运维会执行纠正策略（例如，重新启动服务）。
- en: However, the development team doesn't know exactly what makes it fail and they
    have other pressing priorities, so they won't fix the problem.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，开发团队并不确切知道是什么导致了失败，他们还有其他紧迫的任务，所以他们不会解决问题。
- en: Over time, this may compromise the stability of the system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，这可能会危及系统的稳定性。
- en: DevOps is a set of techniques to improve collaboration between the operation
    side and the development side. It aims to allow quick deployment by making developers
    aware of the whole operation side, and to simplify operations by using automation
    as much as possible.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps是一套旨在改善运营方面和开发方面之间协作的技术。它旨在通过使开发人员了解整个运营方面来实现快速部署，并尽可能地使用自动化来简化运营。
- en: The core of it is to empower teams to allow them to control their own infrastructure
    and deployments, speeding up the rate of deployment and understanding the infrastructure
    to help identify problems early. The team should be autonomous in deploying and
    supporting the infrastructure.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它的核心是赋予团队控制自己的基础设施和部署的能力，加快部署速度并了解基础设施以帮助及早识别问题。团队应该在部署和支持基础设施方面是自治的。
- en: To enable DevOps practices, you need some tools to control the different operations
    in a controlled way. GitOps is an interesting choice for that, especially if you
    use Kubernetes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现DevOps实践，您需要一些工具来以受控的方式控制不同的操作。GitOps是一个有趣的选择，特别是如果您使用Kubernetes。
- en: Defining GitOps
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义GitOps
- en: The idea of GitOps is simple—we use Git to describe our infrastructure and configuration
    management. Any change to a defined branch will trigger the relevant changes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps的想法很简单——我们使用Git来描述我们的基础设施和配置管理。对定义分支的任何更改都将触发相关的更改。
- en: 'If you are able to define the whole system through code, Git gives you a lot
    of advantages:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能够通过代码定义整个系统，Git会给您带来很多优势：
- en: Any change to either infrastructure or configuration management is versioned.
    They are explicit and can be rolled back if they have problems. Changes between
    versions can be observed through diffs, which is a normal Git operation.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对基础设施或配置管理的任何更改都是有版本的。它们是明确的，如果有问题可以回滚。版本之间的变化可以通过差异来观察，这是正常的Git操作。
- en: A Git repo can act as a backup that can enable recovery from scratch if there's
    a catastrophic failure in the underlying hardware.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git仓库可以作为备份，可以在底层硬件发生灾难性故障时实现从头恢复。
- en: It is the most common source control tool. Everyone in the company likely knows
    how it works and can use it. It also easily integrates with existing workflows,
    like reviews.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是最常见的源代码控制工具。公司里的每个人可能都知道它的工作原理并且可以使用它。它也很容易与现有的工作流程集成，比如审查。
- en: The GitOps concept was introduced and named by Weaveworks in a blog post ([https://www.weave.works/blog/gitops-operations-by-pull-request](https://www.weave.works/blog/gitops-operations-by-pull-request)).
    Since then, it has been used more and more in companies.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps概念是由Weaveworks在一篇博客文章中引入并命名的（[https://www.weave.works/blog/gitops-operations-by-pull-request](https://www.weave.works/blog/gitops-operations-by-pull-request)）。从那时起，它在公司中被越来越多地使用。
- en: While GitOps could be applied to other kinds of deployments (and it certainly
    has been), it has good synergy with Kubernetes, which actually was the description
    in the Weaveworks blog post.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然GitOps也可以应用于其他类型的部署（当然也已经应用了），但它与Kubernetes有很好的协同作用，这实际上是Weaveworks博客文章中的描述。
- en: A Kubernetes cluster can be completely configured using YAML files, which encapsulates
    almost the whole definition of the system. As we saw in the previous chapter,
    this may include the definition of elements such as load balancers. The elements
    external to the Kubernetes cluster, such as an external DNS, which are not included
    in the YAML files, are rare to change.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用YAML文件完全配置Kubernetes集群，这几乎包含了整个系统的定义。正如我们在上一章中看到的，这可能包括诸如负载均衡器之类的元素的定义。Kubernetes集群外的元素，比如外部DNS，这些不包含在YAML文件中的元素，很少发生变化。
- en: The servers and infrastructure can be automated with other tools, like Terraform,
    or with the automated procedures described in [Chapter 7](92e63376-1c9e-4c63-9f7f-c34fa6848ef3.xhtml),
    *Configuring and Securing the Production System*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器和基础设施可以使用其他工具自动化，比如Terraform，或者使用[第7章](92e63376-1c9e-4c63-9f7f-c34fa6848ef3.xhtml)中描述的自动化程序，*配置和保护生产系统*。
- en: For pragmatic reasons, it is entirely feasible that some infrastructure operations
    are manual. For example, upgrading the Kubernetes version of an EKS cluster is
    an operation that can be done through the AWS console, and it is rare enough that
    it is fine to do so manually.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 出于实际原因，一些基础设施操作完全可以是手动的。例如，升级EKS集群的Kubernetes版本是一个可以通过AWS控制台完成的操作，而且很少发生，所以手动操作也是可以的。
- en: It is also fine to have these kinds of operations remain manual, since automating
    them probably won't pay dividends.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作保持手动也是可以的，因为自动化它们可能不会带来回报。
- en: As we saw in [Chapter 6](e7d90194-85f2-4f11-a573-d69382ef79cf.xhtml), *Local
    Development with Kubernetes*, the Kubernetes YAML files contain element definitions
    that can be applied with the `kubectl apply -f <file>` commands. Kubernetes is
    quite flexible since a single file can contain multiple elements or a single one.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第6章](e7d90194-85f2-4f11-a573-d69382ef79cf.xhtml)中看到的，Kubernetes的YAML文件包含可以使用`kubectl
    apply -f <file>`命令应用的元素定义。Kubernetes非常灵活，因为一个文件可以包含多个元素或一个元素。
- en: Grouping all the YAML files under a directory structure and getting them under
    Git control makes a very explicit way of applying changes. This is the way that
    we will operate.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有的YAML文件分组到一个目录结构下，并将它们纳入Git控制，这是一种非常明确的应用变更的方式。这是我们将要操作的方式。
- en: This operation is not complicated, but we will use an existing tool, created
    by Weaveworks, called **Flux**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作并不复杂，但我们将使用一个现有的工具，由Weaveworks创建，叫做**Flux**。
- en: Setting up Flux to control the Kubernetes cluster
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Flux来控制Kubernetes集群
- en: Flux ([https://github.com/fluxcd/flux](https://github.com/fluxcd/flux)) is a
    tool that ensures that the state of a Kubernetes cluster matches the files stored
    in a Git repo.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Flux（[https://github.com/fluxcd/flux](https://github.com/fluxcd/flux)）是一个工具，确保Kubernetes集群的状态与存储在Git仓库中的文件匹配。
- en: It gets deployed inside the Kubernetes cluster, as another deployment. It runs
    every 5 minutes and checks with the Git repo and Docker registry. Then, it applies
    any changes. This helps with access to the Git repo, as there's no need to create
    any push mechanism inside a CI system.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它被部署在Kubernetes集群内部，作为另一个部署。它每5分钟运行一次，并与Git仓库和Docker注册表进行检查。然后，它应用任何变更。这有助于访问Git仓库，因为不需要在CI系统内部创建任何推送机制。
- en: We will see how to start a Flux container inside Kubernetes that pulls from
    the GitHub repo.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在Kubernetes内部启动一个从GitHub仓库拉取的Flux容器。
- en: Starting the system
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动系统
- en: 'For simplicity, we will use the local Kubernetes. We will use the images described
    in [Chapter 6](e7d90194-85f2-4f11-a573-d69382ef79cf.xhtml), *Local Development
    with Kubernetes*, so be sure to run the following commands:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将使用本地Kubernetes。我们将使用[第6章](e7d90194-85f2-4f11-a573-d69382ef79cf.xhtml)中描述的镜像，所以确保运行以下命令：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The basic Kubernetes configuration is stored in the example folder ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter08/example](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter08/example))
    subdirectory.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的Kubernetes配置存储在示例文件夹（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter08/example](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter08/example)）子目录中。
- en: 'You can deploy the entire system with the following commands:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令部署整个系统：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This creates the entire system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了整个系统。
- en: Apply the `namespace.yaml` file to avoid not being able to deploy elements as
    the namespace is not present, but you can run the `kubectl apply -f . --recursive` command
    twice.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 应用`namespace.yaml`文件以避免无法部署元素，因为命名空间不存在，但您可以两次运行`kubectl apply -f . --recursive`命令。
- en: 'If you check the system, it should be deployed now, as shown by running the `kubectl
    get pods` command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查系统，应该已经部署了，通过运行`kubectl get pods`命令显示：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that there are four copies of `frontend`. We will change the number of
    pods during this chapter as an example of how to change a deployment.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有四个`frontend`的副本。我们将在本章中更改Pod的数量，作为如何更改部署的示例。
- en: 'Now, delete the deployment to start from scratch:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，删除部署以从头开始：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For more details about this setup, check the *Deploying the full system locally* section
    in [Chapter 6](e7d90194-85f2-4f11-a573-d69382ef79cf.xhtml), *Local Development
    with Kubernetes*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此设置的更多详细信息，请查看[第6章](e7d90194-85f2-4f11-a573-d69382ef79cf.xhtml)中的*在本地部署完整系统*部分，*使用Kubernetes进行本地开发*。
- en: Configuring Flux
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Flux
- en: We will prepare a Flux system, which will help us keep track of our Git configuration. We
    prepared one based on the Flux example in this repo ([https://github.com/fluxcd/flux/tree/master/deploy](https://github.com/fluxcd/flux/tree/master/deploy)),
    and it's available in the `Chapter08/flux` subdirectory.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将准备一个Flux系统，它将帮助我们跟踪我们的Git配置。我们根据这个存储库中的Flux示例准备了一个（[https://github.com/fluxcd/flux/tree/master/deploy](https://github.com/fluxcd/flux/tree/master/deploy)），它在`Chapter08/flux`子目录中可用。
- en: 'The main file is `flux-deployment.yaml`. Most of it is commented boilerplate,
    but take a look at the definition of the repo to pull from:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 主文件是`flux-deployment.yaml`。其中大部分是注释的样板文件，但请查看要从中提取的存储库的定义：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These lines tell Flux the repo to use, the branch, and any path. If the path
    is commented, which it probably is in your case, it uses the whole repo. In the
    next section, we will need to change the repo to use your own one.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行告诉Flux要使用的存储库，分支和任何路径。如果路径被注释了，在您的情况下可能是这样，它将使用整个存储库。在下一节中，我们需要更改要使用的存储库为您自己的存储库。
- en: Note that we use the `flux` namespace to deploy all these elements. You can
    reuse your main namespace or use the default one if it works better for you.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`flux`命名空间来部署所有这些元素。您可以重用您的主要命名空间，或者如果对您更有效，可以使用默认命名空间。
- en: 'To use Flux, create the namespace and then apply the full `flux` directory:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Flux，请创建命名空间，然后应用完整的`flux`目录：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using the following code, you can check that everything is running as expected:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码，您可以检查一切是否按预期运行：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But, to be able to deploy from a Git repo, we need to configure it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，要能够从Git存储库部署，我们需要对其进行配置。
- en: Configuring GitHub
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置GitHub
- en: Though we can configure any Git repo, typically, we will use GitHub to set it
    up. We will need to set up a valid key to access the Git repo.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以配置任何Git存储库，但通常，我们将使用GitHub进行设置。我们需要设置一个有效的密钥来访问Git存储库。
- en: The easiest way to do this is to allow Flux to generate its own key, and add
    it to the GitHub repo. But to be able to do so, we need to create our own GitHub
    repo.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的最简单方法是允许Flux生成自己的密钥，并将其添加到GitHub存储库。但是，为了能够这样做，我们需要创建自己的GitHub存储库。
- en: Forking the GitHub repo
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分叉GitHub存储库
- en: 'The first step in configuring the repo is to fork it. Let''s look at the following
    steps for more details:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 配置存储库的第一步是分叉。让我们查看更多详细信息的以下步骤：
- en: Go to the page of the GitHub repo for the code ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/))
    and click in Fork on the top-right corner to generate your own copy.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到GitHub代码的页面（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/)），然后单击右上角的Fork以生成您自己的副本。
- en: 'Once you have your own copy, it will have a URL similar to the following:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您拥有自己的副本，它将具有类似以下的URL：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, you need to replace it in the `Chapter08/flux/flux-deployment.yaml` file for
    the `--git-url` parameter.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要在`Chapter08/flux/flux-deployment.yaml`文件中替换它为`--git-url`参数。
- en: 'Once you change it, reapply the Flux configuration with the following command:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改后，使用以下命令重新应用Flux配置：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, Flux is tracking your own repo under your full control, and you can make
    changes to it. First of all, we need to allow Flux to access the GitHub repo,
    which can be achieved through a deploy key.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Flux正在跟踪您完全控制的自己的存储库，并且您可以对其进行更改。首先，我们需要允许Flux访问GitHub存储库，可以通过部署密钥实现。
- en: Adding a deploy key
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加部署密钥
- en: 'To allow Flux to access GitHub, we need to add its secret key as a valid deploy
    key. Using `fluxctl`, it is easy to get the current `ssh` key; just run the following
    command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许Flux访问GitHub，我们需要将其秘钥添加为有效的部署密钥。使用`fluxctl`，很容易获取当前的`ssh`秘钥；只需运行以下命令：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With that information, go to the Settings | Deploy keys section on your forked
    GitHub project. Fill the title with a descriptive name, the Key section with your
    secret key as obtained before, and then select Add key:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，转到您分叉的GitHub项目的“设置|部署密钥”部分。使用描述性名称填写标题，使用之前获取的秘钥填写密钥部分，然后选择“添加密钥”：
- en: '![](img/a8ab5d41-bfa3-4964-83e9-88a473e2f7b5.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/a8ab5d41-bfa3-4964-83e9-88a473e2f7b5.png)
- en: Be sure to select the checkbox for Allow write access. Now, Flux will be able
    to contact GitHub.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要选择“允许写入访问”的复选框。现在，Flux将能够联系GitHub。
- en: The next step is to synchronize the state on GitHub and the cluster.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在GitHub和集群上同步状态。
- en: Syncing Flux
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步Flux
- en: 'We can sync with Flux, so the description in GitHub is applied in the cluster,
    using the following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以与Flux同步，因此GitHub中的描述将应用于集群，使用以下命令：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It will take a bit to sync, and it''s possible that you will get an error stating
    that it is cloning the repo:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 同步需要一点时间，可能会出现错误，指出正在克隆存储库：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Wait for a couple of minutes and try again:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几分钟，然后重试：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Your Flux deployment and, therefore, the local Kubernetes cluster are now in
    sync with the configuration in Git and will update with any change.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Flux部署，因此本地Kubernetes集群现在与Git中的配置同步，并将随任何更改更新。
- en: Making a Kubernetes cluster change through GitHub
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过GitHub进行Kubernetes集群更改
- en: Your local Kubernetes cluster, through Flux, will update to reflect changes
    in the Git repo. Any change in Git will be propagated to the cluster after a few
    minutes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Flux，您的本地Kubernetes集群将更新以反映Git存储库中的更改。几分钟后，Git中的任何更改都将传播到集群。
- en: 'Let''s see this with a test updating the number of pods in the frontend deployment:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过测试来查看这一点，更新前端部署中的Pod数量：
- en: 'Change the `Chapter08/example/frontend/deployment.yaml` file in your forked
    repo as described here:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下描述更改您分叉的存储库中的`Chapter08/example/frontend/deployment.yaml`文件：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This changes the number of replicas from `4` to `2`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将将副本的数量从`4`更改为`2`。
- en: Commit the change into the `master` branch and push into the GitHub repo.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更改提交到`master`分支并推送到GitHub仓库。
- en: 'Monitor the cluster with the following command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令监视集群：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You will see how the number of frontend pods will decrease after a few minutes.
    You can speed it up by manually syncing Flux.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，您将看到前端Pod的数量减少。您可以通过手动同步Flux来加快速度。
- en: Revert the change and see how they'll be added.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 撤消更改并查看它们将如何被添加。
- en: Flux won't delete elements to avoid problems. This means that removing a file
    of a deployment or service won't eliminate it from the repo. To do so, you need
    to remove it manually.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Flux不会删除元素以避免问题。这意味着删除部署或服务文件不会从存储库中删除它。要这样做，您需要手动删除它。
- en: You can disable pods controlled by a deployment by setting the number of replicas
    to zero.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将副本的数量设置为零来禁用由部署控制的Pod。
- en: Congratulations! You now have a cluster controlled by a GitHub repo.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您现在拥有一个由GitHub存储库控制的集群。
- en: Let's look at some ideas on how to use this methodology efficiently in production
    environments.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在生产环境中有效地使用这种方法。
- en: Working in production
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在生产中工作
- en: GitOps is mainly aimed at working on production environments, which are bigger
    and more complex than the example local cluster we used in this chapter. In this
    section, we will describe how to use the advantages of Git to improve clarity
    in terms of deployments and changes, and how to be sure that we structure the
    different files under source control to avoid confusion.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps主要针对生产环境，这些环境比本章中使用的示例本地集群更大更复杂。在本节中，我们将描述如何利用Git的优势来提高部署和更改的清晰度，以及如何确保我们在源代码控制下结构化不同文件以避免混乱。
- en: Creating structure
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建结构
- en: Structuring the YAML files is critical for a big deployment. Technically, you
    can join everything in a single file, but that's not the best way of handling
    it when it grows. Kubernetes allows a great deal of flexibility, so try to find
    a structure that works for you.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型部署来说，结构化YAML文件至关重要。从技术上讲，您可以将所有内容合并到一个文件中，但当它增长时，这并不是处理它的最佳方式。Kubernetes允许极大的灵活性，因此请尝试找到适合您的结构。
- en: A simple one is to create subdirectories by namespace and then by microservice.
    This is the way we have structured it in this example. This structure keeps related
    elements together and has a clear path for anyone touching a microservice. If
    deployments affect only one microservice (as they should, as we discussed in [Chapter
    1](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml), *Making the Move – Design, Plan,
    and Execute*, in the *Parallel deployment and development speed* section), this
    keeps changes in the same subdirectory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的方法是按命名空间和微服务创建子目录。这是我们在本示例中的结构方式。这种结构将相关元素放在一起，并为任何涉及微服务的人提供了清晰的路径。如果部署仅影响一个微服务（正如我们在[第1章](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml)中讨论的那样，*进行移动-设计、计划和执行*，在*并行部署和开发速度*部分），这将使更改保持在同一个子目录中。
- en: But don't feel limited to this structure. If it makes sense for you, you can
    try something different; for example, making a division by element, that is, all
    deployments under a directory, all services under another, and so on. Don't be
    afraid to experiment and move elements, searching for the best structure for your
    project.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要感到受限于这种结构。如果对您有意义，您可以尝试一些不同的东西；例如，按元素进行划分，即将所有部署放在一个目录下，所有服务放在另一个目录下，依此类推。不要害怕尝试和移动元素，寻找项目的最佳结构。
- en: All these files are under source control in GitHub, which allows us to use their
    features to our advantage.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些文件都在GitHub中受源代码控制，这使我们能够利用它们的功能。
- en: Using GitHub features
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GitHub功能
- en: Given that any merge to the main branch will trigger a change in the cluster,
    this should be reviewed before going live.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到任何对主分支的合并都会触发集群的变化，这在上线之前应该进行审查。
- en: You can do it by requiring a pull request that needs approval prior to merging.
    The approval can come from an Ops team dedicated to keeping track of the cluster,
    or by the owner of the microservice; for example, a team lead or manager.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过要求需要批准的拉取请求来进行。批准可以来自专门跟踪集群的Ops团队，也可以来自微服务的所有者；例如，团队领导或经理。
- en: You can enforce code owners natively in GitHub. This means that a change in
    a particular file or directory requires some user or team to approve it. Check
    the GitHub documentation for more info ([https://help.github.com/en/articles/about-code-owners](https://help.github.com/en/articles/about-code-owners)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub中本地强制执行代码所有者。这意味着特定文件或目录的更改需要某个用户或团队批准。查看GitHub文档以获取更多信息（[https://help.github.com/en/articles/about-code-owners](https://help.github.com/en/articles/about-code-owners)）。
- en: A single GitHub repo can also keep track of more than one environment, for example,
    a staging environment to run tests, and a production environment that is available
    to customers. You can divide them either by branch or subdirectory.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 单个GitHub存储库也可以跟踪多个环境，例如，用于运行测试的暂存环境和向客户提供的生产环境。您可以通过分支或子目录来划分它们。
- en: But GitHub features are not the only ones available, the regular Git tag is
    extremely versatile and allows us to define specific containers to deploy.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但GitHub功能并不是唯一可用的，常规的Git标签非常灵活，可以让我们定义要部署的特定容器。
- en: Working with tags
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标签
- en: In this example, we've worked with the `latest` tag for the images. This uses
    the most recently built container, which can change each time that an image is
    built. For production, we should use a specific tag linked to an immutable container,
    as we discussed in [Chapter 3](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml), *Build,
    Run, and Test Your Service Using Docker*, in the *Using a remote registry* section,
    and in [Chapter 4](872309f3-42ba-493c-8595-af1e610af61a.xhtml), *Creating a Pipeline
    and Workflow*, in the *Pushing Docker Images from Travis CI* section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们使用了图像的`latest`标签。这使用了最近构建的容器，每次构建图像时都可能会发生变化。对于生产环境，我们应该使用与不可变容器相关联的特定标签，正如我们在[第3章](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml)中讨论的那样，在*使用远程注册表*部分，以及在[第4章](872309f3-42ba-493c-8595-af1e610af61a.xhtml)中的*创建流水线和工作流程*部分中讨论的那样。
- en: 'This means replacing the following lines:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着替换以下行：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We replace them with the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用以下行替换它们：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is where being able to update the images in a controlled way shines. You
    will use the pipeline (as described in [Chapter 4](872309f3-42ba-493c-8595-af1e610af61a.xhtml),
    *Creating a Pipeline and Workflow*) to build and push the tagged images to the
    remote registry, and then you can control which specific version is deployed in
    the cluster.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是能够以受控方式更新图像的优势所在。您将使用流水线（如[第4章](872309f3-42ba-493c-8595-af1e610af61a.xhtml)中所述的*创建流水线和工作流程*）构建和推送带标记的图像到远程注册表，然后您可以控制在集群中部署哪个特定版本。
- en: In some cases, it may be needed to stop the syncing. Flux works with the concept
    of workloads, which are updateable elements, in the same way as deployments.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能需要停止同步。Flux使用工作负载的概念，这些工作负载是可更新的元素，与部署的方式相同。
- en: You can stop the automatic updating of them or control how they are updated.
    Refer to the documentation for more information: [https://github.com/fluxcd/flux/blob/master/docs/using/fluxctl.md#workloads](https://github.com/fluxcd/flux/blob/master/docs/using/fluxctl.md#workloads).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以停止它们的自动更新或控制它们的更新方式。有关更多信息，请参阅文档：[https://github.com/fluxcd/flux/blob/master/docs/using/fluxctl.md#workloads](https://github.com/fluxcd/flux/blob/master/docs/using/fluxctl.md#workloads)。
- en: Making this version under Git control makes it easy for developers revert to,
    or to come back to, a previous version.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将此版本置于Git控制之下，使开发人员能够轻松地恢复到以前的版本。
- en: To follow the continuous integration principles, try to make small changes and
    apply them quickly. Git will help you revert a bad change, but small incremental
    changes are easy to test and reduce the risk of breaking the system.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循持续集成原则，尝试进行小的更改并快速应用。Git将帮助您撤消不良更改，但小的增量更改易于测试，并减少了破坏系统的风险。
- en: Most of the operations will be simple changes—either change the version of the
    image to be deployed, or tweak parameters, such as the number of replicas or an
    environment variable.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作将是简单的更改，要么更改要部署的图像的版本，要么调整参数，例如副本的数量或环境变量。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We started this chapter with a review of the most common different kinds of
    configuration management strategies, and how they tend to be applied as a project
    grows. We discussed how the DevOps approach makes teams take ownership of their
    deployments and helps to fill the traditional gap between development and operations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从回顾最常见的不同类型的配置管理策略开始本章，并讨论了它们在项目增长时的应用方式。我们讨论了DevOps方法如何使团队承担起部署的责任，并有助于填补开发和运维之间的传统差距。
- en: We saw how the latest approach called GitOps works very well with a Kubernetes
    cluster, as the configuration is tightly described as a set of files. We went
    through the advantages of using Git to track the configuration.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了最新的GitOps方法在Kubernetes集群中运行得非常好，因为配置被紧密描述为一组文件。我们讨论了使用Git跟踪配置的优势。
- en: We introduced Flux, a tool that gets deployed inside your cluster and pulls
    changes from a Git repo branch. We presented an example configuration, deployed
    it in our local Kubernetes cluster, and configured GitHub to be able to work with
    it. This enabled any push to our Git branch in GitHub to be reflected in the local
    cluster.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了Flux，这是一个部署在集群内并从Git存储库分支中拉取更改的工具。我们提供了一个示例配置，在本地Kubernetes集群中部署了它，并配置了GitHub以便与其一起工作。这样一来，GitHub中对Git分支的任何推送都会在本地集群中反映出来。
- en: We ended the chapter with some strategies for working in production. We looked
    at making sure that the Kubernetes YAML files are properly structured, taking
    advantage of the GitHub features, and we learned how to release and roll back
    tagged images.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章结束时介绍了一些在生产环境中工作的策略。我们研究了确保Kubernetes YAML文件结构正确，利用GitHub功能的方法，并学习了如何发布和回滚带标记的图像。
- en: In the next chapter, we will describe the process of a full developing cycle
    for the cluster, from the introduction of a new feature until it gets deployed
    in a production environment. We will describe some useful strategies when working
    in live systems, so that the deployed code works smoothly and is of a high quality.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将描述集群的完整开发周期的过程，从引入新功能到在生产环境中部署。我们将描述在实时系统中工作时的一些有用策略，以确保部署的代码运行顺畅且质量高。
- en: Questions
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between using a script to push new code to servers and
    using a configuration management tool such as Puppet?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用脚本将新代码推送到服务器和使用Puppet等配置管理工具有何区别？
- en: What is the core idea behind DevOps?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DevOps的核心理念是什么？
- en: What are the advantages of using GitOps?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用GitOps的优势是什么？
- en: Can GitOps only be used in a Kubernetes cluster?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GitOps只能在Kubernetes集群中使用吗？
- en: Where is the Flux deployment located?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flux部署位于何处？
- en: What do you need to configure in GitHub in order to allow Flux to access it?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了允许Flux访问GitHub，您需要在GitHub中配置什么？
- en: For working in production environments, which features does GitHub provide that
    can help ensure control over deployments?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生产环境中工作时，GitHub提供了哪些功能可以帮助确保对部署的控制？
- en: Further reading
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: You can learn more about DevOps practices and ideas in the following books: *Practical
    DevOps – Second Edition* ([https://www.packtpub.com/virtualization-and-cloud/practical-devops-second-edition](https://www.packtpub.com/virtualization-and-cloud/practical-devops-second-edition)),
    and *DevOps Paradox* ([https://www.packtpub.com/web-development/devops-paradox](https://www.packtpub.com/web-development/devops-paradox)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下书籍中了解更多关于DevOps实践和理念：*实用DevOps-第二版* ([https://www.packtpub.com/virtualization-and-cloud/practical-devops-second-edition](https://www.packtpub.com/virtualization-and-cloud/practical-devops-second-edition))，以及*DevOps悖论*
    ([https://www.packtpub.com/web-development/devops-paradox](https://www.packtpub.com/web-development/devops-paradox))。
