- en: Advanced IoT Programming Concepts - Threads, AsyncIO, and Event Loops
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 高级IoT编程概念-线程、异步IO和事件循环
- en: In the previous chapter, we learned how to detect movement with a PIR sensor,
    as well as measure distances and detect movement with ultrasonic sensors and Hall-effect
    sensors.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用PIR传感器检测运动，以及如何使用超声波传感器和霍尔效应传感器测量距离和检测运动。
- en: In this chapter, we will discuss alternative ways of *structuring* our Python
    programs when we are working with electronic sensors (input devices) and actuators
    (output devices). We will cover the classic event-loop approach to programming,
    before moving on to more advanced approaches, including the use of threads in
    Python, the publisher/subscriber model, and finally, asynchronous I/O programming
    with Python.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论在处理电子传感器（输入设备）和执行器（输出设备）时，*构建*Python程序的替代方式。我们将首先介绍经典的事件循环编程方法，然后转向更高级的方法，包括在Python中使用线程、发布者/订阅者模型，最后是使用Python进行异步IO编程。
- en: I guarantee you that there are many, many blog posts and tutorials across the
    internet covering these topics; however, what we will cover in this chapter will
    be uniquely focused on practical electronic interfacing. Our approach in this
    chapter will involve creating a simple circuit with a push-button, a potentiometer,
    and two LEDs that we will make flash at different rates, and presenting four different
    coding approaches to make the circuit work.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我向您保证，互联网上有很多博客文章和教程涵盖了这些主题；然而，本章将专注于实际的电子接口。本章的方法将涉及创建一个简单的电路，其中包括一个按钮、一个电位计和两个LED，我们将使它们以不同的速率闪烁，并提供四种不同的编码方法来使电路工作。
- en: 'Here is what we will cover in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将涵盖的内容：
- en: Building and testing our circuit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和测试我们的电路
- en: Exploring an event-loop approach
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索事件循环的方法
- en: Exploring a threaded approach
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索线程化方法
- en: Exploring a publisher-subscriber alternative
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索发布者-订阅者的替代方案
- en: Exploring an AsyncIO approach
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索异步IO的方法
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To perform the exercises in this chapter, you will need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章的练习，您需要以下内容：
- en: Raspberry Pi 4 Model B
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派4型B
- en: Raspbian OS Buster (with desktop and recommended software)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspbian OS Buster（带桌面和推荐软件）
- en: Minimum Python version 3.5
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最低Python版本3.5
- en: These requirements are what the code examples in this book are based on. It's
    reasonable to expect that the code examples should work without modification on
    Raspberry Pi 3 Model B or a different version of Raspbian OS as long as your Python
    version is 3.5 or higher.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求是本书中代码示例的基础。可以合理地期望，只要您的Python版本是3.5或更高，本书中的代码示例应该可以在树莓派3型B或不同版本的Raspbian
    OS上无需修改即可运行。
- en: You will find this chapter's source code in the `chapter12` folder in the GitHub
    repository available at [https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub存储库的`chapter12`文件夹中找到本章的源代码，该存储库位于[https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT)。
- en: 'You will need to execute the following commands in a terminal to set up a virtual
    environment and install the Python libraries required for the code in this chapter:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在终端中执行以下命令来设置虚拟环境并安装本章所需的Python库：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following dependencies are installed from `requirements.txt`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下依赖项已从`requirements.txt`中安装：
- en: '**PiGPIO**: The PiGPIO GPIO library ([https://pypi.org/project/pigpio](https://pypi.org/project/pigpio))'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PiGPIO**：PiGPIO GPIO库（[https://pypi.org/project/pigpio](https://pypi.org/project/pigpio)）'
- en: '**ADS1X15**: The ADS1x15 ADC library ([https://pypi.org/project/adafruit-circuitpython-ads1x15](https://pypi.org/project/adafruit-circuitpython-ads1x15))'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ADS1X15**：ADS1x15 ADC库（[https://pypi.org/project/adafruit-circuitpython-ads1x15](https://pypi.org/project/adafruit-circuitpython-ads1x15)）'
- en: '**PyPubSub**: In-process messaging and events ([https://pypi.org/project/PyPubSub](https://pypi.org/project/PyPubSub))'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PyPubSub**：进程内消息和事件（[https://pypi.org/project/PyPubSub](https://pypi.org/project/PyPubSub)）'
- en: 'The electronic components we will need for this chapter''s exercises are as
    follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章练习所需的电子元件如下：
- en: 2 x red LEDs
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x 红色LED
- en: 2 x 200 Ω resistors
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x 200 Ω 电阻
- en: 1 x push-button switch
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 按钮开关
- en: 1 x ADS1115 module
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x ADS1115模块
- en: 1 x 10k Ω potentiometer
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 10k Ω 电位计
- en: 'To maximize your learning in this chapter, there are some assumptions made
    regarding pre-existing knowledge and experience:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大限度地提高您在本章中的学习效果，对于预先存在的知识和经验做出了一些假设：
- en: From an electronic interfacing perspective, I will assume that you have read the
    preceding 11 chapters of this book and are comfortable working with the PiGPIO
    and ADS1115 Python libraries featured throughout this book.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从电子接口的角度来看，我假设您已经阅读了本书前面的11章，并且对本书中始终出现的PiGPIO和ADS1115 Python库的工作感到满意。
- en: From a programming perspective, I am assuming existing knowledge of **Object-Oriented
    Programming** (**OOP**) techniques and how they are implemented in Python.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从编程的角度来看，我假设您已经掌握了**面向对象编程**（**OOP**）技术以及它们在Python中的实现。
- en: Familiarity with the concepts *event-loop*, *threads,* *publisher-subscriber,* and
    *synchronous versus asynchronous* paradigms will also be advantageous.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉*事件循环*、*线程*、*发布者-订阅者*和*同步与异步*范式的概念也将是有利的。
- en: If any of the preceding topics are unfamiliar, you will find many online tutorials
    available covering these topics in great detail. Please see the *Further reading*
    section at the end of the chapter for suggestions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前述任何主题对您来说是陌生的，您会发现有很多在线教程详细介绍了这些主题。请参阅本章末尾的*进一步阅读*部分以获取建议。
- en: Building and testing our circuit
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和测试我们的电路
- en: 'I''m going to present the circuit and programs for this chapter in the form
    of a practical exercise. Let''s pretend for a moment that we have been asked to
    design and build a *gizmo* that has the following requirements:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我将以实际练习的形式呈现本章的电路和程序。让我们假设我们被要求设计和构建一个具有以下要求的*小玩意*：
- en: It has two LEDs that blink.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有两个LED灯在闪烁。
- en: A potentiometer is used to adjust the rate that the LED(s) blink.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电位计用于调整LED的闪烁速率。
- en: When the program starts, both LEDs will blink at the same rate determined by
    the position of the potentiometer.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序启动时，两个LED将以由电位计位置确定的相同速率闪烁。
- en: A blinking rate of 0 seconds means an LED is off, while the maximum blinking
    rate of 5 seconds means an LED is on for 5 seconds, then off for 5 seconds, before
    repeating the cycle.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0秒的闪烁速率意味着LED关闭，而5秒的最大闪烁速率意味着LED打开5秒，然后关闭5秒，然后重复循环。
- en: A push-button is used to select which LED changes its blinking rate when the
    potentiometer is adjusted.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下按钮用于选择调整闪烁速率的LED，当调整电位计时。
- en: When the push-button is pressed and held for 0.5 seconds, all LEDs synchronize
    to the same rate, determined by the potentiometer's position.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当按下并保持按下按钮0.5秒时，所有LED将同步到相同的速率，由电位计的位置确定。
- en: Ideally, the program code should easily scale to support more LEDs with minimal
    coding effort.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理想情况下，程序代码应该很容易扩展，以支持更多LED，而编码工作量很小。
- en: 'Here is a scenario illustrating the gizmo''s use:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个说明使用这个小玩意的场景：
- en: After applying power (and the program starts), all LEDs start to blink at a
    rate of 2.5 seconds because the potentiometer's dial is at the midpoint (50%)
    of its rotation.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用电源后（程序启动），所有LED以2.5秒的速率开始闪烁，因为电位计的刻度在旋转的中点（50%）。
- en: The user adjusts the potentiometer to make the *first* LED blink at a rate of
    4 seconds.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户调整电位计，使*第一个*LED以4秒的速率闪烁。
- en: Next, the user briefly presses and releases the push-button so that the potentiometer
    will change the *second* LED's blinking rate.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，用户简短地按下并释放按钮，以便电位计改变*第二个*LED的闪烁速率。
- en: Now, the user adjusts the potentiometer so that the *second* LED blinks at a
    rate of 0.5 seconds.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，用户调整电位计，使*第二个*LED以0.5秒的速率闪烁。
- en: Finally, the user presses and holds the button down for 0.5 seconds to make
    both the *first* and *second* LED blink in unison at a rate of 0.5 seconds (the
    rate set by the potentiometer at *step 4*).
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，用户按下并保持按钮0.5秒，使*第一个*和*第二个*LED以0.5秒的速率同步闪烁（由*步骤4*中电位计设置的速率）。
- en: Now for the challenge I mentioned – before we get into this chapter's circuit
    and code, I challenge you to stop reading now and try to create a circuit and
    write a program that implements the preceding requirements.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我提到的挑战 - 在我们进入本章的电路和代码之前，我挑战您停止阅读，尝试创建一个实现上述要求的电路并编写程序。
- en: You will find a short video demonstrating these requirements at [https://youtu.be/seKkF61OE8U](https://youtu.be/seKkF61OE8U).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://youtu.be/seKkF61OE8U](https://youtu.be/seKkF61OE8U)上找到演示这些要求的短视频。
- en: I anticipate that you will encounter challenges and have questions about the
    best approach to take. There is no one best approach; however, by having your
    own implementation – whether it works or not – you will have something to compare and
    contrast with the four solutions that I will present during this chapter. I'm
    confident that if you have a go yourself first, then you will gain a deeper understanding
    and more insight. Hey, perhaps you'll create an even better solution!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我预计您会遇到挑战，并对采取的最佳方法有疑问。没有最佳方法；然而，通过拥有自己的实现 - 无论是否有效 - 您将有东西可以与我在本章中将提出的四种解决方案进行比较和对比。我相信，如果您首先自己尝试一下，那么您将获得更深入的理解和更多的见解。也许您会创造出更好的解决方案！
- en: 'If you need suggestions to help get you started, here they are:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要建议来帮助您入门，这里有一些建议：
- en: We first covered LEDs and push-buttons in [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml),
    *Getting Started with Python and IoT*.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在《使用Python和物联网入门》的[第2章]中首次介绍了LED和按钮。
- en: We first covered potentiometers and analog input using an ADS1115 module in [Chapter
    5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting Your Raspberry Pi
    to the Physical World*.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先在《将树莓派连接到物理世界》的[第5章]中介绍了电位计和模拟输入，使用了ADS1115模块。
- en: When you are ready, we will look at a circuit that fulfills the aforementioned
    requirements.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备好时，我们将看一个满足上述要求的电路。
- en: Building the reference circuit
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建参考电路
- en: 'In *Figure 12.1* is a circuit that meets the requirements we just listed. It
    has a push-button, a potentiometer in the form of a voltage divider connected
    to an ADS1115 analog-to-digital converter, and two LEDs connected by current limiting
    resistors. Adding additional LEDs will be as simple as wiring more LED and resistors
    pairs between GND and a free GPIO pin:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图12.1*中是一个符合我们刚列出的要求的电路。它有一个按钮，一个电位计，以电压分压器的形式连接到ADS1115模数转换器，和两个通过限流电阻连接的LED。添加额外的LED将像在GND和一个空闲的GPIO引脚之间布线更多的LED和电阻对一样简单：
- en: '![](assets/1ce6b28c-49d3-4bae-bfce-ee96b13a20ab.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1ce6b28c-49d3-4bae-bfce-ee96b13a20ab.png)'
- en: Figure 12.1 – Reference circuit schematic
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 - 参考电路原理图
- en: 'If you have not already created a similar circuit on your own, we will create
    this circuit now on your breadboard. We will build this circuit in three parts.
    Let''s get started:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有在面包板上创建类似的电路，我们现在将在您的面包板上创建这个电路。我们将分三部分构建这个电路。让我们开始吧：
- en: '![](assets/e0af2da2-7c85-476e-97eb-25ad65088378.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e0af2da2-7c85-476e-97eb-25ad65088378.png)'
- en: Figure 12.2 – Reference circuit (part 1 of 3)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 - 参考电路（3部分之一）
- en: 'Here are the steps to follow to create the first part of our breadboard build
    where we place the components. The step numbers match the numbers in black circles
    in *Figure 12.2*:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建我们的面包板构建的第一部分的步骤。步骤编号与*图12.2*中黑色圆圈中的数字相匹配：
- en: Place the ADS1115 module into your breadboard.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ADS1115模块放入面包板中。
- en: Place the potentiometer into your breadboard.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电位计放入面包板中。
- en: Place an LED into your breadboard, taking care to orientate the LED's legs as
    illustrated.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将LED放入面包板中，注意LED的引脚方向如图所示。
- en: Place a second LED into your breadboard, taking care to orientate the LED's
    legs as illustrated.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第二个LED放入面包板中，注意LED的引脚方向如图所示。
- en: Place a 200Ω resistor (R1) into your breadboard. One end of this resistor shares
    the same row as the anode leg of the LED placed in *step 3*.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个200Ω电阻（R1）放入您的面包板中。这个电阻的一端与*步骤3*中放置的LED的阳极腿共用一行。
- en: Place another 200Ω resistor (R2) into your breadboard. One end of this resistor
    shares the same row as the anode leg of the second LED you placed in *step 5*.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将另一个200Ω电阻（R2）放入您的面包板中。这个电阻的一端与*步骤5*中放置的第二个LED的阳极腿共用一行。
- en: Place the push-button into your breadboard.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按键放入您的面包板中。
- en: 'Now that we have placed the components into the breadboard, let''s start wiring
    them:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将组件放入面包板中，让我们开始将它们连接起来：
- en: '![](assets/332b67b8-0242-43a3-a206-485f0325e118.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/332b67b8-0242-43a3-a206-485f0325e118.png)'
- en: Figure 12.3 – Reference circuit (part 2 of 3)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 - 参考电路（2/3部分）
- en: 'Here are the steps to follow to continue with the second part of our breadboard
    build. The step numbers match the numbers in black circles in *Figure 12.3*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是继续进行面包板组装的步骤。步骤编号与*图12.3*中的黑色圆圈中的编号相匹配：
- en: Connect a 3.3-volt pin from your Raspberry Pi to the positive rail of the left-hand
    side power rail.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派的3.3伏特引脚连接到左侧电源轨的正电源轨。
- en: Connect the Vdd terminal of the ADS1115 to the positive rail of the left-hand
    side power rail.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ADS1115的Vdd端连接到左侧电源轨的正电源轨。
- en: Connect the GND terminal of the ADS1115 to the negative rail of the left-hand
    side power rail.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ADS1115的GND端连接到左侧电源轨的负电源轨。
- en: Connect the SCL terminal of the ADS1115 to the SCL pin on your Raspberry Pi.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ADS1115的SCL端连接到树莓派的SCL引脚。
- en: Connect the SDA terminal of the ADS1115 to the SDA pin on your Raspberry Pi.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ADS1115的SDA端连接到树莓派的SDA引脚。
- en: Connect a GND pin on your Raspberry Pi to the negative rail of the left-hand
    side power rail.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派上的GND引脚连接到左侧电源轨的负电源轨。
- en: Connect an outer terminal of the potentiometer to the positive rail of the left-hand
    side power rail.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电位器的外端连接到左侧电源轨的正电源轨。
- en: Connect another outer terminal of the potentiometer to the negative rail of
    the left-hand side power rail.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电位器的另一个外端连接到左侧电源轨的负电源轨。
- en: Connect the center terminal of the potentiometer to port A0 of the ADS1115.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电位器的中间端口连接到ADS1115的A0端口。
- en: Can you recall that the potentiometer in this configuration is creating a variable
    voltage divider? If not, you may want to revisit [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml),
    *Electronics 101 for the Software Engineer*. Furthermore, if you would like a
    detailed refresher on the ADS1115 module, please refer to [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml),
    *Connecting your Raspberry Pi to the Physical World*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否记得，这种配置中的电位器正在创建一个可变电压分压器？如果没有，您可能需要重新阅读[第6章](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml)，*软件工程师的电子学101*。此外，如果您想对ADS1115模块进行详细复习，请参阅[第5章](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)，*将树莓派连接到物理世界*。
- en: 'Let''s continue with our build:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续组装：
- en: '![](assets/2c48c450-5450-4f1e-b387-70c8aaf5848a.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2c48c450-5450-4f1e-b387-70c8aaf5848a.png)'
- en: Figure 12.4 – Reference circuit (part 3 of 3)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 - 参考电路（3/3部分）
- en: 'Here are the steps to follow to continue with the final part of our breadboard
    build. The step numbers match the numbers in black circles in *Figure 12.4*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是继续进行面包板组装的最后部分的步骤。步骤编号与*图12.4*中的黑色圆圈中的编号相匹配：
- en: Connect GPIO 26 from your Raspberry Pi to the 200 Ω resistor (R1).
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派的GPIO 26连接到200Ω电阻（R1）。
- en: Connect GPIO 19 from your Raspberry Pi to the second 200 Ω resistor (R2).
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派的GPIO 19连接到第二个200Ω电阻（R2）。
- en: Connect GPIO 21 from your Raspberry Pi to one leg of the push-button.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派的GPIO 21连接到按键的一腿。
- en: Connect the two cathode legs of the LEDs together.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个LED的阴极腿连接在一起。
- en: Connect the cathode legs of the LEDs to the negative rail of the left-hand side
    power rail.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将LED的阴极腿连接到左侧电源轨的负电源轨。
- en: Connect the second leg of the push-button to the negative rail of the left-hand
    side power rail.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按键的第二腿连接到左侧电源轨的负电源轨。
- en: Now that we have finished our circuit build, we are ready to run the sample
    code to make the circuit work.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了电路组装，我们准备运行示例代码使电路工作。
- en: Running the examples
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行示例
- en: 'This chapter comes with four different versions of code that can work with
    the circuit shown previously in *Figure 12.1.* You will find the code in the `chapter12`
    folder organized by version:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了四个不同版本的代码，可以与*图12.1*中先前显示的电路配合使用。您将在`chapter12`文件夹中按版本组织的代码：
- en: '`chapter12/version1_eventloop` is an *event-loop*-based example.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter12/version1_eventloop`是一个基于*事件循环*的示例。'
- en: '`chapter12/version2_thread` is a *thread and callback*-based example.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter12/version2_thread`是一个基于*线程和回调*的示例。'
- en: '`chapter12/version3_pubsub` is a *publisher-subscriber-*based example.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter12/version3_pubsub`是一个基于*发布者-订阅者*的示例。'
- en: '`chapter12/version4_asyncio` is an**Asynchronous IO** *(***AsyncIO***)*-based
    example.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter12/version4_asyncio`是一个**异步IO**（***AsyncIO***)*-based示例。'
- en: All versions are functionally equivalent; however, they differ in their code
    structure and design. We will discuss each version in greater detail after we
    test our circuit.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所有版本在功能上是等效的；但是它们在代码结构和设计上有所不同。在测试电路后，我们将更详细地讨论每个版本。
- en: 'Here are the steps to follow to run each version (starting with version 1)
    and test the circuit:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行每个版本（从版本1开始）并测试电路的步骤：
- en: Change to the `version1_eventloop` folder.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`version1_eventloop`文件夹。
- en: Briefly look over the `main.py` source file, and any additional Python files
    in the folder, to get a feel for what they contain and how the program is structured.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简要查看`main.py`源文件，以及文件夹中的任何其他Python文件，了解它们包含的内容以及程序的结构。
- en: Run `main.py` in a terminal (remember to switch into the chapter's virtual environment
    first).
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行`main.py`（记得先切换到本章的虚拟环境）。
- en: At this point, if you receive errors regarding I2C or ADS11x5, remember that
    there is the i2cdetect tool, which can be used to confirm that an I2C device such
    as the ADS1115 is correctly connected and visible to your Raspberry Pi. Refer
    to [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting Your Raspberry
    Pi to the Physical World*, for more information.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果您收到关于I2C或ADS11x5的错误，请记住有一个`i2cdetect`工具，可以用来确认I2C设备（如ADS1115）是否正确连接并对您的树莓派可见。有关更多信息，请参阅[第5章](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)，*将您的树莓派连接到物理世界*。
- en: Turn the potentiometer dial and observe the *first* LED's blinking rate changes.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转动电位器拨号并观察*第一个*LED的闪烁速率变化。
- en: Press the button briefly.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 短按按钮。
- en: Turn the potentiometer dial and observe the *second* LED's blinking rate changes.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转动电位器拨号并观察*第二个*LED的闪烁速率变化。
- en: Press and hold the button for 0.5 seconds, and observe that both LEDs now blink
    in unison at the same rate.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住按钮0.5秒，观察两个LED现在以相同速率同步闪烁。
- en: 'The following is an example of the terminal output you will receive:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您将收到的终端输出示例：
- en: '[PRE1]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Press *Ctrl *+ *C* in your terminal to exit the program.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中按*Ctrl *+ *C*退出程序。
- en: Repeat *steps 1* through *8* for `version2_threads`, `version3_pubsub`, and
    `version4_asyncio`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`version2_threads`、`version3_pubsub`和`version4_asyncio`重复*步骤1*至*8*。
- en: You have just tested and glanced at the source code of four different programs
    (perhaps five, if you challenged yourself to create your own) that all achieve
    exactly the same end result but in different ways.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚测试并浏览了四种不同程序的源代码（也许五种，如果您挑战自己创建了自己的程序），它们都以不同的方式实现了完全相同的最终结果。
- en: Now it's time to understand how these programs are built. Let's begin with the
    *event-loop* version of the program.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候了解这些程序是如何构建的了。让我们从程序的*事件循环*版本开始。
- en: Exploring the event-loop approach
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索事件循环方法
- en: We will start our code exploration by discussing an event-loop-based approach
    to building the sample gizmo that we just tested in the previous section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过讨论基于事件循环的方法来开始我们的代码探索，以构建我们在上一节中测试过的示例小玩意。
- en: The code for the event-loop-based approach can be found in the `chapter12/version1_eventloop`
    folder. You will find one file named `main.py`. Please take the time now to stop
    and read through the code contained in `main.py` to get a basic understanding
    of how the program is structured and how it works. Alternatively, you could add
    breakpoints or insert `print()` statements into the code and run it again to understand
    how it works.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 基于事件循环的方法的代码可以在`chapter12/version1_eventloop`文件夹中找到。您会找到一个名为`main.py`的文件。现在请花时间停下来阅读`main.py`中的代码，以基本了解程序的结构和工作原理。或者，您可以在代码中添加断点或插入`print()`语句，然后再次运行它以了解其工作原理。
- en: How did it go, and what did you notice? If you thought *yuck* or got lost in
    the web of loops, `if` statements, and state variables, then well done! This means
    you have invested the time to consider this approach and how the code is constructed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您的体验如何，您注意到了什么？如果您认为*呸*或者在循环、`if`语句和状态变量的网络中迷失了，那么干得好！这意味着您已经投入了时间来考虑这种方法以及代码的构造方式。
- en: 'What I mean by an event-loop approach is demonstrated in the code by the `while
    True:` loop abbreviated on line 1:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的事件循环方法在代码中通过第1行的`while True:`循环进行了演示：
- en: '[PRE2]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Granted, I could have used functions and even external classes to reduce the
    quantity (and possibly enhance the readability) of the code within the `while`
    loop, however, the overall design paradigm remains the same – the body of the
    program control is sitting in a perpetual loop.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我可以使用函数甚至外部类来减少`while`循环中的代码数量（可能还可以增强可读性），但是，总体设计范式仍然是相同的-程序控制的主体部分处于永久循环中。
- en: If you are familiar with Arduino programming, you will be intimately familiar
    with this approach to programming. That's why I titled this section *event-loop*
    due to the similarity of approach and the popularity of the term. Notwithstanding,
    note that the term *event-loop* has a wider context within Python, as we will
    see when we look at the AsyncIO (version 4) of our program.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉Arduino编程，您将对这种编程方法非常熟悉。这就是为什么我将本节标题为*事件循环*，因为这种方法和术语的流行度相似。尽管如此，请注意*事件循环*这个术语在Python中有更广泛的上下文，当我们查看程序的AsyncIO（版本4）时会看到。
- en: 'You may have realized that this event-loop approach to programming has been
    used by many of the examples throughout this book. Three examples are as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经意识到，本书中许多示例都使用了这种事件循环编程方法。以下是三个示例：
- en: When we wanted a timed event such as blinking an LED ([Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml),
    *Getting Started with Python and IoT*)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要定时事件，比如闪烁LED时（[第2章](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml)，*使用Python和物联网入门*）
- en: Polling the DHT 11 or DHT 22 temperature/humidity sensor ([Chapter 9](a77d6d94-a71a-4d7e-a66f-7c552af5b051.xhtml),
    *Measuring Temperature, Humidity, and Light Levels*)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DHT 11或DHT 22温度/湿度传感器的轮询（[第9章](a77d6d94-a71a-4d7e-a66f-7c552af5b051.xhtml)，*测量温度、湿度和光照水平*）
- en: Polling the ADS1115 analog-to-digital converter connected to a **Light-Dependent-Resistor**
    (**LDR**) (also [Chapter 9](a77d6d94-a71a-4d7e-a66f-7c552af5b051.xhtml), *Measuring
    Temperature, Humidity, and Light Levels*)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮询连接到**光敏电阻**（**LDR**）的ADS1115模拟数字转换器（也[第9章](a77d6d94-a71a-4d7e-a66f-7c552af5b051.xhtml)，*测量温度、湿度和光照水平*）
- en: In this context, for a single focused example, event-loops make sense. They
    even make sense purely for convenience when you're hacking about and trying out
    new ideas and learning about a new actuator or sensor. However, as demonstrated
    by our `version1_eventloop/main.py` program, as soon as you add in multiple components
    (such as a potentiometer, two LEDs, and a push-button) and want to make them work
    together for a definite purpose, the code gets complex fast.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对于一个单一的专注示例，事件循环是有意义的。甚至在你进行试验和学习新的执行器或传感器时，它们也是纯粹为了方便而有意义的。然而，正如我们的`version1_eventloop/main.py`程序所示，一旦你添加了多个组件（比如电位计、两个LED和一个按钮）并且想要让它们为一个明确的目的一起工作，代码就会迅速变得复杂。
- en: 'For instance, consider the following code on line 3, which is responsible for
    blinking all the LEDs, and remember that this block of code is evaluated once
    per loop iteration and is responsible for blinking every LED:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一下第3行的以下代码，它负责让所有LED闪烁，并记住这个代码块在每次循环迭代中被评估一次，负责让每个LED闪烁：
- en: '[PRE3]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Compare this to a vanilla alternative (similar to what we will see in other
    approaches), which at a moment''s glance is significantly easier to understand:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与纯粹的替代方案相比（类似于我们将在其他方法中看到的），一眼看去，它们显然更容易理解：
- en: '[PRE4]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you also consider the following block of code, starting on line 2, which
    is responsible for detecting button presses, then you find nearly 40 lines of
    code (in the actual `main.py` file) just to detect what the button is doing:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再考虑一下从第2行开始的以下代码块，它负责检测按钮按下，那么你会发现在实际的`main.py`文件中有将近40行代码，只是为了检测按钮的操作：
- en: '[PRE5]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You will count multiple variables at play – `button_pressed`, `button_held`,
    `was_pressed`, and `button_hold_timer` – that are all evaluated at every `while`
    loop iteration and are there primarily to detect a *button-hold* event. I'm sure
    you can appreciate that writing and debugging this code like this can be tedious
    and error-prone.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现有多个变量在起作用 - `button_pressed`、`button_held`、`was_pressed`和`button_hold_timer`
    - 它们在每次`while`循环迭代中都被评估，并且主要用于检测*按钮按住*事件。我相信你会理解，像这样编写和调试这样的代码可能会很乏味和容易出错。
- en: We could have used a `PiGPIO` *callback* to handle button presses outside of
    the `while` loop, or even a GPIO Zero `Button` class. Both approaches would help
    reduce the complexity of the button-handling logic. Likewise, maybe we could have
    mixed in a GPIO Zero `LED` class to handle the LED blinking. However, if we did,
    our example would not be a purely event-loop-based example.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用`PiGPIO` *回调*来处理`while`循环之外的按钮按下，或者使用GPIO Zero的`Button`类。这两种方法都有助于减少按钮处理逻辑的复杂性。同样，也许我们本可以混合使用GPIO
    Zero的`LED`类来处理LED的闪烁。然而，如果这样做，我们的示例就不会是一个纯粹基于事件循环的示例。
- en: Now, I'm not saying that event-loops are a bad or wrong approach. They have
    their uses, they are needed, and, in essence, we create one every time we use
    a `while` loop or another looping construct – so the base ideal is everywhere,
    but it's just not an ideal approach to building complex programs, because this
    approach makes them harder to understand, maintain, and debug.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我并不是说事件循环是一种不好或错误的方法。它们有它们的用途，是必需的，实际上，每当我们使用`while`循环或其他循环结构时，我们都会创建一个 -
    所以基本理念无处不在，但这并不是构建复杂程序的理想方法，因为这种方法使它们更难理解、维护和调试。
- en: Whenever you find that your program is heading down this event-loop path, stop
    and reflect, because it might be time to consider refactoring your code to employ
    a different – and more maintainable – approach, such as a threaded/callback approach,
    which we will look at next.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你发现你的程序正在走这条事件循环的道路时，停下来反思一下，因为也许是时候考虑重构你的代码，采用不同的 - 更易维护的 - 方法，比如线程/回调方法，我们将在下面看到。
- en: Exploring a threaded approach
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索线程方法
- en: Now that we have explored an event-loop-based approach to creating our program,
    let's consider an alternative approach built using threads, callbacks, and OOP
    and see how this approach improves code readability and maintainability and promotes
    code reuse.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了一个基于事件循环的方法来创建我们的程序，让我们考虑一种使用线程、回调和面向对象编程的替代方法，并看看这种方法如何改进了代码的可读性和可维护性，并促进了代码的重用。
- en: 'The code for the *threaded*-based approach can be found in the `chapter12/version2_threads`
    folder. You will find four files – the main program, `main.py`, and three class
    definitions: `LED.py`, `BUTTON.py`, and `POT.py`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 基于*线程*的方法的代码可以在`chapter12/version2_threads`文件夹中找到。你会找到四个文件 - 主程序`main.py`和三个类定义：`LED.py`、`BUTTON.py`和`POT.py`。
- en: Please take the time now to stop and read through the code contained in `main.py` to
    get a basic understanding of how the program is structured and how it works. Then,
    proceed to review `LED.py`, `BUTTON.py`, and `POT.py`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请花点时间停下来阅读`main.py`中包含的代码，以基本了解程序的结构和工作原理。然后，继续查看`LED.py`、`BUTTON.py`和`POT.py`。
- en: 'How did it go, and what did you notice? I''d guess that you found this version
    of the program (while reading through `main.py`) much quicker and easier to understand
    and noticed that there is no cumbersome and complex `while` loop, but instead
    a `pause()` call, which is necessary to stop our program from exiting, as summarized on
    line 3:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何进行的，你注意到了什么？我猜想你会发现这个程序的版本（在阅读`main.py`时）更快更容易理解，并且注意到没有繁琐复杂的`while`循环，而是一个`pause()`调用，这是必要的，用于阻止我们的程序退出，如第3行总结的那样：
- en: '[PRE6]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this program example, we have employed object-oriented techniques and componentized
    our program using three classes:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序示例中，我们使用了面向对象的技术，并使用了三个类来组件化我们的程序：
- en: A button class (`BUTTON.py`), which takes care of all the button logic
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个按钮类（`BUTTON.py`），负责所有按钮逻辑
- en: A potentiometer class (`POT.py`), which takes care of all the potentiometer
    and analog-to-digital conversion logic
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个电位计类（`POT.py`），负责所有电位计和模拟数字转换逻辑
- en: A LED class (`LED.py`), which is responsible for making a *single* LED flash
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个LED类（`LED.py`），负责让*单个*LED闪烁
- en: By using an OOP approach, our `main.py` code is greatly simplified. Its role
    is now to create and initialize class instances and house the callback handlers
    and logic that make our program work.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用面向对象的方法，我们的`main.py`代码大大简化了。它的作用现在是创建和初始化类实例，并包含使我们的程序工作的回调处理程序和逻辑。
- en: 'Consider the following OOP approach for our push-button:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下我们的按钮的面向对象的方法：
- en: '[PRE7]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Compared to the button-handing code from the event-loop example, this is greatly
    simplified and much more readable – it's pretty explicit where and how this code
    is responding to the button pressed at line 1 and button holds on line 2.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与事件循环示例中的按钮处理代码相比，这大大简化了并且更易读——很明显这段代码在第1行响应按钮按下，第2行响应按钮保持。
- en: 'Let''s consider the `BUTTON` class, which is defined in the `BUTTON.py` file.
    This class is an enhancing wrapper around a PiGPIO callback function that turns
    the `HIGH`/`LOW` states of the button''s GPIO pin into `PRESSED`, `RELEASED`,
    and `HOLD` events, as summarized in the following code at line 1 in `BUTTON.py`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下`BUTTON`类，它在`BUTTON.py`文件中定义。这个类是一个增强的包装器，可以将按钮的GPIO引脚的`HIGH`/`LOW`状态转换为`PRESSED`、`RELEASED`和`HOLD`事件，如在`BUTTON.py`的第1行中总结的代码所示：
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Compared to the button-handling code of the event-loop example, we did not introduce
    and interrogate multiple state variables to detect the button-hold event, but
    instead, this logic is reduced to a simple and linear approach at line 2.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与事件循环示例中的按钮处理代码相比，我们没有引入和审问多个状态变量来检测按钮保持事件，而是将这个逻辑简化为在第2行的简单线性方法。
- en: Next, as we consider the `POT` class (defined in `POT.py`) and `LED` class (defined
    in `LED.py`), we will see threads come into our program.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当我们考虑`POT`类（在`POT.py`中定义）和`LED`类（在`LED.py`中定义）时，我们将看到线程进入我们的程序。
- en: Did you know that even in a multi-threaded Python program, only one thread is
    active at a time? While it seems counter-intuitive, it was a design decision known
    as the **Global Interpreter Lock** (**GIL**) made back when the Python language
    was first created. If you want to learn more about the GIL and the many other
    forms of achieving concurrency with Python, you will find resources in the *Further
    reading* section of this chapter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道即使在多线程的Python程序中，也只有一个线程在活动吗？虽然这似乎违反直觉，但这是Python语言最初创建时做出的一个称为**全局解释器锁**（**GIL**）的设计决定。如果您想了解更多关于GIL和使用Python实现并发的其他形式的信息，您可以在本章的*进一步阅读*部分找到相关资源。
- en: 'The following is the thread run method for the `POT` class, which can be found
    in the `POT.py` source file, and illustrates, starting on line 1, the approach
    of intermediately polling the ADS1115 ADC to determine the potentiometer''s position.
    We''ve seen this polling example several times already throughout this book, starting
    back in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting Your
    Raspberry Pi to the Physical World*, where we first discussed analog-to-digital
    conversion, the ADS1115 module, and potentiometers:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`POT`类的线程运行方法，可以在`POT.py`源文件中找到，从第1行开始说明了中间轮询ADS1115 ADC以确定电位器位置的方法。我们已经在本书中多次看到这个轮询示例，最早是在[第5章](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)中，*将您的树莓派连接到物理世界*，我们首次讨论模数转换、ADS1115模块和电位器：
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The difference with our code here is that we are monitoring the ADC for voltage
    changes on line 2 (for example, when a user turns the potentiometer), and turning
    them into a callback on line 3, which you will have seen handled in `main.py`
    when you reviewed the source code in that file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里的代码不同之处在于我们正在监视ADC上的电压变化（例如，当用户转动电位器时），并将其转换为回调（在第3行），您在审查该文件中的源代码`main.py`时会看到。
- en: 'Let''s now discuss how we are implementing the `version2` LED-related code. As
    you are aware, the basic code pattern for blinking an LED on and off at a defined
    rate involves a `while` loop and a `sleep` statement. This is the approach taken
    in the LED class, as seen in the `run()` method on line 3 in `LED.py`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一下我们如何实现`version2` LED相关的代码。正如您所知，闪烁LED的基本代码模式涉及`while`循环和`sleep`语句。这就是LED类中采用的方法，如`LED.py`中第3行的`run()`方法中所示：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I am sure you will agree that this is easier to understand than the approach
    taken by the event-loop approach we discussed in the previous section. It is important
    to remember, however, that the event-loop approach was working with and altering
    the blinking rate of *all* LEDs together in a *single* block of code, and within
    a *single* thread – the program's main thread.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信您会同意这比我们在前一节讨论的事件循环方法更容易理解。然而，重要的是要记住，事件循环方法是在*单个*代码块中使用和改变*所有*LED的闪烁速率，并在*单个*线程——程序的主线程中进行的。
- en: Notice the two sleep approaches shown in the preceding code. While the first
    approach using `sleep(self.blink_rate_secs)` is common and tempting, the caveat
    is that it blocks the thread for the full duration of the sleep. As a result,
    the LED will not respond to rate changes immediately and will feel sluggish to
    a user when they turn the potentiometer. The second approach, commended `#Better
    approach`, alleviates this issue and allows the LED to respond to rate changes
    in (near) real time.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前面代码中显示的两种睡眠方法。虽然使用 `sleep(self.blink_rate_secs)` 的第一种方法很常见且诱人，但需要注意的是它会阻塞线程，使其在整个睡眠期间无法立即响应速率变化，当用户转动电位器时会感觉迟钝。第二种方法，称为
    `#Better approach`，缓解了这个问题，使LED能够（近乎）实时地响应速率变化。
- en: Our `version2` program example using the LED class with its own internal thread
    now means that we have multiple threads – one per LED – all making the LEDs blink
    independently to one another.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`version2`程序示例使用LED类及其自己的内部线程，这意味着我们现在有多个线程——每个LED一个——都独立地使LED独立地闪烁。
- en: Can you think of any potential problems this may introduce? Okay, it might be
    obvious if you have read through the `version2` source files – it's the synchronization
    of all LEDs to blink at the same rate in unison when the button is held for 0.5
    seconds!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到这可能引入的任何潜在问题吗？好吧，如果你已经阅读了`version2`源文件，这可能是显而易见的——当按钮按下0.5秒时，同步所有LED以同样的速率同时闪烁！
- en: By introducing multiple threads, we have introduced multiple timers (that is,
    the `sleep()` statement), so each thread is blinking on its own independent schedule,
    and not from a common reference point in terms of a starting timebase.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入多个线程，我们引入了多个定时器（即`sleep()`语句），因此每个线程都在自己独立的时间表上闪烁，而不是从一个共同的参考点开始闪烁。
- en: This means that if we simply called `led.set_rate(n)` on multiple LEDs, while
    they would all blink on and off at the rate *n*, they would not necessarily blink
    in unison.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果我们简单地在多个LED上调用`led.set_rate(n)`，虽然它们都会以速率*n*闪烁，但它们不一定会同步闪烁。
- en: A simple solution to this issue is to synchronize the turning off of all LEDs
    before we start them blinking at the same rate. That is, we start them blinking
    from a common state (that is, off), and start them blinking together.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个简单方法是在开始以相同速率闪烁之前同步关闭所有LED。也就是说，我们从一个共同的状态（即关闭）开始让它们一起闪烁。
- en: 'This approach is shown in the following code snippet starting at line 1 in
    `LED.py`. The core of the synchronization is achieved by the `led._thread.join()`
    statements on line 2:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在`LED.py`的第1行开始的以下代码片段中显示。同步的核心是在第2行的`led._thread.join()`语句中实现的：
- en: '[PRE11]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is a good first pass at synchronization, and for practical purposes, it
    works well for our situation. As mentioned, all we are doing is ensuring our LEDs
    start blinking together from an off state at the same time (well, very, very,
    very close to the same time, subject to the time taken for Python to iterate through
    the `for` loops).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是同步的一个很好的第一步，对于我们的情况来说，实际上效果很好。正如前面提到的，我们所做的就是确保我们的LED从关闭状态同时开始闪烁（嗯，非常非常接近同时，取决于Python迭代`for`循环所花费的时间）。
- en: Try commenting out `led._thread.join()` and the embodying `for` loop on line
    2 in the preceding code and run the program. Make the LEDs blink at different
    rates, then try to synchronize them by holding down the button. Does it always
    work?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将前面代码中第2行的`led._thread.join()`和包含的`for`循环注释掉，然后运行程序。让LED以不同的速率闪烁，然后尝试通过按住按钮来同步它们。它总是有效吗？
- en: However, it must be noted that we are still dealing with multiple threads and
    independent timers to make our LEDs blink, so the potential for a time drift to
    occur is present. If this ever presented a practical issue, we would then need
    to explore alternative techniques to synchronize the time in each thread, or we
    could create and use a single class to manage multiple LEDs together (basically
    using the approach from the event-loop example, only refactoring it into a class
    and a thread).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但必须指出的是，我们仍然在处理多个线程和独立的定时器来让我们的LED闪烁，因此存在时间漂移的可能性。如果这曾经成为一个实际问题，那么我们将需要探索替代技术来同步每个线程中的时间，或者我们可以创建并使用一个单一的类来管理多个LED（基本上使用事件循环示例中的方法，只是将其重构为一个类和一个线程）。
- en: The takeaway here regarding threads is that when you introduce threads to your
    applications, you can introduce timing issues that *may* be designed around or
    synchronized.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 关于线程的要点是，当您将线程引入应用程序时，您可能会引入*可能*可以设计或同步的时间问题。
- en: If your first pass at a prototype or new program involves an event-loop-based
    approach (as I often do), then as you refactor that code out into classes and
    threads, always think about any timing and synchronizing issues that may arise.
    Discovering synchronization-related bugs by accident during testing (or worse,
    when in production) is frustrating as they can be hard to reliably replicate,
    and could result in the need for extensive rework.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的原型或新程序的第一次尝试涉及基于事件循环的方法（就像我经常做的那样），那么当你将代码重构为类和线程时，始终要考虑可能出现的任何时间和同步问题。在测试期间意外发现与同步相关的错误（或更糟糕的是，在生产中）是令人沮丧的，因为它们很难可靠地复制，并且可能导致需要进行大量的重做。
- en: We've just seen how to create our sample gizmo program using OOP techniques,
    threads, and callbacks. We've seen how this approach results in easier to read
    and maintain code, and we also discovered the additional requirement and effort
    needed to synchronize threaded code. Next, we will look at the third variation
    of our program, which is based around a publisher-subscriber model.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何使用面向对象编程技术、线程和回调创建样本小工具程序。我们已经看到了这种方法导致了更容易阅读和维护的代码，同时也发现了需要同步线程代码的额外要求和工作。接下来，我们将看一下我们的程序的第三种变体，它是基于发布-订阅模型的。
- en: Exploring the publisher-subscriber alternative
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索发布-订阅的替代方法
- en: Now that we have seen an approach to creating our program using threads, callbacks,
    and OOP techniques, let's consider a third approach using a *publisher-subscriber*
    model.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了使用线程、回调和面向对象编程技术创建程序的方法，让我们考虑第三种方法，使用*发布-订阅*模型。
- en: 'The code for the publisher-subscriber approach can be found in the `chapter12/version3_pubsub`
    folder. You will find four files – the main program, `main.py`, and three class
    definitions: `LED.py`, `BUTTON.py`, and `POT.py`.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 发布-订阅方法的代码可以在`chapter12/version3_pubsub`文件夹中找到。你会找到四个文件——主程序`main.py`和三个类定义：`LED.py`、`BUTTON.py`和`POT.py`。
- en: Please take the time now to stop and read through the code contained in `main.py` to
    get a basic understanding of how the program is structured and how it works. Then,
    proceed to review `LED.py`, `BUTTON.py`, and `POT.py`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请花时间停下来阅读`main.py`中包含的代码，以基本了解程序的结构和工作原理。然后，继续查看`LED.py`、`BUTTON.py`和`POT.py`。
- en: What you will have noticed is that the overall program structure (especially
    the class files) is very similar to the `version2` thread/callback example that
    we covered in the previous heading.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，整体程序结构（特别是类文件）与我们在上一个标题中介绍的`version2`线程/回调示例非常相似。
- en: You may also have realized that this approach is very similar in concept to
    the publisher/subscribing method employed by MQTT, which we discussed in detail
    in [Chapter 4](6947b564-6182-4ec9-998a-37f636c0bce6.xhtml), *Networking with MQTT,
    Python, and the Mosquitto MQTT Broker*. The main difference is that in our current
    `version3` example, our publisher-subscribing context is confined just to our
    program run-time environment, not a network-distributed set of programs, which
    was the scenario for our MQTT examples.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也意识到，这种方法在概念上与MQTT采用的发布者/订阅者方法非常相似，我们在[第4章](6947b564-6182-4ec9-998a-37f636c0bce6.xhtml)中详细讨论了MQTT、Python和Mosquitto
    MQTT Broker的网络。主要区别在于，在我们当前的“version3”示例中，我们的发布者-订阅者上下文仅限于我们的程序运行时环境，而不是网络分布式程序集，这是我们MQTT示例的情况。
- en: I have implemented the publishing-subscribing layer in `version3` using the
    `PyPubSub` Python library, which is available from [pypi.org](https://pypi.org)
    and is installed using `pip`. We will not discuss this library in any detail,
    as the overall concepts and use of this type of library should already be familiar
    to you, and if not, I have no doubt that you will immediately understand what's
    going on once you review the `version3` source code files (if you have not already
    done so).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经使用`PyPubSub` Python库在“version3”中实现了发布-订阅层，该库可以从[pypi.org](https://pypi.org)获取，并使用`pip`安装。我们不会详细讨论这个库，因为这种类型的库的整体概念和使用应该已经很熟悉了，如果没有，我相信一旦你审查了“version3”源代码文件（如果你还没有这样做），你会立刻明白发生了什么。
- en: There are alternative PubSub libraries available for Python through PyPi.org.
    The choice to use `PyPubSub` for this example was due to the quality of its documentation
    and the examples provided there. You will find a link to this library in the *Technical
    requirements* section at the start of this chapter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Python通过PyPi.org提供了其他可选的PubSub库。选择在这个例子中使用`PyPubSub`是因为它的文档质量和提供的示例。你会在本章开头的*技术要求*部分找到这个库的链接。
- en: 'Due to the similarity of the `version2` (threaded approach) and `version3`
    (publisher-subscriber approach) examples, we will not discuss each code file in
    detail, other than to point out that the core differences:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“version2”（线程方法）和“version3”（发布者-订阅者方法）示例的相似性，我们不会详细讨论每个代码文件，只是指出核心差异：
- en: 'In `version2` (threaded), this is how our `led`, `button`, and `pot` class
    instances communicate with one another:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“version2”（线程）中，这是我们的`led`、`button`和`pot`类实例之间的通信方式：
- en: We registered callback handlers in `main.py` on the `button` and `pot` class
    instances.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`main.py`上注册了`button`和`pot`类实例的回调处理程序。
- en: '`button` and `pot` send events (for example, a button press or potentiometer
    adjustment) via this callback mechanism.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`button`和`pot`通过这种回调机制发送事件（例如按钮按下或电位器调整）。'
- en: We interacted with the LED class instances directly using the `set_rate()` instance
    method and the `set_rate_all()` class method.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们直接使用`set_rate()`实例方法和`set_rate_all()`类方法与LED类实例进行交互。
- en: 'In `version3 `(publisher-subscriber), here is the intra-class communication
    structure and design:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“version3”（发布者-订阅者）中，这是类内通信结构和设计：
- en: Every class instance is very loosely coupled.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个类实例都是非常松散耦合的。
- en: There are no callbacks.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有回调。
- en: We do not interact with any class instances directly after they are created
    and registered with `PyPubSub`.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类实例创建并注册到`PyPubSub`之后，我们不再直接与任何类实例进行交互。
- en: All communication between classes and threads occurs using the messaging layer
    provided by `PyPubSub`.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有类和线程之间的通信都是使用`PyPubSub`提供的消息层进行的。
- en: Now, to be honest, our gizmo program does not benefit from a publisher-subscriber
    approach. My personal preference is to adopt the callback version for a small
    program like this one. However, I have provided the publisher-subscriber alternative
    implementation as a point of reference so that you have this alternative to consider
    for your own needs.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，说实话，我们的小玩意程序并不从发布者-订阅者方法中受益。我个人偏好采用回调版本来处理这样一个小程序。然而，我提供了发布者-订阅者的替代实现作为参考，这样你就有这个选择来考虑你自己的需求。
- en: Where a publisher-subscriber approach shines is in more complex programs where
    you have many components (and here I mean software components, not necessarily electronics
    components) that need to share data and can do so in an asynchronous PubSub-style
    nature.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者-订阅者方法在更复杂的程序中表现出色，其中有许多组件（这里指的是软件组件，不一定是电子组件）需要共享数据，并且可以以异步的发布者-订阅者方式进行。
- en: We're presenting the coding and design approaches in this chapter in four very
    discrete and focused examples. In practice, however, it's common to combine these
    approaches (and other design patterns) in a hybrid and mixed fashion when creating
    your programs. Remember, the approach or combination of approaches to use is whatever
    makes the most sense for what you are trying to achieve.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中以四个非常离散和专注的例子来展示编码和设计方法。然而，在实践中，当创建程序时，通常会将这些方法（以及其他设计模式）以混合的方式结合起来。记住，使用的方法或方法组合应该是对你所要实现的目标最有意义的。
- en: As we have just discussed, and you will have seen as you reviewed the `version3`
    code, a publisher-subscriber approach to our gizmo program is a simple variation
    of the thread and callback approach, where instead of using callbacks and interacting
    with class instances directly, we standardize all code communication to a messaging
    layer. Next, we will look at our final approach to coding our gizmo program, this
    time taking the AsyncIO approach.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚讨论过的，你在审查“version3”代码时会看到，我们的小玩意程序的发布者-订阅者方法是线程和回调方法的一个简单变体，我们不再直接使用回调与类实例交互，而是将所有代码通信标准化到一个消息层。接下来，我们将看看我们编写小玩意程序的最终方法，这次采用AsyncIO方法。
- en: Exploring an AsyncIO approach
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索AsyncIO方法
- en: So far in this chapter, we have seen three different programming approaches
    to achieving the same end goal. Our fourth and final approach will be built using
    the AsyncIO libraries offered by Python 3\. As we will see, this approach shares
    similarities and differences with our previous approaches, and also adds an extra
    dimension to our code and how it operates.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经看到了三种不同的编程方法来实现相同的最终目标。我们的第四种和最终方法将使用Python 3提供的AsyncIO库构建。正如我们将看到的，这种方法与我们以前的方法有相似之处和不同之处，并且还为我们的代码及其操作方式增加了一个额外的维度。
- en: Speaking from my own experience, this approach can feel complex, cumbersome,
    and confusing the first time you experience asynchronous programming in Python.
    Yes, there is a steep learning curve to asynchronous programming (and we can only
    barely scratch the surface in this section). However, as you learn to master the
    concepts and gain practical experience, you may start to discover that it is an
    elegant and graceful way to create programs!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，第一次体验Python中的异步编程可能会感到复杂、繁琐和令人困惑。是的，异步编程有一个陡峭的学习曲线（在本节中我们只能勉强触及表面）。然而，当您学会掌握这些概念并获得实际经验时，您可能会开始发现这是一种优雅而优美的创建程序的方式！
- en: If you are new to asynchronous programming in Python, you will find curated
    tutorial links in the *Further reading* section to deepen your learning. It is
    my intention in this section to give you a simple working AsyncIO program that
    focuses on electronic interfacing, which you can use as a reference as you learn
    more about this style of programming.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是Python中异步编程的新手，您将在*进一步阅读*部分找到精心策划的教程链接，以加深您的学习。在本节中，我打算为您提供一个专注于电子接口的简单工作的AsyncIO程序，您可以在学习更多关于这种编程风格时作为参考。
- en: 'The code for the asynchronous-based approach can be found in the `chapter12/version4_asyncio`
    folder. You will find four files – the main program, `main.py`, and three class
    definitions: `LED.py`, `BUTTON.py`, and `POT.py`.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 基于异步的方法的代码可以在`chapter12/version4_asyncio`文件夹中找到。您会找到四个文件 - 主程序`main.py`和三个类定义：`LED.py`，`BUTTON.py`和`POT.py`。
- en: Please take the time now to stop and read through the code contained in `main.py` to
    get a basic understanding of how the program is structured and how it works. Then
    proceed to review `LED.py`, `BUTTON.py`, and `POT.py`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请花时间停下来阅读`main.py`中包含的代码，以基本了解程序的结构和工作原理。然后继续查看`LED.py`，`BUTTON.py`和`POT.py`。
- en: If you are also a JavaScript developer – particularly Node.js – you will already
    know that JavaScript is an asynchronous programming language; however, it looks
    and feels very different from what you are seeing in Python! I can assure you
    that the principles are the same. Here is a key reason why they feel very different
    – JavaScript is *asynchronous by default.* As any experienced Node.js developer
    knows, we often have to go to (often extreme) lengths in code to make parts of
    our code behave synchronously. The opposite is true for Python – it's *synchronous
    by default*, and we need to extend extra programming effort to make parts of our
    code behave asynchronously.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您也是JavaScript开发人员 - 特别是Node.js - 您可能已经知道JavaScript是一种异步编程语言；但是，它看起来和感觉起来与您在Python中看到的非常不同！我可以向您保证，原则是相同的。以下是它们感觉非常不同的一个关键原因
    - JavaScript是*默认异步*的。正如任何有经验的Node.js开发人员所知道的，我们经常不得不在代码中采取（通常是极端的）措施来使我们的代码部分表现出同步行为。对于Python来说，情况正好相反
    - 它是*默认同步*的，我们需要额外的编程工作来使我们的代码部分表现出异步行为。
- en: 'As you read through the source code files, I want you to think about our `version4`
    AsyncIO program as having elements of both the `version1` event-loop-based program
    and the `version2` threaded/callback program. Here is a summary of the key differences
    and similarities:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当您阅读源代码文件时，我希望您将我们的`version4` AsyncIO程序视为同时具有`version1`基于事件循环的程序和`version2`线程/回调程序的元素。以下是关键差异和相似之处的摘要：
- en: The overall program structure is very similar to the `version2` thread/callback
    example.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整体程序结构与`version2`线程/回调示例非常相似。
- en: At the end of `main.py`, we have a few new lines of code that we have not seen
    in this book before – for example, `loop = asyncio.get_event_loop()`.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`main.py`的末尾，我们有几行新的代码，在这本书中我们以前没有见过 - 例如，`loop = asyncio.get_event_loop()`。
- en: Like the `version2` program, we have used OOP techniques to factor our components
    into classes, which also have a `run()` method – but notice how there is no thread
    instance in these classes and no code related to starting a thread.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像`version2`程序一样，我们使用了面向对象编程技术将组件分解为类，这些类也有一个`run()`方法 - 但请注意这些类中没有线程实例，也没有与启动线程相关的代码。
- en: In the class definition files, `LED.py`, `BUTTON.py`, and `POT.py`, we have
    the `async` and `await` keywords sprinkled around and in the `run()` function,
    and a delay of 0 seconds in the `while` loop – that is, `asyncio.sleep(0)` – so
    we're not really sleeping at all!
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类定义文件`LED.py`，`BUTTON.py`和`POT.py`中，我们在`run()`函数中使用了`async`和`await`关键字，并在`while`循环中延迟了0秒
    - 也就是说，`asyncio.sleep(0)` - 因此我们实际上并没有睡觉！
- en: In `BUTTON.py`, we are no longer using the PiGPIO callback to monitor a button
    being pressed, but instead polling the button GPIO in a `while` loop.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`BUTTON.py`中，我们不再使用PiGPIO回调来监视按钮被按下，而是在`while`循环中轮询按钮的GPIO。
- en: The Python 3 AsyncIO library has evolved significantly over time (and still
    is evolving), with new API conventions, the addition of higher-level functionality.
    and deprecated functions. Due to this evolution, code can get out of date with
    the latest API conventions quickly, and two code examples illustrating the same
    underlying concepts can be using seemingly different APIs. I highly recommend
    you glance through the latest Python AsyncIO library API documentation as it will
    give you hints and examples of newer versus older API practices, which may help
    you better interpret code examples.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3的AsyncIO库随着时间的推移发生了显著的演变（并且仍在演变），具有新的API约定，更高级功能的添加和废弃的函数。由于这种演变，代码可能会很快地与最新的API约定过时，两个代码示例展示了相同的基本概念，但可能使用看似不同的API。我强烈建议您浏览最新的Python
    AsyncIO库API文档，因为它将为您提供有关新旧API实践的提示和示例，这可能有助于您更好地解释代码示例。
- en: I will explain how this program works by walking you through the high-level
    program flow in a simplified way. When you can grasp the general idea of what
    is happening, you are well on your way to understanding asynchronous programming
    in Python.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过以简化的方式引导您了解程序的高级程序流程来解释这个程序是如何工作的。当您能够掌握正在发生的一般情况时，您就已经在理解Python中的异步编程方面迈出了重要的一步。
- en: You will also find a file named `chapter12/version4_asyncio/main_py37.py`. This
    is a Python 3.7+ version of our program. It uses an API available since Python
    3.7\. If you look through this file, the differences are clearly commented.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会发现一个名为`chapter12/version4_asyncio/main_py37.py`的文件。这是我们程序的Python 3.7+版本。它使用自Python
    3.7以来可用的API。如果您浏览这个文件，差异是清楚地被注释了。
- en: 'At the end of the `main.py` file, we see the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.py`文件的末尾，我们看到以下代码：
- en: '[PRE12]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: An asynchronous program in Python evolves around the event-loop. We see this
    created at line 1 and started at line 5\. We'll come back to the registrations
    occurring in between at lines 2, 3, and 4 momentarily.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的异步程序围绕着事件循环发展。我们在第1行创建了这个事件循环，并在第5行启动了它。我们将在稍后回到在第2、3和4行之间发生的注册。
- en: The overall principle of this asynchronous event-loop is similar to our version1
    event-loop example; however, the semantics are different. Both versions are single-threaded,
    and both sets of code do *go around in a loop*. In `version1`, this was very explicit
    because our main body of code was contained in an outer `while` loop. In our asynchronous
    `version4`, it's more implicit, and has a core difference – it's non-blocking
    *if programmed correctly*, and as we will see soon, this is the purpose of the
    `await asyncio.sleep()` calls in the class `run()` methods.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个异步事件循环的整体原则与我们的version1事件循环示例类似；但是，语义是不同的。两个版本都是单线程的，两组代码都会*在循环中运行*。在`version1`中，这是非常明确的，因为我们的主要代码体包含在外部的`while`循环中。在我们的异步`version4`中，这更加隐含，并且有一个核心的区别——如果编写正确，它是非阻塞的，并且很快我们会看到，这是类`run()`方法中`await
    asyncio.sleep()`调用的目的。
- en: 'As mentioned, we have registered our class `run()` methods with the loop on
    lines 2, 3, and 4\. After we start the event-loop on line 5, here is what happens
    in simplified terms:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，我们已经在第2、3和4行将我们的类`run()`方法注册到循环中。在第5行启动事件循环后，简化来看发生了以下情况：
- en: 'The *first* LED''s `run()` function (shown in the following code) is called:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*第一个*LED的`run()`函数（在下面的代码中显示）被调用：'
- en: '[PRE13]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It enters the `while` loop on line 1 and toggles the LED on or off from line
    2, depending on the blinking rate.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它进入第1行的`while`循环，并根据闪烁速率从第2行切换LED的开关状态。
- en: Next, it gets to line 3, `await asyncio.sleep(0)`, and *yields* control. At
    this point, the `run()` method is effectively paused, and another `while` loop
    iteration does not start.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它到达第3行，`await asyncio.sleep(0)`，并*让出*控制。在这一点上，`run()`方法实际上被暂停了，另一个`while`循环迭代不会开始。
- en: Control is passed over the *second* LED's `run()` function, and it runs through
    it's `while` loop once until it reaches `await asyncio.sleep(0)`. It then yields
    control.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制权转移到*第二个*LED的`run()`函数，并且它通过它的`while`循环运行一次，直到达到`await asyncio.sleep(0)`。然后它让出控制。
- en: 'Now, the pot instance''s `run()` method (shown in the following code) gets
    a turn to run:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，pot实例的`run()`方法（在下面的代码中显示）获得了运行的机会：
- en: '[PRE14]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `run()` method performs one iteration of the `while` loop until it reaches `await
    asyncio.sleep(0)`. It then yields control.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`run()`方法执行`while`循环的一个迭代，直到达到`await asyncio.sleep(0)`。然后它让出控制。'
- en: 'Control is passed to the `button` instance''s `run()` method (partly shown
    in the following code), which has multiple `await asyncio.sleep(0)` statements:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制权转移到`button`实例的`run()`方法（部分显示在下面的代码中），它有多个`await asyncio.sleep(0)`语句：
- en: '[PRE15]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As soon as the button's `run()` method reaches any instance of `await asyncio.sleep(0)`,
    it yields control.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦按钮的`run()`方法达到任何`await asyncio.sleep(0)`的实例，它就会让出控制。
- en: Now, all our registered `run()` methods have had a chance to run, so the *first*
    LED's `run()` method will take control again and perform one `while` loop iteration
    until it reaches `await asyncio.sleep(0)`. Again, at this point it *yields* control
    and the *second* LED's `run()` method gets another turn to run...and the process
    continues over and over, with each `run()` method getting a turn to run in a round-robin
    fashion.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们所有注册的`run()`方法都有机会运行，所以*第一个*LED的`run()`方法将再次控制并执行一个`while`循环迭代，直到达到`await
    asyncio.sleep(0)`。同样，在这一点上它*让出*控制，*第二个*LED的`run()`方法再次获得运行的机会...这个过程一遍又一遍地继续进行，每个`run()`方法以轮流的方式获得运行的机会。
- en: 'Let''s tie up a few loose ends where you will likely have questions:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决一些可能会有问题的问题：
- en: What about the button's `run()` function with its many `await asyncio.sleep(0)`
    statements?
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么按钮的`run()`函数和它的许多`await asyncio.sleep(0)`语句呢？
- en: When control is yielded at any `await asyncio.sleep(0)` statement, the function
    yields at this point. The next time the `run()` button gets control, the code
    will continue from the next statement beneath the `await asyncio.sleep(0)` statement
    that yielded.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当在任何`await asyncio.sleep(0)`语句处*让出*控制时，函数就在这一点上让出。下一次`run()`按钮获得控制时，代码将从`await
    asyncio.sleep(0)`语句下面的下一个语句继续执行。
- en: Why is the sleep delay 0 seconds?
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么睡眠延迟为0秒？
- en: Awaiting a zero-delay sleep is the simplest way to yield control (and please
    note that it is the `sleep()` function from the `asyncio` library, not the `sleep()`
    function from the `time` library). However, you can `await` any asynchronous method,
    but this is beyond the scope for our simple example.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 等待零延迟睡眠是放弃控制的最简单方法（请注意，这是`asyncio`库的`sleep()`函数，而不是`time`库的`sleep()`函数）。然而，你可以`await`任何异步方法，但这超出了我们简单示例的范围。
- en: I have used zero-second delays for this example for simplicity in explaining
    how the program works, but you can use non-zero delays. All this means is that
    the yielding `run()` function would sleep for this period – the event-loop will
    not give it a turn to run until this period expires.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这个例子中使用了零秒延迟，以简化解释程序的工作原理，但你也可以使用非零延迟。这只是意味着放弃控制的`run()`函数会在这段时间内休眠 - 直到这段时间过去，事件循环才会让它运行。
- en: What about the `async` and `await` keywords – how do I know where to use them?
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么`async`和`await`关键字呢？我怎么知道在哪里使用它们？
- en: 'This certainly comes with practice; however, here are the basic design rules:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然需要练习；然而，这里有一些基本的设计规则：
- en: If you are registering a function (for example, `run()`) with the event-loop,
    the function must start with the `async` keyword.
  id: totrans-243
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你要向事件循环注册一个函数（例如`run()`），那么这个函数必须以`async`关键字开头。
- en: Any `async` function must contain at least one `await` statement.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何`async`函数必须包含至少一个`await`语句。
- en: Writing and learning asynchronous programs takes practice and experimentation.
    One of the initial design challenges you will face is knowing where to put `await`
    statements (and how many), and how long you should yield control for. I encourage
    you to play with the `version4` code base, add in your own debugging `print()` or
    logging statements, and just experiment and tinker until you get a feel for how
    it all fits together. At some point, you'll have that *aha* moment, and at that
    point, you have just opened the door to further explore the many advanced features
    offered by the Python AsyncIO libraries.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 编写和学习异步程序需要练习和实验。你将面临的一个最初的设计挑战是知道在哪里放置`await`语句（以及有多少个），以及你应该放弃控制多长时间。我鼓励你玩一下`version4`代码库，添加你自己的调试`print()`或日志语句，然后进行实验和调试，直到你对它如何组合在一起有了感觉。在某个时候，你会有那个“啊哈”时刻，那时，你刚刚打开了进一步探索Python
    AsyncIO库提供的许多高级功能的大门。
- en: Now that we have seen how an asynchronous program is structured and behaves
    at runtime, I want to give you something to experiment with and ponder.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了异步程序在运行时的结构和行为，我想给你一些可以进行实验和思考的东西。
- en: An asynchronous experiment
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步实验
- en: Let's try an experiment. Maybe you've wondered how `version4` (AsyncIO) is a
    bit like our `version1` (event-loop) code, only it's been refactored into classes
    just like the `version2` (threaded) code. So, couldn't we just refactor the code
    in the `version1 while` loop into classes, create and call a function them (for
    example, `run()`) in the `while` loop, and not bother with all the asynchronous
    stuff and its extra library and syntax?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试。也许你想知道为什么`version4`（AsyncIO）有点像我们的`version1`（事件循环）代码，只是它已经重构成类，就像`version2`（线程）代码一样。那么，我们是否可以将`version1
    while`循环中的代码重构成类，创建并调用一个函数（例如`run()`）在`while`循环中，而不必理会所有的异步内容及其额外的库和语法？
- en: Let's try. You will find a version just like this in the `chapter12/version5_eventloop2`
    folder. Try running this version, and see what happens. You'll find that the first
    LED blinks, the second one is always on, and that the button and potentiometer do
    not work.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试。你会在`chapter12/version5_eventloop2`文件夹中找到一个与此类似的版本。尝试运行这个版本，看看会发生什么。你会发现第一个LED会闪烁，第二个LED会一直亮着，按钮和电位器不起作用。
- en: Can you work out why?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想出原因吗？
- en: 'Here''s the simple answer: in `main.py`, once the first LED''s `run()` function
    is called, we''re stuck in its `while` loop forever!'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的答案是：在`main.py`中，一旦第一个LED的`run()`函数被调用，我们就会永远停留在它的`while`循环中！
- en: The call to `sleep()` (from the `time` library) does not yield control; it just
    halts the LED's `run()` method for the duration before the next `while` loop iteration
    occurs.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`sleep()`（来自`time`库）不会放弃控制；它只是在下一个`while`循环迭代发生之前暂停LED的`run()`方法。
- en: Hence, this is an example of why we say synchronous programs are blocking (no
    yielding of control), and why asynchronous programs are non-blocking (they yield
    control and give other code a chance to run).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是为什么我们说同步程序是阻塞的（不会放弃控制），而异步程序是非阻塞的（它们放弃控制并让其他代码有机会运行）的一个例子。
- en: I hope you have enjoyed our exploration of four alternative ways of structuring
    electronic-interfacing programs – and one way we shouldn't. Let's conclude by
    recapping what we have learned in this chapter.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你喜欢我们探索了四种不同的构建电子接口程序的方法，以及我们不应该使用的方法。让我们通过回顾本章学到的内容来结束。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at four different way of structuring a Python program
    that interface with electronics. We learned about an event-loop approach to programming,
    two variations on a thread-based approach – callbacks and a publisher-subscriber
    model – and finished by looking at how an AsyncIO approach to programming works.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了四种不同的Python程序与电子设备接口的结构方式。我们了解了一种基于事件循环的编程方法，两种基于线程的变体 - 回调和发布-订阅模型
    - 最后看了一下异步编程的工作方式。
- en: Each of the four examples we covered was very discrete and specific in its approach.
    While we briefly discussed the relative benefits and pitfalls of each approach
    along the way, it's worth remembering that in practice, your projects will likely
    use a mixture of these (and potentially other) approaches, depending on the programming
    and interfacing goals you are trying to achieve.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的四个例子都在方法上非常具体和离散。虽然我们在讨论过程中简要讨论了每种方法的相对优势和缺点，但值得记住的是，在实践中，你的项目可能会使用这些方法的混合（可能还有其他方法），这取决于你试图实现的编程和接口目标。
- en: In the next chapter, we will turn our attention toward IoT platforms and present
    a discussion of the various options and alternatives that are available for building
    IoT programs.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把注意力转向物联网平台，并讨论可用于构建物联网程序的各种选项和替代方案。
- en: Questions
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    of this chapter''s material. You will find the answers in the *Assessments* section
    of the book:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有一些问题供您测试本章内容的知识。您可以在书的“评估”部分找到答案：
- en: When is a publisher-subscriber model a good design approach?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布者-订阅者模型何时是一个好的设计方法？
- en: What is the Python GIL, and what implication does it present for classic threading?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python GIL是什么，对于经典线程有什么影响？
- en: Why is a pure event-loop usually a poor choice for complex applications?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么纯事件循环通常不适合复杂的应用程序？
- en: Is an event-loop approach a bad idea? Why or why not?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件循环方法是一个坏主意吗？为什么？
- en: What is the purpose of the `thread.join()` function call?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`thread.join()`函数调用的目的是什么？'
- en: You have used a thread to poll your new analog component via an analog-to-digital
    converter. However, you find that your code behaves sluggishly to changes in the
    component. What could be the problem?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您已经使用线程通过模拟数字转换器来轮询您的新模拟组件。然而，您发现您的代码对组件的变化反应迟缓。可能的问题是什么？
- en: Which is the superior approach to designing an IoT or electronic interfacing
    application in Python – using an event-loop, a thread/callback, the publisher-subscriber
    model, or an AsyncIO-based approach?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python中设计物联网或电子接口应用的优越方法是什么——使用事件循环、线程/回调、发布者-订阅者模型还是基于AsyncIO的方法？
- en: Further reading
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The [realpython.com](https://realpython.com) website has a range of excellent
    tutorials covering all things concurrency in Python, including the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[realpython.com](https://realpython.com)网站提供了一系列优秀的教程，涵盖了Python中的并发编程，包括以下内容：'
- en: What is the Python GIL? [https://realpython.com/python-gil](https://realpython.com/python-gil)
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python GIL是什么？[https://realpython.com/python-gil](https://realpython.com/python-gil)
- en: Speed Up Your Python Program with Concurrency: [https://realpython.com/python-concurrency](https://realpython.com/python-concurrency)
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过并发加速您的Python程序：[https://realpython.com/python-concurrency](https://realpython.com/python-concurrency)
- en: An Intro to Threading in Python: [https://realpython.com/intro-to-python-threading](https://realpython.com/intro-to-python-threading)
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中线程的介绍：[https://realpython.com/intro-to-python-threading](https://realpython.com/intro-to-python-threading)
- en: 'Async IO in Python: A Complete Walkthrough: [https://realpython.com/async-io-python](https://realpython.com/async-io-python)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的异步IO：完整演练：[https://realpython.com/async-io-python](https://realpython.com/async-io-python)
- en: 'The following are relevant links from the official Python (3.7) API documentation:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是来自官方Python（3.7）API文档的相关链接：
- en: Threading: [https://docs.python.org/3.7/library/threading.html](https://docs.python.org/3.7/library/threading.html)
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程：[https://docs.python.org/3.7/library/threading.html](https://docs.python.org/3.7/library/threading.html)
- en: The AsyncIO library: [https://docs.python.org/3.7/library/asyncio.htm](https://docs.python.org/3.7/library/asyncio.htm)
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AsyncIO库：[https://docs.python.org/3.7/library/asyncio.htm](https://docs.python.org/3.7/library/asyncio.htm)
- en: Developing with AsyncIO: [https://docs.python.org/3.7/library/asyncio-dev.html](https://docs.python.org/3.7/library/asyncio-dev.html)
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AsyncIO进行开发：[https://docs.python.org/3.7/library/asyncio-dev.html](https://docs.python.org/3.7/library/asyncio-dev.html)
- en: Concurrency in Python: [https://docs.python.org/3.7/library/concurrency.html](https://docs.python.org/3.7/library/concurrency.html)
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的并发编程：[https://docs.python.org/3.7/library/concurrency.html](https://docs.python.org/3.7/library/concurrency.html)
