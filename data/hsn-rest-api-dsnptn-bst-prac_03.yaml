- en: Essential RESTful API Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要的RESTful API模式
- en: This chapter provides both the concepts and code examples of common and fundamental
    design patterns of the RESTful API so that you can pick up these examples and
    replicate and power their RESTful API services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了RESTful API常见和基本设计模式的概念和代码示例，以便您可以挑选这些示例并复制和增强它们的RESTful API服务。
- en: As design patterns provide generic, time-tested, proven, and reusable solutions
    to familiar yet recurring design problems, API design patterns are essential for
    software designers to learn and adapt in their RESTful API applications. API design
    patterns provide a description or templates to solve specific, recurring API design
    problems that any software architects and API designers would like to adopt in
    their API designs. Adopting patterns provides much flexibility to developers and
    helps them focus on business logic implementation and deliver the service with
    high quality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设计模式提供了通用的、经过时间考验的、经过验证的和可重用的解决方案，以解决熟悉但反复出现的设计问题，因此API设计模式对于软件设计师在他们的RESTful
    API应用中学习和适应是必不可少的。API设计模式提供了解决特定、反复出现的API设计问题的描述或模板，任何软件架构师和API设计师都希望在他们的API设计中采用。采用模式为开发者提供了很大的灵活性，并帮助他们专注于业务逻辑实现，以高质量交付服务。
- en: 'As part of this chapter, we will learn the following common yet essential API
    design patterns, along with a few sample pieces of code as well. However, please
    note that there is no specific order to the following patterns and each pattern
    addresses the RESTful constraints. We also need to ensure that these essential
    patterns are accounted and ingrained as needed for our API designs and implementation
    patterns:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的一部分，我们将学习以下常见且重要的API设计模式，以及一些代码示例。然而，请注意，以下模式没有特定的顺序，每个模式都针对RESTful约束。我们还需要确保这些基本模式在我们的API设计和实现模式中得到了考虑和内化：
- en: Statelessness
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态
- en: Content negotiation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容协商
- en: URI templates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI模板
- en: Design for intent
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对意图进行设计
- en: Pagination
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页
- en: Discoverability
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可发现性
- en: Error and exception logging
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误和异常记录
- en: Unicode
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As we will take a plunge into the code and samples, and a few pattern implementations
    in this chapter, the readers are expected to have a Java programming language
    and understand the basic concepts of Java 1.8\. Our examples are implemented with
    Spring Boot and we have provided instructions to download and run the sample codes
    anywhere. However, for those who want to execute and test the code samples provided
    in this chapter, they may need to have the basic and necessary understanding of
    data formats such as JSON and XML, and also have a basic understanding of a Maven
    build process and client-server or web services development.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在本章中深入代码和示例，以及一些模式实现，因此读者应具备Java编程语言的知识并理解Java 1.8的基本概念。我们的示例使用Spring Boot实现，并提供了在任何地方下载和运行示例代码的说明。然而，对于那些想要执行和测试本章提供的代码示例的人来说，他们可能需要具备对数据格式（如JSON和XML）的基本和必要的理解，以及对于Maven构建过程和客户端/服务器或Web服务开发的基本理解。
- en: The following is the GitHub link for this chapter: [https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices.git](https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices.git).[ ](https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices.git)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为本章的GitHub链接：[https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices.git](https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices.git).[ ](https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices.git)
- en: 'For the code to run in your computer, you need Java 8, Spring 4 (1.4.4), and
    Maven 3.x. Please follow the following instructions to get started. The following
    are the prerequisites for this chapter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的计算机上运行代码，您需要Java 8、Spring 4（1.4.4）和Maven 3.x。请按照以下说明开始。以下为本章的先决条件：
- en: Java 1.8
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 1.8
- en: Maven 3.2
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven 3.2
- en: Your favorite IDE (optional)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您喜欢的IDE（可选）
- en: Command-line
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行
- en: Postman
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Postman
- en: To start with, please download or clone the samples from GitHub. There are various
    online help resources available in case anyone needs help in downloading the samples
    to their local machines.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请从GitHub下载或克隆示例。如果有人需要帮助将示例下载到本地机器，有多种在线帮助资源可用。
- en: Beginning with the installations
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从安装开始
- en: If you don't have JDK or Maven installed in your environment yet, you may want
    to install it now by following their respective installation instructions. We
    need Maven installed on our machines, and we can run the program with IDEs as
    well. The following instructions cover how to run these samples with Windows command-line,
    along with the maven command line.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您环境中还没有安装JDK或Maven，您可能需要现在按照它们各自的安装说明进行安装。我们需要在我们的机器上安装Maven，并且我们还可以使用IDE运行程序。以下说明涵盖了如何使用Windows命令行和maven命令行运行这些示例。
- en: If you need Maven installation instructions, please follow the link and steps
    defined in the installation document. The Maven installation guide is available
    at [https://maven.apache.org/install.html](https://maven.apache.org/install.html).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要Maven的安装说明，请按照安装文档中定义的链接和步骤进行操作。Maven安装指南可在[https://maven.apache.org/install.html](https://maven.apache.org/install.html)找到。
- en: 'The following section provides instructions on how to run the examples of this
    chapter, along with screenshots that the author was able to set up and run in
    his Windows-based laptop:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分提供了如何运行本章示例的说明，以及作者在其基于Windows的笔记本电脑上能够设置和运行的截图：
- en: Download the build script from [Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/scripts/buildMyExamples.bat](https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/blob/master/scripts/buildMyExamples.bat).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从[Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/scripts/buildMyExamples.bat](https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/blob/master/scripts/buildMyExamples.bat)下载构建脚本。
- en: 'Run the downloaded `buildMyExample.bat` script in your Windows Command Prompt
    and observe your output, which should be similar to what you can see in the following
    screenshot:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的Windows命令提示符中运行下载的`buildMyExample.bat`脚本，并观察您的输出，它应该与以下截图中的类似：
- en: '![](img/d40a8af4-84ea-4596-9bd5-16caaf99956e.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d40a8af4-84ea-4596-9bd5-16caaf99956e.png)'
- en: 'Download the run script from [Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/scripts/runMyExamples.bat](https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/blob/master/scripts/runMyExamples.bat).
    Observe the following screenshot and match it with your Windows command-line output:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从[Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/scripts/runMyExamples.bat](https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/blob/master/scripts/runMyExamples.bat)下载运行脚本。观察以下截图，并将其与您的Windows命令行输出进行匹配：
- en: '![](img/28f94f2a-1a74-4c7c-a51b-2d2bee315512.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/28f94f2a-1a74-4c7c-a51b-2d2bee315512.png)'
- en: 'Once your local server has started, you can download the sample Postman collections
    for this book from the following GitHub link: [https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/blob/master/scripts/book-examples.postman_collection.json](https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/blob/master/scripts/book-examples.postman_collection.json).
    Import the collection to your local Postman tool, then run the mentioned examples
    in this chapter and witness the results in your Postman as you see in the following
    screenshot:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦您的本地服务器启动，您可以从以下GitHub链接下载本书的示例Postman集合：[https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/blob/master/scripts/book-examples.postman_collection.json](https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/blob/master/scripts/book-examples.postman_collection.json)。将集合导入到您的本地Postman工具中，然后运行本章中提到的示例，并像以下截图所示在您的Postman中查看结果：
- en: '![](img/41d14f24-6cec-45f9-b738-1bc4dc5363d2.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/41d14f24-6cec-45f9-b738-1bc4dc5363d2.png)'
- en: If you need help on installing Postman, you may find this link useful: [https://learning.getpostman.com/docs/postman/launching_postman/installation_and_updates/](https://learning.getpostman.com/docs/postman/launching_postman/installation_and_updates/).
    If you need help importing the Postman collections to your local Postman installation,
    you may find this link useful: [https://learning.getpostman.com/docs/postman/collections/data_formats/#exporting-and-importing-postman-data](https://learning.getpostman.com/docs/postman/collections/data_formats/#exporting-and-importing-postman-data).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要安装Postman的帮助，您可能会发现此链接很有用：[https://learning.getpostman.com/docs/postman/launching_postman/installation_and_updates/](https://learning.getpostman.com/docs/postman/launching_postman/installation_and_updates/)。如果您需要帮助将Postman集合导入到您的本地Postman安装中，您可能会发现此链接很有用：[https://learning.getpostman.com/docs/postman/collections/data_formats/#exporting-and-importing-postman-data](https://learning.getpostman.com/docs/postman/collections/data_formats/#exporting-and-importing-postman-data)。
- en: Beginning with RESTful API patterns – part I
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从RESTful API模式开始 - 第一部分
- en: 'This chapter covers the most common and necessary REST services design patterns
    to aid API designers and developers in API development in various domains. The
    design patterns included in this section are as follow:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了最常见和必要的 REST 服务设计模式，以帮助 API 设计师和开发者在各个领域的 API 开发中。本节包含的设计模式如下：
- en: Statelessness
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态
- en: Content negotiation
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容协商
- en: URI templates
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI 模板
- en: Design for intent
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计意图
- en: Pagination
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页
- en: Discoverability
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可发现性
- en: Error and exception logging
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误和异常记录
- en: Unicode
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode
- en: Statelessness
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态
- en: Statelessness refers to servers being free from application states, that is,
    the states that are stored at the server side and help to identify the client's
    requests, client's last interaction details, and their current context information.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态指的是服务器摆脱应用状态，即存储在服务器端并帮助识别客户端请求、客户端最后交互细节及其当前上下文信息的状态。
- en: The REST architecture enforces the server *not* to maintain any client states
    at the server side and insists on statelessness between the server and the calling
    client. Any API developer certainly does not want to store state information at
    the application server side. So, the application server should always be designed
    as state-free (in most cases).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: REST 架构强制服务器**不**在服务器端维护任何客户端状态，并坚持服务器与调用客户端之间的无状态性。任何 API 开发者当然不希望在应用服务器端存储状态信息。因此，应用服务器应该始终设计为无状态（在大多数情况下）。
- en: 'Let''s observe a few responsibilities for both the client and server so that
    we can achieve statelessness:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们观察客户端和服务器的一些责任，以便我们实现无状态性：
- en: '| **Client** | **Server** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **客户端** | **服务器** |'
- en: '| A client should provide all necessary information to the server as part of
    its request to the server. | The server understands the client''s request and
    should include all the necessary information as a response that a client needs
    to create a session on its side. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 客户端应将其请求中所有必要的信息提供给服务器。 | 服务器理解客户端的请求，并应在响应中包含客户端创建会话所需的所有必要信息。 |'
- en: '| Session states should entirely be managed and kept at the client side. |
    The server does not store the client state and doesn''t rely on its stored context.
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 会话状态应完全由客户端管理和保持。 | 服务器不存储客户端状态，也不依赖于其存储的上下文。 |'
- en: '| The client is responsible for storing and handling all its states and sends
    state information to the server whenever it is needed. | No session affinity or
    session stickiness on the server is to be maintained. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 客户端负责存储和处理所有其状态，并在需要时将状态信息发送到服务器。 | 服务器上不维护任何会话亲和性或会话粘性。 |'
- en: To comply with RESTful constraints, and for the service to be genuinely stateless,
    the servers don't even store the authentication/authorization information of the
    client and make clients provide credentials with their request. So, each request
    is understood separately by the server and there is no impact on the current request
    due to previous requests from the same clients.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵守 RESTful 约束，并且为了服务真正实现无状态，服务器甚至不存储客户端的认证/授权信息，并要求客户端在请求中提供凭证。因此，服务器会单独理解每个请求，并且之前的请求对当前请求没有影响。
- en: In our chapter code example, we can observe that none of our requests and responses
    are associated with/carry any state information and they are entirely independent.
    Even in later sections when we will develop authentication examples, our code
    will still evolve and maintain statelessness across its life cycle.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们章节的代码示例中，我们可以观察到，我们的所有请求和响应都与/携带任何状态信息无关，它们是完全独立的。即使在后面的章节中，当我们开发认证示例时，我们的代码仍然会发展和保持在其生命周期中的无状态性。
- en: 'For stateless constraints, how do we code? Spring Boot''s REST API framework
    provides out-of-the-box implementation; our responsibility as a developer is to
    ensure we follow URI constraints and provide the necessary implementation for
    the URI. In the following code snippet from our example, `InvestorController.java`,
    we have a URI (`/investors/{investorId}/stocks` ) defined for fetching the stock
    of an investor by the investor ID; that''s all—we do not have any specific implementation,
    session validation, and so on:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无状态约束，我们如何编码？Spring Boot 的 REST API 框架提供了现成的实现；作为开发者，我们的责任是确保我们遵循 URI 约束，并为
    URI 提供必要的实现。在以下代码片段中，来自我们的示例，`InvestorController.java`，我们定义了一个 URI (`/investors/{investorId}/stocks`
    )，用于通过投资者 ID 获取投资者的股票；仅此而已——我们没有任何特定的实现，会话验证等：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As the path element doesn't have any indications of state, and the code expects
    an `investorId` along with a few other parameters, our implementation is fulfilling
    the stateless constraints. This will be more interesting when we deal with authentication
    (also with statelessness) in the next chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于路径元素没有任何状态指示，并且代码期望一个`investorId`以及一些其他参数，我们的实现满足了无状态约束。这将在我们处理下一章中的身份验证（也是无状态的）时更有趣。
- en: 'Let''s also observe the necessities and a few advantages of enforcing statelessness
    in RESTful services through the following table:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下表格观察强制RESTful服务无状态化的必要性和一些优点：
- en: '| **Advantages** | **Details** |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **优点** | **细节** |'
- en: '| Scalability | Achieve scalability by having server code that''s been deployed
    to multiple servers so that any server can handle any requests as there is no
    session stickiness/affinity to be maintained by the server. This occurs since
    the client''s requests will have all the necessary information in each request
    for to the server manage. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 可扩展性 | 通过将服务器代码部署到多个服务器上，实现可扩展性，这样任何服务器都可以处理任何请求，因为服务器不需要维护会话粘性/亲和力。这是因为客户端的请求将包含服务器管理所需的所有必要信息。|'
- en: '| Reduced complexity | There is reduced complexity as the server can get rid
    of server-side state synchronization logic and implementations (leads to simplified
    application design). |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 简化复杂性 | 由于服务器可以摆脱服务器端状态同步逻辑和实现（导致简化了应用程序设计），因此复杂性降低。|'
- en: '| Easy cache-ability, so improved performance | The intermediate software can
    cache the results of specific HTTP requests by looking at the client''s requests.
    Also, there are no uncertainties and concerns about the state information of the
    previous requests. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 易于缓存，因此性能提升 | 中间件软件可以通过查看客户端请求来缓存特定HTTP请求的结果。此外，关于先前请求的状态信息没有不确定性和担忧。|'
- en: '| Traceability | The server never loses track of where each client is in the
    application as the client requests themselves have all the necessary information.
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 可追踪性 | 由于客户端请求本身包含所有必要信息，服务器永远不会失去对每个客户端在应用程序中位置的跟踪。|'
- en: '| Best use of HTTP/HTTPS | As HTTP itself is a stateless protocol. REST implementation
    becomes seamless with HTTP protocols (it adheres well to REST constraints). |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 最佳使用HTTP/HTTPS | 由于HTTP本身是一个无状态协议，REST实现与HTTP协议无缝结合（它很好地遵循REST约束）。|'
- en: Content negotiation
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容协商
- en: The resources in the RESTful APIs need to deal with different type of representations—not
    just XML or **JavaScript Object Notation** (**JSON**), as different clients may
    need different representations. In fact, as we build our complex APIS, we may
    find that XML/JSON is too limiting, and we may need to move to another type of
    content in an entirely different format (Instagram and Flickr use JPEG and PNG
    images, while media houses use MP3/MP4), and that's how we get to content negotiation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API中的资源需要处理不同类型的表示，不仅仅是XML或**JavaScript对象表示法**（**JSON**），因为不同的客户端可能需要不同的表示。实际上，随着我们构建复杂API，我们可能会发现XML/JSON过于限制，我们可能需要转向另一种完全不同格式的内容（Instagram和Flickr使用JPEG和PNG图像，而媒体机构使用MP3/MP4），这就是我们如何进行内容协商的。
- en: '**Content-negotiation** is a mechanism or process that services and clients
    can select as their resources representation format for their communication and
    handshakes during their usual course of communication.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容协商**是一种机制或过程，服务和客户端可以在它们通常的通信过程中选择作为它们资源表示格式的通信和握手。'
- en: As we saw in [Chapter 2](edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml), *Design
    Strategy, Guidelines, and Best Practices*, in the *HTTP headers* section, the
    HTTP specification comes up with a set of standard headers, through which the
    client can get information about a requested resource and carry the messages that
    indicate its representations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml)，“设计策略、指南和最佳实践”，在*HTTP头*部分所看到的，HTTP规范提出了一组标准头，客户端可以通过这些头获取有关请求资源的信息，并携带指示其表示的消息。
- en: So, for content negotiation, REST services need to use HTTP headers; that is,
    when the client makes requests, it includes the accepts header, the list of file
    types that the client and server can handle with no additional steps to the client
    requests, the server processes, and replies.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于内容协商，REST服务需要使用HTTP头；也就是说，当客户端发起请求时，它包括接受头，客户端和服务器可以处理的文件类型列表，无需对客户端请求、服务器处理和回复采取额外步骤。
- en: If the response representation selection is determined at the server-side, then
    it is server-driven negotiation or proactive negotiation using request-headers.
    If the same selection is at the client side, then it is agent-driven content negotiation
    or reactive negotiation using distinct a URI. For most practical purposes, server-side
    negotiations are more complex and lead to make many assumptions about client requirements.
    So, most of the REST API implementations follow agent-driven content negotiations
    that rely on the HTTP request headers or resource URI patterns.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应表示的选择是在服务器端确定的，那么它是服务器驱动的协商或使用请求头的主动协商。如果同样的选择是在客户端，那么它是代理驱动的内容协商或使用不同URI的反应式协商。对于大多数实际用途，服务器端协商更为复杂，并且需要对客户端需求做出许多假设。因此，大多数REST
    API实现遵循代理驱动的内容协商，这依赖于HTTP请求头或资源URI模式。
- en: 'Let us look at a quick and live example of content negotiation by going to
    the following link: [http://www.w3.org/StyleSheets/TR/logo-REC](http://www.w3.org/StyleSheets/TR/logo-REC).
    Observe that logo-REC is an image file; however, it does not have any file extension
    (that is, w3.org serving images without a file suffix), and the log-REC is not
    just one file, but two—`loge-REC.gif` and `logo-REC.png`. So, with content-negotiation
    the w3.org server serves two different files. The following screenshot explains
    a bit more about the request and response headers for the same:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下链接快速查看一个内容协商的实时例子：[http://www.w3.org/StyleSheets/TR/logo-REC](http://www.w3.org/StyleSheets/TR/logo-REC)。观察一下，logo-REC是一个图像文件；然而，它没有任何文件扩展名（即，w3.org在没有任何文件后缀的情况下提供图像），而log-REC不仅仅是一个文件，而是两个——`loge-REC.gif`和`logo-REC.png`。因此，通过内容协商，w3.org服务器提供了两个不同的文件。以下截图解释了更多关于相同请求和响应头的信息：
- en: '![](img/d792f267-caa2-472d-b23c-e5e38478daf2.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d792f267-caa2-472d-b23c-e5e38478daf2.png)'
- en: Please observe the highlighted pieces from the preceding screenshot. The URL
    path, [http://www.w3.org/StyleSheets/TR/logo-REC](http://www.w3.org/StyleSheets/TR/logo-REC),
    does not say any file extension; however, in the response headers, observe the
    **content-location** and the **content-type** as `image/png`. The highlighted
    rectangles are quick examples of some of the content negotiation. Also please
    observe reactive negotiation through the request header accept.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前一个截图中突出显示的部分。URL路径，[http://www.w3.org/StyleSheets/TR/logo-REC](http://www.w3.org/StyleSheets/TR/logo-REC)，没有说明任何文件扩展名；然而，在响应头中，观察**content-location**和**content-type**为`image/png`。突出显示的矩形是一些内容协商的快速示例。同时，请观察通过请求头accept进行的反应式协商。
- en: Let's get into the details about content negotiation and the way the services/clients
    use them in the following paragraphs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来详细讨论内容协商以及服务/客户端如何使用它们。
- en: Content negotiation with HTTP headers
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTP头进行内容协商
- en: With our earlier example, we have seen that the server understands the content-types
    of incoming requests and entities with HTTP request header content-types.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们之前的例子，我们已经看到服务器理解了传入请求和具有HTTP请求头内容类型的实体的内容类型。
- en: In our code example, we have implemented the following content type and, by
    default `application/JSON`, and to represent what content type that the client
    desired to get, we use `application/JSON`  as the Accept header.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码示例中，我们实现了以下内容类型，默认为`application/JSON`，并且为了表示客户端希望获取的内容类型，我们使用`application/JSON`作为Accept头。
- en: 'Please note that if no Accept header is present in the request, the server
    will send a pre-configured default representation type. In our example, it is
    always `application/JSON`, as shown in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果请求中没有Accept头，服务器将发送预先配置的默认表示类型。在我们的例子中，它始终是`application/JSON`，如下面的截图所示：
- en: '![](img/e8cc437e-5741-4487-91eb-e2c1aa9fda2a.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8cc437e-5741-4487-91eb-e2c1aa9fda2a.png)'
- en: The preceding screenshot depicts the Content-Type and Accept headers from our
    examples.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图展示了我们例子中的Content-Type和Accept头。
- en: 'If we want to implement our earlier example of a w3c image within our investor
    service application  in a similar fashion, all we need to do is add the following
    dependency to `pom.xml`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在我们的投资者服务应用程序中以类似的方式实现我们之前提到的w3c图像示例，我们只需要在`pom.xml`中添加以下依赖项：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Modify the `@GetMapping` annotation in the controller class as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式修改控制器类中的`@GetMapping`注解：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So, by using the accept request header, the client either gets the response
    as XML or as JSON. Cool, isn't it?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过使用accept请求头，客户端要么以XML形式，要么以JSON形式获取响应。酷，不是吗？
- en: 'With Postman, we will get either a XML or JSON response according to the `application/XML`
    or `application/JSON` Accept header value:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Postman，我们将根据`application/XML`或`application/JSON`的`Accept`头信息值获取XML或JSON响应：
- en: '![](img/9587bcd8-1b89-49d5-b386-e154834fbaa8.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9587bcd8-1b89-49d5-b386-e154834fbaa8.png)'
- en: 'Two other ways that we can pass the content type information to the server
    are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将内容类型信息传递给服务器的两种其他方式如下：
- en: 'Using specific extensions in resource URIs:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在资源URI中使用特定扩展：
- en: '[https://xxx.api.com/v1/students/course.xml](https://xxx.api.com/v1/students/course.xml)'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://xxx.api.com/v1/students/course.xml](https://xxx.api.com/v1/students/course.xml)'
- en: '[https://xxx.api.com/v1/students/courses.json](https://xxx.api.com/v1/students/courses.json)'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://xxx.api.com/v1/students/courses.json](https://xxx.api.com/v1/students/courses.json)'
- en: 'Using parameters for representing an extension:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数表示扩展：
- en: '[https://xxx.api.com/v1/students/course?forrmat=xml](https://xxx.api.com/v1/students/course?forrmat=xml)'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://xxx.api.com/v1/students/course?forrmat=xml](https://xxx.api.com/v1/students/course?forrmat=xml)'
- en: '[https://xxx.api.com/v1/students/courses?forrmat=json](https://xxx.api.com/v1/students/courses?forrmat=json)'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://xxx.api.com/v1/students/courses?forrmat=json](https://xxx.api.com/v1/students/courses?forrmat=json)'
- en: 'The following table provides a quick reference guide of a few other content-negotiation
    examples as server and client may need to deal with many other aspects of content-negotiation:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格提供了一个快速参考指南，其中包含一些其他内容协商示例，因为服务器和客户端可能需要处理许多其他内容协商方面：
- en: '| **Content-Negotiation** | **Implementation** |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **内容协商** | **实现** |'
- en: '| Indicate client preference—allows clients to indicate their capabilities
    (such as media types and languages) | `Accept:application/json,application/xml;q=0.9,*/*;q=0.8``(support
    json or xml, q -> preference order)` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 表明客户端偏好——允许客户端表明其能力（如媒体类型和语言）| `Accept:application/json,application/xml;q=0.9,*/*;q=0.8`
    (支持JSON或XML，q -> 偏好顺序) |'
- en: '| Implement media type—how to decide which media type to use for representation
    in a response | According to the Accept header from the client (Accept: `application/atom+xml`),
    the server can respond with a content-type, that is, `Content-Type: application/atom+xml`; `charset=UTF-8`
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 实现媒体类型——如何决定在响应中表示中应使用哪种媒体类型 | 根据客户端的`Accept`头信息（Accept: `application/atom+xml`），服务器可以响应一个内容类型，即`Content-Type:
    application/atom+xml`; `charset=UTF-8` |'
- en: '| Implement character encoding—know what character encoding to use for textual
    representations in responses | `Content-Type: charset=UTF-8` (use content-type
    charset) |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 实现字符编码——了解在响应中的文本表示应使用哪种字符编码 | `Content-Type: charset=UTF-8` (使用content-type
    charset) |'
- en: '| Support compression—know when to enable the compression of representations
    | # Request `Accept-Encoding: gzip`# Response `Content-Encoding: gzip Vary: Accept-Encoding`
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 支持压缩——了解何时启用表示的压缩 | # 请求`Accept-Encoding: gzip`# 响应`Content-Encoding: gzip
    Vary: Accept-Encoding` |'
- en: '| Send Vary header—know how to use the Vary header to indicate to clients how
    the server chooses a particular representation | # Response `Content-Language:
    en Vary: Accept-Language` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 发送Vary头信息——了解如何使用Vary头向客户端指示服务器如何选择特定的表示 | # 响应`Content-Language: en Vary:
    Accept-Language` |'
- en: '| Handling negotiation failures—know whether to serve a default representation
    or return an error | # Request`Accept: application/json,*/*;q=0.0` (client cannot
    process anything other than JSON)# Response`406 Not Acceptable` (the server returns
    an error code as it does not support JSON. `@GetMapping` our chapter examples
    throws this error when the client expects only an XML responses as our example
    serves the JSON and not XML, except for one—a `GET` mapping)Link: `<http://www.example.org/errors/mediatypes.html>`;`rel="help"`{`"message":
    "This server does not support JSON. See help for alternatives."`} (additional
    help) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 处理谈判失败——了解何时提供默认表示或返回错误 | # 请求`Accept: application/json,*/*;q=0.0` (客户端只能处理JSON格式的内容)#
    响应`406 Not Acceptable` (服务器返回错误代码，因为它不支持JSON。`@GetMapping`我们的章节示例在客户端期望只有XML响应时抛出此错误，因为我们的示例提供的是JSON而不是XML，除了一个`GET`映射)链接：`<http://www.example.org/errors/mediatypes.html>`;`rel="help"`{`"message":
    "此服务器不支持JSON。请参阅帮助了解替代方案。"}` (额外帮助) |'
- en: URI templates
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URI模板
- en: As we saw in [Chapter 1](ce158181-8265-4afb-b858-348cc775d6d8.xhtml), *Introduction
    to the Basics of RESTful Architecture,* a**Uniform Resource** **Identifier** (**URI**)
    is often used to identify a specific resource within a common space of similar
    resources. For instance, if we pick up the Star Wars API example from [Chapter
    1](ce158181-8265-4afb-b858-348cc775d6d8.xhtml), *Introduction to the Basics of
    RESTful Architecture*, the films resource is represented by the URIs [https://swapi.co/api/films/2](https://swapi.co/api/films/2), [https://swapi.co/api/films/3](https://swapi.co/api/films/3),
    and so on. It is always the case that the client may need to include some additional
    information in their request, and how the server lets the client include that
    information about resources in the URIs. Server-side developers require the ability
    to describe the layout of the URIs that their services will respond to.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第1章](ce158181-8265-4afb-b858-348cc775d6d8.xhtml)，“RESTful架构基础介绍”中看到的，**统一资源标识符**（**URI**）通常用于在类似资源的公共空间中标识特定的资源。例如，如果我们从[第1章](ce158181-8265-4afb-b858-348cc775d6d8.xhtml)“RESTful架构基础介绍”中选取星球大战API示例，电影资源由以下URI表示：[https://swapi.co/api/films/2](https://swapi.co/api/films/2)，[https://swapi.co/api/films/3](https://swapi.co/api/films/3)，等等。客户端通常需要在他们的请求中包含一些附加信息，以及服务器如何让客户端在URI中包含有关资源的信息。服务器端开发者需要能够描述其服务将响应的URI布局。
- en: 'The answer to this is URI templates. URI templates provide a way to describe
    a set of resources as variables. So, let''s observe the following table with our
    more general examples before we move on go to this chapter''s code examples:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案是URI模板。URI模板提供了一种描述一组资源作为变量的方式。因此，在我们继续前进并查看这一章的代码示例之前，让我们观察以下表格，其中包含我们的更通用示例：
- en: '| **Resources** | **URI templates** |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **资源** | **URI模板** |'
- en: '| People: [https://swapi.co/api/people/](https://swapi.co/api/people/)Planets:
    [https://swapi.co/api/planets/](https://swapi.co/api/planets/)Films: [https://swapi.co/api/films/](https://swapi.co/api/films/)Species:
    [https://swapi.co/api/species/](https://swapi.co/api/species/) | `https://swapi.co/api/{resource_id}/`
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 人物：[https://swapi.co/api/people/](https://swapi.co/api/people/) 行星：[https://swapi.co/api/planets/](https://swapi.co/api/planets/)
    电影：[https://swapi.co/api/films/](https://swapi.co/api/films/) 物种：[https://swapi.co/api/species/](https://swapi.co/api/species/)
    | `https://swapi.co/api/{resource_id}/` |'
- en: '| [https://swapi.co/api/films/2/](https://swapi.co/api/films/2/)[https://swapi.co/api/films/6/](https://swapi.co/api/films/6/)
    | `https://swapi.co/api/{resource_id1}/{resource_id2}` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| [https://swapi.co/api/films/2/](https://swapi.co/api/films/2/)[https://swapi.co/api/films/6/](https://swapi.co/api/films/6/)
    | `https://swapi.co/api/{resource_id1}/{resource_id2}` |'
- en: So, it is clear that if we need to define the URI template for the preceding
    list with variables or resource identifiers, we need to provide those variables
    within curly braces.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，很明显，如果我们需要为上述列表定义带有变量或资源标识符的URI模板，我们需要在花括号内提供这些变量。
- en: 'Now, we will see examples from the code implementation of this chapter which
    have been picked up from the investor-service controller class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到来自本章代码实现的示例，这些示例是从投资者服务控制器类中挑选出来的：
- en: '| `@GetMapping("/investors/{investorId}/stocks")``@GetMapping("/investors/{investorId}/stocks/{symbol}")`
    | The client would need to send an investor ID and a stock symbol for `GET` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `@GetMapping("/investors/{investorId}/stocks")` `@GetMapping("/investors/{investorId}/stocks/{symbol}")`
    | 客户需要发送一个投资者ID和一个股票符号以进行`GET`操作 |'
- en: '| `@DeleteMapping("/investors/{investorId}/stocks/{symbol}")` | The client
    would need to send an investor ID and a stock symbol for `Delete` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `@DeleteMapping("/investors/{investorId}/stocks/{symbol}")` | 客户需要发送一个投资者ID和一个股票符号以进行`Delete`操作
    |'
- en: 'The`@PathVariable` annotation of spring boot does the magic of applying the
    URI template for the resources that the client needs. Please take note of the
    following code snippet from our code (`InvestorController.java`) as an example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot的`@PathVariable`注解为客户端需要的资源应用URI模板的魔法。请注意以下代码片段（来自我们的代码`InvestorController.java`）作为示例：
- en: '[PRE3]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `@PathVariable` annotation provided by Spring Boot help us implement the
    URI template pattern in our code seamlessly. As we can see, `investorId` and the
    symbol variables are picked up as parameters by our methods.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot提供的`@PathVariable`注解帮助我们无缝地实现URI模板模式。正如我们所见，`investorId`和符号变量被我们的方法作为参数提取。
- en: Please note that there are other REST frameworks that do a good job and provide
    out-of-the-box URI templating.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，还有其他REST框架做得很好，并提供开箱即用的URI模板功能。
- en: Design for intent
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计意图
- en: Imagine our car getting repaired without even taking it to an automobile service
    centre. A few years back, Tesla, the car manufacturing company, famously did that
    when it issued an over-the-air repair to their cars. Tesla's software got updated
    to detect charging problems and help decrease the charging rates (cascading effect)
    to avoid overheating and hence avoid engine fires.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们的汽车在没有送到汽车服务中心修理的情况下被修理。几年前，汽车制造公司特斯拉在向其汽车发布空中修复时，就著名地做到了这一点。特斯拉的软件更新以检测充电问题并帮助降低充电速率（级联效应），以避免过热并因此避免发动机火灾。
- en: Design for intent is a term that's used in structural and automobile fields
    for parameterized changes, and we will learn how it benefits REST API services
    as well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 意图设计是一个在结构和汽车领域用于参数化更改的术语，我们将学习它如何使REST API服务受益。
- en: Design for intent is a method that expresses the different relationships between
    objects so that changes to one object automatically propagates changes to others.
    In Tesla's case, the decreased number of charging cycles (cascading effect) helped
    to avoid overheating of the engine.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 意图设计是一种表达对象之间不同关系的方法，以便一个对象的变化会自动传播到其他对象。在特斯拉的案例中，充电周期数量的减少（级联效应）有助于避免发动机过热。
- en: In a RESTful API world, the API should be developed to ensure they meet the
    requirements of the use cases, provided and faced by the users, but without exposing
    the internal business objects. Design for intent is a strategic design pattern
    that's intended to influence or result in specific and additional user behaviors.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在RESTful API世界中，API应该被开发以确保它们满足用户提供的和面临的使用案例的要求，但又不暴露内部业务对象。意图设计是一种旨在影响或导致特定和额外用户行为的战略设计模式。
- en: 'To relate the design for intent implementation within our investor service
    example, we should provide the mechanism to update the investor''s portfolio automatically
    whenever the new (type) stocks get added to the investor object:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们投资者服务示例中的意图实现设计联系起来，我们应该提供一种机制，以便在新的（类型）股票被添加到投资者对象时自动更新投资者的投资组合：
- en: '![](img/701f6963-a5cf-45ae-aa21-dd2f7e67d290.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/701f6963-a5cf-45ae-aa21-dd2f7e67d290.png)'
- en: As you can see in the preceding diagram, the intention of the API is to add
    a new stock; however, it should have a cascading effect on the investor's portfolio
    as well—maybe a new stock type should get added, the total number of stocks needs
    to be updated, and so on. This is abstract to the app developer. The same applies
    when stocks are deleted as well.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上述图中看到的，API的意图是添加一个新的股票；然而，它也应该对投资者的投资组合产生级联效应——也许应该添加新的股票类型，需要更新股票的总数，等等。这抽象于应用开发者。当删除股票时也是如此。
- en: 'Please recollect the granularity of APIs discussion from [Chapter 2](edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml),
    *Design Strategy, Guidelines, and Best Practices*, as choosing the right granularity
    of APIs plays a vital role in the design for intent strategy. In this chapter''s
    example, we have provided a simple update method for adding the stock types to
    the investor''s portfolio, and readers are encouraged to develop more functionalities
    as part of this pattern ensures having the right granularity (coarse-grained versus
    fine-grained) of APIs for the update and delete stock types within an investor''s
    portfolio. Consider the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请回忆一下[第2章](edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml)中关于API粒度的讨论，*设计策略、指南和最佳实践*，因为选择正确的API粒度在意图设计策略中起着至关重要的作用。在本章的示例中，我们提供了一个简单的更新方法，用于向投资者的投资组合添加股票类型，并鼓励读者开发更多功能，因为这种模式确保了具有正确的API粒度（粗粒度与细粒度）来更新和删除投资者投资组合中的股票类型。考虑以下代码：
- en: '[PRE4]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/74b87bb0-0108-4c6d-adbc-5cc5fb182bca.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/74b87bb0-0108-4c6d-adbc-5cc5fb182bca.png)'
- en: The preceding screenshot and code is the sample implementation (code snippets)
    that we can see in `InvestorService.java`. This also shows a console message when
    the `Delete` and `Add` APIs are called with the Postman tool.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图和代码是我们在`InvestorService.java`中可以看到的示例实现（代码片段）。这也显示了当使用Postman工具调用`Delete`和`Add`
    API时，控制台消息的情况。
- en: Pagination
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分页
- en: When a client tries to fetch a list of objects that run into pages, we have
    to think about how the server can manage to serve the clients with such a massive
    response without hampering its performance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端尝试获取一个分页的对象列表时，我们必须考虑服务器如何在不损害其性能的情况下管理向客户端提供如此巨大的响应。
- en: '**Pagination** is a concept that helps in serving only part of the data as
    a response, however, with information about how to access all the data from the
    server, page by page, without much load and high computation for the server to
    serve the whole data.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**分页**是一个概念，它有助于仅作为响应提供部分数据，然而，它提供了如何从服务器逐页访问所有数据的信息，从而减少了服务器提供全部数据的负载和计算量。'
- en: Should we consider a page (of results) as a resource or just a representation
    of resources? Considering the page as a representation and not as a resource is
    what we are going to discuss in this section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否应该将页面（的结果）视为资源或仅仅是资源的表示？将页面视为表示而不是资源是我们将在本节中讨论的内容。
- en: As we decided pagination is a resource representation, we will include the pagination
    information as part of the URI query, that is, `xxx.api.com/stocks?page=2`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们决定分页是资源表示的一部分，我们将分页信息包含在URI查询中，即`xxx.api.com/stocks?page=2`。
- en: Please note that pagination as part of the URI path is not an option (as we
    consider that it is not a resource but resource representation), that is, `xxx.api.com/stocks/page/2`,
    as we may not be able to uniquely find the resource between calls.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，作为URI路径一部分的分页不是一个选项（因为我们认为它不是一个资源，而是资源表示），即`xxx.api.com/stocks/page/2`，因为我们可能无法在调用之间唯一地找到资源。
- en: One problem that we need to solve in the case of pagination for URI queries
    is encoding, and we can use the standard way of encoding the paging information
     to do this.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理URI查询的分页时，我们需要解决的一个问题是编码，我们可以使用标准的编码方式来编码分页信息。
- en: Before we jump into the code, let's have a look at some better API pagination
    examples in the industry and a few pagination types as well.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，让我们看看一些行业中的更好的API分页示例以及一些分页类型。
- en: Facebook's API uses offset and limit (`fields=id`, `message& amp;limit=5`),
    linkedIn uses start and count (`.../{service}?start=10&count=10`), and Twitter
    uses records per page or count (`api.twitter.com/2/accounts/abc1/campaigns?cursor=c-3yvu1pzhd3i7&count=50`).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook的API使用偏移量和限制（`fields=id`，`message& amp;limit=5`），LinkedIn使用起始和计数（`.../{service}?start=10&count=10`），而Twitter使用每页记录数或计数（`api.twitter.com/2/accounts/abc1/campaigns?cursor=c-3yvu1pzhd3i7&count=50`）。
- en: 'There are three variants of resource representation ways of pagination, and
    they are as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 分页的资源表示方式有三种变体，具体如下：
- en: '**Offset-based**: When a client needs responses based on page count and page
    number. For example, `GET /investor/{id}/stocks?offset=2&limit=5 (returns stocks
    2 through 7 )`**.**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于偏移量的**: 当客户端需要基于页数和页码的响应时。例如，`GET /investor/{id}/stocks?offset=2&limit=5
    (返回2到7的股票)`**。**'
- en: '**Time-based**: When a client needs responses between a specified timeframe
    and can have a limit as well as part of the parameter to represent the max number
    of results per page. For example, `GET /investor/{id}/stocks?since=xxxxxx&until=yyyyy`
    `(returns stocks between a given dates)`*.*'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于时间的**: 当客户端需要在指定的时间范围内获得响应，并且可以有一个限制，以及作为参数的一部分来表示每页的最大结果数。例如，`GET /investor/{id}/stocks?since=xxxxxx&until=yyyyy`
    `(返回给定日期之间的股票)`*.*'
- en: '**Cursor-based**: A technique where a pointer (a built-in bookmark with breadcrumbs)
    reference of the remaining data is served a specific subset of data as a response
    and is let off. However, the rest of the data is still needed for later requests
    until the cursor reaches the end of the records. For example, `GET slack.com/api/users.list?limit=2&token=xoxp-1234-5678-90123`.
    The following code explains this:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于游标的**: 一种技术，其中指针（一个带有面包屑的内置书签）引用剩余数据，作为响应提供特定子集的数据，然后释放。然而，直到游标到达记录的末尾，剩余的数据仍然需要用于后续请求。例如，`GET
    slack.com/api/users.list?limit=2&token=xoxp-1234-5678-90123`。以下代码解释了这一点：'
- en: '[PRE5]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/f0047d1f-8cca-42d8-b2cd-97129061ee0e.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0047d1f-8cca-42d8-b2cd-97129061ee0e.png)'
- en: The preceding blocks shows offset-based pagination implementation within our
    investor service code. We will implement and touch upon other pagination methods,
    along with sorting and filtering in the next chapter when we discuss versioning
    and other patterns involving a database.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块展示了在我们投资者服务代码中的基于偏移量的分页实现。我们将在下一章讨论版本化和涉及数据库的其他模式时，实现和讨论其他分页方法，包括排序和过滤。
- en: Discoverability
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可发现性
- en: As we have discussed in the earlier chapter, API developers are the raison d'être
    of APIs. Helping them find the right APIs and helping them figure out programmatically
    whether the site that's being accessed has an API enabled or not will be the most
    critical responsibility of the API.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中讨论的那样，API开发者是API存在的理由。帮助他们找到合适的API，并帮助他们通过编程方式确定正在访问的网站是否启用了API，将是API最关键的责任。
- en: The primary step to connect with a site is to find out if the site is API enabled
    by simple URLs that are be using as user input to help us verify the API's availability.
    They also help us find out how to access them.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与网站建立连接的主要步骤是通过使用作为用户输入的简单URL来找出该网站是否启用了API。它们还帮助我们了解如何访问它们。
- en: Discoverability of the API is all about the descriptive capability of the server
    to instruct the client on the usage of the API.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: API的可发现性完全取决于服务器描述其API使用方式的描述能力。
- en: 'Let''s look at the two types of discoverability in the following section and
    their implementation in our code examples (as screenshots):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中查看两种类型的可发现性及其在我们代码示例（截图）中的实现：
- en: '**By valid HTTP methods**: When clients call REST services with invalid HTTP
    methods, the response of that request should end up in the `405` HTTP error code;
    that is, `405 Method Not Allowed`. In addition to the error code, the response
    header should provide flexibility to the client to find the supported methods
    that allow headers in its response. The code for this is as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过有效的HTTP方法**：当客户端使用无效的HTTP方法调用REST服务时，该请求的响应应最终以`405`HTTP错误代码结束；即`405 方法不允许`。除了错误代码外，响应头还应提供灵活性，使客户端能够找到其响应中允许的允许的方法。此代码如下：'
- en: '[PRE6]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/db97037f-37e9-4eca-ba46-7b0a3ab7032d.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db97037f-37e9-4eca-ba46-7b0a3ab7032d.png)'
- en: '**By providing the URI of the newly created resource**: Including the URI as
    part of the location header as the response to the newly created resource is another
    method of discoverability. The returned URI as a location will be available through
    `GET`. The code for it is as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过提供新创建资源的URI**：将URI作为部分位置头作为新创建资源的响应是另一种可发现性的方法。返回的URI作为位置将通过`GET`可用。此代码如下：'
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/a65b4b72-7c56-46a8-8bff-b5a1af3e4a06.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a65b4b72-7c56-46a8-8bff-b5a1af3e4a06.png)'
- en: Please note that, as our examples are using spring boot, we are leveraging the
    capabilities of spring boot's seamless and out-of-the-box implementations for
    discoverability (with `@GetMapping`, the servlets URI components builder, and
    so on).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们的示例使用的是Spring Boot，我们正在利用Spring Boot无缝和开箱即用的可发现性实现能力（使用`@GetMapping`、servlets
    URI组件构建器等）。
- en: 'One more type of discoverability (yet to be standardized, though) can be implemented
    through valid link headers. While responding to the client''s particular resources
    through `GET`, you must provide the client with clues about what they can do next
    as well; that is, providing a list of all available resources as a list through
    the link header:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的可发现性（尽管尚未标准化）可以通过有效的链接头实现。当通过`GET`响应客户端的特定资源时，你必须向客户端提供有关他们下一步可以做什么的线索；也就是说，通过链接头提供所有可用资源列表：
- en: '![](img/eacff5f9-49e7-4ca5-ac31-51f758a4e1d1.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eacff5f9-49e7-4ca5-ac31-51f758a4e1d1.png)'
- en: As a live example of discoverability, the preceding screenshot depicts one of
    Google's APIs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 作为可发现性的一个实时示例，前面的截图展示了谷歌的一个API。
- en: Error and exception logging
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误和异常日志记录
- en: As we keep on emphasizing when we discuss the importance of API developers when
    it comes to the consumption of our services, error handling and exception handling
    should be taken care of without any compromises. Services are the black boxes
    to the API developers, and therefore service providing errors and exceptions provide
    clients with a clear context and visibility to use our APIs.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论API开发者对我们服务消费的重要性时，我们一直在强调，错误处理和异常处理应无妥协地得到妥善处理。服务对API开发者来说是黑盒子，因此提供错误和异常的服务可以为客户端提供清晰的上下文和可见性，以便使用我们的API。
- en: 'Let''s take some real-world and very popular APIs and how they are handling
    these errors in a sample error scenario. This is shown in the following table.
    We will also look at the way we handle these errors and exceptions within our
    investor service code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些真实世界且非常流行的API，以及它们在样本错误场景中是如何处理这些错误的。这将在以下表格中展示。我们还将查看我们在投资者服务代码中处理这些错误和异常的方式：
- en: '| **APIs** | **HTTP code** | **Sample message** | **Remarks** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **APIs** | **HTTP代码** | **样本消息** | **备注** |'
- en: '| Facebook | `200` | `{"type":"OAUTH exception","message":"...."}` | Note that `200`
    indicates success. However, the API decides to send an error message as a response
    and still provide a success (`200`) code for an API call. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| Facebook | `200` | `{"type":"OAUTH exception","message":"...."}` | 注意，`200`表示成功。然而，API决定发送一个错误消息作为响应，同时仍然为API调用提供一个成功（`200`）代码。
    |'
- en: '| Twilio | `401` | `{"status":401,"message":"Authenticate","code":"...."..}`
    | Leverages the existing HTTP code as it is. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| Twilio | `401` | `{"status":401,"message":"Authenticate","code":"...."..}`
    | 利用现有的HTTP代码。 |'
- en: '| InvestorService | `405` | `{"Status":405,"error":"Method Not Allowed"....`
    | Leverages the existing HTTP code as it is. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 投资者服务 | `405` | `{"Status":405,"error":"Method Not Allowed"....` | 利用现有的HTTP代码。
    |'
- en: 'We also have a sample implementation of a custom exception class called `InvestorNotFoundException`
    in our sample repository. The code snippet and output sample (from Postman) is
    as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的样本仓库中，我们还实现了一个名为`InvestorNotFoundException`的自定义异常类的示例。以下是从Postman获取的代码片段和输出样本：
- en: '[PRE8]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/c1fe1000-aba7-4237-a270-23baef5c0a6b.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c1fe1000-aba7-4237-a270-23baef5c0a6b.png)'
- en: From our earlier examples, we can observe we have done a fair job regarding
    managing errors and exceptions with existing HTTP standard error codes. However,
    we can go further by providing more customized errors and messages to the caller;
    for instance, it would be more proper for the caller to receive a `404` error
    instead of a `500` error. Maybe we will implement a few customized error messages
    in the next chapter while we build some more patterns.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前的例子中，我们可以观察到我们在使用现有的HTTP标准错误代码管理错误和异常方面做得相当不错。然而，我们可以更进一步，通过向调用者提供更多定制化的错误和消息来做到这一点；例如，调用者收到一个`404`错误而不是`500`错误可能更为恰当。也许我们将在下一章构建更多模式的同时实现一些自定义错误消息。
- en: Unicode
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unicode
- en: A simple yet powerful way to make our API support multiple languages is to enable
    the API to support Unicode.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的API支持多种语言的一个简单而强大的方法是使API能够支持Unicode。
- en: '**Unicode** is an encoding standard that support an international character
    set. It has a unique number for every character across multiple languages including
    Chinese, Korean, and Arabic and their scripts. The unique number makes almost
    all characters identifiable and accessible across platforms, programs, and devices.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unicode**是一种编码标准，它支持国际字符集。它为包括中文、韩文和阿拉伯文及其脚本在内的多种语言中的每个字符都有一个唯一的数字。这个唯一的数字使得几乎所有的字符都可以在平台、程序和设备之间识别和访问。'
- en: 'So, in short, we can simplify our REST API that supports multiple languages
    by supporting Unicode as part of their headers. The following code depicts this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简而言之，我们可以通过支持Unicode作为它们头部的部分来简化支持多语言的REST API。以下代码展示了这一点：
- en: '[PRE9]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output for it is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 其输出如下：
- en: '![](img/68bf55e0-448a-48e2-a53c-b31382c485bd.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/68bf55e0-448a-48e2-a53c-b31382c485bd.png)'
- en: The preceding diagram shows the code snippet of the (`InvestorController.java`)
    accept-encoding charset in the header and the Postman results for the same.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了(`InvestorController.java`)头部中的accept-encoding字符集代码片段以及Postman的结果。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With a sense of our hands dealing with real code examples of statelessness,
    content-negotiation practices, URI templates definitions, service design for intent,
    discoverability, and a type of pagination. Then, we discussed error and exception
    handling in detail before finally concluded with a Unicode implementation for
    internationalization (supporting multiple languages with our services).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了处理无状态、内容协商实践、URI模板定义、服务设计以实现意图、可发现性和一种分页类型等真实代码示例之后，我们详细讨论了错误和异常处理，最后以Unicode国际化实现（支持我们的服务中的多种语言）作为结论。
- en: This chapter should be an excellent start for anyone who wants to get their
    hands on the RESTful services; not just the basics, but the essential patterns
    as well. In the next chapter, we will see more advanced pattern implementation
    and examples to enable our readers to increasingly utilize best practices and
    implementations.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 本章应为任何想要掌握RESTful服务的人提供一个出色的起点；不仅包括基础知识，还包括核心模式。在下一章中，我们将看到更多高级模式的实现和示例，以便我们的读者能够越来越多地利用最佳实践和实现。
