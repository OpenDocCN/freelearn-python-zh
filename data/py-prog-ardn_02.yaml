- en: Chapter 2. Working with the Firmata Protocol and the pySerial Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：使用Firmata协议和pySerial库
- en: 'In the previous chapter, you learned the fundamentals of the Python programming
    language and the Arduino hardware platform so that you could get started. If you
    are reading this chapter directly without going through the previous chapter,
    it is assumed that you have some level of expertise or working experience with
    these technologies. This chapter describes two important components that are required
    to bridge Arduino with Python:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，你学习了Python编程语言和Arduino硬件平台的基础知识，以便开始使用。如果你直接阅读本章而没有阅读前一章，我们假设你对这些技术有一定的专业知识或工作经验。本章描述了两个将Arduino与Python连接所需的重要组件：
- en: The Arduino Firmata protocol
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino Firmata协议
- en: Python's serial library called `pySerial`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python的串行库名为`pySerial`
- en: Although the Firmata protocol is useful to interface Arduino with Python, it
    can also be used as an independent tool to develop a large variety of applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Firmata协议对于将Arduino与Python接口很有用，但它也可以作为一个独立的工具来开发各种应用。
- en: It is time to take your Arduino hardware out and start getting your hands dirty.
    During the course of this chapter, you will require an LED, a breadboard, and
    a 1 kilo-ohm resistor as well as the components that you already used in the previous
    chapter, that is, Arduino Uno and a USB cable.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候拿出你的Arduino硬件并开始动手实践了。在本章的过程中，你需要一个LED灯、一个面包板、一个1千欧姆电阻以及你已经在上一章中使用过的组件，即Arduino
    Uno和USB线。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are using any other variant of Arduino, you can obtain further information
    about it from [http://arduino.cc/en/Guide/HomePage](http://arduino.cc/en/Guide/HomePage)
    or the community-supported Arduino forum that is located at [http://forum.arduino.cc/](http://forum.arduino.cc/).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是任何其他版本的Arduino，你可以从[http://arduino.cc/en/Guide/HomePage](http://arduino.cc/en/Guide/HomePage)或位于[http://forum.arduino.cc/](http://forum.arduino.cc/)的社区支持的Arduino论坛中获取更多信息。
- en: Connecting the Arduino board
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接Arduino板
- en: As mentioned in the previous chapter, this book supports all major operating
    systems, and this section will provide you with steps to connect and configure
    the Arduino board for these operating systems. In the previous chapter, we utilized
    example code to get started with the Arduino IDE. If you were unable to successfully
    communicate with Arduino by following the information given in the previous chapter,
    follow the instructions provided in this section to establish a connection between
    your computer and your Arduino. First, connect your Arduino board to your computer's
    USB port using a USB cable and follow the steps according to your operating system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，本书支持所有主要操作系统，本节将为你提供连接和配置Arduino板的步骤。在前一章中，我们使用了示例代码来开始使用Arduino IDE。如果你没有按照前一章提供的信息成功与Arduino通信，请遵循本节提供的说明，在计算机和Arduino之间建立连接。首先，使用USB线将Arduino板连接到计算机的USB端口，并按照你的操作系统步骤进行操作。
- en: Linux
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux
- en: If you are using the latest version of Ubuntu Linux, once you connect the Arduino
    board and open the Arduino IDE, you will be asked to add your username to the
    dailout group, as displayed in the following screenshot. Click on the **Add**
    button and log out from the system. You don't need to restart the computer for
    the changes to take effect. Log in with the same username and open the Arduino
    IDE.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是最新的Ubuntu Linux版本，一旦你连接Arduino板并打开Arduino IDE，系统会要求你将自己的用户名添加到dailout组，如下面的截图所示。点击**添加**按钮并从系统中注销。你不需要重启计算机，更改即可生效。使用相同的用户名登录并打开Arduino
    IDE。
- en: '![Linux](img/5938OS_02_02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![Linux](img/5938OS_02_02.jpg)'
- en: 'If you don''t see this dialog box, check whether you can see the **Serial Port**
    option in the **Tools** menu of the Arduino IDE. It is possible that the installation
    of other programs might have added your username to the dailout group already.
    If you don''t get the dialog box and don''t have any options to select in **Serial
    Port**, execute the following script in the terminal, where `<username>` is your
    Linux username:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到这个对话框，请检查是否可以在Arduino IDE的**工具**菜单中看到**串行端口**选项。可能是因为安装了其他程序已经将你的用户名添加到了dailout组。如果你没有对话框，且在**串行端口**没有选择项，请在终端中执行以下脚本，其中`<username>`是你的Linux用户名：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This script will add your username to the dialout group, and it should also
    work for other Linux versions. In Linux, the Arduino board mostly gets connected
    as `/dev/ttyACMx`, where `x` is the integer value and depends on your physical
    port address. If you are using any other distribution of Linux other than Ubuntu,
    you might want to check out the proper groups associated with the Arduino serial
    port from the Linux installation page ([http://playground.arduino.cc/Learning/Linux](http://playground.arduino.cc/Learning/Linux))
    of the Arduino website.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将把您的用户名添加到拨出组，并且它也应该适用于其他Linux版本。在Linux中，Arduino板通常连接为`/dev/ttyACMx`，其中`x`是整数值，取决于您的物理端口地址。如果您使用的是除Ubuntu以外的任何其他Linux发行版，您可能需要从Arduino网站上的Linux安装页面（[http://playground.arduino.cc/Learning/Linux](http://playground.arduino.cc/Learning/Linux)）检查与Arduino串行端口关联的正确组。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For the Fedora Linux distribution, add the `uucp` and `lock` groups with the
    `dialout` group to control the serial port:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Fedora Linux发行版，将`uucp`和`lock`组与`dialout`组合并，以控制串行端口：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Mac OS X
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mac OS X
- en: 'In Mac OS X, when you connect your Arduino through a serial port, the OS configures
    it as a network interface. In OS X Mavericks, once the Arduino board is connected,
    open **Network** from **System Preferences**. A dialog box should appear that
    states that a new network interface has been detected. Click on **OK** for **Thunderbolt
    Bridge** and then click on **Apply**. The following screenshot displays the dialog
    box to add a new network interface:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac OS X中，当您通过串行端口连接Arduino时，操作系统将其配置为网络接口。在OS X Mavericks中，一旦Arduino板连接，从**系统偏好设置**中打开**网络**。应该会出现一个对话框，表明检测到新的网络接口。点击**Thunderbolt
    Bridge**的**确定**，然后点击**应用**。以下截图显示了添加新网络接口的对话框：
- en: '![Mac OS X](img/5938OS_02_03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Mac OS X](img/5938OS_02_03.jpg)'
- en: For OS X Lion or later versions, on connecting the Arduino board, a dialog box
    will appear that will ask you to add a new network interface. In this case, you
    will not have to navigate to your network preferences. If you see the network
    interface with the status **Not connected** and highlighted in red, don't worry
    about it as it should work just fine.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于OS X Lion或更高版本，连接Arduino板时，将出现一个对话框，要求您添加新的网络接口。在这种情况下，您不需要导航到您的网络首选项。如果您看到状态为**未连接**并以红色突出显示的网络接口，请不要担心，因为它应该可以正常工作。
- en: 'Open the Arduino IDE and navigate to **Serial Port** from the **Tools** menu.
    You should be able to see options similar to those displayed in the following
    screenshot. The serial port on which the Arduino board is connected might vary
    according to your OS X version and the physical port to which it is connected.
    Make sure that you select a `tty` interface for a USB modem. As displayed in the
    following screenshot, the Arduino board is connected to the serial port `/dev/tty.usbmodemfd121`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Arduino IDE，从**工具**菜单导航到**串行端口**。您应该能看到类似于以下截图中的选项。Arduino板连接的串行端口可能会根据您的OS
    X版本和连接的物理端口而有所不同。确保您为USB调制解调器选择一个`tty`接口。如以下截图所示，Arduino板连接到串行端口`/dev/tty.usbmodemfd121`：
- en: '![Mac OS X](img/5938OS_02_04.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![Mac OS X](img/5938OS_02_04.jpg)'
- en: Windows
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows
- en: The configuration of the Arduino serial port is very straightforward if you
    are using Windows. When you connect your Arduino board the very first time, the
    operating system will automatically install the necessary drivers by itself. Once
    this process is complete, select an appropriate COM port from the **Serial Port**
    option in the menu bar. From the main menu, navigate to **Tools** | **Serial Port**
    and select the COM port.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Windows，Arduino串行端口的配置非常简单。当您第一次连接Arduino板时，操作系统将自动安装必要的驱动程序。一旦此过程完成，从菜单栏中的**串行端口**选项中选择一个合适的COM端口。从主菜单中，导航到**工具**
    | **串行端口**并选择COM端口。
- en: Troubleshooting
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'Even after following the steps mentioned earlier, if you still don''t see the
    highlighted **Serial Port** option as displayed in the following screenshot, then
    you have got a problem. There can be two main reasons for this: the serial port
    is being used by another program or the Arduino USB drivers are not installed
    properly.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 即使按照前面提到的步骤操作，如果您仍然看不到以下截图所示的突出显示的**串行端口**选项，那么您可能遇到了问题。这可能有两个主要原因：串行端口被另一个程序使用，或者Arduino
    USB驱动程序没有正确安装。
- en: 'If any program other than the Arduino IDE is using the specific serial port,
    terminate that program and restart the Arduino IDE. Sometimes in Linux, the `brltty`
    library conflicts with the Arduino serial interface. Remove this library, log
    out, and log back in:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有除 Arduino IDE 之外的其他程序正在使用特定的串行端口，请终止该程序并重新启动 Arduino IDE。有时在 Linux 中，`brltty`
    库与 Arduino 串行接口冲突。请删除此库，注销并重新登录：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In Windows, reinstalling the Arduino IDE also works, as this process installs
    and configures the Arduino USB driver again.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，重新安装 Arduino IDE 也有效，因为这个过程会重新安装和配置 Arduino USB 驱动程序。
- en: '![Troubleshooting](img/5938OS_02_05.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![故障排除](img/5938OS_02_05.jpg)'
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The Arduino board can be used by only one program at a time. It is very import
    to make sure that any previously used program or other services are not using
    the serial port or Arduino when you try to use the Arduino IDE. This check will
    become very important when we start using multiple programs to control Arduino
    in the next section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 板一次只能由一个程序使用。在尝试使用 Arduino IDE 时，确保任何之前使用的程序或其他服务都没有使用串行端口或 Arduino，这一点非常重要。当我们开始在下节使用多个程序控制
    Arduino 时，这个检查将变得非常重要。
- en: Assuming that you can now select the serial port in the Arduino IDE, we can
    go ahead with compiling and uploading sketches to your Arduino board. The Arduino
    IDE ships with preinstalled example sketches with which you can play around. However,
    before we go ahead and start playing with complex examples, let's go through the
    next section, which explains the Firmata protocol and also guides you through
    step-by-step instructions to compile and upload a sketch.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你现在可以在 Arduino IDE 中选择串行端口，我们可以继续编译并将草图上传到您的 Arduino 板。Arduino IDE 预装了示例草图，您可以尝试使用它们。然而，在我们开始尝试复杂的示例之前，让我们先浏览下一节，该节解释了
    Firmata 协议，并指导您逐步编译和上传草图。
- en: Introducing the Firmata protocol
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Firmata 协议
- en: Before Arduino, the domain of microcontroller-based applications was limited
    to hardware programmers. Arduino made it simple for developers that came from
    other software fields and even for the non-coding community to develop microcontroller-based
    hardware applications. Arduino consists of a simple hardware design with a microcontroller
    and I/O pins to interface external devices. If one can write an Arduino sketch
    that can transfer the control of the microcontroller and these pins to an external
    software mechanism, then it will reduce one's efforts to upload Arduino sketches
    for every modification. This process can be performed by developing such an Arduino
    program that can then be controlled using a serial port. There exists a protocol
    called **Firmata**, which does exactly that.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Arduino 之前，基于微控制器的应用程序领域仅限于硬件程序员。Arduino 使来自其他软件领域的开发者和甚至非编码社区的开发者能够轻松地开发基于微控制器的硬件应用程序。Arduino
    由一个简单的硬件设计组成，包括微控制器和 I/O 引脚，用于连接外部设备。如果能够编写一个 Arduino 草图，可以将微控制器和这些引脚的控制权转移到外部软件机制，那么这将减少每次修改上传
    Arduino 草图的努力。这个过程可以通过开发这样的 Arduino 程序来完成，然后可以通过串行端口对其进行控制。存在一个名为 **Firmata**
    的协议，它正是这样做的。
- en: What is Firmata?
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Firmata？
- en: Firmata is a generic protocol that allows communication between the microcontroller
    and the software that is hosted on a computer. Any software from any computer
    host that is capable of serial communication can communicate with the microcontroller
    using Firmata. Firmata gives complete access of Arduino directly to the software
    and eliminates the processes of modifying and uploading Arduino sketches.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Firmata 是一种通用协议，允许微控制器与在计算机上托管的应用软件之间进行通信。任何能够进行串行通信的计算机主机上的软件都可以使用 Firmata
    与微控制器通信。Firmata 使 Arduino 直接对软件提供完全访问权限，并消除了修改和上传 Arduino 草图的流程。
- en: To utilize the Firmata protocol, a developer can upload a sketch that supports
    the protocol to the Arduino client as a onetime process. Afterwards, the developer
    can write custom software on the host computer and perform complex tasks. This
    software will provide commands via a serial port to the Arduino board that is
    equipped with Firmata. He or she can keep altering the logic on the host computer
    without interrupting the Arduino hardware.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Firmata 协议，开发者可以一次性将支持该协议的草图上传到 Arduino 客户端。之后，开发者可以在主机计算机上编写自定义软件并执行复杂任务。该软件将通过串行端口向配备
    Firmata 的 Arduino 板提供命令。他们可以在不中断 Arduino 硬件的情况下，不断更改主机计算机上的逻辑。
- en: The practice of writing custom Arduino sketches is still valid for standalone
    applications where the Arduino board has to perform a task locally. We will explore
    both these options in the upcoming chapters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 编写自定义Arduino草图的做法对于Arduino板需要本地执行任务的独立应用程序仍然有效。我们将在接下来的章节中探讨这两种选项。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about the Firmata protocol and its latest version from the
    official website at [http://www.firmata.org](http://www.firmata.org).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从官方网站[http://www.firmata.org](http://www.firmata.org)了解更多关于Firmata协议及其最新版本的信息。
- en: Uploading a Firmata sketch to the Arduino board
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Firmata草图上传到Arduino板
- en: The best way to start testing the Firmata protocol is to upload a standard Firmata
    program to the Arduino board and use the testing software from the host. In this
    section, we are going to demonstrate a method to upload an Arduino sketch, which
    has this standard Firmata program, to the board. This is going to be the default
    method to upload any sketch in the future.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 开始测试Firmata协议的最佳方式是将标准Firmata程序上传到Arduino板，并使用主机上的测试软件。在本节中，我们将演示一种将具有此标准Firmata程序的自定义Arduino草图上传到板的方法。这将成为将来上传任何草图时的默认方法。
- en: 'Implementation of the Firmata protocol requires the latest version of the Firmata
    firmware and you don''t have to worry about writing it. The latest Arduino IDE
    ships with a standard version of the Firmata firmware, and we recommend that you
    use the latest IDE to avoid any conflict. Now, follow the following steps to upload
    the program to your Arduino board:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 实现Firmata协议需要最新的Firmata固件版本，您无需担心编写它。最新的Arduino IDE自带标准版本的Firmata固件，我们建议您使用最新的IDE以避免任何冲突。现在，按照以下步骤将程序上传到您的Arduino板：
- en: As shown in the following screenshot, open the **StandardFirmata** sketch by
    navigating to **File** | **Examples** | **Firmata** | **StandardFirmata** in the
    Arduino IDE:![Uploading a Firmata sketch to the Arduino board](img/5938OS_02_06.jpg)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下截图所示，通过在Arduino IDE中导航到**文件** | **示例** | **Firmata** | **StandardFirmata**来打开**StandardFirmata**草图：![将Firmata草图上传到Arduino板](img/5938OS_02_06.jpg)
- en: This action will open another sketchbook in a new window with the **StandardFirmata**
    sketch loaded in the editor. Do not modify anything in the sketch and go ahead
    with the compiling process that is described in the next step. It is important
    not to modify anything in the code as the test software that we are going to use
    complies with the latest unchanged firmware.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此操作将在新窗口中打开另一个草图簿，并在编辑器中加载**StandardFirmata**草图。不要修改草图中的任何内容，并继续执行下一节中描述的编译过程。重要的是不要修改代码，因为我们将要使用的测试软件与最新的未更改固件兼容。
- en: Once the **StandardFirmata** sketch is opened, the next step is to compile it
    for your Arduino board. In the previous section, we already connected the Arduino
    board to the computer and selected the proper serial port. However, if the new
    sketchbook has a different configuration than that, follow the steps from the
    previous section, that is, select the appropriate serial port and the Arduino
    board type.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦打开**StandardFirmata**草图，下一步就是为您的Arduino板编译它。在上一节中，我们已经将Arduino板连接到计算机并选择了正确的串行端口。然而，如果新的草图簿与之前的配置不同，请按照上一节的步骤操作，即选择适当的串行端口和Arduino板类型。
- en: To compile the current sketch, click on the **Verify** icon from the toolbar
    as displayed in the following screenshot. You can also compile it by navigating
    to **Sketch** | **Verify / Compile** or clicking on *Ctrl* + *R* (*command* +
    *R* if you are using Mac OS X):![Uploading a Firmata sketch to the Arduino board](img/5938OS_02_07.jpg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译当前草图，请点击以下截图所示的**验证**图标。您也可以通过导航到**草图** | **验证/编译**或点击*Ctrl* + *R*（如果您使用的是Mac
    OS X，则为*command* + *R*）来编译它：![将Firmata草图上传到Arduino板](img/5938OS_02_07.jpg)
- en: The compilation process should complete without any errors as we are using default
    example code from the IDE itself. Now it's time to upload the sketch to the board.
    Make sure that you have connected the board.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编译过程应该没有错误完成，因为我们使用的是IDE自带的默认示例代码。现在，是时候将草图上传到板上了。请确保您已经连接了板。
- en: Press the upload icon in the toolbar as displayed in the following screenshot.
    This action will upload the compiled code to your Arduino board:![Uploading a
    Firmata sketch to the Arduino board](img/5938OS_02_08.jpg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下截图所示，在工具栏中按下上传图标。此操作将上传编译后的代码到您的Arduino板：![将Firmata草图上传到Arduino板](img/5938OS_02_08.jpg)
- en: 'On completion, you should see the **Done uploading.** text in the IDE, as displayed
    in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你应该在IDE中看到**上传完成**的文本，如图下所示：
- en: '![Uploading a Firmata sketch to the Arduino board](img/5938OS_02_09.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![将Firmata草图上传到Arduino板](img/5938OS_02_09.jpg)'
- en: Your Arduino board is now ready with the latest Firmata firmware and is waiting
    for a request from your computer. Let's move on to the next section and start
    testing the Firmata protocol.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Arduino板现在已安装了最新的Firmata固件，并等待来自计算机的请求。让我们继续到下一节，开始测试Firmata协议。
- en: Testing the Firmata protocol
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试Firmata协议
- en: In the previous chapter, we used an on-board LED at pin 13 to test the **Blink**
    program. This time, we are going to use an external LED to get you started with
    the assembly of hardware components using your Arduino board. As all the upcoming
    exercises and projects will require you to interface hardware components such
    as sensors and actuators to your Arduino board using a breadboard, we want you
    to start getting hands-on experience with wiring these components.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了13号引脚上的板载LED来测试**闪烁**程序。这次，我们将使用外部LED，帮助你开始使用Arduino板组装硬件组件。由于所有即将到来的练习和项目都将要求你使用面包板将硬件组件如传感器和执行器连接到Arduino板上，我们希望你开始获得实际操作这些组件的实践经验。
- en: 'Now is the time to use the LED that we asked you to get at the beginning of
    the chapter. Before we start wiring the LED, let''s first understand the physics
    of it. The LED that you obtained should have two legs: a short one and a long
    one. The short leg is connected to the cathode of the LED and it needs to be connected
    to the ground via a resistor. As you can see in the following figure, we are using
    a 1 k-ohm resistor to ground the cathode of the LED. The long leg, which is connected
    to the anode, needs to connect to one of the digital pins of the Arduino board.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用我们在本章开头要求你获取的LED了。在我们开始接线LED之前，让我们首先了解它的物理原理。你获得的LED应该有两个引脚：一个短的和一个长的。短的引脚连接到LED的阴极，并且需要通过一个电阻连接到地。如图所示，我们使用一个1千欧姆的电阻将LED的阴极接地。连接到阳极的长引脚需要连接到Arduino板上的一个数字引脚。
- en: As shown in the following figure, we have connected the anode to the digital
    pin number 13\. Look at the figure and wire the connection as displayed. Make
    sure that you disconnect the Arduino board from the host computer to avoid any
    kind of damage from static electricity.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，我们将阳极连接到了数字引脚13。查看图示并按照显示的接线方式接线。确保你已将Arduino板从主机计算机断开，以避免静电造成的任何损坏。
- en: '![Testing the Firmata protocol](img/5938OS_02_10.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![测试Firmata协议](img/5938OS_02_10.jpg)'
- en: In this example, we are going to use an LED to test some basic functionalities
    of the Firmata protocol. We have already uploaded the Firmata code to the Arduino
    board and we are ready to control the LED from the host computer.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用LED来测试Firmata协议的一些基本功能。我们已将Firmata代码上传到Arduino板，并准备好从主机计算机控制LED。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding wiring figure was created using an open source tool called **Fritzing**.
    We are going to cover the Fritzing tool comprehensively in the next chapter, as
    it will be our standard software to create the wiring diagram before we perform
    the actual physical wiring.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上述接线图是使用一个名为**Fritzing**的开源工具创建的。我们将在下一章全面介绍Fritzing工具，因为它将成为我们在实际物理接线之前创建接线图的标准软件。
- en: 'There are multiple ways to communicate with the Arduino board from the host
    computer using Firmata, such as writing your own program in Python using the supported
    library or using the prebuilt testing software. Starting from the next section,
    we are going to write our own programs to use Firmata, but at this stage, let''s
    use a freely available tool for testing purposes. The official Firmata website,
    [http://www.firmata.org](http://www.firmata.org), also provides test tools that
    you can download from the **Firmata Test Program** section on the main page. The
    website includes a different variant of the tool called `firmata_test` for different
    operating systems. Using the following steps, you can test the implementation
    of the Firmata protocol:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Firmata与主机计算机通信有多种方式，例如使用支持的库在Python中编写自己的程序或使用预构建的测试软件。从下一节开始，我们将编写自己的程序来使用Firmata，但在这个阶段，让我们使用一个免费工具进行测试。官方Firmata网站[http://www.firmata.org](http://www.firmata.org)还提供了测试工具，您可以从主页上的**Firmata测试程序**部分下载。该网站为不同的操作系统提供了名为`firmata_test`的不同工具变体。按照以下步骤，您可以测试Firmata协议的实现：
- en: Download the appropriate version of the `firmata_test` program to your computer.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`firmata_test`程序的适当版本下载到您的计算机上。
- en: Now, connect your Arduino board with the LED to the host computer using the
    USB cable and run the downloaded `firmata_test` program. You will be able to see
    an empty window on the successful execution of the program.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用USB线将带有LED的Arduino板连接到主机计算机，并运行下载的`firmata_test`程序。您将能够在程序成功执行后看到一个空窗口。
- en: As displayed in the following screenshot, select the appropriate port from the
    drop-down menu. Make sure to select the same port that you used to upload the
    Arduino sketch.![Testing the Firmata protocol](img/5938OS_02_11.jpg)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下屏幕截图所示，从下拉菜单中选择适当的端口。请确保选择您用于上传Arduino草图相同的端口。![测试Firmata协议](img/5938OS_02_11.jpg)
- en: Tip
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: At this point, make sure that your Arduino IDE is not connected to the board
    using the same port number. As we mentioned earlier, the serial interface grants
    exclusive access to only one application at a time.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一点上，请确保您的Arduino IDE没有使用相同的端口号连接到板。如我们之前提到的，串行接口一次只授予一个应用程序独家访问权限。
- en: Once you select the Arduino serial port, the program will load multiple drop-down
    boxes and buttons with labels that contain the pin number. You can see in the
    following screenshot that the program is loaded with 12 digital pins (from pin
    2 to pin 13) and six analog pins (from pin 14 to pin 19). As we are using the
    Arduino Uno board for our applications, the test program only loads pins that
    are part of Arduino Uno. If you are using Arduino Mega or any other board, the
    number of pins displayed in the program will be according to the pins supported
    by that particular variant of the Arduino board.![Testing the Firmata protocol](img/5938OS_02_12.jpg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您选择了Arduino串行端口，程序将加载多个带有包含引脚编号标签的下拉框和按钮。您可以在下面的屏幕截图中看到，程序已加载了12个数字引脚（从引脚2到引脚13）和6个模拟引脚（从引脚14到引脚19）。由于我们使用Arduino
    Uno板进行我们的应用，测试程序只加载Arduino Uno板的部分引脚。如果您使用Arduino Mega或任何其他板，程序中显示的引脚数量将根据该特定Arduino板变体支持的引脚数量而定。![测试Firmata协议](img/5938OS_02_12.jpg)
- en: Tip
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Working with the firmata_test program on Linux**'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**在Linux上使用firmata_test程序**'
- en: 'On a Linux platform, you might have to modify the property of the downloaded
    file and make it executable. From the same directory, run the following command
    in the terminal to make it executable:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Linux平台上，您可能需要修改下载文件的属性并使其可执行。从同一目录中，在终端中运行以下命令使其可执行：
- en: '[PRE3]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once you have changed the permissions, use the following command to run the
    program from the terminal:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦您更改了权限，请使用以下命令从终端运行程序：
- en: '[PRE4]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see in the program window, you have two other columns as well as
    the column containing the labels. The second column in the program lets you select
    the role for the appropriate pins. You can specify the role of digital pins (in
    the case of Arduino Uno, from 2 to 13) as input or output. As displayed in the
    following screenshot, you will see **Low** in the third column as soon as you
    select the role of pins 2 and 3 as input pins. This is correct, as we don't have
    any input connected to these pins. You can play with the program by changing the
    roles and values of multiple pins.![Testing the Firmata protocol](img/5938OS_02_13.jpg)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你在程序窗口中所见，你还有两列以及其他包含标签的列。程序中的第二列允许你选择适当引脚的角色。你可以指定数字引脚（在Arduino Uno的情况下，从2到13）作为输入或输出。如以下截图所示，当你选择2号和3号引脚作为输入引脚时，你会在第三列看到**低**。这是正确的，因为我们没有将这些引脚连接到任何输入。你可以通过更改多个引脚的角色和值来玩弄程序。![测试Firmata协议](img/5938OS_02_13.jpg)
- en: As we have connected the LED to digital pin 13, we are not expecting any physical
    changes on the board while you are playing around with the other pins.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们已经将LED连接到数字引脚13，所以在你玩弄其他引脚时，我们不会期望在板上出现任何物理变化。
- en: Now, select pin 13 as an output pin and press the **Low** button. This will
    change the button's label to **High** and you will see that the LED is turned
    on. By performing this action, we have changed the logic of the digital pin 13
    to 1, that is, **High**, which translates to +5 volts at the pin. This potential
    will be sufficient to light the LED. You can change the level of pin 13 back to
    0 by clicking on the button again and turning it to **Low**. This will change
    the potential back to 0 volts.![Testing the Firmata protocol](img/5938OS_02_14.jpg)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择引脚13作为输出引脚并按下**低**按钮。这将改变按钮的标签为**高**，并且你会看到LED灯被点亮。通过执行此操作，我们已经将数字引脚13的逻辑更改为1，即**高**，这在引脚上相当于+5伏特。这种电压足以点亮LED。你可以通过再次点击按钮并将它切换到**低**来将引脚13的级别改回0。这将使电压回到0伏特。![测试Firmata协议](img/5938OS_02_14.jpg)
- en: The program that we used here is perfect to test the fundamentals, but it cannot
    be used to write complex applications using the Firmata protocol. In real-world
    applications, we really need to execute the Firmata methods using custom code,
    which in addition to switching the LED status also includes the implementation
    of smart logic and algorithms, interfacing other components, and so on. We are
    going to use Python for these applications, starting from the next section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的程序非常适合测试基础知识，但不能用来编写使用Firmata协议的复杂应用程序。在实际应用中，我们确实需要使用自定义代码来执行Firmata方法，这不仅包括切换LED状态，还包括实现智能逻辑和算法、与其他组件接口等。从下一节开始，我们将使用Python来处理这些应用。
- en: Getting started with pySerial
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用pySerial
- en: You learned about the Firmata protocol in the previous section. This is an easy
    and quick way to start working with Arduino. Although the Firmata protocol helps
    you to develop complex applications from your computer without modifying the Arduino
    sketch, we are not ready to start coding these applications.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了Firmata协议。这是一个简单快捷的开始使用Arduino的方法。尽管Firmata协议可以帮助你在不修改Arduino草图的情况下从电脑上开发复杂的应用程序，但我们还没有准备好开始编写这些应用程序的代码。
- en: The first step towards writing these complex applications is to provide an interface
    between your programming environment and the Arduino via a serial port. In this
    book, you will be required to establish a connection between the Python interpreter
    and Arduino for every project that we develop.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这些复杂应用程序的第一步是在你的编程环境和Arduino之间通过串行端口提供一个接口。在这本书中，你将需要为每个我们开发的项目在Python解释器和Arduino之间建立连接。
- en: Writing your own library, which includes implementation of functions and specifications
    to enable communication on a serial protocol, is an inconvenient and time consuming
    process. We are going to avoid that by using an open source, well maintained Python
    library called `pySerial`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 编写自己的库，该库包括实现函数和规范以在串行协议上启用通信，是一个不方便且耗时的过程。我们将通过使用一个开源、维护良好的Python库`pySerial`来避免这种情况。
- en: The `pySerial` library enables communication with Arduino by encapsulating the
    access for the serial port. This module provides access to the serial port settings
    through Python properties and allows you to configure the serial port directly
    through the interpreter. `pySerial` will be the bridge for any future communication
    between the Python and Arduino. Let's start by installing `pySerial`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`pySerial` 库通过封装串行端口的访问来启用与 Arduino 的通信。此模块通过 Python 属性提供对串行端口设置的访问，并允许你通过解释器直接配置串行端口。`pySerial`
    将成为 Python 和 Arduino 之间未来通信的桥梁。让我们从安装 `pySerial` 开始。'
- en: Installing pySerial
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 pySerial
- en: We installed the package manager Setuptools in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Python and Arduino"), *Getting Started with Python and Arduino*.
    If you have skipped that chapter and are not sure about it, then please go through
    that section. If you already know how to install and configure Python library
    packages, skip these installation steps.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 1 章](ch01.html "第 1 章。Python 和 Arduino 入门")*Python 和 Arduino 入门*中安装了包管理器
    Setuptools。如果你跳过了那一章并且对此不确定，那么请阅读该部分。如果你已经知道如何安装和配置 Python 库包，则可以跳过这些安装步骤。
- en: 'From this stage, we are going to use only pip-based installation commands due
    to their obvious advantages that were described in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Python and Arduino"), *Getting Started with Python and Arduino*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个阶段开始，我们将只使用基于 pip 的安装命令，因为它们在[第 1 章](ch01.html "第 1 章。Python 和 Arduino 入门")*Python
    和 Arduino 入门*中描述的明显优势：
- en: 'Open a terminal or command prompt and execute the following command:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端或命令提示符，并执行以下命令：
- en: '[PRE5]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The Windows operating system does not require administrator-level user access
    to execute the command, but you should have root privileges to install Python
    packages in Unix-based operating systems, as follows:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Windows 操作系统不需要管理员级别的用户访问来执行命令，但在基于 Unix 的操作系统中，你应该有 root 权限来安装 Python 包，如下所示：
- en: '[PRE6]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you want to install the `pySerial` library from source, download the archive
    from [http://pypi.python.org/pypi/pyserial](http://pypi.python.org/pypi/pyserial),
    unpack it, and from the `pySerial` directory, run the following command:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想要从源代码安装 `pySerial` 库，请从 [http://pypi.python.org/pypi/pyserial](http://pypi.python.org/pypi/pyserial)
    下载存档，解压它，然后从 `pySerial` 目录中运行以下命令：
- en: '[PRE7]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If Python and Setuptools are installed properly, you should see the following
    output at the command line after the installation is complete:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Python 和 Setuptools 安装正确，那么在安装完成后，你应在命令行中看到以下输出：
- en: '[PRE8]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This means that you have successfully installed the `pySerial` library and you
    are good to go to the next section.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着你已经成功安装了 `pySerial` 库，并且可以进入下一部分。
- en: 'Now, to check whether or not `pySerial` is successfully installed, start your
    Python interpreter and import the `pySerial` library using the following command:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了检查 `pySerial` 是否成功安装，启动你的 Python 解释器，并使用以下命令导入 `pySerial` 库：
- en: '[PRE9]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Playing with a pySerial example
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩转 pySerial 示例
- en: Your Arduino board has the Firmata sketch **StandardFirmata** from the previous
    example. To play with `pySerial`, we are not going to use the Firmata protocol
    anymore. Instead, we are going to use another simple Arduino sketch that implements
    serial communication that can be captured on the Python interpreter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Arduino 板有来自上一个示例的 Firmata 草图 **StandardFirmata**。为了玩转 `pySerial`，我们不再使用
    Firmata 协议。相反，我们将使用另一个简单的 Arduino 草图，该草图实现了可以在 Python 解释器上捕获的串行通信。
- en: 'Sticking with the promise of not performing any coding for the Arduino sketch,
    let''s select an example sketch from the Arduino IDE:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 坚持不进行任何 Arduino 草图编码的承诺，让我们从 Arduino IDE 中选择一个示例草图：
- en: As displayed in the following screenshot, navigate to **File** | **Examples**
    | **01\. Basics** | **DigitalReadSerial**.![Playing with a pySerial example](img/5938OS_02_15.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下截图所示，导航到**文件** | **示例** | **01\. 基础** | **DigitalReadSerial**。![玩转 pySerial
    示例](img/5938OS_02_15.jpg)
- en: Compile and upload the program to the Arduino board using the same method that
    was described earlier. Select the appropriate serial port on which your Arduino
    is connected and make a note of it. As you can see in the sketch, this simple
    Arduino code transmits the status of digital pin 2 that is on the serial port
    with a baud rate of 9600 bps.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面描述的方法编译并上传程序到 Arduino 板。选择你的 Arduino 连接的适当串行端口，并记下它。正如你在草图中所见，这段简单的 Arduino
    代码以 9600 bps 的波特率通过串行端口传输数字引脚 2 的状态。
- en: 'Without disconnecting the Arduino board from your computer, open the Python
    interpreter. Then, execute the following commands on the Python interpreter. Make
    sure that you replace `/dev/ttyACM0` with the port name that you noted down earlier:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不将Arduino板从计算机断开连接的情况下，打开Python解释器。然后，在Python解释器上执行以下命令。确保将`/dev/ttyACM0`替换为你之前记下的端口名称：
- en: '[PRE10]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: On execution, you should get repeated `0` values in the Python interpreter.
    Press *Ctrl* + *C* to terminate this code. As you can see, the Arduino code will
    keep sending messages due to the loop function that was used in the sketch. We
    don't have anything connected to pin 2, and because of this, we are getting the
    status `0`, that is, `Low`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行时，你应在Python解释器中看到重复的`0`值。按*Ctrl* + *C*来终止此代码。正如你所见，由于草图中的循环函数，Arduino代码会持续发送消息。我们没有将任何东西连接到引脚2，因此我们得到了状态`0`，即`低`。
- en: If you know what you are doing, you can connect any digital sensor to pin 2
    and run the script again to see the changed status.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你清楚自己在做什么，你可以将任何数字传感器连接到引脚2，然后再次运行脚本以查看更改后的状态。
- en: In the preceding Python script, the `serial.Serial` method interfaces and opens
    the specified serial port, while the `readline()` method reads each line from
    this interface, terminated with `\n`, that is, the newline character.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的Python脚本中，`serial.Serial`方法用于接口和打开指定的串行端口，而`readline()`方法则从该接口读取每行，以`\n`结束，即换行符。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The newline character is a special character that signifies the end of a line
    of text. It is also known as **End of Line** (**EOL**) or **Line feed + Carriage
    Return** (**LF + CR**). Learn more about the newline character at [http://en.wikipedia.org/wiki/Newline](http://en.wikipedia.org/wiki/Newline).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 换行符是一个特殊字符，表示文本行的结束。它也被称为**行结束**（**EOL**）或**换行+回车**（**LF + CR**）。了解更多关于换行符的信息，请访问[http://en.wikipedia.org/wiki/Newline](http://en.wikipedia.org/wiki/Newline)。
- en: Bridging pySerial and Firmata
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接pySerial和Firmata
- en: 'In the Firmata section, we already learned how useful it is to use the Firmata
    protocol instead of constantly modifying the Arduino sketch and uploading it for
    simple programs. `pySerial` is a simple library that provides a bridge between
    Arduino and Python via a serial port, but it lacks any support for the Firmata
    protocol. As mentioned earlier, the biggest benefit of Python can be described
    in one sentence, "There is a library for that." So, there exists a Python library
    called `pyFirmata` that is built on `pySerial` to support the Firmata protocol.
    There are a few other Python libraries that also support Firmata, but we will
    only be focusing on `pyFirmata` in this chapter. We will be extensively using
    this library for various upcoming projects as well:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firmata部分，我们已经了解到使用Firmata协议而不是不断修改Arduino草图并上传它对于简单程序是多么有用。`pySerial`是一个简单的库，它通过串行端口在Arduino和Python之间提供桥梁，但它不支持Firmata协议。如前所述，Python的最大好处可以用一句话来描述，“有库就能做到。”因此，存在一个名为`pyFirmata`的Python库，它是基于`pySerial`构建的，以支持Firmata协议。还有一些其他Python库也支持Firmata，但我们将只在本章中关注`pyFirmata`。我们将在即将到来的各种项目中广泛使用这个库：
- en: 'Let''s start by installing `pyFirmata` just like any other Python package by
    using Setuptools:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从像安装其他Python包一样安装`pyFirmata`开始，使用Setuptools：
- en: '[PRE11]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the previous section, while testing `pySerial`, we uploaded the `DigitalSerialRead`
    sketch to the Arduino board.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的章节中，当我们测试`pySerial`时，我们将`DigitalSerialRead`草图上传到了Arduino板。
- en: To communicate using the Firmata protocol, you need to upload the **StandardFirmata**
    sketch again, just as we did in the *Uploading a Firmata sketch to the Arduino
    board* section.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用Firmata协议进行通信，你需要再次上传**StandardFirmata**草图，就像我们在*上传Firmata草图到Arduino板*部分所做的那样。
- en: Once you have uploaded this sketch, open the Python interpreter and execute
    the following script. This script imports the `pyfirmata` library to the interpreter.
    It also defines the pin number and the port.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦上传了这个草图，打开Python解释器并执行以下脚本。此脚本将`pyfirmata`库导入到解释器中。它还定义了引脚号和端口。
- en: '[PRE12]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After this, we need to associate the port with the microcontroller board type:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们需要将端口与微控制器板类型关联：
- en: '[PRE13]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While executing the previous script, two LEDs on the Arduino will flicker as
    the communication link between the Python interpreter and the board gets established.
    In the *Testing the Firmata protocol* section, we used a prebuilt program to turn
    an LED on and off. Once the Arduino board is associated to the Python interpreter,
    these functions can be performed directly from the prompt.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在执行前面的脚本时，Arduino上的两个LED会闪烁，因为Python解释器和板之间的通信链路正在建立。在*测试Firmata协议*部分，我们使用了一个预构建的程序来开关LED。一旦Arduino板与Python解释器关联，这些功能可以直接从提示符中执行。
- en: 'You can now start playing with Arduino pins. Turn on the LED by executing the
    following command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以开始使用Arduino引脚进行实验了。通过执行以下命令来打开LED：
- en: '[PRE14]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can turn off the LED by executing the following command. Here, in both
    commands, we set the state of digital pin 13 by passing values `1` (**High**)
    or `0` (**Low**):'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过执行以下命令来关闭LED。在这两个命令中，我们通过传递值`1`（**高**）或`0`（**低**）来设置数字引脚13的状态：
- en: '[PRE15]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Similarly, you can also read the status of a pin from the prompt:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，您也可以从提示符中读取引脚的状态：
- en: '[PRE16]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we combined this script in an executable file with a `.py` extension, we
    can have a Python program that can be run directly to control the LED rather than
    running these individual scripts on a terminal. Later, this program can be extended
    to perform complex functions without writing or changing the Arduino sketch.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个脚本与具有`.py`扩展名的可执行文件结合起来，我们就可以拥有一个可以直接运行的Python程序来控制LED，而不是在终端上运行这些单个脚本。稍后，这个程序可以扩展以执行更复杂的功能，而无需编写或更改Arduino草图。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although we are running individual scripts at the Python prompt, we will be
    going through the process of creating Python executable files in the next chapter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在Python提示符中运行单个脚本，但我们将在下一章中介绍创建Python可执行文件的过程。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: By introducing the Firmata library, we avoided writing any custom Arduino sketches
    in this chapter. We will continue this practice during the remaining part of this
    book and will only use or make custom sketches when required. In this chapter,
    you interacted with the Arduino board by making the LED blink, which is the easiest
    way to get started on a hardware project. Now it's time for your first project,
    where we are also going to make some more LEDs blink. One might ask the question
    that if we have already done it, then why do we need another project to make LEDs
    blink? Let's find out.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入Firmata库，我们避免了在本章中编写任何自定义Arduino草图。我们将在本书剩余部分继续这种做法，并且只有在需要时才会使用或创建自定义草图。在本章中，您通过与Arduino板交互使LED闪烁来与之交互，这是开始硬件项目的最简单方法。现在，是时候开始您的第一个项目了，我们也将使更多的LED闪烁。有人可能会问，如果我们已经做到了这一点，那么为什么还需要另一个项目来使LED闪烁呢？让我们来看看。
