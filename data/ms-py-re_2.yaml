- en: Chapter 2. Regular Expressions with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。Python正则表达式
- en: In the previous chapter, we've seen how generic regular expressions work. In
    this chapter, we walk you through all the operations Python provides us with to
    work with regular expressions and how Python deals with them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经看到了通用正则表达式的工作原理。在本章中，我们将带您了解Python提供给我们的所有操作来处理正则表达式以及Python如何处理它们。
- en: To do so, we will see the quirks of the language when dealing with regular expressions,
    the different types of strings, the API it offers through the `RegexObject` and
    `MatchObject` classes, every operation that we can do with them in depth with
    many examples, as well as some problems generally faced by users. Lastly, we will
    see the small nuances and differences between Python and other regex engines and
    between Python 2 and Python 3.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将看到处理正则表达式时语言的怪癖，不同类型的字符串，通过`RegexObject`和`MatchObject`类提供的API，我们可以深入地了解它们的所有操作，并提供许多示例，以及一些通常由用户面临的问题。最后，我们将看到Python和其他正则表达式引擎以及Python
    2和Python 3之间的小细微差别。
- en: A brief introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简要介绍
- en: Since v1.5, Python provides a Perl-style regular expression with some subtle
    exceptions that we will see later. Both patterns and strings to be searched can
    be **Unicode** strings, as well as an 8-bit string (**ASCII**).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 自v1.5以来，Python提供了一种类似Perl的正则表达式，其中有一些微妙的例外情况，我们稍后会看到。要搜索的模式和字符串都可以是**Unicode**字符串，也可以是8位字符串（**ASCII**）。
- en: Tip
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Unicode is the universal encoding with more than 110.00 characters and 100 scripts
    to represent all the world's living characters and even historic scripts. You
    can think of it as a mapping between numbers, or code points as they are called,
    and characters. So, we can represent every character, no matter in what language,
    with one single number. For example, the character ![A brief introduction](graphics/inlinemedia1.jpg)
    is the number 26159, and it is represented as \u662f (hexadecimal) in Python.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode是一种通用编码，有超过110,000个字符和100种文字，可以表示世界上所有的活字和历史文字。您可以将它视为数字之间的映射，或者称为代码点，和字符。因此，我们可以用一个单一的数字表示每个字符，无论是什么语言。例如，字符![A
    brief introduction](graphics/inlinemedia1.jpg)是数字26159，它在Python中表示为\u662f（十六进制）。
- en: 'Regular expressions are supported by the `re` module. So, as with all modules
    in Python, we only need to import it to start playing with them. For that, we
    need to start the Python interactive shell using the following line of code:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式由`re`模块支持。因此，与Python中的所有模块一样，我们只需要导入它就可以开始使用它们。为此，我们需要使用以下代码行启动Python交互式shell：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once we have imported the module, we can start trying to match a pattern. To
    do so, we need to compile a pattern, transforming it into **bytecode**, as shown
    in the following line of code. This bytecode will be executed later by an engine
    written in C.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导入了模块，我们就可以开始尝试匹配模式。为此，我们需要编译一个模式，将其转换为**字节码**，如下面的代码行所示。这个字节码稍后将由用C编写的引擎执行。
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Bytecode is an intermediary language. It's the output generated by languages,
    which will be later interpreted by an interpreter. The Java bytecode that is interpreted
    by JVM is probably the best known example.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码是一种中间语言。它是由语言生成的输出，稍后将由解释器解释。由JVM解释的Java字节码可能是最著名的例子。
- en: 'Once we have the compiled pattern, we can try to match it against a string,
    as in the following code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了编译后的模式，我们可以尝试将其与字符串匹配，就像以下代码中所示的那样：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we mentioned in the preceding example, we compiled a pattern and then we
    searched whether the pattern matches the text *foo bar*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的例子中提到的，我们编译了一个模式，然后搜索这个模式是否与文本*foo bar*匹配。
- en: 'Working with Python and regular expressions in the command line is easy enough
    to perform quick tests. You just need to start the python interpreter and import
    the `re` module as we mentioned previously. However, if you prefer a GUI to test
    your regex, you can download one written in Python at the following link:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中使用Python和正则表达式很容易进行快速测试。您只需要启动Python解释器并像之前提到的那样导入`re`模块。但是，如果您更喜欢使用GUI来测试您的正则表达式，您可以在以下链接下载一个用Python编写的GUI：
- en: '[http://svn.python.org/view/*checkout*/python/trunk/Tools/scripts/redemo.py?content-type=text%2Fplain](http://svn.python.org/view/*checkout*/python/trunk/Tools/scripts/redemo.py?content-type=text%2Fplain)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://svn.python.org/view/*checkout*/python/trunk/Tools/scripts/redemo.py?content-type=text%2Fplain](http://svn.python.org/view/*checkout*/python/trunk/Tools/scripts/redemo.py?content-type=text%2Fplain)'
- en: There are a number of online tools such as the one at [https://pythex.org/](https://pythex.org/),
    as well as desktop programs such as RegexBuddy that we will cover in [Chapter
    5](ch05.html "Chapter 5. Performance of Regular Expressions"), *Performance of
    Regular Expressions*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多在线工具，比如[https://pythex.org/](https://pythex.org/)，以及桌面程序，比如我们将在[第5章](ch05.html
    "第5章。正则表达式的性能")中介绍的RegexBuddy，*正则表达式的性能*。
- en: At this point, it's preferable to use the interpreter to gain fluency with them
    and get direct feedback.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，最好使用解释器来熟练掌握它们并获得直接的反馈。
- en: Backslash in string literals
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串文字中的反斜杠
- en: 'Regular expressions aren''t part of the core Python language. Thus, there isn''t
    a special syntax for them and therefore they are handled as any other string.
    As we''ve seen in [Chapter 1](ch01.html "Chapter 1. Introducing Regular Expressions"),
    *Introducing Regular Expressions*, the backslash character `\` is used to indicate
    metacharacters or special forms in regular expressions. The backslash is also
    used in strings to escape special characters. In other words, it has a special
    meaning in Python. So, if we need to use the `\` character, we''ll have to escape
    it: `\\`. This will give the string literal meaning to the backslash. However,
    in order to match inside a regular expression, we should escape the backslashes,
    effectively writing four back slashes: `\\\\`.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式不是Python核心语言的一部分。因此，它们没有特殊的语法，因此它们被处理为任何其他字符串。正如我们在[第1章](ch01.html "第1章。介绍正则表达式")中看到的，*介绍正则表达式*，反斜杠字符`\`用于指示正则表达式中的元字符或特殊形式。反斜杠也用于字符串中转义特殊字符。换句话说，在Python中它有特殊含义。因此，如果我们需要使用`\`字符，我们将不得不对其进行转义：`\\`。这将给反斜杠赋予字符串字面意义。然而，为了在正则表达式中匹配，我们应该转义反斜杠，实际上写四个反斜杠：`\\\\`。
- en: 'Just as an example, let''s write a regular expression to match `\`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，让我们写一个正则表达式来匹配`\`：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, this is tedious and difficult to understand when the pattern
    is long.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，当模式很长时，这是繁琐且难以理解的。
- en: Python provides the **raw string notation** `r`, with which the backslashes
    are treated as normal characters. So, `r"\b"` is not the backspace anymore; it's
    just the character `\` and the character `b`, and the same goes for `r"\n"`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了**原始字符串表示法** `r`，其中反斜杠被视为普通字符。因此，`r"\b"`不再是退格键；它只是字符`\`和字符`b`，对于`r"\n"`也是一样。
- en: Python 2.x and Python 3.x treat strings differently. In Python 2, there are
    two types of Strings, 8-bit Strings and Unicode strings; while in Python 3, we
    have text and binary data. Text is always Unicode and the encoded Unicode is represented
    as binary data ([http://docs.python.org/3.0/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit](http://docs.python.org/3.0/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit)).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2.x和Python 3.x对字符串的处理方式不同。在Python 2中，有两种类型的字符串，8位字符串和Unicode字符串；而在Python
    3中，我们有文本和二进制数据。文本始终是Unicode，并且编码后的Unicode表示为二进制数据（[http://docs.python.org/3.0/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit](http://docs.python.org/3.0/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit)）。
- en: Strings have special notation to indicate what type we're using.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串有特殊的表示法来指示我们使用的类型。
- en: String Python 2.x
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串 Python 2.x
- en: '| Type | Prefixed | Description |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 前缀 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| String |   | String literals. They''re encoded automatically by using the
    default encoding (UTF-8 in our case). The backslash is necessary to escape meaningful
    characters.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '| 字符串 |   | 字符串字面值。它们通过使用默认编码（在我们的情况下是UTF-8）进行自动编码。反斜杠是必要的，以转义有意义的字符。'
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Raw string | `r` or `R` | They''re equal to literal strings with the exception
    of the backslashes, which are treated as normal characters.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '| 原始字符串 | `r` 或 `R` | 它们与字面字符串相同，除了反斜杠被视为普通字符。'
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Unicode string | `u` or `U` | These strings use the Unicode character set
    (ISO 10646).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode字符串 | `u` 或 `U` | 这些字符串使用Unicode字符集（ISO 10646）。
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Unicode raw string | `ur` or `UR` | They''re Unicode strings but treat backslashes
    as normal raw strings.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode原始字符串 | `ur` 或 `UR` | 它们是Unicode字符串，但将反斜杠视为普通的原始字符串。
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Go to the *What's new in Python 3* section to find out how the notation is in
    Python 3
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 转到*Python 3中的新内容*部分，了解Python 3中的表示法是什么
- en: 'Using raw string is the recommended option following the Python official documentation,
    and that''s what we will be using with Python 2.7 throughout the book. So with
    this in mind, we can rewrite the regex as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python官方文档，使用原始字符串是推荐的选项，这也是我们在整本书中将要使用的Python 2.7。因此，考虑到这一点，我们可以将正则表达式重写如下：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Building blocks for Python regex
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python正则表达式的构建块
- en: 'In Python, there are two different objects dealing with Regex:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，有两种不同的对象处理正则表达式：
- en: '`RegexObject`: It is also known as *Pattern Object*. It represents a compiled
    regular expression'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegexObject`：它也被称为*Pattern Object*。它表示编译后的正则表达式'
- en: '`MatchObject`: It represents the matched pattern'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MatchObject`：它表示匹配的模式'
- en: RegexObject
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RegexObject
- en: In order to start matching patterns, we'll have to compile the regex. Python
    gives us an interface to do that as we've seen previously. The result will be
    a pattern object or `RegexObject`. This object has several methods for typical
    operations on regular expressions. As we will see later, the `re` module provides
    a shorthand for every operation so that we can avoid compiling it first.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始匹配模式，我们将不得不编译正则表达式。Python给了我们一个接口来做到这一点，就像我们之前看到的那样。结果将是一个模式对象或`RegexObject`。这个对象有几种用于正则表达式的典型操作的方法。正如我们将在后面看到的，`re`模块提供了每个操作的简写，以便我们可以避免首先编译它。
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The compilation of a regular expression produces a reusable pattern object
    that provides all the operations that can be done, such as matching a pattern
    and finding all substrings that match a particular regex. So, for example, if
    we want to know if a string starts with `<HTML>`, we can use the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的编译产生一个可重用的模式对象，提供了所有可以进行的操作，比如匹配模式和找到所有匹配特定正则表达式的子字符串。因此，例如，如果我们想知道一个字符串是否以`<HTML>`开头，我们可以使用以下代码：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are two ways of matching patterns and executing the operations related
    to the regular expressions. We can compile a pattern, which gives us a `RegexObject`,
    or we can use the module operations. Let's compare the two different mechanisms
    in the following examples.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种匹配模式和执行与正则表达式相关的操作的方法。我们可以编译一个模式，这给了我们一个`RegexObject`，或者我们可以使用模块操作。让我们在以下示例中比较这两种不同的机制。
- en: 'If we want to re-use the regular expression, we can use the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要重复使用正则表达式，我们可以使用以下代码：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On the other hand, we can directly perform the operation on the module using
    the following line of code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以直接在模块上执行操作，使用以下代码行：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `re` module provides a wrapper for every operation in the `RegexObject`.
    You can see them as shortcuts.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`re`模块为`RegexObject`中的每个操作提供了一个包装器。您可以将它们视为快捷方式。'
- en: Internally, these wrappers create the `RegexObject` and then call the corresponding
    method. You might be wondering whether every time you call one of these wrappers
    it compiles the regular expression first. The answer is no. The `re` module caches
    the compiled pattern so that in future calls it doesn't have to compile it again.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，这些包装器创建了`RegexObject`，然后调用相应的方法。您可能想知道每次调用这些包装器时是否都会先编译正则表达式。答案是否定的。`re`模块会缓存已编译的模式，以便在将来的调用中不必再次编译它。
- en: Beware of the memory needs of your program. When you're using module operations,
    you don't control the cache, and so you can end up with a lot of memory usage.
    You can always use `re.purge` to clear the cache but this is a tradeoff with performance.
    Using compiled patterns allows you to have a fine-grained control of the memory
    consumption because you can decide when to purge them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意您的程序的内存需求。当您使用模块操作时，您无法控制缓存，因此可能会导致大量内存使用。您可以随时使用`re.purge`来清除缓存，但这会影响性能。使用编译后的模式允许您对内存消耗进行精细控制，因为您可以决定何时清除它们。
- en: There are some differences between both ways though. With the `RegexObject`,
    it is possible to limit the region in which the pattern will be searched, for
    example limit the search of a pattern between the characters at index 2 and 20\.
    In addition to that, you can set `flags` in every call by using the operations
    in the module. However, be careful; every time you change the flag, a new pattern
    will be compiled and cached.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方式之间有一些区别。使用`RegexObject`，可以限制模式将在其中搜索的区域，例如限制在索引2和20之间的模式搜索。除此之外，您可以通过在模块中使用操作来在每次调用中设置`flags`。但是要小心；每次更改标志时，都会编译并缓存一个新模式。
- en: Let's dive into the most important operations that can be done with a pattern
    object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解可以使用模式对象执行的最重要操作。
- en: Searching
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索
- en: Let's see the operations we have to look for patterns in strings. Note that
    python has two operations, match and search; where many other languages have one,
    match.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们必须在字符串中查找模式的操作。请注意，Python有两种操作，match和search；而许多其他语言只有一种操作，match。
- en: match(string[, pos[, endpos]])
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: match(string[, pos[, endpos]])
- en: 'This method tries to match the compiled pattern only at the beginning of the
    string. If there is a match, then it returns a `MatchObject`. So, for example,
    let''s try to match whether a string starts with `<HTML>` or not:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法尝试仅在字符串的开头匹配编译后的模式。如果匹配成功，则返回一个`MatchObject`。因此，例如，让我们尝试匹配一个字符串是否以`<HTML>`开头：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding example, first we've compiled the pattern and then we've found
    a match in the `<HTML><head>` string.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，首先我们编译了模式，然后在`<HTML><head>`字符串中找到了一个匹配。
- en: 'Let''s see what happens when the string doesn''t start with `<HTML>`, as shown
    in the following lines of code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当字符串不以`<HTML>`开头时会发生什么，如下面的代码行所示：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, there is no match. Remember what we said before, `match` tries
    to match at the beginning of the string. The string starts with a whitespace unlike
    the pattern. Note the difference with `search` in the following example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，没有匹配。请记住我们之前说过的，`match`尝试在字符串的开头进行匹配。字符串以空格开头，与模式不同。请注意与以下示例中的`search`的区别：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As expected, we have a match.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们有一个匹配。
- en: 'The optional **pos** parameter specifies where to start searching, as shown
    in the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的**pos**参数指定从哪里开始搜索，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the highlighted code, we can see how the pattern has a match even though
    there are two whitespaces in the string. This is possible because we've set **pos**
    to `2`, so the match operation starts searching in that position.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们可以看到即使字符串中有两个空格，模式也能匹配。这是可能的，因为我们将**pos**设置为`2`，所以匹配操作从该位置开始搜索。
- en: 'Note that **pos** bigger than 0 doesn''t mean that string starts at that index,
    for example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，**pos**大于0并不意味着字符串从该索引开始，例如：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we've created a pattern to match strings in which the
    first character after "start" is followed by `<HTML>`. After that, we've tried
    to match the string `<HTML>` starting at the second character, `<`. There is no
    match because the pattern is trying to match the `^` metacharacter at the `2`
    position first.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了一个模式，用于匹配字符串，其中“start”后的第一个字符后面跟着`<HTML>`。然后，我们尝试从第二个字符`<`开始匹配字符串`<HTML>`。由于模式试图首先在位置`2`匹配`^`元字符，因此没有匹配。
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Anchor characters tip**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**锚字符提示**'
- en: The characters `^` and `$` indicate the start and end of the string respectively.
    You can neither see them in the strings nor write them, but they are always there
    and are valid characters for the regex engine.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 字符`^`和`$`分别表示字符串的开头和结尾。您既看不到它们在字符串中，也不能写它们，但它们总是存在的，并且是正则表达式引擎的有效字符。
- en: 'Note the different result if we slice the string 2 positions, as in the following
    code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们将字符串切片2个位置，结果会有所不同，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The slice gives us a new string; therefore, there is a `^` metacharacter in
    it. On the contrary, **pos** just moves the index to the starting point for the
    search in the string.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 切片给我们一个新的字符串；因此，它里面有一个`^`元字符。相反，**pos**只是将索引移动到字符串中搜索的起始点。
- en: 'The second argument, **endpos**, sets how far the pattern will try to match
    in the string. In the following case, it''s equivalent to slicing:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数**endpos**设置模式在字符串中尝试匹配的距离。在下面的情况中，它相当于切片：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So, in the following case, we don''t have the problem mentioned with **pos**.
    There is a match even when the `$` metacharacter is used:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在下面的情况中，我们不会遇到**pos**中提到的问题。即使使用了`$`元字符，也会有匹配：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, there is no difference between slicing and **endpos**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，切片和**endpos**之间没有区别。
- en: search(string[, pos[, endpos]])
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: search(string[, pos[, endpos]])
- en: This operation would be like the **match** of many languages, Perl for example.
    It tries to match the pattern at any location of the string and not just at the
    beginning. If there is a match, it returns a `MatchObject`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作就像许多语言中的**match**，例如Perl。它尝试在字符串的任何位置匹配模式，而不仅仅是在开头。如果有匹配，它会返回一个`MatchObject`。
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The **pos** and **endpos** parameters have the same meaning as that in the `match`
    operation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**pos**和**endpos**参数的含义与`match`操作中的相同。'
- en: Note that with the `MULTILINE` flag, the `^` symbol matches at the beginning
    of the string and at the beginning of each line (we'll see more on this flag later).
    So, it changes the behavior of `search`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`MULTILINE`标志，`^`符号在字符串的开头和每行的开头匹配（我们稍后会更多地了解这个标志）。因此，它改变了`search`的行为。
- en: In the following example, the first `search` matches `<HTML>` because it's at
    the beginning of the string, but the second `search` doesn't match because the
    string starts with a whitespace. And finally, in the third `search`, we have a
    match as we find `<HTML>` right after new line, thanks to `re.MULTILINE`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，第一个`search`匹配`<HTML>`，因为它在字符串的开头，但第二个`search`不匹配，因为字符串以空格开头。最后，在第三个`search`中，我们有一个匹配，因为我们在新行后找到了`<HTML>`，这要归功于`re.MULTILINE`。
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So, as long as the **pos** parameter is less than, or equal to, the new lines,
    there will be a match.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只要**pos**参数小于或等于新行，就会有一个匹配。
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: findall(string[, pos[, endpos]])
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: findall(string[, pos[, endpos]])
- en: The previous operations worked with one match at a time. On the contrary, in
    this case it returns a list with all the non-overlapping occurrences of a pattern
    and not the `MatchObject` like `search` and `match` do.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的操作一次只能匹配一个。相反，在这种情况下，它返回一个列表，其中包含模式的所有不重叠的出现，而不是像`search`和`match`那样返回`MatchObject`。
- en: In the following example, we're looking for every word in a string. So, we obtain
    a list in which every item is the pattern found, in this case a word.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们正在寻找字符串中的每个单词。因此，我们得到一个列表，其中每个项目都是找到的模式，这里是一个单词。
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Keep in mind that empty matches are a part of the result:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，空匹配是结果的一部分：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: I bet you're wondering what's happening here? The trick comes from the `*` quantifier,
    which allows 0 or more repetitions of the preceding regex; the same had happened
    with the `?` quantifier.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌你想知道这里发生了什么？这个技巧来自`*`量词，它允许前面的正则表达式重复0次或更多次；与`?`量词发生的情况相同。
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Basically, both of them match the expression even though the preceding regex
    is not found:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，它们两个都匹配表达式，即使前面的正则表达式没有找到：
- en: '![findall(string[, pos[, endpos]])](graphics/3156OS_02_01.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![findall(string[, pos[, endpos]])](graphics/3156OS_02_01.jpg)'
- en: findall matching process
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: findall匹配过程
- en: First, the regex matches the character `a`, then it follows with `b`. There
    is a match due to the `*` quantifier, the empty string. After that, it matches
    another `a` and finally it tries to match `$`. As we've mentioned before, even
    though you can't see `$`, it's a valid character for the regex engine. As it happened
    with the `b`, it matches due to the `*` quantifier.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，正则表达式匹配字符`a`，然后跟着`b`。由于`*`量词，空字符串也会匹配。之后，它匹配另一个`a`，最后尝试匹配`$`。正如我们之前提到的，即使你看不到`$`，它对于正则表达式引擎来说也是一个有效的字符。就像`b`一样，由于`*`量词，它会匹配。
- en: We've seen quantifiers in depth in [Chapter 1](ch01.html "Chapter 1. Introducing
    Regular Expressions"), *Introducing Regular Expressions*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](ch01.html "第1章。介绍正则表达式")*介绍正则表达式*中深入了解了量词。
- en: In case there are groups in the pattern, they are returned as tuples. The string
    is scanned from left to right, so the groups are returned in the same order they
    are found.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模式中有组，它们将作为元组返回。字符串从左到右扫描，因此组将按照它们被找到的顺序返回。
- en: The following example tries to match a pattern made of two words and creates
    a group for every word. That's why we have a list of tuples in which every tuple
    has two groups.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例尝试匹配由两个单词组成的模式，并为每个单词创建一个组。这就是为什么我们有一个元组列表，其中每个元组有两个组。
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `findall` operation along with `groups` is another thing that seems to confuse
    a lot of people. In [Chapter 3](ch03.html "Chapter 3. Grouping"), *Groups*, we've
    dedicated a complete section to explain this complex subject.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`findall`操作以及`groups`似乎是许多人困惑的另一件事情。在[第3章](ch03.html "第3章。分组")*分组*中，我们专门有一个完整的部分来解释这个复杂的主题。'
- en: finditer(string[, pos[, endpos]])
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: finditer(string[, pos[, endpos]])
- en: Its working is essentially the same as `findall`, but it returns an iterator
    in which each element is a `MatchObject`, so we can use the operations provided
    by this object. So, it's quite useful when you need information for every match,
    for example the position in which the substring was matched. Several times, I've
    found myself using it to understand what's happening in `findall`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理与`findall`基本相同，但它返回一个迭代器，其中每个元素都是一个`MatchObject`，因此我们可以使用这个对象提供的操作。因此，当您需要每个匹配的信息时，例如匹配子字符串的位置时，它非常有用。有好几次，我发现自己使用它来理解`findall`中发生了什么。
- en: 'Let''s go back to one of our initial examples. Match every two words and capture
    them:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们最初的一个例子。匹配每两个单词并捕获它们：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding example, we can see how we get an iterator with all the matches.
    For every element in the iterator, we get a `MatchObject`, so we can see the captured
    groups in the pattern, two in this case. We will also get the position of the
    match.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以看到我们得到了一个包含所有匹配的迭代器。对于迭代器中的每个元素，我们得到一个`MatchObject`，因此我们可以看到模式中捕获的组，在这种情况下是两个。我们还将得到匹配的位置。
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we consume another element from the iterator and perform the same operations
    as before. So, we get the next match, its groups, and the position of the match.
    We''ve done the same as we did with the first match:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们从迭代器中消耗另一个元素，并执行与之前相同的操作。因此，我们得到下一个匹配，它的组和匹配的位置。我们与第一个匹配所做的事情一样：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finally, we try to consume another match, but in this case a `StopIteration`
    exception is thrown. This is normal behavior to indicate that there are no more
    elements.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们尝试消耗另一个匹配，但在这种情况下会抛出`StopIteration`异常。这是指示没有更多元素的正常行为。
- en: Modifying a string
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改字符串
- en: In this section, we're going to see the operations to modify strings, such as
    an operation to divide the string and another to replace some parts of it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到修改字符串的操作，比如将字符串分割的操作和替换其中某些部分的操作。
- en: split(string, maxsplit=0)
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: split(string, maxsplit=0)
- en: 'In almost every language, you can find the `split` operation in strings. The
    big difference is that the split in the `re` module is more powerful due to which
    you can use a regex. So, in this case, the string is split based on the matches
    of the pattern. As always, the best way to understand it is with an example, so
    let''s split a string into lines:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎每种语言中，你都可以在字符串中找到`split`操作。最大的区别在于`re`模块中的`split`更加强大，因为你可以使用正则表达式。因此，在这种情况下，字符串是基于模式的匹配进行分割的。和往常一样，最好的理解方法是通过一个例子，所以让我们将一个字符串分割成行：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding example, the match is `\n`; so, the string is split using
    it as the separator. Let''s see a more complex example of how to get the words
    in a string:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，匹配是`\n`；因此，字符串是使用它作为分隔符进行分割的。让我们看一个更复杂的例子，如何获取字符串中的单词：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding example, we''ve defined a pattern to match any non-alphanumeric
    character. So, in this case the match happens in the whitespace. That''s why the
    string is split into words. Let''s see another example to understand it better:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了一个匹配任何非字母数字字符的模式。因此，在这种情况下，匹配发生在空格中。这就是为什么字符串被分割成单词。让我们看另一个例子来更好地理解它：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that the match is the whitespace.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，匹配的是空格。
- en: 'The **maxsplit** parameter specifies how many splits can be done at maximum
    and returns the remaining part in the result:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**maxsplit**参数指定最多可以进行多少次分割，并将剩余部分返回为结果：'
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, only two words are split and the other words are a part of the
    result.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，只有两个单词被分割，其他单词是结果的一部分。
- en: Have you realized that the pattern matched is not included? Take a look at every
    example in this section. What can we do if we want to capture the pattern too?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否意识到匹配的模式没有被包括？看一下本节中的每个例子。如果我们想要捕获模式，我们该怎么办？
- en: 'The answer is to use groups:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是使用组：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This happens because the split operation always returns the captured groups.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为分割操作总是返回捕获的组。
- en: 'Note that when a group matches the start of the string, the result will contain
    the empty string as a first result:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当一个组匹配字符串的开头时，结果将包含空字符串作为第一个结果：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: sub(repl, string, count=0)
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: sub(repl, string, count=0)
- en: 'This operation returns the resulting string after replacing the matched pattern
    in the original string with the replacement. If the pattern is not found, the
    original string is returned. For example, we''re going to replace the digits in
    the string with `-` (dash):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作返回原始字符串中替换匹配模式后的结果字符串。如果未找到模式，则返回原始字符串。例如，我们将用`-`（破折号）替换字符串中的数字：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Basically, the regex matches 1 and more digits and replaces the pattern matched,
    `0`, `1`, and `13` here, with `-` (dash).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，正则表达式匹配1个或多个数字，并用匹配的模式`0`、`1`和`13`替换为`-`（破折号）。
- en: 'Note that it replaces the leftmost non-overlapping occurrences of the pattern.
    Let''s see another example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它替换了模式的最左边的非重叠出现。让我们看另一个例子：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding example, we're replacing zeroes two by two. So, the first two
    are matched and then replaced, then the following two zeroes are matched and replaced
    too, and finally the last zero is left intact.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们是两两替换零。因此，首先匹配并替换前两个，然后接下来的两个零也被匹配并替换，最后剩下最后一个零。
- en: 'The `repl` argument can also be a function, in which case it receives a MatchObject
    as an argument and the string returned is the replacement. For example, imagine
    you have a legacy system in which there are two kinds of orders. Some start with
    a dash and the others start with a letter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`repl`参数也可以是一个函数，这种情况下，它接收一个MatchObject作为参数，并返回的字符串是替换后的结果。例如，想象一下你有一个旧系统，其中有两种类型的订单。一些以破折号开头，另一些以字母开头：'
- en: '-1234'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-1234'
- en: A193, B123, C124
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A193, B123, C124
- en: 'You must change it to the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须将其更改为以下内容：
- en: A1234
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A1234
- en: B193, B123, B124
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B193, B123, B124
- en: In short, the ones starting with a dash should start with an A and the rest
    should start with a B.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，以破折号开头的应该以A开头，其余的应该以B开头。
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As mentioned previously, for each matched pattern the `normalize_orders` function
    is called. So, if the first matched group is a `–`, then we return an `A`; in
    any other case, we return `B`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，对于每个匹配的模式，都会调用`normalize_orders`函数。因此，如果第一个匹配的组是`–`，那么我们返回`A`；在任何其他情况下，我们返回`B`。
- en: Note that in the code we get the first group with the index 1; take a look at
    the `group` operation to understand why.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在代码中，我们使用索引1获取第一个组；看一下`group`操作，以了解原因。
- en: 'Backreferences, a powerful feature is also provided by `sub`. We''ll see them
    in depth in the next chapter. Basically, what it does is that it replaces the
    backreferences with the corresponding groups. For example, let''s say you want
    to transform markdown to HTML, for the sake of keeping the example short, just
    bold the text:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 反向引用，也是`sub`提供的一个强大功能。我们将在下一章中深入了解它们。基本上，它的作用是用相应的组替换反向引用。例如，假设你想要将markdown转换为HTML，为了简化示例，只需将文本加粗：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As always, the previous example first compiles the pattern, which matches every
    word between the two `*`, and in addition to that it captures the word. Note that
    thanks to the `?` metacharacter the pattern is non-greedy.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，前面的例子首先编译了模式，它匹配两个`*`之间的每个单词，并且捕获了这个单词。请注意，由于`?`元字符，模式是非贪婪的。
- en: 'Note that `\g<number>` is there to avoid ambiguity with literal numbers, for
    example, imagine you need to add "1" right after a group:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`\g<number>`是为了避免与字面数字产生歧义，例如，想象一下，你需要在一个组后面添加"1"：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you can see, the behavior is as expected. Let''s see what happens on using
    the notation without `<` and `>`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，行为是符合预期的。让我们看看在使用没有`<`和`>`的符号时会发生什么：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding example, the group is highlighted to remove ambiguity and help
    us see it, and that's precisely the problem the regex engine is facing. Here,
    the regex engine tries to use the group number 11 which doesn't exist. For this
    reason, there is the `\g<group>` notation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，突出显示了该组以消除歧义并帮助我们看到它，这正是正则表达式引擎所面临的问题。在这里，正则表达式引擎尝试使用不存在的第11组。因此，有`\g<group>`表示法。
- en: Another thing to keep in mind with `sub` is that every backslash that escapes
    in the replacement string will be processed. As you can see in `<\\b>`, you need
    to escape them if you want to avoid it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`sub`的另一点需要记住的是，替换字符串中的每个反斜杠都将被处理。正如你在`<\\b>`中看到的，如果你想避免它，你需要对它们进行转义。'
- en: You can limit the number of replacements with the optional **count** argument.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用可选的**count**参数限制替换的次数。
- en: subn(repl, string, count=0)
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: subn(repl, string, count=0)
- en: 'It is basically the same operation as `sub`, you can think of it as a utility
    above `sub`. It returns a tuple with the new string and the number of substitutions
    made. Let us see the working by using the same example as before:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上与`sub`相同，你可以将它视为`sub`的一个实用程序。它返回一个包含新字符串和替换次数的元组。让我们通过使用与之前相同的示例来看一下它的工作：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It's been a long section. We explored the main operations we can do with `re`
    module and the `RegexObject` class along with examples. Let's continue with the
    object we get after a match.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很长的部分。我们探讨了我们可以使用`re`模块和`RegexObject`类进行的主要操作以及示例。让我们继续讨论匹配后得到的对象。
- en: MatchObject
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MatchObject
- en: 'This object represents the matched pattern; you will get one every time you
    execute one of these operations:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象代表了匹配的模式；每次执行这些操作时都会得到一个：
- en: match
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: match
- en: search
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: search
- en: finditer
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: finditer
- en: This object provides us with a set of operations for working with the captured
    groups, getting information about the position of the match, and so on. Let's
    see the most important operations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象为我们提供了一组操作，用于处理捕获的组，获取有关匹配位置的信息等。让我们看看最重要的操作。
- en: group([group1, …])
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: group([group1, …])
- en: The `group` operation gives you the subgroups of the match. If it's invoked
    with no arguments or zero, it will return the entire match; while if one or more
    group identifiers are passed, the corresponding groups' matches will be returned.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`group`操作给出了匹配的子组。如果没有参数或零调用它，它将返回整个匹配；而如果传递一个或多个组标识符，则将返回相应组的匹配。'
- en: 'Let''s see them with an example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来看看：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The pattern matches the whole string and captures two groups, `Hello` and `world`.
    Once we have the match, we can see the the following concrete cases:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配整个字符串并捕获两个组，`Hello`和`world`。一旦我们有了匹配，我们可以看到以下具体情况：
- en: With no arguments or zero, it returns the entire match.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有参数或零，它返回整个匹配。
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With `group1` bigger than 0, it returns the corresponding group.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`group1`大于0，它返回相应的组。
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If the group doesn't exist, an `IndexError` will be thrown.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果该组不存在，将抛出`IndexError`。
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: With multiple arguments, it returns the corresponding groups.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个参数，它返回相应的组。
- en: '[PRE48]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this case, we want the whole pattern and the second group, that's why we
    pass `0` and `2`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们想要整个模式和第二组，这就是为什么我们传递`0`和`2`。
- en: 'Groups can be named, we''ll see it in depth in the next chapter; there is a
    special notation for it. If the pattern has named groups, they can be accessed
    using the names or the index:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 组可以被命名，我们将在下一章中深入讨论；有一个特殊的表示方法。如果模式有命名组，可以使用名称或索引来访问它们：
- en: '[PRE49]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the preceding example, we''ve compiled a pattern to capture two groups:
    the first one is named `first` and the second one is named `second`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们编译了一个模式来捕获两个组：第一个命名为`first`，第二个命名为`second`。
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In this way, we can get a group by its name. Note that using named groups we
    can still get the groups by their index, as shown in the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以通过名称获取组。请注意，使用命名组，我们仍然可以通过它们的索引获取组，就像下面的代码中所示：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can even use both types:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以同时使用两种类型：
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: groups([default])
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: groups([default])
- en: 'The `groups` operation is similar to the previous operation. However, in this
    case it returns a tuple with all the subgroups in the match instead of giving
    you one or some of the groups. Let''s see it with the example we''ve used in the
    previous section:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`groups`操作类似于前面的操作。但是，在这种情况下，它返回一个包含匹配中所有子组的元组，而不是给出一个或一些组。让我们用前一节中使用的例子来看一下：'
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As we had in the previous section, we have two groups `Hello` and `World` and
    that's exactly what `groups` gives us. In this case, you can see `groups` as `group(1,
    lastGroup)`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在前一节中看到的那样，我们有两个组`Hello`和`World`，这正是`groups`给我们的。在这种情况下，您可以将`groups`视为`group(1,
    lastGroup)`。
- en: 'In case there are groups that don''t match, the default argument is returned.
    If the default argument is not specified then `None` is used, for example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有不匹配的组，将返回默认参数。如果未指定默认参数，则使用`None`，例如：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The pattern in the preceding example is trying to match two groups made of one
    or more alphanumeric characters. The second one is optional; so we get only one
    group with the string `Hello`. After getting the match, we call `groups` with
    `default` set to `mundo` so that it returns `mundo` as the second group. Note
    that in the following call we don't set default, so `None` is returned.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例中的模式试图匹配由一个或多个字母数字字符组成的两个组。第二个是可选的；所以我们只得到一个包含字符串`Hello`的组。在获得匹配后，我们调用`groups`，将`default`设置为`mundo`，这样它就返回`mundo`作为第二组。请注意，在下面的调用中，我们没有设置默认值，因此返回`None`。
- en: groupdict([default])
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: groupdict([default])
- en: 'The `groupdict` method is used in the cases where named groups have been used.
    It will return a dictionary with all the groups that were found:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupdict`方法用于已使用命名组的情况。它将返回一个包含所有找到的组的字典：'
- en: '[PRE55]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding example, we use a pattern similar to what we've seen in the
    previous sections. It captures two groups with the names `first` and `second`.
    So, `groupdict` returns them in a dictionary. Note that if there aren't named
    groups, then it returns an empty dictionary.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了与前几节中看到的类似的模式。它使用名称为“first”和“second”的两个组进行捕获。因此，“groupdict”以字典形式返回它们。请注意，如果没有命名组，则它将返回一个空字典。
- en: Don't worry if you don't understand quite well what is happening here. As we've
    mentioned before, we'll see everything related to groups in [Chapter 3](ch03.html
    "Chapter 3. Grouping"), *Groups*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不太明白这里发生了什么，不要担心。正如我们之前提到的，我们将在[第3章](ch03.html "第3章。分组")中看到与分组相关的所有内容，*分组*。
- en: start([group])
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: start（[组]）
- en: 'Sometimes, it is useful to know the index where the pattern matched. As with
    all the operations related to groups, if the argument group is zero, then the
    operation works with the whole string matched:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，知道模式匹配的索引位置是有用的。与所有与组相关的操作一样，如果参数组为零，则该操作将使用匹配的整个字符串：
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If there are groups that don''t match, then `-1` is returned:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有不匹配的组，则返回“-1”：
- en: '[PRE57]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: end([group])
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: end（[组]）
- en: 'The `end` operation behaves exactly the same as `start`, except that it returns
    the end of the substring matched by the group:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: “end”操作的行为与“start”完全相同，只是它返回与组匹配的子字符串的结尾：
- en: '[PRE58]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: span([group])
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: span（[组]）
- en: 'It''s an operation that gives you a tuple with the values from `start` and
    `end`. This operation is often used in text editors to locate and highlight a
    search. The following code is an example of this operation:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个操作，它给出一个包含`start`和`end`的元组。这个操作经常用于文本编辑器中来定位和突出显示搜索。以下代码是这个操作的一个示例：
- en: '[PRE59]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: expand(template)
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展（模板）
- en: This operation returns the string after replacing it with backreferences in
    the template string. It's similar to `sub`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作返回替换模板字符串后的字符串。它类似于`sub`。
- en: 'Continuing with the example in the previous section:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上一节的示例：
- en: '[PRE60]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Module operations
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块操作
- en: Let's see two useful operations from the module.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看模块中的两个有用的操作。
- en: escape()
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转义（）
- en: It escapes the literals that may appear in the expressions.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 它转义可能出现在表达式中的文字。
- en: '[PRE61]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: purge()
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清除（）
- en: It purges the regular expressions cache. We've already talked about this; you
    need to use this in order to release memory when you're using the operations through
    the module. Keep in mind that there is a tradeoff with the performance; once you
    release the cache, every pattern has to be compiled and cached again.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 它清除正则表达式缓存。我们已经谈论过这一点；当您通过模块使用操作时，您需要使用它以释放内存。请记住，这会影响性能；一旦释放缓存，每个模式都必须重新编译和缓存。
- en: Well done, you already know the main operations that you can do with the `re`
    module. After this, you can start using regex in your projects without many problems.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好，你已经知道了你可以用`re`模块做的主要操作。之后，你可以在项目中开始使用正则表达式而不会遇到太多问题。
- en: Now, we're going to see how to change the default behavior of the patterns.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到如何更改模式的默认行为。
- en: Compilation flags
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译标志
- en: When compiling a pattern string into a pattern object, it's possible to modify
    the standard behavior of the patterns. In order to do that, we have to use the
    compilation flags. These can be combined using the bitwise OR "`|`".
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在将模式字符串编译为模式对象时，可以修改模式的标准行为。为了做到这一点，我们必须使用编译标志。这些可以使用按位或“|”组合。
- en: '| Flag | Python | Description |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | Python | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `re.IGNORECASE` or `re.I` | 2.x3.x | The pattern will match lower case and
    upper case. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `re.IGNORECASE`或`re.I` | 2.x3.x | 该模式将匹配小写和大写。 |'
- en: '| `re.MULTILINE` or `re.M` | 2.x3.x | This flag changes the behavior of two
    metacharacters:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '| `re.MULTILINE`或`re.M` | 2.x3.x | 此标志更改了两个元字符的行为：'
- en: '`^`: Which now matches at the beginning of the string and at the beginning
    of each new line.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^`：现在匹配字符串的开头和每一行的开头。'
- en: '`$`: In this case, it matches at the end of the string and the end of each
    line. Concretely, it matches right before the newline character.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`：在这种情况下，它匹配字符串的结尾和每一行的结尾。具体来说，它匹配换行符之前的位置。'
- en: '|'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `re.DOTALL` or `re.S` | 2.x3.x | The metacharacter "`.`" will match any character
    even the newline. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `re.DOTALL`或`re.S` | 2.x3.x | 元字符“。”将匹配任何字符，甚至包括换行符。'
- en: '| `re.LOCALE` or `re.L` | 2.x3.x | This flag makes \w, \W, \b, \B, \s, and
    \S dependent on the current locale."re.LOCALE just passes the character to the
    underlying C library. It really only works on bytestrings which have 1 byte per
    character. UTF-8 encodes code points outside the ASCII range to multiple bytes
    per code point, and the re module will treat each of those bytes as a separate
    character." (at [http://www.gossamer-threads.com/lists/python/python/850772](http://www.gossamer-threads.com/lists/python/python/850772))Note
    that when using `re.L` and `re.U` together (re.L&#124;re.U, only Locale is used).
    Also, note that in Python 3 the use of this flag is discouraged; go to the documentation
    for more info. |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `re.LOCALE`或`re.L` | 2.x3.x | 此标志使\w、\W、\b、\B、\s和\S依赖于当前区域设置。“re.LOCALE只是将字符传递给底层的C库。它实际上只适用于每个字符有1个字节的字节串。UTF-8将ASCII范围之外的码点编码为每个码点多个字节，re模块将把这些字节中的每一个都视为单独的字符。”（在[http://www.gossamer-threads.com/lists/python/python/850772](http://www.gossamer-threads.com/lists/python/python/850772)）请注意，当使用`re.L`和`re.U`一起时（re.L&#124;re.U，只使用区域设置）。另请注意，在Python
    3中，不鼓励使用此标志；请查看文档以获取更多信息。'
- en: '| `re.VERBOSE` or `re.X` | 2.x3.x | It allows writing of regular expressions
    that are easier to read and understand. For that, it treats some characters in
    a special way:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '| `re.VERBOSE`或`re.X` | 2.x3.x | 它允许编写更易于阅读和理解的正则表达式。为此，它以一种特殊的方式处理一些字符：'
- en: Whitespace is ignored except when it's in character class or preceded by a backslash
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略空格，除非它在字符类中或者在反斜杠之前
- en: 'All characters to the right of the # are ignored like it was a comment, except
    when # is preceded by the backslash or it''s in a character class.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '#右侧的所有字符都被忽略，就像是注释一样，除非#之前有反斜杠或者它在字符类中。'
- en: '|'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `re.DEBUG` | 2.x3.x | It gives you information about the compilation pattern.
    |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `re.DEBUG` | 2.x3.x | 它为您提供有关编译模式的信息。 |'
- en: '| `re.UNICODE` or `re.U` | 2.x | It makes \w, \W, \b, \B, \d, \D, \s, and \S
    dependent on the Unicode character properties database. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `re.UNICODE`或`re.U` | 2.x | 它使\w、\W、\b、\B、\d、\D、\s和\S依赖于Unicode字符属性数据库。 |'
- en: '| `re.ASCII` or `re.A` (only Python 3) | 3.x | It makes \w, \W, \b, \B, \d,
    \D, \s, and \S perform ASCII-only matching. This makes sense because in Python
    3 the matches are Unicode by default. You can find more on this in the *What''s
    new on Python 3* section. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `re.ASCII`或`re.A`（仅Python 3）| 3.x | 它使\w、\W、\b、\B、\d、\D、\s和\S执行仅ASCII匹配。这是有道理的，因为在Python
    3中，默认情况下匹配是Unicode的。您可以在“Python 3的新功能”部分中找到更多信息。 |'
- en: Let's see some examples of the most important flags.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些最重要的标志示例。
- en: re.IGNORECASE or re.I
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: re.IGNORECASE或re.I
- en: As you can see, the following pattern matches even though the string starts
    with A and not with an a.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，以下模式匹配，即使字符串以A开头而不是a开头。
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: re.MULTILINE or re.M
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: re.MULTILINE或re.M
- en: 'In the following example, the pattern doesn''t match the date after newline
    because we''re not using the flag:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，模式不匹配换行符后的日期，因为我们没有使用标志：
- en: '[PRE63]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'However, on using the `Multiline` flag, it matches the two dates:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，使用“多行”标志时，它匹配了两个日期：
- en: '[PRE64]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is not the best way to capture a date.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是捕获日期的最佳方法。
- en: re.DOTALL or re.S
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: re.DOTALL或re.S
- en: 'Let''s try to match anything after a digit:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试匹配数字后的任何内容：
- en: '[PRE65]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can see in the previous example that the character class `.` with its default
    behavior doesn''t match the newline. Let''s see what happens on using the flag:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的例子中看到，具有默认行为的字符类“。”不匹配换行符。让我们看看使用标志会发生什么：
- en: '[PRE66]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As expected, on using the `DOTALL` flag it matches the newline perfectly.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的是，使用“DOTALL”标志后，它完美地匹配了换行符。
- en: re.LOCALE or re.L
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: re.LOCALE或re.L
- en: 'In the following example, we get the first 256 characters and then we try to
    find every alphanumeric character in the string, so we obtain the expected characters
    as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们首先获取了前256个字符，然后尝试在字符串中找到每个字母数字字符，因此我们得到了预期的字符，如下所示：
- en: '[PRE67]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'After setting the locale to our system locale, we can again try to obtain every
    alphanumeric character:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在将区域设置为我们的系统区域设置后，我们可以再次尝试获取每个字母数字字符：
- en: '[PRE68]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In this case, we get many more characters according to the new locale:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，根据新的区域设置，我们得到了更多的字符：
- en: '[PRE69]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: re.UNICODE or re.U
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: re.UNICODE或re.U
- en: 'Let''s try to find all the alphanumeric characters in a string:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在字符串中找到所有字母数字字符：
- en: '[PRE70]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'But what would happen if we want to do the same with other languages? The alphanumeric
    characters depend on the language, so we need to indicate it to the regex engine:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想要在其他语言中执行相同的操作会发生什么呢？字母数字字符取决于语言，因此我们需要将其指示给正则表达式引擎：
- en: '[PRE71]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: re.VERBOSE or re.X
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: re.VERBOSE或re.X
- en: 'In the following pattern, we''ve used several ⇢; the first one is ignored because
    it is not in a character class or preceded by a backslash and the second one is
    part of the pattern. We''ve also used # three times, the first and the third one
    are ignored because they''re not preceded by a backslash, and the second one is
    part of the pattern.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的模式中，我们使用了几个⇢；第一个被忽略，因为它不在字符类中，也没有在反斜杠之前，第二个是模式的一部分。我们还使用了#三次，第一个和第三个被忽略，因为它们没有在反斜杠之前，第二个是模式的一部分。
- en: '[PRE72]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: re.DEBUG
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: re.DEBUG
- en: '[PRE73]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Python and regex special considerations
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python和正则表达式的特殊考虑
- en: In this section, we will review differences with other flavors, how to deal
    with Unicode, and also differences in the `re` module between Python 2.x and Python
    3.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾与其他版本的差异，如何处理Unicode，以及Python 2.x和Python 3之间的“re”模块的差异。
- en: Differences between Python and other flavors
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python和其他版本之间的差异
- en: As we mentioned at the beginning of the book, the `re` module has Perl-style
    regular expressions. However, that doesn't mean Python support every feature the
    Perl engine has.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书开头提到的，re模块具有Perl风格的正则表达式。但是，这并不意味着Python支持Perl引擎具有的每个功能。
- en: 'There are too many differences to cover them in a short book like this, if
    you want to know them in-depth here you have two good places to start:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 有太多的差异无法在这样一本简短的书中涵盖，如果您想深入了解它们，这里有两个很好的起点：
- en: '[http://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines](http://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines)'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines](http://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines)'
- en: '[http://www.regular-expressions.info/reference.html](http://www.regular-expressions.info/reference.html)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.regular-expressions.info/reference.html](http://www.regular-expressions.info/reference.html)'
- en: Unicode
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unicode
- en: 'When you''re using Python 2.x and you want to match Unicode, the regex has
    to be Unicode escape. For example:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用Python 2.x并且要匹配Unicode时，正则表达式必须是Unicode转义。例如：
- en: '[PRE74]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Note that if you use Unicode characters but the type of the string you''re
    using is not Unicode, python automatically encodes it using the default encoding.
    For example, in my case I have UTF-8:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您使用Unicode字符，但您使用的字符串类型不是Unicode，则Python会自动使用默认编码对其进行编码。例如，在我的情况下，我有UTF-8：
- en: '[PRE75]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'So, you have to be careful while mixing types:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在混合类型时，您必须小心：
- en: '[PRE76]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Here, you''re not matching Unicode but the characters in the default encoding:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您不是匹配Unicode，而是默认编码中的字符：
- en: '[PRE77]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'So, if you use Unicode in any of them, you''re pattern won''t match anything:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您在其中任何一个中使用Unicode，则您的模式将不匹配任何内容：
- en: '[PRE78]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'On the other hand, you can use Unicode on both sides and it would match as
    expected:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，您可以在两侧使用Unicode，并且它将按预期进行匹配：
- en: '[PRE79]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `re` module doesn''t do Unicode case folding, so case insensitive doesn''t
    work on Unicode:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: “re”模块不执行Unicode大小写折叠，因此在Unicode上不起作用：
- en: '[PRE80]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: What's new in Python 3
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 3中的新功能
- en: There are some changes in Python 3 that affect the regex behavior, and new features
    have been added to the `re` module. First, let's review how the string notation
    has changed.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3中有一些影响正则表达式行为的变化，并且已经向“re”模块添加了新功能。首先，让我们回顾一下字符串表示法如何发生变化。
- en: '| Type | Prefixed | Description |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 前缀 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| String |   | They are string literals. They''re Unicode. The backslash is
    necessary to escape meaningful characters.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '| 字符串 |   | 它们是字符串文字。它们是Unicode。反斜杠是必要的，用于转义有意义的字符。'
- en: '[PRE81]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '|'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Raw string | `r` or `R` | They''re equal to literal strings with the exception
    of the backslashes, which are treated as normal characters.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '| 原始字符串 | `r` 或 `R` | 它们与文字字符串相同，只是反斜杠被视为普通字符。'
- en: '[PRE82]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '|'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Byte strings | `b` or `B` | Strings represented as bytes. They can only contain
    ASCII characters; if the byte is greater than 128, it must be escaped.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '| 字节字符串 | `b` 或 `B` | 以字节表示的字符串。它们只能包含ASCII字符；如果字节大于128，必须进行转义。'
- en: '[PRE83]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We can convert to Unicode in this way:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样转换为Unicode：
- en: '[PRE84]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The backslash is necessary to escape meaningful characters. |
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠是必要的，用于转义有意义的字符。
- en: '| Byte raw string | `r` or `R` | They are like byte strings, but the backslashes
    are escaped.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '| 字节原始字符串 | `r` 或 `R` | 它们类似于字节字符串，但反斜杠被转义。'
- en: '[PRE85]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'So, the backslash used to escape bytes are escaped again, which complicates
    their conversion to Unicode:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，用于转义字节的反斜杠再次被转义，这使得它们转换为Unicode变得更加复杂：
- en: '[PRE86]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '|'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Unicode | `r` or `U` | The `u` prefix was removed in the early versions of
    Python 3, and recovered in version 3.3 the syntax is accepted again. They''re
    equal to strings. |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| Unicode | `r` 或 `U` | `u`前缀在Python 3的早期版本中被移除，但在3.3版本中又被接受。它们与字符串相同。'
- en: Literal strings are Unicode by default in Python 3, which means that there is
    no need to use the flag Unicode anymore.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3中，文字字符串默认为Unicode，这意味着不再需要使用Unicode标志。
- en: '[PRE87]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Python 3.3 ([http://docs.python.org/dev/whatsnew/3.3.html](http://docs.python.org/dev/whatsnew/3.3.html))
    adds more features related to Unicode and how it is treated in the language. For
    example, it adds support for the complete range of code points, including non-BMP
    ([http://en.wikipedia.org/wiki/Plane_(Unicode)](http://en.wikipedia.org/wiki/Plane_(Unicode))).
    So, for example:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.3 ([http://docs.python.org/dev/whatsnew/3.3.html](http://docs.python.org/dev/whatsnew/3.3.html))
    添加了更多与Unicode相关的功能以及语言中对其处理的方式。例如，它增加了对完整代码点范围的支持，包括非BMP ([http://en.wikipedia.org/wiki/Plane_(Unicode)](http://en.wikipedia.org/wiki/Plane_(Unicode)))。因此，例如：
- en: 'In Python 2.7:'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python 2.7中：
- en: '[PRE88]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In Python 3.3.2:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python 3.3.2中：
- en: '[PRE89]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: As we've seen in the *Compilation Flags* section, the ASCII flag has been added.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*编译标志*部分中看到的，已添加了ASCII标志。
- en: Another important aspect to note when using Python 3 has to do with metacharacters.
    As the strings are Unicode by default, the metacharacters too, unless you use
    8-bit patterns or use the ASCII flag.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Python 3时需要注意的另一个重要方面与元字符有关。由于字符串默认为Unicode，元字符也是如此，除非您使用8位模式或使用ASCII标志。
- en: '[PRE90]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In the preceding example, the characters that aren't ASCII are ignored.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，不是ASCII的字符被忽略了。
- en: Take into account that Unicode pattern and 8-bit patterns cannot be mixed.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Unicode模式和8位模式不能混合使用。
- en: 'In the following example, we''ve tried to match an 8-bit pattern against a
    Unicode String, that''s why an exception is thrown (remember that it would work
    in Python 2.x):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们试图将一个8位模式与Unicode字符串匹配，这就是为什么会抛出异常（请记住，在Python 2.x中可以工作）：
- en: '[PRE91]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Summary
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This was a long chapter! We've covered a lot of material in it. We began with
    how strings work in Python and their different notations in Python 2.x and Python
    3.x. After that, we looked at how to build regular expressions, the objects and
    interface the `re` module give us to deal with them, and the most important operations
    for searching and modifying strings. We also learned how to extract information
    from a pattern through `MatchObject`, such as the position or the groups of a
    match. We also learned how to modify the default behavior of some character classes
    and metacharacters using the compilation flags. And finally, we've seen how to
    deal with Unicode and the new features we can find in Python 3.x.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很长的章节！我们在其中涵盖了很多内容。我们从Python中字符串的工作方式及其在Python 2.x和Python 3.x中的不同表示开始。之后，我们看了如何构建正则表达式，`re`模块提供给我们处理它们的对象和接口，以及搜索和修改字符串的最重要操作。我们还学习了如何通过`MatchObject`从模式中提取信息，例如匹配的位置或组。我们还学习了如何使用编译标志修改一些字符类和元字符的默认行为。最后，我们看到了如何处理Unicode以及在Python
    3.x中可以找到的新功能。
- en: Throughout this chapter, we've seen that groups are crucial part of regular
    expressions and that many operations of the `re` module are meant to be used with
    groups. That's why we cover groups in depth in the following chapter.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到组是正则表达式的重要部分，`re`模块的许多操作都是为了与组一起使用。这就是为什么我们在下一章中深入讨论组。
