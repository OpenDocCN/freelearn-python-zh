- en: '*Chapter 3*: Understanding Algorithms and Algorithmic Thinking'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：理解算法和算法思维'
- en: In this chapter, we will focus more closely on understanding algorithms and
    algorithmic thinking. While this is the last step in the computational thinking
    process, it is critical that we understand how algorithmic thinking helps us plan
    and understand our problems better. That is, the more we practice algorithmic
    design and algorithmic thinking, the easier it is to understand, decompose, and
    recognize patterns when problems are presented to us.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更加专注于理解算法和算法思维。虽然这是计算思维过程中的最后一步，但我们必须理解算法思维如何帮助我们更好地规划和理解问题。也就是说，我们练习算法设计和算法思维的次数越多，就越容易理解、分解和识别问题呈现给我们时的模式。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Defining algorithms in depth
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入定义算法
- en: Designing algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计算法
- en: Analyzing algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析算法
- en: After reading this chapter, you'll understand algorithms better. So, we'll begin
    by analyzing the definition of algorithms again, which we covered previously in
    [*Chapter 2*](B15413_02_Final_SK_ePub.xhtml#_idTextAnchor043), *Elements of Computational
    Thinking*, as well as how to design mathematical and computational algorithms.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，你会更好地理解算法。因此，我们将重新分析算法的定义，这是我们之前在[*第2章*](B15413_02_Final_SK_ePub.xhtml#_idTextAnchor043)中涵盖的，*计算思维的要素*，以及如何设计数学和计算算法。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the latest version of Python to run the codes in this chapter.
    You will find the full source code used in this chapter here: [https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter03](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter03)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要最新版本的Python来运行本章中的代码。你可以在这里找到本章使用的完整源代码：[https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter03](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter03)
- en: Defining algorithms in depth
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入定义算法
- en: As we mentioned in [*Chapter 2*](B15413_02_Final_SK_ePub.xhtml#_idTextAnchor043),
    *Elements of Computational Thinking*, an **algorithm** is simply a set of instructions.
    We use instructions in everyday life, sometimes consciously, sometimes unconsciously.
    Think about the routines you follow in the morning, for example. The alarm clock
    sounds. *What do you do next?* *Do you go prepare coffee?* *Shower?* *Brush your
    teeth first?*
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第2章*](B15413_02_Final_SK_ePub.xhtml#_idTextAnchor043)中提到的，*计算思维的要素*，**算法**只是一组指令。我们在日常生活中使用指令，有时是有意识的，有时是无意识的。例如，想想你早上遵循的例行程序。闹钟响了。*接下来你会做什么？*
    *你会准备咖啡吗？* *洗澡？* *先刷牙吗？*
- en: Most of us follow the same steps every single morning. You could say we've programmed
    ourselves to follow those steps. Now think of a time your schedule changed and
    your routine was different. I know I've had to stop and regroup many times because
    my *program* no longer works. I can't wake up at 6 a.m. for a 5 a.m. flight, for
    example.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人每天早上都会按照相同的步骤。你可以说我们已经编程自己遵循这些步骤。现在想想一个你的日程变化，你的例行程序不同了的时候。我知道我不得不停下来重新调整很多次，因为我的“程序”不再起作用了。例如，我不能在早上6点起床赶5点的飞机。
- en: Algorithms for computers are similar in that we need to reprogram the set of
    instructions if a set of conditions has changed. The programs can only go as far
    as we have stated parameters for them. Most programs cannot adjust or adapt to
    any new information that is not previously coded into it. That said, **machine
    learning** and **artificial learning** are evolving. We're not talking about those
    kinds of programs, but even in those instances, we'd still need to adjust those
    programs to do what we need them to.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的算法类似，如果一组条件发生了变化，我们需要重新编写一组指令。程序只能执行我们已经规定的参数。大多数程序无法调整或适应任何未事先编码的新信息。也就是说，**机器学习**和**人工学习**正在发展。我们不是在谈论那些类型的程序，但即使在这些情况下，我们仍然需要调整这些程序以满足我们的需求。
- en: 'To design algorithms, we need to make sure that they meet some specific characteristics:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计算法，我们需要确保它们满足一些特定的特征：
- en: '**They are clear and unambiguous.**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它们是清晰和明确的。**'
- en: '**They have inputs that are well defined.**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它们有明确定义的输入。**'
- en: '**They have outputs that are well defined.**'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它们有明确定义的输出。**'
- en: '**They have finiteness.**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它们是有限的。**'
- en: '**They are feasible.**'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它们是可行的。**'
- en: '**They are language-independent.**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它们与语言无关。**'
- en: Let's look at each of the characteristics in the preceding list and define them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个查看前面列表中的每个特征并对其进行定义。
- en: Algorithms should be clear and unambiguous
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法应该是清晰和明确的
- en: An algorithm is clear and unambiguous when every one of the steps can easily
    be understood, is easily defined, and has inputs and outputs that are also clear
    and well defined. There should also be only one meaning for each component of
    the algorithm.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个步骤都能轻松理解、容易定义，并且输入和输出也清晰明确时，算法就是清晰和明确的。算法的每个组成部分应该只有一个意思。
- en: Algorithms should have inputs and outputs that are well defined
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法应该有明确定义的输入和输出
- en: The **inputs** for an algorithm can be user-provided, meaning that the user
    of the program enters the data. Input can also mean something that is defined
    within the program. This means that I may include a variable with a set value
    already provided.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的**输入**可以是用户提供的，这意味着程序的用户输入数据。输入也可以指程序内部定义的内容。这意味着我可以包含一个已经提供了固定值的变量。
- en: For example, if I need a user to tell me the number of tickets they are purchasing,
    I can write the algorithm to ask for that input. I can also give that input as
    a defined variable with a given value already. An algorithm does not always require
    an input – zero-input algorithms do exist – but when the algorithm requires input,
    defining that input is important. An example of an input is asking for a user's
    name in a program. Think about modern video games. Many of them will prompt the
    user for a name with phrases such as, *"Hello traveler. What is your name?"*
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我需要用户告诉我他们购买的票数，我可以编写算法来询问输入。我也可以将该输入作为一个已定义的变量，并赋予一个给定的值。算法并不总是需要输入 -
    零输入算法是存在的 - 但是当算法需要输入时，定义该输入是很重要的。一个输入的例子是在程序中要求用户的姓名。想想现代视频游戏。其中许多游戏会提示用户输入姓名，比如，“你好，旅行者。你叫什么名字？”
- en: 'As a user, I''d enter `Sofia` when given that prompt, which gives me the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为用户，当给出提示时，我会输入`Sofia`，这给了我以下结果：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the game will then produce an output and uses my name in that
    output.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，游戏将产生一个输出，并在该输出中使用我的名字。
- en: 'This final line is the **output** of the program. I can write a simple program
    to ask that question in Python as well:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一行是程序的**输出**。我也可以用Python编写一个简单的程序来问这个问题：
- en: ch3_nameprompt.py
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ch3_nameprompt.py
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that we used `%s` and `%` symbols here. The syntax here is what we call
    an f-string. We use the `%s` syntax to let the program know where we want to insert
    the information and then we call that information by using the `%` symbol. In
    this case, we saved the input to the `name` variable, then called it in the `salutation`
    variable.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里使用了`%s`和`%`符号。这里的语法是我们所谓的f-string。我们使用`%s`语法来让程序知道我们想要插入信息的位置，然后我们通过使用`%`符号来调用该信息。在这种情况下，我们将输入保存到`name`变量中，然后在`salutation`变量中调用它。
- en: 'When run, the program looks like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，程序看起来是这样的：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This simple algorithm allowed us to save the name as a variable. That variable
    was used only once in the output of this simple code. However, in a game, that
    name variable may be used in multiple instances, such as during conversations
    with characters within the game, and so on.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的算法允许我们将名字保存为一个变量。该变量仅在这个简单代码的输出中使用了一次。然而，在游戏中，该名字变量可能会在多个实例中使用，比如在与游戏中的角色对话时等。
- en: The **output** of a program is the information that leaves a system, that is,
    the product of your program. Given some information or code, the output is what
    is produced from the instructions in the program.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的**输出**是离开系统的信息，也就是你的程序的产物。根据一些信息或代码，输出是从程序中的指令产生的东西。
- en: Algorithms should have finiteness
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法应该具有有限性
- en: 'An algorithm has to have **finiteness**. This means that an algorithm must
    end. Let''s look at a situation where an algorithm would not end. **I don''t recommend
    writing this or running it!** Nonetheless, let''s look at the steps we would take
    to create this algorithm:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 算法必须具有**有限性**。这意味着算法必须结束。让我们看一个算法不会结束的情况。**我不建议编写或运行这个！**尽管如此，让我们看看创建这个算法的步骤：
- en: 'Define a variable, `i`, and set it as equal to `0`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个变量`i`，并将其设置为等于`0`：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Increase the value by `1`. There are a few different ways we can do that:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加值`1`。我们可以以几种不同的方式来做到这一点：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Both of the preceding lines of code will increase the value of `i` by `1`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面两行代码都会将`i`的值增加`1`。
- en: '*Add an error!* We''re about to create an error in finiteness. Again, I''m
    only doing this to prove a point, but this is an error you want to avoid:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*添加一个错误！*我们即将在有限性中创建一个错误。再次强调，我只是为了证明一个观点，但这是一个你要避免的错误：'
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this algorithm, I'm telling the program to continue to increase `i` by `1`
    so as long as it is greater than `0`, then the computer is supposed to print the
    value. This will just continue to go on forever and ever, without stopping, because
    the condition will always hold true as given. So, the output for the program will
    begin at 1, but will continue printing the next item in the sequence as 2, 3,
    4, 5, and so on. The program simply has no way to end.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个算法中，我告诉程序继续将`i`增加`1`，只要它大于`0`，然后计算机应该打印这个值。这将永远继续下去，永远不会停止，因为条件将始终成立。因此，程序的输出将从1开始，但将继续打印序列中的下一个项目，如2、3、4、5等。程序根本没有结束的方法。
- en: 'Now, a similar program may be done given a few different conditions. Let''s
    say we want to print all the values of our addition, but only so long as `i` is
    less than 15:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以根据几种不同的条件来完成类似的程序。假设我们想打印所有加法的值，但只要`i`小于15：
- en: ch3_finiteness.py
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ch3_finiteness.py
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding program is a terminating program. It now only works for all values
    while `i` is less than `15` (not including 15). We will get an output shown as
    follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序是一个终止程序。现在它只适用于`i`小于`15`的所有值（不包括15）。我们将得到如下所示的输出：
- en: '![Figure 3.1 – Output for finiteness code'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 - 有限性代码的输出'
- en: '](image/Figure_03.01_B15413.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_03.01_B15413.jpg)'
- en: Figure 3.1 – Output for finiteness code
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 - 有限性代码的输出
- en: I know I said this program did not include 15\. It doesn't. Since this happens
    while `i` is less than 15, the last value it will evaluate for is 14\. However,
    it says that while the value is less than 15, we increase it by 1 (`i += 1`).
    So, when `i` is 14, the printed value is 14 + 1, or 15\. Finiteness allows the
    program to terminate.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道我说过这个程序不包括15。确实不包括。因为这发生在`i`小于15的情况下，它将评估的最后一个值是14。然而，它说当值小于15时，我们将其增加1（`i
    += 1`）。所以，当`i`为14时，打印的值是14 + 1，即15。有限性允许程序终止。
- en: Algorithms have to be feasible
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法必须是可行的
- en: 'An algorithm also has to be **feasible**. To be feasible, an algorithm needs
    to be possible with the available content and resources. When writing algorithms,
    we have constraints, or conditions we may write into the steps. If there is no
    way to meet all the constraints, then the algorithm isn''t feasible. Think of
    the two conditions, given as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 算法还必须是可行的。为了可行，算法需要使用可用的内容和资源。在编写算法时，我们有约束或条件可以写入步骤中。如果没有办法满足所有约束，那么算法就不可行。考虑以下给出的两个条件：
- en: It is 3:00 p.m.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在是下午3点。
- en: It is 5:00 p.m.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在是下午5点。
- en: If we set both of these constraints on a variable, for example, it would not
    be possible. It cannot be both 3:00 p.m. and 5:00 p.m. at the same time. This
    is what we call **infeasible**. While the algorithm can continue, we're still
    creating a problem by making these two things true at the same time. Some constraints
    will never be met, so the algorithm is considered infeasible. There has to be
    a way for the algorithm to meet all constraints in order to be feasible. In addition,
    if an algorithm is written to depend on future technology, for example, it is
    also considered infeasible.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对一个变量设置这两个约束，比如，它不可能。它不能同时是下午3点和下午5点。这就是我们所说的不可行。虽然算法可以继续，但我们通过同时使这两个事情成为真实的问题。有些约束永远不会被满足，因此算法被认为是不可行的。算法必须有一种方法来满足所有约束才能被认为是可行的。此外，如果算法是依赖未来技术编写的，也被认为是不可行的。
- en: Algorithms are language-independent
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法是与语言无关的
- en: Finally, an algorithm must be **language-independent**. The set of instructions
    in an algorithm should be written as simply as possible. A good algorithm will
    be such that it can be written in any language easily and produce the same output.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，算法必须是与语言无关的。算法中的一组指令应该尽可能简单地编写。一个好的算法将是这样的，它可以很容易地用任何语言编写，并产生相同的输出。
- en: In this section, we learned about algorithms and the characteristics needed
    to design them. Keeping in mind the characteristics of a good algorithm will allow
    us to avoid errors and create working algorithms for whatever problems we are
    presented with, let's now take a look at how to design some algorithms.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们学习了算法以及设计算法所需的特征。牢记一个好算法的特征将使我们能够避免错误，并为我们所面临的任何问题创建可行的算法，现在让我们看看如何设计一些算法。
- en: Designing algorithms
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计算法
- en: When designing algorithms, order matters. There are hierarchies that matter
    when we are working with programming languages. That includes when we are working
    with Python. Think about this as the order of operations in mathematics. If you
    recall, we use the mnemonic **PEMDAS** to remember the order of operations in
    mathematics. **PEMDAS** stands for **Parentheses**, **Exponents**, **Multiplication/Division**,
    and **Addition/Subtraction**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 设计算法时，顺序很重要。在使用编程语言时，存在重要的层次结构。这包括在使用Python时。把这看作是数学中的运算顺序。如果你还记得，我们使用PEMDAS来记住数学中的运算顺序。PEMDAS代表括号、指数、乘法/除法和加法/减法。
- en: I write **Multiplication/Division** together like this because multiplication
    and division hold the same weight. That is, multiplication does not necessarily
    need to happen before division. If I have a division first and then a multiplication
    from left to right, then the division happens first. The same is true for addition
    and subtraction. Neither has more weight than the other, so we perform them in
    order of appearance from left to right.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我把乘法/除法写在一起是因为乘法和除法具有相同的权重。也就是说，乘法不一定需要在除法之前发生。如果我先进行除法，然后从左到右进行乘法，那么除法先发生。加法和减法也是如此。两者都没有更多的权重，所以我们按照从左到右的出现顺序执行它们。
- en: Let's write a mathematical algorithm for a problem. We'll look at an algorithm
    in a food setting. And yes, I know I write about food and food algorithms a lot.
    I love food almost as much as I love code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为一个问题编写一个数学算法。我们将看一个食物环境中的算法。是的，我知道我经常写关于食物和食物算法。我几乎和我喜欢代码一样喜欢食物。
- en: Problem 1 – An office lunch
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题1 - 办公室午餐
- en: 'An office is ordering catering for employees. Employees were given two lunch
    options: sandwiches or salads. Each sandwich meal costs $8.50, while each salad
    meal costs $7.95.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 办公室正在为员工订餐。员工可以选择三明治或沙拉两种午餐选项。每份三明治餐的成本为8.50美元，而每份沙拉餐的成本为7.95美元。
- en: Office lunch mathematical algorithm
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 办公室午餐数学算法
- en: 'The number of employees who choose each option is unknown. Let''s use some
    variables to help us in designing the mathematical algorithm. Let''s use *s* for
    the number of sandwiches and *b* for the number of salad bowls. And I know what
    you''re thinking, those two variables aren''t very helpful if you come back to
    this problem a while from now. But we''ll talk about that in a second. For now,
    let''s just write what our total cost, *c*, will look like:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 选择每个选项的员工数量是未知的。让我们使用一些变量来帮助我们设计数学算法。让我们用s表示三明治的数量，用b表示沙拉碗的数量。我知道你在想什么，如果你过一段时间再回到这个问题，这两个变量并不是很有用。但我们马上就会谈到这个问题。现在，让我们写出我们的总成本c会是什么样子：
- en: '![](image/Formula_B15413_03_001.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](image/Formula_B15413_03_001.png)'
- en: This is a simple mathematical problem that requires two unknown variable inputs,
    *s* and *b*, in order to get our total, *c*. Now let's look at a different version
    of the same lunch scenario.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的数学问题，需要两个未知的变量输入s和b，以获得我们的总成本c。现在让我们看看同样的午餐场景的另一个版本。
- en: Office lunch Python algorithm
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 办公室午餐Python算法
- en: 'Now let''s think about a few more considerations when writing the program.
    As we design a Python algorithm for this problem, we''ll need to think about two
    perspectives: the programmer and the user.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在编写程序时考虑一些更多的考虑因素。在为这个问题设计Python算法时，我们需要考虑两个角度：程序员和用户。
- en: Sometimes we're both the programmer/developer and the end user for our programs,
    but many times, we'll write or develop content for someone else to use. It is
    important that we keep those considerations in mind because it may affect how
    we write our program and define our variables. In addition, if we're writing a
    program as part of a company, others may need to go and edit our programs at some
    point.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们既是程序员/开发人员，也是程序的最终用户，但很多时候，我们会为其他人编写或开发内容。重要的是我们要记住这些考虑因素，因为这可能会影响我们编写程序和定义变量的方式。此外，如果我们正在为公司编写程序，其他人可能需要在某个时候去编辑我们的程序。
- en: 'That means we need to write the program in a way that others will be able to
    understand. Our variables should be easily understood, so writing a simple one-letter
    variable may make it harder for another programmer or user to understand. Let''s
    look at a program for *Problem 1*. Recall that in that problem, we''re trying
    to determine the final cost for an office lunch for employees given two possible
    options:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要以其他人能够理解的方式编写程序。我们的变量应该易于理解，因此使用简单的单个字母变量可能会使另一个程序员或用户更难理解。让我们看看*问题1*的程序。请记住，在这个问题中，我们试图确定给员工提供两种可能选择的办公午餐的最终成本：
- en: $8.50 for a sandwich meal
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: $8.50 三明治套餐
- en: $7.95 for a salad meal
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: $7.95 沙拉套餐
- en: 'Let''s create the program for this problem using Python. Let''s clarify some
    variables first. We''ll want to use full words or a series of words separated
    by *_* to define these variables. Before we start, you may want to recall that
    for **Python variables**, some rules need to be followed so as not to cause an
    error:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Python为这个问题创建程序。首先让我们澄清一些变量。我们将使用完整的单词或用*_*分隔的一系列单词来定义这些变量。在开始之前，您可能需要回想一下，对于**Python变量**，需要遵循一些规则，以免引起错误：
- en: Variables must start with a letter or an underscore (*_*).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量必须以字母或下划线（*_*）开头。
- en: Variables can only contain letters, numbers, and underscores.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量只能包含字母，数字和下划线。
- en: Variables cannot start with a number.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量不能以数字开头。
- en: Variables are case sensitive (*alpha* is not the same variable as *Alpha* or
    *ALPHA*).
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量是区分大小写的（*alpha*不是与*Alpha*或*ALPHA*相同的变量）。
- en: 'For *Problem 1*, we need three variables:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*问题1*，我们需要三个变量：
- en: The total cost of the lunch
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 午餐的总成本
- en: The number of sandwich meal lunches
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三明治午餐的数量
- en: The number of salad meal lunches
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沙拉午餐的数量
- en: 'Now we need to name them:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要给它们命名：
- en: '`total_cost` = the total cost for all lunches'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`total_cost` = 所有午餐的总成本'
- en: '`number_of_sandwiches` = the total number of sandwich meals ordered'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number_of_sandwiches` = 订购的三明治套餐总数'
- en: '`number_of_salads` = the total number of salad meals ordered'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number_of_salads` = 订购的沙拉午餐的总数'
- en: The important thing here is that those variables are easily read and easily
    understood. I should make a note that I am partial to lowercase variables when
    programming. I do have some exceptions for when I like to use capital letters,
    but you'll see many examples with only lowercase letters and underscores. I found
    a long time ago that even when capital letters made sense to me at the time I
    was writing a program, I'd later forget which letters were capitalized, which
    was just an added headache that could be avoided if I just used lowercase letters
    instead.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是这些变量易于阅读和理解。我应该注意到，我在编程时偏爱小写变量。我确实有一些例外情况，我喜欢使用大写字母，但您会看到许多只有小写字母和下划线的示例。很久以前，我发现即使在编写程序时大写字母对我来说是有意义的，但后来我会忘记哪些字母是大写的，这只是一个额外的头痛，如果我只是使用小写字母，就可以避免。
- en: In addition, some programmers eliminate the underscores and use variables such
    as `numberofsandwiches` or simply `sandwiches`, for example. Both of those are
    acceptable, of course, and the simple `sandwiches` will make it easier to write
    some of the code. There are both pros and cons to doing this, however. If someone
    else is looking at the program, readability will be important. Like I said, I
    am partial to clear, lowercase variables and the use of underscores, but it is
    up to every programmer to make that choice themselves.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些程序员会消除下划线，并使用变量，例如`numberofsandwiches`或简单的`sandwiches`。当然，这两种都是可以接受的，而简单的`sandwiches`会使编写一些代码变得更容易。然而，这样做有利有弊。如果其他人正在查看程序，可读性将很重要。就像我说的，我偏爱清晰的小写变量和使用下划线，但每个程序员都可以自行选择。
- en: 'Now that I have defined my variables, I can begin to write my program. *What
    will I need to ask the user for?* I need **inputs** from the user for both the
    number of sandwiches and the number of salads. What I want as an **output**, or
    what the user will want as an output, is the total cost of the lunch. To ask for
    input from the user in Python, we need to use the `input` command. However, we
    also need to remember that since we are using this number in an algorithm that
    uses a `float` number (decimals are float characters), we need to convert the
    number provided to `integer` or `float`. Employees will not be able to order half
    a salad, so we can safely save them as integers, or `int`. As a reminder, comments
    in Python start with a `#` symbol. Write the code in IDLE, shown as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经定义了我的变量，我可以开始编写我的程序了。*我需要向用户询问什么？* 我需要用户的**输入**，包括三明治和沙拉的数量。我想要作为**输出**的是午餐的总成本。在Python中向用户询问输入，我们需要使用`input`命令。然而，我们还需要记住，由于我们在使用`float`数字的算法中使用了这个数字（小数点是浮点字符），我们需要将提供的数字转换为`integer`或`float`。员工不会点半份沙拉，所以我们可以安全地将它们保存为整数，或`int`。作为提醒，在Python中，注释以`#`符号开头。在IDLE中编写代码，如下所示：
- en: ch3_officelunch.py
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ch3_officelunch.py
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When running the code, the user can enter the number of each of the options
    for the office lunch. The code first asks the user for the number of sandwiches
    like so:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码时，用户可以输入办公午餐的各种选项的数量。代码首先询问用户三明治的数量，如下所示：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code will then ask for the number of salad lunches and provide a total
    cost. The following sample takes an input of 12 sandwich lunches and 23 salad
    lunches, which would be a total cost of $284.85:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后代码将要求输入沙拉午餐的数量，并提供总费用。以下示例输入12份三明治午餐和23份沙拉午餐，总费用为284.85美元：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now let's take a look at a similar problem, but from a different perspective.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从不同的角度来看一个类似的问题。
- en: Problem 2 – A catering company
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题2 - 一个餐饮公司
- en: Let's say you start a simple catering company. You begin only selling two options,
    a sandwich meal for $8.50 and a salad meal for $7.95\. You can create a program
    that stores these options using a Python dictionary.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你开始了一个简单的餐饮公司。你开始只销售两种选择，一份8.50美元的三明治套餐和一份7.95美元的沙拉套餐。你可以创建一个使用Python字典存储这些选项的程序。
- en: 'You can find additional information on the Python programming language and
    dictionaries in [*Chapter 8*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114),
    *Introduction to Python*, but we''ll define a Python dictionary here as well.
    A dictionary is used when we want items that are unordered, can be changed, and
    are indexed. Here''s an example of a dictionary for our catering company in Python:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[*第8章*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114)中找到有关Python编程语言和字典的更多信息，*Python简介*，但我们也会在这里定义一个Python字典。当我们想要无序、可更改且有索引的项目时，我们使用字典。以下是Python中我们餐饮公司的一个字典的示例：
- en: ch3_cateringdict.py
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ch3_cateringdict.py
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, dictionaries are common and very useful for various reasons: primarily,
    that they are easy to read and they provide a way to change data as required.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，字典是常见的，而且非常有用，原因有很多：主要是它们易于阅读，并且它们提供了根据需要更改数据的方法。
- en: 'When printed, the dictionary code looks like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当打印时，字典代码看起来像这样：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that you have a dictionary, let's talk about its usefulness to your catering
    company. Let's say that there is a cost increase for your salad ingredients that
    you want to account for by changing the price of the salads. You can do so in
    a few different ways. You can change it in the original program, since it is so
    short, or you can just tell the program what you want to change based on the key.
    This is important because you may have two items for sale now, *but what happens
    when your menu options become much wider?* *Would you want to search for each
    item every time you change a price?* Python makes it easy to identify what you
    want to change and then change it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个字典，让我们谈谈它对你的餐饮公司的用处。假设你的沙拉配料成本增加了，你想通过改变沙拉的价格来进行核算。你可以通过几种不同的方式来做到这一点。你可以在原始程序中进行更改，因为它非常简短，或者你可以告诉程序你想要根据键值来进行更改。这很重要，因为现在你可能有两种出售的物品，*但是当你的菜单选项变得更加广泛时会发生什么？*
    *每次更改价格时，你是否想要搜索每个项目？* Python使得识别你想要更改的内容然后进行更改变得很容易。
- en: 'To do so, you can use the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，你可以使用以下代码：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Your new code in Python looks like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新Python代码看起来像这样：
- en: ch3_cateringdict2.py
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ch3_cateringdict2.py
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When printed, the new value for the salads will be shown:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当打印时，沙拉的新价值将被显示：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*But, what happens if you want to add a menu item?* Say you want to add a soup
    option for $3.75\. In this case, you can add the menu option to your dictionary
    by using a simple line of code, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*但是，如果你想添加一个菜单项目会发生什么？* 比如说你想添加一个售价为3.75美元的汤选项。在这种情况下，你可以通过一行简单的代码将菜单选项添加到你的字典中，如下所示：'
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When you put it all together, the initial code and the changes would look like
    the following code block. Notice that you have the initial dictionary, then the
    two changes below that. When you print the dictionary, it will include all changes
    along with the addition of the soup option:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你把所有东西放在一起时，初始代码和更改将看起来像下面的代码块。请注意，你有初始字典，然后是下面的两个更改。当你打印字典时，它将包括所有更改以及添加汤选项：
- en: ch3_cateringdict3.py
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ch3_cateringdict3.py
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that you have added the `soup` item, you can print your dictionary to see
    your full menu:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经添加了`soup`项目，你可以打印你的字典来查看你的完整菜单：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can use the information within the dictionary to create more robust programs,
    such as an online menu, an ordering menu option, and much more. In this section,
    we learned about designing an algorithm with the help of two problems.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用字典中的信息来创建更健壮的程序，比如在线菜单、点餐菜单选项等等。在本节中，我们学习了如何设计算法，并解决了两个问题。
- en: We will take a look at more development using Python through additional problems
    in the following chapters of this book, especially in *Section 3*, *Data Processing,
    Analysis, and Applications Using Computational Thinking and Python*. For now,
    we'll move on to analyzing some algorithms.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后续章节中更多地使用Python进行开发，特别是在*第3节*，*使用计算思维和Python进行数据处理、分析和应用*。现在，让我们继续分析一些算法。
- en: Analyzing algorithms
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析算法
- en: 'As mentioned previously in this chapter, when we design algorithms, they should
    meet the following characteristics:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面提到的，当我们设计算法时，它们应该具备以下特点：
- en: They are clear and unambiguous.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是清晰和明确的。
- en: They have inputs that are well defined.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有明确定义的输入。
- en: They have outputs that are well defined.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有明确定义的输出。
- en: They have finiteness.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们具有有限性。
- en: They are feasible.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是可行的。
- en: They are language-independent.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是与语言无关的。
- en: 'In addition to those characteristics, when we are looking at algorithms and
    analyzing them, we want to make sure we ask ourselves some questions:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些特点之外，当我们看算法并分析它们时，我们希望确保自己问一些问题：
- en: '*Does the algorithm do what we want?*'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*算法是否做我们想要的？*'
- en: '*Does the output make sense?*'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*输出是否合理？*'
- en: '*Is there another way to get the same information in a clearer way?*'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*是否有其他更清晰地获取相同信息的方法？*'
- en: There are many more questions we can ask ourselves when analyzing algorithms,
    but for now, let's take a look at some algorithmic solutions and analyze them
    based on the aforementioned characteristics and questions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析算法时，我们可以问自己许多更多的问题，但现在让我们看一些算法解决方案，并根据上述特点和问题进行分析。
- en: Algorithm analysis 1 – States and capitals
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法分析1 - 州和首府
- en: 'A student has created an algorithm that includes a list of US states and the
    capitals for each of those states, but only those states she has already studied
    are included. Her algorithm is shown as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个学生创建了一个算法，其中包括美国各州和每个州的首都的列表，但只包括她已经学过的州。她的算法如下所示：
- en: ch3_statecapitals1.py
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ch3_statecapitals1.py
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The program is simple, yet not easy to use, nor helpful when run. *Does it contain
    the information needed?* Yes. *Can we organize it in a different way so we can
    call the information in other ways?* Yes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序很简单，但使用起来并不容易，也不在运行时提供帮助。*它包含所需的信息吗？*是的。*我们可以以不同的方式组织它，以便以其他方式调用信息吗？*可以。
- en: 'Think about states and capitals as key pairs. We can use a dictionary to store
    the information. You may recall from earlier in this chapter that a dictionary
    can be adjusted and adapted easily, adding a new key with a simple line of code.
    Let''s first convert the information in the previous code into a dictionary:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 把州和首都看作键对。我们可以使用字典来存储这些信息。你可能还记得本章前面提到过，字典可以很容易地进行调整和适应，只需一行简单的代码就可以添加一个新的键。让我们先把前面代码中的信息转换成字典：
- en: ch3_statecapitals2.py
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ch3_statecapitals2.py
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice that we can now access the information for the state capital by simply
    giving the state name. The output for this code is simply `Columbus`. *But what
    if you just want to run the program and ask for the user to input a state of their
    choosing?* We can also write that in a line of code with the existing dictionary.
    Take a look at the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在我们可以通过简单地给出州名来访问州首都的信息。这段代码的输出只是`哥伦布`。*但是如果你只想运行程序并要求用户输入他们选择的州呢？*我们也可以用现有的字典在一行代码中编写。看一下以下代码：
- en: ch3_statecapitals3.py
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ch3_statecapitals3.py
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this code, the user enters the state for which they want to find the capital.
    This is helpful, as you can just run the code each time without having to go into
    it to change the line of code to be printed, which we had to do with the algorithm
    in the `ch3_statecapitals2.py` file. The code, when run, looks like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，用户输入他们想要查找首都的州。这很有帮助，因为你可以每次运行代码而不必进入代码中去更改要打印的代码行，这是我们在`ch3_statecapitals2.py`文件中的算法中不得不做的。运行时，代码看起来像这样：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now let''s look at the need for the algorithm in the first place. The student
    wants to continue to add states to the program. With this program, since it is
    dictionary-based, she can simply add a line of code when she needs to add another
    state. For example, if she wanted to add the state of **Iowa**, whose capital
    is Des Moines, she''d need to use the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下首先需要这个算法的原因。学生想要继续向程序中添加州。由于这个程序是基于字典的，她只需在需要添加另一个州时添加一行代码。例如，如果她想要添加**爱荷华州**，其首都是得梅因，她需要使用以下代码：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Take a look at the following code block. Note the placement of the code within
    the program. It is important that we place that new code before the new variables,
    otherwise, if you try to run the program and input `Iowa`, the code will return
    an error rather than providing the capital of Iowa.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码块。注意代码在程序中的放置位置。很重要的是我们把新代码放在新变量之前，否则，如果你尝试运行程序并输入`爱荷华州`，代码将返回一个错误而不是提供爱荷华州的首都。
- en: 'In algorithms, logic is extremely important. We cannot use a value we have
    not defined in variables that have already been used. That is, if the variables
    `state` and `capital` are used before identifying the new value for `Iowa`, then
    the code ends with an error when the input is `Iowa`. However, if we add the key
    pair values before we run those two variables, the code runs as expected:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法中，逻辑非常重要。我们不能在已经使用过的变量中使用我们尚未定义的值。也就是说，如果在为`爱荷华州`标识新值之前就使用了`州`和`首都`变量，那么当输入`爱荷华州`时，代码会以错误结束。然而，如果我们在运行这两个变量之前添加键对值，代码就会如预期般运行：
- en: ch3_statecapitals4.py
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ch3_statecapitals4.py
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, we can adapt and adjust the code to better suit our needs. Now
    let's take a look at a few algorithms to determine whether they would run; that
    is, whether they would produce an error or run appropriately.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们可以调整和修改代码以更好地满足我们的需求。现在让我们看一下一些算法，确定它们是否会运行；也就是说，它们是否会产生错误或正确运行。
- en: Algorithm analysis 2 – Terminating or not terminating?
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法分析2 - 终止还是不终止？
- en: 'As we discussed earlier in this chapter, algorithms should be terminating.
    That is, they must have a way to end, or they can cause many errors. Let''s look
    at an algorithm and analyze it to determine whether it will terminate or not:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面讨论过的那样，算法应该是终止的。也就是说，它们必须有一种结束的方式，否则会导致许多错误。让我们看一个算法并分析它，确定它是否会终止：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, let's take a look at the value of the `x` variable. The `x` variable
    starts the program with a value of `0`. The `while` loop, which states the conditions
    under which the value of `x` will change, states that when the `x` value is greater
    than `3`, it is incremented by a value of `1`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下`x`变量的值。`x`变量以`0`的值开始程序。`while`循环规定了`x`值将发生变化的条件，当`x`值大于`3`时，它会增加`1`的值。
- en: This algorithm terminates because it will print the original value for the variable,
    `0`. However, this algorithm doesn't really perform any actions, as the condition
    will never be met. Also, notice that the `print` command is not indented. If it
    were indented, no output would be given for this algorithm, as the `print` command
    would never be called since the variable will never meet the conditions of the
    `while` loop.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法终止，因为它将打印变量`0`的原始值。然而，这个算法实际上并不执行任何操作，因为条件永远不会满足。另外，请注意`print`命令没有缩进。如果缩进了，对于这个算法将不会给出任何输出，因为`print`命令永远不会被调用，因为变量永远不会满足`while`循环的条件。
- en: 'Now let''s take a look at the following algorithm:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下以下算法：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this case, the variable condition is met because `j` has to be greater than
    or equal to 0 for the program to run. Once the condition is met, the value of
    the variable is decremented by 1, so the `print` command will produce an output
    of `-1`. The code will not run a second time because the value of the variable
    is no longer greater than or equal to 0\. This algorithm is terminating, produces
    an output, and is feasible.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，变量条件得到满足，因为`j`必须大于或等于0才能使程序运行。一旦条件得到满足，变量的值就会减少1，因此`print`命令将产生一个输出为`-1`。代码不会再次运行，因为变量的值不再大于或等于0。这个算法是终止的，产生了输出，并且是可行的。
- en: 'Finally, let''s take a look at the following algorithm with a changed condition:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看一下以下具有改变条件的算法：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this case, the algorithm isn't terminating. Because we changed the `while`
    loop to be less than or equal to 0, this algorithm will now continue to run forever.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，算法是不终止的。因为我们将`while`循环改为小于或等于0，这个算法现在将永远继续运行。
- en: 'Analyzing algorithms can be very complex. We have only started to touch on
    some of the components of algorithms. As we delve deeper into other computational
    thinking problems throughout this book, we will need to keep in mind the characteristics
    of a good algorithm in order to analyze our own code effectively. It is also important
    that we continue to take into consideration the elements of the computational
    thinking process: **decomposition**, **pattern recognition**, **pattern generalization**,
    and **algorithm design**.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 分析算法可能非常复杂。我们只是开始涉及算法的一些组成部分。随着我们在本书中深入研究其他计算思维问题，我们需要牢记良好算法的特性，以便有效地分析我们自己的代码。同样重要的是，我们继续考虑计算思维过程的元素：**分解**，**模式识别**，**模式概括**和**算法设计**。
- en: When we are designing the algorithm and testing it, using the characteristics
    of good algorithms will allow us to observe errors, adjust our algorithm for ease
    of use, provide better inputs and outputs, and ensure that we are not creating
    infeasible and non-terminating algorithms.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计算法并测试它时，使用良好算法的特性将使我们能够观察错误，调整我们的算法以便使用，提供更好的输入和输出，并确保我们不会创建不可行和非终止的算法。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the definition of an algorithm, which is a set
    of steps that allows a computer to complete a process and provide some output.
    We went through the characteristics of algorithms.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了算法的定义，即一组步骤，允许计算机完成一个过程并提供一些输出。我们了解了算法的特性。
- en: We designed algorithms based on problem scenarios and then analyzed algorithms
    to determine whether they met the characteristics needed to run properly. Understanding
    the characteristics of algorithms and how algorithms work will allow us to create
    algorithms with far fewer errors than if we were unaware of these characteristics.
    Notice that I said *fewer* errors.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计了基于问题场景的算法，然后分析算法，以确定它们是否满足正确运行所需的特性。理解算法的特性以及算法的工作原理将使我们能够创建比不了解这些特性时错误要少得多的算法。请注意，我说的是*更少*的错误。
- en: When working with code, errors are a fact of life. We will inevitably make mistakes
    and we will accidentally introduce bugs or make some code infinite. Understanding
    the characteristics of a good algorithm allows us to reduce those errors, even
    if we don't fully eliminate them from our daily lives.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，错误是生活中不可避免的事实。我们将不可避免地犯错误，我们将无意中引入错误或使一些代码无限。了解良好算法的特性使我们能够减少这些错误，即使我们无法完全将它们从我们的日常生活中消除。
- en: In the next chapter, we will be learning more about logical reasoning. Throughout
    the chapter, we will discuss the definition of logic, learn about inductive and
    deductive reasoning, add to our knowledge of operators and Boolean logic, and
    learn more about logic errors. We will be using elements of computational thinking
    and the characteristics of algorithms to further our knowledge of logical reasoning.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于逻辑推理的知识。在整个章节中，我们将讨论逻辑的定义，学习归纳和演绎推理，增加我们对运算符和布尔逻辑的了解，并更多地了解逻辑错误。我们将使用计算思维的元素和算法的特性来进一步增进我们对逻辑推理的了解。
