- en: Chapter 4. Forms and Validation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。表单和验证
- en: In this chapter, we will learn how to use forms to modify the content on our
    blog directly through the site. This will be a fun chapter because we will be
    adding all sorts of new ways to interact with our site. We will create forms for
    working with the Entry model, learn how to receive and validate user data, and
    finally update the values in the database. Form processing and validation will
    be handled by the popular **WTForms** library. We will continue building out views
    and templates to support these new forms, learning a few new Jinja2 tricks along
    the way.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用表单直接通过网站修改博客上的内容。这将是一个有趣的章节，因为我们将添加各种新的与网站交互的方式。我们将创建用于处理Entry模型的表单，学习如何接收和验证用户数据，并最终更新数据库中的值。表单处理和验证将由流行的WTForms库处理。我们将继续构建视图和模板来支持这些新的表单，并在此过程中学习一些新的Jinja2技巧。
- en: 'In this chapter we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Install WTForms and create a form for working with the Entry model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装WTForms并创建一个用于处理Entry模型的表单
- en: Write views to validate and process form data, and persist changes to the database
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写视图来验证和处理表单数据，并将更改持久化到数据库中
- en: Create templates to display forms and validation errors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模板来显示表单和验证错误
- en: Use Jinja2 macros to encapsulate complex template logic
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jinja2宏来封装复杂的模板逻辑
- en: Display flash messages to the user
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户显示闪存消息
- en: Create an image uploader and learn how to securely handle file uploads
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个图片上传器，并学习如何安全处理文件上传
- en: Learn how to store and serve static assets, such as JavaScript, stylesheets
    and image uploads
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何存储和提供静态资产，如JavaScript、样式表和图像上传
- en: Getting started with WTForms
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用WTForms
- en: '**WTForms** is a popular choice for form processing and validation in the Flask
    community. It uses a declarative approach to building forms (similar to how we
    defined our SQLAlchemy models), and supports a variety of different field types
    and validators.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**WTForms**是Flask社区中处理表单和验证的流行选择。它使用一种声明性的方法来构建表单（类似于我们定义SQLAlchemy模型的方式），并支持各种不同的字段类型和验证器。'
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing this book, WTForms 2.0 is still a development release,
    but should be the official release shortly. For that reason we will be using version
    2.0 in this book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，WTForms 2.0仍然是一个开发版本，但应该很快就会成为官方版本。因此，我们将在本书中使用版本2.0。
- en: 'Let''s get started by installing WTForms into our blog project `virtualenv`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始通过将WTForms安装到我们的博客项目`virtualenv`中：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can verify that the installation succeeded by opening up a shell and checking
    the project version:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过打开一个shell并检查项目版本来验证安装是否成功：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: My version shows the development release since 2.0 has not been officially released
    yet.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我的版本显示了开发版本，因为2.0尚未正式发布。
- en: Defining a form for the Entry model
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Entry模型定义一个表单
- en: Our goal is to be able to create and edit blog entries directly through our
    site, so the first question we need to answer is—How will we input the data for
    our new entries? The answer, of course, is by using forms. Forms are a part of
    the HTML standard, which allows us to use free-form text inputs, large multi-line
    text boxes, drop-down selects, checkboxes, radio buttons, and more. When a user
    submits a form, the form specifies a URL that will receive the form data. That
    URL can then process the data and then respond in any way it likes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是能够直接通过我们的网站创建和编辑博客条目，因此我们需要回答的第一个问题是——我们将如何输入我们的新条目的数据？答案当然是使用表单。表单是HTML标准的一部分，它允许我们使用自由格式的文本输入、大型多行文本框、下拉选择、复选框、单选按钮等。当用户提交表单时，表单会指定一个URL来接收表单数据。然后该URL可以处理数据，然后以任何喜欢的方式做出响应。
- en: 'For blog entries, let''s keep it simple with three fields:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于博客条目，让我们保持简单，只有三个字段：
- en: '`Title`, displayed as a simple text input'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标题`，显示为简单的文本输入'
- en: '`Body`, displayed as a large free-form textbox'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`正文`，显示为大型自由格式文本框'
- en: '`Status`, which will be displayed as drop-down select'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`状态`，将显示为下拉选择'
- en: 'Inside the `entries` directory, create a new Python file named `forms.py`.
    We will be defining a simple form class that will contain these fields. Open `forms.py`
    and add the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在`entries`目录中，创建一个名为`forms.py`的新Python文件。我们将定义一个简单的表单类，其中包含这些字段。打开`forms.py`并添加以下代码：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This should look pretty similar to our model definition. Note that we''re using
    the names of the columns in our model as the names for the fields in our form:
    this will allow WTForms to automatically copy data between the Entry model fields
    and the form fields.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该看起来与我们的模型定义非常相似。请注意，我们正在使用模型中列的名称作为表单字段的名称：这将允许WTForms自动在Entry模型字段和表单字段之间复制数据。
- en: 'The first two fields, `title` and `body`, both specify a single argument: the
    label that will be displayed when the form is rendered. The `status` field contains
    a label as well as two additional parameters: `choices` and `coerce`. The `choices`
    parameter consists of a list of 2-tuples where the first value is the actual value
    we are interested in storing and the second value is a user-friendly representation.
    The second parameter, `coerce,` will convert the value from the form to an integer
    (by default, it would be treated as a string, which we do not want).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个字段，`标题`和`正文`，都指定了一个参数：在渲染表单时将显示的标签。`状态`字段包含一个标签以及两个额外的参数：`choices`和`coerce`。`choices`参数由一个2元组的列表组成，其中第一个值是我们感兴趣存储的实际值，第二个值是用户友好的表示。第二个参数，`coerce`，将把表单中的值转换为整数（默认情况下，它将被视为字符串，这是我们不想要的）。
- en: A form with a view
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个带有视图的表单
- en: 'In order to start using this form, we need to create a view that will display
    the form and accept data when it is submitted. To do this, let''s open the entries
    blueprint module and define a new URL route to handle entry creation. At the top
    of the `blueprint.py` file, we need to import the `EntryForm` class from the `forms`
    module:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始使用这个表单，我们需要创建一个视图，该视图将显示表单并在提交时接受数据。为此，让我们打开`entries`蓝图模块，并定义一个新的URL路由来处理条目创建。在`blueprint.py`文件的顶部，我们需要从`forms`模块导入`EntryForm`类：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then, above the definition for the `detail` view, we will add a new view named
    `create` that will be accessed by navigating to `/entries/create/`. The reason
    we must put it above the `detail` view is because Flask will search your URL routes
    in the order in which they are defined. Since `/entries/create/` looks very much
    like an entry detail URL (imagine the title of the entry was `create`), if the
    detail route is defined first, Flask will stop there and never reach the create
    route.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`detail`视图的定义之上，我们将添加一个名为`create`的新视图，该视图将通过导航到`/entries/create/`来访问。我们必须将其放在`detail`视图之上的原因是因为Flask将按照定义的顺序搜索URL路由。由于`/entries/create/`看起来非常像一个条目详细信息URL（想象条目的标题是`create`），如果首先定义了详细信息路由，Flask将在那里停止，永远不会到达创建路由。
- en: 'In our create view, we will simply instantiate the form and pass it into the
    template context. Add the following view definition:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的创建视图中，我们将简单地实例化表单并将其传递到模板上下文中。添加以下视图定义：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Before we add code to save the new entries to the database, let's build a template
    and see what our form looks like. We will then circle back and add the code to
    validate the form data and create the new entry.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加代码将新条目保存到数据库之前，让我们构建一个模板，看看我们的表单是什么样子。然后我们将回过头来添加代码来验证表单数据并创建新条目。
- en: The create.html template
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: create.html模板
- en: 'Let''s build a basic template for our new form. Create a new template named
    `create.html` alongside the other entry templates. The path to this file, relative
    to the app directory, should be `entries/templates/entries/create.html`. We will
    extend the base template and override the content block to display our form. Since
    we are using bootstrap, we will use special CSS classes to make our form look
    nice. Add the following HTML code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的新表单构建一个基本模板。在其他条目模板旁边创建一个名为`create.html`的新模板。相对于应用程序目录，该文件的路径应为`entries/templates/entries/create.html`。我们将扩展基本模板并覆盖内容块以显示我们的表单。由于我们使用的是bootstrap，我们将使用特殊的CSS类来使我们的表单看起来漂亮。添加以下HTML代码：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By iterating over the form, which we passed into the context, we can render
    each individual field. To render the field, we first render the field's label
    by simply calling `field.label()` and passing in the desired CSS class. Similarly,
    to render the field, we call `field()`, again passing in the CSS class. Also note
    that, in addition to a `submit` button, we've added a `Cancel` link that will
    return the user to the entries list.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过迭代我们传入上下文的表单，我们可以渲染每个单独的字段。要渲染字段，我们首先通过简单调用`field.label()`并传入所需的CSS类来渲染字段的标签。同样，要渲染字段，我们调用`field()`，再次传入CSS类。还要注意的是，除了`submit`按钮，我们还添加了一个`Cancel`链接，该链接将返回用户到条目列表。
- en: 'Start the development server and navigate to `http://127.0.0.1:5000/entries/create/`
    to view the following form:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 启动开发服务器并导航到`http://127.0.0.1:5000/entries/create/`以查看以下表单：
- en: '![The create.html template](img/1709_04_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![create.html模板](img/1709_04_01.jpg)'
- en: 'Try submitting the form. When you click the **Create** button, you should see
    the following error message:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试提交表单。当您点击**创建**按钮时，您应该会看到以下错误消息：
- en: '![The create.html template](img/1709_04_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![create.html模板](img/1709_04_02.jpg)'
- en: The reason you are seeing this message is because, by default, Flask views will
    only respond to HTTP `GET` requests. When we submit our form, the browser sends
    a `POST` request, which our view does not currently accept. Let's return to the
    `create` view and add the code to correctly handle the `POST` requests.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到此消息的原因是因为默认情况下，Flask视图只会响应HTTP `GET`请求。当我们提交表单时，浏览器会发送`POST`请求，而我们的视图目前不接受。让我们返回`create`视图并添加代码来正确处理`POST`请求。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Whenever a form makes changes to the data (creates, edits, or deletes something),
    that form should specify the `POST` method. Other forms, such as our search form,
    which do not make any changes, should use the `GET` method. Additionally, when
    a form is submitted using the `GET` method, the form data is submitted as part
    of the query-string.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每当表单对数据进行更改（创建、编辑或删除某些内容）时，该表单应指定`POST`方法。其他表单，例如我们的搜索表单，不进行任何更改，应使用`GET`方法。此外，当使用`GET`方法提交表单时，表单数据将作为查询字符串的一部分提交。
- en: Handling form submissions
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理表单提交
- en: 'Before we modify our view, let''s add a helper method to our `EntryForm` that
    we will use to copy data from the form into our `Entry` object. Open `forms.py`
    and make the following additions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改视图之前，让我们向我们的`EntryForm`添加一个辅助方法，我们将使用该方法将数据从表单复制到我们的`Entry`对象中。打开`forms.py`并进行以下添加：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This helper method will populate the `entry` we pass in with the form data,
    re-generate the entry's slug based on the title, and then return the `entry` object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个辅助方法将用表单数据填充我们传入的`entry`，根据标题重新生成条目的slug，然后返回`entry`对象。
- en: 'Now that the form is configured to populate our `Entry` models, we can modify
    the view to accept and handle the `POST` requests. We will be using two new Flask
    helpers, so modify the imports at the top of `blueprint.py`, adding `redirect`
    and `url_for`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在表单已配置为填充我们的`Entry`模型，我们可以修改视图以接受和处理`POST`请求。我们将使用两个新的Flask辅助函数，因此修改`blueprint.py`顶部的导入，添加`redirect`和`url_for`：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once you''ve added the imports, update the following changes to the `create`
    view in `blueprint.py`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 添加导入后，更新`blueprint.py`中`create`视图的以下更改：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is quite a bit of new code, so let's take a closer look at what's happening.
    To begin with, we've added a parameter to the route decorator indicating that
    this view accepts both `GET` and `POST` requests. This will get rid of the **Method
    Not Allowed** error when we submit the form.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当多的新代码，让我们仔细看看发生了什么。首先，我们在路由装饰器中添加了一个参数，指示此视图接受`GET`和`POST`请求。这将消除当我们提交表单时出现的**方法不允许**错误。
- en: In the body of the view, we are now checking the `request` method and based
    on that we do one of two things. Let's look at the 'else' clause first. This branch
    of code will execute when we receive a `GET` request, such as when someone opens
    their browser and navigates to the `/entries/create/` page. When this happens,
    we simply want to display an HTML page containing the form, so we will instantiate
    a form and pass it into the template context.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图的主体中，我们现在正在检查`request`方法，并根据这一点做两件事中的一件。让我们首先看看'else'子句。当我们收到`GET`请求时，比如当有人打开他们的浏览器并导航到`/entries/create/`页面时，代码分支将执行。当这种情况发生时，我们只想显示包含表单的HTML页面，因此我们将实例化一个表单并将其传递到模板上下文中。
- en: In the event this is a `POST` request, which will happen when someone submits
    the form, we want to instantiate the `EntryForm` and pass in the raw form data.
    Flask stores the raw POST data in the special attribute `request.form`, which
    is a dictionary-like object. WTForms knows how to interpret the raw form data
    and map it to the fields we defined.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个`POST`请求，当有人提交表单时会发生，我们想要实例化`EntryForm`并传入原始表单数据。Flask将原始的POST数据存储在特殊属性`request.form`中，这是一个类似字典的对象。WTForms知道如何解释原始表单数据并将其映射到我们定义的字段。
- en: After instantiating our form with the raw form data, we then need to check and
    ensure that the form is valid by calling `form.validate()`. If the form fails
    to validate for some reason, we will simply pass the invalid form into the context
    and render the template. A bit later you will see how we can display error messages
    to the user when there is a problem with their form submission.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在用原始表单数据实例化我们的表单之后，我们需要检查并确保表单有效，通过调用`form.validate()`。如果表单由于某种原因未能验证，我们将简单地将无效的表单传递到上下文并呈现模板。稍后您将看到我们如何在用户的表单提交出现问题时向用户显示错误消息。
- en: If the form validates, we can finally proceed with saving the entry. To do this,
    we will call our `save_entry` helper method, passing in a fresh `entry` instance.
    WTForms will populate the `Entry` object with form data, then return it back to
    us, where we add it to the database session, commit, and redirect. The redirect
    helper will issue an HTTP 302 redirect, sending the user's browser from `/entries/create/`
    to the detail page of the newly-created blog post.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表单验证通过，我们最终可以继续保存条目。为此，我们将调用我们的`save_entry`辅助方法，传入一个新的`entry`实例。WTForms将使用表单数据填充`Entry`对象，然后将其返回给我们，在那里我们将其添加到数据库会话中，提交并重定向。重定向助手将发出HTTP
    302重定向，将用户的浏览器从`/entries/create/`发送到新创建的博客文章的详细页面。
- en: Open up your browser and give it a try.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的浏览器，试一试。
- en: '![Handling form submissions](img/1709_04_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![处理表单提交](img/1709_04_03.jpg)'
- en: Validating input and displaying error messages
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证输入并显示错误消息
- en: 'There is one glaring problem with our form: right now there is nothing to prevent
    us from accidentally submitting an empty blog entry. To ensure that we have a
    title and content when saving, we need to use a WTForm object called a validator.
    Validators are rules that are applied to the form data, and WTForms ships with
    a number of useful validators. Some of the more commonly-used validators are listed
    as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表单存在一个明显的问题：现在没有任何东西可以阻止我们意外地提交一个空的博客条目。为了确保在保存时有标题和内容，我们需要使用一个名为验证器的WTForm对象。验证器是应用于表单数据的规则，WTForms附带了许多有用的验证器。一些常用的验证器列在下面：
- en: '`DataRequired`: this field cannot be blank'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataRequired`：此字段不能为空'
- en: '`Length(min=?, max=?)`: verify that the length of the data entered either exceeds
    the minimum, or does not exceed the maximum'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Length(min=?, max=?)`：验证输入的数据的长度是否超过最小值，或者是否不超过最大值'
- en: '`NumberRange(min=?, max=?)`: verify that the number entered is within the given
    range'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumberRange(min=?, max=?)`：验证输入的数字是否在给定范围内'
- en: '`Email`: verify that the data is a valid email address'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Email`：验证数据是否为有效的电子邮件地址'
- en: '`URL`: verify that the data entered is a valid URL'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URL`：验证输入的数据是否为有效的URL'
- en: '`AnyOf(values=?)`: verify that the data entered is equal to one of the provided
    values'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnyOf(values=?)`：验证输入的数据是否等于提供的值之一'
- en: '`NoneOf(values=?)`: verify that the data entered is not equal to any of the
    provided values'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NoneOf(values=?)`：验证输入的数据是否不等于提供的任何值'
- en: 'For the blog entry form, we will just be using the `DataRequired` validator
    to ensure that Entries cannot be created without a title or body content. Let''s
    open `forms.py` and add the validators to our form definition. Altogether, our
    forms module should look a follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于博客条目表单，我们将只使用`DataRequired`验证器来确保条目不能在没有标题或正文内容的情况下创建。让我们打开`forms.py`并将验证器添加到我们的表单定义中。总的来说，我们的表单模块应该如下所示：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Start the development server and now try to submit an empty form. As you might
    expect, it will fail to save since the call to `form.validate()` returns `False`.
    Unfortunately, there is no indication on the front-end why our form is not getting
    saved. Luckily, WTForms will make the validation errors available to us in the
    template, and all we need to do is modify our template to display them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 启动开发服务器，现在尝试提交一个空表单。正如你所期望的那样，由于对`form.validate()`的调用返回`False`，它将无法保存。不幸的是，前端没有任何指示我们的表单为什么没有保存。幸运的是，WTForms将使验证错误在模板中可用，我们所需要做的就是修改我们的模板来显示它们。
- en: 'To display validation errors we will be using several bootstrap CSS classes
    and constructions, but the end result will look very nice, as seen in the following
    screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示验证错误，我们将使用几个bootstrap CSS类和结构，但最终结果将非常好看，如下面的截图所示：
- en: '![Validating input and displaying error messages](img/1709_04_04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![验证输入并显示错误消息](img/1709_04_04.jpg)'
- en: 'Make the following changes to the field display code in the `create.html` template:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对`create.html`模板中的字段显示代码进行以下更改：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We are checking whether the field has any errors by looking at the `field.errors`
    attribute. If there are any errors, then we do the following things:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过查看`field.errors`属性来检查字段是否有任何错误。如果有任何错误，那么我们会做以下事情：
- en: Add a CSS class to the `form-group` div
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`form-group` div添加CSS类
- en: Add a special icon indicating there is an error
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个特殊的图标表示有错误发生
- en: Display each error in a `<span>` beneath the form field. Since `field.errors`
    is a list and may contain multiple validation errors, we will iterate through
    these using a for loop
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表单字段下方显示每个错误的`<span>`。由于`field.errors`是一个列表，可能包含多个验证错误，我们将使用for循环来遍历这些错误。
- en: You are now able to create valid blog entries using a form, which also performs
    a little validation to ensure that you do not submit blank forms. In the next
    section, we will describe how to re-use this same form for editing existing entries.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用表单创建有效的博客条目，该表单还会执行一些验证，以确保您不会提交空白表单。在下一节中，我们将描述如何重复使用相同的表单来编辑现有条目。
- en: Editing existing entries
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑现有条目
- en: Believe it or not, we can actually use the same form we used for creating entries
    to edit existing ones. We will only need to make some slight changes to the view
    and template logic, so let's get started.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，我们实际上可以使用相同的表单来编辑现有条目。我们只需要对视图和模板逻辑进行一些微小的更改，所以让我们开始吧。
- en: 'In order to edit entries, we will need a view, so we will need a URL. Because
    the view needs to know which entry we are editing, it will be important to convey
    that as part of the URL structure, and for that reason we will set up the `edit`
    view at `/entries/<slug>/edit/`. Open `entries/blueprint.py` and, below the detail
    view, add the following code for the `edit` view. Note the similarities to the
    `create` view:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编辑条目，我们将需要一个视图，因此我们将需要一个URL。因为视图需要知道我们正在编辑哪个条目，所以将其作为URL结构的一部分传达是很重要的，因此我们将在`/entries/<slug>/edit/`设置`edit`视图。打开`entries/blueprint.py`，在详细视图下方，添加以下代码以获取`edit`视图。请注意与`create`视图的相似之处：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Just as we did with the `create` view, we check the `request` method and, based
    on that, we will either validate and process the form, or simply instantiate it
    and pass it to the template.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在`create`视图中所做的那样，我们检查`request`方法，并根据它，我们将验证和处理表单，或者只是实例化它并将其传递给模板。
- en: The biggest difference is in how we are instantiating the `EntryForm`. We pass
    it an additional parameter, `obj=entry`. When WTForms receives an `obj` parameter,
    it will attempt to pre-populate the form fields with values taken from `obj` (in
    this case, our blog entry).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的区别在于我们如何实例化`EntryForm`。我们向它传递了一个额外的参数，`obj=entry`。当WTForms接收到一个`obj`参数时，它将尝试使用从`obj`中获取的值（在本例中是我们的博客条目）预填充表单字段。
- en: We are also passing an additional value into the template context, the entry
    that we are editing. We will do this so we can display the title of the entry
    to the user; in this way, we can make the **Cancel** button of the form link back
    to the entry detail view.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在模板上下文中传递一个额外的值，即我们正在编辑的条目。我们这样做是为了能够向用户显示条目的标题；这样，我们可以使表单的**取消**按钮链接回条目详细视图。
- en: The edit.html template
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑.html模板
- en: As you might guess, the `edit.html` template will be almost identical to `create.html`.
    Due to the complexity of the field rendering logic, it seems like a bad idea to
    copy-and-paste all that code. If we ever decided to change the display of the
    form fields, we would find ourselves touching multiple files, which should always
    be a big red flag.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能猜到的，`edit.html`模板几乎与`create.html`相同。由于字段渲染逻辑的复杂性，复制并粘贴所有代码似乎是一个坏主意。如果我们决定更改表单字段的显示方式，我们将发现自己需要修改多个文件，这应该始终是一个很大的警告信号。
- en: To avoid this, we will be using a powerful Jinja2 feature called macros to render
    our fields. The field rendering code will be defined in a macro and then, wherever
    we wish to render a field, we will just call our macro instead. This makes it
    really easy to make changes to the way our fields are styled.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们将使用一个强大的Jinja2功能，称为宏，来渲染我们的字段。字段渲染代码将在宏中定义，然后，无论我们想要渲染一个字段的地方，我们只需调用我们的宏。这样可以很容易地更改我们的字段样式。
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Macros are a feature of Jinja2 that allow you to treat a section of a template
    like a function so it can be called multiple times with different arguments and
    produce largely similar HTML. You can view more on the Jinja documentation site:
    [http://jinja.pocoo.org/docs/dev/templates/](http://jinja.pocoo.org/docs/dev/templates/)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 宏是Jinja2的一个功能，允许您将模板的一部分视为函数，因此可以使用不同的参数多次调用它，并生成基本相似的HTML。您可以在Jinja文档网站上查看更多内容：[http://jinja.pocoo.org/docs/dev/templates/](http://jinja.pocoo.org/docs/dev/templates/)
- en: 'Since this macro is going to be useful for any form field we might wish to
    display, we will put it in our app''s template directory. Inside the app''s template
    directory, create a new directory named `macros` and add a field `form_field.html`.
    Relative to the app directory, the path to this file is `templates/macros/form_field.html`.
    Add the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个宏对于我们可能希望显示的任何表单字段都是有用的，我们将把它放在我们应用程序的模板目录中。在应用程序的模板目录中，创建一个名为`macros`的新目录，并添加一个字段`form_field.html`。相对于应用程序目录，该文件的路径是`templates/macros/form_field.html`。添加以下代码：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For the most part, we have simply copied and pasted the field rendering code
    from our `create` template but there are a couple of differences I''d like to
    point out:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在大部分情况下，我们只是从`create`模板中复制并粘贴了字段渲染代码，但有一些区别我想指出：
- en: The template begins with a `macro` template tag that defines the name of the
    `macro` and any arguments that it accepts.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板以`macro`模板标签开头，定义了`macro`的名称和它接受的任何参数。
- en: When we render the field, we are passing in `**kwargs`. WTForms fields can accept
    arbitrary keyword arguments, which are then translated into attributes on the
    HTML tag. While we are not currently going to make use of this, we will be using
    it in later chapters.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们渲染字段时，我们传入`**kwargs`。WTForms字段可以接受任意关键字参数，然后将其转换为HTML标记上的属性。虽然我们目前不打算使用这个功能，但我们将在后面的章节中使用它。
- en: We indicate the end of a macro with the `endmacro` tag.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`endmacro`标记表示宏的结束。
- en: 'Now let''s update `create.html` to make use of the new macro. In order to use
    the macro, we must first `import` it. Then we can replace all the field markup
    with a simple call to the macro. With the changes, the `create.html` template
    should look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新`create.html`以使用新的宏。为了使用这个宏，我们必须首先`import`它。然后我们可以用一个简单的宏调用替换所有的字段标记。通过这些更改，`create.html`模板应该是这样的：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With that out of the way, we can proceed to creating our `edit.html` template.
    It will look almost identical to the `create` template, except we will display
    text in the `app/entries/templates/entries` directory to indicate to the user
    that they are editing an existing entry:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 搞定这些之后，我们可以继续创建我们的`edit.html`模板。它看起来几乎和`create`模板一样，只是我们将在`app/entries/templates/entries`目录中显示文本，以指示用户他们正在编辑一个现有条目：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To wrap things up, on the entry detail page let''s add a link in the sidebar
    that will take us to the `Edit` page. Add the following link to the sidebar in
    `detail.html`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一部分，在条目详细页面上，让我们在侧边栏中添加一个链接，可以带我们到`Edit`页面。在`detail.html`的侧边栏中添加以下链接：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Deleting entries
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除条目
- en: To round out this section, we will add a view for deleting entries. We will
    design this view so that, when the user goes to delete an entry, they are taken
    to a confirmation page. Only by submitting the confirmation form (a `POST` request)
    will they actually be able to delete the entry. Because this form does not require
    any fields, we do not need a special WTForms class and can just create it using
    HTML.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这一部分，我们将添加一个用于删除条目的视图。我们将设计这个视图，当用户去删除一个条目时，他们会被带到一个确认页面。只有通过提交确认表单（一个`POST`请求），他们才能真正删除条目。因为这个表单不需要任何字段，我们不需要一个特殊的WTForms类，可以直接使用HTML创建它。
- en: 'Create a template named `delete.html` alongside the `create.html` and `edit.html`
    templates, and add the following HTML:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`create.html`和`edit.html`模板旁边创建一个名为`delete.html`的模板，并添加以下HTML：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now we need to define the `entries.delete` view. Like the `edit` view, the URL
    for deleting an entry needs the entry slug as part of the URL structure. For that
    reason, we will be using `/entries/<slug>/delete/`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要定义`entries.delete`视图。与`edit`视图一样，删除条目的URL需要条目slug作为URL结构的一部分。因此，我们将使用`/entries/<slug>/delete/`。
- en: 'When the form is submitted, we could simply remove the entry from the database
    but in my experience I have usually come to regret deleting content permanently.
    Instead of actually deleting the entry from the database, we will be giving it
    a `_DELETED` status; we will change its status to `STATUS_DELETED`. We will then
    modify our views so that entries with this status never appear on any part of
    the site. For all intents and purposes, the entry is gone but, should we ever
    need it again, we can retrieve it from the database. Add the following view code
    below the `edit` view:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单提交时，我们可以简单地从数据库中删除条目，但根据我的经验，我通常会后悔永久删除内容。我们不会真正从数据库中删除条目，而是给它一个`_DELETED`状态；我们将把它的状态改为`STATUS_DELETED`。然后我们将修改我们的视图，以便具有这种状态的条目永远不会出现在网站的任何部分。在所有方面，条目都消失了，但是，如果我们将来需要它，我们可以从数据库中检索它。在`edit`视图下面添加以下视图代码：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will also need to add STATUS_DELETED to the Entries model in model.py:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在model.py中的Entries模型中添加STATUS_DELETED：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we did with the Edit link, take a moment and add a `delete` link to the detail
    view sidebar as well.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与编辑链接一样，花点时间在详细视图侧边栏中添加一个`delete`链接。
- en: Cleaning up
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理
- en: Let's take a moment to refactor our blueprint. Since we do not want to display
    deleted entries on the site, we will need to make sure we filter our Entries by
    status. Additionally, looking at the `detail`, `edit` and `delete` views, I see
    three instances where we have copied and pasted the code to query an entry by
    slug. Let's move that into a helper function as well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间重构我们的蓝图。由于我们不想在网站上显示已删除的条目，我们需要确保通过状态筛选我们的条目。此外，看着`detail`、`edit`和`delete`视图，我看到了三个我们复制并粘贴查询条目的代码的实例。让我们也将其移动到一个辅助函数中。
- en: To start with, let's update the `entry_list` helper to filter for Entries that
    are either public or drafts.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更新`entry_list`辅助函数，以筛选出公共或草稿条目。
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In the next chapter, we will be adding log-in functionality to the site. Once
    we have that, we will add logic to display draft entries only to the users who
    created them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为网站添加登录功能。一旦我们有了这个功能，我们将添加逻辑，只向创建它们的用户显示草稿条目。
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can now be confident that anywhere we display lists of entries, no deleted
    entries will show up.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以确信，无论我们在哪里显示条目列表，都不会显示已删除的条目。
- en: 'Now let''s add a new helper to retrieve an `Entry` by its slug. If the entry
    cannot be found, we will return a 404\. Add the following code below `entry_list`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加一个新的辅助函数来通过其slug检索`Entry`。如果找不到条目，我们将返回404。在`entry_list`下面添加以下代码：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Replace the call to `Entry.query.filter()` in the `detail`, `edit`, and `delete`
    views with a call to `get_entry_or_404`. The following is the updated detail view:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 用`get_entry_or_404`替换`detail`、`edit`和`delete`视图中的`Entry.query.filter()`调用。以下是更新后的detail视图：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using flash messages
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用闪存消息
- en: When a user performs an action on a site, it is common to display a one-time
    message on the subsequent page-load indicating that their action has succeeded.
    These are called flash messages and Flask comes with a helper for displaying them.
    In order to get started using flash messages, we need to take a brief detour to
    our `config` module where we will be adding a secret key. The secret key is necessary
    because flash messages are stored in the session, which in turn is stored as an
    encrypted cookie. To securely encrypt this data, Flask needs a key.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在网站上执行操作时，通常会在随后的页面加载时显示一次性消息，指示他们的操作已成功。这些称为闪存消息，Flask带有一个辅助函数来显示它们。为了开始使用闪存消息，我们需要在`config`模块中添加一个秘钥。秘钥是必要的，因为闪存消息存储在会话中，而会话又存储为加密的cookie。为了安全地加密这些数据，Flask需要一个秘钥。
- en: 'Open `config.py` and add a secret key. It can be a phrase, random characters,
    whatever you like:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`config.py`并添加一个秘钥。可以是短语、随机字符，任何你喜欢的东西：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, wherever we have the user performing an action, we want to flash them
    a message indicating that their action succeeded. This means we will be adding
    a message to the `create`, `edit,` and `delete` views. Open up the entries blueprint
    and add the flash function to the list of flask imports at the top of the module:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论我们的用户在哪个页面上执行操作，我们都希望向他们显示一个消息，指示他们的操作成功。 这意味着我们将在`create`，`edit`和`delete`视图中添加一个消息。
    打开条目蓝图并将闪存函数添加到模块顶部的flask导入列表中：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, in each of the appropriate views, let''s call `flash` with a helpful
    message. The call should occur right before we redirect:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在每个适当的视图中，让我们调用`flash`并显示一个有用的消息。 在重定向之前应该发生调用：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Displaying flash messages in the template
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模板中显示闪存消息
- en: Because we do not always know which page we will be on when we need to display
    a flash message, it is a standard practice to add the display logic to the base
    template. Flask provides a Jinja2 function `get_flashed_messages` that will return
    us a list of any pending messages to display.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们并不总是知道在需要显示闪存消息时我们将在哪个页面上，所以将显示逻辑添加到基本模板是一种标准做法。 Flask提供了一个Jinja2函数`get_flashed_messages`，它将返回一个待显示的消息列表。
- en: 'Open `base.html` and add the following code. I have placed mine between the
    `content_title` block and the `content` block:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`base.html`并添加以下代码。 我已经将我的代码放在`content_title`块和`content`块之间：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s give it a try! Start the development server and try adding a new entry.
    Upon saving, you should be redirected to your new entry and see a helpful message
    as seen in the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看！ 启动开发服务器并尝试添加一个新条目。 保存后，您应该被重定向到新条目，并看到一个有用的消息，如下面的屏幕截图所示：
- en: '![Displaying flash messages in the template](img/1709_04_05.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![在模板中显示闪存消息](img/1709_04_05.jpg)'
- en: Saving and modifying tags on posts
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和修改帖子上的标签
- en: We have covered how to save and modify tags on our entries. One of the most
    common approaches to managing tags is to use a comma-separated text input, so
    we might list the tags as *Python*, *Flask*, *Web-development*. With WTForms this
    seems pretty straightforward, since we would just use a `StringField`. The fact
    that we are dealing with a database relationship, though, means that at some point
    we need to do some processing to convert between `Tag` models and a comma-separated
    string.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何保存和修改条目上的标签。 管理标签的最常见方法之一是使用逗号分隔的文本输入，因此我们可以将标签列为*Python*，*Flask*，*Web-development*。
    使用WTForms似乎非常简单，因为我们只需使用`StringField`。 然而，由于我们正在处理数据库关系，这意味着我们需要在`Tag`模型和逗号分隔的字符串之间进行一些处理。
- en: While there are many ways we could accomplish this, we will implement a custom
    field class `TagField`, which will encapsulate all the logic for translating between
    comma-separated tag names and `Tag` model instances.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以通过许多方式来实现这一点，但我们将实现一个自定义字段类`TagField`，它将封装在逗号分隔的标签名称和`Tag`模型实例之间进行转换的所有逻辑。
- en: Tip
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Another option would be to create a *property* on the `Entry` model. A property
    looks like a normal object attribute, but it is actually a combination of getter
    and (sometimes) setter methods. Since WTForms can automatically work with our
    model attributes, this means that, if we implement our translation logic in the
    getter and setter, WTForms will just work.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是在`Entry`模型上创建一个*property*。 属性看起来像一个普通的对象属性，但实际上是getter和（有时）setter方法的组合。
    由于WTForms可以自动处理我们的模型属性，这意味着，如果我们在getter和setter中实现我们的转换逻辑，WTForms将正常工作。
- en: 'Let''s start by defining our tag field class. There are two important methods
    we need to override:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义我们的标签字段类。 我们需要重写两个重要的方法：
- en: '`_value()`: converts the list of `Tag` instances into a comma-separated list
    of tag names'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_value()`: 将`Tag`实例列表转换为逗号分隔的标签名称列表'
- en: '`process_formdata(valuelist)`: accepts the comma-separated tag list and converts
    it into a list of `Tag` instances'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process_formdata(valuelist)`: 接受逗号分隔的标签列表并将其转换为`Tag`实例的列表'
- en: 'Following is the implementation for the `TagField`. Note how we take special
    care when processing user input to not create duplicate rows in the `Tag` table.
    We are also using Python''s `set()` data-type to eliminate possible duplicates
    in the user input. Add the following class to `forms.py` above the `EntryForm`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`TagField`的实现。 请注意，我们在处理用户输入时要特别小心，以避免在`Tag`表中创建重复行。 我们还使用Python的`set()`数据类型来消除用户输入中可能的重复项。
    将以下类添加到`forms.py`中的`EntryForm`上方：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now all that is left is to add the field to the `EntryForm`. Add the following
    field below the `status` field. Note the use of the `description` keyword argument:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将字段添加到`EntryForm`中。 在`status`字段下面添加以下字段。 请注意`description`关键字参数的使用：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In order to display this helpful `description` text, let''s make a quick modification
    to the `form_field` macro:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示这个有用的`description`文本，让我们对`form_field`宏进行快速修改：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Start the development server and experiment by saving a few tags. Your form
    should look something like the following screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 启动开发服务器，并尝试保存一些标签。 您的表单应该看起来像下面的屏幕截图：
- en: '![Saving and modifying tags on posts](img/1709_04_06.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![保存和修改帖子上的标签](img/1709_04_06.jpg)'
- en: Image uploads
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像上传
- en: We'll round out the chapter on form processing by adding an image-uploading
    feature to the site. This feature will be a simple view that accepts an image
    file and stores it on the server in an uploads directory. This will make it easy
    to display images on our blog entries.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过为网站添加一个图片上传功能来完成表单处理章节。 这个功能将是一个简单的视图，接受一个图像文件并将其存储在服务器上的上传目录中。 这将使我们能够轻松在博客条目中显示图像。
- en: 'The first step will be to create a form for handling our image uploads. Alongside
    `EntryForm`, let''s add a new form called `ImageForm`. This form will be very
    simple and contain a single file input. We will use a custom validator to ensure
    that the uploaded file is a valid image. Add the following code to `forms.py`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个处理图像上传的表单。 除了`EntryForm`，让我们添加一个名为`ImageForm`的新表单。 这个表单将非常简单，包含一个文件输入。
    我们将使用自定义验证器来确保上传的文件是有效的图像。 将以下代码添加到`forms.py`中：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Before we add a view to save the form, we need to know where we are going to
    save the file. Typically, resources for an app—such as images, JavaScript, and
    stylesheets—are served out of a single directory called `static`. Common practice
    is to then over-ride the path to this directory in your web server so it can transfer
    this file without having to go through a Python intermediary, making access much
    faster. We make use of this usage of the `static` directory to store our image
    uploads. In the blog project''s `app` directory, let''s create a new directory
    named `static` and a subdirectory `images`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加一个视图来保存表单之前，我们需要知道我们将在哪里保存文件。通常，应用程序的资源（如图像、JavaScript和样式表）都是从一个名为`static`的单个目录中提供的。通常的做法是在web服务器中覆盖此目录的路径，以便它可以在不经过Python中介的情况下传输此文件，从而使访问速度更快。我们利用`static`目录来存储我们的图像上传。在博客项目的`app`目录中，让我们创建一个名为`static`的新目录和一个子目录`images`：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now let''s add a new value to our configuration file so we can easily reference
    the path to our images on-disk. This simplifies our code in the long run should
    we ever choose to change this location. Open `config.py` and add the following
    value:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们向配置文件中添加一个新值，这样我们就可以轻松地引用磁盘上图像的路径。这样可以简化我们的代码，以后如果我们选择更改此位置，也会更加方便。打开`config.py`并添加以下值：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Processing file uploads
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理文件上传
- en: We are now ready to create a view for processing the image upload. The logic
    will be very similar to our other form processing views with the exception that,
    after validating the form, we will save the uploaded file to disk. Since these
    images are intended for use in our blog entries, I am adding the view to the entries
    blueprint, accessible at `/entries/image-upload/`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备创建一个用于处理图像上传的视图。逻辑将与我们的其他表单处理视图非常相似，唯一的区别是，在验证表单后，我们将把上传的文件保存到磁盘上。由于这些图像是用于我们博客条目的，我将视图添加到entries
    blueprint中，可在`/entries/image-upload/`访问。
- en: 'We need to import our new form along with other helpers. Open `blueprint.py`
    and add the following imports to the top of the module:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要导入我们的新表单以及其他辅助工具。打开`blueprint.py`并在模块顶部添加以下导入：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'At the top of the list of views, let''s add the new `image-upload` view. It
    is important that it appears before the `detail` view, otherwise Flask will incorrectly
    treat `/image-upload/` as the slug of a blog entry. Add the following view definition:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图列表的顶部，让我们添加新的`image-upload`视图。重要的是它出现在`detail`视图之前，否则Flask会错误地将`/image-upload/`视为博客条目的slug。添加以下视图定义：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Most of the code here probably looks familiar to you, the notable exception
    being the use of `request.files` and `secure_filename`. When a file is uploaded,
    Flask will store it in `request.files`, which is a special dictionary keyed by
    the name of the form field. We do some path joining using `secure_filename` to
    prevent malicious filenames and to generate the correct path to the `static/images`
    directory, and then save the uploaded file to disk. It is that easy.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的大部分代码可能看起来很熟悉，值得注意的例外是使用`request.files`和`secure_filename`。当文件上传时，Flask会将其存储在`request.files`中，这是一个特殊的字典，以表单字段的名称为键。我们使用`secure_filename`进行一些路径连接，以防止恶意文件名，并生成到`static/images`目录的正确路径，然后将上传的文件保存到磁盘上。就是这么简单。
- en: The image upload template
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图片上传模板
- en: 'Let''s create a simple template for our image upload form. Create a file in
    the entries template directory named `image_upload.html` and add the following
    code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的图片上传表单创建一个简单的模板。在entries模板目录中创建一个名为`image_upload.html`的文件，并添加以下代码：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In order for Flask to process our uploaded file, we must specify `enctype="multipart/form-data"`
    when defining our `<form>` element. This is a very common mistake, so I will repeat
    again: whenever you are accepting file uploads, your form element must specify
    `enctype="multipart/form-data"`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Flask处理我们上传的文件，我们必须在定义`<form>`元素时指定`enctype="multipart/form-data"`。这是一个非常常见的错误，所以我会再次重复：每当您接受文件上传时，您的表单元素必须指定`enctype="multipart/form-data"`。
- en: Go ahead and try out the image uploader. You should see your uploaded files
    appear in the `static/images/directory` in your app. You can also view the image
    in your browser by navigating to `http://127.0.0.1:5000/static/images/the-file-name.jpg`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 继续尝试图片上传。您应该在应用程序中的`static/images/directory`中看到您上传的文件。您还可以通过浏览器导航到`http://127.0.0.1:5000/static/images/the-file-name.jpg`来查看图像。
- en: Serving static files
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: Flask will automatically serve up files from our `/static/` directory. When
    we deploy our site in [Chapter 10](ch10.html "Chapter 10. Deploying Your Application"),
    *Deploying Your Application*, we will use the **Nginx** web server to serve static
    assets but, for local development, Flask makes things really easy.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Flask将自动从我们的`/static/`目录中提供文件。当我们在[第10章](ch10.html "第10章。部署您的应用程序")部署我们的网站时，*部署您的应用程序*，我们将使用**Nginx**
    web服务器来提供静态资产，但是对于本地开发，Flask使事情变得非常简单。
- en: 'In addition to our image uploads, let''s also serve our site''s JavaScript
    and stylesheets from `/static/`. Download jQuery and Bootstrap and place the JavaScript
    files (`jquery-<version>.min.js` and `boostrap.min.js`) in `static/js`. Place
    the minified bootstrap CSS file (`bootstrap.min.css`) in `static/css`. Bootstrap
    also comes with some special fonts that are used for icons. Copy the bootstrap
    fonts directory into the static directory as well. You should now have four directories
    inside your application''s static directory: `css`, `fonts`, `images` and `js`,
    each containing the relevant files:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们的图像上传，让我们还从`/static/`提供我们网站的JavaScript和样式表。下载jQuery和Bootstrap，并将JavaScript文件（`jquery-<version>.min.js`和`boostrap.min.js`）放在`static/js`中。将压缩的bootstrap
    CSS文件（`bootstrap.min.css`）放在`static/css`中。Bootstrap还带有一些用于图标的特殊字体。将bootstrap字体目录也复制到static目录中。现在，您的应用程序的static目录中应该有四个目录：`css`、`fonts`、`images`和`js`，每个目录中都包含相关文件：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In order to point our base template at the local versions of these files, we
    will use the `url_for` helper to generate the correct URL. Open `base.html` and
    remove the old stylesheet and JavaScript tags, replacing them with the local version:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的基本模板指向这些文件的本地版本，我们将使用`url_for`助手来生成正确的URL。打开`base.html`，删除旧的样式表和JavaScript标签，并用本地版本替换它们：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you like, you can create a `site.css` file in the `static/css` directory
    and replace the `<style>` tag with a link to `site.css`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，可以在`static/css`目录中创建一个`site.css`文件，并将`<style>`标签替换为指向`site.css`的链接。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added a variety of new ways to interact with the site. It
    is now possible to create and modify content directly through the site. We discussed
    how to create object-oriented forms with WTForms, including processing and validating
    the form data from the view, as well as writing that form data to the database.
    We also created templates to display forms and validation errors and used Jinja2
    macros to remove repetitive code to make the code more modular. We were then able
    to display single-use flash messages to the user when they perform an action.
    Finally we also explained how to handle file uploads using WTForms and Flask,
    and to serve static assets, such as JavaScript, stylesheets, and image uploads.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们添加了各种与网站交互的新方法。现在可以直接通过网站创建和修改内容。我们讨论了如何使用WTForms创建面向对象的表单，包括从视图处理和验证表单数据，以及将表单数据写入数据库。我们还创建了模板来显示表单和验证错误，并使用Jinja2宏来删除重复的代码，使代码更加模块化。然后，我们能够向用户显示单次使用的闪存消息，当他们执行操作时。最后，我们还解释了如何使用WTForms和Flask处理文件上传，并提供静态资产，如JavaScript、样式表和图像上传。
- en: 'Before jumping into the next chapter, take some time to experiment with the
    new features we added to the site. Here are some ideas for ways you can improve
    on what we''ve built in this chapter:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在跳转到下一章之前，花一些时间尝试一下我们在网站中添加的新功能。以下是一些可以改进本章内容的方法：
- en: Add a header link to the image upload form.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页眉中添加一个链接到图像上传表单。
- en: In the image upload view, validate that the file's extension is a recognized
    image extension (.png, .jpg, .gif).
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像上传视图中，验证文件的扩展名是否是已识别的图像扩展名（.png、.jpg、.gif）。
- en: Add a read-only StringField to display the Entry's slug.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个只读的StringField来显示条目的slug。
- en: 'Our tag index view will show tags that have zero entries associated with them
    (which might be the case if we added a tag, then removed it from an entry). Improve
    the query to only list tags with one or more associated entries. Hint: `Tag.query.join(entry_tags).distinct()`.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的标签索引视图将显示与零个条目关联的标签（如果我们添加了一个标签，然后从条目中删除它，这可能是这种情况）。改进查询，只列出具有一个或多个关联条目的标签。提示：`Tag.query.join(entry_tags).distinct()`。
- en: 'Display the number of entries associated with a tag in the tag index. Advanced:
    do it in a single query.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标签索引中显示与标签关联的条目数量。高级：在单个查询中完成。
- en: 'Advanced: Create an Image model and views for creating, editing, and deleting
    images.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级：创建一个图像模型和用于创建、编辑和删除图像的视图。
- en: In the next chapter, we will add authentication to our site so that only trusted
    users can create and modify content. We will build a model to represent blog authors,
    add log-in/log-out forms, and prevent unauthenticated users from accessing certain
    areas of the site.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为我们的网站添加身份验证，以便只有受信任的用户才能创建和修改内容。我们将构建一个模型来代表博客作者，添加登录/注销表单，并防止未经身份验证的用户访问网站的某些区域。
