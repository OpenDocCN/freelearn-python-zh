- en: 14\. Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14. 测试
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to the concept of testing Django web applications.
    You will learn about the importance of testing in software development and, more
    importantly, in building web applications. You will write unit tests for your
    Django application's components, such as **views**, **models**, and **endpoints**.
    Completing this chapter will equip you with the skills to write test cases for
    Django web applications. That way, you can ensure that your application code works
    the way you expect.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了测试Django Web应用程序的概念。您将了解测试在软件开发中的重要性，尤其是在构建Web应用程序方面。您将为Django应用程序的组件编写单元测试，例如**视图**、**模型**和**端点**。完成本章后，您将具备为Django
    Web应用程序编写测试用例的技能。这样，您可以确保您的应用程序代码按预期工作。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the preceding chapters, we have focused upon building our web application
    in Django by writing different components such as database models, views, and
    templates. We did all that to provide our users with an interactive application
    where they can create a profile and write reviews for the books they have read.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们通过编写不同的组件，如数据库模型、视图和模板，来专注于构建我们的Django Web应用程序。我们这样做是为了提供一个交互式应用程序，让用户可以创建个人资料并为他们读过的书籍撰写评论。
- en: Apart from building and running the application, there is another important
    aspect of making sure that the application code works the way we expect it to
    work. This is ensured by a technique called **testing**. In testing, we run the
    different parts of the web application and check whether the output of the executed
    component matches the output we expected. If the output matches, we can say that
    the component was tested successfully, and if the output does not match, we say
    that the component failed to work as intended.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构建和运行应用程序之外，确保应用程序代码按预期工作还有一个重要的方面。这是通过一种称为**测试**的技术来保证的。在测试中，我们运行Web应用程序的不同部分，并检查执行组件的输出是否与预期的输出匹配。如果输出匹配，我们可以说该组件已成功测试，如果输出不匹配，我们则说该组件未能按预期工作。
- en: In this chapter, as we go through the different sections, we will learn why
    testing is important, what the different ways to test a web application are, and
    how we can build a strong testing strategy that will help us ensure that the web
    application we build is robust. Let us start our journey by learning about the
    importance of testing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，随着我们浏览不同的部分，我们将了解测试的重要性，了解测试Web应用程序的不同方法，以及我们如何构建一个强大的测试策略，以确保我们构建的Web应用程序是健壮的。让我们从了解测试的重要性开始我们的旅程。
- en: The Importance of Testing
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试的重要性
- en: Making sure that an application works the way it was designed to work is an
    important aspect of development efforts because, otherwise, our users might keep
    on encountering weird behaviors that will usually drive them away from engaging
    with the application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 确保应用程序按预期设计的方式工作是开发工作的重要方面，否则，我们的用户可能会不断遇到奇怪的行为，这通常会驱使他们远离与应用程序的互动。
- en: The efforts we put into testing help us ensure that the different kinds of problems
    that we intend to solve are indeed being solved correctly. Imagine a case where
    a developer is building an online event scheduling platform. On this platform,
    users can schedule events on their calendars as per their local time zone. Now,
    what if, on this platform, users can schedule events as expected, but due to a
    bug, the events are scheduled in an incorrect time zone? It is such issues that
    tend to drive many users away.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在测试上投入的努力帮助我们确保我们打算解决的问题确实被正确解决。想象一下，一个开发者正在构建一个在线活动调度平台。在这个平台上，用户可以根据他们的本地时区在日历上安排活动。现在，如果在这个平台上，用户可以按预期安排活动，但由于一个错误，活动被安排在了错误的时间区域？这类问题往往会驱使许多用户离开。
- en: That is why a lot of companies spend a huge amount of money making sure that
    the applications they are building have undergone thorough testing. That way,
    they ensure that they do not release a buggy product or a product that is far
    away from satisfying user requirements.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，许多公司花费大量资金确保他们构建的应用程序已经经过彻底的测试。这样，他们可以确保不会发布有缺陷的产品或远未满足用户需求的产品。
- en: 'In brief, testing helps us achieve the following goals:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，测试帮助我们实现以下目标：
- en: Ensuring that the components of the application work according to specifications
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保应用程序的组件按规范工作
- en: 'Ensuring interoperability with different infrastructure platforms: if an application
    can be deployed on a different operating system, such as Linux, Windows, and so
    on'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保与不同基础设施平台的互操作性：如果一个应用程序可以部署在不同的操作系统上，例如Linux、Windows等
- en: Reducing the probability of introducing a bug while refactoring the application code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在重构应用程序代码时降低引入错误的可能性
- en: Now, a common assumption many people make about testing is that they have to
    test all the components manually as they are developed to make sure each component
    works according to its specifications, and repeat this exercise every time a change
    is made, or a new component is added to the application. While this is true, this
    does not provide a complete picture of testing. Testing as a technique has grown
    to be very powerful with time, and as a developer, you can reduce a huge amount
    of testing effort by implementing **automated test cases**. So, what are these
    automated test cases? Or, in other words, what is **automation testing**? Let
    us find out.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，许多人关于测试的常见假设是他们必须手动测试所有组件，以确保每个组件按照其规范工作，每次更改或向应用程序添加新组件时都重复此操作。虽然这是真的，但这并不提供完整的测试图景。随着时间的推移，测试作为一种技术已经变得非常强大，作为开发者，你可以通过实现**自动化测试用例**来减少大量的测试工作。那么，这些自动化测试用例是什么？或者说，什么是**自动化测试**？让我们来了解一下。
- en: Automation Testing
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试
- en: Testing a whole application repeatedly when a single component is modified can
    turn out to be a challenging task, and even more so if that application consists
    of a large codebase. The size of the codebase could be due to the sheer number
    of features or the complexity of the problem it solves.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当单个组件被修改时，重复测试整个应用程序可能是一项具有挑战性的任务，尤其是如果该应用程序包含大量的代码库。代码库的大小可能是由于功能数量庞大或解决的问题的复杂性。
- en: As we develop applications, it is important to make sure that the changes being
    made to these applications can be tested easily, so that we can verify whether
    there is something that is breaking. That is where the concept of automation testing
    comes in handy. The focus of automation testing is to write tests as code, such
    that the individual components of an application can be tested in isolation as
    well as in terms of their interaction with each other.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开发应用程序，确保对这些应用程序所做的更改可以轻松测试非常重要，这样我们就可以验证是否有破坏性的东西。这就是自动化测试概念派上用场的地方。自动化测试的重点是将测试编写为代码，这样应用程序的各个组件就可以在隔离状态下以及它们相互交互的情况下进行测试。
- en: With this aspect, it now becomes important for us to define the different kinds
    of automation tests that can be done for applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，现在对我们来说，定义可以为应用程序执行的不同类型的自动化测试变得很重要。
- en: 'Automation testing can be broadly categorized into five different types:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试可以大致分为五种不同类型：
- en: '**Unit Testing**: In this type of testing, the individual isolated units of
    code are tested. For example, a unit test can target a single method or a single
    isolated API. This kind of testing is performed to make sure the basic units of
    the application work according to their specification.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：在这种测试类型中，代码的各个独立单元被单独测试。例如，单元测试可以针对单个方法或单个独立的API。这种测试的目的是确保应用程序的基本单元按照其规范工作。'
- en: '**Integration Testing**: In this type of testing, the individual isolated units
    of code are merged to form a logical grouping. Once this grouping is formed, testing
    is performed on this logical group to make sure that the group works in the way
    it is expected to.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：在这种测试类型中，代码的各个独立单元被合并成一个逻辑分组。一旦形成这种分组，就会对这个逻辑组进行测试，以确保该组按预期的方式工作。'
- en: '**Functional Testing**: In this kind of testing, the overall functionality
    of the different components of the application is tested. This may include different
    APIs, user interfaces, and so on.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试**：在这种测试中，测试应用程序不同组件的整体功能。这可能包括不同的API、用户界面等。'
- en: '**Smoke Testing**: In this kind of testing, the stability of the deployed application
    is tested to make sure that the application continues to remain functional as
    users interact with it, without causing a crash.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冒烟测试**：在这种测试中，测试已部署应用程序的稳定性，以确保应用程序在用户与其交互时继续保持功能，而不会导致崩溃。'
- en: '**Regression Testing**: This kind of testing is done to make sure that the
    changes being made to the application do not degrade the previously built functionality
    of the application.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归测试**：这种测试是为了确保对应用程序所做的更改不会降低应用程序先前构建的功能。'
- en: As we can see, testing is a big domain that takes time to master, and entire
    books have been written on this topic. To make sure we highlight the important
    aspects of testing, we are going to focus on the aspect of unit testing in this
    chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，测试是一个庞大的领域，需要时间来掌握，关于这个主题已经写出了整本书。为了确保我们突出测试的重要方面，我们将在本章中专注于单元测试的方面。
- en: Testing in Django
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django中的测试
- en: Django is a feature-packed framework that aims to make web application development
    rapid. It provides a full-featured way of testing an application. It also provides
    a well-integrated module that allows application developers to write unit tests
    for their applications. This module is based on the Python `unittest` library
    that ships with most Python distributions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Django是一个功能丰富的框架，旨在使Web应用程序开发快速。它提供了一种全面的方式来测试应用程序。它还提供了一个良好集成的模块，允许应用程序开发者为其应用程序编写单元测试。此模块基于大多数Python发行版附带的Python
    `unittest`库。
- en: Let us get started with understanding how we can write basic test cases in Django
    and how to leverage the framework-provided modules to test our application code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始了解如何在Django中编写基本的测试用例，以及如何利用框架提供的模块来测试我们的应用程序代码。
- en: Implementing Test Cases
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现测试用例
- en: When working on implementing mechanisms for testing your code, the first thing
    that needs to be understood is how this implementation can be logically grouped,
    such that modules that are closely related to each other are tested in one logical
    unit.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在实现测试代码的机制时，首先需要理解的是如何逻辑地分组这种实现，以便相互紧密相关的模块可以在一个逻辑单元中进行测试。
- en: This is simplified by implementing a **test case**. A test case is nothing more
    than a logical unit that groups together tests that are related to logically similar
    units, such that all the common logic to initialize the environment for the test
    cases can be combined in the same place, hence avoiding duplication of work while
    implementing application testing code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过实现一个**测试用例**来简化。测试用例不过是一个逻辑单元，它将逻辑上相似的测试组合在一起，这样所有用于初始化测试用例环境的公共逻辑都可以组合在同一个地方，从而在实现应用程序测试代码时避免重复工作。
- en: Unit Testing in Django
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django中的单元测试
- en: 'Now, with our basic understanding of the tests clear, let us look at how we
    can do unit testing inside Django. In the context of Django, a unit test consists
    of two major parts:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着我们对测试的基本理解已经清楚，让我们看看我们如何在Django中进行单元测试。在Django的上下文中，一个单元测试由两个主要部分组成：
- en: A `TestCase` class, which wraps the different test cases that are grouped for
    a given module
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`TestCase`类，它封装了为给定模块分组的不同测试用例
- en: An actual test case, which needs to be executed to test the flow of a particular component
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要执行以测试特定组件流程的实际测试用例
- en: The class implementing a unit test should inherit from the `TestCase` class
    provided by Django's `test` module. By default, Django provides a `tests.py` file
    in every application directory, which can be used to store the test cases for
    the application module.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 实现单元测试的类应该继承自Django的`test`模块提供的`TestCase`类。默认情况下，Django在应用程序目录中提供了一个`tests.py`文件，可以用来存储应用程序模块的测试用例。
- en: 'Once these unit tests are written, they can also be executed easily by running
    them directly using the provided `test` command in `manage.py` as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编写了这些单元测试，它们也可以通过直接运行`manage.py`中提供的`test`命令来轻松执行，如下所示：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Utilizing Assertions
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用断言
- en: An important part of writing tests is validating whether the test passed or
    failed. Generally, to implement such decisions inside a testing environment, we
    utilize something known as **assertions**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试的一个重要部分是验证测试是否通过或失败。通常，为了在测试环境中实现这样的决策，我们使用一种称为**断言**的东西。
- en: Assertions are a common concept in software testing. They take in two operands
    and validate whether the value of the operand on the **left-hand side (LHS)**
    matches the value of the operand on the **right-hand side (RHS)**. If the value
    on the LHS matches the value on the RHS, an assertion is considered to be successful,
    whereas if the values differ, the assertion is considered to have failed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是软件测试中的一个常见概念。它们接受两个操作数，并验证左边的操作数（LHS）的值是否与右边的操作数（RHS）的值匹配。如果左边的值与右边的值匹配，则认为断言成功，而如果值不同，则认为断言失败。
- en: An assertion evaluating to `False` essentially causes a test case to be evaluated
    as a failure, which is then reported to the user.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个评估为`False`的断言实际上会导致测试用例被评估为失败，然后报告给用户。
- en: 'Assertions in Python are quite easy to implement and they use a simple keyword
    called `assert`. For example, the following code snippet shows a very simple assertion:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的断言实现相当简单，它们使用一个简单的关键字`assert`。例如，以下代码片段展示了一个非常简单的断言：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding assertion takes in a single expression, which evaluates to `True`.
    If this assertion were a part of a test case, the test would have succeeded.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的断言接受一个表达式，该表达式评估为`True`。如果这个断言是测试用例的一部分，那么测试就会成功。
- en: 'Now, let us see how we can implement test cases using the Python `unittest`
    library. Doing so is quite easy and can be accomplished in a few easy-to-follow
    steps:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用Python的`unittest`库实现测试用例。这样做相当简单，可以按照以下几个易于遵循的步骤完成：
- en: 'Import the `unittest` module, which allows us to build the test cases:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`unittest`模块，它允许我们构建测试用例：
- en: '[PRE2]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the module is imported, you can create a class whose name starts with
    `Test`, which inherits from the `TestCase` class provided by the `unittest` module:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦模块被导入，你可以创建一个以`Test`开头的新类，该类继承自`unittest`模块提供的`TestCase`类：
- en: '[PRE3]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Only if the `TestMyModule` class inherits the `TestCase` class will Django be
    able to run it automatically with full integration with the framework. Once the
    class is defined, we can implement a new method inside the class named `test_method_a()`,
    which validates an assertion.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只有当`TestMyModule`类继承自`TestCase`类时，Django才能自动运行它，并且与框架完全集成。一旦类被定义，我们就可以在类内部实现一个新的方法，命名为`test_method_a()`，该方法验证断言。
- en: Note
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: An important part to note here is the naming scheme for the test cases and test
    functions. The test cases being implemented should be prefixed with the name `test`,
    such that the test execution modules can detect them as valid test cases and execute
    them. The same rule applies to the naming of testing methods.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里需要注意的一个重要部分是测试用例和测试函数的命名方案。所实现的测试用例应该以`test`为前缀，这样测试执行模块可以检测它们作为有效的测试用例并执行它们。同样的规则也适用于测试方法的命名。
- en: 'Once the test case is written, it can be simply executed by running the following command:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦编写了测试用例，就可以简单地通过运行以下命令来执行它：
- en: '[PRE4]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, with our basic understanding of implementing test cases clarified, let
    us write a very simple unit test to see how the unit testing framework behaves
    inside Django.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，随着我们对实现测试用例的基本理解已经明确，让我们编写一个非常简单的单元测试来查看单元测试框架在Django中的行为。
- en: 'Exercise 14.01: Writing a Simple Unit Test'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.01：编写简单的单元测试
- en: In this exercise, you will write a simple unit test to understand how the Django
    unit testing framework works and use this knowledge to implement your first test
    case that validates a couple of simple expressions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将编写一个简单的单元测试来了解Django单元测试框架的工作方式，并使用这些知识来实现你的第一个测试用例，该测试用例验证几个简单的表达式。
- en: 'To get started, open the `tests.py` file under the `reviews` application of
    the `Bookr` project. By default, this file will contain only a single line that
    imports Django''s `TestCase` class from the `test` module. In case the file already
    has a couple of test cases, you can remove all the lines in the file except the
    one which imports the `TestCase` class as shown next:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，打开`Bookr`项目下`reviews`应用的`tests.py`文件。默认情况下，该文件将只包含一行，导入Django的`TestCase`类。如果文件已经包含几个测试用例，你可以删除文件中除导入`TestCase`类的行之外的所有行，如下所示：
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following lines of code in the `tests.py` file you just opened:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你刚刚打开的`tests.py`文件中添加以下代码行：
- en: '[PRE6]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, you created a new class named `TestSimpleComponent`, which inherits from
    the `TestCase` class provided by Django's `test` module. The `assert` statement
    will compare the expression on the left-hand side (`1 + 1`) with the one on the
    right (`2`).
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，你创建了一个名为 `TestSimpleComponent` 的新类，它继承自 Django 的 `test` 模块提供的 `TestCase`
    类。`assert` 语句将比较左侧的表达式（`1 + 1`）与右侧的表达式（`2`）。
- en: 'Once you have written the test case, navigate back to the project folder, and
    run the following command:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你编写了测试用例，导航回项目文件夹，并运行以下命令：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following output should be generated:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应该生成以下输出：
- en: '[PRE8]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding output signifies that Django's test runner executed one test case,
    which successfully passed the evaluation.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的输出表明 Django 的测试运行器执行了一个测试用例，该测试用例成功通过了评估。
- en: 'With the test case confirmed to be working and passing, now try to add another
    assertion at the end of the `test_basic_sum()` method, as shown in the following
    code snippet:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在确认测试用例正常工作并通过测试后，现在尝试在 `test_basic_sum()` 方法的末尾添加另一个断言，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the `assert` statement added to `tests.py`, now execute the test cases
    by running the following command from the project folder:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `tests.py` 文件中添加了 `assert` 语句后，现在可以从项目文件夹中运行以下命令来执行测试用例：
- en: '[PRE10]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At this point, you will notice Django reporting that the execution of the test
    cases has failed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你会注意到 Django 报告测试用例的执行失败了。
- en: With this, you now have an understanding of how test cases can be written in
    Django and how assertions can be used to validate whether the output generated
    from your method calls under test is correct or not.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你现在已经了解了如何在 Django 中编写测试用例以及如何使用断言来验证测试方法调用生成的输出是否正确。
- en: Types of Assertions
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言类型
- en: 'In *Exercise 14.01*, *Writing a Simple Unit Test*, we had a brief encounter
    with assertions when we came across the following `assert` statement:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *练习 14.01*，*编写简单的单元测试* 中，当我们遇到以下 `assert` 语句时，我们对断言有了一个简短的接触：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'These assertion statements are simple and use the Python `assert` keyword.
    There are a few different types of assertions possible that can be tested inside
    a unit test while using the `unittest` library. Let us look at those:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些断言语句很简单，使用了 Python 的 `assert` 关键字。在使用 `unittest` 库进行单元测试时，有几种不同的断言类型可以进行测试。让我们看看那些：
- en: '`assertIsNone`: This assertion is used to check whether an expression evaluates
    to `None` or not. For example, this type of assertion can be used in cases where
    a query to a database returns `None` because no records were found for the specified
    filtering criteria.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIsNone`：这个断言用于检查一个表达式是否评估为 `None`。例如，这种类型的断言可以在查询数据库返回 `None` 的情况下使用，因为没有找到指定过滤条件下的记录。'
- en: '`assertIsInstance`: This assertion is used to validate whether a provided object
    evaluates to an instance of the provided type. For example, we can validate whether
    the value returned by a method is indeed of a specific type, such as list, dict,
    tuple, and so on.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIsInstance`：这个断言用于验证提供的对象是否评估为提供的类型的实例。例如，我们可以验证方法返回的值是否确实为特定的类型，如列表、字典、元组等。'
- en: '`assertEquals`: This is a very basic function that takes in two arguments and
    checks whether the provided arguments to it are equal in value or not. This can
    be useful when you plan to compare the values of data structures that do not guarantee
    ordering.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEquals`：这是一个非常基础的函数，它接受两个参数并检查提供给它的参数是否在值上相等。这在你计划比较那些不保证排序的数据结构的值时可能很有用。'
- en: '`assertRaises`: This method is used to validate whether the name of the method
    provided to it when called raises a specified exception or not. This is helpful
    when we are writing test cases where a code path that raises an exception needs
    to be tested. As an example, this kind of assertion can be useful when we want
    to want to make sure an exception is raised by a method performing a database
    query (say, to let us know if the database connection is not yet established).'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertRaises`：这个方法用于验证当调用它时，提供给它的方法名称是否引发了指定的异常。这在编写测试用例时很有用，其中需要测试引发异常的代码路径。例如，这种断言在确保执行数据库查询的方法（例如，让我们知道数据库连接是否尚未建立）引发异常时可能很有用。'
- en: These were just a small set of useful assertions that we can make in our test
    cases. The `unittest` module on top of which Django's testing library is built
    provides a lot more assertions that can be tested for.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是我们可以在测试用例中做出的一小部分有用的断言。Django 测试库建立在 `unittest` 模块之上，它提供了更多可以进行测试的断言。
- en: Performing Pre-Test Setup and Cleanup after Every Test Case Run
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在每个测试用例运行后执行预测试设置和清理
- en: Sometimes while writing test cases, we may need to perform some repetitive tasks;
    for example, setting up some variables that will be required for the test. Once
    the test is over, we would want to clean up all the changes made to the test variables,
    such that any new test starts with a fresh instance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试用例时，有时我们可能需要执行一些重复性任务；例如，设置一些测试所需的变量。一旦测试完成，我们希望清理所有对测试变量的更改，以便任何新的测试都从一个全新的实例开始。
- en: Luckily, the `unittest` library provides a useful way through which we can automate
    our repetitive efforts of setting up the environment before every test case runs
    and cleaning it up after the test case is finished. This is achieved using the
    following two methods, which we can implement in `TestCase`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`unittest`库提供了一种有用的方法，通过它可以自动化我们在每个测试用例运行之前设置环境以及在测试用例完成后清理环境时的重复性工作。这是通过以下两个方法实现的，我们可以在`TestCase`中实现这些方法。
- en: '`setUp()`: This method is called before the execution of every `test` method
    inside the `TestCase` class. It implements the code required to set up the test
    case''s environment before the test executes. This method can be a good place
    to set up any local database instance or test variables that may be required for
    the test cases.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUp()`：此方法在`TestCase`类中每个`test`方法执行之前调用。它实现了在测试执行之前设置测试用例环境的代码。此方法可以是一个设置任何本地数据库实例或测试变量的好地方，这些变量可能对测试用例是必需的。'
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `setUp()` method is valid only for test cases written inside the `TestCase`
    class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUp()`方法仅适用于在`TestCase`类内部编写的测试用例。'
- en: 'For example, the following example illustrates a simple definition of how the
    `setUp()` method is used inside a `TestCase` class:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下示例说明了如何在`TestCase`类内部使用`setUp()`方法的一个简单定义：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding example, when we try to execute the test cases, the `setUp()`
    method we defined here will be called every time before a `test` method executes.
    In other words, the `setUp()` method will be called before the execution of the
    `test_method_a()` call and then it will be called again before `test_method_b()`
    is called.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，当我们尝试执行测试用例时，我们定义的`setUp()`方法将在每次`test`方法执行之前调用。换句话说，`setUp()`方法将在`test_method_a()`调用之前调用，然后它将在`test_method_b()`调用之前再次调用。
- en: '`tearDown()`: This method is called once the `test` function finishes execution
    and cleans up the variables and their values once the test case execution is finished.
    This method is executed no matter whether the test case evaluates to `True` or
    `False`. An example of using the `tearDown()` method is shown next:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`tearDown()`：此方法在`test`函数执行完毕后调用，并在测试用例执行完毕后清理变量及其值。无论测试用例评估结果为`True`还是`False`，都会执行此方法。下面将展示如何使用`tearDown()`方法的示例：'
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding example, the `tearDown()` method will be called every time
    a `test` method finishes execution, that is, once `test_method_a()` finishes execution
    and again once after `test_method_b()` finishes execution.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`tearDown()`方法将在每次`test`方法执行完毕时调用，即`test_method_a()`执行完毕后，再次在`test_method_b()`执行完毕后。
- en: Now, we are aware of the different components of writing test cases. Let us
    now look at how we can test the different aspects of a Django application using
    the provided test framework.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了编写测试用例的不同组件。让我们看看如何使用提供的测试框架来测试Django应用程序的不同方面。
- en: Testing Django Models
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Django模型
- en: Models in Django are object-based representations of how the data will be stored
    inside the database of an application. They provide methods that can help us validate
    the data input provided for a given record, as well as performing any processing
    on the data before it is inserted into the database.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Django中的模型是数据将在应用程序数据库中存储的对象表示。它们提供了可以帮助我们验证给定记录提供的数据输入的方法，以及在数据插入数据库之前对数据进行任何处理的方法。
- en: As easy as it is to create models in Django, it is equally easy to test them.
    Now, let us look at how Django models can be tested using the Django test framework.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在Django中创建模型一样容易，测试它们也同样简单。现在，让我们看看如何使用Django测试框架来测试Django模型。
- en: 'Exercise 14.02: Testing Django Models'
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.02：测试Django模型
- en: 'In this exercise, you will create a new Django model and write test cases for
    it. The test case will validate whether your model can correctly insert and retrieve
    the data from the database. These kinds of test cases that work on database models
    can turn out to be useful in cases where a team of developers is collaborating
    on a large project and the same database model may get modified by multiple developers
    over time. Implementing test cases for database models allows developers to pre-emptively
    identify potentially breaking changes that they may inadvertently introduce as
    a part of their work:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建一个新的 Django 模型，并为它编写测试用例。这个测试用例将验证您的模型是否能够正确地将数据插入和从数据库中检索。这类在数据库模型上运行的测试用例在团队开发大型项目时可能非常有用，因为同一个数据库模型可能会随着时间的推移被多个开发者修改。为数据库模型实现测试用例允许开发者预先识别他们可能在不经意间引入的潜在破坏性更改：
- en: Note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To ensure we get a good hang of running tests from scratch on newly created
    apps, we'll be creating a new application called `bookr_test`. This application's
    code is independent of the main `bookr` application and consequently, we won't
    be including this app's files in the `final/bookr` folder. Upon completion of
    this chapter, we recommend you practice what you learned by writing similar tests
    for various components of the main `bookr` application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们能够熟练地从零开始在新创建的应用程序上运行测试，我们将创建一个新的应用程序，名为 `bookr_test`。这个应用程序的代码与主 `bookr`
    应用程序独立，因此，我们不会将这个应用程序的文件包含在 `final/bookr` 文件夹中。完成本章内容后，我们建议您通过为 `bookr` 应用程序的各种组件编写类似的测试来练习您所学的知识。
- en: 'Create a new application, which you will use for the exercises in this chapter.
    To do this, run the following command, which will set up a new application for
    your use case:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的应用程序，您将使用它来完成本章的练习。为此，运行以下命令，这将为您的情况设置一个新的应用程序：
- en: '[PRE14]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To make sure the `bookr_test` application behaves the same way as any other
    application in the Django project, add this application to our `INSTALLED_APPS`
    section of the `bookr` project. To do this, open the `settings.py` file in your
    `bookr` project and append the following code to the `INSTALLED_APPS` list:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保 `bookr_test` 应用程序的行为与 Django 项目中的任何其他应用程序相同，将此应用程序添加到 `bookr` 项目的 `INSTALLED_APPS`
    部分中。为此，打开您的 `bookr` 项目的 `settings.py` 文件，并将以下代码追加到 `INSTALLED_APPS` 列表中：
- en: '[PRE15]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, with the application setup complete, create a new database model, which
    you will use for testing purposes. For this exercise, you are going to create
    a new model named `Publisher`, which will store the details about the book publisher
    in our database. To create the model, open the `models.py` file under the `bookr_test`
    directory and add the following code to it:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，随着应用程序设置的完成，创建一个新的数据库模型，您将使用它来进行测试。对于这个练习，您将创建一个名为 `Publisher` 的新模型，该模型将存储有关书籍出版商的详细信息。要创建模型，打开
    `bookr_test` 目录下的 `models.py` 文件，并将以下代码添加到其中：
- en: '[PRE16]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code snippet, you have created a new class named `Publisher`,
    which inherits from the `Model` class of Django''s `models` module, defining the
    class as a Django model, which will be used to store data about the publisher:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，您创建了一个名为 `Publisher` 的新类，该类继承自 Django 的 `models` 模块中的 `Model` 类，将类定义为
    Django 模型，该模型将用于存储有关出版商的数据：
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Inside this model, you have added three fields, which will act as the properties
    of the model:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个模型内部，您添加了三个字段，这些字段将作为模型的属性：
- en: '`name`: The name of the publisher'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`name`: 出版商的名称'
- en: '`website`: The website belonging to the publisher'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`website`: 出版商的网站'
- en: '`email`: The email address of the publisher'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`email`: 出版商的电子邮件地址'
- en: Once this is done, you create a class method, `__str__()`, which defines how
    the string representation of the model will look.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成此操作后，您创建了一个类方法 `__str__()`，它定义了模型字符串表示的形式。
- en: 'Now, with the model created, you first need to migrate this model before you
    can run a test on it. To do this, run the following commands:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，模型已经创建，您首先需要迁移此模型，然后才能在它上面运行测试。为此，运行以下命令：
- en: '[PRE18]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the model now set up, write the test case with which you are going to
    test the model created in *step 3*. For this, open the `tests.py` file under the
    `bookr_test` directory and add the following code to it:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在模型已经设置好了，编写测试用例来测试在 *步骤 3* 中创建的模型。为此，打开 `bookr_test` 目录下的 `tests.py` 文件，并将以下代码添加到其中：
- en: '[PRE19]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code snippet, there are a couple of things worth exploring.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，有几个值得探讨的地方。
- en: At the start, after importing the `TestCase` class from the Django `test` module,
    you imported the `Publisher` model from the `bookr_test` directory, which is going
    to be used for testing.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在开始时，在从Django的`test`模块导入`TestCase`类之后，你从`bookr_test`目录导入了`Publisher`模型，该模型将被用于测试。
- en: 'Once the required libraries were imported, you created a new class named `TestPublisherModel`,
    which inherits the `TestCase` class and is used for grouping the unit tests related
    to the `Publisher` model:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在导入所需的库之后，你创建了一个名为`TestPublisherModel`的新类，它继承自`TestCase`类，并用于组织与`Publisher`模型相关的单元测试：
- en: '[PRE20]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Inside this class, you defined a couple of methods. First, you defined a new
    method named `setUp()` and added the `Model` object creation code inside it such
    that the `Model` object is created every time a new `test` method is executed
    inside this test case. This `Model` object is stored as a class member, such that
    it can be accessed inside other methods without a problem:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个类中，你定义了一些方法。首先，你定义了一个名为`setUp()`的新方法，并在其中添加了`Model`对象创建的代码，这样每次在这个测试用例中执行新的`test`方法时，都会创建一个`Model`对象。这个`Model`对象被存储为类成员，这样就可以在其他方法中无问题地访问它：
- en: '[PRE21]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The first test case validates whether the `Model` object for the `Publisher`
    model was created successfully or not. To do this, you created a new method named
    `test_create_publisher()`, inside which you check whether the created Model object
    points to an object of the `Publisher` type. If this `Model` object was not created
    successfully, your test will fail:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个测试用例验证`Publisher`模型的`Model`对象是否创建成功。为此，你创建了一个名为`test_create_publisher()`的新方法，在其中检查创建的模型对象是否指向`Publisher`类型的对象。如果这个`Model`对象没有成功创建，你的测试将失败：
- en: '[PRE22]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you check carefully, you are using the `assertIsInstance()` method of the
    `unittest` library here to assert whether the `Model` object belongs to the `Publisher`
    type or not.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你仔细检查，你在这里使用的是`unittest`库的`assertIsInstance()`方法来断言`Model`对象是否属于`Publisher`类型。
- en: 'The next test validates whether the string representation of the model is the
    same as what you expected it to be. From the code definition, the string representation
    of the `Publisher` model should output the name of the publisher. To test this,
    you create a new method named `test_str_representation()` and check whether the
    generated string representation of the model matches the one you are expecting:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一个测试验证模型的字符串表示是否与预期相同。从代码定义来看，`Publisher`模型的字符串表示应该输出出版者的名称。为了测试这一点，你创建了一个名为`test_str_representation()`的新方法，并检查生成的模型字符串表示是否与预期匹配：
- en: '[PRE23]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To perform this validation, you use the `assertEquals` method of the `unittest`
    library, which validates whether the two values provided to it are equal or not.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了执行这个验证，你使用`unittest`库的`assertEquals`方法，该方法验证提供的两个值是否相等。
- en: 'With the test cases now in place, you can run them to check what happens. To
    run these test cases, run the following command:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在测试用例已经就绪，你可以运行它们来检查会发生什么。要运行这些测试用例，请运行以下命令：
- en: '[PRE24]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once the command finishes execution, you will see an output that resembles
    the one shown here (your output may differ slightly, though):'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦命令执行完成，你将看到类似于以下输出的输出（你的输出可能略有不同）：
- en: '[PRE25]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see from the preceding output, the test cases are executed successfully,
    hence validating that the operations such as the creation of a new `Publisher`
    object and its string representation when fetched are being done correctly.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前所述的输出所示，测试用例执行成功，从而验证了诸如创建新的`Publisher`对象及其在检索时的字符串表示等操作是否正确执行。
- en: With this exercise, we got to see how we can write test cases for our Django
    models easily and validate their functioning, involving the creation of objects,
    their retrieval, and representation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习，我们看到了如何轻松编写Django模型的测试用例并验证其功能，包括对象的创建、检索和表示。
- en: 'Also, there is an important line to notice in the output from this exercise:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在这个练习的输出中还有一行重要的内容需要注意：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This happens because when there are test cases that require the data to be persisted
    inside a database, instead of using the production database, Django creates a
    new empty database for the test cases, which it uses to persist the value for
    the test case.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当存在需要将数据持久化存储在数据库中的测试用例时，Django不会使用生产数据库，而是为测试用例创建一个新的空数据库，它使用这个数据库来持久化测试用例的值。
- en: Testing Django Views
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Django视图
- en: Views in Django control the rendering of the HTTP response for users based on
    the URL they visit in a web application. In this section, we will get on to understand
    how we can test views inside Django. Imagine you are working on a website where
    a lot of **Application Programming Interface** (**API**) endpoints are required.
    An interesting question to ask would be, how will you be able to validate every
    new endpoint? If done manually, you will have to first deploy the application
    every time a new endpoint is added, then manually visit the endpoint in the browser
    to validate whether it is working fine or not. Such an approach may work out when
    the number of endpoints is low but may become extremely cumbersome if there are
    hundreds of endpoints.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Django中的视图控制用户基于在Web应用程序中访问的URL渲染HTTP响应。在本节中，我们将了解如何测试Django中的视图。想象一下，您正在开发一个需要大量**应用程序编程接口**（**API**）端点的网站。一个有趣的问题可能是，您将如何验证每个新的端点？如果手动完成，每次添加新端点时，您都必须首先部署应用程序，然后在浏览器中手动访问端点以验证其是否正常工作。当端点数量较少时，这种方法可能可行，但如果端点有数百个，这种方法可能会变得极其繁琐。
- en: 'Django provides a very comprehensive way of testing application views. This
    happens with the use of a testing client class provided by Django''s `test` module.
    This class can be used to visit URLs mapped to the views and capture the output
    generated by visiting the URL endpoint. Then we can use the captured output to
    test whether the URLs are generating a correct response or not. This client can
    be used by importing the `Client` class from the Django `test` module and then
    initializing it as shown in the following snippet:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了一种非常全面的测试应用程序视图的方法。这是通过使用Django的`test`模块提供的测试客户端类来实现的。这个类可以用来访问映射到视图的URL，并捕获访问URL端点时生成的输出。然后我们可以使用捕获的输出来测试URL是否生成了正确的响应。此客户端可以通过从Django的`test`模块导入`Client`类，然后按照以下代码片段初始化它来使用：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The client object supports several methods that can be used to simulate the
    different HTTP calls a user can make, namely, `GET`, `POST`, `PUT`, `DELETE`,
    and so on. An example of making such a request will look like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端对象支持多种方法，这些方法可以用来模拟用户可以发起的不同HTTP调用，例如，`GET`、`POST`、`PUT`、`DELETE`等。发起此类请求的示例将如下所示：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The response generated by the view is then captured by the client and gets exposed
    as a `response` object, which can then be queried to validate the output of the
    view.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 视图生成的响应随后被客户端捕获，并作为`response`对象暴露出来，然后可以查询以验证视图的输出。
- en: With this knowledge, now let us look at how we can write test cases for our
    Django views.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，现在让我们看看我们如何为我们的Django视图编写测试用例。
- en: 'Exercise 14.03: Writing Unit Tests for Django Views'
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.03：为Django视图编写单元测试
- en: 'In this exercise, you will use the Django test client to write a test case
    for your Django view, which will be mapped to a specific URL. These test cases
    will help you validate whether your view function generates the correct response
    when visited using its mapped URL:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用Django测试客户端编写针对您的Django视图的测试用例，该视图将被映射到特定的URL。这些测试用例将帮助您验证当使用其映射的URL访问视图函数时，是否生成了正确的响应：
- en: 'For this exercise, you are going to use the `bookr_test` application that was
    created in *step 1* of *Exercise 14.02*, *Testing Django Models*. To get started,
    open the `views.py` file under the bookr_test directory and add the following
    code to it:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个练习，您将使用在*练习14.02*的*步骤1*中创建的`bookr_test`应用程序，即*测试Django模型*。要开始，打开bookr_test目录下的`views.py`文件，并将以下代码添加到其中：
- en: '[PRE29]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, you have created a simple Django view, which will be used to greet the
    user with a welcome message whenever they visit an endpoint mapped to the provided
    view.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，您创建了一个简单的Django视图，该视图将在用户访问映射到提供的视图的端点时，用欢迎消息问候用户。
- en: 'Once this view is created, you need to map it to a URL endpoint, which can
    then be visited in a browser or a test client. To do this, open the `urls.py`
    file under the `bookr_test` directory and add the highlighted code to the `urlpatterns` list:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了此视图，您需要将其映射到URL端点，然后可以在浏览器或测试客户端中访问它。为此，打开`bookr_test`目录下的`urls.py`文件，并将高亮代码添加到`urlpatterns`列表中：
- en: '[PRE30]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once this path is set up, you need to make sure that it is also identified
    by your project. To do this, you need to add this entry to the `bookr` project''s
    URL mapping. To achieve that, open the `urls.py` file in the `bookr` directory
    and append the following highlighted line to the end of the `urlpatterns` list,
    as shown next:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦设置了此路径，你需要确保它也被你的项目识别。为此，你需要将此条目添加到`bookr`项目的URL映射中。为了实现这一点，打开`bookr`目录下的`urls.py`文件，并将以下突出显示的行追加到`urlpatterns`列表的末尾，如下所示：
- en: '[PRE31]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once the view is set up, validate whether it works correctly. Do this by running
    the following command:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦设置好视图，请验证其是否正确工作。通过运行以下命令来完成此操作：
- en: '[PRE32]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then visit `http://localhost:8080/test/greeting` in your web browser. Once
    the page opens, you should see the following text, which you added to the greeting
    view in *step 1*, being displayed in the browser:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后在你的网络浏览器中访问`http://localhost:8080/test/greeting`。一旦页面打开，你应该看到以下文本，这是你在*步骤1*中添加到问候视图中的，并在浏览器中显示：
- en: '[PRE33]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, you are ready to write the test cases for `greeting_view`. In this exercise,
    you are going to write a test case that checks whether, on visiting the `/test/greeting`
    endpoint, you get a successful result or not. To implement this test case, open
    the `tests.py` file under the `bookr_test` directory and add the following code
    at the end of the file:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你准备好为`greeting_view`编写测试用例。在这个练习中，你将编写一个测试用例，检查在访问`/test/greeting`端点时，你是否得到一个成功的结果。为了实现这个测试用例，打开`bookr_test`目录下的`tests.py`文件，并在文件末尾添加以下代码：
- en: '[PRE34]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code snippet, you have defined a test case that helps in validating
    whether the greeting view is working fine or not.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你定义了一个测试用例，有助于验证问候视图是否正常工作。
- en: 'This is done by first importing Django''s test client, which allows testing
    views mapped to the URLs by making calls to them and analyzing the generated response:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是通过首先导入Django的测试客户端来完成的，它允许通过对其调用并分析生成的响应来测试映射到URL的视图：
- en: '[PRE35]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once the import is done, you now create a new class named `TestGreetingView`,
    which will group the test cases related to the greeting view that you created
    in *step 2*:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成导入后，你现在创建一个名为`TestGreetingView`的新类，该类将分组与你在*步骤2*中创建的问候视图相关的测试用例：
- en: '[PRE36]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Inside this test case, you defined two methods, `setUp()` and `test_greeting_view()`.
    The `test_greeting_view()` method implements your test case. Inside this, you
    first make an HTTP `GET` call to the URL that is mapped to the greeting view and
    then store the response generated by the view inside the `response` object created:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此测试用例中，你定义了两个方法，`setUp()`和`test_greeting_view()`。`test_greeting_view()`方法实现了你的测试用例。在这个方法中，你首先对映射到问候视图的URL进行HTTP
    `GET`调用，然后将视图生成的响应存储在创建的`response`对象中：
- en: '[PRE37]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once this call finishes, you will have its HTTP response code, contents, and
    headers available inside the `response` variable. Next, with the following code,
    you make an assertion validating whether the status code generated by the call
    matches the status code for successful HTTP calls (`HTTP 200`):'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦这个调用完成，你将在`response`变量内部获得其HTTP响应代码、内容和头信息。接下来，使用以下代码，你将进行断言以验证调用生成的状态码是否与成功HTTP调用（`HTTP
    200`）的状态码匹配：
- en: '[PRE38]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With this, you are now ready to run the tests.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这种方式，你现在可以运行测试了。
- en: 'With the test case written, let''s look at what happens when you run the test
    case:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写测试用例后，让我们看看运行测试用例时会发生什么：
- en: '[PRE39]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once the command executes, you can expect to see an output like the one shown
    in the following snippet:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦命令执行，你可以预期看到以下片段所示的输出：
- en: '[PRE40]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see from the output, your test cases executed successfully, hence
    validating that the response generated by the `greeting_view()` method is as per
    your expectations.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如输出所示，你的测试用例执行成功，从而验证了`greeting_view()`方法生成的响应符合你的预期。
- en: In this exercise, you learned how you can implement a test case for a Django
    view function and use `TestClient` provided by Django to assert that the output
    generated by the view function matches the one that the developer should see.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你学习了如何为Django视图函数实现测试用例，并使用Django提供的`TestClient`断言视图函数生成的输出与开发者应看到的输出相匹配。
- en: Testing Views with Authentication
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用身份验证测试视图
- en: In the previous example, we looked at how we can test views inside Django. An
    important part to be highlighted about this view is that the view we created could
    be accessed by anyone and is not protected by any authentication or login checks.
    Now imagine a case where a view should only be accessible if the user is logged
    in. For example, imagine implementing a view function that renders the profile
    page of a registered user of our web application. To make sure that only logged-in
    users can view the profile page for their account, you might want to restrict
    the view to logged-in users only.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们探讨了如何在 Django 中测试视图。关于这个视图的一个重要方面是，我们创建的视图可以被任何人访问，并且没有任何身份验证或登录检查来保护。现在想象一个场景，其中视图只有在用户登录时才可访问。例如，想象实现一个视图函数，用于渲染我们网络应用的注册用户的个人资料页面。为了确保只有登录用户可以查看其账户的个人资料页面，您可能希望将视图限制为仅对登录用户开放。
- en: 'With this, we now have an important question: *How can we test views that require authentication?*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们现在有一个重要的问题：*我们如何测试需要认证的视图？*
- en: 'Luckily, Django''s test client provides this functionality through which we
    can log in to our views and then run tests on them. This result can be achieved
    by using Django''s test client `login()` method. When this method is called, Django''s
    test client performs an authentication operation against the service and if the
    authentication succeeds, it stores the login cookie internally, which it can then
    use for further test runs. The following code snippet shows how you can set up
    Django''s test client to simulate a logged-in user:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Django 的测试客户端提供了这项功能，我们可以通过它登录到我们的视图并对其运行测试。这可以通过使用 Django 的测试客户端 `login()`
    方法来实现。当此方法被调用时，Django 的测试客户端会对服务执行身份验证操作，如果身份验证成功，它将在内部存储登录cookie，然后可以使用它进行进一步的测试运行。以下代码片段显示了如何设置
    Django 的测试客户端来模拟已登录用户：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `login` method requires a username and password for the test user that we
    are going to test with, as will be shown in the next exercise. So, let us look
    at how we can test a flow that requires user authentication.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`login` 方法需要测试用户的用户名和密码，正如将在下一个练习中展示的那样。因此，让我们看看如何测试需要用户身份验证的流程。'
- en: 'Exercise 14.04: Writing Test Cases to Validate Authenticated Users'
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.04：编写测试用例以验证已认证用户
- en: 'In this exercise, you will write test cases for views that require the user
    to be authenticated. As part of this, you will validate the output generated by
    the view method when a user who is not logged in tries to visit the page and when
    a user who is logged in tries to visit the page mapped to the view function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将编写测试用例来测试需要用户进行身份验证的视图。作为这部分，您将验证当未登录用户尝试访问页面以及当登录用户尝试访问映射到视图函数的页面时，视图方法生成的输出。
- en: 'For this exercise, you are going to use the `bookr_test` application that you
    created in *step 1* of *Exercise 14.02*, *Testing Django Models*. To get started,
    open the `views.py` file under the bookr_test application and add the following
    code to it:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个练习，您将使用在 *练习 14.02* 的 *步骤 1* 中创建的 `bookr_test` 应用程序。要开始，打开 `bookr_test`
    应用程序下的 `views.py` 文件，并向其中添加以下代码：
- en: '[PRE42]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once the preceding code snippet is added, create a new function, `greeting_view_user()`,
    at the end of the file, as shown in the following code snippet:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦添加了前面的代码片段，请在文件的末尾创建一个新的函数 `greeting_view_user()`，如下面的代码片段所示：
- en: '[PRE43]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With this, you have created a simple Django view that will be used to greet
    the logged-in user with a welcome message whenever they visit an endpoint mapped
    to the provided view.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这种方式，您已经创建了一个简单的 Django 视图，该视图将在用户访问映射到提供的视图的端点时，用欢迎信息问候登录用户。
- en: 'Once this view is created, you need to map this view to a URL endpoint that
    can then be visited in a browser or a test client. To do this, open the `urls.py`
    file under the `bookr_test` directory and add the following highlighted code to
    it:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了此视图，您需要将其映射到可以在浏览器或测试客户端中访问的 URL 端点。为此，打开 `bookr_test` 目录下的 `urls.py` 文件，并向其中添加以下突出显示的代码：
- en: '[PRE44]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once the view is set up, the next thing you need to do is to validate whether
    it works correctly. To do this, run the following command:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦设置了视图，接下来您需要做的就是验证它是否正确工作。为此，运行以下命令：
- en: '[PRE45]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Then visit `http://localhost:8080/test/greet_user` in your web browser.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后在您的网页浏览器中访问 `http://localhost:8080/test/greet_user`。
- en: If you are not logged in already, by visiting the preceding URL, you will be
    redirected to the login page for the project.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您尚未登录，通过访问前面的 URL，您将被重定向到项目的登录页面。
- en: 'Now, write the test cases for `greeting_view_user`, which checks whether, on
    visiting the `/test/greet_user` endpoint, you get a successful result. To implement
    this test case, open the `tests.py` file under the `bookr_test` directory and
    add the following code to it:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为`greeting_view_user`编写测试用例，该测试用例检查在访问`/test/greet_user`端点时是否得到成功的结果。为了实现此测试用例，打开`bookr_test`目录下的`tests.py`文件，并向其中添加以下代码：
- en: '[PRE46]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding code snippet, you have implemented a test case that checks
    the views that have authentication enabled before their content can be seen.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，您实现了一个测试用例，该用例检查在内容可见之前是否启用了视图的认证。
- en: 'With this, you first imported the required classes and methods that will be
    used to define the test case and initialize a testing client:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，您首先导入了将用于定义测试用例和初始化测试客户端的必需类和方法：
- en: '[PRE47]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The next thing you require is the `User` model from Django''s `auth` module:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您接下来需要的是Django `auth`模块中的`User`模型：
- en: '[PRE48]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This model is required because for the test cases requiring authentication,
    you will need to initialize a new test user. Next up, you created a new class
    named `TestLoggedInGreetingView`, which wraps your tests related to the `greeting_user`
    view (which requires authentication). Inside this class, you defined three methods,
    namely: `setUp()`, `test_user_greeting_not_authenticated()`, and `test_user_authenticated()`.
    The `setUp()` method is used to first initialize a test user, which you will use
    for authentication. This is a required step because a test environment inside
    Django is a completely isolated environment that doesn''t use data from your production
    application, hence all the required models and objects are to be instantiated
    separately inside the test environment.'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此模型是必需的，因为对于需要认证的测试用例，您需要初始化一个新的测试用户。接下来，您创建了一个名为`TestLoggedInGreetingView`的新类，该类封装了与`greeting_user`视图（需要认证）相关的测试。在这个类内部，您定义了三个方法，分别是：`setUp()`、`test_user_greeting_not_authenticated()`和`test_user_authenticated()`。`setUp()`方法用于首先初始化一个测试用户，您将使用它进行认证。这是一个必需的步骤，因为Django测试环境是一个完全隔离的环境，它不使用生产应用程序中的数据，因此所有必需的模型和对象都必须在测试环境中单独实例化。
- en: 'You then created the test user and initiated the test client using the following code:'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，您使用以下代码创建了测试用户并初始化了测试客户端：
- en: '[PRE49]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next up, you wrote the test case for the `greet_user` endpoint when the user
    is not authenticated. Inside this, you should expect Django to redirect the user
    to the login endpoint. This redirect can be detected by checking the HTTP status
    code of the response, which should be set to `HTTP 302`, indicating a redirect operation:'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，您为用户未认证时的`greet_user`端点编写了测试用例。在这个测试用例中，您应该期望Django将用户重定向到登录端点。可以通过检查响应的HTTP状态码来检测此重定向，状态码应设置为`HTTP
    302`，表示重定向操作：
- en: '[PRE50]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, you wrote another test case to check whether the `greet_user` endpoint
    renders successfully when the user is authenticated. To authenticate the user,
    you first call the `login()` method of the test client and perform authentication
    by providing the username and password of the test user you created in the `setUp()`
    method as follows:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，您又编写了另一个测试用例，以检查当用户认证时`greet_user`端点是否成功渲染。为了认证用户，您首先调用测试客户端的`login()`方法，并通过提供在`setUp()`方法中创建的测试用户的用户名和密码进行认证，如下所示：
- en: '[PRE51]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Once the login is completed, you make an `HTTP GET` request to the `greet_user`
    endpoint and validate whether the endpoint generates a correct result or not by
    checking the HTTP status code of the returned response:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 登录完成后，您向`greet_user`端点发送一个`HTTP GET`请求，并通过检查返回响应的HTTP状态码来验证端点是否生成正确的结果：
- en: '[PRE52]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'With the test cases written, it is time to check how they run. For this, run
    the following command:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试用例编写完成后，是时候检查它们如何运行了。为此，运行以下命令：
- en: '[PRE53]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once the execution finishes, you can expect to see a response that resembles
    the one that follows:'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行完成后，您应该会看到以下类似响应：
- en: '[PRE54]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As we can see from the preceding output, our test cases have passed successfully,
    validating that the view we created generates the desired response of redirecting
    the user if the user is unauthenticated to the website, and allows the user to
    see the page if the user is authenticated.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前所述的输出所示，我们的测试用例已成功通过，验证了我们创建的视图在用户未认证时重定向用户到网站，并在用户认证时允许用户查看页面。
- en: In this exercise, we just implemented a test case where we can test the output
    generated by a view function regarding the authentication status of the user.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们只是实现了一个测试用例，我们可以测试视图函数生成的关于用户认证状态的输出。
- en: Django Request Factory
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django请求工厂
- en: Till now, we have been using Django's test client to test the views we have
    created for our application. The test client class simulates a browser and uses
    this simulation to make calls to the required APIs. But what if we did not want
    to use the test client and its associated simulation of being a browser, but rather
    wanted to test the view functions directly by passing the request parameter? How
    can we do that?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用Django的测试客户端来测试我们为应用程序创建的视图。测试客户端类模拟了一个浏览器，并使用这种模拟来调用所需的API。但如果我们不想使用测试客户端及其作为浏览器的相关模拟，而是想直接通过传递请求参数来测试视图函数，我们应该怎么做？
- en: 'To help us in such cases, we can leverage the `RequestFactory` class provided
    by Django. The `RequestFactory` class helps us provide the `request` object, which
    we can pass to our view functions to evaluate their working. The following object
    for `RequestFactory` can be created by instantiating the class as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们处理这种情况，我们可以利用Django提供的`RequestFactory`类。`RequestFactory`类帮助我们提供`request`对象，我们可以将其传递给我们的视图函数以评估其工作。可以通过以下方式创建`RequestFactory`的实例：
- en: '[PRE55]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `factory` object thus created supports only HTTP methods such as `get()`,
    `post()`, `put()`, and others, to simulate a call to any URL endpoint. Let us
    look at how we can modify the test case that we wrote in *Exercise 14.04*, *Writing
    Test Cases to Validate Authenticated Users*, to use `RequestFactory`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此创建的`factory`对象仅支持HTTP方法，如`get()`、`post()`、`put()`等，以模拟对任何URL端点的调用。让我们看看我们如何修改我们在*练习14.04*，*编写测试用例以验证已认证用户*中编写的测试用例，以使用`RequestFactory`。
- en: 'Exercise 14.05: Using a Request Factory to Test Views'
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.05：使用请求工厂测试视图
- en: 'In this exercise, you will use a request factory to test view functions in
    Django:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用请求工厂来测试Django中的视图函数：
- en: 'For this exercise, you are going to use the existing `greeting_view_user` view
    function, which you created earlier, in *step 1* of *Exercise 14.04*, *Writing
    Test Cases to Validate Authenticated Users*, which is shown as follows:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个练习，你将使用在*练习14.04*，*编写测试用例以验证已认证用户*的第1步中创建的现有的`greeting_view_user`视图函数，如下所示：
- en: '[PRE56]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Next, modify the existing test case, `TestLoggedInGreetingView`, defined inside
    the `tests.py` file under the `bookr_test` directory. Open the `tests.py` file
    and make the following changes.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，修改在`bookr_test`目录下的`tests.py`文件中定义的现有测试用例`TestLoggedInGreetingView`。打开`tests.py`文件并做出以下更改。
- en: 'First, you need to add the following import to use `RequestFactory` inside
    the test cases:'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，你需要添加以下导入以在测试用例中使用`RequestFactory`：
- en: '[PRE57]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The next thing you need is an import for the `AnonymousUser` class from Django''s
    `auth` module and the `greeting_view_user` view method from the `views` module.
    This is required to test the view functions with a simulated user who is not logged
    in. This can be done by adding the following code:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一步你需要的是从Django的`auth`模块导入`AnonymousUser`类和从`views`模块导入的`greeting_view_user`视图方法。这是为了测试使用模拟未登录用户的视图函数所必需的。这可以通过添加以下代码来完成：
- en: '[PRE58]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Once the `import` statements are added, modify the `setUp()` method of the
    `TestLoggedInGreetingView` class and change its contents to resemble the one shown
    next:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦添加了`import`语句，修改`TestLoggedInGreetingView`类的`setUp()`方法，并更改其内容以类似于以下所示：
- en: '[PRE59]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this method, you first created a `user` object and stored it as a class member
    such that you can use it later in the tests. Once the `user` object is created,
    then instantiate a new instance of the `RequestFactory` class to use it for testing
    our view function.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个方法中，你首先创建了一个`user`对象，并将其存储为类成员，以便你可以在测试中稍后使用它。一旦创建了`user`对象，然后实例化一个新的`RequestFactory`类的新实例，以便用于测试我们的视图函数。
- en: 'With the `setUp()` method now defined, modify the existing tests to use the
    `RequestFactory` instance. For the test for a non-authenticated call to the view
    function, modify the `test_user_greeting_not_authenticated` method to have the
    following contents:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在定义了`setUp()`方法后，修改现有的测试以使用`RequestFactory`实例。对于对视图函数的非认证调用测试，将`test_user_greeting_not_authenticated`方法修改为以下内容：
- en: '[PRE60]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In this method, you first created a `request` object using the `RequestFactory`
    instance you defined in the `setUp()` method. Once that was done, you assigned
    an `AnonymousUser()` instance to the `request.user` property. Assigning the `AnonymousUser()`
    instance to the property makes the view function think that the user making the
    request is not logged in:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个方法中，你首先使用在`setUp()`方法中定义的`RequestFactory`实例创建了一个`request`对象。一旦完成，你将一个`AnonymousUser()`实例分配给`request.user`属性。将`AnonymousUser()`实例分配给该属性使得视图函数认为发起请求的用户未登录：
- en: '[PRE61]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Once this is done, you made a call to the `greeting_view_user()` view method
    and passed to it the `request` object you created. Once the call is successful,
    you capture the output of the method in the `response` variable using the following
    code:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦完成，你调用了`greeting_view_user()`视图方法，并将你创建的`request`对象传递给它。一旦调用成功，你使用以下代码在`response`变量中捕获方法的输出：
- en: '[PRE62]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'For the unauthenticated user, you expect to get a redirect response, which
    can be tested by checking the HTTP status code of the response as follows:'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于未认证的用户，你期望得到一个重定向响应，可以通过检查响应的HTTP状态码来测试，如下所示：
- en: '[PRE63]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Once this is done, go ahead and modify the other method, `test_user_authenticated()`,
    similarly by using the `RequestFactory` instance as follows:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成这个步骤，继续修改其他方法，例如`test_user_authenticated()`，同样使用`RequestFactory`实例，如下所示：
- en: '[PRE64]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'As you can see, most of the code resembles the code you wrote in the `test_user_greeting_not_authenticated`
    method, with the small change that, in this method, instead of using `AnonymousUser`
    for our `request.user` property, you are using `test_user`, which you created
    in our `setUp()` method:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，大部分代码与你在`test_user_greeting_not_authenticated`方法中编写的代码相似，只是有一点小的变化：在这个方法中，我们不是使用`AnonymousUser`来设置`request.user`属性，而是使用你在`setUp()`方法中创建的`test_user`。
- en: '[PRE65]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: With the changes done, it is time to run the tests.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成这些更改后，是时候运行测试了。
- en: 'To run the tests and validate whether the request factory works as expected,
    run the following command:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行测试并验证请求工厂是否按预期工作，请运行以下命令：
- en: '[PRE66]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Once the command executes, you can expect to see an output that resembles the
    one shown next:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命令执行后，你可以期待看到类似于以下输出的结果：
- en: '[PRE67]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As we can see from the output, the test cases written by us have passed successfully,
    hence validating the behavior of the `RequestFactory` class.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，我们编写的测试用例已经成功通过，从而验证了`RequestFactory`类的行为。
- en: With this exercise, we learned how we can write test cases for view functions
    leveraging `RequestFactory` and passing the `request` object directly to the view
    function, rather than simulating a URL visit using the test client approach, and
    hence allowing more direct testing.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习，我们学习了如何利用`RequestFactory`编写测试用例，并将`request`对象直接传递给视图函数，而不是使用测试客户端方法模拟URL访问，从而允许更直接的测试。
- en: Testing Class-Based Views
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试基于类的视图
- en: In the previous exercise, we saw how we can test views defined as methods. But
    what about class-based views? How can we test those?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们看到了如何测试定义为方法的视图。但对于基于类的视图呢？我们该如何测试它们？
- en: 'As it turns out, it is quite easy to test class-based views. For example, if
    we have a class-based view defined with the name `ExampleClassView(View)`, to
    test the view, all we need to do is to use the following syntax:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，测试基于类的视图相当简单。例如，如果我们有一个名为`ExampleClassView(View)`的基于类的视图，要测试这个视图，我们只需要使用以下语法：
- en: '[PRE68]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It is as simple as that.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单。
- en: A Django application generally consists of several different components that
    can work in isolation, such as models, and some other components that need to
    interact with the URL mapping and other parts of the framework to work. Testing
    these different components may require some steps that are common only to those
    components. For example, when testing a model, we might first want to create certain
    objects of the `Model` class before we start testing, or for views, we might first
    want to initialize a test client with user credentials.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Django应用程序通常由几个不同的组件组成，这些组件可以独立工作，例如模型，以及一些需要与URL映射和其他框架部分交互才能工作的其他组件。测试这些不同的组件可能需要一些只有这些组件共有的步骤。例如，在测试模型时，我们可能首先想要在开始测试之前创建某些`Model`类的对象，或者对于视图，我们可能首先想要使用用户凭据初始化测试客户端。
- en: As it turns out, Django also provides some other classes based on top of the
    `TestCase` class, which can be used to write test cases of specific types about
    the type of the component being used. Let us look at these different classes provided
    by Django.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Django还提供了一些基于`TestCase`类的其他类，可以用来编写关于所使用组件类型的特定类型的测试用例。让我们看看Django提供这些不同的类。
- en: Test Case Classes in Django
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django中的测试用例类
- en: Beyond the base `TestCase` class provided by Django, which can be used to define
    a multitude of test cases for different components, Django also provides some
    specialized classes derived from the `TestCase` class. These classes are used
    for specific types of test cases based on the capabilities they provide to the
    developer.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Django提供的基类`TestCase`，它可以用来为不同的组件定义多种测试用例之外，Django还提供了一些从`TestCase`类派生的专用类。这些类根据它们提供给开发者的功能，用于特定类型的测试用例。
- en: Let us take a quick look at them.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下它们。
- en: SimpleTestCase
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SimpleTestCase
- en: 'This class is derived from the `TestCase` class provided by Django''s `test`
    module and should be used for writing simple test cases that test the view functions.
    Usually, the class is not preferred when your test case involves making database
    queries. The class also provides a lot of useful features, such as the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是从Django的`test`模块提供的`TestCase`类派生出来的，应该用于编写测试视图函数的简单测试用例。通常，当你的测试用例涉及进行数据库查询时，不推荐使用这个类。该类还提供了许多有用的功能，例如以下功能：
- en: The ability to check for exceptions raised by a view function
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查由视图函数引发的异常的能力
- en: The ability to test form fields
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试表单字段的能力
- en: A built-in test client
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的测试客户端
- en: The ability to verify a redirect by a view function
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证视图函数引起的重定向的能力
- en: Matching the equality of two HTML, JSON, or XML outputs generated by the view functions
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配由视图函数生成的两个HTML、JSON或XML输出的相等性
- en: Now, with a basic idea of what `SimpleTestCase` is, let us try to understand
    another type of test case class that helps in writing test cases involving interaction
    with databases.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们先了解一下`SimpleTestCase`是什么，然后尝试理解另一种类型的测试用例类，它有助于编写涉及与数据库交互的测试用例。
- en: TransactionTestCase
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TransactionTestCase
- en: This class is derived from the `SimpleTestCase` class and should be used when
    writing test cases that involve interaction with the database, such as database
    queries, model object creations, and so on.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是从`SimpleTestCase`类派生出来的，应该在编写涉及数据库交互的测试用例时使用，例如数据库查询、模型对象创建等。
- en: 'The class provides the following added features:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 该类提供了以下附加功能：
- en: The ability to reset the database to a default state before a test case runs
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试用例运行之前将数据库重置到默认状态的能力
- en: Skipping tests based on database features – this feature can come in handy if
    the database being used for testing does not support all the features of a production database
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据数据库功能跳过测试 - 如果用于测试的数据库不支持生产数据库的所有功能，这个功能可能会很有用
- en: LiveServerTestCase
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LiveServerTestCase
- en: This class is like the `TransactionTestCase` class, but with the small difference
    that the test cases written in the class use a live server created by Django (instead
    of using the default test client).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类类似于`TransactionTestCase`类，但有一个小的区别，即该类中编写的测试用例使用Django创建的实时服务器（而不是使用默认的测试客户端）。
- en: This ability to run the live server for testing comes in handy when writing
    test cases that test for the rendered web pages and any interaction with them,
    which is not possible while using the default test client.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写测试用例以测试渲染的网页及其任何交互时，这种运行实时服务器进行测试的能力会很有用，这是在使用默认测试客户端时无法实现的。
- en: Such test cases can leverage tools such as **Selenium**, which can be used to
    build interactive test cases that modify the state of the rendered page by interacting
    with it.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的测试用例可以利用像**Selenium**这样的工具，它可以用来构建通过与之交互来修改渲染页面状态的交互式测试用例。
- en: Modularizing Test Code
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试代码模块化
- en: In the previous exercises, we have seen how we can write test cases for different
    components of our project. But an important aspect to note is that, till now,
    we have written the test cases for all the components in a single file. This approach
    is okay when the application does not have a lot of views and models. But this
    can become problematic as our application grows because now our single `tests.py`
    file will be hard to maintain.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的练习中，我们已经看到了如何为项目中的不同组件编写测试用例。但需要注意的一个重要方面是，到目前为止，我们一直在单个文件中为所有组件编写测试用例。当应用程序没有很多视图和模型时，这种方法是可以的。但随着应用程序的增长，这可能会变得有问题，因为现在我们的单个
    `tests.py` 文件将难以维护。
- en: 'To avoid running into such scenarios, we should try to modularize our test
    cases such that the test cases for models are kept separately from test cases
    related to the views, and so on. To achieve this modularization, all we need to
    do is two simple steps:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免遇到此类场景，我们应该尝试模块化我们的测试用例，使得模型测试用例与视图相关的测试用例等保持分离。为了实现这种模块化，我们只需要执行两个简单的步骤：
- en: 'Create a new directory named `tests` inside your application directory by running
    the following command:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令，在您的应用程序目录内创建一个名为 `tests` 的新目录：
- en: '[PRE69]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Create a new empty file named `__init__.py` inside your tests directory by
    running the following command:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令，在您的测试目录中创建一个名为 `__init__.py` 的新空文件：
- en: '[PRE70]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This `__init__.py` file is required by Django to correctly detect the `tests`
    directory we created as a module and not a regular directory.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个 `__init__.py` 文件是 Django 所需的，以便正确检测我们创建的 `tests` 目录作为一个模块而不是普通目录。
- en: Once the preceding steps are done, you can go ahead and create new testing files
    for the different components in your application. For example, to write test cases
    for your models, you can create a new file named `test_models.py` inside the tests
    directory and add any associated code for your model testing inside this file.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 完成前面的步骤后，您可以继续为应用程序中的不同组件创建新的测试文件。例如，要为您的模型编写测试用例，您可以在测试目录中创建一个名为 `test_models.py`
    的新文件，并将与模型测试相关的任何代码添加到此文件中。
- en: 'Also, you do not need to take any other additional steps to run your tests.
    The same command will work perfectly fine for your modular testing code base as
    well:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您不需要采取任何其他额外步骤来运行您的测试。相同的命令将完美适用于您的模块化测试代码库：
- en: '[PRE71]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: With this, we have now understood how we can write test cases for our projects.
    So, how about we assess this knowledge by writing test cases for the Bookr project
    that we are working on?
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们现在已经了解了如何为我们的项目编写测试用例。那么，我们何不通过为正在进行的 Bookr 项目编写测试用例来评估我们的知识呢？
- en: 'Activity 14.01: Testing Models and Views in Bookr'
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 14.01：在 Bookr 中测试模型和视图
- en: In this activity, you will implement test cases for the Bookr project. You will
    implement test cases to validate the functioning of the models created inside
    the `reviews` application of the Bookr project, and then you will implement a
    simple test case for validating the `reviews` application.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您将为 Bookr 项目实现测试用例。您将实现验证 `reviews` 应用程序中创建的模型的测试用例，然后您将实现一个简单的测试用例来验证
    `reviews` 应用程序。
- en: 'The following steps will help you work through this activity:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个活动：
- en: Create a directory named `tests` inside the `reviews` application directory,
    such that all our test cases for the `reviews` application can be modularized.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `reviews` 应用程序目录中创建一个名为 `tests` 的目录，以便我们可以将所有针对 `reviews` 应用程序的测试用例进行模块化。
- en: Create an empty `__init__.py` file, such that the directory is considered not
    as a general directory, but rather a Python module directory.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的 `__init__.py` 文件，这样目录就被视为不是普通目录，而是一个 Python 模块目录。
- en: Create a new file, `test_models.py`, for implementing the code that tests the
    models. Inside this file, import the models you want to test.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，名为 `test_models.py`，用于实现测试模型的代码。在此文件中，导入您想要测试的模型。
- en: Inside `test_models.py`, create a new class that inherits from the `TestCase`
    class of the `django.tests` module and implements methods to validate the creation
    and reading of the `Model` objects.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `test_models.py` 中，创建一个新的类，该类继承自 `django.tests` 模块的 `TestCase` 类，并实现验证 `Model`
    对象创建和读取的方法。
- en: To test the view function, create a new file named `test_views.py` inside the
    `tests` directory, which was created in *step 1*.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试视图函数，在 `tests` 目录中（在步骤 1 中创建的）创建一个名为 `test_views.py` 的新文件。
- en: Inside the `test_views.py` file, import the test `Client` class from the `django.tests`
    module and the `index` view function from the `reviews` application's `views.py`
    file.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `test_views.py` 文件中，从 `django.tests` 模块导入测试 `Client` 类，以及从 `reviews` 应用程序的
    `views.py` 文件中导入 `index` 视图函数。
- en: Inside the `test_views.py` file created in *step 5*, create a new `TestCase`
    class, and implement methods to validate the index view.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *步骤 5* 中创建的 `test_views.py` 文件中，创建一个新的 `TestCase` 类，并实现方法来验证索引视图。
- en: Inside the `TestCase` class created in *step 7*, create a new function, `setUp()`,
    inside which you should initialize an instance of `RequestFactory`, which will
    be used to create a `request` object that can be directly passed to the view function
    for testing.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *步骤 7* 中创建的 `TestCase` 类中，创建一个新的函数 `setUp()`，在其中你应该初始化一个 `RequestFactory`
    实例，该实例将用于创建一个可以直接传递给视图函数进行测试的 `request` 对象。
- en: Once the previous steps are done and the test cases are written, run the test
    cases by executing the `python manage.py` test to validate that the test cases pass.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成前面的步骤并编写了测试用例后，通过执行 `python manage.py test` 来运行测试用例，以验证测试用例是否通过。
- en: Upon completing this activity, all test cases should pass successfully.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动后，所有测试用例都应成功通过。
- en: Note
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在 [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ) 找到。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we looked at how we can write test cases for different
    components of our web application project with Django. We learned about why testing
    plays a crucial role in the development of any web application and the different
    types of testing techniques that are employed in the industry to make sure the
    application code they ship is stable and bug-free.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何使用 Django 为我们的 Web 应用程序项目编写不同组件的测试用例。我们了解了为什么测试在任何 Web 应用程序的开发中都起着至关重要的作用，以及行业中采用的不同测试技术，以确保他们发布的应用程序代码是稳定且无错误的。
- en: We then looked at how we can use the `TestCase` class provided by Django's `test`
    module to implement our unit tests, which can be used to test the models as well
    as views. We also looked at how we can use Django's `test` client to test our
    view functions that require or do not require the user to be authenticated. We
    also glanced over another approach of using `RequestFactory` to test method views
    and class-based views.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着探讨了如何使用 Django 的 `test` 模块提供的 `TestCase` 类来实现我们的单元测试，这些测试可以用来测试模型以及视图。我们还探讨了如何使用
    Django 的 `test` 客户端来测试需要或不需要用户认证的视图函数。我们还简要介绍了使用 `RequestFactory` 来测试方法视图和基于类的视图的另一种方法。
- en: We concluded the chapter by understanding the predefined classes provided by
    Django and where they should be used and looked at how we can modularize our testing
    codebase to make it appear clean.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过了解 Django 提供的预定义类以及它们应该在哪里使用，并探讨了如何模块化我们的测试代码库，使其看起来更整洁，来结束本章。
- en: As we move on to the next chapter, we will try to understand how we can make
    our Django application more powerful by integrating third-party libraries into
    our project. This functionality will then be used to implement third-party authentication
    into our Django application and thus allow users to log in to the application
    using popular services such as Google Sign-In, Facebook Login, and more.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入下一章，我们将尝试理解如何通过将第三方库集成到我们的项目中来使我们的 Django 应用程序更加强大。然后，我们将使用此功能将第三方身份验证集成到我们的
    Django 应用程序中，从而允许用户使用 Google Sign-In、Facebook 登录等流行服务登录应用程序。
