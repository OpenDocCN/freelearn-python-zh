- en: Concurrent Execution
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发执行
- en: '"What do we want? Now! When do we want it? Fewer race conditions!"– Anna Melzer'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “我们想要什么？现在！我们什么时候想要？更少的竞争条件！”- Anna Melzer
- en: In this chapter, I'm going to up the game a little bit, both in terms of the
    concepts I'll present, and in the complexity of the code snippets I'll show you.
    If you don't feel up to the task, or as you are reading through you realize it
    is getting too difficult, feel free to skip it. You can always come back to it
    when you feel ready.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我打算稍微提高一下游戏水平，无论是在我将要介绍的概念上，还是在我将向你展示的代码片段的复杂性上。如果你觉得任务太艰巨，或者在阅读过程中意识到它变得太困难，可以随时跳过。等你准备好了再回来。
- en: The plan is to take a detour from the familiar single-threaded execution paradigm,
    and deep dive into what can be described as concurrent execution. I will only
    be able to scratch the surface of this complex topic, so I won't expect you to
    be a master of concurrency by the time you're done reading, but I will, as usual,
    try to give you enough information so that you can then proceed by *walking the
    path*, so to speak.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 计划是离开熟悉的单线程执行范式，深入探讨可以描述为并发执行的内容。我只能浅尝这个复杂的主题，所以我不指望你在阅读完之后就成为并发性的大师，但我会像往常一样，尽量给你足够的信息，这样你就可以继续“走上这条路”，可以这么说。
- en: We will learn about all the important concepts that apply to this area of programming,
    and I will try to show you examples coded in different styles, to give you a solid
    understanding of the basics of these topics. To dig deep into this challenging
    and interesting branch of programming, you will have to refer to the *Concurrent
    Execution* section in the Python documentation ([https://docs.python.org/3.7/library/concurrency.html](https://docs.python.org/3.7/library/concurrency.html)),
    and maybe supplement your knowledge by studying books on the subject.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习适用于这个编程领域的所有重要概念，并且我会尝试向你展示以不同风格编码的示例，以便让你对这些主题的基础有扎实的理解。要深入研究这个具有挑战性和有趣的编程分支，你将不得不参考Python文档中的*并发执行*部分（[https://docs.python.org/3.7/library/concurrency.html](https://docs.python.org/3.7/library/concurrency.html)），也许还要通过学习相关书籍来补充你的知识。
- en: 'In particular, we are going to explore the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们将探讨以下内容：
- en: The theory behind threads and processes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程和进程背后的理论
- en: Writing multithreaded code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写多线程代码
- en: Writing multiprocessing code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写多进程代码
- en: Using executors to spawn threads and processes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用执行器来生成线程和进程
- en: A brief example of programming with `asyncio`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`asyncio`进行编程的简短示例
- en: Let's start by getting the theory out of the way.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先把理论搞清楚。
- en: Concurrency versus parallelism
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发与并行
- en: Concurrency and parallelism are often mistaken for the same thing, but there
    is a distinction between them. **Concurrency** is the ability to run multiple
    things at the same time, not necessarily in parallel. **Parallelism** is the ability
    to do a number of things at the same time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 并发和并行经常被误解为相同的事物，但它们之间有区别。并发是同时运行多个任务的能力，不一定是并行的。并行是同时做多件事情的能力。
- en: 'Imagine you take your other half to the theater. There are two lines: that
    is, for VIP and regular tickets. There is only one functionary checking tickets
    and so, in order to avoid blocking either of the two queues, they check one ticket
    from the VIP line, then one from the regular line. Over time, both queues are
    processed. This is an example of concurrency.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你带着另一半去剧院。有两条队列：VIP和普通票。只有一个工作人员检查票，为了避免阻塞两个队列中的任何一个，他们先检查VIP队列的一张票，然后检查普通队列的一张票。随着时间的推移，两个队列都被处理了。这是并发的一个例子。
- en: Now imagine that another functionary joins, so now we have one functionary per
    queue. This way, both queues will be processed each by its own functionary. This
    is an example of parallelism.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，另一个工作人员加入了，所以现在每个队列都有一个工作人员。这样，每个队列都将由自己的工作人员处理。这是并行的一个例子。
- en: Modern laptop processors feature multiple cores (normally two to four). A **core**
    is an independent processing unit that belongs to a processor. Having more than
    one core means that the CPU in question has the physical ability to actually execute
    tasks in parallel. Within each core, normally there is a constant alternation
    of streams of work, which is concurrent execution.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现代笔记本电脑处理器具有多个核心（通常是两到四个）。核心是属于处理器的独立处理单元。拥有多个核心意味着所讨论的CPU实际上具有并行执行任务的物理能力。在每个核心内部，通常会有一系列工作流的不断交替，这是并发执行。
- en: Bear in mind that I'm keeping the discussion generic on purpose here. According
    to which system you are using, there will be differences in how execution is handled,
    so I will concentrate on the concepts that are common to all, or at least most,
    systems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我在这里故意保持讨论的泛化。根据你使用的系统，执行处理方式会有所不同，所以我将集中讨论那些对所有系统或至少大多数系统都通用的概念。
- en: Threads and processes – an overview
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程和进程-概述
- en: A **thread** can be defined as a sequence of instructions that can be run by
    a scheduler, which is that part of the operating system that decides which chunk
    of work will receive the necessary resources to be carried out. Typically, a thread
    lives within a process. A process can be defined as an instance of a computer
    program that is being executed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可以被定义为一系列指令，可以由调度程序运行，调度程序是操作系统的一部分，决定哪个工作块将获得必要的资源来执行。通常，一个线程存在于一个进程内。进程可以被定义为正在执行的计算机程序的一个实例。
- en: In previous chapters, we have run our own modules and scripts with commands
    similar to `$ python my_script.py`. What happens when a command like that is run,
    is that a Python process is created. Within it, a main thread of execution is
    spawned. The instructions in the script are what will be run within that thread.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们用类似`$ python my_script.py`的命令运行我们自己的模块和脚本。当运行这样的命令时，会创建一个Python进程。在其中，会生成一个主执行线程。脚本中的指令将在该线程内运行。
- en: This is just one way of working though, and Python can actually use more than
    one thread within the same process, and can even spawn multiple processes. Unsurprisingly,
    these branches of computer science are called **multithreading** and **multiprocessing**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一种工作方式，Python实际上可以在同一个进程中使用多个线程，甚至可以生成多个进程。毫不奇怪，这些计算机科学的分支被称为多线程和多进程。
- en: In order to understand the difference, let's take a moment to explore threads
    and processes in slightly more depth.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解区别，让我们花点时间稍微深入地探讨线程和进程。
- en: Quick anatomy of a thread
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程的快速解剖
- en: 'Generally speaking, there are two different types of threads:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，有两种不同类型的线程：
- en: '**User-level threads**: Threads that we can create and manage in order to perform
    a task'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户级线程：我们可以创建和管理以执行任务的线程
- en: '**Kernel-level threads**: Low-level threads that run in kernel mode and act
    on behalf of the operating system'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核级线程：在内核模式下运行并代表操作系统执行操作的低级线程
- en: Given that Python works at the user level, we're not going to deep dive into
    kernel threads at this time. Instead, we will explore several examples of user-level
    threads in this chapter's examples.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于Python在用户级别上运行，我们暂时不会深入研究内核线程。相反，我们将在本章的示例中探索几个用户级线程的示例。
- en: 'A thread can be in any of the following states:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可以处于以下任何状态：
- en: '**New thread**: A thread that hasn''t started yet, and hasn''t been allocated
    any resources.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新线程：尚未启动，也没有分配任何资源的线程。
- en: '**Runnable**: The thread is waiting to run. It has all the resources needed
    to run, and as soon as the scheduler gives it the green light, it will be run.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可运行：线程正在等待运行。它具有运行所需的所有资源，一旦调度程序给予它绿灯，它将运行。
- en: '**Running**: A thread whose stream of instructions is being executed. From
    this state, it can go back to a non-running state, or die.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行：正在执行指令流的线程。从这种状态，它可以返回到非运行状态，或者死亡。
- en: '**Not-running**: A thread that has been paused. This could be due to another
    thread taking precedence over it, or simply because the thread is waiting for
    a long-running IO operation to finish.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非运行：已暂停的线程。这可能是由于另一个线程优先于它，或者仅仅是因为线程正在等待长时间运行的IO操作完成。
- en: '**Dead**: A thread that has died because it has reached the natural end of
    its stream of execution, or it has been killed.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死亡：线程已经死亡，因为它已经到达了其执行流的自然结束，或者它已经被终止。
- en: Transitions between states are provoked either by our actions or by the scheduler.
    There is one thing to bear in mind, though; it is best not to interfere with the
    death of a thread.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 状态之间的转换是由我们的操作或调度程序引起的。不过，有一件事要记住；最好不要干涉线程的死亡。
- en: Killing threads
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终止线程
- en: Killing threads is not considered to be good practice. Python doesn't provide
    the ability to kill a thread by calling a method or function, and this should
    be a hint that killing threads isn't something you want to be doing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 终止线程并不被认为是良好的做法。Python不提供通过调用方法或函数来终止线程的能力，这应该是终止线程不是你想要做的事情的暗示。
- en: One reason is that a thread might have children—threads spawned from within
    the thread itself—which would be orphaned when their parent dies. Another reason
    could be that if the thread you're killing is holding a resource that needs to
    be closed properly, you might prevent that from happening and that could potentially
    lead to problems.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个原因是线程可能有子线程——从线程本身内部生成的线程——当其父线程死亡时会成为孤儿。另一个原因可能是，如果您要终止的线程持有需要正确关闭的资源，您可能会阻止这种情况发生，这可能会导致问题。
- en: Later, we will see an example of how we can work around these issues.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将看到如何解决这些问题的示例。
- en: Context-switching
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文切换
- en: We have said that the scheduler can decide when a thread can run, or is paused,
    and so on. Any time a running thread needs to be suspended so that another can
    be run, the scheduler saves the state of the running thread in a way that it will
    be possible, at a later time, to resume execution exactly where it was paused.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过调度程序可以决定何时运行线程，或者暂停线程等。任何时候运行的线程需要被暂停以便另一个线程可以运行时，调度程序会以一种方式保存运行线程的状态，以便在以后的某个时间恢复执行，恢复到暂停的地方。
- en: This act is called **context-switching**. People do that all the time too. We
    are doing some paperwork, and we hear *bing!* on our phone. We stop the paperwork
    and check our phone. When we're done dealing with what was probably the umpteenth
    picture of a funny cat, we go back to our paperwork. We don't start the paperwork
    from the beginning, though; we simply continue where we had left off.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个行为被称为上下文切换。人们也经常这样做。我们正在做一些文书工作，然后听到手机上的*叮铃声！*。我们停下文书工作，查看手机。当我们处理完可能是第n张有趣猫的照片后，我们回到文书工作。不过，我们并不是从头开始文书工作；我们只是继续之前离开的地方。
- en: Context-switching is a marvelous ability of modern computers, but it can become
    troublesome if you generate too many threads. The scheduler then will try to give
    each of them a chance to run for a little time, and there will be a lot of time
    spent saving and recovering the state of the threads that are respectively paused
    and restarted.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文切换是现代计算机的奇妙能力，但如果生成了太多线程，它可能会变得麻烦。调度程序将尝试给每个线程一点时间来运行，并且将花费大量时间保存和恢复分别暂停和重新启动的线程的状态。
- en: In order to avoid this problem, it is quite common to limit the amount of threads
    (the same consideration applies to processes) that can be run at any given point
    in time. This is achieved by using a structure called a pool, the size of which
    can be decided by the programmer. In a nutshell, we create a pool and then assign
    tasks to its threads. When all the threads of the pool are busy, the program won't
    be able to spawn a new thread until one of them terminates (and goes back to the
    pool). Pools are also great for saving resources, in that they provide recycling
    features to the thread ecosystem.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，限制可以在任何给定时间点运行的线程数量（同样的考虑也适用于进程）是相当常见的。这是通过使用一个称为池的结构来实现的，其大小可以由程序员决定。简而言之，我们创建一个池，然后将任务分配给它的线程。当池中的所有线程都忙碌时，程序将无法生成新的线程，直到其中一个终止（并返回到池中）。池对于节省资源也非常有用，因为它为线程生态系统提供了回收功能。
- en: When you write multithreaded code, it is useful to have information about the
    machine our software is going to run on. That information, coupled with some profiling
    (we'll learn about it in [Chapter 11](part0288.html#8IL200-2ddb708647cc4530a187c2c6c0e9acfe),
    *Debugging and Troubleshootin*g), should enable us to calibrate the size of our
    pools correctly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写多线程代码时，了解软件将在哪台机器上运行的信息是很有用的。这些信息，再加上一些分析（我们将在[第11章](part0288.html#8IL200-2ddb708647cc4530a187c2c6c0e9acfe)
    *调试和故障排除*中学习），应该能够让我们正确地校准我们的池的大小。
- en: The Global Interpreter Lock
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局解释器锁
- en: In July 2015, I attended the EuroPython conference in Bilbao, where I gave a
    talk about test-driven development. The camera operator unfortunately lost the
    first half of it, but I've since been able to give that talk another couple of
    times, so you can find a complete version of it on the web. At the conference,
    I had the great pleasure of meeting Guido van Rossum and talking to him, and I
    also attended his keynote speech.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年7月，我参加了在毕尔巴鄂举行的EuroPython大会，我在那里做了一个关于测试驱动开发的演讲。摄像机操作员不幸地丢失了其中的前半部分，但我后来又有机会再做了几次那个演讲，所以你可以在网上找到完整版本。在会议上，我有幸见到了Guido
    van Rossum并与他交谈，我还参加了他的主题演讲。
- en: One of the topics he addressed was the infamous **Global Interpreter Lock**
    (**GIL**). The GIL is a mutex that protects access to Python objects, preventing
    multiple threads from executing Python bytecodes at once. This means that even
    though you can write multithreaded code in Python, there is only one thread running
    at any point in time (per process, of course).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 他谈到的一个话题是臭名昭著的**全局解释器锁**（**GIL**）。GIL是一个互斥锁，用于保护对Python对象的访问，防止多个线程同时执行Python字节码。这意味着即使你可以在Python中编写多线程代码，但在任何时间点只有一个线程在运行（每个进程，当然）。
- en: In computer programming, a mutual exclusion object (mutex) is a program object
    that allows multiple program threads to share the same resource, such as file
    access, but not simultaneously.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程中，互斥对象（mutex）是一个允许多个程序线程共享相同资源（如文件访问）但不是同时的程序对象。
- en: This is normally seen as an undesired limitation of the language, and many developers
    take pride in cursing this great villain. The truth lies somewhere else though,
    as was beautifully explained by Raymond Hettinger in his Keynote on Concurrency,
    at PyBay 2017 ([https://bit.ly/2KcijOB](https://bit.ly/2KcijOB)). About 10 minutes
    in, Raymond explains that it is actually quite simple to remove the GIL from Python.
    It takes about a day of work. The price you pay for this *GIL-ectomy* though,
    is that you then have to apply locks yourself wherever they are needed in your
    code. This leads to a more expensive footprint, as multitudes of individual locks
    take more time to be acquired and released, and most importantly, it introduces
    the risk of bugs, as writing robust multithreaded code is not easy and you might
    end up having to write dozens or hundreds of locks.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常被视为语言的不良限制，许多开发人员以诅咒这个伟大的反派为傲。然而，事实并非如此，正如Raymond Hettinger在2017年PyBay大会上的并发性主题演讲中所美妙地解释的那样（[https://bit.ly/2KcijOB](https://bit.ly/2KcijOB)）。大约10分钟后，Raymond解释说，实际上很容易从Python中删除GIL。这需要大约一天的工作。然而，你为此付出的代价是在代码中需要在需要的地方自行应用锁。这会导致更昂贵的印记，因为大量的个别锁需要更长的时间来获取和释放，最重要的是，它引入了错误的风险，因为编写健壮的多线程代码并不容易，你可能最终不得不编写几十甚至几百个锁。
- en: 'In order to understand what a lock is, and why you might want to use it, we
    first need to talk about one of the perils of multithreaded programming: race
    conditions.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解锁是什么，以及为什么你可能想要使用它，我们首先需要谈谈多线程编程的危险之一：竞争条件。
- en: Race conditions and deadlocks
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 竞争条件和死锁
- en: When it comes to writing multithreaded code, you need to be aware of the dangers
    that come when your code is no longer executed linearly. By that, I mean that
    multithreaded code is exposed to the risk of being paused at any point in time
    by the scheduler, because it has decided to give some CPU time to another stream
    of instructions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及编写多线程代码时，你需要意识到当你的代码不再被线性执行时会出现的危险。我的意思是，多线程代码有可能在任何时间点被调度程序暂停，因为它决定给另一个指令流一些CPU时间。
- en: This behavior exposes you to different types of risks, the two most famous being
    race conditions and deadlocks. Let's talk about them briefly.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为使你面临不同类型的风险，其中最著名的两种是竞争条件和死锁。让我们简要谈谈它们。
- en: Race conditions
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 竞争条件
- en: A **race condition** is a behavior of a system where the output of a procedure
    depends on the sequence or timing of other uncontrollable events. When these events
    don't unfold in the order intended by the programmer, a race condition becomes
    a bug.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**竞争条件**是系统行为的一种，其中过程的输出取决于其他无法控制的事件的顺序或时间。当这些事件不按程序员预期的顺序展开时，竞争条件就会成为一个错误。'
- en: It's much easier to explain this with an example.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个例子来解释这一点会更容易理解。
- en: Imagine you have two threads running. Both are performing the same task, which
    consists of reading a value from a location, performing an action with that value,
    incrementing the value by *1* unit, and saving it back. Say that the action is
    to post that value to an API.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你有两个运行的线程。两者都在执行相同的任务，即从一个位置读取一个值，对该值执行一个操作，将该值增加*1*单位，然后保存回去。假设该操作是将该值发布到API。
- en: Scenario A – race condition not happening
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情景A - 竞争条件不会发生
- en: Thread *A* reads the value (*1*), posts *1* to the API, then increments it to
    *2*, and saves it back. Right after this, the scheduler pauses Thread *A*, and
    runs Thread *B*. Thread *B* reads the value (now *2*), posts *2* to the API, increments
    it to *3*, and saves it back.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 线程*A*读取值（*1*），将*1*发送到API，然后将其增加到*2*，并保存回去。就在这之后，调度程序暂停了线程*A*，并运行了线程*B*。线程*B*读取值（现在是*2*），将*2*发送到API，将其增加到*3*，然后保存回去。
- en: 'At this point, after the operation has happened twice, the value stored is
    correct: *1 + 2 = 3*. Moreover, the API has been called with both *1* and *2*,
    correctly.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，即使操作发生了两次，存储的值也是正确的：*1 + 2 = 3*。此外，API已经正确地被调用了两次，分别是*1*和*2*。
- en: Scenario B – race condition happening
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情景B - 竞争条件发生
- en: Thread *A* reads the value (*1*), posts it to the API, increments it to *2*,
    but before it can save it back, the scheduler decides to pause thread *A* in favor
    of Thread *B*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 线程*A*读取值（*1*），将其发送到API，将其增加到*2*，但在它保存回去之前，调度程序决定暂停线程*A*，转而执行线程*B*。
- en: Thread *B* reads the value (still *1*!), posts it to the API, increments it
    to *2*, and saves it back. The scheduler then switches over to Thread *A* again.
    Thread *A* resumes its stream of work by simply saving the value it was holding
    after incrementing, which is *2*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 线程*B*读取值（仍然是*1*！），将其发送到API，将其增加到*2*，然后保存回去。然后调度程序再次切换到线程*A*。线程*A*通过简单保存增加后的值（*2*）来恢复其工作流。
- en: After this scenario, even though the operation has happened twice as in Scenario
    *A*, the value saved is *2*, and the API has been called twice with *1*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，即使操作像情景A中发生了两次，保存的值是*2*，API也被调用了两次，每次都是*1*。
- en: In a real-life situation, with multiple threads and real code performing several
    operations, the overall behavior of the program explodes into a myriad of possibilities.
    We'll see an example of this later on, and we'll fix it using locks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，有多个线程和真实代码执行多个操作的情况下，程序的整体行为会爆炸成无数可能性。我们稍后会看到一个例子，并使用锁来解决它。
- en: The main problem with race conditions is that they make our code non-deterministic,
    which is bad. There are areas in computer science where non-determinism is used
    to achieve things, and that's fine, but in general you want to be able to predict
    how your code will behave, and race conditions make it impossible to do so.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争条件的主要问题在于它使我们的代码变得不确定，这是不好的。在计算机科学中有一些领域使用了非确定性来实现某些目标，这是可以接受的，但通常情况下，你希望能够预测代码的行为，而竞争条件使这变得不可能。
- en: Locks to the rescue
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁来拯救
- en: Locks come to the rescue when dealing with race conditions. For example, in
    order to fix the preceding example, all you need is a lock around the procedure.
    A lock is like a guardian that will allow only one thread to take hold of it (we
    say *to acquire* a lock), and until that thread releases the lock, no other thread
    can acquire it. They will have to sit and wait until the lock is available again.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理竞争条件时，锁会拯救我们。例如，为了修复前面的例子，你只需要在该过程周围加上一个锁。锁就像一个守护者，只允许一个线程拿住它（我们说*获取*锁），并且直到该线程释放锁，其他线程都无法获取它。它们必须坐下等待，直到锁再次可用。
- en: Scenario C – using a lock
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情景C - 使用锁
- en: Thread *A* acquires the lock, reads the value (*1*), posts to the API, increases
    to *2*, and the scheduler suspends it. Thread *B* is given some CPU time, so it
    tries to acquire the lock. But the lock hasn't been released yet by Thread *A*,
    so Thread *B* sits and waits. The scheduler might notice this, and quickly decide
    to switch back to Thread *A*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 线程*A*获取锁，读取值（*1*），发送到API，增加到*2*，然后调度程序将其挂起。线程*B*获得了一些CPU时间，所以它尝试获取锁。但是锁还没有被线程*A*释放，所以线程*B*等待。调度程序可能会注意到这一点，并迅速决定切换回线程*A*。
- en: Thread *A* saves 2, and releases the lock, making it available to all other
    threads.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 线程*A*保存2，并释放锁，使其对所有其他线程可用。
- en: At this point, whether the lock is acquired again by Thread *A*, or by Thread
    *B* (because the scheduler might have decided to switch again), is not important.
    The procedure will always be carried out correctly, since the lock makes sure
    that when a thread reads a value, it has to complete the procedure (ping API,
    increment, and save) before any other thread can read the value as well.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，无论是线程*A*再次获取锁，还是线程*B*获取锁（因为调度程序可能已经决定再次切换），都不重要。该过程将始终被正确执行，因为锁确保当一个线程读取一个值时，它必须在任何其他线程也能读取该值之前完成该过程（ping
    API，增加和保存）。
- en: There are a multitude of different locks available in the standard library.
    I definitely encourage you to read up on them to understand all the perils you
    might encounter when coding multithreaded code, and how to solve them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中有许多不同的锁可用。我绝对鼓励你阅读它们，以了解在编写多线程代码时可能遇到的所有危险，以及如何解决它们。
- en: Let's now talk about deadlocks.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈死锁。
- en: Deadlocks
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 死锁
- en: A **deadlock** is a state in which each member of a group is waiting for some
    other member to take action, such as sending a message or, more commonly, releasing
    a lock, or a resource.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**死锁**是一种状态，在这种状态下，组中的每个成员都在等待其他成员采取行动，例如发送消息，更常见的是释放锁或资源。'
- en: A simple example will help you get the picture. Imagine two little kids playing
    together. Find a toy that is made of two parts, and give each of them one part.
    Naturally, neither of them will want to give the other one their part, and they
    will want the other one to release the part they have. So neither of them will
    be able to play with the toy, as they each hold half of it, and will indefinitely
    wait for the other kid to release the other half.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子将帮助你理解。想象两个小孩在一起玩。找一个由两部分组成的玩具，给他们每人一部分。自然地，他们中没有一个会想把自己的那部分给另一个，他们会想让另一个释放他们手中的那部分。因此，他们中没有一个能够玩这个玩具，因为他们每个人都握着一半，会无限期地等待另一个孩子释放另一半。
- en: Don't worry, no kids were harmed during the making of this example. It all happened
    in my mind.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，在制作这个例子的过程中没有伤害到任何孩子。这一切都发生在我的脑海中。
- en: Another example could be having two threads execute the same procedure again.
    The procedure requires acquiring two resources, *A* and *B*, both guarded by a
    separate lock. Thread *1* acquires *A*, and Thread *2* acquires *B*, and then
    they will wait indefinitely until the other one releases the resource it has.
    But that won't happen, as they both are instructed to wait and acquire the second
    resource in order to complete the procedure. Threads can be much more stubborn
    than kids.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子可能是让两个线程再次执行相同的过程。该过程需要获取两个资源，*A*和*B*，分别由单独的锁保护。线程*1*获取*A*，线程*2*获取*B*，然后它们将无限期地等待，直到另一个释放它所拥有的资源。但这不会发生，因为它们都被指示等待并获取第二个资源以完成该过程。线程可能比孩子更倔强。
- en: 'You can solve this problem in several ways. The easiest one might be simply
    to apply an order to the resources acquisition, which means that the thread that
    gets *A*, will also get all the rest: *B*, *C*, and so on.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用几种方法解决这个问题。最简单的方法可能就是对资源获取应用顺序，这意味着获得*A*的线程也会获得其余的*B*、*C*等等。
- en: Another way is to put a lock around the whole resources acquisition procedure,
    so that even if it might happen out of order, it will still be within the context
    of a lock, which means only one thread at a time can actually gather all the resources.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在整个资源获取过程周围加锁，这样即使可能发生顺序错误，它仍然会在锁的上下文中进行，这意味着一次只有一个线程可以实际获取所有资源。
- en: Let's now pause our talk on threads for a moment, and explore processes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们暂停一下关于线程的讨论，来探讨进程。
- en: Quick anatomy of a process
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程的简单解剖
- en: Processes are normally more complex than threads. In general, they contain a
    main thread, but can also be multithreaded if you choose. They are capable of
    spawning multiple sub-threads, each of which contains its own set of registers
    and a stack. Each process provides all the resources that the computer needs in
    order to execute the program.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 进程通常比线程更复杂。一般来说，它们包含一个主线程，但如果你选择的话也可以是多线程的。它们能够生成多个子线程，每个子线程都包含自己的寄存器和堆栈。每个进程都提供计算机执行程序所需的所有资源。
- en: Similarly to using multiple threads, we can design our code to take advantage
    of a multiprocessing design. Multiple processes are likely to run over multiple
    cores, therefore with multiprocessing, you can truly parallelize computation.
    Their memory footprints, though, are slightly heavier than those of threads, and
    another drawback to using multiple processes is that **inter-process communication**
    (**IPC**) tends to be more expensive than communication between threads.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用多个线程类似，我们可以设计我们的代码以利用多进程设计。多个进程可能在多个核心上运行，因此使用多进程可以真正并行计算。然而，它们的内存占用略高于线程的内存占用，使用多个进程的另一个缺点是**进程间通信**（IPC）往往比线程间通信更昂贵。
- en: Properties of a process
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程的属性
- en: 'A UNIX process is created by the operating system. It typically contains the
    following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX进程是由操作系统创建的。它通常包含以下内容：
- en: A process ID, process group ID, user ID, or group ID
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程ID、进程组ID、用户ID或组ID
- en: An environment and working directory
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个环境和工作目录
- en: Program instructions
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序指令
- en: Registers, a stack, and a heap
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器、堆栈和堆
- en: File descriptors
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件描述符
- en: Signal actions
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号动作
- en: Shared libraries
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享库
- en: Inter-process communication tools (pipes, message queues, semaphores, or shared
    memory)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程间通信工具（管道、消息队列、信号量或共享内存）
- en: 'If you are curious about processes, open up a shell and type `$ top`. This
    command displays and updates sorted information about the processes that are running
    in your system. When I run it on my machine, the first line tells me the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对进程感兴趣，打开一个shell并输入`$ top`。这个命令会显示并更新有关系统中正在运行的进程的排序信息。当我在我的机器上运行它时，第一行告诉我以下信息：
- en: '[PRE0]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This gives you an idea about how much work our computers are doing without us
    being really aware of it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这让你对我们的计算机在我们并不真正意识到的情况下做了多少工作有了一个概念。
- en: Multithreading or multiprocessing?
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程还是多进程？
- en: Given all this information, deciding which approach is the best means having
    an understanding of the type of work that needs to be carried out, and knowledge
    about the system that will be dedicated to doing that work.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些信息，决定哪种方法是最好的意味着要了解需要执行的工作类型，并且要了解将要专门用于执行该工作的系统。
- en: There are advantages to both approaches, so let's try to clarify the main differences.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有优势，所以让我们试着澄清一下主要的区别。
- en: 'Here are some advantages of using multithreading:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用多线程的一些优势：
- en: Threads are all born within the same process. They share resources and can communicate
    with one another very easily. Communication between processes requires more complex
    structures and techniques.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程都是在同一个进程中诞生的。它们共享资源，并且可以非常容易地相互通信。进程之间的通信需要更复杂的结构和技术。
- en: The overhead of spawning a thread is smaller than that of a process. Moreover,
    their memory footprint is also smaller.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成线程的开销比生成进程的开销小。此外，它们的内存占用也更小。
- en: Threads can be very effective at blocking IO-bound applications. For example,
    while one thread is blocked waiting for a network connection to give back some
    data, work can be easily and effectively switched to another thread.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程在阻塞IO密集型应用程序方面非常有效。例如，当一个线程被阻塞等待网络连接返回一些数据时，工作可以轻松有效地切换到另一个线程。
- en: Because there aren't any shared resources between processes, we need to use
    IPC techniques, and they require more memory than communication between threads.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为进程之间没有共享资源，所以我们需要使用IPC技术，而且它们需要比线程之间通信更多的内存。
- en: 'Here are some advantages of using multiprocessing:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用多进程的一些优势：
- en: We can avoid the limitations of the GIL by using processes.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过使用进程来避免GIL的限制。
- en: Sub-processes that fail won't kill the main application.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败的子进程不会终止主应用程序。
- en: Threads suffer from issues such as race conditions and deadlocks; while using
    processes the likelihood of having to deal with them is greatly reduced.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程存在诸如竞争条件和死锁等问题；而使用进程时，需要处理这些问题的可能性大大降低。
- en: Context-switching of threads can become quite expensive when their amount is
    above a certain threshold.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当线程数量超过一定阈值时，线程的上下文切换可能变得非常昂贵。
- en: Processes can make better use of multicore processors.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程可以更好地利用多核处理器。
- en: Processes are better than multiple threads at handling CPU-intensive tasks.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程比多线程更擅长处理CPU密集型任务。
- en: In this chapter, I'll show you both approaches for multiple examples, so hopefully
    you'll gain a good understanding of the various different techniques. Let's get
    to the code then!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将为您展示多个示例的两种方法，希望您能对各种不同的技术有一个很好的理解。那么让我们开始编码吧！
- en: Concurrent execution in Python
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的并发执行
- en: Let's start by exploring the basics of Python multithreading and multiprocessing
    with some simple examples.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些简单的例子开始，探索Python多线程和多进程的基础知识。
- en: Keep in mind that several of the following examples will produce an output that
    depends on a particular run. When dealing with threads, things can get non-deterministic,
    as I mentioned earlier. So, if you experience different results, it is absolutely
    fine. You will probably notice that some of your results will vary from run to
    run too.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，以下示例中的几个将产生取决于特定运行的输出。处理线程时，事情可能变得不确定，就像我之前提到的那样。因此，如果您遇到不同的结果，那是完全正常的。您可能会注意到，您的一些结果也会从一次运行到另一次运行有所不同。
- en: Starting a thread
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始一个线程
- en: 'First things first, let''s start a thread:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们开始一个线程：
- en: '[PRE1]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After importing `threading`, we define a function: `sum_and_product`. This function
    calculates the sum and the product of two numbers, and prints the results. The
    interesting bit is after the function. We instantiate `t` from `threading.Thread`.
    This is our thread. We passed the name of the function that will be run as the
    thread body, we gave it a name, and passed the arguments `3` and `7`, which will
    be fed into the function as `a` and `b`, respectively.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入`threading`之后，我们定义一个函数：`sum_and_product`。这个函数计算两个数字的和和积，并打印结果。有趣的部分在函数之后。我们从`threading.Thread`实例化了`t`。这是我们的线程。我们传递了将作为线程主体运行的函数的名称，给它一个名称，并传递了参数`3`和`7`，它们将分别作为`a`和`b`传递到函数中。
- en: After having created the thread, we start it with the homonymous method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了线程之后，我们使用同名方法启动它。
- en: 'At this point, Python will start executing the function in a new thread, and
    when that operation is done, the whole program will be done as well, and exit.
    Let''s run it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，Python将在一个新线程中开始执行函数，当该操作完成时，整个程序也将完成，并退出。让我们运行它：
- en: '[PRE2]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Starting a thread is therefore quite simple. Let''s see a more interesting
    example where we display more information:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，开始一个线程非常简单。让我们看一个更有趣的例子，其中我们显示更多信息：
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, the thread logic is exactly the same as in the previous one,
    so you don't need to sweat on it and can concentrate on the (insane!) amount of
    logging information I added. We use two functions to display information: `status`
    and `print_current`. The first one takes a thread in input and displays its name
    and whether or not it's alive by calling its `is_alive` method. The second one
    prints the current thread, and then enumerates all the threads in the process.
    This information comes from `threading.current_thread` and `threading.enumerate`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，线程逻辑与之前的完全相同，所以你不需要为此而劳累，可以专注于我添加的（疯狂的！）大量日志信息。我们使用两个函数来显示信息：`status`和`print_current`。第一个函数接受一个线程作为输入，并通过调用其`is_alive`方法显示其名称以及它是否存活。第二个函数打印当前线程，然后枚举进程中的所有线程。这些信息来自`threading.current_thread`和`threading.enumerate`。
- en: There is a reason why I put `.2` seconds of sleeping time within the function.
    When the thread starts, its first instruction is to sleep for a moment. The sneaky
    scheduler will catch that, and switch execution back to the main thread. You can
    verify this by the fact that in the output, you will see the result of `status(t)`
    before that of `print_current` from within the thread. This means that that call
    happens while the thread is sleeping.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我在函数内部放置了`.2`秒的睡眠时间是有原因的。当线程启动时，它的第一条指令是休眠一会儿。调皮的调度程序会捕捉到这一点，并将执行切换回主线程。您可以通过输出中看到，在线程内部的`status(t)`的结果之前，您将看到`print_current`的结果。这意味着这个调用发生在线程休眠时。
- en: 'Finally, notice I called `t.join()` at the end. That instructs Python to block
    until the thread has completed. The reason for that is because I want the last
    call to `status(t)` to tell us that the thread is gone. Let''s peek at the output
    (slightly rearranged for readability):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意我在最后调用了`t.join()`。这指示Python阻塞，直到线程完成。这是因为我希望最后一次对`status(t)`的调用告诉我们线程已经结束。让我们来看一下输出（为了可读性稍作调整）：
- en: '[PRE4]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, at first the current thread is the main thread. The enumeration
    shows only one thread. Then we create and start `SumProd`. We print its status
    and we learn it is alive. Then, and this time from within `SumProd`, we display
    information about the current thread again. Of course, now the current thread
    is `SumProd`, and we can see that enumerating all threads returns both of them.
    After the result is printed, we verify, with one last call to `status`, that the
    thread has terminated, as predicted. Should you get different results (apart from
    the IDs of the threads, of course), try increasing the sleeping time and see whether
    anything changes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，一开始当前线程是主线程。枚举只显示一个线程。然后我们创建并启动`SumProd`。我们打印它的状态，我们得知它还活着。然后，这一次是从`SumProd`内部，我们再次显示当前线程的信息。当然，现在当前线程是`SumProd`，我们可以看到枚举所有线程返回了两个。打印结果后，我们通过最后一次对`status`的调用验证线程是否已经终止，正如预期的那样。如果你得到不同的结果（当然除了线程的ID之外），尝试增加睡眠时间，看看是否有任何变化。
- en: Starting a process
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动一个进程
- en: 'Let''s now see an equivalent example, but instead of using a thread, we''ll
    use a process:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个等价的例子，但是不使用线程，而是使用进程：
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code is exactly the same as for the first example, but instead of using
    a `Thread`, we actually instantiate `multiprocessing.Process`. The `sum_and_product`
    function is the same as before. The output is also the same, except the numbers
    are different.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与第一个示例完全相同，但我们实例化`multiprocessing.Process`而不是使用`Thread`。`sum_and_product`函数与以前相同。输出也是相同的，只是数字不同。
- en: Stopping threads and processes
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止线程和进程
- en: 'As mentioned before, in general, stopping a thread is a bad idea, and the same
    goes for a process. Being sure you''ve taken care to dispose and close everything
    that is open can be quite difficult. However, there are situations in which you
    might want to be able to stop a thread, so let me show you how to do it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一般来说，停止线程是一个坏主意，进程也是一样。确保你已经注意到处理和关闭所有打开的东西可能会非常困难。然而，有些情况下你可能希望能够停止一个线程，所以让我告诉你如何做：
- en: '[PRE6]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For this example, we use a Fibonacci generator. We've seen it before so I won't
    explain it. The important bit to focus on is the `_running` attribute. First of
    all, notice the class inherits from `Thread`. By overriding the `__init__` method,
    we can set the `_running` flag to `True`. When you write a thread this way, instead
    of giving it a target function, you simply override the `run` method in the class.
    Our `run` method calculates a new Fibonacci number, and then sleeps for about
    `0.07` seconds.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们使用一个斐波那契生成器。我们之前见过它，所以我不会解释它。要关注的重要部分是`_running`属性。首先要注意的是类继承自`Thread`。通过重写`__init__`方法，我们可以将`_running`标志设置为`True`。当你以这种方式编写线程时，而不是给它一个目标函数，你只需在类中重写`run`方法。我们的`run`方法计算一个新的斐波那契数，然后睡眠约`0.07`秒。
- en: 'In the last block of code, we create and start an instance of our class. Then
    we sleep for one second, which should give the thread time to produce about 14
    Fibonacci numbers. When we call `fibo.stop()`, we aren''t actually stopping the
    thread. We simply set our flag to `False`, and this allows the code within `run`
    to reach its natural end. This means that the thread will die organically. We
    call `join` to make sure the thread is actually done before we print `All done.`
    on the console. Let''s check the output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一段代码中，我们创建并启动了一个类的实例。然后我们睡眠一秒钟，这应该给线程时间产生大约14个斐波那契数。当我们调用`fibo.stop()`时，我们实际上并没有停止线程。我们只是将我们的标志设置为`False`，这允许`run`中的代码达到自然的结束。这意味着线程将自然死亡。我们调用`join`来确保线程在我们在控制台上打印`All
    done.`之前实际完成。让我们检查输出：
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Check how many numbers were printed: 14, as predicted.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 检查打印了多少个数字：14，正如预期的那样。
- en: This is basically a workaround technique that allows you to stop a thread. If
    you design your code correctly according to multithreading paradigms, you shouldn't
    have to kill threads all the time, so let that need become your alarm bell that
    something could be designed better.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是一种解决技术，允许你停止一个线程。如果你根据多线程范例正确设计你的代码，你就不应该总是不得不杀死线程，所以让这种需要成为你设计更好的警钟。
- en: Stopping a process
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止一个进程
- en: When it comes to stopping a process, things are different, and fuss-free. You
    can use either the `terminate` or `kill` method, but please make sure you know
    what you're doing, as all the preceding considerations about open resources left
    hanging are still true.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到停止一个进程时，情况就不同了，而且没有麻烦。你可以使用`terminate`或`kill`方法，但请确保你知道自己在做什么，因为之前关于悬挂的开放资源的所有考虑仍然是正确的。
- en: Spawning multiple threads
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成多个线程
- en: 'Just for fun, let''s play with two threads now:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了好玩，现在让我们玩两个线程：
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `run` function simply prints the current thread, and then enters a loop
    of `n` cycles, in which it prints a greeting message, and sleeps for a random
    amount of time, between `0` and `0.2` seconds (`random()` returns a float between
    `0` and `1`).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`函数简单地打印当前线程，然后进入`n`个周期的循环，在循环中打印一个问候消息，并睡眠一个随机的时间，介于`0`和`0.2`秒之间（`random()`返回一个介于`0`和`1`之间的浮点数）。'
- en: 'The purpose of this example is to show you how a scheduler might jump between
    threads, so it helps to make them sleep a little. Let''s see the output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的目的是向你展示调度程序可能在线程之间跳转，所以让它们睡一会儿会有所帮助。让我们看看输出：
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the output alternates randomly between the two. Every time that
    happens, you know a context switch has been performed by the scheduler.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，输出在两者之间随机交替。每当发生这种情况时，你就知道调度程序已经执行了上下文切换。
- en: Dealing with race conditions
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理竞争条件
- en: 'Now that we have the tools to start threads and run them, let''s simulate a
    race condition such as the one we discussed earlier:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了启动线程和运行它们的工具，让我们模拟一个竞争条件，比如我们之前讨论过的条件：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we define the `incr` function, which gets a number `n` in input,
    and loops over `n`. In each cycle, it reads the value of the counter, sleeps for
    a random amount of time (between `0` and `0.1` seconds) by calling `randsleep`,
    a tiny Lambda function I wrote to improve readability, then increases the value of
    the `counter` by `1`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了`incr`函数，它接收一个数字`n`作为输入，并循环`n`次。在每个循环中，它读取计数器的值，通过调用我编写的一个小的Lambda函数`randsleep`来随机休眠一段时间（在`0`和`0.1`秒之间），然后将`counter`的值增加`1`。
- en: I chose to use `global` in order to have read/write access to `counter`, but
    it could be anything really, so feel free to experiment with that yourself.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用`global`来读/写`counter`，但实际上可以是任何东西，所以请随意尝试。
- en: The whole script basically starts two threads, each of which runs the same function,
    and gets `n = 5`. Notice how we need to join on both threads at the end to make
    sure that when we print the final value of the counter (last line), both threads
    are done doing their work.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 整个脚本基本上启动了两个线程，每个线程运行相同的函数，并获得`n = 5`。请注意，我们需要在最后加入两个线程的连接，以确保当我们打印计数器的最终值（最后一行）时，两个线程都完成了它们的工作。
- en: When we print the final value, we would expect the counter to be 10, right?
    Two threads, five loops each, that makes 10\. However, we almost never get 10
    if we run this script. I ran it myself many times, and it seems to always hit
    somewhere between 5 and 7\. The reason this happens is that there is a race condition
    in this code, and those random sleeps I added are there to exacerbate it. If you
    removed them, there would still be a race condition, because the counter is increased
    in a non-atomic way (which means an operation that can be broken down in multiple
    steps, and therefore paused in between). However, the likelihood of that race
    condition showing is really low, so adding the random sleep helps.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印最终值时，我们期望计数器是10，对吧？两个线程，每个循环五次，这样就是10。然而，如果我们运行这个脚本，我们几乎永远不会得到10。我自己运行了很多次，似乎总是在5和7之间。发生这种情况的原因是这段代码中存在竞争条件，我添加的随机休眠是为了加剧这种情况。如果你删除它们，仍然会存在竞争条件，因为计数器的增加是非原子的（这意味着一个可以被分解成多个步骤的操作，因此在其中间可以暂停）。然而，竞争条件发生的可能性非常低，所以添加随机休眠有所帮助。
- en: Let's analyze the code. `t1` gets the current value of the counter, say, `3`.
    `t1` then sleeps for a moment. If the scheduler switches context in that moment,
    pausing `t1` and starting `t2`, `t2` will read the same value, `3`. Whatever happens
    afterward, we know that both threads will update the counter to be `4`, which
    will be incorrect as after two readings it should have gone up to `5`. Adding
    the second random sleep call, after the update, helps the scheduler switch more
    frequently, and makes it easier to show the race condition. Try commenting out
    one of them, and see how the result changes (it will do so, dramatically).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下代码。`t1`获取计数器的当前值，比如`3`。然后，`t1`暂停一会儿。如果调度程序在那一刻切换上下文，暂停`t1`并启动`t2`，`t2`将读取相同的值`3`。无论之后发生什么，我们知道两个线程都将更新计数器为`4`，这是不正确的，因为在两次读取后，它应该已经增加到`5`。在更新后添加第二个随机休眠调用有助于调度程序更频繁地切换，并且更容易显示竞争条件。尝试注释掉其中一个，看看结果如何改变（它会发生戏剧性的变化）。
- en: 'Now that we have identified the issue, let''s fix it by using a lock. The code
    is basically the same, so I''ll show you only what changes:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了问题，让我们通过使用锁来解决它。代码基本上是一样的，所以我只会向您展示发生了什么变化：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This time we have created a lock, from the `threading.Lock` class. We could
    call its `acquire` and `release` methods manually, or we can be Pythonic and use
    it within a context manager, which looks much nicer, and does the whole acquire/release
    business for us. Notice I left the random sleeps in the code. However, every time
    you run it, it will now return `10`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次我们创建了一个锁，来自`threading.Lock`类。我们可以手动调用它的`acquire`和`release`方法，或者我们可以使用上下文管理器在其中使用它，这看起来更好，而且可以为我们完成整个获取/释放的工作。请注意，我在代码中保留了随机休眠。然而，每次运行它，它现在会返回`10`。
- en: 'The difference is this: when the first thread acquires that lock, it doesn''t
    matter that when it''s sleeping, a moment later, the scheduler switches the context.
    The second thread will try to acquire the lock, and Python will answer with a
    resounding *no*. So, the second thread will just sit and wait until that lock
    is released. As soon as the scheduler switches back to the first thread, and the
    lock is released, then the other thread will have a chance (if it gets there first,
    which is not necessarily guaranteed), to acquire the lock and update the counter.
    Try adding some prints into that logic to see whether the threads alternate perfectly
    or not. My guess is that they won''t, at least not every time. Remember the `threading.current_thread`
    function, to be able to see which thread is actually printing the information.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于：当第一个线程获取该锁时，即使它在睡眠时，调度程序稍后切换上下文也无所谓。第二个线程将尝试获取锁，Python会坚决拒绝。因此，第二个线程将一直等待，直到锁被释放。一旦调度程序切换回第一个线程并释放锁，那么另一个线程将有机会（如果它首先到达那里，这并不一定保证）获取锁并更新计数器。尝试在该逻辑中添加一些打印，看看线程是否完美交替。我猜想它们不会，至少不是每次都会。记住`threading.current_thread`函数，以便能够看到哪个线程实际上打印了信息。
- en: 'Python offers several data structures in the `threading` module: Lock, RLock,
    Condition, Semaphore, Event, Timer, and Barrier. I won''t be able to show you
    all of them, because unfortunately I don''t have the room to explain all the use
    cases, but reading the documentation of the `threading` module ([https://docs.python.org/3.7/library/threading.html](https://docs.python.org/3.7/library/threading.html)) will
    be a good place to start understanding them.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Python在`threading`模块中提供了几种数据结构：Lock、RLock、Condition、Semaphore、Event、Timer和Barrier。我无法向您展示所有这些，因为不幸的是，我没有足够的空间来解释所有的用例，但阅读`threading`模块的文档（[https://docs.python.org/3.7/library/threading.html](https://docs.python.org/3.7/library/threading.html)）将是开始理解它们的好地方。
- en: Let's now see an example about thread's local data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个关于线程本地数据的例子。
- en: A thread's local data
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程的本地数据
- en: 'The `threading` module offers a way to implement local data for threads. Local
    data is an object that holds thread-specific data. Let me show you an example,
    and allow me to sneak in a `Barrier` too, so I can tell you how it works:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`threading`模块提供了一种为线程实现本地数据的方法。本地数据是一个保存特定于线程的数据的对象。让我给你展示一个例子，并且让我偷偷加入一个`Barrier`，这样我就可以告诉你它是如何工作的：'
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We start by defining `local`. That is the special object that holds thread-specific
    data. We run three threads. Each of them will assign a random value to `local.my_value`,
    and print it. Then the thread reaches a `Barrier` object, which is programmed
    to hold three threads in total. When the barrier is hit by the third thread, they
    all can pass. It's basically a nice way to make sure that *N* amount of threads
    reach a certain point and they all wait until every single one of them has arrived.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义`local`。这是保存特定于线程的数据的特殊对象。我们运行三个线程。它们中的每一个都将一个随机值赋给`local.my_value`，并将其打印出来。然后线程到达一个`Barrier`对象，它被编程为总共容纳三个线程。当第三个线程碰到屏障时，它们都可以通过。这基本上是一种确保*N*个线程达到某一点并且它们都等待，直到每一个都到达的好方法。
- en: 'Now, if `local` was a normal, dummy object, the second thread would override
    the value of `local.my_value`, and the third would do the same. This means that
    we would see them printing different values in the first set of prints, but they
    would show the same value (the last one) in the second round of prints. But that
    doesn''t happen, thanks to `local`. The output shows the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果`local`是一个普通的虚拟对象，第二个线程将覆盖`local.my_value`的值，第三个线程也会这样做。这意味着我们会看到它们在第一组打印中打印不同的值，但在第二组打印中它们将显示相同的值（最后一个）。但由于`local`的存在，这种情况不会发生。输出显示如下：
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice the wrong order, due to the scheduler switching context, but the values
    are all correct.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意错误的顺序，由于调度程序切换上下文，但所有值都是正确的。
- en: Thread and process communication
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程和进程通信
- en: We have seen quite a lot of examples so far. So, let's explore how to make threads
    and processes talk to one another by employing a queue. Let's start with threads.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了很多例子。所以，让我们探讨如何通过使用队列使线程和进程相互通信。让我们从线程开始。
- en: Thread communication
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程通信
- en: 'For this example, we will be using a normal `Queue`, from the `queue` module:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用`queue`模块中的普通`Queue`：
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The logic is very basic. We have a `producer` function that generates Fibonacci
    numbers and puts them in a queue. When the next number is greater than a given `n`,
    the producer exits the `while` loop, and puts one last thing in the queue: a `SENTINEL`.
    A `SENTINEL` is any object that is used to signal something, and in our case,
    it signals to the consumer that the producer is done.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑非常基本。我们有一个`producer`函数，它生成斐波那契数并将它们放入队列中。当下一个数字大于给定的`n`时，生产者退出`while`循环，并在队列中放入最后一件事：一个`SENTINEL`。`SENTINEL`是用来发出信号的任何对象，在我们的例子中，它向消费者发出信号，表示生产者已经完成。
- en: The interesting bit of logic is in the `consumer` function. It loops indefinitely,
    reading values out of the queue and printing them out. There are a couple of things
    to notice here. First, see how we are calling `q.task_done()`? That is to acknowledge
    that the element in the queue has been processed. The purpose of this is to allow
    the final instruction in the code, `q.join()`, to unblock when all elements have
    been acknowledged, so that the execution can end.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的逻辑部分在`consumer`函数中。它无限循环，从队列中读取值并将其打印出来。这里有几件事情需要注意。首先，看看我们如何调用`q.task_done()`？这是为了确认队列中的元素已被处理。这样做的目的是允许代码中的最后一条指令`q.join()`在所有元素都被确认时解除阻塞，以便执行可以结束。
- en: Second, notice how we use the `is` operator to compare against the items in
    order to find the sentinel. We'll see shortly that when using a `multiprocessing.Queue`
    this won't be possible any more. Before we get there, would you be able to guess
    why?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，注意我们如何使用`is`运算符来与项目进行比较，以找到哨兵。我们很快会看到，当使用`multiprocessing.Queue`时，这将不再可能。在我们到达那里之前，你能猜到为什么吗？
- en: Running this example produces a series of lines, such as `Got number 0`, `Got
    number 1`, and so on, until `34`, since the limit we put is `35`, and the next
    Fibonacci number would be `55`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个例子会产生一系列行，比如`Got number 0`，`Got number 1`，依此类推，直到`34`，因为我们设置的限制是`35`，下一个斐波那契数将是`55`。
- en: Sending events
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送事件
- en: 'Another way to make threads communicate is to fire events. Let me quickly show
    you an example of that:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使线程通信的方法是触发事件。让我快速给你展示一个例子：
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here we have two threads that run `fire` and `listen`, respectively firing
    and listening for an event. To fire an event, call the `set` method on it. The `t2` thread,
    which is started first, is already listening to the event, and will sit there
    until the event is fired. The output from the previous example is the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个线程分别运行`fire`和`listen`，分别触发和监听事件。要触发事件，调用`set`方法。首先启动的`t2`线程已经在监听事件，直到事件被触发。前面例子的输出如下：
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Events are great in some situations. Think about having threads that are waiting
    on a connection object to be ready, before they can actually start using it. They
    could be waiting on an event, and one thread could be checking that connection,
    and firing the event when it's ready. Events are fun to play with, so make sure
    you experiment and think about use cases for them.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，事件非常有用。想象一下，有一些线程正在等待连接对象准备就绪，然后才能开始使用它。它们可以等待事件，一个线程可以检查该连接，并在准备就绪时触发事件。事件很有趣，所以确保你进行实验，并考虑它们的用例。
- en: Inter-process communication with queues
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用队列进行进程间通信
- en: 'Let''s now see how to communicate between processes using a queue. This example
    is very very similar to the one for threads:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看如何使用队列在进程之间进行通信。这个例子非常类似于线程的例子：
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, in this case, we have to use a queue that is an instance of
    `multiprocessing.Queue`, which doesn't expose a `task_done` method. However, because
    of the way this queue is designed, it automatically joins the main thread, therefore
    we only need to start the two processes and all will work. The output of this
    example is the same as the one before.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这种情况下，我们必须使用`multiprocessing.Queue`的实例作为队列，它不公开`task_done`方法。但是，由于这个队列的设计方式，它会自动加入主线程，因此我们只需要启动两个进程，一切都会正常工作。这个示例的输出与之前的示例相同。
- en: When it comes to IPC, be careful. Objects are pickled when they enter the queue,
    so IDs get lost, and there are a few other subtle things to take care of. This
    is why in this example I can no longer use an object as a sentinel, and compare
    using `is`, like I did in the multi-threaded version. That sentinel object would
    be pickled in the queue (because this time the `Queue` comes from `multiprocessing`
    and not from `queue` like before), and would assume a new ID after unpickling,
    failing to compare correctly. The string `"STOP"` in this case does the trick,
    and it will be up to you to find a suitable value for a sentinel, which needs
    to be something that could never clash with any of the items that could be in
    the same queue. I leave it up to you to refer to the documentation, and learn
    as much as you can on this topic.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPC方面，要小心。对象在进入队列时被pickled，因此ID丢失，还有一些其他微妙的事情要注意。这就是为什么在这个示例中，我不能再使用对象作为sentinel，并使用`is`进行比较，就像我在多线程版本中所做的那样。这个sentinel对象将在队列中被pickled（因为这次`Queue`来自`multiprocessing`而不是之前的`queue`），并且在unpickling后会假定一个新的ID，无法正确比较。在这种情况下，字符串`"STOP"`就派上了用场，你需要找到一个适合的sentinel值，它需要是永远不会与队列中的任何项目发生冲突的值。我把这留给你去参考文档，并尽可能多地了解这个主题。
- en: Queues aren't the only way to communicate between processes. You can also use
    pipes (`multiprocessing.Pipe`), which provide a connection (as in, a pipe, clearly)
    from one process to another, and vice versa. You can find plenty of examples in
    the documentation; they aren't that different from what we've seen here.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 队列不是进程之间通信的唯一方式。您还可以使用管道（`multiprocessing.Pipe`），它提供了从一个进程到另一个进程的连接（显然是管道），反之亦然。您可以在文档中找到大量示例；它们与我们在这里看到的并没有太大的不同。
- en: Thread and process pools
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程和进程池
- en: As mentioned before, pools are structures designed to hold *N* objects (threads,
    processes, and so on). When the usage reaches capacity, no work is assigned to
    a thread (or process) until one of those currently working becomes available again.
    Pools, therefore, are a great way to limit the number of threads (or processes)
    that can be alive at the same time, preventing the system from starving due to
    resource exhaustion, or the computation time from being affected by too much context
    switching.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，池是设计用来保存*N*个对象（线程、进程等）的结构。当使用达到容量时，不会将工作分配给线程（或进程），直到其中一个当前正在工作的线程再次可用。因此，池是限制同时可以活动的线程（或进程）数量的绝佳方式，防止系统因资源耗尽而饥饿，或者计算时间受到过多的上下文切换的影响。
- en: In the following examples, I will be tapping into the `concurrent.futures` module
    to use the `ThreadPoolExecutor` and `ProcessPoolExecutor` executors. These two
    classes, use a pool of threads (and processes, respectively), to execute calls
    asynchronously. They both accept a parameter, `max_workers`, which sets the upper
    limit to how many threads (or processes) can be used at the same time by the executor.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我将利用`concurrent.futures`模块来使用`ThreadPoolExecutor`和`ProcessPoolExecutor`执行器。这两个类使用线程池（和进程池），以异步方式执行调用。它们都接受一个参数`max_workers`，它设置了执行器同时可以使用多少个线程（或进程）的上限。
- en: 'Let''s start from the multithreaded example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从多线程示例开始：
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After importing the necessary bits, we define the `run` function. It gets a
    random value, prints it, and returns it, along with the `name` argument it was
    called with. The interesting bit comes right after the function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入必要的部分之后，我们定义了`run`函数。它获取一个随机值，打印它，并返回它，以及它被调用时的`name`参数。有趣的部分就在函数之后。
- en: As you can see, we're using a context manager to call `ThreadPoolExecutor`,
    to which we pass `max_workers=3`, which means the pool size is `3`. This means
    only three threads at any time will be alive.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用上下文管理器调用`ThreadPoolExecutor`，我们传递`max_workers=3`，这意味着池大小为`3`。这意味着任何时候只有三个线程是活动的。
- en: We define a list of future objects by making a list comprehension, in which
    we call `submit` on our executor object. We instruct the executor to run the `run`
    function, with a name that will go from `T0` to `T4`. A `future` is an object
    that encapsulates the asynchronous execution of a callable.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用列表推导式定义了一个未来对象列表，在其中我们在执行器对象上调用`submit`。我们指示执行器运行`run`函数，名称将从`T0`到`T4`。`future`是一个封装可调用异步执行的对象。
- en: 'Then we loop over the `future` objects, as they are are done. To do this, we
    use `as_completed` to get an iterator of the `future` instances that returns them
    as soon as they complete (finish or were cancelled). We grab the result of each
    `future` by calling the homonymous method, and simply print it. Given that `run`
    returns a tuple `name`*,* `value`, we expect the result to be a two-tuple containing
    `name` and `value`. If we print the output of a `run` (bear in mind each `run`
    can potentially be slightly different), we get:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们循环遍历`future`对象，因为它们已经完成。为此，我们使用`as_completed`来获取`future`实例的迭代器，它们在完成（完成或被取消）时立即返回。我们通过调用同名方法来获取每个`future`的结果，并简单地打印它。鉴于`run`返回一个元组`name`，`value`，我们期望结果是包含`name`和`value`的两元组。如果我们打印`run`的输出（请记住每个`run`可能略有不同），我们会得到：
- en: '[PRE19]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Before reading on, can you tell why the output looks like this? Could you explain
    what happened? Spend a moment thinking about it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续阅读之前，你能告诉我为什么输出看起来像这样吗？你能解释发生了什么吗？花点时间思考一下。
- en: So, what goes on is that three threads start running, so we get three `Hi, I
    am...` messages printed out. Once all three of them are running, the pool is at
    capacity, so we need to wait for at least one thread to complete before anything
    else can happen. In the example run, `T0` and `T2` complete (which is signaled
    by the printing of what they returned), so they return to the pool and can be
    used again. They get run with names `T3` and `T4`, and finally all three, `T1`, `T3`,
    and `T4` complete. You can see from the output how the threads are actually reused,
    and how the first two are reassigned to `T3` and `T4` after they complete.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，发生的是三个线程开始运行，所以我们得到三个“嗨，我是…”消息被打印出来。一旦它们都在运行，池就满了，所以我们需要等待至少一个线程完成，然后才能发生其他事情。在示例运行中，T0和T2完成了（这是通过打印它们返回的内容来表示），所以它们返回到池中可以再次使用。它们被命名为T3和T4，并最终所有三个T1、T3和T4都完成了。您可以从输出中看到线程是如何被实际重用的，以及前两个在完成后如何被重新分配给T3和T4。
- en: 'Let''s now see the same example, but with the multiprocess design:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看相同的例子，但使用多进程设计：
- en: '[PRE20]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The difference is truly minimal. We use `ProcessPoolExecutor` this time, and
    the `run` function is exactly the same, with one small addition: we sleep for
    50 milliseconds at the beginning of each `run`. This is to exacerbate the behavior
    and have the output clearly show the size of the pool, which is still three. If
    we run the example, we get:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 差异真的是微乎其微。这次我们使用ProcessPoolExecutor，并且run函数完全相同，只是增加了一个小细节：在每次运行开始时我们休眠50毫秒。这是为了加剧行为并清楚地显示池的大小，仍然是三。如果我们运行示例，我们得到：
- en: '[PRE21]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This output clearly shows the pool size being three. It is very interesting
    to notice that if we remove that call to `sleep`, most of the time the output
    will have five prints of `Hi, I am...`, followed by five prints of `Process Px
    returned...`. How can we explain that? Well it's simple. By the time the first
    three processes are done, and returned by `as_completed`, all three are asked
    for their result, and whatever is returned, is printed. While this happens, the
    executor can already start recycling two processes to run the final two tasks,
    and they happen to print their `Hi, I am...` messages, before the prints in the
    `for` loop are allowed to take place.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出清楚地显示了池的大小为三。有趣的是，如果我们去掉对sleep的调用，大多数情况下输出将有五次打印“嗨，我是…”，然后是五次打印“进程Px返回…”。我们如何解释这个呢？很简单。当前三个进程完成并由as_completed返回时，所有三个都被要求返回它们的结果，无论返回什么，都会被打印出来。在这个过程中，执行器已经可以开始回收两个进程来运行最后两个任务，它们恰好在允许for循环中的打印发生之前打印它们的“嗨，我是…”消息。
- en: This basically means `ProcessPoolExecutor` is quite fast and aggressive (in
    terms of getting the scheduler's attention), and it's worth noting that this behavior
    doesn't happen with the thread counterpart, in which, if you recall, we didn't
    need to use any artificial sleeping.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上意味着ProcessPoolExecutor非常快速和积极（在获取调度程序的注意方面），值得注意的是，这种行为在线程对应的情况下不会发生，如果您还记得，我们不需要使用任何人为的睡眠。
- en: The important thing to keep in mind though, is being able to appreciate that
    even simple examples such as these can already be slightly tricky to understand
    or explain. Let this be a lesson to you, so that you raise your attention to 110%
    when you code for multithreaded or multiprocess designs.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要记住的重要事情是，即使是这样简单的例子，也可能稍微难以理解或解释。让这成为你的一课，这样你在为多线程或多进程设计编码时就能提高你的注意力到110%。
- en: Let's now move on to a more interesting example.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到一个更有趣的例子。
- en: Using a process to add a timeout to a function
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用一个过程为函数添加超时
- en: 'Most, if not all, libraries that expose functions to make HTTP requests, provide
    the ability to specify a timeout when performing the request. This means that
    if after *X* seconds (*X* being the timeout), the request hasn''t completed, the
    whole operation is aborted and execution resumes from the next instruction. Not
    all functions expose this feature though, so, when a function doesn''t provide
    the ability to being interrupted, we can use a process to simulate that behavior. In
    this example, we''ll be trying to translate a hostname into an IPv4 address. The `gethostbyname` function,
    from the `socket` module, doesn''t allow us to put a timeout on the operation
    though, so we use a process to do that artificially. The code that follows might
    not be so straightforward, so I encourage you to spend some time going through
    it before you read on for the explanation:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数，如果不是所有，公开函数以进行HTTP请求的库，在执行请求时提供指定超时的能力。这意味着如果在*X*秒后（*X*是超时时间），请求还没有完成，整个操作将被中止，并且执行将从下一条指令继续。不过，并非所有函数都提供这个功能，所以当一个函数没有提供中断的能力时，我们可以使用一个过程来模拟这种行为。在这个例子中，我们将尝试将主机名翻译成IPv4地址。然而，socket模块的gethostbyname函数不允许我们在操作上设置超时，所以我们使用一个过程来人为地实现。接下来的代码可能不那么直接，所以我鼓励您在阅读解释之前花一些时间去理解它：
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let's start from `resolve`. It simply takes a `hostname` and a `timeout`, and
    calls `resolve_host` with them. If the exit code is `0` (which means the process
    terminated correctly), it returns the IPv4 that corresponds to that host. Otherwise,
    it returns the `hostname` itself, as a fallback mechanism.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从resolve开始。它只是接受一个主机名和一个超时时间，并用它们调用resolve_host。如果退出代码是0（这意味着进程正确终止），它返回对应于该主机的IPv4。否则，它将主机名本身作为后备机制返回。
- en: Next, let's talk about `gethostbyname`. It takes a `hostname` and a `queue`,
    and calls `socket.gethostbyname` to resolve the `hostname`. When the result is
    available, it is put into the `queue`. Now, this is where the issue lies. If the
    call to `socket.gethostbyname` takes longer than the timeout we want to assign,
    we need to kill it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈gethostbyname。它接受一个主机名和一个队列，并调用socket.gethostbyname来解析主机名。当结果可用时，它被放入队列。现在问题就出在这里。如果对socket.gethostbyname的调用时间超过我们想要分配的超时时间，我们需要终止它。
- en: The `resolve_host` function does exactly this. It receives the `hostname` and
    the `timeout`, and, at first, it simply creates a `queue`. Then it spawns a new
    process that takes `gethostbyname` as the `target`, and passes the appropriate
    arguments. Then the process is started and joined on, but with a `timeout`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolve_host`函数正是这样做的。它接收`hostname`和`timeout`，起初只是创建一个`queue`。然后它生成一个以`gethostbyname`为`target`的新进程，并传递适当的参数。然后启动进程并加入，但带有一个`timeout`。'
- en: 'Now, the successful scenario is this: the call to `socket.gethostbyname` succeeds
    quickly, the IP is in the queue, the process terminates well before its timeout
    time, and when we get to the `if` part, the queue will not be empty. We fetch
    the IP from it, and return it, alongside the process exit code.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，成功的情况是这样的：对`socket.gethostbyname`的调用很快成功，IP在队列中，进程在超时时间之前成功终止，当我们到达`if`部分时，队列不会为空。我们从中获取IP，并返回它，以及进程退出代码。
- en: In the unsuccessful scenario, the call to `socket.gethostbyname` takes too long,
    and the process is killed after its `timeout` has expired. Because the call failed,
    no IP has been inserted in the `queue`, and therefore it will be empty. In the `if`
    logic, we therefore set the IP to `None`, and return as before. The `resolve`
    function will find that the exit code is not `0` (as the process didn't terminate
    happily, but was killed instead), and will correctly return the hostname instead
    of the IP, which we couldn't get anyway.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在失败的情况下，对`socket.gethostbyname`的调用时间太长，进程在超时后被终止。因为调用失败，没有IP被插入到队列中，因此队列将为空。在`if`逻辑中，我们将IP设置为`None`，并像以前一样返回。`resolve`函数会发现退出代码不是`0`（因为进程不是幸福地终止，而是被杀死），并且将正确地返回主机名而不是IP，我们无论如何都无法获取IP。
- en: In the source code of the book, in the `hostres` folder of this chapter, I have
    added some tests to make sure this behavior is actually correct. You can find
    instructions on how to run them in the `README.md` file in the folder. Make sure
    you check the test code too, it should be quite interesting.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的源代码中，在本章的`hostres`文件夹中，我添加了一些测试，以确保这种行为是正确的。你可以在文件夹中的`README.md`文件中找到如何运行它们的说明。确保你也检查一下测试代码，它应该会很有趣。
- en: Case examples
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例示例
- en: In this final part of the chapter, I am going to show you three case examples
    in which we'll see how to do the same thing by employing different approaches
    (single-thread, multithread, and multiprocess). Finally, I'll dedicate a few words
    to `asyncio`, a module that introduces yet another way of doing asynchronous programming
    in Python.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我将向你展示三个案例，我们将看到如何通过采用不同的方法（单线程、多线程和多进程）来做同样的事情。最后，我将专门介绍`asyncio`，这是一个在Python中引入另一种异步编程方式的模块。
- en: Example one – concurrent mergesort
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 例一 - 并发归并排序
- en: 'The first example will revolve around the mergesort algorithm. This sorting
    algorithm is based on the *divide et impera* (divide and conquer) design paradigm.
    The way it works is very simple. You have a list of numbers you want to sort.
    The first step is to divide the list into two parts, sort them, and merge the
    results back into one sorted list. Let me give you a simple example with six numbers.
    Imagine we have a list, `v=[8, 5, 3, 9, 0, 2]`. The first step would be to divide
    the list, `v`, into two sublists of three numbers: `v1=[8, 5, 3]` and `v2=[9,
    0, 2]`. Then we sort `v1` and `v2` by recursively calling mergesort on them. The
    result would be `v1=[3, 5, 8]` and `v2=[0, 2, 9]`. In order to combine `v1` and `v2`
    back into a sorted `v`, we simply consider the first item in both lists, and pick
    the minimum of those. The first iteration would compare `3` and `0`. We pick `0`,
    leaving `v2=[2, 9]`. Then we rinse and repeat: we compare `3` and `2`, we pick
    `2`, so now `v2=[9]`. Then we compare `3` and `9`. This time we pick `3`, leaving `v1=[5,
    8]`, and so on and so forth. Next we would pick `5` (`5` versus `9`), then `8`
    (`8` versus `9`), and finally `9`. This would give us a new, sorted version of `v`: `v=[0,
    2, 3, 5, 8, 9]`.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子将围绕归并排序算法展开。这种排序算法基于“分而治之”设计范式。它的工作方式非常简单。你有一个要排序的数字列表。第一步是将列表分成两部分，对它们进行排序，然后将结果合并成一个排序好的列表。让我用六个数字举个简单的例子。假设我们有一个列表，`v=[8,
    5, 3, 9, 0, 2]`。第一步是将列表`v`分成两个包含三个数字的子列表：`v1=[8, 5, 3]`和`v2=[9, 0, 2]`。然后我们通过递归调用归并排序对`v1`和`v2`进行排序。结果将是`v1=[3,
    5, 8]`和`v2=[0, 2, 9]`。为了将`v1`和`v2`合并成一个排序好的`v`，我们只需考虑两个列表中的第一个项目，并选择其中的最小值。第一次迭代会比较`3`和`0`。我们选择`0`，留下`v2=[2,
    9]`。然后我们重复这个过程：比较`3`和`2`，我们选择`2`，现在`v2=[9]`。然后我们比较`3`和`9`。这次我们选择`3`，留下`v1=[5,
    8]`，依此类推。接下来我们会选择`5`（`5`与`9`比较），然后选择`8`（`8`与`9`比较），最后选择`9`。这将给我们一个新的、排序好的`v`：`v=[0,
    2, 3, 5, 8, 9]`。
- en: The reason why I chose this algorithm as an example is twofold. First, it is
    easy to parallelize. You split the list in two, have two processes work on them,
    and then collect the results. Second, it is possible to amend the algorithm so
    that it splits the initial list into any *N ≥ 2*, and assigns those parts to *N*
    processes. Recombination is as simple as dealing with just two parts. This characteristic
    makes it a good candidate for a concurrent implementation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择这个算法作为例子的原因有两个。首先，它很容易并行化。你将列表分成两部分，让两个进程对它们进行处理，然后收集结果。其次，可以修改算法，使其将初始列表分成任意*N
    ≥ 2*，并将这些部分分配给*N*个进程。重新组合就像处理两个部分一样简单。这个特性使它成为并发实现的一个很好的候选。
- en: Single-thread mergesort
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单线程归并排序
- en: 'Let''s see how all this translates into code, starting by learning how to code
    our own homemade `mergesort`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看所有这些是如何转化为代码的，首先学习如何编写我们自己的自制`mergesort`：
- en: '[PRE23]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's start from the `sort` function. First we encounter the base of the recursion,
    which says that if the list has `0` or `1` elements, we don't need to sort it,
    we can simply return it as it is. If that is not the case, then we calculate the
    midpoint (`mid`), and recursively call sort on `v[:mid]` and `v[mid:]`. I hope
    you are by now very familiar with the slicing syntax, but just in case you need
    a refresher, the first one is all elements in `v` up to the `mid` index (excluded),
    and the second one is all elements from `mid` to the end. The results of sorting
    them are assigned respectively to `v1` and `v2`. Finally, we call `merge`, passing `v1`
    and `v2`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`sort`函数开始。首先，我们遇到递归的基础，它说如果列表有`0`或`1`个元素，我们不需要对其进行排序，我们可以直接返回它。如果不是这种情况，我们计算中点(`mid`)，并在`v[:mid]`和`v[mid:]`上递归调用sort。我希望你现在对切片语法非常熟悉，但以防万一你需要复习一下，第一个是`v`中到`mid`索引（不包括）的所有元素，第二个是从`mid`到末尾的所有元素。排序它们的结果分别分配给`v1`和`v2`。最后，我们调用`merge`，传递`v1`和`v2`。
- en: The logic of `merge` uses two pointers, `h` and `k`, to keep track of which
    elements in `v1` and `v2` we have already compared. If we find that the minimum
    is in `v1`, we append it to `v`, and increase `h`. On the other hand, if the minimum
    is in `v2`, we append it to `v` but increase `k` this time. The procedure is running
    in a `while` loop whose condition, combined with the inner `if`, makes sure we
    don't get errors due to indexes out of bounds. It's a pretty standard algorithm
    that you can find in many different variations on the web.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge`的逻辑使用两个指针`h`和`k`来跟踪我们已经比较了`v1`和`v2`中的哪些元素。如果我们发现最小值在`v1`中，我们将其附加到`v`，并增加`h`。另一方面，如果最小值在`v2`中，我们将其附加到`v`，但这次增加`k`。该过程在一个`while`循环中运行，其条件与内部的`if`结合在一起，确保我们不会因为索引超出范围而出现错误。这是一个非常标准的算法，在网上可以找到许多不同的变体。'
- en: In order to make sure this code is solid, I have written a test suite that resides
    in the `ch10/ms` folder. I encourage you to check it out.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这段代码是可靠的，我编写了一个测试套件，位于`ch10/ms`文件夹中。我鼓励你去看一下。
- en: Now that we have the building blocks, let's see how we modify this to make it
    so that it works with an arbitrary number of parts.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了构建模块，让我们看看如何修改它，使其能够处理任意数量的部分。
- en: Single-thread multipart mergesort
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单线程多部分归并排序
- en: 'The code for the multipart version of the algorithm is quite simple. We can
    reuse the `merge` function, but we''ll have to rewrite the `sort` one:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的多部分版本的代码非常简单。我们可以重用`merge`函数，但我们需要重新编写`sort`函数：
- en: '[PRE24]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We saw `reduce` in [Chapter 4](part0108.html#36VSO0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Functions, the Building Blocks of Code*, when we coded our own factorial function.
    The way it works within `multi_merge` is to merge the first two lists in `v`.
    Then the result is merged with the third one, after which the result is merged
    with the fourth one, and so on.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](part0108.html#36VSO0-2ddb708647cc4530a187c2c6c0e9acfe)中看到了`reduce`，*函数，代码的构建模块*，当我们编写我们自己的阶乘函数时。它在`multi_merge`中的工作方式是合并`v`中的前两个列表。然后将结果与第三个合并，之后将结果与第四个合并，依此类推。
- en: Take a look at the new version of `sort`. It takes the `v` list, and the number
    of parts we want to split it into. The first thing we do is check that we passed
    a correct number for `parts`, which needs to be at least two. Then, like before,
    we have the base of the recursion. And finally we get into the main logic of the
    function, which is simply a multipart version of the one we saw in the previous
    example. We calculate the length of each `chunk` using the `max` function, just
    in case there are fewer elements in the list than parts. And then we write a generator
    expression that calls `sort` recursively on each `chunk`. Finally, we merge all
    the results by calling `multi_merge`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`sort`的新版本。它接受`v`列表和我们想要将其分割成的部分数。我们首先检查我们传递了一个正确的`parts`数，它至少需要是两个。然后，就像以前一样，我们有递归的基础。最后，我们进入函数的主要逻辑，这只是前一个例子中看到的逻辑的多部分版本。我们使用`max`函数计算每个`chunk`的长度，以防列表中的元素少于部分数。然后，我们编写一个生成器表达式，对每个`chunk`递归调用`sort`。最后，我们通过调用`multi_merge`合并所有的结果。
- en: I am aware that in explaining this code, I haven't been as exhaustive as I usually
    am, and I'm afraid it is on purpose. The example that comes after the mergesort
    will be much more complex, so I would like to encourage you to really try to understand
    the previous two snippets as thoroughly as you can.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我意识到在解释这段代码时，我没有像我通常那样详尽，我担心这是有意的。在归并排序之后的例子将会更加复杂，所以我想鼓励你尽可能彻底地理解前两个片段。
- en: 'Now, let''s take this example to the next step: multithreading.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个例子推进到下一步：多线程。
- en: Multithreaded mergesort
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程归并排序
- en: 'In this example, we amend the `sort` function once again, so that, after the
    initial division into chunks, it spawns a thread per part. Each thread uses the
    single-threaded version of the algorithm to sort its part, and then at the end
    we use the multi-merge technique to calculate the final result. Translating into
    Python:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们再次修改`sort`函数，这样，在初始分成块之后，它会为每个部分生成一个线程。每个线程使用单线程版本的算法来对其部分进行排序，然后最后我们使用多重归并技术来计算最终结果。翻译成Python：
- en: '[PRE25]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We import all the required tools, including executors, the `ceiling` function,
    and `sort` and `merge` from the single-threaded version of the algorithm. Notice
    how I changed the name of the single-threaded `sort` into `_sort` upon importing
    it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入所有必需的工具，包括执行器、`ceiling`函数，以及从单线程版本的算法中导入的`sort`和`merge`。请注意，我在导入时将单线程的`sort`的名称更改为`_sort`。
- en: In this version of `sort`, we check whether `v` is empty first, and if not we
    proceed. We calculate the dimension of each `chunk` using the `ceil` function.
    It's basically doing what we were doing with `max` in the previous snippet, but
    I wanted to show you another way to solve the issue.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的`sort`中，我们首先检查`v`是否为空，如果不是，我们继续。我们使用`ceil`函数计算每个`chunk`的维度。它基本上做的是我们在前面片段中使用`max`的事情，但我想向你展示另一种解决问题的方法。
- en: 'When we have the dimension, we calculate the `chunks` and prepare a nice generator
    expression to serve them to the executor. The rest is straightforward: we define
    a list of future objects, each of which is the result of calling `submit` on the
    executor. Each future object runs the single-threaded `_sort` algorithm on the
    `chunk` it has been assigned to.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有了维度，我们计算`chunks`并准备一个漂亮的生成器表达式来将它们提供给执行器。其余部分很简单：我们定义了一个未来对象列表，每个未来对象都是在执行器上调用`submit`的结果。每个未来对象在分配给它的`chunk`上运行单线程的`_sort`算法。
- en: Finally as they are returned by the `as_completed` function, the results are
    merged using the same technique we saw in the earlier multipart example.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当它们被`as_completed`函数返回时，结果将使用我们在之前的多部分示例中看到的相同技术进行合并。
- en: Multiprocess mergesort
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多进程归并排序
- en: 'To perform the final step, we need to amend only two lines in the previous
    code. If you have paid attention in the introductory examples, you will know which
    of the two lines I am referring to. In order to save some space, I''ll just give
    you the diff of the code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行最后一步，我们只需要修改前面代码中的两行。如果你在介绍性的例子中注意到了，你会知道我指的是哪两行。为了节省一些空间，我只会给你代码的差异：
- en: '[PRE26]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That's it! Basically all you have to do is use `ProcessPoolExecutor` instead
    of `ThreadPoolExecutor`, and instead of spawning threads, you are spawning processes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！你所要做的就是使用`ProcessPoolExecutor`而不是`ThreadPoolExecutor`，而不是生成线程，你正在生成进程。
- en: 'Do you recall when I was saying that processes can actually run on different
    cores, while threads run within the same process so they are not actually running
    in parallel? This is a good example to show you a consequence of choosing one
    approach or the other. Because the code is CPU-intensive, and there is no IO going
    on, splitting the list and having threads working the chunks doesn''t add any
    advantage. On the other hand, using processes does. I have run some performance
    tests (run the `ch10/ms/performance.py` module by yourself and you will see how
    your machine performs) and the results prove my expectations:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我说过进程实际上可以在不同的核心上运行，而线程在同一个进程中运行，因此它们实际上并不是并行运行吗？这是一个很好的例子，向你展示选择其中一种方法的后果。因为代码是CPU密集型的，没有进行IO操作，分割列表并让线程处理块并没有任何优势。另一方面，使用进程有优势。我进行了一些性能测试（自己运行`ch10/ms/performance.py`模块，你会看到你的机器的性能如何），结果证明了我的期望：
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The two tests are run on two lists of 100,000 and 500,000 items, respectively.
    And I am using four workers for the multithreaded and multiprocessing versions.
    Using different sizes is quite useful when looking for patterns. As you can see,
    the time elapsed is basically the same for the first two versions (single-threaded,
    and multithreaded), but they are reduced by about 50% for the multiprocessing
    version. It's slightly more than 50% because having to spawn processes, and handle
    them, comes at a price. But still, you can definitely appreciate that I have a
    processor with two cores on my machine.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个测试分别在两个包含10万和50万个项目的列表上运行。我为多线程和多进程版本使用了四个工作进程。在寻找模式时，使用不同的大小非常有用。正如你所看到的，前两个版本（单线程和多线程）的时间消耗基本相同，但在多进程版本中减少了约50%。这略高于50%，因为生成进程并处理它们是有代价的。但是，你肯定会欣赏到我在我的机器上有一个有两个内核的处理器。
- en: This also tells you that even though I used four workers in the multiprocessing
    version, I can still only parallelize proportionately to the amount of cores my
    processor has. Therefore, two or more workers makes very little difference.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这也告诉你，即使我在多进程版本中使用了四个工作进程，我仍然只能按比例并行化我的处理器核心数量。因此，两个或更多的工作进程几乎没有什么区别。
- en: Now that you are all warmed up, let's move on to the next example.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经热身了，让我们继续下一个例子。
- en: Example two – batch sudoku-solver
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二个例子 - 批量数独求解器
- en: In this example, we are going to explore a sudoku-solver. We are not going to
    go into much detail with it, as the point is not that of understanding how to
    solve sudoku, but rather to show you how to use multi-processing to solve a batch
    of sudoku puzzles.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将探索一个数独求解器。我们不会详细讨论它，因为重点不是理解如何解决数独，而是向你展示如何使用多进程来解决一批数独谜题。
- en: What is interesting in this example, is that instead of making the comparison
    between single and multithreaded versions again, we're going to skip that and
    compare the single-threaded version with two different multiprocess versions.
    One will assign one puzzle per worker, so if we solve 1,000 puzzles, we'll use
    1,000 workers (well, we will use a pool of *N* workers, each of which is constantly
    recycled). The other version will instead divide the initial batch of puzzles
    by the pool size, and batch-solve each chunk within one process. This means, assuming
    a pool size of four, dividing those 1,000 puzzles into chunks of 250 puzzles each,
    and giving each chunk to one worker, for a total of four of them.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中有趣的是，我们不再比较单线程和多线程版本，而是跳过这一点，将单线程版本与两个不同的多进程版本进行比较。一个将分配一个谜题给每个工作进程，所以如果我们解决了1,000个谜题，我们将使用1,000个工作进程（好吧，我们将使用一个*
    N *工作进程池，每个工作进程都在不断回收）。另一个版本将把初始批次的谜题按照池的大小进行划分，并在一个进程内批量解决每个块。这意味着，假设池的大小为四，将这1,000个谜题分成每个250个谜题的块，并将每个块分配给一个工作进程，总共有四个工作进程。
- en: The code I will present to you for the sudoku-solver (without the multiprocessing
    part), comes from a solution designed by Peter Norvig, which has been distributed
    under the MIT license. His solution is so efficient that, after trying to re-implement
    my own for a few days, and getting to the same result, I simply gave up and decided
    to go with his design. I did do a lot of refactoring though, because I wasn't
    happy with his choice of function and variable names, so I made those more *book
    friendly*, so to speak. You can find the original code, a link to the original
    page from which I got it, and the original MIT license, in the `ch10/sudoku/norvig`
    folder. If you follow the link, you'll find a very thorough explanation of the
    sudoku-solver by Norvig himself.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向您展示数独求解器的代码（不包括多进程部分），这是由Peter Norvig设计的解决方案，根据MIT许可证进行分发。他的解决方案非常高效，以至于在尝试重新实现自己的解决方案几天后，得到了相同的结果，我简单地放弃了并决定采用他的设计。不过，我进行了大量的重构，因为我对他选择的函数和变量名不满意，所以我将它们更改为更符合书本风格的名称。您可以在`ch10/sudoku/norvig`文件夹中找到原始代码、获取原始页面的链接以及原始的MIT许可证。如果您跟随链接，您将找到Norvig本人对数独求解器的非常详尽的解释。
- en: What is Sudoku?
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是数独？
- en: First things first. What is a sudoku puzzle? Sudoku is a number-placement puzzle
    based on logic that originated in Japan. The objective is to fill a *9x9* grid
    with digits so that each row, column, and box (*3x3* subgrids that compose the
    grid) contains all of the digits from *1* to *9*. You start from a partially populated
    grid, and add number after number using logic considerations.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 首先来看看。什么是数独谜题？数独是一种基于逻辑的数字填充谜题，起源于日本。目标是用数字填充*9x9*网格，使得每行、每列和每个*3x3*子网格（组成网格的子网格）都包含从*1*到*9*的所有数字。您从一个部分填充的网格开始，然后根据逻辑考虑逐渐添加数字。
- en: Sudoku can be interpreted, from a computer science perspective, as a problem
    that fits in the *exact cover* category. Donald Knuth, the author of *The Art
    of Computer Programming* (and many other wonderful books), has devised an algorithm,
    called **Algorithm X**, to solve problems in this category. A beautiful and efficient
    implementation of Algorithm X, called **Dancing Links**, which harnesses the power
    of circular doubly-linked lists, can be used to solve sudoku. The beauty of this
    approach is that all it requires is a mapping between the structure of the sudoku,
    and the Dancing Links algorithm, and without having to do any of the logic deductions
    normally needed to solve the puzzle, it gets to the solution at the speed of light.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 从计算机科学的角度来看，数独可以被解释为一个适合*exact cover*类别的问题。唐纳德·克努斯，*计算机编程艺术*的作者（以及许多其他精彩的书籍），设计了一个算法，称为**Algorithm
    X**，用于解决这一类问题。一种名为**Dancing Links**的美丽而高效的Algorithm X实现，利用了循环双向链表的强大功能，可以用来解决数独。这种方法的美妙之处在于，它只需要数独的结构与Dancing
    Links算法之间的映射，而无需进行通常需要解决难题的逻辑推断，就能以光速到达解决方案。
- en: Many years ago, when my free time was a number greater than zero, I wrote a
    Dancing Links sudoku-solver in C#, which I still have archived somewhere, which
    was great fun to design and code. I definitely encourage you to check out the
    literature and code your own solver, it's a great exercise, if you can spare the
    time.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 许多年前，当我的空闲时间大于零时，我用C#编写了一个Dancing Links数独求解器，我仍然在某个地方存档着，设计和编码过程非常有趣。我绝对鼓励您查阅相关文献并编写自己的求解器，如果您有时间的话，这是一个很好的练习。
- en: In this example's solution though, we're going to use a **search** algorithm
    used in conjunction with a process that, in artificial intelligence, is known
    as **constraint propagation**. The two are quite commonly used together to make
    a problem simpler to solve. We'll see that in our example, they are enough for
    us to be able to solve a difficult sudoku in a matter of milliseconds.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例的解决方案中，我们将使用与人工智能中的**约束传播**相结合的**搜索**算法。这两种方法通常一起使用，使问题更容易解决。我们将看到在我们的例子中，它们足以让我们在几毫秒内解决一个困难的数独。
- en: Implementing a sudoku-solver in Python
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中实现数独求解器
- en: 'Let''s now explore my refactored implementation of the solver. I''m going to
    present the code to you in steps, as it is quite involved (also, I won''t repeat
    the source name at the top of each snippet, until I move to another module):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来探索我重构后的求解器实现。我将分步向您展示代码，因为它非常复杂（而且在每个片段的顶部我不会重复源名称，直到我转移到另一个模块）：
- en: '[PRE28]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We start with some imports, and then we define a couple of useful functions: `cross_product`
    and `chunk`. They do exactly what the names hint at. The first one returns the
    cross-product between two iterables, while the second one returns a list of chunks
    from `iterable`, each of which has `n` elements, and the last of which might be
    padded with a given `fillvalue`, should the length of `iterable` not be a multiple
    of `n`. Then we proceed to define a few structures, which will be used by the
    solver:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一些导入开始，然后定义了一些有用的函数：`cross_product`和`chunk`。它们确实做了名称所暗示的事情。第一个函数返回两个可迭代对象之间的叉积，而第二个函数返回`iterable`的一系列块，每个块都有`n`个元素，最后一个块可能会用给定的`fillvalue`填充，如果`iterable`的长度不是`n`的倍数。然后我们继续定义一些结构，这些结构将被求解器使用：
- en: '[PRE29]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Without going too much into detail, let's hover over these objects. `squares`
    is a list of all squares in the grid. Squares are represented by a string such
    as *A3* or *C7*. Rows are numbered with letters, and columns with numbers, so *A3*
    will indicate the square in the first row, and third column.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 不详细展开，让我们简单介绍一下这些对象。`squares`是网格中所有方块的列表。方块由诸如*A3*或*C7*之类的字符串表示。行用字母编号，列用数字编号，因此*A3*表示第一行第三列的方块。
- en: '`all_units` is a list of all possible rows, columns, and blocks. Each of those
    elements is represented as a list of the squares that belong to the row/column/block. `units`
    is a more complex structure. It is a dictionary with 81 keys. Each key represents
    a square, and the corresponding value is a list with three elements in it: a row,
    a column, and a block. Of course, those are the row, column, and block that the
    square belongs to.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`all_units`是所有可能的行、列和块的列表。每个元素都表示为属于行/列/块的方格的列表。`units`是一个更复杂的结构。它是一个有81个键的字典。每个键代表一个方格，相应的值是一个包含三个元素的列表：行、列和块。当然，这些是方格所属的行、列和块。'
- en: Finally, `peers` is a dictionary very similar to `units`, but the value of each
    key (which still represents a square), is a set containing all peers for that
    square. Peers are defined as all the squares belonging to the row, column, and
    block the square in the key belongs to. These structures will be used in the calculation
    of the solution, when attempting to solve a puzzle.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`peers`是一个与`units`非常相似的字典，但每个键的值（仍然表示一个方格）是一个包含该方格的所有对等方格的集合。对等方格被定义为属于键中的方格所属的行、列和块的所有方格。这些结构将在解决谜题时用于计算解决方案。
- en: 'Before we take a look at the function that parses the input lines, let me give
    you an example of what an input puzzle looks like:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看一下解析输入行的函数之前，让我给你一个输入谜题的例子：
- en: '[PRE30]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The first nine characters represent the first row, then another nine for the
    second row, and so on. Empty squares are represented by dots:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 前九个字符代表第一行，然后另外九个代表第二行，依此类推。空方格用点表示：
- en: '[PRE31]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This simple `parse_puzzle` function is used to parse an input puzzle. We do
    a little bit of sanity checking at the beginning, asserting that the input puzzle
    has to shrink into a set that is a subset of the set of all numbers plus a dot.
    Then we make sure we have `81` input characters, and finally we define `grid`,
    which initially is simply a dictionary with `81` keys, each of which is a square,
    all with the same value, which is a string of all possible digits. This is because
    a square in a completely empty grid has the potential to become any number from
    1 to 9.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的`parse_puzzle`函数用于解析输入的谜题。我们在开始时进行了一些合理性检查，断言输入的谜题必须缩小为所有数字加一个点的子集。然后我们确保有81个输入字符，最后我们定义了`grid`，最初它只是一个有81个键的字典，每个键都是一个方格，都具有相同的值，即所有可能数字的字符串。这是因为在完全空的网格中，一个方格有潜力成为1到9之间的任何数字。
- en: The `for` loop is definitely the most interesting part. We parse each of the
    81 characters in the input puzzle, coupling them with the corresponding square
    in the grid, and we try to *"place"* them. I put that in double quotes because,
    as we'll see in a moment, the `place` function does much more than simply setting
    a given number in a given square. If we find that we cannot place a digit from
    the input puzzle, it means the input is invalid, and we return `False`. Otherwise,
    we're good to go and we return the `grid`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环绝对是最有趣的部分。我们解析输入谜题中的每个81个字符，将它们与网格中相应的方格相结合，并尝试“放置”它们。我用双引号括起来，因为正如我们将在一会儿看到的，`place`函数做的远不止简单地在给定的方格中设置一个给定的数字。如果我们发现无法在输入谜题中放置一个数字，这意味着输入无效，我们返回`False`。否则，我们可以继续并返回`grid`。'
- en: '`parse_puzzle` is used in the `solve` function, which simply parses the input
    puzzle, and unleashes `search` on it. What follows is therefore the heart of the
    algorithm:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_puzzle`函数用于`solve`函数中，它简单地解析输入的谜题，并在其上释放`search`。因此，接下来的内容是算法的核心：'
- en: '[PRE32]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This simple function first checks whether the grid is actually non-empty. Then
    it tries to see whether the grid is solved. A solved grid will have one value
    per square. If that is not the case, it loops through each square and finds the
    square with the minimum amount of candidates. If a square has a string value of
    only one digit, it means a number has been placed in that square. But if the value
    is more than one digit, then those are possible candidates, so we need to find
    the square with the minimum amount of candidates, and try them. Trying a square
    with `23` candidates is much better than trying one with `23589`. In the first
    case, we have a 50% chance of getting the right value, while in the second one,
    we only have 20%. Choosing the square with the minimum amount of candidates therefore
    maximizes the chances for us to place good numbers in the grid.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的函数首先检查网格是否真的非空。然后它尝试查看网格是否已解决。已解决的网格将每个方格都有一个值。如果不是这种情况，它会循环遍历每个方格，并找到具有最少候选项的方格。如果一个方格的字符串值只有一个数字，这意味着一个数字已经放在了那个方格中。但如果值超过一个数字，那么这些就是可能的候选项，所以我们需要找到具有最少候选项的方格，并尝试它们。尝试一个有23个候选项的方格要比尝试一个有23589个候选项的方格好得多。在第一种情况下，我们有50%的机会得到正确的值，而在第二种情况下，我们只有20%。选择具有最少候选项的方格因此最大化了我们在网格中放置好数字的机会。
- en: 'Once the candidates have been found, we try them in order and if any of them
    results in being successful, we have solved the grid and we return. You might
    have noticed the use of the `place` function in the search too. So let''s explore
    its code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到候选项，我们按顺序尝试它们，如果其中任何一个成功，我们就解决了网格并返回。您可能已经注意到在搜索中使用了`place`函数。因此，让我们来探索它的代码：
- en: '[PRE33]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This function takes a work-in-progress grid, and tries to place a given digit
    in a given square. As I mentioned before, *"placing"* is not that straightforward.
    In fact, when we place a number, we have to propagate the consequences of that
    action throughout the grid. We do that by calling the `eliminate` function, which
    applies two strategies of the sudoku game:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个正在进行中的网格，并尝试在给定的方格中放置一个给定的数字。正如我之前提到的，*“放置”*并不那么简单。事实上，当我们放置一个数字时，我们必须在整个网格中传播该行为的后果。我们通过调用`eliminate`函数来做到这一点，该函数应用数独游戏的两种策略：
- en: If a square has only one possible value, eliminate that value from the square's
    peers
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个方格只有一个可能的值，就从该方格的对等方格中消除该值
- en: If a unit has only one place for a value, place the value there
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个单元只有一个值的位置，就把值放在那里
- en: Let me briefly offer an example of both points. For the first one, if you place,
    say, number 7 in a square, then you can eliminate 7 from the list of candidates
    for all the squares that belong to the row, column, and block that square belongs
    to.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我简要地举个例子。对于第一个点，如果你在一个方块中放入数字7，那么你可以从属于该行、列和块的所有方块的候选数字列表中删除7。
- en: For the second point, say you're examining the fourth row and, of all the squares
    that belong to it, only one of them has number 7 in its candidates. This means
    that number 7 can only go in that precise square, so you should go ahead and place
    it there.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二点，假设你正在检查第四行，而属于它的所有方块中，只有一个方块的候选数字中有数字7。这意味着数字7只能放在那个确切的方块中，所以你应该继续把它放在那里。
- en: 'The following function, `eliminate`, applies these two rules. Its code is quite
    involved, so instead of going line by line and offering an excruciating explanation,
    I have added some comments, and will leave you with the task of understanding
    it:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的函数`eliminate`应用了这两条规则。它的代码相当复杂，所以我没有逐行解释，而是添加了一些注释，留给你去理解：
- en: '[PRE34]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The rest of the functions in the module aren't important for the rest of this
    example, so I will skip them. You can run this module by itself; it will first
    perform a series of checks on its data structures, and then it will solve all
    the sudoku puzzles I have placed in the `sudoku/puzzles` folder. But that is not
    what we're interested in, right? We want to see how to solve sudoku using multiprocessing
    techniques, so let's get to it.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 模块中的其他函数对于本例来说并不重要，所以我会跳过它们。你可以单独运行这个模块；它首先对其数据结构进行一系列检查，然后解决我放在`sudoku/puzzles`文件夹中的所有数独难题。但这不是我们感兴趣的，对吧？我们想要看看如何使用多进程技术解决数独，所以让我们开始吧。
- en: Solving sudoku with multiprocessing
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多进程解决数独
- en: 'In this module, we''re going to implement three functions. The first one simply
    solves a batch of sudoku puzzles, with no multiprocessing involved. We will use
    the results for benchmarking. The second and the third ones will use multiprocessing,
    with and without batch-solving, so we can appreciate the differences. Let''s start:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模块中，我们将实现三个函数。第一个函数简单地解决一批数独难题，没有涉及多进程。我们将使用结果进行基准测试。第二个和第三个函数将使用多进程，一个是批量解决，一个是非批量解决，这样我们可以欣赏到它们之间的差异。让我们开始吧：
- en: '[PRE35]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After a long list of imports, we define a context manager that we''re going
    to use as a timer device. It takes a reference to the current time (`t`), and
    then it yields. After having yielded, that''s when the body of the managed context
    is executed. Finally, on exiting the managed context, we calculate `tot`, which
    is the total amount of time elapsed, and print it. It''s a simple and elegant
    context manager written with the decoration technique, and it''s super fun. Let''s
    now see the three functions I mentioned earlier:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一长串的导入后，我们定义了一个上下文管理器，我们将用它作为计时器。它获取当前时间的引用（`t`），然后进行yield。在yield之后，才执行上下文管理器的主体。最后，在退出上下文管理器时，我们计算总共经过的时间`tot`，并打印出来。这是一个简单而优雅的上下文管理器，使用了装饰技术编写，非常有趣。现在让我们看看前面提到的三个函数：
- en: '[PRE36]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This one is a single-threaded simple batch solver, which will give us a time
    to compare against. It simply returns a list of all solved grids. Boring. Now,
    check out the following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个单线程的简单批量求解器，它将给我们一个用于比较的时间。它只是返回所有已解决的网格的列表。无聊。现在，看看下面的代码：
- en: '[PRE37]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This one is much better. It uses `ProcessPoolExecutor` to use a pool of `workers`,
    each of which is used to solve roughly one-fourth of the puzzles. This is because
    we are spawning one future object per puzzle. The logic is extremely similar to
    any multiprocessing example we have already seen in the chapter. Let''s see the
    third function:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数好多了。它使用`ProcessPoolExecutor`来使用一个`workers`池，每个池用于解决大约四分之一的难题。这是因为我们为每个难题生成一个`future`对象。逻辑与本章中已经看到的任何多进程示例非常相似。现在让我们看看第三个函数：
- en: '[PRE38]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This last function is slightly different. Instead of spawning one `future` object
    per puzzle, it splits the total list of puzzles into `workers` chunks, and then
    creates one `future` object per chunk. This means that if `workers` is eight,
    we're going to spawn eight `future` objects. Notice that instead of passing `solve`
    to `executor.submit`, we're passing `batch_solve`, which does the trick. The reason
    why I coded the last two functions so differently is because I was curious to
    see the severity of the impact of the overhead we incur into when we recycle processes
    from a pool a non-negligible amount of times.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数略有不同。它不是为每个难题生成一个`future`对象，而是将所有难题的列表分成`workers`块，然后为每一块创建一个`future`对象。这意味着如果`workers`为八，我们将生成八个`future`对象。请注意，我们不是将`solve`传递给`executor.submit`，而是传递`batch_solve`，这就是诀窍所在。我之所以编写最后两个函数如此不同，是因为我很好奇我们从池中重复使用进程时所产生的开销的严重程度。
- en: 'Now that we have the functions defined, let''s use them:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了这些函数，让我们使用它们：
- en: '[PRE39]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We use a set of 234 very hard sudoku puzzles for this benchmarking session.
    As you can see, we simply run the three functions, `batch_solve`, `parallel_single_solver`,
    and `parallel_batch_solver`, all within a timed context. We collect the results,
    and, just to make sure, we verify that all the runs have produced the same results.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一组234个非常难的数独难题进行基准测试。正如你所看到的，我们只是在一个计时上下文中运行了三个函数，`batch_solve`，`parallel_single_solver`和`parallel_batch_solver`。我们收集结果，并且为了确保，我们验证所有运行是否产生了相同的结果。
- en: 'Of course, in the second and third runs, we have used multiprocessing, so we
    cannot guarantee that the order in the results will be the same as that of the
    single-threaded `batch_solve`. This minor issue is brilliantly solved with the
    aid of `assertCountEqual`, one of the worst-named methods in the Python standard
    library. We find it in the `TestCase` class, which we can instantiate just to
    take a reference to the method we need. We''re not actually running unit tests,
    but this is a cool trick, and I wanted to show it to you. Let''s see the output
    of running this module:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在第二次和第三次运行中，我们使用了多进程，所以我们不能保证结果的顺序与单线程`batch_solve`的顺序相同。这个小问题通过`assertCountEqual`得到了很好的解决，这是Python标准库中命名最糟糕的方法之一。我们可以在`TestCase`类中找到它，我们可以实例化它来引用我们需要的方法。我们实际上并没有运行单元测试，但这是一个很酷的技巧，我想向你展示一下。让我们看看运行这个模块的输出：
- en: '[PRE40]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Wow. That is quite interesting. First of all, you can once again see that my
    machine has a two-core processor, as the time elapsed for the multiprocessing
    runs is about half the time taken by the single-threaded solver. However, what
    is actually much more interesting is the fact that there is basically no difference
    in the time taken by the two multiprocessing functions. Multiple runs sometimes
    end in favor of one approach, and sometimes in favor of the other. Understanding
    why requires a deep understanding of all the components that are taking part in
    the game, not just the processes, and therefore is not something we can discuss
    here. It is fairly safe to say though, that the two approaches are comparable
    in terms of performance.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 哇。这非常有趣。首先，你可以再次看到我的机器有一个双核处理器，因为多进程运行的时间大约是单线程求解器所花时间的一半。然而，更有趣的是，两个多进程函数所花费的时间基本上没有区别。多次运行有时候会偏向一种方法，有时候会偏向另一种方法。要理解原因需要对参与游戏的所有组件有深入的了解，而不仅仅是进程，因此这不是我们可以在这里讨论的事情。不过，可以相当肯定的是，这两种方法在性能方面是可比较的。
- en: In the source code for the book, you can find tests in the `sudoku` folder,
    with instructions on how to run them. Take the time to check them out!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的源代码中，你可以在`sudoku`文件夹中找到测试，并附有运行说明。花点时间去查看一下吧！
- en: And now, let's get to the final example.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看最后一个例子。
- en: Example three – downloading random pictures
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三个例子 - 下载随机图片
- en: 'This example has been fun to code. We are going to download random pictures
    from a website. I''ll show you three versions: a serial one, a multiprocessing
    one, and finally a solution coded using `asyncio`. In these examples, we are going
    to use a website called [http://lorempixel.com](http://lorempixel.com/), which
    provides you with an API that you can call to get random images. If you find that
    the website is down or slow, you can use an excellent alternative to it: [https://lorempizza.com/](https://lorempizza.com/).'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子编写起来很有趣。我们将从网站上下载随机图片。我会向你展示三个版本：一个串行版本，一个多进程版本，最后一个使用`asyncio`编写的解决方案。在这些例子中，我们将使用一个名为[http://lorempixel.com](http://lorempixel.com/)的网站，它提供了一个API，你可以调用它来获取随机图片。如果你发现该网站宕机或运行缓慢，你可以使用一个很好的替代网站：[https://lorempizza.com/](https://lorempizza.com/)。
- en: It may be something of a *cliché* for a book written by an Italian, but the
    pictures are gorgeous. You can search for another alternative on the web, if you
    want to have some fun. Whatever website you choose, please be sensible and try
    not to hammer it by making a million requests to it. The multiprocessing and `asyncio`
    versions of this code can be quite aggressive!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个意大利人写的书的陈词滥调，但图片确实很漂亮。如果你想玩得开心，可以在网上寻找其他选择。无论你选择哪个网站，请理智一点，尽量不要通过发出一百万个请求来使其崩溃。这段代码的多进程和`asyncio`版本可能会相当激进！
- en: 'Let''s start by exploring the single-threaded version of the code:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来探索单线程版本的代码：
- en: '[PRE41]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This code should be straightforward to you by now. We define a `download` function,
    which makes a request to the given `URL`, saves the result by calling `save_image`,
    and feeds it the body of the response from the website. Saving the image is very
    simple: we create a random filename with `token_hex`, just because it''s fun,
    then we calculate the full path of the file, create it in binary mode, and write
    into it the content of the response. We return the `filename` to be able to print
    it on screen. Finally `batch_download` simply runs the `n` requests we want to
    run and returns the filenames as a result.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这段代码对你来说应该很简单了。我们定义了一个`download`函数，它向给定的`URL`发出请求，通过调用`save_image`保存结果，并将来自网站响应的主体传递给它。保存图片非常简单：我们使用`token_hex`创建一个随机文件名，只是因为这样很有趣，然后计算文件的完整路径，以二进制模式创建文件，并将响应的内容写入其中。我们返回`filename`以便在屏幕上打印它。最后，`batch_download`只是运行我们想要运行的`n`个请求，并将文件名作为结果返回。
- en: 'You can leapfrog the `if __name__ ...` line for now, it will be explained in
    [Chapter 12](part0305.html#92RRI0-2ddb708647cc4530a187c2c6c0e9acfe),* GUIs and
    Scripts* and it''s not important here. All we do is call `batch_download` with
    the URL and we tell it to download `10` images. If you have an editor, open the `pics`
    folder, and you can see it getting populated in a few seconds (also notice: the
    script assumes the `pics` folder exists).'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以跳过`if __name__ ...`这一行，它将在[第12章](part0305.html#92RRI0-2ddb708647cc4530a187c2c6c0e9acfe)中解释，*GUIs
    and Scripts*，这里并不重要。我们所做的就是调用`batch_download`并告诉它下载`10`张图片。如果你有编辑器，打开`pics`文件夹，你会看到它在几秒钟内被填充（还要注意：脚本假设`pics`文件夹存在）。
- en: 'Let''s spice things up a bit. Let''s introduce multiprocessing (the code is
    vastly similar, so I will not repeat it):'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加点料。让我们引入多进程（代码基本相似，所以我就不重复了）：
- en: '[PRE42]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The technique should be familiar to you by now. We simply submit jobs to the
    executor, and collect the results as they become available. Because this is IO
    bound code, the processes work quite fast and there is heavy context-switching
    while the processes are waiting for the API response. If you have a view over
    the `pics` folder, you will notice that it's not getting populated in a linear
    fashion any more, but rather, in batches.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术现在对你来说应该很熟悉。我们只是将作业提交给执行器，并在结果可用时收集它们。因为这是IO绑定的代码，所以进程工作得相当快，而在进程等待API响应时，有大量的上下文切换。如果你查看`pics`文件夹，你会注意到它不再是线性地填充，而是分批次地填充。
- en: Let's now look at the `asyncio` version of this example.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这个例子的`asyncio`版本。
- en: Downloading random pictures with asyncio
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用asyncio下载随机图片
- en: The code is probably the most challenging of the whole chapter, so don't feel
    bad if it is too much for you at this moment in time. I have added this example
    just as a mouthwatering device, to encourage you to dig deeper into the heart
    of Python asynchronous programming. Another thing worth knowing is that there
    are probably several other ways to write this same logic, so please bear in mind
    that this is just one of the possible examples.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能是整个章节中最具挑战性的，所以如果此刻对你来说太多了，不要感到难过。我添加了这个例子，只是作为一种引人入胜的手段，鼓励你深入了解Python异步编程的核心。另一个值得知道的是，可能有几种其他编写相同逻辑的方式，所以请记住，这只是可能的例子之一。
- en: 'The `asyncio` module provides infrastructure for writing single-threaded, concurrent
    code using coroutines, multiplexing IO access over sockets and other resources,
    running network clients and servers, and other related primitives. It was added
    to Python in version 3.4, and some claim it will become the *de facto* standard
    for writing Python code in the future. I don''t know whether that''s true, but
    I know it is definitely worth seeing an example:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`模块提供了基础设施，用于使用协程编写单线程并发代码，多路复用IO访问套接字和其他资源，运行网络客户端和服务器，以及其他相关原语。它在Python
    3.4版本中添加，有人声称它将成为未来编写Python代码的*事实*标准。我不知道这是否属实，但我知道它绝对值得看一个例子：'
- en: '[PRE43]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'First of all, we cannot use `requests` any more, as it is not suitable for
    `asyncio`. We have to use `aiohttp`, so please make sure you have installed it
    (it''s in the requirements for the book):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们不能再使用`requests`，因为它不适用于`asyncio`。我们必须使用`aiohttp`，所以请确保你已经安装了它（它在这本书的要求中）：
- en: '[PRE44]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The previous code does not look too friendly, but it's not so bad, once you
    know the concepts behind it. We define the async coroutine `download_image`, which
    takes a URL as parameter.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码看起来不太友好，但一旦你了解了背后的概念，就不会那么糟糕。我们定义了异步协程`download_image`，它以URL作为参数。
- en: In case you don't know, a coroutine is a computer program component that generalizes
    subroutines for non-preemptive multitasking, by allowing multiple entry points
    for suspending and resuming execution at certain locations. A subroutine is a
    sequence of program instructions that performs a specific task, packaged as a
    unit.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道，协程是一种计算机程序组件，它通过允许在特定位置挂起和恢复执行来概括非抢占式多任务处理的子例程。子例程是作为一个单元打包的执行特定任务的程序指令序列。
- en: Inside `download_image`, we create a session object using the `ClientSession`
    context manager, and then we get the response by using another context manager,
    this time from `session.get`. The fact that these managers are defined as asynchronous
    simply means that they are able to suspend execution in their enter and exit methods.
    We return the content of the response by using the `await` keyword, which allows
    suspension. Notice that creating a session for each request is not optimal, but
    I felt that for the purpose of this example I would keep the code as straightforward
    as possible, so I leave its optimization to you, as an exercise.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在`download_image`中，我们使用`ClientSession`上下文管理器创建一个会话对象，然后通过使用另一个上下文管理器`session.get`获取响应。这些管理器被定义为异步的事实意味着它们能够在它们的`enter`和`exit`方法中暂停执行。我们使用`await`关键字返回响应的内容，这允许暂停。请注意，为每个请求创建一个会话并不是最佳的，但是为了这个例子的目的，我觉得保持代码尽可能简单，所以将其优化留给你作为一个练习。
- en: 'Let''s proceed with the next snippet:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一个片段：
- en: '[PRE45]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Another coroutine, `download`, gets a `URL` and a `semaphore`. All it does is
    fetch the content of the image, by calling `download_image`, saving it, and returning
    the `filename`. The interesting bit here is the use of that `semaphore`. We use
    it as an asynchronous context manager, so that we can suspend this coroutine as
    well, and allow a switch to something else, but more than *how*, it is important
    to understand *why* we want to use a `semaphore`. The reason is simple, this `semaphore`
    is kind of the equivalent of a pool of threads. We use it to allow at most *N*
    coroutines to be active at the same time. We instantiate it in the next function,
    and we pass 10 as the initial value. Every time a coroutine acquires the `semaphore`,
    its internal counter is decreased by `1`, therefore when 10 coroutines have acquired
    it, the next one will sit and wait, until the semaphore is released by a coroutine
    that has completed. This is a nice way to try to limit how aggressively we are
    fetching images from the website API.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个协程`download`获取一个`URL`和一个`信号量`。它所做的就是获取图像的内容，通过调用`download_image`保存它，并返回`文件名`。这里有趣的地方是使用了`信号量`。我们将其用作异步上下文管理器，以便我们也可以暂停这个协程，并允许切换到其他东西，但更重要的不是*如何*，而是理解*为什么*我们要使用`信号量`。原因很简单，这个`信号量`有点类似于线程池。我们使用它来允许最多*N*个协程同时活动。我们在下一个函数中实例化它，并将10作为初始值传递。每当一个协程获取`信号量`时，它的内部计数器就会减少`1`，因此当有10个协程获取它时，下一个协程将会等待，直到`信号量`被一个已经完成的协程释放。这是一个不错的方式，试图限制我们从网站API中获取图像的侵略性。
- en: 'The `save_image` function is not a coroutine, and its logic has already been
    discussed in the previous examples. Let''s now get to the part of the code where
    execution takes place:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`save_image`函数不是一个协程，它的逻辑已经在之前的例子中讨论过。现在让我们来到执行代码的部分：'
- en: '[PRE46]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We define the `batch_download` function, which takes a number, `images`, and
    the URL of where to fetch them. The first thing it does is create an event loop,
    which is necessary to run any asynchronous code. The event loop is the central
    execution device provided by `asyncio`. It provides multiple facilities, including:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`batch_download`函数，它接受一个数字`images`和要获取它们的URL。它做的第一件事是创建一个事件循环，这是运行任何异步代码所必需的。事件循环是`asyncio`提供的中央执行设备。它提供了多种设施，包括：
- en: Registering, executing, and cancelling delayed calls (timeouts)
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册、执行和取消延迟调用（超时）
- en: Creating client and server transports for various kinds of communication
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为各种通信创建客户端和服务器传输
- en: Launching subprocesses and the associated transports for communication with
    an external program
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动子进程和与外部程序通信的相关传输
- en: Delegating costly function calls to a pool of threads
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将昂贵的函数调用委托给线程池
- en: After the event loop is created, we instantiate the semaphore, and then we proceed
    to create a list of futures, `cors`. By calling `loop.run_until_complete`, we
    make sure the event loop will run until the whole task has been completed. We
    feed it the result of a call to `asyncio.wait`, which waits for the futures to
    complete.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环创建后，我们实例化信号量，然后继续创建一个期货列表`cors`。通过调用`loop.run_until_complete`，我们确保事件循环将一直运行，直到整个任务完成。我们将其喂给`asyncio.wait`的调用结果，它等待期货完成。
- en: When done, we close the event loop, and return a list of the results yielded
    by each future object (the filenames of the saved images). Notice how we capture
    the results of the call to `loop.run_until_complete`. We don't really care for
    the errors, so we assign `_` to the second item in the tuple. This is a common
    Python idiom used when we want to signal that we're not interested in that object.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们关闭事件循环，并返回每个期货对象产生的结果列表（保存图像的文件名）。请注意我们如何捕获对`loop.run_until_complete`的调用结果。我们并不真正关心错误，所以我们将第二个元组项赋值为`_`。这是一个常见的Python习惯用法，用于表明我们对该对象不感兴趣。
- en: At the end of the module, we call `batch_download` and we get 20 images saved.
    They come in batches, and the whole process is limited by a semaphore with only
    10 available spots.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块的最后，我们调用`batch_download`，并保存了20张图片。它们分批次到达，整个过程受到只有10个可用位置的信号量的限制。
- en: And that's it! To learn more about `asyncio`, please refer to the documentation
    page ([https://docs.python.org/3.7/library/asyncio.html](https://docs.python.org/3.7/library/asyncio.html))
    for the `asyncio` module on the standard library. This example was fun to code,
    and hopefully it will motivate you to study hard and understand the intricacies
    of this wonderful side of Python.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！要了解更多关于`asyncio`的信息，请参阅标准库中`asyncio`模块的文档页面（[https://docs.python.org/3.7/library/asyncio.html](https://docs.python.org/3.7/library/asyncio.html)）。这个例子编码起来很有趣，希望它能激励你努力学习并理解Python这一美妙的一面的复杂性。
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we learned about concurrency and parallelism. We saw how threads
    and processes help in achieving one and the other. We explored the nature of threads
    and the issues that they expose us to: race conditions and deadlocks.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了并发和并行。我们看到了线程和进程如何帮助实现其中的一个和另一个。我们探讨了线程的性质以及它们暴露给我们的问题：竞争条件和死锁。
- en: We learned how to solve those issues by using locks and careful resource management.
    We also learned how to make threads communicate and share data, and we talked
    about the scheduler, which is that part of the operating system that decides which
    thread will run at any given time. We then moved to processes, and explored a
    bunch of their properties and characteristics.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了如何通过使用锁和谨慎的资源管理来解决这些问题。我们还学会了如何使线程通信和共享数据，并讨论了调度程序，即操作系统决定任何给定时间运行哪个线程的部分。然后我们转向进程，并探讨了它们的一些属性和特征。
- en: Following the initial theoretical part, we learned how to implement threads
    and processes in Python. We dealt with multiple threads and processes, fixed race
    conditions, and learned workarounds to stop threads without leaving any resource
    open by mistake. We also explored IPC, and used queues to exchange messages between
    processes and threads. We also played with events and barriers, which are some
    of the tools provided by the standard library to control the flow of execution
    in a non-deterministic environment.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初的理论部分之后，我们学会了如何在Python中实现线程和进程。我们处理了多个线程和进程，解决了竞争条件，并学会了防止线程错误地留下任何资源的解决方法。我们还探讨了IPC，并使用队列在进程和线程之间交换消息。我们还使用了事件和屏障，这些是标准库提供的一些工具，用于在非确定性环境中控制执行流程。
- en: 'After all these introductory examples, we deep dived into three case examples,
    which showed how to solve the same problem using different approaches: single-thread,
    multithread, multiprocess, and `asyncio`.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些介绍性示例之后，我们深入研究了三个案例示例，展示了如何使用不同的方法解决相同的问题：单线程、多线程、多进程和`asyncio`。
- en: We learned about mergesort and how, in general, *divide and conquer* algorithms
    are easy to parallelize.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了归并排序以及通常*分而治之*算法易于并行化。
- en: We learned about sudoku, and explored a nice solution that uses a little bit
    of artificial intelligence to run an efficient algorithm, which we then ran in
    different serial and parallel modes.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了关于数独，并探讨了一种使用少量人工智能来运行高效算法的好方法，然后我们以不同的串行和并行模式运行了它。
- en: Finally, we saw how to download random pictures from a website, using serial,
    multiprocess, and `asyncio` code. The latter was by far the hardest piece of code
    in the whole book, and its presence in the chapter serves as a reminder, or some
    sort of milestone that will encourage the reader to learn Python well, and deeply.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了如何使用串行、多进程和`asyncio`代码从网站上下载随机图片。后者无疑是整本书中最难的代码，它在本章中的存在是作为一种提醒，或者一种里程碑，鼓励读者深入学习Python。
- en: Now we'll move on to much simpler, and mostly project-oriented chapters, where
    we get a taste of different real-world applications in different contexts.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将转向更简单的、大多数是项目导向的章节，我们将在不同的背景下尝试不同的真实世界应用。
