- en: Chapter 4. Data Structures and Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 数据结构和算法
- en: 'Data structures are the building blocks to solve programming problems. They
    provide organization for the data, and algorithms provide the logic to carve the
    perfect solution. Python provides many efficient built-in data structures that
    can be used effectively. There are other good data-structure implementations in
    the standard library as well as third-party libraries. Often, the more pressing
    question is when to use what, or what data-structure is good for the present problem
    description. To resolve this, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是解决编程问题的基石。它们为数据提供组织，算法提供解决问题的逻辑。Python 提供了许多高效的内建数据结构，可以有效地使用。标准库以及第三方库中也有其他优秀的数据结构实现。通常，更紧迫的问题是何时使用什么，或者哪种数据结构适合当前的问题描述。为了解决这个问题，我们将涵盖以下主题：
- en: Python data structures
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 数据结构
- en: Python library data structures
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 库数据结构
- en: Third-party data structures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方数据结构
- en: Algorithms on scale
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规模算法
- en: Python built-in data structures
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 内置数据结构
- en: '**Key 1: Understanding Python''s in-built data structure.**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键点 1：理解 Python 的内置数据结构。**'
- en: 'Before going in on how to use different data structures, we should take a look
    at the attributes of the object that are important for built-in data structures.
    For the default sorting to work, the object should have one of the `__lt__`, and
    `__gt__` methods defined. Otherwise, we can pass a key function to the sorting
    method to use in getting the intermediate keys that are used to compare it, as
    shown in the following code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨如何使用不同的数据结构之前，我们应该先看看对于内置数据结构来说重要的对象属性。为了默认排序能够工作，对象应该定义了`__lt__`和`__gt__`方法之一。否则，我们可以传递一个键函数给排序方法，以使用在获取用于比较的中间键，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Whether two objects are equal in value is defined by the output of the `__eq__`
    method. Collections have the same value if they have the same length and the same
    value of all items, as shown in the following code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 两个对象在值上是否相等由`__eq__`方法的输出定义。如果集合具有相同的长度和所有项相同的值，则它们具有相同的值，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Hash function maps a larger value set to the smaller hash set. Hence, two different
    objects can have the same hash, but objects with a different hash must be different.
    In other words, equal value objects should have the same hash, and objects with
    a different hash must have different values for hash to be meaningful. When we
    define `__eq__` in a class, we must define a hash function as well. By default,
    for user class instances, hash uses the ID of the object, as shown in the following
    code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数将较大的值集映射到较小的哈希集。因此，两个不同的对象可以有相同的哈希值，但具有不同哈希值的对象必须不同。换句话说，具有相等值的对象应该有相同的哈希值，而具有不同哈希值的对象必须有不同的值，以便哈希才有意义。当我们在一个类中定义`__eq__`时，我们也必须定义一个哈希函数。默认情况下，对于用户类实例，哈希使用对象的
    ID，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It can be seen that mutable objects do not have hash defined. Although this
    is not advised, we can, however, do so in our user defined classes:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，可变对象没有定义哈希。尽管这不被建议，但我们仍然可以在我们的用户定义类中这样做：
- en: '**Tuples**: These are immutable lists, slice operations are *O(n)*, retrieval
    is *O(n)*, and they have small memory requirements. They are normally used to
    group objects of different types in a single structure, such as C language structures,
    where the position is fixed for particular types of information, shown as follows:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元组**：这些是不可变列表，切片操作是*O(n)*，检索是*O(n)*，并且它们有较小的内存需求。它们通常用于在单个结构中组合不同类型的对象，例如
    C 语言结构，其中特定类型的信息位置是固定的，如下所示：'
- en: '[PRE6]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Named tuples that are available from the collections module can be used to
    access values with object notation, as follows:'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 collections 模块可用的命名元组可以用来使用对象表示法访问值，如下所示：
- en: '[PRE7]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Lists** : These are mutable data structures that are similar to tuples. They
    are good to collect objects of similar types. When analyzing their time-complexity,
    we see that insert, delete, slice, and copy operations require *O(n)*, Retrieval
    require len *O(1)*, and sort requires *O(nlogn)*. Lists are implemented as dynamic
    arrays. It must resize to double of its previous on increase in size greater than
    current capacity. Insert and delete at the front of the list takes more time as
    it must move all references to other elements one by one:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表**：这些是类似于元组的可变数据结构，适合收集类似类型的对象。在分析它们的时间复杂度时，我们看到插入、删除、切片和复制操作需要 *O(n)*，检索需要len
    *O(1)*，排序需要 *O(nlogn)*。列表作为动态数组实现。当大小增加超过当前容量时，它必须将其大小加倍。在列表前面插入和删除需要更多时间，因为它必须逐个移动其他元素的引用：'
- en: '[PRE8]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Dictionary**: These are mutable mappings. A key can be any hashable object.
    Getting a value for key, setting a value for a key, and deleting a key are all
    *O(1)*, and copying is *O(n)*:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字典**：这些是可以变动的映射。键可以是任何可哈希的对象。获取键的值、为键设置值和删除键都是 *O(1)*，复制是 *O(n)*：'
- en: '[PRE9]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Sets**: These can be thought as of groups of items where hash is used to
    retrieve items. Sets have methods to check union, and intersection, which is useful
    rather than checking the same with lists. Let''s take an example of groups of
    animals, as follows:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合**：这些可以被视为使用哈希检索项目的项目组。集合有检查并集和交集的方法，这比使用列表检查更方便。以下是一个动物组的例子：'
- en: '[PRE10]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Their implementation and time-complexity is very similar to dictionary, shown
    as follows:'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它们的实现和时间复杂度与字典非常相似，如下所示：
- en: '[PRE11]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Python library data structures
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python库数据结构
- en: '**Key 2: Using Python''s** **standard library data structures.**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键2：使用Python的标准库数据结构。**'
- en: '**collections.deque**: The collections module have a `deque` implementation.
    Deque is useful for the scenarios where item insertion and deletion occurs at
    both ends of structure as it has efficient inserts at the start of structure as
    well. Time-complexity is similar to copy *O(n)*, insert—*O(1)*, and delete—*O(n)*.
    The following graph shows an insert at 0 position operation comparison between
    list and deque:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**collections.deque**：collections模块有一个`deque`实现。当结构两端都需要进行项目插入和删除时，deque非常有用，因为它在结构开始处的插入效率很高。时间复杂度类似于复制
    *O(n)*，插入—*O(1)*，删除—*O(n)*。以下图表显示了列表和deque在0位置插入操作的比较：'
- en: '[PRE12]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following image is the graphical representation of the preceding code:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下图像是前面代码的图形表示：
- en: '![Python library data structures](img/B04885_04_02.jpg)'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Python库数据结构](img/B04885_04_02.jpg)'
- en: '**PriorityQueue**: A standard library queue module has implementations for
    multiproducer, and multiconsumer queues. We can simplify and reuse its `PriorityQueue`
    for simpler cases using the `heapq` module, as follows:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先队列**：标准库队列模块有多个生产者和多个消费者队列的实现。我们可以使用`heapq`模块简化并重用其`PriorityQueue`，如下所示：'
- en: '[PRE13]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Other than these, queue modules have `threadsafe`, `LifoQueue`, `PriorityQueue`,
    `queue`, `deque` implementations. Also, lists can be used as stacks or queues.
    Collections also have `orderedDict`, which remembers the sequence of elements.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，队列模块有`threadsafe`、`LifoQueue`、`PriorityQueue`、`queue`、`deque`的实现。此外，列表也可以用作栈或队列。集合也有`orderedDict`，它可以记住元素的顺序。
- en: Third party data structures
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方数据结构
- en: '**Key 3: Using third-party data structures.**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键3：使用第三方数据结构。**'
- en: 'Python has a good bunch of data structures in the core language/library. But
    sometimes, an application has very specific requirements. We can always use third-party
    data-structure packages. Most of such modules are Python wrapper over C, C++ implementations:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Python在核心语言/库中有许多数据结构。但有时，一个应用程序有非常具体的要求。我们总是可以使用第三方数据结构包。这些模块中的大多数都是Python对C、C++实现的封装：
- en: The `blist` module provides a drop-in replacement for list, `sortedList`, and
    `sortedset`. It is discussed in greater detail in later chapters.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blist`模块提供了对列表、`sortedList`和`sortedset`的即插即用替换。在后面的章节中将有更详细的讨论。'
- en: The `bintrees` module provides binary, AVL tree, and Red-Black trees.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bintrees`模块提供了二叉树、AVL树和红黑树。'
- en: The `banyan` module provides Red-Black trees, splay tree, and sorted lists.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`banyan`模块提供了红黑树、伸展树和有序列表。'
- en: The `Sortedcontainers` module provides `SortedList`, `SortedDict`, and `SortedSet`.
    So, one can get almost every data structure for Python easily. More stress should
    be given on why one data structure is better than another for a use case.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sortedcontainers`模块提供了`SortedList`、`SortedDict`和`SortedSet`。因此，可以轻松地获得Python的几乎所有数据结构。应该更多地关注为什么某个数据结构在特定用例中比另一个更好。'
- en: Arrays/List
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组/列表
- en: For numeric calculations involving math, NumPy arrays should be considered.
    They are fast, memory-efficient, and provide many vector and matrix operations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及数学计算的数值计算，应考虑使用NumPy数组。它们速度快，内存高效，并提供许多矢量和矩阵操作。
- en: Binary tree
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二叉树
- en: Trees have better worst-case insertion/removal, *O(log(n))*, min/max, and look-ups
    than dictionaries. There are several implementations that are available.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 树在插入/删除、最小/最大值和查找方面比字典有更好的最坏情况性能，*O(log(n))*，并且有几种可用的实现。
- en: 'One module is `bintrees`, which have C implementations that are available for
    Red-Black trees, AVL tree, and Binary trees. For example, in Red-Black trees,
    it is easy to find max, and min, ranges as shown in the following example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块是`bintrees`，它有C实现，可用于红黑树、AVL树和二叉树。例如，在红黑树中，很容易找到最大值和最小值范围，如下面的示例所示：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Sorted containers
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序容器
- en: 'These are pure-Python modules having `SortedList`, `SortedSet`, and `SortedDict`
    Data structures, which can keep the keys/items sorted. The `SortedContainers`
    module claims to have speed comparable to C extensions modules, shown as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是纯Python模块，具有`SortedList`、`SortedSet`和`SortedDict`数据结构，可以保持键/项的排序。`SortedContainers`模块声称其速度与C扩展模块相当，如下所示：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Trie
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Trie
- en: This is an ordered-tree data-structure, where the position in the tree defines
    the key. The keys are normally strings. In comparison to dictionaries, it has
    faster worst-case data retrieval *O(m)*. Hash functions are not needed. If we
    are using strings only to be stored in the keys, it can take a lot less space
    then dictionary.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有序树数据结构，其中树中的位置定义了键。键通常是字符串。与字典相比，它具有更快的最坏情况数据检索速度 *O(m)*。不需要哈希函数。如果我们只使用字符串作为键进行存储，那么它可能比字典占用更少的空间。
- en: '![Trie](img/B04885_04_01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![Trie](img/B04885_04_01.jpg)'
- en: 'In Python, we have the `marisa-trie` package that provides this functionality
    as static Data structures. It is a Cython wrapper over the C++ library. We can
    associate values with the keys as well. It also provides memory mapped I/O, which
    is useful to decrease memory usage on cost of speed. The `datrie` is another package
    that provides read-write tries, The following are some basic usage of these libraries:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们有`marisa-trie`包，它提供这种功能作为静态数据结构。它是一个C++库的Cython包装器。我们还可以将值与键关联起来。它还提供了内存映射I/O，这有助于减少内存使用，但可能会牺牲速度。`datrie`是另一个提供读写Trie的包。以下是一些这些库的基本用法：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Algorithms on scale
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规模算法
- en: '**Key 4: Thinking out-of-the-box for the algorithms.**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键4：为算法跳出思维定势。**'
- en: 'An algorithm is how we solve a problem. The most common issue of not being
    able to solve the problem is to not being able to define it properly. Normally,
    we look to apply an algorithm only at a small level, such as in a small functionality,
    or sorting in a function. We, however, do not think about algorithms when the
    scale increases, mostly the stress is on how fast it is. Let''s take a simple
    requirement of sorting a file and sending it to a user. If the file is, let''s
    say 10-20 KB or so, it will be best to simply use the Python sorted function to
    sort the entries. In the following code, the file is of format where columns are
    ID, name, due, and due-date. We want to sort it based on dues, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 算法是我们解决问题的方法。无法解决问题的最常见问题是无法正确定义它。通常，我们只在较小范围内应用算法，例如在小的功能中或在一个函数中的排序。然而，当规模增加时，我们并没有考虑算法，主要关注的是速度。让我们以一个简单的需求为例，即对文件进行排序并将其发送给用户。如果文件大小为10-20
    KB左右，最好简单地使用Python的sorted函数对条目进行排序。在下面的代码中，文件格式为列ID、名称、到期日和到期日期。我们希望根据到期日进行排序，如下所示：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This works great, but as the file increases in size, the memory requirement
    increases. We cannot load all contents in the memory at the same time. Hence,
    we can use external merge-sort to divide the file into small parts, sort them,
    and then merge the sorted results together. In the following code, we used `heapq.merge`
    to merge iterators:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这效果很好，但随着文件大小的增加，内存需求也会增加。我们无法同时将所有内容加载到内存中。因此，我们可以使用外部归并排序将文件分成小块，对它们进行排序，然后将排序后的结果合并在一起。在以下代码中，我们使用了`heapq.merge`来合并迭代器：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once we use up memory of a single computer, or have files distributed over
    multiple computers in a network, the file-based algorithm will not work. We will
    need to sort incoming streams from upstream servers, and send the sorted stream
    to the downstream. If we look at the following code carefully, we will see that
    we have not changed the underlying mechanism. We are still using `heapq.merge`
    to merge elements, but now, we are getting elements from the network instead.
    The following client code is simple, it just starts sending sorted lines by lines
    on receive of the next command from a downstream server:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们用完单个计算机的内存，或者在网络中的多台计算机上分布文件，基于文件的算法将无法工作。我们需要对来自上游服务器的传入流进行排序，并将排序后的流发送到下游。如果我们仔细查看以下代码，我们会发现我们没有改变底层机制。我们仍然使用`heapq.merge`来合并元素，但现在，我们从网络中获取元素。以下客户端代码很简单，它只是在接收到来自下游服务器的下一个命令后，逐行开始发送排序后的行：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the server code, the `ClientConn` class abstracts away network operations
    and provides an iterator interface to `heapq.merge`. We can greatly enhance the
    code using buffering. Here, the `get_next` method gets new line from the client.
    Simple abstraction solved a great problem:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器代码中，`ClientConn`类抽象了网络操作，并为`heapq.merge`提供了一个迭代器接口。我们可以通过缓冲区来大大增强代码。在这里，`get_next`方法从客户端获取新行。简单的抽象解决了大问题：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Summary
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the data structures that are available in
    the Python standard library and some third-party libraries, which are extremely
    useful for everyday programming. Knowledge of data-structure usage is very much
    important in choosing right tool for the job. Choosing of an algorithm is highly
    application-specific, and we should always try to find out a solution that is
    simpler to read.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Python标准库和一些第三方库中可用的数据结构，这些数据结构对于日常编程非常有用。了解数据结构的使用对于选择合适的工具至关重要。算法的选择高度依赖于具体的应用，我们应该总是试图找到一个更易于阅读的解决方案。
- en: In the next chapter, we will cover design patterns that provide great help in
    writing elegant solutions to the problems.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一些设计模式，这些模式在编写优雅的解决方案时提供了极大的帮助。
