- en: Chapter 2. Writing Modifiable and Readable Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。编写可修改和可读的代码
- en: In the first chapter, we discussed the various aspects of software architecture,
    and covered some definitions of the terms involved. We looked at the different
    aspects of software architecture that an architect should be concerned with. Towards
    the end of the chapter, we discussed the various architectural quality attributes
    that an architect should focus on when building a system. We went in some detail
    into each of these attributes, looked at some definitions, and also various concerns
    that should be kept in mind when architecting a system for achieving these attributes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们讨论了软件架构的各个方面，并介绍了涉及的术语的一些定义。我们看了架构师应该关注的软件架构的不同方面。在章末，我们讨论了在构建系统时架构师应该关注的各种架构质量属性。我们详细讨论了每个属性，看了一些定义，以及在构建系统以实现这些属性时应该牢记的各种关注点。
- en: From this chapter onwards, we will focus on each of these quality attributes
    one by one, and discuss them in detail, per chapter. We will delve deep into an
    attribute—such as its various factors, techniques to achieve it, aspects to keep
    in mind when programming towards it, and so on. Since our focus in this book is
    on Python and its ecosystem, we will also look at various code examples and third-party
    software support that Python provides for achieving and maintaining these quality
    attributes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将逐一关注这些质量属性，并逐章详细讨论它们。我们将深入研究一个属性，比如它的各种因素、实现它的技术、在编程时要牢记的方面等等。由于本书的重点是Python及其生态系统，我们还将查看Python为实现和维护这些质量属性提供的各种代码示例和第三方软件支持。
- en: The focus of this chapter is on the quality attribute of Modifiability.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点关注可修改性的质量属性。
- en: What is modifiability?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是可修改性？
- en: 'The architectural quality attribute of Modifiability can be defined as:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 可修改性的架构质量属性可以定义为：
- en: '*Modifiability is the degree of ease at which changes can be made to a system,
    and the flexibility with which the system adapts to such changes.*'
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*可修改性是指系统可以轻松进行更改的程度，以及系统适应这些更改的灵活性。*'
- en: We discussed various aspects of modifiability in the first chapter, such as
    **cohesion**, **coupling**, and others. We will dig a little bit deeper into these
    aspects in this chapter with some examples. However, before we dig deeper, it
    might be a good idea to take a look at the big picture of how modifiability fits
    in with the other quality attributes that are related to it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一章中讨论了可修改性的各个方面，如**内聚**、**耦合**等。在本章中，我们将通过一些示例更深入地挖掘这些方面。然而，在深入研究之前，看一看可修改性如何与其他与之相关的质量属性相互关联可能是个好主意。
- en: Aspects related to Modifiability
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与可修改性相关的方面
- en: 'We have already seen some aspects of modifiability in the previous chapter.
    Let us discuss this a bit further, and look at some of the related quality attributes
    that are closely related to modifiability:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章中看到了可修改性的一些方面。让我们进一步讨论一下，并看一看与可修改性密切相关的一些相关质量属性：
- en: '**Readability**: Readability can be defined as the ease with which a program''s
    logic can be followed and understood. Readable software is code that has been
    written in a specific style, following guidelines typically adopted for the programming
    language used, and whose logic uses the features provided by the language in a
    concise, clear way.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性**：可读性可以定义为程序逻辑能够被跟随和理解的轻松程度。可读的软件是以特定风格编写的代码，遵循通常采用的编程语言的指南，并且其逻辑以简洁、清晰的方式使用语言提供的特性。'
- en: '**Modularity**: Modularity means that the software system is written in well-encapsulated
    modules, which do very specific, well-documented functions. In other words, modular
    code provides programmer friendly APIs to the rest of the system. Modifiability
    is closely connected to Reusability.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化**：模块化意味着软件系统是以良好封装的模块编写的，这些模块执行非常具体、有文档记录的功能。换句话说，模块化代码为系统的其余部分提供了程序员友好的API。可修改性与可重用性密切相关。'
- en: '**Reusability**: This measures the number of parts of a software system, including
    code, tools, designs, and others, that can be reused in other parts of the system
    with zero or very little modifications. A good design would emphasize reusability
    from the beginning. Reusability is embodied in the DRY principle of software development.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：这衡量了软件系统的各个部分（包括代码、工具、设计等）可以在系统的其他部分中零或很少修改地重复使用的数量。一个好的设计会从一开始就强调可重用性。可重用性体现在软件开发的DRY原则中。'
- en: '**Maintainability**: Maintainability of a software is the ease and efficiency
    with which the system can be updated and kept working in a useful state by its
    intended stakeholders. Maintainability is a metric, which encompasses the aspects
    of modifiability, readability, modularity and testability.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：软件的可维护性是指系统可以被其预期的利益相关者轻松高效地更新并保持在有用状态的程度。可维护性是一个度量标准，包括可修改性、可读性、模块化和可测试性的方面。'
- en: In this chapter, we are going to go deep into the readability and reusability/modularity
    aspects. We will look at these one by one from the context of the Python programming
    language. We will start with readability first.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究可读性和可重用性/模块化方面。我们将从Python编程语言的背景下逐一查看这些方面。我们将首先从可读性开始。
- en: Understanding readability
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解可读性
- en: The readability of a software system is closely tied to its modifiability. Well-written,
    well-documented code, keeping up with standard or adopted practices for the programming
    language, tends to produce simple, concise code that is easy to read and modify.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 软件系统的可读性与其可修改性密切相关。写得好、有文档记录的代码，遵循编程语言的标准或采用的实践，往往会产生简单、简洁的代码，易于阅读和修改。
- en: Readability is not only related to the aspect of following good coding guidelines,
    but it also ties up to how clear the logic is, how much the code uses standard
    features of the language, how modular the functions are, and so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性不仅与遵循良好的编码指南相关，而且还与逻辑的清晰程度、代码使用语言的标准特性的程度、函数的模块化程度等相关。
- en: 'In fact, we can summarize the different aspects of readability as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以总结可读性的不同方面如下：
- en: '**Well-written**: A piece of code is well-written if it uses simple syntax,
    uses well-known features and idioms of the language, the logic is clear and concise,
    and if it uses variables, functions, and class/module names meaningfully; that
    is, they express what they do.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写得好：如果一段代码使用简单的语法，使用语言的常见特性和习语，逻辑清晰简洁，并且有意义地使用变量、函数和类/模块名称，那么它就是写得好的。
- en: '**Well-documented**: Documentation usually refers to the inline comments in
    the code. A well-documented piece of code tells what it does, what its input arguments
    (if any) are, and what is its return value (if any) along with the logic or algorithm,
    if any, in detail. It also documents any external library, or API usage and configuration
    required for running the code either inline or in separate files.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档良好**：文档通常指的是代码中的内联注释。一段文档良好的代码告诉它做了什么，它的输入参数（如果有的话）是什么，它的返回值（如果有的话）是什么，以及详细的逻辑或算法。它还记录了运行代码所需的任何外部库或API使用和配置，无论是内联还是在单独的文件中。'
- en: '**Well-formatted**: Most programming languages, especially the open source
    languages developed over the Internet via distributed but closely-knit programming
    communities, tend to have well-documented style guidelines. A piece of code that
    keeps up with these guidelines on aspects such as indentation and formatting will
    tend to be more readable than something which doesn''t.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**格式良好**：大多数编程语言，特别是通过分布但紧密结合的编程社区在互联网上开发的开源语言，往往有良好的文档化风格指南。遵循这些缩进和格式等方面的指南的代码，往往比不遵循的代码更易读。'
- en: Code which doesn't keep up with these guidelines would in general be lacking
    on the readability aspect.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，不遵循这些指南的代码在可读性方面会有所欠缺。
- en: Lack of readability affects modifiability, and hence, maintainability of the
    code, thereby incurring ever-increasing costs for the organization in terms of
    resources—mainly people and time—in maintaining the system in a useful state.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性的缺乏影响了代码的可修改性，因此，维护代码的成本不断增加，主要是资源方面——主要是人力和时间——以保持系统处于有用状态。
- en: Python and readability
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python和可读性
- en: Python is a language that has been designed from the ground-up for readability.
    To borrow a line from the well-known Zen of Python.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种从头开始设计用于可读性的语言。借用一句著名的Python禅语。
- en: '*readability counts*'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*可读性很重要*'
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'The Zen of Python is a set of 20 principles that influence the design of the
    Python programming language, 19 of which have been written down. You can see the
    Zen of Python by opening the Python interpreter prompt and typing this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Python的禅是影响Python编程语言设计的20个原则，其中19个已经被写下来。你可以通过打开Python解释器提示符并输入以下内容来查看Python的禅：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Python, as a language, emphasizes readability. It achieves this by clear, concise
    keywords, which mimic their English language counterparts, using minimal operators,
    and following the following philosophy:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Python作为一种语言，强调可读性。它通过清晰、简洁的关键字实现了这一点，这些关键字模仿了它们的英语语言对应词，使用最少的运算符，并遵循以下哲学：
- en: '*There should be one-- and preferably only one --obvious way to do it.*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*应该有一种——最好只有一种——明显的方法来做到这一点。*'
- en: 'For example, here is one way to iterate through a sequence in Python while
    also printing its index:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Python中迭代一个序列并打印它的索引的一种方法如下：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, a more common idiom used in Python is to use the `enumerate()` helper
    for iterators, which returns a two tuple of (`idx`, `item`) for each item in the
    sequence:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Python中更常见的习惯是使用`enumerate()`辅助函数来进行迭代，它为序列中的每个项目返回一个两元组（`idx`，`item`）：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In many programming languages like C++, Java, or Ruby, the first version would
    be considered equally good as the second version. However, in Python, there are
    certain idioms of writing code, which keep up with the language's principles—the
    Zen—than certain others.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多编程语言中，如C++、Java或Ruby，第一个版本将被认为与第二个版本一样好。然而，在Python中，有一些写代码的习惯，它们比其他一些更符合语言的原则——Python的禅。
- en: In this case, the second version is closer to the way Python programmers would
    write code to solve the problem. The first way would be considered less Pythonic
    than the second one.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，第二个版本更接近Python程序员解决问题的方式。第一种方式被认为不如第二种方式Pythonic。
- en: The term "Pythonic" is something you would commonly encounter when interacting
    with the Python community. It means that the code not just solves the problem,
    but follows the conventions and idioms the Python community generally follows,
    and uses the language in the way it is intended to be used.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与Python社区互动时，你会经常遇到“Pythonic”这个词。它意味着代码不仅解决了问题，而且遵循了Python社区通常遵循的约定和习惯，并且以其预期的方式使用了语言。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The definition of Pythonic is subjective, but you can think of it as Python
    code keeping up with the Zen of Python, or in general, following well-known idiomatic
    programming practices adopted by the community.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Pythonic的定义是主观的，但你可以把它看作是Python代码遵循Python禅的方式，或者一般来说，遵循社区采用的众所周知的惯用编程实践。
- en: Python, by its design principles and clean syntax, makes writing readable code
    easy. However, it is a common trap for programmers migrating to Python from other
    more pedantic and less-idiomatic languages like say C++ or Java to write Python
    code in a less Pythonic way. For example, it is more likely that the first version
    of the loop is written by someone migrating to Python from one of these languages
    than someone who has been coding in Python for some time.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Python，根据其设计原则和清晰的语法，使得编写可读代码变得容易。然而，对于从其他更为拘谨和不太符合惯用法的语言（比如C++或Java）迁移到Python的程序员来说，以一种不太符合Python习惯的方式编写Python代码是一个常见的陷阱。例如，第一个循环的版本更可能是由从这些语言迁移到Python的人编写，而不是已经在Python中编码了一段时间的人。
- en: It is important for a Python programmer to understand this aspect early so that
    you tend to write more idiomatic or Pythonic code as you get used to the language
    more and more. You can be more productive with Python in the long term if you
    familiarize yourself with its coding principles and idioms than otherwise.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python程序员来说，早期了解这一方面是很重要的，这样你在逐渐熟悉语言的过程中就更有可能编写符合习惯或Python风格的代码。如果你熟悉其编码原则和习惯用法，长期来看你可以更有效地使用Python。
- en: Readability - antipatterns
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可读性-反模式
- en: Python, in general, encourages and facilitates writing readable code. However,
    it would be, of course, very unrealistic to say that any code written in Python
    is highly readable. Even with all its readability DNA, Python also has its fairshare
    of difficult-to-read, badly written, or unreadable code as can be evident by spending
    some time scanning through some of the public, open-source code written in Python
    on the Web.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，Python鼓励并便于编写可读代码。然而，当然，说任何用Python编写的代码都非常可读是非常不现实的。即使具有所有可读性的DNA，Python也有其公平份额的难以阅读、编写不佳或难以阅读的代码，这可以通过花一些时间浏览一些在网络上用Python编写的公开开源代码来明显看出。
- en: 'There are certain practices that tend to produce difficult-to-read or unreadable
    code in a programming language. These can be thought of as antipatterns, which
    are a bane, not just in programming with Python, but in any programming language:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言中有一些实践往往会产生难以阅读或难以阅读的代码。这些可以被认为是反模式，不仅在Python编程中是一种祸害，而且在任何编程语言中都是如此：
- en: '**Code with little or no comments**: Lack of code comments is often the primary
    reason for producing code that is unreadable. More often than not, programmers
    don''t do a very good job of documenting their thoughts, which led to a particular
    implementation, in code. When the same code is read by another programmer or by
    the same programmer a few months later (this happens quite a lot!), it is not
    easy to figure out why the specific implementation approach was followed. This
    makes it difficult to reason about the pros and cons of an alternate approach.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**几乎没有注释的代码**：缺乏代码注释通常是产生难以阅读的代码的主要原因。往往程序员并没有很好地记录他们的想法，这导致了特定实现方式的难以理解。当另一个程序员或同一个程序员几个月后（这种情况经常发生！）阅读相同的代码时，很难弄清为什么采用了特定的实现方式。这使得很难推理出替代方法的利弊。'
- en: This also makes taking decisions on modifying the code—perhaps for a customer
    fix—difficult, and in general, affects code modifiability in the long term. Commenting
    of code is often an indicator of the discipline and rigor of the programmer who
    wrote the code, and also of the organization in enforcing such practices.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这也使得在修改代码时做出决策（也许是为了修复客户问题）变得困难，并且一般来说，会影响长期的代码可修改性。代码的注释通常是编写代码的程序员的纪律和严谨的指标，也是组织强制执行这些实践的指标。
- en: '**Code which breaks best practices of the language**: Best practices of a programming
    language typically evolves from years of experience in using the language by a
    community of developers, and the efficient feedback that it generates. They capture
    the best way of putting the programming language to good use to solve problems,
    and typically, capture the idioms and common patterns for using the language.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**违反语言最佳实践的代码**：编程语言的最佳实践通常是由开发者社区多年使用该语言的经验和高效反馈所演变而来的。它们捕捉了将编程语言有效地用于解决问题的最佳方式，通常捕捉了使用该语言的习惯用法和常见模式。'
- en: For example, in Python, the Zen can be considered as a shining torch to its
    best practices and the set of common programming idioms adopted by the community.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Python中，禅可以被认为是其最佳实践和社区采用的常见编程习惯的闪亮火炬。
- en: Often, programmers who are either inexperienced or those who migrate from other
    programming languages or environments tend to produce code that is not in keeping
    with these practices, and hence, end up writing code that is low on readability.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，那些经验不足或从其他编程语言或环境迁移而来的程序员往往会产生不符合这些实践的代码，因此最终编写出了可读性较低的代码。
- en: '**Programming antipatterns**: There are a large number of coding or programming
    antipatterns which tend to produce difficult-to-read, and hence, difficult-to-maintain
    code. Here are some of the well-known ones:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编程反模式**：有许多编码或编程反模式，往往会产生难以阅读，因此难以维护的代码。以下是一些众所周知的反模式：'
- en: '**Spaghetti code**: A piece of code with no discernible structure or control-flow.
    It is typically produced by following complex logic with a lot of unconditional
    jumps and unstructured exception handling, badly designed concurrency structures,
    and so on.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**意大利面代码**：没有可辨识的结构或控制流的代码片段。通常是通过遵循复杂逻辑、大量无条件跳转和无结构的异常处理、设计不良的并发结构等方式产生的。'
- en: '**Big ball of mud**: A system with pieces of code that show no overall structure
    or goal. Big ball of mud typically consists of many pieces of spaghetti code,
    and is usually a sign of code that has been worked on by multiple people, patched-up
    multiple times with little or zero documentation.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大泥球**：一个系统，其中的代码片段没有整体结构或目标。大泥球通常由许多意大利面代码片段组成，通常是代码被多人修改多次，几乎没有文档的迹象。'
- en: '**Copy-Paste programming**: Often produced in organizations where expediency
    of delivery is favored over thoughtful design, copy/paste coding produces long,
    repetitive chunks of code, which essentially do the same thing again and again
    with minor modifications. This leads to code-bloat, and in the long term, the
    code becomes unmaintainable.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制粘贴编程**：通常在组织中产生，其中交付速度优先于深思熟虑的设计，复制/粘贴编码会产生长而重复的代码块，基本上一遍又一遍地做同样的事情，只是进行了微小的修改。这导致代码膨胀，并且从长远来看，代码变得难以维护。'
- en: A similar antipattern is *cargo-cult programming*, where programmers follows
    the same design or programming pattern over and over again without a thought to
    whether it fits the specific scenarios or problems that it is trying to solve.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的反模式是*模仿式编程*，程序员一遍又一遍地遵循相同的设计或编程模式，而不考虑它是否适合特定的场景或问题。
- en: '**Ego Programming**: Ego programming is where a programmer—often an experienced
    one—favors his personal style over the documented best practices or the organizational
    style of coding. This sometimes creates code that is cryptic and difficult to
    read for the other—usually, the younger or less-experienced programmers. An example
    is the tendency to use functional programming constructs in Python to write everything
    as a one-liner.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自我编程**：自我编程是指程序员——通常是经验丰富的程序员——更喜欢他个人的风格，而不是文档化的最佳实践或组织的编码风格。这有时会产生晦涩难懂的代码，对其他人——通常是年轻或经验较少的程序员来说，阅读起来困难。一个例子是倾向于在Python中使用函数式编程构造将所有东西写成一行的倾向。'
- en: Coding antipatterns can be circumvented by adopting practices of Structured
    Programming in your organization, and by enforcing the use of coding guidelines
    and best practices.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在组织中采用结构化编程的实践，并强制执行编码准则和最佳实践，可以避免编码反模式。
- en: 'The following are some antipatterns which are specific to Python:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些特定于Python的反模式：
- en: '**Mixed Indentation**: Python uses indentation to separate blocks of code,
    as it lacks braces or other syntactical constructs of languages like C/C++ or
    Java which separate code blocks. However, one needs to be careful when indenting
    code in Python. A common antipattern is where people mix both tabs (the `\t` character)
    and spaces in their Python code. This can be fixed by using editors which always
    use either tabs or spaces to indent code.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合缩进**：Python使用缩进来分隔代码块，因为它缺少像C/C++或Java这样的语言中分隔代码块的大括号或其他语法结构。然而，在Python中缩进代码时需要小心。一个常见的反模式是人们在他们的Python代码中混合使用制表符（`\t`字符）和空格。可以通过使用总是使用制表符或空格来缩进代码的编辑器来解决这个问题。'
- en: Python comes with built-in modules like *tabnanny*, which can be used to check
    your code for indentation issues.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带内置模块，如*tabnanny*，可用于检查代码的缩进问题。
- en: '**Mixing string literal types**: Python provides three different ways to create
    string literals: either by using the single quote (`''`), the double quote (`"`),
    or Python''s own special triple quote (`''''''` or `"""`). Code which mixes these
    three types of literals in the same block of code or functional unit becomes more
    difficult to read.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合字符串文字类型**：Python提供了三种不同的创建字符串文字的方式：使用单引号（`''`）、双引号（`"`）或Python自己特殊的三引号（`''''''`或`"""`）。在同一段代码或功能单元中混合这三种文字类型的代码会变得更难阅读。'
- en: A related abuse of strings is where programmers use the triple-quoted string
    for inline comments in their Python code rather than using the `#` character to
    prefix their comments.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相关的字符串滥用是程序员在他们的Python代码中使用三引号字符串来进行内联注释，而不是使用`#`字符来为他们的注释添加前缀。
- en: '**Overuse of functional constructs**: Python, being a mixed paradigm language,
    provides support for functional programming via its lambda keyword and its `map()`,
    `reduce()`, and `filter()`functions. However, sometimes, experienced programmers
    or programmers coming from a background of functional programming to Python, overuse
    these constructs producing code that is too cryptic, and hence, unreadable to
    other programmers.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过度使用函数式构造**：Python作为一种混合范式语言，通过其lambda关键字和`map()`、`reduce()`和`filter()`函数提供对函数式编程的支持。然而，有时，经验丰富的程序员或从函数式编程背景转到Python的程序员会过度使用这些构造，产生过于晦涩的代码，因此对其他程序员来说难以阅读。'
- en: Techniques for readability
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可读性技巧
- en: Now that we have a good knowledge on what helps readability of code, let us
    look at the approaches that we can adopt in order to improve the readability of
    code in Python.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对提高Python代码的可读性的方法有了很好的了解，让我们看看我们可以采用的方法来改善Python代码的可读性。
- en: Document your code
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录你的代码
- en: A simple and effective way to improve the readability of your code is to document
    what it does. Documentation is important for readability and long term modifiability
    of your code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 改善代码可读性的一个简单有效的方法是记录它的功能。文档对于代码的可读性和长期可修改性非常重要。
- en: 'Code documentation can be categorized as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代码文档可以分为以下几类：
- en: '**Inline documentation**: The programmer documents his code by using code comments,
    function documentation, module documentation, and others as part of the code itself.
    This is the most effective and useful type of code documentation.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内联文档**：程序员通过使用代码注释、函数文档、模块文档等作为代码本身的一部分来记录他的代码。这是最有效和有用的代码文档类型。'
- en: '**External documentation**: These are additional documentation captured in
    separate files, which usually document aspects such as usage of code, code changes,
    install steps, deployment, and the like. Examples are the `README`, `INSTALL`,
    or `CHANGELOG`, files usually found with open-source projects keeping up with
    the GNU build principles.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部文档**：这些是捕获在单独文件中的附加文档，通常记录代码的使用方式、代码更改、安装步骤、部署等方面。例如，`README`、`INSTALL`或`CHANGELOG`，通常在遵循GNU构建原则的开源项目中找到。'
- en: '**User Manuals**: These are formal documents, usually by a dedicated person
    or team, using pictures and text that is usually targeted towards users of the
    system. Such documentation is usually prepared and delivered towards the end of
    a software project when the product is stable and is ready to ship. We are not
    concerned with this type of documentation in our discussion here.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户手册**：这些是正式文件，通常由专门的人或团队编写，使用图片和通常面向系统用户的文本。这种文档通常在软件项目结束时准备和交付，当产品稳定并准备发货时。我们在这里的讨论中不关心这种类型的文档。'
- en: 'Python is a language that is designed for smart inline code documentation from
    the groundup. In Python, inline documentation can be done at the following levels:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种从头开始设计的智能内联代码文档的语言。在Python中，内联文档可以在以下级别完成：
- en: '**Code comments**: This is the text inline with code, prefixed by the hash
    (`#`) character. They can be used liberally inside your code explaining what each
    step of the code does.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码注释**：这是与代码一起的内联文本，以井号（`#`）字符为前缀。它们可以在代码内部自由使用，解释代码的每个步骤。'
- en: 'Here is an example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The liberal use of comments even in places it may be deemed superfluous. We
    will look at some general rules of thumb in commenting your code later.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在可能被认为是多余的地方，也要大量使用注释。我们稍后将看一些关于在代码中添加注释的一般规则。
- en: '**Function doc-strings**: Python provides a simple way to document what a function
    does by using a string literal just below the function definition. This can be
    done by using any of the three styles of string literals.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数文档字符串**：Python提供了一种简单的方法，通过在函数定义的下方使用字符串文字来记录函数的功能。这可以通过使用三种风格的字符串文字之一来完成。'
- en: 'Here is an example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The function docstring is the line which says *Fetch a given URL and return
    its contents*. However, though it is useful, the usage is limited, since it only
    says what the function does and doesn''t explain its parameters. Here is an improved
    version:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 函数文档字符串是一行，其中写着*获取给定URL并返回其内容*。然而，尽管它很有用，但使用范围有限，因为它只说明函数的功能，而不解释其参数。这里是一个改进版本：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, the function usage has become much more clear to the
    programmer, who may be planning to import its definition and use it in his code.
    Note that such extended documentation would usually span more than one line, and
    hence, it is a good idea to always use triple quotes with your function docstrings.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，函数的使用对于计划导入其定义并在其代码中使用的程序员来说变得更加清晰。请注意，这种扩展文档通常会跨越多行，因此，始终使用三引号与函数文档字符串是一个好主意。
- en: '**Class docstrings**: These work just like a function docstring except that
    they provide documentation for a class directly. This is provided just below the
    class keyword defining the class.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类文档字符串**：这些与函数文档字符串的工作方式相同，只是它们直接为类提供文档。这是在定义类的关键字下方提供的。'
- en: 'Here is an example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: See how the class docstring defines some of the main methods of the class. This
    is a very useful practice, as it gives the programmer useful information at the
    top level without having to go and inspect each function's documentation separately.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 查看类文档字符串如何定义类的一些主要方法。这是一个非常有用的做法，因为它在顶层为程序员提供了有用的信息，而无需去检查每个函数的文档。
- en: '**Module docstrings**: Module docstring capture information at the module level,
    usually about the functionality of the module and some detail about what each
    member of the module (function, class, and others) does. The syntax is the same
    as the class or function docstring. The information is usually captured at the
    beginning of the module code.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块文档字符串**：模块文档字符串在模块级别捕获信息，通常是关于模块功能的信息以及模块的每个成员（函数、类和其他）的一些详细信息。语法与类或函数文档字符串相同。这些信息通常在模块代码的开头捕获。'
- en: 'A module documentation can also capture any specific external dependencies
    of a module if they are not very obvious, for example, importing a third-party
    package which is not very commonly used:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块文档还可以捕获模块的任何特定外部依赖项，如果它们不是非常明显的话，例如，导入一个不太常用的第三方包：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Follow coding and style guidelines
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遵循编码和风格指南
- en: Most programming languages have a relatively well-known set of coding and/or
    style guidelines. These are either developed over many years of use as a convention,
    or come as a result of discussions in the online community of that programming
    language. C/C++ is a good example of the former, and Python is a good example
    of the latter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都有一个相对知名的编码和/或风格指南。这些要么是作为惯例多年使用而形成的，要么是作为该编程语言在线社区讨论的结果。C/C++是前者的一个很好的例子，Python是后者的一个很好的例子。
- en: It is also a common practice for companies to specify their own guidelines—mostly,
    by adopting existing standard guidelines, and customizing them for the company's
    own specific development environment and requirements.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 公司通常会制定自己的指南，大多数情况下是通过采用现有的标准指南，并根据公司自己的特定开发环境和要求进行定制。
- en: For Python, there is a clear set of coding style guidelines published by the
    Python programming community. This guideline, known as PEP-8, is available online
    as part of the **Python Enhancement Proposal** (**PEP**) set of documents.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python，Python编程社区发布了一套清晰的编码风格指南。这个指南被称为PEP-8，可以在线作为Python增强提案（PEP）文档的一部分找到。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find PEP-8 at the following URL:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下网址找到PEP-8：
- en: '[https://www.python.org/dev/peps/pep-0008/](http://www.python.org/dev/peps/pep-0008/).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.python.org/dev/peps/pep-0008/](http://www.python.org/dev/peps/pep-0008/)。'
- en: PEP-8 was first created in 2001, and has undergone multiple revisions since
    then. The primary author is the creator of Python, is Guido Van Rossum, with inputs
    from Barry Warsaw and Nick Coghlan.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: PEP-8首次创建于2001年，自那时以来已经经历了多次修订。主要作者是Python的创始人Guido Van Rossum，Barry Warsaw和Nick
    Coghlan提供了输入。
- en: PEP-8 was created by adapting Guido's original *Python Style Guide essay* with
    additions from Barry's style guide.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: PEP-8是通过调整Guido的原始*Python风格指南*并加入Barry的风格指南而创建的。
- en: We will not go deep into PEP-8 in this book, as the goal of this section is
    not to teach you PEP-8\. However, we will discuss the general principles underlying
    PEP-8, and list out some of its main recommendations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中深入讨论PEP-8，因为本节的目标不是教你PEP-8。然而，我们将讨论PEP-8的基本原则，并列出一些其主要建议。
- en: 'The philosophy underlying PEP-8 can be summarized as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: PEP-8的基本原则可以总结如下：
- en: Code is read more than it is written. Hence, providing a guideline would make
    code more readable, and make it consistent across a full spectrum of Python code.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码被阅读的次数比被编写的次数要多。因此，提供一个准则会使代码更易读，并使其在整个Python代码的全谱上保持一致。
- en: Consistency within a project is important. However, consistency within a module
    or package is more important. Consistency within a unit of code—such as class
    or function is the most important.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目内的一致性很重要。但是，在一个模块或包内的一致性更重要。在代码单元内（如类或函数）的一致性是最重要的。
- en: Know when to ignore a guideline. For example, this may happen if adopting the
    guideline makes your code less readable, breaks the surrounding code, or breaks
    backward compatibility of the code. Study examples, and choose what is best.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道何时忽略一个准则。例如，如果采用该准则使您的代码变得不太可读，破坏了周围的代码，或者破坏了代码的向后兼容性，那么可能会发生这种情况。学习示例，并选择最好的。
- en: If a guideline is not directly applicable or useful for your organization, customize
    it. If you have any doubts about a guideline, get clarification by asking the
    helpful Python community.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个准则对您的组织不直接适用或有用，那么自定义它。如果您对某个准则有任何疑问，请向乐于助人的Python社区寻求澄清。
- en: We will not cover the PEP-8 guidelines in detail here. The interested reader
    can refer to the documentation online on the Web using the URLs given here.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里详细介绍PEP-8准则。有兴趣的读者可以参考在线文档，使用这里提供的URL。
- en: Review and refactor code
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查和重构代码
- en: Code requires maintenance. Unmaintained code which is used in production can
    become a problem and a nightmare if not tended to periodically.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 代码需要维护。在生产中使用的未维护的代码可能会成为一个问题，如果不定期处理，可能会变成一个噩梦。
- en: Periodically scheduled reviews of code can be very useful in keeping the code
    readable and in good health aiding modifiability and maintainability. Code which
    is central to a system or an application in production tends to get a lot of quick-fixes
    over time, as it is customized or enhanced for different use cases or patched
    for issues. It is observed that programmers generally don't document such quick
    fixes (called "patch" or "hot-fix"), as the time demands often expedite immediate
    testing and deployment over good engineering practices such as documentation and
    following guidelines!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 定期安排代码审查非常有助于保持代码的可读性和良好的健康，有助于可修改性和可维护性。在生产中对系统或应用程序至关重要的代码往往会随着时间的推移得到许多快速修复，因为它被定制或增强以适应不同的用例或为问题打补丁。观察到程序员通常不会记录这些快速修复（称为“补丁”或“热修复”），因为时间要求通常会加速立即测试和部署，而不是遵循良好的工程实践，如文档和遵循准则！
- en: Over time, such patches can accumulate, thereby causing code-bloat and creating
    huge future engineering debts for the team, which can become a costly affair.
    The solution is periodical reviews.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，这样的补丁可能会积累，从而导致代码膨胀，并为团队创造巨大的未来工程债务，这可能会成为一项昂贵的事务。解决方案是定期审查。
- en: Reviews should be done with engineers who are familiar with the application,
    but need not be working on the same code. This gives the code a fresh set of eyes,
    which is often useful in detecting bugs that the original author(s) may have overlooked.
    It is a good idea to get large changes reviewed by a couple of reviewers who are
    experienced developers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 审查应该由熟悉应用程序的工程师进行，但不一定要在同一段代码上工作。这给了代码一个新鲜的视角，通常有助于发现原始作者可能忽视的错误。最好让经验丰富的开发人员对大的更改进行审查。
- en: This can be combined with the general refactoring of code to improve implementation,
    reduce coupling, or increase cohesion.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以与代码的一般重构结合起来，以改进实现，减少耦合，或增加内聚。
- en: Commenting the code
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释代码
- en: 'We are coming towards the end of our discussions on readability of code, and
    it is a good time to introduce some general rules of thumb to follow when writing
    code comments. These can be listed as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将结束对代码可读性的讨论，现在是介绍一些编写代码注释时要遵循的一般经验法则的好时机。这些可以列举如下：
- en: Comments should be descriptive, and should explain the code. A comment which
    simply repeats what is obvious from the function name is not very useful.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释应该是描述性的，并解释代码。一个简单重复函数名称显而易见的注释并不是很有用。
- en: 'Here is an example. Both of the following codes show the same implementation
    of an **root-mean-squared** (**RMS**) velocity calculation, but the second version
    has a much more useful `docstring` than the first:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子。以下两个代码都展示了相同的**均方根**（**RMS**）速度计算实现，但第二个版本比第一个版本有一个更有用的`docstring`：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Code comments should be written in the block we are commenting on, rather than
    as follows:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码注释应该写在我们正在评论的代码块中，而不是像下面这样：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding version is much more clearer than the following version, which
    uses comments below the code since it is in keeping with the natural order of
    reading from top to bottom.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个版本比下一个版本更清晰，下一个版本使用了代码下面的注释，因为它符合从上到下的自然阅读顺序。
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inline comments should be used as little as possible. This is because it is
    very easy to get these confused as part of the code itself, especially if the
    separating comment character is accidentally deleted, causing bugs:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量少使用内联注释。这是因为很容易将其混淆为代码本身的一部分，特别是如果分隔注释字符被意外删除，导致错误：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Try to avoid comments that are superfluous and add little value:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量避免多余的、增加很少价值的注释：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The second comment in the last piece of code adds little value, and can be omitted.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一段代码中，第二条评论增加了很少的价值，可以省略。
- en: Fundamentals of Modifiability – Cohesion & Coupling
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可修改性的基本原则-内聚性和耦合性
- en: Let us now get back to the main topic of modifiability, and discuss the two
    fundamental aspects that affect modifiability of code—namely, cohesion and coupling.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到代码可修改性的主题，并讨论影响代码可修改性的两个基本方面，即内聚性和耦合。
- en: We've already discussed these concepts briefly in the first chapter. Let us
    do a quick review here.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在第一章中简要讨论了这些概念。让我们在这里进行快速回顾。
- en: The cohesion refers to how tightly the responsibilities of a module are related
    to each other. A module which performs a specific task or group of related tasks
    has high cohesion. A module in which a lot of functionality is dumped without
    a thought as to the core functionality would have low cohesion.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 内聚指的是模块的责任之间的紧密关联程度。执行特定任务或一组相关任务的模块具有高内聚性。如果一个模块在没有考虑核心功能的情况下堆积了大量功能，那么它的内聚性就会很低。
- en: The coupling is the degree to which the functionality of two modules A and B
    are related. Two modules are strongly coupled if their functionality overlaps
    strongly at the code level—in terms of function or method calls. Any changes in
    module A would probably require changes in module B.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合是模块A和B的功能相关程度。如果两个模块的功能在代码级别（在函数或方法调用方面）有很强的重叠，那么它们就是强耦合的。对模块A的任何更改可能需要对模块B进行更改。
- en: Strong coupling is always prohibitory for modifiability, as it increases the
    cost of maintaining the code base.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 强耦合对可修改性总是具有禁止作用，因为它增加了维护代码库的成本。
- en: Code which aims to increase modifiability should aim for high cohesion and low
    coupling.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 旨在提高可修改性的代码应该追求高内聚性和低耦合性。
- en: We will analyze cohesion and coupling in the following subsections with some
    examples.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下各小节中通过一些例子分析内聚和耦合。
- en: Measuring cohesion and coupling
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 衡量内聚和耦合
- en: 'Let us look at a simple example of two modules to figure out how we can measure
    coupling and cohesion quantitatively. The following is the code for module A,
    which purportedly implements functions that operate with a series (array) of numbers:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的例子，有两个模块，以找出如何定量地衡量耦合和内聚。以下是模块A的代码，据称实现了对一系列（数组）数字进行操作的函数：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next is the listing of module B.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是模块B的列表。
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let us do an analysis of the functions in module A and B. Here is the report:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对模块A和B中的函数进行分析。以下是报告：
- en: '| Module | Core functions | Unrelated functions | Function dependencies |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | 核心功能 | 无关功能 | 函数依赖 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| B | 4 | 0 | 3 x 1 = 3 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| B | 4 | 0 | 3 x 1 = 3 |'
- en: '| A | 3 | 1 | 0 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| A | 3 | 1 | 0 |'
- en: 'This has four functions that can be explained as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这有四个函数，可以解释如下：
- en: Module B has four functions, all of them dealing with the core functionality.
    There are no unrelated functions in this module from its core functionality. The
    module B has 100% cohesion.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块B有四个函数，所有这些函数都涉及核心功能。在这个模块中没有与核心功能无关的函数。模块B的内聚性为100%。
- en: Module A has four functions, three of which are related to its core functionality,
    but the last one (frequency) isn't. This gives module A approximately `75%` cohesion.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块A有四个函数，其中三个与其核心功能相关，但最后一个（frequency）不相关。这使得模块A的内聚性约为`75%`。
- en: Three of module B has functions that depend on one function in module A, namely,
    square. This makes module B strongly coupled to module A. coupling at function
    level is *75%* from module B ? A.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块B的三个函数依赖于模块A中的一个函数，即square。这使得模块B与模块A强耦合。从模块B到A的函数级耦合为*75%*。
- en: Module A doesn't depend on any functionality of module B. Module A will work
    independent of module B. coupling from module A ? B is zero.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块A不依赖于模块B的任何功能。模块A将独立于模块B工作。从模块A到B的耦合为零。
- en: Let us now look at how we can improve the cohesion of module A. In this case,
    it is as simple as dropping the last function which doesn't really belong there.
    It could be dropped out entirely or moved to another module.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何改进模块A的内聚性。在这种情况下，简单地删除最后一个实际上不属于那里的函数就可以了。它可以完全删除或移动到另一个模块。
- en: 'Here is the rewritten module A code, now with 100% cohesion with respect to
    its responsibilities:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是重写后的模块A代码，现在在责任方面具有100%的内聚性：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let us now analyze the quality of coupling from module B? A, and look at the
    risk factors of modifiability of code in B with respect to code in A, which are
    as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们分析从模块B到A的耦合质量，并查看与A中的代码相关的B代码的可修改性风险因素，如下所示：
- en: The three functions in B depend on just one function in module A.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B中的三个函数仅依赖于模块A中的一个函数。
- en: The function is named squares, which takes in an array and returns each of its
    member squared.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数名为squares，它接受一个数组并返回每个成员的平方。
- en: The function signature (API) is simple, so chances of changing the function
    signature in the future is less.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数签名（API）很简单，因此将来更改函数签名的可能性较小。
- en: There is no two-way coupling in the system. The dependency is only from direction
    B ? A.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中没有双向耦合。依赖仅来自B到A的方向。
- en: In other words, even though there is strong coupling from B to A, it is good
    coupling, and doesn't affect the modifiability of the system in any way at all.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，尽管从B到A存在强耦合，但这是良好的耦合，并且不会以任何方式影响系统的可修改性。
- en: Let us now look at another example.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看另一个例子。
- en: Measuring cohesion and coupling – string and text processing
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 衡量内聚和耦合 - 字符串和文本处理
- en: 'Let us consider a different use case now, an example with functions which do
    a lot of string and text processing:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一个不同的用例，一个涉及大量字符串和文本处理的函数的例子：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next is the listing of module B which is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是模块B的列表，如下所示：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s go through the coupling and cohesion analysis of these modules given
    in following table:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这些模块的耦合和内聚分析，如下表所示：
- en: '| Module | Core functions | Unrelated functions | Function dependencies |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | 核心功能 | 无关功能 | 函数依赖 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| B | 2 | 0 | 1 x 1 = 1 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| B | 2 | 0 | 1 x 1 = 1 |'
- en: '| A | 2 | 0 | 1 x 1 = 1 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| A | 2 | 0 | 1 x 1 = 1 |'
- en: 'Here is an explanation of these numbers in the table:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是表中这些数字的解释：
- en: Module A and B has two functions each, each of them dealing with the core functionality.
    Modules A and B both have *100%* cohesion.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块A和B各有两个函数，每个函数都处理核心功能。模块A和B都具有*100%*的内聚。
- en: One function of module A is dependent on one function of module B. Similarly,
    one function of module B is dependent on one function of module A. There is strong
    coupling from A? B, and also from B ? A. In other words, the coupling is bidirectional.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块A的一个函数依赖于模块B的一个函数。同样，模块B的一个函数依赖于模块A的一个函数。从A到B有强耦合，从B到A也是如此。换句话说，耦合是双向的。
- en: Bidirectional coupling between two modules ties their modifiability to each
    other very strongly. Any changes in module A will quickly cascade to the behavior
    of module B and viceversa. In other words, this is bad coupling.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 两个模块之间的双向耦合会使它们的可修改性之间产生非常强烈的联系。模块A的任何更改都会迅速影响模块B的行为，反之亦然。换句话说，这是不好的耦合。
- en: Exploring strategies for modifiability
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索可修改性的策略
- en: Now that we have seen some examples of good and bad coupling and also cohesion,
    let us get to the strategies and approaches that a software designer or architect
    can use to reduce the effects of these aspects on modifiability in order to improve
    the modifiability of the software system.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一些好的和坏的耦合和内聚的例子，让我们来看看软件设计师或架构师可以使用的策略和方法，以减少这些方面对可修改性的影响，从而改进软件系统的可修改性。
- en: Providing explicit interfaces
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供明确的接口
- en: A module should to and mark a set of functions, classes, or methods as the **interface**
    it provides to external code. This can be thought of as the API of this module,
    which is exported from it. Any external code which uses this API would become
    a client to the module.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块应该标记一组函数、类或方法作为其提供给外部代码的**接口**。这可以被视为该模块的API，从中导出。使用此API的任何外部代码都将成为该模块的客户端。
- en: Methods or functions which the module considers internal to its function, and
    which do not make up its API, should either be explicitly made private to the
    module or should be documented as such.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 模块认为是其内部功能的方法或函数，不构成其API的，应该明确地作为模块的私有部分，或者应该被记录为这样的部分。
- en: In Python, which doesn't provide variable access scope for functions or class
    methods, this can be done by conventions such as prefixing the function name with
    a single or double underscore, thereby signaling to potential clients that these
    functions are internal and shouldn't be referred to from outside.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，函数或类方法没有提供变量访问范围，可以通过约定来实现，例如在函数名前加上单下划线或双下划线，从而向潜在客户表明这些函数是内部函数，不应该从外部引用。
- en: Reducing two-way dependencies
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少双向依赖
- en: As seen in the examples earlier, coupling between two software modules is manageable
    if the coupling direction is one-way. However, bidirectional coupling creates
    very strong linkages between modules, which can complicate the usage of the modules
    and increase their maintenance costs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，如果耦合方向是单向的，那么两个软件模块之间的耦合是可以管理的。然而，双向耦合会在模块之间创建非常强的联系，这可能会使模块的使用复杂化，并增加其维护成本。
- en: In languages like Python, which uses reference-based garbage collection, this
    may also create cryptic referential loops for variables and objects, thereby making
    their garbage collection difficult.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在像Python这样使用基于引用的垃圾收集的语言中，这也可能为变量和对象创建难以理解的引用循环，从而使它们的垃圾收集变得困难。
- en: Bidirectional dependencies can be broken by refactoring the code in such a way
    that a module always uses the other one and not vice-versa. In other words, encapsulate
    all related functions in the same module.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重构代码的方式打破双向依赖，使一个模块始终使用另一个模块，而不是反之。换句话说，将所有相关函数封装在同一个模块中。
- en: 'Here are our modules A and B of the earlier example, rewritten to break their
    bidirectional dependency:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们之前例子中的模块A和B，重写以打破它们的双向依赖：
- en: '[PRE18]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next is the listing of module B.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是模块B的清单。
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We achieved this by simply moving the function `common`, which picks common
    words from two strings from module B to A. This is an example of refactoring to
    improve modifiability.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过简单地将模块B中从两个字符串中选择共同单词的函数`common`移动到模块A来实现这一点。这是改进可修改性的重构的一个例子。
- en: Abstract common services
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象共同服务
- en: Usage of helper modules which abstract common functions and methods can reduce
    coupling between two modules, and also increase their cohesion. For example, in
    the first example, the module A acts as a helper module for module B. In the second
    example also, after the refactoring step, module A acts as a helper module to
    module B.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用抽象共同函数和方法的辅助模块可以减少两个模块之间的耦合，并增加它们的内聚。例如，在第一个例子中，模块A充当了模块B的辅助模块。在第二个例子中，重构后，模块A也充当了模块B的辅助模块。
- en: Helper modules can be thought of as intermediaries or mediators, which abstract
    common services for other modules so that the dependent code is all abstracted
    in one place without duplication. They can also help modules to increase their
    Cohesion by moving away unwanted or unrelated functions to a suitable helper module.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助模块可以被视为中介或调解者，它们为其他模块提供共同服务，以便依赖代码都在一个地方进行抽象，避免重复。它们还可以通过将不需要或不相关的函数移动到合适的辅助模块来帮助模块增加它们的内聚。
- en: Using inheritance techniques
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用继承技术
- en: When we find similar code or functionality occurring in classes, it might be
    a good time to refactor them so as to create class hierarchies so that common
    code is shared by virtue of inheritance.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发现类中出现相似的代码或功能时，可能是时候对其进行重构，以创建类层次结构，以便通过继承共享公共代码。
- en: 'Let us take a look at the following example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子：
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is another module, `urlrank`, which performs the same function on URLs:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个模块`urlrank`，它在URL上执行相同的功能：
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Both these modules perform similar functions of ranking a set of input data
    in terms of how much a given keyword appears in them. Over time, these classes
    could develop a lot of similar functionality, and the organization can end up
    with a lot of duplicate code, reducing modifiability.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个模块都执行类似的功能，即根据给定关键字在一组输入数据中出现的频率对其进行排名。随着时间的推移，这些类可能会开发出许多相似的功能，组织可能会出现大量重复的代码，降低了可修改性。
- en: 'We can use inheritance to help us here to abstract away the common logic in
    a parent class. Here is the parent class named `RankBase`, which accomplishes
    this by moving away all common code to itself:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用继承来帮助我们在父类中抽象出通用逻辑。这里是名为`RankBase`的父类，通过将所有通用代码移动到自身来实现这一点：
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We now have the `textrank` and `urlrank` modules rewritten to take advantage
    of the logic in the parent class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经重写了`textrank`和`urlrank`模块，以利用父类中的逻辑：
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is the modified listing for the `urlrank` module:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`urlrank`模块的修改列表：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Not only has refactoring reduced the size of the code in each module, but it
    has also resulted in improved modifiability of the classes by abstracting the
    common code to a parent module/class, which can be developed independently.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 重构不仅减少了每个模块中代码的大小，还通过将通用代码抽象到父模块/类中，从而改善了类的可修改性，这可以独立开发。
- en: Using late binding techniques
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用后期绑定技术
- en: The late binding refers to the practice of postponing the binding of values
    to parameters as late as possible in the order of execution of a code. Late binding
    allows the programmer to defer the factors which influence code execution, and
    hence the results of execution and performance of the code, to a later time by
    making use of multiple techniques.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 后期绑定是指尽可能晚地将值绑定到代码执行顺序中的参数的做法。后期绑定允许程序员推迟影响代码执行的因素，从而推迟执行结果和代码性能，通过使用多种技术。
- en: 'Some late-binding techniques which can be used are as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可以使用的后期绑定技术：
- en: '**Plugin mechanisms**: Rather than statically binding modules together, which
    increases coupling, this technique uses values resolved at runtime to load plugins
    which execute a specific dependent code. Plugins can be Python modules whose names
    are fetched during computations done at runtime, or via IDs or variable names
    loaded from database queries or from configuration files.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件机制**：这种技术使用在运行时解析的值来加载插件，执行特定的依赖代码，而不是静态地将模块绑定在一起，这会增加耦合。插件可以是Python模块，其名称在运行时的计算中获取，也可以是从数据库查询或配置文件中加载的ID或变量名称。'
- en: '**Brokers/Registry lookup services**: Some services can be completely deferred
    to brokers, which look up the service names from a registry on demand, and call
    them dynamically and return results. An example may be a currency exchange service,
    which accepts a specific currency transformation as input (say USDINR), and looks
    up and configures a service for it dynamically at runtime, thereby requiring only
    the same code to execute on the system at all times. Since there is no dependent
    code on the system that varies with the input, the system remains immune from
    any changes required if the logic for the transformation changes, as it is deferred
    to an external service.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经纪人/注册表查找服务**：某些服务可以完全推迟到经纪人，经纪人根据需要从注册表中查找服务名称，并动态调用并返回结果。例如，货币兑换服务可以接受特定货币转换作为输入（例如USDINR），并在运行时动态查找和配置服务，因此系统在任何时候只需要相同的代码执行。由于系统上没有依赖于输入的代码，系统不会受到任何变化的影响，因此它被推迟到外部服务。'
- en: '**Notification services**: Publish/Subscribe mechanisms which notify subscribers
    when the value of an object changes or when an event is published, can be useful
    to decouple systems from a volatile parameter and its value. Rather than tracking
    changes to such variables/objects internally, which may need a lot of dependent
    code and structures, such systems keep their clients immune to the changes in
    the system which affect and trigger the objects internal behavior, but bind them
    only to an external API, which simply notifies the clients of the changed value.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知服务**：发布/订阅机制在对象值发生变化或事件发布时通知订阅者，对于将系统与易变参数及其值解耦非常有用。这些系统不会在内部跟踪这些变量/对象的变化，而是将客户端仅绑定到外部API，该API仅通知客户端值的变化。'
- en: '**Deployment time binding**: By keeping the variable values associated to names
    or IDs in configuration files, we can defer object/variable binding to deployment
    time. The values are bound at startup by the software system once it loads its
    configuration files, which can then invoke specific paths in the code that creates
    appropriate objects.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署时间绑定**：通过将变量值与名称或ID关联到配置文件中，我们可以将对象/变量绑定推迟到部署时间。软件系统在启动时通过加载配置文件绑定值，然后调用创建适当对象的代码路径。'
- en: This approach can be combined with object-oriented patterns like Factories,
    which create the required object at runtime given the name or ID, thus, keeping
    the clients which are dependent on these objects immune from any internal changes,
    increasing their modifiability.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以与工厂等面向对象模式结合使用，工厂可以在运行时根据名称或ID创建所需的对象，从而使依赖于这些对象的客户端免受任何内部更改的影响，增加了它们的可修改性。
- en: '**Using creational patterns**: Creational design patterns such as factory or
    builder, which abstract the task of creating of an object from the details of
    creating it, are ideal for separation of concerns for client modules which don''t
    want their code to be modified when the code for creation of a dependent object
    changes.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用创建型模式**：创建型设计模式（如工厂或生成器）将对象的创建任务与创建细节抽象出来，非常适合客户端模块的关注点分离，这些模块不希望在创建依赖对象的代码发生更改时修改它们的代码。'
- en: These approaches, when combined with deployment/configuration time or dynamic
    binding (using Lookup Services), can greatly increase the flexibility of a system
    and aid its modifiability.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法与部署/配置时间或动态绑定（使用查找服务）相结合，可以极大地增加系统的灵活性，并帮助其可修改性。
- en: We will look at examples of Python patterns in a later chapter in this book.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面章节中看一些Python模式的例子。
- en: Metrics – tools for static analysis
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 度量标准-静态分析工具
- en: Static code analysis tools can provide a rich summary of information on the
    static properties of your code, which can provide insights into aspects like complexity
    and modifiability/readability of the code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析工具可以提供关于代码静态属性的丰富摘要信息，可以提供有关代码复杂性和可修改性/可读性等方面的见解。
- en: 'Python has a lot of third-party tool support, which helps in measuring the
    static aspects of Python code such as these:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Python有很多第三方工具支持，可以帮助衡量Python代码的静态方面，比如：
- en: Conformance to coding standards like PEP-8
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵守编码规范，如PEP-8
- en: Code complexity metrics like the McCabe metric
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像McCabe度量这样的代码复杂度指标
- en: Errors in code such as syntax errors, indentation issues, missing imports, variable
    overwrites, and others
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码中的错误，如语法错误、缩进问题、缺少导入、变量覆盖等
- en: Logic issues in code
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码中的逻辑问题
- en: Code smells
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码异味
- en: 'The following are some of the most popular tools in the Python ecosystem which
    can perform such static analysis:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Python生态系统中一些最流行的工具，可以进行静态分析：
- en: '**Pylint**: Pylint is a static checker for Python code, which can detect a
    range of coding errors, code smells, and style errors. Pylint uses a style close
    to PEP-8\. The newer versions of Pylint also provide statistics about code complexity,
    and can print reports. Pylint requires the code to be executed before checking
    it. You can refer to the [http://pylint.org](http://pylint.org) link.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pylint**：Pylint是Python代码的静态检查器，可以检测一系列的编码错误、代码异味和风格错误。Pylint使用接近PEP-8的风格。较新版本的Pylint还提供有关代码复杂性的统计信息，并可以打印报告。Pylint要求在检查代码之前执行代码。您可以参考[http://pylint.org](http://pylint.org)链接。'
- en: '**Pyflakes**: Pyflakes is a more recent project than Pylint. It differs from
    Pylint in that it need not execute the code before checking it for errors. Pyflakes
    does not check for coding style errors, and only performs logic checks in code.
    You can refer to the [https://launchpad.net/pyflakes](https://launchpad.net/pyflakes)
    link.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pyflakes**：Pyflakes是一个比Pylint更新的项目。它与Pylint的不同之处在于，在检查代码错误之前，它不需要执行代码。Pyflakes不检查编码风格错误，只在代码中执行逻辑检查。您可以参考[https://launchpad.net/pyflakes](https://launchpad.net/pyflakes)链接。'
- en: '**McCabe**: It is a script which checks and prints a report on the McCabe complexity
    of your code. You can refer to the [https://pypi.python.org/pypi/mccabe](http://pypi.python.org/pypi/mccabe)
    link.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**McCabe**：这是一个检查并打印代码McCabe复杂度报告的脚本。您可以参考[https://pypi.python.org/pypi/mccabe](http://pypi.python.org/pypi/mccabe)链接。'
- en: '**Pycodestyle**: Pycodestyle is a tool which checks your Python code against
    some of the PEP-8 guidelines. This tool was earlier called PEP-8\. Refer to the
    [https://github.com/PyCQA/pycodestyle](http://github.com/PyCQA/pycodestyle) link.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pycodestyle**：Pycodestyle是一个检查Python代码是否符合PEP-8指南的工具。这个工具以前被称为PEP-8。请参考[https://github.com/PyCQA/pycodestyle](http://github.com/PyCQA/pycodestyle)链接。'
- en: '**Flake8**: Flake8 is a wrapper around the Pyflakes, McCabe, and pycodestyle
    tools, and can perform a number of checks including the ones provided by these
    tools. Refer to the [https://gitlab.com/pycqa/flake8/](http://gitlab.com/pycqa/flake8/)
    link.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flake8**：Flake8是Pyflakes、McCabe和pycodestyle工具的包装器，可以执行一些检查，包括这些工具提供的检查。请参考[https://gitlab.com/pycqa/flake8/](http://gitlab.com/pycqa/flake8/)链接。'
- en: What are code smells?
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是代码异味？
- en: C**ode smells** are surface symptoms of deeper problems with your code. They
    usually indicate problems with the design which can cause bugs in the future or
    negatively impact development of the particular piece of code.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码异味**是代码中更深层次问题的表面症状。它们通常表明设计上存在问题，可能会导致将来的错误或对特定代码段的开发产生负面影响。'
- en: Code smells are not bugs themselves, but they are patterns that indicate that
    the approach to solving problems adopted in the code is not right, and should
    be fixed by refactoring.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 代码异味本身并不是错误，而是指示代码解决问题的方法不正确，并且应该通过重构来修复的模式。
- en: 'Some of the common code smells are as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的代码异味包括：
- en: 'At the class level:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在类级别：
- en: '**God Object**: A class which tries to do too many things. In short, this class
    lacks any kind of cohesion.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**God Object**：一个试图做太多事情的类。简而言之，这个类缺乏任何形式的内聚性。'
- en: '**Constant Class**: A class that''s nothing but a collection of constants,
    which is used elsewhere, and hence, should not ideally belong here.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Constant Class**：一个仅仅是常量集合的类，被其他地方使用，因此理想情况下不应该存在于这里。'
- en: '**Refused Bequest**: A class which doesn''t honor the contract of the base
    class, and hence, breaks the substitution principle of inheritance.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Refused Bequest**：一个不遵守基类合同的类，因此违反了继承的替换原则。'
- en: '**Freeloader**: A class with too few functions, which do almost nothing and
    add little value.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Freeloader**：一个函数太少的类，几乎什么都不做，价值很小。'
- en: '**Feature Envy**: A class which is excessively dependent on methods of another
    class indicating high coupling.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Feature Envy**：一个过度依赖另一个类方法的类，表明耦合度很高。'
- en: 'At the method/function level:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法/函数级别：
- en: '**Long method**: A method or function which has grown too big and complex.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Long method**：一个变得太大和复杂的方法或函数。'
- en: '**Parameter creep**: Too many parameters for a function or method. This makes
    the call ability and testability of the function difficult.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Parameter creep**：函数或方法的参数太多。这使得函数的可调用性和可测试性变得困难。'
- en: '**Cyclomatic complexity**: A function or method with too many branches or loops,
    which creates a convoluted logic that is difficult to follow, and can cause subtle
    bugs. Such a function should be refactored and broken down to multiple functions,
    or the logic rewritten to avoid too much branching.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**圈复杂度**：具有太多分支或循环的函数或方法，这会导致复杂的逻辑难以跟踪，并可能导致微妙的错误。这样的函数应该被重构并拆分为多个函数，或者重写逻辑以避免过多的分支。'
- en: '**Overly long or short identifiers**: A function which uses either overly long
    or overly short variable names such that their purpose is not clear from their
    names. The same is applicable to the function name as well.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过长或过短的标识符**：使用过长或过短的变量名的函数，使得它们的用途无法从它们的名称中清楚地看出。对函数名称也适用相同的规则。'
- en: A related antipattern to code smell is design smell, which are the surface symptoms
    in the design of a system that indicate underlying deeper problems in the architecture.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 与代码异味相关的反模式是设计异味，这些是系统设计中的表面症状，表明架构中存在更深层次的问题。
- en: Cyclomatic complexity – the McCabe metric
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 圈复杂度 – McCabe度量
- en: Cyclomatic complexity is a measure of complexity of a computer program. It is
    computed as the number of linearly independent paths through the program's source
    code from start to finish.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 圈复杂度是计算机程序复杂性的一种度量。它被计算为程序源代码从开始到结束的线性独立路径的数量。
- en: For a piece of code with no branches at all, such as the one given next, the
    cyclomatic complexity would be `1`, as there is just one path through the code.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有任何分支的代码片段，例如接下来给出的代码，圈复杂度将为`1`，因为代码只有一条路径。
- en: '[PRE25]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A piece of code with one branch, like the following one, will have a complexity
    of 2:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 具有一个分支的代码片段，如下面的代码，复杂度将为2：
- en: '[PRE26]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The use of Cyclomatic complexity as a metric using the control graph of a code
    was developed by Thomas J. McCabe in 1976\. Hence, it is also called McCabe complexity
    or the McCabe index.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码的控制图作为度量标准的圈复杂度是由Thomas J. McCabe于1976年开发的。因此，它也被称为McCabe复杂度或McCabe指数。
- en: To measure the metric, the control graph can be pictured as a directed graph,
    where the nodes represent the blocks of the program and edges represent control
    flow from one block to another.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测量度量标准，控制图可以被描绘为一个有向图，其中节点表示程序的块，边表示从一个块到另一个块的控制流。
- en: 'With respect to the control graph of a program, the McCabe complexity can be
    expressed as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 关于程序的控制图，McCabe复杂度可以表示如下：
- en: '*M = E - N + 2P*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*M = E - N + 2P*'
- en: where,
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，
- en: '*E => Number of edges in the graph,*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*E => 图中的边数*'
- en: '*N => Number of nodes in the graph*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*N => 图中的节点数*'
- en: '*P => Number of connected components in the graph*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*P => 图中的连通分量数*'
- en: In Python, the package `mccabe`, written by Ned Batcheldor, can be used to measure
    a program's Cyclomatic complexity. It can be used as a standalone module, or as
    a plugin to programs like Flake8 or Pylint.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，可以使用由Ned Batcheldor编写的`mccabe`包来测量程序的圈复杂度。它可以作为独立模块使用，也可以作为Flake8或Pylint等程序的插件使用。
- en: 'For example, here is how we measure the Cyclomatic complexity of the two code
    pieces given earlier:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是我们如何测量前面给出的两个代码片段的圈复杂度：
- en: '![Cyclomatic complexity – the McCabe metric](../Images/image00375.jpeg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![圈复杂度 – McCabe度量](../Images/image00375.jpeg)'
- en: McCabe metrics for some sample Python programs
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例Python程序的McCabe度量
- en: The argument `–min` tells the `mccabe` module to start measuring and reporting
    from the given McCabe index.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`–min`告诉`mccabe`模块从给定的McCabe指数开始测量和报告。
- en: Testing for metrics
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试度量标准
- en: Let us now try a few of the aforementioned tools, and use them on an example
    module to find out what kind of information these tools report.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试一下前面提到的一些工具，并在一个示例模块上使用它们，以找出这些工具报告了什么样的信息。
- en: Note
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The purpose of the following sections is not to teach you the usage of these
    tools or their command-line options—these can be picked up by the reader via the
    tool's documentation. Instead, the purpose is to explore the depth and richness
    of information that these tools provide with respect to the style, logic, and
    other issues with the code.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节的目的不是教授读者如何使用这些工具或它们的命令行选项——这些可以通过工具的文档来学习。相反，目的是探索这些工具在代码的样式、逻辑和其他问题方面提供的深度和丰富信息。
- en: For purposes of this testing, the following contrived module example has been
    used. It is written purposefully with a lot of coding errors, style errors, and
    coding smells.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行这项测试，使用了以下人为构造的模块示例。它故意写有许多编码错误、样式错误和编码异味。
- en: 'Since the tools we are using lists errors by line numbers, the code has been
    presented with numbered lines so that it is easy to follow the output of the tools
    back to the code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的工具按行号列出错误，因此代码已经被呈现为带有编号的行，以便轻松地将工具的输出追溯到代码：
- en: '[PRE27]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Running Static Checkers
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行静态检查器
- en: Let us see what Pylint has to say about our rather horrible looking piece of
    test code.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Pylint对我们相当可怕的测试代码的看法。
- en: Note
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pylint prints a lot of styling errors, but the purpose of this example being
    to focus on logic issues and code smells, the log is shown only starting from
    these reports.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Pylint打印了许多样式错误，但由于这个示例的目的是专注于逻辑问题和代码异味，因此日志只显示了从这些报告开始。
- en: '[PRE28]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here is the detailed output captured in two screenshots:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是两个截图中捕获的详细输出：
- en: '![Running Static Checkers](../Images/image00376.jpeg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![运行静态检查器](../Images/image00376.jpeg)'
- en: Figure 2\. Pylint output for metric test program (page 1)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图2. 测量测试程序的Pylint输出（第1页）
- en: 'Take a look at the another screenshot:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 再看另一张截图：
- en: '![Running Static Checkers](../Images/image00377.jpeg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![运行静态检查器](../Images/image00377.jpeg)'
- en: Pylint output for metric test program (page 2)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 测量测试程序的Pylint输出（第2页）
- en: Let us focus on those very interesting last 10-20 lines of the Pylint report,
    skipping the earlier styling and convention warnings.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于Pylint报告的最后10-20行非常有趣的部分，跳过早期的样式和约定警告。
- en: 'Here are the errors, classified into a table. We have skipped similar occurrences
    to keep the table short:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是分类为表格的错误。为了保持表格的简洁，我们已跳过了类似的情况：
- en: '| Error | Occurrences | Explanation | Type of Code Smell |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 错误 | 出现次数 | 说明 | 代码异味类型 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Invalid function name | function `fn` | Name `fn` is too short toexplain
    what the function does | Too short identifier |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 无效的函数名称 | 函数`fn` | 名称`fn`太短，无法解释函数的作用 | 标识符太短 |'
- en: '| Invalid variable name | variables `x`, `y` of the `fn` function `f` | Names
    `x`, `y` too short to indicate what the variables represent | Too short identifier
    |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 无效的变量名称 | 函数`f`的变量`x`，`y` | 名称`x`，`y`太短，无法指示变量代表什么 | 标识符太短 |'
- en: '| Invalid function name | Function name `find_optimal_route_to_my_office_from_home`
    | Function name is too long | Too long identifier |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 无效的函数名称 | 函数名称`find_optimal_route_to_my_office_from_home` | 函数名称太长 | 标识符太长
    |'
- en: '| Invalid variable name | variable `d` of function `find_optimal`... | Name
    `d` too short to indicate what the variable represents | Too short identifier
    |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 无效的变量名称 | 函数`find_optimal`的变量`d` | 名称`d`太短，无法指示变量代表什么 | 标识符太短 |'
- en: '| Invalid class name | Class `C` | Name `C` doesn''t tell anything about the
    class | Too short identifier |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 无效的类名 | 类`C` | 名称`C`不表明类的任何信息 | 标识符太短 |'
- en: '| Invalid method name | Class `C`: Method `f` | Name `f` too short to explain
    what it does | Too short identifier |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 无效的方法名称 | 类`C`：方法`f` | 名称`f`太短，无法解释其作用 | 标识符太短 |'
- en: '| Invalid `__init__` method | Class `D`: Method `__init__` | Doesn''t call
    base class''s `__init__` | Breaks contract with base Class |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| 无效的`__init__`方法 | 类`D`：方法`__init__` | 不调用基类的`__init__` | 与基类的合同违约 |'
- en: '| Arguments of f differ in class `D` from class `C` | Class `D`: Method `f`
    | Method signature breaks contract with base class''s signature | Refused bequest
    |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `f`的参数在类`D`中与类`C`不同 | 类`D`：方法`f` | 方法签名与基类的签名不符 | 拒绝继承 |'
- en: '| Arguments of `g` differ in class `D` from class `C` | Class `D`: Method `g`
    | Method signature breaks contract with base class''s signature | Refused bequest
    |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `g`的参数在类`D`中与类`C`不同 | 类`D`：方法`g` | 方法签名与基类的签名不符 | 拒绝继承 |'
- en: As you can see, Pylint has detected a number of code smells, which we discussed
    in the previous section. Some of the most interesting ones are how it detected
    the absurdly long function name, and also how the subclass D breaks the contract
    with the base class `C` in its `__init__` and other methods.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '正如您所看到的，Pylint检测到了许多代码异味，我们在上一节中讨论过。其中一些最有趣的是它如何检测到荒谬的长函数名称，以及子类D如何在其`__init__`和其他方法中违反了与基类`C`的合同。 '
- en: 'Let us see what `flake8` has to tell about our code. We will run it in order
    to report the statistics and summary of error counts:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`flake8`对我们的代码有什么看法。我们将运行它以报告错误计数的统计和摘要：
- en: '[PRE29]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![Running Static Checkers](../Images/image00378.jpeg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![运行静态检查器](../Images/image00378.jpeg)'
- en: Figure 4\. flake8 static check output of metric test program
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图4。度量测试程序的flake8静态检查输出
- en: As you would've expected from a tool which is written to mostly follow PEP-8
    conventions, the errors reported are all styling and convention errors. These
    errors are useful to improve the readability of the code, and make it follow closer
    to the style guidelines of PEP-8.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的那样，这个工具大部分是按照PEP-8约定编写的，报告的错误都是样式和约定错误。这些错误对于提高代码的可读性并使其更接近PEP-8的样式指南是有用的。
- en: Note
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can get more information about the PEP-8 tests by passing the option `–show-pep8`
    to Flake8.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将选项“-show-pep8”传递给Flake8，您可以获取有关PEP-8测试的更多信息。
- en: 'It is a good time to now check the complexity of our code. First, we will use
    `mccabe` directly, and then call it via Flake8:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是检查我们的代码复杂性的好时机。首先，我们将直接使用`mccabe`，然后通过Flake8调用它：
- en: '![Running Static Checkers](../Images/image00379.jpeg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![运行静态检查器](../Images/image00379.jpeg)'
- en: mccabe complexity of metric test program
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 度量测试程序的mccabe复杂度
- en: As expected, the complexity of the office-route function is too high, as it
    has too many branches and sub-branches.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，办公室路线函数的复杂性太高，因为它有太多的分支和子分支。
- en: 'As `flake8` prints too many styling errors, we will grep specifically for the
    report on complexity:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`flake8`打印了太多的样式错误，我们将专门搜索复杂性的报告：
- en: '![Running Static Checkers](../Images/image00380.jpeg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![运行静态检查器](../Images/image00380.jpeg)'
- en: mccabe complexity of metric test program as reported by flake8
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 由flake8报告的度量测试程序的mccabe复杂度
- en: As expected, Flake8 reports the function find `_optimal_route_to_my_office_from_home`
    as too complex.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，Flake8报告了函数`find_optimal_route_to_my_office_from_home`的复杂性太高。
- en: Note
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a way to run `mccabe` as a plugin from Pylint as well, but since it
    involves some configuration steps, we will not cover it here.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方法可以从Pylint作为插件运行`mccabe`，但由于涉及一些配置步骤，我们将不在这里介绍。
- en: 'As a last step, let us run `pyflakes` on the code:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步，让我们在代码上运行`pyflakes`：
- en: '![Running Static Checkers](../Images/image00381.jpeg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![运行静态检查器](../Images/image00381.jpeg)'
- en: Static analysis output of pyflakes on the metric test code
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: pyflakes对度量测试代码的静态分析输出
- en: There is no output! So Pyflakes finds no issues with the code. The reason is
    that PyFlakes is a basic checker, which does not report anything beyond the obvious
    syntax and logic errors, unused imports, missing variable names, and the liked.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 没有输出！因此，Pyflakes在代码中找不到任何问题。原因是PyFlakes是一个基本的检查器，除了明显的语法和逻辑错误、未使用的导入、缺少变量名称和类似的问题外，它不报告任何其他问题。
- en: 'Let us add some errors into our code, and rerun Pyflakes. Here is the adjusted
    code with line numbers:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的代码中添加一些错误，然后重新运行Pyflakes。以下是带有行号的调整后的代码：
- en: '[PRE30]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Take a look at the following output:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '看一下以下输出： '
- en: '![Running Static Checkers](../Images/image00382.jpeg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![运行静态检查器](../Images/image00382.jpeg)'
- en: Figure 8\. Static analysis output of pyflakes on the metric test code, after
    modifications
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图8。修改后的度量测试代码的pyflakes静态分析输出
- en: Pyflakes now returns some useful information in terms of a missing name (random),
    unused import (`sys`), and an undefined name (variable `c` in the newly introduced
    function `myfunc`). So it does perform some useful static analysis on the code.
    For example, the information on the missing and undefined names is useful to fix
    obvious bugs in the preceding code.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Pyflakes现在返回一些有用的信息，例如缺少名称（random）、未使用的导入（`sys`）和新引入函数`myfunc`中的未定义名称（变量`c`）。因此，它对代码进行了一些有用的静态分析。例如，有关缺少和未定义名称的信息对于修复前面代码中的明显错误很有用。
- en: Tip
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is a good idea to run Pylint and/or Pyflakes on your code to report and figure
    out logic and syntax errors after the code is written. To run Pylint to report
    only errors, use the -E option. To run Pyflakes, just follow the preceding example.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码后，运行Pylint和/或Pyflakes对代码进行报告和查找逻辑和语法错误是个好主意。要运行Pylint仅报告错误，使用-E选项。要运行Pyflakes，只需按照前面的示例。
- en: Refactoring Code
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构代码
- en: Now that we have seen how static tools can be used to report a wide range of
    errors and issues in our Python code, let us do a simple exercise of refactoring
    our code. We will take our poorly written metric test module as the use case (the
    first version of it), and perform a few refactoring steps.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到静态工具如何用于报告我们Python代码中的各种错误和问题，让我们做一个简单的重构练习。我们将以我们编写不好的度量测试模块作为用例（它的第一个版本），并执行一些重构步骤。
- en: 'Here are the rough guidelines we will follow when doing the refactoring:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行重构时，我们将遵循以下大致指南：
- en: '**Fix complex code first**: This will get a lot of code out of the way, as
    typically, when a complex piece of code is refactored, we end up reducing the
    number of lines of code. This overall improves the code quality, and reduces code
    smells. You may be creating new functions or classes here, so it always helps
    to perform this step first.'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**首先修复复杂代码**：这将大量代码放在一边，因为通常情况下，当复杂的代码被重构时，我们最终会减少代码行数。这将全面改善代码质量，并减少代码异味。您可能会在这里创建新的函数或类，因此最好先执行此步骤。'
- en: '**Do an analysis of the code now**: It is a good idea to run the complexity
    checkers at this step, and see how the overall complexity of the code—class/module
    or functions—has been reduced. If not, iterate again.'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**现在对代码进行分析**：在这一步运行复杂性检查器是个好主意，看看代码的整体复杂性——类/模块或函数——是否有所减少。如果没有，再次迭代。'
- en: '**Fix code smells next**: Fix any issue with code smells—class, function, or
    module—next. This gets your code into a much better shape, and also improves the
    overall semantics.'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**接下来修复代码异味**：接下来修复任何与代码异味有关的问题——类、函数或模块。这将使您的代码变得更好，并且还会改善整体语义。'
- en: '**Run checkers**: Run checkers like Pylint on the code now, and get a report
    on the code smells. Ideally, they should be close to zero, or reduced very much
    from the original.'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行检查器**：现在在代码上运行Pylint等检查器，并获取有关代码异味的报告。理想情况下，它们应该接近零，或者与原始值相比大大减少。'
- en: '**Fix low-hanging fruits**: Fix low-hanging fruits such as code style and convention
    errors, the last. This is because, in the process of refactoring, trying to reduce
    complexity and code smells, you typically would introduce or delete a lot of code.
    So, it doesn''t make sense to try and improve the coding convention at earlier
    stages.'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修复低悬果**：最后修复低悬果，如代码风格和约定错误。这是因为在重构过程中，试图减少复杂性和代码异味时，通常会引入或删除大量代码。因此，在较早的阶段尝试改进编码约定是没有意义的。'
- en: '**Perform a final check using the tools**: You can run Pylint for code smells,
    Flake8 for PEP-8 conventions, and Pyflakes for catching the logic, syntax, and
    missing variable issues.'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用工具进行最终检查**：您可以运行Pylint检查代码异味，运行Flake8检查PEP-8约定，运行Pyflakes捕获逻辑、语法和缺少变量问题。'
- en: Here is a step-by-step demonstration of fixing our poorly written metric test
    module using this approach in the next section.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个逐步演示，使用下一节中的方法修复我们编写不好的度量测试模块的过程。
- en: Refactoring code – fixing complexity
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构代码-修复复杂性
- en: 'Most of the complexity is in the office route function, so let''s try and fix
    it. Here is the rewritten version (showing only that function here):'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分复杂性在office route函数中，所以让我们尝试修复它。这是重写的版本（仅显示该函数）：
- en: '[PRE31]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding rewrite, we got rid of the redundant if.. else conditions.
    Let us check the complexity now:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的重写中，我们摆脱了多余的if.. else条件。现在让我们检查一下复杂性：
- en: '![Refactoring code – fixing complexity](../Images/image00383.jpeg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![重构代码-修复复杂性](../Images/image00383.jpeg)'
- en: 'mccabe metric of metric test program after refactoring step #1'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 重构步骤#1后度量测试程序的mccabe度量
- en: We were able to reduce the complexity from `7` to `5`. Can we do better?
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将复杂性从`7`降低到`5`。我们能做得更好吗？
- en: 'In the following piece of code, the code is rewritten to use ranges of values
    as keys, and the corresponding return value as values. This simplifies our code
    a lot. Also, the earlier default return at the end would never have got picked,
    so it is removed now, thus getting rid of a branch and reducing complexity by
    one. The code has become much simpler:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，代码被重写为使用值范围作为键，相应的返回值作为值。这大大简化了我们的代码。此外，之前的默认返回最终永远不会被选中，所以现在它被移除了，从而消除了一个分支，并减少了一个复杂性。代码变得简单多了：
- en: '[PRE32]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![Refactoring code – fixing complexity](../Images/image00384.jpeg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![重构代码-修复复杂性](../Images/image00384.jpeg)'
- en: 'mccabe metric of metric test program after refactoring step #2'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 重构步骤#2后度量测试程序的mccabe度量
- en: The complexity of the function is now reduced to `4`, which is manageable.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的复杂性现在降低到`4`，这是可以管理的。
- en: Refactoring code - fixing code smells
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构代码-修复代码异味
- en: The next step is to fix code smells. Thankfully, we have a very good list from
    the previous analysis, so this is not too difficult. Mostly, we need to change
    function names, variable names, and also fix the contract issue from sub-class
    to base-class.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是修复代码异味。幸运的是，我们有一个非常好的列表来自上一次分析，所以这并不太困难。大多数情况下，我们需要更改函数名称、变量名称，并且还需要从子类到基类修复合同问题。
- en: 'Here is the code with all the fixes:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所有修复的代码：
- en: '[PRE33]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let us run Pylint on this code, and see what it outputs this time:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这段代码上运行Pylint，看看这次它输出了什么：
- en: '![Refactoring code - fixing code smells](../Images/image00385.jpeg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![重构代码-修复代码异味](../Images/image00385.jpeg)'
- en: Pylint output of refactored metric test program
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后的度量测试程序的Pylint输出
- en: You see that the number of code smells has boiled down to near zero except a
    complaint of lack of `public` methods, and the insight that the method `some_func`
    of class `MiscClassD` can be a function, as it does not use any attributes of
    the class.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现代码异味的数量已经减少到接近零，除了缺少`public`方法的投诉，以及类`MiscClassD`的方法`some_func`可以是一个函数的洞察，因为它不使用类的任何属性。
- en: Note
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have invoked Pylint with the option `–reports=n` in order to avoid Pylint
    printing its summary report, as it would make the entire output too long to display
    here. These reports can be enabled by calling Pylint without any argument.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用选项`–reports=n`调用了Pylint，以避免Pylint打印其摘要报告，因为这样会使整个输出太长而无法在此处显示。可以通过调用Pylint而不带任何参数来启用这些报告。
- en: Refactoring code - fixing styling and coding issues
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构代码-修复样式和编码问题
- en: Now that we have fixed the major code issues, the next step is to fix code style
    and convention errors. However, in order to shorten the number of steps and the
    amount of code to be printed in this book for this exercise, this was already
    merged along with the last step, as you may have guessed from the output of Pylint.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了主要的代码问题，下一步是修复代码风格和约定错误。然而，为了缩短步骤数量和在本书中打印的代码量，这已经与最后一步合并，正如您可能从Pylint的输出中猜到的那样。
- en: Except for a few whitespace warnings, all the issues are fixed.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一些空白警告之外，所有问题都已解决。
- en: This completes our refactoring exercise.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的重构练习。
- en: Summary
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the architectural quality attribute of modifiability,
    and its various aspects. We discussed readability in some detail, including the
    readability antipatterns along with a few coding antipatterns. During the discussion,
    we understood that Python, from its ground up, is a language written for readability.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了修改性的架构质量属性及其各个方面。我们详细讨论了可读性，包括可读性反模式以及一些编码反模式。在讨论过程中，我们了解到Python从根本上就是一种为了可读性而编写的语言。
- en: We looked at the various techniques for improving readability of code, and spent
    some time with the various aspects of code commenting and looked at documentation
    strings in Python at the function, class, and module levels. We also looked at
    PEP-8, the official coding convention guideline for Python, and learned that continuous
    refactoring of code is important to keep up its modifiability and to reduce its
    maintenance costs in the long term.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了改进代码可读性的各种技术，并花了一些时间讨论了代码注释的各个方面，并在函数、类和模块级别上看了Python的文档字符串。我们还看了PEP-8，这是Python的官方编码约定指南，并了解到持续重构代码对于保持其可修改性并在长期内减少维护成本是很重要的。
- en: We then looked at some rules of thumb for code comments, and went on to discuss
    the fundamentals of modifiability, namely, coupling and cohesion of code. We looked
    at different cases of coupling and cohesion with a few examples. We then went
    on to discuss the strategies of improving modifiability of code such as providing
    explicit interfaces or APIs, avoiding two-way dependencies, abstracting common
    services to helper modules, and using inheritance techniques. We looked at an
    example where we refactored a class hierarchy via inheritance to abstract away
    common code and to improve the modifiability of the system.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看了一些代码注释的经验法则，并讨论了代码的修改性基本原理，即代码的耦合性和内聚性。我们用一些例子看了不同情况下的耦合和内聚。然后我们讨论了改进代码修改性的策略，比如提供明确的接口或API、避免双向依赖、将常见服务抽象到辅助模块中，以及使用继承技术。我们看了一个例子，通过继承重构了一个类层次结构，以抽象出共同的代码并改进系统的修改性。
- en: Towards the end, we listed the different tools providing static code metrics
    in Python such as PyLint, Flake8, PyFlakes, and others. We learned about McCabe
    Cyclomatic complexity with the help of a few examples. We also learned what code
    smells are, and performed a refactoring exercise to improve the quality of the
    piece of code in stages.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们列出了提供Python静态代码度量的不同工具，如PyLint、Flake8、PyFlakes等。我们通过一些例子了解了McCabe圈复杂度。我们还了解了代码异味是什么，并进行了重构练习，以逐步改进代码的质量。
- en: In the next chapter, we'll discuss another important quality attribute of software
    architecture, namely, Testability.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论软件架构的另一个重要质量属性，即可测试性。
