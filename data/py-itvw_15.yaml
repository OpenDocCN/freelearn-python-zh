- en: Chapter 15. Oliver Schoenborn
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章。Oliver Schoenborn
- en: '![Oliver Schoenborn](img/B08180_10_01.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![Oliver Schoenborn](img/B08180_10_01.jpg)'
- en: Oliver Schoenborn is a Canadian software developer and independent software
    developer. Past roles have included working as a simulation consultant at CAE
    Inc and as a visualization software developer at the National Research Council
    Canada. Oliver is passionate about connecting with the business and government
    communities. He is the author of Pypubsub (hosted at [https://github.com/schollii/pypubsub](https://github.com/schollii/pypubsub)),
    a Python package that gives users a simple way to decouple parts of their event-based
    application. Oliver regularly updates Pypubsub and contributes to the wxPython
    mailing list.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Oliver Schoenborn是一位加拿大软件开发商和独立软件开发商。他过去的工作经历包括在CAE公司担任模拟顾问以及在加拿大国家研究委员会担任可视化软件开发者。Oliver热衷于与商业和政府社区建立联系。他是Pypubsub（托管在[https://github.com/schollii/pypubsub](https://github.com/schollii/pypubsub)）的作者，这是一个Python包，为用户提供了一种简单的方法来解耦他们基于事件的程序的部分。Oliver定期更新Pypubsub，并为wxPython邮件列表做出贡献。
- en: '**Discussion themes: Pypubsub, Python in AI, Python''s future.**'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**讨论主题：Pypubsub、Python在人工智能中的应用、Python的未来。**'
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Catch up with Oliver Schoenborn here: @schollii2**'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**与Oliver Schoenborn保持联系：@schollii2**'
- en: '**Mike Driscoll**: So let''s start with your background. Why did you decide
    to become a programmer?'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mike Driscoll**：那么，让我们从你的背景开始。你为什么决定成为一名程序员？'
- en: '**Oliver Schoenborn**: Well, a buddy at school was selling his Apple IIe. I
    had never done programming before that, but I decided to buy his used computer.
    I was 14 at the time.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**Oliver Schoenborn**：嗯，学校的一个朋友在卖他的Apple IIe。在那之前，我从未编程过，但我决定买下他的二手电脑。我当时14岁。'
- en: I remember being quite intrigued by the BASIC and assembly language. There was
    a command prompt and you could somehow drop into the assembly level to write assembly.
    I read the many manuals for the computer, which described how to program it. I
    tried to write some little programs and eventually got into Pascal. I really enjoyed
    it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得我对BASIC和汇编语言非常感兴趣。有一个命令提示符，你可以以某种方式进入汇编级别来编写汇编代码。我阅读了计算机的许多手册，它们描述了如何编程。我尝试编写了一些小程序，最终进入了Pascal。我真的很喜欢它。
- en: In my fifth year of high school, a school teacher asked us to do something with
    a language called Logo. It was basically graphics commands to move a pen right,
    left, draw lines etc. I created a simulation loop in there so that I could simulate
    a little aircraft flying and dropping a bomb. It was very simple but it was fun,
    and the teacher was impressed!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我高中第五年时，一位老师要求我们用一种叫做Logo的语言做一些事情。它基本上是一组图形命令，用来移动笔、画线等。我在那里创建了一个模拟循环，这样我就可以模拟一个小飞机飞行并投下炸弹。这很简单，但很有趣，老师也很印象深刻！
- en: So that's how I got into programming. It was more or less a chance in some ways.
    At that point, programming was still just a hobby, because my goal was to get
    into physics.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我就这样进入了编程。在某种程度上，这更像是一个机会。那时，编程仍然只是个爱好，因为我的目标是进入物理学。
- en: '**Driscoll**: So how did you end up getting into Python itself?'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driscoll**：那么你是如何最终接触到Python本身的？'
- en: '**Schoenborn**: At work we had a project that needed some graphical user interface
    development on Windows.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**Schoenborn**：在工作时，我们有一个需要在Windows上开发图形用户界面的项目。'
- en: For the previous 10 years, I had mostly programmed in C++ on UNIX, developing
    command line and 3D graphics applications, but not menu-based applications (except
    for a GUI written in Java AWT). I really dreaded MFC, so I started looking into
    options on Windows for doing that. I came across Python (because it was platform
    independent), and Tk.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的10年里，我主要在UNIX上用C++编程，开发命令行和3D图形应用程序，但不是基于菜单的应用程序（除了用Java AWT编写的GUI）。我真的很讨厌MFC，所以我开始寻找Windows上做这个的选项。我发现了Python（因为它具有平台无关性），还有Tk。
- en: '**Oliver Schoenborn: ''Python was the perfect fit. As soon as I saw the language,
    I really related to its simple and clean syntax.''**'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Oliver Schoenborn**：“Python是完美的选择。一看到这种语言，我就真的喜欢上了它的简单和清晰的语法。”'
- en: Python was the perfect fit. As soon as I saw the language, I really related
    to its simple and clean syntax. I don't know if it just matched my way of thinking.
    I also found wxPython and saw that its API seemed to be rather solid. I fell in
    love with Python and the ability it provided to quickly create interfaces using
    wxPython.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Python是完美的选择。一看到这种语言，我就真的喜欢上了它的简单和清晰的语法。我不知道它是否只是与我思维方式相匹配。我还发现了wxPython，并看到它的API似乎相当稳固。我爱上了Python以及它提供的快速创建wxPython界面的能力。
- en: So how I got into Python was through a work project that had requirements that
    were more easily achievable in Python than in C++.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我是如何接触到 Python 的呢？是通过一个工作项目，这个项目的要求在 Python 中比在 C++ 中更容易实现。
- en: '**Driscoll**: Was this how you got involved with the wxPython community as
    well?'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driscoll**：这是你如何参与 wxPython 社区的吗？'
- en: '**Schoenborn**: That''s right. I developed my first application in wxPython
    as a result of that project. It was an application for analyzing seat heating
    and air-conditioning. Back then, automobile seat comfort was being prototyped
    using this kind of software.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**Schoenborn**：没错。我之所以开发我的第一个 wxPython 应用程序，是因为那个项目。这是一个分析座椅加热和空调的应用程序。当时，汽车座椅的舒适性正在使用这种软件进行原型设计。'
- en: So I used wxPython and I thought that the publish-subscribe pattern that it
    supported was a really awesome idea. I got involved more heavily with the wxPython
    development by taking over the Pubsub component of that library.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我使用了 wxPython，并认为它支持的发布-订阅模式是一个非常棒的想法。我通过接管那个库的 Pubsub 组件，更深入地参与了 wxPython
    的开发。
- en: '**Oliver Schoenborn: ''I got involved more heavily with wxPython development
    by taking over the Pubsub component of the wxPython library.''**'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Oliver Schoenborn**：“我通过接管 wxPython 库的 Pubsub 组件，更深入地参与了 wxPython 的开发。”'
- en: '**Driscoll**: So was Pubsub started by someone else?'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driscoll**：那么 Pubsub 是由其他人开始的吗？'
- en: '**Schoenborn**: Yes, Robb Shecter created the first version of Pubsub. There
    were limitations that I needed to get around (mostly, a memory leak: subscribers
    were not released after they were no longer needed by the application), and I
    proposed some significant patches and unit tests. Robb was looking for someone
    to take over `wx.lib.pubsub`. So I did that.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**Schoenborn**：是的，Robb Shecter 创建了 Pubsub 的第一个版本。有一些限制需要我解决（主要是内存泄漏：订阅者在不再被应用程序需要后没有被释放），我提出了一些重要的补丁和单元测试。Robb
    正在寻找接手 `wx.lib.pubsub` 的人。所以我做了这件事。'
- en: '**Driscoll**: Is that also when Pubsub got split into its own module away from
    wxPython?'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driscoll**：这是 Pubsub 被分割成自己的模块，脱离 wxPython 的时候吗？'
- en: '**Schoenborn**: I think it was a couple of years later. Pubsub was pretty much
    a standalone sub-package, whereas most other wx.lib sub-packages required other
    wxPython components. I wanted to make wx.lib.pubsub available to a broader set
    of developers, and others on the wxPython developers group agreed.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**Schoenborn**：我认为是在那之后的几年。Pubsub 几乎是一个独立的子包，而其他大多数 wx.lib 子包需要其他 wxPython
    组件。我想让 wx.lib.pubsub 对更广泛的开发者可用，并且 wxPython 开发者小组的其他人也同意了。'
- en: '**Oliver Schoenborn: ''Pubsub was pretty much a standalone component.''**'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Oliver Schoenborn**：“Pubsub 几乎是一个独立的组件。”'
- en: '**Driscoll**: Were you guys aware of the PyDispatcher projects at that time?'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driscoll**：当时你们是否知道 PyDispatcher 项目？'
- en: '**Schoenborn**: Well, I did become aware of PyDispatcher at some point in those
    years. It was quite a different approach.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**Schoenborn**：嗯，我在那些年中的某个时候确实意识到了 PyDispatcher。它是一个相当不同的方法。'
- en: I remember that at the time it was not topic- based. Pubsub was sufficiently
    different from it to be justified as a separate package. It has been a while since
    I have looked at it, but it would be interesting actually to see where PyDispatcher
    is at now.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得当时它不是基于主题的。Pubsub 与它足够不同，以至于可以作为一个独立的包来证明其合理性。自从上次查看它以来已经有一段时间了，但实际看看 PyDispatcher
    现在处于什么位置会很有趣。
- en: There are several projects now that use the basic idea of topics, messaging,
    and publish/subscribe (such as MQTT and Google pub/sub), but at the network, that
    is the inter-application level, whereas Pypubsub is at the application inter-component
    level. They have evolved much more than Pubsub has had to evolve; Pypubsub is
    mature and production quality.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有几个项目正在使用主题、消息和发布/订阅的基本思想（例如 MQTT 和 Google pub/sub），但在网络层面，即应用程序之间的层面，而 Pypubsub
    是在应用程序的组件之间层面。它们的发展比 Pubsub 必须发展的要多得多；Pypubsub 已经成熟，是生产级别的。
- en: '**Driscoll**: So I noticed that when you did that interview with me in the
    PyDev of the Week series, you had switched to PyQt. How did that happen?'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driscoll**：所以我注意到，在你参加我在“PyDev of the Week”系列中的采访的时候，你已经切换到了 PyQt。这是怎么发生的？'
- en: '**Schoenborn**: That was some time in 2013\. We basically had this project
    that involved modernizing an old prototype that our client had. The application
    involved user-defined scripts that could be run by the prototype and those were
    all written in Python. So we had to either embed a Python interpreter, or translate
    huge Python scripts into another language, while guaranteeing the same outputs,
    (a task that could not fit within the scope of the project budget).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**肖恩博恩：**那是在2013年左右。我们基本上有一个项目，涉及现代化我们的客户的一个旧原型。该应用程序涉及用户定义的脚本，这些脚本可以通过原型运行，并且都是用Python编写的。因此，我们不得不嵌入一个Python解释器，或者将大量的Python脚本翻译成另一种语言，同时保证相同的输出（这是一个无法在项目预算范围内完成的任务）。'
- en: '**Oliver Schoenborn: ''We had to either embed a Python interpreter, or translate
    huge Python scripts.''**'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**奥利弗·肖恩博恩：''我们不得不嵌入一个Python解释器，或者翻译大量的Python脚本。''**'
- en: The graphics interface had to be very sophisticated. At the time, the prototype
    had a 3D component, where the user could rotate model components in a 3D environment.
    We needed to integrate the graphical user interface with menus and list views
    as a sophisticated 2D and 3D canvas, where the user could interact with things.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图形界面必须非常复杂。当时，原型有一个3D组件，用户可以在3D环境中旋转模型组件。我们需要将图形用户界面与菜单和列表视图集成，作为一个复杂的2D和3D画布，用户可以与之交互。
- en: We wanted something that was stable, powerful, and well-documented, with an
    active community behind it. At the time, WPF, wxPython, and PyQt (or Qt, for a
    C++ infrastructure) were the main candidates for us. On the C# side there was
    WPF. We looked at a number of different approaches and in the end it was between
    wxPython and PyQt.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的是一个稳定、强大、文档完善的解决方案，背后有一个活跃的社区。当时，WPF、wxPython和PyQt（或Qt，用于C++基础设施）是我们主要的候选者。在C#方面有WPF。我们考虑了多种不同的方法，最后在wxPython和PyQt之间选择了。
- en: PyQt seemed to have more powerful integration of a 3D environment than wxPython
    did. PyQt also seemed to be quickly growing towards supporting a 3D scene graph,
    whereas in wxPython I would have had to use OpenGL, and this would have been more
    complicated.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: PyQt似乎比wxPython有更强大的3D环境集成。PyQt似乎也在迅速增长，以支持3D场景图，而在wxPython中，我可能需要使用OpenGL，这将更加复杂。
- en: Python 3 was required, but I think that's when Robin Dunn decided to create
    wxPython 3, and so the work on supporting Python 3 was still very early. Basically,
    there was only Python 2.7 for wxPython and the availability of Qt Designer was
    also a factor. PyQt had a very sophisticated interface for creating designs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 需要Python 3，但我认为那是罗宾·邓恩决定创建wxPython 3的时候，因此支持Python 3的工作还非常早期。基本上，wxPython只有Python
    2.7，Qt Designer的可用性也是一个因素。PyQt在创建设计时有一个非常复杂的界面。
- en: '**Oliver Schoenborn: ''PyQt definitely seemed to have momentum.''**'
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**奥利弗·肖恩博恩：''PyQt显然有势头。''**'
- en: An XML-driven user interface description was supported by both PyQt and WPF.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: PyQt和WPF都支持由XML驱动的用户界面描述。
- en: PyQt definitely seemed to have momentum, and it supported commercial use of
    the package, which was important for that project. I had had some negative experiences
    with WPF, fighting with the black-magic that it used in order to bind properties
    to widgets. Also, there were signs that IronPython was unmaintained. All things
    considered, we picked PyQt. We did not regret the choice.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: PyQt显然有势头，并且支持该包的商业使用，这对那个项目来说很重要。我之前与WPF有过一些负面体验，与它用来将属性绑定到小部件的黑魔法作斗争。此外，有迹象表明IronPython不再维护。综合考虑，我们选择了PyQt。我们没有后悔这个选择。
- en: '**Driscoll**: Going back to the Pypubsub part, I forgot to ask you, did you
    have any challenges while running that open source project that you''d like to
    talk about?'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里科：**回到Pypubsub部分，我忘记问你了，你在运行那个开源项目时遇到了什么挑战吗？'
- en: '**Schoenborn**: Well, it wasn''t really a technical challenge, but I did have
    an interesting experience from an open source development point of view. It reminded
    me that you don''t really control the space that you can occupy in the open source
    world.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**肖恩博恩：**嗯，那并不是一个技术挑战，但我确实从开源开发的角度有一个有趣的经验。这让我想起，你实际上并不能控制你在开源世界中可以占据的空间。'
- en: '**Oliver Schoenborn: ''You don''t really control the space that you can occupy
    in the open source world.''**'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**奥利弗·肖恩博恩：''你实际上并不能控制你在开源世界中可以占据的空间。''**'
- en: What happened was that Pypubsub was on SourceForge, where it was named simply
    "pubsub", because that's how it was named in wxPython. On PyPI I had named it
    pypubsub. A couple of years later, I found out that there was another project
    on SourceForge called Pypubsub, but it hadn't gone anywhere. Basically, it was
    a dead project and sometimes it led to some confusion on Stack Overflow and the
    two pypubsub forums.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情是Pypubsub在SourceForge上，那里的名字简单地是“pubsub”，因为这就是在wxPython中的命名。在PyPI上，我把它命名为pypubsub。几年后，我发现SourceForge上还有一个名为Pypubsub的项目，但它并没有取得进展。基本上，这是一个已经停止的项目，有时它会导致Stack
    Overflow和两个pypubsub论坛上的一些混淆。
- en: That took some effort to straighten out. I had to contact the author and explain
    what was going on. Eventually, he agreed and I was able to take ownership of the
    "pypubsub" name on SourceForge.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一些努力才能弄清楚。我不得不联系作者并解释发生了什么。最终，他同意了，我得以在SourceForge上拥有“pypubsub”这个名称。
- en: In the meantime, GitHub had become really popular. Some people had copied my
    Pypubsub source code into GitHub, just to have it handy. Nothing wrong with that,
    but since these forks were not to add features, when I actually decided to move
    Pypubsub to GitHub, I had to let some devs know that Pypubsub was finally available
    there. I explained that there probably was no longer a good reason to have separate
    copies. This was an interesting aspect of open source.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，GitHub已经变得非常流行。有些人把我的Pypubsub源代码复制到GitHub上，只是为了方便使用。这没什么不妥，但既然这些分支并没有添加新功能，当我决定将Pypubsub迁移到GitHub时，我不得不通知一些开发者Pypubsub最终可以在那里找到。我解释说，可能已经没有理由保留单独的副本了。这是开源的一个有趣方面。
- en: '**Driscoll**: How much of a commitment was the project?'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**德里科：**这个项目需要多大的承诺？'
- en: '**Schoenborn**: Well, there have been various periods during the past 15 years
    when I made major changes to the implementation and extended the API: fixing bugs,
    updating documentation, and make sure that all tests work when there was a new
    release of Python. Finding the time to do those things was often a challenge.
    It is, I guess, another interesting aspect of working on a volunteer basis.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**肖恩博恩：**嗯，在过去15年的不同时期，我进行了重大的实现更改并扩展了API：修复错误、更新文档，并确保在Python的新版本发布时所有测试都能通过。找到时间做这些事情通常是一个挑战。我想，这也是在志愿者基础上工作的另一个有趣方面。'
- en: Evolving the API, while maintaining backwards compatibility, was mostly requested
    by Robin, the wxPython author, and this was important to me even if Pypubsub was
    technically separate from wxPython. It was a major technical challenge to make
    that possible. This led to the concept of Pubsub supporting three APIs or messaging
    protocols.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在保持向后兼容的同时演进API，主要是罗宾，wxPython的作者所要求的，即使Pypubsub在技术上与wxPython分开，这对我也很重要。这是一个重大的技术挑战，使得这一切成为可能。这导致了Pubsub支持三个API或消息协议的概念。
- en: '**Oliver Schoenborn: ''It was a major technical challenge.''**'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**奥利弗·肖恩博恩：**“这是一个重大的技术挑战。”'
- en: First, there was backwards compatibility with the very first version of Pubsub.
    That was what I called the version 1 messaging protocol. Then there was the sort
    of "modern" Pubsub, which had significant improvements in the API, and there were
    two APIs for that.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，与Pubsub的第一个版本保持向后兼容。这就是我所说的版本1消息协议。然后是“现代”Pubsub，它在API方面有显著的改进，并且有两个API。
- en: One was called `arg1` because all message data was in one big blob given as
    one argument to the `sendMessage()` function. The other was called `kwargs` because
    message data was sent via keyword arguments in the `sendMessage()` function. That
    was the default when you installed Pypubsub standalone.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个被称作`arg1`，因为所有消息数据都包含在一个大块中，作为`sendMessage()`函数的一个参数传递。另一个被称作`kwargs`，因为消息数据是通过`sendMessage()`函数中的关键字参数发送的。当你独立安装Pypubsub时，这是默认设置。
- en: A vanilla installation of wxPython would install the `arg1` API, since that
    one was almost 100% compatible with the version 1 API. A setup flag could be set
    in the application code, before importing Pypubsub, to choose the `kwargs` protocol..
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个标准的wxPython安装会安装`arg1` API，因为这与版本1 API几乎100%兼容。可以在导入Pypubsub之前在应用程序代码中设置一个设置标志，以选择`kwargs`协议。
- en: So getting all that to work was a major headache. I had to sort of hijack the
    import system a little bit, basically to allow for the user to say, "Well in this
    application I want the `arg1` protocol and in this wxPython application, I want
    the `kwargs` protocol.."
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让所有这些工作起来是一个巨大的头疼问题。我不得不稍微篡改一下导入系统，基本上是为了允许用户说：“嗯，在这个应用程序中，我想使用`arg1`协议，而在这个wxPython应用程序中，我想使用`kwargs`协议。”
- en: I also added some code to help transition a wxPython application from version
    1 to `arg1`, to `kwargs` protocol. That was tough too.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我还添加了一些代码，帮助wxPython应用程序从版本1过渡到`arg1`，再到`kwargs`协议。这也很困难。
- en: I really wish that I hadn't had to do all that, but I felt at the time that
    it was a necessary evil.. Other than code complexity, it made the import system
    used by Pypubsub rather complicated, which could interfere with freezing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的很希望我没有做所有那些事情，但当时我觉得这是必要的恶行。除了代码复杂性之外，它使Pypubsub使用的导入系统相当复杂，可能会干扰冻结。
- en: '**Driscoll**: Why did you focus on making this transition possible?'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driscoll**：你为什么专注于使这种过渡成为可能？'
- en: '**Schoenborn**: Because I had to go through that challenge in one of my own
    applications on a project. It was using the `arg1` protocol and migrating it to
    the new `kwargs` protocol. Although not complex, this was somewhat tedious and
    error prone. It was worth adding these error checkers and going through the transition,
    due to the advantages of the `kwargs` API.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**Schoenborn**：因为我必须在我自己的一个项目应用中经历那个挑战。它使用`arg1`协议并将其迁移到新的`kwargs`协议。虽然不算复杂，但这有点繁琐且容易出错。由于`kwargs`
    API的优势，添加这些错误检查器并经历过渡是值得的。'
- en: I had the concept of a parameter that you could set when you imported Pypubsub.
    This would configure Pypubsub to do some "in-between" tasks, that were useful
    during a transition between the two messaging protocols. The bridge would allow
    you to gradually move towards being fully kwargs, with some helpful facilities
    along the way.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个概念，可以在导入Pypubsub时设置参数。这将配置Pypubsub执行一些“中间”任务，这些任务在两种消息协议之间的过渡期间很有用。这个桥梁将允许你逐步过渡到完全使用kwargs，沿途还有一些有用的设施。
- en: '**Oliver Schoenborn: ''The code was certainly more complex than I wanted it
    to be.''**'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Oliver Schoenborn**：''代码确实比我想要的要复杂。''**'
- en: Getting to a stable API took quite a bit of effort. The frustration was that
    the code was certainly more complex than I wanted it to be, so it was a harder
    to maintain and harder to trace calls through Pypubsub. Also, it caused some challenges
    for people who wanted to freeze their application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个稳定的API花费了相当多的努力。令人沮丧的是，代码确实比我想要的要复杂，因此维护起来更困难，通过Pypubsub追踪调用也更困难。此外，它也给那些想要冻结其应用程序的人带来了一些挑战。
- en: As soon as I was able to, I suggested we deprecate all of that old stuff, since
    it was only useful for the wxPython app with the old API. Robin agreed. In 2016,
    I dropped all support for version 1 and arg1 protocols, allowing for a major clean
    up and the simplification of the code base. So now there's just one API. This
    is v4 of Pypubsub.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我有能力，我就建议我们废弃所有那些旧的东西，因为它们只对具有旧API的wxPython应用程序有用。罗宾同意了。2016年，我放弃了所有对版本1和arg1协议的支持，从而实现了代码库的重大清理和简化。所以现在只有一个API。这是Pypubsub的v4版本。
- en: '**Driscoll**: So can you tell me about some other Python projects that you''ve
    been involved with lately?'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driscoll**：那么你能告诉我你最近参与的一些其他Python项目吗？'
- en: '**Schoenborn**: Sure, one is a really cool closed-source project, which is
    very challenging technically, with a very sophisticated GUI. I actually mentioned
    it indirectly in discussing the reason for working with PyQt in recent years.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**Schoenborn**：当然，有一个非常酷的闭源项目，技术上具有挑战性，GUI非常复杂。我实际上在讨论近年来与PyQt合作的原因时间接提到了它。'
- en: The application shows a canvas on which you can drop boxes and connect them
    together in different ways. The difference from a tool like Visio is that the
    user can program these boxes to change in time, like an animation, to represent
    a process.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序显示一个画布，用户可以在上面放置盒子并以不同的方式将它们连接起来。与Visio这样的工具相比，用户可以编程这些盒子随时间变化，就像动画一样，以表示一个过程。
- en: The user does this by defining Python scripts. The application adds a live Python
    namespace to each user script, so that the user can dynamically query the underlying
    model (such as code completion on properties dynamically changed in the model).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过定义Python脚本来实现这一点。应用程序为每个用户脚本添加了一个实时Python命名空间，因此用户可以动态查询底层模型（例如，在模型中动态更改的属性上的代码补全）。
- en: '**Oliver Schoenborn: ''The application adds a live Python namespace to each
    user script, so that the user can dynamically query the underlying model.''**'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Oliver Schoenborn**：''该应用程序为每个用户脚本添加了一个实时Python命名空间，因此用户可以动态查询底层模型。''**'
- en: So there's a very sophisticated interface for creating model components, adding
    them, and linking them. There is also a very sophisticated undo function that
    covers all the different aspects of model editing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有一个非常复杂的界面用于创建模型组件、添加它们以及将它们链接起来。还有一个非常复杂的撤销功能，涵盖了模型编辑的所有不同方面。
- en: '**Oliver Schoenborn: '' As usual, there was 10% of the feature that occupied
    90% of its dev time.''**'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Oliver Schoenborn: ''就像往常一样，有 10% 的功能占据了 90% 的开发时间。’**'
- en: We coupled the view to the undo/redo so that the user could always see what
    was going to be undone, or redone, as they navigated their document. This was
    an interesting challenge, and as usual, there was 10% of the feature that occupied
    90% of its dev time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将视图与撤销/重做功能耦合，这样用户在导航文档时总能看到将要撤销或重做的内容。这是一个有趣的挑战，就像往常一样，有 10% 的功能占据了 90% 的开发时间。
- en: The application is a simulation system, so it's not just creating lines or boxes.
    There are interface components to manage the simulation, that is, the changing
    of the model in time, restoring it to its initial state, seeing the queue of changes,
    etc.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序是一个模拟系统，所以它不仅仅是创建线条或盒子。还有界面组件来管理模拟，即随时间改变模型，恢复到初始状态，查看更改队列等。
- en: So there is a very large set of functionality in the application. But PyQt has
    been awesome to work with in that respect.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，应用程序中有很多功能。但在这个方面，PyQt 与之合作得非常出色。
- en: '**Driscoll**: Could you explain a little more about using Qt for this project?'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driscoll**: 你能多解释一下在这个项目中使用 Qt 吗？'
- en: '**Schoenborn**: Yes, Qt''s Graphics View has been really impressive in terms
    of what it has allowed us to do.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**Schoenborn**: 是的，Qt 的图形视图在允许我们做的事情方面给人留下了深刻的印象。'
- en: I remember in the beginning, it was not always obvious how to do certain things
    in Qt. For example, in a canvas-based application, where you can do so many different
    things, it's super useful to have a state machine to manage what can be done at
    any given moment. There is no documentation that explains this because it is something
    that you learn over the years as a useful technique. Note that Qt has built-in
    support for state machines, but it wasn't sufficiently powerful for our needs.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得一开始，在 Qt 中做某些事情并不总是那么明显。例如，在一个基于画布的应用程序中，你可以做很多不同的事情，有一个状态机来管理在任何给定时刻可以做什么是非常有用的。没有文档解释这一点，因为这是你多年来作为有用技术学到的东西。请注意，Qt
    内置了对状态机的支持，但它并不足以满足我们的需求。
- en: A state machine allows you to define states in which only certain actions are
    possible. So in the "creating line" state, the only thing you can do is cancel
    creation, drag the mouse, or select the line target. That's where the state machine
    shines. Without it, your code ends up an unmaintainable spaghetti. Troubleshooting
    and extending with new actions is so much simpler.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机允许你定义只有某些动作可能发生的状态。所以在“创建线条”状态下，你唯一能做的就是取消创建、拖动鼠标或选择线条目标。这就是状态机发光的地方。没有它，你的代码最终会变成难以维护的意大利面。调试和扩展新动作要简单得多。
- en: Although the Qt docs are excellent, there are things you figure out as you go.
    Sometimes you say, "Oh yeah, I finally understand how to do this. I'm going to
    backtrack a bit and fix things." You end up with a more robust implementation
    that can really support the next level of features.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Qt 文档很优秀，但有些东西是在使用过程中逐渐理解的。有时你会说，“哦，我终于明白了怎么这么做。我要回过头来修改一下。”最终你得到的是一个更健壮的实现，能够真正支持下一级别的功能。
- en: '**Oliver Schoenborn: ''You end up with a more robust implementation that can
    really have the next level of features.''**'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Oliver Schoenborn: ''你最终得到的是一个更健壮的实现，能够真正支持下一级别的功能。’**'
- en: I'm starting to get kind of familiar with all of the widgets that Qt has. There
    was a nasty bug that we found, when we upgraded PyQt, that caused a whole interface
    to show all sorts of lines as you dragged pieces around. Needless to say, that
    was a problem, but we really needed to update PyQt for other features.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我开始熟悉 Qt 所有的小部件了。当我们升级 PyQt 时，我们发现了一个讨厌的 bug，导致整个界面在拖动部件时显示各种线条。不用说，这确实是个问题，但我们确实需要更新
    PyQt 以支持其他功能。
- en: 'We traced the problem back to the C++ layer and by some incredible stroke of
    luck, there was a workaround: there was one line of code that we just had to put
    in our application at Python level. We didn''t even need to change the PyQt source
    code. As long as we had that one line of code, then the bug would go away. I submitted:
    [https://bugreports.qt.io/browse/QTBUG-55918](https://bugreports.qt.io/browse/QTBUG-55918).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将问题追溯到C++层，并且由于一些不可思议的幸运，有一个解决方案：有一行代码我们只需要在Python级别上放入我们的应用程序中。我们甚至不需要更改PyQt源代码。只要我们有了那一行代码，那么错误就会消失。我提交了：[https://bugreports.qt.io/browse/QTBUG-55918](https://bugreports.qt.io/browse/QTBUG-55918)。
- en: 'Another very interesting aspect of using Qt was unit testing. We needed unit
    tests for the GUI side of the application. We used the excellent pytest, and had
    one test suite for the core business logic, and one for the GUI components. Unit
    testing a GUI can be really challenging: you have to script user actions.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Qt的另一个非常有趣的方面是单元测试。我们需要为应用程序的GUI部分编写单元测试。我们使用了优秀的pytest，有一个用于核心业务逻辑的测试套件，还有一个用于GUI组件的测试套件。对GUI进行单元测试可能真的很有挑战性：你必须编写用户操作的脚本。
- en: Luckily, Qt makes this relatively easy, in that you can easily trigger any widget
    event just by calling a method. But being event based, we needed a way to define
    a bunch of user actions, with the expected outcome. So I created a library to
    support doing this. Unfortunately, source is closed, so I could not share the
    code, but I mentioned the idea on the PyQt forum and some people implemented their
    own concept of it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Qt使得这相对容易，因为你可以通过调用一个方法轻松触发任何小部件事件。但因为是基于事件的，我们需要一种方法来定义一系列用户操作及其预期结果。因此，我创建了一个库来支持这样做。不幸的是，源代码是封闭的，所以我无法分享代码，但我已经在PyQt论坛上提到了这个想法，有些人实现了他们自己的概念。
- en: '**Driscoll**: Python is one of the major languages being used in the AI and
    machine learning boom. What do you think is behind this?'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driscoll**: Python是AI和机器学习热潮中被广泛使用的几种主要语言之一。你认为这背后是什么原因？'
- en: '**Schoenborn**: I would say that it''s the "Olympian" nature of Python that
    makes it good for AI and machine learning. Python happens to be very strong in
    many of the necessary elements, instead of just one or two.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**Schoenborn**: 我认为正是Python的“奥林匹克”特性使其非常适合人工智能和机器学习。Python恰好在很多必要的元素上都非常强大，而不仅仅是某一个或两个。'
- en: '**Oliver Schoenborn: ''It''s the "Olympian" nature of Python that makes it
    good for AI and machine learning.''**'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Oliver Schoenborn: ''Python的“奥林匹克”特性使其非常适合人工智能和机器学习。”**'
- en: 'For example, Python can be used for functional, procedural, or object-oriented
    coding, in any combination, and the code is still understandable and clean. Moreover,
    no compilation needed makes the exploration of algorithms and data so easy: you
    just modify the code and re-run the script.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Python可以用于函数式、过程式或面向对象的编码，可以任意组合，代码仍然易于理解和简洁。此外，不需要编译使得算法和数据探索变得非常容易：你只需修改代码并重新运行脚本。
- en: Finally, Python provides powerful abstractions using a simple syntax. Maybe
    I'm biased, but I think that Python is at the top in this respect. I'm big on
    explicit and clean code, and on refactoring and testing. Being strong at all of
    these things makes Python the perfect language for AI.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Python通过简单的语法提供了强大的抽象。也许我有偏见，但我觉得在这方面Python处于领先地位。我非常重视代码的明确性和简洁性，以及重构和测试。在这些方面都表现出色使得Python成为人工智能的完美语言。
- en: '**Mike Driscoll: What could be done to make Python a better language for AI
    and machine learning?**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mike Driscoll: 为了使Python成为更好的AI和机器学习语言，我们可以做些什么？**'
- en: '**Schoenborn**: A language is most useful, in a given problem domain, when
    the abstractions provided match those of the problem domain.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**Schoenborn**: 在某个问题域中，当提供的抽象与问题域的抽象相匹配时，一种语言最有用。'
- en: So if deep learning uses neural networks, then having a generic concept of a
    neural net could be really useful.. This is currently provided by libraries like
    TensorFlow. But perhaps as machine learning algorithms improve, a generic abstraction
    for a neural net will emerge that can become a basic data structure like lists
    and maps.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果深度学习使用神经网络，那么拥有一个通用的神经网络概念可能非常有用。这目前由像TensorFlow这样的库提供。但随着机器学习算法的改进，可能会出现一个通用的神经网络抽象，它可以成为一个像列表和映射这样的基本数据结构。
- en: Also, I think we need the ability to ask the AI/machine learning functions,
    "How did you get to this result?" That's how humans validate conclusions. They
    are aware of the logic they used, they can verbalise it, another person can follow
    it, and they can verify its correctness.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我认为我们需要能够询问AI/机器学习功能，“你是如何得到这个结果的？”这是人类验证结论的方式。他们了解自己使用的逻辑，可以将其口头表达出来，其他人可以跟随，并验证其正确性。
- en: '**Driscoll**: Many people I have talked to, and even people at PyCon, have
    put a lot of emphasis on Python growing in the data science field. Are you seeing
    that in what you''re doing, or can you give me any kind of opinion one way or
    the other?'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driscoll**：我和很多人交谈过，甚至PyCon上的人，都非常强调Python在数据科学领域的增长。你在你所做的工作中看到这一点了吗，或者你能给我任何一方面的意见吗？'
- en: '**Schoenborn**: Yeah, Python is really growing in that field. Tools like Jupyter,
    Anaconda, and scikit-learn are major reasons for this, in my opinion.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**Schoenborn**：是的，Python在那个领域确实在增长。我认为像Jupyter、Anaconda和scikit-learn这样的工具是这一增长的主要原因。'
- en: Probably in combination with the fact that with large compute power, the speed
    of the language no longer matters so much. Python can be used in embedded systems,
    so in principle some predictive analytics based on trained machine models can
    happen in the devices themselves.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还因为有了强大的计算能力，语言的运行速度不再那么重要。Python可以用于嵌入式系统，所以原则上，基于训练的机器模型的预测分析可以在设备本身发生。
- en: '****Oliver Schoenborn: ''With large compute power, the speed of the** **language
    no longers matters so much.''****'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '****Oliver Schoenborn：''有了强大的计算能力，语言的运行速度不再那么重要。''****'
- en: There was a really interesting presentation at PyCon in 2017\. A presenter was
    surveying the plotting libraries landscape. The survey started with matplotlib
    and everything around that. Then the survey moved on to some of the JavaScript
    libraries, in some cases related to Python libraries. So this was really fascinating,
    because there is a lot of interest, even for my own clients, in using pandas,
    NumPy, and matplotlib. This showed that there are many different extensions or
    layers that you can add.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在2017年的PyCon大会上，有一个非常有趣的演讲。演讲者正在调查绘图库的格局。调查从matplotlib及其相关内容开始。然后调查转向了一些JavaScript库，有些情况下与Python库相关。这真的很吸引人，因为即使对我的客户来说，对使用pandas、NumPy和matplotlib也很有兴趣。这表明你可以添加很多不同的扩展或层。
- en: Speaking from a client perspective, you want a certain amount of capability
    and you don't want to be limited to only matplotlib, because there's so much more
    that's available. You also know that you don't want to be reinventing the wheel,
    so you must make sure that what you build is sufficiently generic. If you want
    to do statistical analysis, then you might want to do it with Jupyter or R. You
    always try to get a sense of the applications that are providing these capabilities.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户的角度来看，你希望有一定程度的可用性，而且你不希望仅限于matplotlib，因为还有更多可用。你也知道，你不想重新发明轮子，所以你必须确保你构建的东西足够通用。如果你想进行统计分析，那么你可能想用Jupyter或R来做。你总是试图了解提供这些功能的应用程序。
- en: You don't want to force the user to use matplotlib, because it is so diverse
    and the API is so advanced. There's no way that you can provide a GUI component
    that supports everything that matplotlib can do.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望强迫用户使用matplotlib，因为它如此多样化，API也如此先进。你无法提供一个支持matplotlib所能做的一切的GUI组件。
- en: Python is such an expressive language and so easy to learn. I think that's why
    Python is so big now in research and applied research. It's easy to apply, sophisticated
    and solves technical problems.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种如此表达性强的语言，而且如此容易学习。我认为这就是Python现在在研究和应用研究中如此受欢迎的原因。它易于应用，复杂且能解决技术问题。
- en: '****Oliver Schoenborn: ''Python is such an expressive language and so** **easy
    to learn. I think that''s why Python is so big now in research and applied research.''****'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '****Oliver Schoenborn：''Python是一种如此表达性强的语言，而且如此容易学习。我认为这就是Python现在在研究和应用研究中如此受欢迎的原因。''****'
- en: Python gives you all of the tools to make and provide something that's robust
    and deterministic. We can measure performance, find bottlenecks or find memory
    leaks. There are so many things that really make Python a great tool.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Python为你提供了所有工具来制作和提供既稳健又确定性的东西。我们可以衡量性能，找到瓶颈或找到内存泄漏。有很多事情真正使Python成为一个伟大的工具。
- en: '**Driscoll**: Have there been any other particularly memorable PyCon presentations?'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driscoll**：有没有其他特别值得记忆的PyCon演讲？'
- en: '**Schoenborn**: There was another interesting PyCon 2017 presentation about
    the Global Interpreter Lock (GIL). In theory, getting rid of the GIL would be
    so great: we could run Python threads on separate cores.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**Schoenborn**: 在2017年的PyCon上，还有一个关于全局解释器锁（GIL）的有趣演讲。从理论上讲，去掉GIL会非常好：我们可以让Python线程在不同的核心上运行。'
- en: '**Oliver Schoenborn: ''In theory, getting rid of the GIL would be so great.''**'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Oliver Schoenborn: ''从理论上讲，去掉GIL会非常好。''**'
- en: 'But the GIL solves a very practical problem: synchronizing access to Python
    data structures. You start digging into the GIL by analyzing what would be necessary,
    and what would be the gain versus the cost. You realize that the GIL really simplifies
    a lot of things and may well be a reason that it''s so easy to do complicated
    things with Python.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但GIL解决了一个非常实际的问题：同步访问Python数据结构。您开始分析什么是必要的，以及与成本相比的收益，从而深入了解GIL。您会意识到GIL确实简化了很多事情，并且可能是Python做复杂事情如此容易的一个原因。
- en: You can basically get concurrent programming, without all the catches of multi-threaded
    programming. Most often in a large class of problems, that's what you want. In
    the other class of problems, you want to tackle trivially parallelizable problems.
    It's basically where you are subdividing the solution into tasks. There's very
    little coupling between the tasks and you can do it very easily.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您基本上可以获取并发编程，而不需要多线程编程的所有陷阱。在大多数问题的大类中，这正是您想要的。在另一类问题中，您想要解决那些可以轻易并行化的简单问题。这基本上是将解决方案细分为任务。任务之间几乎没有耦合，您可以非常容易地完成它们。
- en: Monte Carlo is one example because it's very important in simulation and business
    processes. You basically want to run a large number of things many times, with
    very little variation between them. Python makes that easy too.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡洛是一个例子，因为它在模拟和业务流程中非常重要。您基本上想要多次运行大量的事情，它们之间几乎没有变化。Python也使这一点变得容易。
- en: For trivially parallelizable problems, you need to run those. You can run them
    on separate cores, just using a multiprocessing module. Yes, there's even that
    capability! So many different things that are complex in principle, are simple
    in Python, which makes it so usable for number crunching tasks.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可以轻易并行化的问题，您需要运行它们。您可以在单独的核心上运行它们，只需使用多进程模块。是的，甚至有这种能力！所以，在Python中，许多在原则上复杂的事情实际上很简单，这使得它非常适合数值计算任务。
- en: '**Oliver Schoenborn: ''So many different things that are complex in principle,
    are simple in Python.''**'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Oliver Schoenborn: ''所以，在Python中，许多在原则上复杂的事情实际上很简单。''**'
- en: But I do think that there should be an easier way to run Python code on multiple
    cores without having to use the module. There should be language constructs that
    work hand in hand with the GIL. There is no technical infeasibility there; it's
    just that there has to be enough concerted effort to make it happen.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但我认为应该有一个更简单的方法来在多个核心上运行Python代码，而无需使用该模块。应该有与GIL协同工作的语言结构。那里没有技术上的不可行性；只是需要有足够的共同努力来实现它。
- en: '**Driscoll**: What are you most excited about in Python today?'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driscoll**: 您今天对Python中最兴奋的是什么？'
- en: '**Schoenborn**: The optional type annotation system, asynchronous calls, and
    the multiprocessing module.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**Schoenborn**: 可选类型注解系统、异步调用和多进程模块。'
- en: '**Driscoll**: Which language is Python''s biggest competitor would you say?'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driscoll**: 您认为哪种语言是Python最大的竞争对手？'
- en: '**Schoenborn**: JavaScript. It''s just so unfortunate that JavaScript dominates
    the web side of things. There are these two major contenders: JavaScript on the
    web and Python in technical computing. If you really need the raw compute speed,
    then you can do C++.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**Schoenborn**: JavaScript。真是太不幸了，JavaScript在网页方面占主导地位。有两个主要竞争者：网页上的JavaScript和科技计算中的Python。如果您真的需要原始的计算速度，那么您可以做C++。'
- en: You can get major speedups in Python, by writing some C++ code and ingesting
    it in Python via SWIG and SIP. There is also Cython. It's so easy to work at a
    high level of abstraction with Python, with that compute power when you need it
    from C++.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写一些C++代码并通过SWIG和SIP将其摄入Python，您可以在Python中获得重大的速度提升。还有Cython。使用Python在高级抽象层次上工作非常容易，当您需要从C++获取计算能力时。
- en: I don't know where that's going to go. I think that a lot of things would have
    to happen on the JavaScript side to make it as powerful and as simple to use as
    Python, but on the other hand, I can't see Python becoming a supported language
    in the web browser, because JavaScript is just too established. Maybe if Google
    decides to make Python code runnable from Chrome.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道这会走向何方。我认为在JavaScript方面需要发生很多事情才能使其像Python一样强大且易于使用，但另一方面，我看不到Python成为网络浏览器的支持语言，因为JavaScript已经太根深蒂固了。也许如果谷歌决定让Python代码在Chrome中可运行。
- en: '**Oliver Schoenborn: ''A lot of things would have to happen on the JavaScript
    side to make it as powerful and simple to use as Python.''**'
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**奥利弗·肖恩博恩：''要使JavaScript像Python一样强大且易于使用，需要在JavaScript方面发生很多事情。''**'
- en: '**Driscoll**: So is Python here to stay?'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driscoll**: 那么Python会一直存在吗？'
- en: '**Schoenborn**: I think that Python is here to stay. Python is too good a language
    and its community has developed good quality and solid libraries, and language
    evolution processes via PEPs. There is a very rigorous process for Python and
    a lot of smart people working on it. So it''s here to stay for sure.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**Schoenborn**: 我认为Python会一直存在。Python是一门太好的语言，其社区已经开发出了高质量和稳固的库，以及通过PEPs的语言进化过程。Python有一个非常严格的过程，并且有很多聪明的人在工作。所以它肯定会一直存在。'
- en: '**Driscoll**: What do you think about the long life of Python 2.7? Should people
    move over to the latest version?'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driscoll**: 你对Python 2.7的长期存在有何看法？人们应该迁移到最新版本吗？'
- en: '**Schoenborn**: The long life of Python 2.7 is most irritating! Big influencers,
    like Ubuntu and Google Cloud Platform, must start making Python 3.6 their default.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**Schoenborn**: Python 2.7的长期存在最令人烦恼！像Ubuntu和谷歌云平台这样的大影响力者必须开始将Python 3.6作为默认版本。'
- en: '**Oliver Schoenborn: ''The long life of Python 2.7 is most irritating!''**'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**奥利弗·肖恩博恩：''Python 2.7的长期存在最令人烦恼！''**'
- en: '**Driscoll**: What changes would you like to see in future Python releases?'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driscoll**: 你希望在未来的Python版本中看到哪些变化？'
- en: '**Schoenborn**: I would like to see an optional static typing system with type
    inference (so types do not need declaration), true parallelism, and an optional
    compilation mode.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**Schoenborn**: 我希望看到一种可选的静态类型系统，具有类型推断（因此不需要声明类型），真正的并行性，以及可选的编译模式。'
- en: The combination of optional static typing, compilation, and type inference would
    allow the language to stay simple when starting, and get more rigorous when needed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的静态类型、编译和类型推断的结合将允许语言在开始时保持简单，在需要时变得更加严格。
- en: 'It could also provide massive gains in speed and productivity: it''s always
    a time saver to be able to point to any object and know exactly what operations
    are either available on it, or required of it (within a function signature). Realistically,
    I don''t know if a compilation mode (even JIT) that freezes types is feasible,
    but there are some incredibly smart people out there, so I would not discount
    it.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以在速度和生产率上带来巨大的提升：能够指向任何对象并确切知道对其可用的操作或对其的要求（在函数签名内），这总是节省时间。现实地讲，我不知道一个冻结类型的编译模式（即使是即时编译）是否可行，但外面有一些极其聪明的人，所以我不会排除它。
- en: With regards to parallelism, I'm referring to the ability to run Python code
    on multiple cores simultaneously, while keeping the GIL. Sure, there is the multiprocessing
    module, but I'm talking about constructs built into the language itself as first-class
    citizens.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 关于并行性，我指的是在保持全局解释器锁（GIL）的同时，能够在多个核心上同时运行Python代码的能力。当然，有进程模块，但我谈论的是语言本身内置的一等构造。
- en: '**Driscoll**: Thank you, Oliver Schoenborn.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driscoll**: 感谢，奥利弗·肖恩博恩。'
